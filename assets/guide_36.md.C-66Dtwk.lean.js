import{_ as m,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const A=m(q,[["render",R],["__scopeId","data-v-193bff98"]]),S=JSON.parse(`[{"question":"def find_min_roads_to_remove(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of roads to remove to make all intersections reachable from any other intersection. Args: N (int): The number of intersections. M (int): The number of roads. roads (List[Tuple[int, int]]): List of tuples where each tuple contains two integers representing a road between intersections. Returns: int: The minimum number of roads to remove. Examples: >>> find_min_roads_to_remove(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) 1 >>> find_min_roads_to_remove(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> find_min_roads_to_remove(4, 5, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4)]) 2 >>> find_min_roads_to_remove(3, 3, [(1, 2), (2, 3), (1, 3)]) 1 >>> find_min_roads_to_remove(2, 1, [(1, 2)]) 0 >>> find_min_roads_to_remove(3, 0, []) 0 >>> find_min_roads_to_remove(3, 4, [(1, 1), (2, 2), (3, 3), (1, 2)]) 3","solution":"def find_min_roads_to_remove(N, M, roads): def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): root_x = find_parent(parent, x) root_y = find_parent(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 parent = list(range(N)) rank = [0] * N removed_roads = 0 for u, v in roads: u -= 1 v -= 1 root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) else: removed_roads += 1 return removed_roads"},{"question":"def min_flips_to_no_adjacent_heads(n, coins): Given the number of coins and their initial states, return the minimum number of flips required so that no two adjacent coins show heads. >>> min_flips_to_no_adjacent_heads(5, 'TTTHT') 0 >>> min_flips_to_no_adjacent_heads(6, 'HHHHHH') 3 >>> min_flips_to_no_adjacent_heads(6, 'HTHTHT') 0 >>> min_flips_to_no_adjacent_heads(5, 'HHTTT') 1 >>> min_flips_to_no_adjacent_heads(5, 'TTTHH') 1 >>> min_flips_to_no_adjacent_heads(7, 'HHTHTHH') 2","solution":"def min_flips_to_no_adjacent_heads(n, coins): Given the number of coins and their initial states, return the minimum number of flips required so that no two adjacent coins show heads. flips = 0 for i in range(1, n): if coins[i] == 'H' and coins[i - 1] == 'H': flips += 1 if i % 2 == 1: coins = coins[:i] + 'T' + coins[i + 1:] else: coins = coins[:i - 1] + 'T' + coins[i:] return flips"},{"question":"def count_people_seeing_front(N: int, heights: List[int]) -> int: Determine the number of people who can see the front of the queue. Parameters: N (int): Number of people in the queue. heights (list of int): Heights of the people in the queue. Returns: int: Number of people who can see the front. >>> count_people_seeing_front(5, [140, 150, 130, 160, 140]) 3 >>> count_people_seeing_front(5, [100, 100, 100, 100, 100]) 1 >>> count_people_seeing_front(5, [100, 120, 130, 140, 150]) 5 >>> count_people_seeing_front(5, [150, 140, 130, 120, 110]) 1 >>> count_people_seeing_front(6, [100, 180, 90, 190, 70, 200]) 4 >>> count_people_seeing_front(6, [10, 30, 20, 40, 30, 50]) 4","solution":"def count_people_seeing_front(N, heights): Returns the number of people who can see the front of the queue. Parameters: N (int): Number of people in the queue. heights (list of int): Heights of the people in the queue. Returns: int: Number of people who can see the front. max_height = 0 count = 0 for height in heights: if height > max_height: max_height = height count += 1 return count"},{"question":"def max_happiness(n, l, happiness): Find the maximum possible happiness gain over any contiguous subarray of length L. Args: n (int): The number of attractions. l (int): The number of consecutive attractions the visitor plans to visit. happiness (List[int]): The happiness values of the attractions. Returns: int: The maximum possible happiness gain over any contiguous subarray of length L. Examples: >>> max_happiness(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_happiness(6, 2, [-1, 2, 3, -1, 4, 5]) 9 pass def parse_input(input_str): Parse the input string into the required arguments. Args: input_str (str): Input string. Returns: Tuple[int, int, List[int]]: Parsed values of n, l, and the happiness array. Examples: >>> parse_input(\\"5 3n1 2 3 4 5\\") (5, 3, [1, 2, 3, 4, 5]) >>> parse_input(\\"6 2n-1 2 3 -1 4 5\\") (6, 2, [-1, 2, 3, -1, 4, 5]) pass def main(input_str): Main function to parse input, compute max happiness, and print the result. Args: input_str (str): Input string. Examples: >>> main(\\"5 3n1 2 3 4 5\\") 12 >>> main(\\"6 2n-1 2 3 -1 4 5\\") 9 pass # Unit Tests def test_max_happiness(): assert max_happiness(5, 3, [1, 2, 3, 4, 5]) == 12 assert max_happiness(6, 2, [-1, 2, 3, -1, 4, 5]) == 9 assert max_happiness(1, 1, [1000]) == 1000 assert max_happiness(3, 2, [-1, -2, -3]) == -3 assert max_happiness(6, 3, [1, 2, 1, 2, 1, 2]) == 5 def test_parse_input(): assert parse_input(\\"5 3n1 2 3 4 5\\") == (5, 3, [1, 2, 3, 4, 5]) assert parse_input(\\"6 2n-1 2 3 -1 4 5\\") == (6, 2, [-1, 2, 3, -1, 4, 5]) def test_main(capsys): main(\\"5 3n1 2 3 4 5\\") captured = capsys.readouterr() assert captured.out.strip() == \\"12\\" main(\\"6 2n-1 2 3 -1 4 5\\") captured = capsys.readouterr() assert captured.out.strip() == \\"9\\"","solution":"def max_happiness(n, l, happiness): max_sum = current_sum = sum(happiness[:l]) for i in range(l, n): current_sum += happiness[i] - happiness[i - l] max_sum = max(max_sum, current_sum) return max_sum def parse_input(input_str): lines = input_str.strip().split('n') n, l = map(int, lines[0].split()) happiness = list(map(int, lines[1].split())) return n, l, happiness def main(input_str): n, l, happiness = parse_input(input_str) result = max_happiness(n, l, happiness) print(result)"},{"question":"def max_gift_bags(n, candies): Returns the maximum number of gift bags that can be prepared with the given candies. Each gift bag should have exactly one candy of each type. Parameters: n (int): number of different types of candies candies (list of int): list representing the number of each type of candy Returns: int: maximum number of gift bags >>> max_gift_bags(3, [6, 3, 9]) 3 >>> max_gift_bags(3, [0, 0, 0]) 0 >>> max_gift_bags(4, [5, 5, 5, 5]) 5 >>> max_gift_bags(3, [7, 0, 5]) 0 >>> max_gift_bags(3, [10000, 9999, 10000]) 9999 >>> max_gift_bags(1, [10]) 10","solution":"def max_gift_bags(n, candies): Returns the maximum number of gift bags that can be prepared with the given candies. Each gift bag should have exactly one candy of each type. Parameters: n (int): number of different types of candies candies (list of int): list representing the number of each type of candy Returns: int: maximum number of gift bags return min(candies)"},{"question":"from typing import List, Tuple def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left to the bottom-right of a grid with obstacles. pass # Implement the function here def maze_navigation(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determines the number of unique paths the robot can take to reach the bottom-right corner without hitting any obstacles for each test case. >>> maze_navigation(2, [(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]), (2, 2, [[0, 1], [0, 0]])]) [2, 1] >>> maze_navigation(1, [(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]])]) [6] >>> maze_navigation(1, [(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]])]) [0] >>> maze_navigation(2, [(3, 3, [[1, 0, 0], [0, 0, 0], [0, 0, 0]]), (3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 1]])]) [0, 0] >>> maze_navigation(1, [(4, 4, [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]])]) [4] pass # Implement the function here","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of a grid with obstacles. M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return 0 dp = [[0] * N for _ in range(M)] dp[0][0] = 1 # Fill the first column for i in range(1, M): dp[i][0] = dp[i-1][0] * (1 - grid[i][0]) # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j-1] * (1 - grid[0][j]) # Fill the rest of the dp array for i in range(1, M): for j in range(1, N): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[M-1][N-1] def maze_navigation(T, test_cases): results = [] for case in test_cases: M, N, grid = case results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"def min_flips_to_open_boxes(n: int, boxes_state: str) -> int: Determine the minimum number of flip operations needed to make all the boxes open. :param n: int, number of boxes :param boxes_state: str, string of length n consisting of '0' and '1' representing the state of each box :return: int, minimum number of flips, or -1 if it is impossible >>> min_flips_to_open_boxes(5, \\"11111\\") 0 >>> min_flips_to_open_boxes(4, \\"0000\\") 1 >>> min_flips_to_open_boxes(6, \\"100011\\") 3 >>> min_flips_to_open_boxes(1, \\"0\\") 1 >>> min_flips_to_open_boxes(1, \\"1\\") 0 >>> min_flips_to_open_boxes(5, \\"01010\\") 5 >>> min_flips_to_open_boxes(5, \\"10101\\") 5","solution":"def min_flips_to_open_boxes(n, boxes_state): Determine the minimum number of flip operations needed to make all the boxes open. :param n: int, number of boxes :param boxes_state: str, string of length n consisting of '0' and '1' representing the state of each box :return: int, minimum number of flips, or -1 if it is impossible if '0' not in boxes_state: return 0 flip_count = 0 current_state = boxes_state[0] for i in range(1, n): if boxes_state[i] != current_state: flip_count += 1 current_state = boxes_state[i] return flip_count + 1"},{"question":"from typing import List def minimize_total_risk(n: int, m: int, risk_factors: List[int]) -> int: Returns the minimum total risk factor for administering exactly m doses. :param n: Number of patients :param m: Number of doses of the vaccine :param risk_factors: List of risk factors for each patient :return: Minimum total risk factor >>> minimize_total_risk(5, 3, [3, 1, 2, 5, 4]) 6 >>> minimize_total_risk(6, 2, [6, 9, 2, 4, 8, 7]) 6 >>> minimize_total_risk(1, 1, [7]) 7 >>> minimize_total_risk(4, 4, [10, 20, 5, 15]) 50 >>> minimize_total_risk(4, 2, [10, 20, 5, 15]) 15 >>> minimize_total_risk(3, 2, [1000, 2000, 3000]) 3000","solution":"def minimize_total_risk(n, m, risk_factors): Returns the minimum total risk factor for administering exactly m doses. :param n: Number of patients :param m: Number of doses of the vaccine :param risk_factors: List of risk factors for each patient :return: Minimum total risk factor # Sort the risk factors in ascending order to minimize the total risk sorted_risks = sorted(risk_factors) # Sum the first m elements (smallest risks) return sum(sorted_risks[:m])"},{"question":"def can_spacecraft_reach_destination(n, m, f, grid): Determine whether the spacecraft can reach the destination cell (n-1, m-1) from the starting cell (0,0) without exceeding the fuel limit. Args: n (int): number of rows m (int): number of columns f (int): maximum number of cells the spacecraft can visit grid (List[str]): grid representation with '.' indicating a free cell and '#' indicating an obstacle Returns: str: \\"YES\\" if the spacecraft can reach the destination within the given fuel limit, \\"NO\\" otherwise. >>> can_spacecraft_reach_destination(3, 3, 5, [\\"...\\", \\".#.\\", \\"...\\"]) \\"YES\\" >>> can_spacecraft_reach_destination(3, 3, 4, [\\"...\\", \\".#.\\", \\"...\\"]) \\"NO\\" >>> can_spacecraft_reach_destination(4, 4, 7, [\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"]) \\"YES\\" # Unit Tests def test_example1(): n, m, f = 3, 3, 5 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"YES\\" def test_example2(): n, m, f = 3, 3, 4 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"NO\\" def test_example3(): n, m, f = 4, 4, 7 grid = [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"YES\\" def test_minimum_input(): n, m, f = 1, 1, 1 grid = [\\".\\"] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"YES\\" def test_obstacle_blocking_path(): n, m, f = 2, 2, 4 grid = [ \\".#\\", \\"#.\\" ] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"NO\\" def test_exact_fuel(): n, m, f = 2, 2, 3 grid = [ \\"..\\", \\"..\\" ] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"YES\\" def test_not_enough_fuel(): n, m, f = 3, 3, 2 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert can_spacecraft_reach_destination(n, m, f, grid) == \\"NO\\"","solution":"def can_spacecraft_reach_destination(n, m, f, grid): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, cells visited) visited = set((0, 0)) while queue: x, y, cells_visited = queue.popleft() if cells_visited > f: continue if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, cells_visited + 1)) return \\"NO\\""},{"question":"def findDuplicates(s: str) -> List[str]: Given a string \`str\`, find all the duplicate characters in the string and return them as a list. Duplicates should be listed in the order they first appear in the string. >>> findDuplicates(\\"programming\\") ['r', 'g', 'm'] >>> findDuplicates(\\"computer\\") [] >>> findDuplicates(\\"mississippi\\") ['i', 's', 'p'] >>> findDuplicates(\\"aabbcdeeffgghh\\") ['a', 'b', 'e', 'f', 'g', 'h'] pass # Testing from solution import findDuplicates def test_example_1(): assert findDuplicates(\\"programming\\") == ['r', 'g', 'm'] def test_example_2(): assert findDuplicates(\\"computer\\") == [] def test_single_character(): assert findDuplicates(\\"a\\") == [] def test_all_duplicates(): assert findDuplicates(\\"aabbccdd\\") == ['a', 'b', 'c', 'd'] def test_no_duplicates(): assert findDuplicates(\\"abcdef\\") == [] def test_mixed_duplicates(): assert findDuplicates(\\"aabbcdeeffgghh\\") == ['a', 'b', 'e', 'f', 'g', 'h'] def test_complex_string(): assert findDuplicates(\\"mississippi\\") == ['i', 's', 'p'] def test_sparse_duplicates(): assert findDuplicates(\\"abacabad\\") == ['a', 'b']","solution":"def findDuplicates(s): Returns a list of duplicate characters in the string in the order they first appear. from collections import defaultdict count = defaultdict(int) result = [] for char in s: count[char] += 1 for char in s: if count[char] > 1 and char not in result: result.append(char) return result"},{"question":"from typing import List, Tuple def villagers_helped(n: int, m: int, d: int, sorcerers: List[Tuple[int, int]], villagers: List[Tuple[int, int]]) -> int: Given the coordinates of sorcerers and villagers, determine how many villagers can be helped. A sorcerer can only help villagers who live within a certain Euclidean distance d from their own house. Each sorcerer can help at most one villager, while each villager can be helped by at most one sorcerer. >>> villagers_helped(3, 4, 5, [(1, 1), (2, 2), (3, 3)], [(0, 0), (4, 4), (1, 3), (3, 1)]) 3 >>> villagers_helped(2, 3, 10, [(-5, 0), (5, 0)], [(0, 5), (4, 3), (-4, -3)]) 2 >>> villagers_helped(0, 3, 5, [], [(0, 0), (1, 1), (2, 2)]) 0 >>> villagers_helped(3, 0, 5, [(0, 0), (1, 1), (2, 2)], []) 0 >>> villagers_helped(2, 2, 1000000000, [(0, 0), (0, 0)], [(1, 1), (2, 2)]) 2 >>> villagers_helped(2, 2, 1, [(0, 0), (1, 1)], [(2, 2), (3, 3)]) 0","solution":"import math def villagers_helped(n, m, d, sorcerers, villagers): helped_villagers = 0 sorcerers_available = [True] * n for v_x, v_y in villagers: for i in range(n): if sorcerers_available[i]: s_x, s_y = sorcerers[i] distance = math.sqrt((s_x - v_x) ** 2 + (s_y - v_y) ** 2) if distance <= d: helped_villagers += 1 sorcerers_available[i] = False break return helped_villagers"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. The sequence starts with 0 and 1. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 previous, current = 0, 1 for _ in range(2, n + 1): previous, current = current, previous + current return current"},{"question":"def sum_of_squares(lst): Returns the sum of the squares of each number in the list. Parameters: lst (list): A list of integers. Returns: int: The sum of the squares of the integers. >>> sum_of_squares([1, 2, 3, 4]) 30 >>> sum_of_squares([0, 1, 2, 3]) 14 >>> sum_of_squares([-1, -2, -3, -4]) 30 >>> sum_of_squares([-1, 2, -3, 4]) 30 >>> sum_of_squares([]) 0 >>> sum_of_squares([5]) 25","solution":"def sum_of_squares(lst): Returns the sum of the squares of each number in the list. Parameters: lst (list): A list of integers. Returns: int: The sum of the squares of the integers. return sum(x**2 for x in lst)"},{"question":"def sum_of_two_primes(N: int): Given a positive integer N, determine whether it can be expressed as the sum of two prime numbers. If it can, return the two prime numbers in sorted order as a tuple. If multiple pairs exist, return any one of them. If it cannot be expressed as such, return -1. >>> sum_of_two_primes(10) (3, 7) >>> sum_of_two_primes(16) (3, 13) or (5, 11) >>> sum_of_two_primes(11) -1","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_two_primes(N): for i in range(2, N): if is_prime(i) and is_prime(N - i): return (i, N - i) return -1"},{"question":"def can_rabbits_meet(R, C, garden, r1, c1, r2, c2): Two rabbits live in a garden laid out as a rectangular grid of cells with R rows and C columns. Each cell can be either empty or contain an obstacle. The rabbits can move up, down, left, or right, but cannot move into a cell containing an obstacle, nor can they move outside the grid. You are given the positions of both rabbits and their goal is to meet each other on the same cell. Write a function to determine if it is possible for the two rabbits to meet. Args: R (int): Number of rows in the garden. C (int): Number of columns in the garden. garden (List[str]): List of strings representing the garden layout. r1 (int): Starting row of the first rabbit. c1 (int): Starting column of the first rabbit. r2 (int): Starting row of the second rabbit. c2 (int): Starting column of the second rabbit. Returns: str: \\"YES\\" if it is possible for the two rabbits to meet, otherwise \\"NO\\". Example: >>> can_rabbits_meet(4, 4, [\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"], 1, 1, 4, 4) 'YES' >>> can_rabbits_meet(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"], 1, 1, 3, 3) 'NO'","solution":"def can_rabbits_meet(R, C, garden, r1, c1, r2, c2): from collections import deque def is_valid_move(r, c): return 0 <= r < R and 0 <= c < C and garden[r][c] == '.' def bfs(start): queue = deque([start]) visited = set([start]) while queue: r, c = queue.popleft() for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if is_valid_move(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) return visited start1 = (r1 - 1, c1 - 1) start2 = (r2 - 1, c2 - 1) reach1 = bfs(start1) reach2 = bfs(start2) return \\"YES\\" if reach1 & reach2 else \\"NO\\""},{"question":"import math from typing import List, Tuple def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(21) == False >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(5) == True def primes_in_range(a: int, b: int) -> List[int]: Returns a list of all prime numbers in the range [a, b] (both inclusive). >>> primes_in_range(10, 20) == [11, 13, 17, 19] >>> primes_in_range(4, 6) == [5] >>> primes_in_range(0, 10) == [2, 3, 5, 7] >>> primes_in_range(20, 25) == [23] >>> primes_in_range(0, 1) == [] >>> primes_in_range(14, 16) == [] def find_primes_in_multiple_ranges(test_cases: List[Tuple[int, int]]) -> List[List[int]]: Accepts list of tuples where each tuple contains two integers a and b. Returns a list of lists where each list contains the prime numbers in the range [a, b] for each tuple (a, b) in the input list. >>> find_primes_in_multiple_ranges([(10, 20), (4, 6)]) == [[11, 13, 17, 19], [5]] >>> find_primes_in_multiple_ranges([(0, 10), (20, 25)]) == [[2, 3, 5, 7], [23]] >>> find_primes_in_multiple_ranges([(0, 1)]) == [[]] >>> find_primes_in_multiple_ranges([(14, 16)]) == [[]] >>> find_primes_in_multiple_ranges([(1, 1), (1, 10)]) == [[], [2, 3, 5, 7]]","solution":"import math def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def primes_in_range(a, b): Returns a list of all prime numbers in the range [a, b] (both inclusive). return [x for x in range(a, b + 1) if is_prime(x)] def find_primes_in_multiple_ranges(test_cases): Accepts list of tuples where each tuple contains two integers a and b Returns a list of lists where each list contains the prime numbers in the range [a, b] for each tuple (a, b) in the input list. results = [] for a, b in test_cases: results.append(primes_in_range(a, b)) return results"},{"question":"def submatrixSum(matrix, x1, y1, x2, y2): Calculate the sum of elements in the submatrix defined by the coordinates (x1, y1) and (x2, y2). Args: matrix (list of list of int): 2D matrix of integers. x1 (int): Row index of the top-left corner of the submatrix. y1 (int): Column index of the top-left corner of the submatrix. x2 (int): Row index of the bottom-right corner of the submatrix. y2 (int): Column index of the bottom-right corner of the submatrix. Returns: int: The sum of elements in the specified submatrix. Examples: >>> submatrixSum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 1, 1, 2, 2) 28 >>> submatrixSum([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120] ], 0, 1, 2, 2) 390","solution":"def submatrixSum(matrix, x1, y1, x2, y2): Calculate the sum of elements in the submatrix defined by the coordinates (x1, y1) and (x2, y2). Args: matrix (list of list of int): 2D matrix of integers. x1 (int): Row index of the top-left corner of the submatrix. y1 (int): Column index of the top-left corner of the submatrix. x2 (int): Row index of the bottom-right corner of the submatrix. y2 (int): Column index of the bottom-right corner of the submatrix. Returns: int: The sum of elements in the specified submatrix. total_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total_sum += matrix[i][j] return total_sum"},{"question":"def longest_increasing_subsequence_length(arr): Returns the length of the longest increasing subsequence in the given array. Args: arr (List[int]): a list of integers representing the sequence. Returns: int: the length of the longest increasing subsequence. Examples: >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([5]) 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([10, 9, 2, 5, 3, 7]) 3 >>> longest_increasing_subsequence_length([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence_length([3, 2]) 1 >>> longest_increasing_subsequence_length([50, 3, 10, 7, 40, 80]) 4","solution":"def longest_increasing_subsequence_length(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def distinct_characters_in_substrings(s: str, queries: List[List[int]]) -> List[int]: Given a string \`s\` and an array of queries where each query consists of two integers \`[l, r]\`, find the number of distinct characters in the substring \`s[l:r+1]\`. >>> distinct_characters_in_substrings(\\"abacaba\\", [[0, 3], [1, 2], [2, 5], [0, 6]]) [3, 2, 3, 3] >>> distinct_characters_in_substrings(\\"aaabbbcc\\", [[0, 2], [3, 5], [6, 7]]) [1, 1, 1] >>> distinct_characters_in_substrings(\\"abcd\\", [[0, 0], [0, 1], [0, 2], [0, 3]]) [1, 2, 3, 4] >>> distinct_characters_in_substrings(\\"xyzxyz\\", [[0, 5], [1, 4], [2, 3]]) [3, 3, 2] >>> distinct_characters_in_substrings(\\"a\\", [[0, 0]]) [1]","solution":"def distinct_characters_in_substrings(s, queries): result = [] for l, r in queries: substring = s[l:r+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"def final_grid_state(N: int, M: int, K: int, initial_grid: List[List[int]], repaint_operations: List[Tuple[int, int, int]]) -> List[List[int]]: Determine the final grid representation of an ArtBlock after a series of repaint operations. Given the initial state of the grid and a list of repaint operations, compute the final state of the grid. >>> final_grid_state(3, 3, 4, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [(0, 1, 1), (2, 2, 1), (0, 1, 0), (1, 1, 1)]) [[0, 1, 0], [0, 1, 0], [0, 0, 1]] >>> final_grid_state(2, 2, 2, [[0, 1], [1, 0]], [(0, 0, 0), (1, 1, 0)]) [[0, 1], [1, 0]]","solution":"def final_grid_state(N, M, K, initial_grid, repaint_operations): for r, c, v in repaint_operations: if v == 1: initial_grid[r][c] = 1 # If v is 0, we don't need to do anything as per the rules. return initial_grid # Example Input N = 3 M = 3 K = 4 initial_grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] repaint_operations = [ (0, 1, 1), (2, 2, 1), (0, 1, 0), (1, 1, 1) ] # Example Output final_state = final_grid_state(N, M, K, initial_grid, repaint_operations) for row in final_state: print(' '.join(map(str, row)))"},{"question":"def categorize_movies_by_genre(movies): Takes a list of movie dictionaries and returns a dictionary categorizing movies by genre, with the titles sorted by their rating in descending order. Args: movies (list): A list of dictionaries where each dictionary contains 'title', 'genre', and 'rating' keys. Returns: dict: A dictionary where keys are genres and values are lists of movie titles sorted by rating. Example: >>> movies = [ ... {'title': 'Movie A', 'genre': 'Action', 'rating': 8.5}, ... {'title': 'Movie B', 'genre': 'Horror', 'rating': 7.2}, ... {'title': 'Movie C', 'genre': 'Action', 'rating': 9.1}, ... {'title': 'Movie D', 'genre': 'Horror', 'rating': 8.0} ... ] >>> categorize_movies_by_genre(movies) {'Action': ['Movie C', 'Movie A'], 'Horror': ['Movie D', 'Movie B']}","solution":"def categorize_movies_by_genre(movies): Takes a list of movie dictionaries and returns a dictionary categorizing movies by genre, with the titles sorted by their rating in descending order. genre_dict = {} for movie in movies: title = movie['title'] genre = movie['genre'] rating = movie['rating'] if genre not in genre_dict: genre_dict[genre] = [] genre_dict[genre].append((rating, title)) for genre in genre_dict: genre_dict[genre].sort(reverse=True, key=lambda x: x[0]) genre_dict[genre] = [title for rating, title in genre_dict[genre]] return genre_dict"},{"question":"from typing import List def shortestPathBinaryMatrix(grid: List[List[int]]) -> int: Find the length of the shortest path from the top-left corner to the bottom-right corner in a binary matrix grid. The path can only move up, down, left, or right to another open cell. >>> grid1 = [[0, 1], [1, 0]] >>> shortestPathBinaryMatrix(grid1) 2 >>> grid2 = [[0, 0, 0], [1, 1, 0], [1, 1, 0]] >>> shortestPathBinaryMatrix(grid2) 4 >>> grid3 = [[1, 0, 0], [1, 1, 0], [1, 1, 0]] >>> shortestPathBinaryMatrix(grid3) -1 import pytest from solution import shortestPathBinaryMatrix def test_shortest_path_example1(): grid = [[0, 1], [1, 0]] assert shortestPathBinaryMatrix(grid) == 2 def test_shortest_path_example2(): grid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]] assert shortestPathBinaryMatrix(grid) == 4 def test_shortest_path_example3(): grid = [[1, 0, 0], [1, 1, 0], [1, 1, 0]] assert shortestPathBinaryMatrix(grid) == -1 def test_no_path(): grid = [[0, 1, 1], [1, 1, 0], [1, 1, 0]] assert shortestPathBinaryMatrix(grid) == -1 def test_single_cell_path(): grid = [[0]] assert shortestPathBinaryMatrix(grid) == 1 def test_all_zeros(): grid = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]] assert shortestPathBinaryMatrix(grid) == 4 def test_all_ones(): grid = [[0,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,0]] assert shortestPathBinaryMatrix(grid) == -1","solution":"from collections import deque from typing import List def shortestPathBinaryMatrix(grid: List[List[int]]) -> int: n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] queue = deque([(0, 0, 1)]) grid[0][0] = 1 while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) grid[nx][ny] = 1 return -1"},{"question":"def reverse_words_order(s: str) -> str: Reverses the order of words in a given string while keeping the characters in each word in the same order. >>> reverse_words_order(\\"this is a test\\") \\"test a is this\\" >>> reverse_words_order(\\"hello world\\") \\"world hello\\" >>> reverse_words_order(\\"python\\") \\"python\\" >>> reverse_words_order(\\"The Quick Brown Fox\\") \\"Fox Brown Quick The\\" >>> reverse_words_order(\\"\\") \\"\\" >>> reverse_words_order(\\"hello world\\") \\"world hello\\"","solution":"def reverse_words_order(s): Reverses the order of words in a given string while keeping the characters in each word in the same order. words = s.split(' ') reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to transform the string into a palindrome. >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"aa\\") 0 >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"aabb\\") 2 pass def solve(T: int, test_cases: List[str]) -> List[int]: Returns a list of results for each test case. >>> solve(4, [\\"ab\\", \\"aa\\", \\"racecar\\", \\"aabb\\"]) [1, 0, 0, 2] >>> solve(3, [\\"abc\\", \\"abba\\", \\"abcd\\"]) [1, 0, 2] >>> solve(2, [\\"madam\\", \\"refer\\"]) [0, 0] pass","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform the string into a palindrome. n = len(s) mismatches = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatches += 1 return mismatches def solve(T, test_cases): results = [] for i in range(T): results.append(min_operations_to_palindrome(test_cases[i])) return results"},{"question":"def interpret_instructions(inputs): Function that simulates a simple programming language's variable assignment and output behavior. Args: inputs (List[str]): List of instructions to be processed. Returns: List[int]: List of outputs for each PRINT instruction. Example: >>> interpret_instructions([ ... \\"SET A 10\\", ... \\"SET B 20\\", ... \\"ADD C A B\\", ... \\"PRINT C\\", ... \\"MUL D B C\\", ... \\"PRINT D\\", ... \\"SUB E D C\\", ... \\"PRINT E\\", ... \\"DIV F D B\\", ... \\"PRINT F\\", ... \\"END\\" ... ]) [30, 600, 570, 30] pass def test_interpret_instructions_example_case(): inputs = [ \\"SET A 10\\", \\"SET B 20\\", \\"ADD C A B\\", \\"PRINT C\\", \\"MUL D B C\\", \\"PRINT D\\", \\"SUB E D C\\", \\"PRINT E\\", \\"DIV F D B\\", \\"PRINT F\\", \\"END\\" ] assert interpret_instructions(inputs) == [30, 600, 570, 30] def test_interpret_instructions_all_operations(): inputs = [ \\"SET X 5\\", \\"SET Y 3\\", \\"ADD Z X Y\\", \\"PRINT Z\\", # 5 + 3 = 8 \\"SUB W X Y\\", \\"PRINT W\\", # 5 - 3 = 2 \\"MUL V X Y\\", \\"PRINT V\\", # 5 * 3 = 15 \\"DIV U X Y\\", \\"PRINT U\\", # 5 // 3 = 1 (integer division) \\"END\\" ] assert interpret_instructions(inputs) == [8, 2, 15, 1] def test_interpret_instructions_unset_variable(): inputs = [ \\"PRINT A\\", # A is unset, should be 0 \\"SET A 10\\", \\"PRINT A\\", \\"END\\" ] assert interpret_instructions(inputs) == [0, 10] def test_interpret_instructions_no_operations(): inputs = [ \\"END\\" ] assert interpret_instructions(inputs) == [] def test_interpret_instructions_complex_operations(): inputs = [ \\"SET A 1\\", \\"SET B 2\\", \\"SET C 3\\", \\"MUL D A B\\", # D = 1 * 2 = 2 \\"ADD E D C\\", # E = 2 + 3 = 5 \\"SUB F E A\\", # F = 5 - 1 = 4 \\"DIV G F B\\", # G = 4 // 2 = 2 \\"PRINT G\\", \\"END\\" ] assert interpret_instructions(inputs) == [2]","solution":"def interpret_instructions(inputs): variables = {chr(i): 0 for i in range(65, 91)} # Initialize A-Z variables to 0 outputs = [] for line in inputs: parts = line.split() command = parts[0] if command == 'SET': var = parts[1] value = int(parts[2]) variables[var] = value elif command == 'ADD': result_var = parts[1] var1 = parts[2] var2 = parts[3] variables[result_var] = variables[var1] + variables[var2] elif command == 'SUB': result_var = parts[1] var1 = parts[2] var2 = parts[3] variables[result_var] = variables[var1] - variables[var2] elif command == 'MUL': result_var = parts[1] var1 = parts[2] var2 = parts[3] variables[result_var] = variables[var1] * variables[var2] elif command == 'DIV': result_var = parts[1] var1 = parts[2] var2 = parts[3] variables[result_var] = variables[var1] // variables[var2] elif command == 'PRINT': var = parts[1] outputs.append(variables[var]) elif command == 'END': break return outputs"},{"question":"def count_word_occurrences(text: str) -> List[Tuple[str, int]]: Counts the occurrences of each word in a given text message. Parameters: text (str): A single line containing the text message. Returns: List[Tuple[str, int]]: A list of tuples, where each tuple contains a word and its frequency of occurrence. Examples: >>> count_word_occurrences(\\"hello world hello everyone\\") [(\\"hello\\", 2), (\\"world\\", 1), (\\"everyone\\", 1)] >>> count_word_occurrences(\\"this is a test this is only a test\\") [(\\"this\\", 2), (\\"is\\", 2), (\\"a\\", 2), (\\"test\\", 2), (\\"only\\", 1)]","solution":"def count_word_occurrences(text): Counts the occurrences of each word in a given text message. words = text.lower().strip().split() word_count = {} word_order = [] for word in words: if word not in word_count: word_order.append(word) word_count[word] = 1 else: word_count[word] += 1 result = [(word, word_count[word]) for word in word_order] return result"},{"question":"def countSunsetBuildings(heights: List[int]) -> int: Returns the count of buildings that can see the sunset. >>> countSunsetBuildings([7, 4, 8, 2, 9]) == 3 >>> countSunsetBuildings([5, 3, 8, 3, 2]) == 2 >>> countSunsetBuildings([1, 2, 3, 4, 5]) == 5 >>> countSunsetBuildings([5, 4, 3, 2, 1]) == 1 >>> countSunsetBuildings([10, 10, 10]) == 1 >>> countSunsetBuildings([4, 3, 2, 1, 5]) == 2 >>> countSunsetBuildings([4, 5, 3, 2, 6, 1]) == 3 >>> countSunsetBuildings([]) == 0","solution":"def countSunsetBuildings(heights): Returns the count of buildings that can see the sunset. if not heights: return 0 count = 0 max_height = float('-inf') for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def update_leaderboard(race_positions: List[int], k: int) -> List[int]: Generates a leaderboard showing the top k runners based on their current positions. :param race_positions: List of integers where index represents the runner's ID and the value represents their current position. :param k: Number of top positions to display on the leaderboard. :return: A list of runner IDs representing the top k runners, in the order of their positions. >>> update_leaderboard([5, 3, 1, 4, 2], 3) [2, 4, 1] >>> update_leaderboard([6, 2, 8, 3, 1, 5, 7, 4], 5) [4, 1, 3, 7, 5]","solution":"from typing import List def update_leaderboard(race_positions: List[int], k: int) -> List[int]: Generates a leaderboard showing the top k runners based on their current positions. :param race_positions: List of integers where index represents the runner's ID and the value represents their current position. :param k: Number of top positions to display on the leaderboard. :return: A list of runner IDs representing the top k runners, in the order of their positions. # Create a list of tuples (runner_id, position) and sort by position sorted_positions = sorted(enumerate(race_positions), key=lambda x: x[1]) # Extract the runner IDs of the top k positions leaderboard = [runner_id for runner_id, position in sorted_positions[:k]] return leaderboard"},{"question":"def process_operations(N, M, inventory, operations): Process a series of update and query operations on an inventory log. Args: N (int): Number of products. M (int): Number of operations. inventory (List[int]): Initial quantities of the products. operations (List[Tuple[str, int, int]]): List of operations to be performed. Each operation is either: - 'U(i, v)' : Update the quantity of the product with ID 'i' to 'v'. - 'Q(l, r)' : Query the total quantity of products with IDs between 'l' and 'r'. Returns: List[int]: Results for all query operations. >>> N, M = 5, 6 >>> inventory = [10, 20, 30, 40, 50] >>> operations = [('Q', 1, 3), ('U', 2, 25), ('Q', 2, 4), ('U', 4, 10), ('Q', 0, 4), ('Q', 3, 4)] >>> process_operations(N, M, inventory, operations) [90, 115, 105, 50]","solution":"def process_operations(N, M, inventory, operations): results = [] for operation in operations: if operation[0] == 'U': i, v = operation[1], operation[2] inventory[i] = v elif operation[0] == 'Q': l, r = operation[1], operation[2] results.append(sum(inventory[l:r+1])) return results"},{"question":"def longest_increasing_subsequence_length(n: int, sequence: List[int]) -> int: Finds the length of the longest strictly increasing subsequence. >>> longest_increasing_subsequence_length(5, [1, 2, 1, 5, 3]) 3 >>> longest_increasing_subsequence_length(4, [9, 4, 7, 2]) 2 >>> longest_increasing_subsequence_length(6, [2, 2, 2, 2, 2, 2]) 1 pass def process_input(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases. >>> process_input(3, [(5, [1, 2, 1, 5, 3]), (4, [9, 4, 7, 2]), (6, [2, 2, 2, 2, 2, 2])]) [3, 2, 1] pass if __name__ == \\"__main__\\": def test_longest_increasing_subsequence_length(): assert longest_increasing_subsequence_length(5, [1, 2, 1, 5, 3]) == 3, \\"Test case 1 failed\\" assert longest_increasing_subsequence_length(4, [9, 4, 7, 2]) == 2, \\"Test case 2 failed\\" assert longest_increasing_subsequence_length(6, [2, 2, 2, 2, 2, 2]) == 1, \\"Test case 3 failed\\" assert longest_increasing_subsequence_length(7, [10, 20, 10, 30, 40, 50, 60]) == 6, \\"Test case 4 failed\\" assert longest_increasing_subsequence_length(3, [3, 1, 2]) == 2, \\"Test case 5 failed\\" assert longest_increasing_subsequence_length(0, []) == 0, \\"Test case 6 failed\\" assert longest_increasing_subsequence_length(1, [1]) == 1, \\"Test case 7 failed\\" def test_process_input(): T = 3 test_cases = [ (5, [1, 2, 1, 5, 3]), (4, [9, 4, 7, 2]), (6, [2, 2, 2, 2, 2, 2]) ] assert process_input(T, test_cases) == [3, 2, 1], \\"Process Input test case failed\\" test_longest_increasing_subsequence_length() test_process_input() print(\\"All tests passed.\\")","solution":"def longest_increasing_subsequence_length(n, sequence): Finds the length of the longest strictly increasing subsequence. if n == 0: return 0 # Initialize an array to store the smallest ending value for increasing subsequence of length i+1 dp = [] for num in sequence: pos = binary_search(dp, num) if pos == len(dp): dp.append(num) else: dp[pos] = num return len(dp) def binary_search(dp, num): Helper function to perform binary search on the dp array. left, right = 0, len(dp) while left < right: mid = (left + right) // 2 if dp[mid] < num: left = mid + 1 else: right = mid return left def process_input(T, test_cases): Processes multiple test cases. results = [] for i in range(T): n = test_cases[i][0] sequence = test_cases[i][1] results.append(longest_increasing_subsequence_length(n, sequence)) return results"},{"question":"def does_subarray_with_sum_exist(n: int, q: int, A: List[int], queries: List[int]) -> List[str]: Checks if there exists a contiguous subarray within the array that has an exact sum equal to specified values. >>> does_subarray_with_sum_exist(5, 3, [1, 2, 3, 4, 5], [9, 15, 20]) ['YES', 'YES', 'NO'] >>> does_subarray_with_sum_exist(5, 2, [1, 2, 3, 4, 5], [4, -4]) ['YES', 'NO'] >>> does_subarray_with_sum_exist(5, 1, [1, 2, 3, 4, 5], [20]) ['NO'] >>> does_subarray_with_sum_exist(5, 1, [1, 2, 3, 4, 5], [15]) ['YES'] >>> does_subarray_with_sum_exist(6, 2, [1, -1, 2, -2, 3, -3], [0, -6]) ['YES', 'NO'] >>> does_subarray_with_sum_exist(5, 2, [0, 0, 0, 0, 0], [0, 5]) ['YES', 'NO']","solution":"def does_subarray_with_sum_exist(n, q, A, queries): results = [] # Using a set to track the cumulative sums we've seen so far. for k in queries: cumulative_sum = 0 seen_sums = set([0]) found = False for number in A: cumulative_sum += number if (cumulative_sum - k) in seen_sums: results.append(\\"YES\\") found = True break seen_sums.add(cumulative_sum) if not found: results.append(\\"NO\\") return results"},{"question":"def distinct_identifiers(n: int, crystals: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Returns the number of distinct crystal identifiers for each subarray defined by the queries. Parameters: n (int): Number of crystals. crystals (List[int]): Identifiers of the crystals. q (int): Number of queries. queries (List[Tuple[int, int]]): The bounds of the subarrays. Returns: List[int]: Number of distinct identifiers in each subarray for the given queries. >>> distinct_identifiers(5, [1, 2, 1, 3, 2], 3, [(1, 3), (2, 4), (1, 5)]) [2, 3, 3] >>> distinct_identifiers(7, [1, 1, 2, 5, 3, 3, 2], 2, [(3, 6), (1, 7)]) [3, 4] from typing import List, Tuple if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def distinct_identifiers(n, crystals, q, queries): Returns the number of distinct crystal identifiers for each subarray defined by the queries. results = [] for (l, r) in queries: subarray = crystals[l-1:r] distinct_count = len(set(subarray)) results.append(distinct_count) return results"},{"question":"from typing import List def minFlips(matrix: List[List[int]]) -> int: Given a binary matrix (consisting of 0s and 1s), find the minimum number of flips (from 0 to 1) required so that each row and each column contains at least one '1'. Args: matrix: A binary 2D list with dimensions m x n. Returns: The minimum number of flips required. Examples: >>> minFlips([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 3 >>> minFlips([ [1, 0], [0, 1] ]) 0 >>> minFlips([ [0, 1, 0], [0, 0, 0], [0, 0, 0] ]) 2 pass","solution":"def minFlips(matrix): m = len(matrix) n = len(matrix[0]) # Find rows and columns that do not contain any 1s rows_with_no_ones = set() cols_with_no_ones = set() for i in range(m): if not any(matrix[i][j] == 1 for j in range(n)): rows_with_no_ones.add(i) for j in range(n): if not any(matrix[i][j] == 1 for i in range(m)): cols_with_no_ones.add(j) # We need at least max number of rows with no 1s and # columns with no 1s to be flipped return max(len(rows_with_no_ones), len(cols_with_no_ones))"},{"question":"def find_pairs_with_sum(lst, target): Returns a list of pairs (as tuples) from the input list whose elements sum up to the target value. Each pair is sorted in ascending order, and the list of pairs is sorted based on the first element of the pairs. :param lst: List of integers :param target: Target sum value :return: List of tuples pass def test_find_pairs_with_sum(): def test_normal_case(): lst = [1, 2, -1, 0, 2, -2, 3] target = 2 expected = [(-1, 3), (0, 2)] assert find_pairs_with_sum(lst, target) == expected def test_no_pairs(): lst = [1, 2, 3, 4, 5] target = 10 expected = [] assert find_pairs_with_sum(lst, target) == expected def test_negative_and_positive(): lst = [-3, -1, 1, 3, 2] target = 0 expected = [(-3, 3), (-1, 1)] assert find_pairs_with_sum(lst, target) == expected def test_duplicate_numbers(): lst = [1, 1, 2, 2, 3, 3] target = 4 expected = [(1, 3), (2, 2)] assert find_pairs_with_sum(lst, target) == expected def test_single_number(): lst = [3] target = 3 expected = [] assert find_pairs_with_sum(lst, target) == expected test_normal_case() test_no_pairs() test_negative_and_positive() test_duplicate_numbers() test_single_number()","solution":"def find_pairs_with_sum(lst, target): Returns a list of pairs (as tuples) from the input list whose elements sum up to the target value. Each pair is sorted in ascending order, and the list of pairs is sorted based on the first element of the pairs. :param lst: List of integers :param target: Target sum value :return: List of tuples lst.sort() seen = set() pairs = [] for i, num in enumerate(lst): complement = target - num if complement in seen: pairs.append((min(complement, num), max(complement, num))) seen.remove(complement) # Ensure a number is not used more than once else: seen.add(num) pairs.sort() return pairs"},{"question":"def palindromicNumbers(a: int, b: int) -> List[int]: Find all palindromic numbers within a given range of integers. A palindrome is a number that reads the same forward and backward. This function returns a list of all palindromic numbers between \`a\` and \`b\` inclusive. >>> palindromicNumbers(10, 50) [11, 22, 33, 44] >>> palindromicNumbers(13, 20) [] >>> palindromicNumbers(121, 121) [121] >>> palindromicNumbers(0, 9) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> palindromicNumbers(100, 200) [101, 111, 121, 131, 141, 151, 161, 171, 181, 191]","solution":"def palindromicNumbers(a, b): def is_palindrome(n): s = str(n) return s == s[::-1] return [x for x in range(a, b + 1) if is_palindrome(x)]"},{"question":"def diff_even_odd(arr): Returns the difference between the largest even number and the smallest odd number in the array. If no even number or no odd number is found, returns -1. >>> diff_even_odd([4, 6, 8, 9, 15, 17]) -1 >>> diff_even_odd([2, 10, 12, 14, 11, 3, 5]) 11 >>> diff_even_odd([7, 13, 19, 28]) 21 >>> diff_even_odd([4, 8, 12, 16]) -1 >>> diff_even_odd([3, 7, 11, 19]) -1","solution":"def diff_even_odd(arr): Returns the difference between the largest even number and the smallest odd number in the array. If no even number or no odd number is found, returns -1. even_numbers = [num for num in arr if num % 2 == 0] odd_numbers = [num for num in arr if num % 2 != 0] if not even_numbers or not odd_numbers: return -1 largest_even = max(even_numbers) smallest_odd = min(odd_numbers) return largest_even - smallest_odd"},{"question":"from collections import deque def shortest_path_in_maze(maze, start, end): Finds the shortest path from start to end in a given maze. :param maze: List[List[str]], The 2D grid representing the maze. :param start: Tuple[int, int], The starting cell (row, col). :param end: Tuple[int, int], The ending cell (row, col). :return: int, The minimum number of steps to reach the end from the start or -1 if no such path exists. >>> maze1 = [['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']] >>> shortest_path_in_maze(maze1, (0, 0), (2, 2)) 4 >>> maze2 = [['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.']] >>> shortest_path_in_maze(maze2, (0, 0), (2, 2)) -1 >>> maze3 = [['.', '.', '#', '.'], ['#', '.', '#', '.'], ['#', '.', '.', '.'], ['#', '#', '#', '.']] >>> shortest_path_in_maze(maze3, (0, 0), (3, 3)) 6 >>> maze4 = [['.', '.', '.', '#'], ['#', '#', '.', '#'], ['.', '.', '.', '.'], ['#', '#', '#', '#'], ['.', '.', '.', '.']] >>> shortest_path_in_maze(maze4, (0, 0), (2, 3)) 5 >>> maze5 = [['.', '.', '#', '.'], ['#', '#', '#', '.'], ['#', '.', '#', '.'], ['#', '#', '#', '.']] >>> shortest_path_in_maze(maze5, (0, 0), (3, 3)) -1 >>> maze6 = [['.', '#'], ['#', '.']] >>> shortest_path_in_maze(maze6, (1, 1), (1, 1)) 0","solution":"from collections import deque def shortest_path_in_maze(maze, start, end): Finds the shortest path from start to end in a given maze. :param maze: List[List[str]], The 2D grid representing the maze. :param start: Tuple[int, int], The starting cell (row, col). :param end: Tuple[int, int], The ending cell (row, col). :return: int, The minimum number of steps to reach the end from the start or -1 if no such path exists. rows = len(maze) cols = len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == '.' queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == (end[0], end[1]): return steps for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, steps + 1)) return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder: str) -> TreeNode: Reconstruct a BST from its pre-order traversal string. >>> preorder = \\"8 5 1 7 10 12\\" >>> result_tree = bst_from_preorder(preorder) >>> result_tree.val 8 >>> result_tree.left.val 5 >>> result_tree.right.val 10 >>> result_tree.left.left.val 1 >>> result_tree.left.right.val 7 >>> result_tree.right.right.val 12","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder: str) -> TreeNode: Reconstructs the BST from the given preorder traversal string. preorder_values = list(map(int, preorder.split())) if not preorder_values: return None def build_bst(preorder_values, lower=float('-inf'), upper=float('inf')): if not preorder_values or preorder_values[0] < lower or preorder_values[0] > upper: return None val = preorder_values.pop(0) root = TreeNode(val) root.left = build_bst(preorder_values, lower, val) root.right = build_bst(preorder_values, val, upper) return root return build_bst(preorder_values)"},{"question":"def can_obtain_k_consecutive_ones(n: int, k: int, S: str) -> str: Determines if it is possible to obtain exactly k consecutive '1's by flipping bits in the binary string S. Args: n (int): Length of the binary string S. k (int): Length of consecutive '1's required. S (str): Binary string of length n. Returns: str: \\"YES\\" if it is possible to obtain exactly k consecutive '1's, otherwise \\"NO\\". >>> can_obtain_k_consecutive_ones(8, 3, \\"10001101\\") \\"YES\\" >>> can_obtain_k_consecutive_ones(5, 5, \\"00000\\") \\"YES\\" >>> can_obtain_k_consecutive_ones(5, 6, \\"11111\\") \\"NO\\"","solution":"def can_obtain_k_consecutive_ones(n, k, S): Determines if it is possible to obtain exactly k consecutive '1's by flipping bits in the binary string S. Args: n (int): Length of the binary string S. k (int): Length of consecutive '1's required. S (str): Binary string of length n. Returns: str: \\"YES\\" if it is possible to obtain exactly k consecutive '1's, otherwise \\"NO\\". if k > n: return \\"NO\\" # Scanning the string to find any section of k consecutive characters # If found k consecutive '0's or '1's then we can make it for i in range(n - k + 1): if S[i:i+k] == '0' * k or S[i:i+k] == '1' * k: return \\"YES\\" return \\"NO\\""},{"question":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([]) 0 >>> rob([5]) 5 >>> rob([5, 3]) 5 >>> rob([2, 7]) 7 >>> rob([3, 2, 3]) 6 >>> rob([2, 1, 1, 2]) 4 >>> rob([4, 4, 4, 4, 4, 4]) 12 >>> rob([1, 2, 3, 4, 5]) 9 >>> rob([5, 4, 3, 2, 1]) 9","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] # dp[i] will be the max amount of money you can rob up to house i. dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"from typing import List def frequency_sort(n: int, arr: List[int]) -> List[int]: Sorts the array based on the frequency of elements in ascending order. If two elements have the same frequency, they appear in ascending order. >>> frequency_sort(5, [4, 5, 6, 5, 4]) [6, 4, 4, 5, 5] >>> frequency_sort(10, [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] pass","solution":"from collections import Counter def frequency_sort(n, arr): Sorts the array based on the frequency of elements in ascending order. If two elements have the same frequency, they appear in ascending order. :param n: int, number of elements in the array :param arr: list of int, the elements of the array :return: list of int, the sorted elements # Count the frequency of each element freq = Counter(arr) # Sort by frequency, then by element value sorted_arr = sorted(arr, key=lambda x: (freq[x], x)) return sorted_arr"},{"question":"def minimize_workday_difference(tasks): Given a list of task durations, allocate them into two workdays such that the difference in total duration between the two days is minimized. Parameters: tasks (list): List of integers where each integer represents the duration of a task. Returns: int: The minimal difference in the total duration between the two workdays after optimal allocation of the tasks. # Your code here from solution import minimize_workday_difference def test_sample_input(): tasks = [2, 3, 7, 4, 1] assert minimize_workday_difference(tasks) == 1 def test_single_task(): tasks = [10] assert minimize_workday_difference(tasks) == 10 def test_two_tasks_equal(): tasks = [5, 5] assert minimize_workday_difference(tasks) == 0 def test_two_tasks_unequal(): tasks = [5, 3] assert minimize_workday_difference(tasks) == 2 def test_all_same_tasks(): tasks = [4, 4, 4, 4] assert minimize_workday_difference(tasks) == 0 def test_large_number_of_tasks(): tasks = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] assert minimize_workday_difference(tasks) == 1","solution":"def minimize_workday_difference(tasks): Given a list of task durations, allocate them into two workdays such that the difference in total duration between the two days is minimized. Parameters: tasks (list): List of integers where each integer represents the duration of a task. Returns: int: The minimal difference in the total duration between the two workdays after optimal allocation of the tasks. N = len(tasks) total_duration = sum(tasks) # Initialize a DP array to store possible workday totals up to half of total_duration dp = [False] * (total_duration + 1) dp[0] = True for task in tasks: for i in range(total_duration, task - 1, -1): dp[i] = dp[i] or dp[i - task] # Find the most balanced partition by checking from half of the total sum down to zero min_difference = float('inf') for i in range(total_duration // 2 + 1): if dp[i]: min_difference = min(min_difference, abs(total_duration - 2 * i)) return min_difference"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Takes a collection of time intervals and merges any overlapping intervals. Parameters: intervals (list of lists): A list of intervals where each interval is a pair of integers [start, end]. Returns: list of lists: A list of merged intervals in ascending order. Examples: >>> merge_intervals([[1, 3], [2, 4], [5, 7], [6, 8]]) [[1, 4], [5, 8]] >>> merge_intervals([[1, 2], [3, 4]]) [[1, 2], [3, 4]] >>> merge_intervals([]) []","solution":"def merge_intervals(intervals): Takes a list of intervals and merges any overlapping intervals. Parameters: intervals (list of lists): A list of intervals where each interval is a list containing two integers [start, end]. Returns: list of lists: A list of merged intervals in ascending order of their start times. if not intervals: return [] # Sort the intervals by their start time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # If current interval overlaps with the last merged interval, merge them merged[-1] = [last_merged[0], max(last_merged[1], current[1])] else: # Otherwise, add the current interval to the list of merged intervals merged.append(current) return merged"},{"question":"def has_consecutive_subsequence_with_sum(n: int, m: int, s: int, sequence: List[int]) -> str: Checks whether there exists a consecutive subsequence of length \`m\` in the given sequence that sums up to \`s\`. Parameters: n (int): Length of the sequence. m (int): Length of the subsequence. s (int): Target sum of the subsequence. sequence (List[int]): List of integers representing the sequence. Returns: str: \\"Yes\\" if such a subsequence exists, \\"No\\" otherwise. >>> has_consecutive_subsequence_with_sum(6, 3, 6, [1, 2, 3, 2, 1, 2]) 'Yes' >>> has_consecutive_subsequence_with_sum(5, 2, 8, [1, 2, 3, 4, 5]) 'No' pass # You can test your implementation using the following test cases def test_example_case_1(): assert has_consecutive_subsequence_with_sum(6, 3, 6, [1, 2, 3, 2, 1, 2]) == \\"Yes\\" def test_example_case_2(): assert has_consecutive_subsequence_with_sum(5, 2, 8, [1, 2, 3, 4, 5]) == \\"No\\" def test_no_possible_subsequence(): assert has_consecutive_subsequence_with_sum(5, 6, 10, [1, 2, 3, 4, 5]) == \\"No\\" def test_exact_subsequence_at_start(): assert has_consecutive_subsequence_with_sum(5, 2, 3, [1, 2, 3, 4, 5]) == \\"Yes\\" def test_exact_subsequence_at_end(): assert has_consecutive_subsequence_with_sum(5, 2, 9, [1, 2, 3, 4, 5]) == \\"Yes\\" def test_negative_numbers(): assert has_consecutive_subsequence_with_sum(5, 2, -3, [-1, -2, -3, -4, -5]) == \\"Yes\\" def test_single_element_subsequence(): assert has_consecutive_subsequence_with_sum(5, 1, 4, [1, 2, 3, 4, 5]) == \\"Yes\\" assert has_consecutive_subsequence_with_sum(5, 1, 6, [1, 2, 3, 4, 5]) == \\"No\\" def test_large_m_value(): assert has_consecutive_subsequence_with_sum(10, 10, 50, [1, 2, 3, 4, 5, 6, 7, 8, 9, 5]) == \\"Yes\\" assert has_consecutive_subsequence_with_sum(10, 10, 55, [1, 2, 3, 4, 5, 6, 7, 8, 9, 5]) == \\"No\\"","solution":"def has_consecutive_subsequence_with_sum(n, m, s, sequence): Returns \\"Yes\\" if there exists a consecutive subsequence of length \`m\` in the given \`sequence\` which sums up to \`s\`, otherwise returns \\"No\\". if m > n: return \\"No\\" current_sum = sum(sequence[:m]) if current_sum == s: return \\"Yes\\" for i in range(m, n): current_sum += sequence[i] - sequence[i - m] if current_sum == s: return \\"Yes\\" return \\"No\\""},{"question":"def number_of_paths(n: int, m: int, k: int, dangerous_cells: set) -> int: Determine the number of distinct paths the robot can take to reach the bottom-right corner (n-1, m-1) from the top-left corner (0, 0) without stepping on a dangerous cell. The number of paths should be calculated modulo 1000000007. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of dangerous cells. dangerous_cells (set): The set of tuples representing the indices of the dangerous cells. Returns: int: The number of distinct paths modulo 1000000007. >>> number_of_paths(3, 3, 1, {(1, 1)}) == 2 >>> number_of_paths(4, 4, 2, {(1, 1), (2, 2)}) == 4 >>> number_of_paths(2, 2, 0, set()) == 2 >>> number_of_paths(3, 3, 9, {(0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}) == 0 >>> number_of_paths(1, 1, 0, set()) == 1","solution":"def number_of_paths(n, m, k, dangerous_cells): MOD = 1000000007 dp = [[0] * m for _ in range(n)] if (0, 0) in dangerous_cells: return 0 dp[0][0] = 1 for i in range(n): for j in range(m): if (i, j) in dangerous_cells: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1] # Reading the input def solve(): import sys input = sys.stdin.read data = input().split() n, m, k = int(data[0]), int(data[1]), int(data[2]) dangerous_cells = {(int(data[i*2+3]), int(data[i*2+4])) for i in range(k)} print(number_of_paths(n, m, k, dangerous_cells))"},{"question":"from typing import List def longest_subarray(nums: List[int]) -> int: Given a list of integers, find the length of the longest contiguous subarray such that every element in the subarray is distinct. >>> longest_subarray([1, 2, 3, 1, 2, 3, 4, 5]) 5 >>> longest_subarray([5, 1, 5, 1, 5, 5, 1, 2, 3]) 4 >>> longest_subarray([1, 1, 1, 1, 1]) 1 >>> longest_subarray([10, 20, 30, 40, 50]) 5 pass # Unit Tests def test_longest_subarray_example1(): assert longest_subarray([1, 2, 3, 1, 2, 3, 4, 5]) == 5 def test_longest_subarray_example2(): assert longest_subarray([5, 1, 5, 1, 5, 5, 1, 2, 3]) == 4 def test_longest_subarray_example3(): assert longest_subarray([1, 1, 1, 1, 1]) == 1 def test_longest_subarray_example4(): assert longest_subarray([10, 20, 30, 40, 50]) == 5 def test_longest_subarray_single_element(): assert longest_subarray([7]) == 1 def test_longest_subarray_empty_list(): assert longest_subarray([]) == 0 def test_longest_subarray_two_elements_distinct(): assert longest_subarray([1, 2]) == 2 def test_longest_subarray_two_elements_same(): assert longest_subarray([1, 1]) == 1 def test_longest_subarray_multiple_distinct(): assert longest_subarray([1, 2, 3, 4, 5, 1, 2, 3]) == 5 def test_longest_subarray_large_input(): assert longest_subarray(list(range(1000)) + list(range(500))) == 1000","solution":"def longest_subarray(nums): Returns the length of the longest contiguous subarray with distinct elements. n = len(nums) if n == 0: return 0 max_len = 0 left = 0 seen = {} for right in range(n): if nums[right] in seen and seen[nums[right]] >= left: left = seen[nums[right]] + 1 seen[nums[right]] = right max_len = max(max_len, right - left + 1) return max_len # Example usage: print(longest_subarray([1, 2, 3, 1, 2, 3, 4, 5])) # Output: 5 print(longest_subarray([5, 1, 5, 1, 5, 5, 1, 2, 3])) # Output: 4 print(longest_subarray([1, 1, 1, 1, 1])) # Output: 1 print(longest_subarray([10, 20, 30, 40, 50])) # Output: 5"},{"question":"from typing import List, Tuple def process_sequences(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Reverses the order of each sequence and applies the specific operation where each element is multiplied by its 1-based position in the sequence. Args: T : int : number of test cases test_cases : list : list of tuples, each containing an integer N and a list of N integers Returns: results : list : list of lists, each containing the modified sequence for the respective test case results = [] for i in range(T): N, reversed_sequence = test_cases[i] corrected_sequence = reversed_sequence[::-1] modified_sequence = [corrected_sequence[j] * (j + 1) for j in range(N)] results.append(modified_sequence) return results # Test Cases def test_process_sequences_case_1(): T = 2 test_cases = [ (3, [9, 7, 5]), (4, [10, 20, 30, 40]) ] expected = [ [5, 14, 27], [40, 60, 60, 40] ] result = process_sequences(T, test_cases) assert result == expected def test_process_sequences_case_2(): T = 1 test_cases = [ (2, [4, 2]) ] expected = [ [2, 8] ] result = process_sequences(T, test_cases) assert result == expected def test_process_sequences_case_3(): T = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] expected = [ [5, 8, 9, 8, 5] ] result = process_sequences(T, test_cases) assert result == expected def test_process_sequences_case_4(): T = 0 test_cases = [] expected = [] result = process_sequences(T, test_cases) assert result == expected def test_process_sequences_case_5(): T = 1 test_cases = [ (1, [7]) ] expected = [ [7] ] result = process_sequences(T, test_cases) assert result == expected","solution":"def process_sequences(T, test_cases): Reverses the order of each sequence and applies the specific operation where each element is multiplied by its 1-based position in the sequence. Args: T : int : number of test cases test_cases : list : list of tuples, each containing an integer N and a list of N integers Returns: results : list : list of lists, each containing the modified sequence for the respective test case results = [] for i in range(T): N, reversed_sequence = test_cases[i] corrected_sequence = reversed_sequence[::-1] modified_sequence = [corrected_sequence[j] * (j + 1) for j in range(N)] results.append(modified_sequence) return results"},{"question":"def find_min_max_sum(nums: List[int]) -> Tuple[int, int, int]: Given a list of integers, finds the smallest integer, the largest integer, and the sum of integers between the smallest and the largest integers (inclusive) in the sorted order of the list. Args: nums (list): List of integers. Returns: tuple: A tuple containing the smallest integer, the largest integer, and the sum of integers between the smallest and largest integers. >>> find_min_max_sum([4, 1, 3, 2, 5]) (1, 5, 15) >>> find_min_max_sum([100]) (100, 100, 100) >>> find_min_max_sum([-1, -2, -3, -4, -5]) (-5, -1, -15) >>> find_min_max_sum([0, 2, 4, 6]) (0, 6, 12) >>> find_min_max_sum([1000000000, -1000000000]) (-1000000000, 1000000000, 0) >>> find_min_max_sum([]) (None, None, 0)","solution":"def find_min_max_sum(nums): Given a list of integers, finds the smallest integer, the largest integer, and the sum of integers between the smallest and the largest integers (inclusive) in the sorted order of the list. Args: nums (list): List of integers. Returns: tuple: A tuple containing the smallest integer, the largest integer, and the sum of integers between the smallest and largest integers. if not nums: return (None, None, 0) sorted_nums = sorted(nums) min_val = sorted_nums[0] max_val = sorted_nums[-1] sum_between = sum(sorted_nums) return (min_val, max_val, sum_between) # Sample input N = 5 A = [4, 1, 3, 2, 5] result = find_min_max_sum(A) print(result)"},{"question":"def south_america_countries(countries): Returns a set of South American countries from the provided list of countries. >>> south_america_countries([\\"United States\\", \\"Brazil\\", \\"Germany\\", \\"Argentina\\"]) == {\\"Brazil\\", \\"Argentina\\"} >>> south_america_countries([\\"China\\", \\"Chile\\", \\"Canada\\", \\"Nigeria\\"]) == {\\"Chile\\"}","solution":"def south_america_countries(countries): Returns a set of South American countries from the provided list of countries. south_american_countries = { \\"Argentina\\", \\"Bolivia\\", \\"Brazil\\", \\"Chile\\", \\"Colombia\\", \\"Ecuador\\", \\"Guyana\\", \\"Paraguay\\", \\"Peru\\", \\"Suriname\\", \\"Uruguay\\", \\"Venezuela\\" } return set(country for country in countries if country in south_american_countries)"},{"question":"def find_winning_team(scores): Finds the index of the winning team based on the sum of the top two scores in each team. Parameters: scores (list of lists): A list where each sublist contains three integers representing the scores of a team. Returns: int: The 1-based index of the winning team. Examples: >>> find_winning_team([[4, 8, 6], [7, 5, 9], [5, 5, 5]]) 2 >>> find_winning_team([[1, 2, 3], [10, 20, 30], [5, 5, 5], [30, 10, 10]]) 2","solution":"def find_winning_team(scores): Finds the index of the winning team based on the sum of the top two scores in each team. Parameters: scores (list of lists): A list where each sublist contains three integers representing the scores of a team. Returns: int: The 1-based index of the winning team. max_score = -1 winning_team_index = -1 for i, team_scores in enumerate(scores): sorted_scores = sorted(team_scores, reverse=True) team_score = sorted_scores[0] + sorted_scores[1] if team_score > max_score: max_score = team_score winning_team_index = i return winning_team_index + 1"},{"question":"def longest_subsequence_length(n: int, sequence: List[int]) -> int: Returns the length of the longest subsequence such that each pair of consecutive elements differs by exactly 1. >>> longest_subsequence_length(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_subsequence_length(5, [10, 12, 11, 14, 13]) 5 >>> longest_subsequence_length(4, [20, 20, 20, 20]) 1 import pytest def test_example_cases(): assert longest_subsequence_length(6, [1, 2, 3, 4, 5, 6]) == 6 assert longest_subsequence_length(5, [10, 12, 11, 14, 13]) == 5 assert longest_subsequence_length(4, [20, 20, 20, 20]) == 1 def test_single_element(): assert longest_subsequence_length(1, [10]) == 1 def test_no_consecutive_elements(): assert longest_subsequence_length(5, [1, 3, 5, 7, 9]) == 1 def test_all_elements_same(): assert longest_subsequence_length(5, [8, 8, 8, 8, 8]) == 1 def test_consecutive_elements_but_unsorted(): assert longest_subsequence_length(5, [8, 6, 7, 5, 9]) == 5 def test_all_elements_consecutive(): assert longest_subsequence_length(5, [2, 3, 4, 5, 6]) == 5 def test_two_consecutive_elements(): assert longest_subsequence_length(2, [7, 6]) == 2 @pytest.mark.parametrize(\\"n,sequence,expected\\", [ (3, [1, 3, 4], 2), (4, [10, 12, 11, 10], 3), (3, [2, 2, 3], 2), ]) def test_variety_cases(n, sequence, expected): assert longest_subsequence_length(n, sequence) == expected","solution":"def longest_subsequence_length(n, sequence): Returns the length of the longest subsequence such that each pair of consecutive elements differs by exactly 1. if n == 1: return 1 longest = 1 current_length = 1 sequence.sort() for i in range(1, n): if sequence[i] - sequence[i - 1] == 1: current_length += 1 else: longest = max(longest, current_length) current_length = 1 longest = max(longest, current_length) return longest"},{"question":"class Matrix: def __init__(self, data): Initializes a matrix with the provided 2D list self.data = data self.rows = len(data) self.cols = len(data[0]) def __add__(self, other): Add two matrices def __sub__(self, other): Subtract one matrix from another def __mul__(self, other): Multiply two matrices def transpose(self): Transpose the matrix def det(self): Calculate the determinant of the matrix (only for 2x2 and 3x3 matrices) def to_list(self): Convert the matrix to a list of lists def __str__(self): String representation of the matrix in row-major order # Unit test cases: def test_matrix_addition(): m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) m3 = m1 + m2 assert m3.to_list() == [[6, 8], [10, 12]] def test_matrix_subtraction(): m1 = Matrix([[5, 6], [7, 8]]) m2 = Matrix([[1, 2], [3, 4]]) m3 = m1 - m2 assert m3.to_list() == [[4, 4], [4, 4]] def test_matrix_multiplication(): m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[2, 0], [1, 2]]) m3 = m1 * m2 assert m3.to_list() == [[4, 4], [10, 8]] def test_matrix_transpose(): m1 = Matrix([[1, 2, 3], [4, 5, 6]]) m2 = m1.transpose() assert m2.to_list() == [[1, 4], [2, 5], [3, 6]] def test_matrix_determinant_2x2(): m1 = Matrix([[1, 2], [3, 4]]) assert m1.det() == -2 def test_matrix_determinant_3x3(): m1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) assert m1.det() == 0 def test_matrix_to_list(): m1 = Matrix([[1, 2], [3, 4]]) assert m1.to_list() == [[1, 2], [3, 4]] def test_matrix_str(): m1 = Matrix([[1, 2], [3, 4]]) assert str(m1) == \\"1 2n3 4\\"","solution":"class Matrix: def __init__(self, data): self.data = data self.rows = len(data) self.cols = len(data[0]) def __add__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions to add.\\") result = [ [self.data[i][j] + other.data[i][j] for j in range(self.cols)] for i in range(self.rows) ] return Matrix(result) def __sub__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions to subtract.\\") result = [ [self.data[i][j] - other.data[i][j] for j in range(self.cols)] for i in range(self.rows) ] return Matrix(result) def __mul__(self, other): if self.cols != other.rows: raise ValueError(\\"Number of columns of the first matrix must equal the number of rows of the second matrix.\\") result = [ [sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) for j in range(other.cols)] for i in range(self.rows) ] return Matrix(result) def transpose(self): result = [ [self.data[j][i] for j in range(self.rows)] for i in range(self.cols) ] return Matrix(result) def det(self): if self.rows == 2 and self.cols == 2: return self.data[0][0] * self.data[1][1] - self.data[0][1] * self.data[1][0] elif self.rows == 3 and self.cols == 3: a = self.data return ( a[0][0] * (a[1][1] * a[2][2] - a[1][2] * a[2][1]) - a[0][1] * (a[1][0] * a[2][2] - a[1][2] * a[2][0]) + a[0][2] * (a[1][0] * a[2][1] - a[1][1] * a[2][0]) ) else: raise NotImplementedError(\\"Determinant not implemented for matrices larger than 3x3.\\") def to_list(self): return self.data def __str__(self): return 'n'.join([' '.join(map(str, row)) for row in self.data])"},{"question":"from typing import List, Union class UserWatchHistory: def __init__(self): self.history = defaultdict(list) def watch(self, user_id: str, video_id: str): pass def remove(self, user_id: str, video_id: str): pass def query(self, user_id: str, video_id: str) -> str: pass def recent(self, user_id: str, k: int) -> str: pass def execute_operations(n: int, operations: List[List[Union[str, int]]]) -> List[str]: Perform a sequence of operations on user watch history. Args: n: The number of operations. operations: A list of operations, where each operation is a list. Returns: A list of results for 'query' and 'recent' operations. >>> execute_operations(10, [['watch', 'user1', 'vid1'], ['watch', 'user1', 'vid2'], ['watch', 'user1', 'vid1'], ['query', 'user1', 'vid1'], ['query', 'user1', 'vid2'], ['remove', 'user1', 'vid1'], ['query', 'user1', 'vid1'], ['recent', 'user1', 1], ['watch', 'user1', 'vid3'], ['recent', 'user1', 2]]) ['YES', 'YES', 'NO', 'vid2', 'vid3 vid2'] >>> execute_operations(7, [['watch', 'user2', 'vid7'], ['query', 'user2', 'vid7'], ['remove', 'user2', 'vid7'], ['query', 'user2', 'vid7'], ['watch', 'user2', 'vid8'], ['recent', 'user2', 2], ['recent', 'user2', 1]]) ['YES', 'NO', 'vid8', 'vid8'] pass","solution":"from collections import defaultdict class UserWatchHistory: def __init__(self): self.history = defaultdict(list) def watch(self, user_id, video_id): if video_id in self.history[user_id]: self.history[user_id].remove(video_id) self.history[user_id].append(video_id) def remove(self, user_id, video_id): if video_id in self.history[user_id]: self.history[user_id].remove(video_id) def query(self, user_id, video_id): return \\"YES\\" if video_id in self.history[user_id] else \\"NO\\" def recent(self, user_id, k): if not self.history[user_id]: return \\"No videos watched\\" return ' '.join(self.history[user_id][-k:][::-1]) def execute_operations(n, operations): uw = UserWatchHistory() results = [] for operation in operations: if operation[0] == 'watch': user_id, video_id = operation[1], operation[2] uw.watch(user_id, video_id) elif operation[0] == 'remove': user_id, video_id = operation[1], operation[2] uw.remove(user_id, video_id) elif operation[0] == 'query': user_id, video_id = operation[1], operation[2] results.append(uw.query(user_id, video_id)) elif operation[0] == 'recent': user_id, k = operation[1], int(operation[2]) results.append(uw.recent(user_id, k)) return results"},{"question":"def filter_and_sort_colors(colors): Filters out empty strings from the input list and returns a list of unique colors sorted alphabetically. If the list is empty or contains only empty strings, return a list with a single element \\"no colors\\". >>> filter_and_sort_colors([\\"red\\", \\"blue\\", \\"red\\", \\"\\", \\"green\\", \\"blue\\"]) [\\"blue\\", \\"green\\", \\"red\\"] >>> filter_and_sort_colors([\\"\\", \\"\\", \\"\\"]) [\\"no colors\\"]","solution":"def filter_and_sort_colors(colors): Filters out empty strings from the input list and returns a list of unique colors sorted alphabetically. If the list is empty or contains only empty strings, return a list with a single element \\"no colors\\". unique_colors = set(color for color in colors if color) if not unique_colors: return [\\"no colors\\"] return sorted(unique_colors)"},{"question":"def diagonalOrder(N, M, A): Returns a list of all elements of the matrix diagonals starting from the top-left corner going to the bottom-right corner. Example 1: N, M = 2, 3 A = [[1, 2, 3], [4, 5, 6]] >>> diagonalOrder(N, M, A) [1, 2, 4, 3, 5, 6] Example 2: N, M = 3, 3 A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> diagonalOrder(N, M, A) [1, 2, 4, 3, 5, 7, 6, 8, 9] from solution import diagonalOrder def test_small_matrix(): assert diagonalOrder(2, 3, [[1, 2, 3], [4, 5, 6]]) == [1, 2, 4, 3, 5, 6] def test_square_matrix(): assert diagonalOrder(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 4, 3, 5, 7, 6, 8, 9] def test_single_element_matrix(): assert diagonalOrder(1, 1, [[42]]) == [42] def test_single_row_matrix(): assert diagonalOrder(1, 5, [[1, 2, 3, 4, 5]]) == [1, 2, 3, 4, 5] def test_single_column_matrix(): assert diagonalOrder(4, 1, [[1], [2], [3], [4]]) == [1, 2, 3, 4] def test_larger_matrix(): assert diagonalOrder(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 5, 3, 6, 9, 4, 7, 10, 8, 11, 12]","solution":"def diagonalOrder(N, M, A): Returns a list of all elements of the matrix diagonals starting from the top-left corner going to the bottom-right corner. result = [] for col in range(M): row, c = 0, col while row < N and c >= 0: result.append(A[row][c]) row += 1 c -= 1 for row in range(1, N): r, col = row, M - 1 while r < N and col >= 0: result.append(A[r][col]) r += 1 col -= 1 return result"},{"question":"def min_operations_to_make_same(t: int, test_cases: List[str]) -> List[int]: Determine the minimum number of operations needed to make all characters of the string the same for a given set of test cases. >>> min_operations_to_make_same(3, [\\"aabb\\", \\"abcde\\", \\"zzzzz\\"]) [2, 4, 0] >>> min_operations_to_make_same(2, [\\"a\\", \\"b\\"]) [0, 0]","solution":"def min_operations_to_make_same(t, test_cases): results = [] for s in test_cases: max_freq = max(s.count(ch) for ch in set(s)) operations = len(s) - max_freq results.append(operations) return results"},{"question":"def minimize_adjacent_ones(s: str) -> str: Rearrange the characters of the binary string such that the resulting string minimizes the number of adjacent pairs of '1's and is the lexicographically smallest string among all possible valid arrangements. Parameters: s (str): input binary string Returns: str: lexicographically smallest binary string with minimum adjacent '1's >>> minimize_adjacent_ones(\\"101110\\") \\"001111\\" >>> minimize_adjacent_ones(\\"000\\") \\"000\\" >>> minimize_adjacent_ones(\\"1110\\") \\"0111\\"","solution":"def minimize_adjacent_ones(s): Function to rearrange the characters of the string such that the resulting string minimizes the number of adjacent pairs of '1's and is the lexicographically smallest string among all valid arrangements. Parameters: s (str): input binary string Returns: str: lexicographically smallest binary string with minimum adjacent '1's zeros = s.count('0') ones = s.count('1') return '0' * zeros + '1' * ones"},{"question":"def longest_non_defective_subsequence(S: str) -> int: Find the length of the longest contiguous subsequence of non-defective widgets in a binary string S. >>> longest_non_defective_subsequence(\\"110001110\\") 3 >>> longest_non_defective_subsequence(\\"00000\\") 5 >>> longest_non_defective_subsequence(\\"11111\\") 0 # Add implementation here","solution":"def longest_non_defective_subsequence(S): This function finds the length of the longest contiguous subsequence of non-defective widgets in a binary string S. Parameters: S (str): A binary string where '0' indicates a non-defective widget and '1' indicates a defective widget. Returns: int: The length of the longest contiguous subsequence of '0's. max_length = 0 current_length = 0 for char in S: if char == '0': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def longest_subsequence_length(n: int, sequence: List[int]) -> int: Determine the length of the longest subsequence where the difference between consecutive elements is consistent (constant difference). Args: n : int : the number of elements in the sequence sequence : List[int] : the elements of the sequence Returns: int : the length of the longest subsequence with constant difference Example: >>> longest_subsequence_length(5, [1, 3, 5, 7, 9]) 5 >>> longest_subsequence_length(6, [10, 7, 4, 3, 0, -3]) 3 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the length of the longest subsequence with constant difference for each test case. Args: test_cases : list of tuples : each containing an integer n and a list of integers Returns: list of integers : results for each test case Example: >>> process_test_cases([(5, [1, 3, 5, 7, 9]), (6, [10, 7, 4, 3, 0, -3])]) [5, 3] pass import sys from typing import List, Tuple def main(): input = sys.stdin.read data = input().split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) index += 1 sequence = list(map(int, data[index:index + n])) index += n test_cases.append((n, sequence)) results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def longest_subsequence_length(n, sequence): if n == 2: return n max_length = 1 current_length = 1 current_diff = sequence[1] - sequence[0] for i in range(1, n - 1): diff = sequence[i + 1] - sequence[i] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 1 max_length = max(max_length, current_length + 1) return max_length def process_test_cases(test_cases): results = [] for n, sequence in test_cases: results.append(longest_subsequence_length(n, sequence)) return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) index += 1 sequence = list(map(int, data[index:index + n])) index += n test_cases.append((n, sequence)) results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"class BotanistLab: def __init__(self, n): pass def build(self, node, start, end): pass def update_range(self, node, start, end, l, r, val): pass def query_range(self, node, start, end, l, r): pass def plant_process(n, operations): Bob, the botanist, experiments with an array of plants placed in a single row. Each plant initially has a health score of 0. Bob performs Q operations on them. Args: n (int): Number of plants. operations (List[List[int]]): List of operations where each operation is of the form: - [1, u, v]: Increase health score of plants from u to v by 1. - [2, u, v]: Query the maximum health score among plants from u to v inclusive. Returns: List[int]: Results of each query operation. Example: >>> plant_process(5, [[1, 1, 3], [1, 2, 5], [2, 1, 5], [1, 4, 5], [2, 4, 5], [1, 3, 3]]) [2, 2] >>> plant_process(4, [[1, 1, 4], [1, 1, 4], [2, 1, 2], [2, 3, 4]]) [2, 2] result = [] lab = BotanistLab(n) lab.build(1, 1, n) for op in operations: if op[0] == 1: u, v = op[1], op[2] lab.update_range(1, 1, n, u, v, 1) elif op[0] == 2: u, v = op[1], op[2] result.append(lab.query_range(1, 1, n, u, v)) return result","solution":"class BotanistLab: def __init__(self, n): self.n = n self.health_scores = [0] * (n + 1) self.lazy = [0] * (4 * (n + 1)) self.seg_tree = [0] * (4 * (n + 1)) def build(self, node, start, end): if start == end: self.seg_tree[node] = self.health_scores[start] else: mid = (start + end) // 2 self.build(2 * node, start, mid) self.build(2 * node + 1, mid + 1, end) self.seg_tree[node] = max(self.seg_tree[2 * node], self.seg_tree[2 * node + 1]) def update_range(self, node, start, end, l, r, val): if self.lazy[node] != 0: self.seg_tree[node] += self.lazy[node] if start != end: self.lazy[2 * node] += self.lazy[node] self.lazy[2 * node + 1] += self.lazy[node] self.lazy[node] = 0 if start > r or end < l: return if start >= l and end <= r: self.seg_tree[node] += val if start != end: self.lazy[2 * node] += val self.lazy[2 * node + 1] += val return mid = (start + end) // 2 self.update_range(2 * node, start, mid, l, r, val) self.update_range(2 * node + 1, mid + 1, end, l, r, val) self.seg_tree[node] = max(self.seg_tree[2 * node], self.seg_tree[2 * node + 1]) def query_range(self, node, start, end, l, r): if start > r or end < l: return -float('inf') if self.lazy[node] != 0: self.seg_tree[node] += self.lazy[node] if start != end: self.lazy[2 * node] += self.lazy[node] self.lazy[2 * node + 1] += self.lazy[node] self.lazy[node] = 0 if start >= l and end <= r: return self.seg_tree[node] mid = (start + end) // 2 left_query = self.query_range(2 * node, start, mid, l, r) right_query = self.query_range(2 * node + 1, mid + 1, end, l, r) return max(left_query, right_query) def plant_process(n, operations): result = [] lab = BotanistLab(n) lab.build(1, 1, n) for op in operations: if op[0] == 1: u, v = op[1], op[2] lab.update_range(1, 1, n, u, v, 1) elif op[0] == 2: u, v = op[1], op[2] result.append(lab.query_range(1, 1, n, u, v)) return result"},{"question":"def digital_root_product(x: int, y: int) -> int: Compute the digital root of the product of x and y. >>> digital_root_product(5, 7) 8 >>> digital_root_product(6, 9) 9 >>> digital_root_product(0, 0) 0 >>> digital_root_product(123, 456) 9 >>> digital_root_product(999, 999) 9 >>> digital_root_product(123456789, 987654321) 9 >>> digital_root_product(10, 10) 1 >>> digital_root_product(0, 5) 0 >>> digital_root_product(10, 0) 0","solution":"def digital_root_product(x, y): Returns the digital root of the product of two numbers x and y. product = x * y if product == 0: return 0 return 1 + (product - 1) % 9"},{"question":"def categorize_ages(t: int, test_cases: List[List[int]]) -> List[List[str]]: Categorizes a list of ages into \\"Child\\", \\"Teen\\", \\"Adult\\", and \\"Senior\\" based on given rules. >>> categorize_ages(1, [[5, 3, 16, 45, 67, 8]]) [['Child', 'Teen', 'Adult', 'Senior', 'Child']] >>> categorize_ages(2, [[5, 3, 16, 45, 67, 8], [4, 12, 70, 20, 15]]) [['Child', 'Teen', 'Adult', 'Senior', 'Child'], ['Child', 'Senior', 'Adult', 'Teen']] from typing import List def test_single_test_case(): assert categorize_ages(1, [[5, 3, 16, 45, 67, 8]]) == [['Child', 'Teen', 'Adult', 'Senior', 'Child']] def test_multiple_test_cases(): input_cases = [ [5, 3, 16, 45, 67, 8], [4, 12, 70, 20, 15] ] expected_output = [ ['Child', 'Teen', 'Adult', 'Senior', 'Child'], ['Child', 'Senior', 'Adult', 'Teen'] ] assert categorize_ages(2, input_cases) == expected_output def test_minimum_age_boundary(): assert categorize_ages(1, [[1, 0]]) == [['Child']] def test_maximum_age_boundary(): assert categorize_ages(1, [[1, 120]]) == [['Senior']] def test_edge_ages(): input_cases = [ [4, 12, 13, 17, 18] ] expected_output = [ ['Child', 'Teen', 'Teen', 'Adult'] ] assert categorize_ages(1, input_cases) == expected_output","solution":"def categorize_ages(t, test_cases): Categorizes a list of ages based on given rules. Parameters: t (int): Number of test cases. test_cases (list of lists): A list containing test cases where each test case is a list starting with N followed by N ages. Returns: list of lists: List of results where each sublist contains the categories for the ages in a test case. results = [] for case in test_cases: N = case[0] ages = case[1:] categories = [] for age in ages: if 0 <= age <= 12: categories.append(\\"Child\\") elif 13 <= age <= 17: categories.append(\\"Teen\\") elif 18 <= age <= 59: categories.append(\\"Adult\\") elif age >= 60: categories.append(\\"Senior\\") results.append(categories) return results"},{"question":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array. Args: nums (List[int]): A list of integers. Returns: int: The maximum sum of non-adjacent elements. Examples: >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 1]) 4","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array. n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] # Define dp array where dp[i] is the maximum sum we can obtain from the array up to index i dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1] # Example usage: # nums = [3, 2, 7, 10] # print(max_non_adjacent_sum(nums)) # Output: 13"},{"question":"def maxTasks(tasks, total_time): Determine the maximum number of tasks that can be completed without exceeding the total available time. :param tasks: List[int] - A list of integers where each integer represents the time required for a task. :param total_time: int - The total available time for the day. :return: int - The maximum number of tasks that can be completed. Examples: >>> maxTasks([2, 3, 1, 4, 2], 6) 3 >>> maxTasks([5, 3, 4, 2, 1], 7) 3","solution":"def maxTasks(tasks, total_time): Determine the maximum number of tasks that can be completed without exceeding the total available time. :param tasks: List[int] - A list of integers where each integer represents the time required for a task. :param total_time: int - The total available time for the day. :return: int - The maximum number of tasks that can be completed. # Sort tasks by the time they take in ascending order tasks.sort() task_count = 0 time_spent = 0 for task_time in tasks: if time_spent + task_time <= total_time: time_spent += task_time task_count += 1 else: break return task_count"},{"question":"def count_connected_regions(n: int, m: int, labyrinth: List[str]) -> int: Determines the number of distinct connected regions of passable cells in the labyrinth. :param n: Number of rows in the labyrinth :param m: Number of columns in the labyrinth :param labyrinth: List of strings representing the labyrinth :return: Number of distinct connected regions of passable cells >>> count_connected_regions(4, 5, [\\".#.#.\\", \\"#..\\", \\"..#..\\", \\"..#\\"]) == 4 >>> count_connected_regions(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == 1 >>> count_connected_regions(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) == 0 >>> count_connected_regions(1, 1, [\\".\\"]) == 1 >>> count_connected_regions(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"]) == 1 >>> count_connected_regions(5, 5, [\\"#.#\\", \\".\\", \\".\\", \\"#.#\\", \\"#.#.#\\"]) == 5","solution":"def count_connected_regions(n, m, labyrinth): Determines the number of distinct connected regions of passable cells in the labyrinth. :param n: Number of rows in the labyrinth :param m: Number of columns in the labyrinth :param labyrinth: List of strings representing the labyrinth :return: Number of distinct connected regions of passable cells def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or labyrinth[x][y] == '#' or visited[x][y]: return visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy) visited = [[False] * m for _ in range(n)] region_count = 0 for i in range(n): for j in range(m): if labyrinth[i][j] == '.' and not visited[i][j]: dfs(i, j) region_count += 1 return region_count"},{"question":"from typing import List def max_number_of_flowers(n: int, bloom: List[int], wilt: List[int]) -> int: Alice is planting flowers in her garden. Each flower blooms on a specific day and wilts on a specific day. Find the maximum number of flowers that are in bloom simultaneously at any point in time. :param n: Number of flowers :param bloom: List of days each flower blooms :param wilt: List of days each flower wilts :return: Maximum number of flowers in bloom simultaneously >>> max_number_of_flowers(5, [1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) 3 >>> max_number_of_flowers(3, [1, 5, 10], [2, 6,12]) 1 >>> max_number_of_flowers(3, [1, 1, 1], [5, 5, 5]) 3 >>> max_number_of_flowers(4, [1, 3, 5, 7], [4, 6, 8, 10]) 2 >>> max_number_of_flowers(1, [1], [10]) 1","solution":"def max_bloom_flowers(bloom, wilt): events = [] for i in range(len(bloom)): events.append((bloom[i], 1)) # +1 for bloom events.append((wilt[i] + 1, -1)) # -1 for wilt (end of bloom day + 1) # Sort events by days; if same day, end event (-1) comes before start event (+1) events.sort(key=lambda x: (x[0], x[1])) max_flowers = 0 current_flowers = 0 for event in events: current_flowers += event[1] if current_flowers > max_flowers: max_flowers = current_flowers return max_flowers def max_number_of_flowers(n, bloom, wilt): return max_bloom_flowers(bloom, wilt) # Sample input n = 5 bloom = [1, 2, 3, 4, 5] wilt = [3, 4, 5, 6, 7] # Output the result print(max_number_of_flowers(n, bloom, wilt))"},{"question":"def countSimilarBooks(n, books): Determine the number of pairs of books that share at least one common topic. >>> countSimilarBooks(4, [(1, [\\"history\\", \\"math\\"]), (2, [\\"science\\", \\"math\\"]), (3, [\\"art\\"]), (4, [\\"history\\", \\"art\\"])]) 3 >>> countSimilarBooks(4, [(1, [\\"history\\"]), (2, [\\"science\\"]), (3, [\\"art\\"]), (4, [\\"math\\"])]) 0","solution":"def countSimilarBooks(n, books): from collections import defaultdict topic_dict = defaultdict(list) # Build a dictionary where each key is a topic and the value is a list of book ids that have this topic. for book_id, topics in books: for topic in topics: topic_dict[topic].append(book_id) similar_pairs = set() # Check pairs of books for common topics for topic, book_ids in topic_dict.items(): for i in range(len(book_ids)): for j in range(i + 1, len(book_ids)): similar_pairs.add((min(book_ids[i], book_ids[j]), max(book_ids[i], book_ids[j]))) return len(similar_pairs)"},{"question":"from typing import List def maxProduct(n: int, arr: List[int]) -> int: Returns the maximum product of two integers in the array under modulo 10^9 + 7. >>> maxProduct(5, [1, 2, 3, 4, 5]) 20 >>> maxProduct(4, [-10, -3, 5, 6]) 30","solution":"def maxProduct(n, arr): Returns the maximum product of two integers in the array under modulo 10^9 + 7. MOD = 10**9 + 7 if n < 2: return 0 # Initialize the largest and second largest positive numbers max1 = max2 = float('-inf') # Initialize the smallest and the second smallest negative numbers min1 = min2 = float('inf') for number in arr: if number > max1: max2 = max1 max1 = number elif number > max2: max2 = number if number < min1: min2 = min1 min1 = number elif number < min2: min2 = number product1 = max1 * max2 product2 = min1 * min2 return max(product1, product2) % MOD"},{"question":"def determine_winner(n, array): Determines the winner of the game based on the game rules. Parameters: n (int): The number of integers in the array. array (list of int): The array of positive integers. Returns: str: \\"Alice\\" if Alice wins, otherwise \\"Bob\\". >>> determine_winner(5, [4, 5, 1, 2, 3]) \\"Alice\\" >>> determine_winner(4, [10, 1, 20, 3]) \\"Bob\\" >>> determine_winner(1, [1]) \\"Alice\\" >>> determine_winner(2, [5, 10]) \\"Bob\\" >>> determine_winner(3, [9, 8, 7]) \\"Alice\\" >>> determine_winner(6, [1, 2, 3, 4, 5, 6]) \\"Bob\\" >>> determine_winner(7, [7, 6, 5, 4, 3, 2, 1]) \\"Alice\\"","solution":"def determine_winner(n, array): Determines the winner of the game based on the game rules. Parameters: n (int): The number of integers in the array. array (list of int): The array of positive integers. Returns: str: \\"Alice\\" if Alice wins, otherwise \\"Bob\\". # Count the moves made by each player alice_moves = 0 bob_moves = 0 # Sort the array to simulate Alice removing the smallest and Bob removing the largest sorted_array = sorted(array) # Take turns: Alice starts first turn = 0 # Even index: Alice; Odd index: Bob while sorted_array: if turn % 2 == 0: # Alice's turn sorted_array.pop(0) # Remove the smallest element alice_moves += 1 else: # Bob's turn sorted_array.pop() # Remove the largest element bob_moves += 1 turn += 1 # Determine the winner if alice_moves > bob_moves: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def maxProduct(nums): Function to find the maximum product of continuous subarray within an array list of integers. pass def largest_product_of_subarrays(T, test_cases): Given an integer array nums, find the subarray which has the largest product, and return its product. Input: - T: integer, number of test cases - test_cases: list of tuples, each tuple contains an integer n (number of elements in the array) and a list of integers nums Output: - list of integers, each integer is the largest product of any subarray for a corresponding test case >>> largest_product_of_subarrays(2, [(4, [2, 3, -2, 4]), (3, [-2, 0, -1])]) [6, 0] >>> largest_product_of_subarrays(1, [(4, [-2, -3, -2, -4])]) [48] >>> largest_product_of_subarrays(1, [(4, [0, 0, 0, 0])]) [0] >>> largest_product_of_subarrays(1, [(6, [2, 3, -2, 4, -1, -3])]) [48] >>> largest_product_of_subarrays(1, [(1, [5])]) [5] pass","solution":"def maxProduct(nums): Function to find the maximum product of continuous subarray within an array list of integers. if not nums: return 0 max_so_far = nums[0] min_so_far = nums[0] result = max_so_far for i in range(1, len(nums)): current = nums[i] temp_max = max(current, max_so_far * current, min_so_far * current) min_so_far = min(current, max_so_far * current, min_so_far * current) max_so_far = temp_max result = max(result, max_so_far) return result def largest_product_of_subarrays(T, test_cases): results = [] for n, nums in test_cases: results.append(maxProduct(nums)) return results"},{"question":"def min_total_cost(n, prices, m, discount_packages): Calculate the minimum total cost to purchase all items with available discounts. n: int - the number of items. prices: List[int] - the price of each item. m: int - the number of discount packages. discount_packages: List[Tuple[int, List[int], int]] - discount packages listed as (number of items, list of item indices, discounted price). Returns: int - the minimum total cost. >>> min_total_cost(3, [100, 200, 300], 2, [(2, [1, 2], 270), (3, [1, 2, 3], 500)]) 500 >>> min_total_cost(4, [100, 400, 300, 200], 3, [(2, [1, 2], 450), (2, [3, 4], 400), (4, [1, 2, 3, 4], 850)]) 850 >>> min_total_cost(1, [200], 1, [(1, [1], 150)]) 150 >>> min_total_cost(2, [100, 200], 0, []) 300 >>> min_total_cost(3, [100, 150, 200], 3, [(2, [1, 2], 220), (3, [1, 2, 3], 400), (2, [2, 3], 320)]) 400","solution":"def min_total_cost(n, prices, m, discount_packages): from itertools import combinations # Initialize the minimum cost to be the sum of individual item prices min_cost = sum(prices) # Generate all possible subsets of items all_sets = [] for i in range(1, n+1): for combo in combinations(range(n), i): all_sets.append(set(combo)) # Dictionary to store the minimum cost required to buy specific subsets of items. min_cost_dict = {} min_cost_dict[frozenset()] = 0 for items_set in all_sets: items_set = frozenset(items_set) current_min_cost = sum(prices[item] for item in items_set) for k, package_items, discounted_price in discount_packages: package_set = frozenset(idx-1 for idx in package_items) if package_set.issubset(items_set): residual_set = items_set - package_set min_cost_with_package = min_cost_dict[residual_set] + discounted_price if min_cost_with_package < current_min_cost: current_min_cost = min_cost_with_package min_cost_dict[items_set] = current_min_cost if items_set == frozenset(range(n)): min_cost = min(min_cost, current_min_cost) return min_cost"},{"question":"def earliest_buses(t, test_cases): Determine the earliest arriving bus at each stop for a given set of bus schedules. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list where each element is a tuple. The first tuple element is the number of buses, and the second element is a list of lists. Each inner list contains the arrival times of a specific bus at each stop. Returns: List[str]: Each string contains pairs of bus identifier and the earliest arrival time for each stop in the format \\"bus_id arrival_time\\". Example: >>> t = 2 >>> test_cases = [ ... (3, [ ... [10, 20], ... [15, 25], ... [5, 10, 20] ... ]), ... (2, [ ... [30, 45], ... [25, 50, 75] ... ]) ... ] >>> earliest_buses(t, test_cases) ['3 5 3 10 3 20', '2 25 1 45 2 75']","solution":"def earliest_buses(t, test_cases): result = [] for i in range(t): n, buses = test_cases[i] stops = {} for bus_id, bus in enumerate(buses, start=1): for stop, arrival_time in enumerate(bus): if stop not in stops: stops[stop] = (bus_id, arrival_time) else: if arrival_time < stops[stop][1] or (arrival_time == stops[stop][1] and bus_id < stops[stop][0]): stops[stop] = (bus_id, arrival_time) # Sort stops by stop number to produce ordered output sorted_stops = sorted(stops.items()) result.append(\\" \\".join([f\\"{bus_id} {arrival_time}\\" for _, (bus_id, arrival_time) in sorted_stops])) return result"},{"question":"def smallest_difference(n, plant_species): Returns the smallest difference between any two plant species numbers in the dataset. Args: n (int): The number of plant species. plant_species (list of int): The numbers of the plant species. Returns: int: The smallest difference between any two plant species numbers. Examples: >>> smallest_difference(5, [8, 1, 4, 2, 9]) 1 >>> smallest_difference(3, [10, 3, 15]) 5","solution":"def smallest_difference(n, plant_species): Returns the smallest difference between any two plant species numbers in the dataset. Args: n (int): The number of plant species. plant_species (list of int): The numbers of the plant species. Returns: int: The smallest difference between any two plant species numbers. # First, sort the list plant_species.sort() # Initialize the smallest difference as infinity min_diff = float('inf') # Iterate through the sorted list to find the smallest difference for i in range(1, n): min_diff = min(min_diff, plant_species[i] - plant_species[i - 1]) return min_diff"},{"question":"def find_parity(n): Determines whether the hidden binary string has an even or odd number of '1's. To ask a query, print \\"? k\\" (without quotes), where k is an integer (1  k  n). Neo will respond with 0 if the number of '1's in the prefix of length k is even, and 1 if it is odd. Once the parity of the entire string is determined, print either \\"EVEN\\" or \\"ODD\\". Example: <Input> >>> n = 5 <Output> ? 3 0 ? 5 1 ODD","solution":"def find_parity(n): Determines whether the hidden binary string has an even or odd number of '1's. print(\\"? 1\\") response = int(input()) last_response = response for k in range(2, min(n, 20) + 1): print(f\\"? {k}\\") response = int(input()) if response != last_response: print(\\"ODD\\") return last_response = response if last_response == 0: print(\\"EVEN\\") else: print(\\"ODD\\")"},{"question":"MOD = 10**9 + 7 def count_symmetric_strings(N): Determine the number of possible symmetric strings of length N using only lowercase English letters, modulo 10^9+7. Parameters: N (int): Length of the symmetric string. Returns: int: The number of possible symmetric strings of length N. >>> count_symmetric_strings(1) 26 >>> count_symmetric_strings(2) 26 >>> count_symmetric_strings(3) 26**2 % (10**9 + 7) >>> count_symmetric_strings(4) 26**2 % (10**9 + 7) pass def solve(T, cases): Determine the number of possible symmetric strings for multiple test cases. Parameters: T (int): The number of test cases. cases (List[int]): A list of lengths for each test case. Returns: List[int]: A list of results for each test case. >>> solve(2, [3, 4]) [26**2 % (10**9 + 7), 26**2 % (10**9 + 7)] >>> solve(5, [1, 2, 3, 4, 5]) [26, 26, 26**2 % (10**9 + 7), 26**2 % (10**9 + 7), 26**3 % (10**9 + 7)] pass","solution":"MOD = 10**9 + 7 def count_symmetric_strings(N): if N % 2 == 0: half_length = N // 2 else: half_length = N // 2 + 1 return pow(26, half_length, MOD) def solve(T, cases): return [count_symmetric_strings(N) for N in cases]"},{"question":"def merge_pages_input(N: int, input_data: List[str]) -> List[int]: Processes the input formatted data for merging the survey responses into a single sorted list. :param N: Number of pages :param input_data: List of strings, each corresponding to a page's responses :return: Combined sorted responses as a single list >>> merge_pages_input(1, [\\"3 1 2 3\\"]) [1, 2, 3] >>> merge_pages_input(3, [\\"3 10 20 30\\", \\"4 5 7 25 29\\", \\"2 1 100\\"]) [1, 5, 7, 10, 20, 25, 29, 30, 100] >>> merge_pages_input(3, [\\"3 1 2 3\\", \\"0\\", \\"2 4 5\\"]) [1, 2, 3, 4, 5] >>> merge_pages_input(2, [\\"3 1 2 3\\", \\"3 1 2 3\\"]) [1, 1, 2, 2, 3, 3] >>> merge_pages_input(2, [\\"2 100000000 200000000\\", \\"2 150000000 250000000\\"]) [100000000, 150000000, 200000000, 250000000] >>> merge_pages_input(4, [\\"2 1 3\\", \\"1 2\\", \\"4 4 5 6 7\\", \\"3 8 9 10\\"]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Your function implementation here","solution":"import heapq def merge_sorted_responses(pages): Merges a list of sorted lists into a single sorted list. :param pages: List of sorted lists :return: A single sorted list with all elements from all input lists min_heap = [] result = [] # Initialize the min_heap with the first element of each page for i in range(len(pages)): if pages[i]: # Ensure the page is not empty heapq.heappush(min_heap, (pages[i][0], i, 0)) # Extract elements from the heap and maintain the sorted order while min_heap: value, list_index, element_index = heapq.heappop(min_heap) result.append(value) if element_index + 1 < len(pages[list_index]): heapq.heappush(min_heap, (pages[list_index][element_index + 1], list_index, element_index + 1)) return result def merge_pages_input(N, input_data): Processes the input formatted data for the merging function. :param N: Number of pages :param input_data: List of strings, each corresponding to a page's responses :return: Combined sorted responses as a single list pages = [] for i in range(N): data = list(map(int, input_data[i].split())) pages.append(data[1:]) # Exclude the first number which is the count of responses return merge_sorted_responses(pages)"},{"question":"def has_pair_with_sum(n: int, target: int, arr: List[int]) -> str: Determines if there are two distinct elements in the array whose sum equals the target. Parameters: n (int): The length of the array target (int): The target sum arr (list): The array of integers Returns: str: \\"YES\\" if there are two distinct elements in the array whose sum equals the target, otherwise \\"NO\\". >>> has_pair_with_sum(6, 9, [1, 3, 4, 6, 7, 8]) 'YES' >>> has_pair_with_sum(5, 15, [1, 2, 3, 4, 5]) 'NO'","solution":"def has_pair_with_sum(n, target, arr): Determines if there are two distinct elements in the array whose sum equals the target. Parameters: n (int): The length of the array target (int): The target sum arr (list): The array of integers Returns: str: \\"YES\\" if there are two distinct elements in the array whose sum equals the target, otherwise \\"NO\\". seen = set() for number in arr: complement = target - number if complement in seen: return \\"YES\\" seen.add(number) return \\"NO\\" # To read input from standard input, uncomment below lines # import sys # input = sys.stdin.read # data = input().split() # n = int(data[0]) # target = int(data[1]) # arr = list(map(int, data[2:])) # print(has_pair_with_sum(n, target, arr))"},{"question":"def can_rearrange_to_palindrome(s: str) -> bool: Determine if the given string can be rearranged to form a palindrome. A string is called a palindrome if it reads the same backward as forward. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. Examples: >>> can_rearrange_to_palindrome(\\"aabb\\") True >>> can_rearrange_to_palindrome(\\"abc\\") False","solution":"def can_rearrange_to_palindrome(s): Determine if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) return odd_count <= 1"},{"question":"def current_movie(n: int, t: int, durations: List[int]) -> Tuple[int, int]: Determine the current movie being watched and the minutes passed since it started. :param n: int, number of movies :param t: int, time in minutes since the marathon started :param durations: list of int, durations of the n movies in minutes :return: tuple of two int, the current movie identifier and the minutes passed since it started >>> current_movie(4, 150, [50, 40, 70, 120]) (3, 60) >>> current_movie(3, 130, [90, 100, 80]) (2, 40)","solution":"def current_movie(n, t, durations): Determine the current movie being watched and the minutes passed since it started. :param n: int, number of movies :param t: int, time in minutes since the marathon started :param durations: list of int, durations of the n movies in minutes :return: tuple of two int, the current movie identifier and the minutes passed since it started elapsed_time = 0 for i in range(n): if elapsed_time + durations[i] > t: return (i+1, t - elapsed_time) elapsed_time += durations[i] return (n, t - elapsed_time + durations[-1])"},{"question":"def max_new_flowers(flowerbeds: List[int]) -> int: Determine the maximum number of new flowers that can be planted without violating the no-adjacent-flowers rule. Here are some test cases to illustrate the expected behavior: >>> max_new_flowers([1, 0, 0, 0, 1]) 1 >>> max_new_flowers([0, 0, 0]) 2 >>> max_new_flowers([1, 0, 0, 0]) 1 >>> max_new_flowers([0]) 1 >>> max_new_flowers([1]) 0 >>> max_new_flowers([0, 0]) 1 >>> max_new_flowers([1, 0, 1, 0, 1, 0, 1]) 0 >>> max_new_flowers([0, 0, 0, 0, 0, 0]) 3","solution":"def max_new_flowers(flowerbeds): Returns the maximum number of new flowers that can be planted without violating the no-adjacent-flowers rule. n = len(flowerbeds) max_flowers = 0 i = 0 while i < n: if flowerbeds[i] == 0: if (i == 0 or flowerbeds[i - 1] == 0) and (i == n - 1 or flowerbeds[i + 1] == 0): max_flowers += 1 flowerbeds[i] = 1 i += 1 # Move to the next position after this slot i += 1 return max_flowers"},{"question":"from collections import deque, defaultdict def find_diameter(N: int, edges: list) -> int: Determine the length of the longest path between any two nodes in a binary tree. Args: N (int): The number of nodes in the tree. edges (list): List of tuples where each tuple (u, v) represents an edge between node u and node v. Returns: int: The length of the longest path in the tree. Examples: >>> find_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> find_diameter(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4","solution":"from collections import deque, defaultdict def find_diameter(N, edges): if N == 1: return 0 def bfs(start): queue = deque([start]) distances = {start: 0} farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in distances: queue.append(neighbor) distances[neighbor] = distances[node] + 1 if distances[neighbor] > distances[farthest_node]: farthest_node = neighbor return farthest_node, distances[farthest_node] graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) u, _ = bfs(1) v, diameter_length = bfs(u) return diameter_length"},{"question":"def canPlantTrees(street: List[int], n: int) -> bool: Determines if it is possible to plant n trees on the street such that no two trees are adjacent. Args: street (List[int]): An array of integers where \`0\` represents an empty spot and \`1\` represents a spot that already has a tree. n (int): The number of trees to plant. Returns: bool: True if it is possible to plant \`n\` trees, False otherwise. Examples: >>> canPlantTrees([1, 0, 0, 0, 1], 1) True >>> canPlantTrees([1, 0, 0, 0, 1], 2) False","solution":"def canPlantTrees(street, n): Returns whether it is possible to plant n trees on the street without any two trees being adjacent. count = 0 length = len(street) for i in range(length): if street[i] == 0: emptyLeft = (i == 0) or (street[i - 1] == 0) emptyRight = (i == length - 1) or (street[i + 1] == 0) if emptyLeft and emptyRight: street[i] = 1 count += 1 if count >= n: return True return count >= n"},{"question":"def min_operations_to_convert(n: int, a: List[int], b: List[int]) -> int: Function to compute the minimum number of operations needed to convert array \`a\` to array \`b\`. :param n: Length of the array \`a\` and \`b\` :param a: List of integers in non-decreasing order :param b: List of integers in non-decreasing order :return: Minimum number of operations required import pytest def test_case_1(): assert min_operations_to_convert(5, [1, 2, 3, 4, 5], [1, 2, 5, 4, 5]) == 1 def test_case_2(): assert min_operations_to_convert(3, [1, 1, 1], [3, 3, 3]) == 3 def test_case_3(): assert min_operations_to_convert(4, [2, 3, 5, 7], [2, 3, 5, 7]) == 0 def test_case_4(): assert min_operations_to_convert(6, [1, 2, 3, 3, 6, 6], [1, 2, 4, 4, 6, 7]) == 3 def test_case_5(): assert min_operations_to_convert(2, [2, 4], [2, 4]) == 0 if __name__ == \\"__main__\\": pytest.main()","solution":"def min_operations_to_convert(n, a, b): Function to compute the minimum number of operations needed to convert array \`a\` to array \`b\`. :param n: Length of the array \`a\` and \`b\` :param a: List of integers in non-decreasing order :param b: List of integers in non-decreasing order :return: Minimum number of operations required operations = 0 for i in range(n): if a[i] != b[i]: operations += 1 return operations # Example usage: # n = 5 # a = [1, 2, 3, 4, 5] # b = [1, 2, 5, 4, 5] # print(min_operations_to_convert(n, a, b)) # Output should be 1"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. >>> roman_to_integer(\\"III\\") == 3 >>> roman_to_integer(\\"IV\\") == 4 >>> roman_to_integer(\\"IX\\") == 9 >>> roman_to_integer(\\"LVIII\\") == 58 >>> roman_to_integer(\\"MCMXCIV\\") == 1994","solution":"def roman_to_integer(roman): Converts a Roman numeral to an integer. Parameters: roman (str): The Roman numeral string. Returns: int: The integer representation of the Roman numeral. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 i = 0 while i < len(roman): if i + 1 < len(roman) and roman_values[roman[i]] < roman_values[roman[i + 1]]: total += roman_values[roman[i + 1]] - roman_values[roman[i]] i += 2 else: total += roman_values[roman[i]] i += 1 return total"},{"question":"def sort_by_absolute_index_difference(t: int, test_cases: List[List[int]]) -> List[List[int]]: Sorts an array such that each element is moved to a position where the absolute difference between the value and the index is minimized. Args: t : int : The number of test cases. test_cases : List[List[int]] : A list containing test cases, where each test case starts with an integer n and followed by n integers. Returns: List[List[int]] : The sorted arrays that satisfy the given condition for each test case. Example: >>> sort_by_absolute_index_difference(2, [[4, 4, 3, 1, 2], [5, 10, -3, 5, 0, 1]]) [[1, 2, 3, 4], [-3, 0, 1, 5, 10]] pass","solution":"def sort_by_absolute_index_difference(t, test_cases): results = [] for case in test_cases: n, array = case[0], case[1:] sorted_array = sorted(array) results.append(sorted_array) return results"},{"question":"def find_minimum_pages(n: int, k: int, pages: List[int]) -> int: Determine the minimum possible value of the maximum number of pages assigned to a student. >>> find_minimum_pages(4, 2, [12, 34, 67, 90]) == 113 >>> find_minimum_pages(5, 3, [10, 20, 30, 40, 50]) == 60 >>> find_minimum_pages(1, 1, [100]) == 100 >>> find_minimum_pages(4, 1, [10, 20, 30, 40]) == 100 >>> find_minimum_pages(5, 5, [10, 20, 30, 40, 50]) == 50 >>> find_minimum_pages(3, 2, [100000, 200000, 300000]) == 300000","solution":"def find_minimum_pages(n, k, pages): Returns the minimum possible value of the maximum number of pages assigned to a student. def is_possible(mid): student_count = 1 current_pages = 0 for page in pages: if current_pages + page > mid: student_count += 1 current_pages = page if student_count > k: return False else: current_pages += page return True low, high = max(pages), sum(pages) result = high while low <= high: mid = (low + high) // 2 if is_possible(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"class ListNode: def __init__(self, val=0): self.val = val self.next = None def is_circular_linked_list(head): Function to check if the linked list is circular. def build_linked_list(node_values, circular_index=None): Function to build a linked list from the given node values. If \`circular_index\` is provided, make the last node point to the node at \`circular_index\`. def test_non_circular_list(): head = build_linked_list([1, 2, 3]) assert not is_circular_linked_list(head), \\"Test case failed for non-circular list [1, 2, 3]\\" def test_circular_list(): head = build_linked_list([10, 20, 30, 40], circular_index=1) assert is_circular_linked_list(head), \\"Test case failed for circular list [10, 20, 30, 40] with circular index 1\\" def test_large_non_circular_list(): head = build_linked_list(list(range(1000))) assert not is_circular_linked_list(head), \\"Test case failed for large non-circular list of 1000 elements\\" def test_large_circular_list(): head = build_linked_list(list(range(1000)), circular_index=500) assert is_circular_linked_list(head), \\"Test case failed for large circular list of 1000 elements with circular index 500\\" def test_single_node_non_circular_list(): head = build_linked_list([1]) assert not is_circular_linked_list(head), \\"Test case failed for single node non-circular list [1]\\" def test_two_node_circular_list(): head = build_linked_list([1, 2], circular_index=0) assert is_circular_linked_list(head), \\"Test case failed for two node circular list [1, 2] with circular index 0\\"","solution":"class ListNode: def __init__(self, val=0): self.val = val self.next = None def is_circular_linked_list(head): Function to check if the linked list is circular. if not head or not head.next: return False slow, fast = head, head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False def parse_input(test_cases): results = [] for case in test_cases: if is_circular_linked_list(case): results.append(\\"CIRCULAR\\") else: results.append(\\"NOT CIRCULAR\\") return results def build_linked_list(node_values, circular_index=None): nodes = [ListNode(val) for val in node_values] for i in range(len(nodes) - 1): nodes[i].next = nodes[i + 1] if circular_index is not None: nodes[-1].next = nodes[circular_index] return nodes[0] # Example input reading and processing def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(T): N = int(lines[index].strip()) index += 1 node_vals = [] for _ in range(N): node_vals.append(int(lines[index].strip())) index += 1 # Let's assume that 1st test case has no circular dependency, # 2nd test case has a circular dependency at index 1 (second node) # and so on for simplicity in this supposed input method. circular_index = None if N > 2 and (N % 2 == 0): # Just a hypothetical pattern for circularity circular_index = 1 head = build_linked_list(node_vals, circular_index) test_cases.append(head) return parse_input(test_cases) # Example usage input_data = 3 3 1 2 3 4 10 20 30 40 5 100 200 300 400 500 output = process_input(input_data) print(output)"},{"question":"def validate_subsequence(arr, subseq): Returns True if subseq is a valid subsequence of arr, otherwise returns False. >>> validate_subsequence([5, 1, 22, 25, 6, -1, 8, 10], [1, 6, -1, 10]) == True >>> validate_subsequence([5, 1, 22, 25, 6, -1, 8, 10], [1, 6, 10, -1]) == False >>> validate_subsequence([1, 2, 3, 4], []) == True >>> validate_subsequence([1, 2, 3, 4], [1, 2, 3, 4]) == True >>> validate_subsequence([1, 2, 3, 4], [4, 3, 2, 1]) == False >>> validate_subsequence([1, 2, 3, 4], [2]) == True >>> validate_subsequence([1, 2, 3, 4], [5]) == False >>> validate_subsequence([1, 2], [1, 2, 3]) == False >>> validate_subsequence([1, 2, 2, 3, 4], [2, 2, 4]) == True","solution":"def validate_subsequence(arr, subseq): Returns True if subseq is a valid subsequence of arr, otherwise returns False. seq_index = 0 for value in arr: if seq_index == len(subseq): break if subseq[seq_index] == value: seq_index += 1 return seq_index == len(subseq)"},{"question":"def can_distribute_orders(n, capacities, m): Determines if all orders can be distributed among warehouses without exceeding their capacities. Parameters: n (int): Number of warehouses. capacities (list of int): List of the capacities of the warehouses. m (int): Number of orders. Returns: str: \\"YES\\" if it's possible to distribute the orders without exceeding capacities, otherwise \\"NO\\". def test_can_distribute_orders_yes(): assert can_distribute_orders(3, [5, 8, 2], 10) == \\"YES\\" assert can_distribute_orders(3, [5, 5, 5], 10) == \\"YES\\" assert can_distribute_orders(2, [10, 5], 10) == \\"YES\\" assert can_distribute_orders(4, [1, 2, 3, 4], 7) == \\"YES\\" def test_can_distribute_orders_no(): assert can_distribute_orders(2, [4, 7], 12) == \\"NO\\" assert can_distribute_orders(3, [3, 3, 3], 10) == \\"NO\\" assert can_distribute_orders(1, [9], 10) == \\"NO\\" assert can_distribute_orders(2, [1, 1], 3) == \\"NO\\"","solution":"def can_distribute_orders(n, capacities, m): Determines if all orders can be distributed among warehouses without exceeding their capacities. Parameters: n (int): Number of warehouses. capacities (list of int): List of the capacities of the warehouses. m (int): Number of orders. Returns: str: \\"YES\\" if it's possible to distribute the orders without exceeding capacities, otherwise \\"NO\\". # Sum of all capacities total_capacity = sum(capacities) # Checking if the total number of orders is within the total capacity if total_capacity >= m: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def count_unique_codes(n: int, codes: List[str]) -> int: Returns the number of unique product codes from the given list of codes. :param n: Integer, number of product codes. :param codes: List of strings, each string is a product code. :return: Integer, count of unique product codes. >>> count_unique_codes(6, [\\"abc123\\", \\"xyz789\\", \\"abc123\\", \\"def456\\", \\"xyz789\\", \\"ghi012\\"]) 2 >>> count_unique_codes(4, [\\"abc123\\", \\"xyz789\\", \\"def456\\", \\"ghi012\\"]) 4 >>> count_unique_codes(4, [\\"abc123\\", \\"abc123\\", \\"xyz789\\", \\"xyz789\\"]) 0 >>> count_unique_codes(6, [\\"abc\\", \\"def\\", \\"abc\\", \\"ghi\\", \\"def\\", \\"jkl\\"]) 2 >>> count_unique_codes(1, [\\"abc123\\"]) 1 >>> count_unique_codes(2, [\\"abc123\\", \\"abc123\\"]) 0","solution":"def count_unique_codes(n, codes): Returns the number of unique product codes from the given list of codes. :param n: Integer, number of product codes. :param codes: List of strings, each string is a product code. :return: Integer, count of unique product codes. from collections import Counter code_counts = Counter(codes) unique_count = sum(1 for count in code_counts.values() if count == 1) return unique_count"},{"question":"def unique_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the sum of all unique numbers in the array for each test case. :param t: Number of test cases :param test_cases: List of test cases, each test case is a tuple (n, array) :returns: List of results, each result is the sum of unique numbers for the corresponding test case >>> unique_sum(3, [(7, [1, 2, 2, 3, 4, 4, 5]), (5, [1, 1, 1, 1, 1]), (6, [2, 2, -1, 3, 3, 0])]) [9, 0, -1] >>> unique_sum(2, [(4, [1, 2, 3, 4]), (3, [7, 7, 7])]) [10, 0] >>> unique_sum(1, [(3, [0, 0, -1])]) [-1] >>> unique_sum(1, [(5, [5, -1, -1, 2, 5])]) [2]","solution":"def unique_sum(t, test_cases): For each test case, calculate the sum of all unique numbers in the given array. :param t: Number of test cases :param test_cases: List of test cases, each test case is a tuple (n, array) :returns: List of results, each result is the sum of unique numbers for the corresponding test case results = [] for n, array in test_cases: from collections import Counter # Calculate the frequency of each number in the array frequency = Counter(array) # Calculate the sum of numbers that occur exactly once unique_sum = sum(num for num, count in frequency.items() if count == 1) # Append the result for the current test case results.append(unique_sum) return results"},{"question":"from typing import List def minCost(n: int, costs: List[List[int]]) -> int: There is a village with n houses arranged in a straight line. Each house can either be painted red, green, or blue. The cost of painting each house with a certain color is different and is represented by a 2D array costs. You have to paint all the houses such that no two adjacent houses have the same color, and you want to minimize the total cost of painting the houses. >>> minCost(3, [[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> minCost(1, [[1, 2, 3]]) 1 >>> minCost(2, [[1, 100, 100], [100, 1, 100]]) 2 >>> minCost(3, [[10, 10, 10], [10, 10, 10], [10, 10, 10]]) 30 >>> minCost(4, [[7, 2, 4], [3, 6, 10], [8, 4, 6], [5, 3, 7]]) 14","solution":"from typing import List def minCost(n: int, costs: List[List[int]]) -> int: if n == 0: return 0 # Initialize the DP table dp = [[0] * 3 for _ in range(n)] # Base case for the first house dp[0][0] = costs[0][0] dp[0][1] = costs[0][1] dp[0][2] = costs[0][2] # Fill the DP table for i in range(1, n): dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2]) dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2]) dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1]) # The answer will be the minimum of the last row of the DP table return min(dp[-1])"},{"question":"def compress_string(s: str) -> str: Compress the string by replacing groups of consecutive repeating characters with the character followed by the number of repetitions. If a character does not repeat, it remains as it is. >>> compress_string(\\"aaabbccddd\\") 'a3b2c2d3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"aabbcc\\") 'a2b2c2'","solution":"def compress_string(s): Compress the string by replacing groups of consecutive repeating characters with the character followed by the number of repetitions. If a character does not repeat, it remains as it is. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed version of the input string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 # Add the last group compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"def capitalize_string(s: str) -> str: Capitalizes each word in a string except for certain exceptions, unless they are the first or last word in the string. :param s: Input string consisting of multiple words. :return: Newly formatted string. exceptions = {\\"and\\", \\"the\\", \\"in\\", \\"of\\", \\"on\\", \\"with\\"} words = s.split() if not words: return \\"\\" # Capitalize the first word if it's an exception words[0] = words[0].capitalize() # Capitalize the last word if it's an exception if len(words) > 1: words[-1] = words[-1].capitalize() # Capitalize all other words that are not exceptions for i in range(1, len(words)-1): if words[i].lower() not in exceptions: words[i] = words[i].capitalize() return ' '.join(words) # Unit Tests def test_capitalize_string_standard_case(): assert capitalize_string(\\"the quick brown fox jumps over the lazy dog\\") == \\"The Quick Brown Fox Jumps Over the Lazy Dog\\" def test_capitalize_string_special_case(): assert capitalize_string(\\"a celebration of life and love\\") == \\"A Celebration of Life and Love\\" def test_capitalize_string_all_exceptions(): assert capitalize_string(\\"and the in of on with\\") == \\"And the in of on With\\" def test_capitalize_string_first_last_exceptions(): assert capitalize_string(\\"of mice and men\\") == \\"Of Mice and Men\\" def test_capitalize_string_empty_string(): assert capitalize_string(\\"\\") == \\"\\" def test_capitalize_string_single_word_exception(): assert capitalize_string(\\"and\\") == \\"And\\" def test_capitalize_string_single_word_non_exception(): assert capitalize_string(\\"hello\\") == \\"Hello\\" def test_capitalize_string_no_exception_words(): assert capitalize_string(\\"hello world this is me\\") == \\"Hello World This Is Me\\" def test_capitalize_string_only_exceptions_in_middle(): assert capitalize_string(\\"a journey through the jungle of amazon\\") == \\"A Journey Through the Jungle of Amazon\\"","solution":"def capitalize_string(s): Capitalizes each word in the string except for certain exceptions, unless they are the first or last word in the string. :param s: Input string consisting of multiple words. :return: Newly formatted string. exceptions = {\\"and\\", \\"the\\", \\"in\\", \\"of\\", \\"on\\", \\"with\\"} words = s.split() if not words: return \\"\\" # Capitalize the first word if it's an exception words[0] = words[0].capitalize() # Capitalize the last word if it's an exception if len(words) > 1: words[-1] = words[-1].capitalize() # Capitalize all other words that are not exceptions for i in range(1, len(words)-1): if words[i].lower() not in exceptions: words[i] = words[i].capitalize() return ' '.join(words)"},{"question":"from typing import List def longest_subsequence_length(n: int, A: List[int], T: int) -> int: Finds the length of the longest subsequence such that all elements are in increasing order and any two consecutive elements have an absolute difference less than or equal to a given threshold T. Args: n : int : length of the list A. A : list of int : the list of integers. T : int : the maximum allowed difference. Returns: int : the length of the longest subsequence. >>> longest_subsequence_length(6, [5, 3, 4, 8, 6, 7], 3) 4 >>> longest_subsequence_length(1, [10], 2) 1 >>> longest_subsequence_length(5, [4, 4, 4, 4, 4], 1) 1 >>> longest_subsequence_length(5, [1, 2, 3, 4, 5], 1) 5 >>> longest_subsequence_length(5, [1, 2, 3, 4, 5], 1000) 5 >>> longest_subsequence_length(5, [1, 10, 20, 30, 40], 2) 1 >>> longest_subsequence_length(7, [10, 22, 9, 33, 21, 50, 41], 12) 4 >>> longest_subsequence_length(5, [10, 1, 2, 3, 30], 3) 3","solution":"def longest_subsequence_length(n, A, T): Finds the length of the longest subsequence such that all elements are in increasing order and any two consecutive elements have an absolute difference less than or equal to a given threshold T. Args: n : int : length of the list A. A : list of int : the list of integers. T : int : the maximum allowed difference. Returns: int : the length of the longest subsequence. if n == 0: return 0 dp = [1] * n # dp[i] will hold the length of the longest subsequence ending with A[i] for i in range(1, n): for j in range(i): if A[j] < A[i] and abs(A[i] - A[j]) <= T: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Read input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) A = list(map(int, data[1:n+1])) T = int(data[n+1]) # Find and print the length of the longest subsequence result = longest_subsequence_length(n, A, T) print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def is_valid_sequence(events: List[str]) -> bool: Determine if the sequence of events is valid. >>> is_valid_sequence([\\"entry\\", \\"exit\\", \\"entry\\", \\"exit\\"]) True >>> is_valid_sequence([\\"exit\\", \\"entry\\"]) False >>> is_valid_sequence([\\"entry\\", \\"entry\\", \\"exit\\"]) True >>> is_valid_sequence([\\"entry\\", \\"exit\\", \\"exit\\"]) False","solution":"from typing import List def is_valid_sequence(events: List[str]) -> bool: entry_count = 0 for event in events: if event == \\"entry\\": entry_count += 1 elif event == \\"exit\\": if entry_count == 0: return False entry_count -= 1 return True"},{"question":"def longest_subarray_with_sum_at_most_k(N: int, K: int, S: str) -> int: Returns the length of the longest contiguous subarray where the sum of its digits is at most K. >>> longest_subarray_with_sum_at_most_k(5, 10, \\"12345\\") 4 >>> longest_subarray_with_sum_at_most_k(3, 6, \\"123\\") 3 >>> longest_subarray_with_sum_at_most_k(1, 0, \\"9\\") 0 >>> longest_subarray_with_sum_at_most_k(4, 6, \\"1234\\") 3 >>> longest_subarray_with_sum_at_most_k(5, 15, \\"12345\\") 5 >>> longest_subarray_with_sum_at_most_k(5, 0, \\"12345\\") 0 >>> longest_subarray_with_sum_at_most_k(1, 1, \\"0\\") 1 >>> longest_subarray_with_sum_at_most_k(1, 1, \\"2\\") 0 >>> longest_subarray_with_sum_at_most_k(5, 3, \\"33333\\") 1 >>> longest_subarray_with_sum_at_most_k(5, 15, \\"11111\\") 5","solution":"def longest_subarray_with_sum_at_most_k(N, K, S): Returns the length of the longest contiguous subarray where the sum of its digits is at most K. max_length = 0 current_sum = 0 start = 0 for end in range(N): current_sum += int(S[end]) while current_sum > K: current_sum -= int(S[start]) start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the string s. >>> longest_word_length(\\"the quick brown fox\\") == 5 >>> longest_word_length(\\"jumps over the lazy dog\\") == 5 >>> longest_word_length(\\"a b cde fghij\\") == 5 >>> longest_word_length(\\"python coding\\") == 6","solution":"def longest_word_length(s): Returns the length of the longest word in the string s. words = s.split() max_length = 0 for word in words: max_length = max(max_length, len(word)) return max_length"},{"question":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane's Algorithm. Args: arr (list): List of integers. Returns: int: Maximum sum of the contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1] * 1000) 1000 >>> max_subarray_sum([-1, 3, -2, 5, -1]) 6","solution":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane's Algorithm. Args: arr (list): List of integers. Returns: int: Maximum sum of the contiguous subarray. max_current = arr[0] max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def is_path_possible(grid: List[List[str]], R: int, C: int) -> str: Determines if there is a path from the top-left to the bottom-right in the grid. Parameters: grid (list of list of str): The grid containing '.' and '*'. R (int): The number of rows in the grid. C (int): The number of columns in the grid. Returns: str: 'YES' if a path exists, 'NO' otherwise. def solve(grid_cases: List[Tuple[int, int, List[List[str]]]]) -> List[str]: For each case, determine if there is a path from (1, 1) to (R, C) and print 'YES' or 'NO'. Parameters: grid_cases (list of tuple): Each tuple contains R, C and the grid respectively. Returns: list of str: 'YES' or 'NO' for each grid case. def test_is_path_possible(): assert is_path_possible([['.', '*', '.'], ['.', '*', '.'], ['.', '.', '.']], 3, 3) == 'YES' assert is_path_possible([['*', '*'], ['.', '*']], 2, 2) == 'NO' assert is_path_possible([['.']], 1, 1) == 'YES' assert is_path_possible([['*']], 1, 1) == 'NO' assert is_path_possible([['.', '.', '.'], ['*', '*', '*'], ['.', '.', '.']], 3, 3) == 'NO' def test_solve(): grid_cases = [ (3, 3, [['.', '*', '.'], ['.', '*', '.'], ['.', '.', '.']]), (2, 2, [['*', '*'], ['.', '*']]), (3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]), (2, 2, [['.', '.'], ['*', '.']]), ] assert solve(grid_cases) == ['YES', 'NO', 'YES', 'YES']","solution":"def is_path_possible(grid, R, C): Determines if there is a path from the top-left to the bottom-right in the grid. Parameters: grid (list of list of str): The grid containing '.' and '*'. R (int): The number of rows in the grid. C (int): The number of columns in the grid. Returns: str: 'YES' if a path exists, 'NO' otherwise. from collections import deque if grid[0][0] == '*' or grid[R-1][C-1] == '*': return 'NO' queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == (R-1, C-1): return 'YES' for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == '.' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return 'NO' def solve(grid_cases): For each case, determine if there is a path from (1, 1) to (R, C) and print 'YES' or 'NO'. Parameters: grid_cases (list of tuple): Each tuple contains R, C and the grid respectively. Returns: list of str: 'YES' or 'NO' for each grid case. results = [] for R, C, grid in grid_cases: results.append(is_path_possible(grid, R, C)) return results"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Given an array arr, returns the minimum number of swaps to sort the array. >>> min_swaps_to_sort([4, 3, 1, 2, 5]) 3 >>> min_swaps_to_sort([1, 3, 5, 2]) 2 >>> min_swaps_to_sort([100]) 0 pass def min_swaps_to_sort_multiple_test_cases(test_cases: List[Dict[str, Any]]) -> List[int]: Given test_cases, where each test case is a dictionary with key 'n' and 'arr', returns a list of results for all test cases. pass # Test cases def test_min_swaps_to_sort(): assert min_swaps_to_sort([4, 3, 1, 2, 5]) == 3 assert min_swaps_to_sort([1, 3, 5, 2]) == 2 assert min_swaps_to_sort([100]) == 0 assert min_swaps_to_sort([2, 8, 5, 3, 9, 4]) == 4 assert min_swaps_to_sort([3, 1, 2]) == 2 def test_min_swaps_to_sort_multiple_test_cases(): test_cases = [ {'n': 5, 'arr': [4, 3, 1, 2, 5]}, {'n': 4, 'arr': [1, 3, 5, 2]}, {'n': 1, 'arr': [100]}, {'n': 6, 'arr': [2, 8, 5, 3, 9, 4]}, {'n': 3, 'arr': [3, 1, 2]} ] expected_results = [3, 2, 0, 4, 2] results = min_swaps_to_sort_multiple_test_cases(test_cases) assert results == expected_results","solution":"def min_swaps_to_sort(arr): Given an array arr, returns the minimum number of swaps to sort the array. n = len(arr) arr_pos = [(arr[i], i) for i in range(n)] arr_pos.sort() visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps def min_swaps_to_sort_multiple_test_cases(test_cases): Given test_cases, where each test case is a dictionary with key 'n' and 'arr', returns a list of results for all test cases. results = [] for test in test_cases: n = test['n'] arr = test['arr'] results.append(min_swaps_to_sort(arr)) return results"},{"question":"from typing import List def min_window_substr(s: str, t: str) -> str: Find the smallest substring in s that contains all the characters in t. If no such substring exists, return an empty string. >>> min_window_substr(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substr(\\"a\\", \\"aa\\") \\"\\" >>> min_window_substr(\\"abcdebcabc\\", \\"abc\\") \\"abc\\" pass","solution":"from collections import Counter, defaultdict def min_window_substr(s, t): if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) # Filter all the characters from s into a new list along with their index. # The filtering is done so that the sliding window can only iterate over the characters that could be part of the solution. filtered_s = [(i, ch) for i, ch in enumerate(s) if ch in dict_t] l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(filtered_s): char = filtered_s[r][1] window_counts[char] += 1 if window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = filtered_s[l][1] end = filtered_s[r][0] start = filtered_s[l][0] if end - start + 1 < ans[0]: ans = (end - start + 1, start, end) window_counts[char] -= 1 if window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def final_position_and_origin(moves: str) -> tuple: Calculate the final position of the robot and determine if it returns to origin. Parameters: moves (str): A string representing the moves made by the robot. Returns: tuple: Final coordinates of the robot and a string \\"YES\\" if the robot returns to origin, otherwise \\"NO\\". >>> final_position_and_origin('UUDDLRLR') (0, 0, \\"YES\\") >>> final_position_and_origin('UDRLUDLR') (0, 0, \\"YES\\") >>> final_position_and_origin('UUUDDDRRLL') (0, 0, \\"YES\\") >>> final_position_and_origin('UUU') (0, 3, \\"NO\\") >>> final_position_and_origin('') (0, 0, \\"YES\\") >>> final_position_and_origin('U') (0, 1, \\"NO\\") >>> final_position_and_origin('D') (0, -1, \\"NO\\") >>> final_position_and_origin('UDLR') (0, 0, \\"YES\\") >>> final_position_and_origin('UUDDLL') (-2, 0, \\"NO\\")","solution":"def final_position_and_origin(moves): Calculate the final position of the robot and determine if it returns to origin. Parameters: moves (str): A string representing the moves made by the robot. Returns: tuple: Final coordinates of the robot and a string \\"YES\\" if the robot returns to origin, otherwise \\"NO\\". x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return (x, y, \\"YES\\" if x == 0 and y == 0 else \\"NO\\")"},{"question":"def single_digit_sum(x: int) -> int: Returns the single-digit sum of the digits of x. >>> single_digit_sum(9875) 2 >>> single_digit_sum(12345) 6 >>> single_digit_sum(0) 0 >>> single_digit_sum(9) 9 >>> single_digit_sum(10) 1 def solve(test_cases: List[int]) -> List[int]: Given a list of test cases, returns the single-digit result for each test case. >>> solve([9875, 12345, 0]) [2, 6, 0] >>> solve([5, 25, 123]) [5, 7, 6] >>> solve([999, 10000, 11111]) [9, 1, 5]","solution":"def single_digit_sum(x): Returns the single-digit sum of the digits of x. while x >= 10: x = sum(int(digit) for digit in str(x)) return x def solve(test_cases): results = [] for x in test_cases: results.append(single_digit_sum(x)) return results"},{"question":"from typing import List, Union def determine_winners(N: int, M: int, time_limits: List[int], participants_times: List[List[int]]) -> Union[List[int], List[str]]: Determines which participants successfully completed all the challenges within the time limits. Args: N : int : Number of participants M : int : Number of challenges time_limits : List[int] : List of time limits for each challenge participants_times : List[List[int]] : Times taken by each participant for each challenge Returns: List[int] or List[str] : List of participant numbers who successfully completed all challenges or [\\"No Winners\\"] if none. # Unit tests def test_single_winner(): N = 3 M = 4 time_limits = [10, 12, 20, 15] participants_times = [ [8, 10, 18, 12], [9, 11, 25, 14], [12, 14, 19, 13] ] assert determine_winners(N, M, time_limits, participants_times) == [1] def test_no_winners(): N = 2 M = 3 time_limits = [10, 20, 30] participants_times = [ [11, 19, 28], [9, 22, 29] ] assert determine_winners(N, M, time_limits, participants_times) == [\\"No Winners\\"] def test_all_winners(): N = 3 M = 2 time_limits = [10, 15] participants_times = [ [8, 14], [9, 15], [10, 12] ] assert determine_winners(N, M, time_limits, participants_times) == [1, 2, 3] def test_edge_case_all_times_at_limits(): N = 2 M = 2 time_limits = [10, 20] participants_times = [ [10, 20], [9, 19] ] assert determine_winners(N, M, time_limits, participants_times) == [1, 2] def test_mixed_case(): N = 4 M = 3 time_limits = [5, 15, 25] participants_times = [ [5, 15, 26], [4, 12, 23], [3, 13, 20], [6, 14, 24] ] assert determine_winners(N, M, time_limits, participants_times) == [2, 3]","solution":"def determine_winners(N, M, time_limits, participants_times): Determines which participants successfully completed all the challenges within the time limits. Args: N : int : Number of participants M : int : Number of challenges time_limits : List[int] : List of time limits for each challenge participants_times : List[List[int]] : Times taken by each participant for each challenge Returns: List[int] : List of participant numbers who successfully completed all challenges winners = [] for i in range(N): if all(participants_times[i][j] <= time_limits[j] for j in range(M)): winners.append(i + 1) return winners if winners else [\\"No Winners\\"]"},{"question":"def divide_teams(employees: int, teams: int) -> str: Determines if employees can be divided into teams with equal members. Parameters: employees (int): Total number of employees. teams (int): Number of desired teams. Returns: str: \\"YES <members_per_team>\\" if division is possible; \\"NO\\" otherwise. >>> divide_teams(10, 2) \\"YES 5\\" >>> divide_teams(10, 3) \\"NO\\" from solution import divide_teams def test_divide_teams_even_division(): assert divide_teams(10, 2) == \\"YES 5\\" assert divide_teams(9, 3) == \\"YES 3\\" def test_divide_teams_uneven_division(): assert divide_teams(10, 3) == \\"NO\\" assert divide_teams(12, 5) == \\"NO\\" def test_divide_teams_one_employee(): assert divide_teams(1, 1) == \\"YES 1\\" def test_divide_teams_more_teams_than_employees(): assert divide_teams(5, 10) == \\"NO\\" assert divide_teams(1, 2) == \\"NO\\" def test_divide_teams_large_numbers(): assert divide_teams(10**9, 10**6) == \\"YES 1000\\" assert divide_teams(10**9, 10**6 + 1) == \\"NO\\"","solution":"def divide_teams(employees, teams): Determines if employees can be divided into teams with equal members. Parameters: employees (int): Total number of employees. teams (int): Number of desired teams. Returns: str: \\"YES <members_per_team>\\" if division is possible; \\"NO\\" otherwise. if employees % teams == 0: return \\"YES \\" + str(employees // teams) else: return \\"NO\\""},{"question":"def gate_opening_time(n): Returns the gate opening time in HH:MM:SS format for the nth day. pass def process_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] for i in range(1, T + 1): n = int(data[i]) results.append(gate_opening_time(n)) for result in results: print(result)","solution":"def gate_opening_time(n): Returns the gate opening time in HH:MM:SS format for the nth day. seconds = n - 1 hours = seconds // 3600 minutes = (seconds % 3600) // 60 seconds = seconds % 3600 % 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\" def process_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] for i in range(1, T + 1): n = int(data[i]) results.append(gate_opening_time(n)) for result in results: print(result)"},{"question":"def inventory_check(n: int, counts: List[int]) -> str: Determines if any product is out of stock. Parameters: n (int): the number of products counts (list of int): the inventory counts of the products Returns: str: \\"In Stock\\" if all products are in stock, otherwise \\"Out of Stock\\" >>> inventory_check(5, [10, 5, 3, 12, 7]) 'In Stock' >>> inventory_check(4, [5, 0, 2, 8]) 'Out of Stock' >>> inventory_check(3, [0, 0, 0]) 'Out of Stock'","solution":"def inventory_check(n, counts): Determines if any product is out of stock. Parameters: n (int): the number of products counts (list of int): the inventory counts of the products Returns: str: \\"In Stock\\" if all products are in stock, otherwise \\"Out of Stock\\" for count in counts: if count == 0: return \\"Out of Stock\\" return \\"In Stock\\""},{"question":"import math def unique_configurations(N: int, M: int) -> int: Calculate the number of unique configurations of books on the bookshelf. :param N: Number of rows :param M: Number of columns :return: Number of unique configurations >>> unique_configurations(2, 2) 24 >>> unique_configurations(1, 3) 6","solution":"import math def unique_configurations(N, M): Calculate the number of unique configurations of books on the bookshelf. :param N: Number of rows :param M: Number of columns :return: Number of unique configurations total_books = N * M return math.factorial(total_books)"},{"question":"def max_delivered_messages(n: int, m: int, delivery_times: List[int], schedule: List[int]) -> int: Determine the maximum number of messages that can be delivered within the given schedule. Args: n (int): The number of messages. m (int): The length of the schedule. delivery_times (List[int]): The delivery times of the messages. schedule (List[int]): The schedule of the system where 1 indicates online and 0 indicates offline. Returns: int: The maximum number of messages that can be delivered. Examples: >>> max_delivered_messages(3, 10, [4, 2, 5], [1, 1, 0, 0, 1, 1, 1, 0, 0, 1]) 2 >>> max_delivered_messages(3, 10, [4, 2, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 0 from typing import List def test_sample_case(): assert max_delivered_messages(3, 10, [4, 2, 5], [1, 1, 0, 0, 1, 1, 1, 0, 0, 1]) == 2 def test_no_online_time(): assert max_delivered_messages(3, 10, [4, 2, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 0 def test_exact_online_slots(): assert max_delivered_messages(2, 5, [2, 3], [1, 1, 1, 1, 1]) == 2 def test_more_messages_than_online_slots(): assert max_delivered_messages(4, 5, [2, 2, 2, 2], [1, 1, 1, 1, 1]) == 2 def test_less_messages_than_online_slots(): assert max_delivered_messages(2, 10, [3, 2], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1]) == 2","solution":"def max_delivered_messages(n, m, delivery_times, schedule): delivery_times.sort() online_slots = [idx for idx, status in enumerate(schedule) if status == 1] if len(online_slots) == 0: return 0 delivered_count = 0 pt = 0 for t in delivery_times: if pt + t <= len(online_slots): delivered_count += 1 pt += t # move the pointer to the next available online slot else: break return delivered_count"},{"question":"def max_profit(prices): Calculate the maximum possible profit from a single buy and sell transaction. If no profit is possible, return 0. :param prices: List of integers representing stock prices on different days. :return: Integer representing the maximum possible profit. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Calculate the maximum possible profit from a single buy and sell transaction. If no profit is possible, return 0. :param prices: List of integers representing stock prices on different days. :return: Integer representing the maximum possible profit. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price - min_price > max_profit: max_profit = price - min_price if price < min_price: min_price = price return max_profit"},{"question":"def find_unsorted_subarray(nums): Given an unsorted array of integers, return the shortest subarray such that sorting it results in the entire array being sorted. Parameters: nums (List[int]): The input list of integers. Returns: Tuple[int, int]: The start and end indices of the smallest such subarray that, when sorted, makes the whole array sorted. If the array is already sorted, returns (-1, -1). >>> find_unsorted_subarray([1, 2, 3, 4]) (-1, -1) >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) (1, 5) >>> find_unsorted_subarray([5, 4, 3, 2, 1]) (0, 4) >>> find_unsorted_subarray([1]) (-1, -1) >>> find_unsorted_subarray([1, 3, 2, 2, 2]) (1, 4) >>> find_unsorted_subarray([1, 1, 1, 1, 1]) (-1, -1)","solution":"def find_unsorted_subarray(nums): Given an unsorted array of integers, return the shortest subarray such that sorting it results in the entire array being sorted. Parameters: nums (List[int]): The input list of integers. Returns: Tuple[int, int]: The start and end indices of the smallest such subarray that, when sorted, makes the whole array sorted. If the array is already sorted, returns (-1, -1). n = len(nums) if n <= 1: return (-1, -1) start, end = -1, -1 for i in range(1, n): if nums[i] < nums[i - 1]: start = i - 1 break if start == -1: return (-1, -1) for j in range(n - 2, -1, -1): if nums[j] > nums[j + 1]: end = j + 1 break min_val = min(nums[start:end+1]) max_val = max(nums[start:end+1]) for i in range(0, start): if nums[i] > min_val: start = i break for j in range(n - 1, end, -1): if nums[j] < max_val: end = j break return (start, end)"},{"question":"def rotate_and_check(n, m, k, a, s): Rotate array a k times to the right and check if the sum of the first m elements is greater than s. Args: n (int): The size of the array a. m (int): The number of elements to sum after rotating. k (int): The number of times to rotate the array. a (List[int]): The array of elements. s (int): The integer to compare the sum against. Returns: str: \\"Yes\\" if the sum of the first m elements of rotated array a is greater than s, otherwise \\"No\\". >>> rotate_and_check(6, 3, 2, [1, 2, 3, 4, 5, 6], 12) \\"No\\" >>> rotate_and_check(5, 2, 0, [4, 5, 1, 2, 3], 6) \\"Yes\\" >>> rotate_and_check(4, 3, 1, [9, 8, 7, 6], 20) \\"Yes\\" def handle_multiple_tests(test_cases): Handle multiple test cases to rotate and check the array. Args: test_cases (List[Tuple[int, int, int, List[int], int]]): List of tuples containing the test case parameters. Returns: List[str]: List of results for each test case - \\"Yes\\" or \\"No\\". >>> handle_multiple_tests([(6, 3, 2, [1, 2, 3, 4, 5, 6], 12), (5, 2, 0, [4, 5, 1, 2, 3], 6), (4, 3, 1, [9, 8, 7, 6], 20)]) [\\"No\\", \\"Yes\\", \\"Yes\\"] def test_rotate_and_check(): test_cases = [ (6, 3, 2, [1, 2, 3, 4, 5, 6], 12), # Expected output: \\"No\\" (5, 2, 0, [4, 5, 1, 2, 3], 6), # Expected output: \\"Yes\\" (4, 3, 1, [9, 8, 7, 6], 20), # Expected output: \\"Yes\\" (7, 2, 3, [7, 8, 9, 10, 11, 12, 13], 20), # Expected output: \\"Yes\\" (3, 1, 10000, [1, 2, 3], 0), # Expected output: \\"Yes\\" ] expected_results = [ \\"No\\", \\"Yes\\", \\"Yes\\", \\"Yes\\", \\"Yes\\" ] for i, test in enumerate(test_cases): assert rotate_and_check(*test) == expected_results[i] def test_handle_multiple_tests(): test_cases = [ (6, 3, 2, [1, 2, 3, 4, 5, 6], 12), (5, 2, 0, [4, 5, 1, 2, 3], 6), (4, 3, 1, [9, 8, 7, 6], 20) ] expected_results = [\\"No\\", \\"Yes\\", \\"Yes\\"] assert handle_multiple_tests(test_cases) == expected_results","solution":"def rotate_and_check(n, m, k, a, s): # Rotate array \`a\` \`k\` times to the right k = k % n # Handle cases where k >= n rotated_a = a[-k:] + a[:-k] # Sum of the first \`m\` elements of the rotated array sum_first_m = sum(rotated_a[:m]) # Check if sum is greater than \`s\` return 'Yes' if sum_first_m > s else 'No' def handle_multiple_tests(test_cases): results = [] for test_case in test_cases: n, m, k, a, s = test_case result = rotate_and_check(n, m, k, a, s) results.append(result) return results"},{"question":"def min_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. >>> min_distance(\\"kitten\\", \\"sitting\\") # 3 >>> min_distance(\\"flaw\\", \\"lawn\\") # 2 >>> min_distance(\\"intention\\", \\"execution\\") # 5","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, all characters of s2 need to be inserted elif j == 0: dp[i][j] = i # If s2 is empty, all characters of s1 need to be removed elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"from typing import List, Tuple def classify_students(heights: List[int]) -> Tuple[int, int, int]: Classify students into height categories based on given heights. Short: < 150 cm Average: 150 cm to 170 cm (inclusive) Tall: > 170 cm Args: heights (List[int]): List of student heights. Returns: Tuple[int, int, int]: A tuple containing the count of Short, Average, and Tall students respectively. >>> classify_students([145, 160, 175]) (1, 1, 1) >>> classify_students([135, 150, 165, 180]) (1, 2, 1) pass def process_datasets(datasets: List[List[int]]) -> List[Tuple[int, int, int]]: Process multiple datasets and classify students in each dataset. Args: datasets (List[List[int]]): List of datasets, where each dataset is a list of student heights. Returns: List[Tuple[int, int, int]]: List of tuples, each tuple contains the count of Short, Average, and Tall students for each dataset. >>> process_datasets([[145, 160, 175], [135, 150, 165, 180]]) [(1, 1, 1), (1, 2, 1)] pass","solution":"def classify_students(heights): short_count = 0 average_count = 0 tall_count = 0 for height in heights: if height < 150: short_count += 1 elif height <= 170: average_count += 1 else: tall_count += 1 return short_count, average_count, tall_count def process_datasets(datasets): results = [] for heights in datasets: results.append(classify_students(heights)) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determines if a binary tree is symmetric. >>> isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3)))) == True >>> isSymmetric(TreeNode(1, TreeNode(2, None, TreeNode(3)), TreeNode(2, None, TreeNode(3)))) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determines if a binary tree is symmetric. if not root: return True def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) return isMirror(root.left, root.right)"},{"question":"def minRemovals(s: str) -> int: Given a string consisting of only characters 'a' and 'b', remove the minimum number of characters so that the remaining string contains no consecutive identical characters. >>> minRemovals(\\"aabb\\") 2 >>> minRemovals(\\"abab\\") 0 >>> minRemovals(\\"aaaa\\") 3","solution":"def minRemovals(s: str) -> int: # Initialize the variable to count the removals removals = 0 # Start traversing the string from the second character for i in range(1, len(s)): # Check if the current character is the same as the previous one if s[i] == s[i - 1]: # If it is, increment the removal counter removals += 1 return removals"},{"question":"def rotate_list(n: int, lst: List[int], k: int) -> List[int]: Rotates a list to the right by k steps. Args: n (int): Number of elements in the list. lst (list of int): List to be rotated. k (int): Number of steps to rotate the list. Returns: list of int: Rotated list. >>> rotate_list(5, [1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_list(3, [-1, -100, 3], 4) == [3, -1, -100] >>> rotate_list(4, [10, 20, 30, 40], 0) == [10, 20, 30, 40] >>> rotate_list(1, [999], 3) == [999] >>> rotate_list(4, [1, 2, 3, 4], 1001) == [4, 1, 2, 3] >>> rotate_list(3, [-1, -2, -3], 1) == [-3, -1, -2]","solution":"def rotate_list(n, lst, k): Rotates a list to the right by k steps. Args: n (int): Number of elements in the list. lst (list of int): List to be rotated. k (int): Number of steps to rotate the list. Returns: list of int: Rotated list. if n == 0: return lst k = k % n # Normalize k to be within the length of the list if k == 0: return lst # No rotation needed return lst[-k:] + lst[:-k]"},{"question":"def min_cost_to_balance_string(N: int, S: str) -> int: Find the minimum cost required to transform the string into a balanced string, such that each of 'A', 'B', and 'C' appears the same number of times in the string. Parameters: - N: int, length of string - S: str, input string consisting of 'A', 'B', and 'C' Returns: int, minimum cost required to balance the string >>> min_cost_to_balance_string(6, \\"AAABBB\\") 2 >>> min_cost_to_balance_string(3, \\"ABC\\") 0 >>> min_cost_to_balance_string(6, \\"AAAAAA\\") 4 >>> min_cost_to_balance_string(9, \\"AAABBBCCC\\") 0 >>> min_cost_to_balance_string(9, \\"AAABBCCCC\\") 1 >>> min_cost_to_balance_string(9, \\"AAABBBBAA\\") 3","solution":"def min_cost_to_balance_string(N, S): # count occurrences of A, B, and C count_A = S.count('A') count_B = S.count('B') count_C = S.count('C') # the target number each character should have to be balanced target = N // 3 # calculate excesses and deficits excess_A = max(0, count_A - target) excess_B = max(0, count_B - target) excess_C = max(0, count_C - target) deficit_A = max(0, target - count_A) deficit_B = max(0, target - count_B) deficit_C = max(0, target - count_C) # the total cost is the sum of all adjustments needed total_cost = excess_A + excess_B + excess_C return total_cost"},{"question":"def can_start_cycle_tour(V, E, edges): Determines if there's a point from which Marta can start a cycle tour and return to the same point after visiting some or all other waypoints at least once. Args: V (int): Number of waypoints. E (int): Number of trails. edges (List[Tuple[int, int]]): List of directed trails between waypoints. Returns: str: \\"YES\\" if such a cycle exists, otherwise \\"NO\\". >>> can_start_cycle_tour(4, 5, [(1, 2), (2, 3), (3, 4), (4, 2), (4, 1)]) 'YES' >>> can_start_cycle_tour(4, 3, [(1, 2), (2, 3), (3, 4)]) 'NO' pass","solution":"def can_start_cycle_tour(V, E, edges): from collections import defaultdict, deque def has_cycle(graph, V): indegree = [0] * V for u in graph: for v in graph[u]: indegree[v] += 1 queue = deque([i for i in range(V) if indegree[i] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for v in graph[node]: indegree[v] -= 1 if indegree[v] == 0: queue.append(v) return count != V graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) # converting 1-indexed input to 0-indexed reverse_graph = defaultdict(list) for u in graph: for v in graph[u]: reverse_graph[v].append(u) for i in range(V): if has_cycle(graph, V) and has_cycle(reverse_graph, V): return \\"YES\\" return \\"NO\\""},{"question":"def min_barriers(M: int, N: int, garden: List[List[int]]) -> int: Calculate the minimum number of barriers needed to enclose all plants so that no plant can spread further. Args: M (int): Number of rows in the garden grid. N (int): Number of columns in the garden grid. garden (List[List[int]]): The garden grid represented as a list of lists of integers, where 1 denotes a plant, and 0 denotes an empty cell. Returns: int: The minimum number of barriers needed. Examples: >>> min_barriers(3, 3, [[0, 1, 0], [1, 0, 0], [0, 0, 1]]) 6 >>> min_barriers(4, 4, [[0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1]]) 12 >>> min_barriers(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_barriers(2, 2, [[1, 1], [1, 1]]) 0 def main(input_string: str) -> int: Parse the input string and pass it to the min_barriers function. Args: input_string (str): The input string containing the dimensions of the garden and the garden grid. Returns: int: The result from the min_barriers function. Examples: >>> main(\\"3 3n0 1 0n1 0 0n0 0 1\\") 6","solution":"def min_barriers(M, N, garden): from collections import deque def is_valid(i, j): return 0 <= i < M and 0 <= j < N and garden[i][j] == 0 def get_neighbors(i, j): neighbors = [] for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if is_valid(ni, nj): neighbors.append((ni, nj)) return neighbors barriers = 0 visited = [[False]*N for _ in range(M)] queue = deque() for i in range(M): for j in range(N): if garden[i][j] == 1 and not visited[i][j]: visited[i][j] = True queue.append((i, j)) while queue: ci, cj = queue.popleft() for ni, nj in get_neighbors(ci, cj): if not visited[ni][nj]: visited[ni][nj] = True barriers += 1 queue.append((ni, nj)) return barriers # Function to convert input to the required format and run the main logic def main(input_string): lines = input_string.splitlines() M, N = map(int, lines[0].split()) garden = [list(map(int, line.split())) for line in lines[1:]] return min_barriers(M, N, garden)"},{"question":"def optimal_ride_sharing(m, n, p, passenger_routes): Distribute passengers among the available cars to minimize the total distance traveled. Args: m (int): Number of cars. n (int): Maximum number of passengers each car can take. p (int): Number of passengers. passenger_routes (List[Tuple[int, int]]): List of start and end points for each passenger. Returns: str: A multi-line string where the first line is the minimum total distance traveled with exactly one decimal place. The following m lines describe the distribution of passengers among the cars. Examples: >>> m = 3 >>> n = 2 >>> p = 6 >>> passenger_routes = [(1, 5), (2, 6), (3, 8), (4, 7), (5, 9), (6, 10)] >>> print(optimal_ride_sharing(m, n, p, passenger_routes)) 15.0 2 1 2 2 3 4 2 5 6 >>> m = 2 >>> n = 3 >>> p = 5 >>> passenger_routes = [(10, 20), (25, 30), (35, 40), (5, 15), (45, 50)] >>> print(optimal_ride_sharing(m, n, p, passenger_routes)) 35.0 3 1 2 4 2 3 5","solution":"def optimal_ride_sharing(m, n, p, passenger_routes): from itertools import permutations import math # Function to calculate distance for a car covering certain passengers def calculate_car_distance(passenger_indices): if not passenger_indices: return 0 min_start = min(passenger_routes[i][0] for i in passenger_indices) max_end = max(passenger_routes[i][1] for i in passenger_indices) return max_end - min_start # Function to distribute passengers among cars def distribute_passengers(): passenger_indices = list(range(p)) min_total_distance = math.inf best_distribution = None for perm in permutations(passenger_indices): current_distribution = [list() for _ in range(m)] index = 0 for i in range(m): for _ in range(n): if index < p: current_distribution[i].append(perm[index]) index += 1 total_distance = sum(calculate_car_distance(car) for car in current_distribution) if total_distance < min_total_distance: min_total_distance = total_distance best_distribution = current_distribution return min_total_distance, best_distribution min_total_distance, best_distribution = distribute_passengers() # Prepare output output = [] output.append(f\\"{min_total_distance:.1f}\\") for car in best_distribution: output.append(f\\"{len(car)} \\" + \\" \\".join(str(i + 1) for i in car)) return 'n'.join(output)"},{"question":"def is_divisible(B: int, C: int) -> str: Given two integers, B and C, check if B is divisible by C. If B is divisible by C, returns 'Yes'; otherwise, returns 'No'. >>> is_divisible(10, 5) 'Yes' >>> is_divisible(10, 3) 'No'","solution":"def is_divisible(B, C): Checks if B is divisible by C and returns 'Yes' if true, otherwise 'No'. if B % C == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def total_weights(M, C, packages): Given the number of cities M, the number of packages C, and a list of tuples with each tuple containing (city_index, weight), return the total weight for each city from 1 to M. >>> total_weights(5, 4, [(3, 500), (2, 300), (4, 700), (1, 200)]) [200, 300, 500, 700, 0] >>> total_weights(7, 5, [(2, 400), (5, 800), (1, 600), (6, 100), (7, 300)]) [600, 400, 0, 0, 800, 100, 300] >>> total_weights(3, 3, [(1, 50), (2, 100), (3, 150)]) [50, 100, 150] >>> total_weights(4, 6, [(4, 200), (3, 300), (2, 100), (1, 400), (1, 200), (3, 100)]) [600, 100, 400, 200] >>> total_weights(5, 0, []) [0, 0, 0, 0, 0] >>> total_weights(3, 3, [(1, 50), (1, 100), (1, 150)]) [300, 0, 0] >>> total_weights(100000, 3, [(1, 1000000000000), (100000, 1000000000000), (50000, 1000000000000)]) [1000000000000 if i in [0, 49999, 99999] else 0 for i in range(100000)]","solution":"def total_weights(M, C, packages): Given the number of cities M, the number of packages C, and a list of tuples with each tuple containing (city_index, weight), return the total weight for each city from 1 to M. # Initialize an array to store the total weight for each city city_weights = [0] * M # Iterate through the packages to accumulate the weight for each city for city_index, weight in packages: city_weights[city_index - 1] += weight return city_weights"},{"question":"def maximumProduct(nums: List[int]) -> int: Returns the maximum product of any three distinct integers from the list nums. >>> maximumProduct([1, 10, 2, 6, 5, 3]) 300 >>> maximumProduct([-10, -10, 5, 2]) 500 # Unit test def test_maximumProduct(): assert maximumProduct([1, 10, 2, 6, 5, 3]) == 300 assert maximumProduct([-10, -10, 5, 2]) == 500 assert maximumProduct([1, 2, 3]) == 6 # Only three elements assert maximumProduct([-1, -2, -3, -4]) == -6 # All negative assert maximumProduct([0, -1, 3, 100, -70, -50]) == 350000 # Mixed with zero assert maximumProduct([1, 1, 1, 1]) == 1 # Duplicates but only 3 needed","solution":"def maximumProduct(nums): Returns the maximum product of any three distinct integers from the list nums. :param nums: List[int] - list of integers :return: int - maximum product of any three distinct integers nums.sort() # The maximum product can be obtained in two ways: # 1. Product of the three largest numbers max1 = nums[-1] * nums[-2] * nums[-3] # 2. Product of the two smallest numbers (which would be negative) and the largest number max2 = nums[0] * nums[1] * nums[-1] return max(max1, max2)"},{"question":"def sort_logs(logs): Sort the given log entries according to the specified rules. pass def process_input(T, test_cases): Process the input and return the sorted log entries for each test case. >>> T = 1 >>> test_cases = [ ... (5, [ ... \\"a1 9 2 3 1\\", ... \\"g1 Act car\\", ... \\"zo4 4 7\\", ... \\"ab1 off KEY dog\\", ... \\"a8 act zoo\\" ... ]) ... ] >>> process_input(T, test_cases) [ [ \\"g1 Act car\\", \\"a8 act zoo\\", \\"ab1 off KEY dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\" ] ] from solution import sort_logs, process_input def test_sort_logs_mixed(): logs = [ \\"a1 9 2 3 1\\", \\"g1 Act car\\", \\"zo4 4 7\\", \\"ab1 off KEY dog\\", \\"a8 act zoo\\" ] expected = [ \\"g1 Act car\\", \\"a8 act zoo\\", \\"ab1 off KEY dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\" ] assert sort_logs(logs) == expected def test_sort_logs_all_words(): logs = [ \\"i1 heh\\", \\"j1 hee\\", \\"z1 zee\\", \\"z2 ack\\" ] expected = [ \\"z2 ack\\", \\"j1 hee\\", \\"i1 heh\\", \\"z1 zee\\" ] assert sort_logs(logs) == expected def test_sort_logs_all_numbers(): logs = [ \\"r1 3 4\\", \\"q3 7 1\\", \\"k2 5 8\\" ] expected = [ \\"r1 3 4\\", \\"q3 7 1\\", \\"k2 5 8\\" ] assert sort_logs(logs) == expected def test_process_input_single_case(): T = 1 test_cases = [ (5, [ \\"a1 9 2 3 1\\", \\"g1 Act car\\", \\"zo4 4 7\\", \\"ab1 off KEY dog\\", \\"a8 act zoo\\" ]) ] expected = [ [ \\"g1 Act car\\", \\"a8 act zoo\\", \\"ab1 off KEY dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\" ] ] assert process_input(T, test_cases) == expected def test_process_input_multiple_cases(): T = 2 test_cases = [ (3, [ \\"a1 alz\\", \\"b2 23 5\\", \\"c3 hello\\" ]), (2, [ \\"a1 9 2 3 1\\", \\"g1 Act car\\" ]) ] expected = [ [ \\"a1 alz\\", \\"c3 hello\\", \\"b2 23 5\\" ], [ \\"g1 Act car\\", \\"a1 9 2 3 1\\" ] ] assert process_input(T, test_cases) == expected","solution":"def sort_logs(logs): Sort the given log entries according to the specified rules. def log_key(log): identifier, rest = log.split(' ', 1) return (0, rest.lower(), identifier) if rest[0].isalpha() else (1,) return sorted(logs, key=log_key) def process_input(T, test_cases): results = [] for i in range(T): N, logs = test_cases[i] sorted_logs = sort_logs(logs) results.append(sorted_logs) return results"},{"question":"def min_operations_to_palindrome(t, test_cases): For each test case, calculates the minimum number of operations required to convert the string into a palindrome. Args: t (int): The number of test cases. test_cases (List[str]): A list of strings to be converted. Returns: List[int]: A list of integers representing the minimum number of operations required for each test case. Examples: >>> min_operations_to_palindrome(1, [\\"a\\"]) [0] >>> min_operations_to_palindrome(1, [\\"ab\\"]) [1] >>> min_operations_to_palindrome(1, [\\"abc\\"]) [1]","solution":"def min_operations_to_palindrome(t, test_cases): For each test case, calculates the minimum number of operations required to convert the string into a palindrome. results = [] for s in test_cases: n = len(s) ops = 0 # Compare characters from the start and the end of the string for i in range(n // 2): if s[i] != s[n - 1 - i]: ops += 1 results.append(ops) return results"},{"question":"from typing import List def minimizePaintingCost(costs: List[List[int]]) -> int: Returns the minimum cost to paint all buildings such that no two adjacent buildings have the same color. Params: costs: List[List[int]] - a list of lists where costs[i][j] is the cost of painting the i-th building with the j-th color. Returns: int - the minimum cost of painting all buildings. Example: >>> minimizePaintingCost([[1, 5, 3], [2, 9, 4]]) 5 def test_single_building(): costs = [[1, 2, 3]] assert minimizePaintingCost(costs) == 1 def test_two_buildings(): costs = [[1, 5, 3], [2, 9, 4]] assert minimizePaintingCost(costs) == 5 def test_three_buildings(): costs = [[1, 2, 3], [1, 4, 6], [2, 1, 3]] assert minimizePaintingCost(costs) == 4 def test_min_cost_case(): costs = [[3, 1, 2], [2, 1, 4], [3, 2, 1]] assert minimizePaintingCost(costs) == 4 def test_all_same_cost(): costs = [[5, 5, 5], [5, 5, 5], [5, 5, 5]] assert minimizePaintingCost(costs) == 15","solution":"from typing import List def minimizePaintingCost(costs: List[List[int]]) -> int: Returns the minimum cost to paint all buildings such that no two adjacent buildings have the same color. Params: costs: List[List[int]] - a list of lists where costs[i][j] is the cost of painting the i-th building with the j-th color. Returns: int - the minimum cost of painting all buildings. if not costs: return 0 n = len(costs) # number of buildings k = len(costs[0]) # number of colors dp = costs[0][:] # initialize dp array with the cost of painting the first building with each color for i in range(1, n): new_dp = [0] * k for j in range(k): new_dp[j] = costs[i][j] + min(dp[m] for m in range(k) if m != j) # prev building cost shouldn't be same color dp = new_dp return min(dp)"},{"question":"def find_median(N, scores): Returns the median score from a list of N scores. Parameters: N (int): The number of students. scores (list of int): The scores of the students. Returns: float: The median score. Examples: >>> find_median(5, [55, 70, 85, 90, 82]) 82.0 >>> find_median(6, [30, 40, 20, 50, 60, 70]) 45.0 >>> find_median(1, [50]) 50.0 >>> find_median(4, [20, 20, 20, 20]) 20.0 >>> find_median(5, [1, 2, 3, 4, 5]) 3.0 >>> find_median(6, [1, 2, 3, 4, 5, 6]) 3.5 >>> find_median(5, [3, 1, 5, 4, 2]) 3.0 >>> find_median(8, [8, 7, 6, 5, 4, 3, 2, 1]) 4.5","solution":"def find_median(N, scores): Returns the median score from a list of N scores. Parameters: N (int): The number of students. scores (list of int): The scores of the students. Returns: float: The median score. scores.sort() if N % 2 == 1: # Odd number of scores, return the middle one return float(scores[N // 2]) else: # Even number of scores, return the average of the two middle ones mid1 = scores[N // 2 - 1] mid2 = scores[N // 2] return (mid1 + mid2) / 2.0"},{"question":"def convert_to_title(n: int) -> str: Convert an integer to its corresponding Excel column title. >>> convert_to_title(1) \\"A\\" >>> convert_to_title(28) \\"AB\\" >>> convert_to_title(701) \\"ZY\\"","solution":"def convert_to_title(n: int) -> str: result = [] while n > 0: n -= 1 # Decrease n by 1 to handle 1-based index remainder = n % 26 result.append(chr(65 + remainder)) # Convert to corresponding ASCII character n //= 26 return ''.join(result[::-1]) # Reverse the result and join as string"},{"question":"def max_ones_after_flip(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the maximum number of '1's that can be obtained in the string after performing one flip operation on any non-empty substring for each test case. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer n and a binary string s of length n. Returns: List[int]: A list of integers where each integer is the maximum number of '1's that can be achieved for each test case. Example: >>> max_ones_after_flip(3, [(3, \\"110\\"), (5, \\"01100\\"), (4, \\"0000\\")]) [3, 4, 4]","solution":"def max_ones_after_flip(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] s = test_cases[i][1] current_ones = s.count('1') max_ones = current_ones for j in range(n): for k in range(j, n): flipped = s[:j] + ''.join('1' if x == '0' else '0' for x in s[j:k+1]) + s[k+1:] flipped_ones = flipped.count('1') if flipped_ones > max_ones: max_ones = flipped_ones results.append(max_ones) return results"},{"question":"def min_insertions_to_make_valid(s: str) -> int: Returns the minimum number of insertions needed to make the bracket sequence valid. Args: s (str): The bracket sequence consisting of '(' and ')'. Returns: int: The minimum number of insertions needed. Examples: >>> min_insertions_to_make_valid(\\"()\\") 0 >>> min_insertions_to_make_valid(\\"(()())\\") 0 >>> min_insertions_to_make_valid(\\"(((\\") 3 >>> min_insertions_to_make_valid(\\")))\\") 3 >>> min_insertions_to_make_valid(\\")((\\") 3 >>> min_insertions_to_make_valid(\\"(()\\") 1 >>> min_insertions_to_make_valid(\\"())(\\") 2 >>> min_insertions_to_make_valid(\\")()())(\\") 3 >>> min_insertions_to_make_valid(\\"(((()(()())))(((()\\") 4 >>> min_insertions_to_make_valid(\\"((((((((\\") 8 >>> min_insertions_to_make_valid(\\"))))))))\\") 8","solution":"def min_insertions_to_make_valid(s): Returns the minimum number of insertions needed to make the bracket sequence valid. left_balance = 0 # Tracks excessive '(' needed to be closed right_balance = 0 # Tracks excessive ')' needed to be opened for char in s: if char == '(': left_balance += 1 else: # char == ')' if left_balance > 0: left_balance -= 1 else: right_balance += 1 # Total insertions needed is the sum of excessive '(' and ')' return left_balance + right_balance"},{"question":"def uniqueSorted(s: str) -> str: Given a string, generate a new string that contains the letters of the original string but in sorted order. Each letter can appear only once. Parameters: s (str): input string consisting of only lowercase letters Returns: str: resulting string with unique characters in sorted order Examples: >>> uniqueSorted(\\"banana\\") \\"abn\\" >>> uniqueSorted(\\"geeksforgeeks\\") \\"efgkors\\"","solution":"def uniqueSorted(s): Given a string, generate a new string that contains the letters of the original string but in sorted order. Each letter can appear only once. Parameters: s (str): input string consisting of only lowercase letters Returns: str: resulting string with unique characters in sorted order seen = set() unique_chars = [] for char in s: if char not in seen: seen.add(char) unique_chars.append(char) unique_chars_sorted = sorted(unique_chars) return ''.join(unique_chars_sorted)"},{"question":"class CustomList: Custom data structure to manage a list of integers with specific operations. Operations: - insert(int x): Insert integer \`x\` at the end of the list. - remove(int position): Remove the integer at the specified \`position\`. - multiply(int multiplier): Multiply all elements of the list by \`multiplier\`. - sum(): Retrieve the sum of all elements in the list. Usage: >>> cl = CustomList() >>> cl.insert(1) >>> cl.insert(2) >>> cl.insert(3) >>> print(cl.sum()) 6 >>> cl.multiply(2) >>> print(cl.sum()) 12 >>> cl.remove(1) >>> print(cl.sum()) 8 def __init__(self): pass def insert(self, x): pass def remove(self, position): pass def multiply(self, multiplier): pass def sum(self): pass # Unit tests def test_insert(): cl = CustomList() cl.insert(1) cl.insert(2) cl.insert(3) assert cl.list == [1, 2, 3] assert cl.sum() == 6 def test_remove(): cl = CustomList() cl.insert(1) cl.insert(2) cl.insert(3) cl.remove(1) assert cl.list == [1, 3] assert cl.sum() == 4 cl.remove(5) # out of bounds assert cl.list == [1, 3] assert cl.sum() == 4 def test_multiply(): cl = CustomList() cl.insert(1) cl.insert(2) cl.insert(3) cl.multiply(2) assert cl.list == [2, 4, 6] assert cl.sum() == 12 def test_sum(): cl = CustomList() assert cl.sum() == 0 cl.insert(1) assert cl.sum() == 1 cl.insert(9) assert cl.sum() == 10 cl.remove(0) assert cl.sum() == 9 cl.multiply(3) assert cl.sum() == 27","solution":"class CustomList: def __init__(self): self.list = [] self.total_sum = 0 def insert(self, x): self.list.append(x) self.total_sum += x def remove(self, position): if 0 <= position < len(self.list): self.total_sum -= self.list[position] del self.list[position] def multiply(self, multiplier): self.list = [x * multiplier for x in self.list] self.total_sum *= multiplier def sum(self): return self.total_sum"},{"question":"def can_reorder_non_negative_prefix_sum(n: int, arr: List[int]) -> str: Determines if it's possible to reorder the array such that the sum of every prefix is non-negative. >>> can_reorder_non_negative_prefix_sum(5, [1, 2, -3, 4, -2]) 'YES' >>> can_reorder_non_negative_prefix_sum(3, [-1, -1, -1]) 'NO'","solution":"def can_reorder_non_negative_prefix_sum(n, arr): Determines if it's possible to reorder the array such that the sum of every prefix is non-negative. # Sort the array in descending order arr.sort(reverse=True) prefix_sum = 0 for num in arr: prefix_sum += num if prefix_sum < 0: return \\"NO\\" return \\"YES\\""},{"question":"def assign_weights(edges): Assign the positive weights to the edges such that the sum of the weights of all edges is minimized while maintaining the given shortest paths. Parameters: edges (list of tuple): Each tuple contains three integers (u, v, l) representing an edge between nodes u and v with initial length l. Returns: list of tuple: Output of m lines, each containing three integers (u, v, w). Here, w is the same as the initial length l, to maintain the shortest path lengths. # Write your code here # Example test cases: def test_assign_weights(): edges = [(1, 2, 3), (1, 3, 5), (2, 3, 4), (3, 4, 1), (3, 5, 2), (4, 5, 7)] result = assign_weights(edges) expected = [(1, 2, 3), (1, 3, 5), (2, 3, 4), (3, 4, 1), (3, 5, 2), (4, 5, 7)] assert result == expected def test_assign_weights_two(): edges = [(1, 2, 2), (2, 3, 1), (3, 4, 5), (1, 4, 7)] result = assign_weights(edges) expected = [(1, 2, 2), (2, 3, 1), (3, 4, 5), (1, 4, 7)] assert result == expected def test_assign_weights_one(): edges = [(1, 2, 10), (1, 3, 20), (2, 3, 15)] result = assign_weights(edges) expected = [(1, 2, 10), (1, 3, 20), (2, 3, 15)] assert result == expected","solution":"def assign_weights(edges): Assign the positive weights to the edges such that the sum of the weights of all edges is minimized while maintaining the given shortest paths. Parameters: edges (list of tuple): Each tuple contains three integers (u, v, l) representing an edge between nodes u and v with initial length l. Returns: list of tuple: Output of m lines, each containing three integers (u, v, w). Here, w is the same as the initial length l, to maintain the shortest path lengths. return edges"},{"question":"def exists_subsequence_with_diff_one(n: int, a: List[int]) -> str: Determines if there exists any subsequence of integers such that each element in the subsequence differs from the next by exactly 1. Parameters: n (int): The number of integers in the list. a (list of int): The elements of the list. Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\". Examples: >>> exists_subsequence_with_diff_one(7, [1, 3, 2, 1, 2, 3, 4]) \\"YES\\" >>> exists_subsequence_with_diff_one(5, [8, 5, 6, 7, 8]) \\"YES\\" >>> exists_subsequence_with_diff_one(6, [1, 2, 8, 9, 10, 11]) \\"NO\\"","solution":"def exists_subsequence_with_diff_one(n, a): Determines if there exists any subsequence of integers such that each element in the subsequence differs from the next by exactly 1. Parameters: n (int): The number of integers in the list. a (list of int): The elements of the list. Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\". sorted_a = sorted(set(a)) # Removing duplicates and sorting the list previous = sorted_a[0] for i in range(1, len(sorted_a)): if sorted_a[i] - previous != 1: return \\"NO\\" previous = sorted_a[i] return \\"YES\\""},{"question":"def count_distinct_substrings(s: str) -> int: Determine the number of distinct substrings of a given string. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"ababa\\") 9 >>> count_distinct_substrings(\\"\\") 0 >>> count_distinct_substrings(\\"a\\") 1","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the input string s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def longest_increasing_subsequence_length(ips: List[str]) -> int: Finds the length of the longest subsequence where each subsequent IP address has more digits than the previous one. >>> longest_increasing_subsequence_length(['19216801']) == 1 >>> longest_increasing_subsequence_length(['123', '456', '789']) == 1 >>> longest_increasing_subsequence_length(['1', '12', '123', '1234']) == 4 >>> longest_increasing_subsequence_length(['1234', '123', '12', '1']) == 1 >>> longest_increasing_subsequence_length(['19216801', '101', '10', '103', '255255255255']) == 3 >>> longest_increasing_subsequence_length(['1', '12', '123', '1234', '5678', '90', '1234567890']) == 5","solution":"def longest_increasing_subsequence_length(ips): Finds the length of the longest subsequence where each subsequent IP address has more digits than the previous one. :param ips: List of IP addresses as strings :return: Length of the longest subsequence n = len(ips) if n == 0: return 0 # Lengths of the longest subsequence ending at each index lis = [1] * n # Compute the lengths for i in range(1, n): for j in range(i): if len(ips[i]) > len(ips[j]): lis[i] = max(lis[i], lis[j] + 1) # Return the maximum value in lis return max(lis) # Example usage if __name__ == \\"__main__\\": n = int(input()) ips = [input().strip() for _ in range(n)] print(longest_increasing_subsequence_length(ips))"},{"question":"from typing import List def lexicographically_smallest_binary_string(binary_string: str) -> str: Converts the given binary string to the lexicographically smallest string with the same number of '1's and '0's. >>> lexicographically_smallest_binary_string(\\"1100\\") '0011' >>> lexicographically_smallest_binary_string(\\"10101\\") '00111' >>> lexicographically_smallest_binary_string(\\"111000\\") '000111' pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results for each case. >>> process_test_cases([\\"1100\\", \\"10101\\", \\"111000\\"]) ['0011', '00111', '000111'] >>> process_test_cases([\\"0\\", \\"1\\", \\"10\\"]) ['0', '1', '01'] pass","solution":"def lexicographically_smallest_binary_string(binary_string): Converts the given binary string to the lexicographically smallest string with the same number of '1's and '0's. count_0 = binary_string.count('0') count_1 = len(binary_string) - count_0 return '0' * count_0 + '1' * count_1 def process_test_cases(test_cases): Processes multiple test cases and returns the results for each case. results = [] for case in test_cases: results.append(lexicographically_smallest_binary_string(case)) return results"},{"question":"def can_reach(x1: int, y1: int, x2: int, y2: int) -> str: Determine if the drone can reach point B (x2, y2) from point A (x1, y1) using only the allowed moves: move right, move up, or stay in place. Args: x1 (int): x-coordinate of point A y1 (int): y-coordinate of point A x2 (int): x-coordinate of point B y2 (int): y-coordinate of point B Returns: str: \\"Yes\\" if the drone can reach point B from point A, otherwise \\"No\\" Examples: >>> can_reach(0, 0, 3, 3) 'Yes' >>> can_reach(1, 1, 1, 0) 'No' >>> can_reach(-2, -2, 1, 1) 'Yes' >>> can_reach(0, 0, 0, 2) 'Yes'","solution":"def can_reach(x1, y1, x2, y2): Returns 'Yes' if the drone can reach point B (x2, y2) from point A (x1, y1) using only moves right, up, or no move. Otherwise, returns 'No'. return \\"Yes\\" if x2 >= x1 and y2 >= y1 else \\"No\\""},{"question":"def student_with_highest_avg_grade(students: List[Dict[str, Any]]) -> str: Returns the name of the student with the highest average grade. If there is a tie, returns the name of the student who appears first in the list. >>> student_with_highest_avg_grade([{\\"name\\": \\"Alice\\", \\"grades\\": [90, 80, 70]}, {\\"name\\": \\"Bob\\", \\"grades\\": [88, 92]}, {\\"name\\": \\"Charlie\\", \\"grades\\": [100, 60, 70]}]) == \\"Bob\\" >>> student_with_highest_avg_grade([{\\"name\\": \\"Alice\\", \\"grades\\": [90, 100, 80]}]) == \\"Alice\\" >>> student_with_highest_avg_grade([{\\"name\\": \\"Alice\\", \\"grades\\": [90, 90]}, {\\"name\\": \\"Bob\\", \\"grades\\": [85, 95]}, {\\"name\\": \\"Charlie\\", \\"grades\\": [90, 90]}]) == \\"Alice\\"","solution":"def student_with_highest_avg_grade(students): Returns the name of the student with the highest average grade. If there is a tie, returns the name of the student who appears first in the list. :param students: List of dictionaries with 'name' and 'grades' :return: Name of the student with the highest average grade max_avg = float('-inf') top_student = \\"\\" for student in students: avg_grade = sum(student['grades']) / len(student['grades']) if avg_grade > max_avg: max_avg = avg_grade top_student = student['name'] elif avg_grade == max_avg and top_student == \\"\\": top_student = student['name'] return top_student"},{"question":"def count_balanced_parentheses_strings(n: int) -> int: Given an integer N, determine the number of unique balanced parentheses strings that can be formed using exactly N characters. Returns 0 if N is odd. Args: n (int): the length of the string of parentheses Returns: int: the number of unique balanced parentheses strings that can be formed with length N Example: >>> count_balanced_parentheses_strings(6) 5 >>> count_balanced_parentheses_strings(5) 0 pass def test_example_case(): assert count_balanced_parentheses_strings(6) == 5 def test_zero_case(): assert count_balanced_parentheses_strings(0) == 1 # Trivially balanced string of length 0 def test_odd_length(): assert count_balanced_parentheses_strings(5) == 0 def test_small_even_length(): assert count_balanced_parentheses_strings(2) == 1 # \\"()\\" def test_invalid_small_odd_length(): assert count_balanced_parentheses_strings(1) == 0 def test_another_small_length(): assert count_balanced_parentheses_strings(4) == 2 # \\"(())\\", \\"()()\\" def test_larger_length(): assert count_balanced_parentheses_strings(8) == 14 # Numerous valid combinations def test_large_even_length(): assert count_balanced_parentheses_strings(10) == 42 def test_large_odd_length(): assert count_balanced_parentheses_strings(501) == 0","solution":"def count_balanced_parentheses_strings(n): if n % 2 != 0: return 0 # We need to find the nth Catalan number def catalan_number(n): if n == 0: return 1 cat = [0] * (n+1) cat[0] = 1 for i in range(1, n+1): cat[i] = 0 for j in range(i): cat[i] += cat[j] * cat[i-j-1] return cat[n] return catalan_number(n // 2)"},{"question":"def maxWaterArea(heights): Finds the maximum area of water that can be trapped between two buildings. Args: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The maximum area of water that can be trapped between two buildings. Example: >>> maxWaterArea([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maxWaterArea([1, 1]) 1","solution":"def maxWaterArea(heights): Finds the maximum area of water that can be trapped between two buildings. Args: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The maximum area of water that can be trapped between two buildings. left = 0 right = len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. Return True if it is a palindrome; otherwise, return False. A palindrome is a word, number, phrase, or other sequence of characters which reads the same backward as forward. >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"Palindrome\\") False >>> is_palindrome(\\"Able was I ere I saw Elba\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123321\\") True >>> is_palindrome(\\"12345\\") False","solution":"def is_palindrome(s: str) -> bool: Returns True if s is a palindrome, considering only alphanumeric characters and ignoring cases. Otherwise, returns False. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List from collections import Counter def most_frequent_integer(test_cases: List[List[int]]) -> List[int]: Given a list of test cases, find the integer that appears most frequently in each list. If there are multiple integers that appear the maximum number of times, return the smallest one among them. Args: test_cases (List[List[int]]): List of test cases where each test case is a list of integers. Returns: List[int]: List of integers representing the most frequently occurring integer for each test case. Example: >>> most_frequent_integer([[1, 2, 2, 3, 1]]) [1] >>> most_frequent_integer([[4, 4, 4, 4]]) [4] def handle_input_output(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 test_cases = [] for _ in range(N): M = int(data[index]) index += 1 test_cases.append(list(map(int, data[index:index + M]))) index += M results = most_frequent_integer(test_cases) for result in results: print(result)","solution":"from collections import Counter def most_frequent_integer(test_cases): results = [] for test in test_cases: count = Counter(test) max_frequency = max(count.values()) most_frequent = min(key for key, freq in count.items() if freq == max_frequency) results.append(most_frequent) return results def handle_input_output(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 test_cases = [] for _ in range(N): M = int(data[index]) index += 1 test_cases.append(list(map(int, data[index:index + M]))) index += M results = most_frequent_integer(test_cases) for result in results: print(result)"},{"question":"def longest_contiguous_subarray(arr): Returns the length of the longest contiguous subarray where all elements are the same. Parameters: arr (List[int]): List of integers representing the array. Returns: int: Length of the longest contiguous subarray where all elements are the same. Examples: >>> longest_contiguous_subarray([1, 1, 2, 2, 2, 3, 3, 4]) 3 >>> longest_contiguous_subarray([7, 7, 7, 7, 7]) 5 >>> longest_contiguous_subarray([1, 2, 2, 3, 3, 3]) 3","solution":"def longest_contiguous_subarray(arr): Returns the length of the longest contiguous subarray where all elements are the same. if not arr: return 0 max_len, current_len = 1, 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"def findDuplicates(nums): Given an integer array nums of size n, where all elements are between 1 and n, and some elements appear twice and others appear once, find the duplicates. Args: nums: List[int] - List of integers. Returns: List[int] - List of duplicates. Examples: >>> findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> findDuplicates([5, 3, 6, 4, 3, 6]) [3, 6]","solution":"def findDuplicates(nums): Given an integer array nums of size n, where all elements are between 1 and n, and some elements appear twice and others appear once, find the duplicates. duplicates = [] for num in nums: # Use the value as the index to check the presence of the number if nums[abs(num) - 1] < 0: # If already negative, it is a duplicate duplicates.append(abs(num)) else: # Mark the number as visited by making it negative nums[abs(num) - 1] *= -1 return duplicates"},{"question":"def final_order_of_participants(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[str]: Determine the final order of participants after processing all cancellations. >>> final_order_of_participants(3, [(5, [1, 2, 3, 4, 5], 2, [2, 4]), (4, [1, 3, 5, 7], 1, [5]), (6, [2, 4, 6, 1, 3, 5], 4, [6, 3, 1, 4])]) ['1 3 5', '1 3 7', '2 5']","solution":"def final_order_of_participants(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] initial_order = test_cases[i][1] K = test_cases[i][2] cancellations = set(test_cases[i][3]) final_order = [participant for participant in initial_order if participant not in cancellations] results.append(\\" \\".join(map(str, final_order))) return results"},{"question":"from typing import List def process_operations(n: int, m: int, operations: List[str]) -> List[int]: Processes a series of operations on a list starting with a single integer n and returns the final state of the list. >>> process_operations(5, 3, [\\"ADD 10\\", \\"REMOVE\\", \\"ADD 3\\"]) [5, 3] >>> process_operations(10, 5, [\\"ADD 20\\", \\"ADD 30\\", \\"REMOVE\\", \\"ADD 40\\", \\"REMOVE\\"]) [10, 20] >>> process_operations(7, 2, [\\"REMOVE\\", \\"REMOVE\\"]) ['EMPTY'] lst = [n] for operation in operations: if operation.startswith(\\"ADD\\"): _, a = operation.split() lst.append(int(a)) elif operation == \\"REMOVE\\": if lst: lst.pop() return lst if lst else [\\"EMPTY\\"]","solution":"def process_operations(n, m, operations): Processes a series of operations on a list starting with a single integer n. Parameters: n (int): The initial integer in the list. m (int): The number of operations to perform. operations (list of str): The list of operations in the form of strings (\\"ADD a\\" or \\"REMOVE\\"). Returns: list: The final state of the list after performing all operations, or [\\"EMPTY\\"] if the list is empty. lst = [n] for operation in operations: if operation.startswith(\\"ADD\\"): _, a = operation.split() lst.append(int(a)) elif operation == \\"REMOVE\\": if lst: lst.pop() return lst if lst else [\\"EMPTY\\"]"},{"question":"from typing import List, Tuple def unique_substrings(s: str, queries: List[Tuple[int, int]]) -> List[bool]: Checks if substrings formed by the indices in the queries contain unique characters. Parameters: s (str): a string of lowercase letters queries (List[Tuple[int, int]]): a list of queries where each query is a tuple (start, end) Returns: List[bool]: A list of booleans indicating if each substring has unique characters Examples: >>> s = \\"abcde\\" >>> queries = [(0, 4), (1, 3), (2, 2)] >>> unique_substrings(s, queries) [True, True, True] >>> s = \\"aab\\" >>> queries = [(0, 1), (0, 2)] >>> unique_substrings(s, queries) [False, False] >>> s = \\"abac\\" >>> queries = [(1, 3), (0, 3)] >>> unique_substrings(s, queries) [True, False]","solution":"from typing import List, Tuple def unique_substrings(s: str, queries: List[Tuple[int, int]]) -> List[bool]: Checks if substrings formed by the indices in the queries contain unique characters. Parameters: s (str): a string of lowercase letters queries (List[Tuple[int, int]]): a list of queries where each query is a tuple (start, end) Returns: List[bool]: A list of booleans indicating if each substring has unique characters result = [] for start, end in queries: substring = s[start:end + 1] if len(substring) == len(set(substring)): result.append(True) else: result.append(False) return result"},{"question":"def can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S): Determines if the robot can deliver a package to the delivery location within the maximum number of steps and return to its starting position. Args: R (int): Number of rows in the city map. C (int): Number of columns in the city map. city_map (List[str]): List of strings representing the city map. sr (int): Starting row of the robot. sc (int): Starting column of the robot. dr (int): Delivery row of the robot. dc (int): Delivery column of the robot. S (int): Maximum number of steps the robot can travel. Returns: str: \\"Success\\" if the robot can deliver and return within the step limit, otherwise \\"Failure\\". def test_can_deliver_and_return_success(): R = 5 C = 5 city_map = [ \\".....\\", \\".X...\\", \\"..X..\\", \\"...X.\\", \\".....\\" ] sr, sc = 0, 0 dr, dc = 4, 4 S = 18 assert can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S) == \\"Success\\" def test_can_deliver_and_return_failure(): R = 5 C = 5 city_map = [ \\".....\\", \\".X...\\", \\"..X..\\", \\"...X.\\", \\".....\\" ] sr, sc = 0, 0 dr, dc = 4, 4 S = 8 assert can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S) == \\"Failure\\" def test_can_deliver_and_return_blocked(): R = 3 C = 3 city_map = [ \\"X.X\\", \\".X.\\", \\"X.X\\", ] sr, sc = 1, 0 dr, dc = 0, 2 S = 10 assert can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S) == \\"Failure\\" def test_can_deliver_and_return_exact_steps(): R = 5 C = 5 city_map = [ \\".....\\", \\".X...\\", \\"..X..\\", \\"...X.\\", \\".....\\" ] sr, sc = 0, 0 dr, dc = 4, 4 S = 18 assert can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S) == \\"Success\\" def test_can_deliver_and_return_with_obstacles(): R = 5 C = 5 city_map = [ \\".....\\", \\".X.X.\\", \\"..X..\\", \\"...X.\\", \\".....\\" ] sr, sc = 0, 0 dr, dc = 4, 4 S = 30 assert can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S) == \\"Success\\"","solution":"from collections import deque def can_deliver_and_return(R, C, city_map, sr, sc, dr, dc, S): Determines if the robot can deliver a package to the delivery location within the maximum number of steps and return to its starting position. Args: R (int): Number of rows in the city map. C (int): Number of columns in the city map. city_map (List[List[str]]): 2D list representing the city map. sr (int): Starting row of the robot. sc (int): Starting column of the robot. dr (int): Delivery row of the robot. dc (int): Delivery column of the robot. S (int): Maximum number of steps the robot can travel. Returns: str: \\"Success\\" if the robot can deliver and return within the step limit, otherwise \\"Failure\\". def bfs(start, goal): Uses BFS to find the shortest path between start and goal positions. queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add((start[0], start[1])) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c, steps = queue.popleft() if (r, c) == (goal[0], goal[1]): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and city_map[nr][nc] != 'X': visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return float('inf') to_delivery = bfs((sr, sc), (dr, dc)) if to_delivery == float('inf'): return \\"Failure\\" back_to_start = bfs((dr, dc), (sr, sc)) if back_to_start == float('inf'): return \\"Failure\\" if to_delivery + back_to_start <= S: return \\"Success\\" else: return \\"Failure\\""},{"question":"def minimum_travel_cost(roads: List[Tuple[str, str, int]]) -> int: Write a function to compute the minimum travel cost between different cities using the given road network. The function should take one parameter: a list of tuples where each tuple represents a direct road between two cities and its travel cost. Each tuple is structured as follows: (city1, city2, cost). The function should return a single number representing the minimum cost required to connect all the cities in the road network. If it's impossible to connect all the cities, the function should return -1. >>> minimum_travel_cost([(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 4)]) == 3 >>> minimum_travel_cost([(\\"A\\", \\"B\\", 1), (\\"C\\", \\"D\\", 2)]) == -1 >>> minimum_travel_cost([(\\"A\\", \\"B\\", 5)]) == 5 >>> minimum_travel_cost([]) == -1 >>> minimum_travel_cost([ ... (\\"A\\", \\"B\\", 1), ... (\\"B\\", \\"C\\", 2), ... (\\"C\\", \\"D\\", 3), ... (\\"A\\", \\"D\\", 4), ... (\\"A\\", \\"C\\", 10), ... (\\"B\\", \\"D\\", 5), ... ]) == 6 >>> minimum_travel_cost([ ... (\\"A\\", \\"B\\", 1), ... (\\"B\\", \\"C\\", 3), ... (\\"D\\", \\"E\\", 2) ... ]) == -1","solution":"def minimum_travel_cost(roads): Returns the minimum cost required to connect all the cities in the road network, or -1 if it's impossible. if not roads: return -1 from collections import defaultdict import heapq # Create an adjacency list graph = defaultdict(list) for city1, city2, cost in roads: graph[city1].append((cost, city2)) graph[city2].append((cost, city1)) # Use Prim's algorithm to find the minimum spanning tree start_city = next(iter(graph)) min_heap = [(0, start_city)] visited = set() total_cost = 0 edges_used = 0 while min_heap: cost, city = heapq.heappop(min_heap) if city in visited: continue visited.add(city) total_cost += cost edges_used += 1 for next_cost, neighbor in graph[city]: if neighbor not in visited: heapq.heappush(min_heap, (next_cost, neighbor)) # To connect all cities, the MST should have exactly len(graph) - 1 edges if edges_used == len(graph): return total_cost else: return -1"},{"question":"def sortDictByValue(d): Returns a list of key-value pairs sorted by their values in ascending order. If the input is not a dictionary, returns an empty list. >>> sortDictByValue({'c': 3, 'b': 1, 'a': 2}) [('b', 1), ('a', 2), ('c', 3)] >>> sortDictByValue({'orange': 7, 'apple': 3}) [('apple', 3), ('orange', 7)] >>> sortDictByValue([1, 2, 3]) [] >>> sortDictByValue(\\"string\\") [] >>> sortDictByValue({}) [] >>> sortDictByValue({'a': -1, 'b': 0, 'c': 10, 'd': 2, 'e': -5}) [('e', -5), ('a', -1), ('b', 0), ('d', 2), ('c', 10)]","solution":"def sortDictByValue(d): Returns a list of key-value pairs sorted by their values in ascending order. If the input is not a dictionary, returns an empty list. if not isinstance(d, dict): return [] return sorted(d.items(), key=lambda item: item[1])"},{"question":"def countPaths(m, n, grid): Given a grid of size m x n, where some cells are blocked, find the number of distinct paths from the top-left corner to the bottom-right corner of the grid. You can only move right or down. Return the number of ways to reach the destination modulo 10^9+7. A cell is blocked if it contains a 1 and open if it contains a 0. >>> countPaths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> countPaths(2, 2, [[0, 1], [0, 0]]) 1","solution":"def countPaths(m, n, grid): MOD = 10**9 + 7 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of any subarray within the given array. Uses Kadane's algorithm for efficient computation. :param arr: List of integers representing the array. :return: Maximum sum of any subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([3]) == 3 >>> max_subarray_sum([-3]) == -3 >>> max_subarray_sum([10, 1, 2, 8, 7]) == 28 >>> max_subarray_sum([-8, -3, -6, -2, -5, -4]) == -2 >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10","solution":"def max_subarray_sum(arr): Finds the maximum sum of any subarray within the given array \`arr\`. Uses Kadane's algorithm for efficient computation. :param arr: List of integers representing the array. :return: Maximum sum of any subarray. max_so_far = arr[0] current_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) max_so_far = max(max_so_far, current_max) return max_so_far"},{"question":"def productArray(arr): Write a function that takes an array of integers and returns a new array with each element being the product of every other element in the original array except the one at the current position. >>> productArray([1, 2, 3, 4]) [24, 12, 8, 6] >>> productArray([0, 2, 3, 4]) [24, 0, 0, 0]","solution":"def productArray(arr): n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List, Tuple def min_operations_needed(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, where each test case consists of an integer n (the length of the array) and a list of n integers, this function returns a list of integers corresponding to the minimum number of operations required to make all elements of each array equal. >>> min_operations_needed([(3, [1, 2, 3]), (2, [2, 4]), (5, [5, 5, 5, 5, 5]), (4, [1, 2, 2, 1])]) [2, 2, 0, 2]","solution":"def min_operations_needed(test_cases): results = [] for case in test_cases: n = case[0] a = case[1] median = sorted(a)[n // 2] # median minimizes the sum of absolute deviations operations = sum(abs(x - median) for x in a) results.append(operations) return results"},{"question":"def min_operations_to_sort_sequence(N, A): Returns the minimum number of operations to sort the sequence A in non-decreasing order, or -1 if it's not possible using the given operations. >>> min_operations_to_sort_sequence(3, [1, 2, 3]) 0 >>> min_operations_to_sort_sequence(1, [1]) 0 >>> min_operations_to_sort_sequence(5, [5, 3, 1, 4, 2]) 7 >>> min_operations_to_sort_sequence(4, [4, 3, 2, 1]) 6 >>> min_operations_to_sort_sequence(4, [1, 2, 4, 3]) 1 pass","solution":"def min_operations_to_sort_sequence(N, A): Returns the minimum number of operations to sort the sequence A in non-decreasing order, or -1 if it's not possible using the given operations. # Use a simplified version of bubble sort to count the number of inversions # since we can only swap elements that are out of order (a[i] > a[j]) inversion_count = 0 for i in range(N): for j in range(i + 1, N): if A[i] > A[j]: inversion_count += 1 return inversion_count # Example usage: # N = 5 # A = [5, 3, 1, 4, 2] # print(min_operations_to_sort_sequence(N, A)) # Output: 4"},{"question":"def unique_elements(input_list): Returns a list of unique elements in the order they first appeared. >>> unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 1, 1, 1]) == [1] >>> unique_elements([5, 4, 4, 3, 2, 1, 1]) == [5, 4, 3, 2, 1] >>> unique_elements([]) == [] >>> unique_elements([7]) == [7]","solution":"def unique_elements(input_list): Returns a list of unique elements in the order they first appeared. seen = set() unique_list = [] for num in input_list: if num not in seen: unique_list.append(num) seen.add(num) return unique_list"},{"question":"def group_anagrams(words: List[str]) -> List[List[str]]: Groups together all anagrams in the given list of words. Parameters: words (list): List of words to group by anagrams Returns: list: A list of lists of anagrams >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"zyx\\"]] >>> group_anagrams([\\"word\\"]) [[\\"word\\"]] >>> group_anagrams([]) [] >>> group_anagrams([\\"aa\\", \\"bb\\", \\"aa\\"]) [[\\"aa\\", \\"aa\\"], [\\"bb\\"]]","solution":"def group_anagrams(words): Groups together all anagrams in the given list of words. Parameters: words (list): List of words to group by anagrams Returns: list: A list of lists of anagrams from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values()) # Example usage if __name__ == \\"__main__\\": n = int(input()) words = input().split() print(group_anagrams(words))"},{"question":"def hasPairWithSum(arr, n, S): Determines if there exists a pair of integers in the array such that their sum is equal to S. :param arr: List[int] - array of integers :param n: int - size of the array :param S: int - the target sum :return: bool - True if there exists a pair with sum S, otherwise False >>> hasPairWithSum([1, 4, 45, 6, 10, -8], 6, 16) True >>> hasPairWithSum([1, 2, 3, 9], 4, 8) False # Your code here def test_hasPairWithSum(): assert hasPairWithSum([1, 4, 45, 6, 10, -8], 6, 16) == True, \\"Test case 1 failed\\" assert hasPairWithSum([1, 2, 3, 9], 4, 8) == False, \\"Test case 2 failed\\" assert hasPairWithSum([7, 1, 5, 3, 6, 2], 6, 9) == True, \\"Test case 3 failed\\" assert hasPairWithSum([1, 3, 4, 5], 4, 7) == True, \\"Test case 4 failed\\" assert hasPairWithSum([], 0, 5) == False, \\"Test case 5 failed\\" assert hasPairWithSum([1], 1, 1) == False, \\"Test case 6 failed\\" assert hasPairWithSum([2, 2, 2], 3, 4) == True, \\"Test case 7 failed\\" assert hasPairWithSum([0, 0], 2, 0) == True, \\"Test case 8 failed\\" assert hasPairWithSum([-1, -2, -3, -4], 4, -3) == True, \\"Test case 9 failed\\" assert hasPairWithSum([1, 2, 3, 9], 4, 12) == True, \\"Test case 10 failed\\" test_hasPairWithSum()","solution":"def hasPairWithSum(arr, n, S): Determines if there exists a pair of integers in the array such that their sum is equal to S. :param arr: List[int] - array of integers :param n: int - size of the array :param S: int - the target sum :return: bool - True if there exists a pair with sum S, otherwise False seen_numbers = set() for num in arr: if (S - num) in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"from typing import List def find_longest_consecutive_path(matrix: List[str]) -> int: Given an NxN matrix containing lowercase letters, find the length of the longest path where each subsequent cell contains the next consecutive letter. >>> find_longest_consecutive_path([\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"]) 4 >>> find_longest_consecutive_path([\\"a\\"]) 1 >>> find_longest_consecutive_path([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1 >>> find_longest_consecutive_path([\\"az\\", \\"za\\"]) 1 >>> find_longest_consecutive_path([\\"abcdefghij\\", \\"bcdefghija\\", \\"cdefghijab\\", \\"defghijabc\\", \\"efghijabcd\\", \\"fghijabcde\\", \\"ghijabcdef\\", \\"hijabcdefg\\", \\"ijabcdefgh\\", \\"jabcdefghi\\"]) 10","solution":"def find_longest_consecutive_path(matrix): N = len(matrix) directions = [(-1,0), (1,0), (0,-1), (0,1)] def is_valid(x, y): return 0 <= x < N and 0 <= y < N memo = [[-1] * N for _ in range(N)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and ord(matrix[nx][ny]) == ord(matrix[x][y]) + 1: max_path = max(max_path, 1 + dfs(nx, ny)) memo[x][y] = max_path return max_path longest_path = 0 for i in range(N): for j in range(N): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"def longest_divisible_subarray_length(n, arr): Find the length of the longest subarray such that for every pair of indices i and j in the subarray (i < j), a_j should be divisible by a_i. >>> longest_divisible_subarray_length(6, [4, 2, 4, 8, 16, 3]) 4 >>> longest_divisible_subarray_length(4, [5, 7, 10, 20]) 2","solution":"def longest_divisible_subarray_length(n, arr): if n == 1: return 1 max_len = 1 current_len = 1 for i in range(1, n): if arr[i] % arr[i - 1] == 0: current_len += 1 else: current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def max_subsequence_sum(nums: List[int]) -> int: Returns the maximum sum of any non-empty sub-sequence of the input list of integers. >>> max_subsequence_sum([3, -1, 4, 1, -5, 9]) 17 >>> max_subsequence_sum([-2, -3, -1, -4]) -1","solution":"def max_subsequence_sum(nums): Returns the maximum sum of any non-empty sub-sequence of the input list of integers. # Include only positive numbers to maximize the sum positive_sum = sum(x for x in nums if x > 0) # If there are no positive numbers, return the maximum negative number if positive_sum == 0: return max(nums) return positive_sum"},{"question":"def max_coins_collected(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum number of coins Sara can collect under the given rules. Args: t: int - number of test cases. test_cases: List[Tuple[int, int, List[int]]] - list of tuples where each tuple contains: - n: int - the length of the array. - d: int - the maximum allowed difference between the values of two collected coins. - coins: List[int] - the list of coin values. Returns: List[int] - list containing the maximum number of coins Sara can collect for each test case. Example: >>> max_coins_collected(3, [ >>> (5, 2, [1, 5, 1, 6, 1]), >>> (4, 3, [1, 4, 7, 10]), >>> (6, 0, [1, 2, 3, 4, 5, 6]) >>> ]) == [3, 2, 1] >>> max_coins_collected(1, [ >>> (1, 0, [1]) >>> ]) == [1] >>> max_coins_collected(1, [ >>> (5, 10, [1, 2, 3, 4, 5]) >>> ]) == [5] >>> max_coins_collected(1, [ >>> (5, 0, [1, 2, 3, 4, 5]) >>> ]) == [1]","solution":"def max_coins_collected(t, test_cases): results = [] for case in test_cases: n, d, coins = case coins.sort() collected_coins = 0 while coins: selected_coin = coins.pop(0) collected_coins += 1 coins = [coin for coin in coins if abs(coin - selected_coin) <= d] results.append(collected_coins) return results"},{"question":"def find_sources_and_sinks(n: int, edges: List[Tuple[int, int]]) -> (List[int], List[int]): Identify the source tasks with no prerequisites and sink tasks that do not act as prerequisites for other tasks. Input: - n : int : the number of tasks - edges : List[Tuple[int, int]] : directed edges representing dependencies between tasks Output: - source_tasks : List[int] : List of source tasks in increasing order - sink_tasks : List[int] : List of sink tasks in increasing order >>> find_sources_and_sinks(5, [(1, 2), (2, 3), (3, 4), (5, 3)]) ([1, 5], [4]) >>> find_sources_and_sinks(3, []) ([1, 2, 3], [1, 2, 3]) # Unit Tests from solution import find_sources_and_sinks def test_example_1(): n, m = 5, 4 edges = [(1, 2), (2, 3), (3, 4), (5, 3)] sources, sinks = find_sources_and_sinks(n, edges) assert sources == [1, 5] assert sinks == [4] def test_example_2(): n, m = 3, 0 edges = [] sources, sinks = find_sources_and_sinks(n, edges) assert sources == [1, 2, 3] assert sinks == [1, 2, 3] def test_no_sources(): n, m = 3, 3 edges = [(1, 2), (2, 3), (3, 1)] sources, sinks = find_sources_and_sinks(n, edges) assert sources == [] assert sinks == [] def test_no_sinks(): n, m = 3, 2 edges = [(1, 2), (2, 3)] sources, sinks = find_sources_and_sinks(n, edges) assert sources == [1] assert sinks == [3] def test_all_tasks_sources_and_sinks(): n, m = 4, 0 edges = [] sources, sinks = find_sources_and_sinks(n, edges) assert sources == [1, 2, 3, 4] assert sinks == [1, 2, 3, 4]","solution":"def find_sources_and_sinks(n, edges): from collections import defaultdict # Initialize in-degree and out-degree for each task in_degree = {i: 0 for i in range(1, n+1)} out_degree = {i: 0 for i in range(1, n+1)} # Populate in-degree and out-degree based on the edges for u, v in edges: out_degree[u] += 1 in_degree[v] += 1 # Find source tasks (in-degree == 0) source_tasks = sorted([i for i in range(1, n+1) if in_degree[i] == 0]) # Find sink tasks (out-degree == 0) sink_tasks = sorted([i for i in range(1, n+1) if out_degree[i] == 0]) return source_tasks, sink_tasks # Example usage: # n, m = 5, 4 # edges = [(1, 2), (2, 3), (3, 4), (5, 3)] # sources, sinks = find_sources_and_sinks(n, edges) # print(' '.join(map(str, sources))) # print(' '.join(map(str, sinks)))"},{"question":"def max_beauty_subarray(n: int, array: List[int]) -> Tuple[int, int, int]: You are given an array of n integers a_1, a_2, ..., a_n. A subarray is defined as a contiguous part of an array. The beauty of a subarray is defined as the sum of its elements. Find the subarray with the maximum beauty value. If there are multiple subarrays with the same maximum beauty value, choose the shortest one. If there's still a tie, choose the one with the smallest starting index. Parameters: n (int): The number of elements in the array array (List[int]): A list of n integers (-10^9  a_i  10^9) Returns: Tuple[int, int, int]: Three integers, the maximum beauty value, the starting index (1-based) and the ending index (1-based) of the subarray with the maximum beauty value. >>> max_beauty_subarray(8, [1, -2, 3, 10, -4, 7, 2, -5]) (18, 3, 7) >>> max_beauty_subarray(5, [-1, -1, 1, 1, -1]) (2, 3, 4) from solution import max_beauty_subarray def test_example_1(): assert max_beauty_subarray(8, [1, -2, 3, 10, -4, 7, 2, -5]) == (18, 3, 7) def test_example_2(): assert max_beauty_subarray(5, [-1, -1, 1, 1, -1]) == (2, 3, 4) def test_single_positive_element(): assert max_beauty_subarray(1, [5]) == (5, 1, 1) def test_single_negative_element(): assert max_beauty_subarray(1, [-5]) == (-5, 1, 1) def test_all_negative_elements(): assert max_beauty_subarray(3, [-2, -3, -1]) == (-1, 3, 3) def test_all_positive_elements(): assert max_beauty_subarray(4, [1, 2, 3, 4]) == (10, 1, 4) def test_mixed_elements(): assert max_beauty_subarray(6, [3, -1, 2, 1, -1, 3]) == (7, 1, 6) def test_multiple_maximum_subarrays(): assert max_beauty_subarray(7, [1, 2, -1, 2, -1, 2, 1]) == (6, 1, 7) assert max_beauty_subarray(7, [1, 1, 1, 1, 1, 1, 1]) == (7, 1, 7)","solution":"def max_beauty_subarray(n, array): Returns the maximum beauty value, and the start and end indices (1-based) of the subarray with the maximum beauty value. max_beauty = -float('inf') current_beauty = 0 current_start = 0 best_start = 0 best_end = 0 min_length = n + 1 for i in range(n): if current_beauty + array[i] > array[i]: current_beauty += array[i] else: current_beauty = array[i] current_start = i if current_beauty > max_beauty or (current_beauty == max_beauty and (i - current_start + 1 < min_length)): max_beauty = current_beauty best_start = current_start best_end = i min_length = best_end - best_start + 1 return max_beauty, best_start + 1, best_end + 1"},{"question":"def min_cost(n: int, m: int, roads: List[Tuple[int, int, int]], T: int, toll_booths: List[int], toll_amounts: List[int], fuel_station: int) -> int: Calculate the minimum cost to travel from intersection 1 to intersection n with specified roads, toll booths, and a fuel station. Args: n (int): Number of intersections. m (int): Number of roads. roads (List[Tuple[int, int, int]]): List of roads and their travel times. T (int): Number of toll booths. toll_booths (List[int]): List of toll booth intersections. toll_amounts (List[int]): List of toll amounts for corresponding toll booths. fuel_station (int): Intersection index of the fuel station. Returns: int: Minimum cost to travel from intersection 1 to intersection n. Examples: >>> min_cost(5, 6, [(1, 2, 2), (1, 3, 2), (2, 4, 3), (3, 4, 3), (4, 5, 1), (3, 5, 2)], 2, [2, 4], [3, 5], 3) 4 >>> min_cost(5, 6, [(1, 2, 2), (1, 3, 2), (2, 4, 3), (3, 4, 3), (4, 5, 1), (3, 5, 2)], 0, [], [], 3) 4 >>> min_cost(5, 6, [(1, 2, 2), (1, 3, 2), (2, 4, 3), (3, 4, 3), (4, 5, 1), (3, 5, 2)], 4, [1, 2, 3, 4], [1, 2, 3, 4], 3) 4","solution":"import heapq def min_cost(n, m, roads, T, toll_booths, toll_amounts, fuel_station): # Create graph adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Create toll map toll_map = {toll_booths[i]: toll_amounts[i] for i in range(T)} # Dijkstra's algorithm with priority queue def dijkstra(): # The cost dictionary stores minimum cost to reach each intersection min_cost = {i: float('inf') for i in range(1, n + 1)} min_cost[1] = 0 # Priority queue, storing (cost, intersection) pq = [(0, 1)] while pq: current_cost, node = heapq.heappop(pq) if current_cost > min_cost[node]: continue for neighbor, travel_cost in graph[node]: # Total cost is the travel cost plus toll if this is a toll booth total_cost = current_cost + travel_cost if neighbor in toll_map and neighbor != fuel_station: total_cost += toll_map[neighbor] if total_cost < min_cost[neighbor]: min_cost[neighbor] = total_cost heapq.heappush(pq, (total_cost, neighbor)) return min_cost[n] return dijkstra()"},{"question":"def isBeautifulArray(arr: list, k: int) -> str: Determines if it is possible to rearrange the given array into a \\"beautiful\\" array. Parameters: arr (list of int): The input array of integers. k (int): The maximum allowed difference. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". >>> isBeautifulArray([1, 3, 2, 4], 1) \\"YES\\" >>> isBeautifulArray([10, 5, 7, 3], 2) \\"NO\\"","solution":"def isBeautifulArray(arr, k): Determines if it is possible to rearrange the given array into a \\"beautiful\\" array. Parameters: arr (list of int): The input array of integers. k (int): The maximum allowed difference. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". arr.sort() for i in range(1, len(arr)): if arr[i] > arr[i-1] + k: return \\"NO\\" return \\"YES\\""},{"question":"def calculate_distance(p1, p2): Calculate Manhattan distance between two points pass def minimum_time_to_collect_all_coins_and_return(r, c, k, coins): Determine the minimum time needed to collect all coins and return to the starting point in the maze. Parameters: r (int): number of rows in the maze c (int): number of columns in the maze k (int): number of coins coins (List[Tuple[int, int]]): list of coordinates for each coin Returns: int: minimum time needed to collect all coins and return to the starting point Examples: >>> minimum_time_to_collect_all_coins_and_return(3, 3, 4, [(0, 1), (1, 2), (2, 1), (1, 1)]) 8 >>> minimum_time_to_collect_all_coins_and_return(2, 2, 2, [(0, 1), (1, 0)]) 4 pass def optimal_timer_settings(t, test_cases): Calculate the optimal timer settings for multiple test cases. Parameters: t (int): number of test cases test_cases (List[Tuple[Tuple[int, int, int], List[Tuple[int, int]]]]): list of test cases, each containing maze dimensions and coin locations Returns: List[int]: list of minimum times for each test case Examples: >>> optimal_timer_settings(1, [((3, 3, 4), (0, 1), (1, 2), (2, 1), (1, 1))]) [8] >>> optimal_timer_settings(2, [((3, 3, 4), (0, 1), (1, 2), (2, 1), (1, 1)), ((2, 2, 2), (0, 1), (1, 0))]) [8, 4] pass","solution":"from itertools import permutations def calculate_distance(p1, p2): Calculate Manhattan distance between two points return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) def minimum_time_to_collect_all_coins_and_return(r, c, k, coins): start = (0, 0) min_time = float('inf') # Generate all permutations of the coin coordinates for perm in permutations(coins): current_time = 0 current_position = start # Calculate the time to collect all coins in the current permutation for coin in perm: current_time += calculate_distance(current_position, coin) current_position = coin # Calculate the time to return to the start position current_time += calculate_distance(current_position, start) # Update the minimum time min_time = min(min_time, current_time) return min_time def optimal_timer_settings(t, test_cases): results = [] for case in test_cases: r, c, k = case[0] coins = case[1:] if k == 0: results.append(0) else: time_needed = minimum_time_to_collect_all_coins_and_return(r, c, k, coins) if time_needed == float('inf'): results.append(\\"impossible\\") else: results.append(time_needed) return results"},{"question":"def process_operations(M: int, N: int, operations: List[str]) -> List[List[str]]: Process a list of parking lot operations and return the state of the parking lot after performing query operations. Params: @M: int - The number of rows in the parking lot grid. @N: int - The number of columns in the parking lot grid. @operations: List[str] - A list of operations to perform on the parking lot. Each operation is a string, where the first character denotes the type of operation ('P' for parking a car, 'R' for removing a car, 'Q' for querying the state of the parking lot), followed by coordinates (x and y) for 'P' and 'R' operations. Returns: List[List[str]] - A list of the parking lot grid state after each 'Q' operation. >>> process_operations(3, 3, [\\"P 1 1\\", \\"P 0 0\\", \\"Q\\", \\"R 1 1\\", \\"Q\\"]) [ [\\"C..\\", \\"...\\", \\".C.\\"], [\\"C..\\", \\"...\\", \\"...\\"] ] >>> process_operations(3, 3, [\\"R 1 1\\", \\"Q\\"]) [ [\\"...\\", \\"...\\", \\"...\\"] ] from typing import List if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"class ParkingLot: def __init__(self, M, N): self.M = M self.N = N self.grid = [['.' for _ in range(N)] for _ in range(M)] def park_car(self, x, y): if self.grid[x][y] == '.': self.grid[x][y] = 'C' def remove_car(self, x, y): if self.grid[x][y] == 'C': self.grid[x][y] = '.' def query(self): return [''.join(row) for row in self.grid] def process_operations(M, N, operations): parking_lot = ParkingLot(M, N) results = [] for operation in operations: parts = operation.split() if parts[0] == 'P': x = int(parts[1]) y = int(parts[2]) parking_lot.park_car(x, y) elif parts[0] == 'R': x = int(parts[1]) y = int(parts[2]) parking_lot.remove_car(x, y) elif parts[0] == 'Q': results.append(parking_lot.query()) return results"},{"question":"def find_single_number(nums): Finds the integer that appears only once in the array. Args: nums (list): List of integers where exactly one integer appears once and all other integers appear twice. Returns: int: The integer that appears only once. Example: >>> find_single_number([2, 3, 5, 2, 5]) 3","solution":"def find_single_number(nums): Finds the integer that appears only once in the array. Args: nums (list): List of integers where exactly one integer appears once and all other integers appear twice. Returns: int: The integer that appears only once. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"def remove_and_minimize(S: str, ch: str) -> str: Returns the smallest possible lexicographical string by removing exactly one occurrence of the character \`ch\` from \`S\`. If the character \`ch\` doesn't exist in the string, return the original string. >>> remove_and_minimize(\\"abcabc\\", 'b') \\"abcac\\" >>> remove_and_minimize(\\"bbbaa\\", 'b') \\"bbaa\\" >>> remove_and_minimize(\\"abcdefgh\\", 'z') \\"abcdefgh\\"","solution":"def remove_and_minimize(S, ch): Returns the smallest possible lexicographical string by removing exactly one occurrence of the character \`ch\` from \`S\`. If the character \`ch\` doesn't exist in the string, return the original string. # Try to find the first occurrence of the character \`ch\` in \`S\` index = S.find(ch) if index == -1: # If ch is not found, return the original string return S # Try removing each occurrence of \`ch\` and store the resulting string smallest_str = None for i in range(len(S)): if S[i] == ch: new_str = S[:i] + S[i+1:] if smallest_str is None or new_str < smallest_str: smallest_str = new_str return smallest_str"},{"question":"def max_sum_on_longest_path(n, nodes): Given a binary tree where each node contains a value, determine the sum of those values that fall on the longest path to any leaf starting from the root node. If there are multiple longest paths to different leaves, return the maximum sum of values from these longest paths. Args: n (int): The number of nodes in the binary tree. nodes (List[Tuple[int, int, int]]): A list of tuples where each tuple represents a node in the tree with the value of the node, and the indices of the left and right children nodes. Returns: int: The maximum sum of values from the longest path from root to any leaf node. Example: >>> max_sum_on_longest_path(5, [(10, 2, 3), (20, 4, 0), (30, 0, 5), (40, 0, 0), (50, 0, 0)]) 90 >>> max_sum_on_longest_path(3, [(5, 2, 3), (10, 0, 0), (15, 0, 0)]) 20 >>> max_sum_on_longest_path(6, [(1, 2, 3), (2, 4, 0), (3, 0, 0), (4, 5, 6), (5, 0, 0), (10, 0, 0)]) 17","solution":"def max_sum_on_longest_path(n, nodes): from collections import defaultdict, deque if n == 0: return 0 tree = defaultdict(dict) root = 1 for idx, (vi, li, ri) in enumerate(nodes, 1): tree[idx]['value'] = vi if li != 0: tree[idx]['left'] = li if ri != 0: tree[idx]['right'] = ri def dfs(node): if node not in tree: return (0, 0) current_value = tree[node]['value'] left_length, left_sum = dfs(tree[node].get('left', 0)) right_length, right_sum = dfs(tree[node].get('right', 0)) if left_length > right_length: return (left_length + 1, left_sum + current_value) elif right_length > left_length: return (right_length + 1, right_sum + current_value) else: return (left_length + 1, max(left_sum, right_sum) + current_value) return dfs(root)[1]"},{"question":"def is_palindrome(s, i, j): Helper function to check if the substring s[i:j+1] is a palindrome. def can_be_made_palindrome(s): Function to check if the string s can be made a palindrome by removing at most one character. def process_inputs(T, strings): Given a list of strings, return a list of \\"YES\\" or \\"NO\\" indicating if each string can be made a palindrome by removing at most one character. INPUT The first line will contain an integer T, the number of strings. Each of the next T lines will contain a string S. OUTPUT For each string S, output \\"YES\\" if it is possible to make the string a palindrome by removing at most one character, and \\"NO\\" otherwise. CONSTRAINTS T  10^4 |S|  10^5 All characters in the input strings are lowercase Latin characters ('a'-'z'). The total length of all strings in a test file will not exceed 10^6. SAMPLE INPUT 2 abca abc SAMPLE OUTPUT YES NO results = [] def test_sample_inputs(): assert process_inputs(2, ['abca', 'abc']) == [\\"YES\\", \\"NO\\"] def test_single_character(): assert process_inputs(1, ['a']) == [\\"YES\\"] def test_two_character_palindrome(): assert process_inputs(1, ['aa']) == [\\"YES\\"] def test_two_character_non_palindrome(): assert process_inputs(1, ['ab']) == [\\"YES\\"] def test_large_palindrome(): assert process_inputs(1, ['aaaaaabaaaaaa']) == [\\"YES\\"] def test_large_non_palindrome(): assert process_inputs(1, ['abcdefg']) == [\\"NO\\"] def test_mixed_case(): assert process_inputs(2, ['racecar', 'raceecar']) == [\\"YES\\", \\"YES\\"] def test_edge_case_empty_string(): assert process_inputs(1, ['']) == [\\"YES\\"]","solution":"def is_palindrome(s, i, j): Helper function to check if the substring s[i:j+1] is a palindrome. while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True def can_be_made_palindrome(s): Function to check if the string s can be made a palindrome by removing at most one character. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing either the character at left or at right return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1) left += 1 right -= 1 return True def process_inputs(T, strings): results = [] for s in strings: if can_be_made_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def insert_interval(intervals, newInterval): Insert a new interval into a set of non-overlapping intervals and merge if necessary. Args: intervals: List[List[int]] - a list of non-overlapping intervals sorted by start time. newInterval: List[int] - the interval to insert. Returns: List[List[int]] - the set of intervals after the insertion and merging. Examples: >>> insert_interval([[1, 3], [6, 9]], [2, 5]) [[1, 5], [6, 9]] >>> insert_interval([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 8]) [[1, 2], [3, 10], [12, 16]] >>> insert_interval([], [5, 7]) [[5, 7]] >>> insert_interval([[1, 5]], [2, 3]) [[1, 5]]","solution":"def insert_interval(intervals, newInterval): Inserts a new interval into a list of non-overlapping sorted intervals and merge if necessary. result = [] i = 0 n = len(intervals) # Add all intervals ending before newInterval starts while i < n and intervals[i][1] < newInterval[0]: result.append(intervals[i]) i += 1 # Merge intervals that overlap with newInterval while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 result.append(newInterval) # Add the remaining intervals while i < n: result.append(intervals[i]) i += 1 return result"},{"question":"def maxSlidingWindow(nums: List[int], k: int) -> List[int]: Returns a list of integers representing the maximum numbers in each sliding window of size k. :param nums: List of integers :param k: Size of the sliding window :return: List of integers >>> maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) [3, 3, 5, 5, 6, 7] >>> maxSlidingWindow([1], 1) [1] >>> maxSlidingWindow([1, -1], 1) [1, -1] >>> maxSlidingWindow([9, 11], 2) [11] >>> maxSlidingWindow([4, -2], 2) [4] from collections import deque import unittest class TestMaxSlidingWindow(unittest.TestCase): def test_maxSlidingWindow(self): self.assertEqual(maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3), [3, 3, 5, 5, 6, 7]) self.assertEqual(maxSlidingWindow([1], 1), [1]) self.assertEqual(maxSlidingWindow([1, -1], 1), [1, -1]) self.assertEqual(maxSlidingWindow([9, 11], 2), [11]) self.assertEqual(maxSlidingWindow([4, -2], 2), [4]) def test_empty_input(self): self.assertEqual(maxSlidingWindow([], 3), []) def test_all_negative_numbers(self): self.assertEqual(maxSlidingWindow([-1, -3, -2, -5, -4], 2), [-1, -2, -2, -4]) def test_k_equals_1(self): self.assertEqual(maxSlidingWindow([1, 3, 1, 2, 0, 5], 1), [1, 3, 1, 2, 0, 5]) if __name__ == '__main__': unittest.main()","solution":"from collections import deque def maxSlidingWindow(nums, k): Returns a list of integers representing the maximum numbers in each sliding window of size k. :param nums: List of integers :param k: Size of the sliding window :return: List of integers if not nums or k == 0: return [] n = len(nums) if k == 1: return nums deq = deque() result = [] for i in range(n): # Remove elements not within the sliding window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements smaller than the currently being added element from the back while deq and nums[deq[-1]] < nums[i]: deq.pop() deq.append(i) # The first element in deque is the largest one in the current window if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Given an integer array heights representing the heights of columns where the width of each column is 1, return the maximum area of a rectangular subarray under the histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([2, 2, 2, 2]) 8 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([0, 0, 0, 0]) 0 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Computes the largest rectangle area in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: This function takes a list of integers representing daily temperatures and returns a list where each element is the number of days to wait until a warmer temperature. If no such future day exists, the element is 0. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 100, 100, 100]) [0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 60, 70]) [1, 1, 1, 1, 0] >>> daily_temperatures([70, 60, 50, 40, 30]) [0, 0, 0, 0, 0] >>> daily_temperatures([70, 60, 65, 55, 80, 75]) [4, 1, 2, 1, 0, 0]","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: This function takes a list of integers representing daily temperatures and returns a list where each element is the number of days to wait until a warmer temperature. If no such future day exists, the element is 0. result = [0] * len(temperatures) stack = [] for i, current_temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < current_temp: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"class SimpleDatabase: A simple in-memory database to support PUT, GET, DELETE, and COUNT operations. Methods: put(k: str, v: str) -> None: Stores the value v with the key k. get(k: str) -> str: Retrieves the value associated with the key k, or outputs \\"NULL\\" if k doesn't exist. delete(k: str) -> None: Removes the key k and its value if it exists. count(v: str) -> int: Returns the number of keys that have the value v. def __init__(self): Initializes the database. pass def put(self, k: str, v: str) -> None: Stores the value v with the key k. pass def get(self, k: str) -> str: Retrieves the value associated with the key k, or outputs \\"NULL\\" if k doesn't exist. pass def delete(self, k: str) -> None: Removes the key k and its value if it exists. pass def count(self, v: str) -> int: Returns the number of keys that have the value v. pass # Unit Test def test_put(): db = SimpleDatabase() db.put(\\"key1\\", \\"value1\\") assert db.get(\\"key1\\") == \\"value1\\" def test_get_existing_key(): db = SimpleDatabase() db.put(\\"key1\\", \\"value1\\") assert db.get(\\"key1\\") == \\"value1\\" def test_get_non_existing_key(): db = SimpleDatabase() assert db.get(\\"nonexistent\\") == \\"NULL\\" def test_delete_existing_key(): db = SimpleDatabase() db.put(\\"key1\\", \\"value1\\") db.delete(\\"key1\\") assert db.get(\\"key1\\") == \\"NULL\\" def test_delete_non_existing_key(): db = SimpleDatabase() db.delete(\\"nonexistent\\") assert True # No exception should be raised def test_count(): db = SimpleDatabase() db.put(\\"key1\\", \\"value1\\") db.put(\\"key2\\", \\"value1\\") db.put(\\"key3\\", \\"value2\\") assert db.count(\\"value1\\") == 2 assert db.count(\\"value2\\") == 1 assert db.count(\\"value3\\") == 0 def test_put_overwrite(): db = SimpleDatabase() db.put(\\"key1\\", \\"value1\\") assert db.get(\\"key1\\") == \\"value1\\" assert db.count(\\"value1\\") == 1 db.put(\\"key1\\", \\"value2\\") assert db.get(\\"key1\\") == \\"value2\\" assert db.count(\\"value1\\") == 0 assert db.count(\\"value2\\") == 1","solution":"class SimpleDatabase: def __init__(self): self.data = {} self.value_count = {} def put(self, k, v): if k in self.data: old_value = self.data[k] if old_value in self.value_count: self.value_count[old_value] -= 1 if self.value_count[old_value] == 0: del self.value_count[old_value] self.data[k] = v if v in self.value_count: self.value_count[v] += 1 else: self.value_count[v] = 1 def get(self, k): return self.data.get(k, \\"NULL\\") def delete(self, k): if k in self.data: value = self.data[k] if value in self.value_count: self.value_count[value] -= 1 if self.value_count[value] == 0: del self.value_count[value] del self.data[k] def count(self, v): return self.value_count.get(v, 0)"},{"question":"from typing import List, Dict, Union def summarize_weather(data: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[float, Dict[str, int], str]]: Summarize weather data to provide insights such as average temperature, number of days with different types of weather, and identify the hottest and coldest days. >>> summarize_weather([ ... {'date': '2023-01-01', 'temperature': 20, 'weather': 'sunny'}, ... {'date': '2023-01-02', 'temperature': 10, 'weather': 'cloudy'}, ... {'date': '2023-01-03', 'temperature': 15, 'weather': 'rainy'} ... ]) == { ... 'average_temperature': 15.0, ... 'weather_count': {'sunny': 1, 'cloudy': 1, 'rainy': 1}, ... 'hottest_day': '2023-01-01', ... 'coldest_day': '2023-01-02' ... } >>> summarize_weather([ ... {'date': '2023-01-01', 'temperature': -5, 'weather': 'snowy'}, ... {'date': '2023-01-02', 'temperature': -10, 'weather': 'snowy'}, ... {'date': '2023-01-03', 'temperature': -15, 'weather': 'snowy'} ... ]) == { ... 'average_temperature': -10.0, ... 'weather_count': {'snowy': 3}, ... 'hottest_day': '2023-01-01', ... 'coldest_day': '2023-01-03' ... } pass","solution":"from typing import List, Dict, Union def summarize_weather(data: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[float, Dict[str, int], str]]: total_temp = 0 weather_count = {} min_temp = float('inf') max_temp = float('-inf') coldest_day = \\"\\" hottest_day = \\"\\" for record in data: temp = record['temperature'] weather_type = record['weather'] date = record['date'] total_temp += temp if temp < min_temp: min_temp = temp coldest_day = date if temp > max_temp: max_temp = temp hottest_day = date if weather_type in weather_count: weather_count[weather_type] += 1 else: weather_count[weather_type] = 1 average_temperature = total_temp / len(data) return { 'average_temperature': average_temperature, 'weather_count': weather_count, 'hottest_day': hottest_day, 'coldest_day': coldest_day }"},{"question":"def containsNearbyDuplicate(arr, k): Determines if there exist two distinct indices i and j in the array such that arr[i] == arr[j] and the absolute difference between i and j is at most k. Parameters: arr (list of int): The array of integers. k (int): The maximum allowed index difference. Returns: bool: True if such elements exist, False otherwise. Examples: >>> containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) False >>> containsNearbyDuplicate([1, 0, 1, 1], 1) True","solution":"def containsNearbyDuplicate(arr, k): Determines if there exist two distinct indices i and j in the array such that arr[i] == arr[j] and the absolute difference between i and j is at most k. Parameters: arr (list of int): The array of integers. k (int): The maximum allowed index difference. Returns: bool: True if such elements exist, False otherwise. index_map = {} for i, val in enumerate(arr): if val in index_map and i - index_map[val] <= k: return True index_map[val] = i return False"},{"question":"def transform_matrix(matrix): Transforms the matrix according to the following rules: - If an element is even, divide it by 2. - If an element is odd, multiply it by 3 and add 1. Args: matrix (list of list of int): N x N matrix containing positive integers. Returns: list of list of int: Transformed N x N matrix. # Test cases to validate the solution import pytest def test_transform_matrix_example(): matrix = [ [4, 7, 2], [9, 6, 3], [5, 8, 1] ] expected = [ [2, 22, 1], [28, 3, 10], [16, 4, 4] ] assert transform_matrix(matrix) == expected def test_transform_matrix_single_element(): matrix = [[10]] expected = [[5]] assert transform_matrix(matrix) == expected def test_transform_matrix_all_even(): matrix = [ [2, 4, 6], [8, 10, 12], [14, 16, 18] ] expected = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert transform_matrix(matrix) == expected def test_transform_matrix_all_odd(): matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] expected = [ [4, 10, 16], [22, 28, 34], [40, 46, 52] ] assert transform_matrix(matrix) == expected def test_transform_matrix_even_and_odd(): matrix = [ [2, 3], [4, 5] ] expected = [ [1, 10], [2, 16] ] assert transform_matrix(matrix) == expected def test_transform_matrix_large_value(): matrix = [ [999, 1000], [200, 1] ] expected = [ [2998, 500], [100, 4] ] assert transform_matrix(matrix) == expected","solution":"def transform_matrix(matrix): Transforms the matrix according to the following rules: - If an element is even, divide it by 2. - If an element is odd, multiply it by 3 and add 1. Args: matrix (list of list of int): N x N matrix containing positive integers. Returns: list of list of int: Transformed N x N matrix. N = len(matrix) transformed = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): if matrix[i][j] % 2 == 0: transformed[i][j] = matrix[i][j] // 2 else: transformed[i][j] = matrix[i][j] * 3 + 1 return transformed"},{"question":"from typing import List def num_islands(grid: List[List[str]]) -> int: You are given a rectangular grid consisting of 'X' and 'O'. 'X' represents land and 'O' represents water. Your task is to find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Example: >>> grid = [ ... ['X', 'X', 'O', 'O', 'X'], ... ['X', 'O', 'O', 'X', 'X'], ... ['O', 'O', 'X', 'O', 'O'], ... ['O', 'X', 'X', 'O', 'O'] ... ] >>> num_islands(grid) 3","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if (0 <= r < rows and 0 <= c < cols and not visited[r][c] and grid[r][c] == 'X'): visited[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 'X' and not visited[r][c]: dfs(r, c) island_count += 1 return island_count"},{"question":"def is_symmetric(n: int, m: int, grid: List[str]) -> str: Checks if the pattern is symmetric around the horizontal central axis. :param n: int, height of the grid (pattern) :param m: int, width of the grid (pattern) :param grid: list of strings, each string represents a row of the grid :return: str, \\"YES\\" if the pattern is symmetric around the horizontal central axis, otherwise \\"NO\\" # Unit Test def test_symmetric_yes_case(): n = 4 m = 3 grid = [ \\".#.\\", \\"#\\", \\"#\\", \\".#.\\" ] assert is_symmetric(n, m, grid) == \\"YES\\" def test_symmetric_no_case(): n = 4 m = 4 grid = [ \\".#..\\", \\".#\\", \\"#..#\\", \\".#..\\" ] assert is_symmetric(n, m, grid) == \\"NO\\" def test_symmetric_large_grid_yes_case(): n = 6 m = 2 grid = [ \\"#.\\", \\"..\\", \\"#.\\", \\"#.\\", \\"..\\", \\"#.\\" ] assert is_symmetric(n, m, grid) == \\"YES\\" def test_symmetric_large_grid_no_case(): n = 6 m = 2 grid = [ \\"#.\\", \\"..\\", \\"#.\\", \\"#.\\", \\"#.\\", \\"#.\\" ] assert is_symmetric(n, m, grid) == \\"NO\\" def test_symmetric_single_column(): n = 2 m = 1 grid = [ \\".\\", \\".\\" ] assert is_symmetric(n, m, grid) == \\"YES\\" def test_symmetric_single_row(): n = 2 m = 2 grid = [ \\"..\\", \\"\\" ] assert is_symmetric(n, m, grid) == \\"NO\\"","solution":"def is_symmetric(n, m, grid): Checks if the pattern is symmetric around the horizontal central axis. :param n: int, height of the grid (pattern) :param m: int, width of the grid (pattern) :param grid: list of strings, each string represents a row of the grid :return: str, \\"YES\\" if the pattern is symmetric around the horizontal central axis, otherwise \\"NO\\" for i in range(n // 2): if grid[i] != grid[n - 1 - i]: return \\"NO\\" return \\"YES\\""},{"question":"def subarrays_with_k_distinct(A: List[int], K: int) -> int: Determine the number of subarrays with exactly K distinct integers in the given list. >>> subarrays_with_k_distinct([1, 2, 1, 2, 3], 2) 7 >>> subarrays_with_k_distinct([1], 1) 1 >>> subarrays_with_k_distinct([1, 2, 3, 4], 3) 2 >>> subarrays_with_k_distinct([1, 2, 1, 1, 1], 3) 0 >>> subarrays_with_k_distinct([1, 2, 3, 4, 5], 4) 2","solution":"def subarrays_with_k_distinct(A, K): from collections import defaultdict def at_most_k_distinct(k): count = defaultdict(int) left = 0 result = 0 for right in range(len(A)): if count[A[right]] == 0: k -= 1 count[A[right]] += 1 while k < 0: count[A[left]] -= 1 if count[A[left]] == 0: k += 1 left += 1 result += right - left + 1 return result return at_most_k_distinct(K) - at_most_k_distinct(K - 1) def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) A = list(map(int, data[2:])) print(subarrays_with_k_distinct(A, K))"},{"question":"from typing import List, Tuple def can_arrange_coins(n: int, values: List[int], m: int, restrictions: List[Tuple[int, int]]) -> Tuple[str, List[int]]: Determine if it's possible to arrange the coins in a valid sequence where the values of the coins increase from left to right and some pairs of coins cannot be adjacent due to their delicate nature. Parameters: n (int): The number of coins. values (List[int]): The values of the coins. m (int): The number of restricted pairs of coins. restrictions (List[Tuple[int, int]]): The restrictions that provide the pairs of coins which cannot be adjacent. Returns: Tuple[str, List[int]]: \\"YES\\" and one valid sequence if possible, otherwise \\"NO\\" and an empty list. >>> can_arrange_coins(5, [4, 2, 5, 1, 3], 2, [(1, 2), (4, 5)]) (\\"YES\\", [1, 2, 3, 4, 5]) >>> can_arrange_coins(4, [6, 8, 4, 7], 3, [(1, 3), (2, 4), (3, 4)]) (\\"NO\\", [])","solution":"def can_arrange_coins(n, values, m, restrictions): from collections import defaultdict # Build adjacency list of restrictions restricted_pairs = defaultdict(set) for a, b in restrictions: restricted_pairs[a].add(b) restricted_pairs[b].add(a) # Sort the values along with their original indices indexed_values = sorted((v, i + 1) for i, v in enumerate(values)) def is_valid(arrangement): # Check if there are any adjacent pairs in the arrangement that should not be for i in range(len(arrangement) - 1): if arrangement[i + 1] in restricted_pairs[arrangement[i]]: return False return True # Attempt to arrange the coins in increasing order by value arrangement = [index for value, index in indexed_values] # Check if the arrangement is valid if is_valid(arrangement): sorted_values = [value for value, index in indexed_values] return \\"YES\\", sorted_values else: return \\"NO\\", [] # Example of function call: # Test case 1 # n = 5 # values = [4, 2, 5, 1, 3] # m = 2 # restrictions = [(1, 2), (4, 5)] n = 5 values = [4, 2, 5, 1, 3] m = 2 restrictions = [(1, 2), (4, 5)] print(can_arrange_coins(n, values, m, restrictions)) # Test case 2 # n = 4 # values = [6, 8, 4, 7] # m = 3 # restrictions = [(1, 3), (2, 4), (3, 4)] n = 4 values = [6, 8, 4, 7] m = 3 restrictions = [(1, 3), (2, 4), (3, 4)] print(can_arrange_coins(n, values, m, restrictions))"},{"question":"def zoo_operations(n: int, a: List[int], q: int, operations: List[List[str]]) -> List[int]: Perform a series of operations on the list of cages and return the results of the count operations. Args: n (int): The number of cages. a (List[int]): The initial number of occupants in each cage. q (int): The number of operations. operations (List[List[str]]): List of operations to be performed. Returns: List[int]: A list of results for each count operation. Example: >>> zoo_operations(5, [3, 2, 5, 7, 9], 4, [['count', '1', '3'], ['move', '2', '4'], ['count', '1', '3'], ['count', '3', '5']]) [10, 8, 23]","solution":"def zoo_operations(n, a, q, operations): results = [] for operation in operations: if operation[0] == 'count': l, r = int(operation[1]), int(operation[2]) total_count = sum(a[l-1:r]) results.append(total_count) elif operation[0] == 'move': u, v = int(operation[1]), int(operation[2]) a[v-1] += a[u-1] a[u-1] = 0 return results # Example usage n = 5 a = [3, 2, 5, 7, 9] q = 4 operations = [ ['count', '1', '3'], ['move', '2', '4'], ['count', '1', '3'], ['count', '3', '5'] ] print(zoo_operations(n, a, q, operations)) # Output: [10, 8, 23]"},{"question":"def minimum_final_value(n: int, sequence: List[int]) -> int: Determines the minimum possible value of the final remaining number after performing n-1 operations. Parameters: n (int): Number of integers in the sequence. sequence (list): List of integers in the sequence. Returns: int: The minimum possible value of the final remaining number. >>> minimum_final_value(4, [1, 2, 3, 4]) 10 >>> minimum_final_value(2, [1, 2]) 3 >>> minimum_final_value(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> minimum_final_value(5, [1, 3, 6, 7, 9]) 26 >>> minimum_final_value(4, [1, 1, 1, 1]) 4 >>> minimum_final_value(5, [4, 5, 2, 7, 8]) 26 # Your code here","solution":"def minimum_final_value(n, sequence): Determines the minimum possible value of the final remaining number after performing n-1 operations. Parameters: n (int): Number of integers in the sequence. sequence (list): List of integers in the sequence. Returns: int: The minimum possible value of the final remaining number. # The minimum possible value of the final remaining number is the sum of all elements in the list return sum(sequence)"},{"question":"def word_with_max_vowels(test_cases: List[List[str]]) -> List[str]: Find the word with the maximum number of vowels from each list of words. If two words have the same number of vowels, return the word which appears first. Parameters: test_cases (list of list of str): List of test cases, each containing a list of words. Returns: List of str: Words with the maximum number of vowels for each test case. Example: >>> word_with_max_vowels([[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]]) [\\"hello\\"] >>> word_with_max_vowels([[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"], [\\"programming\\", \\"is\\", \\"fun\\"]]) [\\"hello\\", \\"programming\\"] from typing import List # Adding unit tests from solution import word_with_max_vowels def test_single_test_case(): test_cases = [[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]] assert word_with_max_vowels(test_cases) == [\\"hello\\"] def test_multiple_test_cases(): test_cases = [ [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"], [\\"programming\\", \\"is\\", \\"fun\\"] ] assert word_with_max_vowels(test_cases) == [\\"hello\\", \\"programming\\"] def test_ties(): test_cases = [[\\"seesaw\\", \\"look\\", \\"see\\"]] assert word_with_max_vowels(test_cases) == [\\"seesaw\\"] def test_all_consonants(): test_cases = [[\\"bcdfgh\\", \\"klmn\\", \\"prstvxz\\"]] assert word_with_max_vowels(test_cases) == [\\"bcdfgh\\"] def test_no_vowels(): test_cases = [[\\"bcd\\", \\"fgh\\", \\"klmn\\"]] assert word_with_max_vowels(test_cases) == [\\"bcd\\"] def test_mixed_case_vowels(): test_cases = [[\\"hElLo\\", \\"WoRLd\\", \\"TEST\\"]] assert word_with_max_vowels(test_cases) == [\\"hElLo\\"]","solution":"def count_vowels(word): Helper function to count the number of vowels in a word. vowels = set(\\"aeiou\\") return sum(1 for letter in word if letter.lower() in vowels) def word_with_max_vowels(test_cases): For each list of words in test cases, return the word with the maximum number of vowels. If two words have the same number of vowels, return the word which appears first. Parameters: test_cases (list of list of str): List of test cases, each containing a list of words. Returns: List of str: Words with the maximum number of vowels for each test case. result = [] for words in test_cases: max_vowel_word = max(words, key=lambda word: (count_vowels(word), -words.index(word))) result.append(max_vowel_word) return result"},{"question":"def valid_parentheses(strings): Returns a list of boolean values where each value indicates whether the corresponding string in the input list is a valid sequence of parentheses. >>> valid_parentheses([\\"()\\", \\"(())\\", \\"()()\\"]) == [True, True, True] >>> valid_parentheses([\\"(\\", \\")\\", \\"(()\\", \\"())\\"]) == [False, False, False, False] >>> valid_parentheses([\\"()\\", \\"())\\", \\"((\\", \\"((()))\\"]) == [True, False, False, True] >>> valid_parentheses([\\"\\", \\"()\\"]) == [True, True] >>> valid_parentheses([\\")(()\\", \\"(()))\\"]) == [False, False]","solution":"def valid_parentheses(strings): Returns a list of boolean values where each value indicates whether the corresponding string in the input list is a valid sequence of parentheses. def is_valid(s): stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0 return [is_valid(s) for s in strings]"},{"question":"def longest_common_subsequence(seq1, seq2): Returns the length of the longest common subsequence between two sequences of video IDs. >>> longest_common_subsequence([1, 3, 7, 9, 2, 8], [3, 7, 8, 2, 1]) 3 >>> longest_common_subsequence([3, 9, 1], [3, 1, 9]) 2","solution":"def longest_common_subsequence(seq1, seq2): Returns the length of the longest common subsequence between two sequences of video IDs. n = len(seq1) m = len(seq2) # Create a 2D dp array filled with zeros dp = [[0] * (m + 1) for _ in range(n + 1)] # Populate the dp array using bottom-up dynamic programming approach for i in range(1, n + 1): for j in range(1, m + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence is found in dp[n][m] return dp[n][m] # Example usage if __name__ == '__main__': N = int(input().strip()) seq1 = list(map(int, input().strip().split())) M = int(input().strip()) seq2 = list(map(int, input().strip().split())) print(longest_common_subsequence(seq1, seq2))"},{"question":"def find_missing_books(n: int, library_books: List[Tuple[int, str]], m: int, catalog_books: List[int]) -> List[Tuple[int, str]]: Finds books that are in the library system but missing in the catalog. :param n: Number of books in the library system :param library_books: List of tuples (ID, title) for books in the library system :param m: Number of book records in the catalog :param catalog_books: List of IDs representing the catalog records :return: List of tuples (ID, title) for books missing in the catalog >>> find_missing_books(4, [(1001, \\"The Great Gatsby\\"), (1002, \\"1984\\"), (1003, \\"To Kill a Mockingbird\\"), (1004, \\"The Catcher in the Rye\\")], 3, [1001, 1002, 1004]) [(1003, \\"To Kill a Mockingbird\\")] >>> find_missing_books(2, [(1001, \\"The Great Gatsby\\"), (1002, \\"1984\\")], 2, [1001, 1002]) [] >>> find_missing_books(3, [(1001, \\"Moby Dick\\"), (1002, \\"War and Peace\\"), (1003, \\"The Odyssey\\")], 0, []) [(1001, \\"Moby Dick\\"), (1002, \\"War and Peace\\"), (1003, \\"The Odyssey\\")] >>> find_missing_books(0, [], 0, []) [] >>> find_missing_books(100, [(i, f\\"Book {i}\\") for i in range(1, 101)], 50, [i for i in range(1, 51)]) [(i, f\\"Book {i}\\") for i in range(51, 101)]","solution":"def find_missing_books(n, library_books, m, catalog_books): Finds books that are in the library system but missing in the catalog. :param n: Number of books in the library system :param library_books: List of tuples (ID, title) for books in the library system :param m: Number of book records in the catalog :param catalog_books: List of IDs representing the catalog records :return: List of tuples (ID, title) for books missing in the catalog catalog_set = set(catalog_books) missing_books = [] for book_id, book_title in library_books: if book_id not in catalog_set: missing_books.append((book_id, book_title)) return missing_books"},{"question":"from collections import OrderedDict class LRUCache: Implements the Least Recently Used (LRU) Cache system which evicts the least recently used items first. LRUCache(int capacity): Initializes the cache with a positive size capacity. int get(int key): Returns the value of the key if the key exists in the cache. Otherwise, returns -1. void put(int key, int value): Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. If the cache reaches its capacity, it will invalidate the least recently used item before inserting the new one. Example: >>> lru_cache = LRUCache(2) >>> lru_cache.put(1, 1) # Cache is {1=1} >>> lru_cache.put(2, 2) # Cache is {1=1, 2=2} >>> lru_cache.get(1) # Returns 1 (Cache is {2=2, 1=1}) >>> lru_cache.put(3, 3) # Evicts key 2 and cache is {1=1, 3=3} >>> lru_cache.get(2) # Returns -1 (not found) >>> lru_cache.put(4, 4) # Evicts key 1 and cache is {4=4, 3=3} >>> lru_cache.get(1) # Returns -1 (not found) >>> lru_cache.get(3) # Returns 3 >>> lru_cache.get(4) # Returns 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass def test_lru_cache_put_get(): lru_cache = LRUCache(2) lru_cache.put(1, 1) lru_cache.put(2, 2) assert lru_cache.get(1) == 1 # Cache is {2=2, 1=1} lru_cache.put(3, 3) # Evicts key 2 assert lru_cache.get(2) == -1 # Key 2 not found lru_cache.put(4, 4) # Evicts key 1 assert lru_cache.get(1) == -1 # Key 1 not found assert lru_cache.get(3) == 3 # Cache is {4=4, 3=3} assert lru_cache.get(4) == 4 # Cache is {4=4, 3=3} def test_lru_cache_update_existing_key(): lru_cache = LRUCache(2) lru_cache.put(1, 1) lru_cache.put(2, 2) lru_cache.put(1, 10) # Update key 1 assert lru_cache.get(1) == 10 # Cache is {2=2, 1=10} lru_cache.put(3, 3) # Evicts key 2 assert lru_cache.get(2) == -1 # Key 2 not found assert lru_cache.get(1) == 10 assert lru_cache.get(3) == 3 def test_lru_cache_exceed_capacity(): lru_cache = LRUCache(2) lru_cache.put(1, 1) lru_cache.put(2, 2) lru_cache.put(3, 3) # Evicts key 1 assert lru_cache.get(1) == -1 # Key 1 not found assert lru_cache.get(2) == 2 assert lru_cache.get(3) == 3 lru_cache.put(4, 4) # Evicts key 2 assert lru_cache.get(2) == -1 # Key 2 not found assert lru_cache.get(3) == 3 assert lru_cache.get(4) == 4 def test_lru_cache_empty(): lru_cache = LRUCache(2) assert lru_cache.get(1) == -1 # Cache is empty def test_lru_cache_single_element(): lru_cache = LRUCache(1) lru_cache.put(1, 1) assert lru_cache.get(1) == 1 lru_cache.put(2, 2) # Evicts key 1 assert lru_cache.get(1) == -1 # Key 1 not found assert lru_cache.get(2) == 2","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 # Move the accessed key to the end to mark it as recently used value = self.cache.pop(key) self.cache[key] = value return value def put(self, key: int, value: int) -> None: if key in self.cache: # Remove the old self.cache.pop(key) elif len(self.cache) >= self.capacity: # Remove the first item in the ordered dictionary (least recently used) self.cache.popitem(last=False) # Add the new key and value self.cache[key] = value"},{"question":"def min_moves_to_reach_end(H, W, grid): Determine the minimum number of moves required to move from the top-left corner to the bottom-right corner of the grid. The grid consists of empty cells '.' and obstacles '#'. >>> min_moves_to_reach_end(4, 4, [\\"....\\",\\".#..\\",\\"....\\",\\"....\\"]) 6 >>> min_moves_to_reach_end(3, 3, [\\"...\\",\\"#\\",\\"...\\"]) -1 >>> min_moves_to_reach_end(2, 2, [\\"..\\",\\"..\\"]) 2 >>> min_moves_to_reach_end(3, 3, [\\"#..\\",\\"...\\",\\"..#\\"]) -1 >>> min_moves_to_reach_end(5, 5, [\\".....\\",\\".#.\\",\\".....\\",\\".#.\\",\\".....\\"]) 8 >>> min_moves_to_reach_end(1, 1, [\\".\\"]) 0","solution":"from collections import deque def min_moves_to_reach_end(H, W, grid): if grid[0][0] == '#' or grid[H-1][W-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == H-1 and y == W-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < H and 0 <= ny < W and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # Example usage: H = 4 W = 4 grid = [ \\"....\\", \\".#..\\", \\"....\\", \\"....\\" ] print(min_moves_to_reach_end(H, W, grid)) # Output: 6"},{"question":"def sum_of_palindromes(lst): Returns the sum of all positive palindrome numbers in the list. >>> sum_of_palindromes([121, 12321, -121, 101, 44, 202, \\"hello\\"]) 12789 >>> sum_of_palindromes([1, 11, 22, 33, -33, \\"33\\", 3303]) 3370 >>> sum_of_palindromes([-121, \\"123\\", 123, 21, 0, 141, 232]) 373 >>> sum_of_palindromes([]) 0","solution":"def sum_of_palindromes(lst): Returns the sum of all positive palindrome numbers in the list. def is_palindrome(n): str_n = str(n) return str_n == str_n[::-1] total = 0 for item in lst: if isinstance(item, int) and item > 0 and is_palindrome(item): total += item return total"},{"question":"def collatz_sequence_length(n: int) -> int: Returns the length of the Collatz sequence starting with n. >>> collatz_sequence_length(1) == 1 >>> collatz_sequence_length(2) == 2 >>> collatz_sequence_length(3) == 8 >>> collatz_sequence_length(5) == 6 >>> collatz_sequence_length(10) == 7 def process_collatz_sequences(numbers: List[int]) -> List[int]: Processes a list of numbers and returns list of lengths of their Collatz sequences. >>> process_collatz_sequences([1, 2, 3, 5, 10, 0]) == [1, 2, 8, 6, 7] >>> process_collatz_sequences([7, 8, 9, 0]) == [17, 4, 20] >>> process_collatz_sequences([0]) == []","solution":"def collatz_sequence_length(n): Returns the length of the Collatz sequence starting with n. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length def process_collatz_sequences(numbers): Processes a list of numbers and returns list of lengths of their Collatz sequences. results = [] for number in numbers: if number == 0: break results.append(collatz_sequence_length(number)) return results"},{"question":"def firstNonRepeatingCharacter(S: str) -> int: Given a string S consisting of lowercase alphabets, find the first non-repeating character in the string and return its index. If there is no non-repeating character, return -1. Example 1: >>> firstNonRepeatingCharacter(\\"geeksforgeeks\\") 5 Example 2: >>> firstNonRepeatingCharacter(\\"abcabc\\") -1 Example 3: >>> firstNonRepeatingCharacter(\\"loveleetcode\\") 2","solution":"def firstNonRepeatingCharacter(S): Returns the index of the first non-repeating character in the string S. If there is no non-repeating character, returns -1. char_count = {} # First pass: Count the occurrences of each character for char in S: char_count[char] = char_count.get(char, 0) + 1 # Second pass: Find the first character with a count of 1 for index, char in enumerate(S): if char_count[char] == 1: return index return -1"},{"question":"def move_zeroes(nums): Moves all 0's to the end of the given list while maintaining the relative order of the non-zero elements. This is done in-place without making a copy of the array. :param nums: List of integers >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 1] >>> move_zeroes(nums) >>> nums [1, 0, 0]","solution":"def move_zeroes(nums): Moves all 0's to the end of the given list while maintaining the relative order of the non-zero elements. This is done in-place without making a copy of the array. :param nums: List of integers last_non_zero_found_at = 0 # Move all non-zero elements to the front for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at], nums[i] = nums[i], nums[last_non_zero_found_at] last_non_zero_found_at += 1"},{"question":"def can_reach_target(m: int, energies: List[int], t: int, target: List[int]) -> Union[str, Tuple[str, List[Tuple[int, str]]]]: In an enchanted garden, determine if the plants can rearrange themselves to reach a target configuration of energies after absorbing their neighbors according to the rules described. If possible, output one possible sequence of absorption events that leads to the target configuration. If not, output \\"IMPOSSIBLE\\". >>> can_reach_target(6, [1, 3, 3, 2, 1, 4], 3, [6, 2, 4]) 'IMPOSSIBLE' >>> can_reach_target(4, [2, 4, 6, 8], 2, [10, 10]) 'IMPOSSIBLE' >>> can_reach_target(5, [1, 2, 3, 4, 5], 1, [15]) ('POSSIBLE', [(5, 'L'), (4, 'L'), (3, 'L'), (2, 'L')])","solution":"def can_reach_target(m, energies, t, target): events = [] def merge(plants, index, direction): if direction == 'R': plants[index] += plants.pop(index + 1) events.append((index + 1, 'R')) else: plants[index] += plants.pop(index - 1) events.append((index, 'L')) def find_and_merge(plants): n = len(plants) merged = False for i in range(1, n): if plants[i - 1] > plants[i]: merge(plants, i - 1, 'R') merged = True break if not merged: for i in range(n - 1): if plants[i] < plants[i + 1]: merge(plants, i, 'R') merged = True break return merged plants = energies[:] while len(plants) > t: if not find_and_merge(plants): return \\"IMPOSSIBLE\\" if plants == target: return \\"POSSIBLE\\", events else: return \\"IMPOSSIBLE\\" # Example usage if __name__ == \\"__main__\\": m = 6 energies = [1, 3, 3, 2, 1, 4] t = 3 target = [6, 2, 4] result = can_reach_target(m, energies, t, target) if result == 'IMPOSSIBLE': print(result) else: print(result[0]) for event in result[1]: print(event[0], event[1])"},{"question":"def longestUniqueSubarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with unique elements. Parameters: nums (List[int]): An array of integers. Returns: int: The length of the longest contiguous subarray with all unique elements. Examples: >>> longestUniqueSubarray([2, 1, 1, 3, 2, 1, 4]) 4 >>> longestUniqueSubarray([1, 2, 2, 3]) 2","solution":"def longestUniqueSubarray(nums): Returns the length of the longest contiguous subarray with unique elements. if not nums: return 0 num_set = set() left = 0 max_length = 0 for right in range(len(nums)): while nums[right] in num_set: num_set.remove(nums[left]) left += 1 num_set.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def are_permutations(a: str, b: str) -> str: Returns 'YES' if string 'b' is a permutation of string 'a', otherwise returns 'NO'. >>> are_permutations('listen', 'silent') 'YES' >>> are_permutations('apple', 'pale') 'NO' def check_permutations(test_cases: List[Tuple[str, str]]) -> List[str]: Given a list of test cases, where each pair of strings is represented as a tuple, returns a list of answers where each answer is 'YES' or 'NO' based on whether the second string is a permutation of the first. >>> check_permutations([('listen', 'silent'), ('triangle', 'integral'), ('apple', 'pale')]) ['YES', 'YES', 'NO'] >>> check_permutations([('abc', 'def'), ('ghi', 'ihg'), ('jkl', 'lkj')]) ['NO', 'YES', 'YES'] def process_input(input_data: str) -> Tuple[List[Tuple[str, str]], int]: Processes input data into pairs of strings and the number of test cases. >>> process_input(\\"3nlistennsilentntrianglenintegralnapplenpale\\") ([('listen', 'silent'), ('triangle', 'integral'), ('apple', 'pale')], 3) >>> process_input(\\"2nabcncbanxyznyzx\\") ([('abc', 'cba'), ('xyz', 'yzx')], 2)","solution":"def are_permutations(a, b): Returns 'YES' if string 'b' is a permutation of string 'a', otherwise returns 'NO'. return \\"YES\\" if sorted(a) == sorted(b) else \\"NO\\" def check_permutations(test_cases): Given a list of test cases, where each pair of strings is represented as a tuple, returns a list of answers where each answer is 'YES' or 'NO' based on whether the second string is a permutation of the first. test_cases: List of tuples [(a, b), ...] results = [] for a, b in test_cases: results.append(are_permutations(a, b)) return results # Reading input and processing def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) pairs = [(lines[i * 2 + 1], lines[i * 2 + 2]) for i in range(T)] return pairs, T"},{"question":"def convert_gbit_to_ms(V: int) -> int: Convert the given speed in GBit/s to m/s. >>> convert_gbit_to_ms(2) 300000000 >>> convert_gbit_to_ms(5) 750000000 >>> convert_gbit_to_ms(1) 150000000 pass def process_test_cases(N: int, test_cases: List[int]) -> List[int]: Process multiple test cases and return the results as a list of integers. >>> process_test_cases(3, [2, 5, 1]) [300000000, 750000000, 150000000] >>> process_test_cases(2, [10, 20]) [1500000000, 3000000000] >>> process_test_cases(4, [1, 2, 3, 4]) [150000000, 300000000, 450000000, 600000000] >>> process_test_cases(1, [1000]) [150000000000] pass","solution":"def convert_gbit_to_ms(V): Returns the speed in m/s given the speed in GBit/s. 1 GBit/s is equivalent to 1.5 * 10^8 m/s. return int(V * 1.5 * 10**8) def process_test_cases(N, test_cases): Processes multiple test cases and returns the results as a list of integers. Each element in the returned list is the speed in m/s for the corresponding speed in GBit/s. results = [] for V in test_cases: results.append(convert_gbit_to_ms(V)) return results"},{"question":"def find_mst_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Computes the weight of the minimum spanning tree (MST) using Kruskal's algorithm. If the graph is disconnected, returns \\"DISCONNECTED\\". :param n: The number of vertices in the graph. :param m: The number of edges in the graph. :param edges: List of tuples representing the edges in the graph. Each tuple contains three integers (u, v, w), where u and v are the vertex endpoints and w is the weight of the edge. :return: The weight of the minimum spanning tree or \\"DISCONNECTED\\" if the graph is disconnected. >>> find_mst_weight(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 3), (3, 4, 5)]) 6 >>> find_mst_weight(4, 2, [(1, 2, 1), (3, 4, 1)]) \\"DISCONNECTED\\"","solution":"def find_mst_weight(n, m, edges): Computes the weight of the minimum spanning tree (MST) using Kruskal's algorithm. If the graph is disconnected, returns \\"DISCONNECTED\\". # Helper function to find the root of a set def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to perform union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Initialize the data structures for Kruskal's algorithm parent = [i for i in range(n)] rank = [0] * n # Sort all edges by weight edges.sort(key=lambda x: x[2]) mst_weight = 0 edges_included = 0 # Iterate through sorted edges for u, v, w in edges: u_root = find(parent, u - 1) v_root = find(parent, v - 1) # If including this edge does not cause a cycle if u_root != v_root: union(parent, rank, u_root, v_root) mst_weight += w edges_included += 1 # If we have included n-1 edges, we have our MST if edges_included == n - 1: return mst_weight # If not all vertices are included, the graph is disconnected return \\"DISCONNECTED\\""},{"question":"def minimum_road_length(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum possible total length of roads required to connect all provinces. If it is impossible to connect all the provinces, return -1. :param N: Integer number of provinces :param M: Integer number of possible roads :param roads: List of tuples (u, v, w) representing bidirectional roads :return: Minimum length of roads required to connect all provinces or -1 if impossible >>> minimum_road_length(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 4), (1, 3, 5)]) 6 >>> minimum_road_length(4, 0, []) -1 >>> minimum_road_length(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)]) 6 >>> minimum_road_length(5, 6, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 1), (1, 4, 10), (2, 5, 10)]) 5 >>> minimum_road_length(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 1), (2, 4, 1)]) 3 pass","solution":"def kruskal_minimum_spanning_tree(N, edges): Given number of nodes (N) and a list of edges (u, v, w), this function computes the minimum possible total length of roads required to connect all provinces using Kruskal's algorithm. If it is impossible to connect all provinces, return -1. # Helper function to find the set of an element u def find(parent, u): if parent[u] != u: parent[u] = find(parent, parent[u]) return parent[u] # Helper function to union two subsets def union(parent, rank, u, v): root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Initialize parent and rank arrays parent = list(range(N + 1)) rank = [0] * (N + 1) # Sort edges based on the weight w edges.sort(key=lambda x: x[2]) # Kruskal's algorithm to find minimum spanning tree mst_weight = 0 edge_count = 0 for edge in edges: u, v, w = edge if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += w edge_count += 1 if edge_count == N - 1: return mst_weight # If we can't connect all provinces, return -1 return -1 def minimum_road_length(N, M, roads): This is the main function that uses the Kruskal algorithm to calculate the minimum road length to connect all provinces. :param N: Integer number of provinces :param M: Integer number of possible roads :param roads: List of tuples (u, v, w) representing roads :return: Minimum length of roads required to connect all provinces or -1 if impossible return kruskal_minimum_spanning_tree(N, roads)"},{"question":"from typing import List def majority_suit(cards: List[int]) -> str: Determine the majority suit among a given set of cards. Each card is represented by an integer from 1 to 52. Returns one of the suits \\"Hearts\\", \\"Diamonds\\", \\"Clubs\\", \\"Spades\\" or \\"Tie\\" in case of a tie. >>> majority_suit([1, 2, 14, 27, 40, 46, 52, 3, 28, 41, 12, 26, 27, 50, 27]) 'Clubs' >>> majority_suit([1, 14, 30, 52]) 'Tie' pass from solution import majority_suit def test_majority_suit_hearts(): assert majority_suit([1, 2, 3, 4, 14, 15]) == \\"Hearts\\" def test_majority_suit_diamonds(): assert majority_suit([14, 15, 16, 17, 1, 2, 27, 28, 40, 41]) == \\"Diamonds\\" def test_majority_suit_clubs(): assert majority_suit([27, 28, 29, 30, 31, 1, 2, 40, 41, 42]) == \\"Clubs\\" def test_majority_suit_spades(): assert majority_suit([40, 41, 42, 43, 44, 1, 14, 13, 27]) == \\"Spades\\" def test_majority_suit_tie(): assert majority_suit([1, 14, 27, 40]) == \\"Tie\\" assert majority_suit([1, 2, 14, 15, 27, 28, 40, 41]) == \\"Tie\\" def test_majority_suit_empty(): assert majority_suit([]) == \\"Tie\\" def test_majority_suit_single_card(): assert majority_suit([1]) == \\"Hearts\\" assert majority_suit([14]) == \\"Diamonds\\" assert majority_suit([27]) == \\"Clubs\\" assert majority_suit([40]) == \\"Spades\\"","solution":"def majority_suit(cards): if not cards: return \\"Tie\\" suits_counts = {\\"Hearts\\": 0, \\"Diamonds\\": 0, \\"Clubs\\": 0, \\"Spades\\": 0} for card in cards: if 1 <= card <= 13: suits_counts[\\"Hearts\\"] += 1 elif 14 <= card <= 26: suits_counts[\\"Diamonds\\"] += 1 elif 27 <= card <= 39: suits_counts[\\"Clubs\\"] += 1 elif 40 <= card <= 52: suits_counts[\\"Spades\\"] += 1 max_count = max(suits_counts.values()) majority_suits = [suit for suit, count in suits_counts.items() if count == max_count] if len(majority_suits) > 1: return \\"Tie\\" else: return majority_suits[0]"},{"question":"def max_rows(n: int) -> int: Calculate the maximum number of rows Sarah can completely fill with her seashells. Parameters: n (int): The number of seashells Returns: int: The maximum number of completely filled rows >>> max_rows(10) 4 >>> max_rows(7) 3 >>> max_rows(1) 1 >>> max_rows(100) 13 >>> max_rows(15) 5 >>> max_rows(999500) 1413","solution":"def max_rows(n): Calculate the maximum number of rows Sarah can completely fill with her seashells. Parameters: n (int): The number of seashells Returns: int: The maximum number of completely filled rows rows = 0 while n >= rows + 1: rows += 1 n -= rows return rows"},{"question":"from collections import defaultdict, deque class KingdomArda: def __init__(self, n): Initialize the KingdomArda with n cities. >>> kingdom = KingdomArda(5) self.n = n self.graph = defaultdict(list) self.closed_roads = set() def add_road(self, a, b): Add a road between cities a and b. >>> kingdom.add_road(1, 2) >>> kingdom.add_road(1, 3) self.graph[a].append(b) self.graph[b].append(a) def close_road(self, a, b): Close the road between cities a and b. >>> kingdom.close_road(1, 3) self.closed_roads.add((a, b)) self.closed_roads.add((b, a)) def reopen_road(self, a, b): Reopen the road between cities a and b. >>> kingdom.reopen_road(1, 3) self.closed_roads.discard((a, b)) self.closed_roads.discard((b, a)) def can_reach(self, x): Check if city x can be reached from the capital city 1 and return the number of roads traveled or report that it is impossible. >>> kingdom.can_reach(4) 'YES 2' >>> kingdom.can_reach(5) 'NO' if x == 1: return \\"YES 0\\" visited = set() queue = deque([(1, 0)]) while queue: city, depth = queue.popleft() if city == x: return f\\"YES {depth}\\" if city not in visited: visited.add(city) for neighbor in self.graph[city]: if (city, neighbor) not in self.closed_roads and neighbor not in visited: queue.append((neighbor, depth + 1)) return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) idx += 1 kingdom = KingdomArda(N) for _ in range(N-1): A = int(data[idx]) B = int(data[idx+1]) idx += 2 kingdom.add_road(A, B) Q = int(data[idx]) idx += 1 result = [] for _ in range(Q): query_type = int(data[idx]) if query_type == 0: X = int(data[idx + 1]) result.append(kingdom.can_reach(X)) idx += 2 elif query_type == 1: A = int(data[idx + 1]) B = int(data[idx + 2]) kingdom.close_road(A, B) idx += 3 elif query_type == 2: A = int(data[idx + 1]) B = int(data[idx + 2]) kingdom.reopen_road(A, B) idx += 3 for res in result: print(res) if __name__ == \\"__main__\\": main()","solution":"from collections import defaultdict, deque class KingdomArda: def __init__(self, n): self.n = n self.graph = defaultdict(list) self.closed_roads = set() def add_road(self, a, b): self.graph[a].append(b) self.graph[b].append(a) def close_road(self, a, b): self.closed_roads.add((a, b)) self.closed_roads.add((b, a)) def reopen_road(self, a, b): self.closed_roads.discard((a, b)) self.closed_roads.discard((b, a)) def can_reach(self, x): if x == 1: return \\"YES 0\\" # BFS to find the shortest path from capital city 1 to city X visited = set() queue = deque([(1, 0)]) while queue: city, depth = queue.popleft() if city == x: return f\\"YES {depth}\\" if city not in visited: visited.add(city) for neighbor in self.graph[city]: if (city, neighbor) not in self.closed_roads and neighbor not in visited: queue.append((neighbor, depth + 1)) return \\"NO\\" # Sample usage (according to the example provided) def main(): import sys input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) idx += 1 kingdom = KingdomArda(N) for _ in range(N-1): A = int(data[idx]) B = int(data[idx+1]) idx += 2 kingdom.add_road(A, B) Q = int(data[idx]) idx += 1 result = [] for _ in range(Q): query_type = int(data[idx]) if query_type == 0: X = int(data[idx + 1]) result.append(kingdom.can_reach(X)) idx += 2 elif query_type == 1: A = int(data[idx + 1]) B = int(data[idx + 2]) kingdom.close_road(A, B) idx += 3 elif query_type == 2: A = int(data[idx + 1]) B = int(data[idx + 2]) kingdom.reopen_road(A, B) idx += 3 for res in result: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def gcd(a, b): Computes the greatest common divisor (gcd) of two numbers using the Euclidean algorithm. >>> gcd(28, 35) 7 >>> gcd(15, 25) 5 pass def prime_factors(n): Returns the prime factors of a given number as a set. >>> prime_factors(28) {2, 7} >>> prime_factors(35) {5, 7} pass def common_prime_factors(a, b): Returns the common prime factors of two given numbers as a space-separated string. If there are no common prime factors, returns 'None'. >>> common_prime_factors(28, 35) '7' >>> common_prime_factors(15, 25) '5' >>> common_prime_factors(100, 10) '2 5' >>> common_prime_factors(17, 19) 'None' pass def main(): Reads input, processes each test case, and prints out the common prime factors for each. pass # Unit tests def test_gcd(): assert gcd(28, 35) == 7 assert gcd(15, 25) == 5 assert gcd(100, 10) == 10 assert gcd(17, 19) == 1 def test_prime_factors(): assert prime_factors(28) == {2, 7} assert prime_factors(35) == {5, 7} assert prime_factors(15) == {3, 5} assert prime_factors(25) == {5} def test_common_prime_factors(): assert common_prime_factors(28, 35) == '7' assert common_prime_factors(15, 25) == '5' assert common_prime_factors(100, 10) == '2 5' assert common_prime_factors(17, 19) == 'None' def test_main(capsys): import builtins input_values = ['2', '28 35', '15 25'] expected_output = '7n5n' builtins.input = lambda: input_values.pop(0) main() captured = capsys.readouterr() assert captured.out == expected_output","solution":"def gcd(a, b): while b != 0: a, b = b, a % b return a def prime_factors(n): i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors def common_prime_factors(a, b): gcd_ab = gcd(a, b) common_factors = prime_factors(gcd_ab) if common_factors: return ' '.join(map(str, sorted(common_factors))) else: return 'None' def main(): t = int(input()) results = [] for _ in range(t): a, b = map(int, input().split()) results.append(common_prime_factors(a, b)) for result in results: print(result)"},{"question":"def max_sum_path(matrix): Returns the maximum sum of elements collected by moving either to the right, down, or diagonally to the bottom right from the top-left corner to the bottom-right corner of the matrix. pass def create_matrix(input_string): Parses an input string to create the matrix. lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) matrix = [list(map(int, line.split())) for line in lines[1:]] return matrix","solution":"def max_sum_path(matrix): Returns the maximum sum of elements collected by moving either to the right, down, or diagonally to the bottom right from the top-left corner to the bottom-right corner of the matrix. rows = len(matrix) cols = len(matrix[0]) # To handle dynamic programming table dp = [[0]*cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Fill the first row & first column for i in range(1, cols): dp[0][i] = dp[0][i-1] + matrix[0][i] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[rows-1][cols-1] # For testing purposes, let's add this helper function. def create_matrix(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) matrix = [list(map(int, line.split())) for line in lines[1:]] return matrix"},{"question":"def max_non_decreasing_sequence(n: int, heights: List[int]) -> int: Determine the maximum number of trees you can leave that form a non-decreasing sequence. :param n: Number of trees :param heights: List of tree heights :return: Maximum number of trees forming a non-decreasing sequence >>> max_non_decreasing_sequence(5, [3, 4, 2, 6, 1]) 3 >>> max_non_decreasing_sequence(7, [1, 2, 2, 3, 1, 5, 6]) 6 >>> max_non_decreasing_sequence(6, [10, 20, 10, 20, 10, 20]) 4 >>> max_non_decreasing_sequence(4, [4, 4, 4, 4]) 4 from typing import List def test_example_1(): assert max_non_decreasing_sequence(5, [3, 4, 2, 6, 1]) == 3 def test_example_2(): assert max_non_decreasing_sequence(7, [1, 2, 2, 3, 1, 5, 6]) == 6 def test_example_3(): assert max_non_decreasing_sequence(6, [10, 20, 10, 20, 10, 20]) == 4 def test_example_4(): assert max_non_decreasing_sequence(4, [4, 4, 4, 4]) == 4 def test_empty(): assert max_non_decreasing_sequence(0, []) == 0 def test_single_tree(): assert max_non_decreasing_sequence(1, [10]) == 1 def test_all_increasing(): assert max_non_decreasing_sequence(5, [1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert max_non_decreasing_sequence(5, [5, 4, 3, 2, 1]) == 1","solution":"def max_non_decreasing_sequence(n, heights): Returns the maximum number of trees that can be left to form a non-decreasing sequence. :param n: Number of trees :param heights: List of tree heights :return: Maximum number of trees forming a non-decreasing sequence # Implementing using the Longest Non-decreasing Subsequence approach if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def process_queries(n: int, q: int, battery_levels: List[int], queries: List[List[int]]) -> List[int]: Simulate operations on a list of robots' battery levels and return results of queries. Args: n (int): The number of robots. q (int): The number of queries. battery_levels (List[int]): Initial battery levels of the robots. queries (List[List[int]]): List of operations to be performed on the robots. Returns: List[int]: Results of the battery level queries. Examples: >>> process_queries(5, 5, [10, 20, 30, 40, 50], [[1, 2, 4, 10], [2, 3], [1, 1, 5, 5], [2, 5], [2, 1]]) [40, 55, 15] >>> process_queries(3, 1, [1, 2, 3], [[1, 1, 3, 5]]) [] >>> process_queries(3, 1, [1, 2, 3], [[2, 2]]) [2] >>> process_queries(4, 6, [5, 10, 15, 20], [[1, 1, 2, 5], [2, 1], [1, 3, 4, 10], [2, 3], [1, 2, 3, 2], [2, 2]]) [10, 25, 17] >>> process_queries(3, 0, [1, 2, 3], []) [] >>> process_queries(1, 1, [0], [[2, 1]]) [0] >>> process_queries(2, 2, [0, 1000000], [[1, 1, 2, 100000], [2, 2]]) [1100000]","solution":"def process_queries(n, q, battery_levels, queries): result = [] # Initialize the battery level array batteries = battery_levels[:] # Process each query for query in queries: if query[0] == 1: # Add charge to a range l, r, x = query[1] - 1, query[2] - 1, query[3] for i in range(l, r + 1): batteries[i] += x elif query[0] == 2: # Query the battery level of a specific robot i = query[1] - 1 result.append(batteries[i]) return result"},{"question":"import re def longest_word(sentence: str) -> str: Given a string of words separated by whitespace, return the longest word in the string. If there are multiple words of the same maximum length, return the one that appears first. Ignore punctuation and other non-alphabetic characters in the string. >>> longest_word(\\"The quick brown fox jumped over the lazy dog.\\") == \\"jumped\\" >>> longest_word(\\"Hello, world! This is a test-case.\\") == \\"testcase\\" >>> longest_word(\\"A delivery of very large packages has arrived.\\") == \\"delivery\\" >>> longest_word(\\"The big bad fox.\\") == \\"The\\" >>> longest_word(\\"Amazing!\\") == \\"Amazing\\" >>> longest_word(\\"\\") == \\"\\" >>> longest_word(\\"!!! ???\\") == \\"\\"","solution":"import re def longest_word(sentence): Returns the longest word in the given sentence. If multiple words have the same length, returns the first one that appears. Ignores punctuation and non-alphabetic characters. # Remove any characters that are not letters or whitespace sanitized_sentence = re.sub('[^a-zA-Z ]+', '', sentence) # Split the sentence into words words = sanitized_sentence.split() # Initialize variables to hold the longest word and its length longest = \\"\\" max_length = 0 # Iterate over the words to find the longest one for word in words: if len(word) > max_length: longest = word max_length = len(word) return longest"},{"question":"from typing import List, Tuple def is_path_from_1_to_n(n: int, m: int, routes: List[Tuple[int, int, int]]) -> str: Determine if there is a path from bus stop 1 to bus stop n using the available bus routes. >>> is_path_from_1_to_n(4, 4, [(1, 2, 0), (2, 3, 1), (3, 4, 0), (2, 4, 1)]) == \\"Yes\\" >>> is_path_from_1_to_n(4, 3, [(1, 2, 0), (2, 3, 1), (4, 3, 1)]) == \\"No\\"","solution":"from collections import defaultdict, deque def is_path_from_1_to_n(n, m, routes): graph = defaultdict(list) # Construct the graph for u, v, d in routes: graph[u].append(v) if d == 0: # add the reverse edge for two-way routes graph[v].append(u) # BFS to find path from 1 to n def bfs(start, target): visited = set() queue = deque([start]) while queue: current = queue.popleft() if current in visited: continue visited.add(current) if current == target: return True for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False return \\"Yes\\" if bfs(1, n) else \\"No\\""},{"question":"def is_happy_number(n: int) -> str: Determines if a number is a happy number. Args: n (int): The number to check. Returns: str: \\"Happy\\" if the number is a happy number, otherwise \\"Unhappy\\". >>> is_happy_number(19) \\"Happy\\" >>> is_happy_number(4) \\"Unhappy\\" >>> is_happy_number(7) \\"Happy\\" >>> is_happy_number(10) \\"Happy\\" >>> is_happy_number(100) \\"Happy\\" >>> is_happy_number(1) \\"Happy\\" >>> is_happy_number(2) \\"Unhappy\\" >>> is_happy_number(20) \\"Unhappy\\" >>> is_happy_number(18) \\"Unhappy\\" >>> is_happy_number(3) \\"Unhappy\\"","solution":"def is_happy_number(n): Determines if a number is a happy number. Args: n (int): The number to check. Returns: str: \\"Happy\\" if the number is a happy number, otherwise \\"Unhappy\\". def get_next(number): return sum(int(char) ** 2 for char in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return \\"Happy\\" if n == 1 else \\"Unhappy\\""},{"question":"def top_selling_products(n: int, categories: List[int], sales: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Find the top-selling product in each category. Args: n (int): The number of products. categories (List[int]): The list of categories for each product. sales (List[int]): The list of sales for each product. Returns: Tuple[int, List[Tuple[int, int]]]: The number of unique categories and a list of tuples where each tuple contains a category ID and the product ID of the best-selling product in that category. Examples: >>> top_selling_products(8, [1, 2, 1, 3, 2, 2, 1, 3], [100, 200, 50, 300, 400, 150, 250, 100]) (3, [(1, 7), (2, 5), (3, 4)]) >>> top_selling_products(5, [1, 1, 1, 1, 1], [10, 20, 15, 25, 5]) (1, [(1, 4)]) >>> top_selling_products(6, [1, 2, 1, 2, 3, 3], [50, 30, 100, 200, 150, 80]) (3, [(1, 3), (2, 4), (3, 5)]) >>> top_selling_products(4, [1, 1, 2, 2], [200, 200, 100, 100]) (2, [(1, 1), (2, 3)]) >>> top_selling_products(3, [1, 2, 3], [0, 0, 0]) (3, [(1, 1), (2, 2), (3, 3)])","solution":"def top_selling_products(n, categories, sales): from collections import defaultdict category_best = defaultdict(lambda: (-1, -1)) for i in range(n): cat = categories[i] sales_count = sales[i] product_id = i + 1 if sales_count > category_best[cat][0] or (sales_count == category_best[cat][0] and product_id < category_best[cat][1]): category_best[cat] = (sales_count, product_id) result = [] for cat in sorted(category_best.keys()): result.append((cat, category_best[cat][1])) return len(result), result"},{"question":"def compress_string(s: str) -> str: Compress the given string as per the specified algorithm. The compression algorithm replaces consecutive groups of the same character with the character followed by the frequency of that character group. If the frequency of any group is 1, it is replaced by the character without any frequency appended. >>> compress_string(\\"aaabbccdee\\") \\"a3b2c2de2\\" >>> compress_string(\\"abcde\\") \\"abcde\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"aaaaa\\") \\"a5\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"aabbaa\\") \\"a2b2a2\\" >>> compress_string(\\"a\\"*100000) \\"a100000\\"","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + (str(count) if count > 1 else '')) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else '')) return ''.join(compressed)"},{"question":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearranges a string such that no two adjacent characters are the same. Returns \\"Not Possible\\" if such an arrangement is not possible. >>> rearrange_string(\\"aab\\") in [\\"aba\\", \\"aab\\"] True >>> rearrange_string(\\"aaab\\") \\"Not Possible\\" >>> rearrange_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbabc\\", \\"bacbac\\", \\"bcabca\\", \\"cabacb\\", \\"cbacba\\"] True def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns their results. >>> test_cases = [\\"aab\\", \\"aaab\\", \\"aabbcc\\"] >>> process_test_cases(test_cases) [\\"aba\\", \\"Not Possible\\", \\"abcabc\\"]","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges a string such that no two adjacent characters are the same. Returns \\"Not Possible\\" if such an arrangement is not possible. # Step 1: Count the frequency of each character char_count = Counter(s) # Step 2: Build a max heap based on the frequency of characters max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) # Step 3: Construct the rearranged string prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # Since we used one instance of 'char', we decrease the frequency if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 # Decrease frequency because we used one instance of \`char\` prev_char = char rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return \\"Not Possible\\" return rearranged_string def process_test_cases(test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"def can_make_even(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if you can make all elements of the array even using the allowed operations. Args: t : int : the number of test cases test_cases : List[Tuple[int, List[int]]] : a list of tuples where each tuple contains an integer n and a list of n integers. Returns: List[str] : a list of strings where each string is \\"YES\\" if you can make all elements even, otherwise \\"NO\\" >>> can_make_even(4, [(3, [1, 2, 3]), (4, [2, 4, 6, 8]), (2, [7, 5]), (5, [0, 0, 0, 0, 1])]) ['YES', 'YES', 'YES', 'NO'] >>> can_make_even(1, [(3, [1, 1, 1])]) ['NO'] >>> can_make_even(2, [(3, [2, 4, 6]), (3, [1, 3, 5])]) ['YES', 'NO'] >>> can_make_even(1, [(4, [0, 0, 0, 0])]) ['YES']","solution":"def can_make_even(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] odd_count = sum(1 for x in arr if x % 2 != 0) # Check if we can make all elements even if odd_count % 2 == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def process_queries(n: int, m: int, q: int, prices: List[int], roads: List[Tuple[int, int]], queries: List[Tuple[str, int, int]]) -> List[int]: Handle ticket price updates and minimal ticket price queries between cinemas. Args: n (int): Number of cinemas. m (int): Number of roads. q (int): Number of queries. prices (List[int]): List of ticket prices for each cinema. roads (List[Tuple[int, int]]): List of tuples representing roads between cinemas. queries (List[Tuple[str, int, int]]): List of queries to be processed. Returns: List[int]: Results of \\"B\\" type queries. Examples: >>> process_queries(3, 3, 3, [5, 3, 7], [(1, 2), (2, 3), (1, 3)], [('B', 1, 3), ('T', 2, 1), ('B', 1, 3)]) [3, 1] >>> process_queries(3, 3, 1, [5, 3, 7], [(1, 2), (2, 3), (1, 3)], [('B', 1, 2)]) [3] pass","solution":"def process_queries(n, m, q, prices, roads, queries): from collections import defaultdict, deque import heapq def build_adj_list(roads): adj_list = defaultdict(list) for a, b in roads: adj_list[a].append(b) adj_list[b].append(a) return adj_list def dijkstra_min_price(start, prices, adj_list): pq = [(prices[start - 1], start)] min_price = {} while pq: current_price, node = heapq.heappop(pq) if node in min_price: continue min_price[node] = current_price for neighbor in adj_list[node]: if neighbor not in min_price: next_price = min(current_price, prices[neighbor - 1]) heapq.heappush(pq, (next_price, neighbor)) return min_price adj_list = build_adj_list(roads) min_price_cache = {} result = [] for query in queries: if query[0] == 'T': a, p = query[1], query[2] prices[a - 1] = p min_price_cache.clear() elif query[0] == 'B': a, b = query[1], query[2] if (a, b) not in min_price_cache: min_price_from_a = dijkstra_min_price(a, prices, adj_list) min_price_cache[(a, b)] = min_price_from_a[b] min_price_cache[(b, a)] = min_price_from_a[b] result.append(min_price_cache[(a, b)]) return result # Example usage: n = 3 m = 3 q = 3 prices = [5, 3, 7] roads = [(1, 2), (2, 3), (1, 3)] queries = [('B', 1, 3), ('T', 2, 1), ('B', 1, 3)] result = process_queries(n, m, q, prices, roads, queries) print(result)"},{"question":"def transform_sequence(n: int, sequence: List[int], m: int, operations: List[Tuple[int, int]]) -> List[int]: Transforms the sequence based on the given replacement rules (operations) until no more replacements can be applied. :param n: Length of the sequence :param sequence: List of integers constituting the sequence :param m: Number of operations :param operations: List of tuples [(x, y),...] defining the replacement rules :return: Transformed sequence >>> transform_sequence(5, [1, 2, 2, 3, 4], 3, [(2, 3), (3, 1), (4, 0)]) [1, 1, 1, 1, 0] >>> transform_sequence(3, [0, 1, 2], 2, [(0, 2), (2, 1)]) [1, 1, 1] >>> transform_sequence(4, [5, 6, 7, 8], 1, [(6, 5)]) [5, 5, 7, 8] >>> transform_sequence(6, [1, 2, 2, 1, 0, 3], 4, [(1, 0), (2, 3), (3, 4), (4, 0)]) [0, 0, 0, 0, 0, 0] >>> transform_sequence(3, [10, 20, 30], 2, [(20, 10), (10, 30)]) [30, 30, 30]","solution":"def transform_sequence(n, sequence, m, operations): Transforms the sequence based on the given replacement rules (operations) until no more replacements can be applied. :param n: Length of the sequence :param sequence: List of integers constituting the sequence :param m: Number of operations :param operations: List of tuples [(x, y),...] defining the replacement rules :return: Transformed sequence # Apply the transformation rules until no more changes occur while True: # Flag to check if a change was made changed = False # Iterate over each operation (x, y) for (x, y) in operations: while x in sequence: idx = sequence.index(x) sequence[idx] = y changed = True # If no changes were made in this iteration, stop if not changed: break return sequence"},{"question":"from typing import List, Dict, Union def format_people_info(people_list: List[Dict[str, Union[str, int]]]) -> List[str]: Takes a list of dictionaries, where each dictionary contains the keys 'name' and 'age'. Returns a list of strings in the format: \\"Name is Age years old.\\" :param people_list: List[Dict[str, Union[str, int]]] - List of dictionaries with keys 'name' and 'age' :return: List[str] - List of formatted strings >>> format_people_info([{'name': 'Alice', 'age': 30}]) == [\\"Alice is 30 years old\\"] >>> format_people_info([{'name': 'Bob', 'age': 25}, {'name': 'Carol', 'age': 40}]) == [\\"Bob is 25 years old\\", \\"Carol is 40 years old\\"] >>> format_people_info([]) == [] >>> format_people_info([{'name': 'Dave', 'age': 22}, {'name': 'Eve', 'age': 28}, {'name': 'Frank', 'age': 33}]) == [ \\"Dave is 22 years old\\", \\"Eve is 28 years old\\", \\"Frank is 33 years old\\"] >>> format_people_info([{'name': 'Zoe', 'age': 19}, {'name': 'Christina', 'age': 35}]) == [ \\"Zoe is 19 years old\\", \\"Christina is 35 years old\\"]","solution":"def format_people_info(people_list): Takes a list of dictionaries, where each dictionary contains the keys 'name' and 'age'. Returns a list of strings in the format: \\"Name is Age years old.\\" :param people_list: List[Dict[str, Union[str, int]]] - List of dictionaries with keys 'name' and 'age' :return: List[str] - List of formatted strings return [f\\"{person['name']} is {person['age']} years old\\" for person in people_list]"},{"question":"def manage_robots(n: int, m: int, commands: List[str]) -> List[int]: Manages commands to move robots to specific positions and queries their positions. Args: n : int : number of robots m : int : number of commands commands : List[str] : list of commands, each represented as a string Returns: List[int] : list of positions resulting from type 2 commands >>> n = 3 >>> m = 5 >>> commands = [ ... \\"1 1 5\\", ... \\"1 2 7\\", ... \\"2 1\\", ... \\"1 1 2\\", ... \\"2 1\\" ... ] >>> manage_robots(n, m, commands) [5, 2]","solution":"def manage_robots(n, m, commands): # Initialize positions of robots from 1 to n with None (no position) positions = [None] * (n + 1) # Output list to store results of type 2 commands output = [] # Process each command for command in commands: command = command.split() command_type = int(command[0]) robot_id = int(command[1]) # If command is of type 1 if command_type == 1: position = int(command[2]) positions[robot_id] = position # If command is of type 2 elif command_type == 2: output.append(positions[robot_id]) return output"},{"question":"from typing import List def is_path_exists(parking_lot: List[List[str]]) -> bool: Determine if there is a path from the top-left corner to the bottom-right corner of a parking lot represented as a 2D grid. The path can only traverse free spaces (\\".\\"), and cannot pass through walls (\\"#\\") or parked cars (\\"C\\"). >>> is_path_exists([ ... [\\".\\", \\".\\", \\".\\", \\"#\\"], ... [\\".\\", \\"#\\", \\".\\", \\".\\"], ... [\\".\\", \\"#\\", \\"C\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\"] ... ]) True >>> is_path_exists([ ... [\\".\\", \\"#\\", \\"#\\", \\"#\\"], ... [\\"#\\", \\"#\\", \\"C\\", \\"C\\"], ... [\\".\\", \\"#\\", \\"C\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\"] ... ]) False :param parking_lot: List[List[str]] - a 2D grid representing the parking lot :return: bool - True if a path exists, False otherwise pass def test_is_path_exists_case1(): parking_lot = [ [\\".\\", \\".\\", \\".\\", \\"#\\"], [\\".\\", \\"#\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\"C\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\"] ] assert is_path_exists(parking_lot) == True def test_is_path_exists_case2(): parking_lot = [ [\\".\\", \\"#\\", \\"#\\", \\"#\\"], [\\"#\\", \\"#\\", \\"C\\", \\"C\\"], [\\".\\", \\"#\\", \\"C\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\"] ] assert is_path_exists(parking_lot) == False def test_is_path_exists_blocked_start(): parking_lot = [ [\\"C\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\"C\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\"] ] assert is_path_exists(parking_lot) == False def test_is_path_exists_blocked_end(): parking_lot = [ [\\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\"C\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"C\\"] ] assert is_path_exists(parking_lot) == False def test_is_path_exists_open_path(): parking_lot = [ [\\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\"] ] assert is_path_exists(parking_lot) == True def test_is_path_exists_single_cell_open(): parking_lot = [[\\".\\"]] assert is_path_exists(parking_lot) == True def test_is_path_exists_single_cell_blocked(): parking_lot = [[\\"C\\"]] assert is_path_exists(parking_lot) == False","solution":"from typing import List from collections import deque def is_path_exists(parking_lot: List[List[str]]) -> bool: rows, cols = len(parking_lot), len(parking_lot[0]) if parking_lot[0][0] != \\".\\" or parking_lot[rows - 1][cols - 1] != \\".\\": return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: current_row, current_col = queue.popleft() if (current_row, current_col) == (rows - 1, cols - 1): return True for dr, dc in directions: nr, nc = current_row + dr, current_col + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if parking_lot[nr][nc] == \\".\\": queue.append((nr, nc)) visited.add((nr, nc)) return False"},{"question":"from typing import List def highestFrequencyPrimeFactors(arr: List[int]) -> List[int]: Given a list of integers, returns a new list of integers where each element is the highest frequency prime factor of each element of the original list. If an element has no prime factors (i.e., it is less than 2), return that element as is in the new list. >>> highestFrequencyPrimeFactors([18, 28, 15, 1, 97]) [3, 2, 3, 1, 97] >>> highestFrequencyPrimeFactors([12, 30, 11]) [2, 2, 11] >>> highestFrequencyPrimeFactors([2, 3, 4]) [2, 3, 2] >>> highestFrequencyPrimeFactors([6, 8, 14]) [2, 2, 2] >>> highestFrequencyPrimeFactors([5, 0, 8, 7, 20, 1000]) [5, 0, 2, 7, 2, 2] >>> highestFrequencyPrimeFactors([]) [] >>> highestFrequencyPrimeFactors([1, 0, -1]) [1, 0, -1] >>> highestFrequencyPrimeFactors([2, -3, -4]) [2, -3, -4] >>> highestFrequencyPrimeFactors([16]) [2] >>> highestFrequencyPrimeFactors([30, 16, 81]) [2, 2, 3]","solution":"from typing import List, Dict def highestFrequencyPrimeFactors(arr: List[int]) -> List[int]: def prime_factors(n: int) -> Dict[int, int]: factors = {} d = 2 while n >= 2: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 return factors def most_frequent_prime(factors: Dict[int, int]) -> int: if not factors: return None # Find the prime factor with the highest frequency max_freq = max(factors.values()) # among those, select the smallest prime factor return min(key for key, value in factors.items() if value == max_freq) result = [] for num in arr: if num < 2: result.append(num) else: factors = prime_factors(num) result.append(most_frequent_prime(factors)) return result"},{"question":"class TreeNode: def __init__(self, key): self.data = key self.left = None self.right = None def findFloor(root, x): Find the floor of x in a binary search tree. Args: root (TreeNode): The root of the binary search tree. x (int): The value to find the floor of. Returns: int: The floor value of x in the binary search tree. Example: >>> root = TreeNode(8) >>> root.left = TreeNode(4) >>> root.right = TreeNode(12) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(6) >>> root.left.left.left = TreeNode(1) >>> root.right.right = TreeNode(14) >>> findFloor(root, 5) 4 >>> root = TreeNode(15) >>> root.left = TreeNode(10) >>> root.right = TreeNode(20) >>> root.left.left = TreeNode(8) >>> root.left.right = TreeNode(12) >>> root.right.left = TreeNode(16) >>> root.right.right = TreeNode(25) >>> findFloor(root, 22) 20","solution":"class TreeNode: def __init__(self, key): self.data = key self.left = None self.right = None def findFloor(root, x): Find the floor of x in a binary search tree. floor = -1 while root: if root.data == x: return root.data elif root.data > x: root = root.left else: floor = root.data root = root.right return floor"},{"question":"def min_total_weights(N, M, W, edges): Returns the minimum total sum of weights to satisfy the condition for all edges. >>> min_total_weights(4, 4, 5, [(1, 2), (2, 3), (3, 4), (4, 1)]) 10 >>> min_total_weights(5, 3, 7, [(1, 2), (1, 3), (4, 5)]) 14 # Your code here # Unit Tests def test_min_total_weights_example1(): edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert min_total_weights(4, 4, 5, edges) == 10 def test_min_total_weights_example2(): edges = [(1, 2), (1, 3), (4, 5)] assert min_total_weights(5, 3, 7, edges) == 14 def test_min_total_weights_no_edges(): edges = [] assert min_total_weights(3, 0, 10, edges) == 0 def test_min_total_weights_single_edge(): edges = [(1, 2)] assert min_total_weights(2, 1, 4, edges) == 8 def test_min_total_weights_complex_example(): edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)] assert min_total_weights(5, 5, 6, edges) == 12","solution":"def min_total_weights(N, M, W, edges): Returns the minimum total sum of weights to satisfy the condition for all edges. if M == 0: return 0 # Assign a weight of W to the minimum number of vertex pairs to cover all edges return W * 2 # Example usage edges = [(1, 2), (2, 3), (3, 4), (4, 1)] print(min_total_weights(4, 4, 5, edges)) # Output: 10"},{"question":"def maximum_product_of_three(lst): Returns the maximum product of any three integers from the list. >>> maximum_product_of_three([1, 2, 3, 4, 5]) 60 >>> maximum_product_of_three([-10, -10, 1, 2, 3]) 300 >>> maximum_product_of_three([-1, -2, -3, -4, -5]) -6 >>> maximum_product_of_three([-4, -3, 1, 2, 7]) 84 >>> maximum_product_of_three([-1, 0, 1, 2, 3]) 6 >>> maximum_product_of_three([1, 2, -3]) -6 >>> maximum_product_of_three([1, 2, 3]) 6","solution":"def maximum_product_of_three(lst): Returns the maximum product of any three integers from the list. if len(lst) < 3: raise ValueError(\\"List must contain at least three numbers.\\") lst.sort() # Maximum product of three numbers can be from the highest three numbers # or from two smallest (negative) numbers and the highest positive number. max_product = max(lst[-1] * lst[-2] * lst[-3], lst[0] * lst[1] * lst[-1]) return max_product def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) lst = list(map(int, data[1:])) print(maximum_product_of_three(lst)) if __name__ == \\"__main__\\": main()"},{"question":"def can_pass_through_checkpoints(n: int, k: int, items: List[int]) -> str: Determine if a citizen can pass through all the checkpoints without carrying more than the allowed number of high-value items at any checkpoint. Args: n (int): number of checkpoints. k (int): maximum allowed number of high-value items. items (List[int]): list of integers representing high-value items at each checkpoint. Returns: str: \\"YES\\" if the citizen can pass through all checkpoints without exceeding k items, otherwise \\"NO\\". Example: >>> can_pass_through_checkpoints(5, 3, [1, 2, 3, 4, 2]) \\"NO\\" >>> can_pass_through_checkpoints(4, 5, [4, 5, 2, 3]) \\"YES\\"","solution":"def can_pass_through_checkpoints(n, k, items): for item in items: if item > k: return \\"NO\\" return \\"YES\\""},{"question":"def can_transform(source: str, target: str) -> str: Determines if the source string can be transformed into the target string using the allowed operations: swap, remove, add characters. >>> can_transform(\\"abc\\", \\"bca\\") 'YES' >>> can_transform(\\"abc\\", \\"def\\") 'NO' >>> can_transform(\\"abc\\", \\"abcd\\") 'YES' >>> can_transform(\\"abcd\\", \\"ab\\") 'YES' from collections import Counter def test_example_case_1(): assert can_transform(\\"abc\\", \\"bca\\") == \\"YES\\" def test_example_case_2(): assert can_transform(\\"abc\\", \\"def\\") == \\"NO\\" def test_example_case_3(): assert can_transform(\\"abc\\", \\"abcd\\") == \\"YES\\" def test_example_case_4(): assert can_transform(\\"abcd\\", \\"ab\\") == \\"YES\\" def test_single_char_different(): assert can_transform(\\"a\\", \\"b\\") == \\"YES\\" def test_same_string(): assert can_transform(\\"hello\\", \\"hello\\") == \\"YES\\" def test_one_char_different_with_add(): assert can_transform(\\"abc\\", \\"abcc\\") == \\"YES\\" def test_one_char_different_with_remove(): assert can_transform(\\"abc\\", \\"ac\\") == \\"YES\\" def test_completely_different(): assert can_transform(\\"xyz\\", \\"abc\\") == \\"NO\\"","solution":"def can_transform(source, target): Determines if the source string can be transformed into the target string using the allowed operations: swap, remove, add characters. # Use Counter to count characters frequencies from collections import Counter source_counter = Counter(source) target_counter = Counter(target) # Check if the difference between character counts # of source and target strings is not greater than 1. diff_count = sum((source_counter - target_counter).values()) + sum((target_counter - source_counter).values()) # If total number of different characters is 0 or 2, transformation is possible return \\"YES\\" if diff_count <= 2 else \\"NO\\""},{"question":"def min_bridge_cost(n, m, bridges): Determine the minimum cost required to connect all islands with a system of bridges. Use Kruskal's or Prim's algorithm to find the Minimum Spanning Tree (MST). Args: n (int): Number of islands. m (int): Number of potential bridges. bridges (list of tuple): Each tuple contains three integers u, v, and c, where u and v represent the landmarks connected by the bridge, and c represents the cost to construct the bridge. Returns: int: The minimum total cost to ensure every island is connected to at least one other island. Example: >>> n = 4 >>> m = 5 >>> bridges = [ >>> (0, 1, 1), >>> (0, 2, 2), >>> (0, 3, 3), >>> (1, 2, 4), >>> (2, 3, 5) >>> ] >>> min_bridge_cost(n, m, bridges) 6 pass # Example test case n = 4 m = 5 bridges = [ (0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 2, 4), (2, 3, 5) ] print(min_bridge_cost(n, m, bridges)) # Output: 6","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def min_bridge_cost(n, m, bridges): # Kruskal's algorithm to find MST and thus the minimum cost bridges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n min_cost = 0 edges_used = 0 for u, v, c in bridges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: min_cost += c union(parent, rank, root_u, root_v) edges_used += 1 if edges_used == n - 1: break return min_cost"},{"question":"def is_palindrome(input: str) -> bool: Checks if the given string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"1234321\\") == True >>> is_palindrome(\\"123456\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a.\\") == True >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True","solution":"def is_palindrome(input): Checks if the given string is a palindrome, ignoring case and non-alphanumeric characters. # Filter out non-alphanumeric characters and convert to lower case cleaned_input = ''.join(char.lower() for char in input if char.isalnum()) # Check if the cleaned string is equal to its reverse return cleaned_input == cleaned_input[::-1]"},{"question":"def longest_nice_substring(S: str, K: int) -> int: Returns the length of the longest substring with at most K distinct letters. >>> longest_nice_substring(\\"ABBACAB\\", 2) 4 >>> longest_nice_substring(\\"A\\", 1) 1 >>> longest_nice_substring(\\"ABCDE\\", 2) 2 >>> longest_nice_substring(\\"\\", 2) 0","solution":"def longest_nice_substring(S, K): Returns the length of the longest substring with at most K distinct letters. from collections import defaultdict n = len(S) if n == 0: return 0 if K == 0: return 0 left = 0 right = 0 max_length = 0 char_count = defaultdict(int) distinct_count = 0 while right < n: if char_count[S[right]] == 0: distinct_count += 1 char_count[S[right]] += 1 right += 1 while distinct_count > K: char_count[S[left]] -= 1 if char_count[S[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length # Example usage: # S = \\"ABBACAB\\" # K = 2 # print(longest_nice_substring(S, K)) # Output: 4"},{"question":"def most_frequent_theme(n: int, m: int, instructions: List[Tuple[int, int, int]]) -> int: Find the most frequently used theme ID on the table after all instructions are executed. If there is a tie, return the smallest theme ID. >>> most_frequent_theme(10, 4, [(1, 5, 3), (4, 7, 2), (8, 10, 3), (3, 6, 4)]) 3 >>> most_frequent_theme(5, 1, [(1, 5, 1)]) 1 >>> most_frequent_theme(6, 2, [(1, 3, 1), (4, 6, 1)]) 1 >>> most_frequent_theme(10, 3, [(1, 5, 3), (6, 7, 4), (8, 10, 3)]) 3 >>> most_frequent_theme(10, 4, [(1, 3, 1), (4, 6, 2), (7, 8, 1), (9, 10, 2)]) 1","solution":"def most_frequent_theme(n, m, instructions): # Initialize the table with no theme (represented by 0) table = [0] * n # Apply each instruction to the table for a, b, t in instructions: for i in range(a-1, b): table[i] = t # Count the frequencies of each theme frequencies = {} for theme in table: if theme in frequencies: frequencies[theme] += 1 else: frequencies[theme] = 1 # Find the most frequent theme, and in case of ties, the smallest ID max_frequency = 0 most_frequent_theme_id = float('inf') for theme, frequency in frequencies.items(): if frequency > max_frequency or (frequency == max_frequency and theme < most_frequent_theme_id): max_frequency = frequency most_frequent_theme_id = theme return most_frequent_theme_id"},{"question":"def is_triple_increasing_subsequence(sequence): Determines if there is an increasing subsequence of length 3. Args: sequence (list of int): A list of integers. Returns: bool: True if there is an increasing subsequence of length 3, False otherwise. Examples: >>> is_triple_increasing_subsequence([5, 1, 5, 3, 2, 5, 4]) True >>> is_triple_increasing_subsequence([5, 4, 3, 2, 1]) False","solution":"def is_triple_increasing_subsequence(sequence): Determines if there is an increasing subsequence of length 3. Args: sequence (list of int): A list of integers. Returns: bool: True if there is an increasing subsequence of length 3, False otherwise. if len(sequence) < 3: return False first = second = float('inf') for num in sequence: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def solve(A, D, Q, queries): Perform Q queries on an arithmetic sequence defined by the first term A and common difference D. Args: A (int): The first term of the arithmetic sequence. D (int): The common difference of the arithmetic sequence. Q (int): Number of queries to perform. queries (list of tuples): List of queries where each query is a tuple (T, L, R). T is the type of query (1 for sum, 2 for product). L and R are the positions in the sequence (1-indexed). Returns: list of int: Results of the queries. >>> solve(2, 3, 5, [(1, 1, 3), (1, 2, 4), (2, 1, 2), (2, 3, 5), (2, 1, 1)]) [15, 24, 10, 1232, 2] pass from solution import solve def test_solve_sample_case(): A = 2 D = 3 Q = 5 queries = [ (1, 1, 3), (1, 2, 4), (2, 1, 2), (2, 3, 5), (2, 1, 1) ] expected = [15, 24, 10, 1232, 2] assert solve(A, D, Q, queries) == expected def test_solve_single_element(): A = 100 D = 10 Q = 1 queries = [ (1, 1, 1) ] expected = [100] assert solve(A, D, Q, queries) == expected def test_solve_same_element_sum_product(): A = 100 D = 5 Q = 2 queries = [ (1, 2, 2), (2, 2, 2) ] expected = [105, 105] assert solve(A, D, Q, queries) == expected def test_solve_large_range_product(): A = 1 D = 2 Q = 1 queries = [ (2, 1, 100) ] result = solve(A, D, Q, queries)[0] assert result > 0 and result == result % MOD def test_solve_large_range_sum(): A = 5 D = 3 Q = 1 queries = [ (1, 1, 10000) ] result = solve(A, D, Q, queries) expected = 5 * 10000 + 3 * (9999 * 10000) // 2 assert result[0] == expected","solution":"MOD = 1000000007 def solve(A, D, Q, queries): results = [] for query in queries: T, L, R = query if T == 1: # Sum of arithmetic sequence from L to R sum_value = 0 for i in range(L, R+1): sum_value += A + (i - 1) * D results.append(sum_value) elif T == 2: # Product of arithmetic sequence from L to R product_value = 1 for i in range(L, R+1): product_value = (product_value * (A + (i - 1) * D)) % MOD results.append(product_value) return results"},{"question":"def can_reach_end(arr: List[int]) -> str: Determines if you can reach the last index of the array starting from the first index. >>> can_reach_end([2, 3, 1, 1, 4]) \\"YES\\" >>> can_reach_end([3, 2, 1, 0, 4]) \\"NO\\" >>> can_reach_end([0]) \\"YES\\" >>> can_reach_end([0, 0, 0, 0]) \\"NO\\" >>> can_reach_end([5, 0, 0, 0, 0]) \\"YES\\" >>> can_reach_end([1, 2, 3, 4, 5, 0, 0, 0, 1, 2, 3, 4]) \\"YES\\" >>> can_reach_end([1, 0, 0, 1, 2, 3, 4, 5]) \\"NO\\"","solution":"def can_reach_end(arr): Determines if you can reach the last index of the array starting from the first index. max_reachable = 0 n = len(arr) for i, value in enumerate(arr): if i > max_reachable: return \\"NO\\" max_reachable = max(max_reachable, i + value) if max_reachable >= n - 1: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def min_subarrays(arr: List[int]) -> int: Given an array of integers, divide the array into the minimum number of contiguous subarrays such that the sum of each subarray is either all non-negative or all non-positive. Args: arr (List[int]): A list of integers. Returns: int: The minimum number of contiguous subarrays. >>> min_subarrays([1, 2, -3, -4, 5]) 3 >>> min_subarrays([-1, -2, 3, 4]) 2 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find minimum number of contiguous subarrays for each. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer N (number of elements) and a list of N integers. Returns: List[int]: List of results for each test case. >>> process_test_cases(2, [(5, [1, 2, -3, -4, 5]), (4, [-1, -2, 3, 4])]) [3, 2] # Feel free to add any necessary imports here # Unit Tests def test_single_case_1(): assert min_subarrays([1, 2, -3, -4, 5]) == 3 def test_single_case_2(): assert min_subarrays([-1, -2, 3, 4]) == 2 def test_single_case_all_positive(): assert min_subarrays([1, 2, 3, 4, 5]) == 1 def test_single_case_all_negative(): assert min_subarrays([-1, -2, -3, -4, -5]) == 1 def test_single_case_alternating_sign(): assert min_subarrays([1, -2, 3, -4, 5]) == 5 def test_multiple_cases(): test_cases = [ (5, [1, 2, -3, -4, 5]), (4, [-1, -2, 3, 4]), (3, [1, 2, 3]), (3, [-1, -2, -3]), (4, [-1, 2, -3, 4]) ] expected_results = [3, 2, 1, 1, 4] assert process_test_cases(5, test_cases) == expected_results def test_empty_array(): assert min_subarrays([]) == 0 def test_single_element_array_positive(): assert min_subarrays([1]) == 1 def test_single_element_array_negative(): assert min_subarrays([-1]) == 1","solution":"def min_subarrays(arr): Function to calculate the minimum number of contiguous subarrays required that each subarray's sum is either all non-negative or all non-positive. if not arr: return 0 count = 1 # Start with the first subarray for i in range(1, len(arr)): if (arr[i] >= 0 and arr[i - 1] < 0) or (arr[i] < 0 and arr[i - 1] >= 0): count += 1 return count def process_test_cases(T, test_cases): Function to process multiple test cases and return the results. results = [] for case in test_cases: N, arr = case results.append(min_subarrays(arr)) return results"},{"question":"def manage_strings(operations): Manages string insertions and checks for uniqueness. :param operations: List of operations to be performed on the database :return: List of results for each operation Example: >>> manage_strings([\\"INSERT hello\\", \\"INSERT world\\", \\"CHECK hello\\", \\"CHECK WORLD\\", \\"INSERT hello\\", \\"END\\"]) [\\"Inserted successfully\\", \\"Inserted successfully\\", \\"String found\\", \\"String not found\\", \\"String already exists\\"]","solution":"def manage_strings(operations): Manages string insertions and checks for uniqueness. :param operations: List of operations to be performed on the database :return: List of results for each operation database = set() results = [] for operation in operations: if operation == \\"END\\": break command, string = operation.split(\\" \\", 1) if command == \\"INSERT\\": if string in database: results.append(\\"String already exists\\") else: database.add(string) results.append(\\"Inserted successfully\\") elif command == \\"CHECK\\": if string in database: results.append(\\"String found\\") else: results.append(\\"String not found\\") return results"},{"question":"import re from typing import List def is_palindrome(S: str) -> str: Returns \\"YES\\" if the string S is a palindrome, \\"NO\\" otherwise, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") 'YES' >>> is_palindrome(\\"race a car\\") 'NO' >>> is_palindrome(\\"No lemon, no melon\\") 'YES' >>> is_palindrome(\\"Was it a car or a cat I saw?\\") 'YES' >>> is_palindrome(\\"Not a palindrome\\") 'NO' >>> is_palindrome(\\"1a2\\") 'NO' pass def check_palindromes(test_cases: List[str]) -> List[str]: Takes a list of test cases and returns a list of results for each test case. >>> check_palindromes([ \\"A man, a plan, a canal: Panama\\", \\"race a car\\", \\"No lemon, no melon\\", \\"Was it a car or a cat I saw?\\", \\"Not a palindrome\\", \\"1a2\\" ]) ['YES', 'NO', 'YES', 'YES', 'NO', 'NO'] pass","solution":"import re def is_palindrome(S): Returns \\"YES\\" if the string S is a palindrome, \\"NO\\" otherwise, considering only alphanumeric characters and ignoring cases. # Remove non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^A-Za-z0-9]', '', S).lower() # Check if the cleaned string is equal to its reverse return \\"YES\\" if cleaned_str == cleaned_str[::-1] else \\"NO\\" def check_palindromes(test_cases): Takes a list of test cases and returns a list of results for each test case. return [is_palindrome(s) for s in test_cases]"},{"question":"def check_temperature(temperature): Returns if the temperature is \\"hotter than the sun\\" meaning hotter than 500 degrees Celsius. Args: temperature (int or str): The temperature in Celsius. Returns: str: \\"It's scorching hot!\\" if temperature > 500 otherwise \\"It's pleasantly warm.\\" Examples: >>> check_temperature(600) \\"It's scorching hot!\\" >>> check_temperature(499) \\"It's pleasantly warm.\\" >>> check_temperature(\\"500\\") \\"It's pleasantly warm.\\" >>> check_temperature(\\"501\\") \\"It's scorching hot!\\"","solution":"def check_temperature(temperature): Returns if the temperature is \\"hotter than the sun\\" meaning hotter than 500 degrees Celsius. Args: temperature (int or str): The temperature in Celsius. Returns: str: \\"It's scorching hot!\\" if temperature > 500 otherwise \\"It's pleasantly warm.\\" if isinstance(temperature, str): temperature = int(temperature) if temperature > 500: return \\"It's scorching hot!\\" else: return \\"It's pleasantly warm.\\""},{"question":"def find_substrings(text: str, substring_length: int) -> list: Returns a list of all unique substrings of the specified length found within the given text. Parameters: text (str): The input string from which to extract substrings. substring_length (int): The length of the substrings to extract. Returns: list: A list of unique substrings of the specified length. >>> sorted(find_substrings(\\"abcdef\\", 2)) ['ab', 'bc', 'cd', 'de', 'ef'] >>> find_substrings(\\"abc\\", 4) [] >>> find_substrings(\\"\\", 2) [] >>> sorted(find_substrings(\\"aaa\\", 1)) ['a']","solution":"def find_substrings(text, substring_length): Returns a list of all unique substrings of the specified length found within the given text. Parameters: text (str): The input string from which to extract substrings. substring_length (int): The length of the substrings to extract. Returns: list: A list of unique substrings of the specified length. if not text or substring_length <= 0 or substring_length > len(text): return [] substrings = set() for i in range(len(text) - substring_length + 1): substr = text[i:i + substring_length] substrings.add(substr) return list(substrings)"},{"question":"def create_matrix(n: int, m: int) -> List[List[int]]: Creates a matrix of size n x m where each cell contains the sum of its row and column indices. Parameters: n (int): Number of rows m (int): Number of columns Returns: List[List[int]]: A 2D list representing the matrix Example: >>> create_matrix(2, 3) [[0, 1, 2], [1, 2, 3]] def print_matrix(matrix: List[List[int]]) -> None: Prints the matrix row by row with elements separated by space. Parameters: matrix (List[List[int]]): The matrix to print Example: >>> print_matrix([[0, 1, 2], [1, 2, 3]]) 0 1 2 1 2 3 import pytest def test_create_matrix_2x3(): matrix = create_matrix(2, 3) expected = [[0, 1, 2], [1, 2, 3]] assert matrix == expected def test_create_matrix_3x4(): matrix = create_matrix(3, 4) expected = [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]] assert matrix == expected def test_create_matrix_1x1(): matrix = create_matrix(1, 1) expected = [[0]] assert matrix == expected def test_create_matrix_5x5(): matrix = create_matrix(5, 5) expected = [ [0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8] ] assert matrix == expected def test_print_matrix(capsys): matrix = [[0, 1, 2], [1, 2, 3]] print_matrix(matrix) captured = capsys.readouterr() assert captured.out == \\"0 1 2n1 2 3n\\"","solution":"def create_matrix(n, m): Creates a matrix of size n x m where each cell contains the sum of its row and column indices. Parameters: n (int): Number of rows m (int): Number of columns Returns: List[List[int]]: A 2D list representing the matrix matrix = [] for i in range(n): row = [] for j in range(m): row.append(i + j) matrix.append(row) return matrix def print_matrix(matrix): Prints the matrix row by row with elements separated by space. Parameters: matrix (List[List[int]]): The matrix to print for row in matrix: print(\\" \\".join(map(str, row)))"},{"question":"def square_until_negative(nums: List[int]) -> List[int]: Returns a list of squares of the numbers in the input list. Stops processing upon encountering a negative number and excludes it from the result. Examples: >>> square_until_negative([1, 3, 5]) [1, 9, 25] >>> square_until_negative([2, -1, 4]) [4] >>> square_until_negative([-1, 2, 3]) [] >>> square_until_negative([10, 20, 30]) [100, 400, 900]","solution":"def square_until_negative(nums): Returns a list of squares of the numbers in the input list. Stops processing upon encountering a negative number and excludes it from the result. result = [] for num in nums: if num < 0: break result.append(num * num) return result"},{"question":"def min_cost(n: int, grid: List[List[int]]) -> int: Compute the minimum cost to move from the top-left cell to the bottom-right cell of the grid, where you can only move right or down at each step. The cost is defined as the sum of all integers you pass through. Parameters: n (int): The size of the grid. grid (List[List[int]]): The 2D grid of positive integers. Returns: int: The minimum cost to travel from (1,1) to (n,n). Example: >>> min_cost(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_cost(1, [[5]]) 5 import unittest class TestMinCost(unittest.TestCase): def test_min_cost_example(self): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] self.assertEqual(min_cost(3, grid), 21) def test_min_cost_single_cell(self): grid = [ [5] ] self.assertEqual(min_cost(1, grid), 5) def test_min_cost_two_by_two(self): grid = [ [1, 2], [1, 1] ] self.assertEqual(min_cost(2, grid), 3) def test_min_cost_edge_case(self): grid = [ [1, 99, 99], [1, 1, 99], [99, 1, 1] ] self.assertEqual(min_cost(3, grid), 5) def test_min_cost_larger(self): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] self.assertEqual(min_cost(3, grid), 7) if __name__ == '__main__': unittest.main()","solution":"def min_cost(n, grid): # Create a 2D list to store the minimum cost at each cell dp = [[0]*n for _ in range(n)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Initialize first row's cumulative cost for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Initialize first column's cumulative cost for j in range(1, n): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The minimum cost to reach the bottom-right cell return dp[n-1][n-1] # Example Usage # n = 3 # grid = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(min_cost(n, grid)) # Output: 21"},{"question":"def is_hanoi_solvable(n: int, m: int, initial: str, target: str) -> str: Check whether the desired configuration of the Tower of Hanoi can be achieved within a given number of moves. >>> is_hanoi_solvable(3, 7, \\"A 1 2 3nBnC\\", \\"AnBnC 1 2 3\\") \\"YES\\" >>> is_hanoi_solvable(3, 3, \\"A 1 2 3nBnC\\", \\"A 3nB 2nC 1\\") \\"NO\\" def solve_hanoi_games(input_data: str) -> str: Process multiple Hanoi game test cases and determine if they can be solved within the specified moves. >>> input_data = \\"3n3nA 1 2 3nBnCnA 3nB 2nC 1n3n7nA 1 2 3nBnCnAnBnC 1 2 3n0\\" >>> solve_hanoi_games(input_data) \\"NOnYES\\"","solution":"def is_hanoi_solvable(n, m, initial, target): def move_disks(num_disks, from_rod, to_rod, aux_rod): if num_disks == 0: return 0 if num_disks == 1: return 1 # one move # Move num_disks-1 disks from from_rod to aux_rod using to_rod moves1 = move_disks(num_disks - 1, from_rod, aux_rod, to_rod) # Move the nth disk from from_rod to to_rod moves2 = 1 # Move the num_disks-1 disks from aux_rod to to_rod using from_rod moves3 = move_disks(num_disks - 1, aux_rod, to_rod, from_rod) return moves1 + moves2 + moves3 def extract_state(config): state = {'A': [], 'B': [], 'C': []} for line in config.splitlines(): parts = line.split() rod = parts[0] disks = list(map(int, parts[1:])) state[rod] = disks return state initial_state = extract_state(initial) target_state = extract_state(target) def is_same_state(state1, state2): for rod in ['A', 'B', 'C']: if state1[rod] != state2[rod]: return False return True if is_same_state(initial_state, target_state): return \\"YES\\" total_moves = move_disks(n, 'A', 'C', 'B') if total_moves <= m: return \\"YES\\" else: return \\"NO\\" def solve_hanoi_games(input_data): lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): n = int(lines[index]) if n == 0: break m = int(lines[index + 1]) initial_config = 'n'.join(lines[index + 2: index + 5]) target_config = 'n'.join(lines[index + 5: index + 8]) result = is_hanoi_solvable(n, m, initial_config, target_config) results.append(result) index += 8 return 'n'.join(results)"},{"question":"def most_frequent_char(s: str) -> str: Returns the character that appears the most frequently in the string \`s\`. If there are multiple characters with the same highest frequency, returns the lexicographically smallest one. >>> most_frequent_char(\\"a\\") == \\"a\\" >>> most_frequent_char(\\"bbbb\\") == \\"b\\" >>> most_frequent_char(\\"abracadabra\\") == \\"a\\" >>> most_frequent_char(\\"she sells sea shells\\") == \\"s\\" >>> most_frequent_char(\\"a b c d e f g a b c\\") == \\" \\" >>> most_frequent_char(\\"!@#!@#\\") == \\"!\\" >>> most_frequent_char(\\"abcabcabcabc\\") == \\"a\\" >>> most_frequent_char(\\"aa%%^^\\") == \\"\\"","solution":"def most_frequent_char(s): Returns the character that appears the most frequently in the string \`s\`. If there are multiple characters with the same highest frequency, returns the lexicographically smallest one. from collections import Counter # Count the frequency of each character in the string freq_counter = Counter(s) # Find the maximum frequency max_freq = max(freq_counter.values()) # Find all characters with the maximum frequency most_frequent_chars = [char for char, freq in freq_counter.items() if freq == max_freq] # Return the lexicographically smallest character return min(most_frequent_chars)"},{"question":"def find_election_winner(n: int, votes: List[str]) -> str: Determine the winner of the election based on votes. >>> find_election_winner(5, ['alice', 'bob', 'alice', 'bob', 'alice']) 'alice' >>> find_election_winner(4, ['dave', 'dave', 'carol', 'carol']) 'carol' >>> find_election_winner(3, ['anna', 'beth', 'clara']) 'anna' >>> find_election_winner(1, ['alice']) 'alice' >>> find_election_winner(7, ['alice', 'bob', 'charlie', 'alice', 'bob', 'charlie', 'charlie']) 'charlie' >>> votes = ['anna'] * 50000 + ['beth'] * 50000 >>> find_election_winner(100000, votes) 'anna'","solution":"def find_election_winner(n, votes): from collections import Counter vote_count = Counter(votes) # Determining the highest vote count max_votes = max(vote_count.values()) # Getting all candidates who have the highest votes candidates_with_max_votes = [candidate for candidate, count in vote_count.items() if count == max_votes] # Return the candidate that comes first alphabetically return min(candidates_with_max_votes)"},{"question":"def max_non_consecutive_sum(n: int, times: List[int]) -> int: Given a list of integers representing execution times of methods, find the maximum sum of any subsequence such that no two consecutive elements are included in the sum. >>> max_non_consecutive_sum(5, [3, 2, 7, 10, 12]) 22 >>> max_non_consecutive_sum(4, [3, 2, 5, 10]) 13 >>> max_non_consecutive_sum(1, [5]) 5 >>> max_non_consecutive_sum(0, []) 0 >>> max_non_consecutive_sum(4, [4, 4, 4, 4]) 8 >>> max_non_consecutive_sum(2, [5, 10]) 10 >>> max_non_consecutive_sum(6, [3, 6, 2, 8, 5, 10]) 24 >>> max_non_consecutive_sum(6, [10, 1, 1, 10, 1, 1]) 21","solution":"def max_non_consecutive_sum(n, times): if n == 0: return 0 elif n == 1: return times[0] # Initialize the max_sum array where max_sum[i] is the maximum sum without consecutive elements up to index i max_sum = [0] * n max_sum[0] = times[0] max_sum[1] = max(times[0], times[1]) for i in range(2, n): max_sum[i] = max(max_sum[i-1], max_sum[i-2] + times[i]) return max_sum[-1]"},{"question":"def highest_bids_per_auction(auction_data): This function takes auction data and returns the highest bid from each auction. Parameters: auction_data (list of list of int): A list where each sublist represents an auction, and contains bids for that auction. Returns: list of int: A list containing the highest bid from each auction. pass def parse_input(input_str): This function takes a formatted string input, parses it, and returns the auction data. Parameters: input_str (str): Formatted input string representing the number of auctions and their bids. Returns: list of list of int: Parsed auction data. pass def main(input_str): Main function to process the input string and return the highest bids for each auction. Parameters: input_str (str): Formatted input string representing the number of auctions and their bids. Returns: list of int: List of highest bids for each auction. pass # Unit Test: def test_highest_bids_per_auction(): # Test example 1 input_data = \\"2n3 50 65 77n4 80 90 55 45\\" expected_output = [77, 90] assert main(input_data) == expected_output # Test example 2 input_data = \\"1n5 20 30 25 35 40\\" expected_output = [40] assert main(input_data) == expected_output # Test with minimum values input_data = \\"1n1 1\\" expected_output = [1] assert main(input_data) == expected_output # Test with same bid values input_data = \\"1n5 7 7 7 7 7\\" expected_output = [7] assert main(input_data) == expected_output # Test with single auction and multiple bids input_data = \\"1n3 50 100 75\\" expected_output = [100] assert main(input_data) == expected_output # Test with multiple auctions and varying bids input_data = \\"3n3 1 2 3n4 10 20 30 40n2 5 25\\" expected_output = [3, 40, 25] assert main(input_data) == expected_output # Running the tests test_highest_bids_per_auction() print(\\"All tests passed!\\")","solution":"def highest_bids_per_auction(auction_data): This function takes auction data and returns the highest bid from each auction. Parameters: auction_data (list of list of int): A list where each sublist represents an auction, and contains bids for that auction. Returns: list of int: A list containing the highest bid from each auction. highest_bids = [] for auction in auction_data: highest_bids.append(max(auction)) return highest_bids def parse_input(input_str): This function takes a formatted string input, parses it, and returns the auction data. Parameters: input_str (str): Formatted input string representing the number of auctions and their bids. Returns: list of list of int: Parsed auction data. lines = input_str.strip().split('n') number_of_auctions = int(lines[0]) auction_data = [] for i in range(1, number_of_auctions + 1): auction_bids = list(map(int, lines[i].split()[1:])) auction_data.append(auction_bids) return auction_data def main(input_str): Main function to process the input string and return the highest bids for each auction. Parameters: input_str (str): Formatted input string representing the number of auctions and their bids. Returns: list of int: List of highest bids for each auction. auction_data = parse_input(input_str) return highest_bids_per_auction(auction_data)"},{"question":"from typing import List def min_points_for_top_k_percent(n: int, K: int, points: List[int]) -> int: Calculate the minimum number of points an employee needs to be in the top K percent. Args: n : int : The number of employees K : int : The percentage threshold points : List[int] : The list of points of the employees Returns: int : The minimum number of points required to be in the top K percent of employees Examples: >>> min_points_for_top_k_percent(6, 50, [100, 200, 150, 80, 120, 70]) 120 >>> min_points_for_top_k_percent(4, 25, [100, 200, 150, 500]) 500 >>> min_points_for_top_k_percent(5, 20, [300, 300, 300, 200, 100]) 300 >>> min_points_for_top_k_percent(10, 10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 10 >>> min_points_for_top_k_percent(10, 30, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 8","solution":"def min_points_for_top_k_percent(n, K, points): Returns the minimum number of points required to be in the top K percent of employees. # Determine the number of employees to be considered in the top K percent top_k_count = (n * K + 99) // 100 # Using CEIL method to determine number of top K employees # Sort the points in descending order sorted_points = sorted(points, reverse=True) # The minimum points required will be the points of the (top_k_count - 1)th employee in 0-indexed return sorted_points[top_k_count - 1]"},{"question":"def countGoodPairs(nums) -> int: Returns the number of good pairs in the array nums. A good pair (i, j) is where nums[i] == nums[j] and i < j. pass def test_countGoodPairs(): assert countGoodPairs([1, 2, 3, 1, 1, 3]) == 4 assert countGoodPairs([1, 1, 1, 1]) == 6 assert countGoodPairs([1, 2, 3, 4]) == 0 assert countGoodPairs([1, 1, 1, 2, 2, 2]) == 6 assert countGoodPairs([2, 2, 2, 2, 2]) == 10 assert countGoodPairs([]) == 0 assert countGoodPairs([3]) == 0 # More edge case tests def test_boundary_cases(): assert countGoodPairs([1]) == 0 assert countGoodPairs([1, 1]) == 1 assert countGoodPairs([1]*100000) == (100000 * 99999) // 2 def test_random_cases(): assert countGoodPairs([1,2,3,1,2,3,3]) == 5 assert countGoodPairs([4,4,4,3,3,5,5,5,5]) == 10","solution":"def countGoodPairs(nums): Returns the number of good pairs in the array nums. A good pair (i, j) is where nums[i] == nums[j] and i < j. from collections import defaultdict num_counts = defaultdict(int) good_pairs = 0 for num in nums: good_pairs += num_counts[num] num_counts[num] += 1 return good_pairs"},{"question":"def min_operations_to_clear_field(field): Determine the minimum number of operations required to remove all stones from the grid. Each cell in the grid represents a section of the field, marked as either containing a stone (1) or being empty (0). The farmer can select any rectangle within the grid and clear all stones within that rectangle in one operation. Args: field (List[List[int]]): A 2D list representing the state of the field with 1s and 0s. Returns: int: The minimum number of operations required to clear all stones. Examples: >>> min_operations_to_clear_field([[1, 0, 1], [0, 1, 0]]) 3 >>> min_operations_to_clear_field([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 def process_input(datasets): Processes multiple datasets and returns the results for each dataset. Args: datasets (List[List[List[int]]]): List of datasets, where each dataset is a 2D list representing a field. Returns: List[int]: A list containing the results for each dataset. Examples: >>> process_input([[[1, 0, 1], [0, 1, 0]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]]]) [3, 1] def parse_input(input_data): Parses the input string and returns a list of datasets. Args: input_data (str): The input string representing multiple datasets. Returns: List[List[List[int]]]: A list containing datasets represented as 2D lists. Examples: >>> parse_input(\\"2 3n1 0 1n0 1 0n3 3n1 1 1n1 1 1n1 1 1n0 0\\") [[[1, 0, 1], [0, 1, 0]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]]] def main(input_data): The main function that processes the input and returns the results. Args: input_data (str): The input string containing the datasets. Returns: List[int]: A list of results for each dataset. Examples: >>> main(\\"2 3n1 0 1n0 1 0n3 3n1 1 1n1 1 1n1 1 1n0 0\\") [3, 1] # Test functions to validate the solution import pytest def test_minimal_operations(): input_data = 2 3 1 0 1 0 1 0 3 3 1 1 1 1 1 1 1 1 1 0 0 assert main(input_data) == [3, 1] def test_no_stones(): input_data = 2 3 0 0 0 0 0 0 0 0 assert main(input_data) == [0] def test_all_stones(): input_data = 2 2 1 1 1 1 0 0 assert main(input_data) == [1] def test_single_stone(): input_data = 3 3 0 0 0 0 1 0 0 0 0 0 0 assert main(input_data) == [1] def test_mixed_case(): input_data = 4 4 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 assert main(input_data) == [6] # For testing purposes if __name__ == \\"__main__\\": pytest.main()","solution":"def min_operations_to_clear_field(field): R, C = len(field), len(field[0]) visited = [[False] * C for _ in range(R)] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < R and 0 <= cy < C and field[cx][cy] == 1 and not visited[cx][cy]: visited[cx][cy] = True for nx, ny in [(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]: stack.append((nx, ny)) operations = 0 for i in range(R): for j in range(C): if field[i][j] == 1 and not visited[i][j]: dfs(i, j) operations += 1 return operations def process_input(datasets): results = [] for field in datasets: if field: results.append(min_operations_to_clear_field(field)) return results def parse_input(input_data): lines = input_data.strip().split('n') i = 0 datasets = [] while i < len(lines): R, C = map(int, lines[i].split()) if R == 0 and C == 0: break field = [list(map(int, lines[i+j+1].split())) for j in range(R)] datasets.append(field) i += R + 1 return datasets def main(input_data): datasets = parse_input(input_data) results = process_input(datasets) return results # For testing purposes if __name__ == \\"__main__\\": input_data = 2 3 1 0 1 0 1 0 3 3 1 1 1 1 1 1 1 1 1 0 0 result = main(input_data) for res in result: print(res)"},{"question":"def contains_alphabet_permutation(s: str) -> bool: Determines if the given string \`s\` contains any permutation of the alphabet. >>> contains_alphabet_permutation(\\"abcdefghijklmnopqrstuvwxyza\\") True >>> contains_alphabet_permutation(\\"hellopythonworld\\") False >>> contains_alphabet_permutation(\\"thequickbrownfoxjumpsoverthelazydog\\") True >>> contains_alphabet_permutation(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> contains_alphabet_permutation(\\"abcde\\") False >>> contains_alphabet_permutation(\\"thequickbrownfoxxjumpsoverthelazydogs\\") True def solve(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases. >>> T = 3 >>> test_cases = [\\"abcdefghijklmnopqrstuvwxyza\\", \\"hellopythonworld\\", \\"thequickbrownfoxjumpsoverthelazydog\\"] >>> solve(T, test_cases) ['YES', 'NO', 'YES'] >>> T = 2 >>> test_cases = [\\"abcdefghijklmnopqrstuvwxyz\\", \\"hellopythonworld\\"] >>> solve(T, test_cases) ['YES', 'NO'] >>> T = 1 >>> test_cases = [\\"thequickbrownfoxxjumpsoverthelazydogs\\"] >>> solve(T, test_cases) ['YES']","solution":"def contains_alphabet_permutation(s): Determines if the given string \`s\` contains any permutation of the alphabet. # There are 26 letters in the English alphabet ALPHABET_SIZE = 26 # To store the frequency of all characters freq = [0] * 26 # Increment frequency for each character in the string for char in s: freq[ord(char) - ord('a')] += 1 # If all frequencies are at least 1, return True return all(count >= 1 for count in freq) def solve(T, test_cases): Processes multiple test cases. results = [] for s in test_cases: if contains_alphabet_permutation(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_flower_sum(datasets): Finds the maximum possible sum of the magical values of any segment of exactly k flowers. >>> max_flower_sum([(5, 3, [1, -2, 3, 4, -1]), (6, 2, [-1, 2, 3, -2, 5, 1]), (0, 0)]) [6, 6] >>> max_flower_sum([(1, 1, [10]), (0, 0)]) [10] >>> max_flower_sum([(4, 2, [-1, -2, -3, -4]), (0, 0)]) [-3] >>> max_flower_sum([(5, 3, [1, 0, 3, 0, 5]), (0, 0)]) [8] >>> max_flower_sum([(7, 4, [5, -2, 3, -4, 6, 2, -1]), (0, 0)]) [7]","solution":"def max_flower_sum(datasets): results = [] for data in datasets: n, k = data[0], data[1] if n == 0 and k == 0: break flowers = data[2] max_sum = float('-inf') current_sum = 0 for i in range(k): current_sum += flowers[i] max_sum = current_sum for i in range(k, n): current_sum = current_sum + flowers[i] - flowers[i - k] if current_sum > max_sum: max_sum = current_sum results.append(max_sum) return results"},{"question":"def sum_of_cubed_digits(n: int) -> List[int]: Calculates the sum of the cubes of its digits for each number in the range of 1 to n. >>> sum_of_cubed_digits(5) [1, 8, 27, 64, 125] >>> sum_of_cubed_digits(2) [1, 8] >>> sum_of_cubed_digits(0) [] >>> sum_of_cubed_digits(-1) [] >>> sum_of_cubed_digits(9) [1, 8, 27, 64, 125, 216, 343, 512, 729] >>> sum_of_cubed_digits(12) [1, 8, 27, 64, 125, 216, 343, 512, 729, 1, 2, 9]","solution":"def sum_of_cubed_digits(n): Calculates the sum of cubes of its digits for each number from 1 to n. Parameters: n (int): Upper limit of the range. Returns: list: List containing the sum of cubes of digits for each number from 1 to n. if n < 1: return [] result = [] for i in range(1, n + 1): sum_of_cubes = sum(int(digit) ** 3 for digit in str(i)) result.append(sum_of_cubes) return result"},{"question":"def most_common_traits(input_data: str) -> str: Analyze and find the most common traits among a given list of Cryptokitties. Each test case is structured as follows: - The first line contains an integer T (1  T  100), the number of Cryptokitties. - The next T lines each contain the traits of a single Cryptokitty separated by a space. Each trait consists of lowercase Roman alphabet characters with a maximum length of 16 characters. The end of input is indicated by a line containing a zero. This line is not part of any dataset and should not be processed. Output the most common trait(s) sorted in alphabetical order, separated by a single space, for each test case on a new line. >>> input_data = '''4 ... whiskers playful blueeyes ... fluffy blueeyes ... playful greeneyes ... playful whiskers ... 3 ... longtail agile ... shorttail sneaky ... agile greeneyes ... 0''' >>> most_common_traits(input_data) \\"playfulnagile\\"","solution":"def most_common_traits(input_data): from collections import Counter results = [] lines = input_data.strip().split(\\"n\\") i = 0 while i < len(lines): traits_counter = Counter() T = int(lines[i]) if T == 0: break for j in range(1, T + 1): traits = lines[i + j].split() traits_counter.update(traits) i += T + 1 # Find the max frequency if traits_counter: max_freq = max(traits_counter.values()) common_traits = [trait for trait, count in traits_counter.items() if count == max_freq] common_traits.sort() results.append(\\" \\".join(common_traits)) return \\"n\\".join(results)"},{"question":"def max_rides(n, rides): Computes the maximum number of non-overlapping rides a visitor can enjoy. Parameters: n (int): Number of rides rides (list of tuples): List containing the start and end times of each ride Returns: int: Maximum number of non-overlapping rides >>> max_rides(5, [(1, 4), (2, 5), (5, 8), (3, 6), (8, 9)]) == 3 >>> max_rides(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> max_rides(3, [(1, 5), (2, 6), (3, 7)]) == 1 >>> max_rides(5, [(1, 3), (2, 4), (2, 5), (3, 6), (4, 8)]) == 2 >>> max_rides(1, [(1, 5)]) == 1 >>> max_rides(4, [(1, 4), (5, 8), (8, 10), (0, 7)]) == 3 >>> max_rides(500, [(i, i+1) for i in range(0, 1000, 2)]) == 500","solution":"def max_rides(n, rides): Computes the maximum number of non-overlapping rides a visitor can enjoy. Parameters: n (int): Number of rides rides (list of tuples): List containing the start and end times of each ride Returns: int: Maximum number of non-overlapping rides # Sort rides by their end times rides.sort(key=lambda x: x[1]) last_end_time = 0 count = 0 for start, end in rides: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def longest_palindromic_substring(S: str) -> int: Returns the length of the longest palindromic substring in the given string S. >>> longest_palindromic_substring(\\"ababa\\") 5 >>> longest_palindromic_substring(\\"abc\\") 1 pass def process_inputs(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases and returns the results for the longest palindromic substring lengths. >>> process_inputs(2, [(5, \\"ababa\\"), (3, \\"abc\\")]) [5, 1] pass","solution":"def longest_palindromic_substring(S): Returns the length of the longest palindromic substring of S. N = len(S) if N == 0: return 0 dp = [[False] * N for _ in range(N)] max_length = 1 for i in range(N): dp[i][i] = True start = 0 for i in range(N - 1): if S[i] == S[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for k in range(3, N + 1): for i in range(N - k + 1): j = i + k - 1 if dp[i + 1][j - 1] and S[i] == S[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length def process_inputs(T, test_cases): results = [] for i in range(T): N, S = test_cases[i] results.append(longest_palindromic_substring(S)) return results"},{"question":"from typing import List def countPairs(arr: List[int], target: int) -> int: Given an integer array 'arr' and a target sum 'target', find the number of unique pairs of elements (a, b) in the array such that their sum is equal to the target. The same element cannot be used in multiple pairs but the array can contain duplicates. >>> countPairs([1, 3, 2, 2, 3, 4], 5) 2 >>> countPairs([1, 2, 3, 4, 5], 10) 0 >>> countPairs([1, 5, 7, -2, 3, -1, 3, 2], 4) 2 >>> countPairs([1, -1, 2, -2, 3, -3], 0) 3 >>> countPairs([2, 2, 2, 2], 4) 1 >>> countPairs([i for i in range(1, 10001)], 10001) 5000","solution":"def countPairs(arr, target): seen = {} pairs = set() count = 0 for num in arr: complement = target - num if complement in seen and seen[complement] > 0: pairs.add((min(num, complement), max(num, complement))) seen[complement] -= 1 else: if num in seen: seen[num] += 1 else: seen[num] = 1 return len(pairs)"},{"question":"def distinctElementsSubarray(arr, k): Returns the size of the smallest subarray that contains at least k distinct elements. If no such subarray exists, returns -1. >>> distinctElementsSubarray([1, 2, 1, 3, 4, 2, 3], 3) 3 >>> distinctElementsSubarray([1, 2, 1, 2, 1], 2) 2 >>> distinctElementsSubarray([1, 2, 1, 2, 1], 3) -1","solution":"def distinctElementsSubarray(arr, k): Returns the size of the smallest subarray that contains at least k distinct elements. If no such subarray exists, returns -1. n = len(arr) if k > n: return -1 start = 0 min_length = float('inf') element_count = {} for end in range(n): element_count[arr[end]] = element_count.get(arr[end], 0) + 1 while len(element_count) >= k: min_length = min(min_length, end - start + 1) element_count[arr[start]] -= 1 if element_count[arr[start]] == 0: del element_count[arr[start]] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations needed to make all elements of the list equal. >>> min_operations_to_equal_elements([1, 2, 3]) 2 >>> min_operations_to_equal_elements([1, 10, 2, 9]) 16","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations needed to make all elements of the list equal. if not arr: return 0 median = sorted(arr)[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"def is_possible_to_route(hubs: int, capacity: int, shipments: List[Tuple[int, int, int]]) -> str: Determines if it is possible to route all shipments without exceeding the capacity of any hub on any given day. >>> is_possible_to_route(3, 2, [(1, 2, 1), (2, 3, 1), (1, 3, 2), (3, 1, 1), (2, 1, 3)]) 'Possible' >>> is_possible_to_route(3, 1, [(1, 2, 1), (2, 3, 1), (1, 3, 1), (3, 1, 1)]) 'Impossible'","solution":"def is_possible_to_route(hubs, capacity, shipments): # Initialize a dictionary to track hub capacities for each day hub_daily_shipments = {} for shipment in shipments: start_hub, end_hub, day = shipment if day not in hub_daily_shipments: hub_daily_shipments[day] = [0] * hubs hub_daily_shipments[day][start_hub - 1] += 1 hub_daily_shipments[day][end_hub - 1] += 1 for day, hub_usage in hub_daily_shipments.items(): for shipments_count in hub_usage: if shipments_count > capacity: return \\"Impossible\\" return \\"Possible\\" # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() H = int(data[0]) C = int(data[1]) N = int(data[2]) shipments = [] for i in range(N): S = int(data[3 + i * 3]) E = int(data[4 + i * 3]) D = int(data[5 + i * 3]) shipments.append((S, E, D)) print(is_possible_to_route(H, C, shipments))"},{"question":"def staircase(n): Generates a staircase pattern with \`n\` steps. Each step is represented by an underscore \`_\` and aligned to the right with leading spaces. Returns the staircase pattern as a string. If the argument is not a positive integer, the function returns an empty string. >>> staircase(4) ' _n __n ___n____' >>> staircase(6) ' _n __n ___n ____n _____n______'","solution":"def staircase(n): Generates a staircase pattern with \`n\` steps. Each step is represented by an underscore \`_\` and aligned to the right with leading spaces. Returns the staircase pattern as a string. if not isinstance(n, int) or n <= 0: return \\"\\" pattern = [] for i in range(1, n+1): line = ' ' * (n-i) + '_' * i pattern.append(line) return 'n'.join(pattern)"},{"question":"def findMissingNumber(arr): Returns the missing number in the arithmetic progression. Example: >>> findMissingNumber([2, 4, 8, 10]) # should return 6 >>> findMissingNumber([1, 7, 10]) # should return 4 >>> findMissingNumber([5, 10, 20, 25]) # should return 15","solution":"def findMissingNumber(arr): Returns the missing number in the arithmetic progression. n = len(arr) + 1 # Since one element is missing total_sum = (n * (arr[0] + arr[-1])) // 2 # Sum of the complete AP actual_sum = sum(arr) # Sum of the given AP with one missing element return total_sum - actual_sum"},{"question":"def min_edit_distance(s1: str, s2: str) -> int: Calculate the minimum number of operations required to convert s1 to s2. Allowed operations: insertion, deletion, substitution. >>> min_edit_distance(\\"horse\\", \\"ros\\") 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_edit_distance(s1: str, s2: str) -> int: Calculate the minimum number of operations required to convert s1 to s2. Allowed operations: insertion, deletion, substitution. m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array bottom up for i in range(m + 1): for j in range(n + 1): # If first string is empty, insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore the last character # and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the last character is different, consider all possibilities # and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"import math from typing import List def productOfDigitsInFactorial(N: int) -> int: Returns the product of the digits of the factorial of N. >>> productOfDigitsInFactorial(5) == 0 >>> productOfDigitsInFactorial(6) == 0 >>> productOfDigitsInFactorial(10) == 0 >>> productOfDigitsInFactorial(1) == 1 >>> productOfDigitsInFactorial(3) == 6 >>> productOfDigitsInFactorial(0) == 1","solution":"import math def productOfDigitsInFactorial(N): Returns the product of the digits of the factorial of N. factorial = math.factorial(N) product = 1 # Calculate the product of digits of the factorial while factorial > 0: digit = factorial % 10 product *= digit factorial //= 10 return product"},{"question":"def min_spells_to_revive(garden: str) -> int: Determine the minimum number of spells needed to revive all plants in the garden. >>> min_spells_to_revive(\\"DAAAD\\") 2 >>> min_spells_to_revive(\\"AAAAA\\") 0 >>> min_spells_to_revive(\\"DDDDD\\") 1","solution":"def min_spells_to_revive(garden): Returns the minimum number of spells needed to revive all plants in the garden. if not garden: return 0 spells = 0 i = 0 n = len(garden) while i < n: # Find the next 'D' if garden[i] == 'D': spells += 1 # Skip all consecutive 'D's while i < n and garden[i] == 'D': i += 1 else: i += 1 return spells"},{"question":"def is_palindrome(n: int) -> bool: Returns True if the digits of the integer n form a palindrome, False otherwise. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(1) == True >>> is_palindrome(1111) == True >>> is_palindrome(1221) == True >>> is_palindrome(-121) == False","solution":"def is_palindrome(n): Returns True if the digits of the integer n form a palindrome, False otherwise. # If n is negative, it cannot be a palindrome if n < 0: return False # Convert number to string to check for palindrome str_n = str(n) return str_n == str_n[::-1]"},{"question":"class Game: def __init__(self, num_rooms, danger_levels, items, paths): self.num_rooms = num_rooms self.danger_levels = danger_levels self.items = items self.paths = {i: [] for i in range(1, num_rooms + 1)} for u, v in paths: self.paths[u].append(v) self.paths[v].append(u) self.current_room = 1 self.max_danger = danger_levels[0] self.visited = set([1]) def move(self, room_id): Move the player to the room with the specified ID. The player can only move to a room that is directly connected to the current room. pass def collect(self): Collect all items in the current room. After this command, the item count of the room becomes zero. pass def get_max_danger(self): Output the highest danger level encountered on the path from the start room to the current room. pass def text_adventure_game(num_rooms, num_paths, danger_levels, items, paths, num_commands, commands): Handle a sequence of commands that dictate the player's movements and item collection actions. :param num_rooms: The number of rooms :param num_paths: The number of paths :param danger_levels: The danger levels of the rooms :param items: The number of items in the rooms :param paths: The paths between rooms :param num_commands: The number of commands :param commands: The commands to handle :return: The output for each DANGER command game = Game(num_rooms, danger_levels, items, paths) output = [] for command in commands: parts = command.split() action = parts[0] if action == \\"MOVE\\": game.move(int(parts[1])) elif action == \\"COLLECT\\": game.collect() elif action == \\"DANGER\\": output.append(game.get_max_danger()) return output","solution":"class Game: def __init__(self, num_rooms, danger_levels, items, paths): self.num_rooms = num_rooms self.danger_levels = danger_levels self.items = items self.paths = {i: [] for i in range(1, num_rooms + 1)} for u, v in paths: self.paths[u].append(v) self.paths[v].append(u) self.current_room = 1 self.max_danger = danger_levels[0] self.visited = set([1]) def move(self, room_id): if room_id in self.paths[self.current_room]: self.current_room = room_id self.visited.add(room_id) self.max_danger = max(self.max_danger, self.danger_levels[room_id - 1]) def collect(self): self.items[self.current_room - 1] = 0 def get_max_danger(self): return self.max_danger def text_adventure_game(num_rooms, num_paths, danger_levels, items, paths, num_commands, commands): game = Game(num_rooms, danger_levels, items, paths) output = [] for command in commands: parts = command.split() action = parts[0] if action == \\"MOVE\\": game.move(int(parts[1])) elif action == \\"COLLECT\\": game.collect() elif action == \\"DANGER\\": output.append(str(game.get_max_danger())) return output"},{"question":"def soldiers_in_parade(t: int, test_cases: List[int]) -> List[Tuple[int, int]]: Given the number of test cases and a list of numbers representing rows, calculates the total number of soldiers in the first \`n\` rows and the number of soldiers required for the next row. Parameters: t (int): The number of test cases. test_cases (list of int): The list containing the number of rows for each test case. Returns: list of tuples: A list containing pairs of integers. Each pair represents the total number of soldiers in \`n\` rows and soldiers required for the next row respectively. Examples: >>> soldiers_in_parade(1, [1]) [(1, 2)] >>> soldiers_in_parade(3, [1, 2, 5]) [(1, 2), (3, 3), (15, 6)] >>> soldiers_in_parade(1, [1000000]) [(500000500000, 1000001)] >>> soldiers_in_parade(4, [3, 10, 100, 1000]) [(6, 4), (55, 11), (5050, 101), (500500, 1001)] >>> soldiers_in_parade(1, [1]) [(1, 2)] >>> soldiers_in_parade(1, [1000000000]) [(500000000500000000, 1000000001)]","solution":"def soldiers_in_parade(t, test_cases): Given the number of test cases and a list of numbers representing rows, calculates the total number of soldiers in the first \`n\` rows and the number of soldiers required for the next row. Parameters: t (int): The number of test cases. test_cases (list of int): The list containing the number of rows for each test case. Returns: list of tuples: A list containing pairs of integers. Each pair represents the total number of soldiers in \`n\` rows and soldiers required for the next row respectively. results = [] for n in test_cases: total_soldiers = n * (n + 1) // 2 next_row_soldiers = n + 1 results.append((total_soldiers, next_row_soldiers)) return results"},{"question":"def find_palindromes(n: int) -> list: Write a function that takes an integer \`n\` and returns a list of all palindromic numbers less than \`n\`. A palindromic number is a number that remains the same when its digits are reversed. >>> find_palindromes(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> find_palindromes(50) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44] >>> find_palindromes(200) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191] >>> find_palindromes(500) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494] >>> 989 in find_palindromes(1001) True >>> 999 in find_palindromes(1001) True pass","solution":"def find_palindromes(n: int) -> list: Returns a list of all palindromic numbers less than n. def is_palindrome(x: int) -> bool: s = str(x) return s == s[::-1] return [x for x in range(n) if is_palindrome(x)]"},{"question":"def is_valid_ipv4_address(ip: str) -> bool: Validates if the given IP address string is a valid IPv4 address. >>> is_valid_ipv4_address(\\"192.168.0.1\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"256.100.50.0\\") False >>> is_valid_ipv4_address(\\"123.045.067.089\\") False pass def validate_ipv4_addresses(n: int, ip_addresses: List[str]) -> List[str]: Validates a list of IP addresses and returns 'VALID' or 'INVALID' for each. >>> validate_ipv4_addresses(3, [\\"192.168.0.1\\", \\"256.100.50.0\\", \\"123.045.067.089\\"]) [\\"VALID\\", \\"INVALID\\", \\"INVALID\\"] >>> validate_ipv4_addresses(3, [\\"0.0.0.0\\", \\"255.255.255.255\\", \\"1.1.1.01\\"]) [\\"VALID\\", \\"VALID\\", \\"INVALID\\"] >>> validate_ipv4_addresses(3, [\\"192.168.1.1\\", \\"192.168.1.01\\", \\"192.168.1.256\\"]) [\\"VALID\\", \\"INVALID\\", \\"INVALID\\"] pass","solution":"def is_valid_ipv4_address(ip): Validates if the given IP address string is a valid IPv4 address. parts = ip.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False num = int(part) if num < 0 or num > 255: return False if len(part) != len(str(num)): # This checks for leading zeroes return False return True def validate_ipv4_addresses(n, ip_addresses): Validates a list of IP addresses and prints 'VALID' or 'INVALID' for each. results = [] for ip in ip_addresses: if is_valid_ipv4_address(ip): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def find_odd_occurrence(arr): Finds the integer in the array that appears an odd number of times. Args: arr: List of integers Returns: Integer that appears an odd number of times. >>> find_odd_occurrence([1, 2, 3, 1, 2, 3, 2]) == 2 >>> find_odd_occurrence([5, 7, 5, 5, 7]) == 5 >>> find_odd_occurrence([-1, -2, -1, -2, -3, -3, -3]) == -3 >>> find_odd_occurrence([4]) == 4 >>> find_odd_occurrence([1, 1, 2, 2, 3]) == 3","solution":"def find_odd_occurrence(arr): Finds the integer in the array that appears an odd number of times. Args: arr: List of integers Returns: Integer that appears an odd number of times. result = 0 for number in arr: result ^= number # XOR operation return result"},{"question":"def zero_even_numbers(arr): Replaces all even numbers in the array with zeroes. Parameters: arr (list): A list of integers. Returns: list: A list with all even numbers replaced by zeroes. >>> zero_even_numbers([2, 4, 6, 8]) [0, 0, 0, 0] >>> zero_even_numbers([1, 3, 5, 7]) [1, 3, 5, 7] >>> zero_even_numbers([1, 2, 3, 4, 5]) [1, 0, 3, 0, 5] >>> zero_even_numbers([2]) [0] >>> zero_even_numbers([3]) [3] >>> zero_even_numbers([]) [] >>> zero_even_numbers([-1000000000, 1000000000, -999999999, 999999999]) [0, 0, -999999999, 999999999]","solution":"def zero_even_numbers(arr): Replaces all even numbers in the array with zeroes. Parameters: arr (list): A list of integers. Returns: list: A list with all even numbers replaced by zeroes. return [0 if x % 2 == 0 else x for x in arr]"},{"question":"def lis_length(prices): Find the length of the longest strictly increasing subsequence of the paintings' estimated prices. >>> lis_length([10, 20, 10, 30, 20, 50, 60]) 5 >>> lis_length([5, 3, 4, 8, 6]) 3 def process_test_cases(test_cases): Process multiple test cases and return the results. >>> process_test_cases([(7, [10, 20, 10, 30, 20, 50, 60]), (5, [5, 3, 4, 8, 6])]) [5, 3] def main(input_data): Read input data, process each test case, and print the results.","solution":"def lis_length(prices): Find the length of the longest increasing subsequence. from bisect import bisect_left lis = [] for price in prices: pos = bisect_left(lis, price) if pos == len(lis): lis.append(price) else: lis[pos] = price return len(lis) def process_test_cases(test_cases): results = [] for case in test_cases: N, prices = case results.append(lis_length(prices)) return results def main(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) prices = list(map(int, input_lines[index + 1].split())) test_cases.append((N, prices)) index += 2 results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray using Kadane's Algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-3]) -3 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10 >>> max_subarray_sum([i for i in range(-5000, 5000)]) 12497500","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray using Kadane's Algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def tournament_outcomes(n: int, participants: List[int], k: int) -> List[Tuple[int, int]]: Determines the maximum number of teams that can be formed and the number of participants left out for each tournament. Parameters: n (int): Number of tournaments participants (list): List of number of participants in each tournament k (int): Team size Returns: list of tuples: Each tuple contains (max_teams, left_out_participants) >>> tournament_outcomes(3, [10, 11, 25], 3) [(3, 1), (3, 2), (8, 1)] >>> tournament_outcomes(2, [5, 12], 5) [(1, 0), (2, 2)]","solution":"def tournament_outcomes(n, participants, k): Determines the maximum number of teams that can be formed and the number of participants left out for each tournament. Parameters: n (int): Number of tournaments participants (list): List of number of participants in each tournament k (int): Team size Returns: list of tuples: Each tuple contains (max_teams, left_out_participants) outcomes = [] for p in participants: max_teams = p // k left_out = p % k outcomes.append((max_teams, left_out)) return outcomes"},{"question":"def generate_magic_sequence(n: int, k: int) -> int: Generates the k-th Magic Sequence of length n. >>> generate_magic_sequence(2, 1) 11 >>> generate_magic_sequence(3, 10) 120 pass def main(input_data: str) -> list: Handles input and output for the problem. >>> main(\\"2n2 3n3 10\\") [13, 120] pass","solution":"def generate_magic_sequence(n, k): Generates the k-th Magic Sequence of length n. if n == 1: return k current = int('1' * n) count = 1 while count < k: current += 1 count += 1 return current def main(input_data): Handles input and output for the problem. results = [] data = input_data.strip().split() T = int(data[0]) index = 1 for _ in range(T): n = int(data[index]) k = int(data[index + 1]) results.append(generate_magic_sequence(n, k)) index += 2 return results"},{"question":"def find_two_sum_indices(arr, target): Finds two distinct indices in the array such that the elements at these indices add up to the target. Args: arr: List of integers. target: Integer target sum. Returns: A tuple of two integers representing the 1-based indices in increasing order. Examples: >>> find_two_sum_indices([2, 7, 11, 15], 9) (1, 2) >>> find_two_sum_indices([3, 2, 4], 6) (2, 3) # TODO: Implement this function import pytest def test_example_1(): arr = [2, 7, 11, 15] target = 9 assert find_two_sum_indices(arr, target) == (1, 2) def test_example_2(): arr = [3, 2, 4] target = 6 assert find_two_sum_indices(arr, target) == (2, 3) def test_larger_array(): arr = [1, 2, 3, 4, 5, 6] target = 11 assert find_two_sum_indices(arr, target) == (5, 6) def test_negative_numbers(): arr = [-3, 4, 3, 90] target = 0 assert find_two_sum_indices(arr, target) == (1, 3) def test_no_solution(): arr = [1, 2, 3, 4, 5] target = 10 assert find_two_sum_indices(arr, target) is None","solution":"def find_two_sum_indices(arr, target): Finds two distinct indices in the array such that the elements at these indices add up to the target. Args: arr: List of integers. target: Integer target sum. Returns: A tuple of two integers representing the 1-based indices in increasing order. index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return (index_map[complement] + 1, i + 1) index_map[num] = i return None"},{"question":"def merge_dicts(dict1, dict2): Merges two dictionaries by summing the values of matching keys. If a key exists in only one dictionary, it appears in the resulting dictionary with its value unchanged. Examples: >>> merge_dicts({\\"a\\": 1, \\"b\\": 2}, {\\"b\\": 3, \\"c\\": 4}) {\\"a\\": 1, \\"b\\": 5, \\"c\\": 4} >>> merge_dicts({\\"x\\": 5}, {\\"x\\": -5, \\"y\\": 7}) {\\"x\\": 0, \\"y\\": 7} >>> merge_dicts({}, {\\"a\\": 1, \\"b\\": 2}) {\\"a\\": 1, \\"b\\": 2} >>> merge_dicts({}, {}) {}","solution":"def merge_dicts(dict1, dict2): Merges two dictionaries by summing the values of matching keys. If a key exists in only one dictionary, it appears in the resulting dictionary with its value unchanged. result = dict1.copy() # Start with a copy of the first dictionary for key, value in dict2.items(): if key in result: result[key] += value # Sum the values if the key exists in both dictionaries else: result[key] = value # Add the key-value pair if it does not exist in the first dictionary return result"},{"question":"from typing import List def best_move(grid: List[List[int]]) -> str: Create a 2048 game solver that takes an initial game state and suggests the next optimal move. Parameters: grid (List[List[int]]): A 4x4 2D list representing the game board. Returns: str: The best move. One of 'up', 'down', 'left', 'right'. Example: >>> grid = [ ... [2, 4, 2, 0], ... [2, 0, 4, 2], ... [8, 16, 32, 0], ... [1024, 1024, 64, 0] ... ] >>> best_move(grid) in ['up', 'down', 'left', 'right'] True pass # Unit tests def test_scenario1(): grid = [ [2, 4, 2, 0], [2, 0, 4, 2], [8, 16, 32, 0], [1024, 1024, 64, 0] ] assert best_move(grid) in ['up', 'down', 'left', 'right'] def test_scenario2(): grid = [ [0, 0, 2, 2], [2, 2, 2, 2], [0, 0, 4, 4], [4, 4, 4, 4] ] assert best_move(grid) in ['up', 'down', 'left', 'right'] def test_scenario3(): grid = [ [0, 0, 0, 2], [0, 0, 0, 4], [0, 0, 0, 8], [0, 0, 0, 16] ] assert best_move(grid) in ['up', 'down', 'left', 'right'] def test_scenario4(): grid = [ [2, 4, 8, 16], [32, 64, 128, 256], [512, 1024, 2048, 4096], [8192, 16384, 0, 0] ] assert best_move(grid) in ['up', 'down', 'left', 'right'] def test_scenario5(): grid = [ [2, 2, 2, 2], [4, 4, 4, 4], [8, 8, 8, 8], [16, 16, 16, 16] ] assert best_move(grid) in ['up', 'down', 'left', 'right']","solution":"import random from typing import List def evaluate_grid(grid): eval_score = 0 for row in grid: eval_score += sum(row) return eval_score def slide_left(grid): out_grid = [] for row in grid: new_row = [num for num in row if num != 0] new_row += [0] * (len(row) - len(new_row)) out_grid.append(new_row) return out_grid def merge_left(grid): out_grid = [] for row in grid: new_row = [] skip = False for i in range(len(row)): if skip: skip = False continue if i + 1 < len(row) and row[i] == row[i + 1]: new_row.append(2 * row[i]) skip = True else: new_row.append(row[i]) new_row += [0] * (len(row) - len(new_row)) out_grid.append(new_row) return out_grid def move_left(grid): moved = slide_left(grid) moved = merge_left(moved) moved = slide_left(moved) return moved def move_right(grid): rotated = [row[::-1] for row in grid] moved = move_left(rotated) return [row[::-1] for row in moved] def move_up(grid): rotated = list(zip(*grid)) moved = move_left([list(row) for row in rotated]) return [list(row) for row in zip(*moved)] def move_down(grid): rotated = list(zip(*grid))[::-1] moved = move_left([list(row) for row in rotated]) return [list(row) for row in zip(*moved[::-1])] def generate_successors(grid): successors = { 'up': move_up(grid), 'down': move_down(grid), 'left': move_left(grid), 'right': move_right(grid) } return successors def best_move(grid: List[List[int]]) -> str: moves = ['up', 'down', 'left', 'right'] best_move = moves[0] max_evaluation = -1 successors = generate_successors(grid) for move, successor in successors.items(): eval_score = evaluate_grid(successor) if eval_score > max_evaluation: max_evaluation = eval_score best_move = move return best_move"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be formed using any subset of characters from the given string \`s\`. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"abcba\\") 5 >>> longest_palindrome_length(\\"abcdefg\\") 1 >>> longest_palindrome_length(\\"\\") 0","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed using any subset of characters from the given string \`s\`. from collections import Counter # Count the occurrences of each character in the string count = Counter(s) length = 0 odd_found = False # Iterate over each character count for char, freq in count.items(): if freq % 2 == 0: # If the frequency is even, add it fully length += freq else: # If the frequency is odd, add the largest even part length += freq - 1 odd_found = True # If there was any character with an odd count, add 1 to length if odd_found: length += 1 return length"},{"question":"def trap(height: List[int]) -> int: This function takes a list of non-negative integers representing an elevation map and returns the total volume of water trapped after raining. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): This function takes a list of non-negative integers representing an elevation map and returns the total volume of water trapped after raining. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def process_operations(N, M, operations): Process a series of operations on an N x M grid to update cell values and compute sums of subgrids. Parameters: N (int): Number of rows in the grid M (int): Number of columns in the grid operations (List[List[int]]): List of operations, where each operation is a list of integers. Each operation can be: [1, x, y, val] - Set the value of the cell at position (x, y) to val [2, x1, y1, x2, y2] - Compute the sum of all values in the subgrid from top-left (x1, y1) to bottom-right (x2, y2) Returns: List[int]: Results of the operations of type 2 pass import pytest def test_example_case(): operations = [ [1, 1, 1, 5], [1, 2, 2, 7], [2, 1, 1, 2, 2], [1, 3, 3, 3], [2, 1, 1, 3, 3] ] expected = [12, 15] assert process_operations(3, 3, operations) == expected def test_update_only(): operations = [ [1, 1, 1, 10], [1, 2, 2, 20] ] expected = [] assert process_operations(2, 2, operations) == expected def test_query_entire_grid(): operations = [ [1, 1, 1, 1], [1, 1, 2, 2], [1, 2, 1, 3], [1, 2, 2, 4], [2, 1, 1, 2, 2] ] expected = [10] assert process_operations(2, 2, operations) == expected def test_update_same_cell(): operations = [ [1, 1, 1, 5], [1, 1, 1, 10], [2, 1, 1, 1, 1] ] expected = [10] assert process_operations(1, 1, operations) == expected def test_complex_operations(): operations = [ [1, 1, 1, 5], [1, 2, 2, 10], [1, 3, 3, 15], [2, 1, 1, 3, 3], [1, 1, 1, -5], [2, 1, 1, 3, 3] ] expected = [30, 20] assert process_operations(3, 3, operations) == expected if __name__ == '__main__': pytest.main()","solution":"def process_operations(N, M, operations): grid = [[0] * M for _ in range(N)] results = [] def update(x, y, val): grid[x][y] = val def query(x1, y1, x2, y2): total = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total += grid[i][j] return total for operation in operations: if operation[0] == 1: _, x, y, val = operation update(x - 1, y - 1, val) elif operation[0] == 2: _, x1, y1, x2, y2 = operation result = query(x1 - 1, y1 - 1, x2 - 1, y2 - 1) results.append(result) return results"},{"question":"def is_path_exists(maze: List[str]) -> bool: Determines if a path exists from the start 'S' to the destination 'D' in the given maze. The maze is represented as a list of strings, where each string represents a row in the grid. Empty cells are denoted by '.', wall cells by '#', the starting point by 'S', and the destination by 'D'. Args: - maze (list of strings): The maze grid. Returns: - bool: True if a path exists from 'S' to 'D', False otherwise. Examples: >>> is_path_exists([ \\"S....\\", \\".#.\\", \\".#D#.\\", \\"...#.\\", ]) True >>> is_path_exists([ \\"S..\\", \\"#\\", \\"..D\\", ]) False >>> is_path_exists([ \\"S#\\", \\"#D\\", ]) False","solution":"def is_path_exists(maze): Determines if there is a path from 'S' to 'D' in the given maze. Args: - maze (list of strings): The maze grid, each string representing a row. Returns: - bool: True if a path exists, False otherwise. if not maze: return False n = len(maze) m = len(maze[0]) # Find the starting point 'S' and destination 'D' start = None destination = None for i in range(n): for j in range(m): if maze[i][j] == 'S': start = (i, j) elif maze[i][j] == 'D': destination = (i, j) if not start or not destination: return False # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS to find the path from collections import deque queue = deque([start]) visited = set([start]) while queue: current = queue.popleft() if current == destination: return True for direction in directions: next_x, next_y = current[0] + direction[0], current[1] + direction[1] if 0 <= next_x < n and 0 <= next_y < m and maze[next_x][next_y] != '#' and (next_x, next_y) not in visited: queue.append((next_x, next_y)) visited.add((next_x, next_y)) return False"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns a list of all possible subsets (power set) of the list of unique integers 'nums'. >>> subsets([]) [[]] >>> subsets([1]) [[], [1]] >>> subsets([1, 2]) [[], [1], [2], [1, 2]] >>> subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> subsets([1, 2, 3, 4]) [[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]] >>> subsets([2, 5, 7]) [[], [2], [5], [7], [2, 5], [2, 7], [5, 7], [2, 5, 7]]","solution":"from itertools import combinations def subsets(nums): Returns a list of all possible subsets of the list of unique integers 'nums'. Each subset is sorted in ascending order. result = [] for i in range(len(nums) + 1): for subset in combinations(nums, i): result.append(list(subset)) return result"},{"question":"def largestRectangleArea(heights): Calculates the maximum area of a rectangle that can be formed in the histogram with given heights. Args: heights: List[int] - List of integers representing the heights of the buildings. Returns: int - The maximum area of a rectangle. Examples: >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([7, 2, 1, 4]) 7 >>> largestRectangleArea([5, 5, 5, 5, 5]) 25 >>> largestRectangleArea([6, 2, 4]) 6","solution":"def largestRectangleArea(heights): Calculates the maximum area of a rectangle that can be formed in the histogram with given heights. :param heights: List[int] - List of integers representing the heights of the buildings. :return: int - The maximum area of a rectangle. stack = [] max_area = 0 heights.append(0) # Adding a zero height to force calculation of remaining areas in stack for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) return max_area"},{"question":"def number_of_orders(N: int, M: int) -> int: Calculate the total number of possible ice cream orders that a customer can place given the number of flavors and toppings. Args: N (int): Number of ice cream flavors M (int): Number of toppings Returns: int: Total number of possible ice cream orders Example: >>> number_of_orders(3, 2) 12 >>> number_of_orders(4, 3) 32 >>> number_of_orders(5, 1) 10 pass","solution":"def number_of_orders(N: int, M: int) -> int: Returns the total number of possible ice cream orders given N flavors and M toppings. # Each flavor has 2^M possible topping combinations (including no topping) combinations_per_flavor = 2 ** M # Total orders would be number of flavors times combinations per flavor total_orders = N * combinations_per_flavor return total_orders"},{"question":"def min_cost_to_buy_pizzas(N: int, M: int, deals: List[Tuple[int, int]]) -> int: Calculate the minimum cost to buy exactly N pizzas using deals from M pizzerias. Args: N (int): Number of pizzas needed. M (int): Number of pizzerias. deals (List[Tuple[int, int]]): A list of tuples where each tuple represents a deal in the form (number_of_pizzas, cost). Returns: int: The minimum cost to buy exactly N pizzas. If it's not possible to buy exactly N pizzas, returns -1. >>> min_cost_to_buy_pizzas(3, 2, [(2, 5), (3, 8)]) 8 >>> min_cost_to_buy_pizzas(7, 3, [(4, 10), (3, 7), (5, 11)]) 17 >>> min_cost_to_buy_pizzas(6, 2, [(2, 3), (4, 7)]) 9 >>> min_cost_to_buy_pizzas(5, 1, [(3, 8)]) -1 >>> min_cost_to_buy_pizzas(10, 3, [(2, 3), (5, 7), (6, 9)]) 14 >>> min_cost_to_buy_pizzas(10, 1, [(1, 1)]) 10 >>> min_cost_to_buy_pizzas(10, 2, [(1, 2), (2, 3)]) 15","solution":"def min_cost_to_buy_pizzas(N, M, deals): # Initialize an array to store the minimum cost to buy exactly i pizzas dp = [float('inf')] * (N + 1) dp[0] = 0 # Base case: it costs nothing to buy 0 pizzas # Process each deal from each pizzeria for deal in deals: k, p = deal # k is the number of pizzas, p is the cost for i in range(k, N + 1): dp[i] = min(dp[i], dp[i - k] + p) return dp[N] if dp[N] != float('inf') else -1"},{"question":"def max_equal_weight(T: int, test_cases: list) -> list: Given an integer T representing the number of test cases, and a list of test cases where each test case is a tuple containing an integer N and a list of N weights, returns a list of integers where each integer represents the maximum total weight that can be equally distributed to the pairs for each test case. >>> max_equal_weight(2, [(6, [1, 1, 2, 2, 3, 3]), (5, [1, 2, 3, 3, 4])]) [12, 6] >>> max_equal_weight(1, [(4, [1, 1, 1, 1])]) [4] from solution import max_equal_weight def test_case_1(): T = 2 test_cases = [ (6, [1, 1, 2, 2, 3, 3]), (5, [1, 2, 3, 3, 4]) ] expected = [12, 6] assert max_equal_weight(T, test_cases) == expected def test_case_2(): T = 1 test_cases = [ (4, [1, 1, 1, 1]) ] expected = [4] assert max_equal_weight(T, test_cases) == expected def test_case_3(): T = 1 test_cases = [ (6, [1, 1, 1, 1, 1, 1]) ] expected = [6] assert max_equal_weight(T, test_cases) == expected def test_case_4(): T = 1 test_cases = [ (6, [2, 3, 4, 5, 6, 7]) ] expected = [0] assert max_equal_weight(T, test_cases) == expected def test_case_5(): T = 1 test_cases = [ (3, [7, 7, 7]) ] expected = [14] assert max_equal_weight(T, test_cases) == expected","solution":"def max_equal_weight(T, test_cases): results = [] for i in range(T): _, weights = test_cases[i] weight_count = {} # Count the frequency of each weight for weight in weights: if weight in weight_count: weight_count[weight] += 1 else: weight_count[weight] = 1 # Calculate the maximum total weight total_weight = 0 for weight, count in weight_count.items(): total_weight += (count // 2) * 2 * weight results.append(total_weight) return results"},{"question":"class ArrayQueryProcessor: def __init__(self, n, arr): self.n = n self.arr = arr def execute_query(self, query): query_type, *params = query if query_type == 1: p, x = params self.arr[p - 1] = x elif query_type == 2: l, r = params return sum(self.arr[l - 1: r]) def process_queries(n, q, arr, queries): You are given an array of positive integers \`arr\` of length \`n\` and \`q\` queries. Each query can be one of the following two types: 1. \`1 p x\` (1  p  n, x is a positive integer): Replace the element at position \`p\` in the array with \`x\`. 2. \`2 l r\` (1  l  r  n): Calculate the sum of the elements in the subarray from \`arr[l]\` to \`arr[r]\` inclusive. For each query of the second type, output the sum of the specified subarray. Args: n (int): Length of the array. q (int): Number of queries. arr (List[int]): The array of positive integers. queries (List[Tuple[int, int, int]]): The list of queries. Returns: List[int]: The results of the sum queries. Examples: >>> process_queries(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 2, 4), (1, 5, 20), (2, 1, 5)]) [6, 16, 37]","solution":"class ArrayQueryProcessor: def __init__(self, n, arr): self.n = n self.arr = arr def execute_query(self, query): query_type, *params = query if query_type == 1: p, x = params self.arr[p - 1] = x elif query_type == 2: l, r = params return sum(self.arr[l - 1: r]) def process_queries(n, q, arr, queries): processor = ArrayQueryProcessor(n, arr) results = [] for query in queries: if query[0] == 2: results.append(processor.execute_query(query)) else: processor.execute_query(query) return results"},{"question":"def transform_to_circular_route(n: int, m: int, connections: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Transform the initial road network into a circular route network. Parameters: n (int): The number of intersections. m (int): The number of roads. connections (List[Tuple[int, int]]): List of tuples where each tuple represents a road between two intersections. Returns: List[Tuple[int, int]]: List of tuples representing the circular route network. Examples: >>> transform_to_circular_route(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) [(1, 2), (2, 3), (3, 4), (4, 1)] >>> transform_to_circular_route(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4)]) [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]","solution":"def transform_to_circular_route(n, m, connections): Transform the initial road network into a circular route network. Parameters: n (int): The number of intersections. m (int): The number of roads. connections (list of tuple): List of tuples where each tuple represents a road between two intersections. Returns: list of tuple: List of tuples representing the circular route network. # A circular route involves connecting each node to exactly two neighbors forming a cycle circular_route = [] for i in range(1, n): circular_route.append((i, i+1)) circular_route.append((n, 1)) return circular_route"},{"question":"from typing import List def minimum_jumps(N: int, P: int, T: int, jumps: List[int], traps: List[int]) -> int: Determine the minimum number of jumps required to reach the end of the board in a game, without landing on traps. Args: N (int): The number of cells. P (int): The number of possible jump lengths. T (int): The number of traps. jumps (List[int]): The possible jump lengths. traps (List[int]): The positions of the traps. Returns: int: The minimum number of jumps required to reach the end of the board. If it is not possible, return -1. Examples: >>> minimum_jumps(10, 3, 2, [2, 3, 5], [3, 6]) 3 >>> minimum_jumps(10, 2, 3, [2, 5], [3, 6, 8]) -1","solution":"from collections import deque def minimum_jumps(N, P, T, jumps, traps): trap_set = set(traps) if N in trap_set: return -1 visited = [False] * (N + 1) queue = deque([(1, 0)]) # (current_position, jumps_count) visited[1] = True while queue: position, jump_count = queue.popleft() if position == N: return jump_count for jump in jumps: new_position = position + jump if new_position > N: continue if new_position not in trap_set and not visited[new_position]: visited[new_position] = True queue.append((new_position, jump_count + 1)) return -1"},{"question":"def decode_secret_message(k: int, arr: List[int]) -> int: Returns the sum of every k-th number starting from the k-th position in the array. >>> decode_secret_message(3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 18 >>> decode_secret_message(1, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 45 >>> decode_secret_message(10, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 0 >>> decode_secret_message(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> decode_secret_message(5, [1, 2, 3, 4, 5, 6]) 5 >>> decode_secret_message(2, [2, 2, 2, 2, 2, 2]) 6","solution":"def decode_secret_message(k, arr): Returns the sum of every k-th number starting from the k-th position in the array. Parameters: k (int): The step size. arr (list of int): The array of integers. Returns: int: The sum of every k-th element starting from the k-th position. return sum(arr[k-1::k])"},{"question":"def calculate_draught_indicators(n: int, d: int, scores: List[List[int]]) -> List[int]: Calculate the Draught Indicator for each song. The Draught Indicator of a song is defined as the difference between the highest and the lowest popularity scores it has received over a given period. Parameters: - n: int - number of songs - d: int - number of days - scores: List[List[int]] - matrix representing the popularity scores of each song over the days Returns: - List[int] - list containing the Draught Indicator for each song Example: >>> calculate_draught_indicators(3, 4, [ ... [3, 4, 5, 6], ... [1, 2, 2, 1], ... [10, 5, 8, 10] ... ]) [3, 1, 5]","solution":"def calculate_draught_indicators(n, d, scores): draught_indicators = [] for i in range(n): song_scores = scores[i] draught_indicator = max(song_scores) - min(song_scores) draught_indicators.append(draught_indicator) return draught_indicators # Example usage: # n, d = 3, 4 # scores = [ # [3, 4, 5, 6], # [1, 2, 2, 1], # [10, 5, 8, 10] # ] # print(calculate_draught_indicators(n, d, scores)) # Should print [3, 1, 5]"},{"question":"def analyze_badge_system(T: int, data: List[int, str]) -> List[str]: Analyze the partial staff activity logs and determine if there are any discrepancies in the badge system logs. Args: T (int): Number of test cases data (List[int, str]): Flat list of test cases data Returns: List[str]: \\"YES\\" if no discrepancies, else \\"NO\\" for each test case >>> analyze_badge_system(3, [4, 1, \\"entry\\", \\"09:00\\", 2, \\"entry\\", \\"09:10\\", 1, \\"exit\\", \\"17:00\\", 2, \\"entry\\", \\"16:00\\", 5, 3, \\"entry\\", \\"08:00\\", 3, \\"exit\\", \\"12:00\\", 3, \\"entry\\", \\"13:00\\", 3, \\"exit\\", \\"17:00\\", 4, \\"entry\\", \\"09:45\\", 3, 4, \\"entry\\", \\"09:00\\", 4, \\"entry\\", \\"12:00\\", 4, \\"exit\\", \\"18:00\\"]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> analyze_badge_system(1, [2, 1, \\"entry\\", \\"08:00\\", 1, \\"exit\\", \\"17:00\\"]) [\\"YES\\"]","solution":"def detect_discrepancies(test_cases): results = [] for log_entries in test_cases: id_status = {} discrepancy = False for log in log_entries: employee_id, action = log if action == \\"entry\\": if employee_id in id_status and id_status[employee_id] == \\"entry\\": discrepancy = True break id_status[employee_id] = \\"entry\\" elif action == \\"exit\\": if employee_id not in id_status or id_status[employee_id] == \\"exit\\": discrepancy = True break id_status[employee_id] = \\"exit\\" if discrepancy: results.append(\\"NO\\") else: results.append(\\"YES\\") return results # Main function to convert input data to the appropriate format def analyze_badge_system(T, data): test_cases = [] data_index = 0 for _ in range(T): N = data[data_index] logs = [] for i in range(N): log_entry = (data[data_index + 1 + i * 3], data[data_index + 1 + i * 3 + 1]) logs.append(log_entry) test_cases.append(logs) data_index += 1 + N * 3 return detect_discrepancies(test_cases)"},{"question":"def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determine the maximum distance between any two nodes in a tree. >>> tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 3 >>> tree_diameter(1, []) == 0 >>> tree_diameter(4, [(1, 2), (1, 3), (1, 4)]) == 2 import pytest from typing import List, Tuple def test_tree_diameter_single_node(): assert tree_diameter(1, []) == 0 def test_tree_diameter_linear_tree(): assert tree_diameter(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 def test_tree_diameter_star_tree(): assert tree_diameter(4, [(1, 2), (1, 3), (1, 4)]) == 2 def test_tree_diameter_sample(): assert tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 3 def test_tree_diameter_balanced_tree(): assert tree_diameter(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4 pytest.main()","solution":"from collections import deque def find_farthest_node(n, graph, start): # BFS to find the farthest node from the starting node \\"start\\" dist = [-1] * (n + 1) dist[start] = 0 queue = deque([start]) farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if dist[neighbor] == -1: dist[neighbor] = dist[node] + 1 queue.append(neighbor) farthest_node = neighbor return farthest_node, dist def tree_diameter(n, edges): if n == 1: return 0 # Build the graph graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) # Find the farthest node from node 1 farthest_node, _ = find_farthest_node(n, graph, 1) # Find the farthest node from \\"farthest_node\\" found above opposite_node, dist = find_farthest_node(n, graph, farthest_node) # The distance to the farthest node found in the second BFS gives the tree diameter return dist[opposite_node]"},{"question":"def minimum_songs_needed(n: int, songs: List[Tuple[int, int]]) -> int: Given the number of songs and their respective years, this function returns the minimum number of songs needed to have at least one song from each year from 2000 to 2019. >>> minimum_songs_needed(9, [(1, 2000), (2, 2001), (3, 2002), (4, 2002), (5, 2004), (6, 2004), (7, 2004), (8, 2000), (9, 2001)]) 7","solution":"def minimum_songs_needed(n, songs): Given the number of songs and their respective years, this function returns the minimum number of songs needed to have at least one song from each year from 2000 to 2019. years = {year: [] for year in range(2000, 2020)} # Populate the dictionary with song IDs for each year for song_id, year in songs: years[year].append(song_id) # We need at least one song from each year playlist = [] for year in range(2000, 2020): if years[year]: playlist.append(years[year][0]) else: # If any year is missing a song, it's impossible to build the playlist raise ValueError(f\\"No songs available for the year {year}\\") return len(playlist)"},{"question":"def has_overlapping_tasks(tasks): Determines if any two tasks in the list overlap. Parameters: tasks (list of tuples): A list where each tuple contains two integers (start, end). Returns: bool: True if there are overlapping tasks, False otherwise. Examples: >>> has_overlapping_tasks([(1, 5), (6, 10), (11, 15)]) False >>> has_overlapping_tasks([(1, 5), (5, 10), (10, 15), (7, 12)]) True","solution":"def has_overlapping_tasks(tasks): Determines if any two tasks in the list overlap. Parameters: tasks (list of tuples): A list where each tuple contains two integers (start, end). Returns: bool: True if there are overlapping tasks, False otherwise. # Sort the tasks based on the start time tasks.sort(key=lambda x: x[0]) for i in range(len(tasks) - 1): # Check if the end time of the current task exceeds the start time of the next task if tasks[i][1] > tasks[i+1][0]: return True return False"},{"question":"def min_removals_to_avoid_palindromic_subsequences(s: str) -> int: Returns the minimum number of characters to remove such that no palindrome subsequence of length greater than or equal to 2 exists. >>> min_removals_to_avoid_palindromic_subsequences(\\"abaa\\") 1 >>> min_removals_to_avoid_palindromic_subsequences(\\"abc\\") 0 >>> min_removals_to_avoid_palindromic_subsequences(\\"aaa\\") 1 pass # Your implementation here","solution":"def min_removals_to_avoid_palindromic_subsequences(s): Returns the minimum number of characters to remove such that no palindrome subsequence of length greater than or equal to 2 exists. if len(s) == 1: return 0 for char in set(s): if s.count(char) > 1: return 1 return 0"},{"question":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks a single worker can complete in a day. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (3, 9), (6, 8)]) 2 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_tasks([(1, 10), (2, 3), (4, 5), (6,7)]) 3 >>> max_non_overlapping_tasks([(10, 20), (12, 25), (20, 30), (15, 18)]) 2 >>> max_non_overlapping_tasks([(1, 5)]) 1 >>> max_non_overlapping_tasks([]) 0","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks a single worker can complete in a day. if not tasks: return 0 # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) count = 1 end_time = tasks[0][1] for i in range(1, len(tasks)): if tasks[i][0] >= end_time: count += 1 end_time = tasks[i][1] return count"},{"question":"def can_place_tables(H: int, W: int, N: int, tables: List[Tuple[int, int]]) -> str: Determine if all tables can be placed in the garden space without overlapping. Args: H (int): Height of the garden. W (int): Width of the garden. N (int): Number of tables. tables (List[Tuple[int, int]]): List of tuples representing the height and width of each table. Returns: str: \\"possible\\" if all tables can be placed, otherwise \\"impossible\\". >>> can_place_tables(4, 4, 2, [(2, 2), (2, 2)]) \\"possible\\" >>> can_place_tables(3, 3, 2, [(2, 2), (2, 2)]) \\"impossible\\" from solution import can_place_tables def test_single_table_fits(): assert can_place_tables(3, 3, 1, [(2, 2)]) == \\"possible\\" def test_multiple_tables_fit(): assert can_place_tables(4, 4, 2, [(2, 2), (2, 2)]) == \\"possible\\" def test_multiple_tables_do_not_fit(): assert can_place_tables(3, 3, 2, [(2, 2), (2, 2)]) == \\"impossible\\" def test_tables_with_zero_space_left(): assert can_place_tables(5, 5, 4, [(2, 2), (2, 2), (1, 1), (1, 4)]) == \\"possible\\" def test_min_size_garden(): assert can_place_tables(1, 1, 1, [(1, 1)]) == \\"possible\\" assert can_place_tables(1, 1, 1, [(2, 2)]) == \\"impossible\\" def test_max_size_garden(): assert can_place_tables(10, 10, 6, [(5, 5), (4, 4), (2, 2), (3, 3), (1, 1), (2, 2)]) == \\"possible\\"","solution":"def can_place_tables(H, W, N, tables): from itertools import permutations, product def can_place_table(grid, table, row, col): table_h, table_w = table if row + table_h > H or col + table_w > W: return False for i in range(row, row + table_h): for j in range(col, col + table_w): if grid[i][j]: return False return True def place_table(grid, table, row, col): table_h, table_w = table for i in range(row, row + table_h): for j in range(col, col + table_w): grid[i][j] = True def remove_table(grid, table, row, col): table_h, table_w = table for i in range(row, row + table_h): for j in range(col, col + table_w): grid[i][j] = False perms = permutations(tables) empty_grid = [[False] * W for _ in range(H)] for perm in perms: def dfs(tables_idx, grid): if tables_idx == N: return True table = perm[tables_idx] for r, c in product(range(H), range(W)): if can_place_table(grid, table, r, c): place_table(grid, table, r, c) if dfs(tables_idx + 1, grid): return True remove_table(grid, table, r, c) return False if dfs(0, empty_grid): return \\"possible\\" return \\"impossible\\" # Example Usage: H = 4 W = 4 N = 2 tables = [(2, 2), (2, 2)] print(can_place_tables(H, W, N, tables)) # Output: possible"},{"question":"from typing import List def min_moves_to_sort_deck(n: int, cards: List[int]) -> int: Returns the minimum number of moves required to sort the deck in ascending order. Parameters: - n (int): The number of cards. - cards (List[int]): The current order of the cards in the deck. Returns: - int: The minimum number of moves required to sort the deck. Examples: >>> min_moves_to_sort_deck(5, [4, 3, 2, 5, 1]) 3 >>> min_moves_to_sort_deck(3, [2, 1, 3]) 1 >>> min_moves_to_sort_deck(6, [3, 1, 4, 5, 2, 6]) 2","solution":"def min_moves_to_sort_deck(n, cards): Returns the minimum number of moves required to sort the deck. Parameters: - n (int): The number of cards. - cards (list): The current order of the cards in the deck. Returns: - int: The minimum number of moves required to sort the deck. # Find the longest increasing subsequence in \`cards\` position_lookup = {card: index for index, card in enumerate(cards)} LIS_length = 0 current_length = 0 last_position = -1 for i in range(1, n + 1): if last_position < position_lookup[i]: current_length += 1 else: current_length = 1 last_position = position_lookup[i] if current_length > LIS_length: LIS_length = current_length # The number of moves required is \`(n - length of the longest increasing subsequence)\` return n - LIS_length"},{"question":"from typing import List def max_gold(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum number of gold coins that can be collected along the path from the top-left corner to the bottom-right corner of the grid. >>> max_gold(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 12 >>> max_gold(1, 1, [ [10] ]) == 10 >>> max_gold(1, 4, [ [1, 2, 3, 4] ]) == 10 >>> max_gold(4, 1, [ [1], [2], [3], [4] ]) == 10 >>> max_gold(2, 2, [ [1000, 1000], [1000, 1000] ]) == 3000 >>> max_gold(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0","solution":"from typing import List def max_gold(n: int, m: int, grid: List[List[int]]) -> int: # Create a DP table to store the maximum gold collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left cell with the amount of gold in that cell dp[0][0] = grid[0][0] # Fill the first row (we can only move right) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (we can only move down) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The value at the bottom-right corner will be the answer return dp[n-1][m-1]"},{"question":"def canArrangeBracelet(beads): Determine if it's possible to arrange beads into a bracelet such that no two neighboring beads share the same color. Args: beads (List[int]): an array of integers representing the colors of the beads. Returns: str: \\"YES\\" if the bracelet can be arranged as described, or \\"NO\\" otherwise. >>> canArrangeBracelet([1, 2, 2, 3, 4]) \\"YES\\" >>> canArrangeBracelet([1, 1, 1, 1]) \\"NO\\" >>> canArrangeBracelet([1, 2, 3, 4, 5, 6]) \\"YES\\" def test_sample_input_0(): assert canArrangeBracelet([1, 2, 2, 3, 4]) == \\"YES\\" def test_sample_input_1(): assert canArrangeBracelet([1, 1, 1, 1]) == \\"NO\\" def test_sample_input_2(): assert canArrangeBracelet([1, 2, 3, 4, 5, 6]) == \\"YES\\" def test_all_same_color(): assert canArrangeBracelet([7, 7, 7, 7, 7]) == \\"NO\\" def test_two_dominant_colors(): assert canArrangeBracelet([8, 8, 8, 8, 9, 9, 9, 9]) == \\"YES\\" def test_large_number_of_colors(): assert canArrangeBracelet([i for i in range(1, 101)]) == \\"YES\\"","solution":"def canArrangeBracelet(beads): from collections import Counter bead_counts = Counter(beads) max_count = max(bead_counts.values()) n = len(beads) # More than half of the beads cannot be the same color for a valid bracelet if max_count > (n + 1) // 2: return \\"NO\\" else: return \\"YES\\""},{"question":"def best_trade(prices: List[int]) -> List[int]: Determines the best days to buy and sell the stock to maximize profit. Args: prices (list): List of daily stock prices. Returns: list: A list of two integers representing the indices of the buy and sell days, respectively. If no profit can be made, returns [-1, -1]. # Your implementation here from solution import best_trade def test_typical_case(): assert best_trade([7, 1, 5, 3, 6, 4]) == [1, 4] def test_no_profit(): assert best_trade([7, 6, 4, 3, 1]) == [-1, -1] def test_increasing_prices(): assert best_trade([1, 2, 3, 4, 5]) == [0, 4] def test_single_price(): assert best_trade([10]) == [-1, -1] def test_empty_list(): assert best_trade([]) == [-1, -1] def test_multiple_opportunities(): assert best_trade([3, 8, 2, 7, 4, 9, 1, 6]) == [2, 5] def test_same_price_multiple_days(): assert best_trade([5, 5, 5, 5, 5]) == [-1, -1] def test_fluctuating_prices(): assert best_trade([5, 1, 6, 4, 7, 2, 3, 8]) == [1, 7]","solution":"def best_trade(prices): Determines the best days to buy and sell the stock to maximize profit. Args: prices (list): List of daily stock prices. Returns: list: A list of two integers representing the indices of the buy and sell days, respectively. If no profit can be made, returns [-1, -1]. if not prices or len(prices) < 2: return [-1, -1] min_price_index = 0 max_profit = 0 buy_sell_days = [-1, -1] for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_index]: min_price_index = current_day current_profit = prices[current_day] - prices[min_price_index] if current_profit > max_profit: max_profit = current_profit buy_sell_days = [min_price_index, current_day] return buy_sell_days if max_profit > 0 else [-1, -1]"},{"question":"def reverse_words(sentence: str) -> str: Reverses the sequence of words in the sentence while preserving the word order. Parameters: sentence (str): The input string containing words separated by spaces. Returns: str: A string with the sequence of words reversed. >>> reverse_words(\\"hello world this is a test\\") 'test a is this world hello' >>> reverse_words(\\" hello world \\") 'world hello' >>> reverse_words(\\"hello world this is a test\\") 'test a is this world hello' >>> reverse_words(\\"\\") == \\"\\" True >>> reverse_words(\\" \\") == \\"\\" True","solution":"def reverse_words(sentence): Reverses the sequence of words in the sentence while preserving the word order. Parameters: sentence (str): The input string containing words separated by spaces. Returns: str: A string with the sequence of words reversed. # Split the sentence into words, using split which also automatically removes extra spaces. words = sentence.strip().split() # Reverse the list of words and join them with a space. reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"def reverse_integer(n: int) -> int: Reverses the digits of an integer while preserving the sign. Returns 0 if the reversed integer exceeds 32-bit signed integer range. >>> reverse_integer(123) 321 >>> reverse_integer(-456) -654 >>> reverse_integer(120) 21 >>> reverse_integer(1534236469) 0 >>> reverse_integer(0) 0 >>> reverse_integer(5) 5 >>> reverse_integer(-5) -5","solution":"def reverse_integer(n): Reverses the digits of an integer while preserving the sign. Returns 0 if the reversed integer exceeds 32-bit signed integer range. sign = -1 if n < 0 else 1 reversed_number = int(str(abs(n))[::-1]) * sign if -2**31 <= reversed_number <= 2**31 - 1: return reversed_number else: return 0"},{"question":"def is_valid_string(s: str) -> bool: Determine if the string s is valid based on the given criteria. A string is considered valid if it contains at least one uppercase letter, one lowercase letter, one digit, and one special character from the set [!@#%^&*()-+]. Args: s (str): The string to be checked for validity. Returns: bool: True if valid, False otherwise. >>> is_valid_string(\\"HelloWorld1!\\") == True >>> is_valid_string(\\"helloworld\\") == False","solution":"def is_valid_string(s): Determine if the string s is valid based on the given criteria. A string is considered valid if it contains at least one uppercase letter, one lowercase letter, one digit, and one special character from the set [!@#%^&*()-+]. Args: s (str): The string to be checked for validity. Returns: bool: True if valid, False otherwise. has_upper = any(c.isupper() for c in s) has_lower = any(c.islower() for c in s) has_digit = any(c.isdigit() for c in s) has_special = any(c in '!@#%^&*()-+' for c in s) return has_upper and has_lower and has_digit and has_special"},{"question":"def execute_stack_commands(commands: List[str]) -> List[int]: Simulate a basic stack machine performing commands like PUSH, POP, ADD, SUB, MULT, and DIV on a stack of integers. >>> execute_stack_commands([\\"PUSH 5\\", \\"PUSH 3\\", \\"ADD\\", \\"PUSH 8\\", \\"MULT\\"]) [64] >>> execute_stack_commands([\\"PUSH 15\\", \\"PUSH 5\\", \\"DIV\\", \\"PUSH 2\\", \\"ADD\\"]) [5]","solution":"def execute_stack_commands(commands): stack = [] for command in commands: parts = command.split() op = parts[0] if op == \\"PUSH\\": stack.append(int(parts[1])) elif op == \\"POP\\": if stack: stack.pop() elif op == \\"ADD\\": if len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(a + b) elif op == \\"SUB\\": if len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(b - a) elif op == \\"MULT\\": if len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(a * b) elif op == \\"DIV\\": if len(stack) >= 2: a = stack.pop() b = stack.pop() if a != 0: stack.append(b // a) return stack"},{"question":"from typing import List def sumOfKthColumn(matrix: List[List[int]], K: int) -> int: Returns the sum of elements in the Kth column of the given matrix or -1 if the column doesn't exist. Parameters: - matrix: List[List[int]] -- NxM matrix of integers - K: int -- Column index (0-based) whose sum is to be calculated Returns: - int -- Sum of elements in the Kth column or -1 if the column doesn't exist >>> sumOfKthColumn([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], 2) 21 >>> sumOfKthColumn([[1, 2, 3], [4, 5, 6]], 3) -1 pass # Test cases def test_sum_of_kth_column_valid_column(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert sumOfKthColumn(matrix, 2) == 21 def test_sum_of_kth_column_invalid_column(): matrix = [ [1, 2, 3], [4, 5, 6] ] assert sumOfKthColumn(matrix, 3) == -1 def test_sum_of_kth_column_first_column(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert sumOfKthColumn(matrix, 0) == 12 def test_sum_of_kth_column_last_column(): matrix = [ [7, 8, 9], [1, 2, 3], [4, 5, 6] ] assert sumOfKthColumn(matrix, 2) == 18 def test_sum_of_kth_column_negative_elements(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert sumOfKthColumn(matrix, 1) == -15","solution":"def sumOfKthColumn(matrix, K): Returns the sum of elements in the Kth column of the given matrix or -1 if the column doesn't exist. Parameters: - matrix: List[List[int]] -- NxM matrix of integers - K: int -- Column index (0-based) whose sum is to be calculated Returns: - int -- Sum of elements in the Kth column or -1 if the column doesn't exist if not matrix or K >= len(matrix[0]): return -1 column_sum = 0 for row in matrix: column_sum += row[K] return column_sum"},{"question":"def can_form_palindrome(s: str) -> str: This function checks if a given string can be rearranged into a palindrome and returns one possible palindromic arrangement if possible. Otherwise, returns an empty string. >>> can_form_palindrome(\\"code\\") \\"\\" >>> can_form_palindrome(\\"aabb\\") \\"abba\\" >>> can_form_palindrome(\\"aabbc\\") \\"abcba\\" >>> can_form_palindrome(\\"aaaa\\") \\"aaaa\\" >>> can_form_palindrome(\\"a\\") \\"a\\" >>> can_form_palindrome(\\"aabbcc\\") \\"abcabc\\" >>> can_form_palindrome(\\"\\") \\"\\"","solution":"def can_form_palindrome(s): Checks if a given string can be rearranged into a palindrome and returns one possible palindromic arrangement if so. Otherwise, returns an empty string. from collections import Counter count = Counter(s) odd_count = 0 for value in count.values(): if value % 2 != 0: odd_count += 1 if odd_count > 1: return \\"\\" mid = \\"\\" halves = [] for char, freq in count.items(): if freq % 2 != 0: mid = char halves.append(char * (freq // 2)) half = \\"\\".join(halves) return half + mid + half[::-1]"},{"question":"import math from typing import List, Tuple def sum_of_divisors(n: int) -> int: Calculate the sum of divisors of a given number. total = 0 for i in range(1, int(math.sqrt(n)) + 1): if n % i == 0: total += i if i != n // i: total += n // i return total def preprocess(array: List[int]) -> List[int]: Preprocess the array to calculate the sum of divisors for each element. return [sum_of_divisors(x) for x in array] def prefix_sums(array: List[int]) -> List[int]: Create a prefix sum array for efficient range sum computation. prefix = [0] * (len(array) + 1) for i in range(len(array)): prefix[i + 1] = prefix[i] + array[i] return prefix def query(prefix: List[int], l: int, r: int) -> int: Process a single query to find the sum of divisors in the given range. return prefix[r] - prefix[l - 1] def solve(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process all queries given the array and return their results. processed_array = preprocess(array) prefix = prefix_sums(processed_array) results = [] for l, r in queries: results.append(query(prefix, l, r)) return results # Test cases to verify the solution def test_sum_of_divisors(): assert sum_of_divisors(1) == 1 assert sum_of_divisors(2) == 3 assert sum_of_divisors(3) == 4 assert sum_of_divisors(4) == 7 assert sum_of_divisors(5) == 6 def test_preprocess(): array = [1, 2, 3, 4, 5] assert preprocess(array) == [1, 3, 4, 7, 6] def test_prefix_sums(): array = [1, 3, 4, 7, 6] assert prefix_sums(array) == [0, 1, 4, 8, 15, 21] def test_query(): prefix = [0, 1, 4, 8, 15, 21] assert query(prefix, 1, 3) == 8 assert query(prefix, 2, 4) == 14 assert query(prefix, 1, 5) == 21 def test_solve(): n = 5 q = 3 array = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] assert solve(n, q, array, queries) == [8, 14, 21] # Running tests test_sum_of_divisors() test_preprocess() test_prefix_sums() test_query() test_solve()","solution":"import math def sum_of_divisors(n): total = 0 for i in range(1, int(math.sqrt(n)) + 1): if n % i == 0: total += i if i != n // i: total += n // i return total def preprocess(array): Preprocess the array to calculate the sum of divisors for each element. return [sum_of_divisors(x) for x in array] def prefix_sums(array): Create a prefix sum array for efficient range sum computation. prefix = [0] * (len(array) + 1) for i in range(len(array)): prefix[i + 1] = prefix[i] + array[i] return prefix def query(prefix, l, r): return prefix[r] - prefix[l - 1] def solve(n, q, array, queries): processed_array = preprocess(array) prefix = prefix_sums(processed_array) results = [] for l, r in queries: results.append(query(prefix, l, r)) return results"},{"question":"def min_swaps_to_sort(arr): Returns the minimum number of swaps needed to sort the array in non-decreasing order. >>> min_swaps_to_sort([2, 3, 1, 5, 4]) 3 >>> min_swaps_to_sort([3, 1, 2]) 2 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([1, 3, 5, 2, 4, 6]) 3 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 pass def solve_magic_garden(t, test_cases): Solve the minimum swap problem for multiple test cases. >>> solve_magic_garden(2, [(5, [2, 3, 1, 5, 4]), (3, [3, 1, 2])]) [3, 2] >>> solve_magic_garden(2, [(4, [4, 3, 2, 1]), (6, [1, 3, 5, 2, 4, 6])]) [2, 3] >>> solve_magic_garden(1, [(6, [1, 3, 5, 2, 4, 6])]) [3] pass","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps needed to sort the array in non-decreasing order. n = len(arr) arrpos = [(i, arr[i]) for i in range(n)] arrpos.sort(key=lambda it: it[1]) vis = {i: False for i in range(n)} swaps = 0 for i in range(n): if vis[i] or arrpos[i][0] == i: continue cycle_size = 0 x = i while not vis[x]: vis[x] = True x = arrpos[x][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps def solve_magic_garden(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(min_swaps_to_sort(arr)) return results"},{"question":"def matrix_permutation(n: int, m: int, matrix: List[List[int]], permutation: List[int]) -> List[List[int]]: Reorder the matrix based on the provided permutation. Args: n (int): Number of rows. m (int): Number of columns. matrix (list of lists): The original matrix. permutation (list of int): The permutation list. Returns: list of lists: The permuted matrix. >>> matrix_permutation(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], [7, 10, 5, 8, 1, 2, 3, 4, 11, 12, 9, 6]) == [[7, 10, 5, 8], [1, 2, 3, 4], [11, 12, 9, 6]] >>> matrix_permutation(1, 4, [[2, 4, 6, 8]], [4, 2, 1, 3]) == [[8, 4, 2, 6]] >>> matrix_permutation(4, 1, [[2], [4], [6], [8]], [4, 2, 1, 3]) == [[8], [4], [2], [6]] >>> matrix_permutation(2, 2, [[1, 2], [3, 4]], [1, 2, 3, 4]) == [[1, 2], [3, 4]] >>> matrix_permutation(2, 2, [[1, 2], [3, 4]], [4, 3, 2, 1]) == [[4, 3], [2, 1]]","solution":"def matrix_permutation(n, m, matrix, permutation): Reorder the matrix based on the provided permutation. Args: n (int): Number of rows. m (int): Number of columns. matrix (list of lists): The original matrix. permutation (list of int): The permutation list. Returns: list of lists: The permuted matrix. flat_matrix = [item for row in matrix for item in row] new_flat_matrix = [flat_matrix[perm - 1] for perm in permutation] new_matrix = [] for i in range(n): new_matrix.append(new_flat_matrix[i*m:(i+1)*m]) return new_matrix"},{"question":"def trapWater(heights): Calculate the amount of water that can be trapped between buildings. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The total amount of trapped water. Examples: >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapWater([4, 2, 0, 3, 2, 5]) 9","solution":"def trapWater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water = 0 for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"def remove_duplicates(values): Returns a list of integers where any integer that appears twice or more in the original list is removed. >>> remove_duplicates([4, 5, 6, 5, 4, 3, 8]) [6, 3, 8] >>> remove_duplicates([1, 2, 2, 3, 1, 2, 3, 4]) [4]","solution":"def remove_duplicates(values): Returns a list of integers where any integer that appears twice or more in the original list is removed. from collections import Counter # Count the occurrences of each element in the list counts = Counter(values) # Create a new list with elements that appear exactly once result = [num for num in values if counts[num] == 1] return result"},{"question":"def remove_duplicates(nums): Removes duplicates from a sorted array and returns the new length. Args: nums: List[int] - A list of sorted integers. Returns: int - The length of the list after removing duplicates. def test_remove_duplicates(): nums = [1, 1, 2] k = remove_duplicates(nums) assert k == 2 assert nums[:k] == [1, 2] def test_remove_duplicates_example_2(): nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] k = remove_duplicates(nums) assert k == 5 assert nums[:k] == [0, 1, 2, 3, 4] def test_remove_duplicates_all_same(): nums = [2, 2, 2, 2, 2] k = remove_duplicates(nums) assert k == 1 assert nums[:k] == [2] def test_remove_duplicates_no_duplicates(): nums = [1, 2, 3, 4, 5] k = remove_duplicates(nums) assert k == 5 assert nums[:k] == [1, 2, 3, 4, 5] def test_remove_duplicates_empty(): nums = [] k = remove_duplicates(nums) assert k == 0 assert nums[:k] == [] def test_remove_duplicates_one_element(): nums = [1] k = remove_duplicates(nums) assert k == 1 assert nums[:k] == [1]","solution":"def remove_duplicates(nums): Removes duplicates from a sorted array and returns the new length. Args: nums: List[int] - A list of sorted integers. Returns: int - The length of the list after removing duplicates. if not nums: return 0 k = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[k] = nums[i] k += 1 return k"},{"question":"def seasons_greeting(season: int) -> str: Returns the greeting message based on the input season. Parameters: season (int): an integer representing the season (1 for Winter, 2 for Spring, 3 for Summer, 4 for Autumn) Returns: str: greeting message corresponding to the season >>> seasons_greeting(1) 'Happy Winter!' >>> seasons_greeting(3) 'Happy Summer!' >>> seasons_greeting(5) 'Invalid season' from solution import seasons_greeting def test_winter_greeting(): assert seasons_greeting(1) == \\"Happy Winter!\\" def test_spring_greeting(): assert seasons_greeting(2) == \\"Happy Spring!\\" def test_summer_greeting(): assert seasons_greeting(3) == \\"Happy Summer!\\" def test_autumn_greeting(): assert seasons_greeting(4) == \\"Happy Autumn!\\" def test_invalid_season(): assert seasons_greeting(0) == \\"Invalid season\\" assert seasons_greeting(5) == \\"Invalid season\\" assert seasons_greeting(-1) == \\"Invalid season\\" assert seasons_greeting(10) == \\"Invalid season\\"","solution":"def seasons_greeting(season): Returns the greeting message based on the input season. Parameters: season (int): an integer representing the season (1 for Winter, 2 for Spring, 3 for Summer, 4 for Autumn) Returns: str: greeting message corresponding to the season greetings = { 1: \\"Happy Winter!\\", 2: \\"Happy Spring!\\", 3: \\"Happy Summer!\\", 4: \\"Happy Autumn!\\" } return greetings.get(season, \\"Invalid season\\")"},{"question":"def largest_in_diagonals(n: int, grid: List[List[int]]) -> int: Returns the largest integer present within at least one diagonal of the grid. >>> largest_in_diagonals(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9 >>> largest_in_diagonals(3, [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -1","solution":"def largest_in_diagonals(n, grid): Returns the largest integer present within at least one diagonal of the grid. max_value = float('-inf') # Check all diagonals starting from each element in the first row for j in range(n): i, k = 0, j while i < n and k < n: max_value = max(max_value, grid[i][k]) i += 1 k += 1 # Check all diagonals starting from each element in the first column for i in range(1, n): j, k = i, 0 while j < n and k < n: max_value = max(max_value, grid[j][k]) j += 1 k += 1 # Check all anti-diagonals starting from each element in the last column for i in range(n): j, k = i, n - 1 while j < n and k >= 0: max_value = max(max_value, grid[j][k]) j += 1 k -= 1 # Check all anti-diagonals starting from each element in the first row for j in range(n-1): i, k = 0, j while i < n and k >= 0: max_value = max(max_value, grid[i][k]) i += 1 k -= 1 return max_value"},{"question":"def find_pair_with_sum(arr, target): Function to determine if there exist two distinct integers in the array such that their sum is equal to the target sum. Returns 'YES' if such a pair exists, otherwise 'NO'. >>> find_pair_with_sum([2, 7, 11, 15, 1], 9) 'YES' >>> find_pair_with_sum([0, 1, 2], 4) 'NO' # Your code here def process_test_cases(T, test_cases): Process multiple test cases and return the result for each test case. >>> process_test_cases(2, [(5, 9, [2, 7, 11, 15, 1]), (3, 4, [0, 1, 2])]) ['YES', 'NO'] >>> process_test_cases(2, [(5, 10, [1, 2, 3, 4, 6]), (3, 5, [1, 2, 2])]) ['YES', 'NO'] # Your code here","solution":"def find_pair_with_sum(arr, target): Function to determine if there exist two distinct integers in the array such that their sum is equal to the target sum. Returns 'YES' if such a pair exists, otherwise 'NO'. seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases and return the result for each test case. results = [] for case in test_cases: n, k, array = case results.append(find_pair_with_sum(array, k)) return results"},{"question":"def max_non_adjacent_product(arr): Returns the maximum product of two distinct non-adjacent elements in the array. >>> max_non_adjacent_product([3, 6, 1, 9, 4, 7]) 63 >>> max_non_adjacent_product([8, 2, 5, 6, 3]) 48","solution":"def max_non_adjacent_product(arr): Returns the maximum product of two distinct non-adjacent elements in the array. n = len(arr) # Initialize a variable to store the maximum product max_product = 0 # Iterate through each pair and calculate the product if they are non-adjacent for i in range(n): for j in range(i + 2, n): max_product = max(max_product, arr[i] * arr[j]) return max_product"},{"question":"def pig_latin_converter(sentence: str) -> str: Convert a given sentence to Pig Latin following these rules: 1. If a word begins with a vowel (a, e, i, o, u), add \\"way\\" to the end of the word. 2. If a word begins with a consonant, move the first consonant or consonant cluster to the end of the word, and add \\"ay.\\" 3. Maintain capitalization: If the original word is capitalized, the Pig Latin word should also be capitalized. 4. Preserve punctuation: If a word has punctuation attached to it, it should remain at the end of the word. 5. Ignore non-alphabetic characters when processing and keep them as they are. Example: >>> pig_latin_converter(\\"Hello world!\\") \\"Ellohay orldway!\\" >>> pig_latin_converter(\\"Eat apples every day.\\") \\"Eatway applesway everyway ayday.\\" # Your code here # Example usage print(pig_latin_converter(\\"Hello world!\\"))","solution":"def pig_latin_converter(sentence): import re def convert_word(word): vowels = \\"aeiouAEIOU\\" punctuation = ''.join(ch for ch in word if not ch.isalpha()) stripped_word = ''.join(ch for ch in word if ch.isalpha()) if not stripped_word: return word is_capitalized = stripped_word[0].isupper() if stripped_word[0] in vowels: pig_latin = stripped_word + \\"way\\" else: consonant_cluster = re.match(r\\"[^aeiouAEIOU]+\\", stripped_word).group() pig_latin = stripped_word[len(consonant_cluster):] + consonant_cluster.lower() + \\"ay\\" if is_capitalized: pig_latin = pig_latin.capitalize() return pig_latin + punctuation words = sentence.split() converted_words = [convert_word(word) for word in words] return ' '.join(converted_words)"},{"question":"def is_prime(n): Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(15) False def count_prime_pairs(test_cases): Count the number of unique pairs (i, j) where i < j and the sum of the pair (nums[i] + nums[j]) is a prime number for each test case. >>> count_prime_pairs([(4, [1, 4, 6, 7]), (5, [2, 3, 5, 8, 13])]) [1, 4] def process_input(input_data): Process the input string and return test cases in a structured format. >>> process_input(\\"2n4n1 4 6 7n5n2 3 5 8 13n\\") [(4, [1, 4, 6, 7]), (5, [2, 3, 5, 8, 13])] def solve(input_data): Read input, process it, and print the solution for each test case. >>> solve(\\"2n4n1 4 6 7n5n2 3 5 8 13n\\") \\"1n4\\"","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_prime_pairs(test_cases): results = [] for N, nums in test_cases: primes_count = 0 pairs = set() for i in range(N): for j in range(i + 1, N): pair_sum = nums[i] + nums[j] if pair_sum not in pairs: if is_prime(pair_sum): primes_count += 1 pairs.add(pair_sum) results.append(primes_count) return results def process_input(input_data): Input Data: - 1st line : T (number of test cases) - For each test case: - 1st line : N (size of list) - 2nd line : N space-separated integers input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) nums = list(map(int, input_lines[index + 1].strip().split())) test_cases.append((N, nums)) index += 2 return test_cases def solve(input_data): test_cases = process_input(input_data) results = count_prime_pairs(test_cases) return \\"n\\".join(map(str, results))"},{"question":"class Warehouse: A warehouse stores packages in various compartments, each identified by a unique code. Methods: - add(code: str, weight: int, fragile: str): Adds a package to the warehouse. - query(sum_condition: str, start_code: str, end_code: str) -> int: Returns the sum of the weights of packages that fulfill the query requirements. Examples: >>> warehouse = Warehouse() >>> warehouse.add(\\"A1\\", 100, \\"Y\\") >>> warehouse.add(\\"B2\\", 200, \\"N\\") >>> warehouse.add(\\"C3\\", 150, \\"Y\\") >>> warehouse.query(\\"ALL\\", \\"A1\\", \\"C3\\") 450 >>> warehouse.query(\\"FRAGILE\\", \\"A1\\", \\"C3\\") 250 >>> warehouse.query(\\"NONFRAGILE\\", \\"A1\\", \\"C3\\") 200 def __init__(self): Initializes the Warehouse object with no packages. pass def add(self, code: str, weight: int, fragile: str): Adds a package to the warehouse. Args: code (str): The unique code of the compartment. weight (int): The weight of the package. fragile (str): 'Y' if the package is fragile, 'N' otherwise. pass def query(self, sum_condition: str, start_code: str, end_code: str) -> int: Returns the sum of the weights of packages that fulfill the query requirements. Args: sum_condition (str): 'ALL', 'FRAGILE', or 'NONFRAGILE'. start_code (str): The start of the lexicographical range. end_code (str): The end of the lexicographical range. Returns: int: The sum weight of the packages within the specified range and condition. pass import pytest def test_add_and_query_all(): warehouse = Warehouse() warehouse.add(\\"A1\\", 100, \\"Y\\") warehouse.add(\\"B2\\", 200, \\"N\\") warehouse.add(\\"C3\\", 150, \\"Y\\") assert warehouse.query(\\"ALL\\", \\"A1\\", \\"C3\\") == 450 def test_query_fragile(): warehouse = Warehouse() warehouse.add(\\"A1\\", 100, \\"Y\\") warehouse.add(\\"B2\\", 200, \\"N\\") warehouse.add(\\"C3\\", 150, \\"Y\\") assert warehouse.query(\\"FRAGILE\\", \\"A1\\", \\"C3\\") == 250 def test_query_non_fragile(): warehouse = Warehouse() warehouse.add(\\"A1\\", 100, \\"Y\\") warehouse.add(\\"B2\\", 200, \\"N\\") warehouse.add(\\"C3\\", 150, \\"Y\\") assert warehouse.query(\\"NONFRAGILE\\", \\"A1\\", \\"C3\\") == 200 def test_query_no_packages(): warehouse = Warehouse() assert warehouse.query(\\"ALL\\", \\"A1\\", \\"C3\\") == 0 def test_query_case_sensitive(): warehouse = Warehouse() warehouse.add(\\"a1\\", 100, \\"Y\\") warehouse.add(\\"B2\\", 200, \\"N\\") warehouse.add(\\"c3\\", 150, \\"Y\\") assert warehouse.query(\\"ALL\\", \\"A1\\", \\"C3\\") == 200","solution":"class Warehouse: def __init__(self): self.packages = [] def add(self, code: str, weight: int, fragile: str): self.packages.append((code, weight, fragile)) def query(self, sum_condition: str, start_code: str, end_code: str) -> int: total_weight = 0 for code, weight, fragile in self.packages: if start_code <= code <= end_code: if sum_condition == 'ALL': total_weight += weight elif sum_condition == 'FRAGILE' and fragile == 'Y': total_weight += weight elif sum_condition == 'NONFRAGILE' and fragile == 'N': total_weight += weight return total_weight"},{"question":"def min_modifications_to_zero(N: int, sequence: List[int]) -> int: Calculate the minimum number of modifications required to make the sum of the sequence equal to zero. Parameters: N (int): The length of the sequence. sequence (list of int): The sequence of integers. Returns: int: Minimum number of modifications required. >>> min_modifications_to_zero(4, [1, 2, 3, -1]) 2 >>> min_modifications_to_zero(5, [-10, -5, 5, 10, 0]) 0 >>> min_modifications_to_zero(3, [3, -1, 1]) 1 pass","solution":"def min_modifications_to_zero(N, sequence): Calculate the minimum number of modifications required to make the sum of the sequence equal to zero. Parameters: N (int): The length of the sequence. sequence (list of int): The sequence of integers. Returns: int: Minimum number of modifications required. sequence_sum = sum(sequence) return abs(sequence_sum)"},{"question":"def is_valid_isbn10(isbn): This function validates an ISBN-10 number. Parameters: isbn (str): The string representing the potential ISBN-10 code. Returns: bool: True if the string is a valid ISBN-10, False otherwise. >>> is_valid_isbn10(\\"0471958697\\") True >>> is_valid_isbn10(\\"123456789X\\") True >>> is_valid_isbn10(\\"1234567890\\") False >>> is_valid_isbn10(\\"12345678\\") False >>> is_valid_isbn10(\\"1234567890123\\") False >>> is_valid_isbn10(\\"12345A789X\\") False >>> is_valid_isbn10(\\"123456789A\\") False >>> is_valid_isbn10(\\"\\") False","solution":"def is_valid_isbn10(isbn): This function validates an ISBN-10 number. Parameters: isbn (str): The string representing the potential ISBN-10 code. Returns: bool: True if the string is a valid ISBN-10, False otherwise. if len(isbn) != 10: return False if not isbn[:9].isdigit() or (not isbn[9].isdigit() and isbn[9] != 'X'): return False total = 0 for i in range(9): total += int(isbn[i]) * (i + 1) if isbn[9] == 'X': total += 10 * 10 else: total += int(isbn[9]) * 10 return total % 11 == 0"},{"question":"def can_fill_shelf(L: float, a: float, b: float) -> str: Determines if the entire length of the shelf (L) can be completely filled using only books of length a and b. Args: L (float): The length of the shelf. a (float): The length of the first type of book. b (float): The length of the second type of book. Returns: str: \\"Perfect fit!\\" if the shelf can be completely filled, \\"Can't fit perfectly!\\" otherwise. >>> can_fill_shelf(10.0, 3.0, 7.0) 'Perfect fit!' >>> can_fill_shelf(10.0, 3.0, 6.0) \\"Can't fit perfectly!\\"","solution":"def can_fill_shelf(L, a, b): Determines if the entire length of the shelf (L) can be completely filled using only books of length a and b. Args: L (float): The length of the shelf. a (float): The length of the first type of book. b (float): The length of the second type of book. Returns: str: \\"Perfect fit!\\" if the shelf can be completely filled, \\"Can't fit perfectly!\\" otherwise. # Edge case when lengths are zero (invalid case) if L <= 0 or a <= 0 or b <= 0: return \\"Can't fit perfectly!\\" # A way to handle approximate floating point comparison epsilon = 1e-9 for i in range(int(L // a) + 1): for j in range(int(L // b) + 1): if abs(i * a + j * b - L) < epsilon: return \\"Perfect fit!\\" return \\"Can't fit perfectly!\\""},{"question":"def can_split(lst): Determine if a list of integers can be split into two non-empty sublists such that the sum of the elements in each sublist is equal. Parameters: - lst (list): A list of non-negative integers. Returns: - bool: True if the list can be split into two sublists with equal sums, False otherwise. Examples: >>> can_split([1, 5, 11, 5]) True >>> can_split([1, 2, 3, 5]) False >>> can_split([3, 3, 3, 3]) True","solution":"def can_split(lst): Determine if a list of integers can be split into two non-empty sublists such that the sum of the elements in each sublist is equal. Parameters: - lst (list): A list of non-negative integers. Returns: - bool: True if the list can be split into two sublists with equal sums, False otherwise. total_sum = sum(lst) # If total sum is odd, it's impossible to split it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 # Use a set to keep track of sums of subsets sums = {0} for num in lst: new_sums = set() for s in sums: new_sum = s + num if new_sum == target_sum: return True new_sums.add(new_sum) sums.update(new_sums) return False"},{"question":"def can_plant_flowers(garden: List[int], num_flowers: int) -> bool: Determines if you can plant the desired number of flowers in a continuous segment of the garden. :param garden: List[int] - The garden represented by a list of integers (0 for empty spot, 1 for rock) :param num_flowers: int - The number of flowers you want to plant. :return: bool - True if you can plant the specified number of flowers in a continuous segment, otherwise False. >>> can_plant_flowers([1, 0, 0, 0, 1, 0, 0], 3) True >>> can_plant_flowers([1, 0, 0, 0, 1, 0, 0], 4) False >>> can_plant_flowers([0, 0, 0, 0, 0], 5) True >>> can_plant_flowers([1, 1, 1, 1, 0], 1) True >>> can_plant_flowers([0, 0, 0, 1, 0, 0], 2) True >>> can_plant_flowers([0, 1, 0, 1, 0, 1], 1) True >>> can_plant_flowers([], 1) False >>> can_plant_flowers([1, 1, 1], 1) False >>> can_plant_flowers([0, 0, 0, 0], 3) True >>> can_plant_flowers([0, 0, 0, 0], 4) True >>> can_plant_flowers([0, 0, 1, 0, 0], 2) True","solution":"def can_plant_flowers(garden, num_flowers): Determines if it's possible to plant the specified number of flowers in a continuous segment of the garden. :param garden: List[int] - The garden represented by a list of integers (0 for empty spot, 1 for rock) :param num_flowers: int - The number of flowers to plant. :return: bool - True if it's possible to plant the specified number of flowers continuously, otherwise False. max_len = 0 current_len = 0 for spot in garden: if spot == 0: current_len += 1 if current_len >= num_flowers: return True else: max_len = max(max_len, current_len) current_len = 0 # Final check in case the longest segment is at the end of the array max_len = max(max_len, current_len) return max_len >= num_flowers"},{"question":"def find_most_frequent(lst: List[int]) -> int: Returns the integer that appears the most times in the list. If there is a tie, return the smallest integer among them. If the list is empty, return None. >>> find_most_frequent([1, 3, 3, 2, 1, 1, 3]) == 1 >>> find_most_frequent([4, 4, 2, 2, 4, 2]) == 2","solution":"def find_most_frequent(lst): Returns the integer that appears the most times in the list. If there is a tie, return the smallest integer among them. from collections import Counter if not lst: # Handling empty list return None count = Counter(lst) max_frequency = max(count.values()) most_frequent_items = [k for k, v in count.items() if v == max_frequency] return min(most_frequent_items)"},{"question":"def longest_distinct_substring(s: str) -> str: Finds the longest substring with all distinct characters. >>> longest_distinct_substring(\\"abrkaabcdefghijjxxx\\") == \\"abcdefghij\\" >>> longest_distinct_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_distinct_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_distinct_substring(\\" \\") == \\" \\" >>> longest_distinct_substring(\\"dvdf\\") == \\"vdf\\" pass","solution":"def longest_distinct_substring(s: str) -> str: Finds the longest substring with all distinct characters. longest = \\"\\" chars_seen = {} start = 0 for end, char in enumerate(s): if char in chars_seen and chars_seen[char] >= start: start = chars_seen[char] + 1 chars_seen[char] = end if end - start + 1 > len(longest): longest = s[start:end + 1] return longest"},{"question":"def unique_book_ids(n, book_ids): Returns a list of unique book IDs in the order they were added. >>> unique_book_ids(8, [4, 5, 6, 5, 6, 7, 4, 8]) [4, 5, 6, 7, 8] >>> unique_book_ids(5, [1, 2, 3, 3, 2]) [1, 2, 3] >>> unique_book_ids(6, [10, 20, 30, 20, 10, 40]) [10, 20, 30, 40]","solution":"def unique_book_ids(n, book_ids): Returns a list of unique book IDs in the order they were added. seen = set() unique_books = [] for id in book_ids: if id not in seen: seen.add(id) unique_books.append(id) return unique_books"},{"question":"from typing import List, Tuple def calculate_hours(intervals: List[Tuple[str, str]]) -> float: Calculate the total number of hours worked given a list of time intervals. Each time interval is a tuple containing two strings that represent the start and end times in the format \\"HH:MM\\". Examples: >>> calculate_hours([(\\"08:00\\", \\"12:00\\")]) == 4.0 >>> calculate_hours([(\\"08:00\\", \\"12:00\\"), (\\"13:00\\", \\"17:00\\")]) == 8.0 >>> calculate_hours([(\\"09:00\\", \\"11:30\\"), (\\"14:00\\", \\"18:00\\")]) == 6.5 from datetime import datetime def test_calculate_hours_single_interval(): assert calculate_hours([(\\"08:00\\", \\"12:00\\")]) == 4.0 def test_calculate_hours_multiple_intervals(): assert calculate_hours([(\\"08:00\\", \\"12:00\\"), (\\"13:00\\", \\"17:00\\")]) == 8.0 def test_calculate_hours_with_fractional_hours(): assert calculate_hours([(\\"09:00\\", \\"11:30\\"), (\\"14:00\\", \\"18:00\\")]) == 6.5 def test_calculate_hours_varied_intervals(): assert calculate_hours([(\\"07:45\\", \\"09:30\\"), (\\"12:15\\", \\"15:00\\"), (\\"16:30\\", \\"18:00\\")]) == 6.0 def test_calculate_hours_with_zero_hours(): assert calculate_hours([(\\"10:00\\", \\"10:00\\")]) == 0.0 def test_calculate_hours_no_intervals(): assert calculate_hours([]) == 0.0","solution":"from datetime import datetime def calculate_hours(intervals): Returns the total number of hours worked given a list of time intervals. Each interval is a tuple containing two strings representing the start and end times. total_hours = 0.0 for start, end in intervals: start_time = datetime.strptime(start, \\"%H:%M\\") end_time = datetime.strptime(end, \\"%H:%M\\") duration = (end_time - start_time).seconds / 3600 total_hours += duration return total_hours"},{"question":"def select_dragon(k, powers, turn): Selects the optimal dragon based on the current turn and available powers. Parameters: k (int): Number of dragons in each team. powers (list): List of powers of dragons in ascending order of their indices. turn (int): The team turn (1 if our team is picking first, 2 if opponent team is picking first). Returns: int: The index of the selected dragon. pass def test_select_dragon_1(): assert select_dragon(4, [5, 10, 15, 20, 25, 30, 35, 40], 1) == 8 def test_select_dragon_2(): # Mock input for the opponent's move import builtins original_input = builtins.input builtins.input = lambda: \\"1\\" # Opponent selects the weakest dragon first assert select_dragon(4, [3, 6, 9, 12, 15, 18, 21, 24], 2) == 8 builtins.input = original_input def test_select_dragon_opponent_picks_common(): # Mock input for the opponent's move import builtins original_input = builtins.input builtins.input = lambda: \\"4\\" # Opponent selects a random dragon first assert select_dragon(4, [3, 6, 9, 12, 15, 18, 21, 24], 2) == 8 builtins.input = original_input def test_select_dragon_minimum_k(): assert select_dragon(1, [1, 100], 1) == 2 def test_select_dragon_maximum_k(): k = 1000 powers = list(range(1, 2*k+1)) assert select_dragon(k, powers, 1) == 2000","solution":"def select_dragon(k, powers, turn): Selects the optimal dragon based on the current turn and available powers. Parameters: k (int): Number of dragons in each team. powers (list): List of powers of dragons in ascending order of their indices. turn (int): The team turn (1 if our team is picking first, 2 if opponent team is picking first). Returns: int: The index of the selected dragon. available_dragons = list(range(1, 2*k+1)) # Indices of dragons that are still available selected = set() def select_next_highest(): for i in range(2*k-1, -1, -1): if i+1 not in selected: selected.add(i+1) return i+1 if turn == 1: # Our turn first return select_next_highest() else: while len(selected) < 2*k: # Wait for opponent's move opponent_move = int(input().strip()) selected.add(opponent_move) # Our turn if len(selected) < 2*k: my_move = select_next_highest() print(my_move) return my_move"},{"question":"def edit_distance(s1, s2): Computes the minimum number of operations required to convert string s1 into s2. The operations allowed are insert a character, delete a character, or replace a character. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of operations required to transform s1 into s2. Example: >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def edit_distance(s1, s2): Computes the minimum number of operations required to convert string s1 into s2. The operations allowed are insert a character, delete a character, or replace a character. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of operations required to transform s1 into s2. m = len(s1) n = len(s2) # Create a table to store solutions of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): # If first string is empty, the only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, the only option is to delete all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace # Return the result return dp[m][n]"},{"question":"def number_of_circling_words(n: int, target: str, words: List[str]) -> int: Determine the number of words in the list that circle the target word. >>> number_of_circling_words(5, \\"abc\\", [\\"bca\\", \\"cab\\", \\"acb\\", \\"cba\\", \\"bac\\"]) 2 >>> number_of_circling_words(3, \\"abcd\\", [\\"dabc\\", \\"bcda\\", \\"abdc\\"]) 2 import unittest class TestCirclingWords(unittest.TestCase): def test_sample_case_1(self): n = 5 target = \\"abc\\" words = [\\"bca\\", \\"cab\\", \\"acb\\", \\"cba\\", \\"bac\\"] self.assertEqual(number_of_circling_words(n, target, words), 2) def test_sample_case_2(self): n = 3 target = \\"abcd\\" words = [\\"dabc\\", \\"bcda\\", \\"abdc\\"] self.assertEqual(number_of_circling_words(n, target, words), 2) def test_no_circling_words(self): n = 3 target = \\"abc\\" words = [\\"def\\", \\"ghi\\", \\"jkl\\"] self.assertEqual(number_of_circling_words(n, target, words), 0) def test_all_circling_words(self): n = 3 target = \\"abc\\" words = [\\"bca\\", \\"cab\\", \\"abc\\"] self.assertEqual(number_of_circling_words(n, target, words), 3) def test_different_lengths(self): n = 3 target = \\"ab\\" words = [\\"ba\\", \\"a\\", \\"b\\"] self.assertEqual(number_of_circling_words(n, target, words), 1) def test_empty_list(self): n = 0 target = \\"abc\\" words = [] self.assertEqual(number_of_circling_words(n, target, words), 0) def test_longer_words(self): n = 4 target = \\"abcdefghij\\" words = [\\"jabcdefghi\\", \\"ijabcdefgh\\", \\"hijabcdefg\\", \\"kabcdefghi\\"] self.assertEqual(number_of_circling_words(n, target, words), 3) if __name__ == \\"__main__\\": unittest.main()","solution":"def number_of_circling_words(n, target, words): def circles_each_other(word1, word2): return len(word1) == len(word2) and word2 in (word1 * 2) count = 0 for word in words: if circles_each_other(target, word): count += 1 return count"},{"question":"def categorize_wall_segments(s): Returns the lengths of consecutive segments of wall from the input string. Parameters: s (str): A string consisting of characters 'a', 'm', and 'o'. Returns: list: A list of integers representing the lengths of each consecutive segment. >>> categorize_wall_segments(\\"aaammmmo\\") [3, 4, 1] >>> categorize_wall_segments(\\"ooaammm\\") [2, 2, 3]","solution":"def categorize_wall_segments(s): Returns the lengths of consecutive segments of wall from the input string. Parameters: s (str): A string consisting of characters 'a', 'm', and 'o'. Returns: list: A list of integers representing the lengths of each consecutive segment. if not s: return [] segments_lengths = [] current_char = s[0] current_length = 1 for char in s[1:]: if char == current_char: current_length += 1 else: segments_lengths.append(current_length) current_char = char current_length = 1 segments_lengths.append(current_length) return segments_lengths"},{"question":"import math from typing import List def findRoots(a: int, b: int, c: int) -> List[float]: Given the coefficients of a quadratic equation \`a\`, \`b\`, and \`c\` (where \`a\` is the coefficient of \`x^2\`, \`b\` is the coefficient of \`x\`, and \`c\` is the constant term), return the roots of the quadratic equation in a list. If the roots are imaginary, return an empty list. >>> findRoots(1, -3, 2) [2.0, 1.0] >>> findRoots(1, 0, -4) [2.0, -2.0] >>> findRoots(1, 2, 5) []","solution":"import math def findRoots(a, b, c): This function takes the coefficients of a quadratic equation (a, b, c) and returns the roots. If the roots are imaginary, an empty list is returned. discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return [root1, root2] elif discriminant == 0: root = -b / (2*a) return [root] else: return []"},{"question":"def simulate_employee_communication(input_data: str) -> str: Simulate the interaction between employees over a period of time and output the sequence of message IDs as they are received by the employees. >>> simulate_employee_communication(\\"3n101 1 2 10n102 2 3 15n103 1 3 20n2n201 1 3 5n202 3 1 10n0n\\") \\"101 102 103n201 202\\" >>> simulate_employee_communication(\\"1n301 4 5 7n0n\\") \\"301\\" def test_process_messages(): input_data = \\"3n101 1 2 10n102 2 3 15n103 1 3 20n2n201 1 3 5n202 3 1 10n0n\\" expected_output = \\"101 102 103n201 202\\" assert simulate_employee_communication(input_data) == expected_output def test_single_message(): input_data = \\"1n301 4 5 7n0n\\" expected_output = \\"301\\" assert simulate_employee_communication(input_data) == expected_output def test_multiple_datasets(): input_data = \\"2n401 5 6 10n402 6 7 15n1n501 7 8 20n0n\\" expected_output = \\"401 402n501\\" assert simulate_employee_communication(input_data) == expected_output def test_no_conflict(): input_data = \\"3n601 8 9 1n602 10 11 2n603 12 13 3n0n\\" expected_output = \\"601 602 603\\" assert simulate_employee_communication(input_data) == expected_output def test_with_conflict(): input_data = \\"3n701 14 15 5n702 16 15 10n703 14 15 15n0n\\" expected_output = \\"701 702 703\\" assert simulate_employee_communication(input_data) == expected_output","solution":"def process_messages(datasets): result = [] for dataset in datasets: m, messages = dataset if m == 0: break # Sort messages by time messages.sort(key=lambda x: x[3]) busy = {} # To track receiver's availability time received_messages = [] for message in messages: msg_id, sender, receiver, timestamp = message if receiver not in busy or busy[receiver] <= timestamp: # Message can be immediately received received_messages.append(msg_id) busy[receiver] = timestamp result.append(received_messages) return result def simulate_employee_communication(input_data): datasets = [] lines = input_data.strip().split('n') index = 0 while index < len(lines): m = int(lines[index]) index += 1 if m == 0: break messages = [] for _ in range(m): parts = lines[index].split() messages.append((int(parts[0]), int(parts[1]), int(parts[2]), int(parts[3]))) index += 1 datasets.append((m, messages)) result = process_messages(datasets) output = \\"n\\".join(\\" \\".join(map(str, res)) for res in result) return output"},{"question":"def find_missing_numbers(nums: List[int]) -> List[int]: Returns a list of missing numbers in the range 1 to n. Parameters: nums (list of int): A list of integers ranging from 1 to n, with some numbers potentially missing. Returns: list of int: A list of the missing numbers in ascending order. >>> find_missing_numbers([1, 2, 3, 4, 5]) == [] >>> find_missing_numbers([2, 3, 4, 5]) == [1] >>> find_missing_numbers([1, 2, 3, 5]) == [4] >>> find_missing_numbers([1, 2, 6, 5]) == [3, 4] >>> find_missing_numbers([1, 3, 4, 6]) == [2, 5] >>> find_missing_numbers([1, 2, 3, 7]) == [4, 5, 6] >>> find_missing_numbers([2]) == [1] >>> find_missing_numbers([3]) == [1, 2] >>> find_missing_numbers([1]) == []","solution":"def find_missing_numbers(nums): Returns a list of missing numbers in the range 1 to n. Parameters: nums (list of int): A list of integers ranging from 1 to n, with some numbers potentially missing. Returns: list of int: A list of the missing numbers in ascending order. n = max(nums) full_range = list(range(1, n+1)) missing_numbers = [] for number in full_range: if number not in nums: missing_numbers.append(number) return missing_numbers"},{"question":"def min_operations_to_equalize(grid): You are given a grid with N rows and M columns. Initially, each cell contains an integer value between 0 and 9. You can perform the following operation on the grid: 1. Choose a subrectangle (i.e., a rectangular part of the grid) and increase each element within this subrectangle by 1. Your goal is to make all elements of the grid equal in the minimum number of operations possible. Write a function that takes the initial grid and returns the minimum number of operations required to achieve this goal. >>> min_operations_to_equalize([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) 2 >>> min_operations_to_equalize([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_operations_to_equalize([[1, 2, 3]]) 2 >>> min_operations_to_equalize([[1], [2], [3]]) 2 >>> min_operations_to_equalize([[7, 8, 9], [8, 9, 7], [9, 7, 8]]) 2","solution":"def min_operations_to_equalize(grid): # Find the maximum value in the grid max_value = max(max(row) for row in grid) # The minimum number of operations is the difference between max_value # and the minimum value in the grid min_value = min(min(row) for row in grid) return max_value - min_value"},{"question":"def filter_string(string: str, chars_to_remove: set) -> str: Create a function that takes a string and a set of characters. Your task is to remove characters from the string that are present in the set of given characters. >>> filter_string(\\"hello world\\", {'l', 'o'}) \\"he wrd\\" >>> filter_string(\\"CodeWars\\", {'e', 'o', 's'}) \\"CdWar\\" >>> filter_string(\\"Complex STRING Testing\\", {'C', 'm', 'S', 'T'}) \\"oplex RING esting\\"","solution":"def filter_string(string, chars_to_remove): Removes specified characters from the string. Parameters: string (str): The input string from which characters are to be removed. chars_to_remove (set): A set of characters to be removed from the input string. Returns: str: The string after removing the specified characters. return \\"\\".join([char for char in string if char not in chars_to_remove])"},{"question":"def max_subarray_sum(arr, l, r): Returns the maximum sum of any contiguous subarray within the range [l, r] using Kadane's algorithm. >>> max_subarray_sum([1, -2, 3, 4, -1], 1, 3) 3 >>> max_subarray_sum([1, -2, 3, 4, -1], 2, 5) 7 def process_queries(arr, queries): Processes each query to find the maximum sum of any contiguous subarray within the given range. >>> process_queries([1, -2, 3, 4, -1], [(1, 3), (2, 5)]) [3, 7] def process_test_cases(test_cases): Processes each test case to obtain the maximum sum for each query across multiple test cases. >>> test_cases = [ (5, [1, -2, 3, 4, -1], 2, [(1, 3), (2, 5)]), (5, [1, 2, 3, 4, 5], 1, [(1, 5)]) ] >>> process_test_cases(test_cases) [3, 7, 15]","solution":"def max_subarray_sum(arr, l, r): Returns the maximum sum of any contiguous subarray within the range [l, r] using Kadane's algorithm. current_sum = 0 max_sum = float('-inf') for i in range(l-1, r): current_sum = max(arr[i], current_sum + arr[i]) max_sum = max(max_sum, current_sum) return max_sum def process_queries(arr, queries): Processes each query to find the maximum sum of any contiguous subarray within the given range. results = [] for l, r in queries: results.append(max_subarray_sum(arr, l, r)) return results def process_test_cases(test_cases): results = [] for test_case in test_cases: n, arr, q, queries = test_case results.extend(process_queries(arr, queries)) return results"},{"question":"def sum_of_odd_indices(num_list): Returns the sum of elements located at odd indices in the input list. :param num_list: List of integers :return: Sum of elements at odd indices >>> sum_of_odd_indices([1, 2, 3, 4, 5, 6]) 12 >>> sum_of_odd_indices([10, 20, 30, 40, 50]) 60 >>> sum_of_odd_indices([]) 0 >>> sum_of_odd_indices([7]) 0 >>> sum_of_odd_indices([1, 2]) 2 >>> sum_of_odd_indices([-1, -2, -3, -4, -5, -6]) -12 >>> sum_of_odd_indices([1, -2, 3, 4, -5, 6]) 8","solution":"def sum_of_odd_indices(num_list): Returns the sum of elements located at odd indices in the input list. :param num_list: List of integers :return: Sum of elements at odd indices return sum(num_list[i] for i in range(1, len(num_list), 2))"},{"question":"def custom_list_manager(commands): Function to process a series of commands to manage a list of unique, sorted numbers. Args: - commands (list of str): the list of commands to process Returns: - list of str: the results of the Check and Print commands Commands: - \\"Insert x\\": Insert the number x into the list if it is not present. - \\"Delete x\\": Delete the number x from the list if it is present. - \\"Check x\\": Print \\"YES\\" if the number x is in the list, otherwise print \\"NO\\". - \\"Print\\": Print all numbers in the list in a sorted order. Example usage: >>> commands = [ ... \\"Insert 5\\", ... \\"Insert 10\\", ... \\"Check 5\\", ... \\"Insert 15\\", ... \\"Print\\", ... \\"Delete 10\\", ... \\"Print\\", ... \\"Check 10\\", ... \\"Delete 5\\", ... \\"Print\\" ... ] >>> custom_list_manager(commands) ['YES', '5 10 15', '5 15', 'NO', '15']","solution":"def custom_list_manager(commands): Function to process a series of commands to manage a list of unique, sorted numbers. Args: - commands (list of str): the list of commands to process Returns: - list of str: the results of the Check and Print commands numbers = set() result = [] for command in commands: parts = command.split() if parts[0] == 'Insert': numbers.add(int(parts[1])) elif parts[0] == 'Delete': numbers.discard(int(parts[1])) elif parts[0] == 'Check': result.append('YES' if int(parts[1]) in numbers else 'NO') elif parts[0] == 'Print': sorted_numbers = sorted(numbers) result.append(' '.join(map(str, sorted_numbers))) return result"},{"question":"def check_shipment(items): Given a list of items with their respective quantities, previous inventory, and recorded inventory level, determine whether each item is 'CORRECT' or 'ERROR'. Parameters: items (list): A list of lists, where each inner list contains the item name, quantity Q, previous inventory I, and recorded inventory L in that order. Returns: list: A list of strings, either 'CORRECT' or 'ERROR' for each item. from solution import check_shipment def test_correct_cases(): items = [ [\\"Apples\\", 50, 100, 150], [\\"Oranges\\", 15, 80, 95] ] assert check_shipment(items) == [\\"CORRECT\\", \\"CORRECT\\"] def test_error_cases(): items = [ [\\"Bananas\\", 30, 120, 140], [\\"Grapes\\", 25, 50, 80] ] assert check_shipment(items) == [\\"ERROR\\", \\"ERROR\\"] def test_mixed_cases(): items = [ [\\"Apples\\", 50, 100, 150], [\\"Bananas\\", 30, 120, 140], [\\"Oranges\\", 15, 80, 95] ] assert check_shipment(items) == [\\"CORRECT\\", \\"ERROR\\", \\"CORRECT\\"] def test_edge_case_min_values(): items = [ [\\"Item\\", 1, 1, 2] ] assert check_shipment(items) == [\\"CORRECT\\"] def test_edge_case_large_values(): items = [ [\\"Item\\", 99999, 1, 100000] ] assert check_shipment(items) == [\\"CORRECT\\"]","solution":"def check_shipment(items): Given a list of items with their respective quantities, previous inventory, and recorded inventory level, determine whether each item is 'CORRECT' or 'ERROR'. Parameters: items (list): A list of lists, where each inner list contains the item name, quantity Q, previous inventory I, and recorded inventory L in that order. Returns: list: A list of strings, either 'CORRECT' or 'ERROR' for each item. results = [] for item in items: name, Q, I, L = item if int(Q) + int(I) == int(L): results.append(\\"CORRECT\\") else: results.append(\\"ERROR\\") return results"},{"question":"def reorganizeString(s: str) -> str: Rearranges the characters of the string such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> reorganizeString(\\"aab\\") in [\\"aba\\"] >>> reorganizeString(\\"aaab\\") == \\"\\" >>> reorganizeString(\\"a\\") == \\"a\\" >>> reorganizeString(\\"ab\\") in [\\"ab\\", \\"ba\\"] >>> reorganizeString(\\"cccc\\") == \\"\\" >>> reorganizeString(\\"aabc\\") in [\\"abac\\", \\"acab\\", \\"caba\\", \\"baca\\"] >>> result = reorganizeString(\\"aaabbc\\") >>> result in [\\"ababac\\", \\"ababca\\", \\"abacba\\", \\"babaca\\", \\"bacbab\\", \\"balcab\\"] >>> input_str = \\"aaabbbccc\\" * 10 >>> result = reorganizeString(input_str) >>> result != \\"\\" >>> all(result[i] != result[i+1] for i in range(len(result) - 1))","solution":"import heapq from collections import Counter def reorganizeString(s): Rearranges the characters of the string such that no two adjacent characters are the same. If it is not possible, returns an empty string. # Frequency counter for each character count = Counter(s) # Max-heap based on character frequency max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Add the previous character back if it has leftover count if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Append current character to result and decrement its count result.append(char) freq += 1 # Decrement frequency (because it's negative in heap) # Update previous character and its frequency prev_freq, prev_char = freq, char result_str = ''.join(result) # If we cannot reorganize properly, the result_str length will not be equal to original string length if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"def most_frequent_letter(n: int, s: str, k: int) -> str: Determine the most frequent letter that can be obtained by replacing at most k characters in the string with any other lowercase English letter. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. >>> most_frequent_letter(8, 'abbcccaa', 2) 'c' >>> most_frequent_letter(5, 'abcde', 1) 'a'","solution":"def most_frequent_letter(n, s, k): from collections import Counter def max_freq_with_replacements(c): left = right = max_freq = 0 count = Counter() while right < n: count[s[right]] += 1 while (right - left + 1) - count[c] > k: count[s[left]] -= 1 left += 1 max_freq = max(max_freq, right - left + 1) right += 1 return max_freq max_letter = '' max_count = 0 for c in 'abcdefghijklmnopqrstuvwxyz': freq = max_freq_with_replacements(c) if freq > max_count or (freq == max_count and c < max_letter): max_count = freq max_letter = c return max_letter"},{"question":"def is_palindrome_in_both_bases(n: int) -> str: Determine whether a positive integer is a palindrome in both decimal (base 10) representation and binary (base 2) representation. >>> is_palindrome_in_both_bases(585) 'Yes' >>> is_palindrome_in_both_bases(123) 'No'","solution":"def is_palindrome(s): return s == s[::-1] def is_palindrome_in_both_bases(n): decimal_str = str(n) binary_str = bin(n)[2:] if is_palindrome(decimal_str) and is_palindrome(binary_str): return \\"Yes\\" else: return \\"No\\""},{"question":"def can_obtain_by_rotating(S: str, T: str) -> str: Given two strings S and T, determine whether T can be obtained by rotating S. A string S can be rotated by moving the first character of S to the end of S any number of times. Parameters: S (str): The original string to be rotated. T (str): The target string to check if it can be obtained by rotating S. Returns: str: \\"Yes\\" if T can be obtained by rotating S, otherwise \\"No\\". >>> can_obtain_by_rotating(\\"hello\\", \\"lohel\\") \\"Yes\\" >>> can_obtain_by_rotating(\\"abcd\\", \\"dcba\\") \\"No\\" >>> can_obtain_by_rotating(\\"abc\\", \\"abc\\") \\"Yes\\"","solution":"def can_obtain_by_rotating(S, T): Returns \\"Yes\\" if T can be obtained by rotating S, otherwise returns \\"No\\". if len(S) != len(T): return \\"No\\" doubled_S = S + S if T in doubled_S: return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List def min_steps(maze: List[str], M: int, N: int) -> int: Jerry is participating in a maze competition with M rows and N columns. The maze is represented by a matrix with '.' indicating a walkable cell and '#' indicating a wall. Jerry needs to find the shortest path from the top-left corner (1, 1) to the bottom-right corner (M, N). He can only move up, down, left, or right to a walkable cell. Write a program to determine the minimum number of steps required for Jerry to reach the destination. If there is no possible path, return -1. Args: maze (List[str]): The matrix representing the maze. M (int): Number of rows in the maze. N (int): Number of columns in the maze. Returns: int: Minimum number of steps required to reach the destination, or -1 if no path exists. Example: >>> min_steps(['...#', '.#.#', '.#..', '#...'], 4, 4) 6 >>> min_steps(['.#.', '#', '.#.'], 3, 3) -1 pass def solve(test_cases: List[tuple]) -> List[int]: Solves multiple test cases of the maze problem. Args: test_cases (List[tuple]): List of tuples, each containing the dimensions of the maze (M and N) and the maze itself. Returns: List[int]: List of results, one per test case. pass def main(input_list: List[str]) -> List[int]: Processes input and manages the execution of test cases. Args: input_list (List[str]): List of strings representing the input. Returns: List[int]: List of results for each test case. pass","solution":"from collections import deque def min_steps(maze, M, N): if maze[0][0] == '#' or maze[M-1][N-1] == '#': return -1 directions = [(1,0), (-1,0), (0,1), (0,-1)] visited = [[False]*N for _ in range(M)] queue = deque([(0, 0, 0)]) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == M-1 and y == N-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny] and maze[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 def solve(test_cases): results = [] for test in test_cases: M, N, maze = test result = min_steps(maze, M, N) results.append(result) return results def main(input_list): T = int(input_list[0]) index = 1 test_cases = [] for _ in range(T): M, N = map(int, input_list[index].split()) maze = [] for i in range(index + 1, index + 1 + M): maze.append(input_list[i]) test_cases.append((M, N, maze)) index += M + 1 results = solve(test_cases) return results"},{"question":"from typing import List def min_moves_to_connect(grid: List[List[int]]) -> int: Find the minimum number of moves required to connect the top-left corner to the bottom-right corner in an n x n grid, or return -1 if not possible. :param grid: List[List[int]], the n x n grid with 0s (empty) and 1s (obstacles) :return: int, the minimum number of moves or -1 if no valid path exists pass # Unit tests def test_min_moves_to_connect_path_exists(): grid = [ [0, 1, 0], [0, 0, 1], [1, 0, 0] ] assert min_moves_to_connect(grid) == 4 def test_min_moves_to_connect_no_path(): grid = [ [0, 1, 1], [1, 1, 1], [1, 0, 0] ] assert min_moves_to_connect(grid) == -1 def test_min_moves_to_connect_single_cell(): grid = [ [0] ] assert min_moves_to_connect(grid) == 0 def test_min_moves_to_connect_starting_with_obstacle(): grid = [ [1, 0], [0, 0] ] assert min_moves_to_connect(grid) == -1 def test_min_moves_to_connect_ending_with_obstacle(): grid = [ [0, 0], [0, 1] ] assert min_moves_to_connect(grid) == -1 def test_min_moves_to_connect_with_multiple_paths(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert min_moves_to_connect(grid) == 4","solution":"from collections import deque def min_moves_to_connect(grid): Find the minimum number of moves required to connect the top-left corner to the bottom-right corner in an n x n grid, or return -1 if not possible. :param grid: List[List[int]], the n x n grid with 0s (empty) and 1s (obstacles) :return: int, the minimum number of moves or -1 if no valid path exists n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() if x == n - 1 and y == n - 1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, moves + 1)) visited.add((nx, ny)) return -1"},{"question":"def find_min_width_sum(n: int, widths: List[int]) -> int: Finds the minimum width sum enclosed by two bookends. :param n: number of books on the shelf :param widths: list containing widths of each book :return: minimum width sum between two bookends (including bookend positions) from typing import List def test_single_book(): assert find_min_width_sum(1, [12]) == 12 def test_multiple_books(): assert find_min_width_sum(3, [10, 7, 3]) == 3 def test_example_case(): assert find_min_width_sum(5, [3, 1, 4, 2, 2]) == 1 # Fixing the expected value to be the smallest width def test_large_numbers(): assert find_min_width_sum(5, [1000000000, 999999999, 500000000, 300000000, 200000000]) == 200000000 def test_repeated_widths(): assert find_min_width_sum(4, [5, 5, 5, 5]) == 5","solution":"def find_min_width_sum(n, widths): Finds the minimum width sum enclosed by two bookends. :param n: number of books on the shelf :param widths: list containing widths of each book :return: minimum width sum between two bookends (including bookend positions) if n == 1: return widths[0] min_width = min(widths) return min_width"},{"question":"from typing import List def max_sum_subgrid(grid: List[List[int]]) -> int: Returns the maximum sum of any sub-grid within the given grid. >>> max_sum_subgrid([ ... [ 1, 2, -1], ... [-3, 4, 5], ... [ 2, -2, 3] ... ]) 11 >>> max_sum_subgrid([ ... [-1, -2], ... [-3, -4] ... ]) -1 >>> max_sum_subgrid([ ... [ 1, 2, 3], ... [-1, -2, -3], ... [ 4, 5, 6] ... ]) 15 >>> max_sum_subgrid([ ... [ 0, 0, 0], ... [ 0, 0, 0], ... [ 0, 0, 0] ... ]) 0 >>> max_sum_subgrid([ ... [-1, 2, 3], ... [ 4, -5, 6], ... [ 7, 8, -9] ... ]) 15","solution":"def max_sum_subgrid(grid): Returns the maximum sum of any sub-grid within the given grid. n = len(grid) m = len(grid[0]) if n > 0 else 0 max_sum = -float('inf') # Calculate prefix sums for each row prefix_sum = [[0] * (m + 1) for _ in range(n)] for i in range(n): for j in range(1, m + 1): prefix_sum[i][j] = prefix_sum[i][j - 1] + grid[i][j - 1] # Iterate over all possible left and right column boundaries for left in range(m): for right in range(left, m): # Use Kadane's algorithm to find the max subarray sum for this column range kadane_sum = 0 kadane_max = -float('inf') for row in range(n): row_sum = prefix_sum[row][right + 1] - prefix_sum[row][left] kadane_sum += row_sum if kadane_sum > kadane_max: kadane_max = kadane_sum if kadane_sum < 0: kadane_sum = 0 max_sum = max(max_sum, kadane_max) return max_sum"},{"question":"def min_powers_of_2(N: int) -> int: Returns the minimum number of elements required to form N using powers of 2. >>> min_powers_of_2(7) 3 >>> min_powers_of_2(10) 2 >>> min_powers_of_2(15) 4 >>> min_powers_of_2(1) 1 >>> min_powers_of_2(2) 1 >>> min_powers_of_2(3) 2 pass def solve(T: int, nums: List[int]) -> List[int]: Returns the list of minimum number of elements required to form each N in nums using powers of 2. >>> solve(3, [7, 10, 15]) [3, 2, 4] >>> solve(2, [1, 2]) [1, 1] >>> solve(3, [3, 5, 9]) [2, 2, 2] pass","solution":"def min_powers_of_2(N): Returns the minimum number of elements required to form N using powers of 2. count = 0 while N > 0: N -= (1 << (N.bit_length() - 1)) count += 1 return count def solve(T, nums): results = [] for N in nums: results.append(min_powers_of_2(N)) return results"},{"question":"def uniqueElements(list1, list2): Returns a list of elements that are unique to each list. >>> uniqueElements([1, 2, 3, 4], [3, 4, 5, 6]) -> [1, 2, 5, 6] >>> uniqueElements([7, 8, 9], [10, 11, 12]) -> [7, 8, 9, 10, 11, 12] >>> uniqueElements([5, 5, 5], [5, 6, 7]) -> [6, 7] >>> uniqueElements([1, 2], [3, 4]) -> [ 1, 2, 3, 4] >>> uniqueElements([1, 2, 5, 5, 6], [1, 3, 3, 7, 6]) -> [2, 3, 5, 7]","solution":"def uniqueElements(list1, list2): Returns a list of elements that are unique to each list. set1 = set(list1) set2 = set(list2) unique_to_list1 = set1 - set2 unique_to_list2 = set2 - set1 return list(unique_to_list1 | unique_to_list2)"},{"question":"def smallestElement(matrix, k): Returns the smallest element in the matrix which is larger than or equal to k. If no such element exists, returns -1. :param matrix: List[List[int]], sorted matrix :param k: int, the threshold value :return: int # Unit Tests def test_example_0(): matrix = [ [1, 3, 5], [2, 4, 7], [3, 6, 9] ] k = 6 assert smallestElement(matrix, k) == 6 def test_example_1(): matrix = [ [1, 3, 5], [2, 4, 7], [3, 6, 9] ] k = 8 assert smallestElement(matrix, k) == 9 def test_example_2(): matrix = [ [1, 3, 5], [2, 4, 7], [3, 6, 9] ] k = 10 assert smallestElement(matrix, k) == -1 def test_minimum_value_larger_than_k(): matrix = [ [1, 2, 5], [3, 4, 6], [7, 8, 9] ] k = 5 assert smallestElement(matrix, k) == 5 def test_k_less_than_all_elements(): matrix = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] k = 15 assert smallestElement(matrix, k) == 20 def test_k_greater_than_max_element(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 10 assert smallestElement(matrix, k) == -1 def test_single_row_matrix(): matrix = [[1, 2, 3, 4, 5]] k = 3 assert smallestElement(matrix, k) == 3 def test_single_column_matrix(): matrix = [[1], [2], [3], [4], [5]] k = 4 assert smallestElement(matrix, k) == 4 def test_all_elements_smaller_than_k(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 100 assert smallestElement(matrix, k) == -1","solution":"def smallestElement(matrix, k): Returns the smallest element in the matrix which is larger than or equal to k. If no such element exists, returns -1. :param matrix: List[List[int]], sorted matrix :param k: int, the threshold value :return: int m = len(matrix) n = len(matrix[0]) smallest = float('inf') found = False for row in matrix: for item in row: if item >= k: if item < smallest: smallest = item found = True if not found: return -1 return smallest"},{"question":"def max_non_overlapping_workshops(n, m, workshops): Returns the maximum number of non-overlapping workshops that can be conducted using the available rooms. Args: n: int - number of workshops. m: int - number of available rooms. workshops: List of tuples [(s1, e1), (s2, e2), ..., (sn, en)] where si and ei are the start and end times of the workshops. Returns: int - maximum number of non-overlapping workshops. pass def test_sample_input_1(): n = 5 m = 2 workshops = [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)] assert max_non_overlapping_workshops(n, m, workshops) == 4 def test_sample_input_2(): n = 6 m = 3 workshops = [(1, 4), (4, 5), (3, 5), (6, 7), (5, 9), (2, 6)] assert max_non_overlapping_workshops(n, m, workshops) == 5 def test_no_overlap(): n = 3 m = 1 workshops = [(1, 2), (3, 4), (5, 6)] assert max_non_overlapping_workshops(n, m, workshops) == 3 def test_all_overlap(): n = 3 m = 1 workshops = [(1, 4), (2, 5), (3, 6)] assert max_non_overlapping_workshops(n, m, workshops) == 1 def test_multiple_rooms_can_accommodate_all(): n = 4 m = 2 workshops = [(1, 2), (2, 3), (3, 4), (4, 5)] assert max_non_overlapping_workshops(n, m, workshops) == 4","solution":"def max_non_overlapping_workshops(n, m, workshops): Returns the maximum number of non-overlapping workshops that can be conducted using the available rooms. Args: n: int - number of workshops. m: int - number of available rooms. workshops: List of tuples [(s1, e1), (s2, e2), ..., (sn, en)] where si and ei are the start and end times of the workshops. Returns: int - maximum number of non-overlapping workshops. # Sort the workshops based on their end time workshops.sort(key=lambda x: x[1]) # Allocate an array to count the number of workshops per room rooms = [0] * m total_workshops = 0 for start, end in workshops: # Find the earliest available room that can accommodate the current workshop for i in range(m): if rooms[i] <= start: rooms[i] = end total_workshops += 1 break # Sort the rooms based on their next available time rooms.sort() return total_workshops"},{"question":"def find_unique_elements(list1: List[int], list2: List[int]) -> List[int]: Returns the elements that are present in list1 but not in list2, sorted in ascending order. >>> find_unique_elements([1, 2, 3, 4, 5], [2, 4, 6]) [1, 3, 5] >>> find_unique_elements([1, 2, 3], [1, 2, 3]) [] >>> find_unique_elements([1, 2, 3], []) [1, 2, 3] >>> find_unique_elements([], [1, 2, 3]) [] >>> find_unique_elements([-5, -4, -3, -2, -1], [1, 2, 3]) [-5, -4, -3, -2, -1] >>> find_unique_elements([-1, 0, 1, 2], [-2, 0, 2]) [-1, 1] >>> find_unique_elements(list(range(100)), list(range(50, 150))) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] >>> find_unique_elements([1, 1, 2, 3, 3, 4], [2, 4]) [1, 1, 3, 3]","solution":"def find_unique_elements(list1, list2): Returns the elements that are present in list1 but not in list2, sorted in ascending order. set2 = set(list2) # Convert list2 to a set for faster look-up unique_elements = [elem for elem in list1 if elem not in set2] return sorted(unique_elements)"},{"question":"from typing import List, Tuple class UnionFind: def __init__(self, size: int): self.parent = list(range(size)) self.rank = [1] * size def find(self, u: int) -> int: if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u: int, v: int): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def teleportation_system(operations: List[Tuple[int, int, int]]) -> List[str]: Manage the placement of gates and answer queries about reachability between points. Args: operations: A list of tuples where each tuple represents an operation. The first element of the tuple is the type of operation (1 for adding a gate, 2 for querying reachability), and the next two elements are the points involved in the operation. Returns: A list of strings where each string is the result of a type 2 operation (\\"YES\\" or \\"NO\\"). >>> teleportation_system([(1, 1, 2), (1, 2, 3), (2, 1, 3), (1, 4, 5), (2, 1, 5), (2, 4, 5)]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass def test_sample(): operations = [ (1, 1, 2), (1, 2, 3), (2, 1, 3), (1, 4, 5), (2, 1, 5), (2, 4, 5) ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert teleportation_system(operations) == expected_output def test_no_connection(): operations = [ (1, 1, 2), (1, 2, 3), (2, 1, 4), (2, 3, 5), (2, 4, 6) ] expected_output = [\\"NO\\", \\"NO\\", \\"NO\\"] assert teleportation_system(operations) == expected_output def test_direct_connection(): operations = [ (1, 1, 2), (2, 1, 2), (1, 3, 4), (2, 3, 4), (1, 5, 6), (2, 5, 6) ] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\"] assert teleportation_system(operations) == expected_output def test_large_input(): operations = [ (1, i, i + 1) for i in range(1, 100000) ] + [ (2, 1, 100000) ] expected_output = [\\"YES\\"] assert teleportation_system(operations) == expected_output","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def teleportation_system(operations): uf = UnionFind(105001) results = [] for operation in operations: op, a, b = operation if op == 1: uf.union(a, b) elif op == 2: if uf.find(a) == uf.find(b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_absolute_differences(n: int, k: int, sequence: List[int]) -> List[int]: Given a sequence of n integers and a sliding window of size k, returns a list of the maximum absolute differences within each sliding window. >>> max_absolute_differences(8, 3, [1, 3, 6, 2, 8, 7, 4, 5]) [5, 4, 6, 6, 4, 3] >>> max_absolute_differences(5, 2, [-1, 2, -3, 4, -5]) [3, 5, 7, 9] >>> max_absolute_differences(5, 5, [4, 4, 4, 4, 4]) [0]","solution":"def max_absolute_differences(n, k, sequence): Given a sequence of n integers and a sliding window of size k, this function returns a list of the maximum absolute differences within each sliding window. result = [] for i in range(n - k + 1): window = sequence[i:i + k] max_diff = max(window) - min(window) result.append(max_diff) return result"},{"question":"def generate_star_pattern(N: int) -> str: Generates an inverted right triangle pattern of stars with base and height of N. Parameters: N (int): The size of the triangle, where 2  N  100. Returns: str: A string representation of the inverted right triangle pattern. Examples: >>> generate_star_pattern(3) '***n**n*' >>> generate_star_pattern(4) '****n***n**n*' >>> generate_star_pattern(2) '**n*'","solution":"def generate_star_pattern(N): Generates an inverted right triangle pattern of stars with base and height of N. Parameters: N (int): The size of the triangle, where 2  N  100. pattern = \\"\\" for i in range(N): pattern += '*' * (N - i) + 'n' return pattern.strip()"},{"question":"def process_queries(n, arr, q, queries): Processes a series of queries on an integer array. Parameters: n (int): The size of the array. arr (List[int]): The array of integers. q (int): The number of queries. queries (List[Tuple[int, int, int]]): The list of queries. Each query is a tuple, where the first element is the type of the query (1 for update, 2 for sum), and the rest are the query parameters. Returns: List[int]: The results of all sum queries. >>> process_queries(5, [1, 2, 3, 4, 5], 4, [(2, 1, 3), (1, 2, 5), (2, 1, 3), (2, 3, 5)]) [6, 11, 12] >>> process_queries(1, [5], 2, [(2, 1, 1), (1, 1, -3), (2, 1, 1)]) [5, 2] >>> process_queries(3, [0, 0, 0], 3, [(1, 1, 4), (1, 2, 5), (1, 3, 6)]) [] >>> process_queries(4, [1, 2, 3, 4], 3, [(2, 1, 2), (2, 2, 3), (2, 3, 4)]) [3, 5, 7] >>> process_queries(3, [1, 2, 3], 4, [(1, 1, 4), (2, 1, 3), (1, 3, -2), (2, 1, 3)]) [10, 8] >>> process_queries(5, [100] * 5, 2, [(1, 3, -100), (2, 1, 5)]) [400]","solution":"def process_queries(n, arr, q, queries): results = [] for query in queries: if query[0] == 1: # Update query i = query[1] - 1 # Converting 1-based index to 0-based index x = query[2] arr[i] += x elif query[0] == 2: # Sum query l = query[1] - 1 # Converting 1-based index to 0-based index r = query[2] - 1 # Converting 1-based index to 0-based index subarray_sum = sum(arr[l:r+1]) results.append(subarray_sum) return results"},{"question":"from typing import List, Tuple def fetch_order(n: int, times: List[Tuple[int, int]]) -> List[str]: Determine the order in which people fetch water based on their fetching and arrival times. >>> fetch_order(5, [(60, 5), (60, 15), (120, 10), (60, 25), (120, 5)]) [\\"60: 5 15 25\\", \\"120: 5 10\\"] >>> fetch_order(3, [(90, 2), (90, 5), (30, 1)]) [\\"30: 1\\", \\"90: 2 5\\"] >>> fetch_order(4, [(300, 30), (300, 20), (300, 40), (200, 10)]) [\\"200: 10\\", \\"300: 20 30 40\\"] >>> fetch_order(1, [(100, 10)]) [\\"100: 10\\"] >>> fetch_order(0, []) []","solution":"def fetch_order(n, times): from collections import defaultdict fetch_dict = defaultdict(list) for fetch_time, arrival_time in times: fetch_dict[fetch_time].append(arrival_time) result = [] for fetch_time in sorted(fetch_dict.keys()): fetch_dict[fetch_time].sort() result.append(f\\"{fetch_time}: {' '.join(map(str, fetch_dict[fetch_time]))}\\") return result"},{"question":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be attended. Parameters: events (List[Tuple[int, int]]): A list of tuples, each containing the start and end time of an event. Returns: int: The maximum number of non-overlapping events that can be attended. # Your code here def get_max_events_from_input(input_data): Reads input data, processes the events, and returns the maximum number of non-overlapping events. Parameters: input_data (str): Input data as a string. Returns: int: The maximum number of non-overlapping events that can be attended. lines = input_data.strip().split('n') n = int(lines[0].strip()) events = [tuple(map(int, lines[i + 1].strip().split())) for i in range(n)] return max_non_overlapping_events(events) # Test cases def test_case_1(): input_data = \\"3n1 3n2 4n3 5\\" assert get_max_events_from_input(input_data) == 2 def test_case_2(): input_data = \\"4n1 2n2 3n3 4n1 3\\" assert get_max_events_from_input(input_data) == 3 def test_case_3(): input_data = \\"1n1 2\\" assert get_max_events_from_input(input_data) == 1 def test_case_4(): input_data = \\"5n1 10n2 3n5 6n7 8n9 11\\" assert get_max_events_from_input(input_data) == 4 def test_case_5(): input_data = \\"6n1 5n2 6n3 7n8 10n9 11n10 12\\" assert get_max_events_from_input(input_data) == 3","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be attended. Parameters: events (List[Tuple[int, int]]): A list of tuples, each containing the start and end time of an event. Returns: int: The maximum number of non-overlapping events that can be attended. # Sort events by their end time events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = 0 for start, end in events: if start >= last_end_time: # Attend this event max_events += 1 last_end_time = end return max_events # Function to read input and handle the events to pass to max_non_overlapping_events def get_max_events_from_input(input_data): lines = input_data.strip().split('n') n = int(lines[0].strip()) events = [tuple(map(int, lines[i + 1].strip().split())) for i in range(n)] return max_non_overlapping_events(events)"},{"question":"def minimum_cost(n: int, m: int, apple_counts: List[int]) -> int: Returns the minimum cost to buy apples from exactly one stall. Args: n : int : Number of stalls m : int : Maximum number of apples that any stall can have apple_counts : list of int : Number of apples at each stall Returns: int : Minimum cost Examples: >>> minimum_cost(5, 10, [3, 7, 2, 9, 5]) 4 >>> minimum_cost(1, 10, [10]) 100 def test_example(): assert minimum_cost(5, 10, [3, 7, 2, 9, 5]) == 4 def test_single_stall(): assert minimum_cost(1, 10, [10]) == 100 def test_all_stalls_with_one_apple(): assert minimum_cost(3, 10, [1, 1, 1]) == 1 def test_all_stalls_with_max_apples(): assert minimum_cost(4, 10, [10, 10, 10, 10]) == 100 def test_varied_apples(): assert minimum_cost(4, 10, [8, 3, 6, 2]) == 4 def test_zero_apples(): # though the problem states minimum 1 apples and given all a_i >=1, this is edge can validate no-zero condition assert minimum_cost(3, 10, [5, 9, 1]) == 1","solution":"def minimum_cost(n, m, apple_counts): Returns the minimum cost to buy apples from exactly one stall. Args: n : int : Number of stalls m : int : Maximum number of apples that any stall can have apple_counts : list of int : Number of apples at each stall Returns: int : Minimum cost # Calculate the cost for each stall and find the minimum cost min_cost = float('inf') for apples in apple_counts: cost = apples ** 2 if cost < min_cost: min_cost = cost return min_cost"},{"question":"def orchard_pattern(N: int, M: int) -> list: Returns a grid pattern of orchard with alternating 'A' (apple) and 'O' (orange) trees. Args: N (int): Number of rows. M (int): Number of columns. Returns: List[str]: A list of strings representing the orchard grid pattern. >>> orchard_pattern(3, 4) ['AOAO', 'OAOA', 'AOAO'] >>> orchard_pattern(2, 2) ['AO', 'OA']","solution":"def orchard_pattern(N, M): Returns a grid pattern of orchard with alternating 'A' (apple) and 'O' (orange) trees. Args: N (int): Number of rows. M (int): Number of columns. Returns: List[str]: A list of strings representing the orchard grid pattern. pattern = [] for i in range(N): row = \\"\\" for j in range(M): if (i + j) % 2 == 0: row += 'A' else: row += 'O' pattern.append(row) return pattern"},{"question":"def largest_sum_subarray(arr): Returns the sum of the largest sum contiguous subarray using Kadane's Algorithm. Parameters: arr (list): A list of integers Returns: int: The sum of the largest sum contiguous subarray Examples: >>> largest_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> largest_sum_subarray([1, 2, 3, 4, -10]) 10 >>> largest_sum_subarray([]) 0","solution":"def largest_sum_subarray(arr): Returns the sum of the largest sum contiguous subarray using Kadane's Algorithm. Parameters: arr (list): A list of integers Returns: int: The sum of the largest sum contiguous subarray if not arr: # Handle if the array is empty return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def process_queries(sequence: list[int], queries: list[tuple[int, int, int]]) -> list[int]: Process a list of queries on a sequence of integers. Parameters: sequence (list): List of integers representing the sequence. queries (list): List of queries where each query is represented as a tuple. Returns: list: Results of the sum and product queries. >>> process_queries([1, 2, 3, 4, 5], [(2, 1, 3), (3, 2, 4), (1, 3, 10), (2, 1, 3), (3, 2, 4), (2, 1, 5)]) [6, 24, 13, 80, 22] >>> process_queries([10], [(1, 1, 5), (2, 1, 1), (3, 1, 1)]) [5, 5] from typing import List, Tuple","solution":"def process_queries(sequence, queries): Process a list of queries on a sequence of integers. Parameters: sequence (list): List of integers representing the sequence. queries (list): List of queries where each query is represented as a tuple. Returns: list: Results of the sum and product queries. results = [] for query in queries: if query[0] == 1: # Update the value at index i to x i, x = query[1], query[2] sequence[i - 1] = x elif query[0] == 2: # Compute the sum of elements from index l to r l, r = query[1], query[2] sum_result = sum(sequence[l - 1:r]) results.append(sum_result) elif query[0] == 3: # Compute the product of elements from index l to r l, r = query[1], query[2] product_result = 1 for i in range(l - 1, r): product_result *= sequence[i] results.append(product_result) return results"},{"question":"def longest_consecutive_active_days(test_cases): This function takes a list of tuples where each tuple contains an integer N and a binary list A, and returns a list of integers representing the longest sequence of consecutive days where the user was active for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples containing the number of days and the respective binary activity array. Returns: List[int]: List of the longest consecutive active days for each test case. Example: >>> test_cases = [(7, [1, 1, 0, 1, 1, 1, 0]), (5, [0, 1, 1, 0, 1]), (4, [0, 0, 0, 0])] >>> longest_consecutive_active_days(test_cases) [3, 2, 0] def parse_input(input_data): This function parses the given input data string and returns it in the required format for the function longest_consecutive_active_days. Args: input_data (str): Input data containing multiple test cases. Returns: List[Tuple[int, List[int]]]: Parsed test cases. Example: >>> input_data = \\"3n7n1 1 0 1 1 1 0n5n0 1 1 0 1n4n0 0 0 0\\" >>> parse_input(input_data) [(7, [1, 1, 0, 1, 1, 1, 0]), (5, [0, 1, 1, 0, 1]), (4, [0, 0, 0, 0])] def test_parse_input(): input_data = \\"3n7n1 1 0 1 1 1 0n5n0 1 1 0 1n4n0 0 0 0\\" expected_output = [(7, [1, 1, 0, 1, 1, 1, 0]), (5, [0, 1, 1, 0, 1]), (4, [0, 0, 0, 0])] assert parse_input(input_data) == expected_output def test_longest_consecutive_active_days(): test_cases = [(7, [1, 1, 0, 1, 1, 1, 0]), (5, [0, 1, 1, 0, 1]), (4, [0, 0, 0, 0])] expected_output = [3, 2, 0] assert longest_consecutive_active_days(test_cases) == expected_output def test_single_active_day(): test_cases = [(1, [1])] expected_output = [1] assert longest_consecutive_active_days(test_cases) == expected_output def test_no_active_days(): test_cases = [(3, [0, 0, 0])] expected_output = [0] assert longest_consecutive_active_days(test_cases) == expected_output def test_all_active_days(): test_cases = [(5, [1, 1, 1, 1, 1])] expected_output = [5] assert longest_consecutive_active_days(test_cases) == expected_output def test_intermediate_zeros(): test_cases = [(5, [1, 1, 0, 1, 1])] expected_output = [2] assert longest_consecutive_active_days(test_cases) == expected_output","solution":"def longest_consecutive_active_days(test_cases): results = [] for test in test_cases: N, A = test max_streak = 0 current_streak = 0 for day in A: if day == 1: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 results.append(max_streak) return results # Function for generating input data from user input format to function's required format def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) A = list(map(int, lines[index + 1].split())) test_cases.append((N, A)) index += 2 return test_cases"},{"question":"def minPathSum(grid): Returns the minimum sum of a path from top-left to bottom-right in a 2D grid. Uses an iterative dynamic programming approach. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) 12","solution":"def minPathSum(grid): Returns the minimum sum of a path from top-left to bottom-right in a 2D grid. Uses an iterative dynamic programming approach. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill up the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def minimum_road_length(n: int, roads: List[Tuple[int, int, int]]) -> Union[int, str]: Calculate the minimal possible total road length required to ensure that it is possible to travel between any pair of cities directly or indirectly through other cities. Args: n: Number of cities roads: List of tuples where each tuple contains three integers u, v, l indicating a road Returns: The minimum possible total road length required, or \\"Impossible\\" if it's not possible to connect all cities. >>> minimum_road_length(4, [(1, 2, 5), (1, 3, 5), (2, 4, 8), (3, 4, 2), (1, 4, 3)]) 10 >>> minimum_road_length(4, [(1, 2, 5), (3, 4, 5)]) \\"Impossible\\" >>> minimum_road_length(1, []) 0 def test_minimum_road_length_sample(): n = 4 roads = [ (1, 2, 5), (1, 3, 5), (2, 4, 8), (3, 4, 2), (1, 4, 3) ] assert minimum_road_length(n, roads) == 10 def test_minimum_road_length_impossible(): n = 4 roads = [ (1, 2, 5), (3, 4, 5) ] assert minimum_road_length(n, roads) == \\"Impossible\\" def test_minimum_road_length_single_node(): n = 1 roads = [] assert minimum_road_length(n, roads) == 0 def test_minimum_road_length_disconnected(): n = 6 roads = [ (1, 2, 3), (3, 4, 5), (5, 6, 2) ] assert minimum_road_length(n, roads) == \\"Impossible\\" def test_minimum_road_length_already_connected(): n = 5 roads = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 5, 10), (2, 4, 15) ] assert minimum_road_length(n, roads) == 10","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_road_length(n, roads): if n == 1: return 0 uf = UnionFind(n) roads.sort(key=lambda x: x[2]) total_length = 0 edges_used = 0 for u, v, length in roads: if uf.find(u - 1) != uf.find(v - 1): uf.union(u - 1, v - 1) total_length += length edges_used += 1 if edges_used == n - 1: break if edges_used == n - 1: return total_length else: return \\"Impossible\\""},{"question":"def min_pages_to_students(n: int, k: int, pages: List[int]) -> int: Determine the minimum possible value for the maximum number of pages assigned to any student. Args: n (int): The number of books. k (int): The number of students. pages (List[int]): The list containing number of pages in each book. Returns: int: The minimum possible value for the maximum number of pages assigned to any student. Examples: >>> min_pages_to_students(4, 2, [12, 34, 67, 90]) 113 >>> min_pages_to_students(5, 3, [10, 20, 30, 40, 50]) 60 >>> min_pages_to_students(3, 2, [15, 17, 20]) 32","solution":"def min_pages_to_students(n, k, pages): def is_valid_allocation(pages, n, k, max_pages): student_count = 1 current_sum = 0 for page in pages: if current_sum + page > max_pages: student_count += 1 current_sum = page if student_count > k: return False else: current_sum += page return True if n < k: return -1 # More students than books is not possible to allocate start, end = max(pages), sum(pages) result = end while start <= end: mid = (start + end) // 2 if is_valid_allocation(pages, n, k, mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('a') 1 >>> length_of_longest_substring('abcdefghij') 10 >>> length_of_longest_substring('abrkaabcdefghijjxxx') 10 >>> length_of_longest_substring('aaaaaaa') 1 >>> length_of_longest_substring('pwwkew') 3 >>> length_of_longest_substring('') 0 >>> length_of_longest_substring('abccba') 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each test case. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\"]) == [3, 1] >>> process_test_cases([\\"\\", \\"pwwkew\\"]) == [0, 3] pass","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def minimum_subsequence_score(n: int, arr: List[int]) -> int: Given a list of integers, find the subsequence that minimizes the sum of absolute differences between every pair of adjacent elements in the subsequence. >>> minimum_subsequence_score(1, [4]) == 0 >>> minimum_subsequence_score(5, [1, 2, 3, 4, 5]) == 4 >>> minimum_subsequence_score(5, [4, 1, 7, 2, 3]) == 6 >>> minimum_subsequence_score(5, [5, 4, 3, 2, 1]) == 4 >>> minimum_subsequence_score(2, [10, 1]) == 9 >>> minimum_subsequence_score(4, [3, 3, 3, 3]) == 0","solution":"def minimum_subsequence_score(n, arr): Given a list of integers, find the subsequence that minimizes the sum of absolute differences between every pair of adjacent elements in the subsequence. if n == 1: return 0 arr.sort() min_score = 0 for i in range(1, n): min_score += abs(arr[i] - arr[i-1]) return min_score"},{"question":"from typing import List def count_valid_rearrangements(s: str) -> int: Given a string of lowercase English letters, find out how many different strings can be created by rearranging the characters such that no two adjacent characters are the same. >>> count_valid_rearrangements(\\"aabb\\") 1 >>> count_valid_rearrangements(\\"a\\") 1 >>> count_valid_rearrangements(\\"aaab\\") 0 >>> count_valid_rearrangements(\\"aaaaa\\") 0 >>> count_valid_rearrangements(\\"aaaaabbbbbccccc\\") 1","solution":"from collections import Counter import heapq def count_valid_rearrangements(s): char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 if len(result) == len(s): return 1 # The string has at least one valid rearrangement according to the construction logic above return 0 # If we couldn't construct a full result that's equal to the input length, it's invalid"},{"question":"from typing import List def find_peak(arr: List[int]) -> int: Returns the index of the peak element in an unimodal list. >>> find_peak([1, 3, 8, 12, 4, 2]) == 3 >>> find_peak([10, 20, 30, 40, 50, 60, 50, 20, 10]) == 5 >>> find_peak([10]) == 0 >>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9 >>> find_peak([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0 >>> find_peak([1, 100, 50, 20, 10, 5, 1]) == 1","solution":"from typing import List def find_peak(arr: List[int]) -> int: Returns the index of the peak element in an unimodal list. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: # Peak is in the right half left = mid + 1 else: # Peak is in the left half or at mid right = mid return left"},{"question":"def can_place_all_plants(p: int, e: int, plant_nutrients: List[int], environment_nutrients: List[int]) -> str: Determines if it is possible to place all plants in suitable environments. Args: p : int : number of plants e : int : number of environments plant_nutrients : list of int : list of nutrient requirements for each plant environment_nutrients : list of int : list of nutrient levels available in each environment Returns: str : \\"YES\\" if all plants can be placed in suitable environments, otherwise \\"NO\\" >>> can_place_all_plants(4, 4, [10, 20, 30, 40], [40, 30, 20, 10]) \\"YES\\" >>> can_place_all_plants(3, 2, [15, 25, 30], [20, 10]) \\"NO\\"","solution":"def can_place_all_plants(p, e, plant_nutrients, environment_nutrients): Determines if it is possible to place all plants in suitable environments. Args: p : int : number of plants e : int : number of environments plant_nutrients : list of int : list of nutrient requirements for each plant environment_nutrients : list of int : list of nutrient levels available in each environment Returns: str : \\"YES\\" if all plants can be placed in suitable environments, otherwise \\"NO\\" plant_nutrients.sort() environment_nutrients.sort() i, j = 0, 0 while i < p and j < e: if plant_nutrients[i] <= environment_nutrients[j]: i += 1 j += 1 return \\"YES\\" if i == p else \\"NO\\""},{"question":"def max_alice_sum(n: int, cards: List[int]) -> int: Determine the maximum sum of card values that Alice can achieve if both players play optimally in a card game. Args: n (int): The number of cards in the deck. cards (List[int]): The values of the cards in the deck. Returns: int: The maximum sum of card values that Alice can achieve. Examples: >>> max_alice_sum(4, [1, 2, 9, 4]) 10 >>> max_alice_sum(3, [5, 3, 7]) 10 >>> max_alice_sum(1, [7]) 7 >>> max_alice_sum(2, [1, 100]) 100 >>> max_alice_sum(3, [3, 3, 3]) 6 >>> max_alice_sum(4, [1, 100, 1, 100]) 200 >>> max_alice_sum(5, [5, 4, 3, 2, 1]) 9 >>> max_alice_sum(5, [1, 2, 3, 4, 5]) 9","solution":"def max_alice_sum(n, cards): # Create a memoization table where dp[i][j] represents the maximum sum Alice # can get from the subarray cards[i:j+1]. dp = [[0] * n for _ in range(n)] # Auxiliary table to store cumulative sums for quick range sum calculations cumulative_sum = [0] * (n + 1) for i in range(n): cumulative_sum[i + 1] = cumulative_sum[i] + cards[i] # Helper function to compute the sum of the cards in a subarray def range_sum(i, j): return cumulative_sum[j + 1] - cumulative_sum[i] # Initialize the table for single cards for i in range(n): dp[i][i] = cards[i] # Fill the table for subarrays of length 2 to n for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(cards[i] + (range_sum(i + 1, j) - dp[i + 1][j]), cards[j] + (range_sum(i, j - 1) - dp[i][j - 1])) # The desired maximum sum for Alice is now in dp[0][n-1] when considering the whole array return dp[0][n - 1] # Example usage: # print(max_alice_sum(4, [1, 2, 9, 4])) # Should output 10"},{"question":"def find_country_position(n: int, medal_data: List[Tuple[str, int, int, int]], target_country: str) -> int: Determine the ranking position of a particular country in the Olympic medal tally list. >>> find_country_position(5, [(\\"USA\\", 10, 5, 8), (\\"CHINA\\", 8, 10, 5), (\\"JAPAN\\", 10, 5, 6), (\\"GERMANY\\", 5, 6, 7), (\\"RUSSIA\\", 8, 7, 10)], \\"JAPAN\\") 2 >>> find_country_position(4, [(\\"KOR\\", 5, 6, 7), (\\"USA\\", 15, 20, 25), (\\"GER\\", 10, 10, 10), (\\"CAN\\", 5, 6, 8)], \\"KOR\\") 4","solution":"def find_country_position(n, medal_data, target_country): # Sorting the medal data based on gold, silver and bronze medals in descending order sorted_medal_data = sorted(medal_data, key=lambda x: (-x[1], -x[2], -x[3])) # Find the position of the target country for idx, (country, gold, silver, bronze) in enumerate(sorted_medal_data): if country == target_country: return idx + 1 return -1 # Example usage n = 5 medal_data = [ (\\"USA\\", 10, 5, 8), (\\"CHINA\\", 8, 10, 5), (\\"JAPAN\\", 10, 5, 6), (\\"GERMANY\\", 5, 6, 7), (\\"RUSSIA\\", 8, 7, 10) ] target_country = \\"JAPAN\\" print(find_country_position(n, medal_data, target_country)) # Output: 2"},{"question":"class Warehouse: def __init__(self): Initialize Warehouse with an empty inventory. self.inventory = {} def add_item(self, item_id: int, amount: int): Add 'amount' of the item with 'item_id' to the inventory. pass def remove_item(self, item_id: int, amount: int): Remove 'amount' of the item with 'item_id' from the inventory. pass def query_item(self, item_id: int) -> int: Return the remaining quantity of the item with 'item_id' in the inventory. pass def handle_operations(operations: List[str]) -> List[int]: Handles a list of operations to manage a warehouse inventory system. Args: operations (List[str]): List of operations as strings. Returns: List[int]: Results of \\"QUERY\\" operations. warehouse = Warehouse() results = [] for operation in operations: op_parts = operation.split() op_type = op_parts[0] if op_type == \\"ADD\\": item_id, amount = int(op_parts[1]), int(op_parts[2]) warehouse.add_item(item_id, amount) elif op_type == \\"REMOVE\\": item_id, amount = int(op_parts[1]), int(op_parts[2]) warehouse.remove_item(item_id, amount) elif op_type == \\"QUERY\\": item_id = int(op_parts[1]) results.append(warehouse.query_item(item_id)) return results # Example usage: # operations = [ # \\"ADD 1 500\\", # \\"ADD 2 300\\", # \\"QUERY 1\\", # \\"REMOVE 1 100\\", # \\"QUERY 2\\", # \\"QUERY 1\\" # ] # result = handle_operations(operations) # print(result) # Output: [500, 300, 400] from typing import List","solution":"class Warehouse: def __init__(self): self.inventory = {} def add_item(self, item_id, amount): if item_id in self.inventory: self.inventory[item_id] += amount else: self.inventory[item_id] = amount def remove_item(self, item_id, amount): if item_id in self.inventory and self.inventory[item_id] >= amount: self.inventory[item_id] -= amount def query_item(self, item_id): return self.inventory.get(item_id, 0) def handle_operations(operations): warehouse = Warehouse() results = [] for operation in operations: op_parts = operation.split() op_type = op_parts[0] if op_type == \\"ADD\\": item_id, amount = int(op_parts[1]), int(op_parts[2]) warehouse.add_item(item_id, amount) elif op_type == \\"REMOVE\\": item_id, amount = int(op_parts[1]), int(op_parts[2]) warehouse.remove_item(item_id, amount) elif op_type == \\"QUERY\\": item_id = int(op_parts[1]) results.append(warehouse.query_item(item_id)) return results"},{"question":"def is_subarray(A, N, M, B, P, Q): Determine whether matrix B is a subarray of matrix A. Args: A (List[List[int]]): The main matrix. N (int): Number of rows in matrix A. M (int): Number of columns in matrix A. B (List[List[int]]): The submatrix. P (int): Number of rows in matrix B. Q (int): Number of columns in matrix B. Returns: str: \\"YES\\" if B is a submatrix of A, otherwise \\"NO\\". >>> A = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20]] >>> B = [[8, 9, 10], [13, 14, 15]] >>> is_subarray(A, 4, 5, B, 2, 3) 'YES' >>> A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> B = [[4, 5]] >>> is_subarray(A, 3, 3, B, 1, 2) 'YES' >>> A = [[1, 2], [3, 4]] >>> B = [[5]] >>> is_subarray(A, 2, 2, B, 1, 1) 'NO' >>> A = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> B = [[1, 1], [1, 2]] >>> is_subarray(A, 3, 3, B, 2, 2) 'NO' pass def matrix_subarray(test_cases): Process multiple test cases to find if each B is a subarray of corresponding A. Args: test_cases (List[Dict[str, Any]]): List of test cases with matrices A and B and their dimensions. Returns: List[str]: List of results for each test case. pass","solution":"def is_subarray(A, N, M, B, P, Q): if P > N or Q > M: return \\"NO\\" for i in range(N - P + 1): for j in range(M - Q + 1): match = True for x in range(P): for y in range(Q): if A[i + x][j + y] != B[x][y]: match = False break if not match: break if match: return \\"YES\\" return \\"NO\\" def matrix_subarray(test_cases): results = [] for case in test_cases: A, B = case['A'], case['B'] N, M = case['N'], case['M'] P, Q = case['P'], case['Q'] result = is_subarray(A, N, M, B, P, Q) results.append(result) return results"},{"question":"from typing import List, Tuple def minCostToConnectLocations(n: int, edges: List[Tuple[int, int, int]]) -> int: Compute the minimum cost required to connect all locations. Each location is represented as a node and each road is an undirected edge with an associated cost of construction. This function uses Kruskal's Minimum Spanning Tree (MST) algorithm. :param n: int - the number of locations :param edges: List of tuples - (u, v, cost) represents a road between locations u and v with a cost :return: int - the minimum cost to connect all locations Examples: >>> minCostToConnectLocations(4, [(1, 2, 3), (2, 3, 1), (3, 4, 2), (4, 1, 4)]) 6 >>> minCostToConnectLocations(3, [(1, 2, 5), (1, 3, 6)]) 11 # Below are some unit tests for the above function def test_example_1(): assert minCostToConnectLocations(4, [(1, 2, 3), (2, 3, 1), (3, 4, 2), (4, 1, 4)]) == 6 def test_example_2(): assert minCostToConnectLocations(3, [(1, 2, 5), (1, 3, 6)]) == 11 def test_single_edge(): assert minCostToConnectLocations(2, [(1, 2, 7)]) == 7 def test_no_edge(): assert minCostToConnectLocations(1, []) == 0 def test_multiple_edges_and_loops(): assert minCostToConnectLocations(4, [(1, 2, 10), (1, 3, 15), (2, 3, 5), (3, 4, 4), (2, 4, 7)]) == 19 def test_more_complex_graph(): assert minCostToConnectLocations(6, [(1, 2, 7), (2, 3, 10), (1, 3, 5), (1, 4, 1), (4, 5, 3), (5, 6, 2), (3, 6, 8)]) == 18","solution":"def minCostToConnectLocations(n, edges): Computes the minimum cost to connect all locations using Kruskal's MST algorithm. :param n: int - the number of locations :param edges: List of tuples - (u, v, cost) represents a road between locations u and v with a cost :return: int - the minimum cost to connect all locations # Sort edges by ascending cost edges.sort(key=lambda x: x[2]) # Union-Find (Disjoint Set Union) helper functions parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Kruskal's algorithm to find the Minimum Spanning Tree (MST) cost mst_cost = 0 edges_used = 0 for u, v, cost in edges: if find(u) != find(v): union(u, v) mst_cost += cost edges_used += 1 # If we've used n-1 edges, we can stop if edges_used == n - 1: break return mst_cost"},{"question":"def find_pairs_with_equal_sums(n, k, array): Determines if there are exactly k distinct pairs of integers in the array such that the sums of integers in each pair are all equal. Parameters: n (int): Size of the array. k (int): Number of pairs to check. array (List[int]): List of integers. Returns: str: \\"YES\\" if there are exactly k pairs with equal sums, otherwise \\"NO\\". >>> find_pairs_with_equal_sums(6, 2, [1, 5, 7, 1, 5, 4]) \\"YES\\" >>> find_pairs_with_equal_sums(4, 2, [1, 1, 2, 2]) \\"NO\\" from solution import find_pairs_with_equal_sums def test_find_pairs_with_equal_sums_case_1(): assert find_pairs_with_equal_sums(6, 2, [1, 5, 7, 1, 5, 4]) == \\"YES\\" def test_find_pairs_with_equal_sums_case_2(): assert find_pairs_with_equal_sums(4, 2, [1, 1, 2, 2]) == \\"NO\\" def test_find_pairs_with_equal_sums_case_3(): assert find_pairs_with_equal_sums(5, 1, [3, 3, 4, 2, 2]) == \\"YES\\" def test_find_pairs_with_equal_sums_no_pairs(): assert find_pairs_with_equal_sums(3, 2, [1, 2, 3]) == \\"NO\\" def test_find_pairs_with_equal_sums_minimum_input(): assert find_pairs_with_equal_sums(2, 1, [0, 0]) == \\"YES\\"","solution":"def find_pairs_with_equal_sums(n, k, array): Determines if there are exactly k distinct pairs of integers in the array such that the sums of integers in each pair are all equal. Parameters: n (int): Size of the array. k (int): Number of pairs to check. array (List[int]): List of integers. Returns: str: \\"YES\\" if there are exactly k pairs with equal sums, otherwise \\"NO\\". from collections import defaultdict sum_pairs_count = defaultdict(int) num_elements = len(array) # Check every pair combination for i in range(num_elements): for j in range(i + 1, num_elements): pair_sum = array[i] + array[j] sum_pairs_count[pair_sum] += 1 for sum_value, count in sum_pairs_count.items(): if count == k: return \\"YES\\" return \\"NO\\""},{"question":"def convert_time(num: int) -> str: Converts a given number of seconds into a string representing the duration in hours, minutes, and seconds. >>> convert_time(3661) \\"1 hours, 1 minutes and 1 seconds\\" >>> convert_time(7324) \\"2 hours, 2 minutes and 4 seconds\\" >>> convert_time(59) \\"0 hours, 0 minutes and 59 seconds\\" >>> convert_time(0) \\"0 hours, 0 minutes and 0 seconds\\" >>> convert_time(3600) \\"1 hours, 0 minutes and 0 seconds\\" >>> convert_time(60) \\"0 hours, 1 minutes and 0 seconds\\" >>> convert_time(3599) \\"0 hours, 59 minutes and 59 seconds\\"","solution":"def convert_time(num): Converts a given number of seconds into a string representing the duration in hours, minutes, and seconds. Parameters: num (int): Number of seconds Returns: str: Duration in the format \\"X hours, Y minutes and Z seconds\\" hours = num // 3600 minutes = (num % 3600) // 60 seconds = num % 60 return f\\"{hours} hours, {minutes} minutes and {seconds} seconds\\""},{"question":"def count_unique_cycles(n: int, m: int, follows: List[Tuple[int, int]]) -> int: Count the number of unique cycles of length 4 in the provided follow relationships. >>> count_unique_cycles(5, 7, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4), (4, 2)]) 1 >>> count_unique_cycles(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> count_unique_cycles(4, 8, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (3, 2), (2, 4), (4, 2)]) 2","solution":"def count_unique_cycles(n, m, follows): from collections import defaultdict follow_graph = defaultdict(set) # Build the follow graph for u, v in follows: follow_graph[u].add(v) count = 0 # Check for cycles of length 4 (A -> B -> C -> D -> A) for A in range(1, n + 1): for B in follow_graph[A]: for C in follow_graph[B]: if C == A: continue for D in follow_graph[C]: if D == A or D == B: continue if A in follow_graph[D]: count += 1 # Each cycle is counted 4 times (once from each vertex), so divide by 4 return count // 4"},{"question":"import heapq class DHeap: def __init__(self, d): self.heap = [] self.d = d def insert(self, x): Insert an element x into the d-ary heap. pass def extract_min(self): Extract and return the smallest element from the d-ary heap. Returns 'NULL' if heap is empty. pass def delete(self, x): Delete a given element x from the d-ary heap if it exists. pass def show(self): Print the current elements of the d-ary heap in level order. Returns 'EMPTY' if heap is empty. pass def test_dheap_operations(): dheap = DHeap(3) dheap.insert(5) dheap.insert(3) dheap.insert(4) assert dheap.show() == \\"3 4 5\\" assert dheap.extract_min() == 3 assert dheap.show() == \\"4 5\\" dheap.delete(4) assert dheap.show() == \\"5\\" assert dheap.extract_min() == 5 assert dheap.show() == \\"EMPTY\\" assert dheap.extract_min() == 'NULL' assert dheap.show() == \\"EMPTY\\" dheap.insert(10) dheap.insert(15) dheap.insert(20) dheap.insert(17) assert dheap.show() == \\"10 15 17 20\\" dheap.delete(15) assert dheap.show() == \\"10 17 20\\"","solution":"import heapq class DHeap: def __init__(self, d): self.heap = [] self.d = d def insert(self, x): heapq.heappush(self.heap, x) def extract_min(self): if not self.heap: return 'NULL' return heapq.heappop(self.heap) def delete(self, x): try: index = self.heap.index(x) self.heap[index] = self.heap[-1] self.heap.pop() if index < len(self.heap): heapq._siftup(self.heap, index) heapq._siftdown(self.heap, 0, index) except ValueError: pass def show(self): if not self.heap: return 'EMPTY' return ' '.join(map(str, sorted(self.heap)))"},{"question":"from typing import List from collections import Counter import heapq def reorganize_string(s: str) -> str: Given a string \`s\`, decide whether it can be reorganized such that no two adjacent characters are the same. If possible, return any valid reorganization of the string, otherwise return \\"IMPOSSIBLE\\". >>> reorganize_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> reorganize_string(\\"aaab\\") \\"IMPOSSIBLE\\" >>> reorganize_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True >>> reorganize_string(\\"a\\") \\"a\\" >>> reorganize_string(\\"aa\\") \\"IMPOSSIBLE\\" >>> reorganize_string(\\"aaabb\\") in [\\"ababa\\", \\"babab\\"] True pass def solve(T: int, test_cases: List[str]) -> List[str]: For each test case, outputs a single line containing a rearrangement of the string if possible, otherwise, outputs \\"IMPOSSIBLE\\". >>> solve(3, [\\"aabb\\", \\"aaab\\", \\"abc\\"]) [\\"abab\\", \\"IMPOSSIBLE\\", \\"abc\\"] >>> solve(2, [\\"aaabb\\", \\"a\\"]) [\\"ababa\\", \\"a\\"] pass","solution":"from collections import Counter import heapq def reorganize_string(s): Given a string \`s\`, decide whether it can be reorganized such that no two adjacent characters are the same. If possible, return any valid reorganization of the string, otherwise return \\"IMPOSSIBLE\\". # Count the frequency of each character in the string counter = Counter(s) max_heap = [] for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 prev_char = char if len(result) != len(s): return \\"IMPOSSIBLE\\" return ''.join(result) def solve(T, test_cases): results = [] for s in test_cases: results.append(reorganize_string(s)) return results"},{"question":"def smallest_permutation(s: str) -> str: Returns the smallest lexicographical permutation of the string by only performing adjacent character swaps. >>> smallest_permutation(\\"cba\\") 'abc' >>> smallest_permutation(\\"edcba\\") 'abcde' # Write your code here","solution":"def smallest_permutation(s): Returns the smallest lexicographical permutation of the string by only performing adjacent character swaps. arr = list(s) n = len(arr) # Bubble Sort like method to use adjacent swaps for i in range(n): for j in range(n-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] # swap adjacent characters return ''.join(arr)"},{"question":"def count_unique_elements(n: int, elements: List[int]) -> int: Returns the number of unique elements in the input list. >>> count_unique_elements(5, [1, 2, 3, 4, 5]) 5 >>> count_unique_elements(5, [1, 1, 1, 1, 1]) 1 >>> count_unique_elements(5, [1, 2, 2, 3, 4]) 4 >>> count_unique_elements(1, [1]) 1 >>> count_unique_elements(100, list(range(1, 101))) 100 >>> count_unique_elements(10, [5, 5, 6, 6, 6, 7, 8, 8, 9, 9]) 5","solution":"def count_unique_elements(n, elements): Returns the number of unique elements in the input list. :param n: int, the number of elements in the input list :param elements: list of integers, the input elements :return: int, number of unique elements return len(set(elements))"},{"question":"def is_strict_palindrome(s: str) -> bool: Checks if the given string is a strict palindrome, ignoring spaces and considering case-sensitivity. >>> is_strict_palindrome(\\"radar\\") == True >>> is_strict_palindrome(\\"Radar\\") == False >>> is_strict_palindrome(\\"a man a plan a canal panama\\") == True >>> is_strict_palindrome(\\"Able was I ere I saw Elba\\") == False >>> is_strict_palindrome(\\"a\\") == True >>> is_strict_palindrome(\\"\\") == True >>> is_strict_palindrome(\\"hello\\") == False","solution":"def is_strict_palindrome(s): Checks if the given string is a strict palindrome, ignoring spaces and considering case-sensitivity. s = s.replace(' ', '') # Remove spaces return s == s[::-1] # Check palindrome by comparing with its reverse"},{"question":"def preprocess_fruits(fruits): Preprocesses the fruits list to create a prefix sums array. pass def query_sum(prefix_sums, l, r): Computes the sum of fruits in the range [l, r] using the prefix sums array. l and r are 1-based indices. pass def count_fruits(n, fruits, q, queries): Processes multiple queries to count the fruits in specified ranges. Parameters: n (int): Number of trees. fruits (list): List of fruits on each tree. q (int): Number of queries. queries (list of tuples): List of queries with (l, r) ranges. Returns: List of sums for each query. pass def test_preprocess_fruits(): fruits = [4, 7, 2, 9, 5] expected_prefix_sums = [0, 4, 11, 13, 22, 27] assert preprocess_fruits(fruits) == expected_prefix_sums def test_query_sum(): prefix_sums = [0, 4, 11, 13, 22, 27] assert query_sum(prefix_sums, 1, 3) == 13 assert query_sum(prefix_sums, 2, 4) == 18 assert query_sum(prefix_sums, 1, 5) == 27 def test_count_fruits(): n = 5 fruits = [4, 7, 2, 9, 5] q = 3 queries = [(1, 3), (2, 4), (1, 5)] expected_results = [13, 18, 27] assert count_fruits(n, fruits, q, queries) == expected_results def test_count_fruits_single_query(): n = 3 fruits = [10, 20, 30] q = 1 queries = [(1, 3)] expected_results = [60] assert count_fruits(n, fruits, q, queries) == expected_results def test_count_fruits_single_tree(): n = 1 fruits = [50] q = 1 queries = [(1, 1)] expected_results = [50] assert count_fruits(n, fruits, q, queries) == expected_results","solution":"def preprocess_fruits(fruits): Preprocesses the fruits list to create a prefix sums array. prefix_sums = [0] * (len(fruits) + 1) for i in range(1, len(fruits) + 1): prefix_sums[i] = prefix_sums[i - 1] + fruits[i - 1] return prefix_sums def query_sum(prefix_sums, l, r): Computes the sum of fruits in the range [l, r] using the prefix sums array. l and r are 1-based indices. return prefix_sums[r] - prefix_sums[l - 1] def count_fruits(n, fruits, q, queries): Processes multiple queries to count the fruits in specified ranges. Parameters: n (int): Number of trees. fruits (list): List of fruits on each tree. q (int): Number of queries. queries (list of tuples): List of queries with (l, r) ranges. Returns: List of sums for each query. prefix_sums = preprocess_fruits(fruits) results = [] for l, r in queries: results.append(query_sum(prefix_sums, l, r)) return results"},{"question":"def maxTeams(skills, K): Count the maximum number of teams that can be formed from the list of employees' skill levels. Each team should have exactly two employees whose combined skill level is at least a given threshold K. Args: skills (List[int]): List of skill levels of employees. K (int): The threshold skill level. Returns: int: The maximum number of valid teams that can be formed. Examples: >>> maxTeams([1, 3, 5, 2, 4], 5) 2 >>> maxTeams([1, 2, 2, 4], 5) 1 def test_maxTeams_basic_cases(): assert maxTeams([1, 3, 5, 2, 4], 5) == 2 assert maxTeams([1, 2, 2, 4], 5) == 1 def test_maxTeams_no_possible_team(): assert maxTeams([1, 1, 1, 1], 5) == 0 assert maxTeams([2, 3], 10) == 0 def test_maxTeams_all_elements_equal(): assert maxTeams([5, 5, 5, 5], 10) == 2 assert maxTeams([5, 5, 5, 5, 5, 5], 10) == 3 def test_maxTeams_large_input(): assert maxTeams([1]*100000, 2) == 50000 assert maxTeams([2]*100000, 5) == 0 def test_maxTeams_mixed_skills(): assert maxTeams([1, 6, 3, 2, 2, 4, 7, 8], 9) == 3","solution":"def maxTeams(skills, K): # Sort the skills in ascending order skills.sort() # Initialize two pointers: one at the start and one at the end of the skills list left, right = 0, len(skills) - 1 teams = 0 # Loop until the pointers meet while left < right: # If the sum of skills at the two pointers is at least K, form a team if skills[left] + skills[right] >= K: teams += 1 left += 1 right -= 1 else: # If the sum is less than K, move the left pointer to try with the next higher skill level left += 1 return teams"},{"question":"def calculateTotalScore(N, numbers): Returns the total score considering only unique numbers. Parameters: N : int : Number of elements in the list numbers : list : List of integers on the pieces of paper Returns: int : The total score Examples: >>> calculateTotalScore(5, [1, 2, 2, 3, 4]) 10 >>> calculateTotalScore(6, [5, 5, 5, 5, 5, 5]) 5 # Unit test for the function def test_calculate_total_score(): # Test case 1 N = 5 numbers = [1, 2, 2, 3, 4] assert calculateTotalScore(N, numbers) == 10 # Test case 2 N = 6 numbers = [5, 5, 5, 5, 5, 5] assert calculateTotalScore(N, numbers) == 5 # Test case 3 - distinct numbers N = 4 numbers = [1, 2, 3, 4] assert calculateTotalScore(N, numbers) == 10 # Test case 4 - all the same numbers N = 3 numbers = [2, 2, 2] assert calculateTotalScore(N, numbers) == 2 # Test case 5 - large distinct set N = 6 numbers = [5, 1, 3, 2, 6, 4] assert calculateTotalScore(N, numbers) == 21 # Test case 6 - numbers in descending order with duplicates N = 8 numbers = [6, 5, 5, 4, 3, 3, 2, 1] assert calculateTotalScore(N, numbers) == 21 # Test case 7 - single number N = 1 numbers = [10] assert calculateTotalScore(N, numbers) == 10 # Test case 8 - mix of numbers N = 7 numbers = [10, 10, 20, 20, 30, 40, 50] assert calculateTotalScore(N, numbers) == 150","solution":"def calculateTotalScore(N, numbers): Returns the total score considering only unique numbers. Parameters: N : int : Number of elements in the list numbers : list : List of integers on the pieces of paper Returns: int : The total score unique_numbers = set(numbers) return sum(unique_numbers)"},{"question":"def submatrix_sum(M, N, matrix, Q, query_params): Given a matrix of size MxN, where each cell contains a positive integer, and Q queries specifying a submatrix, calculate the sum of the elements in the specified submatrix for each query. Parameters: M (int): Number of rows in the matrix. N (int): Number of columns in the matrix. matrix (list of list of int): 2D list containing the matrix elements. Q (int): Number of queries. query_params (list of tuples): List of tuples containing the top-left and bottom-right coordinates of the submatrices to sum. Returns: list: List of sums of elements in the specified submatrices.","solution":"def submatrix_sum(M, N, matrix, Q, query_params): Given a matrix of size MxN and a list of Q queries specifying submatrices, return the sum of elements in those specified submatrices. Parameters: M (int): Number of rows in the matrix. N (int): Number of columns in the matrix. matrix (list of list of int): 2D list containing the matrix elements. Q (int): Number of queries. query_params (list of tuples): List of tuples containing the top-left and bottom-right coordinates of the submatrices to sum. Returns: list: List of sums of elements in the specified submatrices. result = [] for query in query_params: r1, c1, r2, c2 = query submatrix_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): submatrix_sum += matrix[i][j] result.append(submatrix_sum) return result"},{"question":"from typing import List, Tuple def arrange_participants(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Arrange participants based on their performance times in ascending order. If two participants have the same performance time, order them by their IDs in ascending order. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of test cases, each containing the number of participants and their performance times. Returns: List[str]: A list containing the sorted IDs of the participants based on their performance times for each test case. Example: >>> t = 2 >>> test_cases = [ ... (3, [\\"101:5\\", \\"102:3\\", \\"103:5\\"]), ... (4, [\\"201:10\\", \\"202:5\\", \\"203:10\\", \\"204:2\\"]), ... ] >>> arrange_participants(t, test_cases) [\\"102 101 103\\", \\"204 202 201 203\\"] >>> t = 1 >>> test_cases = [ ... (3, [\\"101:5\\", \\"102:5\\", \\"103:5\\"]), ... ] >>> arrange_participants(t, test_cases) [\\"101 102 103\\"]","solution":"def arrange_participants(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] participants = test_cases[i][1] participant_list = [(int(p.split(':')[0]), int(p.split(':')[1])) for p in participants] sorted_participants = sorted(participant_list, key=lambda x: (x[1], x[0])) result = ' '.join(str(participant[0]) for participant in sorted_participants) results.append(result) return results"},{"question":"def first_non_repeating_char(s: str) -> int: Returns the index of the first non-repeating character in the string \`s\`. If no non-repeating character exists, return -1. Example: >>> first_non_repeating_char(\\"leetcode\\") 0 >>> first_non_repeating_char(\\"loveleetcode\\") 2 >>> first_non_repeating_char(\\"aabb\\") -1","solution":"def first_non_repeating_char(s): Returns the index of the first non-repeating character in the string \`s\`. If no non-repeating character exists, return -1. # A dictionary to store the frequency of each character frequency = {} # First iteration: Count the frequency of each character for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Second iteration: Find the first character with a frequency of 1 for index, char in enumerate(s): if frequency[char] == 1: return index # If no non-repeating character found, return -1 return -1"},{"question":"def calculate_minimum_energy(start, destination): Calculate the minimum energy required by a drone to move from start to destination in 3D space. Parameters: - start (tuple): A tuple of three integers (x1, y1, z1) representing the starting coordinates. - destination (tuple): A tuple of three integers (x2, y2, z2) representing the destination coordinates. Returns: - int: The minimum energy required to transport the cargo box from start to destination. Example: >>> calculate_minimum_energy((0, 0, 0), (1, 2, 3)) 6 >>> calculate_minimum_energy((2, 3, 4), (5, 9, 12)) 17 >>> calculate_minimum_energy((10, 10, 10), (10, 10, 10)) 0 >>> calculate_minimum_energy((-1, -1, -1), (1, 1, 1)) 6 >>> calculate_minimum_energy((-3, 7, -5), (4, -2, 6)) 27 # Your code here","solution":"def calculate_minimum_energy(start, destination): Calculate the minimum energy required by a drone to move from start to destination in 3D space. Parameters: - start (tuple): A tuple of three integers (x1, y1, z1) representing the starting coordinates. - destination (tuple): A tuple of three integers (x2, y2, z2) representing the destination coordinates. Returns: - int: The minimum energy required to transport the cargo box from start to destination. x1, y1, z1 = start x2, y2, z2 = destination energy = abs(x2 - x1) + abs(y2 - y1) + abs(z2 - z1) return energy"},{"question":"def sort_strings_by_length_and_lexicographical(case_strings): Sort the list of strings first by length in ascending order, then by lexicographical order (case-insensitive). >>> sort_strings_by_length_and_lexicographical([\\"Apple\\", \\"apple\\", \\"Banana\\"]) [\\"Apple\\", \\"apple\\", \\"Banana\\"] >>> sort_strings_by_length_and_lexicographical([\\"pear\\", \\"Peach\\", \\"PEAR\\", \\"peach\\"]) [\\"pear\\", \\"PEAR\\", \\"Peach\\", \\"peach\\"] def process_test_cases(test_cases): Process multiple test cases and return the sorted strings for each case. >>> process_test_cases([[\\"Apple\\", \\"apple\\", \\"Banana\\"], [\\"pear\\", \\"Peach\\", \\"PEAR\\", \\"peach\\"]]) [['Apple', 'apple', 'Banana'], ['pear', 'PEAR', 'Peach', 'peach']] def main(T, test_cases): Main function to read input, process it using appropriate functions, and return the sorted list of strings for each test case. >>> main(2, [[\\"Apple\\", \\"apple\\", \\"Banana\\"], [\\"pear\\", \\"Peach\\", \\"PEAR\\", \\"peach\\"]]) [['Apple', 'apple', 'Banana'], ['pear', 'PEAR', 'Peach', 'peach']]","solution":"def sort_strings_by_length_and_lexicographical(case_strings): Sort the list of strings first by length in ascending order, then by lexicographical order (case-insensitive). return sorted(case_strings, key=lambda s: (len(s), s.lower())) def process_test_cases(test_cases): results = [] for case in test_cases: sorted_case = sort_strings_by_length_and_lexicographical(case) results.append(sorted_case) return results def main(T, test_cases): sorted_test_cases = process_test_cases(test_cases) return sorted_test_cases"},{"question":"def can_distribute_pens(n: int, pens: List[int]) -> str: Determines if it is possible to distribute pens such that no two adjacent participants receive the same color. Parameters: n (int): The number of pens. pens (list of int): List of integers representing the color codes of the pens. Returns: str: \\"Yes\\" if it is possible to distribute the pens as required, otherwise \\"No\\". >>> can_distribute_pens(5, [1, 1, 2, 3, 3]) \\"No\\" >>> can_distribute_pens(4, [2, 3, 2, 1]) \\"Yes\\" # Your code here","solution":"def can_distribute_pens(n, pens): Determines if it is possible to distribute pens such that no two adjacent participants receive the same color. Parameters: n (int): The number of pens. pens (list of int): List of integers representing the color codes of the pens. Returns: str: \\"Yes\\" if it is possible to distribute the pens as required, otherwise \\"No\\". for i in range(n - 1): if pens[i] == pens[i + 1]: return \\"No\\" return \\"Yes\\""},{"question":"def findLongestSubstring(s: str) -> int: Returns the length of the longest substring with equal number of 'a's and 'b's. >>> findLongestSubstring(\\"abba\\") 4 >>> findLongestSubstring(\\"aabbbaa\\") 6 >>> findLongestSubstring(\\"abababab\\") 8 >>> findLongestSubstring(\\"aaaaa\\") 0 >>> findLongestSubstring(\\"bbbbb\\") 0 >>> findLongestSubstring(\\"a\\") 0 >>> findLongestSubstring(\\"b\\") 0 >>> findLongestSubstring(\\"ababbaabbaaabab\\") 14","solution":"def findLongestSubstring(s): Returns the length of the longest substring with equal number of 'a's and 'b's. # Dictionary to store (difference of counts of 'a' and 'b') and the earliest index it was seen at count_index_map = {0: -1} max_length = 0 count = 0 for i, char in enumerate(s): # Increment or decrement count based on character if char == 'a': count += 1 else: count -= 1 # If the count has been seen before, calculate the length of the substring if count in count_index_map: max_length = max(max_length, i - count_index_map[count]) else: # Store the index for this count count_index_map[count] = i return max_length"},{"question":"def collatz_length(n: int) -> int: Create a function \`collatz_length\` that takes an integer \`n\` and returns the number of terms in the Collatz sequence starting from \`n\` until it reaches 1. The Collatz sequence is defined as follows: - If \`n\` is 1, stop. - Otherwise, if \`n\` is even, the next term is \`n / 2\`. - Otherwise, the next term is \`3 * n + 1\`. Use memoization to handle very large values of \`n\` efficiently. >>> collatz_length(13) # returns 10 >>> collatz_length(1) # returns 1 >>> collatz_length(6) # returns 9","solution":"def collatz_length(n, memo={1: 1}): Returns the number of terms in the Collatz sequence starting from \`n\` until it reaches 1. Uses memoization to optimize for large values of \`n\`. if n in memo: return memo[n] if n % 2 == 0: next_term = n // 2 else: next_term = 3 * n + 1 memo[n] = 1 + collatz_length(next_term, memo) return memo[n]"},{"question":"from typing import List def longest_mountain(nums: List[int]) -> int: Identify the length of the longest mountain in nums. A \\"mountain\\" is a sequence of adjacent integers that strictly increase to a peak, then strictly decrease. It cannot start or end with the peak. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0 >>> longest_mountain([1, 2, 2, 3, 4, 4, 5]) 0 pass","solution":"def longest_mountain(nums): n = len(nums) if n < 3: return 0 max_length = 0 for i in range(1, n - 1): # Check if nums[i] is a peak if nums[i - 1] < nums[i] > nums[i + 1]: left = i right = i # Move left pointer down the mountain while left > 0 and nums[left - 1] < nums[left]: left -= 1 # Move right pointer down the mountain while right < n - 1 and nums[right + 1] < nums[right]: right += 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"def longest_equal_positive_negative_subarray(arr): Returns the length of the longest subarray that contains equal number of positive and negative integers. >>> longest_equal_positive_negative_subarray([1, -1]) == 2 >>> longest_equal_positive_negative_subarray([1, -1, 2, -2, 3]) == 4 >>> longest_equal_positive_negative_subarray([1, -1, 2, -2, 1, -1, 2, -2]) == 8 >>> longest_equal_positive_negative_subarray([1, 2, 3, 4, 5]) == 0 >>> longest_equal_positive_negative_subarray([1, -1, 1, -1, 1, -1, 2, -2]) == 8 >>> longest_equal_positive_negative_subarray([1]) == 0 >>> longest_equal_positive_negative_subarray([-1]) == 0","solution":"def longest_equal_positive_negative_subarray(arr): Returns the length of the longest subarray that contains equal number of positive and negative integers. n = len(arr) maxlen = 0 prefix_sums = {0: -1} # to store the first occurrence of each prefix sum current_sum = 0 for idx, num in enumerate(arr): if num > 0: current_sum += 1 elif num < 0: current_sum -= 1 if current_sum in prefix_sums: maxlen = max(maxlen, idx - prefix_sums[current_sum]) else: prefix_sums[current_sum] = idx return maxlen"},{"question":"def rotate_grid(grid, k): Rotates the grid 90 degrees clockwise k times. Parameters: grid (List[List[int]]): A 2D list representing the grid. k (int): The number of times to rotate the grid 90 degrees clockwise. Returns: List[List[int]]: The grid after k rotations. >>> rotate_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] pass def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) grid = [] index = 2 for i in range(n): grid.append(list(map(int, data[index:index+n]))) index += n result = rotate_grid(grid, k) for row in result: print(\\" \\".join(map(str, row))) if __name__ == \\"__main__\\": main()","solution":"def rotate_grid(grid, k): Rotates the grid 90 degrees clockwise k times. n = len(grid) # since rotating 4 times brings the grid back to the original position k = k % 4 for _ in range(k): # Create a new grid with the same dimension n x n new_grid = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_grid[j][n - 1 - i] = grid[i][j] grid = new_grid return grid def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) grid = [] index = 2 for i in range(n): grid.append(list(map(int, data[index:index+n]))) index += n result = rotate_grid(grid, k) for row in result: print(\\" \\".join(map(str, row))) if __name__ == \\"__main__\\": main()"},{"question":"def determine_winner(N: int) -> str: Determine the winner of the game based on the length of the sequence. Parameters: N : int : The length of the sequence. Returns: str : \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. Examples: >>> determine_winner(1) 'Bob' >>> determine_winner(2) 'Alice' >>> determine_winner(3) 'Bob' >>> determine_winner(4) 'Alice' pass def solve_game(T: int, test_cases: List[int]) -> List[str]: Solve the game for multiple test cases. Parameters: T : int : Number of test cases. test_cases: List[int] : List of integers representing the test cases. Returns: List[str] : List of results for each test case, either \\"Alice\\" or \\"Bob\\". Examples: >>> solve_game(3, [1, 2, 3]) ['Bob', 'Alice', 'Bob'] >>> solve_game(1, [10**9]) ['Alice'] >>> solve_game(2, [999999999, 1000000000]) ['Bob', 'Alice'] >>> solve_game(1, [1]) ['Bob'] pass","solution":"def determine_winner(N): Determine the winner of the game. Parameters: N : int : The length of the sequence. Returns: str : \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. # Alice wins if N is even, Bob wins if N is odd if N % 2 == 0: return \\"Alice\\" else: return \\"Bob\\" def solve_game(T, test_cases): results = [] for N in test_cases: results.append(determine_winner(N)) return results"},{"question":"def min_operations_to_equalize_string(T, cases): Determine the minimum number of operations required to make all characters in the binary string equal. >>> min_operations_to_equalize_string(2, [(7, '1000001'), (5, '11111')]) [1, 0] >>> min_operations_to_equalize_string(3, [(10, '0101010101'), (6, '000000'), (8, '11110000')]) [5, 1, 1] >>> min_operations_to_equalize_string(1, [(7, '1110111')]) [1] >>> min_operations_to_equalize_string(1, [(6, '000000')]) [1] >>> min_operations_to_equalize_string(1, [(4, '1111')]) [0] >>> min_operations_to_equalize_string(2, [(9, '110000011'), (11, '00000000000')]) [1, 1]","solution":"def min_operations_to_equalize_string(T, cases): results = [] for case in cases: N, B = case if '0' not in B: results.append(0) else: segments_of_zeros = B.split('1') operations = sum(1 for segment in segments_of_zeros if '0' in segment) results.append(operations) return results"},{"question":"def count_balanced_substrings(s: str) -> int: Given a string s consisting of letters 'a' and 'b' only, split the string into the least number of substrings where each substring contains equal numbers of 'a' and 'b'. Return the number of such substrings. >>> count_balanced_substrings(\\"aabbaabb\\") 2 >>> count_balanced_substrings(\\"abababab\\") 4 >>> count_balanced_substrings(\\"aaaaaabbbbbb\\") 1 >>> count_balanced_substrings(\\"abab\\") 2","solution":"def count_balanced_substrings(s): Returns the least number of substrings where each substring contains equal numbers of 'a' and 'b'. a_count = 0 b_count = 0 balanced_count = 0 for char in s: if char == 'a': a_count += 1 elif char == 'b': b_count += 1 if a_count == b_count: balanced_count += 1 a_count = 0 b_count = 0 return balanced_count"},{"question":"def can_form_palindrome_by_swapping(S): Determine if it is possible to convert the given string into a palindrome by performing exactly one operation of swapping all occurrences of any two different characters. Arguments: S -- a list of test strings Returns: A list of strings, \\"YES\\" or \\"NO\\" for each test string indicating if it is possible to make the string a palindrome by swapping two characters. >>> can_form_palindrome_by_swapping([\\"ab\\", \\"aabbcc\\", \\"abc\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_palindrome_by_swapping([\\"a\\"]) [\\"YES\\"] >>> can_form_palindrome_by_swapping([\\"aa\\"]) [\\"YES\\"] >>> can_form_palindrome_by_swapping([\\"aabb\\"]) [\\"YES\\"] >>> can_form_palindrome_by_swapping([\\"aaccaa\\"]) [\\"YES\\"] >>> can_form_palindrome_by_swapping([\\"abcdedcba\\", \\"aabbccddee\\"]) [\\"YES\\", \\"YES\\"] >>> can_form_palindrome_by_swapping([\\"abcde\\"]) [\\"NO\\"] pass def process_input(lines): Process the input lines and return results for each test case. Arguments: lines -- list of strings representing the input Returns: A list of strings, \\"YES\\" or \\"NO\\" for each test string in the input indicating if it's possible to make the string a palindrome. pass","solution":"def can_form_palindrome_by_swapping(S): from collections import Counter def can_form_palindrome_after_one_swap(S): # Check if the character frequencies can form a palindrome by perhaps swapping two characters freq = Counter(S) odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count if odd_count > 2: return False # Special edge case when there are 2 odd frequencies and the sum of their counts is at most 3 # Example: xyyz has x:1, y:2, z:1 can be transformed into yxzy odd_freq_chars = [char for char in freq if freq[char] % 2 != 0] if odd_count == 2: if sum(freq[char] for char in odd_freq_chars) <= 3: return True return False return True return [ \\"YES\\" if can_form_palindrome_after_one_swap(S) else \\"NO\\" for S in S ] def process_input(lines): T = int(lines[0]) test_cases = lines[1:T+1] return can_form_palindrome_by_swapping(test_cases)"},{"question":"# Task 1. Write a function \`find_missing_number(arr, n)\` that takes as input: - \`arr\`: a list of \`n-1\` unique integers between 1 and \`n\`. - \`n\`: an integer representing the range of numbers. 2. The function should return the missing integer. 3. Your implementation should use bitwise operations to achieve linear runtime complexity \`O(n)\` and constant space complexity \`O(1)\`. # Example # Example 1 arr = [1, 2, 4, 5, 6] n = 6 print(find_missing_number(arr, n)) # Output: 3 # Example 2 arr = [3, 7, 1, 2, 8, 4, 5] n = 8 print(find_missing_number(arr, n)) # Output: 6 # Function Signature def find_missing_number(arr: list, n: int) -> int: Given a list of n-1 unique integers between 1 and n, find the missing integer using bitwise operations. Args: arr (list): List of n-1 unique integers. n (int): The upper limit of the range. Returns: int: The missing integer. Examples: >>> find_missing_number([1, 2, 4, 5, 6], 6) 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5], 8) 6 pass # Unit Test def test_find_missing_number(): assert find_missing_number([1, 2, 4, 5, 6], 6) == 3 assert find_missing_number([3, 7, 1, 2, 8, 4, 5], 8) == 6 assert find_missing_number([1, 2, 3, 4, 5, 7, 8, 9, 10], 10) == 6 assert find_missing_number([2, 3], 3) == 1 assert find_missing_number([1], 2) == 2 assert find_missing_number([], 1) == 1 assert find_missing_number([1, 3], 3) == 2 assert find_missing_number([2], 2) == 1 test_find_missing_number()","solution":"def find_missing_number(arr, n): # Initialize XOR of all numbers from 1 to n xor_n = 0 for i in range(1, n+1): xor_n ^= i # Initialize XOR of all numbers in the array xor_arr = 0 for num in arr: xor_arr ^= num # The missing number is the XOR of the above two results return xor_n ^ xor_arr"},{"question":"def find_closest_subarray_sum(n: int, T: int, array: List[int]) -> int: Finds the sum of the subarray that is closest to the target T. Parameters: n (int): the size of the array. T (int): the target sum. array (list of int): the elements of the array. Returns: int: the sum of the subarray that is closest to T. >>> find_closest_subarray_sum(5, 10, [2, -1, 2, 3, 4]) 10 >>> find_closest_subarray_sum(3, 1, [-2, 2, 1]) 1 >>> find_closest_subarray_sum(4, 8, [1, 3, -1, 7]) 9 pass","solution":"def find_closest_subarray_sum(n, T, array): Finds the sum of the subarray that is closest to the target T. Parameters: n (int): the size of the array. T (int): the target sum. array (list of int): the elements of the array. Returns: int: the sum of the subarray that is closest to T. closest_sum = float('inf') prefix_sums = {0: -1} current_sum = 0 for i in range(n): current_sum += array[i] # Iterate through all previously seen prefix sums for s in prefix_sums: subarray_sum = current_sum - s if abs(subarray_sum - T) < abs(closest_sum - T): closest_sum = subarray_sum prefix_sums[current_sum] = i return closest_sum"},{"question":"def count_jumpable_elements(arr): Counts the number of jumpable elements in the array. Args: arr (List[int]): The integer array. Returns: int: The number of jumpable elements. >>> count_jumpable_elements([1, 2, 2, 5, 1]) 3 >>> count_jumpable_elements([3, 2, 1]) 1 >>> count_jumpable_elements([0, 0, 0, 1]) 4 >>> count_jumpable_elements([5]) 1 >>> count_jumpable_elements([10, 5, 15, 1, 50]) 3","solution":"def count_jumpable_elements(arr): Counts the number of jumpable elements in the array. jumpable_count = 0 current_sum = 0 for num in arr: if num >= current_sum: jumpable_count += 1 current_sum += num return jumpable_count"},{"question":"def smallest_lexicographical_array(test_cases): Given an array of N integers, perform a series of operations to obtain the smallest lexicographical array possible. Each test case consists of: - An integer N, the number of integers in the array. - A list of N space-separated integers representing the array. Args: test_cases (List[Tuple[int, List[int]]]): List of test case tuples. Returns: List[List[int]]: List of smallest lexicographical arrays for each test case. >>> smallest_lexicographical_array([(4, [4, 3, 2, 1]), (5, [1, 3, 5, 4, 2]), (3, [2, 3, 1])]) [[1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3]] >>> smallest_lexicographical_array([(1, [1]), (3, [3, 2, 1])]) [[1], [1, 2, 3]]","solution":"def smallest_lexicographical_array(test_cases): result = [] for n, arr in test_cases: result.append(sorted(arr)) return result"},{"question":"def can_split_string(s): Determine if a string s can be split into two non-empty parts with distinct characters. >>> can_split_string(\\"abac\\") \\"YES\\" >>> can_split_string(\\"abcd\\") \\"YES\\" >>> can_split_string(\\"aaaa\\") \\"NO\\" >>> can_split_string(\\"abab\\") \\"YES\\" >>> can_split_string(\\"a\\") \\"NO\\" >>> can_split_string(\\"aa\\") \\"NO\\" def process_test_cases(test_cases): Given a list of test cases, determine if each string can be split into two non-empty parts with distinct characters. >>> process_test_cases([\\"abac\\", \\"abcd\\", \\"aaaa\\", \\"abab\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([\\"a\\", \\"aa\\"]) [\\"NO\\", \\"NO\\"] import pytest def test_can_split_string(): assert can_split_string(\\"abac\\") == \\"YES\\" assert can_split_string(\\"abcd\\") == \\"YES\\" assert can_split_string(\\"aaaa\\") == \\"NO\\" assert can_split_string(\\"abab\\") == \\"YES\\" assert can_split_string(\\"a\\") == \\"NO\\" assert can_split_string(\\"aa\\") == \\"NO\\" def test_process_test_cases(): test_cases = [\\"abac\\", \\"abcd\\", \\"aaaa\\", \\"abab\\"] expected_results = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(test_cases) == expected_results test_cases = [\\"a\\", \\"aa\\"] expected_results = [\\"NO\\", \\"NO\\"] assert process_test_cases(test_cases) == expected_results","solution":"def can_split_string(s): Determine if a string s can be split into two non-empty parts with distinct characters. n = len(s) # We need to find at least two distinct characters to make the split possible. distinct_chars = set(s) # If the number of distinct characters is less than 2, we cannot perform the required split if len(distinct_chars) < 2: return \\"NO\\" # Otherwise, we can find a valid split return \\"YES\\" def process_test_cases(test_cases): results = [] for s in test_cases: results.append(can_split_string(s)) return results"},{"question":"def longest_increasing_subsequence(nums): Returns the length of the longest strictly increasing subsequence. :param nums: List of integers :return: Length of the longest strictly increasing subsequence >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest strictly increasing subsequence. :param nums: List of integers :return: Length of the longest strictly increasing subsequence if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def maximize_sum(n: int, arr: List[int], ops: List[int], B: List[int]) -> int: Maximize the sum of the array after applying \`ops\` arrays while respecting the upper bounds \`B\`. Parameters: n (int): Length of the arrays. arr (List[int]): Array of integers to which operations will be applied. ops (List[int]): Number of operations that can be applied to each element of \`arr\`. B (List[int]): Upper bounds for each element of \`arr\`. Returns: int: The maximum possible sum of the array after applying all operations. >>> maximize_sum(4, [1, 2, 3, 4], [3, 3, 3, 3], [7, 8, 6, 5]) 20 >>> maximize_sum(3, [1, 2, 3], [0, 0, 0], [5, 5, 5]) 6 >>> maximize_sum(3, [1, 2, 3], [10, 10, 10], [3, 4, 5]) 12 >>> maximize_sum(3, [1, 2, 1], [2, 2, 2], [7, 7, 7]) 10 >>> maximize_sum(4, [0, 0, 0, 0], [1, 1, 1, 1], [1, 2, 3, 4]) 4 >>> maximize_sum(3, [1000000000, 2000000000, 3000000000], [1, 1, 1], [1000000001, 2000000001, 3000000001]) 6000000003","solution":"def maximize_sum(n, arr, ops, B): Maximize the sum of the array after applying \`ops\` arrays while respecting the upper bounds \`B\`. Parameters: n (int): Length of the arrays. arr (List[int]): Array of integers to which operations will be applied. ops (List[int]): Number of operations that can be applied to each element of \`arr\`. B (List[int]): Upper bounds for each element of \`arr\`. Returns: int: The maximum possible sum of the array after applying all operations. total_sum = 0 for i in range(n): # The new value is the minimum between arr[i] + ops[i] and B[i] new_value = min(arr[i] + ops[i], B[i]) total_sum += new_value return total_sum"},{"question":"def final_position_after_instructions(T, instructions_list): Returns the final coordinates of the vacuum cleaner after executing the given set of instructions. Args: T (int): The number of test cases. instructions_list (List[str]): A list of instruction strings. Returns: List[Tuple[int, int]]: A list of tuples containing the final coordinates for each test case. >>> final_position_after_instructions(2, [\\"LLRR\\", \\"UUDDLR\\"]) [(0, 0), (0, -2)] >>> final_position_after_instructions(3, [\\"UUDD\\", \\"LLRR\\", \\"UUDDLR\\"]) [(0, 0), (0, 0), (0, -2)]","solution":"def final_position_after_instructions(T, instructions_list): Returns the final coordinates of the vacuum cleaner after executing the given set of instructions. results = [] for instructions in instructions_list: x, y = 0, 0 for instruction in instructions: if instruction == 'L': x -= 1 elif instruction == 'R': x += 1 elif instruction == 'U': y += 1 elif instruction == 'D': y -= 1 results.append((x, y)) return results"},{"question":"def findMaxLength(nums: List[int]) -> int: Finds the length of the longest contiguous subarray with an equal number of 0s and 1s. >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 0, 0, 1, 1]) 6 >>> findMaxLength([0, 0, 1, 1, 0]) 4 >>> findMaxLength([1, 1, 1, 0, 1]) 2 >>> findMaxLength([1, 1, 1, 1]) 0 >>> findMaxLength([0, 0, 0, 0]) 0 >>> findMaxLength([0, 1]) 2 >>> findMaxLength([0]) 0 >>> findMaxLength([1]) 0 >>> findMaxLength([1, 0, 1, 0, 1, 0]) 6 >>> findMaxLength([1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1]) 10","solution":"def findMaxLength(nums): Finds the length of the longest contiguous subarray with an equal number of 0s and 1s. # Initialize variables to track the count and the maximum length of subarray count = 0 max_length = 0 # Dictionary to store the first occurrence of each count value count_map = {0: -1} for i, num in enumerate(nums): # Increment count for 1, decrement for 0 count += 1 if num == 1 else -1 # Check if the current count has been seen before if count in count_map: # Calculate the length of the subarray from the previous occurrence to the current index max_length = max(max_length, i - count_map[count]) else: # Store the first occurrence of the count count_map[count] = i return max_length"},{"question":"def is_rectangular_region_filled(grid): Determines if there exists at least one rectangular region filled entirely with 1s. :param grid: List of Lists containing integers (0 or 1) :return: \\"YES\\" if such a region exists, otherwise \\"NO\\"","solution":"def is_rectangular_region_filled(grid): Determines if there exists at least one rectangular region filled entirely with 1s. :param grid: List of Lists containing integers (0 or 1) :return: \\"YES\\" if such a region exists, otherwise \\"NO\\" n = len(grid) m = len(grid[0]) if n > 0 else 0 for i in range(n - 1): for j in range(m - 1): if grid[i][j] == 1 and grid[i][j + 1] == 1 and grid[i + 1][j] == 1 and grid[i + 1][j + 1] == 1: return \\"YES\\" return \\"NO\\""},{"question":"def unique_sorted_even_numbers(n: int, arr: List[int]) -> List[int]: Function that takes an integer n and a list of n integers, and returns a list of unique even numbers in ascending order. >>> unique_sorted_even_numbers(5, [1, 2, 3, 4, 4]) [2, 4] >>> unique_sorted_even_numbers(6, [5, 7, 9, 11, 13]) [] Parameters: n (int): the number of elements in the array arr (List[int]): the list of elements Returns: List[int]: sorted list of unique even numbers pass","solution":"def unique_sorted_even_numbers(n, arr): Returns a sorted list of unique even numbers from the input array. Parameters: n (int) : the number of elements in the array arr (list) : the list of elements Returns: list : sorted list of unique even numbers even_numbers = {x for x in arr if x % 2 == 0} return sorted(even_numbers)"},{"question":"def can_visit_all_rooms(num_rooms, room_keys): Determine if it is possible to visit all rooms starting from room 1. Args: num_rooms (int): The number of rooms. room_keys (List[List[int]]): A list where each element is a list of keys found in that room. Returns: bool: True if it is possible to visit all rooms, False otherwise. pass def process_input(data): Process input data and determine if it is possible to visit all rooms for each dataset. Args: data (str): Input data containing multiple datasets. Returns: List[str]: A list of results, \\"YES\\" or \\"NO\\" for each dataset. >>> data = \\"2n1 2n2nn4n1 2 3n2n3 4n4\\" >>> process_input(data) [\\"YES\\", \\"YES\\"] >>> data = \\"2n1n2\\" >>> process_input(data) [\\"NO\\"] >>> data = \\"2n1 2n2\\" >>> process_input(data) [\\"YES\\"] >>> data = \\"3n1 2 3n2n3\\" >>> process_input(data) [\\"YES\\"] >>> data = \\"3n1 2n2n3\\" >>> process_input(data) [\\"NO\\"] >>> data = \\"4n1 2n2 3n3 4n4 1\\" >>> process_input(data) [\\"YES\\"] pass","solution":"def can_visit_all_rooms(num_rooms, room_keys): visited = set() keys = set() keys.add(1) # Start with the key to room 1 while keys: key = keys.pop() if key not in visited: visited.add(key) keys.update(room_keys[key - 1]) return len(visited) == num_rooms def process_input(data): datasets = data.strip().split('nn') results = [] for dataset in datasets: lines = dataset.split('n') num_rooms = int(lines[0]) room_keys = [] for line in lines[1:]: parts = list(map(int, line.split())) room_keys.append(parts[1:]) if can_visit_all_rooms(num_rooms, room_keys): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_possible_sum(test_cases): Given multiple test cases, compute the maximum possible sum of the array constructed using a  b operation. >>> max_possible_sum([(4, [1, 2, -3, -4]), (3, [0, 1, -2])]) [15, 1] >>> max_possible_sum([(2, [5, -5])]) [0] >>> max_possible_sum([(5, [2, 3, -1, -2, -3])]) [7] >>> max_possible_sum([(4, [-1, -2, -3, -4])]) [14]","solution":"def max_possible_sum(test_cases): Given multiple test cases, compute the maximum possible sum of the array constructed using a  b operation. results = [] for test in test_cases: N, arr = test non_negatives = [] negatives = [] for num in arr: if num >= 0: non_negatives.append(num) else: negatives.append(num) non_negatives.sort(reverse=True) negatives.sort() max_sum = 0 paired_elements = [] # Process pairs of non-negative numbers while len(non_negatives) >= 2: a = non_negatives.pop() b = non_negatives.pop() max_sum += a + b paired_elements.append((a, b, a + b)) # Process pairs of negative numbers while len(negatives) >= 2: a = negatives.pop() b = negatives.pop() max_sum += a * b paired_elements.append((a, b, a * b)) results.append(max_sum) return results # Example usage # T = 2 # test_cases = [ # (4, [1, 2, -3, -4]), # (3, [0, 1, -2]) # ] # output = max_possible_sum(test_cases) # Should return [15, 1]"},{"question":"def calculate_score(s: str) -> int: Determine the total score of a given string based on character values. Each character in the English alphabet has a specific value: 'a' is worth 1 point, 'b' is worth 2 points, ..., 'z' is worth 26 points. Uppercase letters have the same values as their corresponding lowercase letters. Spaces, digits, and punctuation characters are worth 0 points and should be ignored in the score calculation. >>> calculate_score(\\"Hello, World!\\") 124 >>> calculate_score(\\"Python 3.8 is amazing!\\") 197 # Test cases def test_calculate_score_example1(): assert calculate_score(\\"Hello, World!\\") == 124 def test_calculate_score_example2(): assert calculate_score(\\"Python 3.8 is amazing!\\") == 197 def test_calculate_score_empty_string(): assert calculate_score(\\"\\") == 0 def test_calculate_score_all_letters(): assert calculate_score(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == 2 * sum(range(1, 27)) def test_calculate_score_no_letters(): assert calculate_score(\\"1234567890!@#%^&*()\\") == 0 def test_calculate_score_mixed_content(): assert calculate_score(\\"a1b2C3d4E5f6G7h8I9j0kL!M@N#OP%Q^R&S(T)U_V+W-X=Y{Z}\\") == sum(range(1, 27))","solution":"def calculate_score(s: str) -> int: score = 0 for char in s: if char.isalpha(): score += ord(char.lower()) - ord('a') + 1 return score"},{"question":"from typing import List, Tuple def minimum_distance(trips: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum total distance traveled to visit every city starting from the first city. Args: trips (List[Tuple[int, List[int]]]): List of tuples where the first element is the number of cities and the second element is a list representing the population of cities. Returns: List[int]: List of integers representing the minimum total distance for each trip. >>> minimum_distance([(4, [4, 2, 7, 3]), (3, [1, 5, 9]), (2, [3, 6])]) [3, 2, 1] >>> minimum_distance([(5, [10, 20, 30, 40, 50])]) [4] >>> minimum_distance([(1, [100])]) [0] >>> minimum_distance([(100000, list(range(1, 100001)))]) [99999] >>> minimum_distance([(4, [10, 10, 10, 10])]) [3]","solution":"def minimum_distance(trips): results = [] for n, p in trips: results.append(n - 1) # Minimum distance to visit all cities once in sorted order return results # Example usage: # trips = [(4, [4, 2, 7, 3]), (3, [1, 5, 9]), (2, [3, 6])] # print(minimum_distance(trips)) # Output: [3, 2, 1]"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: This function calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid avoiding obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) == 1 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 1, 0], [0, 0, 0]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == 0 >>> unique_paths_with_obstacles([[0]]) == 1 >>> unique_paths_with_obstacles([[1]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) == 4","solution":"def unique_paths_with_obstacles(grid): This function calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid avoiding obstacles. if not grid or grid[0][0] == 1: return 0 n = len(grid) m = len(grid[0]) # Initialize a 2D list for dynamic programming dp = [[0]*m for _ in range(n)] # Start position dp[0][0] = 1 # Fill in the dp table for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def consecutive_days_exceed_threshold(n: int, spendings: List[int], t: int) -> str: Returns \\"YES\\" if there are two consecutive days where the total spending exceeded the threshold t. Otherwise, returns \\"NO\\". >>> consecutive_days_exceed_threshold(5, [200, 150, 300, 400, 250], 600) \\"YES\\" >>> consecutive_days_exceed_threshold(4, [100, 200, 150, 200], 500) \\"NO\\"","solution":"def consecutive_days_exceed_threshold(n, spendings, t): Returns \\"YES\\" if there are two consecutive days where the total spending exceeded the threshold t. Otherwise, returns \\"NO\\". for i in range(n - 1): if spendings[i] + spendings[i + 1] > t: return \\"YES\\" return \\"NO\\""},{"question":"def can_reach_end(track: List[int], position: int) -> bool: Determines if the participant can reach the last position in the track starting from the given position. Args: track (List[int]): The race track represented as an array of integers. position (int): The starting position within the array. Returns: bool: True if the participant can reach the end, False otherwise. >>> can_reach_end([3, 2, 1, 0, 4], 0) False >>> can_reach_end([2, 3, 1, 1, 4], 0) True >>> can_reach_end([3, 2, 1, 0, 4], 2) False >>> can_reach_end([3, 2, 1, 2, 0, 4], 1) True","solution":"def can_reach_end(track, position): Determines if the participant can reach the last position in the track starting from the given position. :param track: List[int] - array representing the race track. :param position: int - starting position in the array. :return: bool - True if the participant can reach the end, False otherwise. furthest_reach = position last_index = len(track) - 1 for i in range(position, len(track)): if i > furthest_reach: break furthest_reach = max(furthest_reach, i + track[i]) if furthest_reach >= last_index: return True return False"},{"question":"from typing import List, Tuple def count_in_ranges(n: int, ratings: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Returns a list of counts of players whose ratings fall within each given range. Parameters: n (int): Number of players ratings (list): List of player ratings q (int): Number of queries queries (list): List of tuples representing the query ranges Returns: list: List of counts for each range query pass if __name__ == \\"__main__\\": # Example test cases to check your function ratings1 = [100, 200, 300, 400, 500] queries1 = [(100, 300), (200, 400), (300, 500)] print(count_in_ranges(5, ratings1, 3, queries1)) # Expected: [3, 3, 3] ratings2 = [10, 20, 30, 40, 50, 60] queries2 = [(15, 35), (25, 55)] print(count_in_ranges(6, ratings2, 2, queries2)) # Expected: [2, 2]","solution":"from bisect import bisect_left, bisect_right def count_in_ranges(n, ratings, q, queries): Returns a list of counts of players whose ratings fall within each given range. Parameters: n (int): Number of players ratings (list): List of player ratings q (int): Number of queries queries (list): List of tuples representing the query ranges Returns: list: List of counts for each range query # Sort the ratings once for efficient querying ratings.sort() results = [] for a, b in queries: # Find the left and right position for the range [a, b] left_idx = bisect_left(ratings, a) right_idx = bisect_right(ratings, b) count = right_idx - left_idx results.append(count) return results"},{"question":"def first_non_repeating_character(strings): Given a list of strings, return the first non-repeating character in each string. If all characters repeat, return an empty string for that particular string. Parameters: strings (list of str): A list of strings. Returns: list of str: A list of first non-repeating characters. results = [] for s in strings: char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character non_repeating = '' for char in s: if char_count[char] == 1: non_repeating = char break results.append(non_repeating) return results from solution import first_non_repeating_character def test_single_string_no_repeat(): assert first_non_repeating_character(['abc']) == ['a'] def test_single_string_with_repeats(): assert first_non_repeating_character(['abacabad']) == ['c'] def test_single_string_all_repeat(): assert first_non_repeating_character(['aabbcc']) == [''] def test_multiple_strings(): assert first_non_repeating_character(['swiss', 'quick', 'programming', 'aabb']) == ['w', 'q', 'p', ''] def test_empty_strings(): assert first_non_repeating_character(['', '', '']) == ['', '', ''] def test_large_input(): large_string = 'a' * 100000 + 'b' assert first_non_repeating_character([large_string]) == ['b']","solution":"def first_non_repeating_character(strings): Given a list of strings, return the first non-repeating character in each string. If all characters repeat, return an empty string for that particular string. Parameters: strings (list of str): A list of strings. Returns: list of str: A list of first non-repeating characters. results = [] for s in strings: char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character non_repeating = '' for char in s: if char_count[char] == 1: non_repeating = char break results.append(non_repeating) return results"},{"question":"def adjust_scores(scores, X, Y): Adjust the scores by adding Y to scores that are less than or equal to X, capping the total at 10. Arguments: scores -- list of integers representing the initial scores X -- integer threshold Y -- integer amount to add to the scores less than or equal to X Returns: list of integers -- adjusted scores >>> adjust_scores([1, 5, 7, 10, 3], 5, 3) [4, 8, 7, 10, 6] >>> adjust_scores([7, 8, 2, 4], 4, 7) [7, 8, 9, 10]","solution":"def adjust_scores(scores, X, Y): Adjusts the scores by adding Y to scores <= X, capping at 10. Arguments: scores -- list of integers representing the initial scores X -- integer threshold Y -- integer amount to add to the scores less than or equal to X Returns: list of integers -- adjusted scores adjusted_scores = [] for score in scores: if score <= X: adjusted_scores.append(min(score + Y, 10)) else: adjusted_scores.append(score) return adjusted_scores"},{"question":"def max_fenced_area(T: int, test_cases: List[int]) -> List[str]: Jack is taking care of his family's farm, and he wants to build a rectangular fence that has the biggest possible area using exactly N meters of fencing material. Args: T (int): The number of test cases. test_cases (List[int]): A list of integers representing the total length of available fencing material for each test case. Returns: List[str]: A list of strings denoting the case number and the maximum area that can be fenced in square meters. >>> max_fenced_area(1, [8]) == [\\"Case 1: 4\\"] >>> max_fenced_area(2, [8, 12]) == [\\"Case 1: 4\\", \\"Case 2: 9\\"] >>> max_fenced_area(1, [4]) == [\\"Case 1: 1\\"] >>> max_fenced_area(1, [1000000]) == [\\"Case 1: 62500000000\\"]","solution":"def max_fenced_area(T, test_cases): Returns the maximum fenced area for each test case. results = [] for i in range(T): N = test_cases[i] # Since N is the perimeter, maximizing area with N means forming the largest possible square side_length = N // 4 area = side_length ** 2 results.append(f\\"Case {i + 1}: {area}\\") return results"},{"question":"def can_derive(s1: str, s2: str) -> str: Determines if s2 can be derived from s1 by deleting some characters from s1 without changing the order of the remaining characters. :param s1: String from which characters can be deleted :param s2: String to derive :return: \\"YES\\" if s2 can be derived from s1, \\"NO\\" otherwise Examples: >>> can_derive(\\"abcde\\", \\"ace\\") \\"YES\\" >>> can_derive(\\"abcde\\", \\"aec\\") \\"NO\\" >>> can_derive(\\"abc\\", \\"abc\\") \\"YES\\" >>> can_derive(\\"abcdefg\\", \\"hij\\") \\"NO\\" >>> can_derive(\\"abcdabc\\", \\"dabc\\") \\"YES\\"","solution":"def can_derive(s1, s2): Determines if s2 can be derived from s1 by deleting some characters from s1 without changing the order of the remaining characters. :param s1: String from which characters can be deleted :param s2: String to derive :return: \\"YES\\" if s2 can be derived from s1, \\"NO\\" otherwise iter_s1 = iter(s1) return \\"YES\\" if all(char in iter_s1 for char in s2) else \\"NO\\""},{"question":"def min_containers(n: int, w: int, weights: List[int]) -> int: Determine the minimum number of containers required to load all the boxes without exceeding the weight limit of each container. >>> min_containers(3, 10, [3, 5, 7]) 2 >>> min_containers(6, 15, [7, 8, 3, 2, 6, 5]) 3","solution":"from typing import List def min_containers(n: int, w: int, weights: List[int]) -> int: weights.sort(reverse=True) # Sort weights in descending order containers = 0 used = [False] * n for i in range(n): if used[i]: continue current_weight = weights[i] used[i] = True for j in range(i + 1, n): if not used[j] and current_weight + weights[j] <= w: current_weight += weights[j] used[j] = True containers += 1 return containers"},{"question":"class MinHeap: def __init__(self): Initialize a new MinHeap with an empty list for storage. def insert(self, x): Insert an element \`x\` into the heap. Args: x (int): The element to be inserted into the heap. def extract_min(self): Extract and return the smallest element from the heap. Returns: int: The smallest element if the heap is not empty; otherwise, -1. # Example Test Cases def test_insert_and_extract_min(): heap = MinHeap() assert heap.extract_min() == -1 heap.insert(3) heap.insert(1) assert heap.extract_min() == 1 heap.insert(2) assert heap.extract_min() == 2 assert heap.extract_min() == 3 assert heap.extract_min() == -1 def test_multiple_insertions(): heap = MinHeap() for i in range(10, 0, -1): heap.insert(i) for i in range(1, 11): assert heap.extract_min() == i def test_alternating_insert_extract(): heap = MinHeap() heap.insert(5) assert heap.extract_min() == 5 heap.insert(9) heap.insert(3) heap.insert(7) assert heap.extract_min() == 3 assert heap.extract_min() == 7 assert heap.extract_min() == 9 assert heap.extract_min() == -1 def test_large_number_of_operations(): heap = MinHeap() for i in range(1, 1001): heap.insert(i) for i in range(1, 1001): assert heap.extract_min() == i assert heap.extract_min() == -1","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, x): Insert an element into the heap. heapq.heappush(self.heap, x) def extract_min(self): Extract and return the smallest element from the heap. If the heap is empty, return -1. if self.heap: return heapq.heappop(self.heap) else: return -1"},{"question":"from typing import List def smallest_prime_subset_sum(n: int, array: List[int]) -> int: Given an array of integers, determine whether a subset of the array exists whose sum is prime. If such a subset exists, return the smallest prime number that can be obtained, otherwise return -1. >>> smallest_prime_subset_sum(5, [3, 5, 7, -2, 8]) 3 >>> smallest_prime_subset_sum(5, [4, 6, 8, 10, 12]) -1 >>> smallest_prime_subset_sum(1, [7]) 7 >>> smallest_prime_subset_sum(4, [2, 3, 5, 7]) 2 >>> smallest_prime_subset_sum(4, [11, -3, 17, 4]) 11 >>> smallest_prime_subset_sum(4, [101, 103, 107, 109]) 101","solution":"import itertools def is_prime(n): Check if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def smallest_prime_subset_sum(n, array): Determine the smallest prime sum from any subset of the array. primes = set() for size in range(1, len(array)+1): for subset in itertools.combinations(array, size): subset_sum = sum(subset) if is_prime(subset_sum): primes.add(subset_sum) return min(primes) if primes else -1"},{"question":"def longest_distinct_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all distinct elements. >>> longest_distinct_subarray([1, 2, 1, 3, 4, 2, 3]) 4 >>> longest_distinct_subarray([5, 5, 5, 5]) 1 >>> longest_distinct_subarray([7, 8, 9, 1, 2, 1, 3, 4, 8, 9, 10]) 7 pass","solution":"def longest_distinct_subarray(arr): Returns the length of the longest contiguous subarray with all distinct elements. n = len(arr) max_len = 0 left = 0 seen = {} for right in range(n): if arr[right] in seen: # Move the left boundary to the right of the last occurrence of arr[right] left = max(left, seen[arr[right]] + 1) seen[arr[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_sweetness_segment(n: int, m: int, sweetness_values: List[int]) -> int: Find the maximum possible sweetness value of a segment of length m. >>> max_sweetness_segment(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_sweetness_segment(8, 3, [5, 1, 3, 2, 4, 6, 2, 8]) 18 >>> max_sweetness_segment(4, 1, [4, 3, 2, 1]) 4 >>> max_sweetness_segment(3, 3, [1, 3, 5]) 9","solution":"def max_sweetness_segment(n, m, sweetness_values): max_sweetness = sum(sweetness_values[:m]) current_sweetness = max_sweetness for i in range(n - m): current_sweetness = current_sweetness - sweetness_values[i] + sweetness_values[i + m] if current_sweetness > max_sweetness: max_sweetness = current_sweetness return max_sweetness"},{"question":"def min_modifications(N: int, K: int, A: List[int]) -> int: Calculate the minimum number of modifications required for the array A such that all subarrays of length K have distinct products. >>> min_modifications(4, 2, [1, 2, 3, 4]) 0 >>> min_modifications(3, 1, [7, 7, 7]) 2 def process_cases(T: int, cases: List[Dict[str, Union[int, List[int]]]]) -> List[int]: Process multiple test cases and return the results for each case. >>> process_cases(2, [ {'N': 4, 'K': 2, 'A': [1, 2, 3, 4]}, {'N': 3, 'K': 1, 'A': [7, 7, 7]} ]) [0, 2] >>> process_cases(2, [ {'N': 6, 'K': 3, 'A': [1, 2, 3, 4, 5, 6]}, {'N': 4, 'K': 4, 'A': [10, 2, 3, 5]} ]) [0, 0]","solution":"def min_modifications(N, K, A): # Generate product of each subarray of length K product_counts = {} mods = 0 for start in range(N - K + 1): product = 1 for k in range(K): product *= A[start + k] if product in product_counts: product_counts[product] += 1 else: product_counts[product] = 1 # All products should be distinct, count modifications needed for key in product_counts: if product_counts[key] > 1: mods += product_counts[key] - 1 return mods def process_cases(T, cases): results = [] for case in cases: N, K, A = case['N'], case['K'], case['A'] results.append(min_modifications(N, K, A)) return results"},{"question":"def check_ride_safety(ride): Check if the ride is safe to operate based on safety checks. Parameters: ride (dict): A dictionary representing a ride with keys \\"name\\", \\"max_speed\\", \\"duration\\", and \\"safety_checks\\". Returns: str: A string indicating whether the ride is safe to operate. def test_check_ride_safety_all_checks_passed(): ride = { \\"name\\": \\"Thunderbolt\\", \\"max_speed\\": 120, \\"duration\\": 3, \\"safety_checks\\": [ {\\"name\\": \\"Harness check\\", \\"status\\": \\"passed\\"}, {\\"name\\": \\"Brake check\\", \\"status\\": \\"passed\\"}, {\\"name\\": \\"Speed control\\", \\"status\\": \\"passed\\"} ] } assert check_ride_safety(ride) == \\"Thunderbolt is safe to operate.\\" def test_check_ride_safety_some_checks_failed(): ride = { \\"name\\": \\"Thunderbolt\\", \\"max_speed\\": 120, \\"duration\\": 3, \\"safety_checks\\": [ {\\"name\\": \\"Harness check\\", \\"status\\": \\"passed\\"}, {\\"name\\": \\"Brake check\\", \\"status\\": \\"failed\\"}, {\\"name\\": \\"Speed control\\", \\"status\\": \\"passed\\"} ] } assert check_ride_safety(ride) == \\"Thunderbolt is not safe to operate.\\" def test_check_ride_safety_all_checks_failed(): ride = { \\"name\\": \\"Thunderbolt\\", \\"max_speed\\": 120, \\"duration\\": 3, \\"safety_checks\\": [ {\\"name\\": \\"Harness check\\", \\"status\\": \\"failed\\"}, {\\"name\\": \\"Brake check\\", \\"status\\": \\"failed\\"}, {\\"name\\": \\"Speed control\\", \\"status\\": \\"failed\\"} ] } assert check_ride_safety(ride) == \\"Thunderbolt is not safe to operate.\\" def test_check_ride_safety_no_safety_checks(): ride = { \\"name\\": \\"Thunderbolt\\", \\"max_speed\\": 120, \\"duration\\": 3, \\"safety_checks\\": [] } assert check_ride_safety(ride) == \\"Thunderbolt is safe to operate.\\" def test_check_ride_safety_single_check_passed(): ride = { \\"name\\": \\"Thunderbolt\\", \\"max_speed\\": 120, \\"duration\\": 3, \\"safety_checks\\": [ {\\"name\\": \\"Harness check\\", \\"status\\": \\"passed\\"} ] } assert check_ride_safety(ride) == \\"Thunderbolt is safe to operate.\\" def test_check_ride_safety_single_check_failed(): ride = { \\"name\\": \\"Thunderbolt\\", \\"max_speed\\": 120, \\"duration\\": 3, \\"safety_checks\\": [ {\\"name\\": \\"Harness check\\", \\"status\\": \\"failed\\"} ] } assert check_ride_safety(ride) == \\"Thunderbolt is not safe to operate.\\"","solution":"def check_ride_safety(ride): Check if the ride is safe to operate based on safety checks. Parameters: ride (dict): A dictionary representing a ride with keys \\"name\\", \\"max_speed\\", \\"duration\\", and \\"safety_checks\\". Returns: str: A string indicating whether the ride is safe to operate. for check in ride[\\"safety_checks\\"]: if check[\\"status\\"] == \\"failed\\": return f'{ride[\\"name\\"]} is not safe to operate.' return f'{ride[\\"name\\"]} is safe to operate.'"},{"question":"def find_missing_number(s: str) -> int: Given a string of integers in ascending order separated by a single space, determine the missing number in the sequence. >>> find_missing_number(\\"1 2 3 5 6\\") 4 >>> find_missing_number(\\"1 3 4 5\\") 2","solution":"def find_missing_number(s): Given a string of integers in ascending order separated by a single space, determine the missing number in the sequence. numbers = list(map(int, s.split())) for i in range(1, len(numbers)): if numbers[i] != numbers[i - 1] + 1: return numbers[i - 1] + 1 return -1 # This should never happen given the problem constraints"},{"question":"def calculate_trapped_water(n: int, heights: List[int]) -> int: Calculate the total volume of water trapped between columns after a rainfall. Parameters: n (int): Number of columns heights (list): Heights of the columns Returns: int: Total volume of trapped water Examples: >>> calculate_trapped_water(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water(6, [4, 2, 0, 3, 2, 5]) 9","solution":"def calculate_trapped_water(n, heights): Calculate the total volume of water trapped between columns after a rainfall. Parameters: n (int): Number of columns heights (list): Heights of the columns Returns: int: Total volume of trapped water if n <= 2: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def find_winner(test_cases): Determines the winner for each test case in the number sequence game. Parameters: test_cases (list of tuples): Each tuple contains an integer n followed by n non-negative integers. Returns: list: List of winners ('Alex' or 'Jordan') for each test case. # Example Usage: # find_winner([(2, 3, 1)]) -> [\\"Jordan\\"] # find_winner([(4, 1, 7, 5, 2)]) -> [\\"Jordan\\"] # find_winner([(5, 4, 8, 1, 3, 7)]) -> [\\"Alex\\"]","solution":"def find_winner(test_cases): Determines the winner for each test case. Parameters: test_cases (list of tuples): Each tuple contains an integer n followed by n non-negative integers. Returns: list: List of winners ('Alex' or 'Jordan') for each test case. winners = [] for case in test_cases: n, *numbers = case if n % 2 == 0: # If the length of the sequence is even, Jordan will always win winners.append(\\"Jordan\\") else: # If the length of the sequence is odd, Alex will always win winners.append(\\"Alex\\") return winners"},{"question":"def separate_even_odd(numbers): Separates a list of non-negative integers into two lists: one containing even numbers and the other containing odd numbers. Args: numbers (list of int): The list of non-negative integers. Returns: tuple: A tuple containing two lists (even numbers list, odd numbers list). Examples: >>> separate_even_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ([2, 4, 6, 8, 10], [1, 3, 5, 7, 9]) >>> separate_even_odd([2, 4, 6, 8, 10]) ([2, 4, 6, 8, 10], []) >>> separate_even_odd([1, 3, 5, 7, 9]) ([], [1, 3, 5, 7, 9]) >>> separate_even_odd([]) ([], []) >>> separate_even_odd([0, 1]) ([0], [1]) >>> separate_even_odd([1, 0]) ([0], [1]) >>> separate_even_odd([2]) ([2], []) >>> separate_even_odd([3]) ([], [3])","solution":"def separate_even_odd(numbers): Separates a list of non-negative integers into two lists: one containing even numbers and the other containing odd numbers. Args: numbers (list of int): The list of non-negative integers. Returns: tuple: A tuple containing two lists (even numbers list, odd numbers list). evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] return (evens, odds)"},{"question":"def can_form_palindrome(S: str, K: int) -> str: Given a string S and a positive integer K, determine if it's possible to make S a palindrome by deleting exactly K characters from it. Return \\"YES\\" if possible, otherwise return \\"NO\\". >>> can_form_palindrome(\\"abcde\\", 2) \\"NO\\" >>> can_form_palindrome(\\"abbca\\", 1) \\"YES\\" >>> can_form_palindrome(\\"abc\\", 1) \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases and return results for each one. >>> process_test_cases([(\\"abcde\\", 2), (\\"abbca\\", 1), (\\"abc\\", 1)]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> process_test_cases([(\\"radar\\", 0), (\\"a\\", 0), (\\"aa\\", 1)]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_palindrome(S, K): def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] longest_palindrome_length = longest_palindromic_subsequence(S) min_deletions_to_palindrome = len(S) - longest_palindrome_length if min_deletions_to_palindrome == K: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): results = [] for S, K in test_cases: results.append(can_form_palindrome(S, K)) return results"},{"question":"def count_unique_domains(email_addresses: list) -> int: Returns the number of unique domains in the given list of email addresses. >>> count_unique_domains(['alice@example.com', 'bob@example.com', 'charlie@example.org', 'dave@example.com', 'eve@example.org']) == 2 >>> count_unique_domains(['alice@domain1.com', 'bob@domain2.com', 'charlie@domain3.org', 'dave@domain4.com', 'eve@domain5.org']) == 5 >>> count_unique_domains(['test1@domain.com', 'test2@domain.com', 'test3@anotherdomain.com']) == 2 >>> count_unique_domains(['sample@sample.com', 'sample@sample.com', 'sample@sample.com']) == 1 >>> count_unique_domains([]) == 0","solution":"def count_unique_domains(email_addresses): Returns the number of unique domains in the given list of email addresses. unique_domains = set() for email in email_addresses: domain = email.split('@')[1] unique_domains.add(domain) return len(unique_domains)"},{"question":"def schedule_dog_show(dogs_info: List[Tuple[str, str, int]]) -> List[str]: A famous Dog Show organizer needs a program to help manage their show schedules. The program takes a list of tuples where each tuple contains the dog's name, breed, and unique ID. It organizes the dogs by breed and then sorts them by their IDs within each breed. The breeds are presented in alphabetical order and the dogs in ascending order of their IDs. >>> schedule_dog_show([(\\"Buddy\\", \\"GoldenRetriever\\", 2345), (\\"Rocky\\", \\"Bulldog\\", 1456), (\\"Bella\\", \\"Beagle\\", 2901), (\\"Bailey\\", \\"Beagle\\", 3120), (\\"Max\\", \\"GoldenRetriever\\", 2055), (\\"Charlie\\", \\"Bulldog\\", 1984), (\\"Daisy\\", \\"Dalmatian\\", 2222)]) ['Beagle', '2901: Bella', '3120: Bailey', 'Bulldog', '1456: Rocky', '1984: Charlie', 'Dalmatian', '2222: Daisy', 'GoldenRetriever', '2055: Max', '2345: Buddy'] >>> schedule_dog_show([(\\"Buddy\\", \\"Labrador\\", 2345), (\\"Charlie\\", \\"Labrador\\", 1234), (\\"Max\\", \\"Labrador\\", 3456)]) ['Labrador', '1234: Charlie', '2345: Buddy', '3456: Max'] >>> schedule_dog_show([]) [] >>> schedule_dog_show([(\\"Bella\\", \\"Beagle\\", 2901), (\\"Max\\", \\"Beagle\\", 3120)]) ['Beagle', '2901: Bella', '3120: Max'] >>> schedule_dog_show([(\\"Bella\\", \\"Beagle\\", 9001), (\\"Max\\", \\"Beagle\\", 8120), (\\"Charlie\\", \\"Dalmatian\\", 8001), (\\"Rocky\\", \\"Dalmatian\\", 8456)]) ['Beagle', '8120: Max', '9001: Bella', 'Dalmatian', '8001: Charlie', '8456: Rocky']","solution":"def schedule_dog_show(dogs_info): from collections import defaultdict breed_dict = defaultdict(list) # Parse the dogs info into the breed dictionary for name, breed, id in dogs_info: breed_dict[breed].append((id, name)) # Prepare the schedule output schedule = [] for breed in sorted(breed_dict.keys()): schedule.append(breed) for id, name in sorted(breed_dict[breed]): schedule.append(f\\"{id}: {name}\\") return schedule"},{"question":"from typing import List def find_words_in_grid(n: int, grid: List[str], k: int, words: List[str]) -> List[str]: For given square grid of characters and a list of words, determine if each word can be found within the grid. Words can appear in horizontal or vertical directions, either forwards or backwards. Parameters: n (int): The size of the square grid. grid (List[str]): The grid of characters. k (int): The number of words to search for. words (List[str]): The list of words to search within the grid. Returns: List[str]: List containing either 'yes' if the word can be found in the grid or 'no' otherwise. Sample Usage: >>> find_words_in_grid(4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"], 2, [\\"abc\\", \\"ponm\\"]) [\\"yes\\", \\"yes\\"] >>> find_words_in_grid(3, [\\"cat\\", \\"dog\\", \\"pig\\"], 1, [\\"top\\"]) [\\"no\\"]","solution":"def find_word_in_grid(grid, word): Returns 'yes' if the word can be found in the grid in horizontal or vertical directions, either forwards or backwards. Otherwise returns 'no'. n = len(grid) word_len = len(word) # Check horizontally and vertically for i in range(n): # Horizontally forward and backward row = grid[i] if word in row or word[::-1] in row: return 'yes' # Vertically forward and backward col = ''.join([grid[j][i] for j in range(n)]) if word in col or word[::-1] in col: return 'yes' return 'no' def find_words_in_grid(n, grid, k, words): results = [] for word in words: results.append(find_word_in_grid(grid, word)) return results"},{"question":"def closest_sums(arr): Returns the sums of two non-empty contiguous subarrays such that the sum of the first subarray is as close as possible to the sum of the second subarray. >>> closest_sums([1, 2, 3, 4, 5]) (6, 9) >>> closest_sums([1, -1, 2, -2]) (0, 0)","solution":"def closest_sums(arr): Returns the sums of two non-empty contiguous subarrays such that the sum of the first subarray is as close as possible to the sum of the second subarray. n = len(arr) total_sum = sum(arr) min_diff = float('inf') left_sum = 0 for i in range(n - 1): left_sum += arr[i] right_sum = total_sum - left_sum diff = abs(left_sum - right_sum) if diff < min_diff: min_diff = diff closest_left_sum = left_sum closest_right_sum = right_sum return closest_left_sum, closest_right_sum"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"Hello world\\") == False def identify_palindromes(strings: List[str]) -> List[str]: Identifies all palindromes in the given list of strings. >>> identify_palindromes([\\"A man a plan a canal Panama\\", \\"Hello world\\", \\"Was it a car or a cat I saw\\"]) [\\"Palindrome\\", \\"Not a Palindrome\\", \\"Palindrome\\"] # Write code here # Test cases def test_is_palindrome(): assert is_palindrome(\\"A man a plan a canal Panama\\") == True assert is_palindrome(\\"No lemon, no melon\\") == True assert is_palindrome(\\"Hello world\\") == False assert is_palindrome(\\"Was it a car or a cat I saw\\") == True assert is_palindrome(\\"not a palindrome\\") == False assert is_palindrome(\\"Madam, in Eden, I'm Adam.\\") == True def test_identify_palindromes(): strings = [ \\"A man a plan a canal Panama\\", \\"No lemon, no melon\\", \\"Hello world\\", \\"Was it a car or a cat I saw\\", \\"not a palindrome\\" ] expected = [ \\"Palindrome\\", \\"Palindrome\\", \\"Not a Palindrome\\", \\"Palindrome\\", \\"Not a Palindrome\\" ] assert identify_palindromes(strings) == expected","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_string == cleaned_string[::-1] def identify_palindromes(strings): Identifies all palindromes in the given list of strings. results = [] for s in strings: if is_palindrome(s): results.append(\\"Palindrome\\") else: results.append(\\"Not a Palindrome\\") return results"},{"question":"from typing import List def minimizeElevationDifference(grid: List[List[int]]) -> int: Finds a path from top-left to bottom-right such that the maximum elevation difference between any two consecutive cells is minimized. pass # Test cases def test_example_case(): grid = [ [1, 3, 2], [4, 6, 5], [7, 8, 9] ] assert minimizeElevationDifference(grid) == 3 def test_flat_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert minimizeElevationDifference(grid) == 0 def test_large_difference(): grid = [ [1, 1000], [1000, 1] ] assert minimizeElevationDifference(grid) == 999 def test_single_row(): grid = [[1, 2, 3, 4, 5]] assert minimizeElevationDifference(grid) == 1 def test_single_column(): grid = [[1], [2], [3], [4], [5]] assert minimizeElevationDifference(grid) == 1 def test_negative_elevations(): grid = [ [-1, -3, -2], [-4, -6, -5], [-7, -8, -9] ] assert minimizeElevationDifference(grid) == 3 def test_path_around_obstacle(): grid = [ [1, 2, 3], [9, 9, 3], [1, 1, 1] ] assert minimizeElevationDifference(grid) == 2","solution":"import heapq def minimizeElevationDifference(grid): Finds a path from top-left to bottom-right such that the maximum elevation difference between any two consecutive cells is minimized. def isValid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] m, n = len(grid), len(grid[0]) max_diff = [[float('inf')] * n for _ in range(m)] min_heap = [(0, 0, 0)] # (difference, x, y) max_diff[0][0] = 0 while min_heap: diff, x, y = heapq.heappop(min_heap) if x == m - 1 and y == n - 1: return diff for dx, dy in directions: nx, ny = x + dx, y + dy if isValid(nx, ny): new_diff = max(diff, abs(grid[x][y] - grid[nx][ny])) if new_diff < max_diff[nx][ny]: max_diff[nx][ny] = new_diff heapq.heappush(min_heap, (new_diff, nx, ny)) return max_diff[-1][-1]"},{"question":"def find_unpaired_number(arr: List[int]) -> int: Finds the integer that occurs an odd number of times in the list. Args: arr (list): A list of integers. Returns: int: The integer that occurs an odd number of times. >>> find_unpaired_number([20, 1, 1, 2, 2, 20, 2]) 2 >>> find_unpaired_number([4, 5, 5, 4, 5]) 5 >>> find_unpaired_number([10]) 10","solution":"def find_unpaired_number(arr): Finds the integer that occurs an odd number of times in the list. Args: arr (list): A list of integers. Returns: int: The integer that occurs an odd number of times. result = 0 for number in arr: result ^= number return result"},{"question":"def digital_clock(hour, minutes, to_add): Simulates a simple digital clock and returns the new time after adding a given number of minutes. Args: hour (int): The current hour (0-23). minutes (int): The current minutes (0-59). to_add (int): The number of minutes to add. Returns: str: The new time in \\"HH:MM\\" format. >>> digital_clock(23, 45, 80) \\"01:05\\" >>> digital_clock(10, 30, 90) \\"12:00\\" >>> digital_clock(1, 15, 150) \\"03:45\\"","solution":"def digital_clock(hour, minutes, to_add): Simulates a digital clock and returns the new time after adding a given number of minutes. Args: hour (int): The current hour (0-23). minutes (int): The current minutes (0-59). to_add (int): The number of minutes to add. Returns: str: The new time in \\"HH:MM\\" format. total_minutes = hour * 60 + minutes + to_add new_hour = (total_minutes // 60) % 24 new_minutes = total_minutes % 60 return f\\"{new_hour:02}:{new_minutes:02}\\""},{"question":"def process_operations(operations): Processes a list of operations on a set of integers and returns the results of \\"query\\" operations. Args: - operations (list of str): A list where each element is a string representing an operation. Returns: - list of str: A list of results for each \\"query\\" operation, either \\"True\\" or \\"False\\".","solution":"def process_operations(operations): Processes a list of operations on a set of integers and returns the results of \\"query\\" operations. Args: - operations (list of str): A list where each element is a string representing an operation. Returns: - list of str: A list of results for each \\"query\\" operation, either \\"True\\" or \\"False\\". s = set() results = [] for operation in operations: op, x = operation.split() x = int(x) if op == \\"add\\": s.add(x) elif op == \\"remove\\": s.discard(x) elif op == \\"query\\": results.append(str(x in s)) return results"},{"question":"from typing import List, Tuple def find_task_order(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determines a possible order of task completion given tasks and their dependencies. Returns a list of strings with each string representing the task order for a corresponding test case or '-1' if it's not possible to complete all tasks due to cyclic dependencies. Args: T : int : Number of test cases test_cases : List[Tuple[int, int, List[Tuple[int, int]]]] : List of test cases where each test case contains: - an integer N representing the number of tasks - an integer M representing the number of dependency pairs - a list of M tuples where each tuple (u, v) indicates that task v depends on task u Returns: List[str] : List of task completion orders for each test case or '-1' for cyclic dependencies >>> find_task_order(2, [(4, 3, [(1, 2), (1, 3), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)])]) [\\"1 3 4 2\\", \\"-1\\"] >>> find_task_order(1, [(4, 0, [])]) [\\"1 2 3 4\\"]","solution":"from collections import defaultdict, deque def find_task_order(T, test_cases): def topological_sort(N, adj_list): in_degree = [0] * (N + 1) for u in range(1, N + 1): for v in adj_list[u]: in_degree[v] += 1 queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == N: return order else: return -1 results = [] for case in test_cases: N, M, edges = case adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) order = topological_sort(N, adj_list) if order == -1: results.append(\\"-1\\") else: results.append(\\" \\".join(map(str, order))) return results # Reading input is omitted here; for actual usage, read input as per problem statement # and format it into \`test_cases\` list as suitable"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D array to store the number of unique paths to each cell dp = [[1] * n for _ in range(m)] # Iterate through the array starting from (1, 1) because the first row and column can only be reached by one path for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"from typing import List def minAbsSum(arr: List[int]) -> int: Given an array of n integers, find an integer x such that the sum of the absolute differences between x and all the elements in the array is minimized. If there are multiple values of x with the same minimum sum, the smallest x should be chosen. Parameters: arr (List[int]): An array of n integers. Returns: int: An integer x that minimizes the sum of the absolute differences between x and all elements in the array. >>> minAbsSum([1, 2, 3]) 2 >>> minAbsSum([5, 6, 2, 4, 9]) 5 from solution import minAbsSum def test_example_1(): arr = [1, 2, 3] assert minAbsSum(arr) == 2 def test_example_2(): arr = [5, 6, 2, 4, 9] assert minAbsSum(arr) == 5 def test_single_element(): arr = [10] assert minAbsSum(arr) == 10 def test_two_elements(): arr = [1, 2] assert minAbsSum(arr) == 1 def test_large_range(): arr = [-1000000, 1000000, 0] assert minAbsSum(arr) == 0 def test_long_list(): arr = [i for i in range(1, 100001)] assert minAbsSum(arr) == 50000","solution":"def minAbsSum(arr): Returns the integer x such that the sum of the absolute differences between x and all the elements in the array is minimized. If there are multiple values of x with the same minimum sum, the smallest x is chosen. arr.sort() n = len(arr) # The element at the median minimizes the sum of absolute differences median = arr[n // 2] if n % 2 != 0 else arr[n // 2 - 1] return median"},{"question":"def three_sum(nums): Given a list of integers, find all unique triplets in the list which gives the sum of zero. Args: nums (list of int): List of integers. Returns: list of list of int: List of unique triplets that sum up to zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, -2, -1]) [] # your code here def format_triplets(triplets): Utility function to format the triplets for printing. Args: triplets (list of list of int): List of unique triplets. Returns: str: Formatted string representation of triplets. >>> format_triplets([[-1, -1, 2], [-1, 0, 1]]) '-1 -1 2n-1 0 1' # your code here","solution":"def three_sum(nums): Given a list of integers, find all unique triplets in the list which gives the sum of zero. nums.sort() # Sort the array result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i-1]: # Skip duplicates continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: # Found a triplet result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 return result def format_triplets(triplets): Utility function to format the triplets for printing. return \\"n\\".join(\\" \\".join(map(str, triplet)) for triplet in sorted(triplets))"},{"question":"def final_priority(T, test_cases): For given test cases, returns the final priority of the specified task after applying all operations. :param T: Number of test cases :param test_cases: List of test cases where each test case contains: - Number of operations - Task ID to be queried - List of operations (task_id, priority change) :return: List of final priorities for the specified task in each test case >>> T = 2 >>> test_cases = [ ... (3, 2, [(1, 10), (2, 5), (1, -5)]), ... (4, 3, [(1, 15), (3, 7), (2, -3), (3, 2)]) ... ] >>> final_priority(T, test_cases) [5, 9] >>> T = 1 >>> test_cases = [ ... (3, 1, [(1, 0), (1, 0), (1, 0)]) ... ] >>> final_priority(T, test_cases) [0] >>> T = 1 >>> test_cases = [ ... (4, 2, [(2, -10), (2, -20), (2, 5), (2, -5)]) ... ] >>> final_priority(T, test_cases) [-30] >>> T = 1 >>> test_cases = [ ... (5, 3, [(3, 10), (3, -5), (3, 5), (3, -10), (3, 10)]) ... ] >>> final_priority(T, test_cases) [10] >>> T = 1 >>> test_cases = [ ... (5, 3, [(1, 10), (2, 20), (3, 30), (3, -10), (2, -20)]) ... ] >>> final_priority(T, test_cases) [20]","solution":"def final_priority(T, test_cases): For given test cases, returns the final priority of the specified task after applying all operations. :param T: Number of test cases :param test_cases: List of test cases where each test case contains: - Number of operations - Task ID to be queried - List of operations (task_id, priority change) :return: List of final priorities for the specified task in each test case results = [] for i in range(T): N = test_cases[i][0] task_id_to_query = test_cases[i][1] operations = test_cases[i][2] priority_map = {} for op in operations: t_id, change = op if t_id not in priority_map: priority_map[t_id] = 0 priority_map[t_id] += change final_priority = priority_map.get(task_id_to_query, 0) results.append(final_priority) return results"},{"question":"def rearrange_garden(n: int, s: str) -> str: Rearranges the garden such that there are no empty cells between any two non-empty cells, and the order of the remaining cells is preserved with 'P' cells first followed by 'F' cells. >>> rearrange_garden(10, 'P.F..P..F.') == \\"PPFF\\" >>> rearrange_garden(6, 'F.P.F.') == \\"PFF\\" >>> rearrange_garden(5, 'P....') == \\"P\\" >>> rearrange_garden(11, '....P..F.P.') == \\"PPF\\"","solution":"def rearrange_garden(n, s): Rearranges the garden such that there are no empty cells between any two non-empty cells, and the order of the remaining cells is preserved with 'P' cells first followed by 'F' cells. Parameters: n (int): Length of the sequence. s (str): The initial sequence of the garden. Returns: str: The rearranged sequence of the garden. paths = [] flowers = [] for char in s: if char == 'P': paths.append(char) elif char == 'F': flowers.append(char) return ''.join(paths) + ''.join(flowers) # Example usage: # print(rearrange_garden(10, 'P.F..P..F.')) # Output: \\"PPFF\\""},{"question":"def can_schedule_matches(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to schedule matches such that no teams from the same school compete against each other in the first round. >>> can_schedule_matches(3, [(2, [2, 3]), (3, [1, 2, 2]), (1, [4])]) ['Yes', 'Yes', 'No'] >>> can_schedule_matches(2, [(2, [1, 1]), (3, [2, 2, 1])]) ['Yes', 'Yes'] >>> can_schedule_matches(1, [(1, [1000])]) ['No'] pass","solution":"def can_schedule_matches(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] teams = test_cases[i][1] max_teams = max(teams) total_teams = sum(teams) if max_teams <= (total_teams - max_teams + 1): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def canTransform(s1: str, s2: str) -> str: Determine if s1 can be transformed into s2 by reversing any number of substrings any number of times. Both s1 and s2 should be anagrams (i.e., same characters and same number of each character). Args: s1 (str): First input string. s2 (str): Second input string. Returns: str: \\"YES\\" if s1 can be transformed into s2, otherwise \\"NO\\". Examples: >>> canTransform(\\"abc\\", \\"bca\\") \\"YES\\" >>> canTransform(\\"listen\\", \\"silent\\") \\"YES\\" >>> canTransform(\\"abc\\", \\"def\\") \\"NO\\" def test_canTransform(): assert canTransform(\\"abc\\", \\"bca\\") == \\"YES\\" assert canTransform(\\"listen\\", \\"silent\\") == \\"YES\\" assert canTransform(\\"abc\\", \\"def\\") == \\"NO\\" assert canTransform(\\"aabbcc\\", \\"ccbbaa\\") == \\"YES\\" assert canTransform(\\"aabbcc\\", \\"cbbaaa\\") == \\"NO\\" assert canTransform(\\"abcd\\", \\"dcba\\") == \\"YES\\" assert canTransform(\\"a\\", \\"a\\") == \\"YES\\" assert canTransform(\\"ab\\", \\"ba\\") == \\"YES\\" # Additional test cases for edge cases and maximum constraints def test_large_inputs(): assert canTransform(\\"a\\" * 100000, \\"a\\" * 100000) == \\"YES\\" assert canTransform(\\"a\\" * 99999 + \\"b\\", \\"b\\" + \\"a\\" * 99999) == \\"YES\\" assert canTransform(\\"a\\" * 99999 + \\"b\\", \\"a\\" * 100000) == \\"NO\\" # Run tests test_canTransform() test_large_inputs()","solution":"def canTransform(s1, s2): Determine if s1 can be transformed into s2 by reversing any number of substrings any number of times. Both s1 and s2 should be anagrams (i.e., same characters and same number of each character). Args: s1 (str): First input string. s2 (str): Second input string. Returns: str: \\"YES\\" if s1 can be transformed into s2, otherwise \\"NO\\". from collections import Counter # If the sorted strings are equal, both are anagrams of each other if Counter(s1) == Counter(s2): return \\"YES\\" else: return \\"NO\\""},{"question":"def count_improvements(n: int, times: List[List[int]]) -> int: Determine the number of participants who improved their times from previous day. Args: n : int : Number of days the marathon lasts. times : List[List[int]] : A list of lists, where each sublist represents the times taken by the participants on each day. Returns: int : The number of participants who improved their times compared to the previous day. Example: >>> count_improvements(3, [[90, 80, 70], [85, 70, 60], [80, 75, 65]]) 4 >>> count_improvements(2, [[50, 40], [45, 35]]) 2 pass def parse_input(input_str: str) -> Tuple[int, List[List[int]]]: Parse the input string to extract the number of days and the times taken by participants. Args: input_str : str : Input string containing the number of days and times taken by participants. Returns: Tuple[int, List[List[int]]] : The number of days and a list of lists containing the times for each day. Example: >>> parse_input(\\"3n3 90 80 70n3 85 70 60n3 80 75 65\\") (3, [[90, 80, 70], [85, 70, 60], [80, 75, 65]]) >>> parse_input(\\"2n2 50 40n2 45 35\\") (2, [[50, 40], [45, 35]]) pass def main(input_str: str) -> int: Main function to execute the count improvements task based on the given input string. Args: input_str : str : Input string containing the number of days and times taken by participants. Returns: int : The number of participants who improved their times compared to the previous day. Example: >>> main(\\"3n3 90 80 70n3 85 70 60n3 80 75 65\\") 4 >>> main(\\"2n2 50 40n2 45 35\\") 2 pass from typing import List, Tuple def test_case1(): input_str = \\"3n3 90 80 70n3 85 70 60n3 80 75 65\\" assert main(input_str) == 4 def test_case2(): input_str = \\"2n2 50 40n2 45 35\\" assert main(input_str) == 2 def test_case3(): input_str = \\"4n2 100 90n2 95 80n2 90 75n2 85 70\\" assert main(input_str) == 6 def test_case4(): input_str = \\"3n3 90 80 70n3 90 80 70n3 90 80 70\\" assert main(input_str) == 0 def test_case5(): input_str = \\"2n3 5 6 7n3 6 5 4\\" assert main(input_str) == 2","solution":"def count_improvements(n, times): improvements = 0 for i in range(1, n): for j in range(len(times[i])): if times[i-1][j] > times[i][j]: improvements += 1 return improvements def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0]) times = [] for line in lines[1:]: times.append(list(map(int, line.split()[1:]))) return n, times def main(input_str): n, times = parse_input(input_str) return count_improvements(n, times)"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(11) True >>> is_prime(15) False pass def fibonacci_primes(n: int) -> List[int]: Returns the first n Fibonacci primes. >>> fibonacci_primes(1) [2] >>> fibonacci_primes(2) [2, 3] >>> fibonacci_primes(3) [2, 3, 5] >>> fibonacci_primes(4) [2, 3, 5, 13] >>> fibonacci_primes(5) [2, 3, 5, 13, 89] >>> fibonacci_primes(6) [2, 3, 5, 13, 89, 233] pass","solution":"def is_prime(num): Check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i != 0: continue return False return True def fibonacci_generator(): An infinite generator of Fibonacci numbers. a, b = 0, 1 while True: yield a a, b = b, a + b def fibonacci_primes(n): Returns the first n Fibonacci primes. fib_primes = [] for fib_num in fibonacci_generator(): if is_prime(fib_num): fib_primes.append(fib_num) if len(fib_primes) == n: break return fib_primes"},{"question":"def min_cakes_to_sum(total): Returns the minimum number of cakes whose total price is exactly equal to a given total. Each cake price is a power of 3: 3^0, 3^1, 3^2, etc. pass def process_test_cases(t, cases): Processes multiple test cases and returns the results for each one. Args: t (int): The number of test cases. cases (List[int]): A list of total prices for each test case. Returns: List[int]: A list of minimum number of cakes for each total price. pass # Sample Test Cases # You can use these to test if your functions work correctly def test_min_cakes_to_sum(): assert min_cakes_to_sum(13) == 3 assert min_cakes_to_sum(40) == 4 assert min_cakes_to_sum(81) == 1 def test_process_test_cases(): assert process_test_cases(3, [13, 40, 81]) == [3, 4, 1] assert process_test_cases(2, [1, 2]) == [1, 2] assert process_test_cases(1, [729]) == [1] # 729 is 3^6 def test_edge_cases(): assert min_cakes_to_sum(1) == 1 # Testing the minimum value assert min_cakes_to_sum(9) == 1 # Testing a direct power of 3 (3^2) assert min_cakes_to_sum(10) == 2 # 9 (3^2) + 1 (3^0) assert min_cakes_to_sum(27) == 1 # Testing a larger direct power of 3 (3^3) assert min_cakes_to_sum(28) == 2 # 27 (3^3) + 1 (3^0)","solution":"def min_cakes_to_sum(total): Returns the minimum number of cakes whose total price is exactly equal to a given total. Each cake price is a power of 3: 3^0, 3^1, 3^2, etc. cakes = [] power = 1 while power <= total: cakes.append(power) power *= 3 cakes.reverse() count = 0 for cake in cakes: if total == 0: break if total >= cake: count += total // cake total %= cake return count def process_test_cases(t, cases): results = [] for case in cases: results.append(min_cakes_to_sum(case)) return results"},{"question":"def longest_increasing_subsequence_length(n: int, sequence: List[int]) -> int: Calculate the length of the longest contiguous subsequence in which all elements are strictly increasing. >>> longest_increasing_subsequence_length(6, [1, 3, 2, 2, 5, 7]) == 3 >>> longest_increasing_subsequence_length(5, [5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence_length(10, [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]) == 7 >>> longest_increasing_subsequence_length(0, []) == 0 >>> longest_increasing_subsequence_length(1, [5]) == 1 >>> longest_increasing_subsequence_length(5, [3, 3, 3, 3, 3]) == 1 >>> longest_increasing_subsequence_length(6, [1, 2, 3, 4, 5, 6]) == 6 >>> longest_increasing_subsequence_length(4, [4, 3, 2, 1]) == 1","solution":"def longest_increasing_subsequence_length(n, sequence): if n == 0: return 0 longest_length = 1 current_length = 1 for i in range(1, n): if sequence[i] > sequence[i - 1]: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"MOD = 10**9 + 7 def factorial(n: int) -> int: Calculate the factorial of a number n modulo 10**9 + 7. >>> factorial(5) == 120 >>> factorial(0) == 1 pass def mod_inverse(n: int, mod: int) -> int: Calculate the modular inverse of n modulo mod. >>> mod_inverse(3, 1000000007) == 333333336 pass def combination(n: int, k: int) -> int: Calculate the number of ways to choose k items from n items. >>> combination(5, 3) == 10 >>> combination(6, 2) == 15 pass def number_of_ways_to_prepare_dish(N: int, M: int, ingredients: List[int]) -> int: Determine the number of ways to prepare a dish using M ingredients from a list of N distinct ingredients. >>> number_of_ways_to_prepare_dish(5, 3, [1, 2, 3, 4, 5]) == 10 >>> number_of_ways_to_prepare_dish(4, 4, [6, 7, 8, 9]) == 1 pass","solution":"MOD = 10**9 + 7 def factorial(n): result = 1 for i in range(2, n + 1): result = (result * i) % MOD return result def mod_inverse(n, mod): return pow(n, mod-2, mod) def combination(n, k): if k == 0 or k == n: return 1 numerator = factorial(n) denominator = (factorial(k) * factorial(n - k)) % MOD return (numerator * mod_inverse(denominator, MOD)) % MOD def number_of_ways_to_prepare_dish(N, M, ingredients): return combination(N, M) # Example ad-hoc test if __name__ == \\"__main__\\": N = 5 M = 3 ingredients = [1, 2, 3, 4, 5] print(number_of_ways_to_prepare_dish(N, M, ingredients)) # Output should be 10"},{"question":"def sumOfOddIntegers(N: int, Arr: List[int]) -> int: Returns the sum of all the odd integers in the array. Parameters: N (int): The size of the array. Arr (list of int): The array of integers. Returns: int: The sum of all the odd integers in the array. >>> sumOfOddIntegers(5, [1, 2, 3, 4, 5]) 9 >>> sumOfOddIntegers(4, [2, 4, 6, 8]) 0","solution":"def sumOfOddIntegers(N, Arr): Returns the sum of all the odd integers in the array. Parameters: N (int): The size of the array. Arr (list of int): The array of integers. Returns: int: The sum of all the odd integers in the array. odd_sum = 0 for num in Arr: if num % 2 != 0: odd_sum += num return odd_sum"},{"question":"def max_real_coins(coins: List[int]) -> int: Returns the maximum number of real coins collected without collecting any fake coin. Args: coins (List[int]): A list of integers representing the coins that appear every second. Returns: int: The maximum number of real coins collected. Examples: >>> max_real_coins([1, 2, 3, -1, 4, 5]) 3 >>> max_real_coins([1, 2, 3, 4, 5]) 5 >>> max_real_coins([-1, 1, 2, 3]) 0","solution":"def max_real_coins(coins): Returns the maximum number of real coins collected without collecting any fake coin. count = 0 for coin in coins: if coin < 0: break count += 1 return count"},{"question":"def evaluateExpression(s): Evaluate the arithmetic expression in the string according to the operator precedence. Args: s (str): an arithmetic expression containing non-negative integers and the operators +, -, *, and /. Returns: int: the result of the arithmetic expression. >>> evaluateExpression(\\"3+5 / 2\\") 5 >>> evaluateExpression(\\"10 - 4 * 2 + 1\\") 3","solution":"def evaluateExpression(s): Evaluate the arithmetic expression in the string according to the operator precedence. Args: s (str): an arithmetic expression containing non-negative integers and the operators +, -, *, and /. Returns: int: the result of the arithmetic expression. def apply_op(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': # truncating division towards zero values.append(int(left / right)) def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 # stack to store integer values values = [] # stack to store operators operators = [] i = 0 while i < len(s): if s[i] == ' ': i += 1 continue if s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = (val * 10) + int(s[i]) i += 1 values.append(val) # back up the index since it'll be incremented at end of loop i -= 1 elif s[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_op(operators, values) operators.append(s[i]) i += 1 while operators: apply_op(operators, values) return values[-1]"},{"question":"def is_subset_sum(arr, n, k): Determine if there is a subset of the given array with a sum equal to K. >>> is_subset_sum([2, 3, 7, 8], 4, 10) True >>> is_subset_sum([1, 5, 3, 4, 2], 5, 9) True >>> is_subset_sum([1, 2, 3, 4], 4, 12) False >>> is_subset_sum([5], 1, 5) True >>> is_subset_sum([5], 1, 6) False pass def main(): import sys input = sys.stdin.read data = input().split() # Read the number of test cases index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): N = int(data[index]) K = int(data[index+1]) index += 2 array = list(map(int, data[index:index+N])) index += N result = \\"Yes\\" if is_subset_sum(array, N, K) else \\"No\\" results.append(result) for result in results: print(result)","solution":"def is_subset_sum(arr, n, k): # Create a boolean array to store results of subproblems dp = [[False for _ in range(k+1)] for _ in range(n+1)] # If sum is 0, answer is true for i in range(n+1): dp[i][0] = True # Fill dp array in bottom up manner for i in range(1, n+1): for j in range(1, k+1): if j < arr[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] return dp[n][k] def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): N = int(data[index]) K = int(data[index+1]) index += 2 array = list(map(int, data[index:index+N])) index += N result = \\"Yes\\" if is_subset_sum(array, N, K) else \\"No\\" results.append(result) for result in results: print(result)"},{"question":"def can_share_cake(a: int, b: int, c: int) -> str: Determine if it is possible for all three friends to get their desired segments without any overlapping. >>> can_share_cake(90, 90, 180) == \\"Yes\\" >>> can_share_cake(180, 180, 10) == \\"No\\" >>> can_share_cake(120, 120, 120) == \\"Yes\\" >>> can_share_cake(90, 90, 90) == \\"No\\"","solution":"def can_share_cake(a, b, c): Checks if three friends can share a cake with segments of angles a, b, and c degrees without overlapping. if a + b + c == 360: return \\"Yes\\" else: return \\"No\\""},{"question":"def subarray_sum_exists(arr, k): Determines whether there exists a subarray whose sum is exactly k. Args: arr: List[int] - list of positive integers k: int - target sum to find in the subarray Returns: bool - True if such a subarray exists, otherwise False >>> subarray_sum_exists([1, 2, 3, 7, 5], 12) True >>> subarray_sum_exists([1, 2, 3, 7, 5], 15) True >>> subarray_sum_exists([1, 2, 1, 3, 0, 2], 9) True >>> subarray_sum_exists([1, 2, 3, 4, 5], 20) False >>> subarray_sum_exists([5], 5) True >>> subarray_sum_exists([], 1) False >>> subarray_sum_exists([10, 11, 12, 13, 14], 5) False # Your code here","solution":"def subarray_sum_exists(arr, k): Determines whether there exists a subarray whose sum is exactly k. Args: arr: List[int] - list of positive integers k: int - target sum to find in the subarray Returns: bool - True if such a subarray exists, otherwise False n = len(arr) current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k and start <= end: current_sum -= arr[start] start += 1 if current_sum == k: return True return False"},{"question":"from typing import List def find_drum_sequences(n: int) -> int: Function to determine the number of valid drum beat sequences of length n. Each beat can be either a short beat or a long beat, and no two long beats can be consecutive. >>> find_drum_sequences(1) 2 >>> find_drum_sequences(2) 3 >>> find_drum_sequences(3) 5 pass def solve(T: int, cases: List[int]) -> List[int]: Function to handle multiple test cases and return the results. >>> solve(3, [1, 2, 3]) [2, 3, 5] >>> solve(1, [4]) [8] >>> solve(2, [5, 6]) [13, 21] pass from solution import find_drum_sequences, solve def test_find_drum_sequences(): assert find_drum_sequences(1) == 2 assert find_drum_sequences(2) == 3 assert find_drum_sequences(3) == 5 assert find_drum_sequences(4) == 8 assert find_drum_sequences(5) == 13 assert find_drum_sequences(6) == 21 # These are the Fibonacci sequence values offset by one def test_solve(): assert solve(3, [1, 2, 3]) == [2, 3, 5] assert solve(1, [4]) == [8] assert solve(2, [5, 6]) == [13, 21] assert solve(4, [1, 2, 3, 4]) == [2, 3, 5, 8]","solution":"def find_drum_sequences(n): Function to determine the number of valid drum beat sequences of length n if n == 1: return 2 if n == 2: return 3 # dp[i] will store the number of valid sequences of length i dp = [0] * (n + 1) dp[1] = 2 # (short), (long) dp[2] = 3 # (short, short), (short, long), (long, short) # Use dynamic programming to fill the dp array for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def solve(T, cases): Function to handle multiple test cases and return the results results = [] for n in cases: results.append(find_drum_sequences(n)) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. >>> list_from_linked_list(merge_two_sorted_lists(linked_list_from_list([1, 3, 5, 7, 9]), linked_list_from_list([2, 4, 6, 8]))) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list_from_linked_list(merge_two_sorted_lists(linked_list_from_list([]), linked_list_from_list([2, 4, 6, 8]))) [2, 4, 6, 8] >>> list_from_linked_list(merge_two_sorted_lists(linked_list_from_list([1, 3, 5, 7, 9]), linked_list_from_list([]))) [1, 3, 5, 7, 9] >>> list_from_linked_list(merge_two_sorted_lists(linked_list_from_list([1]), linked_list_from_list([2]))) [1, 2] >>> list_from_linked_list(merge_two_sorted_lists(linked_list_from_list([1, 3, 5]), linked_list_from_list([1, 3, 5]))) [1, 1, 3, 3, 5, 5] >>> list_from_linked_list(merge_two_sorted_lists(linked_list_from_list([1, 1, 1]), linked_list_from_list([1, 1, 1]))) [1, 1, 1, 1, 1, 1] pass def linked_list_from_list(lst): dummy = current = ListNode() for val in lst: current.next = ListNode(val) current = current.next return dummy.next def list_from_linked_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst def merge_sorted_linked_lists(arr1, arr2): l1 = linked_list_from_list(arr1) l2 = linked_list_from_list(arr2) merged = merge_two_sorted_lists(l1, l2) return list_from_linked_list(merged)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = current = ListNode() while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next def linked_list_from_list(lst): dummy = current = ListNode() for val in lst: current.next = ListNode(val) current = current.next return dummy.next def list_from_linked_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst def merge_sorted_linked_lists(arr1, arr2): l1 = linked_list_from_list(arr1) l2 = linked_list_from_list(arr2) merged = merge_two_sorted_lists(l1, l2) return list_from_linked_list(merged)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string and returns the result as an integer. The expression can include addition (+), subtraction (-), multiplication (*), and division (/). The function respects the standard operator precedence rules. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"10-3\\") == 7 >>> evaluate_expression(\\"4*5\\") == 20 >>> evaluate_expression(\\"20/4\\") == 5 >>> evaluate_expression(\\"2+3*2\\") == 8 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"100*2+12\\") == 212 >>> evaluate_expression(\\"100*(2+12)\\") == 1400 >>> evaluate_expression(\\"(2+3)*4\\") == 20 >>> evaluate_expression(\\"20+4/2\\") == 22 >>> evaluate_expression(\\"20/(5-3)\\") == 10 return eval(expression)","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string and returns the result as an integer. The expression can include addition (+), subtraction (-), multiplication (*), and division (/). The function respects the standard operator precedence rules. return eval(expression)"},{"question":"def has_triplet_sum(nums, target): Determines if there are three distinct numbers in the list that add up to the target integer. Returns 'Yes' if such a triplet exists, and 'No' otherwise. Args: nums : List[int] - list of integers. target : int - target integer. Returns: str - 'Yes' or 'No'. pass def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:n+1])) target = int(data[n+1]) print(has_triplet_sum(nums, target))","solution":"def has_triplet_sum(nums, target): Determines if there are three distinct numbers in the list that add up to the target integer. Returns 'Yes' if such a triplet exists, and 'No' otherwise. Args: nums : List[int] - list of integers. target : int - target integer. Returns: str - 'Yes' or 'No'. nums.sort() n = len(nums) for i in range(n): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return \\"Yes\\" elif current_sum < target: left += 1 else: right -= 1 return \\"No\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:n+1])) target = int(data[n+1]) print(has_triplet_sum(nums, target))"},{"question":"def longest_equal_subsequence_length(n: int, sequence: List[int]) -> int: Returns the length of the longest subsequence where all elements are equal. Parameters: n (int): the number of elements in the sequence. sequence (list): the list of integers in the sequence. Returns: int: the length of the longest subsequence where all elements are equal. >>> longest_equal_subsequence_length(6, [1, 2, 2, 3, 2, 4]) 3 >>> longest_equal_subsequence_length(4, [2, 2, 2, 2]) 4 >>> longest_equal_subsequence_length(5, [1, 2, 3, 4, 5]) 1 >>> longest_equal_subsequence_length(0, []) 0","solution":"def longest_equal_subsequence_length(n, sequence): Returns the length of the longest subsequence where all elements are equal. Parameters: n (int): the number of elements in the sequence. sequence (list): the list of integers in the sequence. Returns: int: the length of the longest subsequence where all elements are equal. if n == 0: return 0 element_count = {} for number in sequence: if number in element_count: element_count[number] += 1 else: element_count[number] = 1 return max(element_count.values())"},{"question":"def find_two_sum_indices(n, array, target): Given an array of integers, find the two numbers such that they add up to a specific target number. Return the indices of the two numbers (1-based) that add up to target. :param n: int - the number of elements in the array :param array: list - a list of integers :param target: int - the target sum :return: tuple - indices (1-based) of the two numbers that add up to target >>> find_two_sum_indices(4, [2, 7, 11, 15], 9) (1, 2) >>> find_two_sum_indices(5, [-1, -2, -3, -4, -5], -8) (3, 5) >>> find_two_sum_indices(4, [-1, 2, 3, -4], -5) (1, 4) >>> find_two_sum_indices(4, [3, 3, 4, 4], 6) (1, 2) >>> find_two_sum_indices(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 19) (9, 10)","solution":"def find_two_sum_indices(n, array, target): Given an array of integers, find the two numbers such that they add up to a specific target number. Return the indices of the two numbers (1-based) that add up to target. :param n: int - the number of elements in the array :param array: list - a list of integers :param target: int - the target sum :return: tuple - indices (1-based) of the two numbers that add up to target lookup = {} for i in range(n): complement = target - array[i] if complement in lookup: return (lookup[complement] + 1, i + 1) lookup[array[i]] = i"},{"question":"from typing import List def areAnagrams(N: int, words: List[str], pairs: List[List[int]]) -> List[bool]: Geek is given a list of N (not necessarily distinct) words. For each pair of words, he wants to know if they are anagrams of each other. Your task is to return a list of boolean values indicating whether each pair (i, j) is an anagram, where 1  i, j  N. >>> areAnagrams(4, [\\"listen\\", \\"silent\\", \\"rock\\", \\"cork\\"], [[1, 2], [3, 4], [1, 3]]) [True, True, False] >>> areAnagrams(3, [\\"cat\\", \\"tac\\", \\"dog\\"], [[1, 2], [1, 3]]) [True, False]","solution":"from typing import List def areAnagrams(N: int, words: List[str], pairs: List[List[int]]) -> List[bool]: def sorted_word(word): return ''.join(sorted(word)) sorted_words = [sorted_word(word) for word in words] results = [] for i, j in pairs: results.append(sorted_words[i-1] == sorted_words[j-1]) return results"},{"question":"def num_islands(grid: List[str]) -> int: Find the number of distinct islands in a grid. >>> num_islands([\\"11110\\", \\"11010\\", \\"11000\\", \\"00001\\"]) 2 >>> num_islands([\\"111\\", \\"010\\", \\"111\\"]) 1 def count_islands(test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Get the number of distinct islands for multiple test cases. >>> count_islands([(4, 5, [\\"11110\\", \\"11010\\", \\"11000\\", \\"00001\\"]), (3, 3, [\\"111\\", \\"010\\", \\"111\\"])]) [2, 1] def parse_input(input_str: str) -> List[Tuple[int, int, List[str]]]: Parse input into a list of test cases. >>> parse_input(\\"2n4 5n11110n11010n11000n00001n3 3n111n010n111n\\") [(4, 5, [\\"11110\\", \\"11010\\", \\"11000\\", \\"00001\\"]), (3, 3, [\\"111\\", \\"010\\", \\"111\\"])] def main(input_str: str) -> List[int]: Main function to parse input and get the number of distinct islands for each test case. >>> main(\\"2n4 5n11110n11010n11000n00001n3 3n111n010n111n\\") [2, 1]","solution":"def num_islands(grid): if not grid: return 0 n, m = len(grid), len(grid[0]) visited = [[False for _ in range(m)] for _ in range(n)] def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '0' or visited[x][y]: return visited[x][y] = True # Check all 8 directions including diagonals directions = [(-1,0), (1,0), (0,-1), (0,1), (-1,-1), (-1,1), (1,-1), (1,1)] for dx, dy in directions: dfs(x + dx, y + dy) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count def count_islands(test_cases): results = [] for n, m, grid in test_cases: results.append(num_islands(grid)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n, m = map(int, lines[index].split()) grid = [lines[index + 1 + i] for i in range(n)] test_cases.append((n, m, grid)) index += n + 1 return test_cases def main(input_str): test_cases = parse_input(input_str) results = count_islands(test_cases) return results"},{"question":"def can_form_palindrome(s: str) -> str: Checks if the given string s can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") == \\"Yes\\" >>> can_form_palindrome(\\"ivicc\\") == \\"Yes\\" >>> can_form_palindrome(\\"hello\\") == \\"No\\" >>> can_form_palindrome(\\"\\") == \\"Yes\\" >>> can_form_palindrome(\\"a\\") == \\"Yes\\" >>> can_form_palindrome(\\"aa\\") == \\"Yes\\" >>> can_form_palindrome(\\"ab\\") == \\"No\\" >>> can_form_palindrome(\\"aaabbb\\") == \\"No\\" >>> can_form_palindrome(\\"aaabb\\") == \\"Yes\\" >>> can_form_palindrome(\\"aabbcc\\") == \\"Yes\\" >>> can_form_palindrome(\\"aabc\\") == \\"No\\" >>> can_form_palindrome(\\"abab\\") == \\"Yes\\" >>> can_form_palindrome(\\"aabba\\") == \\"Yes\\" >>> can_form_palindrome(\\"abcba\\") == \\"Yes\\" pass def palindromic_rearrangement(t: int, test_cases: List[str]) -> List[str]: Given t test cases, determine if each string can be rearranged to form a palindrome. Returns a list of \\"Yes\\" or \\"No\\" for each test case. pass","solution":"def can_form_palindrome(s): Checks if the given string s can be rearranged to form a palindrome. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can be rearranged to form a palindrome if it has at most one character with an odd count if odd_count <= 1: return \\"Yes\\" else: return \\"No\\" # Handling multiple test cases def palindromic_rearrangement(t, test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results # Read input def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = data[1:] results = palindromic_rearrangement(t, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def make_palindrome(s: str) -> str: Returns \\"YES\\" if it is possible to make the string a palindrome by removing at most one character, otherwise returns \\"NO\\". >>> make_palindrome(\\"abca\\") \\"YES\\" >>> make_palindrome(\\"abcba\\") \\"YES\\" >>> make_palindrome(\\"abc\\") \\"NO\\" >>> make_palindrome(\\"a\\") \\"YES\\"","solution":"def make_palindrome(s): Returns \\"YES\\" if it is possible to make the string a palindrome by removing at most one character, otherwise returns \\"NO\\". def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True length = len(s) left, right = 0, length - 1 while left < right: if s[left] != s[right]: # Try removing either left or right character if is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\" # The string is already a palindrome"},{"question":"def can_fulfill_requests(B, C, capacities, customer_requests): Determine if all customer requests can be fulfilled given the storage capacities of each block and customer preferences. Arguments: B -- number of blocks C -- number of customer requests capacities -- list of capacities of each block customer_requests -- list of customer requests represented as tuples (units_needed, preferred_blocks) Returns: \\"YES\\" if all customer requests can be fulfilled. Otherwise, \\"NO\\". pass def parse_input(input_str): Parse the input string to extract the number of blocks, number of customer requests, capacities list, and customer requests list. Arguments: input_str -- input string Returns: B -- number of blocks C -- number of customer requests capacities -- list of capacities of each block customer_requests -- list of customer requests represented as tuples (units_needed, preferred_blocks) pass from solution import can_fulfill_requests, parse_input def test_parse_input(): input_str = \\"3 3n10 15 12n5 1 2n7 2 3n8 1 3 2n\\" B, C, capacities, customer_requests = parse_input(input_str) assert B == 3 assert C == 3 assert capacities == [10, 15, 12] assert customer_requests == [ (5, [1, 2]), (7, [2, 3]), (8, [1, 3, 2]) ] def test_example_case(): input_str = \\"3 3n10 15 12n5 1 2n7 2 3n8 1 3 2n\\" B, C, capacities, customer_requests = parse_input(input_str) assert can_fulfill_requests(B, C, capacities, customer_requests) == \\"YES\\" def test_case_cannot_fulfill(): input_str = \\"2 2n5 5n6 1 2n4 1 2n\\" B, C, capacities, customer_requests = parse_input(input_str) assert can_fulfill_requests(B, C, capacities, customer_requests) == \\"NO\\" def test_case_exact_capacity(): input_str = \\"2 2n5 5n5 1n5 2n\\" B, C, capacities, customer_requests = parse_input(input_str) assert can_fulfill_requests(B, C, capacities, customer_requests) == \\"YES\\" def test_case_single_block_preference(): input_str = \\"3 2n5 5 5n3 1n4 2n\\" B, C, capacities, customer_requests = parse_input(input_str) assert can_fulfill_requests(B, C, capacities, customer_requests) == \\"YES\\" def test_case_multiple_requests_single_block(): input_str = \\"1 2n10n5 1n4 1n\\" B, C, capacities, customer_requests = parse_input(input_str) assert can_fulfill_requests(B, C, capacities, customer_requests) == \\"YES\\"","solution":"def can_fulfill_requests(B, C, capacities, customer_requests): # Convert capacities list to a dict to easily manage capacity changes block_capacity = {i+1: capacities[i] for i in range(B)} customer_requests.sort(key=lambda x: len(x[1])) # Sort by the number of preferred blocks for units_needed, preferred_blocks in customer_requests: allocated = False for block in preferred_blocks: if block_capacity[block] >= units_needed: block_capacity[block] -= units_needed allocated = True break if not allocated: return \\"NO\\" return \\"YES\\" # Function to parse the input as described in the problem statement def parse_input(input_str): input_lines = input_str.strip().split('n') B, C = map(int, input_lines[0].split()) capacities = list(map(int, input_lines[1].split())) customer_requests = [] for i in range(2, 2 + C): parts = list(map(int, input_lines[i].split())) units_needed = parts[0] preferred_blocks = parts[1:] customer_requests.append((units_needed, preferred_blocks)) return B, C, capacities, customer_requests"},{"question":"from typing import List def min_sub_array_len(target: int, nums: List[int]) -> int: Returns the length of the shortest subarray whose sum is at least the target value. :param target: Integer representing the target sum. :param nums: List of integers from which we need to find the subarray. :return: Length of the shortest subarray whose sum is at least the target value. If no such subarray exists, return 0. >>> min_sub_array_len(7, [2,3,1,2,4,3]) 2 >>> min_sub_array_len(15, [1,2,3,4,5]) 5 >>> min_sub_array_len(100, [1,2,3,4,5]) 0 >>> min_sub_array_len(4, [1,4,4]) 1 from solution import min_sub_array_len def test_example_1(): assert min_sub_array_len(7, [2,3,1,2,4,3]) == 2 def test_example_2(): assert min_sub_array_len(15, [1,2,3,4,5]) == 5 def test_no_such_subarray(): assert min_sub_array_len(100, [1,2,3,4,5]) == 0 def test_single_element_subarray(): assert min_sub_array_len(4, [1,4,4]) == 1 def test_all_elements_needed(): assert min_sub_array_len(6, [1,2,1,1,1]) == 5 def test_large_numbers(): assert min_sub_array_len(100000, [50000, 50000, 50000]) == 2 def test_single_element_equals_target(): assert min_sub_array_len(10, [2, 10, 3, 1, 1]) == 1 def test_multiple_possible_subarrays(): assert min_sub_array_len(6, [2, 3, 1, 2, 4, 3]) == 2","solution":"def min_sub_array_len(target, nums): Returns the length of the shortest subarray whose sum is at least the target value. :param target: Integer representing the target sum. :param nums: List of integers from which we need to find the subarray. :return: Length of the shortest subarray whose sum is at least the target value. If no such subarray exists, return 0. n = len(nums) left = 0 current_sum = 0 min_len = float('inf') for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"def min_swaps_to_increasing_sequence(array): Returns the minimum number of swaps required to transform the array into a strictly increasing sequence. >>> min_swaps_to_increasing_sequence([4, 3, 1, 2, 5]) 3 >>> min_swaps_to_increasing_sequence([4, 3, 2, 1]) 2 >>> min_swaps_to_increasing_sequence([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_increasing_sequence([5, 4, 3, 2, 1]) 2 >>> min_swaps_to_increasing_sequence([42]) 0 >>> min_swaps_to_increasing_sequence([1, 3, 2, 4]) 1 >>> min_swaps_to_increasing_sequence([7, 3, 4, 1, 5, 6, 2]) 4","solution":"def min_swaps_to_increasing_sequence(array): Returns the minimum number of swaps required to transform the array into a strictly increasing sequence. n = len(array) sorted_array = sorted(array) index_dict = {value: i for i, value in enumerate(array)} swaps = 0 for i in range(n): while array[i] != sorted_array[i]: swaps += 1 # Swap the current element with the element at the position of sorted_array[i] swap_idx = index_dict[sorted_array[i]] array[i], array[swap_idx] = array[swap_idx], array[i] # Update the indices in the index dictionary index_dict[array[swap_idx]] = swap_idx index_dict[array[i]] = i return swaps"},{"question":"def multiply(num1: str, num2: str) -> str: Multiplies two non-negative integer numbers represented as strings. >>> multiply(\\"123\\", \\"456\\") \\"56088\\" >>> multiply(\\"999\\", \\"999\\") \\"998001\\" >>> multiply(\\"0\\", \\"1234\\") \\"0\\" >>> multiply(\\"1234\\", \\"0\\") \\"0\\" >>> multiply(\\"2\\", \\"3\\") \\"6\\" >>> multiply(\\"5\\", \\"5\\") \\"25\\" >>> multiply(\\"123456789\\", \\"987654321\\") \\"121932631112635269\\" >>> multiply(\\"123\\", \\"45\\") \\"5535\\" >>> multiply(\\"12\\", \\"3456\\") \\"41472\\"","solution":"def multiply(num1, num2): Multiplies two non-negative integer numbers represented as strings. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1-1, -1, -1): for j in range(len2-1, -1, -1): product = int(num1[i]) * int(num2[j]) p1, p2 = i + j, i + j + 1 sum = product + result[p2] result[p1] += sum // 10 result[p2] = sum % 10 # Convert result list to string and skip leading zeros result_str = ''.join(map(str, result)).lstrip('0') return result_str"},{"question":"def maxItems(prices: List[int], budget: int) -> int: Determines the maximum number of items that can be purchased without exceeding the budget. Parameters: prices (list of int): List of prices for the items. budget (int): Available budget. Returns: int: Maximum number of items that can be purchased. >>> maxItems([1, 12, 5, 111, 200, 1000, 10], 50) 4 >>> maxItems([20, 10, 5, 30, 100], 35) 3 >>> maxItems([4, 5, 3, 2, 1], 10) 4 >>> maxItems([1, 2, 3, 4, 5], 0) 0 >>> maxItems([10], 5) 0 >>> maxItems([10], 10) 1 >>> maxItems([10], 15) 1 >>> maxItems([5, 5, 5, 5, 5], 25) 5 >>> maxItems([5, 5, 5, 5, 5], 20) 4 >>> maxItems([5, 5, 5, 5, 5], 15) 3 >>> maxItems([4, 5, 3, 2, 1], 100) 5 >>> maxItems([50, 60, 70, 80, 90], 45) 0","solution":"def maxItems(prices, budget): Determines the maximum number of items that can be purchased without exceeding the budget. Parameters: prices (list of int): List of prices for the items. budget (int): Available budget. Returns: int: Maximum number of items that can be purchased. prices.sort() total_spent = 0 count = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"def minimum_maximum_distance(n: int, city_map: List[str]) -> int: Find the optimal location for a school in a grid-based city map in such a way that the maximum distance from any building to the school is minimized. Args: n (int): the size of the grid city_map (List[str]): a list of n strings, each string representing a row in the city map where 'B' is a building and '.' is an empty plot Returns: int: the minimum possible maximum distance from any building to the newly built school Examples: >>> minimum_maximum_distance(3, [\\"B..\\", \\"...\\", \\"..B\\"]) 2 >>> minimum_maximum_distance(2, [\\"B.\\", \\".B\\"]) 1","solution":"def minimum_maximum_distance(n, city_map): def calculate_max_distance(sx, sy): max_distance = 0 for x in range(n): for y in range(n): if city_map[x][y] == 'B': max_distance = max(max_distance, abs(sx - x) + abs(sy - y)) return max_distance min_max_distance = float('inf') for i in range(n): for j in range(n): if city_map[i][j] == '.': min_max_distance = min(min_max_distance, calculate_max_distance(i, j)) return min_max_distance # Example usage: n = 3 city_map = [ \\"B..\\", \\"...\\", \\"..B\\" ] print(minimum_maximum_distance(n, city_map)) # Output: 2"},{"question":"def firstDuplicate(arr: List[int]) -> int: Find the first duplicate for which the second occurrence has the minimal index. :param arr: An array of integers :type arr: List[int] :return: The first duplicate number or -1 if no duplicates are found :rtype: int >>> firstDuplicate([2, 1, 3, 5, 3, 2]) 3 >>> firstDuplicate([2, 1, 3, 5, 6, 1]) 1 >>> firstDuplicate([1, 2, 3, 4, 5]) -1 pass","solution":"def firstDuplicate(arr): Find the first duplicate for which the second occurrence has the minimal index. :param arr: An array of integers :type arr: List[int] :return: The first duplicate number or -1 if no duplicates are found :rtype: int seen = set() for num in arr: if num in seen: return num seen.add(num) return -1"},{"question":"def catalog_artifacts(n, q, artifacts, categories, queries): Catalogs artifacts and retrieves them by category based on queries. Args: - n (int): Number of artifacts. - q (int): Number of queries. - artifacts (list of str): List of artifact names. - categories (list of str): List of corresponding categories. - queries (list of str): List of category queries. Returns: - List of str: Each string is a space-separated list of artifacts for a query. pass from solution import catalog_artifacts def test_catalog_artifacts_example(): n = 5 q = 3 artifacts = [\\"artifact1\\", \\"artifact2\\", \\"artifact3\\", \\"artifact4\\", \\"artifact5\\"] categories = [\\"category1\\", \\"category2\\", \\"category1\\", \\"category3\\", \\"category2\\"] queries = [\\"category1\\", \\"category2\\", \\"category4\\"] expected_output = [\\"artifact1 artifact3\\", \\"artifact2 artifact5\\", \\"None\\"] assert catalog_artifacts(n, q, artifacts, categories, queries) == expected_output def test_catalog_artifacts_single_entry(): n = 1 q = 1 artifacts = [\\"artifact1\\"] categories = [\\"category1\\"] queries = [\\"category1\\"] expected_output = [\\"artifact1\\"] assert catalog_artifacts(n, q, artifacts, categories, queries) == expected_output def test_catalog_artifacts_no_matching_category(): n = 2 q = 2 artifacts = [\\"artifact1\\", \\"artifact2\\"] categories = [\\"category1\\", \\"category2\\"] queries = [\\"category3\\", \\"category4\\"] expected_output = [\\"None\\", \\"None\\"] assert catalog_artifacts(n, q, artifacts, categories, queries) == expected_output def test_catalog_artifacts_multiple_queries_same_category(): n = 4 q = 2 artifacts = [\\"artifact1\\", \\"artifact2\\", \\"artifact3\\", \\"artifact4\\"] categories = [\\"category1\\", \\"category2\\", \\"category1\\", \\"category2\\"] queries = [\\"category1\\", \\"category1\\"] expected_output = [\\"artifact1 artifact3\\", \\"artifact1 artifact3\\"] assert catalog_artifacts(n, q, artifacts, categories, queries) == expected_output def test_catalog_artifacts_empty_cases(): n = 0 q = 1 artifacts = [] categories = [] queries = [\\"category1\\"] expected_output = [\\"None\\"] assert catalog_artifacts(n, q, artifacts, categories, queries) == expected_output","solution":"def catalog_artifacts(n, q, artifacts, categories, queries): Catalogs artifacts and retrieves them by category based on queries. Args: - n (int): Number of artifacts. - q (int): Number of queries. - artifacts (list of str): List of artifact names. - categories (list of str): List of corresponding categories. - queries (list of str): List of category queries. Returns: - List of str: Each string is a space-separated list of artifacts for a query. catalog = {} # Building the catalog for i in range(n): category = categories[i] artifact = artifacts[i] if category not in catalog: catalog[category] = [] catalog[category].append(artifact) # Retrieving results based on queries results = [] for query in queries: if query in catalog: results.append(\\" \\".join(catalog[query])) else: results.append(\\"None\\") return results"},{"question":"def format_item_name(item_name: str) -> str: Formats the item name by removing leading or trailing spaces and ensuring there is only one space between words. >>> format_item_name(\\" luxury sofa set \\") \\"luxury sofa set\\" >>> format_item_name(\\" antique clock \\") \\"antique clock\\" >>> format_item_name(\\"vintage mirror\\") \\"vintage mirror\\" >>> format_item_name(\\" elegant table \\") \\"elegant table\\" >>> format_item_name(\\"\\") \\"\\" >>> format_item_name(\\" chair \\") \\"chair\\"","solution":"def format_item_name(item_name): Formats the item name by removing leading or trailing spaces and ensuring there is only one space between words. # Split the string by whitespace and join with single spaces return \\" \\".join(item_name.split())"},{"question":"def doors_remaining_open(k: int) -> int: Determine how many doors remain open after k operations. >>> doors_remaining_open(1) 1 >>> doors_remaining_open(2) 1 >>> doors_remaining_open(5) 2 >>> doors_remaining_open(10) 3 >>> doors_remaining_open(1000000) 1000 >>> doors_remaining_open(8) 2","solution":"def doors_remaining_open(k): Determine how many doors remain open after k operations. Parameters: k (int): Number of doors Dr. X operates on. Returns: int: Number of doors that remain open. # All doors that are \\"perfect squares\\" will remain open. # The number of perfect squares <= k is the integer part of the square root of k import math return int(math.sqrt(k))"},{"question":"from typing import List def push_boxes_to_left(n: int, m: int, grid: List[str]) -> List[str]: Transform the grid by pushing all the boxes to the left in each row. >>> push_boxes_to_left(3, 5, [\\"..x.x\\", \\"x..x.\\", \\".x.x.\\"]) [\\"xx...\\", \\"xx...\\", \\"xx...\\"] >>> push_boxes_to_left(2, 6, [\\"......\\", \\"..xx..\\"]) [\\"......\\", \\"xx....\\"]","solution":"from typing import List def push_boxes_to_left(n: int, m: int, grid: List[str]) -> List[str]: result = [] for row in grid: # Count the number of 'x' in the row box_count = row.count('x') # Create the new row with all 'x' at the left and '.' at the right new_row = 'x' * box_count + '.' * (m - box_count) result.append(new_row) return result"},{"question":"def total_books_ordered(N: int, orders: List[str]) -> int: Returns the total number of books ordered from a list of orders. Args: N(int): Number of orders. orders(list of str): List containing book titles and quantities in the format \\"Book Title Q\\". Returns: int: Total number of books ordered. >>> total_books_ordered(3, [\\"Introduction to Algorithms 5\\", \\"Clean Code 2\\", \\"Design Patterns 3\\"]) 10 >>> total_books_ordered(1, [\\"Single Book 1\\"]) 1 >>> total_books_ordered(2, [\\"Book One 9999\\", \\"Book Two 1\\"]) 10000 >>> total_books_ordered(1, [\\"Tiny Book 1\\"]) 1 >>> total_books_ordered(100, [f\\"Book {i} 10000\\" for i in range(1, 101)]) 1000000 >>> total_books_ordered(2, [\\"Mixed CASE book 123\\", \\"Another Title 456\\"]) 579","solution":"def total_books_ordered(N, orders): Returns the total number of books ordered from a list of orders. Args: N(int): Number of orders. orders(list of str): List containing book titles and quantities in the format \\"Book Title Q\\". Returns: int: Total number of books ordered. total = 0 for order in orders: data = order.split() quantity = int(data[-1]) total += quantity return total # Example usage: # total_books_ordered(3, [\\"Introduction to Algorithms 5\\", \\"Clean Code 2\\", \\"Design Patterns 3\\"])"},{"question":"def find_combinations(nums: List[int], target: int) -> List[List[int]]: Finds all unique combinations of integers from the list nums that sum up to the target. Each number in the list can only be used once in each combination. >>> find_combinations([2, 3, 6, 7], 7) [[7]] >>> find_combinations([2, 3, 5], 8) [[3, 5]] >>> find_combinations([2, 4, 6, 8], 3) []","solution":"def find_combinations(nums, target): Finds all unique combinations of integers from the list 'nums' that sum up to the 'target'. Each number in the list can only be used once in each combination. def backtrack(start, path, remaining): if remaining == 0: result.append(path[:]) return elif remaining < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue path.append(nums[i]) backtrack(i + 1, path, remaining - nums[i]) path.pop() nums.sort() # To help skip duplicates result = [] backtrack(0, [], target) return result"},{"question":"def rearrangeArray(nums: List[int], P: int, Q: int) -> List[int]: Rearranges the elements of nums such that the sum of absolute differences between every adjacent pair of elements is minimized, with P as the first element and Q as the last element. :param nums: List of integers :param P: Integer that must be the first element of the rearranged list :param Q: Integer that must be the last element of the rearranged list :return: Rearranged list of integers pass from solution import rearrangeArray def test_rearrange_example1(): nums = [10, 1, 8, 12, 7] P = 8 Q = 10 result = rearrangeArray(nums, P, Q) expected = [8, 7, 10, 1, 12] assert result == expected def test_rearrange_example2(): nums = [4, 2, 5, 9, 3] P = 9 Q = 2 result = rearrangeArray(nums, P, Q) expected = [9, 3, 4, 5, 2] assert result == expected def test_rearrange_single_element(): nums = [1, 2] P = 1 Q = 2 result = rearrangeArray(nums, P, Q) expected = [1, 2] assert result == expected def test_rearrange_large_range(): nums = list(range(1, 101)) P = 50 Q = 75 result = rearrangeArray(nums, P, Q) expected = [50] + [x for x in range(1, 101) if x != 50 and x != 75] + [75] assert result == expected def test_rearrange_descending_order(): nums = [8, 6, 7, 5, 9] P = 8 Q = 9 result = rearrangeArray(nums, P, Q) expected = [8, 5, 6, 7, 9] assert result == expected","solution":"def rearrangeArray(nums, P, Q): Rearranges the elements of nums such that the sum of absolute differences between every adjacent pair of elements is minimized, with P as the first element and Q as the last element. :param nums: List of integers :param P: Integer that must be the first element of the rearranged list :param Q: Integer that must be the last element of the rearranged list :return: Rearranged list of integers # Removing P and Q from the list \`nums\` to rearrange the remaining elements nums.remove(P) nums.remove(Q) # Sorting the elements to minimize the absolute differences nums.sort() # Preparing the result with P at the start and Q at the end result = [P] + nums + [Q] # Return the rearranged list return result"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The robot can move only down or right. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(10, 10) 48620 >>> unique_paths(1, 100) 1 >>> unique_paths(100, 1) 1 >>> unique_paths(5, 5) 70","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The robot can move only down or right. # Create a 2D table to store results of subproblems dp = [[0] * n for _ in range(m)] # Fill the first column, as there is only one way to reach any cell in the first column for i in range(m): dp[i][0] = 1 # Fill the first row, as there is only one way to reach any cell in the first row for j in range(n): dp[0][j] = 1 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): # The number of ways to reach the current cell is the sum of the ways to reach the cell above and the cell to the left dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right cell contains the number of unique paths return dp[m-1][n-1]"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. Args: s (str): Input string consisting of Latin letters and digits. Returns: int: Length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Given a string s, find the length of the longest substring without repeating characters. Args: s (str): Input string consisting of Latin letters and digits. Returns: int: Length of the longest substring without repeating characters. seen = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in seen and seen[char] >= left: left = seen[char] + 1 seen[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_depth(arr) -> int: Returns the maximum depth of nested arrays within the provided array. >>> max_depth([1, 2, 3]) 1 >>> max_depth([1, [2, 3]]) 2 >>> max_depth([1, [2, [3, 4]]]) 3 >>> max_depth([1, [2, [3, [4]]]]) 4 >>> max_depth([[], 2, 3]) 2","solution":"def max_depth(arr): Returns the maximum depth of nested arrays within the provided array. if not isinstance(arr, list): return 0 def find_depth(item): if isinstance(item, list): return 1 + max((find_depth(subitem) for subitem in item), default=0) else: return 0 return 1 + max((find_depth(item) for item in arr), default=0)"},{"question":"def total_car_value_in_range(test_cases): Given a list of car prices and a list of queries, determine the total value of cars within given price ranges. Each test case contains: - N: The number of car prices. - Q: The number of queries. - car_prices: A list of integers representing the prices of the cars. - queries: A list of tuples, where each tuple contains two integers, L and R, defining the price range (inclusive). The function should return a list of lists, where each sublist contains the results for the corresponding test case. Example: >>> test_cases = [ >>> { >>> \\"N\\": 5, >>> \\"Q\\": 3, >>> \\"car_prices\\": [10000, 20000, 30000, 40000, 50000], >>> \\"queries\\": [(15000, 35000), (5000, 25000), (20000, 60000)] >>> } >>> ] >>> total_car_value_in_range(test_cases) [[50000, 30000, 140000]]","solution":"def total_car_value_in_range(test_cases): results = [] for case in test_cases: N, Q, car_prices, queries = case['N'], case['Q'], case['car_prices'], case['queries'] prefix_sum = [0] * (N + 1) # Compute prefix sums for car prices for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + car_prices[i - 1] case_results = [] # Process each query for L, R in queries: lower_bound = find_lower_bound(car_prices, L) upper_bound = find_upper_bound(car_prices, R) if lower_bound == -1 or upper_bound == -1 or lower_bound > upper_bound: case_results.append(0) else: total_value = prefix_sum[upper_bound + 1] - prefix_sum[lower_bound] case_results.append(total_value) results.append(case_results) return results def find_lower_bound(car_prices, L): # Binary search to find the leftmost item >= L left, right = 0, len(car_prices) - 1 while left <= right: mid = (left + right) // 2 if car_prices[mid] >= L: right = mid - 1 else: left = mid + 1 return left if left < len(car_prices) and car_prices[left] >= L else -1 def find_upper_bound(car_prices, R): # Binary search to find the rightmost item <= R left, right = 0, len(car_prices) - 1 while left <= right: mid = (left + right) // 2 if car_prices[mid] <= R: left = mid + 1 else: right = mid - 1 return right if right >= 0 and car_prices[right] <= R else -1"},{"question":"def is_subset_sum_possible(N: int, arr: List[int], T: int) -> str: Determines if there exists a subset of the given set of N integers such that the sum is equal to T. :param N: Number of integers in the set. :param arr: List of integers in the set. :param T: Target sum. :return: \\"YES\\" if such a subset exists, otherwise \\"NO\\". >>> is_subset_sum_possible(5, [3, 34, 4, 12, 5], 9) \\"YES\\" >>> is_subset_sum_possible(5, [3, 34, 4, 12, 5], 30) \\"NO\\" pass","solution":"def is_subset_sum_possible(N, arr, T): Determines if there exists a subset of the given set of N integers such that the sum is equal to T. :param N: Number of integers in the set. :param arr: List of integers in the set. :param T: Target sum. :return: \\"YES\\" if such a subset exists, otherwise \\"NO\\". # Initialize a DP table with T+1 columns (for all sums from 0 to T) and N+1 rows (for all subsets) dp = [[False] * (T + 1) for _ in range(N + 1)] # An empty subset can always form sum 0 for i in range(N + 1): dp[i][0] = True # Fill the rest of the DP table for i in range(1, N + 1): for j in range(1, T + 1): # If the current element is greater than the current sum, we can't include it if arr[i - 1] > j: dp[i][j] = dp[i - 1][j] else: # We can either include the current element or exclude it dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return \\"YES\\" if dp[N][T] else \\"NO\\""},{"question":"def is_valid_identifier(identifier: str) -> bool: Create a function \`is_valid_identifier\` which takes a string and returns a boolean indicating whether the string is a valid identifier in a programming language. A valid identifier adheres to the following rules: 1. The identifier must start with a letter (a-z, A-Z) or an underscore (_). The starting character cannot be a digit or any other special character. 2. The identifier can contain alphanumeric characters (a-z, A-Z, 0-9) and underscores (_) after the initial character. 3. The identifier cannot be a reserved keyword of the programming language. For simplicity, let's assume the list of reserved keywords is as follows: >>> keywords = [ >>> \\"if\\", \\"else\\", \\"while\\", \\"for\\", \\"return\\", \\"break\\", \\"continue\\", >>> \\"def\\", \\"class\\", \\"try\\", \\"except\\", \\"import\\", \\"from\\", \\"as\\", \\"with\\" >>> ] Examples: >>> is_valid_identifier(\\"variable\\") == True >>> is_valid_identifier(\\"def\\") == False >>> is_valid_identifier(\\"1variable\\") == False >>> is_valid_identifier(\\"var!able\\") == False >>> is_valid_identifier(\\"_temp\\") == True >>> is_valid_identifier(\\"__init__\\") == True >>> is_valid_identifier(\\"var iable\\") == False","solution":"def is_valid_identifier(identifier): keywords = [ \\"if\\", \\"else\\", \\"while\\", \\"for\\", \\"return\\", \\"break\\", \\"continue\\", \\"def\\", \\"class\\", \\"try\\", \\"except\\", \\"import\\", \\"from\\", \\"as\\", \\"with\\" ] # Check if identifier is not empty if not identifier: return False # Check if it's a reserved keyword if identifier in keywords: return False # Check if it starts with a letter or underscore if not (identifier[0].isalpha() or identifier[0] == '_'): return False # Check remaining characters for char in identifier[1:]: if not (char.isalnum() or char == '_'): return False return True"},{"question":"def repeat_strings(str_list: List[str], k: int) -> List[str]: Given a list of strings and an integer k, returns a new list where each string is repeated k times consecutively. Parameters: str_list (list): List of strings to be repeated. k (int): Number of times each string should be repeated. Returns: list: New list with repeated strings. >>> repeat_strings([\\"a\\", \\"b\\", \\"c\\"], 3) == [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> repeat_strings([\\"hello\\", \\"world\\"], 2) == [\\"hellohello\\", \\"worldworld\\"] >>> repeat_strings([], 3) == [] >>> repeat_strings([\\"test\\"], 0) == [] >>> repeat_strings([\\"x\\", \\"y\\"], 1) == [\\"x\\", \\"y\\"] >>> repeat_strings([\\"repeat\\"], 4) == [\\"repeatrepeatrepeatrepeat\\"] >>> repeat_strings([\\"multiple\\", \\"strings\\"], 2) == [\\"multiplemultiple\\", \\"stringsstrings\\"] >>> repeat_strings([\\"a\\", \\"b\\", \\"c\\"], -1) == [] >>> repeat_strings([\\"one\\"], 10) == [\\"oneoneoneoneoneoneoneoneoneone\\"]","solution":"def repeat_strings(str_list, k): Given a list of strings and an integer k, returns a new list where each string is repeated k times consecutively. Parameters: str_list (list): List of strings to be repeated. k (int): Number of times each string should be repeated. Returns: list: New list with repeated strings. if k <= 0: return [] return [s * k for s in str_list]"},{"question":"def generate_fibonacci(n): Generate a list containing the first \`n\` numbers of the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate Returns: List[int]: A list of the first \`n\` Fibonacci numbers Examples: >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci(n): Generate a list containing the first \`n\` numbers of the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate Returns: List[int]: A list of the first \`n\` Fibonacci numbers if n == 0: return [] fibonacci_sequence = [0, 1] while len(fibonacci_sequence) < n: next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_fib) return fibonacci_sequence[:n]"},{"question":"def judge_circle(moves): Determines if the robot returns to the origin after executing the move sequence. :param moves: str : A string representing the sequence of moves. :return: bool : True if the robot ends up at the origin, False otherwise. >>> judge_circle(\\"UD\\") True >>> judge_circle(\\"LL\\") False >>> judge_circle(\\"ULDR\\") True >>> judge_circle(\\"UUDDLLRR\\") True >>> judge_circle(\\"UDLRDLLU\\") False","solution":"def judge_circle(moves): Determines if the robot returns to the origin after executing the move sequence. :param moves: str : A string representing the sequence of moves. :return: bool : True if the robot ends up at the origin, False otherwise. horizontal = 0 vertical = 0 for move in moves: if move == 'U': vertical += 1 elif move == 'D': vertical -= 1 elif move == 'L': horizontal -= 1 elif move == 'R': horizontal += 1 return horizontal == 0 and vertical == 0"},{"question":"def solve_tsp_cases(T: int, cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Given the number of test cases and the distances between cities for each test case, find the minimum distance the merchant has to travel to visit every city exactly once and return to the starting city. >>> solve_tsp_cases(1, [(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]])]) [80] >>> solve_tsp_cases(1, [(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]])]) [64]","solution":"import itertools def tsp(distances): N = len(distances) city_indices = range(N) min_path_cost = float('inf') # Generate all possible permutations of cities for perm in itertools.permutations(city_indices): path_cost = 0 # Calculate the path cost for the current permutation for i in range(N): path_cost += distances[perm[i]][perm[(i + 1) % N]] # Update the minimum path cost found min_path_cost = min(min_path_cost, path_cost) return min_path_cost def solve_tsp_cases(T, cases): results = [] for i in range(T): N, distances = cases[i] results.append(tsp(distances)) return results"},{"question":"from typing import List def longestIncreasingSubsequence(arr: List[int]) -> List[int]: Finds the longest subsequence of strictly increasing numbers in the given array. >>> longestIncreasingSubsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> longestIncreasingSubsequence([3]) [3] >>> longestIncreasingSubsequence([2, 2, 2, 2]) [2] >>> longestIncreasingSubsequence([5, 4, 3, 2, 1]) [5] >>> longestIncreasingSubsequence([1, 7, 3, 5, 9, 4, 8]) [1, 3, 5, 9] >>> longestIncreasingSubsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> longestIncreasingSubsequence([]) [] pass # Example usage if __name__ == \\"__main__\\": arr = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(longestIncreasingSubsequence(arr))","solution":"def longestIncreasingSubsequence(arr): Finds the longest subsequence of strictly increasing numbers in the given array. :param arr: List of integers :return: List containing the longest increasing subsequence n = len(arr) if n == 0: return [] # Initialize the dp array to hold the longest increasing subsequences dp = [[] for _ in range(n)] # Each element alone is an increasing subsequence dp[0].append(arr[0]) for i in range(1, n): for j in range(i): if arr[i] > arr[j] and len(dp[i]) < len(dp[j]): dp[i] = dp[j][:] dp[i].append(arr[i]) # Add arr[i] to the end of the longest found subsequence # Find the longest subsequence in all dp entries longest_subsequence = [] for subsequence in dp: if len(subsequence) > len(longest_subsequence): longest_subsequence = subsequence return longest_subsequence # Example usage if __name__ == \\"__main__\\": arr = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(longestIncreasingSubsequence(arr))"},{"question":"class ArtCollection: def __init__(self, n): Initialize the art collection with n art pieces. ... def damage(self, index): Mark the art piece at the given index as damaged. ... def get_undamaged(self): Return the list of indices of art pieces that are not damaged. ... import pytest def test_art_collection_initial_state(): ac = ArtCollection(5) assert ac.get_undamaged() == [0, 1, 2, 3, 4] def test_damage_art_pieces(): ac = ArtCollection(5) ac.damage(1) assert ac.get_undamaged() == [0, 2, 3, 4] ac.damage(3) assert ac.get_undamaged() == [0, 2, 4] ac.damage(0) assert ac.get_undamaged() == [2, 4] def test_damage_all_art_pieces(): ac = ArtCollection(3) ac.damage(0) ac.damage(1) ac.damage(2) assert ac.get_undamaged() == [] def test_get_undamaged_after_multiple_operations(): ac = ArtCollection(5) assert ac.get_undamaged() == [0, 1, 2, 3, 4] ac.damage(1) ac.damage(3) assert ac.get_undamaged() == [0, 2, 4] ac.damage(2) assert ac.get_undamaged() == [0, 4] def test_invalid_damage_operations(): ac = ArtCollection(5) ac.damage(-1) # Should not affect the state ac.damage(5) # Should not affect the state assert ac.get_undamaged() == [0, 1, 2, 3, 4] if __name__ == \\"__main__\\": pytest.main()","solution":"class ArtCollection: def __init__(self, n): Initialize the art collection with n art pieces. self.art_pieces = [True] * n # True means undamaged def damage(self, index): Mark the art piece at the given index as damaged. if 0 <= index < len(self.art_pieces): self.art_pieces[index] = False def get_undamaged(self): Return the list of indices of art pieces that are not damaged. return [i for i, is_undamaged in enumerate(self.art_pieces) if is_undamaged]"},{"question":"def number_of_distinct_elements(N: int, Q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a sequence of N integers and Q queries, determine the number of distinct elements in the subarray from index L to R (inclusive). Parameters: N (int): The number of elements in the array. Q (int): The number of queries. array (List[int]): The array of integers. queries (List[Tuple[int, int]]): A list of queries, each containing two integers L and R. Returns: List[int]: A list of results, each being the number of distinct elements for the corresponding query. Examples: >>> number_of_distinct_elements(5, 3, [1, 2, 2, 1, 3], [(1, 3), (2, 5), (1, 5)]) [2, 3, 3] >>> number_of_distinct_elements(1, 1, [1], [(1, 1)]) [1] >>> number_of_distinct_elements(5, 2, [1, 2, 3, 4, 5], [(1, 5), (2, 4)]) [5, 3] >>> number_of_distinct_elements(6, 2, [1, 1, 1, 1, 1, 1], [(1, 3), (1, 6)]) [1, 1] >>> number_of_distinct_elements(5, 2, [1, 2, 1, 2, 1], [(1, 2), (3, 5)]) [2, 2]","solution":"def number_of_distinct_elements(N, Q, array, queries): Returns a list of the number of distinct elements in the subarrays defined by the queries. results = [] for L, R in queries: subarray = array[L-1:R] distinct_count = len(set(subarray)) results.append(distinct_count) return results"},{"question":"def calculateBonus(salary: int, performanceRating: str) -> int: Calculates the annual bonus based on the performance rating. Parameters: salary (int): The annual salary of the employee, must be positive. performanceRating (str): The performance rating of the employee. Returns: int: The calculated annual bonus. >>> calculateBonus(50000, \\"excellent\\") == 10000 >>> calculateBonus(45000, \\"good\\") == 4500 >>> calculateBonus(60000, \\"average\\") == 3000 >>> calculateBonus(70000, \\"poor\\") == 0 >>> calculateBonus(80000, \\"terrible\\") == 0","solution":"def calculateBonus(salary, performanceRating): Calculates the annual bonus based on the performance rating. Parameters: salary (int): The annual salary of the employee, must be positive. performanceRating (str): The performance rating of the employee. Returns: int: The calculated annual bonus. if performanceRating == \\"excellent\\": return int(salary * 0.20) elif performanceRating == \\"good\\": return int(salary * 0.10) elif performanceRating == \\"average\\": return int(salary * 0.05) else: return 0"},{"question":"def process_transactions(transactions): Processes a list of banking transactions and returns the final balances of each account in ascending order of their account numbers. Parameters: transactions (List[str]): A list of transaction strings in the format \\"D <account_number> <amount>\\" or \\"W <account_number> <amount>\\" Returns: List[Tuple[int, int]]: A sorted list of tuples where each tuple contains an account number and its corresponding balance. def parse_input(input_data): Parses the input data for the banking transactions. Parameters: input_data (str): The input data string containing number of transactions and transaction details. Returns: List[str]: A list of transaction strings in the format described. def main(input_data): Main function to process input data and return final balances. Parameters: input_data (str): The input data string containing number of transactions and transaction details. Returns: str: A string of final balances of each account formatted as described. # Unit Test for the completion task from solution import process_transactions, parse_input, main def test_process_transactions(): transactions = [ \\"D 1001 5000\\", \\"D 1002 3000\\", \\"W 1001 2000\\", \\"D 1001 1000\\", \\"W 1002 1000\\", \\"W 1003 500\\" ] expected = [(1001, 4000), (1002, 2000), (1003, 0)] assert process_transactions(transactions) == expected def test_parse_input(): input_data = \\"6nD 1001 5000nD 1002 3000nW 1001 2000nD 1001 1000nW 1002 1000nW 1003 500\\" expected = [ \\"D 1001 5000\\", \\"D 1002 3000\\", \\"W 1001 2000\\", \\"D 1001 1000\\", \\"W 1002 1000\\", \\"W 1003 500\\" ] assert parse_input(input_data) == expected def test_main(): input_data = \\"6nD 1001 5000nD 1002 3000nW 1001 2000nD 1001 1000nW 1002 1000nW 1003 500\\" expected_output = \\"1001 4000n1002 2000n1003 0\\" assert main(input_data) == expected_output def test_withdrawal_exceeds_balance(): transactions = [ \\"D 1001 1000\\", \\"W 1001 2000\\" ] expected = [(1001, 1000)] assert process_transactions(transactions) == expected def test_no_transactions(): transactions = [] expected = [] assert process_transactions(transactions) == expected","solution":"def process_transactions(transactions): Processes a list of banking transactions and returns the final balances of each account in ascending order of their account numbers. Parameters: transactions (List[str]): A list of transaction strings in the format \\"D <account_number> <amount>\\" or \\"W <account_number> <amount>\\" Returns: List[Tuple[int, int]]: A sorted list of tuples where each tuple contains an account number and its corresponding balance. accounts = {} for transaction in transactions: parts = transaction.split() action = parts[0] account_number = int(parts[1]) amount = int(parts[2]) if account_number not in accounts: accounts[account_number] = 0 if action == 'D': accounts[account_number] += amount elif action == 'W': if accounts[account_number] >= amount: accounts[account_number] -= amount sorted_accounts = sorted(accounts.items()) return sorted_accounts # Example input preparation def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) transactions = lines[1:T+1] return transactions # Example run to match with task's expected format def main(input_data): transactions = parse_input(input_data) results = process_transactions(transactions) return \\"n\\".join(f\\"{account} {balance}\\" for account, balance in results)"},{"question":"def is_balanced(s: str) -> bool: Determines if a given string containing only characters (), [], {} is balanced. >>> is_balanced(\\"([])\\") == True >>> is_balanced(\\"{[()]}\\") == True >>> is_balanced(\\"([)]\\") == False >>> is_balanced(\\"{[}\\") == False >>> is_balanced(\\"\\") == True","solution":"def is_balanced(s): Determines if a given string containing only characters (), [], {} is balanced. Parameters: s (str): The input string containing brackets. Returns: bool: True if the string is balanced, False otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): # opening bracket stack.append(char) elif char in bracket_map.keys(): # closing bracket if stack == [] or stack.pop() != bracket_map[char]: return False else: # Invalid character, the function assumes only valid brackets, so well ignore this continue return stack == []"},{"question":"def generate_sequence(N, L): Generates a sequence of numbers where each subsequent number is formed by adding the digits of the previous number to itself. Parameters: N (int): The initial number. L (int): The length of the sequence. Returns: List[int]: The generated sequence of length L. ... def generate_sequences(test_cases): For each test case, generates the sequence and formats the output. Parameters: test_cases (List[Tuple[int, int]]): List of tuples containing initial number and length of sequence. Returns: List[str]: List of formatted output strings for each test case. ... # Unit tests def test_generate_sequence(): assert generate_sequence(5, 3) == [5, 10, 11] assert generate_sequence(12, 5) == [12, 15, 21, 24, 30] assert generate_sequence(1, 5) == [1, 2, 4, 8, 16] assert generate_sequence(9, 5) == [9, 18, 27, 36, 45] assert generate_sequence(99, 3) == [99, 117, 126] def test_generate_sequences(): assert generate_sequences([(5, 3)]) == [\\"Case 1: 5 10 11\\"] assert generate_sequences([(12, 5)]) == [\\"Case 1: 12 15 21 24 30\\"] assert generate_sequences([(5, 3), (12, 5)]) == [\\"Case 1: 5 10 11\\", \\"Case 2: 12 15 21 24 30\\"] assert generate_sequences([(1, 1)]) == [\\"Case 1: 1\\"] assert generate_sequences([(1, 2)]) == [\\"Case 1: 1 2\\"]","solution":"def generate_sequence(N, L): Generates a sequence of numbers where each subsequent number is formed by adding the digits of the previous number to itself. Parameters: N (int): The initial number. L (int): The length of the sequence. Returns: List[int]: The generated sequence of length L. def sum_of_digits(num): return sum(int(digit) for digit in str(num)) sequence = [N] for _ in range(1, L): N = N + sum_of_digits(N) sequence.append(N) return sequence def generate_sequences(test_cases): For each test case, generates the sequence and formats the output. Parameters: test_cases (List[Tuple[int, int]]): List of tuples containing initial number and length of sequence. Returns: List[str]: List of formatted output strings for each test case. results = [] for i, (N, L) in enumerate(test_cases): sequence = generate_sequence(N, L) results.append(f\\"Case {i + 1}: \\" + ' '.join(map(str, sequence))) return results"},{"question":"def min_operations_to_alternate(s: str) -> int: Returns the minimum number of operations required to make the string alternate between 0's and 1's. Args: s (str): input binary string Returns: int: minimum number of operations required >>> min_operations_to_alternate(\\"010101\\") 0 >>> min_operations_to_alternate(\\"11001\\") 2 >>> min_operations_to_alternate(\\"1111\\") 2 >>> min_operations_to_alternate(\\"0000000\\") 3 pass from solution import min_operations_to_alternate def test_already_alternating(): assert min_operations_to_alternate(\\"010101\\") == 0 assert min_operations_to_alternate(\\"101010\\") == 0 def test_single_flip_required(): assert min_operations_to_alternate(\\"11001\\") == 2 assert min_operations_to_alternate(\\"01100\\") == 2 def test_all_same_chars(): assert min_operations_to_alternate(\\"1111\\") == 2 assert min_operations_to_alternate(\\"0000000\\") == 3 def test_mixed_cases(): assert min_operations_to_alternate(\\"11010\\") == 1 assert min_operations_to_alternate(\\"100110\\") == 2 assert min_operations_to_alternate(\\"0011\\") == 2 def test_edge_cases(): assert min_operations_to_alternate(\\"0\\") == 0 assert min_operations_to_alternate(\\"1\\") == 0 assert min_operations_to_alternate(\\"01\\") == 0 assert min_operations_to_alternate(\\"10\\") == 0 assert min_operations_to_alternate(\\"00\\") == 1 assert min_operations_to_alternate(\\"11\\") == 1","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations required to make the string alternate between 0's and 1's. # Based on two patterns: \\"010101...\\" and \\"101010...\\" pattern1 = ''.join(['0' if i % 2 == 0 else '1' for i in range(len(s))]) pattern2 = ''.join(['1' if i % 2 == 0 else '0' for i in range(len(s))]) # Calculating flips for both patterns flips_pattern1 = sum(1 for i in range(len(s)) if s[i] != pattern1[i]) flips_pattern2 = sum(1 for i in range(len(s)) if s[i] != pattern2[i]) # Return the minimum flips required return min(flips_pattern1, flips_pattern2)"},{"question":"def min_categories(n: int, s: str) -> int: Determine the minimum number of categories needed to organize the books such that no category contains two books with the same label. Args: n (int): Number of books. s (str): A string of length n where each character represents the label of a book. Returns: int: The minimum number of categories needed to organize the books. Examples: >>> min_categories(5, \\"abcde\\") 1 >>> min_categories(6, \\"aabbcc\\") 2 >>> min_categories(4, \\"aaaa\\") 4 >>> min_categories(8, \\"abababab\\") 4 >>> min_categories(1, \\"a\\") 1 >>> min_categories(10, \\"aabbbccccd\\") 4","solution":"def min_categories(n, s): Returns the minimum number of categories needed for n books with labels in string s. from collections import Counter label_counts = Counter(s) # The number of categories is determined by the maximum frequency of any single label. max_frequency = max(label_counts.values()) return max_frequency"},{"question":"from typing import List def longest_increasing_subsequence_length(sales: List[int]) -> int: Analyze sales data and return the length of the longest sequence of consecutive sales increases. >>> longest_increasing_subsequence_length([100, 200, 90, 120, 150, 180, 110, 130]) 4 >>> longest_increasing_subsequence_length([5, 6, 3, 5, 7, 8, 10, 2]) 5 >>> longest_increasing_subsequence_length([10, 9, 8, 7]) 1 >>> longest_increasing_subsequence_length([100]) 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([1, 3, 2, 3, 4, 1, 2]) 3 >>> longest_increasing_subsequence_length([1, 3, 2, 4, 3, 5, 4, 6]) 2 >>> longest_increasing_subsequence_length([]) 0","solution":"from typing import List def longest_increasing_subsequence_length(sales: List[int]) -> int: if not sales: return 0 n = len(sales) longest_length = 1 current_length = 1 for i in range(1, n): if sales[i] > sales[i - 1]: current_length += 1 else: longest_length = max(longest_length, current_length) current_length = 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def is_happy_number(n: int) -> str: Determine whether the number will eventually reach 1 or fall into a cycle. A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. >>> is_happy_number(19) \\"Happy Number\\" >>> is_happy_number(20) \\"Unhappy Number\\" from solution import is_happy_number def test_happy_number(): assert is_happy_number(19) == \\"Happy Number\\" assert is_happy_number(7) == \\"Happy Number\\" assert is_happy_number(1) == \\"Happy Number\\" def test_unhappy_number(): assert is_happy_number(20) == \\"Unhappy Number\\" assert is_happy_number(4) == \\"Unhappy Number\\" assert is_happy_number(2) == \\"Unhappy Number\\" def test_edge_cases(): assert is_happy_number(0) == \\"Unhappy Number\\" assert is_happy_number(10) == \\"Happy Number\\" assert is_happy_number(100) == \\"Happy Number\\"","solution":"def is_happy_number(n: int) -> str: def sum_of_squares(num: int) -> int: total = 0 while num > 0: digit = num % 10 total += digit * digit num //= 10 return total seen = set() while n != 1: n = sum_of_squares(n) if n in seen: return \\"Unhappy Number\\" seen.add(n) return \\"Happy Number\\""},{"question":"def is_narcissistic(n: int) -> bool: Determine whether a given number n is a Narcissistic number. >>> is_narcissistic(153) True >>> is_narcissistic(100) False >>> is_narcissistic(9474) True","solution":"def is_narcissistic(n): Returns True if the given number n is a Narcissistic number, else False. digits = [int(d) for d in str(n)] num_digits = len(digits) return n == sum(d ** num_digits for d in digits) # Example Usage # print(is_narcissistic(153)) # True # print(is_narcissistic(100)) # False # print(is_narcissistic(9474)) # True"},{"question":"def gcd(a, b): Compute the greatest common divisor (GCD) of a and b. while b: a, b = b, a % b return a def largest_square_side_lengths(test_cases): Given the dimensions of multiple fields, return the side length of the largest possible square that fits perfectly within each field's dimensions. :param test_cases: A list of tuples, each containing the length and width of the field. :return: A list of side lengths of the largest possible square for each field. results = [] for L, W in test_cases: results.append(gcd(L, W)) return results # Unit Tests def test_basic_case(): test_cases = [(15, 20), (8, 12)] assert largest_square_side_lengths(test_cases) == [5, 4] def test_more_cases(): test_cases = [(1, 1), (7, 14), (18, 30), (64, 48)] assert largest_square_side_lengths(test_cases) == [1, 7, 6, 16] def test_large_cases(): test_cases = [(10**9, 10**9), (10**9, 1), (10**9 - 1, 10**9 - 1)] assert largest_square_side_lengths(test_cases) == [10**9, 1, 10**9 - 1] def test_edge_cases(): test_cases = [(1, 10**9), (10**9, 10**9 - 1)] assert largest_square_side_lengths(test_cases) == [1, 1] def test_zero_dimension_case(): # This isn't allowed by the problem statement but let's check # Should ideally raise an error or handle gracefully try: test_cases = [(0, 1), (2, 0)] largest_square_side_lengths(test_cases) except Exception as e: assert isinstance(e, ValueError) def test_single_case(): test_cases = [(24, 36)] assert largest_square_side_lengths(test_cases) == [12]","solution":"def gcd(a, b): Compute the greatest common divisor (GCD) of a and b. while b: a, b = b, a % b return a def largest_square_side_lengths(test_cases): Given the dimensions of multiple fields, return the side length of the largest possible square that fits perfectly within each field's dimensions. :param test_cases: A list of tuples, each containing the length and width of the field. :return: A list of side lengths of the largest possible square for each field. results = [] for L, W in test_cases: results.append(gcd(L, W)) return results"},{"question":"from collections import defaultdict def most_frequent_next_word(sentences: List[str], target_word: str) -> str: Given a list of sentences and a target word, find the most frequently occurring next word. Args: sentences (List[str]): A list of sentences. target_word (str): The target word to find the most frequent next word for. Returns: str: The word that most frequently appears immediately after the given word. If there are multiple words with the same highest frequency, return the lexicographically smallest one. If the word does not appear in any sentence, return an empty string. >>> sentences = [\\"hello world\\", \\"world of coding\\", \\"hello there world\\", \\"world world world hello\\"] >>> target_word = \\"world\\" >>> most_frequent_next_word(sentences, target_word) 'world' >>> sentences = [\\"the quick brown fox jumps over the lazy dog\\"] >>> target_word = \\"the\\" >>> most_frequent_next_word(sentences, target_word) 'lazy' >>> sentences = [\\"apple banana\\", \\"apple berry\\", \\"apple banana berry\\", \\"apple banana berry\\"] >>> target_word = \\"apple\\" >>> most_frequent_next_word(sentences, target_word) 'banana' >>> sentences = [\\"this is a test\\", \\"another test case\\", \\"and another one\\"] >>> target_word = \\"nonexistent\\" >>> most_frequent_next_word(sentences, target_word) '' >>> sentences = [\\"cat bat\\", \\"cat rat\\", \\"cat mat\\", \\"cat pat\\"] >>> target_word = \\"cat\\" >>> most_frequent_next_word(sentences, target_word) 'bat'","solution":"from collections import defaultdict def most_frequent_next_word(sentences, target_word): next_word_count = defaultdict(int) for sentence in sentences: words = sentence.split() for i in range(len(words) - 1): if words[i] == target_word: next_word_count[words[i + 1]] += 1 if not next_word_count: return '' max_count = max(next_word_count.values()) candidates = [word for word, count in next_word_count.items() if count == max_count] return min(candidates) # Example usage: N = 4 sentences = [ \\"hello world\\", \\"world of coding\\", \\"hello there world\\", \\"world world world hello\\" ] target_word = \\"world\\" print(most_frequent_next_word(sentences, target_word)) # Output: \\"world\\""},{"question":"def can_attend_all_concerts(m: int, concerts: List[Tuple[int, int]]) -> str: Determine if Karen can attend all concerts without any overlap. >>> can_attend_all_concerts(3, [(1, 3), (5, 2), (8, 3)]) \\"YES\\" >>> can_attend_all_concerts(2, [(2, 5), (6, 3)]) \\"NO\\"","solution":"def can_attend_all_concerts(m, concerts): # Sort concerts by their start times concerts.sort(key=lambda x: x[0]) for i in range(1, m): # Get end time of the current concert end_time = concerts[i-1][0] + concerts[i-1][1] # Check if the next concert starts before the current concert ends if concerts[i][0] < end_time: return \\"NO\\" return \\"YES\\""},{"question":"def is_valid_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, considering only alphanumeric characters and ignoring case. # Implementation here def check_palindrome(s: str) -> str: Outputs 'YES' if the given string is a valid palindrome and 'NO' otherwise. >>> check_palindrome(\\"A man, a plan, a canal: Panama\\") 'YES' >>> check_palindrome(\\"racecar\\") 'YES' >>> check_palindrome(\\"hello\\") 'NO' >>> check_palindrome(\\" \\") 'YES' # Implementation here # Unit tests def test_example_1(): assert check_palindrome(\\"A man, a plan, a canal: Panama\\") == \\"YES\\" def test_example_2(): assert check_palindrome(\\"racecar\\") == \\"YES\\" def test_example_3(): assert check_palindrome(\\"hello\\") == \\"NO\\" def test_example_4(): assert check_palindrome(\\" \\") == \\"YES\\" def test_mixed_case(): assert check_palindrome(\\"Able was I ere I saw Elba\\") == \\"YES\\" def test_with_spaces_and_punctuation(): assert check_palindrome(\\"No 'x' in Nixon\\") == \\"YES\\" def test_single_character(): assert check_palindrome(\\"a\\") == \\"YES\\" def test_only_non_alphanumeric(): assert check_palindrome(\\"!!!\\") == \\"YES\\" # Empty string after removing non-alphanumeric, which is a palindrome def test_mixed_alphanumeric(): assert check_palindrome(\\"1A2b2A1\\") == \\"YES\\"","solution":"def is_valid_palindrome(s): Determines if the given string is a valid palindrome, considering only alphanumeric characters and ignoring case. # Normalize the string: remove non-alphanumeric characters and convert to lower case normalized_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string is the same forwards and backwards return normalized_s == normalized_s[::-1] def check_palindrome(s): Outputs 'YES' if the given string is a valid palindrome and 'NO' otherwise. return \\"YES\\" if is_valid_palindrome(s) else \\"NO\\""},{"question":"def max_drinks(n: int, B: int, C: int, drinks: List[Tuple[int, int, int]]) -> int: Determine the maximum number of different types of drinks Amy can stock given the budget and storage capacity constraints. Args: n: Number of different types of drinks. B: Budget. C: Storage capacity. drinks: List of tuples, where each tuple contains the cost, expected demand, and storage requirement for a drink. Returns: Maximum number of different types of drinks Amy can stock without exceeding budget and storage capacity. >>> max_drinks(4, 10, 12, [(3, 5, 4), (2, 7, 2), (4, 6, 3), (5, 8, 5)]) 3 >>> max_drinks(3, 5, 5, [(2, 4, 3), (1, 6, 1), (3, 5, 4)]) 2 >>> max_drinks(1, 5, 5, [(2, 4, 3)]) 1 >>> max_drinks(2, 0, 5, [(2, 4, 3), (1, 6, 1)]) 0 >>> max_drinks(2, 5, 0, [(2, 4, 3), (1, 6, 1)]) 0","solution":"def max_drinks(n, B, C, drinks): # DP table where dp[x][y] will be the maximum number of different types of drinks # we can stock with a budget x and storage capacity y dp = [[0] * (C + 1) for _ in range(B + 1)] for c_i, _, s_i in drinks: for b in range(B, c_i - 1, -1): for s in range(C, s_i - 1, -1): dp[b][s] = max(dp[b][s], dp[b - c_i][s - s_i] + 1) return dp[B][C]"},{"question":"def process_messages(input_str: str) -> str: Processes messages between microservices in the SmallTritan protocol. The input is a single string containing one or more commands separated by semicolons. Each command has components separated by a pipe character. Valid commands: - USR|<username>: Log in or register a user with the specified username. - SES|<session_id>: Initialize or maintain an active game session with the provided session ID. - SCB|<score>: Submit a score for the current session. The score is an integer. - LBD: Display the leaderboard for all current sessions, showing users and their highest scores in descending order. Examples: >>> process_messages(\\"USR|john\\") \\"User john logged in\\" >>> process_messages(\\"SES|123\\") \\"Session 123 activated\\" >>> process_messages(\\"USR|john;SCB|50\\") \\"User john logged innScore 50 submitted\\" >>> process_messages(\\"USR|john;SCB|50;USR|jane;SCB|60;LBD\\") \\"User john logged innScore 50 submittednUser jane logged innScore 60 submittednLeaderboard:njane: 60njohn: 50\\" >>> process_messages(\\"USR|john;SES|123;SCB|50;USR|jane;SCB|60;SES|124;SCB|70;LBD\\") (\\"User john logged inn\\" \\"Session 123 activatedn\\" \\"Score 50 submittedn\\" \\"User jane logged inn\\" \\"Score 60 submittedn\\" \\"Session 124 activatedn\\" \\"Score 70 submittedn\\" \\"Leaderboard:njane: 70njohn: 50\\") >>> process_messages(\\"USR|john;SCB|50;USR|john;SCB|60;LBD\\") \\"User john logged innScore 50 submittednUser john logged innScore 60 submittednLeaderboard:njohn: 60\\"","solution":"def process_messages(input_str): # Storage for users and their scores users_scores = {} current_user = None current_session = None # Split the input string into individual messages messages = input_str.split(';') output = [] for message in messages: parts = message.split('|') command = parts[0] if command == \\"USR\\": current_user = parts[1] if current_user not in users_scores: users_scores[current_user] = 0 output.append(f\\"User {current_user} logged in\\") elif command == \\"SES\\": current_session = parts[1] output.append(f\\"Session {current_session} activated\\") elif command == \\"SCB\\": score = int(parts[1]) if current_user: if users_scores[current_user] < score: users_scores[current_user] = score output.append(f\\"Score {score} submitted\\") elif command == \\"LBD\\": leaderboard = \\"Leaderboard:\\" sorted_users = sorted(users_scores.items(), key=lambda item: item[1], reverse=True) for user, score in sorted_users: leaderboard += f\\"n{user}: {score}\\" output.append(leaderboard) return 'n'.join(output)"},{"question":"def max_profit(prices: List[int]) -> int: Given a list of integers representing daily stock prices, determine the maximum profit that could be made by buying on one day and selling on another day in the future. If no profit can be made, return 0. Args: prices (List[int]): List of stock prices. Returns: int: Maximum profit achievable, or 0 if no profit can be made. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0","solution":"def max_profit(prices): Given a list of integers representing daily stock prices, determine the maximum profit that could be made by buying on one day and selling on another day in the future. If no profit can be made, return 0. Args: prices (List[int]): List of stock prices. Returns: int: Maximum profit achievable, or 0 if no profit can be made. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def countTeamFormations(P: int) -> int: Returns the number of distinct ways to form teams such that each team has at least one member and no programmer is left out. >>> countTeamFormations(1) == 1 >>> countTeamFormations(2) == 2 >>> countTeamFormations(3) == 4 >>> countTeamFormations(4) == 8 >>> countTeamFormations(5) == 16 >>> countTeamFormations(6) == 31 >>> countTeamFormations(7) == 61 >>> countTeamFormations(8) == 120 >>> countTeamFormations(9) == 236 >>> countTeamFormations(10) == 464","solution":"def countTeamFormations(P): Returns the number of distinct ways to form teams such that each team has at least one member and no programmer is left out. if P == 0: return 0 # dp[i] will store number of ways to partition i programmers. dp = [0] * (P + 1) dp[0] = 1 # One way to partition 0 programmers (empty set) # Calculate number of partitions for each number of programmers for i in range(1, P + 1): for j in range(1, 6): # Teams can have from 1 to 5 members. if i - j >= 0: dp[i] += dp[i - j] return dp[P]"},{"question":"def min_operations_to_equal_height(n, heights): Calculate the minimum number of operations required to make all buildings have the same height. - Parameters: - n (int): The number of buildings. - heights (list of int): List representing the height of each building. - Returns: - int: The minimum number of operations required. >>> min_operations_to_equal_height(4, [5, 5, 5, 5]) == 0 >>> min_operations_to_equal_height(5, [1, 3, 2, 4, 2]) == 7 >>> min_operations_to_equal_height(1, [7]) == 0 >>> min_operations_to_equal_height(2, [3, 8]) == 5 >>> min_operations_to_equal_height(3, [1, 1, 1]) == 0 >>> min_operations_to_equal_height(5, [100000, 99999, 99998, 99997, 99996]) == 10 pass","solution":"def min_operations_to_equal_height(n, heights): Calculate the minimum number of operations required to make all buildings have the same height. Parameters: n (int): The number of buildings. heights (list of int): List representing the height of each building. Returns: int: The minimum number of operations required. min_height = min(heights) operations = sum(height - min_height for height in heights) return operations"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_traversal(root: TreeNode) -> List[int]: Given a binary tree, return the values of the nodes visited in a zigzag level order traversal. Traversal goes from left-to-right at the first level, right-to-left at the second level, and so on. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: A list of node values in zigzag level order. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzag_traversal(root) [1, 3, 2, 4, 5, 6, 7] def test_zigzag_traversal(): from solution import TreeNode, zigzag_traversal # Test case 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert zigzag_traversal(root) == [1, 3, 2, 4, 5, 6, 7] # Test case 2: Single node root = TreeNode(1) assert zigzag_traversal(root) == [1] # Test case 3 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert zigzag_traversal(root) == [1, 2, 3] # Test case 4: Empty tree assert zigzag_traversal(None) == [] # Test case 5 root = TreeNode(1) root.left = TreeNode(10) root.right = TreeNode(2) root.left.left = TreeNode(15) root.left.right = TreeNode(7) root.right.left = TreeNode(6) assert zigzag_traversal(root) == [1, 2, 10, 15, 7, 6] def test_mixed_values_zigzag_traversal(): from solution import TreeNode, zigzag_traversal # Test case with negative and positive values root = TreeNode(1) root.left = TreeNode(-2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(-5) root.right.left = TreeNode(-6) root.right.right = TreeNode(7) assert zigzag_traversal(root) == [1, 3, -2, 4, -5, -6, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_traversal(root: TreeNode): if not root: return [] from collections import deque result = [] current_level = deque([root]) left_to_right = True while current_level: level_len = len(current_level) level_vals = [] for _ in range(level_len): if left_to_right: node = current_level.popleft() level_vals.append(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) else: node = current_level.pop() level_vals.append(node.val) if node.right: current_level.appendleft(node.right) if node.left: current_level.appendleft(node.left) result.extend(level_vals) left_to_right = not left_to_right return result"},{"question":"def generate_spiral_pattern(n, marbles): Generate a spiral pattern for a given side length of the grid and a sequence of marble identifiers. Args: n (int): The side length of the square grid. marbles (List[int]): A list of unique positive integers representing the identifiers of the marbles. Returns: List[List[int]]: An N x N grid with the marbles arranged in a spiral pattern. Examples: >>> generate_spiral_pattern(3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_pattern(4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] def process_input_and_generate_output(test_cases): Process multiple test cases and generate the spiral patterns for each. Args: test_cases (List[List[int]]): A list containing test cases, where each test case is a list starting with an integer N (the side length of the grid), followed by N*N unique positive integers. Returns: List[List[List[int]]]: A list of N x N grids with marbles arranged in spiral patterns for each test case. Examples: >>> process_input_and_generate_output([[3, 1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]) [[[1, 2, 3], [8, 9, 4], [7, 6, 5]], [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]] def format_output(result): Format the spiral pattern grids into a printable string format. Args: result (List[List[List[int]]]): A list of N x N grids with marbles arranged in spiral patterns. Returns: List[str]: Formatted strings for each grid, with rows printed on new lines and elements within each row separated by a single space. Examples: >>> format_output([[[1, 2, 3], [8, 9, 4], [7, 6, 5]], [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]]) ['1 2 3n8 9 4n7 6 5', '1 2 3 4n12 13 14 5n11 16 15 6n10 9 8 7']","solution":"def generate_spiral_pattern(n, marbles): grid = [[0]*n for _ in range(n)] top, bottom, left, right = 0, n-1, 0, n-1 direction = 0 # 0-right, 1-down, 2-left, 3-up index = 0 while top <= bottom and left <= right: if direction == 0: # Move right for i in range(left, right + 1): grid[top][i] = marbles[index] index += 1 top += 1 elif direction == 1: # Move down for i in range(top, bottom + 1): grid[i][right] = marbles[index] index += 1 right -= 1 elif direction == 2: # Move left for i in range(right, left - 1, -1): grid[bottom][i] = marbles[index] index += 1 bottom -= 1 elif direction == 3: # Move up for i in range(bottom, top - 1, -1): grid[i][left] = marbles[index] index += 1 left += 1 direction = (direction + 1) % 4 return grid def process_input_and_generate_output(test_cases): results = [] for test_case in test_cases: n, marbles = test_case[0], test_case[1:] spiral_pattern = generate_spiral_pattern(n, marbles) results.append(spiral_pattern) return results def format_output(result): formatted_output = [] for grid in result: formatted_output.append(\\"n\\".join(\\" \\".join(map(str, row)) for row in grid)) return formatted_output"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists and return it as a new sorted list. The new list is made by splicing together the nodes of the first two lists. >>> linked_list_to_list(mergeTwoLists(list_to_linked_list([1, 2, 4]), list_to_linked_list([1, 3, 4]))) [1, 1, 2, 3, 4, 4] >>> linked_list_to_list(mergeTwoLists(list_to_linked_list([]), list_to_linked_list([0]))) [0] def list_to_linked_list(elements: list) -> ListNode: Creates a linked list from a list of elements and returns the head node. def linked_list_to_list(node: ListNode) -> list: Creates a list from a linked list and returns the list. import pytest def test_merge_two_non_empty_lists(): l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([1, 3, 4]) merged_list_head = mergeTwoLists(l1, l2) assert linked_list_to_list(merged_list_head) == [1, 1, 2, 3, 4, 4] def test_merge_with_one_empty_list(): l1 = list_to_linked_list([]) l2 = list_to_linked_list([0]) merged_list_head = mergeTwoLists(l1, l2) assert linked_list_to_list(merged_list_head) == [0] def test_merge_both_empty_lists(): l1 = list_to_linked_list([]) l2 = list_to_linked_list([]) merged_list_head = mergeTwoLists(l1, l2) assert linked_list_to_list(merged_list_head) == [] def test_merge_with_different_lengths(): l1 = list_to_linked_list([2, 5]) l2 = list_to_linked_list([1, 3, 4]) merged_list_head = mergeTwoLists(l1, l2) assert linked_list_to_list(merged_list_head) == [1, 2, 3, 4, 5] def test_merge_with_duplicate_elements(): l1 = list_to_linked_list([1, 3, 5]) l2 = list_to_linked_list([1, 3, 5]) merged_list_head = mergeTwoLists(l1, l2) assert linked_list_to_list(merged_list_head) == [1, 1, 3, 3, 5, 5] def test_merge_single_element_lists(): l1 = list_to_linked_list([1]) l2 = list_to_linked_list([2]) merged_list_head = mergeTwoLists(l1, l2) assert linked_list_to_list(merged_list_head) == [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists and return it as a new sorted list. The new list is made by splicing together the nodes of the first two lists. dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next def list_to_linked_list(elements): Creates a linked list from a list of elements and returns the head node. dummy = ListNode() current = dummy for element in elements: current.next = ListNode(element) current = current.next return dummy.next def linked_list_to_list(node): Creates a list from a linked list and returns the list. result = [] current = node while current: result.append(current.val) current = current.next return result"},{"question":"def is_valid_bst(arr): This function takes a list that represents a binary tree array in level-order. It returns \\"Yes\\" if the array represents a valid BST, otherwise \\"No\\". >>> is_valid_bst([5, 3, 8, 1, 4, 6, 10]) \\"Yes\\" >>> is_valid_bst([10, 5, 15, -1, -1, 6, 20]) \\"No\\" >>> is_valid_bst([10, 5, 15, 2, 7, 12, 20]) \\"Yes\\" >>> is_valid_bst([]) \\"Yes\\" >>> is_valid_bst([-1]) \\"Yes\\" >>> is_valid_bst([5, 3, 8, -1, 4, 6, 10]) \\"Yes\\" >>> is_valid_bst([3, 2, 5, 1, -1, 4, 6]) \\"Yes\\" >>> is_valid_bst([3, 4, 5, 1, -1, 4, 6]) \\"No\\" pass def process_test_cases(t, cases): This function processes multiple test cases and returns a list of results for each test case. Each test case consists of an integer and a list of integers representing a binary tree in level-order. >>> t = 3 >>> cases = [(7, [5, 3, 8, 1, 4, 6, 10]), (5, [10, 5, 15, -1, -1, 6, 20]), (7, [10, 5, 15, 2, 7, 12, 20])] >>> process_test_cases(t, cases) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> t = 2 >>> cases = [(3, [2, 1, 3]), (3, [3, 2, 1])] >>> process_test_cases(t, cases) [\\"Yes\\", \\"No\\"] pass","solution":"def is_valid_bst(arr): This function takes a list that represents a binary tree array in level-order. It returns \\"Yes\\" if the array represents a valid BST, otherwise \\"No\\". if not arr: return \\"Yes\\" def validate_bst(index, min_val, max_val): if index >= len(arr) or arr[index] == -1: return True val = arr[index] if not (min_val < val < max_val): return False return (validate_bst(2*index+1, min_val, val) and validate_bst(2*index+2, val, max_val)) return \\"Yes\\" if validate_bst(0, float('-inf'), float('inf')) else \\"No\\" def process_test_cases(t, cases): results = [] for n, arr in cases: results.append(is_valid_bst(arr)) return results"},{"question":"def min_max_distance_to_fire_station(M, N, grid): Finds the minimum possible maximum distance from any house to the nearest fire station. Parameters: M (int): number of rows in the grid. N (int): number of columns in the grid. grid (list[list[int]]): MxN grid where each cell is 0 (empty), 1 (house), or 2 (park). Returns: int: minimum possible maximum distance from any house to the nearest fire station. pass def test_min_max_distance_to_fire_station_case_1(): M, N = 3, 3 grid = [ [1, 0, 2], [0, 0, 0], [2, 0, 1] ] assert min_max_distance_to_fire_station(M, N, grid) == 2 def test_min_max_distance_to_fire_station_case_2(): M, N = 2, 2 grid = [ [0, 1], [1, 0] ] assert min_max_distance_to_fire_station(M, N, grid) == 1 def test_min_max_distance_to_fire_station_case_3(): M, N = 3, 3 grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert min_max_distance_to_fire_station(M, N, grid) == 2 def test_min_max_distance_to_fire_station_case_4(): M, N = 3, 4 grid = [ [0, 1, 0, 2], [0, 0, 0, 0], [1, 0, 0, 2] ] assert min_max_distance_to_fire_station(M, N, grid) == 2 def test_min_max_distance_to_fire_station_case_5(): M, N = 4, 3 grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert min_max_distance_to_fire_station(M, N, grid) == 3","solution":"def min_max_distance_to_fire_station(M, N, grid): Finds the minimum possible maximum distance from any house to the nearest fire station. Parameters: M (int): number of rows in the grid. N (int): number of columns in the grid. grid (list[list[int]]): MxN grid where each cell is 0 (empty), 1 (house), or 2 (park). Returns: int: minimum possible maximum distance from any house to the nearest fire station. from collections import deque # List of all houses in the grid houses = [(i, j) for i in range(M) for j in range(N) if grid[i][j] == 1] def bfs(houses, fire_station): Helper function to calculate the maximum distance from any house to the given fire station using BFS. Parameters: houses (list[tuple[int, int]]): list of coordinates of all houses. fire_station (tuple[int, int]): coordinates of the fire station. Returns: int: maximum distance from any house to the fire station. max_distance = 0 # Initialize maximum distance # Perform BFS for each house for house in houses: # Compute the Manhattan distance from fire station to current house distance = abs(fire_station[0] - house[0]) + abs(fire_station[1] - house[1]) max_distance = max(max_distance, distance) # Update the maximum distance return max_distance min_max_distance = float('inf') # Evaluate each empty cell to be the possible place for the fire station for i in range(M): for j in range(N): if grid[i][j] == 0: # This cell is empty max_distance = bfs(houses, (i, j)) min_max_distance = min(min_max_distance, max_distance) return min_max_distance # Example usage (Commented out for testing purposes) # M, N = 3, 3 # grid = [ # [1, 0, 2], # [0, 0, 0], # [2, 0, 1] # ] # print(min_max_distance_to_fire_station(M, N, grid)) # Output: 2"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(level_order): Builds a binary tree from level-order traversal. # Implementation here def tree_height_and_balance(root): Determines the height of the tree and whether it is balanced or not. Returns a tuple of height and balanced status. # Implementation here def process_test_cases(T, test_cases): Processes multiple test cases to find the height and balance status of each binary tree. Args: T (int): Number of test cases. test_cases (List[str]): A list of binary trees represented in level-order traversal. Returns: List[str]: For each test case, returns two integers separated by a space: the height of the binary tree and 1 if the tree is balanced, otherwise 0. # Implementation here # Unit Tests def test_case_1(): T = 2 test_cases = [ \\"3 9 20 null null 15 7\\", \\"1 2 2 3 3 null null 4 4\\" ] result = process_test_cases(T, test_cases) assert result == [\\"3 1\\", \\"4 0\\"] def test_case_single_node(): T = 1 test_cases = [\\"1\\"] result = process_test_cases(T, test_cases) assert result == [\\"1 1\\"] def test_case_none_tree(): T = 1 test_cases = [\\"null\\"] result = process_test_cases(T, test_cases) assert result == [\\"0 1\\"] def test_case_unbalanced(): T = 1 test_cases = [\\"1 2 3 4 null null null 5\\"] result = process_test_cases(T, test_cases) assert result == [\\"4 0\\"] def test_case_balanced(): T = 1 test_cases = [\\"1 2 3 4 5 6 7\\"] result = process_test_cases(T, test_cases) assert result == [\\"3 1\\"]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(level_order): from collections import deque if not level_order or level_order[0] == 'null': return None root = TreeNode(int(level_order[0])) queue = deque([root]) i = 1 while queue and i < len(level_order): node = queue.popleft() if level_order[i] != 'null': node.left = TreeNode(int(level_order[i])) queue.append(node.left) i += 1 if i < len(level_order) and level_order[i] != 'null': node.right = TreeNode(int(level_order[i])) queue.append(node.right) i += 1 return root def tree_height_and_balance(root): def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) height = max(left_height, right_height) + 1 balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return height, balanced height, balanced = check_balance(root) return height, 1 if balanced else 0 def process_test_cases(T, test_cases): results = [] for case in test_cases: level_order = case.split() root = build_tree(level_order) height, balanced = tree_height_and_balance(root) results.append(f\\"{height} {balanced}\\") return results"},{"question":"def vasya_books(favorite_genres, books): This function determines which books Vasya will read until he finds one he likes. Parameters: favorite_genres (list of str): List of Vasya's favorite genres. books (list of tuples): List of books with each tuple containing the title and genre of the book. Returns: list of str: Titles of books Vasya will read until he finds one he likes or \\"None\\" if he doesn't like any books. Example: >>> vasya_books([\\"fiction\\", \\"mystery\\", \\"drama\\"], [(\\"book1\\", \\"mystery\\"), (\\"book2\\", \\"sci-fi\\"), (\\"book3\\", \\"drama\\")]) [\\"book1\\"] >>> vasya_books([\\"fantasy\\", \\"adventure\\"], [(\\"bookA\\", \\"horror\\"), (\\"bookB\\", \\"mystery\\"), (\\"bookC\\", \\"adventure\\")]) [\\"bookC\\"] >>> vasya_books([\\"romance\\"], [(\\"bookA\\", \\"horror\\"), (\\"bookB\\", \\"mystery\\"), (\\"bookC\\", \\"adventure\\")]) [\\"None\\"] pass from solution import vasya_books def test_case_1(): favorite_genres = [\\"fiction\\", \\"mystery\\", \\"drama\\"] books = [(\\"book1\\", \\"mystery\\"), (\\"book2\\", \\"sci-fi\\"), (\\"book3\\", \\"drama\\"), (\\"book4\\", \\"romance\\"), (\\"book5\\", \\"fiction\\")] assert vasya_books(favorite_genres, books) == [\\"book1\\"] def test_case_2(): favorite_genres = [\\"fantasy\\", \\"adventure\\"] books = [(\\"bookA\\", \\"horror\\"), (\\"bookB\\", \\"mystery\\"), (\\"bookC\\", \\"adventure\\"), (\\"bookD\\", \\"sci-fi\\")] assert vasya_books(favorite_genres, books) == [\\"bookC\\"] def test_case_3(): favorite_genres = [\\"romance\\"] books = [(\\"bookA\\", \\"horror\\"), (\\"bookB\\", \\"mystery\\"), (\\"bookC\\", \\"adventure\\")] assert vasya_books(favorite_genres, books) == [\\"None\\"] def test_case_4(): favorite_genres = [\\"history\\", \\"biography\\"] books = [(\\"book1\\", \\"fiction\\"), (\\"book2\\", \\"history\\"), (\\"book3\\", \\"drama\\")] assert vasya_books(favorite_genres, books) == [\\"book2\\"] def test_case_5(): favorite_genres = [\\"adventure\\", \\"science\\"] books = [(\\"book1\\", \\"adventure\\"), (\\"book2\\", \\"science\\"), (\\"book3\\", \\"mystery\\")] assert vasya_books(favorite_genres, books) == [\\"book1\\"]","solution":"def vasya_books(favorite_genres, books): This function determines which books Vasya will read until he finds one he likes. Parameters: favorite_genres (list of str): List of Vasya's favorite genres. books (list of tuples): List of books with each tuple containing the title and genre of the book. Returns: list of str: Titles of books Vasya will read until he finds one he likes or \\"None\\" if he doesn't like any books. favorite_genres_set = set(favorite_genres) for title, genre in books: if genre in favorite_genres_set: return [title] return [\\"None\\"]"},{"question":"def longest_increasing_subsequence(n: int, arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence of arr. >>> longest_increasing_subsequence(8, [10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> longest_increasing_subsequence(6, [3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence(5, [3, 2, 1, 5, 4]) 2","solution":"import bisect def longest_increasing_subsequence(n, arr): Returns the length of the longest strictly increasing subsequence of arr. if n == 0: return 0 # dp array to store the increasing subsequence dp = [] for num in arr: # Use binary search to find the index of the smallest number >= num pos = bisect.bisect_left(dp, num) # If pos is equal to the length of dp, num is greater than any elements in dp if pos == len(dp): dp.append(num) else: # Replace dp[pos] with num to maintain the potential increasing subsequence dp[pos] = num return len(dp)"},{"question":"def compress_sequence(n: int, k: int, sequence: List[int]) -> List[int]: Compresses the sequence based on the given subsequence length k. Parameters: n (int): Total number of elements in the sequence. k (int): Length of each subsequence. sequence (list): The original sequence of integers. Returns: list: The compressed sequence. >>> compress_sequence(8, 2, [10, 20, 30, 40, 50, 60, 70, 80]) [15, 2, 35, 2, 55, 2, 75, 2] >>> compress_sequence(6, 3, [5, 5, 5, 10, 10, 10]) [5, 3, 10, 3] from typing import List def test_compress_sequence_example1(): n = 8 k = 2 sequence = [10, 20, 30, 40, 50, 60, 70, 80] expected_output = [15, 2, 35, 2, 55, 2, 75, 2] assert compress_sequence(n, k, sequence) == expected_output def test_compress_sequence_example2(): n = 6 k = 3 sequence = [5, 5, 5, 10, 10, 10] expected_output = [5, 3, 10, 3] assert compress_sequence(n, k, sequence) == expected_output def test_compress_sequence_single_element_subsequences(): n = 4 k = 1 sequence = [1, 2, 3, 4] expected_output = [1, 1, 2, 1, 3, 1, 4, 1] assert compress_sequence(n, k, sequence) == expected_output def test_compress_sequence_large_k(): n = 8 k = 4 sequence = [10, 20, 30, 40, 50, 60, 70, 80] expected_output = [25, 4, 65, 4] assert compress_sequence(n, k, sequence) == expected_output def test_compress_sequence_all_same_elements(): n = 6 k = 3 sequence = [7, 7, 7, 7, 7, 7] expected_output = [7, 3, 7, 3] assert compress_sequence(n, k, sequence) == expected_output","solution":"def compress_sequence(n, k, sequence): Compresses the sequence based on the given subsequence length k. Parameters: n (int): Total number of elements in the sequence. k (int): Length of each subsequence. sequence (list): The original sequence of integers. Returns: list: The compressed sequence. compressed_sequence = [] for i in range(0, n, k): subsequence = sequence[i:i + k] avg_value = sum(subsequence) // k compressed_sequence.extend([avg_value, k]) return compressed_sequence"},{"question":"def reverse_words(s: str) -> str: Reverses the characters of each word in the string s while keeping the order of the words unchanged. >>> reverse_words(\\"This is an example\\") 'sihT si na elpmaxe' >>> reverse_words(\\"hello\\") 'olleh' >>> reverse_words(\\" hello world \\") ' olleh dlrow ' >>> reverse_words(\\"a b\\") 'a b' >>> reverse_words(\\"123 456 789\\") '321 654 987' >>> reverse_words(\\"abc123 def456\\") '321cba 654fed' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" \\") ' '","solution":"def reverse_words(s): Reverses the characters of each word in the string s while keeping the order of the words unchanged. Parameters: s (str): The input string containing alphanumeric characters and spaces Returns: str: The transformed string with each word's characters reversed # Split the input string by spaces words = s.split(' ') # Reverse each word and join them back with a space reversed_words = [''.join(reversed(word)) for word in words] return ' '.join(reversed_words)"},{"question":"def min_operations_to_make_queue_interesting(N, A): Returns the minimum number of operations required to make the queue interesting or -1 if it's impossible. Parameters: N (int): The number of people in the queue. A (List[int]): The list of heights of the people in the queue. Returns: int: The minimum number of operations or -1 if it's impossible. Example: >>> min_operations_to_make_queue_interesting(5, [4, 3, 5, 6, 2]) 3 >>> min_operations_to_make_queue_interesting(4, [5, 3, 4, 6]) 2 pass def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results for each test case. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of N integers representing heights. Returns: List[int]: A list containing the results for each test case. results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] result = min_operations_to_make_queue_interesting(N, A) results.append(result) return results # Unit Tests def test_case_1(): test_cases = [ (5, [4, 3, 5, 6, 2]), (4, [5, 3, 4, 6]) ] assert process_test_cases(2, test_cases) == [3, 2] def test_case_2(): test_cases = [ (3, [1, 2, 3]), (3, [3, 2, 1]) ] assert process_test_cases(2, test_cases) == [0, 0] def test_case_3(): test_cases = [ (5, [1, 5, 3, 2, 4]), ] assert process_test_cases(1, test_cases) == [-1] def test_case_4(): test_cases = [ (4, [1, 3, 2, 4]), (4, [1, 2, 3, 4]) ] assert process_test_cases(2, test_cases) == [1, 0] def test_case_5(): test_cases = [ (6, [1, 3, 4, 5, 6, 6]), ] assert process_test_cases(1, test_cases) == [0]","solution":"def min_operations_to_make_queue_interesting(N, A): Returns the minimum number of operations required to make the queue interesting or -1 if it's impossible. operations = 0 # For simplicity, we can bubble sort adjacent elements until all differences are <= 1 for i in range(N - 2, -1, -1): if abs(A[i] - A[i + 1]) > 1: return -1 # Impossible if any consecutive difference greater than 1 return operations def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] result = min_operations_to_make_queue_interesting(N, A) results.append(result) return results"},{"question":"def longest_special_subarray(arr: List[int]) -> int: Determines the length of the longest subarray that contains both even and odd numbers. >>> longest_special_subarray([1, 2, 3, 4, 5, 6, 7]) 7 >>> longest_special_subarray([1, 3, 5, 7, 9]) 0","solution":"def longest_special_subarray(arr): Determines the length of the longest subarray that contains both even and odd numbers. :param arr: The list of integers. :return: The length of the longest \\"special\\" subarray. n = len(arr) has_even = any(num % 2 == 0 for num in arr) has_odd = any(num % 2 != 0 for num in arr) if not has_even or not has_odd: return 0 return n"},{"question":"def minSwapsToSort(heights: List[int]) -> int: Returns the minimum number of adjacent swaps required to arrange the books in non-decreasing order of height. >>> minSwapsToSort([3, 1, 2, 4]) 2 >>> minSwapsToSort([4, 3, 2, 1]) 6","solution":"def minSwapsToSort(heights): Returns the minimum number of adjacent swaps required to sort the books in non-decreasing order. n = len(heights) swaps = 0 for i in range(n): for j in range(n - 1): if heights[j] > heights[j + 1]: # Swap adjacent elements heights[j], heights[j + 1] = heights[j + 1], heights[j] swaps += 1 return swaps"},{"question":"from typing import List def min_jumps(arr: List[int]) -> int: Determines the minimum number of jumps needed to reach the last position of the array. Returns -1 if it is not possible to reach the end of the array. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([0]) 0 >>> min_jumps([0, 0, 0, 0]) -1 >>> min_jumps([1]) 0 >>> min_jumps([1, 2, 0, 1, 4]) 3 >>> min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) 3","solution":"def min_jumps(arr): Determines the minimum number of jumps needed to reach the last position of the array. Returns -1 if it is not possible to reach the end of the array. if len(arr) <= 1: return 0 jumps = 0 max_reach = 0 step = 0 for i in range(len(arr)): if i > max_reach: return -1 if i + arr[i] > step: step = i + arr[i] if i == max_reach: jumps += 1 max_reach = step if max_reach >= len(arr) - 1: return jumps return -1"},{"question":"def longest_unique_substring(s: str) -> str: Given a string, find and display the longest substring without repeating characters. If there are multiple substrings with the same maximum length, return the one which appears first. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke'","solution":"def longest_unique_substring(s): Given a string, find and display the longest substring without repeating characters. If there are multiple substrings with the same maximum length, return the one which appears first. start = 0 # Starting index of current substring max_len = 0 # Length of longest substring found start_max = 0 # Starting index of longest substring found used_chars = {} # Dictionary to store characters and their latest indices for i, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len start_max = start return s[start_max:start_max + max_len]"},{"question":"def winner(A: int, B: int) -> str: Determines the winner based on the product of A and B. If the product is even, Bob wins; otherwise, Alice wins. :param A: An integer between 1 and 200 inclusive. :param B: An integer between 1 and 200 inclusive. :return: A string \\"Bob\\" if the product is even, otherwise \\"Alice\\". >>> winner(2, 4) \\"Bob\\" >>> winner(3, 8) \\"Bob\\" >>> winner(5, 7) \\"Alice\\" >>> winner(9, 11) \\"Alice\\" >>> winner(4, 3) \\"Bob\\" >>> winner(1, 1) \\"Alice\\" >>> winner(1, 200) \\"Bob\\"","solution":"def winner(A, B): Determines the winner based on the product of A and B. If the product is even, Bob wins; otherwise, Alice wins. :param A: An integer between 1 and 200 inclusive. :param B: An integer between 1 and 200 inclusive. :return: A string \\"Bob\\" if the product is even, otherwise \\"Alice\\". product = A * B if product % 2 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def can_complete_circle(n: int, h: int, hurdles: List[int]) -> str: Determines if Alice can complete one full circle of the track, jumping over each hurdle exactly once and returning to the starting hurdle. Parameters: n (int): Number of hurdles. h (int): Maximum height Alice can jump. hurdles (list): A list of integers representing the height of each hurdle in clockwise order. Returns: str: \\"YES\\" if Alice can complete the circle, \\"NO\\" otherwise. >>> can_complete_circle(5, 10, [1, 3, 2, 6, 5]) \\"YES\\" >>> can_complete_circle(4, 4, [5, 6, 5, 6]) \\"NO\\" >>> can_complete_circle(3, 7, [7, 10, 7]) \\"NO\\" >>> can_complete_circle(1, 1, [1]) \\"YES\\" >>> can_complete_circle(2, 2, [1, 3]) \\"NO\\" >>> can_complete_circle(6, 50, [30, 40, 50, 10, 20, 30]) \\"YES\\" >>> can_complete_circle(5, 5, [5, 5, 5, 5, 5]) \\"YES\\" >>> can_complete_circle(15, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) \\"YES\\"","solution":"def can_complete_circle(n, h, hurdles): Determines if Alice can complete one full circle of the track, jumping over each hurdle exactly once and returning to the starting hurdle. Parameters: n (int): Number of hurdles. h (int): Maximum height Alice can jump. hurdles (list): A list of integers representing the height of each hurdle in clockwise order. Returns: str: \\"YES\\" if Alice can complete the circle, \\"NO\\" otherwise. for height in hurdles: if height > h: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def max_score(tokens: List[int]) -> int: Determine the maximum score Alex can achieve by selecting tokens according to the game rules. Alex can pick any number of tokens, but he cannot pick two consecutive tokens. The score is the sum of the numbers on the tokens. Args: tokens: List of integers representing the numbers on the tokens. Returns: The maximum score Alex can achieve. Examples: >>> max_score([1, 2, 9, 4]) 10 >>> max_score([3, 2, 5, 10, 7]) 15 >>> max_score([5]) 5 >>> max_score([5, 5]) 5 >>> max_score([-1, 10]) 10","solution":"def max_score(tokens): n = len(tokens) if n == 0: return 0 if n == 1: return max(0, tokens[0]) dp = [0] * n dp[0] = max(0, tokens[0]) dp[1] = max(dp[0], tokens[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + tokens[i]) return dp[-1] def solve_game(n, token_values): return max_score(token_values)"},{"question":"def merge_sort(A, left, right): if left < right: mid = (left + right) // 2 merge_sort(A, left, mid) merge_sort(A, mid + 1, right) merge(A, left, mid, right) def merge(A, left, mid, right): n1 = mid - left + 1 n2 = right - mid L = [0] * n1 R = [0] * n2 for i in range(n1): L[i] = A[left + i] for j in range(n2): R[j] = A[mid + 1 + j] i = 0 j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: A[k] = L[i] i += 1 else: A[k] = R[j] j += 1 k += 1 while i < n1: A[k] = L[i] i += 1 k += 1 while j < n2: A[k] = R[j] j += 1 k += 1 def sort_array(arr): Sort an array of integers in ascending order using the Merge Sort algorithm. >>> sort_array([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> sort_array([12, 11, 13, 5, 6]) [5, 6, 11, 12, 13] >>> sort_array([4]) [4] >>> sort_array([5, 2]) [2, 5] >>> sort_array([1, 7, 3, 8, 5, 2, 6, 4]) [1, 2, 3, 4, 5, 6, 7, 8] >>> sort_array([4, 4, 4, 4]) [4, 4, 4, 4] >>> sort_array([2, 3, 2, 1, 3, 1]) [1, 1, 2, 2, 3, 3] >>> sort_array([-1, -3, -2, -4]) [-4, -3, -2, -1] >>> sort_array([0, -1, 1, -3, 3, -2, 2]) [-3, -2, -1, 0, 1, 2, 3]","solution":"def merge_sort(A, left, right): if left < right: mid = (left + right) // 2 merge_sort(A, left, mid) merge_sort(A, mid + 1, right) merge(A, left, mid, right) def merge(A, left, mid, right): n1 = mid - left + 1 n2 = right - mid L = [0] * n1 R = [0] * n2 for i in range(n1): L[i] = A[left + i] for j in range(n2): R[j] = A[mid + 1 + j] i = 0 j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: A[k] = L[i] i += 1 else: A[k] = R[j] j += 1 k += 1 while i < n1: A[k] = L[i] i += 1 k += 1 while j < n2: A[k] = R[j] j += 1 k += 1 def sort_array(arr): merge_sort(arr, 0, len(arr) - 1) return arr"},{"question":"import re def is_valid_email(email: str) -> bool: Checks the validity of an email address based on given rules. Parameters: email (str): The email address to be validated. Returns: bool: True if the email is valid, False otherwise. >>> is_valid_email(\\"john.doe@example.com\\") True >>> is_valid_email(\\"john..doe@example.com\\") False >>> is_valid_email(\\"john.doe@e-xample.com\\") True >>> is_valid_email(\\"john.doe@example\\") False import pytest def test_valid_email(): assert is_valid_email(\\"john.doe@example.com\\") == True def test_consecutive_dots_in_local(): assert is_valid_email(\\"john..doe@example.com\\") == False def test_valid_special_chars_in_local(): assert is_valid_email(\\"john-doe@example.com\\") == True def test_invalid_domain_part(): assert is_valid_email(\\"john.doe@example\\") == False def test_valid_email_with_numbers(): assert is_valid_email(\\"john123@example.com\\") == True def test_invalid_start_dot_in_local(): assert is_valid_email(\\".johndoe@example.com\\") == False def test_invalid_end_dot_in_local(): assert is_valid_email(\\"johndoe.@example.com\\") == False def test_domain_start_dot(): assert is_valid_email(\\"john.doe@.example.com\\") == False def test_domain_end_dot(): assert is_valid_email(\\"john.doe@example.com.\\") == False def test_double_hyphen_in_domain(): assert is_valid_email(\\"john.doe@exa--mple.com\\") == True def test_all_lower_case(): assert is_valid_email(\\"JOHN.DOE@EXAMPLE.COM\\".lower()) == True def test_special_characters_in_local(): assert is_valid_email(\\"a.b-c_d@example.com\\") == True def test_invalid_multiple_at(): assert is_valid_email(\\"john.doe@@example.com\\") == False def test_uppercase_letters_in_local(): assert is_valid_email(\\"John.Doe@example.com\\") == False","solution":"import re def is_valid_email(email): Checks the validity of an email address based on given rules. Parameters: email (str): The email address to be validated. Returns: bool: True if the email is valid, False otherwise. # Regex to match the local part local_regex = r\\"^[a-z0-9]+[a-z0-9._-]*[a-z0-9]+\\" # Regex to match the domain part domain_regex = r\\"^[a-z0-9]+([a-z0-9-]*[a-z0-9]+)?(.[a-z]{2,})+\\" try: local_part, domain_part = email.split('@') except ValueError: # If there is not exactly one '@' character return False # Check if the local part matches the local_regex if not re.match(local_regex, local_part): return False # Check if the domain part matches the domain_regex if not re.match(domain_regex, domain_part): return False # Check if there are consecutive dots in local-part if '..' in local_part: return False return True"},{"question":"def max_bonus_points(n: int, t: List[int], b: List[int]) -> int: Calculates the maximum bonus points a runner can collect given the times to each checkpoint and bonus points for each checkpoint. Parameters: n : int Number of checkpoints. t : List[int] Time taken to reach each checkpoint. b : List[int] Bonus points for each checkpoint. Returns: int Maximum bonus points that can be collected. >>> max_bonus_points(5, [1, 2, 3, 4, 5], [10, 20, 30, 40, 50]) 150 >>> max_bonus_points(4, [2, 4, 7, 10], [5, 15, 10, 20]) 50","solution":"def max_bonus_points(n, t, b): Calculates the maximum bonus points a runner can collect given the times to each checkpoint and bonus points for each checkpoint. Parameters: n (int): Number of checkpoints. t (list of int): Time taken to reach each checkpoint. b (list of int): Bonus points for each checkpoint. Returns: int: Maximum bonus points that can be collected. # The sum of all bonus points will be maximum since they must be collected # in the given order and each time in \`t\` matches perfectly. return sum(b) # Example usage # n = 5 # t = [1, 2, 3, 4, 5] # b = [10, 20, 30, 40, 50] # max_bonus_points(n, t, b) should return 150"},{"question":"def sorted_squares(nums): Given a list of integers nums, returns a new list containing the squares of each integer sorted in non-decreasing order. :param nums: List of integers :return: List of integers Examples: >>> sorted_squares([-4, -2, 0, 1, 3]) [0, 1, 4, 9, 16] >>> sorted_squares([1, 2, 3, 4]) [1, 4, 9, 16]","solution":"def sorted_squares(nums): Given a list of integers nums, returns a new list containing the squares of each integer sorted in non-decreasing order. :param nums: List of integers :return: List of integers squares = [x**2 for x in nums] return sorted(squares)"},{"question":"def can_construct(s1, s2, t): Determines if the target string t can be constructed by interleaving characters of s1 and s2. Args: s1 (str): The first source string. s2 (str): The second source string. t (str): The target string to be constructed. Returns: bool: True if the target string can be constructed, False otherwise. Examples: >>> can_construct(\\"abc\\", \\"def\\", \\"adbcef\\") True >>> can_construct(\\"ab\\", \\"cd\\", \\"abcd\\") True >>> can_construct(\\"ab\\", \\"cd\\", \\"abdc\\") False pass def interleave_game(test_cases): Determines for each test case if the target string t can be constructed by interleaving characters of s1 and s2. Args: test_cases (list): A list of tuples, each containing three strings: s1, s2, and t. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. Examples: >>> test_cases = [(\\"abc\\", \\"def\\", \\"adbcef\\"), (\\"ab\\", \\"cd\\", \\"abcd\\"), (\\"ab\\", \\"cd\\", \\"abdc\\")] >>> interleave_game(test_cases) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_construct(s1, s2, t): Determines if the target string t can be constructed by interleaving characters of s1 and s2. memo = {} def dp(i, j): if (i, j) in memo: return memo[(i, j)] if i == len(s1) and j == len(s2): return True if i < len(s1) and s1[i] == t[i + j] and dp(i + 1, j): memo[(i, j)] = True return True if j < len(s2) and s2[j] == t[i + j] and dp(i, j + 1): memo[(i, j)] = True return True memo[(i, j)] = False return False return dp(0, 0) def interleave_game(test_cases): results = [] for s1, s2, t in test_cases: if can_construct(s1, s2, t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class PriorityQueue: def __init__(self): self.heap = [] self.count = 0 self.visitor_map = {} def add_visitor(self, priority, visitor_id): Add a visitor to the priority queue with their priority level. pass def remove_highest_priority_visitor(self): Remove the visitor with the highest priority from the queue. If there are multiple visitors with the same priority, the one who entered the queue earlier should be served first. pass def get_highest_priority_visitor(self): Get the visitor with the highest priority from the queue. pass def process_queries(queries: List[str]) -> List[str]: Process a list of queries to maintain the priority queue of visitors and distribute books. Args: queries (List[str]): List of strings representing the queries. Returns: List[str]: For each query of type \\"3 bookID\\", output the visitor ID and the book ID. >>> process_queries([\\"1 5 101\\", \\"1 10 102\\", \\"1 7 103\\", \\"3 201\\", \\"2\\", \\"3 202\\", \\"2\\"]) [\\"102 201\\", \\"103 202\\"] >>> process_queries([\\"1 8 104\\", \\"1 9 105\\", \\"2\\", \\"3 301\\"]) [\\"104 301\\"] pq = PriorityQueue() results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": _, priority, visitor_id = parts pq.add_visitor(int(priority), int(visitor_id)) elif parts[0] == \\"2\\": pq.remove_highest_priority_visitor() elif parts[0] == \\"3\\": _, book_id = parts visitor_id = pq.get_highest_priority_visitor() if visitor_id is not None: results.append(f\\"{visitor_id} {book_id}\\") return results","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.count = 0 self.visitor_map = {} def add_visitor(self, priority, visitor_id): heapq.heappush(self.heap, (-priority, self.count, visitor_id)) self.visitor_map[visitor_id] = priority self.count += 1 def remove_highest_priority_visitor(self): if self.heap: _, _, visitor_id = heapq.heappop(self.heap) del self.visitor_map[visitor_id] return visitor_id return None def get_highest_priority_visitor(self): if not self.heap: return None return self.heap[0][2] def process_queries(queries): pq = PriorityQueue() results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": _, priority, visitor_id = parts pq.add_visitor(int(priority), int(visitor_id)) elif parts[0] == \\"2\\": pq.remove_highest_priority_visitor() elif parts[0] == \\"3\\": _, book_id = parts visitor_id = pq.get_highest_priority_visitor() if visitor_id is not None: results.append(f\\"{visitor_id} {book_id}\\") return results"},{"question":"def product_of_weights_in_mst(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: You are given an undirected graph with n nodes and m edges. Each edge has a weight associated with it. Your task is to find the minimum spanning tree (MST) of this graph and compute the product of the weights of all the edges in the MST. >>> product_of_weights_in_mst(4, 5, [(1, 2, 3), (1, 3, 1), (2, 3, 3), (2, 4, 6), (3, 4, 2)]) 6 >>> product_of_weights_in_mst(3, 0, []) 1 :param n: Number of nodes (1  n  1000) :param m: Number of edges (0  m  10000) :param edge_list: List of tuples with edges (u, v, w) where (1  u, v  n; 1  w  1000) :return: The product of the weights of all the edges in the MST modulo 998244353. If there are no edges, return 1.","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): edges = sorted(edges, key=lambda item: item[2]) # Sort edges by weight parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_edges = [] for edge in edges: u, v, w = edge x = find(parent, u - 1) y = find(parent, v - 1) if x != y: mst_edges.append(edge) union(parent, rank, x, y) if len(mst_edges) == n - 1: break return mst_edges def product_of_weights_in_mst(n, m, edge_list): if m == 0: # no edges return 1 mst_edges = kruskal_mst(n, edge_list) product = 1 MOD = 998244353 for edge in mst_edges: product = (product * edge[2]) % MOD return product # Reading input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edge_list = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edge_list.append((u, v, w)) index += 3 result = product_of_weights_in_mst(n, m, edge_list) print(result)"},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers up to and including n. >>> sum_of_primes(10) == 17 >>> sum_of_primes(7) == 17 >>> sum_of_primes(1) == 0 >>> sum_of_primes(2) == 2 >>> sum_of_primes(19) == 77 >>> sum_of_primes(100) == 1060 >>> sum_of_primes(1000000) == 37550402023","solution":"def sum_of_primes(n): Returns the sum of all prime numbers up to and including n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 return sum(index for index, is_prime in enumerate(sieve) if is_prime)"},{"question":"def search(nums: List[int], target: int) -> int: Returns the index of target in the rotated sorted list nums. If target is not present, returns -1. Example 1: >>> search([4, 5, 6, 7, 0, 1, 2], 0) 4 Example 2: >>> search([4, 5, 6, 7, 0, 1, 2], 3) -1 def test_search(): assert search([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert search([4, 5, 6, 7, 0, 1, 2], 3) == -1 assert search([1], 0) == -1 assert search([1], 1) == 0 assert search([5, 1, 3], 5) == 0 assert search([5, 1, 3], 3) == 2 assert search([4, 5, 6, 7, 8, 9, 1, 2, 3], 6) == 2 assert search([4, 5, 6, 7, 8, 9, 1, 2, 3], 1) == 6 assert search([6, 7, 8, 1, 2, 3, 4, 5], 8) == 2 assert search([6, 7, 8, 1, 2, 3, 4, 5], 3) == 5 assert search([5, 6, 7, 8, 9, 1, 2, 3, 4], 1) == 5","solution":"def search(nums, target): Returns the index of target in the rotated sorted list nums. If target is not present, returns -1. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # Determine which part is sorted if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def max_total_sweetness(n: int, m: int, sweetness_levels: List[int]) -> int: Determine the maximum total sweetness for groups of m candies. Args: n: int - The number of different types of candy. m: int - The number of candies each person should receive. sweetness_levels: List[int] - The sweetness levels of each type of candy. Returns: int - The maximum total sweetness for each person. Examples: >>> max_total_sweetness(1, 1, [5]) 5 >>> max_total_sweetness(4, 3, [5, 3, 9, 7]) 21 >>> max_total_sweetness(4, 2, [5, 5, 5, 5]) 10 >>> max_total_sweetness(5, 5, [5, 3, 9, 7, 2]) 26 >>> max_total_sweetness(5, 5, [1, 2, 3, 4, 5]) 15","solution":"def max_total_sweetness(n, m, sweetness_levels): Returns the maximum possible total sweetness for groups of m candies. # Sorting sweetness levels in descending order. sweetness_levels.sort(reverse=True) # Get the sum of m highest sweetness levels. return sum(sweetness_levels[:m])"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together in the form of lists within a list. :param words: List of words containing lowercase letters. :return: List of lists containing grouped anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\", \\"b\\", \\"\\"]) [[\\"\\", \\"\\"], [\\"b\\"]] >>> group_anagrams([\\"abc\\"]) [[\\"abc\\"]] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"]] >>> group_anagrams([\\"cat\\", \\"dog\\", \\"tac\\", \\"god\\", \\"act\\"]) [[\\"cat\\", \\"tac\\", \\"act\\"], [\\"dog\\", \\"god\\"]]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together in the form of lists within a list. :param words: List of words containing lowercase letters. :return: List of lists containing grouped anagrams. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def can_form_anagram(s: str) -> str: Given a string consisting of 'a', 'b', and 'c', determine if it can be rearranged to form an anagram of a string consisting of 'x', 'y', and 'z'. >>> can_form_anagram(\\"aacbb\\") == \\"Yes\\" >>> can_form_anagram(\\"aaaaa\\") == \\"Yes\\" >>> can_form_anagram(\\"abccba\\") == \\"Yes\\" >>> can_form_anagram(\\"b\\") == \\"Yes\\" >>> can_form_anagram(\\"abcabc\\") == \\"Yes\\"","solution":"def can_form_anagram(s): Determines if the input string consisting of 'a', 'b', and 'c' can be rearranged to form an anagram of a string of equal length consisting of 'x', 'y', and 'z'. from collections import Counter # Count the number of occurrences of each character in 's' counter = Counter(s) # Check if the counts of 'a', 'b', and 'c' add up to the length of the string total_chars = counter['a'] + counter['b'] + counter['c'] # Since s contains only 'a', 'b', 'c', and the length of 's' is equal to \`total_chars\`, # it is possible to rearrange 's' to match 'x', 'y', 'z'. # Indeed, if 'x', 'y', 'z' have constraints that each occurs only a certain number of times, # it does not affect as long as the counts sum up correctly. if total_chars == len(s): return \\"Yes\\" else: return \\"No\\""},{"question":"MOD = 1000000007 def handle_operations(operations): result = [] array = [] for operation in operations: parts = operation.split() if parts[0] == '1': # Operation to insert an integer pass elif parts[0] == '2': # Operation to compute the product of a subarray pass return result def process_input(input_data): Process the input to handle multiple cases of insertions and queries. Args: input_data (str): Multiline string containing the number of cases, followed by operations and queries. Returns: List[int]: List of results for each query operation. >>> input_data = \\"1n5n1 4n1 5n1 3n2 1 2n2 1 3\\" >>> process_input(input_data) [20, 60] >>> input_data = \\"2n2n1 5n2 1 1n3n1 3n1 4n2 1 2\\" >>> process_input(input_data) [5, 12] lines = input_data.strip().split('n') t = int(lines[0]) idx = 1 results = [] for _ in range(t): m = int(lines[idx]) operations = lines[idx + 1: idx + 1 + m] results.extend(handle_operations(operations)) idx += 1 + m return results import pytest def test_case_1(): input_data = \\"1n5n1 4n1 5n1 3n2 1 2n2 1 3\\" expected_output = [20, 60] assert process_input(input_data) == expected_output def test_case_2(): input_data = \\"1n4n1 2n1 3n2 1 1n2 1 2\\" expected_output = [2, 6] assert process_input(input_data) == expected_output def test_case_3(): input_data = \\"1n6n1 10n1 20n1 30n2 1 2n1 40n2 1 4\\" expected_output = [200, 240000] assert process_input(input_data) == expected_output def test_case_single_case(): input_data = \\"1n1n1 3\\" expected_output = [] assert process_input(input_data) == expected_output def test_case_with_no_queries(): input_data = \\"1n3n1 7n1 8n1 9\\" expected_output = [] assert process_input(input_data) == expected_output def test_case_multiple_tests(): input_data = \\"2n2n1 5n2 1 1n3n1 3n1 4n2 1 2\\" expected_output = [5, 12] assert process_input(input_data) == expected_output","solution":"MOD = 1000000007 def handle_operations(operations): result = [] array = [] for operation in operations: parts = operation.split() if parts[0] == '1': # Operation to insert an integer x = int(parts[1]) array.append(x) elif parts[0] == '2': # Operation to compute the product of a subarray a = int(parts[1]) b = int(parts[2]) product = 1 for i in range(a - 1, b): product = (product * array[i]) % MOD result.append(product) return result def process_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) idx = 1 results = [] for _ in range(t): m = int(lines[idx]) operations = lines[idx + 1: idx + 1 + m] results.extend(handle_operations(operations)) idx += 1 + m return results"},{"question":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers in the list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_sequence([5]) == 1 >>> longest_consecutive_sequence([10, 20, 30, 40]) == 1 >>> longest_consecutive_sequence([5, 6, 7, 8, 9, 10]) == 6 >>> longest_consecutive_sequence([0, -1, 1, 2, -2, -3]) == 6 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) == 4 >>> longest_consecutive_sequence([1, 2, 3, 10, 11, 20, 21, 22, 23, 24]) == 5","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers in the list. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak if __name__ == \\"__main__\\": import sys input = sys.stdin.read().strip().split(\\"n\\") L = int(input[0]) nums = list(map(int, input[1:])) print(longest_consecutive_sequence(nums))"},{"question":"import sys from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any subarray of the given array. Args: arr (List[int]): A list of n integers. Returns: int: The sum of the subarray with the maximum sum. Examples: >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4]) -1 pass def process_input(n: int, arr: List[int]) -> int: Processes the input to find the maximum sum of any subarray. Args: n (int): The number of elements in the array. arr (List[int]): A list of n integers. Returns: int: The sum of the subarray with the maximum sum. return max_subarray_sum(arr) # Unit Tests def test_max_subarray_sum_positive_numbers(): assert process_input(5, [1, 2, 3, -2, 5]) == 9 def test_max_subarray_sum_all_negative_numbers(): assert process_input(4, [-1, -2, -3, -4]) == -1 def test_max_subarray_sum_single_number(): assert process_input(1, [5]) == 5 assert process_input(1, [-5]) == -5 def test_max_subarray_sum_mixed_sign_numbers(): assert process_input(6, [-1, 2, 3, -5, 2, 2]) == 5 def test_max_subarray_sum_large_input(): large_input = [1]*100000 assert process_input(100000, large_input) == 100000","solution":"def max_subarray_sum(arr): Returns the maximum sum of any subarray of the given array. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_input(n, arr): return max_subarray_sum(arr)"},{"question":"def sorted_substrings(S: str) -> list: Returns all possible substrings of the string S in lexicographic sorted order. >>> sorted_substrings(\\"bcda\\") ['a', 'b', 'bc', 'bcd', 'bcda', 'c', 'cd', 'cda', 'd', 'da'] >>> sorted_substrings(\\"abc\\") ['a', 'ab', 'abc', 'b', 'bc', 'c'] >>> sorted_substrings(\\"a\\") ['a'] >>> sorted_substrings(\\"ab\\") ['a', 'ab', 'b'] >>> sorted_substrings(\\"aa\\") ['a', 'aa'] pass def print_sorted_substrings(S: str) -> None: Print all possible substrings of the string S in lexicographic sorted order. >>> print_sorted_substrings(\\"bcda\\") a b bc bcd bcda c cd cda d da >>> print_sorted_substrings(\\"abc\\") a ab abc b bc c >>> print_sorted_substrings(\\"a\\") a >>> print_sorted_substrings(\\"ab\\") a ab b >>> print_sorted_substrings(\\"aa\\") a aa pass","solution":"def sorted_substrings(S): Returns all possible substrings of the string S in lexicographic sorted order. substrings = set() n = len(S) for i in range(n): for j in range(i + 1, n + 1): substrings.add(S[i:j]) return sorted(substrings) def print_sorted_substrings(S): Print all possible substrings of the string S in lexicographic sorted order. for substring in sorted_substrings(S): print(substring)"},{"question":"def min_trips(weights, capacity): Determine the minimum number of trips needed to transport all parcels. Parameters: weights (list of int): List of weights of the parcels. capacity (int): The weight capacity of the van. Returns: int: Minimum number of trips. >>> min_trips([2, 3, 4, 5, 9], 10) 3 >>> min_trips([1, 2, 3, 4, 5], 10) 2 >>> min_trips([4, 4, 4, 4], 6) 4 >>> min_trips([7, 2, 3, 9, 5], 10) 3 >>> min_trips([6, 6, 6, 6], 12) 2 >>> min_trips([5], 10) 1 >>> min_trips([100], 100) 1 >>> min_trips([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10) 1","solution":"def min_trips(weights, capacity): Determine the minimum number of trips needed to transport all parcels. Parameters: weights (list of int): List of weights of the parcels. capacity (int): The weight capacity of the van. Returns: int: Minimum number of trips. from itertools import combinations def count_trips(current_weights, current_capacity): if not current_weights: return 0 # Try to find the best fit for the remaining capacity for i in range(len(current_weights), 0, -1): for combo in combinations(current_weights, i): if sum(combo) <= current_capacity: remaining_weights = list(current_weights) for weight in combo: remaining_weights.remove(weight) return 1 + count_trips(remaining_weights, current_capacity) return float('inf') return count_trips(weights, capacity)"},{"question":"def canRearrange(S: str) -> str: Determine if a string can be rearranged such that no two adjacent characters are the same. Parameters: S (str): Input string consisting of lowercase letters. Returns: str: \\"Yes\\" if the rearrangement is possible, otherwise \\"No\\". Example: >>> canRearrange(\\"aabb\\") \\"Yes\\" >>> canRearrange(\\"aaab\\") \\"No\\"","solution":"from collections import Counter import heapq def canRearrange(S): Determine if a string can be rearranged such that no two adjacent characters are the same. Parameters: S (str): Input string consisting of lowercase letters. Returns: str: \\"Yes\\" if the rearrangement is possible, otherwise \\"No\\". # Step 1: Create a frequency counter for the characters freq = Counter(S) # Step 2: Create a max heap based on character frequencies max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Step 3: Initialize previous element tracker prev_count, prev_char = 0, '' # Step 4: Construct the string using characters from the heap result = [] while max_heap: # Get the most frequent character count, char = heapq.heappop(max_heap) # Append the previous character back to the heap if it hasn't been used up if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Append the current character to the result list and update previous character result.append(char) prev_count, prev_char = count + 1, char # Decrement count since we're using one occurrence # If we successfully constructed a string without consecutive identical characters if len(result) == len(S): return \\"Yes\\" else: return \\"No\\""},{"question":"def min_watering_operations(test_cases): Given a list of test cases representing the farm dimensions and crop positions, finds the minimum number of watering operations required to water all crops. Args: test_cases (List[Dict]): A list of dictionaries. Each dictionary contains: - 'n': int, number of rows in the farm - 'm': int, number of columns in the farm - 'farm': List[str], a list of strings representing the farm grid, where '.' denotes an empty cell and '*' denotes a cell with a crop. Returns: List[int]: A list of integers where each integer represents the minimum number of watering operations for the corresponding test case. Example: >>> test_cases = [ { 'n': 3, 'm': 4, 'farm': [ '.*..', '..*.', '....' ] }, { 'n': 2, 'm': 3, 'farm': [ '*..', '..*' ] } ] >>> min_watering_operations(test_cases) [2, 2] import pytest def test_min_watering_operations(): test_cases = [ { 'n': 3, 'm': 4, 'farm': [ '.*..', '..*.', '....' ] }, { 'n': 2, 'm': 3, 'farm': [ '*..', '..*' ] } ] expected = [2, 2] result = min_watering_operations(test_cases) assert result == expected def test_min_watering_operations_single_row(): test_cases = [ { 'n': 1, 'm': 5, 'farm': [ '*.*.*' ] } ] expected = [3] result = min_watering_operations(test_cases) assert result == expected def test_min_watering_operations_single_column(): test_cases = [ { 'n': 5, 'm': 1, 'farm': [ '*', '.', '*', '.', '*' ] } ] expected = [3] result = min_watering_operations(test_cases) assert result == expected def test_min_watering_operations_no_crops(): test_cases = [ { 'n': 4, 'm': 4, 'farm': [ '....', '....', '....', '....' ] } ] expected = [0] result = min_watering_operations(test_cases) assert result == expected def test_min_watering_operations_all_crops(): test_cases = [ { 'n': 2, 'm': 2, 'farm': [ '**', '**' ] } ] expected = [1] result = min_watering_operations(test_cases) assert result == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def min_watering_operations(test_cases): results = [] for case in test_cases: n, m = case['n'], case['m'] farm = case['farm'] def find_rectangles(): visited = [[False] * m for _ in range(n)] rectangles = 0 def dfs(x, y, crop_coords): if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or farm[x][y] != '*': return visited[x][y] = True crop_coords.append((x, y)) dfs(x + 1, y, crop_coords) dfs(x - 1, y, crop_coords) dfs(x, y + 1, crop_coords) dfs(x, y - 1, crop_coords) for i in range(n): for j in range(m): if farm[i][j] == '*' and not visited[i][j]: crop_coords = [] dfs(i, j, crop_coords) if crop_coords: rectangles += 1 return rectangles results.append(find_rectangles()) return results # Example usage: test_cases = [ { 'n': 3, 'm': 4, 'farm': [ '.*..', '..*.', '....' ] }, { 'n': 2, 'm': 3, 'farm': [ '*..', '..*' ] } ] for result in min_watering_operations(test_cases): print(result) # Output: 2, 2"},{"question":"from typing import List from collections import defaultdict def find_anagram_groups(words: List[str]) -> List[List[str]]: Returns groups of anagram words from the given list of words. :param words: List of words (lowercase English letters only) :type words: List[str] :return: List of anagram groups :rtype: List[List[str]] pass def format_output(groups: List[List[str]]) -> str: Formats the output from a list of anagram groups to the desired format :param groups: List of anagram groups :type groups: List[List[str]] :return: Formatted string with each group on a new line :rtype: str pass def group_anagrams(words: str) -> str: Top level function to be called with words lists to get output in desired format. :param str words: Input sentence containing space separated words :rtype: str pass # Unit Tests def test_find_anagram_groups(): words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"stop\\", \\"tops\\", \\"pots\\"] result = find_anagram_groups(words) assert result == [['enlist', 'inlets', 'listen', 'silent'], ['pots', 'stop', 'tops']] def test_format_output(): groups = [['enlist', 'inlets', 'listen', 'silent'], ['pots', 'stop', 'tops']] result = format_output(groups) assert result == 'enlist inlets listen silentnpots stop tops' def test_group_anagrams(): input_words = \\"listen silent enlist inlets stop tops pots\\" expected_output = 'enlist inlets listen silentnpots stop tops' assert group_anagrams(input_words) == expected_output input_words = \\"cat act tac dog god\\" expected_output = 'act cat tacndog god' assert group_anagrams(input_words) == expected_output def test_empty_input(): input_words = \\"\\" expected_output = '' assert group_anagrams(input_words) == expected_output def test_single_word(): input_words = \\"word\\" expected_output = 'word' assert group_anagrams(input_words) == expected_output def test_no_anagrams(): input_words = \\"abcd efgh ijkl\\" expected_output = 'abcdnefghnijkl' assert group_anagrams(input_words) == expected_output def test_all_same_words(): input_words = \\"word word word\\" expected_output = 'word word word' assert group_anagrams(input_words) == expected_output","solution":"from collections import defaultdict def find_anagram_groups(words): Returns groups of anagram words from the given list of words. :param words: List of words (lowercase English letters only) :type words: List[str] :return: List of anagram groups :rtype: List[List[str]] anagram_map = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) # Creating sorted list of anagram groups result = [] for group in anagram_map.values(): result.append(sorted(group)) # Sorting the list of groups lexicographically result.sort() return result def format_output(groups): Formats the output from a list of anagram groups to the desired format :param groups: List of anagram groups :type groups: List[List[str]] :return: Formatted string with each group on a new line :rtype: str return 'n'.join(' '.join(group) for group in groups) def group_anagrams(words): Top level function to be called with words lists to get output in desired format. :param str words: Input sentence containing space separated words :rtype: str word_list = words.split() groups = find_anagram_groups(word_list) return format_output(groups)"},{"question":"def max_pleasure_value(k, s): Returns the maximum possible total pleasure value after performing exactly k operations on string s. >>> max_pleasure_value(2, 'abcde') 10 >>> max_pleasure_value(1, 'abc') 3 >>> max_pleasure_value(1, 'a') 1 >>> max_pleasure_value(100, 'a') 100 >>> max_pleasure_value(5, 'abcdefgh') 40 >>> max_pleasure_value(3, 'abcd') 12 >>> max_pleasure_value(10, 'abcd') 40 >>> max_pleasure_value(1, 'a') 1","solution":"def max_pleasure_value(k, s): Returns the maximum possible total pleasure value after performing exactly k operations on string s. n = len(s) # In the optimal case, we'll always reverse the entire string in one go. total_pleasure = 0 remaining_operations = k while remaining_operations > 0: total_pleasure += n remaining_operations -= 1 return total_pleasure"},{"question":"def smallest_non_representable_sum(arr: List[int]) -> int: Finds the smallest positive integer that cannot be represented as the sum of any subset of elements of the array. Parameters: arr (List[int]): The input array of integers. Returns: int: The smallest positive integer that cannot be represented as the sum of any subset of elements of the array. >>> smallest_non_representable_sum([1, 2, 3]) 7 >>> smallest_non_representable_sum([1, 10, 3, 11, 6, 15]) 2 >>> smallest_non_representable_sum([1, 1, 1, 1]) 5 >>> smallest_non_representable_sum([1]) 2 >>> smallest_non_representable_sum([5, 7, 1, 1, 2, 3]) 20","solution":"def smallest_non_representable_sum(arr): Finds the smallest positive integer that cannot be represented as the sum of any subset of elements of the array. Parameters: arr (List[int]): The input array of integers. Returns: int: The smallest positive integer that cannot be represented as the sum of any subset of elements of the array. arr.sort() smallest_sum = 1 for num in arr: if num > smallest_sum: break smallest_sum += num return smallest_sum"},{"question":"def max_value_under_budget(n: int, values: List[int], budget: int) -> int: Determine the maximum total value of items that can be collected without exceeding the budget. Args: n (int): the number of items values (List[int]): the values of the items budget (int): the budget limit Returns: int: the maximum total value of items that can be collected without exceeding the budget >>> max_value_under_budget(5, [2, 2, 4, 5, 1], 10) 10 >>> max_value_under_budget(3, [1, 2, 3], 4) 4 >>> max_value_under_budget(4, [4, 3, 4, 2], 6) 6 >>> max_value_under_budget(8, [1, 1, 1, 1, 1, 1, 1, 1], 4) 4 >>> max_value_under_budget(2, [7, 3], 10) 10","solution":"def max_value_under_budget(n, values, budget): :param n: int - the number of items :param values: List[int] - the values of the items :param budget: int - the budget limit :return: int - the maximum total value of items that can be collected without exceeding the budget # Using a DP approach, similar to the 0/1 Knapsack problem dp = [0] * (budget + 1) for value in values: for b in range(budget, value - 1, -1): dp[b] = max(dp[b], dp[b - value] + value) return dp[budget]"},{"question":"def min_energy(N: int, M: int, grid: List[List[int]]) -> int: Returns the minimum energy required to reach the bottom-right corner from the top-left corner of the grid. >>> min_energy(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 7 >>> min_energy(2, 2, [ [1, 2], [1, 1] ]) 3 >>> min_energy(1, 1, [ [5] ]) 5","solution":"def min_energy(N, M, grid): Returns the minimum energy required to reach the bottom-right corner from the top-left corner of the grid. # Initialize the dp array. dp = [[0] * M for _ in range(N)] # Fill the first cell with its own cost. dp[0][0] = grid[0][0] # Fill the first row (can only come from the left). for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above). for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array. for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the answer. return dp[-1][-1]"},{"question":"from typing import List, Tuple def is_strongly_connected(n: int, m: int, transporters: List[Tuple[int, int]]) -> str: Determine if the system of locations and transporters is strongly connected. Args: n (int): The number of locations. m (int): The number of directional transporters. transporters (List[Tuple[int, int]]): The list of directional transporters (u, v) where there is a transporter from location u to location v. Returns: str: \\"YES\\" if the system is strongly connected, otherwise \\"NO\\". Examples: >>> is_strongly_connected(4, 5, [(1, 2), (2, 3), (3, 4), (4, 2), (4, 1)]) \\"YES\\" >>> is_strongly_connected(4, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" from solution import is_strongly_connected def test_example_1(): assert is_strongly_connected(4, 5, [(1, 2), (2, 3), (3, 4), (4, 2), (4, 1)]) == \\"YES\\" def test_example_2(): assert is_strongly_connected(4, 3, [(1, 2), (2, 3), (3, 1)]) == \\"NO\\" def test_single_node(): assert is_strongly_connected(1, 0, []) == \\"YES\\" def test_disconnected_graph(): assert is_strongly_connected(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_two_nodes_bidirectional(): assert is_strongly_connected(2, 2, [(1, 2), (2, 1)]) == \\"YES\\" def test_large_strongly_connected(): edges = [(i, i + 1) for i in range(1, 100000)] + [(100000, 1)] assert is_strongly_connected(100000, 100000, edges) == \\"YES\\"","solution":"from collections import defaultdict, deque def is_strongly_connected(n, m, transporters): def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited if n == 1: return \\"YES\\" # Build the graph and its reverse graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in transporters: graph[u].append(v) reverse_graph[v].append(u) # Perform BFS from first node using the graph and its reverse visited_from_start = bfs(1, graph) visited_reverse_from_start = bfs(1, reverse_graph) # Verify if all nodes are visited in both traversals if len(visited_from_start) == n and len(visited_reverse_from_start) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_extra_spend(prices, threshold): Calculate the minimum extra amount needed to reach the spending threshold. Parameters: - prices: List[int], list of prices of items. - threshold: int, the membership threshold. Returns: - int, the minimum extra amount needed to reach the threshold. If the total price of items is already above the threshold, returns 0. >>> min_extra_spend([150, 300, 600, 900, 1200], 5000) 1850 >>> min_extra_spend([100, 200, 300], 500) 0","solution":"def min_extra_spend(prices, threshold): Calculate the minimum extra amount needed to reach the spending threshold. Parameters: - prices: List[int], list of prices of items. - threshold: int, the membership threshold. Returns: - int, the minimum extra amount needed to reach the threshold. If the total price of items is already above the threshold, returns 0. total = sum(prices) if total >= threshold: return 0 else: return threshold - total"},{"question":"def smallest_square_side(X: int, Y: int) -> int: Returns the smallest integer side Z of a square such that the area of the square is greater than the area of the rectangle with sides X and Y. If no such Z exists, returns -1. >>> smallest_square_side(5, 4) 5 >>> smallest_square_side(4, 4) 5 >>> smallest_square_side(1, 1) 2 >>> smallest_square_side(10, 10) 11 >>> smallest_square_side(7, 3) 5 >>> smallest_square_side(1, 100) 11 >>> smallest_square_side(50, 2) 11 >>> smallest_square_side(100, 100) 101 >>> smallest_square_side(2, 2) 3 >>> smallest_square_side(3, 3) 4","solution":"def smallest_square_side(X, Y): Returns the smallest integer side Z of a square such that the area of the square is greater than the area of the rectangle with sides X and Y. If no such Z exists, returns -1. # Calculate the area of the rectangle rectangle_area = X * Y # Start with the smallest possible side length z = 1 Z = 1 # Iterate to find the smallest square side Z whose area is greater than the rectangle area while Z * Z <= rectangle_area: Z += 1 return Z"},{"question":"def can_sort_with_swaps(n: int, k: int, arr: List[int]) -> str: Determines if the array \`arr\` can be sorted in non-decreasing order using the allowed adjacent swap operations. >>> can_sort_with_swaps(5, 3, [3, 1, 4, 1, 5]) \\"YES\\" >>> can_sort_with_swaps(4, 1, [5, 8, 6, 2]) \\"NO\\"","solution":"def can_sort_with_swaps(n, k, arr): Determines if the array \`arr\` can be sorted in non-decreasing order using the allowed adjacent swap operations. sorted_arr = sorted(arr) # A function to perform BFS to check if we can reach all correct positions def can_reach_sorted_position(start, sorted_value): queue = [start] visited = set() while queue: index = queue.pop(0) if arr[index] == sorted_value: return True visited.add(index) # Check neighbors if within bounds and not visited if index > 0 and abs(arr[index] - arr[index - 1]) <= k and (index - 1) not in visited: queue.append(index - 1) if index < n - 1 and abs(arr[index] - arr[index + 1]) <= k and (index + 1) not in visited: queue.append(index + 1) return False for i in range(n): if not can_reach_sorted_position(i, sorted_arr[i]): return \\"NO\\" return \\"YES\\""},{"question":"def kthSmallest(matrix: List[List[int]], K: int) -> int: Returns the Kth smallest number in a given NxN matrix where each row and column is sorted in ascending order. >>> kthSmallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15]], 8) 13 >>> kthSmallest([ ... [1, 2], ... [1, 3]], 2) 1 >>> kthSmallest([ ... [10, 20, 30, 40], ... [15, 25, 35, 45], ... [24, 29, 37, 48], ... [32, 33, 39, 50]], 7) 30 >>> kthSmallest([[7]], 1) 7 >>> kthSmallest([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]], 1) 1","solution":"import heapq def kthSmallest(matrix, K): Returns the Kth smallest number in a given NxN matrix where each row and column is sorted in ascending order. N = len(matrix) min_heap = [] # Initialize the heap with the smallest element from each row for r in range(min(K, N)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min K times from the min heap count = 0 while min_heap: element, r, c = heapq.heappop(min_heap) count += 1 if count == K: return element if c < N - 1: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))"},{"question":"import math def tulip_grid(n): Returns the number of rows and columns for planting tulips in a grid such that the grid is as square as possible. Parameters: n (int): Number of tulips to plant Returns: tuple: The number of rows and columns in the grid Example: >>> tulip_grid(12) (3, 4) >>> tulip_grid(7) (1, 7) >>> tulip_grid(20) (4, 5)","solution":"import math def tulip_grid(n): Returns the number of rows and columns for planting tulips in a grid such that the grid is as square as possible. Parameters: n (int): Number of tulips to plant Returns: tuple: The number of rows and columns in the grid min_diff = n best_grid = (1, n) for rows in range(1, int(math.sqrt(n)) + 1): if n % rows == 0: columns = n // rows diff = abs(rows - columns) if diff < min_diff or (diff == min_diff and rows < best_grid[0]): min_diff = diff best_grid = (rows, columns) return best_grid"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(19) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(15) False def prime_nonprime_sort(numbers: List[int]) -> List[int]: Arrange N integers such that all prime numbers come before all non-prime numbers, and within each group, they are sorted in descending order. >>> prime_nonprime_sort([10, 29, 3, 20, 17, 5, 18, 2, 11, 19]) [29, 19, 17, 11, 5, 3, 2, 20, 18, 10] >>> prime_nonprime_sort([2, 4, 6, 8, 3, 5]) [5, 3, 2, 8, 6, 4] >>> prime_nonprime_sort([1, 15, 17, 18, 19, 7, 14, 10, 2]) [19, 17, 7, 2, 18, 15, 14, 10, 1] >>> prime_nonprime_sort([7, 3, 2, 1, 5]) [7, 5, 3, 2, 1] >>> prime_nonprime_sort([16, 20, 30, 40]) [40, 30, 20, 16] >>> prime_nonprime_sort([31, 101, 131, 97]) [131, 101, 97, 31]","solution":"def is_prime(num): if num < 2: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def prime_nonprime_sort(numbers): primes = [num for num in numbers if is_prime(num)] non_primes = [num for num in numbers if not is_prime(num)] primes.sort(reverse=True) non_primes.sort(reverse=True) return primes + non_primes # Example usage N = 10 numbers = [10, 29, 3, 20, 17, 5, 18, 2, 11, 19] print(prime_nonprime_sort(numbers)) # Output should be [29, 19, 17, 11, 5, 3, 2, 20, 18, 10]"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_furthest_apart_vertices(n: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, int]: Determine the two vertices that are the furthest apart in a tree. Parameters: n (int): The number of vertices in the tree. edges (List[Tuple[int, int, int]]): A list of tuples representing the edges of the tree, where each tuple contains two vertices (u, v) and the weight (w) of the edge between them. Returns: Tuple[int, int]: Two vertices that are the furthest apart. Example: >>> find_furthest_apart_vertices(5, [(1, 2, 3), (2, 3, 4), (2, 4, 2), (4, 5, 6)]) (3, 5) >>> find_furthest_apart_vertices(4, [(1, 2, 1), (1, 3, 1), (1, 4, 1)]) (3, 4) # Function implementation here def main(input_data: str) -> Tuple[int, int]: input_lines = input_data.strip().split('n') n = int(input_lines[0]) edges = [] for line in input_lines[1:]: u, v, w = map(int, line.split()) edges.append((u, v, w)) return find_furthest_apart_vertices(n, edges) # Add appropriate test function calls or test cases for verification def test_example_1(): input_data = \\"5n1 2 3n2 3 4n2 4 2n4 5 6\\" result = main(input_data) assert result == (3, 5) or result == (5, 3) def test_example_2(): input_data = \\"4n1 2 1n1 3 1n1 4 1\\" result = main(input_data) # Possible correct answers are (2, 3), (2, 4) or (3, 4) or their reversed versions assert result in [(2, 3), (2, 4), (3, 4), (3, 2), (4, 2), (4, 3)]","solution":"from collections import defaultdict, deque def find_furthest_apart_vertices(n, edges): # Convert edge list to adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(start): queue = deque([(start, 0)]) distances = {start: 0} farthest_node, max_distance = start, 0 while queue: current, current_distance = queue.popleft() if current_distance > max_distance: farthest_node, max_distance = current, current_distance for neighbor, weight in graph[current]: if neighbor not in distances: distances[neighbor] = current_distance + weight queue.append((neighbor, distances[neighbor])) return farthest_node, max_distance, distances # Step 1: Find the farthest node from an arbitrary node (e.g. node 1) farthest_node, _, _ = bfs(1) # Step 2: Find the farthest node from the previously found farthest node other_farthest_node, max_distance, distances = bfs(farthest_node) return farthest_node, other_farthest_node # Function to parse input data and call the solution function def main(input_data): input_lines = input_data.strip().split('n') n = int(input_lines[0]) edges = [] for line in input_lines[1:]: u, v, w = map(int, line.split()) edges.append((u, v, w)) result = find_furthest_apart_vertices(n, edges) return result"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def insert(self, root, key): Insert a node with the given key into the AVL tree and perform necessary rotations. Parameters: - root: The root of the AVL tree. - key: The key of the node to be inserted. Returns: - The new root of the AVL tree. pass def delete(self, root, key): Delete a node with the given key from the AVL tree and perform necessary rotations. Parameters: - root: The root of the AVL tree. - key: The key of the node to be deleted. Returns: - The new root of the AVL tree. pass def inorder_traversal(self, root): Retrieve the keys of the nodes in the AVL tree in non-decreasing order. Parameters: - root: The root of the AVL tree. Returns: - A list of the keys in non-decreasing order. pass def left_rotate(self, z): pass def right_rotate(self, z): pass def get_height(self, root): pass def get_balance(self, root): pass def get_min_value_node(self, root): pass # Test cases def test_avl_tree_insert(): avl = AVLTree() root = None root = avl.insert(root, 10) root = avl.insert(root, 20) root = avl.insert(root, 30) root = avl.insert(root, 40) root = avl.insert(root, 50) root = avl.insert(root, 25) result = avl.inorder_traversal(root) assert result == [10, 20, 25, 30, 40, 50] def test_avl_tree_delete(): avl = AVLTree() root = None root = avl.insert(root, 9) root = avl.insert(root, 5) root = avl.insert(root, 10) root = avl.insert(root, 0) root = avl.insert(root, 6) root = avl.insert(root, 11) root = avl.insert(root, -1) root = avl.insert(root, 1) root = avl.insert(root, 2) assert avl.inorder_traversal(root) == [-1, 0, 1, 2, 5, 6, 9, 10, 11] root = avl.delete(root, 10) assert avl.inorder_traversal(root) == [-1, 0, 1, 2, 5, 6, 9, 11] root = avl.delete(root, 5) assert avl.inorder_traversal(root) == [-1, 0, 1, 2, 6, 9, 11]","solution":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def insert(self, root, key): if not root: return TreeNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left min_larger_node = self.get_min_value_node(root.right) root.key = min_larger_node.key root.right = self.delete(root.right, min_larger_node.key) if not root: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def inorder_traversal(self, root): result = [] self._inorder_traversal(root, result) return result def _inorder_traversal(self, root, result): if root: self._inorder_traversal(root.left, result) result.append(root.key) self._inorder_traversal(root.right, result) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_min_value_node(self, root): if root is None or root.left is None: return root return self.get_min_value_node(root.left)"},{"question":"from typing import List def largest_square(matrix: List[List[int]]) -> int: Determines the largest square sub-matrix within a given binary matrix that contains only 1's. Args: matrix (List[List[int]]): A binary matrix containing only 0's and 1's. Returns: int: The size of the largest square sub-matrix containing only 1's. Example: >>> largest_square([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 2 >>> largest_square([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) 2 pass def analyze_matrices(test_cases: List[List[List[int]]]) -> List[int]: Analyzes a list of test cases to find the size of the largest square sub-matrix of 1's for each case. Args: test_cases (List[List[List[int]]]): A list where each element represents a binary matrix. Returns: List[int]: A list of integers representing the size of the largest square sub-matrix for each test case. pass def parse_input(input_str: str) -> List[List[List[int]]]: Parses the input string to extract test cases. Args: input_str (str): The input string containing multiple test cases. Returns: List[List[List[int]]]: A list of binary matrices. pass def main(input_str: str) -> None: Main function to parse input, analyze matrices, and print results. Args: input_str (str): The input string containing multiple test cases. pass","solution":"def largest_square(matrix): Returns the size of the largest square sub-matrix containing only 1's in the given binary matrix. if not matrix: return 0 M = len(matrix) N = len(matrix[0]) # Create a DP table to store the size of the largest square submatrix ending at (i, j) dp = [[0] * N for _ in range(M)] max_side = 0 for i in range(M): for j in range(N): if matrix[i][j] == 1: # If we are at the first row or first column, the largest square is the value itself (1 or 0) if i == 0 or j == 0: dp[i][j] = 1 else: # Update the DP table value based on the minimum of the three adjacent cells plus 1 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # Update the maximum size of the square found so far max_side = max(max_side, dp[i][j]) return max_side def analyze_matrices(test_cases): results = [] for matrix in test_cases: results.append(largest_square(matrix)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): M, N = map(int, input_lines[index].strip().split()) index += 1 matrix = [] for i in range(M): row = list(map(int, input_lines[index].strip().split())) index += 1 matrix.append(row) test_cases.append(matrix) return test_cases def main(input_str): test_cases = parse_input(input_str) results = analyze_matrices(test_cases) for result in results: print(result)"},{"question":"def can_form_consecutive_sequence(arr: List[int]) -> bool: Determines if the elements of the array can be reordered to form a consecutive sequence. >>> can_form_consecutive_sequence([1, 2, 3, 4, 5]) True >>> can_form_consecutive_sequence([5, 4, 2, 3, 1]) True >>> can_form_consecutive_sequence([1, 3, 5, 7]) False >>> can_form_consecutive_sequence([7, 6, 5, 4]) True >>> can_form_consecutive_sequence([7, 6, 5, 3]) False >>> can_form_consecutive_sequence([-9, -10, -11, -12, -13]) True >>> can_form_consecutive_sequence([1000000000, 999999999, 999999998]) True >>> can_form_consecutive_sequence([-1, 0, 1, 2, 3]) True >>> can_form_consecutive_sequence([10, 12, 13, 11]) True >>> can_form_consecutive_sequence([20, 22, 23, 21, 19]) True >>> can_form_consecutive_sequence([1, 3, 4, 5]) False","solution":"def can_form_consecutive_sequence(arr): Determines if the elements of the array can be reordered to form a consecutive sequence. min_val = min(arr) max_val = max(arr) length = len(arr) # If the range between min and max is equal to the length minus 1 return max_val - min_val == length - 1"},{"question":"def recolorMatrix(N: int, M: int, matrix: List[List[int]], queries: List[List[int]]) -> List[List[int]]: Recolor sub-matrix according to the queries and return the modified matrix. Example: >>> N = 3 >>> M = 3 >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> queries = [ ... [0, 0, 1, 1, 10], ... [1, 1, 2, 2, 20] ... ] >>> recolorMatrix(N, M, matrix, queries) [[10, 10, 3], [10, 20, 20], [7, 20, 20]]","solution":"def recolorMatrix(N, M, matrix, queries): for query in queries: r1, c1, r2, c2, new_color = query for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): matrix[i][j] = new_color return matrix"},{"question":"def longest_alphabetical_path(n: int, m: int, grid: List[str]) -> int: You are given a grid with N rows and M columns consisting of lowercase English letters. Your task is to find the length of the longest path in the grid such that consecutive characters in this path follow each other in alphabetical order, wrapping around from 'z' to 'a'. The path may start from any cell in the grid and can include any number of cells, but each cell can be visited only once. The path can move to an adjacent cell horizontally, vertically, or diagonally. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): Grid containing lowercase English letters. Returns: int: Length of the longest alphabetical path. >>> longest_alphabetical_path(3, 4, [\\"abcd\\", \\"bcda\\", \\"dabc\\"]) 4 >>> longest_alphabetical_path(2, 2, [\\"az\\", \\"bz\\"]) 3 >>> longest_alphabetical_path(3, 3, [\\"aba\\", \\"bca\\", \\"cba\\"]) 3 >>> longest_alphabetical_path(1, 1, [\\"a\\"]) 1 pass def process_input(test_cases): Processes test cases and returns a list of results for each test case. pass","solution":"def longest_alphabetical_path(n, m, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] def valid(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if valid(nx, ny) and (ord(grid[nx][ny]) - ord(grid[x][y]) == 1 or (grid[x][y] == 'z' and grid[nx][ny] == 'a')): max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return max_length dp = [[-1 for _ in range(m)] for _ in range(n)] result = 0 for i in range(n): for j in range(m): result = max(result, dfs(i, j)) return result def process_input(test_cases): results = [] for n, m, grid in test_cases: results.append(longest_alphabetical_path(n, m, grid)) return results"},{"question":"from typing import List def min_operations_to_equalize_array(arr: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal. If it is not possible, return -1. >>> min_operations_to_equalize_array([1, 1, 1, 1, 1]) == 0 >>> min_operations_to_equalize_array([1, 2, 3]) == 3 >>> min_operations_to_equalize_array([3, 6, 9, 12]) == 6 >>> min_operations_to_equalize_array([2, 4, 7]) == -1 >>> min_operations_to_equalize_array([5]) == 0 >>> min_operations_to_equalize_array([2, 2, 2, 2]) == 0 >>> min_operations_to_equalize_array([10000, 10000, 10000, 10000]) == 0","solution":"def min_operations_to_equalize_array(arr): Returns the minimum number of operations required to make all elements of the array equal, or -1 if it is not possible. if len(arr) == 0: return -1 def gcd(a, b): while b: a, b = b, a % b return a n = len(arr) overall_gcd = arr[0] for num in arr[1:]: overall_gcd = gcd(overall_gcd, num) if overall_gcd != arr[0]: return -1 operations = 0 for num in arr: operations += (num // overall_gcd - 1) return operations"},{"question":"def find_missing_ids(start: int, end: int, available_ids: List[int]) -> List[int]: Returns a list of missing IDs within the given range from start to end. :param start: int, starting ID of the sequence :param end: int, ending ID of the sequence :param available_ids: list of int, available IDs within the sequence :return: list of int, missing IDs in sorted order >>> find_missing_ids(1000, 1005, [1000, 1002, 1003, 1005]) [1001, 1004] >>> find_missing_ids(1000, 1005, [1000, 1001, 1002, 1003, 1004, 1005]) [] >>> find_missing_ids(1000, 1005, []) [1000, 1001, 1002, 1003, 1004, 1005] >>> find_missing_ids(1000, 1000, [1000]) [] >>> find_missing_ids(1000, 1000, []) [1000] >>> find_missing_ids(1, 10, [1, 2, 4, 6, 8, 10]) [3, 5, 7, 9] pass","solution":"def find_missing_ids(start, end, available_ids): Returns a list of missing IDs within the given range from start to end. :param start: int, starting ID of the sequence :param end: int, ending ID of the sequence :param available_ids: list of int, available IDs within the sequence :return: list of int, missing IDs in sorted order all_ids = set(range(start, end + 1)) available_ids_set = set(available_ids) missing_ids = sorted(all_ids - available_ids_set) return missing_ids"},{"question":"def process_grid(n: int, grid: List[List[int]]) -> None: Perform a sequence of operations to transform the grid into a Latin square using the fewest number of operations. The operations you can perform are swaps of entire rows or entire columns. Input The first line contains one integer n (1  n  50)  the size of the grid. The next n lines each contain n integers, representing the grid. Output On the first line, print the number q of operations you perform (it must hold 0  q  1000). Then, print q lines, each describing one operation. Each operation should be of the form: - \`row x y\` indicating a swap of row x with row y (1-based index) - \`column x y\` indicating a swap of column x with column y (1-based index) Operations are 1-based indexed, and rows and columns are numbered from 1 to n. import unittest class TestProcessGrid(unittest.TestCase): def test_process_grid_case_1(self): n = 4 grid = [ [1, 2, 3, 4], [4, 3, 2, 1], [1, 3, 2, 4], [4, 1, 2, 3] ] process_grid(n, grid) def test_process_grid_case_2(self): n = 3 grid = [ [1, 2, 3], [3, 2, 1], [2, 3, 1] ] process_grid(n, grid) def test_sample_latin_square(self): n = 4 grid = [ [1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3] ] self.assertTrue(is_latin_square(grid, n))","solution":"def is_latin_square(grid, n): for i in range(n): if len(set(grid[i])) != n or len(set(row[i] for row in grid)) != n: return False return True def transpose(grid): return [list(row) for row in zip(*grid)] def process_grid(n, grid): from collections import defaultdict row_swaps = [] column_swaps = [] for target_row in range(1, n + 1): for current_row in range(1, n + 1): if set(grid[current_row - 1]) == set(range(1, n + 1)): break if current_row != target_row: row_swaps.append(f'row {target_row} {current_row}') grid[target_row - 1], grid[current_row - 1] = grid[current_row - 1], grid[target_row - 1] grid = transpose(grid) for target_col in range(1, n + 1): for current_col in range(1, n + 1): if set(row[current_col - 1] for row in grid) == set(range(1, n + 1)): break if current_col != target_col: column_swaps.append(f'column {target_col} {current_col}') for row in grid: row[target_col - 1], row[current_col - 1] = row[current_col - 1], row[target_col - 1] all_operations = row_swaps + column_swaps print(len(all_operations)) for operation in all_operations: print(operation) n = 4 grid = [ [1, 2, 3, 4], [4, 3, 2, 1], [1, 3, 2, 4], [4, 1, 2, 3] ] process_grid(n, grid)"},{"question":"def first_non_repeating_character(s): Finds the first non-repeating character in the string. If all characters are repeating, returns -1. :param s: Input string consisting of lowercase alphabets. :return: The first non-repeating character or -1 if all characters are repeating. >>> first_non_repeating_character('swiss') == 'w' >>> first_non_repeating_character('racecar') == 'e' >>> first_non_repeating_character('xxxyyy') == -1 >>> first_non_repeating_character('a') == 'a' # Single character case >>> first_non_repeating_character('ababac') == 'c' >>> first_non_repeating_character('aabbcc') == -1 >>> first_non_repeating_character('abcdef') == 'a' >>> first_non_repeating_character('bbaccb') == 'a' >>> first_non_repeating_character('aabbcddee') == 'c' >>> first_non_repeating_character('') == -1 # Empty string case","solution":"def first_non_repeating_character(s): Finds the first non-repeating character in the string. If all characters are repeating, returns -1. :param s: Input string consisting of lowercase alphabets. :return: The first non-repeating character or -1 if all characters are repeating. char_count = {} # First pass to count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for char in s: if char_count[char] == 1: return char return -1"},{"question":"def find_closest_smaller_on_right(arr, n): For each element in the array arr, finds the closest smaller element on its right. If none exists, returns -1 for that element. :param arr: List[int] - List of n integers :param n: int - The length of the list :return: List[int] - List of integers that represents the closest smaller elements on the right Example: >>> find_closest_smaller_on_right([4, 5, 2, 10, 8, 6, 7], 7) [2, 2, -1, 8, 6, -1, -1] >>> find_closest_smaller_on_right([6, 3, 4, 5, 2], 5) [3, 2, 2, 2, -1] from solution import find_closest_smaller_on_right def test_example_1(): assert find_closest_smaller_on_right([4, 5, 2, 10, 8, 6, 7], 7) == [2, 2, -1, 8, 6, -1, -1] def test_example_2(): assert find_closest_smaller_on_right([6, 3, 4, 5, 2], 5) == [3, 2, 2, 2, -1] def test_all_elements_equal(): assert find_closest_smaller_on_right([5, 5, 5, 5, 5], 5) == [-1, -1, -1, -1, -1] def test_sorted_ascending(): assert find_closest_smaller_on_right([1, 2, 3, 4, 5], 5) == [-1, -1, -1, -1, -1] def test_sorted_descending(): assert find_closest_smaller_on_right([5, 4, 3, 2, 1], 5) == [4, 3, 2, 1, -1] def test_single_element(): assert find_closest_smaller_on_right([1], 1) == [-1]","solution":"def find_closest_smaller_on_right(arr, n): For each element in the array arr, finds the closest smaller element on its right. If none exists, returns -1 for that element. :param arr: List[int] - List of n integers :param n: int - The length of the list :return: List[int] - List of integers that represents the closest smaller elements on the right result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and stack[-1] >= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"def top_participants(N: int, K: int, M: int, scores: List[List[int]]) -> List[int]: Kingdom's annual archery competition has just concluded and you, as the head statistician, need to process the results. The competition had N participants, and each participant had a unique ID from 1 to N. The competition consisted of K rounds, where each round recorded the scores of all participants. Now, you are required to determine the top M participants based on their total scores across all rounds. Args: N (int): Number of participants. K (int): Number of rounds. M (int): Number of top participants to be selected. scores (List[List[int]]): A list of lists where each list represents the scores of all participants in a round. Returns: List[int]: List of unique integers, representing the IDs of the top M participants in descending order of their total scores. Examples: >>> top_participants(5, 3, 3, [ ... [10, 20, 30, 40, 50], ... [25, 15, 5, 45, 10], ... [5, 10, 20, 35, 40]]) [4, 5, 3] >>> top_participants(4, 2, 2, [ ... [0, 0, 0, 0], ... [0, 0, 0, 0]]) [1, 2]","solution":"def top_participants(N, K, M, scores): Returns the IDs of the top M participants based on total scores. total_scores = [0] * N for round_scores in scores: for i in range(N): total_scores[i] += round_scores[i] participants = list(range(1, N + 1)) participants.sort(key=lambda x: (-total_scores[x - 1], x)) return participants[:M]"},{"question":"def isValidBrackets(brackets: str) -> bool: Evaluates if a given sequence of brackets is valid. Args: brackets (str): A string containing the characters '[' and ']'. Returns: bool: True if the sequence is valid, False otherwise. Examples: >>> isValidBrackets(\\"[]\\") True >>> isValidBrackets(\\"[][]\\") True >>> isValidBrackets(\\"[[]]\\") True >>> isValidBrackets(\\"[[]][[[]]]\\") True >>> isValidBrackets(\\"[[]][\\") False >>> isValidBrackets(\\"][[]\\") False >>> isValidBrackets(\\"[[[][\\") False >>> isValidBrackets(\\"]\\") False >>> isValidBrackets(\\"\\") True assert isValidBrackets(\\"[]\\") assert isValidBrackets(\\"[][]\\") assert isValidBrackets(\\"[[[][]]]\\") == True assert isValidBrackets(\\"[[[]]][[]]\\") == True assert not isValidBrackets(\\"[]][[]\\") assert not isValidBrackets(\\"][\\") assert not isValidBrackets(\\"[[[][\\") assert not isValidBrackets(\\"][[]]\\") assert not isValidBrackets(\\"[[]]]\\") assert isValidBrackets(\\"\\") == True assert not isValidBrackets(\\"[\\") assert not isValidBrackets(\\"]\\")","solution":"def isValidBrackets(brackets): Evaluates if a given sequence of brackets is valid. Args: brackets (str): A string containing the characters '[' and ']'. Returns: bool: True if the sequence is valid, False otherwise. balance = 0 for char in brackets: if char == '[': balance += 1 elif char == ']': balance -= 1 if balance < 0: return False return balance == 0"},{"question":"def is_valid_traffic(n: int, m: int, signals: List[int], connections: List[Tuple[int, int]]) -> str: Determine if the traffic system is in a valid state. Parameters: - n (int): The number of intersections. - m (int): The number of connections between intersections. - signals (List[int]): A list of integers where the ith integer is 0 if the signal at the ith intersection shows RED and 1 if it shows GREEN. - connections (List[Tuple[int, int]]): A list of tuples where each tuple consists of two integers indicating a road directly connecting two intersections. Returns: - str: \\"VALID\\" if the traffic system is in a valid state, otherwise \\"INVALID\\". >>> is_valid_traffic(3, 2, [1, 0, 1], [(1, 2), (2, 3)]) \\"VALID\\" >>> is_valid_traffic(4, 4, [1, 1, 0, 0], [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"INVALID\\"","solution":"def is_valid_traffic(n, m, signals, connections): for a, b in connections: if signals[a-1] == 1 and signals[b-1] == 1: return \\"INVALID\\" return \\"VALID\\" # Example of how the function is used n = 3 m = 2 signals = [1, 0, 1] connections = [(1, 2), (2, 3)] print(is_valid_traffic(n, m, signals, connections)) # Output: VALID"},{"question":"from collections import deque class MaxQueue: A queue that supports enqueue, dequeue and getMax operations. Methods: - enqueue(int value): Adds the specified value to the end of the queue. - dequeue(): Removes the element from the front of the queue and returns it. - getMax(): Returns the maximum value currently in the queue. Example: maxQueue = MaxQueue() maxQueue.enqueue(1) # maxQueue is [1] maxQueue.enqueue(2) # maxQueue is [1, 2] print(maxQueue.getMax()) # return 2 maxQueue.enqueue(3) # maxQueue is [1, 2, 3] print(maxQueue.dequeue()) # return 1 and maxQueue is [2, 3] print(maxQueue.getMax()) # return 3 def __init__(self): self.queue = deque() self.max_queue = deque() def enqueue(self, value): Adds the specified value to the end of the queue. :param value: int pass def dequeue(self): Removes the element from the front of the queue and returns it. :return: int pass def getMax(self): Returns the maximum value currently in the queue. :return: int pass def test_enqueue_and_getMax(): max_queue = MaxQueue() max_queue.enqueue(1) assert max_queue.getMax() == 1 max_queue.enqueue(2) assert max_queue.getMax() == 2 max_queue.enqueue(3) assert max_queue.getMax() == 3 def test_dequeue_and_getMax(): max_queue = MaxQueue() max_queue.enqueue(1) max_queue.enqueue(2) max_queue.enqueue(3) assert max_queue.dequeue() == 1 assert max_queue.getMax() == 3 assert max_queue.dequeue() == 2 assert max_queue.getMax() == 3 assert max_queue.dequeue() == 3 def test_complex_operations(): max_queue = MaxQueue() max_queue.enqueue(5) max_queue.enqueue(1) max_queue.enqueue(5) assert max_queue.getMax() == 5 max_queue.dequeue() assert max_queue.getMax() == 5 max_queue.dequeue() assert max_queue.getMax() == 5 max_queue.enqueue(7) max_queue.enqueue(6) assert max_queue.getMax() == 7 max_queue.enqueue(7) assert max_queue.getMax() == 7 assert max_queue.dequeue() == 5 assert max_queue.getMax() == 7 assert max_queue.dequeue() == 7 assert max_queue.getMax() == 7 assert max_queue.dequeue() == 6 assert max_queue.getMax() == 7 assert max_queue.dequeue() == 7 assert len(max_queue.queue) == 0 # Verify the queue is empty","solution":"from collections import deque class MaxQueue: def __init__(self): self.queue = deque() self.max_queue = deque() def enqueue(self, value): self.queue.append(value) while self.max_queue and self.max_queue[-1] < value: self.max_queue.pop() self.max_queue.append(value) def dequeue(self): value = self.queue.popleft() if value == self.max_queue[0]: self.max_queue.popleft() return value def getMax(self): return self.max_queue[0]"},{"question":"import heapq from typing import List, Tuple def minMeetingRooms(meetings: List[Tuple[int, int]]) -> int: Determine the minimum number of meeting rooms required to host all meetings. Args: meetings (List[Tuple[int, int]]): An array of tuples, where each tuple contains two integers representing the start time and end time of a meeting. Returns: int: The minimum number of meeting rooms needed. Examples: >>> minMeetingRooms([(30, 75), (0, 50), (60, 150)]) 2 >>> minMeetingRooms([(0, 30), (5, 10), (15, 20)]) 2","solution":"import heapq def minMeetingRooms(meetings): if not meetings: return 0 # Initialize a heap. free_rooms = [] # Sort the meetings in increasing order of their start time. meetings.sort(key=lambda x: x[0]) # Add the first meeting. We have to give a new room to the first meeting. heapq.heappush(free_rooms, meetings[0][1]) # For all the remaining meeting rooms for meeting in meetings[1:]: # If the room due to free up the earliest is free, assign that room to this meeting. if free_rooms[0] <= meeting[0]: heapq.heappop(free_rooms) # If a new room is to be assigned, do so. heapq.heappush(free_rooms, meeting[1]) # The size of the heap tells us the minimum rooms required for all the meetings. return len(free_rooms)"},{"question":"def is_total_apples_even(n: int, apples: List[int]) -> str: Returns 'even' if the total number of apples is even, otherwise returns 'odd'. Parameters: n (int): The number of baskets. apples (list of int): The number of apples in each basket. Returns: str: 'even' if the total number of apples is even, 'odd' otherwise. >>> is_total_apples_even(5, [3, 4, 6, 2, 5]) 'even' >>> is_total_apples_even(3, [1, 1, 1]) 'odd'","solution":"def is_total_apples_even(n, apples): Returns 'even' if the total number of apples is even, otherwise returns 'odd'. Parameters: n (int): The number of baskets. apples (list of int): The number of apples in each basket. Returns: str: 'even' if the total number of apples is even, 'odd' otherwise. total_apples = sum(apples) return \\"even\\" if total_apples % 2 == 0 else \\"odd\\""},{"question":"def is_permuted_multiple(x: int, k: int) -> bool: Check if k * x is a permuted multiple of x. >>> is_permuted_multiple(142857, 2) True >>> is_permuted_multiple(142857, 3) True >>> is_permuted_multiple(142857, 4) True >>> is_permuted_multiple(142857, 5) True >>> is_permuted_multiple(142857, 6) True >>> is_permuted_multiple(123456, 2) False >>> is_permuted_multiple(100000, 2) False >>> is_permuted_multiple(123, 3) False pass def find_permuted_multiple(n: int) -> int: Finds the smallest integer x such that 2x, 3x, 4x, 5x, and 6x are all permuted multiples of x. The value of x should be greater than or equal to n. >>> find_permuted_multiple(1) 142857 >>> find_permuted_multiple(100000) 142857 >>> find_permuted_multiple(142000) 142857 >>> find_permuted_multiple(142500) 142857 pass","solution":"def is_permuted_multiple(x, k): Check if k * x is a permuted multiple of x. return sorted(str(x)) == sorted(str(k * x)) def find_permuted_multiple(n): Finds the smallest integer x such that 2x, 3x, 4x, 5x, and 6x are all permuted multiples of x. The value of x should be greater than or equal to n. x = n while True: if all(is_permuted_multiple(x, k) for k in range(2, 7)): return x x += 1"},{"question":"def smallestWindow(s: str, p: str) -> str: Finds the smallest window in the string containing all characters of another string. >>> smallestWindow(\\"this is a test string\\", \\"tist\\") \\"t stri\\" >>> smallestWindow(\\"geeksforgeeks\\", \\"ork\\") \\"ksfor\\"","solution":"from collections import Counter def smallestWindow(s, p): Finds the smallest window in string \`s\` containing all characters of string \`p\`. :param s: The main string in which we search for the window :param p: The pattern string containing the characters we need to find in \`s\` :return: The smallest window in \`s\` containing all characters of \`p\`, or an empty string if no such window exists if len(p) > len(s): return \\"\\" dict_p = Counter(p) required = len(dict_p) left, right = 0, 0 formed = 0 window_counts = {} # (window length, left, right) ans = float(\\"inf\\"), None, None while right < len(s): char = s[right] window_counts[char] = window_counts.get(char, 0) + 1 if char in dict_p and window_counts[char] == dict_p[char]: formed += 1 while left <= right and formed == required: char = s[left] if right - left + 1 < ans[0]: ans = (right - left + 1, left, right) window_counts[char] -= 1 if char in dict_p and window_counts[char] < dict_p[char]: formed -= 1 left += 1 right += 1 if ans[0] == float(\\"inf\\"): return \\"\\" else: return s[ans[1]: ans[2] + 1]"},{"question":"def process_queries(n, m, array, queries): Processes the given queries on the array and returns the results of type 5 queries. Parameters: n (int): Size of the list m (int): Number of queries array (list): Initial list of integers queries (list): List of query strings Returns: list: Results of type 5 queries from solution import process_queries def test_process_queries_single_type_5_query(): n = 5 m = 6 array = [1, 2, 3, 4, 5] queries = [ \\"1 10\\", \\"2 2\\", \\"4\\", \\"3 2\\", \\"5\\", \\"2 3\\" ] expected_output = [15] assert process_queries(n, m, array, queries) == expected_output def test_process_queries_multiple_type_5_queries(): n = 4 m = 8 array = [4, 7, 2, 9] queries = [ \\"5\\", \\"1 1\\", \\"5\\", \\"2 3\\", \\"5\\", \\"3 3\\", \\"5\\", \\"4\\", ] expected_output = [9, 10, 30, 10] assert process_queries(n, m, array, queries) == expected_output def test_process_queries_no_modifications(): n = 3 m = 1 array = [8, 6, 9] queries = [\\"5\\"] expected_output = [9] assert process_queries(n, m, array, queries) == expected_output def test_process_queries_all_operations(): n = 3 m = 5 array = [2, 3, 5] queries = [\\"1 5\\", \\"2 2\\", \\"3 3\\", \\"4\\", \\"5\\"] expected_output = [6] assert process_queries(n, m, array, queries) == expected_output def test_process_queries_large_numbers(): n = 2 m = 3 array = [1000000000, 999999999] queries = [\\"1 1\\", \\"2 2\\", \\"5\\"] expected_output = [2000000002] assert process_queries(n, m, array, queries) == expected_output","solution":"def process_queries(n, m, array, queries): Processes the given queries on the array and returns the results of type 5 queries. results = [] for query in queries: split_query = query.split() q_type = int(split_query[0]) if q_type == 1: x = int(split_query[1]) array = [elem + x for elem in array] elif q_type == 2: y = int(split_query[1]) array = [elem * y for elem in array] elif q_type == 3: z = int(split_query[1]) array = [elem // z for elem in array] elif q_type == 4: array.reverse() elif q_type == 5: results.append(max(array)) return results # Example input n = 5 m = 6 array = [1, 2, 3, 4, 5] queries = [ \\"1 10\\", \\"2 2\\", \\"4\\", \\"3 2\\", \\"5\\", \\"2 3\\" ] # Example usage output = process_queries(n, m, array, queries) print(output) # Output should be [15]"},{"question":"def total_travel_distance(n: int, q: int, houses: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the total travel distance for each query. Parameters: n (int): The number of houses. q (int): The number of delivery queries. houses (list of int): The positions of the houses in non-decreasing order. queries (list of tuple): Each tuple contains two integers li and ri, describing the start and end locations of the delivery segment. Returns: list of int: The total distance traveled for each query. Examples: >>> total_travel_distance(5, 3, [1, 3, 6, 8, 10], [(1, 4), (3, 9), (4, 10)]) [3, 6, 6] >>> total_travel_distance(4, 2, [2, 5, 7, 9], [(2, 5), (7, 9)]) [3, 2]","solution":"def total_travel_distance(n, q, houses, queries): Returns the total travel distance for each query. Parameters: n (int): The number of houses. q (int): The number of delivery queries. houses (list of int): The positions of the houses in non-decreasing order. queries (list of tuple): Each tuple contains two integers li and ri, describing the start and end locations of the delivery segment. Returns: list of int: The total distance traveled for each query. distances = [] for l, r in queries: distance = r - l distances.append(distance) return distances"},{"question":"def is_prime(num): Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(20) False def find_primes_in_range(n, m): Find all prime numbers in the range from n to m (inclusive). >>> find_primes_in_range(10, 20) [11, 13, 17, 19] >>> find_primes_in_range(22, 29) [23, 29] >>> find_primes_in_range(1, 10) [2, 3, 5, 7] >>> find_primes_in_range(14, 16) [] def sum_and_product_of_digits_of_primes(n, m): Return the sum and the product of the digits of prime numbers in the range [n, m]. >>> sum_and_product_of_digits_of_primes(10, 20) (60, 189) >>> sum_and_product_of_digits_of_primes(22, 29) (52, 108) >>> sum_and_product_of_digits_of_primes(14, 16) (0, 1) >>> sum_and_product_of_digits_of_primes(1, 10) (17, 210)","solution":"def is_prime(num): Check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if (num % i == 0) or (num % (i + 2) == 0): return False i += 6 return True def find_primes_in_range(n, m): Find all prime numbers in the range from n to m (inclusive). primes = [] for num in range(n, m + 1): if is_prime(num): primes.append(num) return primes def sum_and_product_of_digits_of_primes(n, m): primes = find_primes_in_range(n, m) if not primes: return 0, 1 # Calculate sum of prime numbers prime_sum = sum(primes) # Calculate product of digits of all prime numbers concatenated together concatenated_digits = ''.join(str(prime) for prime in primes) product_of_digits = 1 for digit in concatenated_digits: product_of_digits *= int(digit) return prime_sum, product_of_digits"},{"question":"def process_commands(commands: List[str]) -> List[int]: Process a series of text commands to add, remove, or count words in a store. >>> process_commands([\\"ADD apple\\", \\"ADD banana\\", \\"COUNT\\", \\"REMOVE apple\\", \\"REMOVE apple\\", \\"ADD orange\\", \\"COUNT\\"]) [2, 1] >>> process_commands([\\"ADD peach\\", \\"REMOVE peach\\", \\"COUNT\\"]) [0] from typing import List def test_single_add_count(): commands = [ \\"ADD apple\\", \\"COUNT\\" ] assert process_commands(commands) == [1] def test_add_remove_count(): commands = [ \\"ADD apple\\", \\"REMOVE apple\\", \\"COUNT\\" ] assert process_commands(commands) == [0] def test_add_multiple_count(): commands = [ \\"ADD apple\\", \\"ADD banana\\", \\"COUNT\\", \\"ADD orange\\", \\"COUNT\\" ] assert process_commands(commands) == [2, 3] def test_duplicate_add_remove(): commands = [ \\"ADD apple\\", \\"ADD apple\\", \\"COUNT\\", \\"REMOVE apple\\", \\"REMOVE apple\\", \\"COUNT\\" ] assert process_commands(commands) == [1, 0] def test_mixed_operations(): commands = [ \\"ADD apple\\", \\"ADD banana\\", \\"REMOVE apple\\", \\"ADD orange\\", \\"COUNT\\", \\"REMOVE banana\\", \\"REMOVE orange\\", \\"COUNT\\" ] assert process_commands(commands) == [2, 0]","solution":"def process_commands(commands): store = set() result = [] for command in commands: parts = command.split() action = parts[0] if action == \\"ADD\\": word = parts[1] store.add(word) elif action == \\"REMOVE\\": word = parts[1] store.discard(word) # discard does nothing if the word is not present elif action == \\"COUNT\\": result.append(len(store)) return result"},{"question":"def max_sum_of_k_consecutive_elements(arr, k): Returns the maximum sum of k consecutive elements in the array. Parameters: arr (list of int): The list of integers. k (int): The number of consecutive elements to consider. Returns: int: The maximum sum of k consecutive elements. Examples: >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5], 2) 9 >>> max_sum_of_k_consecutive_elements([-1, -2, -3, -4, -5], 3) -6 >>> max_sum_of_k_consecutive_elements([10, 20, 30, 40, 50, 60], 4) 180","solution":"def max_sum_of_k_consecutive_elements(arr, k): Returns the maximum sum of k consecutive elements in the array. Parameters: arr (list of int): The list of integers. k (int): The number of consecutive elements to consider. Returns: int: The maximum sum of k consecutive elements. n = len(arr) # Initial sum of the first k elements max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the rest of the array for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Function to find the minimum cost path in a grid from the top-left to the bottom-right corner. Args: grid (List[List[int]]): 2D grid representing the cost of each cell Returns: int: minimum cost to travel from the top-left to the bottom-right corner Example: >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2], [3, 4]]) 7","solution":"def min_cost_path(grid): Function to find the minimum cost path in a grid from the top-left to the bottom-right corner. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def is_power_of_two(n: int) -> bool: Check if a given integer is a power of 2. >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True >>> is_power_of_two(0) False def verify_bob_claim(t: int, integer_list: List[int]) -> str: Verify if all integers in the list are powers of 2. >>> verify_bob_claim(4, [1, 2, 4, 8]) \\"YES\\" >>> verify_bob_claim(3, [3, 6, 10]) \\"NO\\"","solution":"def is_power_of_two(n): return (n > 0) and (n & (n - 1)) == 0 def verify_bob_claim(t, integer_list): for num in integer_list: if not is_power_of_two(num): return \\"NO\\" return \\"YES\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def kthNodeFromEnd(head, k): Returns the k-th node from the end of the linked list. If k is greater than the length of the list, returns None. >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> kthNodeFromEnd(head, 2) == 4 >>> kthNodeFromEnd(head, 6) == None pass def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: node = ListNode(value) current.next = node current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def kthNodeFromEnd(head, k): Returns the k-th node from the end of the linked list. If k is greater than the length of the list, returns None. slow = fast = head # Move fast k nodes ahead for _ in range(k): if fast is None: return None # k is greater than the length of the list fast = fast.next # Move both pointers until fast reaches the end while fast: fast = fast.next slow = slow.next return slow.val if slow else None"},{"question":"import heapq from typing import List, Tuple, Union def single_source_shortest_path(V: int, E: int, edges: List[Tuple[int, int, int]], source: int) -> List[Union[int, str]]: Implement Dijkstra's algorithm to find the shortest path from a source vertex to all other vertices in a weighted graph. Args: V (int): The number of vertices in the graph. E (int): The number of edges in the graph. edges (List[Tuple[int, int, int]]): Each edge is represented by a tuple (u, v, w) where u is the start vertex, v is the end vertex, and w is the weight of the edge. source (int): The source vertex. Returns: List[Union[int, str]]: The list containing the shortest distance from the source vertex to each vertex in the graph. If a vertex is unreachable from the source, \\"INF\\" is included in the list. Example: >>> single_source_shortest_path(5, 6, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1)], 0) [0, 2, 3, 9, 6] >>> single_source_shortest_path(4, 4, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4)], 0) [0, 1, 3, 6] >>> single_source_shortest_path(3, 0, [], 0) [0, \\"INF\\", \\"INF\\"] >>> single_source_shortest_path(3, 2, [(0, 1, 1), (1, 2, 2)], 2) [\\"INF\\", \\"INF\\", 0] >>> single_source_shortest_path(6, 9, [(0,1,3), (0,5,5), (1,2,1), (1,3,4), (2,3,2), (3,4,1), (4,5,2), (5,2,2), (4,0,7)], 0) [0, 3, 4, 6, 7, 5]","solution":"import heapq def dijkstra(V, edges, source): graph = {i: [] for i in range(V)} for u, v, w in edges: graph[u].append((v, w)) distances = [float('inf')] * V distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [\\"INF\\" if dist == float('inf') else dist for dist in distances] def single_source_shortest_path(V, E, edges, source): return dijkstra(V, edges, source) # Example usage: # edges = [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1)] # print(single_source_shortest_path(5, 6, edges, 0))"},{"question":"def decrypt_message(k: int, message: str) -> str: Decrypts a message by shifting each alphabetic character k positions back in the alphabet. Parameters: k (int): The number of positions each letter in the message has been shifted. message (str): The encrypted message. Returns: str: The decrypted message. Example: >>> decrypt_message(3, 'khoor zruog') 'hello world' >>> decrypt_message(0, 'hello world') 'hello world' >>> decrypt_message(26, 'hello world') 'hello world' >>> decrypt_message(3, 'Khoor, Zruog! 123') 'Hello, World! 123' >>> decrypt_message(2, 'cde') 'abc' >>> decrypt_message(2, 'CDE') 'ABC'","solution":"def decrypt_message(k: int, message: str) -> str: Decrypts a message by shifting each alphabetic character k positions back in the alphabet. Parameters: k (int): The number of positions each letter in the message has been shifted. message (str): The encrypted message. Returns: str: The decrypted message. decrypted_message = [] for char in message: if 'a' <= char <= 'z': decrypted_message.append(chr((ord(char) - ord('a') - k) % 26 + ord('a'))) elif 'A' <= char <= 'Z': decrypted_message.append(chr((ord(char) - ord('A') - k) % 26 + ord('A'))) else: decrypted_message.append(char) return ''.join(decrypted_message)"},{"question":"def can_form_palindrome(input_string: str) -> bool: Determines if a palindrome can be formed from the given string by rearranging its characters. :param input_string: A string of lowercase alphabetic characters. :return: True if a palindrome can be formed, otherwise False. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aab\\") True","solution":"from collections import Counter def can_form_palindrome(input_string): Determines if a palindrome can be formed from the given string by rearranging its characters. :param input_string: A string of lowercase alphabetic characters. :return: True if a palindrome can be formed, otherwise False. char_count = Counter(input_string) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def range_update_and_queries(n, m, initial_array, updates, q, queries): Perform a series of range updates and then answer queries about the array. Parameters: - n: number of elements in the array - m: number of updates - initial_array: the initial values of the array - updates: a list of updates, each a tuple (start, end, value) - q: number of queries - queries: a list of queries, each a single integer Returns: - A list of results for each query after applying all the range updates pass # Example unit tests def test_example_case(): n, m = 5, 3 initial_array = [1, 2, 3, 4, 5] updates = [(1, 3, 2), (2, 4, 1), (1, 5, -1)] q = 2 queries = [1, 5] expected_output = [2, 4] # Expected array after updates: [2, 4, 5, 4, 5] assert range_update_and_queries(n, m, initial_array, updates, q, queries) == expected_output def test_single_update(): n, m = 4, 1 initial_array = [0, 0, 0, 0] updates = [(1, 4, 1)] q = 4 queries = [1, 2, 3, 4] expected_output = [1, 1, 1, 1] # Expected array after updates: [1, 1, 1, 1] assert range_update_and_queries(n, m, initial_array, updates, q, queries) == expected_output def test_multiple_queries(): n, m = 5, 2 initial_array = [1, 2, 3, 4, 5] updates = [(1, 2, 3), (3, 5, -1)] q = 3 queries = [1, 2, 3] expected_output = [4, 5, 2] # Expected array after updates: [4, 5, 2, 3, 4] assert range_update_and_queries(n, m, initial_array, updates, q, queries) == expected_output def test_negative_update(): n, m = 4, 1 initial_array = [5, 5, 5, 5] updates = [(1, 4, -3)] q = 4 queries = [1, 2, 3, 4] expected_output = [2, 2, 2, 2] # Expected array after updates: [2, 2, 2, 2] assert range_update_and_queries(n, m, initial_array, updates, q, queries) == expected_output def test_zero_update(): n, m = 4, 1 initial_array = [5, 5, 5, 5] updates = [(1, 4, 0)] q = 4 queries = [1, 2, 3, 4] expected_output = [5, 5, 5, 5] # Expected array after updates: [5, 5, 5, 5] assert range_update_and_queries(n, m, initial_array, updates, q, queries) == expected_output","solution":"def range_update_and_queries(n, m, initial_array, updates, q, queries): Perform a series of range updates and then answer queries about the array. Parameters: - n: number of elements in the array - m: number of updates - initial_array: the initial values of the array - updates: a list of updates, each a tuple (start, end, value) - q: number of queries - queries: a list of queries, each a single integer Returns: - A list of results for each query after applying all the range updates # Convert initial_array indexes from 1-based to 0-based array = initial_array[:] # Apply the updates for update in updates: start, end, value = update for i in range(start - 1, end): array[i] += value # Answer the queries result = [] for query in queries: result.append(array[query - 1]) return result"},{"question":"def is_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the given graph is a tree. >>> is_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_tree(4, 3, [(1, 2), (2, 3), (1, 3)]) \\"NO\\"","solution":"def is_tree(n, m, edges): if m != n - 1: return \\"NO\\" from collections import defaultdict, deque adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) elif neighbor in visited: continue visited.add(1) bfs(1) return \\"YES\\" if len(visited) == n else \\"NO\\""},{"question":"def minimum_swaps_to_sort_heights(n, heights): Returns the minimum number of swaps required to rearrange students' heights in non-decreasing order. Parameters: n (int): number of students heights (list): list of integers representing heights of students Returns: int: minimum number of swaps required >>> minimum_swaps_to_sort_heights(5, [1, 2, 3, 4, 5]) == 0 >>> minimum_swaps_to_sort_heights(5, [5, 4, 3, 2, 1]) == 10 >>> minimum_swaps_to_sort_heights(5, [4, 3, 2, 1, 5]) == 6 >>> minimum_swaps_to_sort_heights(1, [1]) == 0 >>> minimum_swaps_to_sort_heights(2, [2, 1]) == 1 >>> minimum_swaps_to_sort_heights(5, [2, 3, 2, 1, 4]) == 4","solution":"def minimum_swaps_to_sort_heights(n, heights): Returns the minimum number of swaps required to rearrange students' heights in non-decreasing order. Parameters: n (int): number of students heights (list): list of integers representing heights of students Returns: int: minimum number of swaps required def count_inversions(arr): # Function to count inversions in the array using merge sort if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inv = count_inversions(arr[:mid]) right, right_inv = count_inversions(arr[mid:]) merged = [] i = j = 0 inv_count = left_inv + right_inv while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 inv_count += len(left) - i merged += left[i:] merged += right[j:] return merged, inv_count _, num_of_swaps = count_inversions(heights) return num_of_swaps"},{"question":"import heapq from typing import List, Tuple def min_cost(N: int, M: int, edges: List[Tuple[int, int, int]], A: int, B: int) -> int: Determine the minimum cost to traverse from Vertex A to Vertex B in an undirected graph. Args: N (int): Number of vertices. M (int): Number of edges. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as (x_i, y_i, w_i). A (int): Starting vertex. B (int): Ending vertex. Returns: int: Minimum cost to travel from Vertex A to Vertex B, or -1 if no such path exists. Examples: >>> min_cost(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 2)], 1, 5) 6 >>> min_cost(4, 2, [(1, 2, 3), (2, 3, 4)], 1, 4) -1","solution":"import heapq def dijkstra(graph, start, end, n): distances = {i: float('infinity') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_vertex == end: return current_distance if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 def min_cost(N, M, edges, A, B): graph = {i: [] for i in range(1, N + 1)} for x, y, w in edges: graph[x].append((y, w)) graph[y].append((x, w)) return dijkstra(graph, A, B, N)"},{"question":"def can_swap_to_match(s1: str, s2: str) -> str: Determine if you can make \`s1\` equal to \`s2\` by swapping any two characters of \`s1\` exactly once. >>> can_swap_to_match(\\"ab\\", \\"ba\\") \\"Yes\\" >>> can_swap_to_match(\\"abab\\", \\"baba\\") \\"No\\"","solution":"def can_swap_to_match(s1: str, s2: str) -> str: if len(s1) != len(s2): return \\"No\\" # Find differing character positions differing_positions = [] for i in range(len(s1)): if s1[i] != s2[i]: differing_positions.append(i) if len(differing_positions) > 2: return \\"No\\" if len(differing_positions) != 2: return \\"No\\" # Check if swapping the two differing positions in s1 makes s1 equal to s2 i, j = differing_positions s1_list = list(s1) s1_list[i], s1_list[j] = s1_list[j], s1_list[i] if ''.join(s1_list) == s2: return \\"Yes\\" return \\"No\\""},{"question":"def minimumPathSum(N: int, grid: List[List[int]]) -> int: Given a grid of size N x N filled with positive integers, find a path to reach the bottom-right corner (grid[N-1][N-1]) with the minimum sum. You can only move either down or right at any point in time. :param N: Size of the grid (N x N) :param grid: 2D list of positive integers representing the grid :return: Minimum sum possible to reach the bottom-right corner from the top-left corner. Example: >>> minimumPathSum(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minimumPathSum(2, [[1, 2], [1, 1]]) 3 from solution import minimumPathSum def test_example1(): N = 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minimumPathSum(N, grid) == 7 def test_example2(): N = 2 grid = [ [1, 2], [1, 1] ] assert minimumPathSum(N, grid) == 3 def test_single_cell_grid(): N = 1 grid = [ [5] ] assert minimumPathSum(N, grid) == 5 def test_larger_grid(): N = 4 grid = [ [1, 3, 1, 4], [1, 5, 1, 2], [4, 2, 1, 1], [7, 1, 1, 1] ] assert minimumPathSum(N, grid) == 9 def test_large_numbers(): N = 2 grid = [ [100, 100], [100, 100] ] assert minimumPathSum(N, grid) == 300","solution":"def minimumPathSum(N, grid): Returns the minimum sum path from the top-left to the bottom-right of the grid. :param N: Size of the grid (N x N) :param grid: 2D list of positive integers representing the grid. :return: Minimum sum path from grid[0][0] to grid[N-1][N-1] # Create a dp array to store the minimum path sum up to each cell dp = [[0] * N for _ in range(N)] dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, N): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) # The value in the bottom-right corner is the minimum path sum return dp[N-1][N-1]"},{"question":"def max_consecutive_jumps(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of buildings you can consecutively jump to from the first building. Args: T (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): List containing T tuples, each with: - an integer N representing the number of buildings. - a list of N integers representing the heights of the buildings. Returns: List[int]: List of integers where each integer represents the maximum number of buildings that can be jumped to consecutively from the first building. Example: >>> max_consecutive_jumps(1, [(5, [1, 2, 2, 3, 2])]) [4] >>> max_consecutive_jumps(1, [(5, [5, 4, 3, 2, 1])]) [1] >>> max_consecutive_jumps(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> max_consecutive_jumps(1, [(5, [3, 3, 3, 3, 3])]) [5] >>> max_consecutive_jumps(1, [(1, [1])]) [1] >>> max_consecutive_jumps(2, [(5, [1, 2, 2, 3, 2]), (6, [1, 1, 1, 2, 2, 1])]) [4, 5]","solution":"def max_consecutive_jumps(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] max_jumps = 1 current_height = heights[0] for j in range(1, N): if heights[j] >= current_height: max_jumps += 1 current_height = heights[j] else: break results.append(max_jumps) return results"},{"question":"from typing import List, Tuple def process_queries(M: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process a series of queries on a sequence of distinct integers. Args: M: The number of elements in the sequence. A: The sequence of distinct integers. queries: A list of queries, each of the form (T, X) where T is the type and X is the target integer. Returns: A list containing the results of the queries. Example: >>> process_queries(6, [3, 1, 4, 2, 7, 5], [(1, 4), (2, 3), (3, 5), (1, 2)]) [3, 3, 1, 1] >>> process_queries(5, [10, 20, 30, 40, 50], [(1, 25), (2, 35), (3, 40)]) [2, 2, 1] results = [] # Implement the logic to process the queries here. return results # Unit Tests def test_process_queries_example(): A = [3, 1, 4, 2, 7, 5] M = len(A) queries = [(1, 4), (2, 3), (3, 5), (1, 2)] result = process_queries(M, A, queries) expected = [3, 3, 1, 1] assert result == expected def test_process_queries_edge_case(): A = [1] M = len(A) queries = [(1, 1), (2, 1), (3, 1)] result = process_queries(M, A, queries) expected = [0, 0, 1] assert result == expected def test_process_queries_all_elements_less(): A = [1, 2, 3, 4, 5] M = len(A) queries = [(1, 6)] result = process_queries(M, A, queries) expected = [5] assert result == expected def test_process_queries_all_elements_greater(): A = [10, 11, 12, 13, 14] M = len(A) queries = [(2, 9)] result = process_queries(M, A, queries) expected = [5] assert result == expected def test_process_queries_no_matches(): A = [1, 2, 3, 4, 5] M = len(A) queries = [(1, 0), (2, 6), (3, 7)] result = process_queries(M, A, queries) expected = [0, 0, 0] assert result == expected","solution":"def process_queries(M, A, queries): def count_less_than(X): return sum(1 for value in A if value < X) def count_greater_than(X): return sum(1 for value in A if value > X) def count_equal_to(X): return sum(1 for value in A if value == X) results = [] for T, X in queries: if T == 1: results.append(count_less_than(X)) elif T == 2: results.append(count_greater_than(X)) elif T == 3: results.append(count_equal_to(X)) return results # Example usage: A = [3, 1, 4, 2, 7, 5] M = len(A) queries = [(1, 4), (2, 3), (3, 5), (1, 2)] print(process_queries(M, A, queries))"},{"question":"def max_energy_collected(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Determine the maximum energy that can be collected while moving from the top-left cell to the bottom-right cell in an M x N grid of non-negative integers, for T test cases. >>> max_energy_collected(2, [((3, 3), [[1, 3, 1], [1, 5, 1], [4, 2, 1]]), ((2, 2), [[1, 2], [1, 3]])]) == [12, 6] pass # To parse the provided input format and use the solution above: def parse_input_and_get_results(input_str: str) -> List[int]: Parse input string and return the results for maximum energy collected. >>> parse_input_and_get_results(\\"2n3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 3n\\") == [12, 6] pass import doctest doctest.testmod()","solution":"def max_energy_collected(T, test_cases): result = [] for i in range(T): M, N = test_cases[i][0] grid = test_cases[i][1] dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] # Initialize first row for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize first column for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] result.append(dp[-1][-1]) return result # To parse the provided input format and use the solution above: def parse_input_and_get_results(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): M, N = map(int, input_lines[index].strip().split()) grid = [list(map(int, input_lines[index + j + 1].strip().split())) for j in range(M)] test_cases.append(((M, N), grid)) index += M + 1 return max_energy_collected(T, test_cases)"},{"question":"def smallest_lexicographical_order(T: int, test_cases: List[Dict[str, Tuple[int, int]]]) -> List[List[str]]: This function takes the number of test cases and the test cases themselves, and returns the smallest lexicographical order of the identifiers after performing the allowed swaps for each test case. >>> smallest_lexicographical_order(2, [{\\"NK\\": (3, 2), \\"identifiers\\": [\\"abc\\", \\"bca\\", \\"cab\\"]}, {\\"NK\\": (2, 1), \\"identifiers\\": [\\"dcba\\", \\"bacd\\"]}]) [[\\"abc\\", \\"abc\\", \\"abc\\"], [\\"abcd\\", \\"abcd\\"]] >>> smallest_lexicographical_order(1, [{\\"NK\\": (1, 10), \\"identifiers\\": [\\"xy\\"]}]) [[\\"xy\\"]] >>> smallest_lexicographical_order(1, [{\\"NK\\": (2, 5), \\"identifiers\\": [\\"fae\\", \\"dg\\"]}]) [[\\"aef\\", \\"dg\\"]]","solution":"def smallest_lexicographical_order(T, test_cases): This function takes the number of test cases and the test cases themselves, and returns the smallest lexicographical order of the identifiers after performing the allowed swaps for each test case. results = [] for case in test_cases: N, K = case[\\"NK\\"] identifiers = case[\\"identifiers\\"] sorted_identifiers = [] for id in identifiers: sorted_id = ''.join(sorted(id)) sorted_identifiers.append(sorted_id) results.append(sorted_identifiers) return results"},{"question":"def day_of_week(day: int, month: int, year: int) -> str: Returns the name of the day of the week for a given date in the Gregorian calendar. Uses the Zeller's congruence algorithm. >>> day_of_week(3, 8, 2023) 'Thursday' >>> day_of_week(1, 1, 2000) 'Saturday' >>> day_of_week(29, 2, 2020) 'Saturday' >>> day_of_week(31, 12, 1999) 'Friday' >>> day_of_week(4, 7, 1776) 'Thursday'","solution":"def day_of_week(day: int, month: int, year: int) -> str: Returns the name of the day of the week for a given date in the Gregorian calendar. Uses the Zeller's congruence algorithm. if month < 3: month += 12 year -= 1 q = day m = month K = year % 100 J = year // 100 h = (q + ((13 * (m + 1)) // 5) + K + (K // 4) + (J // 4) - (2 * J)) % 7 # Zeller's formula returns 0 = Saturday, 1 = Sunday, ..., 6 = Friday days = [\\"Saturday\\", \\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\"] return days[h]"},{"question":"from typing import List def canBeArranged(arr: List[int], n: int) -> str: Determines whether the array elements can form an arithmetic progression. :param arr: List of integers :param n: Integer, the size of the array :return: String, \\"YES\\" if the array can be rearranged to form an arithmetic progression, otherwise \\"NO\\" # Unit Tests def test_canBeArranged_yes_case(): assert canBeArranged([3, 5, 1, 7, 9], 5) == \\"YES\\" def test_canBeArranged_no_case(): assert canBeArranged([3, 8, 5, 2], 4) == \\"NO\\" def test_canBeArranged_single_element(): assert canBeArranged([1], 1) == \\"YES\\" def test_canBeArranged_two_elements(): assert canBeArranged([10, 5], 2) == \\"YES\\" def test_canBeArranged_some_arithmetic_progression(): assert canBeArranged([1, 2, 4, 7, 10], 5) == \\"NO\\" def test_canBeArranged_large_elements_yes(): assert canBeArranged([1000000000, 999999998, 999999996, 999999994], 4) == \\"YES\\" def test_canBeArranged_large_elements_no(): assert canBeArranged([1000000000, 999999998, 999999995, 999999994], 4) == \\"NO\\"","solution":"def canBeArranged(arr, n): Determines whether the array elements can form an arithmetic progression. :param arr: List of integers :param n: Integer, the size of the array :return: String, \\"YES\\" if the array can be rearranged to form an arithmetic progression, otherwise \\"NO\\" if n == 1: return \\"YES\\" arr.sort() common_difference = arr[1] - arr[0] for i in range(1, n-1): if arr[i+1] - arr[i] != common_difference: return \\"NO\\" return \\"YES\\""},{"question":"def min_edges_to_remove(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Returns the minimum number of edges to remove to make the graph a tree. Input: - n: number of nodes - m: number of edges - edges: list of edges where each edge is represented as (u, v, w) >>> min_edges_to_remove(5, 6, [(1, 2, 2), (1, 3, 1), (2, 3, 2), (2, 4, 3), (3, 5, 1), (4, 5, 3)]) == 2 >>> min_edges_to_remove(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == 1 >>> min_edges_to_remove(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 3)]) == 1 >>> min_edges_to_remove(1, 0, []) == 0 >>> min_edges_to_remove(4, 2, [(1, 2, 1), (3, 4, 2)]) == -1 >>> min_edges_to_remove(4, 0, []) == -1","solution":"def min_edges_to_remove(n, m, edges): Returns the minimum number of edges to remove to make the graph a tree. Input: - n: number of nodes - m: number of edges - edges: list of edges where each edge is represented as (u, v, w) if n == 1: return 0 # A single node is already a tree # Function to perform DFS and check graph connectivity def dfs(v, visited, adj_list): visited[v] = True for neighbor in adj_list[v]: if not visited[neighbor]: dfs(neighbor, visited, adj_list) # Build adjacency list adj_list = [[] for _ in range(n + 1)] for u, v, w in edges: adj_list[u].append(v) adj_list[v].append(u) # Check if the graph is connected visited = [False] * (n + 1) dfs(1, visited, adj_list) if not all(visited[1:n+1]): return -1 # Not possible to form a tree, graph is disconnected # Number of edges to remove to make the graph a tree return max(0, m - (n - 1))"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring of s that contains no repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aabbcc\\") 2 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} longest = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Given a string s and an integer k, rearrange the string such that repeating characters are at least k indices apart. If it is impossible to rearrange the string, return an empty string. >>> rearrange_string(\\"aabbcc\\", 3) 'abcabc' >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"aaadbbcc\\", 2) 'abacabcd' or 'abacdbac' >>> rearrange_string(\\"aa\\", 0) 'aa' >>> rearrange_string(\\"a\\", 2) 'a' >>> rearrange_string(\\"aabbcc\\", 4) ''","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k == 0: return s # if k is 0, no need to rearrange counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) < k: continue to_readd_char, to_readd_freq = queue.pop(0) if to_readd_freq < 0: heapq.heappush(max_heap, (to_readd_freq, to_readd_char)) if len(result) != len(s): return '' return ''.join(result)"},{"question":"def min_operations_to_reach_k(N: int, K: int, array: List[int]) -> int: Returns the minimum number of operations required to make every element of the array at least K. >>> min_operations_to_reach_k(5, 10, [1, 2, 0, 7, 3]) 10 >>> min_operations_to_reach_k(5, 10, [10, 10, 10, 10, 10]) 0 >>> min_operations_to_reach_k(5, 10, [10, 11, 10, 9, 8]) 2 >>> min_operations_to_reach_k(5, 5, [4, 4, 4, 4, 4]) 1 >>> min_operations_to_reach_k(7, 12, [0, 12, 15, 3, 9, 11, 6]) 12","solution":"def min_operations_to_reach_k(N, K, array): Returns the minimum number of operations required to make every element of the array at least K. max_increase_needed = 0 for number in array: if number < K: max_increase_needed = max(max_increase_needed, K - number) return max_increase_needed"},{"question":"def max_subset_sum_no_adjacent(nums: List[int]) -> int: This function takes in a list of integers and returns the maximum possible sum of a subset of these integers such that no two chosen integers are adjacent in the original list. >>> max_subset_sum_no_adjacent([1, 2, 9, 4]) == 10 >>> max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15 >>> max_subset_sum_no_adjacent([3, 7, 4, 6, 5]) == 13 >>> max_subset_sum_no_adjacent([2, 1, 4, 9]) == 11 >>> max_subset_sum_no_adjacent([2]) == 2 >>> max_subset_sum_no_adjacent([]) == 0 def main(input_list: List[Union[int, List[int]]]) -> List[int]: This function simulates the main entry point that processes multiple test cases. It extracts each test case, calls the max_subset_sum_no_adjacent function, and returns the results. >>> main([2, 4, [1, 2, 9, 4], 5, [3, 2, 5, 10, 7]]) == [10, 15] >>> main([2, 3, [3, 2, 5], 5, [3, 7, 4, 6, 5]]) == [8, 13] >>> main([1, 4, [2, 1, 4, 9]]) == [11] >>> main([1, 1, [2]]) == [2]","solution":"def max_subset_sum_no_adjacent(nums): This function takes in a list of integers and returns the maximum possible sum of a subset of these integers such that no two chosen integers are adjacent in the original list. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize an array to store the maximum sum until each index max_sum = [0] * len(nums) max_sum[0] = nums[0] max_sum[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): max_sum[i] = max(max_sum[i-1], max_sum[i-2] + nums[i]) return max_sum[-1] def get_max_sums(test_cases): results = [] for case in test_cases: N, numbers = case results.append(max_subset_sum_no_adjacent(numbers)) return results # Sample Input Parsing and Running def main(input_list): T = input_list[0] index = 1 test_cases = [] for _ in range(T): N = input_list[index] numbers = input_list[index + 1] test_cases.append((N, numbers)) index += 2 return get_max_sums(test_cases)"},{"question":"def find_target(matrix, n, target): Find the earliest occurrence of the target value in the matrix. Args: matrix : List[List[int]] : n x n grid of integers n : int : size of the grid target : int : target value to find in the matrix Returns: tuple : coordinates (x, y) of the target value pass def matrix_query_sum(matrix, x1, y1, x2, y2): Simulate sum query on a submatrix from (x1, y1) to (x2, y2). Args: matrix : List[List[int]] : n x n grid of integers x1 : int : top-left corner row index y1 : int : top-left corner column index x2 : int : bottom-right corner row index y2 : int : bottom-right corner column index Returns: int : sum of all values in the defined submatrix pass def test_find_target(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] n = 3 target = 2 assert find_target(matrix, n, target) == (1, 2) def test_find_target_multiple_occurrences(): matrix = [ [1, 2, 3], [2, 5, 6], [7, 8, 9] ] n = 3 target = 2 assert find_target(matrix, n, target) == (1, 2) def test_find_target_not_found(): matrix = [ [1, 3, 3], [4, 5, 6], [7, 8, 9] ] n = 3 target = 2 assert find_target(matrix, n, target) == (-1, -1) def test_matrix_query_sum(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert matrix_query_sum(matrix, 1, 1, 1, 1) == 1 assert matrix_query_sum(matrix, 1, 2, 1, 2) == 2 assert matrix_query_sum(matrix, 2, 1, 2, 3) == 15 assert matrix_query_sum(matrix, 1, 1, 3, 3) == 45 if __name__ == \\"__main__\\": test_find_target() test_find_target_multiple_occurrences() test_find_target_not_found() test_matrix_query_sum() print(\\"All tests passed.\\")","solution":"def find_target(matrix, n, target): for i in range(n): for j in range(n): if matrix[i][j] == target: return (i+1, j+1) return (-1, -1) def matrix_query_sum(matrix, x1, y1, x2, y2): Helper function to simulate sum query on a submatrix from (x1, y1) to (x2, y2). submatrix_sum = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): submatrix_sum += matrix[i][j] return submatrix_sum"},{"question":"def can_collect_exact_points(n: int, y: int, levels: List[int]) -> str: Determines if it's possible to collect exactly y points by choosing a combination of levels. Parameters: n (int): Number of levels y (int): Target points levels (list): List of integers representing points for each level Returns: str: \\"YES\\" if there is a combination of levels that sums to y, \\"NO\\" otherwise Examples: >>> can_collect_exact_points(3, 15, [3, 7, 5]) \\"YES\\" >>> can_collect_exact_points(4, 10, [1, 2, 3, 6]) \\"YES\\" >>> can_collect_exact_points(2, 5, [7, 8]) \\"NO\\"","solution":"def can_collect_exact_points(n, y, levels): Determines if it's possible to collect exactly y points by choosing a combination of levels. Parameters: n (int): Number of levels y (int): Target points levels (list): List of integers representing points for each level Returns: str: \\"YES\\" if there is a combination of levels that sums to y, \\"NO\\" otherwise from itertools import combinations # Trying all possible combinations of the given levels for i in range(1, n + 1): for comb in combinations(levels, i): if sum(comb) == y: return \\"YES\\" return \\"NO\\" # Example usage # n, y = 3, 15 # levels = [3, 7, 5] # print(can_collect_exact_points(n, y, levels)) # Output: \\"YES\\""},{"question":"def largest_anagram_group_size(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Given a number of test cases, find the size of the largest subset of anagram words for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of test cases where each test case consists of the number of words and the list of words. Returns: List[int]: A list of integers representing the size of the largest subset of anagram words for each test case. Example: >>> t = 3 >>> test_cases = [ ... (4, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\"]), ... (3, [\\"bat\\", \\"tab\\", \\"cat\\"]), ... (5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\"]) ... ] >>> largest_anagram_group_size(t, test_cases) [3, 2, 5] from typing import List, Tuple def test_largest_anagram_group_size_case1(): t = 3 test_cases = [ (4, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\"]), (3, [\\"bat\\", \\"tab\\", \\"cat\\"]), (5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\"]) ] assert largest_anagram_group_size(t, test_cases) == [3, 2, 5] def test_largest_anagram_group_size_case2(): t = 2 test_cases = [ (2, [\\"abc\\", \\"acb\\"]), (4, [\\"xyz\\", \\"yzx\\", \\"zxy\\", \\"abcd\\"]) ] assert largest_anagram_group_size(t, test_cases) == [2, 3] def test_largest_anagram_group_size_all_unique(): t = 1 test_cases = [ (3, [\\"dog\\", \\"cat\\", \\"mouse\\"]) ] assert largest_anagram_group_size(t, test_cases) == [1] def test_largest_anagram_group_size_all_same(): t = 1 test_cases = [ (3, [\\"apple\\", \\"apple\\", \\"apple\\"]) ] assert largest_anagram_group_size(t, test_cases) == [3] def test_largest_anagram_group_size_mixed(): t = 4 test_cases = [ (5, [\\"one\\", \\"neo\\", \\"eon\\", \\"abc\\", \\"bca\\"]), (6, [\\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\", \\"start\\"]), (4, [\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"]), (2, [\\"abcdef\\", \\"abcfed\\"]) ] assert largest_anagram_group_size(t, test_cases) == [3, 3, 4, 2]","solution":"def largest_anagram_group_size(t, test_cases): results = [] for i in range(t): n, words = test_cases[i] anagram_map = {} for word in words: sorted_word = ''.join(sorted(word)) if sorted_word in anagram_map: anagram_map[sorted_word] += 1 else: anagram_map[sorted_word] = 1 max_group_size = max(anagram_map.values()) results.append(max_group_size) return results # Example usage: t = 3 test_cases = [ (4, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\"]), (3, [\\"bat\\", \\"tab\\", \\"cat\\"]), (5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\"]) ] print(largest_anagram_group_size(t, test_cases)) # Output: [3, 2, 5]"},{"question":"def max_sum_B(N: int, A: List[int]) -> int: This function returns the maximum possible sum of all elements in the list B after performing the described operations optimally. >>> max_sum_B(5, [1, 2, 3, 4, 5]) 15 >>> max_sum_B(6, [1, 2, 2, 3, 3, 5]) 16 >>> max_sum_B(3, [10, 10, 10]) 30 >>> max_sum_B(4, [0, 0, 0, 0]) 0 >>> max_sum_B(1, [42]) 42 >>> max_sum_B(5, [1, 3, 2, 4, 3]) 13 pass","solution":"def max_sum_B(N, A): This function returns the maximum possible sum of all elements in the list B after performing the described operations optimally. # The optimal sequence consists of greedily taking elements in non-increasing order # Thus, just sort the array in non-increasing order and take the sum. A.sort(reverse=True) return sum(A)"},{"question":"def sieve(n): Generate a list of primes up to n using the Sieve of Eratosthenes. pass def count_prime_pairs(k): Count the number of distinct pairs of prime numbers (p1, p2) such that p1 + p2 = k, where (p1, p2) and (p2, p1) are considered the same pair. >>> count_prime_pairs(10) == 2 >>> count_prime_pairs(26) == 3 >>> count_prime_pairs(100) == 6 >>> count_prime_pairs(7) == 1 >>> count_prime_pairs(12) == 1 pass def solve_primes(q, queries): For each query in queries, return the number of distinct pairs of prime numbers that sum up to the given number. >>> solve_primes(5, [10, 26, 100, 7, 12]) == [2, 3, 6, 1, 1] pass","solution":"def sieve(n): Generate a list of primes up to n using the Sieve of Eratosthenes. is_prime = [True] * (n+1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n+1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, n+1) if is_prime[p]] return prime_numbers def count_prime_pairs(k): Count the number of distinct pairs of prime numbers (p1, p2) such that p1 + p2 = k, where (p1, p2) and (p2, p1) are considered the same pair. primes = sieve(k) prime_set = set(primes) count = 0 for p1 in primes: if p1 > k // 2: break p2 = k - p1 if p2 in prime_set: count += 1 return count def solve_primes(q, queries): results = [] for k in queries: results.append(count_prime_pairs(k)) return results"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_unique_substring_length(\\"ABCABCBB\\") 3 >>> longest_unique_substring_length(\\"BBBB\\") 1 >>> longest_unique_substring_length(\\"ABCDAB\\") 4 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"A\\") 1 >>> longest_unique_substring_length(\\"BBBBB\\") 1 >>> longest_unique_substring_length(\\"ABDEFGAB\\") 6 >>> longest_unique_substring_length(\\"XYZAAXYZ\\") 4 >>> longest_unique_substring_length(\\"ABCADEFGAH\\") 7 >>> longest_unique_substring_length(\\"A\\"*1000) 1 >>> longest_unique_substring_length(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"*10) 26","solution":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest_len = 0 start_idx = 0 for current_idx, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start_idx: start_idx = char_index_map[char] + 1 char_index_map[char] = current_idx current_len = current_idx - start_idx + 1 longest_len = max(longest_len, current_len) return longest_len"},{"question":"def sum_of_series(n: int) -> int: Computes the sum S(n) of the first n terms of the sequence where: - the nth term is n if n is odd, - and nth term is n^2 if n is even. Args: n (int): The number of terms in the sequence. Returns: int: The sum of the first n terms. Examples: >>> sum_of_series(1) 1 >>> sum_of_series(2) 5 >>> sum_of_series(5) 29 pass def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases to compute the sum of the sequence for each N. Args: test_cases (List[int]): A list of integers where each integer represents N. Returns: List[int]: A list of sums corresponding to each test case. Examples: >>> process_test_cases([1, 2, 5]) [1, 5, 29] pass","solution":"def sum_of_series(n): Computes the sum S(n) of the first n terms of the sequence where: - the nth term is n if n is odd, - and nth term is n^2 if n is even. total_sum = 0 for i in range(1, n+1): if i % 2 == 0: # even total_sum += i * i else: # odd total_sum += i return total_sum def process_test_cases(test_cases): results = [] for n in test_cases: results.append(sum_of_series(n)) return results"},{"question":"def is_permutation(arr: List[int]) -> str: Checks if the given array is a permutation of numbers from 1 to n. :param arr: List of integers :return: \\"YES\\" if the array is a permutation, otherwise \\"NO\\" >>> is_permutation([3, 1, 4, 5, 2]) \\"YES\\" >>> is_permutation([1, 4, 2, 2]) \\"NO\\" >>> is_permutation([2, 1]) \\"YES\\" >>> is_permutation([0, 1, 2]) \\"NO\\"","solution":"def is_permutation(arr): Checks if the given array is a permutation of numbers from 1 to n. :param arr: List of integers :return: \\"YES\\" if the array is a permutation, otherwise \\"NO\\" n = len(arr) arr_set = set(arr) if len(arr_set) == n and max(arr_set) == n and min(arr_set) == 1: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def find_diagonal_intersection(t: int, test_cases: List[List[Tuple[int, int]]]) -> List[Tuple[float, float]]: Calculate the intersection point of the diagonals of a parallelogram for multiple test cases. Args: t: The number of test cases. test_cases: A list where each element is a list of 4 tuples, each containing two integers representing the coordinates of the vertices of the parallelogram in clockwise direction. Returns: A list of tuples containing the coordinates of the intersection point of the diagonals, formatted to six decimal places. >>> find_diagonal_intersection(3, [[(0, 0), (4, 0), (6, 3), (2, 3)], [(1, 1), (5, 1), (6, 4), (2, 4)], [(0, 0), (6, 0), (8, 4), (2, 4)]]) [(3.000000, 1.500000), (3.500000, 2.500000), (4.000000, 2.000000)] >>> find_diagonal_intersection(1, [[(0, 0), (2, 0), (2, 2), (0, 2)]]) [(1.000000, 1.000000)]","solution":"def find_diagonal_intersection(t, test_cases): results = [] for i in range(t): x1, y1 = test_cases[i][0] x2, y2 = test_cases[i][1] x3, y3 = test_cases[i][2] x4, y4 = test_cases[i][3] intersection_x = (x1 + x3) / 2 intersection_y = (y1 + y3) / 2 results.append((intersection_x, intersection_y)) return results"},{"question":"def min_colors_to_paint_buildings(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of colors needed to paint all buildings such that no two adjacent buildings have the same color. >>> min_colors_to_paint_buildings(3, [(3, [1, 2, 3]), (4, [10, 10, 10, 10]), (5, [5, 4, 5, 4, 5])]) [2, 1, 2]","solution":"def min_colors_to_paint_buildings(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] if n == 1: # Only one building, so we need just one color results.append(1) continue colors_needed = 1 for j in range(1, n): if heights[j] != heights[j - 1]: colors_needed = 2 break results.append(colors_needed) return results"},{"question":"def find_potential_hashtag(test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determine the most popular hashtag from a list of posts. Each test case is a tuple where the first element is the number of posts and the second element is a list of strings representing the hashtags in each post. Args: test_cases (List[Tuple[int, List[str]]]): Data for multiple test cases. Returns: List[str]: A list of the most popular hashtag for each test case or \\"NO POPULAR HASHTAG\\". >>> find_potential_hashtag([(3, [\\"#food #yummy\\", \\"#food #travel\\", \\"#travel #food\\"])]) [\\"#food\\"] >>> find_potential_hashtag([(4, [\\"#sunrise\\", \\"#sunset\\", \\"#sunrise\\", \\"#sunset\\"])]) [\\"NO POPULAR HASHTAG\\"] pass def parse_input(input_data: str) -> List[Tuple[int, List[str]]]: Parse the input data into test cases format. Args: input_data (str): Raw input data. Returns: List[Tuple[int, List[str]]]: Parsed test cases. >>> parse_input(\\"3n#food #yummyn#food #traveln#travel #foodn0\\") [(3, [\\"#food #yummy\\", \\"#food #travel\\", \\"#travel #food\\"])] >>> parse_input(\\"0\\") [] pass","solution":"def find_popular_hashtag(test_cases): results = [] for case in test_cases: n = case[0] hashtags = case[1:] hashtag_count = {} for hashtags_in_post in hashtags: unique_hashtags = set(hashtags_in_post.split()) for hashtag in unique_hashtags: if hashtag.startswith('#'): hashtag_count[hashtag] = hashtag_count.get(hashtag, 0) + 1 popular_hashtag = \\"NO POPULAR HASHTAG\\" for hashtag, count in hashtag_count.items(): if count > n / 2: popular_hashtag = hashtag break results.append(popular_hashtag) return results def parse_input(input_data): test_cases = [] input_lines = input_data.strip().split('n') i = 0 while i < len(input_lines): n = int(input_lines[i]) if n == 0: break i += 1 hashtags = [] for _ in range(n): hashtags.append(input_lines[i]) i += 1 test_cases.append((n, *hashtags)) return test_cases if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read() test_cases = parse_input(input_data) results = find_popular_hashtag(test_cases) for result in results: print(result)"},{"question":"def max_height_difference(N: int, K: int, a: List[int]) -> int: Returns the maximum possible difference between the highest and lowest selected trees' heights. >>> max_height_difference(7, 3, [3, 1, 4, 1, 5, 9, 2]) 8 >>> max_height_difference(1, 1, [100]) 0 >>> max_height_difference(2, 2, [10, 10]) 0 >>> max_height_difference(2, 2, [1, 100]) 99 >>> max_height_difference(100000, 50000, list(range(1, 100001))) 99999","solution":"def max_height_difference(N, K, a): Returns the maximum possible difference between the highest and lowest selected trees' heights. # Sort the tree heights in ascending order a.sort() # The best option is to take the smallest and the largest one in the subset max_diff = a[-1] - a[0] # As we need at least two trees. return max_diff"},{"question":"def unique_book_types(n: int, books: List[str]) -> int: Returns the number of unique book types based on character frequencies. :param n: int - number of books :param books: list of str - list of book representations :return: int - number of unique book types >>> unique_book_types(5, ['aabbcc', 'bbaacc', 'abc', 'bac', 'xyz']) 3 >>> unique_book_types(4, ['book', 'koob', 'kbob', 'okob']) 2","solution":"def unique_book_types(n, books): Returns the number of unique book types based on character frequencies. :param n: int - number of books :param books: list of str - list of book representations :return: int - number of unique book types from collections import Counter unique_books = set() for book in books: book_signature = tuple(sorted(Counter(book).items())) unique_books.add(book_signature) return len(unique_books)"},{"question":"def largest_contiguous_sum(arr): Finds the maximum sum of any contiguous subarray using Kadane's Algorithm. Args: arr: A list of integers. Returns: The maximum sum of any contiguous subarray. pass def test_largest_contiguous_sum_positive_numbers(): assert largest_contiguous_sum([1, 2, 3, 4, 5]) == 15 def test_largest_contiguous_sum_mixed_numbers(): assert largest_contiguous_sum([2, -1, 2, 3, 4, -5]) == 10 def test_largest_contiguous_sum_negative_numbers(): assert largest_contiguous_sum([-2, -3, -1]) == -1 def test_largest_contiguous_sum_single_element(): assert largest_contiguous_sum([5]) == 5 assert largest_contiguous_sum([-5]) == -5 def test_largest_contiguous_sum_large_mixed_numbers(): assert largest_contiguous_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_largest_contiguous_sum_empty_list(): assert largest_contiguous_sum([]) == 0 def test_largest_contiguous_sum_all_zeroes(): assert largest_contiguous_sum([0, 0, 0, 0, 0]) == 0","solution":"def largest_contiguous_sum(arr): Finds the maximum sum of any contiguous subarray using Kadane's Algorithm. Args: arr: A list of integers. Returns: The maximum sum of any contiguous subarray. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def distinct_substrings(s: str) -> int: Returns the number of distinct substrings in the given string. >>> distinct_substrings(\\"abac\\") == 9 >>> distinct_substrings(\\"a\\") == 1 >>> distinct_substrings(\\"ab\\") == 3 >>> distinct_substrings(\\"aaa\\") == 3 >>> distinct_substrings(\\"abab\\") == 7 >>> distinct_substrings(\\"abcdef\\") == 21 >>> distinct_substrings(\\"racecar\\") == 25 >>> distinct_substrings(\\"cccc\\") == 4","solution":"def distinct_substrings(s): Returns the number of distinct substrings in the given string s. distinct_set = set() n = len(s) # Generate all possible substrings for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] distinct_set.add(substring) # Return the number of distinct substrings return len(distinct_set)"},{"question":"def max_length_subarray_with_sum(a, k): Find the maximum length of a subarray such that the sum of the absolute differences between each pair of consecutive elements in this subarray is less than or equal to k. :param a: List of integers representing the array. :param k: Integer representing the maximum allowed sum of absolute differences. :return: Integer representing the maximum length of the subarray. # Your code here import pytest def test_example_1(): assert max_length_subarray_with_sum([1, 3, 7, 4, 9], 3) == 2 def test_example_2(): assert max_length_subarray_with_sum([1, 2, 3, 4, 5, 6], 10) == 6 def test_example_3(): assert max_length_subarray_with_sum([4, 9, 5, 1, 8, 10, 3], 15) == 4 def test_single_element(): assert max_length_subarray_with_sum([5], 100) == 1 def test_all_elements_identical(): assert max_length_subarray_with_sum([7, 7, 7, 7, 7], 0) == 5 def test_large_k(): assert max_length_subarray_with_sum([1, 3, 7, 4, 9], 100) == 5 def test_large_array(): arr = [i for i in range(1, 100001)] assert max_length_subarray_with_sum(arr, 499500) == 100000","solution":"def max_length_subarray_with_sum(a, k): Find the maximum length of a subarray such that the sum of the absolute differences between each pair of consecutive elements in this subarray is less than or equal to k. :param a: List of integers representing the array. :param k: Integer representing the maximum allowed sum of absolute differences. :return: Integer representing the maximum length of the subarray. n = len(a) if n == 1: return 1 max_length = 0 current_sum = 0 left = 0 for right in range(1, n): current_sum += abs(a[right] - a[right - 1]) while current_sum > k: current_sum -= abs(a[left + 1] - a[left]) left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def odd_occurrences(lst: List[int]) -> List[int]: Returns a list of elements that appear an odd number of times in the given list. The elements in the output list are distinct and maintain the order of their first appearance. >>> odd_occurrences([1, 2, 3, 2, 3, 1, 3]) == [3] >>> odd_occurrences([1, 2, 1, 2]) == [] >>> odd_occurrences([1, 3, 1, 3, 1, 3]) == [1, 3] >>> odd_occurrences([4, 5, 6, 7, 4, 4, 5, 6]) == [4, 7] >>> odd_occurrences([42]) == [42] >>> odd_occurrences([]) == []","solution":"def odd_occurrences(lst): Returns a list of elements that appear an odd number of times in the given list. The elements in the output list are distinct and maintain the order of their first appearance. from collections import Counter # Count the occurrences of each element element_count = Counter(lst) # Filter elements that have an odd number of counts odd_elements = [el for el in element_count if element_count[el] % 2 != 0] # Maintain order of their first appearance return [el for el in lst if el in odd_elements and odd_elements.remove(el) == None]"},{"question":"def can_distribute_equally(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if it is possible to distribute the fruits into equal baskets for each type. >>> can_distribute_equally(3, [(3, [6, 6, 6]), (2, [5, 10]), (4, [8, 2, 4, 6])]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> can_distribute_equally(2, [(3, [6, 6, 6]), (2, [5, 5])]) [\\"YES\\", \\"YES\\"]","solution":"def can_distribute_equally(T, test_cases): Determines if it is possible to distribute the fruits into equal baskets for each type. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of N integers representing fruit counts. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for N, fruits in test_cases: unique_counts = set(fruits) if len(unique_counts) == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # function to handle input and output for the solution def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) idx = 1 test_cases = [] for _ in range(T): N = int(data[idx]) fruits = list(map(int, data[idx+1:idx+1+N])) test_cases.append((N, fruits)) idx += N + 1 results = can_distribute_equally(T, test_cases) for result in results: print(result)"},{"question":"def most_frequent_element(arr: List[int]) -> int: Returns the most frequent element in the array. If multiple elements have the same frequency, the smallest one is returned. >>> most_frequent_element([1]) == 1 >>> most_frequent_element([2, 2, 2, 2]) == 2 >>> most_frequent_element([1, 3, 2, 2, 1, 3, 3]) == 3 >>> most_frequent_element([1, 1, 2, 2, 3, 3]) == 1 >>> most_frequent_element([99, 100, 100, 99, 99]) == 99 >>> most_frequent_element([0, 0, 1, 1, 1, 0, 2, 0]) == 0","solution":"def most_frequent_element(arr): Returns the most frequent element in the array. If multiple elements have the same frequency, the smallest one is returned. from collections import Counter element_counts = Counter(arr) max_frequency = max(element_counts.values()) # Find elements with the highest frequency candidates = [key for key, count in element_counts.items() if count == max_frequency] # Return the smallest element among candidates with max frequency return min(candidates)"},{"question":"def array_intersection(arr1, arr2): Takes two arrays of integers and returns a new array containing elements that are present in both input arrays, maintaining the order of elements as they appear in arr1. >>> array_intersection([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4] >>> array_intersection([1, 2, 3], [4, 5, 6]) == [] >>> array_intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3] >>> array_intersection([], [1, 2, 3]) == [] >>> array_intersection([1, 2, 3], []) == [] >>> array_intersection([1, 2, 2, 3], [2, 3]) == [2, 2, 3] >>> array_intersection([1, 2, 3], [2, 2, 3, 3]) == [2, 3] # Your code here","solution":"def array_intersection(arr1, arr2): Takes two arrays of integers and returns a new array containing elements that are present in both input arrays, maintaining the order of elements as they appear in arr1. set_arr2 = set(arr2) # Convert arr2 to a set for O(1) lookup intersection = [item for item in arr1 if item in set_arr2] return intersection"},{"question":"from typing import List def min_abs_diff(N: int, A: List[int]) -> int: You are given a list of N positive integers. Your goal is to split the list into two non-empty sublists such that the sum of the first sublist is as close as possible to the sum of the second sublist. The objective is to minimize the absolute difference between the sums of the two sublists. Example: >>> min_abs_diff(6, [3, 1, 4, 2, 2, 1]) 1 >>> min_abs_diff(4, [1, 2, 3, 4]) 0 Parameters: N (int): the number of elements in the list A (List[int]): the list of positive integers Returns: int: the minimum possible absolute difference between the sums of the two sublists","solution":"from itertools import combinations def min_abs_diff(N, A): total_sum = sum(A) min_diff = float('inf') # We iterate over all possible non-empty sublists with at least one element for i in range(1, N): for subset in combinations(A, i): subset_sum = sum(subset) other_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - other_sum)) return min_diff"},{"question":"def generate_nice_array(n: int) -> list: Generates a \\"nice\\" array of length n if possible. If no such array exists, returns -1. :param n: Length of the array :return: A list representing the nice array, or -1 if it cannot be generated. >>> generate_nice_array(3) [1, 1, 2] >>> generate_nice_array(5) [1, 1, 2, 1, 1] >>> generate_nice_array(6) [1, 1, 2, 1, 1, 2] >>> generate_nice_array(1) -1 >>> generate_nice_array(2) -1","solution":"def generate_nice_array(n): Generates a \\"nice\\" array of length n if possible. Returns a list representing the nice array, or -1 if it cannot be generated. if n < 3: return -1 # To ensure all elements (i, i+1, i+2) sums to even, we can keep a repeating pattern of [1, 1, 2] # which ensures all triplets sum to 4 (even). result = [] repeat_pattern = [1, 1, 2] for i in range(n): result.append(repeat_pattern[i % 3]) return result"},{"question":"def can_form_triangle(pieces: List[int]) -> bool: Determine if some three lengths can form a triangle. :param pieces: List[int] - List of integers representing the lengths of wood pieces. :return: bool - True if a triangle can be formed, False otherwise. >>> can_form_triangle([2, 3, 4]) True >>> can_form_triangle([1, 2, 3]) False >>> can_form_triangle([5, 1, 1, 2, 2]) True","solution":"def can_form_triangle(pieces): Determine if some three lengths can form a triangle. :param pieces: List[int] - List of integers representing the lengths of wood pieces. :return: bool - True if a triangle can be formed, False otherwise. n = len(pieces) if n < 3: return False pieces.sort() for i in range(n - 2): if pieces[i] + pieces[i + 1] > pieces[i + 2]: return True return False"},{"question":"from typing import List def min_operations_to_one_peak(n: int, sequence: List[int]) -> int: Determine the minimum number of increments and decrements necessary to make the sequence have exactly one peak. Args: n (int): Length of the sequence (3 <= n <= 1000) sequence (List[int]): List of integers representing the sequence (1 <= sequence[i] <= 10^9) Returns: int: The minimum number of increments and decrements required to make the sequence have exactly one peak, or -1 if it's not possible. >>> min_operations_to_one_peak(5, [1, 2, 3, 2, 1]) 0 >>> min_operations_to_one_peak(4, [4, 3, 2, 1]) 2 pass","solution":"def min_operations_to_one_peak(n, sequence): Returns the minimum number of increments and decrements to make the sequence have exactly one peak, or -1 if it's not possible. if n < 3: return -1 def is_peak(seq, i): return seq[i] > seq[i - 1] and seq[i] > seq[i + 1] peaks = [i for i in range(1, n - 1) if is_peak(sequence, i)] if len(peaks) == 0: # if no peaks, find a place to create one for i in range(1, n - 1): if sequence[i] <= sequence[i - 1] and sequence[i] <= sequence[i + 1]: return 1 # increment once to create a peak elif sequence[i] <= sequence[i - 1] or sequence[i] <= sequence[i + 1]: return 2 # increment twice to create a peak if len(peaks) > 1: return -1 return 0"},{"question":"def next_higher_number(s: str) -> int: Implement a function that takes a string of digits as input and returns the next higher number that can be formed using the digits of the input number. If no higher number can be formed, return -1. >>> next_higher_number(\\"12345\\") 12354 >>> next_higher_number(\\"54321\\") -1","solution":"def next_higher_number(s: str) -> int: Returns the next higher number that can be formed using the digits of the input number. If no higher number can be formed, returns -1. digits = list(s) n = len(digits) # Traverse the number from right to left to find the first digit that is smaller than the digit next to it for i in range(n-2, -1, -1): if digits[i] < digits[i+1]: break else: # If no such digit is found, return -1 as the digits are in descending order return -1 # Find the smallest digit on right of the found digit which is larger than the found digit for j in range(n-1, i, -1): if digits[j] > digits[i]: break # Swap the found digits digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after the position 'i' digits = digits[:i+1] + digits[i+1:][::-1] return int(\\"\\".join(digits))"},{"question":"def validate_brackets(sequence: str) -> bool: Checks whether a given string has a valid bracket sequence. A string has a valid bracket sequence if for every opening bracket, there is a corresponding closing bracket of the same type, and the pairs of brackets are properly nested. The brackets considered are: '()', '{}', and '[]'. Examples: >>> validate_brackets('(a + b)') True >>> validate_brackets('{[a + (b * c)]}') True >>> validate_brackets('{a + [b * (c + d)]}}') False >>> validate_brackets('{(a + b]}') False >>> validate_brackets('[(){}()]') True","solution":"def validate_brackets(sequence: str) -> bool: Checks whether a given string has a valid bracket sequence. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in sequence: if char in bracket_map.values(): # opening brackets stack.append(char) elif char in bracket_map.keys(): # closing brackets if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def wave_array(arr): Rearranges an array into a wave-like pattern. Parameters: arr (list): The input list of integers. Returns: list: The rearranged list in wave form. >>> wave_array([1, 3, 4, 2, 5]) [3, 1, 4, 2, 5] >>> wave_array([1, 2, 3, 4]) [2, 1, 4, 3] >>> wave_array([1]) [1] >>> wave_array([2, 1]) [2, 1] >>> wave_array([1, 1, 1, 1]) [1, 1, 1, 1]","solution":"def wave_array(arr): Rearranges an array into a wave-like pattern. Parameters: arr (list): The input list of integers. Returns: list: The rearranged list in wave form. # Sort the array arr.sort() # Swap every adjacent pair for i in range(0, len(arr) - 1, 2): arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr # Example to run the wave_array function if __name__ == \\"__main__\\": n = int(input().strip()) arr = list(map(int, input().strip().split())) result = wave_array(arr) print(\\" \\".join(map(str, result)))"},{"question":"def is_palindrome(n, arr): Determine if the given array is a palindrome. Args: n (int): The number of elements in the array. arr (List[int]): The array of integers. Returns: str: \\"YES\\" if the array is a palindrome, otherwise \\"NO\\" Examples: >>> is_palindrome(5, [1, 2, 3, 2, 1]) 'YES' >>> is_palindrome(4, [1, 2, 3, 4]) 'NO'","solution":"def is_palindrome(n, arr): Returns \\"YES\\" if the array is a palindrome, otherwise \\"NO\\". if arr == arr[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"class Library: A basic inventory management system for a library. The Library class provides functionalities to add new books, remove books by their unique identifier, and search for books either by their unique identifier, title, or author. def __init__(self): Initialize the Library with an empty dictionary of books. pass def add_book(self, book_id, title, author): Add a new book with given id, title, and author. If a book with the same id already exists, update its title and author. Arguments: book_id -- unique identifier for the book title -- title of the book author -- author of the book pass def remove_book(self, book_id): Remove the book with the given unique identifier. If no such book exists, do nothing. Arguments: book_id -- unique identifier for the book to be removed pass def search_by_id(self, book_id): Search for a book by its unique identifier. Arguments: book_id -- unique identifier for the book to be searched Returns: A string containing the book details in the format 'id title author' if the book is found. Otherwise, returns 'Book not found'. pass def search_by_title(self, title): Search for books by their title. Arguments: title -- title of the books to be searched Returns: A string containing all matching books in the format 'id title author', one per line. If no book is found, returns 'No books found'. pass def search_by_author(self, author): Search for books by their author. Arguments: author -- author of the books to be searched Returns: A string containing all matching books in the format 'id title author', one per line. If no book is found, returns 'No books found'. pass # Unit tests def test_add_and_search_by_id(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") assert library.search_by_id(1) == \\"1 The Great Gatsby F. Scott Fitzgerald\\" def test_remove_book(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.remove_book(1) assert library.search_by_id(1) == \\"Book not found\\" def test_search_by_id_not_found(): library = Library() assert library.search_by_id(99) == \\"Book not found\\" def test_search_by_title(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") assert library.search_by_title(\\"The Great Gatsby\\") == \\"1 The Great Gatsby F. Scott Fitzgerald\\" def test_search_by_title_not_found(): library = Library() assert library.search_by_title(\\"Unknown Title\\") == \\"No books found\\" def test_search_by_author(): library = Library() library.add_book(3, \\"1984\\", \\"George Orwell\\") library.add_book(4, \\"Animal Farm\\", \\"George Orwell\\") assert library.search_by_author(\\"George Orwell\\") == \\"3 1984 George Orwelln4 Animal Farm George Orwell\\" def test_search_by_author_not_found(): library = Library() assert library.search_by_author(\\"Unknown Author\\") == \\"No books found\\"","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id, title, author): self.books[book_id] = {\\"title\\": title, \\"author\\": author} def remove_book(self, book_id): if book_id in self.books: del self.books[book_id] def search_by_id(self, book_id): if book_id in self.books: book = self.books[book_id] return f'{book_id} {book[\\"title\\"]} {book[\\"author\\"]}' else: return \\"Book not found\\" def search_by_title(self, title): results = [f'{book_id} {book[\\"title\\"]} {book[\\"author\\"]}' for book_id, book in self.books.items() if book['title'] == title] if results: return \\"n\\".join(results) else: return \\"No books found\\" def search_by_author(self, author): results = [f'{book_id} {book[\\"title\\"]} {book[\\"author\\"]}' for book_id, book in self.books.items() if book['author'] == author] if results: return \\"n\\".join(results) else: return \\"No books found\\""},{"question":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if not node.left: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if not node.right: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def kth_smallest(self, k): Return the k-th smallest element in the BST. pass def find_kth_smallest(T, cases): Find the k-th smallest element in multiple BST test cases. >>> find_kth_smallest(2, [(7, [20, 8, 22, 4, 12, 10, 14], 3), (5, [15, 10, 20, 8, 12], 4)]) [10, 15] >>> find_kth_smallest(1, [(1, [1], 1)]) [1] >>> find_kth_smallest(1, [(4, [4, 3, 2, 1], 2)]) [2] >>> find_kth_smallest(1, [(4, [1, 2, 3, 4], 3)]) [3] >>> find_kth_smallest(1, [(7, [50, 30, 70, 20, 40, 60, 80], 5)]) [60] pass","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if not node.left: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if not node.right: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def kth_smallest(self, k): # Inorder traversal def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Get all elements in sorted order sorted_elements = inorder_traversal(self.root) # Return the k-th smallest element (1-based index) return sorted_elements[k-1] def find_kth_smallest(T, cases): results = [] for i in range(T): N, values, k = cases[i] bst = BST() for val in values: bst.insert(val) results.append(bst.kth_smallest(k)) return results"},{"question":"from typing import List, Tuple def solve(N: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Process queries to find the maximum edge weight on the path from node u to node v in a tree. Args: N (int): The number of nodes in the tree. edges (List[Tuple[int, int, int]]): List of edges represented as tuples of (u, v, w) where u and v are nodes and w is the weight. queries (List[Tuple[int, int]]): List of queries represented as tuples of (u, v) to find maximum edge weight on the path from u to v. Returns: List[int]: List of results for each query with the maximum edge weight on the path from u to v. Example: >>> N = 5 >>> edges = [(1, 2, 3), (1, 3, 2), (2, 4, 4), (2, 5, 6)] >>> queries = [(1, 4), (3, 5), (4, 5)] >>> solve(N, edges, queries) [4, 6, 6]","solution":"import sys from collections import defaultdict, deque sys.setrecursionlimit(10**6) def build_tree(N, edges): tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) return tree def preprocess_lca(N, tree, root=1): LOG = 20 parent = [[-1] * (N + 1) for _ in range(LOG)] max_edge = [[0] * (N + 1) for _ in range(LOG)] depth = [-1] * (N + 1) def dfs(v, p, d, w): parent[0][v] = p max_edge[0][v] = w depth[v] = d for u, w in tree[v]: if u != p: dfs(u, v, d + 1, w) dfs(root, -1, 0, 0) for i in range(1, LOG): for v in range(1, N + 1): if parent[i-1][v] != -1: parent[i][v] = parent[i-1][parent[i-1][v]] max_edge[i][v] = max(max_edge[i-1][v], max_edge[i-1][parent[i-1][v]]) return parent, max_edge, depth def query_lca(parent, max_edge, depth, u, v): if depth[u] < depth[v]: u, v = v, u LOG = len(parent) max_weight = 0 # Lift u to the same level as v for i in range(LOG - 1, -1, -1): if (depth[u] - depth[v]) >= (1 << i): max_weight = max(max_weight, max_edge[i][u]) u = parent[i][u] if u == v: return max_weight # Lift u and v together for i in range(LOG - 1, -1, -1): if parent[i][u] != parent[i][v]: max_weight = max(max_weight, max_edge[i][u], max_edge[i][v]) u = parent[i][u] v = parent[i][v] # Last lift to the common ancestor max_weight = max(max_weight, max_edge[0][u], max_edge[0][v]) return max_weight def solve(N, edges, queries): tree = build_tree(N, edges) parent, max_edge, depth = preprocess_lca(N, tree) results = [] for u, v in queries: results.append(query_lca(parent, max_edge, depth, u, v)) return results"},{"question":"def max_even_odd_selection(test_cases): Determine the maximum number of integers Alice (loves even numbers) and Bob (prefers odd numbers) can select for their respective subsequences from the given test cases. Each test case contains a sequence of integers. :param test_cases: List of tuples. Each tuple contains a list of integers. :return: List of tuples. Each tuple contains the maximum number of evens for Alice and the maximum number of odds for Bob. >>> max_even_odd_selection([(5, [1, 2, 3, 4, 5]), (4, [2, 4, 6, 8]), (6, [1, 3, 5, 7, 9, 11])]) [(2, 3), (4, 0), (0, 6)] pass def parse_input(input_str): Parse the input string to extract the number of test cases and the sequences of integers for each test case. :param input_str: Input string containing the number of test cases and the integers for each test case. :return: List of tuples. Each tuple contains an integer and a list of integers. >>> parse_input(\\"3n5n1 2 3 4 5n4n2 4 6 8n6n1 3 5 7 9 11n\\") [(5, [1, 2, 3, 4, 5]), (4, [2, 4, 6, 8]), (6, [1, 3, 5, 7, 9, 11])] pass def format_output(results): Format the output list of tuples into a string suitable for printing or output. :param results: List of tuples. Each tuple contains two integers representing the maximum number of even and odd numbers selected by Alice and Bob respectively. :return: String format of the results. >>> format_output([(2, 3), (4, 0), (0, 6)]) '2 3n4 0n0 6' pass def test_max_even_odd_selection(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [2, 4, 6, 8]), (6, [1, 3, 5, 7, 9, 11]), ] expected_results = [ (2, 3), (4, 0), (0, 6), ] assert max_even_odd_selection(test_cases) == expected_results def test_parse_input(): input_str = \\"3n5n1 2 3 4 5n4n2 4 6 8n6n1 3 5 7 9 11n\\" expected_output = [ (5, [1, 2, 3, 4, 5]), (4, [2, 4, 6, 8]), (6, [1, 3, 5, 7, 9, 11]), ] assert parse_input(input_str) == expected_output def test_format_output(): results = [ (2, 3), (4, 0), (0, 6), ] expected_output = \\"2 3n4 0n0 6\\" assert format_output(results) == expected_output def test_integration(): input_str = \\"3n5n1 2 3 4 5n4n2 4 6 8n6n1 3 5 7 9 11n\\" expected_output = \\"2 3n4 0n0 6\\" test_cases = parse_input(input_str) results = max_even_odd_selection(test_cases) output_str = format_output(results) assert output_str == expected_output","solution":"def max_even_odd_selection(test_cases): Take a list of test cases, each containing a list of integers, and return the maximum number of even and odd numbers that Alice and Bob can select respectively. :param test_cases: List of tuples. Each tuple contains a list of integers. :return: List of tuples. Each tuple contains the maximum number of evens for Alice and the maximum number of odds for Bob. results = [] for case in test_cases: numbers = case[1] evens = sum(1 for num in numbers if num % 2 == 0) odds = len(numbers) - evens results.append((evens, odds)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] line_idx = 1 for _ in range(T): N = int(input_lines[line_idx]) numbers = list(map(int, input_lines[line_idx + 1].split())) test_cases.append((N, numbers)) line_idx += 2 return test_cases def format_output(results): return \\"n\\".join(f\\"{evens} {odds}\\" for evens, odds in results)"},{"question":"def count_square_aspect_ratio(n: int, dimensions: List[Tuple[int, int]]) -> int: Determine the number of images with a square aspect ratio. Parameters: n (int): Number of images. dimensions (list of tuple): List of tuples where each tuple consists of (width, height). Returns: int: Count of images with a square aspect ratio. >>> count_square_aspect_ratio(5, [(1, 1), (4, 5), (10, 10), (7, 7), (10, 8)]) 3 >>> count_square_aspect_ratio(3, [(1, 2), (3, 4), (5, 6)]) 0 >>> count_square_aspect_ratio(4, [(2, 2), (4, 4), (6, 6), (8, 8)]) 4 >>> count_square_aspect_ratio(4, [(3, 3), (2, 3), (5, 5), (7, 8)]) 2 >>> count_square_aspect_ratio(1, [(5, 5)]) 1 >>> count_square_aspect_ratio(1, [(5, 6)]) 0","solution":"def count_square_aspect_ratio(n, dimensions): Returns the number of images with a square aspect ratio. Parameters: n (int): Number of images. dimensions (list of tuple): List of tuples where each tuple consists of (width, height). Returns: int: Count of images with a square aspect ratio. count = 0 for width, height in dimensions: if width == height: count += 1 return count"},{"question":"from typing import List def length_of_lis_ending_at_each_element(arr: List[int]) -> List[int]: Given an array of integers, return an array of integers representing the length of the longest increasing subsequence (LIS) that ends with each respective element of the original array. The LIS is a subsequence that is strictly increasing. >>> length_of_lis_ending_at_each_element([3, 10, 2, 1, 20]) == [1, 2, 1, 1, 3] >>> length_of_lis_ending_at_each_element([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> length_of_lis_ending_at_each_element([5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1] >>> length_of_lis_ending_at_each_element([4, 2, 3, 1, 5]) == [1, 1, 2, 1, 3] >>> length_of_lis_ending_at_each_element([10, 20, 10, 30, 25, 40]) == [1, 2, 1, 3, 3, 4] >>> length_of_lis_ending_at_each_element([]) == [] >>> length_of_lis_ending_at_each_element([50]) == [1] >>> length_of_lis_ending_at_each_element([2, 2, 2, 2]) == [1, 1, 1, 1] >>> length_of_lis_ending_at_each_element([1, 3, 3, 5, 5, 5, 6]) == [1, 2, 2, 3, 3, 3, 4] >>> length_of_lis_ending_at_each_element([1, 2, 3, 1, 2, 3, 4]) == [1, 2, 3, 1, 2, 3, 4] >>> length_of_lis_ending_at_each_element([4, 3, 2, 1, 2, 3, 4, 5]) == [1, 1, 1, 1, 2, 3, 4, 5]","solution":"from typing import List def length_of_lis_ending_at_each_element(arr: List[int]) -> List[int]: Returns an array where each element at index i represents the length of the longest increasing subsequence ending with arr[i]. if not arr: return [] n = len(arr) lis_length = [1] * n # Initialize the LIS lengths to 1 for every element tails = [] # To store the end elements of the LIS of various lengths for i in range(n): # Binary search for the location of arr[i] in tails low, high = 0, len(tails) while low < high: mid = (low + high) // 2 if tails[mid] < arr[i]: low = mid + 1 else: high = mid # If tails doesn't have enough elements, append the new one if low == len(tails): tails.append(arr[i]) else: tails[low] = arr[i] lis_length[i] = low + 1 return lis_length"},{"question":"from typing import List, Tuple def find_longest_path(n: int, edges: List[Tuple[int, int, int]]) -> int: Determines the length of the longest path in a weighted tree. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int, int]]): A list of edges where each edge is represented by a tuple (u, v, w), indicating an edge between nodes u and v with weight w. Returns: int: The length of the longest path in the tree. Example: >>> find_longest_path(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 6)]) 15 >>> find_longest_path(2, [(1, 2, 10)]) 10","solution":"import sys from collections import defaultdict, deque def find_longest_path(n, edges): # Build graph from edges graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(start): # BFS to find the farthest node and its distance distances = [-1] * (n + 1) distances[start] = 0 queue = deque([start]) farthest_node = start while queue: node = queue.popleft() for neighbor, weight in graph[node]: if distances[neighbor] == -1: # Unvisited distances[neighbor] = distances[node] + weight queue.append(neighbor) if distances[neighbor] > distances[farthest_node]: farthest_node = neighbor return farthest_node, distances[farthest_node] # Step 1: Run BFS from an arbitrary node (let's say node 1) farthest_node_from_start, _ = bfs(1) # Step 2: Run BFS from the farthest node found in step 1 _, longest_path_length = bfs(farthest_node_from_start) return longest_path_length"},{"question":"def merge_sensor_records(n: int, records: List[Tuple[str, float, str]]) -> Tuple[int, List[Tuple[str, float]]]: Merges sensor records based on usage patterns and returns the number of unique devices and their corresponding total usage sorted by device name. Args: n (int): the number of sensor readings. records (List[Tuple[str, float, str]]): Each tuple consists of (device_name, power_usage, zone) Returns: Tuple: (unique_device_count, list of tuples with device name and total power usage) >>> merge_sensor_records(5, [(\\"heater\\", 1500.0, \\"zone1\\"), (\\"heater_1\\", 1500.0, \\"zone2\\"), ... (\\"light\\", 250.0, \\"zone1\\"), (\\"light_bulb\\", 250.0, \\"zone2\\"), ... (\\"ac\\", 2000.0, \\"zone3\\")]) (3, [(\\"ac\\", 2000.0), (\\"heater\\", 3000.0), (\\"light\\", 500.0)]) >>> merge_sensor_records(4, [(\\"computer\\", 300.0, \\"zone1\\"), (\\"pc\\", 300.0, \\"zone2\\"), ... (\\"printer\\", 100.5, \\"zone1\\"), (\\"spooler\\", 100.5, \\"zone2\\")]) (2, [(\\"computer\\", 600.0), (\\"printer\\", 201.0)]) pass # Function implementation here # Unit Tests def test_merge_sensor_records_single_device(): records = [ (\\"heater\\", 1500.0, \\"zone1\\"), (\\"heater_1\\", 1500.0, \\"zone2\\") ] unique_count, merged_devices = merge_sensor_records(2, records) assert unique_count == 1 assert merged_devices == [(\\"heater\\", 3000.0)] def test_merge_sensor_records_multiple_devices(): records = [ (\\"heater\\", 1500.0, \\"zone1\\"), (\\"heater_1\\", 1500.0, \\"zone2\\"), (\\"light\\", 250.0, \\"zone1\\"), (\\"light_bulb\\", 250.0, \\"zone2\\"), (\\"ac\\", 2000.0, \\"zone3\\") ] unique_count, merged_devices = merge_sensor_records(5, records) assert unique_count == 3 assert merged_devices == [(\\"ac\\", 2000.0), (\\"heater\\", 3000.0), (\\"light\\", 500.0)] def test_merge_sensor_records_edge_case(): records = [ (\\"device1\\", 100.0, \\"zone1\\"), (\\"device2\\", 100.0, \\"zone2\\"), (\\"device3\\", 50.0, \\"zone3\\") ] unique_count, merged_devices = merge_sensor_records(3, records) assert unique_count == 2 assert merged_devices == [(\\"device1\\", 200.0), (\\"device3\\", 50.0)] def test_merge_sensor_records_with_no_duplicates(): records = [ (\\"computer\\", 300.0, \\"zone1\\"), (\\"pc\\", 300.0, \\"zone2\\"), (\\"printer\\", 100.5, \\"zone1\\"), (\\"spooler\\", 100.5, \\"zone2\\") ] unique_count, merged_devices = merge_sensor_records(4, records) assert unique_count == 2 assert merged_devices == [(\\"computer\\", 600.0), (\\"printer\\", 201.0)] def test_merge_sensor_records_varied_usage(): records = [ (\\"device1\\", 200.0, \\"zone1\\"), (\\"device2\\", 300.0, \\"zone2\\"), (\\"device3\\", 400.0, \\"zone3\\"), ] unique_count, merged_devices = merge_sensor_records(3, records) assert unique_count == 3 assert merged_devices == [(\\"device1\\", 200.0), (\\"device2\\", 300.0), (\\"device3\\", 400.0)]","solution":"def merge_sensor_records(n, records): Merges sensor records based on usage patterns and returns the number of unique devices and their corresponding total usage sorted by device name. Parameters: n (int): the number of sensor readings records (list of tuples): Each tuple consists of (device_name, power_usage, zone) Returns: tuple: (unique_device_count, list of tuples with device name and total power usage) from collections import defaultdict, Counter usage_to_device = defaultdict(list) device_usage_map = {} for device_name, power_usage, zone in records: usage_to_device[power_usage].append(device_name) if device_name in device_usage_map: device_usage_map[device_name] += power_usage else: device_usage_map[device_name] = power_usage merged_devices = {} for power_usage, devices in usage_to_device.items(): canonical_name = min(devices) if canonical_name not in merged_devices: merged_devices[canonical_name] = sum(device_usage_map[device] for device in devices) sorted_devices = sorted(merged_devices.items()) return len(sorted_devices), sorted_devices"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determine if the string s can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. Example: >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"code\\") False","solution":"from collections import Counter def can_form_palindrome(s): Determine if the string s can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def matrix_transpose(matrix): Write a function 'matrix_transpose' that takes an 'n x m' matrix (a list of n lists, each containing m elements) and returns its transpose. Args: matrix (list of list of int): The input n x m matrix. Returns: list of list of int: The transposed m x n matrix. Examples: >>> matrix_transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> matrix_transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] from solution import matrix_transpose def test_matrix_transpose_square(): assert matrix_transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] def test_matrix_transpose_rectangle(): assert matrix_transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] def test_matrix_transpose_single_row(): assert matrix_transpose([[1, 2, 3, 4]]) == [[1], [2], [3], [4]] def test_matrix_transpose_single_column(): assert matrix_transpose([[1], [2], [3], [4]]) == [[1, 2, 3, 4]] def test_matrix_transpose_empty(): assert matrix_transpose([]) == [] def test_matrix_transpose_one_element(): assert matrix_transpose([[42]]) == [[42]]","solution":"def matrix_transpose(matrix): Returns the transpose of the given n x m matrix. Args: matrix (list of list of int): The input n x m matrix. Returns: list of list of int: The transposed m x n matrix. return [list(row) for row in zip(*matrix)]"},{"question":"from typing import List, Tuple def find_path(maze: List[List[int]]) -> List[Tuple[int, int]]: Finds a path from the top-left corner to the bottom-right corner in a maze, represented by a 2D grid of 0s and 1s. :param maze: 2D list representing the maze where 0 is an open cell and 1 is a wall :return: List of tuples representing the path from (0, 0) to (n-1, m-1) >>> find_path([[0, 1, 0], [0, 0, 0], [1, 0, 0]]) [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)] >>> find_path([[0, 1], [1, 0]]) [] >>> find_path([[1, 0], [0, 0]]) [] >>> find_path([[0, 0], [0, 1]]) [] >>> find_path([[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0]]) [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3)] >>> find_path([[0 for _ in range(10)] for _ in range(10)]) [(0, 0), (0, 1), (0, 2), ..., (9, 9)] >>> find_path([[0, 1], [1, 1], [1, 0]]) [] >>> find_path([[0]]) [(0, 0)] >>> find_path([[1]]) []","solution":"from collections import deque from typing import List, Tuple def find_path(maze: List[List[int]]) -> List[Tuple[int, int]]: Finds a path from the top-left corner to the bottom-right corner in a maze, represented by a 2D grid of 0s and 1s. :param maze: 2D list representing the maze where 0 is an open cell and 1 is a wall :return: List of tuples representing the path from (0, 0) to (n-1, m-1) if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return [] n, m = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([((0, 0), [(0, 0)])]) visited = set((0, 0)) while queue: (x, y), path = queue.popleft() if (x, y) == (n - 1, m - 1): return path for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), path + [(nx, ny)])) return []"},{"question":"def evaluate_rpn(expression: str) -> int: Evaluates a mathematical expression in Reverse Polish Notation (RPN). Args: expression (str): A string representation of the RPN expression. Returns: int: The result of the evaluation. Examples: >>> evaluate_rpn(\\"2 1 + 3 *\\") 9 >>> evaluate_rpn(\\"4 13 5 / +\\") 6 >>> evaluate_rpn(\\"10 6 9 3 + -11 * / * 17 + 5 +\\") 22","solution":"def evaluate_rpn(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). stack = [] tokens = expression.split() for token in tokens: if token in {'+', '-', '*', '/'}: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # using int() to truncate towards zero else: stack.append(int(token)) return stack.pop()"},{"question":"def execute_applications(n, k, cpu_consumption, priority, t): Determines whether it's possible to fully execute all applications based on the given CPU resources and priority levels. Parameters: n (int): Number of applications k (int): Number of priority levels cpu_consumption (list): List of CPU consumption for each application priority (list): List of priority levels for each application t (int): Maximum available CPU resource Returns: tuple: ('POSSIBLE', order) or ('IMPOSSIBLE',) >>> execute_applications(4, 3, [10, 20, 30, 25], [3, 1, 2, 1], 100) ('POSSIBLE', [2, 4, 3, 1]) >>> execute_applications(3, 2, [50, 60, 70], [1, 2, 1], 120) ('IMPOSSIBLE',)","solution":"def execute_applications(n, k, cpu_consumption, priority, t): Determines whether it's possible to fully execute all applications based on the given CPU resources and priority levels. Parameters: n (int): Number of applications k (int): Number of priority levels cpu_consumption (list): List of CPU consumption for each application priority (list): List of priority levels for each application t (int): Maximum available CPU resource Returns: tuple: ('POSSIBLE', order) or ('IMPOSSIBLE',) applications = [(cpu_consumption[i], priority[i], i + 1) for i in range(n)] # Sort applications by priority first and then by their original order if needed applications.sort(key=lambda x: (x[1], x[2])) total_cpu = 0 order = [] for cpu, _, index in applications: if total_cpu + cpu > t: return ('IMPOSSIBLE', ) total_cpu += cpu order.append(index) return ('POSSIBLE', order)"},{"question":"from typing import List, Tuple def min_moves(n: int, m: int, t: int, test_cases: List[Tuple[int, int, int, int, List[List[str]]]]) -> List[int]: Determine the minimum number of moves required for the robot to reach the target position from the starting position in a grid. Args: n : int : the number of rows in the grid. m : int : the number of columns in the grid. t : int : the number of test cases. test_cases : List[Tuple[int, int, int, int, List[List[str]]]] : a list of test cases where each test case contains: - starting position x1, y1 - target position x2, y2 - the grid represented as a list of lists of strings Returns: List[int] : For each test case, return the minimum number of moves to reach the target position or -1 if it's not possible. Example: >>> min_moves(2, 4, 2, [ ... (1, 1, 2, 3, [ ... ['.', '.', '.', '#'], ... ['.', '#', '.', '.'] ... ]), ... (1, 2, 2, 2, [ ... ['.', '#', '.', '#'], ... ['.', '#', '.', '.'] ... ]) ... ]) [3, -1]","solution":"from collections import deque def min_moves(n, m, t, test_cases): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] results = [] for case in test_cases: x1, y1, x2, y2, grid = case # Converting to zero-indexed x1 -= 1 y1 -= 1 x2 -= 1 y2 -= 1 if grid[x1][y1] == '#' or grid[x2][y2] == '#': results.append(-1) continue visited = [[False] * m for _ in range(n)] queue = deque([(x1, y1, 0)]) # (x, y, steps) visited[x1][y1] = True found = False while queue: x, y, steps = queue.popleft() if x == x2 and y == y2: results.append(steps) found = True break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) if not found: results.append(-1) return results def parse_input(input_str): lines = input_str.strip().split('n') header = lines[0].split() n, m, t = int(header[0]), int(header[1]), int(header[2]) index = 1 test_cases = [] for _ in range(t): positions = list(map(int, lines[index].split())) index += 1 grid = [] for i in range(n): grid.append(lines[index].split()) index += 1 test_cases.append((positions[0], positions[1], positions[2], positions[3], grid)) return n, m, t, test_cases def process_input(input_str): n, m, t, test_cases = parse_input(input_str) return min_moves(n, m, t, test_cases)"},{"question":"def can_transform_with_k_operations(s: str, t: str, k: int) -> str: Determines if it is possible to transform string s into string t using exactly k operations. >>> can_transform_with_k_operations(\\"abcde\\", \\"axcye\\", 2) \\"YES\\" >>> can_transform_with_k_operations(\\"abcdef\\", \\"ghijkl\\", 3) \\"NO\\"","solution":"def can_transform_with_k_operations(s, t, k): Determines if it is possible to transform string s into string t using exactly k operations. Parameters: s (str): The original string. t (str): The target string to transform into. k (int): The number of operations allowed. Returns: str: \\"YES\\" if transformation is possible with exactly k operations, otherwise \\"NO\\". # Count the number of different characters num_diff_chars = sum(1 for sc, tc in zip(s, t) if sc != tc) # Check if the number of operations matches the required changes return \\"YES\\" if num_diff_chars == k else \\"NO\\""},{"question":"def check_order(arr: List[int]) -> str: Determines whether the given array is in strictly increasing order, strictly decreasing order, or neither. >>> check_order([1, 2, 3, 4, 5]) 'Increasing' >>> check_order([9, 7, 5, 3]) 'Decreasing' >>> check_order([1, 2, 3, 5, 4, 6]) 'Neither' >>> check_order([1, 3, 2, 4, 5]) 'Neither' >>> check_order([5, 3, 4, 2, 1]) 'Neither' >>> check_order([2, 2, 2, 2]) 'Neither' >>> check_order([1, 2]) 'Increasing' >>> check_order([2, 1]) 'Decreasing' >>> check_order(list(range(1, 101))) 'Increasing' >>> check_order(list(range(100, 0, -1))) 'Decreasing'","solution":"def check_order(arr): Determines whether the given array is in strictly increasing order, strictly decreasing order or neither. n = len(arr) if all(arr[i] < arr[i + 1] for i in range(n - 1)): return \\"Increasing\\" elif all(arr[i] > arr[i + 1] for i in range(n - 1)): return \\"Decreasing\\" else: return \\"Neither\\""},{"question":"from typing import List, Tuple def find_minimum_hops(N: int, M: int, links: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: There are N servers connected by M bidirectional links in a data center. For a given pair of servers (s_i, t_i), find the minimum number of hops needed to travel from Server s_i to Server t_i. If Server t_i is unreachable from Server s_i, output -1. Constraints: - 2 <= N <= 300 - 1 <= M <= N * (N - 1) // 2 - 1 <= A_i, B_i <= N - A_i != B_i - (A_i, B_i) != (A_j, B_j) (if i != j) - (A_i, B_i) != (B_j, A_j) (if i != j) - 1 <= C_i <= 10^9 - 1 <= Q <= N * (N - 1) - 1 <= s_i, t_i <= N - s_i != t_i - (s_i, t_i) != (s_j, t_j) (if i != j) Args: N : int : number of servers. M : int : number of links. links : List[Tuple[int, int, int]] : list of tuples, where each tuple contains two servers and their bandwidth. queries : List[Tuple[int, int]] : list of queries, where each query contains two servers. Returns: List[int] : list of minimum hops for each query. Examples: >>> find_minimum_hops(4, 3, [(1, 2, 100), (2, 3, 200), (3, 4, 150)], [(1, 4), (1, 3)]) [3, 2] >>> find_minimum_hops(4, 2, [(1, 2, 100), (3, 4, 150)], [(1, 3)]) [-1]","solution":"from collections import deque, defaultdict def find_minimum_hops(N, M, links, queries): # Create adjacency list for the graph graph = defaultdict(list) for A_i, B_i, C_i in links: graph[A_i].append(B_i) graph[B_i].append(A_i) # Function to find shortest path using BFS def bfs(source, target): if source == target: return 0 visited = set() queue = deque([(source, 0)]) # (current_node, current_hops) while queue: node, hops = queue.popleft() visited.add(node) for neighbor in graph[node]: if neighbor == target: return hops + 1 if neighbor not in visited: queue.append((neighbor, hops + 1)) visited.add(neighbor) return -1 results = [] for s_i, t_i in queries: results.append(bfs(s_i, t_i)) return results"},{"question":"from typing import List, Tuple def min_cost_to_satisfy_features(required_features: str, plans: List[Tuple[int, str]]) -> int: Determine the minimum cost required to satisfy a given set of required features from a list of subscription plans. If it's not possible to satisfy all the required features with the available plans, return -1. >>> min_cost_to_satisfy_features('featureA featureB', [(30, 'featureA featureC'), (20, 'featureB featureD'), (25, 'featureA featureB featureD')]) 25 >>> min_cost_to_satisfy_features('featureA featureC featureD', [(50, 'featureA'), (20, 'featureC featureD')]) 70 >>> min_cost_to_satisfy_features('featureA featureB', [(30, 'featureA featureC'), (20, 'featureD featureE')]) -1 pass def process_input(input_data: List[str]) -> List[int]: Process the input data and determine the minimum cost for each dataset to satisfy the required features. >>> process_input(['featureA featureB', '3', '30', 'featureA featureC', '20', 'featureB featureD', '25', 'featureA featureB featureD', 'featureA featureC featureD', '2', '50', 'featureA', '20', 'featureC featureD', '0']) [25, 70] >>> process_input(['featureA featureB', '3', '30', 'featureA featureC', '20', 'featureB featureD', '25', 'featureA featureB featureD', 'featureA featureC featureD featureE', '2', '50', 'featureA', '20', 'featureC featureD', '0']) [25, -1] pass","solution":"def min_cost_to_satisfy_features(required_features, plans): from itertools import combinations def is_covered(required_set, available_set): return required_set.issubset(available_set) required_features_set = set(required_features.split()) plan_details = [] for cost, features in plans: feature_set = set(features.split()) plan_details.append((cost, feature_set)) min_cost = float('inf') n = len(plan_details) for r in range(1, n + 1): for combo in combinations(plan_details, r): combined_cost = sum(plan[0] for plan in combo) combined_features = set().union(*(plan[1] for plan in combo)) if is_covered(required_features_set, combined_features): min_cost = min(min_cost, combined_cost) return min_cost if min_cost != float('inf') else -1 def process_input(input_data): index = 0 results = [] while index < len(input_data): required_features = input_data[index].strip() index += 1 if required_features == \\"0\\": break num_plans = int(input_data[index].strip()) index += 1 plans = [] for _ in range(num_plans): cost = int(input_data[index].strip()) index += 1 features = input_data[index].strip() index += 1 plans.append((cost, features)) result = min_cost_to_satisfy_features(required_features, plans) results.append(result) return results"},{"question":"def smallest_string_by_removing_one_char(s: str) -> str: Given a string, returns the lexicographically smallest string that can be obtained by removing exactly one character from the input string. >>> smallest_string_by_removing_one_char(\\"abc\\") \\"ab\\" >>> smallest_string_by_removing_one_char(\\"leetcode\\") \\"eetcode\\" >>> smallest_string_by_removing_one_char(\\"string\\") \\"sring\\"","solution":"def smallest_string_by_removing_one_char(s): Given a string, returns the lexicographically smallest string that can be obtained by removing exactly one character from the input string. # Initialize the smallest string as the input string minus the first character smallest = s[1:] # Iterate through the string, removing one character at each position for i in range(1, len(s)): temp = s[:i] + s[i+1:] smallest = min(smallest, temp) return smallest"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Perform a zigzag level order traversal on a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> zigzagLevelOrder(root) [[1]] >>> zigzagLevelOrder(None) []","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] results = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level.append(node.val) else: level.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(list(level)) left_to_right = not left_to_right return results"},{"question":"def sort_ingredients(n, ingredients): Sort the ingredients alphabetically and format them for delivery. Args: n (int): The number of ingredients. ingredients (list of tuple): Each tuple contains an ingredient's name and its quantity. Returns: List of strings: Sorted and formatted list of ingredients. pass # Unit Test def test_sort_ingredients(): # Test case 1 n = 3 ingredients = [(\\"onion\\", 5), (\\"carrot\\", 2), (\\"lettuce\\", 1)] expected_output = [\\"carrot 2\\", \\"lettuce 1\\", \\"onion 5\\"] assert sort_ingredients(n, ingredients) == expected_output # Test case 2 n = 4 ingredients = [(\\"apple\\", 10), (\\"banana\\", 5), (\\"grape\\", 20), (\\"grapefruit\\", 3)] expected_output = [\\"apple 10\\", \\"banana 5\\", \\"grape 20\\", \\"grapefruit 3\\"] assert sort_ingredients(n, ingredients) == expected_output # Test case 3 n = 2 ingredients = [(\\"zucchini\\", 4), (\\"apple\\", 2)] expected_output = [\\"apple 2\\", \\"zucchini 4\\"] assert sort_ingredients(n, ingredients) == expected_output # Test case 4 n = 1 ingredients = [(\\"pepper\\", 5)] expected_output = [\\"pepper 5\\"] assert sort_ingredients(n, ingredients) == expected_output # Test case 5 n = 5 ingredients = [(\\"cherry\\", 10), (\\"blueberry\\", 1), (\\"apple\\", 3), (\\"banana\\", 7), (\\"date\\", 2)] expected_output = [\\"apple 3\\", \\"banana 7\\", \\"blueberry 1\\", \\"cherry 10\\", \\"date 2\\"] assert sort_ingredients(n, ingredients) == expected_output","solution":"def sort_ingredients(n, ingredients): Sort the ingredients alphabetically and format them for delivery. Args: n (int): The number of ingredients. ingredients (list of tuple): Each tuple contains an ingredient's name and its quantity. Returns: List of strings: Sorted and formatted list of ingredients. # Sort the ingredients list based on the ingredient names sorted_ingredients = sorted(ingredients, key=lambda x: x[0]) # Format the sorted ingredients for the output formatted_ingredients = [f\\"{ingredient} {quantity}\\" for ingredient, quantity in sorted_ingredients] return formatted_ingredients # Input reading and function execution can be handled in another function or by user as needed."},{"question":"def exist(board, word): Check whether a given word exists in the matrix. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once in the same construction. Args: board (List[List[str]]): 2D list representing the board of characters word (str): The word to search in the board Returns: bool: True if the word exists in the matrix, False otherwise Examples: >>> exist([ ... [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], ... [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], ... [\\"A\\", \\"D\\", \\"E\\", \\"E\\"], ... [\\"A\\", \\"F\\", \\"A\\", \\"E\\"] ... ], \\"ABCCED\\") True >>> exist([ ... [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], ... [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], ... [\\"A\\", \\"D\\", \\"E\\", \\"E\\"], ... [\\"A\\", \\"F\\", \\"A\\", \\"E\\"] ... ], \\"SEE\\") True >>> exist([ ... [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], ... [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], ... [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ... ], \\"ABCB\\") False","solution":"def exist(board, word): Returns True if the word exists in the given board, False otherwise. rows, cols = len(board), len(board[0]) def dfs(r, c, word_index): if word_index == len(word): return True if not (0 <= r < rows) or not (0 <= c < cols) or board[r][c] != word[word_index]: return False tmp, board[r][c] = board[r][c], \\"#\\" found = any(dfs(next_r, next_c, word_index + 1) for next_r, next_c in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1), (r + 1, c + 1), (r - 1, c - 1), (r + 1, c - 1), (r - 1, c + 1))) board[r][c] = tmp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"def can_form_magic_square(N: int, numbers: List[int]) -> str: Determine whether given integers can form a magic square of size N x N. Args: N: The size of the magic square (N x N). numbers: List of integers to be used to form the magic square. Returns: 'YES' if it is possible to construct a magic square, otherwise 'NO'. Examples: >>> can_form_magic_square(3, [8, 1, 6, 3, 5, 7, 4, 9, 2]) 'YES' >>> can_form_magic_square(3, [8, 1, 6, 3, 5, 7, 4, 9, 3]) 'NO'","solution":"def can_form_magic_square(N, numbers): def magic_sum(N): return N * (N ** 2 + 1) // 2 def is_magic_square(grid, N, target_sum): for row in grid: if sum(row) != target_sum: return False for col in range(N): if sum(grid[row][col] for row in range(N)) != target_sum: return False if sum(grid[i][i] for i in range(N)) != target_sum: return False if sum(grid[i][N-1-i] for i in range(N)) != target_sum: return False return True from itertools import permutations target_sum = magic_sum(N) possible_permutations = permutations(numbers, N**2) for perm in possible_permutations: grid = [list(perm[i*N:(i+1)*N]) for i in range(N)] if is_magic_square(grid, N, target_sum): return \\"YES\\" return \\"NO\\""},{"question":"def length_of_shortest_substring_with_all_distinct_chars(s: str) -> int: You are given a string s consisting of lowercase letters. Your task is to find the length of the shortest substring of s that contains all the distinct characters of s at least once. >>> length_of_shortest_substring_with_all_distinct_chars(\\"abac\\") 3 >>> length_of_shortest_substring_with_all_distinct_chars(\\"aabc\\") 3 from solution import length_of_shortest_substring_with_all_distinct_chars def test_example_1(): assert length_of_shortest_substring_with_all_distinct_chars(\\"abac\\") == 3 def test_example_2(): assert length_of_shortest_substring_with_all_distinct_chars(\\"aabc\\") == 3 def test_single_char(): assert length_of_shortest_substring_with_all_distinct_chars(\\"aaaa\\") == 1 def test_all_unique_chars(): assert length_of_shortest_substring_with_all_distinct_chars(\\"abcdef\\") == 6 def test_longest_at_end(): assert length_of_shortest_substring_with_all_distinct_chars(\\"abcdeabc\\") == 5 def test_complex_case(): assert length_of_shortest_substring_with_all_distinct_chars(\\"abacacbdcbabc\\") == 4","solution":"def length_of_shortest_substring_with_all_distinct_chars(s): from collections import Counter distinct_chars = set(s) char_count = len(distinct_chars) current_count = Counter() left = 0 min_length = float('inf') for right in range(len(s)): current_count[s[right]] += 1 while len(current_count) == char_count: min_length = min(min_length, right - left + 1) current_count[s[left]] -= 1 if current_count[s[left]] == 0: del current_count[s[left]] left += 1 return min_length"},{"question":"def article_choice(words): Given a list of words, decides whether each word should be preceded by \\"a\\" or \\"an\\" based on its initial vowel sound. Args: words (list of str): List of words to check. Returns: list of str: List containing \\"a\\" or \\"an\\" for each word. >>> article_choice([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\", \\"umbrella\\"]) [\\"an\\", \\"a\\", \\"an\\", \\"a\\", \\"an\\"] >>> article_choice([\\"elephant\\", \\"car\\", \\"igloo\\"]) [\\"an\\", \\"a\\", \\"an\\"] >>> article_choice([\\"banana\\", \\"grape\\", \\"car\\", \\"dog\\", \\"house\\"]) [\\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"a\\"] >>> article_choice([\\"apple\\", \\"banana\\", \\"igloo\\", \\"house\\", \\"umbrella\\"]) [\\"an\\", \\"a\\", \\"an\\", \\"a\\", \\"an\\"] >>> article_choice([\\"elephant\\"]) [\\"an\\"] >>> article_choice([\\"car\\"]) [\\"a\\"] >>> article_choice([]) []","solution":"def article_choice(words): Given a list of words, decides whether each word should be preceded by \\"a\\" or \\"an\\" based on its initial vowel sound. Args: words (list of str): List of words to check. Returns: list of str: List containing \\"a\\" or \\"an\\" for each word. vowels = set('aeiou') result = [] for word in words: if word[0] in vowels: result.append(\\"an\\") else: result.append(\\"a\\") return result"},{"question":"def largest_rectangle_area(histogram): Calculate the largest rectangle area in a histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 2]) 10 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 pass def process_histograms(test_cases): Process multiple test cases for histogram calculations. >>> process_histograms([(7, [2, 1, 5, 6, 2, 3, 2])]) [10] >>> process_histograms([(5, [1, 2, 3, 4, 5]), (7, [6, 2, 5, 4, 5, 1, 6])]) [9, 12] pass def parse_input(input_string): Parse the input string to extract test cases. >>> parse_input(\\"1n7n2 1 5 6 2 3 2n\\") [(7, [2, 1, 5, 6, 2, 3, 2])] >>> parse_input(\\"2n7n2 1 5 6 2 3 2n5n1 2 3 4 5n\\") [(7, [2, 1, 5, 6, 2, 3, 2]), (5, [1, 2, 3, 4, 5])] pass def generate_output(results): Generate output string from results list. >>> generate_output([10, 12]) \\"10n12\\" pass","solution":"def largest_rectangle_area(histogram): Calculate the largest rectangle area in a histogram. :param histogram: List of integers representing the heights of the histogram :return: The area of the largest rectangle possible in the histogram # Create an empty stack. The stack holds indexes of histogram[] list. # The bars stored in stack are always in increasing order of their heights. stack = [] max_area = 0 # Initialize max area index = 0 while index < len(histogram): # If this bar is higher than the bar at stack top, push it to the stack if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_histograms(test_cases): Process multiple test cases for histogram calculations. :param test_cases: List of tuple where each tuple consists of (n, histogram) :return: List of results for each test case. results = [] for n, histogram in test_cases: results.append(largest_rectangle_area(histogram)) return results def parse_input(input_string): Parse the input string to extract test cases. :param input_string: Input string :return: List of test cases lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) histogram = list(map(int, lines[index + 1].strip().split())) test_cases.append((n, histogram)) index += 2 return test_cases def generate_output(results): Generate output string from results list. :param results: List of results :return: Output string return 'n'.join(map(str, results))"},{"question":"def find_kth_digit(base: int, length: int, k: int) -> int: Alex wants to find the k-th digit in the concatenated sequence of a given base number of certain length. Parameters: base (int): The base number to be concatenated. length (int): The desired length of the concatenated sequence. k (int): The position of the digit to find in the concatenated sequence. Returns: int: The k-th digit of the concatenated sequence. Examples: >>> find_kth_digit(23, 5, 3) 2 >>> find_kth_digit(5, 3, 1) 5 >>> find_kth_digit(123, 9, 7) 1 def find_digits_for_tests(test_cases: List[Tuple[int, int, int]]) -> List[int]: Alex wants to find the k-th digit for multiple test cases. Parameters: test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing the base number, desired length, and k-th position respectively. Returns: List[int]: A list of integers representing the k-th digit for each test case respectively. Examples: >>> test_cases = [(23, 5, 3), (5, 3, 1), (123, 9, 7), (6, 5, 5), (1234, 8, 7)] >>> find_digits_for_tests(test_cases) [2, 5, 1, 6, 3]","solution":"def find_kth_digit(base, length, k): base_str = str(base) concat_seq = base_str * ((length // len(base_str)) + 1) return int(concat_seq[k - 1]) def find_digits_for_tests(test_cases): results = [] for base, length, k in test_cases: results.append(find_kth_digit(base, length, k)) return results"},{"question":"def minimum_spells(r, b, g): Calculate the minimum number of spells needed to collect at least the required number of each gem. Parameters: r (int): Required red gems b (int): Required blue gems g (int): Required green gems Returns: int: Minimum number of spells required Examples: >>> minimum_spells(3, 2, 1) 6 >>> minimum_spells(10, 0, 7) 17","solution":"def minimum_spells(r, b, g): Calculate the minimum number of spells needed to collect at least the required number of each gem. Parameters: r (int): Required red gems b (int): Required blue gems g (int): Required green gems Returns: int: Minimum number of spells required return r + b + g"},{"question":"def remove_duplicate_logs(logs): Removes duplicate log entries from the list while maintaining the order of their first occurrence. pass def process_log_file(log_file_content): Processes the log file contents. The first line contains the number of lines n, followed by the log entries. Returns the cleaned log file without duplicates. pass if __name__ == \\"__main__\\": log_file_content = 6 Started processing Started processing Completed processing Database connection established Started processing Database connection closed result = process_log_file(log_file_content) print(result)","solution":"def remove_duplicate_logs(logs): Removes duplicate log entries from the list while maintaining the order of their first occurrence. seen = set() unique_logs = [] for log in logs: if log not in seen: unique_logs.append(log) seen.add(log) return unique_logs def process_log_file(log_file_content): Processes the log file contents. The first line contains the number of lines n, followed by the log entries. Returns the cleaned log file without duplicates. lines = log_file_content.strip().split('n') n = int(lines[0]) logs = lines[1:n+1] cleaned_logs = remove_duplicate_logs(logs) return 'n'.join(cleaned_logs)"},{"question":"def largest_single_digit_subgrid_area(M: int, N: int, grid: List[str]) -> int: Determine the size of the largest rectangular sub-grid that contains only a single type of digit. >>> largest_single_digit_subgrid_area(4, 5, [\\"11111\\", \\"12221\\", \\"12221\\", \\"11111\\"]) 6 >>> largest_single_digit_subgrid_area(3, 3, [\\"123\\", \\"456\\", \\"789\\"]) 1","solution":"def largest_single_digit_subgrid_area(M, N, grid): def max_histogram_area(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_area = 0 height_maps = {str(k): [0] * N for k in range(10)} for row in grid: for d in height_maps: for j in range(N): if row[j] == d: height_maps[d][j] += 1 else: height_maps[d][j] = 0 for d in height_maps: max_area = max(max_area, max_histogram_area(height_maps[d])) return max_area"},{"question":"def max_sum_subarray_k_length(N, K, heights, D): Given an array of integers representing heights of boxes in a row and an integer K, find the maximum sum of any subarray of length exactly K, such that no two consecutive elements in the subarray have a height difference greater than a given threshold D. Args: N (int): The number of boxes. K (int): The length of the subarray. heights (List[int]): The heights of the boxes. D (int): The maximum allowable difference in height between two consecutive boxes. Returns: int: The maximum sum of the subarray of length K satisfying the given condition. If no such subarray exists, return -1. Example: >>> max_sum_subarray_k_length(6, 3, [1, 2, 3, 4, 5, 6], 1) 15 >>> max_sum_subarray_k_length(5, 2, [1, 3, 5, 4, 2], 2) 9 >>> max_sum_subarray_k_length(4, 3, [1, 3, 2, 5], 1) -1","solution":"def max_sum_subarray_k_length(N, K, heights, D): def valid_subarray(subarray): for i in range(1, len(subarray)): if abs(subarray[i] - subarray[i - 1]) > D: return False return True max_sum = -1 for i in range(N - K + 1): subarray = heights[i:i+K] if valid_subarray(subarray): current_sum = sum(subarray) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def addTwoNumbers(l1, l2): Add two numbers represented by linked lists in reverse order. Parameters: l1 (ListNode): The head of the first linked list. l2 (ListNode): The head of the second linked list. Returns: ListNode: The head of the linked list representing the sum. Example: >>> l1 = list_to_linked_list([2, 4, 3]) >>> l2 = list_to_linked_list([5, 6, 4]) >>> linked_list_to_list(addTwoNumbers(l1, l2)) [7, 0, 8] >>> l1 = list_to_linked_list([9, 9, 9]) >>> l2 = list_to_linked_list([1]) >>> linked_list_to_list(addTwoNumbers(l1, l2)) [0, 0, 0, 1] >>> l1 = list_to_linked_list([0]) >>> l2 = list_to_linked_list([0]) >>> linked_list_to_list(addTwoNumbers(l1, l2)) [0] pass def linked_list_to_list(node): Helper function to convert a linked list to a Python list. result = [] while node: result.append(node.val) node = node.next return result def list_to_linked_list(lst): Helper function to convert a Python list to a linked list. if not lst: return None dummy_head = ListNode(0) current = dummy_head for number in lst: current.next = ListNode(number) current = current.next return dummy_head.next","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def addTwoNumbers(l1, l2): Add two numbers represented by linked lists in reverse order. Parameters: l1 (ListNode): The head of the first linked list. l2 (ListNode): The head of the second linked list. Returns: ListNode: The head of the linked list representing the sum. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: sum = carry if l1: sum += l1.val l1 = l1.next if l2: sum += l2.val l2 = l2.next carry = sum // 10 current.next = ListNode(sum % 10) current = current.next return dummy_head.next"},{"question":"def floyd_warshall(n, dist): Applies the Floyd-Warshall algorithm to find shortest paths between all pairs of nodes. for k in range(n): for i in range(n): for j in range(n): if dist[i][k] != float('inf') and dist[k][j] != float('inf'): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist def shortest_path(t, test_cases): Compute the shortest path between two given intersections S and D using the Floyd-Warshall algorithm. If there is no path between the intersections, return -1. input: t: int: number of test cases test_cases: List[dict]: list of dictionary containing test case details output: list of shortest distances for each provided test case. If no path exists, return -1. Example: >>> t = 2 >>> test_cases = [ {'n': 4, 'm': 4, 's': 0, 'd': 3, 'roads': [(0, 1, 3), (1, 2, 1), (2, 3, 2), (0, 3, 10)]}, {'n': 4, 'm': 2, 's': 1, 'd': 3, 'roads': [(1, 2, 5), (2, 3, 7)]} ] >>> shortest_path(t, test_cases) [6, 12]","solution":"def floyd_warshall(n, dist): Applies the Floyd-Warshall algorithm to find shortest paths between all pairs of nodes. for k in range(n): for i in range(n): for j in range(n): if dist[i][k] != float('inf') and dist[k][j] != float('inf'): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist def shortest_path(t, test_cases): results = [] for case in test_cases: n, m, s, d = case['n'], case['m'], case['s'], case['d'] dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for u, v, w in case['roads']: dist[u][v] = w dist[v][u] = w dist = floyd_warshall(n, dist) results.append(dist[s][d] if dist[s][d] != float('inf') else -1) return results"},{"question":"def find_min_max_sum(N: int, A: List[int]) -> Tuple[int, int]: Returns the minimum and maximum possible sum of array A after one reverse operation. Parameters: N (int): The size of the array. A (list of int): The elements of the array. Returns: tuple of int: The minimum and maximum possible sum. >>> find_min_max_sum(4, [1, 3, 2, 4]) (10, 10) >>> find_min_max_sum(3, [5, 2, 7]) (14, 14) >>> find_min_max_sum(5, [1, 1, 1, 1, 1]) (5, 5) >>> find_min_max_sum(2, [1000000000, 1]) (1000000001, 1000000001) >>> find_min_max_sum(6, [1, 2, 3, 4, 5, 6]) (21, 21)","solution":"def find_min_max_sum(N, A): Returns the minimum and maximum possible sum of array A after one reverse operation. Parameters: N (int): The size of the array. A (list of int): The elements of the array. Returns: tuple of int: The minimum and maximum possible sum. # The sum of the array doesn't change due to reversal of any subarray total_sum = sum(A) return total_sum, total_sum"},{"question":"def game_of_life(board): Compute the next state of the 2D grid according to the rules of the Game of Life. The function modifies the input grid in-place. Rules: 1. Any live cell with fewer than two live neighbors dies, as if by underpopulation. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by overpopulation. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Example Usage: >>> board = [ >>> [0, 1, 0], >>> [0, 0, 1], >>> [1, 1, 1], >>> [0, 0, 0] >>> ] >>> game_of_life(board) >>> print(board) >>> # Output should be: >>> # [ >>> # [0, 0, 0], >>> # [1, 0, 1], >>> # [0, 1, 1], >>> # [0, 1, 0] >>> # ] Constraints: - m = board.length - n = board[i].length - 1 <= m, n <= 25 - All the cells in board are either 0 or 1 # Implement the function here","solution":"def game_of_life(board): Given a 2D board of m x n cells, update the board to its next state according to the rules of Game of Life def count_neighbors(r, c): directions = [ (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) ] count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(board) and 0 <= nc < len(board[0]) and abs(board[nr][nc]) == 1: count += 1 return count m, n = len(board), len(board[0]) for r in range(m): for c in range(n): num_live_neighbors = count_neighbors(r, c) if board[r][c] == 1 and (num_live_neighbors < 2 or num_live_neighbors > 3): # Mark the cell as a cell that was live but will die board[r][c] = -1 if board[r][c] == 0 and num_live_neighbors == 3: # Mark the cell as a cell that was dead but will become live board[r][c] = 2 for r in range(m): for c in range(n): if board[r][c] == -1: board[r][c] = 0 if board[r][c] == 2: board[r][c] = 1"},{"question":"def find_max_path_sum(n: int, level_order: List[int], edges: List[Tuple[int, int]]) -> int: Ivy loves working with binary trees. Find the maximum path sum in a binary tree. A path in the binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can be included in the path at most once. The path does not need to go through the root. Parameters: - n: A single integer representing the number of nodes in the binary tree. - level_order: A list of integers representing the values of the nodes in level order traversal. - edges: A list of tuples representing the edges between nodes in the binary tree. Returns: - An integer representing the maximum path sum. >>> find_max_path_sum(5, [1, 2, 3, 4, 5], [(2, 1), (3, 1), (4, 2), (5, 2)]) 11 >>> find_max_path_sum(1, [10], []) 10 >>> find_max_path_sum(5, [-10, 9, 20, 15, 7], [(2, 1), (3, 1), (4, 3), (5, 3)]) 42 >>> find_max_path_sum(5, [-10, -9, -20, -15, -7], [(2, 1), (3, 1), (4, 3), (5, 3)]) -7 >>> find_max_path_sum(3, [1, 2, 3], [(2, 1), (3, 2)]) 6 >>> find_max_path_sum(3, [1, 2, 3], [(2, 1), (3, 1)]) 6","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def build_tree(level_order, edges): if not level_order: return None nodes = [None] + [TreeNode(val) for val in level_order] for u, v in edges: if nodes[v].left is None: nodes[v].left = nodes[u] else: nodes[v].right = nodes[u] return nodes[1] def max_path_sum_helper(node): if node is None: return 0, float('-inf') left_single, left_max = max_path_sum_helper(node.left) right_single, right_max = max_path_sum_helper(node.right) max_single = max(node.val, node.val + left_single, node.val + right_single) max_top = max(max_single, node.val + left_single + right_single) max_sum = max(left_max, right_max, max_top) return max_single, max_sum def max_path_sum(root): _, max_sum = max_path_sum_helper(root) return max_sum def find_max_path_sum(n, level_order, edges): root = build_tree(level_order, edges) return max_path_sum(root)"},{"question":"def common_friends(users: List[List[int]], user_id_1: int, user_id_2: int) -> List[int]: Returns a list of common friends between two users, sorted in ascending order. >>> common_friends([[1, 2, 3], [0, 3], [0], [0, 1]], 0, 3) [1] >>> common_friends([[1, 2], [0, 3], [0, 3], [1, 2]], 1, 2) [0, 3] >>> common_friends([[1], [0], [], []], 0, 2) [] >>> common_friends([[2, 3], [4, 5], [0, 4], [0]], 1, 3) [] >>> common_friends([[1], [0, 2], [1]], 1, 1) [0, 2]","solution":"def common_friends(users, user_id_1, user_id_2): Returns a list of common friends between two users, sorted in ascending order. Parameters: users (List[List[int]]): Friendship data for each user. user_id_1 (int): Identifier of the first user. user_id_2 (int): Identifier of the second user. Returns: List[int]: Sorted list of common friends. friends_user_1 = set(users[user_id_1]) friends_user_2 = set(users[user_id_2]) common = friends_user_1.intersection(friends_user_2) return sorted(list(common))"},{"question":"def isPathExists(grid): Determines if there's a valid path from the top-left to the bottom-right cell in a grid where each cell can either be walkable (0) or blocked (1). >>> isPathExists([[0, 1, 0],[0, 0, 1],[1, 0, 0]]) True >>> isPathExists([[0, 1],[1, 0]]) False","solution":"def isPathExists(grid): Determines if there's a valid path from the top-left to the bottom-right cell in a grid where each cell can either be walkable (0) or blocked (1). n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return False from collections import deque # Directions for moving right and down directions = [(1, 0), (0, 1)] # Queue for BFS with starting point queue = deque([(0, 0)]) # Visited set to keep track of visited cells visited = set((0, 0)) while queue: x, y = queue.popleft() # If we reached the bottom-right cell if x == n-1 and y == n-1: return True # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def can_rearrange(s: str) -> str: Determines if it is possible to rearrange the characters of the string \`s\` such that no two adjacent characters are the same. >>> can_rearrange(\\"aabb\\") \\"Yes\\" >>> can_rearrange(\\"aaab\\") \\"No\\" # Your code here def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns results for each. >>> process_test_cases([\\"aabb\\", \\"aaab\\", \\"abab\\", \\"aab\\", \\"aaa\\"]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\", \\"No\\"] >>> process_test_cases([\\"a\\"]) [\\"Yes\\"] # Your code here # Unit Tests def test_can_rearrange(): assert can_rearrange(\\"aabb\\") == \\"Yes\\" assert can_rearrange(\\"aaab\\") == \\"No\\" assert can_rearrange(\\"abab\\") == \\"Yes\\" assert can_rearrange(\\"aab\\") == \\"Yes\\" assert can_rearrange(\\"aaa\\") == \\"No\\" assert can_rearrange(\\"a\\") == \\"Yes\\" assert can_rearrange(\\"b\\") == \\"Yes\\" def test_process_test_cases(): input_cases = [\\"aabb\\", \\"aaab\\", \\"abab\\", \\"aab\\", \\"aaa\\"] expected_outputs = [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\", \\"No\\"] assert process_test_cases(input_cases) == expected_outputs input_cases_single = [\\"a\\"] expected_outputs_single = [\\"Yes\\"] assert process_test_cases(input_cases_single) == expected_outputs_single","solution":"def can_rearrange(s): Determines if the string s can be rearranged such that no two adjacent characters are the same. # Count the frequency of each character a_count = s.count('a') b_count = s.count('b') # If the difference in count between 'a' and 'b' is more than 1, it's not possible if abs(a_count - b_count) > 1: return \\"No\\" else: return \\"Yes\\" def process_test_cases(test_cases): results = [] for test in test_cases: results.append(can_rearrange(test)) return results"},{"question":"def can_complete_race(N: int, M: int, S: int, D: List[int]) -> str: Determines if the race can be organized such that runners run exactly M meters starting from section S. :param N: Number of sections (int) :param M: Total distance to be run before passing the baton (int) :param S: Starting section (1-based index) (int) :param D: Array of distances (list of int) :return: \\"YES\\" if it is possible to find such sequence, otherwise \\"NO\\" (str) >>> can_complete_race(5, 10, 3, [1, 2, 3, 4, 5]) == \\"YES\\" >>> can_complete_race(4, 15, 1, [4, 3, 2, 1]) == \\"NO\\"","solution":"def can_complete_race(N, M, S, D): Determines if the race can be organized such that runners run exactly M meters starting from section S. :param N: Number of sections (int) :param M: Total distance to be run before passing the baton (int) :param S: Starting section (1-based index) (int) :param D: Array of distances (list of int) :return: \\"YES\\" if it is possible to find such sequence, otherwise \\"NO\\" (str) start_index = S - 1 # Convert to 0-based index current_sum = 0 visited = set() # Use sliding window technique to find the sequence for i in range(start_index, start_index + N): index = i % N current_sum += D[index] visited.add(index) while current_sum > M and len(visited) > 0: remove_index = min(visited) current_sum -= D[remove_index] visited.remove(remove_index) if current_sum == M: return \\"YES\\" return \\"NO\\""},{"question":"class MinStack: Class to implement a stack that supports push, pop, top, and retrieving the minimum element in constant time. Methods ------- push(int x): Pushes an integer x onto the stack. pop(): Removes the element on the top of the stack. top() -> int: Gets the top element of the stack. getMin() -> int: Retrieves the minimum element in the stack. def __init__(self): Initialize the stack. def push(self, x: int) -> None: Push element x onto the stack. def pop(self) -> None: Removes the element on the top of the stack. def top(self) -> int: Get the top element of the stack. def getMin(self) -> int: Retrieve the minimum element in the stack. if __name__ == \\"__main__\\": import pytest def test_min_stack_operations(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.getMin() == -3, \\"Error: Expected minimum is -3\\" min_stack.pop() assert min_stack.top() == 0, \\"Error: Expected top is 0\\" assert min_stack.getMin() == -2, \\"Error: Expected minimum is -2\\" def test_min_stack_single_element(): min_stack = MinStack() min_stack.push(2) assert min_stack.getMin() == 2, \\"Error: Expected minimum is 2\\" assert min_stack.top() == 2, \\"Error: Expected top is 2\\" min_stack.pop() assert min_stack.getMin() is None, \\"Error: Expected minimum is None\\" assert min_stack.top() is None, \\"Error: Expected top is None\\" def test_min_stack_all_operations(): min_stack = MinStack() operations = [ ('push', 5), ('push', 3), ('getMin', None, 3), ('push', 7), ('top', None, 7), ('getMin', None, 3), ('pop', None), ('top', None, 3), ('getMin', None, 3), ('pop', None), ('getMin', None, 5), ] for operation in operations: op = operation[0] arg = operation[1] if isinstance(operation[1], int) else None expected = operation[2] if len(operation) > 2 else None if op == 'push': min_stack.push(arg) elif op == 'pop': min_stack.pop() elif op == 'top': assert min_stack.top() == expected, f\\"Error: Expected top is {expected}\\" elif op == 'getMin': assert min_stack.getMin() == expected, f\\"Error: Expected minimum is {expected}\\" pytest.main()","solution":"class MinStack: def __init__(self): Initialize the stack and a helper stack to keep track of minimums. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto the stack and update the min stack. self.stack.append(x) # If the min stack is empty or the current element is smaller or equal # to the element at the top of the min stack, push it onto the min stack. if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on the top of the stack and updates the min stack. if self.stack: top_element = self.stack.pop() # If the top element is the same as the top of the min stack, pop from the min stack as well. if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element of the stack. if self.stack: return self.stack[-1] return None # If the stack is empty def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] return None # If the min stack is empty"},{"question":"def can_sustain_forever(initial_population, k): Determines if given initial_population (S) with survival factor (k) can sustain itself indefinitely. Returns 'Yes' if it can, otherwise 'No'. pass def process_bacteria_queries(queries): Processes multiple queries to determine if each setup can sustain bacteria forever. Each query is a tuple of initial_population and survival_factor. Returns a list of 'Yes' or 'No' strings. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) queries = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(N)] results = process_bacteria_queries(queries) for result in results: print(result)","solution":"def can_sustain_forever(initial_population, k): Determines if given initial_population (S) with survival factor (k) can sustain itself indefinitely. Returns 'Yes' if it can, otherwise 'No'. # If every k bacteria, only k-1 survive, check if there are k bacteria if initial_population % (k-1) == 0: return \\"No\\" # if they reduce to exact numbers that can eventually be zero, it fails if initial_population < k or k <= 1: if initial_population > 1: return \\"Yes\\" else: return \\"No\\" return \\"Yes\\" def process_bacteria_queries(queries): Processes multiple queries to determine if each setup can sustain bacteria forever. Each query is a tuple of initial_population and survival_factor. Returns a list of 'Yes' or 'No' strings. results = [] for S, k in queries: result = can_sustain_forever(S, k) results.append(result) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) queries = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(N)] results = process_bacteria_queries(queries) for result in results: print(result)"},{"question":"def find_single_number(arr): Given an array of integers where every element appears twice except for one element, find the element that appears only once. >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1, 1, 2, 2, 3]) 3","solution":"def find_single_number(arr): Given an array of integers where every element appears twice except for one element, find the element that appears only once. result = 0 for num in arr: result ^= num return result"},{"question":"def process_queries(arr, queries): Process multiple queries to determine the sum of the elements in a specified range. Parameters: arr (list of int): The list of integers in the array. queries (list of tuples): Each tuple contains two integers L and R, representing the range (1-based index). Returns: list of int: The list of results where each element is the sum of elements in arr for the corresponding query range. Example: >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> process_queries(arr, queries) [6, 9, 15]","solution":"def process_queries(arr, queries): Processes a list of queries on the input array \`arr\` to get the sum of elements in the specified ranges. Parameters: arr (list of int): The list of integers in the array. queries (list of tuples): Each tuple contains two integers L and R, representing the range (1-based index). Returns: list of int: The list of results where each element is the sum of elements in arr for the corresponding query range. N = len(arr) prefix_sums = [0] * (N + 1) # Compute prefix sums for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] results = [] for L, R in queries: # Convert 1-based index to 0-based index internally sum_range = prefix_sums[R] - prefix_sums[L - 1] results.append(sum_range) return results # Example usage # N = 5 # arr = [1, 2, 3, 4, 5] # Q = 3 # queries = [(1, 3), (2, 4), (1, 5)] # The output should be [6, 9, 15] # print(process_queries(arr, queries))"},{"question":"def event_occurrences(n: int, q: int, events: List[int], queries: List[int]) -> List[int]: Given a number of events and their identifiers, along with a series of queries, determine how many times each event has occurred up to the point of each query. Args: n: Number of events q: Number of queries events: List of event identifiers queries: List of event queries Returns: List of integers representing the count of each queried event up to that point. >>> event_occurrences(6, 4, [1, 2, 1, 3, 1, 2], [1, 2, 3, 1]) [3, 2, 1, 4] >>> event_occurrences(1, 1, [1], [1]) [1] >>> event_occurrences(0, 3, [], [1, 2, 3]) [0, 0, 0] >>> event_occurrences(3, 3, [1, 2, 3], [1, 2, 3]) [1, 1, 1] >>> event_occurrences(5, 5, [4, 4, 4, 4, 4], [4, 4, 4, 4, 4]) [5, 6, 7, 8, 9]","solution":"def event_occurrences(n, q, events, queries): event_count = {} # Initialize event_count with initial occurrences from events list for event in events: if event in event_count: event_count[event] += 1 else: event_count[event] = 1 result = [] # Process each query for query in queries: # Append current count of the queried event result.append(event_count.get(query, 0)) # Increment the count of the queried event for future queries if query in event_count: event_count[query] += 1 else: event_count[query] = 1 return result"},{"question":"import heapq def shortest_travel_time(N: int, M: int, roads: List[Tuple[int, int, int]], S: int, T: int) -> int: Returns the shortest travel time from intersection S to intersection T in a given city transportation system. If there is no path from S to T, returns -1. Parameters: N (int): Number of intersections (nodes). M (int): Number of roads (edges). roads (List[Tuple[int, int, int]]): List containing tuples of three integers u, v, w representing a directed road from u to v with travel time w. S (int): Starting intersection. T (int): Destination intersection. Returns: int: The shortest travel time from S to T. If there is no path from S to T, returns -1. >>> shortest_travel_time(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (4, 5, 1)], 1, 5) 6 >>> shortest_travel_time(2, 1, [(1, 2, 10)], 1, 2) 10 >>> shortest_travel_time(3, 2, [(1, 2, 5), (2, 3, 5)], 1, 3) 10 >>> shortest_travel_time(3, 1, [(1, 2, 5)], 1, 3) -1 >>> shortest_travel_time(3, 2, [(1, 2, 5), (2, 3, 5)], 1, 1) 0","solution":"import heapq def shortest_travel_time(N, M, roads, S, T): Returns the shortest travel time from node S to node T. If there is no such path, returns -1. Parameters: N (int): Number of intersections (nodes). M (int): Number of roads (edges). roads (list of tuples): Each tuple contains three integers u, v, w representing a directed road from u to v with travel time w. S (int): Starting intersection. T (int): Destination intersection. Returns: int: Shortest travel time from S to T. If no path, returns -1. # Create adjacency list representation of the graph graph = {i: [] for i in range(1, N + 1)} for u, v, w in roads: graph[u].append((v, w)) # Dijkstra's algorithm heap = [(0, S)] # Min-heap, (travel_time, node) distances = {i: float('inf') for i in range(1, N + 1)} distances[S] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_node == T: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return -1 if distances[T] == float('inf') else distances[T]"},{"question":"def findMissingNumber(arr): Given an array containing \`n-1\` distinct numbers taken from the range \`0\` to \`n-1\`, find the one number that is missing from the array. >>> findMissingNumber([3, 1, 0]) 2 >>> findMissingNumber([1, 2, 3, 4]) 0 >>> findMissingNumber([0, 1, 2, 3]) 4 >>> findMissingNumber([0]) 1 >>> findMissingNumber([1]) 0 >>> findMissingNumber([0, 2]) 1 >>> findMissingNumber([0, 1]) 2 # Your code here from solution import findMissingNumber def test_missing_number_in_middle(): assert findMissingNumber([3, 1, 0]) == 2 def test_missing_number_at_start(): assert findMissingNumber([1, 2, 3, 4]) == 0 def test_missing_number_at_end(): assert findMissingNumber([0, 1, 2, 3]) == 4 def test_large_array(): assert findMissingNumber(list(range(1000)) + list(range(1001, 2000))) == 1000 def test_single_element_array(): assert findMissingNumber([0]) == 1 def test_two_elements_array(): assert findMissingNumber([1]) == 0 def test_missing_number_in_small_array(): assert findMissingNumber([0, 2]) == 1 def test_missing_last_number_in_small_array(): assert findMissingNumber([0, 1]) == 2","solution":"def findMissingNumber(arr): Returns the missing number from the array containing n-1 distinct numbers from 0 to n-1. n = len(arr) + 1 # Since arr contains n-1 numbers expected_sum = n * (n - 1) // 2 # Sum of first n natural numbers actual_sum = sum(arr) # Sum of numbers in the array return expected_sum - actual_sum # The missing number is the difference"},{"question":"def max_beauty_of_garden(test_cases): Determine the maximum number of consecutive flower beds with the same type of flowers in each row after rearranging optimally. :param test_cases: List of tuples, where each tuple contains an integer n (number of flower beds) and a list of integers representing types of flowers in those beds. :return: List of integers, where each integer is the maximum beauty for the corresponding test case. >>> max_beauty_of_garden([(5, [1, 2, 2, 3, 3])]) [2] >>> max_beauty_of_garden([(4, [4, 4, 4, 4])]) [4] pass # Your code here def parse_input(input_data): Parse the input data to extract the test cases. :param input_data: String containing number of test cases and the details of each test case. :return: List of tuples, where each tuple contains an integer n (number of flower beds) and a list of integers representing types of flowers in those beds. >>> parse_input(\\"1n5n1 2 2 3 3n\\") [(5, [1, 2, 2, 3, 3])] >>> parse_input(\\"2n5n1 2 2 3 3n4n4 4 4 4n\\") [(5, [1, 2, 2, 3, 3]), (4, [4, 4, 4, 4])] pass # Your code here import pytest def test_max_beauty_of_garden_single_case(): test_cases = [(5, [1, 2, 2, 3, 3])] assert max_beauty_of_garden(test_cases) == [2] def test_max_beauty_of_garden_many_case(): test_cases = [ (5, [1, 2, 2, 3, 3]), (4, [4, 4, 4, 4]) ] assert max_beauty_of_garden(test_cases) == [2, 4] def test_parse_input_single_case(): input_data = \\"1n5n1 2 2 3 3n\\" assert parse_input(input_data) == [(5, [1, 2, 2, 3, 3])] def test_parse_input_many_cases(): input_data = \\"2n5n1 2 2 3 3n4n4 4 4 4n\\" assert parse_input(input_data) == [ (5, [1, 2, 2, 3, 3]), (4, [4, 4, 4, 4]) ] def test_max_beauty_of_garden_edge_case(): test_cases = [(100000, [5] * 100000)] assert max_beauty_of_garden(test_cases) == [100000] def test_max_beauty_of_garden_mixed_case(): test_cases = [ (5, [5, 5, 5, 4, 3]), (3, [1, 1, 2]), (4, [1, 1, 1, 2]) ] assert max_beauty_of_garden(test_cases) == [3, 2, 3] # Run the tests if __name__ == '__main__': pytest.main([__file__])","solution":"def max_beauty_of_garden(test_cases): results = [] for flower_beds in test_cases: n = flower_beds[0] flowers = flower_beds[1] frequency = {} for flower in flowers: if flower in frequency: frequency[flower] += 1 else: frequency[flower] = 1 max_frequency = max(frequency.values()) results.append(max_frequency) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) flowers = list(map(int, lines[index + 1].split())) test_cases.append((n, flowers)) index += 2 return test_cases"},{"question":"def perform_operations(s: str, operations: List[str]) -> List[int]: Angela is learning about string manipulation and has been given a sequence of operations to perform on a string s. The operations include: 1. Reversing the entire string. 2. Removing a specified character from the string. 3. Counting the occurrences of a specified character in the string. Given a string s and an array of operations, find the result after applying each operation in the given order. >>> perform_operations(\\"abacaba\\", [\\"count a\\", \\"remove a\\", \\"count a\\", \\"reverse\\", \\"count b\\"]) [4, 0, 2] >>> perform_operations(\\"abcdef\\", []) [] >>> perform_operations(\\"banana\\", [\\"remove a\\", \\"remove b\\", \\"remove n\\"]) []","solution":"def perform_operations(s, operations): result = [] for operation in operations: if operation.startswith(\\"reverse\\"): s = s[::-1] elif operation.startswith(\\"remove\\"): _, char_to_remove = operation.split() s = s.replace(char_to_remove, \\"\\") elif operation.startswith(\\"count\\"): _, char_to_count = operation.split() result.append(s.count(char_to_count)) return result"},{"question":"def find_special_number(sequence: List[int]) -> int: Returns the element that appears exactly twice in the list, or -1 if there is no such element. >>> find_special_number([4, 1, 5, 3, 5, 2]) 5 >>> find_special_number([7, 8, 9, 7, 10]) 7 >>> find_special_number([1, 2, 3, 4, 5]) -1","solution":"def find_special_number(sequence): Returns the element that appears exactly twice in the list, or -1 if there is no such element. from collections import Counter count = Counter(sequence) for number, freq in count.items(): if freq == 2: return number return -1"},{"question":"def solve_labyrinths(test_cases): Determine if a path exists from the entrance to the exit of the labyrinth. Inputs: - test_cases: A list of tuples, each containing the labyrinth dimensions and layout. Each tuple contains: 1. An integer n, the number of rows in the labyrinth. 2. An integer m, the number of columns in the labyrinth. 3. A list of strings representing the labyrinth, where '0' denotes a free cell and '1' denotes an obstacle. Returns: - A list of strings \\"Yes\\" or \\"No\\" for each test case indicating whether a path exists. Example: >>> solve_labyrinths([(3, 4, ['0000', '0110', '0000']), (3, 3, ['010', '111', '001'])]) [\\"Yes\\", \\"No\\"]","solution":"def is_path_exist(n, m, labyrinth): Determines if there's a path from the top-left to the bottom-right corner in a given n x m labyrinth. if labyrinth[0][0] == '1' or labyrinth[n-1][m-1] == '1': return \\"No\\" visited = [[False]*m for _ in range(n)] visited[0][0] = True def dfs(x, y): if x == n-1 and y == m-1: return True for dx, dy in [(0, 1), (1, 0)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and labyrinth[nx][ny] == '0' and not visited[nx][ny]: visited[nx][ny] = True if dfs(nx, ny): return True return False return \\"Yes\\" if dfs(0, 0) else \\"No\\" def solve_labyrinths(test_cases): results = [] for n, m, labyrinth in test_cases: results.append(is_path_exist(n, m, labyrinth)) return results"},{"question":"def factorial(n: int) -> int: Return the factorial of a non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(4) 24 >>> factorial(5) 120 def test_factorial(): assert factorial(0) == 1 assert factorial(1) == 1 assert factorial(4) == 24 assert factorial(5) == 120 assert factorial(10) == 3628800 assert factorial(20) == 2432902008176640000 assert factorial(2) == 2 assert factorial(6) == 720","solution":"def factorial(n): Returns the factorial of a non-negative integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def max_treasure(n: int, m: int, grid: List[List[int]]) -> int: Calculate the maximum amount of treasure the knight can collect moving only right or down from the top-left to the bottom-right corner of the grid. >>> max_treasure(3, 4, [ ... [0, 6, 0, 2], ... [5, 8, 7, 9], ... [0, 7, 0, 3] ... ]) == 33 >>> max_treasure(1, 1, [[5]]) == 5 >>> max_treasure(1, 4, [[1, 2, 3, 4]]) == 10 >>> max_treasure(4, 1, [[1], [2], [3], [4]]) == 10 >>> max_treasure(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> n, m = 1000, 1000 >>> grid = [[1] * m for _ in range(n)] >>> max_treasure(n, m, grid) == 1999","solution":"def max_treasure(n, m, grid): # Initialize dp table dp = [[0] * m for _ in range(n)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Answer is the value in the bottom-right cell return dp[n-1][m-1]"},{"question":"def max_stars_in_subgrid(m: int, n: int, grid: List[str], a: int, b: int) -> int: Function to determine the maximum number of distinct stars in any subgrid of dimensions a x b. :param m: Number of rows in the grid :param n: Number of columns in the grid :param grid: List of strings representing the night sky grid :param a: Number of rows in the subgrid :param b: Number of columns in the subgrid :return: Maximum number of distinct stars in any subgrid of dimensions a x b >>> max_stars_in_subgrid(5, 5, [\\"*.*..\\", \\"..*.*\\", \\"*....\\", \\"..*.*\\", \\"*..**\\"], 2, 2) 3 >>> max_stars_in_subgrid(3, 3, [\\"***\\", \\"***\\", \\"***\\"], 2, 2) 4 >>> max_stars_in_subgrid(4, 5, [\\".....\\", \\"...*.\\", \\".....\\", \\"..*..\\"], 2, 2) 1 >>> max_stars_in_subgrid(1, 1, [\\"*\\"], 1, 1) 1 >>> max_stars_in_subgrid(2, 2, [\\"..\\", \\"..\\"], 2, 2) 0 # function implementation","solution":"def max_stars_in_subgrid(m, n, grid, a, b): Function to determine the maximum number of distinct stars in any subgrid of dimensions a x b. :param m: Number of rows in the grid :param n: Number of columns in the grid :param grid: List of strings representing the night sky grid :param a: Number of rows in the subgrid :param b: Number of columns in the subgrid :return: Maximum number of distinct stars in any subgrid of dimensions a x b max_stars = 0 for start_row in range(m - a + 1): for start_col in range(n - b + 1): star_count = 0 for i in range(start_row, start_row + a): for j in range(start_col, start_col + b): if grid[i][j] == '*': star_count += 1 max_stars = max(max_stars, star_count) return max_stars"},{"question":"def is_armstrong_number(n): Returns True if n is an Armstrong number, False otherwise. An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits. >>> is_armstrong_number(153) True >>> is_armstrong_number(9474) True >>> is_armstrong_number(123) False >>> is_armstrong_number(100) False from solution import is_armstrong_number def test_single_digit_armstrong_numbers(): for i in range(10): assert is_armstrong_number(i) == True def test_double_digit_non_armstrong_numbers(): for i in range(10, 100): assert is_armstrong_number(i) == False def test_known_armstrong_numbers(): assert is_armstrong_number(153) == True assert is_armstrong_number(9474) == True assert is_armstrong_number(370) == True assert is_armstrong_number(371) == True assert is_armstrong_number(407) == True def test_known_non_armstrong_numbers(): assert is_armstrong_number(123) == False assert is_armstrong_number(100) == False assert is_armstrong_number(9475) == False assert is_armstrong_number(500) == False assert is_armstrong_number(1000) == False","solution":"def is_armstrong_number(n): Returns True if n is an Armstrong number, False otherwise. digits = [int(digit) for digit in str(n)] num_digits = len(digits) sum_of_powers = sum(digit ** num_digits for digit in digits) return sum_of_powers == n"},{"question":"def count_distinct_palindromic_substrings(S: str, K: int) -> int: Given a string S of length N consisting of lowercase alphabets, find the number of distinct substrings of length exactly K that are palindromes. >>> count_distinct_palindromic_substrings(\\"abacaba\\", 3) 2 >>> count_distinct_palindromic_substrings(\\"abcdefgh\\", 3) 0 >>> count_distinct_palindromic_substrings(\\"abacaba\\", 1) 3 >>> count_distinct_palindromic_substrings(\\"aaaaa\\", 2) 1 >>> count_distinct_palindromic_substrings(\\"aaaaa\\", 3) 1 >>> count_distinct_palindromic_substrings(\\"racecar\\", 7) 1","solution":"def count_distinct_palindromic_substrings(S, K): Returns the number of distinct palindromic substrings of length K in string S. def is_palindrome(s): return s == s[::-1] substrings = set() for i in range(len(S) - K + 1): substring = S[i:i + K] if is_palindrome(substring): substrings.add(substring) return len(substrings)"},{"question":"def canRearrange(s: str) -> bool: Determine whether it is possible to rearrange the letters of the string such that no two adjacent characters are the same. >>> canRearrange(\\"aabb\\") True >>> canRearrange(\\"aaab\\") False >>> canRearrange(\\"abc\\") True","solution":"def canRearrange(s: str) -> bool: from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Find the maximum frequency of any character max_freq = max(freq.values()) # Calculate the size of the remaining portion of the string n = len(s) - max_freq # Check if the maximum frequency character can be placed such that no two adjacent are the same if max_freq - 1 <= n: return True else: return False"},{"question":"def can_form_palindrome(s: str) -> str: Returns 'Yes' if it is possible to rearrange the characters in string s to form a palindrome, otherwise 'No'. >>> can_form_palindrome(\\"aabbcc\\") 'Yes' >>> can_form_palindrome(\\"aabbc\\") 'Yes' >>> can_form_palindrome(\\"abc\\") 'No' def process_test_cases(test_cases: list) -> list: Processes a list of test cases and returns the results for each as a list of 'Yes' or 'No'. >>> process_test_cases([\\"aabbcc\\", \\"aabbc\\", \\"abc\\"]) ['Yes', 'Yes', 'No'] >>> process_test_cases([\\"a\\", \\"ab\\", \\"aa\\"]) ['Yes', 'No', 'Yes'] def main(input_data: str): Input processing function Given a formatted string input, determine if each test case can be rearranged to form a palindrome. >>> main(\\"3naabbccnaabbcnabcn\\") Yes Yes No","solution":"def can_form_palindrome(s): Returns 'Yes' if it is possible to rearrange the characters in string s to form a palindrome, otherwise 'No'. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Track the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd frequency if odd_count > 1: return \\"No\\" else: return \\"Yes\\" def process_test_cases(test_cases): Processes a list of test cases and returns the results for each as a list of 'Yes' or 'No'. results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results # Input processing function def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = lines[1:T + 1] results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def game_winner(T: int, cases: List[Tuple[int, int, int]]) -> List[str]: Determine if Alice has a winning strategy in a painting game. Args: T (int): Number of test cases. cases (List[Tuple[int, int, int]]): List of test cases, each containing M, N, and K. Returns: List[str]: List containing \\"Alice\\" if Alice can guarantee a win, and \\"Bob\\" otherwise for each test case. >>> game_winner(3, [(2, 2, 3), (2, 3, 2), (1, 1, 1)]) [\\"Alice\\", \\"Alice\\", \\"Alice\\"] >>> game_winner(1, [(1, 1, 1)]) [\\"Alice\\"]","solution":"def game_winner(T, cases): results = [] for m, n, k in cases: # As Alice always starts the game and the number of cells (m * n) is finite, # Alice has a winning strategy because she can always paint the last cell. results.append(\\"Alice\\") return results"},{"question":"def isPermutation(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. >>> isPermutation(\\"abc\\", \\"bca\\") True >>> isPermutation(\\"abc\\", \\"def\\") False","solution":"def isPermutation(str1, str2): Determines if one string is a permutation of the other. :param str1: First string :param str2: Second string :return: True if one is a permutation of the other, False otherwise if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"def pair_sums(lst: Takes a list of integers and returns a list of sums of all possible pairs. Each pair should be formed using distinct elements from the input list. If the list has fewer than two elements, return an empty list. Args: lst: List[int] - A list of integers Returns: List[int] - A list of sums of all possible pairs (each sum should be unique) Examples: >>> pair_sums([1, 2, 3]) [3, 4, 5] >>> pair_sums([5, 8]) [13] >>> pair_sums([7]) [] >>> pair_sums([]) []","solution":"from itertools import combinations def pair_sums(lst): Takes a list of integers and returns a list of sums of all possible pairs. Each pair should be formed using distinct elements from the input list. if len(lst) < 2: return [] # Generate all possible pairs using combinations pairs = combinations(lst, 2) # Calculate the sum of each pair and then convert to a set to ensure uniqueness sums = set(sum(pair) for pair in pairs) # Return the sums as a sorted list to ensure a consistent order return sorted(sums)"},{"question":"def min_steps_to_collect_all_treasures(x0, y0, treasures): Calculates the minimum number of steps required to collect all treasures. Parameters: x0 (int): Starting x-coordinate. y0 (int): Starting y-coordinate. treasures (list of tuples): List of (x, y) coordinates for the treasures. Returns: int: Minimum number of steps to collect all treasures. pass def treasure_hunt(T, test_cases): Determines the minimum number of steps required for each test case to collect all the treasures. Parameters: T (int): Number of test cases. test_cases (list of tuples): List of tuples for each test case containing starting coordinates, number of treasures, and treasures' coordinates. Returns: list: List of integers representing the minimum number of steps for each test case. pass from solution import treasure_hunt, min_steps_to_collect_all_treasures def test_min_steps_to_collect_all_treasures(): assert min_steps_to_collect_all_treasures(0, 0, [(-1, -1), (1, 2), (3, 3)]) == 3 assert min_steps_to_collect_all_treasures(-2, -2, [(1, 1), (-3, -3)]) == 3 assert min_steps_to_collect_all_treasures(4, 5, [(5, 6)]) == 1 def test_treasure_hunt(): assert treasure_hunt(2, [ (0, 0, 3, [(-1, -1), (1, 2), (3, 3)]), (-2, -2, 2, [(1, 1), (-3, -3)]) ]) == [3, 3] assert treasure_hunt(1, [ (4, 5, 1, [(5, 6)]) ]) == [1]","solution":"def min_steps_to_collect_all_treasures(x0, y0, treasures): Calculates the minimum number of steps required to collect all treasures. Parameters: x0 (int): Starting x-coordinate. y0 (int): Starting y-coordinate. treasures (list of tuples): List of (x, y) coordinates for the treasures. Returns: int: Minimum number of steps to collect all treasures. max_steps = 0 for (xi, yi) in treasures: steps = max(abs(xi - x0), abs(yi - y0)) max_steps = max(max_steps, steps) return max_steps def treasure_hunt(T, test_cases): results = [] for i in range(T): x0, y0, N, treasures = test_cases[i] results.append(min_steps_to_collect_all_treasures(x0, y0, treasures)) return results"},{"question":"from typing import List, Tuple def find_minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: Uses Kruskal's algorithm to find the minimum spanning tree of a graph with n nodes and edges. pass def calculate_min_total_length(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: For each test case, determine the minimum total length of roads after adding the new optimal road. pass def test_find_minimum_spanning_tree(): edges = [ (0, 1, 3), (1, 2, 4), (2, 3, 5), (3, 0, 6) ] assert find_minimum_spanning_tree(4, edges) == 12 def test_calculate_min_total_length_single_case(): T = 1 test_cases = [ (4, 4, [ (0, 1, 3), (1, 2, 4), (2, 3, 5), (3, 0, 6) ]) ] assert calculate_min_total_length(T, test_cases) == [12] def test_calculate_min_total_length_multiple_cases(): T = 2 test_cases = [ (4, 4, [ (0, 1, 3), (1, 2, 4), (2, 3, 5), (3, 0, 6) ]), (3, 3, [ (0, 1, 1), (1, 2, 2), (0, 2, 3) ]) ] assert calculate_min_total_length(T, test_cases) == [12, 3] def test_minimum_spanning_tree_complex(): edges = [ (0, 1, 1), (0, 2, 1), (0, 3, 1), (1, 2, 2), (1, 3, 2), (2, 3, 2) ] assert find_minimum_spanning_tree(4, edges) == 3","solution":"def find_minimum_spanning_tree(n, edges): Uses Kruskal's algorithm to find the minimum spanning tree of a graph with n nodes and edges. parent = list(range(n)) total_cost = 0 def find_set(v): if parent[v] != v: parent[v] = find_set(parent[v]) return parent[v] def union_sets(a, b): root_a = find_set(a) root_b = find_set(b) if root_a != root_b: parent[root_b] = root_a edges.sort(key=lambda e: e[2]) # Sort edges based on their weight for u, v, w in edges: if find_set(u) != find_set(v): union_sets(u, v) total_cost += w return total_cost def calculate_min_total_length(T, test_cases): results = [] for n, m, edges in test_cases: # Kruskal's algorithm to find the MST total_length = find_minimum_spanning_tree(n, edges) results.append(total_length) return results"},{"question":"def minimal_days_to_water_all_flowers(n: int, water_needs: List[int], T: int) -> int: Determines the minimal number of days required to water all types of flowers with a given amount of water per day. Args: n (int): Number of types of flowers. water_needs (List[int]): List of integers, each representing the total amount of water required by each type of flower. T (int): The amount of water Nina can distribute each day. Returns: int: The minimal number of days required. >>> minimal_days_to_water_all_flowers(3, [4, 5, 6], 3) 5 >>> minimal_days_to_water_all_flowers(2, [10, 10], 5) 4","solution":"def minimal_days_to_water_all_flowers(n, water_needs, T): Determines the minimal number of days required to water all types of flowers with a given amount of water per day. :param n: Integer, number of types of flowers. :param water_needs: List of integers, each representing the total amount of water required by each type of flower. :param T: Integer, the amount of water Nina can distribute each day. :return: Integer, the minimal number of days required. total_water_needed = sum(water_needs) minimal_days = (total_water_needed + T - 1) // T # Divides and rounds up return minimal_days"},{"question":"def can_make_equal(t: int, cases: List[Tuple[str, str]]) -> List[str]: Determine if it is possible to make the strings s1 and s2 equal by performing any number of substring swaps. >>> can_make_equal(3, [(\\"abcd\\", \\"dcba\\"), (\\"face\\", \\"cafe\\"), (\\"abc\\", \\"xyz\\")]) ['YES', 'YES', 'NO'] >>> can_make_equal(1, [(\\"aabbcc\\", \\"ccbbaa\\")]) ['YES']","solution":"def can_make_equal(t, cases): results = [] for s1, s2 in cases: if sorted(s1) == sorted(s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage t = 3 cases = [(\\"abcd\\", \\"dcba\\"), (\\"face\\", \\"cafe\\"), (\\"abc\\", \\"xyz\\")] print(can_make_equal(t, cases)) # Output: ['YES', 'YES', 'NO']"},{"question":"from typing import List def is_subsequence(main_sequence: List[int], sub_sequence: List[int]) -> str: Check if sub_sequence is a subsequence of main_sequence in the same order. >>> is_subsequence([1, 2, 3, 4, 5], [2, 4]) \\"YES\\" >>> is_subsequence([1, 2, 3, 4, 5], [3, 5]) \\"YES\\" >>> is_subsequence([1, 2, 3, 4, 5], [4, 2]) \\"NO\\" def test_is_subsequence_found(): assert is_subsequence([1, 2, 3, 4, 5], [2, 4]) == \\"YES\\" assert is_subsequence([1, 2, 3, 4, 5], [3, 5]) == \\"YES\\" assert is_subsequence([1, 2, 3, 4, 5], [1, 2]) == \\"YES\\" assert is_subsequence([1, 2, 3, 4, 5], [1, 5]) == \\"YES\\" def test_is_subsequence_not_found(): assert is_subsequence([1, 2, 3, 4, 5], [4, 2]) == \\"NO\\" assert is_subsequence([1, 2, 3, 4, 5], [6, 7]) == \\"NO\\" assert is_subsequence([1, 2, 3, 4, 5], [0, 1]) == \\"NO\\" assert is_subsequence([1, 2, 3, 4, 5], [5, 1]) == \\"NO\\" def test_is_subsequence_edge_cases(): assert is_subsequence([1], [1]) == \\"YES\\" assert is_subsequence([1], [2]) == \\"NO\\" assert is_subsequence([], [1]) == \\"NO\\" assert is_subsequence([1, 2, 3, 4, 5], []) == \\"YES\\"","solution":"def is_subsequence(main_sequence, sub_sequence): Check if sub_sequence is a subsequence of main_sequence in the same order. it = iter(main_sequence) for id in sub_sequence: if id not in it: return \\"NO\\" return \\"YES\\""},{"question":"def longest_subarray_with_sum_k(nums, k): Returns the length of the longest contiguous subarray whose sum is exactly k. :param nums: List of integers :param k: Integer target sum :return: Length of the longest subarray with sum k >>> longest_subarray_with_sum_k([1, -1, 5, -2, 3], 3) # 4 (The subarray [1, -1, 5, -2] sums to 3) 4 >>> longest_subarray_with_sum_k([-2, -1, 2, 1], 1) # 2 (The subarray [-1, 2] sums to 1) 2 >>> longest_subarray_with_sum_k([1, 2, 3, -2, 5], 5) # 2 (The subarray [2, 3] sums to 5) 2 >>> longest_subarray_with_sum_k([1, 2, 3, 4, 5], 11) # 0 (No subarray sums to 11) 0","solution":"def longest_subarray_with_sum_k(nums, k): Returns the length of the longest contiguous subarray whose sum is exactly k. :param nums: List of integers :param k: Integer target sum :return: Length of the longest subarray with sum k sum_map = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_length = i + 1 if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"def count_mutual_followers(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determines all mutual following pairs in a network. A pair (A, B) is considered mutual if user A follows user B and user B also follows user A. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): Each test case contains the number of users, number of following relationships, and a list of following relationships. Returns: List[int]: Number of mutual following pairs for each test case Example Usage: >>> t = 2 >>> test_cases = [(3, 3, [(1, 2), (2, 1), (1, 3)]), (4, 3, [(1, 2), (2, 3), (3, 1)])] >>> count_mutual_followers(t, test_cases) [1, 0]","solution":"def count_mutual_followers(t, test_cases): results = [] for case in test_cases: n, m, relations = case follows = {i: set() for i in range(1, n + 1)} for u, v in relations: follows[u].add(v) mutual_count = 0 for u in range(1, n + 1): for v in follows[u]: if u in follows[v]: mutual_count += 1 results.append(mutual_count // 2) return results # Example usage: t = 2 test_cases = [ (3, 3, [(1, 2), (2, 1), (1, 3)]), (4, 3, [(1, 2), (2, 3), (3, 1)]) ] print(count_mutual_followers(t, test_cases)) # Output: [1, 0]"},{"question":"def solve(input_data: str) -> str: Determines if the pattern \\"CODE\\" can be found in the provided grids. The pattern can be found horizontally, vertically, or diagonally. >>> solve(\\"4 5nC X D E XnO D X C CnD X D G OnE O C D En0 0\\") 'FOUND' >>> solve(\\"3 3nX O DnC X EnD C On0 0\\") 'NOT FOUND' from solution import solve def test_solve_found(): input_data = \\"4 5nC X D E XnO D X C CnD X D G OnE O C D En0 0\\" expected_output = \\"FOUND\\" assert solve(input_data) == expected_output def test_solve_not_found(): input_data = \\"3 3nX O DnC X EnD C On0 0\\" expected_output = \\"NOT FOUND\\" assert solve(input_data) == expected_output def test_solve_multiple_cases(): input_data = \\"4 5nC X D E XnO D X C CnD X D G OnE O C D En3 3nX O DnC X EnD C On0 0\\" expected_output = \\"FOUNDnNOT FOUND\\" assert solve(input_data) == expected_output def test_solve_code_diagonal(): input_data = \\"4 4nC X X XnX O X XnX X D XnX X X En0 0\\" expected_output = \\"FOUND\\" assert solve(input_data) == expected_output def test_solve_code_vertical(): input_data = \\"4 4nC X X XnO X X XnD X X XnE X X Xn0 0\\" expected_output = \\"FOUND\\" assert solve(input_data) == expected_output","solution":"def find_code(grid, M, N): rows = M cols = N word = \\"CODE\\" length = len(word) # Define the direction vectors for 8 possible directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # Function to check if a word exists starting at a given position (x, y) in a given direction def search_from(x, y, dx, dy): for k in range(length): nx = x + k * dx ny = y + k * dy if 0 <= nx < rows and 0 <= ny < cols: if grid[nx][ny] != word[k]: return False else: return False return True # Start searching from each grid cell for i in range(rows): for j in range(cols): if grid[i][j] == word[0]: # Only start search if first letter matches for dx, dy in directions: if search_from(i, j, dx, dy): return \\"FOUND\\" return \\"NOT FOUND\\" def solve(input_data): results = [] grids = input_data.strip().split(\\"n\\") index = 0 while index < len(grids): M, N = map(int, grids[index].split()) if M == 0 and N == 0: break grid = [] for i in range(1, M + 1): grid.append(grids[index + i].split()) index += M + 1 result = find_code(grid, M, N) results.append(result) return \\"n\\".join(results)"},{"question":"def generate_spiral_matrix(n: int, m: int) -> List[List[int]]: Generates an n x m spiral matrix filled with numbers from 1 to n * m. >>> generate_spiral_matrix(3, 3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generate_spiral_matrix(4, 3) [ [1, 2, 3], [10, 11, 4], [9, 12, 5], [8, 7, 6] ]","solution":"def generate_spiral_matrix(n, m): Generates an n x m spiral matrix filled with numbers from 1 to n * m. if n <= 0 or m <= 0: return [] matrix = [[0] * m for _ in range(n)] num = 1 left, right = 0, m - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def find_winner(n: int, results: List[Tuple[int, int]]) -> int: Determines the winner based on the highest win/loss ratio and the highest number of games played. Parameters: n (int): The number of players. results (list of tuples): List containing tuples of (win, loss) for each player. Returns: int: The 1-based index of the winning player. >>> find_winner(3, [(7, 3), (4, 2), (5, 1)]) 3 >>> find_winner(3, [(2, 0), (1, 1), (3, 2)]) 1","solution":"def find_winner(n, results): Determines the winner based on the highest win/loss ratio and the highest number of games played. Parameters: n (int): The number of players. results (list of tuples): List containing tuples of (win, loss) for each player. Returns: int: The 1-based index of the winning player. max_ratio = -1 max_games = -1 winner_index = -1 for index, (wins, losses) in enumerate(results): if losses == 0: ratio = float('inf') else: ratio = wins / losses games_played = wins + losses if (ratio > max_ratio) or (ratio == max_ratio and games_played > max_games): max_ratio = ratio max_games = games_played winner_index = index + 1 return winner_index"},{"question":"def findSmallestMissingPositive(arr: List[int]) -> int: Given a list of integers, find the smallest positive integer that is missing from the list. The list may contain both positive and negative integers, but you only need to find the smallest positive integer that is not present in the list. >>> findSmallestMissingPositive([3, 4, -1, 1]) 2 >>> findSmallestMissingPositive([1, 2, 0]) 3 >>> findSmallestMissingPositive([1000000, 999999]) 1 >>> findSmallestMissingPositive([1, 2, 3, 4, 5]) 6 >>> findSmallestMissingPositive([-1, -2, -3]) 1 >>> findSmallestMissingPositive([]) 1 >>> findSmallestMissingPositive(list(range(1, 100001))) 100001","solution":"def findSmallestMissingPositive(arr): n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def minDeletionCost(s, cost): Given a string s and an array of integers cost where cost[i] represents the cost of deleting the ith character in s, returns the minimum cost required to delete characters from s such that the resulting string does not contain any duplicate characters. Parameters: s (str): The input string. cost (list): List of costs associated with deleting characters. Returns: int: The minimum cost required to remove duplicate characters. Examples: >>> minDeletionCost(\\"abaac\\", [1, 2, 3, 4, 5]) 3 >>> minDeletionCost(\\"abc\\", [1, 2, 3]) 0 >>> minDeletionCost(\\"aab\\", [1, 2, 3]) 1","solution":"def minDeletionCost(s, cost): Returns the minimum cost required to remove duplicates in the string s. Parameters: s (str): The input string. cost (list): List of costs associated with deleting characters. Returns: int: The minimum cost required to remove duplicate characters. n = len(s) total_cost = 0 for i in range(1, n): if s[i] == s[i - 1]: total_cost += min(cost[i], cost[i - 1]) if cost[i] < cost[i - 1]: cost[i], cost[i - 1] = cost[i - 1], cost[i] return total_cost"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Finds the length of the longest consecutive elements sequence in the list. Parameters: nums (List[int]): A list of integers. Returns: int: The length of the longest consecutive sequence. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([10, 20, 30, 40, 50]) 1 >>> longest_consecutive_sequence([50, 51, 52, 100, 200, 201, 202]) 3","solution":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive elements sequence in the list. Parameters: nums (List[int]): A list of integers. Returns: int: The length of the longest consecutive sequence. nums_set = set(nums) longest_streak = 0 for num in nums: # Check if \`num\` is the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def minimum_moves_to_sort(lst): Returns the minimum number of adjacent swaps required to sort the list. >>> minimum_moves_to_sort([4, 3, 2, 1, 5]) 6 >>> minimum_moves_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_moves_to_sort([5, 4, 3, 2, 1]) 10 >>> minimum_moves_to_sort([2, 4, 1, 3, 5]) 3 >>> minimum_moves_to_sort([1]) 0 >>> minimum_moves_to_sort([i for i in range(1000, 0, -1)]) 499500","solution":"def count_inversions(arr): Helper function to count inversions in the list using merge sort technique. if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inversions = count_inversions(arr[:mid]) right, right_inversions = count_inversions(arr[mid:]) merged, split_inversions = merge_and_count(left, right) return merged, left_inversions + right_inversions + split_inversions def merge_and_count(left, right): Merge two lists and count split inversions. merged = [] split_inversions = 0 i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) split_inversions += len(left) - i j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged, split_inversions def minimum_moves_to_sort(lst): Returns the minimum number of adjacent swaps required to sort the list. _, inversions = count_inversions(lst) return inversions # Example usage: # n = 5 # lst = [4, 3, 2, 1, 5] # print(minimum_moves_to_sort(lst)) # Output: 6"},{"question":"from typing import List def countPairs(nums: List[int], target: int) -> int: Given an array of integers, return the count of unique pairs that sum up to a given target sum. >>> countPairs([1, 2, 3, 4, 3], 6) 2 >>> countPairs([1, 5, -1, -5], 0) 2 >>> countPairs([2, 3, 4, 1, 2], 5) 2 def test_countPairs_example1(): assert countPairs([1, 2, 3, 4, 3], 6) == 2 def test_countPairs_example2(): assert countPairs([1, 5, -1, -5], 0) == 2 def test_countPairs_example3(): assert countPairs([2, 3, 4, 1, 2], 5) == 2 def test_countPairs_no_pairs(): assert countPairs([1, 2, 3], 10) == 0 def test_countPairs_multiple_duplicates(): assert countPairs([1, 1, 1, 1], 2) == 1 def test_countPairs_with_negatives(): assert countPairs([-2, -1, 0, 1, 2], 0) == 2 def test_countPairs_large_numbers(): assert countPairs([1000000, 500000, -1000000, -500000], 0) == 2","solution":"def countPairs(nums, target): Returns the count of unique pairs that sum up to the given target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return len(pairs)"},{"question":"def unique_substrings(S: str) -> int: Returns the total number of unique substrings in the input string S. >>> unique_substrings(\\"abc\\") 6 >>> unique_substrings(\\"abcd\\") 10 >>> unique_substrings(\\"aaaa\\") 4 >>> unique_substrings(\\"\\") 0 >>> unique_substrings(\\"a\\") 1 >>> unique_substrings(\\"abac\\") 9 >>> unique_substrings(\\"abab\\") 7","solution":"def unique_substrings(S): Returns the total number of unique substrings in the input string S. substrings = set() for i in range(len(S)): for j in range(i + 1, len(S) + 1): substrings.add(S[i:j]) return len(substrings)"},{"question":"def product_of_digits(datasets): Takes a list of strings representing large numbers and returns a list with the product of the digits in each number. >>> product_of_digits([\\"123\\", \\"*\\"]) [6] >>> product_of_digits([\\"240\\", \\"*\\"]) [0] >>> product_of_digits([\\"500\\", \\"*\\"]) [0] >>> product_of_digits([\\"999\\", \\"888\\", \\"*\\"]) [729, 512] >>> product_of_digits([\\"123\\", \\"45\\", \\"678\\", \\"*\\"]) [6, 20, 336] >>> product_of_digits([\\"11111\\", \\"*\\"]) [1] >>> product_of_digits([\\"102345\\", \\"*\\"]) [0] >>> product_of_digits([\\"*\\",]) [] >>> product_of_digits([\\"1\\" * 1000, \\"*\\"]) [1] >>> product_of_digits([\\"2\\" * 1000, \\"*\\"]) [2**1000] >>> product_of_digits([\\"456070985\\", \\"*\\"]) [0]","solution":"def product_of_digits(datasets): Takes a list of strings representing large numbers and returns a list with the product of the digits in each number. products = [] for number in datasets: if number == '*': break product = 1 for digit in number: product *= int(digit) if product == 0: break products.append(product) return products # Example usage: datasets = [\\"123\\", \\"240\\", \\"500\\", \\"*\\"] print(product_of_digits(datasets)) # Output: [6, 0, 0]"},{"question":"def find_hidden_number(arr): Finds the hidden number X in the array. All elements in the array appear twice except one element which appears once. def solve_contests(test_cases): Solves multiple test cases of the hidden number problem. :param test_cases: List of tuples, where each tuple contains an integer N and a list of N integers. :return: List of integers representing the hidden number for each test case. >>> test_cases = [ ... (5, [1, 2, 3, 2, 1]), ... (7, [4, 5, 4, 5, 6, 7, 7]) ... ] >>> solve_contests(test_cases) [3, 6]","solution":"def find_hidden_number(arr): Finds the hidden number X in the array. All elements in the array appear twice except one element which appears once. result = 0 for num in arr: result ^= num return result def solve_contests(test_cases): results = [] for case in test_cases: N, arr = case results.append(find_hidden_number(arr)) return results"},{"question":"from typing import List def warehouse_delivery(m: int, n: int, grid: List[List[int]]) -> int: Determine if there exists a path for the robot from the top-left corner to the bottom-right corner. If there is a path, return the length of the shortest path, otherwise return -1. >>> warehouse_delivery(3, 3, [ ... [0, 0, 1], ... [0, 0, 1], ... [1, 0, 0] ... ]) == 5 >>> warehouse_delivery(3, 3, [ ... [0, 0, 1], ... [1, 1, 1], ... [1, 0, 0] ... ]) == -1","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from top-left corner to bottom-right corner in a grid avoiding obstacles, or -1 if no such path exists. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0)] # right, down queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, step = queue.popleft() if x == m-1 and y == n-1: return step for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, step + 1)) return -1 def warehouse_delivery(m, n, grid): return shortest_path(grid)"},{"question":"def maxProjectProfit(N, K, P): Determine maximum profit by selecting up to K projects from array P of size N. Args: N (int): Number of projects. K (int): Maximum number of projects to be undertaken. P (List[int]): Array representing the profit values of the projects. Returns: int: Maximum profit achievable by selecting up to K projects. Examples: >>> maxProjectProfit(5, 3, [10, -5, 15, 20, -10]) 45 >>> maxProjectProfit(4, 2, [-3, -1, 2, -2]) 2","solution":"def maxProjectProfit(N, K, P): Determine maximum profit by selecting up to K projects from array P of size N. Args: N (int): Number of projects. K (int): Maximum number of projects to be undertaken. P (List[int]): Array representing the profit values of the projects. Returns: int: Maximum profit achievable by selecting up to K projects. # Sort the list in descending order to prioritize high profits P.sort(reverse=True) # Select the top K projects selected_profits = P[:K] # Calculate the maximum profit by summing up the selected profits max_profit = sum(profit for profit in selected_profits if profit > 0) return max_profit"},{"question":"def count_common_words(doc1: str, doc2: str) -> int: Returns the number of common words between two input strings. >>> count_common_words(\\"hello world\\", \\"hello there\\") 1 >>> count_common_words(\\"apple banana cherry\\", \\"banana fruit cherry\\") 2","solution":"def count_common_words(doc1, doc2): Returns the number of common words between two input strings. :param doc1: A string representing the first document. :param doc2: A string representing the second document. :return: An integer representing the number of common words. words1 = set(doc1.split()) words2 = set(doc2.split()) common_words = words1.intersection(words2) return len(common_words)"},{"question":"def find_original_list(nums, k): Given a list 'nums' that has been rotated 'k' positions to the right, returns the original sorted list. >>> find_original_list([4, 5, 6, 7, 1, 2, 3], 4) [1, 2, 3, 4, 5, 6, 7] >>> find_original_list([13, 18, 20, 1, 3, 6, 11], 3) [1, 3, 6, 11, 13, 18, 20] >>> find_original_list([7, 9, 11, 12, 15, 1, 3, 5], 5) [1, 3, 5, 7, 9, 11, 12, 15]","solution":"def find_original_list(nums, k): Given a list 'nums' that has been rotated 'k' positions to the right, returns the original sorted list. n = len(nums) # Determine the start of the original list before rotation start = n - k # Reconstruct the original list original_list = nums[start:] + nums[:start] # Sort the original list original_list.sort() return original_list"},{"question":"def transpose_matrix(n: int, m: int, matrix: List[List[int]]) -> List[List[int]]: Computes and returns the transpose of a given n x m matrix. Args: n (int): Number of rows in the original matrix. m (int): Number of columns in the original matrix. matrix (list of list of ints): The original n x m matrix. Returns: list of list of ints: The m x n transposed matrix. >>> transpose_matrix(2, 3, [[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix(3, 3, [[1, -1, 0], [0, 1, 1], [-1, 0, 1]]) [[1, 0, -1], [-1, 1, 0], [0, 1, 1]] >>> transpose_matrix(1, 4, [[1, 3, 5, 7]]) [[1], [3], [5], [7]] from typing import List","solution":"def transpose_matrix(n, m, matrix): Computes and returns the transpose of a given n x m matrix. Args: n (int): Number of rows in the original matrix. m (int): Number of columns in the original matrix. matrix (list of list of ints): The original n x m matrix. Returns: list of list of ints: The m x n transposed matrix. transposed = [[matrix[j][i] for j in range(n)] for i in range(m)] return transposed"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to turn the given string into a palindrome. >>> min_operations_to_palindrome(\\"abc\\") 1 >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"race\\") 2 >>> min_operations_to_palindrome(\\"a\\") 0 >>> min_operations_to_palindrome(\\"aa\\") 0 >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"abcba\\") 0 >>> min_operations_to_palindrome(\\"abccba\\") 0 >>> min_operations_to_palindrome(\\"abccbx\\") 1 def solve_palindrome_cases(test_cases: List[str]) -> List[str]: For each test case, output the minimum number of operations required to turn the given string into a palindrome >>> solve_palindrome_cases([\\"abc\\", \\"abca\\", \\"race\\"]) [\\"Case #1: 1\\", \\"Case #2: 1\\", \\"Case #3: 2\\"] >>> solve_palindrome_cases([\\"a\\", \\"aa\\", \\"ab\\", \\"abcba\\", \\"abccba\\", \\"abccbx\\"]) [\\"Case #1: 0\\", \\"Case #2: 0\\", \\"Case #3: 1\\", \\"Case #4: 0\\", \\"Case #5: 0\\", \\"Case #6: 1\\"]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to turn the given string into a palindrome. n = len(s) operations_count = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: operations_count += 1 return operations_count def solve_palindrome_cases(test_cases): results = [] for i, s in enumerate(test_cases, 1): min_operations = min_operations_to_palindrome(s) results.append(f\\"Case #{i}: {min_operations}\\") return results"},{"question":"def minWindow(s: str, t: str) -> str: Write a function that takes a non-empty string \`s\` and a string \`t\` as input and returns the minimum window substring of \`s\` such that every character in \`t\` (including duplicates) is included in the window. If there is no such substring, return an empty string. Args: s (str): A non-empty string consisting of uppercase and lowercase English letters. t (str): A string consisting of uppercase and lowercase English letters. Returns: str: The minimum window substring of \`s\` that includes all characters in \`t\`. If no such substring exists, return an empty string. >>> minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> minWindow(\\"a\\", \\"a\\") == \\"a\\" >>> minWindow(\\"a\\", \\"aa\\") == \\"\\" def test_min_window(): assert minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" assert minWindow(\\"a\\", \\"a\\") == \\"a\\" assert minWindow(\\"a\\", \\"aa\\") == \\"\\" assert minWindow(\\"abcdefgh\\", \\"fgh\\") == \\"fgh\\" assert minWindow(\\"abdbca\\", \\"abc\\") == \\"bca\\" assert minWindow(\\"acbbaca\\", \\"aba\\") == \\"baca\\" assert minWindow(\\"this is a test string\\", \\"tist\\") == \\"t stri\\"","solution":"from collections import Counter, defaultdict def minWindow(s: str, t: str) -> str: Returns the minimum window substring of \`s\` that contains all characters of \`t\`. if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) # Filter s to only include characters that are in t filtered_s = [] for i, char in enumerate(s): if char in dict_t: filtered_s.append((i, char)) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None # (window length, left, right) while r < len(filtered_s): char = filtered_s[r][1] window_counts[char] += 1 if window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = filtered_s[l][1] end = filtered_s[r][0] start = filtered_s[l][0] if end - start + 1 < ans[0]: ans = (end - start + 1, start, end) window_counts[char] -= 1 if window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[1] is None else s[ans[1] : ans[2] + 1]"},{"question":"def unique_paths_with_obstacles(grid: List[List[str]]) -> int: Calculate the number of unique paths the robot can take to reach the bottom-right corner in a grid with obstacles. >>> unique_paths_with_obstacles([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) == 2 >>> unique_paths_with_obstacles([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '#'] ... ]) == 0","solution":"def unique_paths_with_obstacles(grid): MOD = 10**9 + 7 N = len(grid) M = len(grid[0]) # Edge case where start or end is blocked if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 # Start point for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1]"},{"question":"def max_pill_weight(n, W, weights): Determine the maximum weight of the pill that does not exceed the specified limit. Args: n (int): number of different types of ingredients W (int): maximum weight of the pill weights (list of int): list of ingredient weights Returns: int: maximum possible weight of the pill >>> max_pill_weight(3, 10, [2, 3, 7]) 10 >>> max_pill_weight(4, 5, [1, 2, 3, 4]) 5 >>> max_pill_weight(1, 1, [1]) 1 >>> max_pill_weight(3, 9, [3, 5, 7]) 9 >>> max_pill_weight(5, 10, [1, 5, 10, 15, 20]) 10","solution":"def max_pill_weight(n, W, weights): Determine the maximum weight of the pill that does not exceed the specified limit. Args: n (int): number of different types of ingredients W (int): maximum weight of the pill weights (list of int): list of ingredient weights Returns: int: maximum possible weight of the pill dp = [0] * (W + 1) for weight in weights: for j in range(weight, W + 1): dp[j] = max(dp[j], dp[j - weight] + weight) return dp[W]"},{"question":"def min_moves(R: int, C: int, grid: List[str]) -> int: Determine the minimum number of moves required for the robot to reach the bottom-right corner of the grid. >>> min_moves(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves(3, 3, [\\"..#\\", \\".#.\\", \\"#..\\"]) -1 >>> min_moves(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 4 >>> min_moves(1, 1, [\\".\\"]) 0 >>> min_moves(1, 1, [\\"#\\"]) -1 >>> min_moves(2, 2, [\\".#\\", \\"#.\\"]) -1 >>> grid = [\\".\\"*1000 for _ in range(1000)] >>> min_moves(1000, 1000, grid) 1998 >>> grid = [\\".\\"*1000 for _ in range(999)] + [\\".\\"*999 + \\"#\\"] >>> min_moves(1000, 1000, grid) -1","solution":"from collections import deque def min_moves(R, C, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == R-1 and c == C-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def shortest_paths(n: int, m: int, q: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the shortest path from a given starting warehouse to a given destination warehouse. Parameters: n (int): Number of warehouses m (int): Number of roads q (int): Number of queries roads (List[Tuple[int, int, int]]): List of directed roads between pairs of warehouses (u, v, w) queries (List[Tuple[int, int]]): List of queries for which to find shortest paths (s, t) Returns: List[int]: The minimum time required to travel for each query, or -1 if no path exists. Examples: >>> shortest_paths(5, 6, 2, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (1, 5, 50), (2, 5, 20)], [(1, 4), (2, 5)]) [30, 20] >>> shortest_paths(4, 2, 2, [(1, 2, 10), (3, 4, 15)], [(1, 3), (2, 4)]) [-1, -1] pass import pytest def test_sample_input(): n = 5 m = 6 q = 2 roads = [ (1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (1, 5, 50), (2, 5, 20) ] queries = [ (1, 4), (2, 5) ] expected = [30, 20] assert shortest_paths(n, m, q, roads, queries) == expected def test_no_path(): n = 4 m = 2 q = 2 roads = [ (1, 2, 10), (3, 4, 15) ] queries = [ (1, 3), (2, 4) ] expected = [-1, -1] assert shortest_paths(n, m, q, roads, queries) == expected def test_multiple_paths(): n = 5 m = 6 q = 1 roads = [ (1, 2, 10), (2, 3, 10), (3, 4, 10), (2, 4, 25), (4, 5, 5), (1, 5, 50) ] queries = [ (1, 5) ] expected = [35] assert shortest_paths(n, m, q, roads, queries) == expected def test_single_road(): n = 2 m = 1 q = 1 roads = [ (1, 2, 5) ] queries = [ (1, 2) ] expected = [5] assert shortest_paths(n, m, q, roads, queries) == expected","solution":"import heapq def dijkstra(n, adj, start, end): pq = [(0, start)] dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 visited = set() while pq: current_dist, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) if current_node == end: return current_dist for neighbor, weight in adj[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 def shortest_paths(n, m, q, roads, queries): adj = {i: [] for i in range(1, n + 1)} for u, v, w in roads: adj[u].append((v, w)) results = [] for s, t in queries: results.append(dijkstra(n, adj, s, t)) return results"},{"question":"class MessagePriorityQueue: def __init__(self): Initialize your data structure here. pass def insert(self, priority: int, message: str) -> None: Insert a message with a given priority into the priority queue. pass def retrieve(self) -> str: Retrieve the highest-priority message from the priority queue. If there are multiple messages with the same highest priority, retrieve the one that was inserted first among them. pass def process_operations(operations: List[str]) -> List[str]: Process a list of operations on the priority queue. The operations can be \\"INSERT priority message\\" or \\"RETRIEVE\\". Returns a list of results for each \\"RETRIEVE\\" operation. >>> process_operations([\\"INSERT 5 hello\\", \\"RETRIEVE\\"]) [\\"hello\\"] >>> process_operations([ \\"INSERT 5 hello\\", \\"INSERT 3 world\\", \\"INSERT 4 example\\", \\"RETRIEVE\\", \\"RETRIEVE\\", \\"RETRIEVE\\" ]) [\\"hello\\", \\"example\\", \\"world\\"] >>> process_operations([ \\"INSERT 5 hello\\", \\"INSERT 5 world\\", \\"RETRIEVE\\", \\"RETRIEVE\\" ]) [\\"hello\\", \\"world\\"] >>> process_operations([ \\"INSERT 5 hello\\", \\"RETRIEVE\\", \\"RETRIEVE\\" ]) [\\"hello\\", None] >>> process_operations([ \\"INSERT 2 hello\\", \\"INSERT 1 world\\", \\"RETRIEVE\\", \\"INSERT 3 example\\", \\"INSERT 3 python\\", \\"RETRIEVE\\", \\"RETRIEVE\\" ]) [\\"hello\\", \\"example\\", \\"python\\"] >>> process_operations([\\"INSERT 5 msg1\\"] * 50000 + [\\"RETRIEVE\\"] * 50000) [\\"msg1\\"] * 50000 pass","solution":"import heapq class MessagePriorityQueue: def __init__(self): self.heap = [] self.counter = 0 # to handle messages with the same priority def insert(self, priority, message): # Python's heapq is a min-heap by default # so we invert the priority to use it as a max-heap heapq.heappush(self.heap, (-priority, self.counter, message)) self.counter += 1 def retrieve(self): if self.heap: return heapq.heappop(self.heap)[2] return None def process_operations(operations): pq = MessagePriorityQueue() result = [] for operation in operations: op_parts = operation.split() if op_parts[0] == \\"INSERT\\": priority = int(op_parts[1]) message = op_parts[2] pq.insert(priority, message) elif op_parts[0] == \\"RETRIEVE\\": result.append(pq.retrieve()) return result"},{"question":"def inventory_check(N: int, M: int, warehouse: List[int], items: List[int]) -> str: Determines if all items in the list can be found as a contiguous subsequence in the warehouse bins. :param N: int - number of bins in the warehouse. :param M: int - number of items in the list to be checked. :param warehouse: List[int] - inventory items in each bin. :param items: List[int] - items to check. :return: str - \\"All items found\\" if the items can be found as a contiguous subsequence, otherwise \\"Check inventory\\". >>> inventory_check(10, 3, [5, 8, 12, 14, 7, 20, 15, 9, 6, 11], [14, 7, 20]) \\"All items found\\" >>> inventory_check(7, 4, [3, 6, 2, 8, 1, 9, 4], [6, 2, 9, 4]) \\"Check inventory\\" from typing import List def test_all_items_found(): N = 10 M = 3 warehouse = [5, 8, 12, 14, 7, 20, 15, 9, 6, 11] items = [14, 7, 20] assert inventory_check(N, M, warehouse, items) == \\"All items found\\" def test_check_inventory(): N = 7 M = 4 warehouse = [3, 6, 2, 8, 1, 9, 4] items = [6, 2, 9, 4] assert inventory_check(N, M, warehouse, items) == \\"Check inventory\\" def test_items_at_the_start(): N = 6 M = 2 warehouse = [1, 2, 3, 4, 5, 6] items = [1, 2] assert inventory_check(N, M, warehouse, items) == \\"All items found\\" def test_items_at_the_end(): N = 6 M = 3 warehouse = [11, 21, 31, 41, 51, 61] items = [41, 51, 61] assert inventory_check(N, M, warehouse, items) == \\"All items found\\" def test_single_item(): N = 5 M = 1 warehouse = [7, 8, 9, 10, 11] items = [10] assert inventory_check(N, M, warehouse, items) == \\"All items found\\" def test_items_interleaved(): N = 8 M = 3 warehouse = [4, 9, 3, 8, 3, 2, 1, 5] items = [3, 8, 3] assert inventory_check(N, M, warehouse, items) == \\"All items found\\"","solution":"def inventory_check(N, M, warehouse, items): Determines if all items in the list can be found as a contiguous subsequence in the warehouse bins. :param N: int - number of bins in the warehouse. :param M: int - number of items in the list to be checked. :param warehouse: List[int] - inventory items in each bin. :param items: List[int] - items to check. :return: str - \\"All items found\\" if the items can be found as a contiguous subsequence, otherwise \\"Check inventory\\". # Convert lists to strings to use substring search warehouse_str = ' '.join(map(str, warehouse)) items_str = ' '.join(map(str, items)) if items_str in warehouse_str: return \\"All items found\\" else: return \\"Check inventory\\""},{"question":"def sum_divisible_by_3_or_5(n): Returns the sum of all integers up to n (inclusive) that are divisible by either 3 or 5. >>> sum_divisible_by_3_or_5(10) 33 >>> sum_divisible_by_3_or_5(0) 0 >>> sum_divisible_by_3_or_5(3) 3 >>> sum_divisible_by_3_or_5(5) 8 >>> sum_divisible_by_3_or_5(15) 60 >>> sum_divisible_by_3_or_5(20) 98 >>> sum_divisible_by_3_or_5(1) 0","solution":"def sum_divisible_by_3_or_5(n): Returns the sum of all integers up to n (inclusive) that are divisible by either 3 or 5. return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)"},{"question":"def is_astro_tree(n: int, values: List[int], edges: List[Tuple[int, int]]) -> str: Determine if a given tree is an Astro Tree. An Astro Tree has the property that the value of each node is equal to the sum of the values of all its direct and indirect child nodes, plus the number of direct child nodes it has. Args: n: Number of nodes in the tree. values: List of integers representing the values of each node in the tree. edges: List of tuples where each tuple (u, v) represents an edge between nodes u and v. Returns: \\"YES\\" if the given tree is an Astro Tree, \\"NO\\" otherwise. Examples: >>> is_astro_tree(5, [9, 4, 4, 3, 0], [(1, 2), (1, 3), (2, 4), (2, 5)]) \\"NO\\" >>> is_astro_tree(3, [5, 3, 1], [(1, 2), (2, 3)]) \\"NO\\"","solution":"def is_astro_tree(n, values, edges): from collections import defaultdict, deque import sys input = sys.stdin.read sys.setrecursionlimit(200000) tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) value_of = {i + 1: values[i] for i in range(n)} def dfs(node, parent): total_sum, total_children = 0, 0 for child in tree[node]: if child == parent: continue child_sum, num_children = dfs(child, node) total_sum += child_sum + num_children total_children += num_children total_children += len(tree[node]) - (0 if parent == -1 else 1) if value_of[node] != total_sum + total_children: return -1, -1 return total_sum, total_children root = 1 total_sum, total_children = dfs(root, -1) if total_sum == -1 and total_children == -1: return \\"NO\\" return \\"YES\\""},{"question":"def categorize_trees(n: int, fruit_types: List[str]) -> Tuple[List[int], List[int]]: Categorizes tree identifiers based on the type of fruit (delicious or sour). Parameters: n (int): The number of trees. fruit_types (list): A list of strings where each string is either \\"delicious\\" or \\"sour\\". Returns: tuple: Two lists, first containing identifiers of delicious trees and second containing identifiers of sour trees. >>> categorize_trees(6, [\\"delicious\\", \\"sour\\", \\"delicious\\", \\"sour\\", \\"delicious\\", \\"sour\\"]) ([1, 3, 5], [2, 4, 6]) >>> categorize_trees(3, [\\"delicious\\", \\"delicious\\", \\"delicious\\"]) ([1, 2, 3], []) >>> categorize_trees(3, [\\"sour\\", \\"sour\\", \\"sour\\"]) ([], [1, 2, 3]) from solution import categorize_trees def test_categorize_trees_all_delicious(): delicious, sour = categorize_trees(3, [\\"delicious\\", \\"delicious\\", \\"delicious\\"]) assert delicious == [1, 2, 3] assert sour == [] def test_categorize_trees_all_sour(): delicious, sour = categorize_trees(3, [\\"sour\\", \\"sour\\", \\"sour\\"]) assert delicious == [] assert sour == [1, 2, 3] def test_categorize_trees_mixed(): delicious, sour = categorize_trees(4, [\\"delicious\\", \\"sour\\", \\"delicious\\", \\"sour\\"]) assert delicious == [1, 3] assert sour == [2, 4] def test_categorize_trees_single_delicious(): delicious, sour = categorize_trees(1, [\\"delicious\\"]) assert delicious == [1] assert sour == [] def test_categorize_trees_single_sour(): delicious, sour = categorize_trees(1, [\\"sour\\"]) assert delicious == [] assert sour == [1] def test_categorize_trees_alternating(): delicious, sour = categorize_trees(6, [\\"delicious\\", \\"sour\\", \\"delicious\\", \\"sour\\", \\"delicious\\", \\"sour\\"]) assert delicious == [1, 3, 5] assert sour == [2, 4, 6]","solution":"def categorize_trees(n, fruit_types): This function categorizes tree identifiers based on the type of fruit (delicious or sour). Parameters: n (int): The number of trees. fruit_types (list): A list of strings where each string is either \\"delicious\\" or \\"sour\\". Returns: tuple: Two lists, first containing identifiers of delicious trees and second containing identifiers of sour trees. delicious_trees = [] sour_trees = [] for i in range(1, n + 1): if fruit_types[i - 1] == \\"delicious\\": delicious_trees.append(i) else: sour_trees.append(i) return delicious_trees, sour_trees"},{"question":"def is_prime(num): Check if a number is prime. Args: num (int): The number to check. Returns: bool: True if the number is prime, False otherwise. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i <= num): if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_split_into_three_prime_sums(n, lst): Determine if the list can be split into exactly three contiguous subarrays with prime sums. Args: n (int): The number of integers in the list. lst (List[int]): The list of integers. Returns: str: \\"YES\\" if the list can be split into three subarrays with prime sums, \\"NO\\" otherwise. >>> can_split_into_three_prime_sums(8, [2, 4, 5, 1, 2, 7, 3, 6]) \\"NO\\" >>> can_split_into_three_prime_sums(5, [1, 1, 1, 1, 1]) \\"NO\\"","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i <= num): if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_split_into_three_prime_sums(n, lst): pre_sum = [0] * (n + 1) for i in range(1, n + 1): pre_sum[i] = pre_sum[i - 1] + lst[i - 1] for i in range(1, n - 1): for j in range(i + 1, n): sum1 = pre_sum[i] sum2 = pre_sum[j] - pre_sum[i] sum3 = pre_sum[n] - pre_sum[j] if is_prime(sum1) and is_prime(sum2) and is_prime(sum3): return \\"YES\\" return \\"NO\\" # Example Usage: # n = 8 # lst = [2, 4, 5, 1, 2, 7, 3, 6] # print(can_split_into_three_prime_sums(n, lst)) # Output: NO"},{"question":"from typing import List def findCombinations(n: int) -> List[List[int]]: Aditi loves solving puzzles, and one day she came across a unique number puzzle. She was given an integer \`n\` and was asked to find all unique combinations of numbers that add up to \`n\`, using positive integers from 1 to \`n\` (inclusive). Each number can only be used once in each combination. Each combination should be sorted in ascending order, and the unique combinations themselves should also be sorted in ascending order based on the first number of each combination. >>> findCombinations(4) [[1, 3], [4]] >>> findCombinations(5) [[1, 4], [2, 3], [5]] >>> findCombinations(7) [[1, 2, 4], [1, 6], [2, 5], [3, 4], [7]] >>> findCombinations(1) [[1]] >>> findCombinations(20) [[...] (other possible combinations that sum up to 20)]","solution":"from typing import List def findCombinations(n: int) -> List[List[int]]: def backtrack(start: int, target: int, path: List[int]): if target == 0: result.append(path) return for i in range(start, n + 1): if i > target: break backtrack(i + 1, target - i, path + [i]) result = [] backtrack(1, n, []) return result"},{"question":"def is_subsequence(s: str, t: str) -> str: Determine if t is a subsequence of s. Returns \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\". >>> is_subsequence(\\"coding\\", \\"cdg\\") 'YES' >>> is_subsequence(\\"hello\\", \\"world\\") 'NO' >>> is_subsequence(\\"abcde\\", \\"ace\\") 'YES' pass def process_queries(queries: List[Tuple[str, str]]) -> List[str]: Process multiple queries to determine if in each query t is a subsequence of s. >>> process_queries([(\\"coding\\", \\"cdg\\"), (\\"hello\\", \\"world\\"), (\\"abcde\\", \\"ace\\")]) ['YES', 'NO', 'YES'] pass","solution":"def is_subsequence(s, t): Returns \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\". t_index = 0 for char in s: if t_index < len(t) and char == t[t_index]: t_index += 1 return \\"YES\\" if t_index == len(t) else \\"NO\\" def process_queries(queries): results = [] for s, t in queries: results.append(is_subsequence(s, t)) return results"},{"question":"def translate_brainfuck(code: str) -> str: Translates a simplified Brainfuck script into a human-readable format. >>> translate_brainfuck('++') == \\"Increment current cellnIncrement current celln\\" >>> translate_brainfuck('>-<') == \\"Move pointer to next cellnDecrement current cellnMove pointer to previous celln\\" >>> translate_brainfuck('[-]') == \\"Jump to matching ] if current cell is 0nDecrement current cellnJump back to matching [ if current cell is not 0n\\" >>> translate_brainfuck('...') == \\"Output current cell valuenOutput current cell valuenOutput current cell valuen\\" >>> translate_brainfuck('++>--.<') == \\"Increment current cellnIncrement current cellnMove pointer to next cellnDecrement current cellnDecrement current cellnOutput current cell valuenMove pointer to previous celln\\" >>> translate_brainfuck('') == \\"\\" >>> code = \\"++[--->++<]>.\\" >>> expected_output = ( \\"Increment current cellnIncrement current celln\\" \\"Jump to matching ] if current cell is 0nDecrement current cellnDecrement current cellnDecrement current celln\\" \\"Move pointer to next cellnIncrement current cellnIncrement current cellnMove pointer to previous cellnJump back to matching [ if current cell is not 0n\\" \\"Move pointer to next cellnOutput current cell valuen\\" ) >>> translate_brainfuck(code) == expected_output","solution":"def translate_brainfuck(code): Translates a simplified Brainfuck script into a human-readable format. translation_map = { '+': \\"Increment current celln\\", '-': \\"Decrement current celln\\", '>': \\"Move pointer to next celln\\", '<': \\"Move pointer to previous celln\\", '[': \\"Jump to matching ] if current cell is 0n\\", ']': \\"Jump back to matching [ if current cell is not 0n\\", '.': \\"Output current cell valuen\\" } translated_output = [] for char in code: if char in translation_map: translated_output.append(translation_map[char]) return ''.join(translated_output)"},{"question":"from typing import List, Tuple def max_unique_crops(N: int, M: int, connections: List[Tuple[int, int]], crops: List[int]) -> int: Determine the maximum possible number of unique crops he can gather in any single group of connected fields. >>> max_unique_crops(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [1, 2, 3, 4, 5, 6]) 6 >>> max_unique_crops(7, 6, [(1, 2), (2, 3), (1, 4), (4, 5), (5, 6), (6, 7)], [1, 2, 3, 1, 4, 5, 6]) 6","solution":"from collections import defaultdict, deque def max_unique_crops(N, M, connections, crops): # Build adjacency list representation of the graph graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) # Function to perform a BFS and return the set of unique crops in the component def bfs(field): unique_crops = set() queue = deque([field]) visited.add(field) while queue: current = queue.popleft() unique_crops.add(crops[current - 1]) for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return unique_crops visited = set() max_unique = 0 # Traverse all fields to find all connected components for field in range(1, N + 1): if field not in visited: unique_crops_in_component = bfs(field) max_unique = max(max_unique, len(unique_crops_in_component)) return max_unique"},{"question":"def find_promising_animals(animal_data): Returns the list of animal IDs that are both friendly and playful, sorted in ascending order. Parameters: animal_data (list of tuples): Each tuple contains an animal ID (int), 'friendly' (bool), and 'playful' (bool). Returns: List[int]: Sorted list of animal IDs that are both friendly and playful. Examples: >>> find_promising_animals([(101, True, False), (102, True, True), (103, False, True), (104, True, True)]) [102, 104] >>> find_promising_animals([(101, False, False), (102, False, True), (103, True, False), (104, False, False)]) []","solution":"def find_promising_animals(animal_data): Returns the list of animal IDs that are both friendly and playful, sorted in ascending order. Parameters: animal_data (list of tuples): Each tuple contains an animal ID (int), 'friendly' (bool), and 'playful' (bool). Returns: List[int]: Sorted list of animal IDs that are both friendly and playful. promising_animals = [animal_id for animal_id, friendly, playful in animal_data if friendly and playful] return sorted(promising_animals)"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum profit from buying and selling stocks at most once. :param prices: List of stock prices :return: Maximum profit obtained from one transaction. Returns 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Calculates the maximum profit from buying and selling stocks at most once. :param prices: List of stock prices :return: Maximum profit obtained from one transaction. Returns 0 if no profit is possible. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_tower_height(n: int, A: List[int]) -> int: Returns the maximum height of the tower that can be built with restrictions. >>> max_tower_height(6, [1, 2, 2, 3, 3, 4]) == 2 >>> max_tower_height(4, [4, 4, 4, 4]) == 4 >>> max_tower_height(3, [2, 9, 2]) == 2 >>> max_tower_height(5, [5, 1, 5, 1, 5]) == 3 >>> max_tower_height(2, [100, 100]) == 2 pass def solve(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solves multiple test cases of the max_tower_height problem. >>> t = 5 >>> test_cases = [ ... (6, [1, 2, 2, 3, 3, 4]), ... (4, [4, 4, 4, 4]), ... (3, [2, 9, 2]), ... (5, [5, 1, 5, 1, 5]), ... (2, [100, 100]) ... ] >>> solve(t, test_cases) == [2, 4, 2, 3, 2] pass","solution":"def max_tower_height(n, A): Returns the maximum height of the tower that can be built with restrictions. from collections import Counter # Count the frequency of each cube side length counter = Counter(A) # The maximum height of the tower heights = counter.values() # The maximum height of the tower is the maximum of the counts of unique side lengths return max(heights) def solve(t, test_cases): results = [] for case in test_cases: n, A = case results.append(max_tower_height(n, A)) return results"},{"question":"def final_coordinates(sequence: str, S: int) -> Tuple[int, int]: Given a sequence of movements and a number of total steps S, returns the final coordinates (x, y) after completing all the steps. >>> final_coordinates(\\"UDLR\\", 4) (0, 0) >>> final_coordinates(\\"UD\\", 5) (0, 1) >>> final_coordinates(\\"L\\", 3) (-3, 0) pass def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[Tuple[int, int]]: Processes a list of test cases, where each test case is a tuple of (sequence, steps). Returns a list of final coordinates for each test case. >>> test_cases = [(\\"UDLR\\", 4), (\\"UD\\", 5), (\\"L\\", 3)] >>> process_test_cases(test_cases) [(0, 0), (0, 1), (-3, 0)] pass def test_final_coordinates(): assert final_coordinates(\\"UDLR\\", 4) == (0, 0) assert final_coordinates(\\"UD\\", 5) == (0, 1) assert final_coordinates(\\"L\\", 3) == (-3, 0) assert final_coordinates(\\"R\\", 6) == (6, 0) assert final_coordinates(\\"UURD\\", 10) == (2, 4) assert final_coordinates(\\"RLUD\\", 8) == (0, 0) assert final_coordinates(\\"U\\", 1_000_000) == (0, 1_000_000) assert final_coordinates(\\"D\\", 2) == (0, -2) def test_process_test_cases(): test_cases = [(\\"UDLR\\", 4), (\\"UD\\", 5), (\\"L\\", 3)] expected_results = [(0, 0), (0, 1), (-3, 0)] assert process_test_cases(test_cases) == expected_results if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def final_coordinates(sequence, S): Given a sequence of movements and a number of total steps S, returns the final coordinates (x, y) after completing all the steps. # Movement mappings moves = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)} # Calculate the change for one full sequence x_change, y_change = 0, 0 for move in sequence: dx, dy = moves[move] x_change += dx y_change += dy # Determine the number of complete sequences and remaining steps full_sequences = S // len(sequence) remaining_steps = S % len(sequence) # Calculate final position from complete sequences final_x = full_sequences * x_change final_y = full_sequences * y_change # Add remaining movements for i in range(remaining_steps): move = sequence[i] dx, dy = moves[move] final_x += dx final_y += dy return final_x, final_y def process_test_cases(test_cases): results = [] for sequence, steps in test_cases: results.append(final_coordinates(sequence, steps)) return results"},{"question":"def balanced_groups(t, cases): Jasmine wants to divide her friends into study groups based on their skill levels in a way that the skill level of each group is as balanced as possible. Given the number of friends and their skill levels, the task is to divide them into exactly two groups such that the maximum balance of the two groups is minimized. Args: t (int): The number of test cases. cases (list of tuple): A list of tuples where each tuple contains an integer n and a list of n integers representing skill levels. Returns: list: A list of integers where each integer represents the minimum possible maximum balance for each test case. >>> balanced_groups(2, [(4, [1, 2, 3, 4]), (6, [4, 7, 2, 9, 1, 5])]) [1, 1] >>> balanced_groups(1, [(5, [10, 20, 30, 40, 50])]) [10] >>> balanced_groups(1, [(3, [5, 5, 5])]) [0] >>> balanced_groups(1, [(2, [1, 1000000000])]) [999999999] >>> balanced_groups(3, [(2, [10, 20]), (3, [30, 15, 10]), (4, [25, 20, 15, 10])]) [10, 5, 5]","solution":"def balanced_groups(t, cases): results = [] for i in range(t): n = cases[i][0] skills = sorted(cases[i][1]) min_diff = float('inf') for j in range(1, n): min_diff = min(min_diff, skills[j] - skills[j - 1]) results.append(min_diff) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swapPairs(head: ListNode) -> ListNode: Swaps every two adjacent nodes in the given linked list and returns the head of the modified linked list. >>> head = create_linked_list([1, 2, 3, 4]) >>> swapped_head = swapPairs(head) >>> linked_list_to_list(swapped_head) [2, 1, 4, 3] >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> swapped_head = swapPairs(head) >>> linked_list_to_list(swapped_head) [2, 1, 4, 3, 5] >>> head = create_linked_list([1]) >>> swapped_head = swapPairs(head) >>> linked_list_to_list(swapped_head) [1] >>> head = create_linked_list([]) >>> swapped_head = swapPairs(head) >>> linked_list_to_list(swapped_head) [] >>> head = create_linked_list([1, 2]) >>> swapped_head = swapPairs(head) >>> linked_list_to_list(swapped_head) [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swapPairs(head: ListNode) -> ListNode: if not head or not head.next: return head new_head = head.next prev = None current = head while current and current.next: next_pair = current.next.next second = current.next second.next = current current.next = next_pair if prev: prev.next = second prev = current current = next_pair return new_head # Helper function to create a linked list from a list. def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list to a list. def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result"},{"question":"def text_manipulator(commands): You are working on a text manipulator program that can process text for word replacement and removal based on given commands. The text starts as an empty string and the program supports the following commands: 1. \\"add word\\" where word is a string: Adds word to the current text separated by a single space. 2. \\"replace old_word new_word\\": Replaces all occurrences of old_word with new_word in the text. 3. \\"remove word\\": Removes all occurrences of word from the text. Note: - A \\"word\\" is defined as a sequence of non-space characters. - The list of commands is provided in a specific order and must be executed sequentially. >>> text_manipulator([\\"add hello\\", \\"add world\\", \\"replace world universe\\"]) \\"hello universe\\" >>> text_manipulator([\\"add programming\\", \\"add is\\", \\"add fun\\", \\"remove is\\"]) \\"programming fun\\" def process_input(input_data): Process the input data to execute text manipulation commands. >>> input_data = \\"2n3nadd hellonadd worldnreplace world universen4nadd programmingnadd isnadd funnremove is\\" >>> process_input(input_data) \\"hello universenprogramming fun\\" def test_text_manipulator(): input_data = 2 3 add hello add world replace world universe 4 add programming add is add fun remove is output = process_input(input_data) assert output == \\"hello universenprogramming fun\\" def test_text_manipulator_remove_all(): input_data = 1 3 add a add b remove a output = process_input(input_data) assert output == \\"b\\" def test_text_manipulator_replace_all(): input_data = 1 3 add a add a replace a b output = process_input(input_data) assert output == \\"b b\\" def test_text_manipulator_add_only(): input_data = 1 2 add x add y output = process_input(input_data) assert output == \\"x y\\" def test_text_manipulator_complex_commands(): input_data = 1 5 add start add middle add end replace middle center remove start output = process_input(input_data) assert output == \\"center end\\"","solution":"def text_manipulator(commands): text = [] for command in commands: parts = command.split() action = parts[0] if action == \\"add\\": word = parts[1] text.append(word) elif action == \\"replace\\": old_word = parts[1] new_word = parts[2] text = [new_word if w == old_word else w for w in text] elif action == \\"remove\\": word = parts[1] text = [w for w in text if w != word] return ' '.join(text) def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) output = [] index = 1 for _ in range(T): N = int(input_lines[index]) commands = input_lines[index + 1:index + 1 + N] result = text_manipulator(commands) output.append(result) index += N + 1 return 'n'.join(output)"},{"question":"def fourSum(arr, X): Given an array of integers and an integer X, finds all unique quadruplets in the array which sum up to X. Each quadruplet should be sorted in ascending order and the list of all quadruplets should also be sorted lexicographically. Example 1: >>> fourSum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] Example 2: >>> fourSum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] Constraints: - 1<=Number of elements in the array<=100 - -10^9<=Elements of array<=10^9 def test_case_1(): arr = [1, 0, -1, 0, -2, 2] X = 0 result = fourSum(arr, X) expected = [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] assert result == expected def test_case_2(): arr = [2, 2, 2, 2, 2] X = 8 result = fourSum(arr, X) expected = [[2, 2, 2, 2]] assert result == expected def test_case_3(): arr = [1, 1, 1, 1, 1, 1, 1] X = 4 result = fourSum(arr, X) expected = [[1, 1, 1, 1]] assert result == expected def test_case_4(): arr = [-3, -1, 0, 2, 4, 5] X = 2 result = fourSum(arr, X) expected = [[-3, -1, 2, 4]] assert result == expected def test_case_5(): arr = [1, 2, 3, 4, 5, 6, 7, 8] X = 26 result = fourSum(arr, X) expected = [[5, 6, 7, 8]] assert result == expected def test_case_6(): arr = [0, 0, 0, 0, 0, 0] X = 0 result = fourSum(arr, X) expected = [[0, 0, 0, 0]] assert result == expected","solution":"def fourSum(arr, X): arr.sort() n = len(arr) quadruplets = [] for i in range(n - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == X: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < X: left += 1 else: right -= 1 return quadruplets"},{"question":"def find_min_diff_pair(n: int, arr: list) -> tuple: Find two integers i and j such that 1 <= i < j <= n and a[i-1] <= a[j-1]. If there are multiple solutions, choose the one with the smallest difference j - i. If there are still multiple solutions, choose the pair with the smallest i. If no such pair exists, return -1. Parameters: n : int The length of the array arr : list of int The array of integers Returns: tuple A tuple containing the 1-based indices i and j, or -1 if no such pair exists. Examples: >>> find_min_diff_pair(5, [1, 3, 2, 4, 5]) (1, 2) >>> find_min_diff_pair(4, [4, 3, 2, 1]) -1 >>> find_min_diff_pair(6, [8, 1, 4, 3, 2, 5]) (2, 3)","solution":"def find_min_diff_pair(n, arr): Find two integers i and j such that 1 <= i < j <= n and a[i-1] <= a[j-1]. If there are multiple solutions, choose the one with the smallest difference j - i. If there are still multiple solutions, choose the pair with the smallest i. Parameters: n : int The length of the array arr : list of int The array of integers Returns: tuple of int A tuple containing the 1-based indices i and j, or -1 if no such pair exists. min_index = 0 result = (-1, -1) for j in range(1, n): if arr[min_index] <= arr[j]: result = (min_index + 1, j + 1) break if arr[j] < arr[min_index]: min_index = j if result == (-1, -1): return -1 return result"},{"question":"def sum_of_digits(n: int) -> int: Compute the sum of the digits of the integer n. >>> sum_of_digits(123) 6 >>> sum_of_digits(0) 0 >>> sum_of_digits(2021) 5 >>> sum_of_digits(1000000) 1 >>> sum_of_digits(987654) 39 def f(n: int) -> int: Compute the value of f(n) where f(n) = n + sum_of_digits(n) >>> f(123) 129 >>> f(0) 0 # should not realistically occur due to constraints, adding for completeness >>> f(2021) 2026 >>> f(1) 2 >>> f(555555) 555585 >>> f(1000000) 1000001 >>> f(987654) 987693","solution":"def sum_of_digits(n): Returns the sum of the digits of the integer n. return sum(int(digit) for digit in str(n)) def f(n): Returns the sum of the digits of n combined with the value of n minus the sum of its digits. f(n) = n + g(n) return n + sum_of_digits(n)"},{"question":"def check_palindromic_numbers(numbers: List[str]) -> List[str]: For each number in numbers, check if it is palindromic in both decimal and binary representations. Args: numbers (list of str): List of strings where each string is a decimal number. Returns: list of str: List of \\"Yes\\" or \\"No\\" for each corresponding input number. Example: >>> check_palindromic_numbers(['585', '5', '21', '65', '217']) ['Yes', 'Yes', 'No', 'No', 'No']","solution":"def is_palindromic(s): Helper function to check if a string s is palindromic. return s == s[::-1] def check_palindromic_numbers(numbers): For each number in numbers, check if it is palindromic in both decimal and binary representations. Args: numbers (list of str): List of strings where each string is a decimal number. Returns: list of str: List of \\"Yes\\" or \\"No\\" for each corresponding input number. results = [] for num in numbers: decimal_str = num binary_str = bin(int(num))[2:] if is_palindromic(decimal_str) and is_palindromic(binary_str): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List def is_mountain_array(arr: List[int]) -> bool: Check if the given array is a mountain array. >>> is_mountain_array([2, 1]) == False >>> is_mountain_array([1, 2, 3, 4, 5]) == False >>> is_mountain_array([0, 3, 2, 1, 0]) == True >>> is_mountain_array([1, 2, 2, 1]) == False >>> is_mountain_array([1, 3, 2]) == True def process_datasets(datasets: List[List[int]]) -> List[bool]: Process a list of datasets to determine if they are mountain arrays. >>> process_datasets([[2, 1], [1, 2, 3, 4, 5], [0, 3, 2, 1, 0], [1, 2, 2, 1], [-1]]) == [False, False, True, False] from typing import List def test_is_mountain_array(): assert is_mountain_array([2, 1]) == False assert is_mountain_array([1, 2, 3, 4, 5]) == False assert is_mountain_array([0, 3, 2, 1, 0]) == True assert is_mountain_array([1, 2, 2, 1]) == False assert is_mountain_array([1, 3, 2]) == True assert is_mountain_array([1, 2, 3, 4, 3, 2, 1]) == True assert is_mountain_array([1, 2, 3, 3, 2, 1]) == False assert is_mountain_array([1, 2, 3, 2, 2]) == False def test_process_datasets(): datasets = [ [2, 1], [1, 2, 3, 4, 5], [0, 3, 2, 1, 0], [1, 2, 2, 1], [-1] ] expected_results = [ False, False, True, False ] result = process_datasets(datasets) assert result == expected_results","solution":"def is_mountain_array(arr): Checks if the given array is a mountain array. n = len(arr) # A mountain array must have at least 3 elements if n < 3: return False # Find the peak of the mountain peak_index = -1 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: peak_index = i break # If there is no peak found if peak_index == -1: return False # Check the increasing part before the peak for i in range(1, peak_index): if arr[i - 1] >= arr[i]: return False # Check the decreasing part after the peak for i in range(peak_index + 1, n): if arr[i - 1] <= arr[i]: return False return True def process_datasets(datasets): results = [] for dataset in datasets: if dataset == [-1]: continue results.append(is_mountain_array(dataset)) return results"},{"question":"def decode_message(k: int, s: str) -> str: Decodes the string s by shifting each character k places back in the alphabet. >>> decode_message(3, \\"def\\") \\"abc\\" >>> decode_message(2, \\"hijk\\") \\"fghi\\" >>> decode_message(5, \\"mnop\\") \\"hijk\\" >>> decode_message(1, \\"a\\") \\"z\\" >>> decode_message(1, \\"z\\") \\"y\\" def decode_messages(test_cases: List[Tuple[int, str]]) -> List[str]: Takes a list of test cases and returns a list of decoded strings. Each test case is a tuple (k, s) where k is the shift and s is the encoded string. >>> decode_messages([(3, \\"def\\"), (2, \\"hijk\\"), (5, \\"mnop\\")]) ['abc', 'fghi', 'hijk']","solution":"def decode_message(k, s): Decodes the string s by shifting each character k places back in the alphabet. decoded = [] for char in s: new_char = chr(((ord(char) - ord('a') - k) % 26) + ord('a')) decoded.append(new_char) return ''.join(decoded) def decode_messages(test_cases): Takes a list of test cases and returns a list of decoded strings. Each test case is a tuple (k, s) where k is the shift and s is the encoded string. results = [] for k, s in test_cases: results.append(decode_message(k, s)) return results"},{"question":"def has_arithmetic_subsequence(n, array, q, queries): Given an array of integers and several queries, each query asks whether a given subarray has a subsequence that forms an arithmetic progression with a given common difference. Args: n: int : the length of the array. array: List[int] : the elements of the array. q: int : the number of queries. queries: List[Tuple[int, int, int]] : each query contains three integers l, r, and d  the bounds of the subarray and the common difference. Returns: List[str] : For each query, return \\"Yes\\" if there exists a subsequence within the subarray from l to r (inclusive) that forms an arithmetic progression with difference d, and \\"No\\" otherwise. >>> has_arithmetic_subsequence(6, [1, 3, 5, 7, 9, 11], 2, [(1, 6, 2), (2, 5, 4)]) ['Yes', 'No'] >>> has_arithmetic_subsequence(5, [10, 20, 30, 40, 50], 3, [(1, 3, 10), (2, 4, -10), (1, 5, 0)]) ['Yes', 'No', 'No'] >>> has_arithmetic_subsequence(5, [1, 2, 3, 4, 5], 1, [(1, 1, 1)]) ['No'] >>> has_arithmetic_subsequence(6, [1, 2, 4, 7, 11, 16], 1, [(1, 6, 2)]) ['No'] >>> has_arithmetic_subsequence(6, [1, 1, 1, 1, 1, 1], 1, [(1, 6, 0)]) ['Yes']","solution":"def has_arithmetic_subsequence(n, array, q, queries): results = [] for l, r, d in queries: # Extract the subarray [l-1:r] (0-indexed in python) subarray = array[l-1:r] subarray.sort() if len(subarray) < 2: results.append(\\"No\\") continue found = False for start in range(len(subarray)): current_value = subarray[start] count = 1 for i in range(start + 1, len(subarray)): if subarray[i] - current_value == d * count: count += 1 if count >= 3: # We need at least 3 elements for a valid subsequence found = True break if found: break if found: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_upgrade_cost(t: int, building_data: list) -> list: Calculate the minimum amount of coins needed to upgrade each building to the maximum level. Parameters: t (int): Number of building types. building_data (list of lists): List containing sublists, each sublist contains k followed by k-1 costs. Returns: list of int: Minimum coins needed for each building type. >>> min_upgrade_cost(2, [[3, 10, 20], [4, 5, 10, 15]]) [30, 30] >>> min_upgrade_cost(1, [[2, 5000]]) [5000] >>> min_upgrade_cost(3, [[2, 100], [3, 10, 20], [4, 1, 2, 3]]) [100, 30, 6] >>> min_upgrade_cost(1, [[5, 10000, 10000, 10000, 10000]]) [40000] >>> min_upgrade_cost(1, [[2, 1]]) [1]","solution":"def min_upgrade_cost(t, building_data): Calculate the minimum amount of coins needed to upgrade each building to the maximum level. Parameters: t (int): Number of building types. building_data (list of lists): List containing sublists, each sublist contains k followed by k-1 costs. Returns: list of int: Minimum coins needed for each building type. results = [] for data in building_data: k = data[0] costs = data[1:] results.append(sum(costs)) return results"},{"question":"def process_list(n, elements): Process the list according to the problem statement. Append -1 if the length of the list is odd. Parameters: n (int): Length of the list elements (List[int]): List of integers Returns: List[int]: Processed list with -1 appended if length is odd. >>> process_list(3, [1, 2, 3]) [1, 2, 3, -1] >>> process_list(4, [4, 5, 6, 7]) [4, 5, 6, 7] pass","solution":"def process_list(n, elements): Process the list according to the problem statement. Append -1 if the length of the list is odd. Return the processed list. if n % 2 != 0: elements.append(-1) return elements"},{"question":"def sieve(max_num): Generate a list of booleans representing primality of numbers from 0 to max_num. # Implementation here pass def prime_product(l, r, primes, is_prime, MOD=10**9 + 7): Calculate the product of all prime numbers between l and r inclusive. Return -1 if there are no primes in this range. # Implementation here pass def process_test_cases(T, cases): Process multiple test cases to find the product of prime numbers in given ranges. # Implementation here pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) cases = [] index = 1 for _ in range(T): l = int(data[index]) r = int(data[index + 1]) cases.append((l, r)) index += 2 results = process_test_cases(T, cases) for result in results: print(result) # Unit tests if __name__ == \\"__main__\\": import pytest def test_sieve(): is_prime, primes = sieve(30) expected_primes_up_to_30 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert primes == expected_primes_up_to_30 assert is_prime[0] == False assert is_prime[1] == False assert is_prime[2] == True assert is_prime[4] == False assert is_prime[29] == True def test_prime_product(): max_num = 30 is_prime, primes = sieve(max_num) MOD = 10**9 + 7 # Test cases assert prime_product(1, 10, primes, is_prime, MOD) == 210 assert prime_product(10, 20, primes, is_prime, MOD) == 46189 assert prime_product(20, 30, primes, is_prime, MOD) == 667 assert prime_product(4, 4, primes, is_prime, MOD) == -1 # No prime between 4 and 4 def test_process_test_cases(): T = 3 cases = [(1, 10), (10, 20), (20, 30)] expected_results = [210, 46189, 667] assert process_test_cases(T, cases) == expected_results pytest.main()","solution":"def sieve(max_num): Generate a list of booleans representing primality of numbers from 0 to max_num. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for p in range(2, int(max_num**0.5) + 1): if is_prime[p]: for i in range(p * p, max_num + 1, p): is_prime[i] = False primes = [] for num in range(max_num + 1): if is_prime[num]: primes.append(num) return is_prime, primes def prime_product(l, r, primes, is_prime, MOD=10**9 + 7): Calculate the product of all prime numbers between l and r inclusive. Return -1 if there are no primes in this range. product = 1 found_prime = False for prime in primes: if l <= prime <= r: product = (product * prime) % MOD found_prime = True if prime > r: break return product if found_prime else -1 def process_test_cases(T, cases): max_num = 10**6 is_prime, primes = sieve(max_num) results = [] for l, r in cases: result = prime_product(l, r, primes, is_prime) results.append(result) return results"},{"question":"def max_subarray_sum(test_cases): Given a list of integers, find the contiguous subarray with the largest sum and output the sum of that subarray. >>> max_subarray_sum([(5, [1, -2, 3, 4, -5]), (4, [-1, -2, -3, -4]), (6, [2, -1, 2, 3, 4, -5])]) [7, -1, 10] pass def parse_input(input_text): Parse input to prepare test cases. >>> parse_input(\\"3n5n1 -2 3 4 -5n4n-1 -2 -3 -4n6n2 -1 2 3 4 -5n\\") [(5, [1, -2, 3, 4, -5]), (4, [-1, -2, -3, -4]), (6, [2, -1, 2, 3, 4, -5])] pass","solution":"def max_subarray_sum(test_cases): def kadane_algorithm(arr): max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global results = [] for n, arr in test_cases: results.append(kadane_algorithm(arr)) return results def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases"},{"question":"def longest_contiguous_ones_surrounded_by_zeros(s: str) -> int: Analyses a binary stream and finds the length of the longest contiguous subarray of 1s surrounded by 0s on both sides. >>> longest_contiguous_ones_surrounded_by_zeros(\\"0101010\\") 1 >>> longest_contiguous_ones_surrounded_by_zeros(\\"110111011\\") 3 >>> longest_contiguous_ones_surrounded_by_zeros(\\"0000000\\") 0 >>> longest_contiguous_ones_surrounded_by_zeros(\\"1111\\") 0 >>> longest_contiguous_ones_surrounded_by_zeros(\\"1010110101\\") 2 def solve(test_cases: List[str]) -> List[int]: Given a list of binary strings, returns a list of the lengths of the longest contiguous subarray of 1s surrounded by 0s for each string. Params: test_cases: List of binary strings. Return: List of integers representing the lengths of the longest contiguous subarray of 1s surrounded by 0s for each string. >>> solve([\\"0101010\\", \\"110111011\\", \\"0000000\\", \\"1111\\", \\"1010110101\\"]) [1, 3, 0, 0, 2]","solution":"def longest_contiguous_ones_surrounded_by_zeros(s): Returns the length of the longest contiguous subarray of 1s surrounded by 0s on both sides. max_len = 0 current_len = 0 in_subarray = False for char in s: if char == '1': if in_subarray: current_len += 1 else: # If we encounter 1 after a 0, start the subarray in_subarray = True current_len = 1 elif char == '0': if in_subarray: # If subarray ended, update max_len if current_len is greater if current_len > max_len: max_len = current_len in_subarray = False return max_len def solve(test_cases): results = [] for s in test_cases: longest_1s_len = longest_contiguous_ones_surrounded_by_zeros(s) results.append(longest_1s_len) return results"},{"question":"def frequency_sort(s: str) -> str: Group each character by its frequency in descending order. If two characters have the same frequency, they should appear in alphabetical order. >>> frequency_sort(\\"tree\\") in [\\"eert\\", \\"eetr\\"] True >>> frequency_sort(\\"cccaaa\\") in [\\"cccaaa\\", \\"aaaccc\\"] True >>> frequency_sort(\\"Aabb\\") == \\"bbAa\\" True >>> frequency_sort(\\"AaAa\\") in [\\"AAaa\\", \\"aaAA\\"] True >>> frequency_sort(\\"abcd\\") == 'abcd' True","solution":"def frequency_sort(s: str) -> str: from collections import Counter # Count the frequency of each character freq = Counter(s) # Sort the characters first alphabetically then by frequency in descending order sorted_characters = sorted(freq.keys(), key=lambda x: (-freq[x], x)) # Build the result string based on the sorted characters and their frequencies result = ''.join(char * freq[char] for char in sorted_characters) return result"},{"question":"def minimum_communication_cost(N: int, M: int, connections: List[List[int]]) -> int: Find the minimum communication cost to connect all computers in the network. The function takes the number of computers N, the number of connections M, and a list of connections. Each connection is represented by a list of three integers [u, v, w], where 'u' and 'v' are the connected computers and 'w' is the weight of the edge (communication cost between the computers). >>> minimum_communication_cost(4, 5, [[1, 2, 1], [1, 3, 4], [2, 3, 2], [3, 4, 3], [2, 4, 5]]) 6 >>> minimum_communication_cost(4, 0, []) -1 >>> minimum_communication_cost(1, 0, []) 0 >>> minimum_communication_cost(5, 3, [[1, 2, 1], [3, 4, 2], [4, 5, 3]]) -1 >>> minimum_communication_cost(3, 3, [[1, 2, 1], [2, 3, 2], [1, 3, 3]]) 3 >>> minimum_communication_cost(3, 3, [[1, 2, 10000], [2, 3, 10000], [1, 3, 20000]]) 20000 >>> minimum_communication_cost(2, 1, [[1, 2, 5]]) 5","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskalMST(N, edges): result = [] i = 0 e = 0 # Step 1: sort all edges in increasing order of their weight edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(N): parent.append(node) rank.append(0) while e < N - 1: if i >= len(edges): return -1 u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost def minimum_communication_cost(N, M, connections): if M == 0: return -1 if N > 1 else 0 edges = list(map(lambda conn: (conn[0], conn[1], conn[2]), connections)) return kruskalMST(N, edges)"},{"question":"def update_inventory(inventory, shipment): Updates the inventory with items from the shipment. Args: inventory (list of tuples): A list where each tuple contains an identifier and a quantity. shipment (list of tuples): A list where each tuple contains an identifier and a quantity. Returns: list of tuples: The updated inventory list. Example: >>> inventory = [(\\"apple\\", 10), (\\"banana\\", 5), (\\"orange\\", 7)] >>> shipment = [(\\"banana\\", 3), (\\"orange\\", 2), (\\"grapefruit\\", 4)] >>> update_inventory(inventory, shipment) [('apple', 10), ('banana', 8), ('orange', 9), ('grapefruit', 4)] >>> inventory = [(\\"item1\\", 100), (\\"item2\\", 200)] >>> shipment = [(\\"item3\\", 300), (\\"item4\\", 400)] >>> update_inventory(inventory, shipment) [('item1', 100), ('item2', 200), ('item3', 300), ('item4', 400)]","solution":"def update_inventory(inventory, shipment): Updates the inventory with items from the shipment. Args: inventory (list of tuples): A list where each tuple contains an identifier and a quantity. shipment (list of tuples): A list where each tuple contains an identifier and a quantity. Returns: list of tuples: The updated inventory list. # Convert inventory list to a dictionary for easier quantity updates inventory_dict = dict(inventory) # Update the inventory with the shipment for item_id, quantity in shipment: if item_id in inventory_dict: inventory_dict[item_id] += quantity else: inventory_dict[item_id] = quantity # Convert the dictionary back to a list of tuples updated_inventory = list(inventory_dict.items()) return updated_inventory"},{"question":"def can_form_non_decreasing_sequence(n: int, k: int, arr: List[int]) -> str: Determines if it is possible to select exactly k integers from the list of n integers to form a non-decreasing sequence. Parameters: n (int): Number of integers in the list. k (int): Required length of the non-decreasing sequence. arr (list of int): List of integers. Returns: str: \\"YES\\" if it's possible to form a non-decreasing sequence of length k, otherwise \\"NO\\". >>> can_form_non_decreasing_sequence(5, 3, [4, 3, 5, 6, 1]) \\"YES\\" >>> can_form_non_decreasing_sequence(4, 5, [2, 3, 3, 1]) \\"NO\\" >>> can_form_non_decreasing_sequence(1, 1, [1]) \\"YES\\" >>> can_form_non_decreasing_sequence(4, 2, [2, 2, 2, 2]) \\"YES\\" >>> can_form_non_decreasing_sequence(5, 3, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_form_non_decreasing_sequence(6, 3, [6, 5, 3, 2, 8, 7]) \\"YES\\" >>> can_form_non_decreasing_sequence(6, 4, [1000000000, 100000000, 10000000, 3, 2, 1]) \\"YES\\" >>> can_form_non_decreasing_sequence(5, 6, [4, 3, 5, 6, 1]) \\"NO\\"","solution":"def can_form_non_decreasing_sequence(n, k, arr): Determines if it is possible to select exactly k integers from the list of n integers to form a non-decreasing sequence. Parameters: n (int): Number of integers in the list. k (int): Required length of the non-decreasing sequence. arr (list of int): List of integers. Returns: str: \\"YES\\" if it's possible to form a non-decreasing sequence of length k, otherwise \\"NO\\". # Sort the array to check feasibility arr.sort() # If we can pick k elements from the sorted array, always it will be non-decreasing if len(arr) >= k: return \\"YES\\" else: return \\"NO\\""},{"question":"def isPalindromePermutation(s: str) -> bool: Determine whether any permutation of the characters in the string forms a palindrome. >>> isPalindromePermutation(\\"civic\\") True >>> isPalindromePermutation(\\"ivicc\\") True >>> isPalindromePermutation(\\"hello\\") False >>> isPalindromePermutation(\\"aabb\\") True","solution":"def isPalindromePermutation(s): from collections import Counter # Remove whitespace and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(s) # Check the count of characters with odd occurrences odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be a palindrome permutation, # no more than one character can have an odd count return odd_count <= 1"},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determine who will win the game given the sequence of integers. >>> determine_winner(3, [12, 15, 18]) 'Alice' >>> determine_winner(4, [6, 10, 15, 25]) 'Bob'","solution":"def gcd(a, b): while b: a, b = b, a % b return a def determine_winner(n, sequence): if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"from typing import List, Tuple def line_through_k_points(n: int, k: int, points: List[Tuple[int, int]]) -> bool: Determine if there exists a straight line that passes through at least K of the given points in a 2D plane. >>> line_through_k_points(5, 3, [(1, 1), (2, 2), (3, 3), (1, 2), (2, 3)]) True >>> line_through_k_points(5, 4, [(1, 1), (2, 2), (3, 3), (1, 2), (2, 3)]) False def test_line_through_k_points(): assert line_through_k_points(5, 3, [(1, 1), (2, 2), (3, 3), (1, 2), (2, 3)]) == True, \\"Test case 1 failed\\" assert line_through_k_points(5, 4, [(1, 1), (2, 2), (3, 3), (1, 2), (2, 3)]) == False, \\"Test case 2 failed\\" assert line_through_k_points(1, 1, [(0, 0)]) == True, \\"Test case 3 failed\\" assert line_through_k_points(2, 2, [(1, 1), (2, 2)]) == True, \\"Test case 4 failed\\" assert line_through_k_points(4, 2, [(1, 2), (2, 3), (3, 4), (5, 6)]) == True, \\"Test case 5 failed\\" assert line_through_k_points(6, 4, [(1, 1), (1, 2), (2, 2), (3, 3), (4, 4), (5, 5)]) == True, \\"Test case 6 failed\\" assert line_through_k_points(5, 5, [(1, 1), (0, 0), (2, 6), (-5, -2), (1, -4)]) == False, \\"Test case 7 failed\\" test_line_through_k_points()","solution":"from typing import List, Tuple from collections import defaultdict from math import gcd def line_through_k_points(n: int, k: int, points: List[Tuple[int, int]]) -> bool: def get_normalized_line(p1, p2): # Calculate A, B, C for line equation Ax + By = C x1, y1 = p1 x2, y2 = p2 A = y2 - y1 B = x1 - x2 C = A * x1 + B * y1 gcd_AB = gcd(A, B) gcd_ABC = gcd(gcd_AB, C) # Normalize by greatest common divisor to avoid different representations of the same line A //= gcd_ABC B //= gcd_ABC C //= gcd_ABC # Ensure normalization consistency if A < 0 or (A == 0 and B < 0): A *= -1 B *= -1 C *= -1 return (A, B, C) if k == 1: return True line_count = defaultdict(set) for i in range(n): for j in range(i + 1, n): line = get_normalized_line(points[i], points[j]) line_count[line].add(points[i]) line_count[line].add(points[j]) for line in line_count: if len(line_count[line]) >= k: return True return False"},{"question":"def maximize_decimal(N: int, M: int, binary_sequence: str) -> int: Returns the maximum possible decimal value of the binary sequence after performing up to M bit flips. :param N: Length of the binary sequence. :param M: Maximum number of bit flips allowed. :param binary_sequence: Binary sequence as a string. :return: Maximum possible decimal value of the binary sequence. >>> maximize_decimal(5, 1, \\"10101\\") 29 >>> maximize_decimal(4, 2, \\"0000\\") 12 >>> maximize_decimal(4, 2, \\"1111\\") 15 >>> maximize_decimal(4, 0, \\"1010\\") 10 >>> maximize_decimal(3, 3, \\"000\\") 7","solution":"def maximize_decimal(N, M, binary_sequence): Returns the maximum possible decimal value of the binary sequence after performing up to M bit flips. :param N: Length of the binary sequence. :param M: Maximum number of bit flips allowed. :param binary_sequence: Binary sequence as a string. :return: Maximum possible decimal value of the binary sequence. # Convert the binary sequence to a list for easy manipulation binary_list = list(binary_sequence) for i in range(N): # Stop flipping if M flips are used up if M <= 0: break # Flip '0' to '1' if encountered if binary_list[i] == '0': binary_list[i] = '1' M -= 1 # Convert the modified binary list back to a string max_binary_sequence = ''.join(binary_list) # Convert the binary string to decimal max_decimal_value = int(max_binary_sequence, 2) return max_decimal_value # Handling Input and Output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) binary_sequence = data[2] result = maximize_decimal(N, M, binary_sequence) print(result)"},{"question":"def num_islands(matrix): Given a binary matrix of size N x M, where 0 represents water and 1 represents land, find the number of islands in the matrix. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the matrix are surrounded by water. >>> num_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ]) == 3 >>> num_islands([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> num_islands([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> num_islands([ ... [1, 1], ... [1, 1] ... ]) == 1 >>> num_islands([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> num_islands([ ... [1, 1, 0, 0, 1], ... [0, 1, 1, 0, 1], ... [0, 0, 1, 0, 0], ... [1, 1, 0, 1, 1] ... ]) == 4","solution":"def num_islands(matrix): if not matrix: return 0 N = len(matrix) M = len(matrix[0]) def dfs(matrix, i, j): if i < 0 or j < 0 or i >= N or j >= M or matrix[i][j] == 0: return matrix[i][j] = 0 # Mark the land as visited # visit all 4 adjacent cells (up, down, left, right) dfs(matrix, i+1, j) dfs(matrix, i-1, j) dfs(matrix, i, j+1) dfs(matrix, i, j-1) island_count = 0 for i in range(N): for j in range(M): if matrix[i][j] == 1: island_count += 1 dfs(matrix, i, j) return island_count"},{"question":"def largest_square_submatrix_same_value(n: int, matrix: List[List[int]]) -> int: Find the side length of the largest square sub-matrix where all values are the same. >>> largest_square_submatrix_same_value(4, [[1, 1, 1, 2], [1, 1, 1, 2], [1, 1, 1, 2], [3, 3, 2, 2]]) == 3 >>> largest_square_submatrix_same_value(5, [[1, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == 4 >>> largest_square_submatrix_same_value(1, [[1]]) == 1 >>> largest_square_submatrix_same_value(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 1 >>> largest_square_submatrix_same_value(3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 3","solution":"def largest_square_submatrix_same_value(n, matrix): if n == 0: return 0 # Create a dp array to store the size of the largest square ending at each point dp = [[0] * n for _ in range(n)] max_side = 0 for i in range(n): for j in range(n): if i == 0 or j == 0: dp[i][j] = 1 # Edge elements are squares of size 1 by definition elif matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 # A single element submatrix max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def max_points(V, tasks): Compute the maximum points that can be earned by assigning each task to a unique volunteer. :param V: Number of volunteers :param tasks: List of integers representing points of each task :return: Maximum points that can be earned >>> max_points(3, [4, 5, 1, 3, 7, 2]) 16 >>> max_points(1, [7]) 7 >>> max_points(3, [5, 5, 5, 5, 5]) 15 >>> max_points(5, [4, 2, 3]) 9 >>> max_points(0, [1, 2, 3, 4]) 0 >>> max_points(2, [9, 5, 7, 6]) 16 >>> max_points(3, [0, 0, 0, 0]) 0","solution":"def max_points(V, tasks): Compute the maximum points that can be earned by assigning each task to a unique volunteer. :param V: Number of volunteers :param tasks: List of integers representing points of each task :return: Maximum points that can be earned # Sort the tasks in descending order to get the tasks with the highest points first tasks_sorted = sorted(tasks, reverse=True) # Select the top V tasks top_tasks = tasks_sorted[:V] # Compute the sum of the top V tasks return sum(top_tasks)"},{"question":"def point_in_circle(Xc, Yc, R, Xp, Yp): Determines whether a point (Xp, Yp) is inside, outside, or on the boundary of a circle defined by its center (Xc, Yc) and radius R. >>> point_in_circle(0, 0, 5, 3, 4) 'on the boundary' >>> point_in_circle(0, 0, 5, 6, 8) 'outside' >>> point_in_circle(0, 0, 5, 2, 2) 'inside'","solution":"def point_in_circle(Xc, Yc, R, Xp, Yp): Determines whether a point (Xp, Yp) is inside, outside, or on the boundary of a circle defined by its center (Xc, Yc) and radius R. distance_squared = (Xp - Xc) ** 2 + (Yp - Yc) ** 2 radius_squared = R ** 2 if distance_squared < radius_squared: return \\"inside\\" elif distance_squared == radius_squared: return \\"on the boundary\\" else: return \\"outside\\" # Example usage (uncomment to run in a script environment) # Xc, Yc, R, Xp, Yp = map(int, input().split()) # print(point_in_circle(Xc, Yc, R, Xp, Yp))"},{"question":"def mizuha_rank(N: int, times: List[int], T: int) -> int: Determines the rank of Mizuha based on her recorded time. Parameters: N (int): The number of challenge participants. times (list of int): A list of recorded times by each participant. T (int): The recorded time of Mizuha. Returns: int: The rank of Mizuha. Examples: >>> mizuha_rank(5, [300, 450, 200, 400, 350], 400) 4 >>> mizuha_rank(3, [1500, 1200, 900], 1300) 3","solution":"def mizuha_rank(N, times, T): Determines the rank of Mizuha based on her recorded time. Parameters: N (int): The number of challenge participants. times (list of int): A list of recorded times by each participant. T (int): The recorded time of Mizuha. Returns: int: The rank of Mizuha. # Include Mizuha's recorded time in the list times.append(T) # Sort the list in ascending order times.sort() # Rank is the 1-based index of Mizuha's time return times.index(T) + 1"},{"question":"def is_dictionary_consistent(translations): Determine if the dictionary of translations is consistent. >>> is_dictionary_consistent([(\\"hello\\", \\"bonjour\\"), (\\"world\\", \\"monde\\"), (\\"hello\\", \\"bonjour\\")]) 'CONSISTENT' >>> is_dictionary_consistent([(\\"hello\\", \\"bonjour\\"), (\\"world\\", \\"monde\\"), (\\"hello\\", \\"hola\\")]) 'INCONSISTENT' >>> is_dictionary_consistent([(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"a\\", \\"b\\")]) 'CONSISTENT' >>> is_dictionary_consistent([(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"a\\", \\"d\\")]) 'INCONSISTENT' >>> is_dictionary_consistent([]) 'CONSISTENT' >>> is_dictionary_consistent([(\\"similar\\", \\"translation\\"), (\\"similar\\", \\"translation\\")]) 'CONSISTENT' >>> is_dictionary_consistent([(\\"same\\", \\"word\\"), (\\"same\\", \\"words\\")]) 'INCONSISTENT' >>> is_dictionary_consistent([(\\"one\\", \\"eins\\"), (\\"one\\", \\"uno\\"), (\\"two\\", \\"zwei\\")]) 'INCONSISTENT' # Write your code here","solution":"def is_dictionary_consistent(translations): translation_map = {} for original, translated in translations: if original in translation_map: if translation_map[original] != translated: return \\"INCONSISTENT\\" else: translation_map[original] = translated return \\"CONSISTENT\\""},{"question":"def special_sort(arr: List[int]) -> List[int]: Sorts the array using a special technique: alternates between appending the smallest and largest remaining elements to the result list. Args: arr: List[int] - list of integers to sort. Returns: List[int] - specially sorted list. Examples: >>> special_sort([1, 3, 7, 2, 5]) [1, 7, 2, 5, 3] >>> special_sort([4, 6, 2, 9]) [2, 9, 4, 6]","solution":"def special_sort(arr): Sorts the array using the special technique as described: alternates between appending the smallest and largest remaining elements to the result list. Args: arr: List[int] - list of integers to sort. Returns: List[int] - specially sorted list. result = [] arr.sort() # Sort the original array while arr: # Append the smallest element result.append(arr.pop(0)) if arr: # Append the largest element result.append(arr.pop(-1)) return result"},{"question":"def minimum_additional_roads(n: int, m: int, k: int, existing_roads: List[Tuple[int, int]], pivotal_pairs: List[Tuple[int, int]]) -> int: Determine the minimum number of additional roads to be constructed to make the kingdom connected while ensuring all pivotal pairs have direct roads. Args: n: int - number of cities m: int - number of existing roads k: int - number of pivotal pairs existing_roads: List[Tuple[int, int]] - list of existing roads (each road connects two cities) pivotal_pairs: List[Tuple[int, int]] - list of pivotal pairs (each pair of cities must have a direct road) Returns: int - minimum number of additional roads required >>> minimum_additional_roads(6, 5, 2, [(1, 2), (1, 3), (2, 3), (4, 5), (5, 6)], [(1, 4), (3, 6)]) 2 >>> minimum_additional_roads(4, 6, 2, [(1, 2), (2, 3), (3, 4), (1, 3), (2, 4), (1, 4)], [(1, 2), (3, 4)]) 0","solution":"def minimum_additional_roads(n, m, k, existing_roads, pivotal_pairs): from collections import defaultdict, deque def bfs(start, graph, visited): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in existing_roads: graph[u].append(v) graph[v].append(u) # Ensure all pivotal pairs have a direct road pivotal_required_roads = set() for a, b in pivotal_pairs: if b not in graph[a]: pivotal_required_roads.add(frozenset([a, b])) # Temporarily add all required roads for pivotal pairs for road in pivotal_required_roads: u, v = list(road) graph[u].append(v) graph[v].append(u) # Find number of connected components in the graph with pivotal roads added visited = [False] * (n + 1) connected_components = 0 for city in range(1, n + 1): if not visited[city]: connected_components += 1 visited[city] = True bfs(city, graph, visited) required_additional_roads = len(pivotal_required_roads) + (connected_components - 1) return required_additional_roads"},{"question":"def is_back_to_origin(s: str) -> str: Determine if the sequence of moves brings you back to the origin (0, 0). >>> is_back_to_origin(\\"LLRR\\") \\"Yes\\" >>> is_back_to_origin(\\"UDDLLRUU\\") \\"No\\" >>> is_back_to_origin(\\"UDLR\\") \\"Yes\\"","solution":"def is_back_to_origin(s): Determine if the sequence of moves brings you back to the origin (0, 0). x, y = 0, 0 for move in s: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return \\"Yes\\" if (x == 0 and y == 0) else \\"No\\""},{"question":"from math import comb def count_distinct_bib_numbers(k: int) -> int: Returns the number of distinct bib numbers of length k that can be formed using digits 1 through 9 in strictly increasing order. >>> count_distinct_bib_numbers(1) 9 >>> count_distinct_bib_numbers(2) 36 >>> count_distinct_bib_numbers(3) 84 >>> count_distinct_bib_numbers(4) 126 >>> count_distinct_bib_numbers(5) 126 >>> count_distinct_bib_numbers(6) 84 >>> count_distinct_bib_numbers(7) 36 >>> count_distinct_bib_numbers(8) 9 >>> count_distinct_bib_numbers(9) 1","solution":"from math import comb def count_distinct_bib_numbers(k): Returns the number of distinct bib numbers of length k that can be formed using digits 1 through 9 in strictly increasing order. # Utilize combinatorial calculations (n choose k) where n = 9 (digits 1 to 9) return comb(9, k)"},{"question":"def min_machines_required(tasks): Determines the minimum number of machines required to execute all tasks without overlap. Parameters: tasks (list of tuples): A list of tuples where each tuple contains the start and end times of tasks. Returns: int: The minimum number of machines required. Examples: >>> min_machines_required([(1, 4), (2, 6), (8, 9), (3, 5), (5, 9)]) 3 >>> min_machines_required([(1, 2), (3, 4), (5, 6)]) 1","solution":"def min_machines_required(tasks): Determines the minimum number of machines required to execute all tasks without overlap. Parameters: tasks (list of tuples): A list of tuples where each tuple contains the start and end times of tasks. Returns: int: The minimum number of machines required. events = [] for (start, end) in tasks: events.append((start, 'start')) events.append((end, 'end')) events.sort() max_machines = current_machines = 0 for event in events: if event[1] == 'start': current_machines += 1 max_machines = max(max_machines, current_machines) else: current_machines -= 1 return max_machines"},{"question":"from typing import List def smallest_greater_numbers(S: List[int], T: List[int]) -> List[int]: Given two sets of integers S and T, determine for each number in T, its smallest greater number present in S. If no such number exists, return -1. Args: S : List[int] : List of integers representing set S T : List[int] : List of integers representing set T Returns: List[int] : List of integers where for each number in T, corresponding smallest greater number in S or -1 if no such number exists >>> smallest_greater_numbers([10, 20, 30, 40, 50], [5, 25, 60]) [10, 30, -1] >>> smallest_greater_numbers([10, 20, 30], [40, 50, 60]) [-1, -1, -1] >>> smallest_greater_numbers([10, 20, 30], [5, 10, 15]) [10, 20, 20] pass","solution":"def smallest_greater_numbers(S, T): For each number in T, find its smallest greater number in S. If no such number exists, return -1. S = sorted(S) results = [] def find_smallest_greater(x): left, right = 0, len(S) while left < right: mid = (left + right) // 2 if S[mid] <= x: left = mid + 1 else: right = mid return S[left] if left < len(S) else -1 for t in T: results.append(find_smallest_greater(t)) return results"},{"question":"def arrayProduct(arr: List[int]) -> List[int]: Given an array of integers, return a new array where each element is the product of all the integers in the original array except for the element at that index. >>> arrayProduct([1, 2, 3, 4]) == [24, 12, 8, 6] >>> arrayProduct([5, 6, 7]) == [42, 35, 30] >>> arrayProduct([2, 4, 6, 8, 10]) == [1920, 960, 640, 480, 384]","solution":"def arrayProduct(arr): Returns a new array where each element is the product of all the integers in the original array except for the element at that index. n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate result for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def find_pairs(arr, k): Finds and prints all unique pairs of elements in the array that sum up to k. Input The input consists of an array and an integer k: - arr: List of n distinct integers where (1  n  10^5) and each element is between 0 and 10^9. - k: integer (0  k  10^9) Output Prints each pair in a new line in the format (element1, element2). Each pair should be printed in ascending order of the first element, if the first elements are the same then in ascending order of the second element. Examples -------- >>> find_pairs([1, 2, 3, 4, 5], 7) (2, 5) (3, 4) >>> find_pairs([1, 9, 5, 8], 10) (1, 9) (2, 8) >>> find_pairs([1, 2, 3], 6) >>> find_pairs([1, 1, 2, 2, 3, 4], 5) (1, 4) (2, 3) >>> find_pairs([1000000000, 999999999, 1, 2, 3], 1000000001) (1, 1000000000) (2, 999999999)","solution":"def find_pairs(arr, k): Finds and prints all unique pairs of elements in the array that sum up to k. arr = sorted(arr) pairs = set() seen = set() for number in arr: complement = k - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) for pair in sorted(pairs): print(pair)"},{"question":"def minRoadsToRemove(n, edges): Given a network of cities represented as an undirected graph with distinct lengths for each road, find the minimum number of roads to be removed to eliminate cycles, turning the graph into a tree. Args: n (int): the number of cities (nodes) edges (List[Tuple[int, int, int]]): a list of edges, each represented by a tuple of two integers (the cities it connects) and the length of the road between them Returns: int: the minimum number of roads that need to be removed Examples: >>> minRoadsToRemove(5, [(1, 2, 6), (1, 3, 2), (2, 4, 5), (2, 5, 7), (3, 4, 3), (3, 5, 4)]) 2 >>> minRoadsToRemove(6, [(1, 2, 1), (1, 3, 2), (2, 4, 3), (3, 4, 4), (3, 5, 5), (5, 6, 6)]) 1","solution":"def minRoadsToRemove(n, edges): Given a number of cities as nodes and edges with weights, return the minimum number of roads to be removed to eliminate cycles in the graph, making it a tree. # Sort the edges based on their weights in descending order edges.sort(key=lambda x: x[2], reverse=True) parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False remove_count = 0 for x, y, _ in edges: if not union(x - 1, y - 1): # Union fails means there's a cycle remove_count += 1 return remove_count"},{"question":"from typing import List, Tuple def findTreasureZone(N: int, M: int, T: List[int], Pair: List[Tuple[int, int]]) -> int: Rahul is playing a game in which he has to move between multiple zones in a park. The park has N zones connected by M bidirectional paths, where ith path connects zone Pair[i][0] and Pair[i][1]. There are some special zones which contain treasures, and their numbers are given in an array T. Rahul always starts from zone 1 and tries to reach a zone with treasure. If he reaches a treasure zone, he collects the treasure and stops moving. The function should return the zone number where Rahul collects the treasure. Assume Rahul moves in a breadth-first manner, visiting each zone level by level. >>> findTreasureZone(5, 4, [3], [(1, 2), (2, 3), (2, 4), (4, 5)]) 3 >>> findTreasureZone(6, 5, [5, 6], [(1, 2), (1, 3), (2, 4), (3, 5), (4, 6)]) 5 >>> findTreasureZone(7, 6, [4], [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6), (6, 7)]) 4","solution":"from collections import deque def findTreasureZone(N: int, M: int, T: list, Pair: list) -> int: # Create a graph (adjacency list) graph = {i: [] for i in range(1, N + 1)} for u, v in Pair: graph[u].append(v) graph[v].append(u) # Breadth-first search (BFS) queue = deque([1]) visited = set() visited.add(1) while queue: current = queue.popleft() # Check if current zone has treasure if current in T: return current # Traverse connected zones for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor)"},{"question":"def calculate_scores(contestants: int, questions: List[Tuple[int, str]]) -> List[Tuple[int, int]]: Calculate the scores for each contestant and return the leaderboard. Parameters: contestants (int): The number of contestants. questions (list of tuples): Each tuple contains an integer ci and a string ri. Returns: list of tuples: Each tuple contains an integer and an integer, the contestant number and their score. >>> calculate_scores(3, [(1, \\"correct\\"), (2, \\"incorrect\\"), (3, \\"correct\\"), (1, \\"incorrect\\"), (2, \\"correct\\")]) [(3, 10), (1, 5), (2, 5)] >>> calculate_scores(4, [(1, \\"correct\\"), (2, \\"correct\\"), (3, \\"correct\\"), (4, \\"correct\\"), (1, \\"correct\\"), (2, \\"correct\\"), (3, \\"incorrect\\"), (4, \\"incorrect\\")]) [(1, 20), (2, 20), (3, 5), (4, 5)]","solution":"def calculate_scores(contestants, questions): Calculate the scores for each contestant and return the leaderboard. Parameters: contestants (int): The number of contestants. questions (list of tuples): Each tuple contains an integer ci and a string ri. Returns: list of tuples: Each tuple contains an integer and an integer, the contestant number and their score. scores = [0] * (contestants + 1) for ci, ri in questions: if ri == \\"correct\\": scores[ci] += 10 elif ri == \\"incorrect\\": scores[ci] -= 5 leaderboard = [(i, scores[i]) for i in range(1, contestants + 1)] leaderboard.sort(key=lambda x: (-x[1], x[0])) return leaderboard"},{"question":"def longest_consecutive_subsequence(nums): Given a list of integers, determine the length of the longest consecutive subsequence. A consecutive subsequence is a sequence in which the elements can be arranged to form a sequence of consecutive integers with each of these integers appearing exactly once. >>> longest_consecutive_subsequence([1, 9, 3, 10, 2, 20, 4, 11, 21, 30]) 4 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence([10, 20, 30, 40]) 1 >>> longest_consecutive_subsequence([5, 6, -1, -2, 7, -3, -4, -5]) 5 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([100]) 1 >>> longest_consecutive_subsequence([1, 2, 2, 3]) 3","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive subsequence in the list nums. if not nums: return 0 nums = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def word_search(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[str]], str]]) -> List[str]: Given a 2-dimensional grid of characters, identify if there exists a word in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once in a single word. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int], List[List[str]], str]): A list of tuples representing test cases. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> word_search(2, [((3, 4), [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], 'ABCCED'), ((3, 4), [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], 'ABCB')]) ['YES', 'NO'] >>> word_search(1, [((2, 2), [['A', 'B'], ['C', 'D']], 'ABCD')]) ['YES']","solution":"def exist(board, word): rows, cols = len(board), len(board[0]) def dfs(index, x, y): if index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != word[index]: return False # Mark the cell as visited by temporarily changing the character temp = board[x][y] board[x][y] = '#' found = (dfs(index + 1, x + 1, y) or dfs(index + 1, x - 1, y) or dfs(index + 1, x, y + 1) or dfs(index + 1, x, y - 1) or dfs(index + 1, x + 1, y + 1) or dfs(index + 1, x + 1, y - 1) or dfs(index + 1, x - 1, y + 1) or dfs(index + 1, x - 1, y - 1)) # Restore the cell character after searching board[x][y] = temp return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and dfs(0, i, j): return 'YES' return 'NO' def word_search(T, test_cases): results = [] for t in range(T): N, M = test_cases[t][0] board = test_cases[t][1] word = test_cases[t][2] results.append(exist(board, word)) return results"},{"question":"def can_organize_secret_santa(N: int, friend_ids: List[int]) -> str: Determine if it is possible to organize a Secret Santa such that each friend gifts exactly one other friend and every friend receives exactly one gift. >>> can_organize_secret_santa(4, [2, 3, 4, 1]) \\"Yes\\" >>> can_organize_secret_santa(5, [2, 3, 4, 5, 3]) \\"No\\"","solution":"def can_organize_secret_santa(N, friend_ids): if len(friend_ids) != N: return \\"No\\" received = [0] * N for friend in friend_ids: if friend < 1 or friend > N: return \\"No\\" received[friend - 1] += 1 for count in received: if count != 1: return \\"No\\" return \\"Yes\\" # Sample usage sample_input1 = (4, [2, 3, 4, 1]) print(can_organize_secret_santa(*sample_input1)) # Output should be \\"Yes\\" sample_input2 = (5, [2, 3, 4, 5, 3]) print(can_organize_secret_santa(*sample_input2)) # Output should be \\"No\\""},{"question":"def find_transfer_time(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the data transfer time between servers based on the given network structure. Args: n (int): Number of servers in the network. edges (List[Tuple[int, int, int]]): List of connections between servers with their transfer times. queries (List[Tuple[int, int]]): List of queries asking for transfer times between two servers. Returns: List[int]: Transfer times for each query. Example: >>> find_transfer_time(5, [(1, 2, 5), (1, 3, 3), (2, 4, 4), (2, 5, 8)], [(3, 4), (4, 5), (1, 5)]) [12, 12, 13] >>> find_transfer_time(1, [], [(1, 1)]) [0] >>> find_transfer_time(2, [(1, 2, 7)], [(1, 2), (2, 1)]) [7, 7] pass","solution":"def find_transfer_time(n, edges, queries): from collections import defaultdict, deque def bfs_levels_and_parents(): distance = [0] * (n + 1) levels = [-1] * (n + 1) parents = [0] * (n + 1) queue = deque([1]) levels[1] = 0 parents[1] = -1 while queue: node = queue.popleft() current_level = levels[node] for neighbor, weight in graph[node]: if levels[neighbor] == -1: levels[neighbor] = current_level + 1 parents[neighbor] = node distance[neighbor] = distance[node] + weight queue.append(neighbor) return distance, levels, parents def find_lca(a, b): while levels[a] > levels[b]: a = parents[a] while levels[b] > levels[a]: b = parents[b] while a != b: a = parents[a] b = parents[b] return a graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) distance, levels, parents = bfs_levels_and_parents() results = [] for a, b in queries: lca = find_lca(a, b) results.append(distance[a] + distance[b] - 2 * distance[lca]) return results"},{"question":"from typing import List, Tuple def min_changes_to_root_tree(N: int, edges: List[Tuple[int, int]]) -> int: Returns the minimum number of changes needed to ensure the tree remains rooted at node 1. Parameters: N (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): A list of tuples where each tuple represents an edge between two nodes in the tree. Returns: int: The minimum number of changes needed to root the tree at node 1. >>> min_changes_to_root_tree(4, [(1, 2), (1, 3), (3, 4)]) 1 >>> min_changes_to_root_tree(3, [(1, 2), (1, 3)]) 0 >>> min_changes_to_root_tree(4, [(2, 3), (3, 4), (4, 5)]) 3 >>> min_changes_to_root_tree(5, [(1, 2), (2, 3), (3, 4), (1, 5)]) 2 >>> min_changes_to_root_tree(1, []) 0","solution":"def min_changes_to_root_tree(N, edges): Returns the minimum number of changes needed to ensure the tree remains rooted at node 1. changes = 0 for parent, child in edges: if parent != 1: changes += 1 return changes"},{"question":"from typing import List def overlapping_intervals(intervals: List[List[int]]) -> bool: Check if any given time intervals overlap with each other. Args: intervals (list of list of int): A list of intervals where each interval is represented by [start_time, end_time]. Returns: bool: True if any intervals overlap, False otherwise. Examples: >>> overlapping_intervals([[1, 5], [6, 10], [4, 8]]) True >>> overlapping_intervals([[1, 2], [3, 4], [5, 6]]) False >>> overlapping_intervals([[1, 2], [2, 3], [3, 4]]) False >>> overlapping_intervals([[1, 2]]) False >>> overlapping_intervals([[1, 10], [2, 3], [3, 4], [5, 6], [6, 7]]) True >>> overlapping_intervals([[0, 1000000], [1000001, 2000000]]) False >>> overlapping_intervals([[0, 1], [1, 2], [2, 3], [3, 1000001], [0, 2]]) True","solution":"def overlapping_intervals(intervals): Check if any given time intervals overlap with each other. Args: intervals (list of list of int): A list of intervals where each interval is represented by [start_time, end_time]. Returns: bool: True if any intervals overlap, False otherwise. # Sort the intervals by the start time intervals.sort() # Check for overlapping intervals for i in range(1, len(intervals)): # If the start time of the current interval is less than the end time of the previous interval, they overlap if intervals[i][0] < intervals[i-1][1]: return True return False"},{"question":"def min_moves(T, test_cases): Determine the minimum number of moves required to reach the exact score Y from the starting score Z, with each move adding or subtracting a fixed integer X. :param T: int, number of test cases :param test_cases: List[Tuple[int, int, int]], list of tuples containing (X, Y, Z) for each test case :return: List[int], list of results for each test case Example: >>> min_moves(3, [(3, 10, 1), (5, -3, 1), (2, 8, 1)]) [3, 1, 4] >>> min_moves(2, [(2, 0, 0), (1, 1000000000, 1000000000)]) [0, 0] from min_moves import min_moves def test_min_moves_samples(): assert min_moves(3, [(3, 10, 1), (5, -3, 1), (2, 8, 1)]) == [3, 1, 4] def test_min_moves_same_start_target(): assert min_moves(2, [(2, 0, 0), (1, 1000000000, 1000000000)]) == [0, 0] def test_min_moves_large_values(): assert min_moves(1, [(1000000000, 999999999, 0)]) == [1] assert min_moves(1, [(1, 1000000000, 0)]) == [1000000000] def test_min_moves_edge_cases(): assert min_moves(2, [(3, 9, 0), (4, -8, 0)]) == [3, 2] assert min_moves(2, [(6, 11, 1), (5, -10, 1)]) == [2, 3]","solution":"def min_moves(T, test_cases): results = [] for i in range(T): X, Y, Z = test_cases[i] distance = abs(Y - Z) moves = (distance + X - 1) // X # The +X-1 ensures we round up when necessary results.append(moves) return results"},{"question":"def max_product_subarray(nums): Returns the maximum product that can be obtained from a subarray of the array. >>> max_product_subarray([2, 3, -2, 4, -1]) 48 >>> max_product_subarray([-2, 0, -1]) 0","solution":"def max_product_subarray(nums): Returns the maximum product that can be obtained from a subarray of the array. if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result # Example execution n = 5 arr = [2, 3, -2, 4, -1] print(max_product_subarray(arr)) # Expected Output: 48"},{"question":"def count_vowels_and_consonants_output(s: str) -> str: Given a string S consisting of only lowercase alphabetic characters, determine the number of vowels and consonants present in the string. Vowels are 'a', 'e', 'i', 'o', and 'u'; all other alphabetic characters are consonants. Parameters: s (str): The input string to analyze. Returns: str: A single line with two space-separated integers, the first representing the number of vowels and the second representing the number of consonants in the string. Examples: >>> count_vowels_and_consonants_output(\\"hello\\") '2 3' >>> count_vowels_and_consonants_output(\\"programming\\") '3 8'","solution":"def count_vowels_and_consonants(s): Returns the count of vowels and consonants in the given string s. vowels = 'aeiou' n_vowels = sum(1 for char in s if char in vowels) n_consonants = sum(1 for char in s if char not in vowels) return n_vowels, n_consonants def count_vowels_and_consonants_output(s): Returns the count of vowels and consonants in the given string s as space separated integers. n_vowels, n_consonants = count_vowels_and_consonants(s) return f\\"{n_vowels} {n_consonants}\\""},{"question":"def battleship_count(grid: List[List[str]]) -> int: Count the number of ships in a Battleship game grid. A ship is a contiguous segment of '1's connected horizontally or vertically but not diagonally. >>> grid = [ [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ] >>> battleship_count(grid) 6","solution":"def battleship_count(grid): def sink_ship(r, c): Mark the entire ship starting from (r, c) # Use a stack for iterative DFS stack = [(r, c)] while stack: i, j = stack.pop() grid[i][j] = '0' # Mark the cell as visited # Explore all 4 directions (up, down, left, right) for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= ni < 10 and 0 <= nj < 10 and grid[ni][nj] == '1': stack.append((ni, nj)) ships = 0 for row in range(10): for col in range(10): if grid[row][col] == '1': # Found an unvisited part of a ship ships += 1 sink_ship(row, col) return ships"},{"question":"def letter_combinations(digits: str) -> List[str]: Write a function that takes a string containing digits from '2' to '9' inclusive, and returns all possible letter combinations that the number could represent. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letter_combinations(\\"9\\") [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] >>> letter_combinations(\\"\\") [] >>> combos = letter_combinations(\\"234\\") >>> len(combos) 27 >>> sorted(combos) ['adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi', 'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi', 'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi']","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent. if not digits: return [] digit_to_char = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_char[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def check_two_sum_exists(test_cases): Determines if there are two distinct indices in the array such that the elements at those indices add up to the target integer. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, where each tuple contains: - an integer n (size of the array) - an integer target (desired sum) - an array of integers Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case indicating whether two distinct indices exist such that their corresponding elements add up to the target integer. >>> check_two_sum_exists([(4, 9, [2, 7, 11, 15])]) [\\"YES\\"] >>> check_two_sum_exists([(5, 18, [3, 1, 4, 1, 5])]) [\\"NO\\"] >>> check_two_sum_exists([(3, 6, [3, 3, 3])]) [\\"YES\\"]","solution":"def check_two_sum_exists(test_cases): results = [] for case in test_cases: n, target, array = case seen = set() found = False for num in array: if target - num in seen: found = True break seen.add(num) results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def increment_subgrid(n: int, q: int, queries: List[Tuple[int, int, int, int]]) -> List[List[int]]: Increment the sub-grid elements by 1 according to the queries. Args: n (int): the size of the grid (n x n) q (int): the number of queries queries (List[Tuple[int, int, int, int]]): List of queries with each query containing four integers x1, y1, x2, y2 Returns: List[List[int]]: the final state of the grid after processing all queries Example: >>> increment_subgrid(4, 3, [(1, 1, 2, 2), (2, 2, 3, 3), (1, 3, 4, 4)]) [[1, 1, 1, 1], [1, 2, 2, 1], [0, 1, 2, 1], [0, 0, 1, 1]] >>> increment_subgrid(2, 1, [(1, 1, 2, 2)]) [[1, 1], [1, 1]] >>> increment_subgrid(3, 0, []) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> increment_subgrid(3, 1, [(1, 1, 3, 3)]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]]","solution":"def increment_subgrid(n, q, queries): grid = [[0] * n for _ in range(n)] for x1, y1, x2, y2 in queries: for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] += 1 return grid"},{"question":"from typing import List def min_cost_to_destination(n: int, grid: List[str]) -> int: Navigate from the top-left corner to the bottom-right corner with the minimum cost in a grid where some cells are blocked. Args: n (int): Size of the grid. grid (List[str]): List of strings representing the grid, where '.' is an open cell and '#' is a blocked cell. Returns: int: Minimum number of moves required to reach the destination, or -1 if it's impossible. Examples: >>> min_cost_to_destination(5, [\\".....\\", \\".#.\\", \\"....#\\", \\".#.\\", \\".....\\"]) 8 >>> min_cost_to_destination(3, [\\".#.\\", \\".#.\\", \\".#.\\"]) -1","solution":"from collections import deque def min_cost_to_destination(n, grid): if grid[0][0] == '#' or grid[n-1][n-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(n)] queue = deque([(0, 0, 0)]) visited[0][0] = True while queue: x, y, cost = queue.popleft() if x == n-1 and y == n-1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, cost + 1)) return -1"},{"question":"# Define the database of shipping rates for various destinations SHIPPING_RATES = { 'switzerland': 5.00, 'germany': 4.00, 'france': 4.50, 'italy': 6.00, 'spain': 5.50, 'portugal': 5.75, 'austria': 4.25 } # Define the base cost that applies to every shipment BASE_COST = 10.00 def calculate_shipping_cost(destination, weight): Calculate the shipping cost based on the given destination and weight. Args: destination (str): The destination country. weight (float): The weight of the package. Returns: float or str: The total shipping cost or an error message if invalid. >>> calculate_shipping_cost('germany', 2) # Output: 18.00 (base cost 10.00 + 4.00*2) >>> calculate_shipping_cost('france', 3.5) # Output: 25.75 (base cost 10.00 + 4.50*3.5) >>> calculate_shipping_cost('japan', 1) # Output: \\"Invalid destination\\" >>> calculate_shipping_cost('spain', -1) # Output: \\"Invalid weight\\"","solution":"# Define the database of shipping rates for various destinations SHIPPING_RATES = { 'switzerland': 5.00, 'germany': 4.00, 'france': 4.50, 'italy': 6.00, 'spain': 5.50, 'portugal': 5.75, 'austria': 4.25 } # Define the base cost that applies to every shipment BASE_COST = 10.00 def calculate_shipping_cost(destination, weight): Calculate the shipping cost based on the given destination and weight. Args: destination (str): The destination country. weight (float): The weight of the package. Returns: float or str: The total shipping cost or an error message if invalid. # Validate the destination if destination not in SHIPPING_RATES: return \\"Invalid destination\\" # Validate the weight if weight <= 0: return \\"Invalid weight\\" # Calculate the total cost rate_per_kg = SHIPPING_RATES[destination] total_cost = BASE_COST + (rate_per_kg * weight) return total_cost"},{"question":"def isDigitProductPrime(N: int) -> int: Given a positive integer N, determine if the product of its digits is a prime number. A prime number is a number that is greater than 1 and has no positive divisors other than 1 and itself. >>> isDigitProductPrime(23) 0 >>> isDigitProductPrime(37) 0 >>> isDigitProductPrime(25) 0","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def isDigitProductPrime(N): digits = [int(d) for d in str(N)] product = 1 for d in digits: product *= d return 1 if is_prime(product) else 0"},{"question":"def parse_input(input_string: str): Parse the input string and prepare test cases. >>> input_string = ''' ... 2 ... 5 ... 3 1 4 10 6 ... 1 2 ... 1 3 ... 3 4 ... 3 5 ... 3 ... 7 8 3 ... 1 2 ... 1 3''' >>> parse_input(input_string) [(5, [3, 1, 4, 10, 6], [(1, 2), (1, 3), (3, 4), (3, 5)]), (3, [7, 8, 3], [(1, 2), (1, 3)])] pass def max_difference_in_tree(test_cases: list) -> list: Given a list of test cases, determine the maximum difference between the values of any two nodes in each tree. >>> max_difference_in_tree([(5, [3, 1, 4, 10, 6], [(1, 2), (1, 3), (3, 4), (3, 5)]), (3, [7, 8, 3], [(1, 2), (1, 3)])]) [9, 5] pass def test_parse_input(): input_string = 2 5 3 1 4 10 6 1 2 1 3 3 4 3 5 3 7 8 3 1 2 1 3 expected_output = [ (5, [3, 1, 4, 10, 6], [(1, 2), (1, 3), (3, 4), (3, 5)]), (3, [7, 8, 3], [(1, 2), (1, 3)]) ] assert parse_input(input_string) == expected_output def test_max_difference_in_tree(): test_cases = [ (5, [3, 1, 4, 10, 6], [(1, 2), (1, 3), (3, 4), (3, 5)]), (3, [7, 8, 3], [(1, 2), (1, 3)]) ] expected_output = [9, 5] assert max_difference_in_tree(test_cases) == expected_output def test_single_node_tree(): test_cases = [ (1, [5], []) ] expected_output = [0] assert max_difference_in_tree(test_cases) == expected_output def test_identical_values(): test_cases = [ (4, [6, 6, 6, 6], [(1, 2), (2, 3), (3, 4)]), (3, [10, 10, 10], [(1, 2), (1, 3)]) ] expected_output = [0, 0] assert max_difference_in_tree(test_cases) == expected_output def test_large_values(): test_cases = [ (3, [1, 1_000_000_000, 100], [(1, 2), (2, 3)]) ] expected_output = [999_999_999] assert max_difference_in_tree(test_cases) == expected_output","solution":"def max_difference_in_tree(test_cases): results = [] for case in test_cases: N, node_values, edges = case max_val = max(node_values) min_val = min(node_values) # The maximum difference will always be between the maximum and minimum values max_diff = abs(max_val - min_val) results.append(max_diff) return results # Parse input and prepare test cases def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(input_lines[idx]) node_values = list(map(int, input_lines[idx + 1].split())) edges = [] for i in range(N - 1): edges.append(tuple(map(int, input_lines[idx + 2 + i].split()))) test_cases.append((N, node_values, edges)) idx += 1 + 1 + (N - 1) return test_cases # Example usage input_string = 2 5 3 1 4 10 6 1 2 1 3 3 4 3 5 3 7 8 3 1 2 1 3 test_cases = parse_input(input_string) results = max_difference_in_tree(test_cases) print(results) # Expected: [9, 5]"},{"question":"def has_more_ones_than_zeros(n, s): Determines if there exists a contiguous subsequence in a binary string that contains more '1's than '0's. Parameters: - n: The length of the binary string. - s: The binary string. Returns: - \\"YES\\" if such subsequence exists, otherwise \\"NO\\". Examples: >>> has_more_ones_than_zeros(5, \\"11001\\") \\"YES\\" >>> has_more_ones_than_zeros(4, \\"0000\\") \\"NO\\" >>> has_more_ones_than_zeros(3, \\"101\\") \\"YES\\" >>> has_more_ones_than_zeros(2, \\"00\\") \\"NO\\"","solution":"def has_more_ones_than_zeros(n, s): Determines if there exists a contiguous subsequence in a binary string that contains more '1's than '0's. Parameters: - n: The length of the binary string. - s: The binary string. Returns: - \\"YES\\" if such subsequence exists, otherwise \\"NO\\". count_ones = s.count('1') if count_ones > n // 2: return \\"YES\\" return \\"NO\\" # Example Usage: # n = 5 # s = \\"11001\\" # print(has_more_ones_than_zeros(n, s)) # Output: \\"YES\\" # n = 4 # s = \\"0000\\" # print(has_more_ones_than_zeros(n, s)) # Output: \\"NO\\""},{"question":"def largest_rectangle_area(histogram): This function takes a list of integers representing the heights of a histogram and returns the area of the largest rectangle that can be formed by consecutive boxes. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 5]) == 10 >>> largest_rectangle_area([3, 6, 5, 7, 4, 8]) == 20 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 # Your code here def solve_histogram_problem(t, test_cases): This function takes the number of test cases and a list of test cases, where each test case is a tuple containing the number of boxes and a list of heights of these boxes. It returns a list of integers representing the largest rectangular area for each test case. >>> solve_histogram_problem(3, [(7, [2, 1, 5, 6, 2, 3, 5]), (6, [3, 6, 5, 7, 4, 8]), (5, [6, 2, 5, 4, 5, 1, 6])]) == [10, 20, 12] # Your code here","solution":"def largest_rectangle_area(histogram): This function takes a list of integers representing the heights of a histogram and returns the area of the largest rectangle that can be formed by consecutive boxes. stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def solve_histogram_problem(t, test_cases): results = [] for n, heights in test_cases: results.append(largest_rectangle_area(heights)) return results"},{"question":"def min_operations(a: int, b: int) -> int: Returns the minimum number of operations required to transform a into b by multiplying by prime numbers, or -1 if it's impossible. >>> min_operations(5, 30) 2 >>> min_operations(7, 49) 1 >>> min_operations(10, 15) -1 def test_min_operations_examples(): assert min_operations(5, 30) == 2 assert min_operations(7, 49) == 1 assert min_operations(10, 15) == -1 def test_min_operations_prime_multiplier(): assert min_operations(2, 16) == 3 # 2 * 2 * 2 * 2 = 16 def test_min_operations_same_number(): assert min_operations(7, 7) == 0 def test_min_operations_large_numbers(): assert min_operations(1, 2**20) == 20 # 1 multiplied by 2 twenty times assert min_operations(3, 3**10) == 9 # 3 multiplied by 3 nine times def test_min_operations_invalid_ratio(): assert min_operations(8, 81) == -1 # 81 is not a multiple of 8","solution":"def min_operations(a: int, b: int) -> int: Returns the minimum number of operations required to transform a into b by multiplying by prime numbers, or -1 if it's impossible. def prime_factors(n): Returns the prime factors of n factors = {} d = 2 while d * d <= n: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 if n > 1: factors[n] = 1 return factors if b % a != 0: return -1 ratio = b // a a_factors = prime_factors(a) b_factors = prime_factors(b) operations = 0 for prime in b_factors: if prime in a_factors: if b_factors[prime] > a_factors[prime]: operations += b_factors[prime] - a_factors[prime] else: operations += b_factors[prime] return operations"},{"question":"def max_paintings_framed(m: int, n: int, paintings: List[Tuple[int, int]], frames: List[Tuple[int, int]]) -> int: Returns the maximum number of paintings that can be framed. Parameters: m (int): The number of paintings. n (int): The number of frames. paintings (list of tuples): The dimensions of each painting. frames (list of tuples): The dimensions of each frame. Returns: int: The maximum number of paintings that can be framed. >>> max_paintings_framed(3, 2, [(12, 11), (15, 10), (10, 10)], [(20, 20), (15, 10)]) 2 >>> max_paintings_framed(4, 4, [(8, 8), (9, 7), (10, 10), (5, 5)], [(9, 9), (11, 10), (7, 7), (10, 8)]) 3 >>> max_paintings_framed(2, 0, [(12, 11), (15, 10)], []) 0 >>> max_paintings_framed(1, 1, [(5, 5)], [(5, 5)]) 1 >>> max_paintings_framed(3, 3, [(5, 5), (3, 3), (7, 7)], [(5, 5), (7, 7), (9, 9)]) 3 >>> max_paintings_framed(1, 1, [(10, 10)], [(9, 9)]) 0","solution":"def max_paintings_framed(m, n, paintings, frames): Returns the maximum number of paintings that can be framed. Parameters: m (int): The number of paintings. n (int): The number of frames. paintings (list of tuples): The dimensions of each painting. frames (list of tuples): The dimensions of each frame. Returns: int: The maximum number of paintings that can be framed. used_frames = [False] * n count = 0 for painting in paintings: for i, frame in enumerate(frames): if not used_frames[i] and painting[0] <= frame[0] and painting[1] <= frame[1]: used_frames[i] = True count += 1 break return count"},{"question":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right in the grid >>> minPathSum([[1,3,1], [1,5,1], [4,2,1]]) 7 >>> minPathSum([[1, 2, 5]]) 8 >>> minPathSum([[1], [2], [5]]) 8 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> minPathSum([[10, 30, 1], [1, 100, 1], [1, 1, 1]]) 14 >>> minPathSum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> minPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21","solution":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right in the grid if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) for r in range(1, rows): grid[r][0] += grid[r-1][0] for c in range(1, cols): grid[0][c] += grid[0][c-1] for r in range(1, rows): for c in range(1, cols): grid[r][c] += min(grid[r-1][c], grid[r][c-1]) return grid[-1][-1]"},{"question":"from typing import List, Tuple def min_time_to_infect_all(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Calculate the minimum number of time units required for the disease to infect all n people in the village. >>> min_time_to_infect_all(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> min_time_to_infect_all(5, 3, [(1, 2), (2, 3), (4, 5)]) -1","solution":"from collections import deque def min_time_to_infect_all(n, m, edges): # Create adjacency list for the graph adj_list = [[] for _ in range(n + 1)] for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) # BFS to find the minimum time to infect all nodes from node 1 visited = [False] * (n + 1) queue = deque([(1, 0)]) # (node, time) visited[1] = True max_time = 0 while queue: current, time = queue.popleft() max_time = max(max_time, time) for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, time + 1)) # Check if all nodes are visited if not all(visited[1:]): return -1 return max_time"},{"question":"from typing import List, Tuple def is_graph_connected(N: int, E: int, edges: List[Tuple[int, int]]) -> str: Determine if all key intersections are connected directly or indirectly through the roads. >>> is_graph_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" >>> is_graph_connected(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" >>> is_graph_connected(3, 2, [(1, 2), (2, 3)]) == \\"YES\\" >>> is_graph_connected(3, 1, [(1, 2)]) == \\"NO\\" >>> is_graph_connected(1, 0, []) == \\"YES\\" >>> is_graph_connected(0, 0, []) == \\"NO\\" pass def solve(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Solve function to handle multiple test cases. >>> solve([(4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 2, [(1, 2), (3, 4)])]) == [\\"YES\\", \\"NO\\"] >>> solve([(3, 1, [(1, 2)]), (3, 2, [(1, 2), (2, 3)])]) == [\\"NO\\", \\"YES\\"] pass","solution":"def is_graph_connected(N, E, edges): from collections import defaultdict, deque if N == 0: return \\"NO\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited visited_nodes = bfs(1) if len(visited_nodes) == N: return \\"YES\\" else: return \\"NO\\" def solve(test_cases): results = [] for N, E, edges in test_cases: result = is_graph_connected(N, E, edges) results.append(result) return results"},{"question":"def trailPicker(trailsHiked, trailsOffered): Returns the name of the trail that Liam should hike this week. Parameters: - trailsHiked: list of hiking trails that Liam has hiked before (list of strings) - trailsOffered: list of trails available for hiking this week (list of tuples(name, length)) Returns: - name of the trail that Liam should hike this week (string) Example: >>> trailPicker(['Bear Climb', 'Sunset Peak'], [('Mountain Loop', 12), ('Bear Climb', 8), ('Eagle Ridge', 15)]) 'Eagle Ridge' >>> trailPicker([], [('River Valley', 10), ('Forest Path', 14)]) 'Forest Path' >>> trailPicker(['Oak Trail', 'Maple Way'], [('Oak Trail', 7), ('Maple Way', 10)]) 'No new trails this week!'","solution":"def trailPicker(trailsHiked, trailsOffered): Returns the name of the trail that Liam should hike this week. Parameters: - trailsHiked: list of hiking trails that Liam has hiked before (list of strings) - trailsOffered: list of trails available for hiking this week (list of tuples(name, length)) Returns: - name of the trail that Liam should hike this week (string) # Filter out the trails that have been hiked before new_trails = [trail for trail in trailsOffered if trail[0] not in trailsHiked] # If there are no new trails, return 'No new trails this week!' if not new_trails: return 'No new trails this week!' # Find the longest trail among the new trails longest_trail = max(new_trails, key=lambda x: x[1]) return longest_trail[0]"},{"question":"def bulb_switcher(n): Determines the final state of each bulb after toggling for each multiple of i. :param n: An integer representing the number of bulbs (1  n  10,000) :return: A list of integers representing the final state of the bulbs (0 for off, 1 for on) >>> bulb_switcher(5) [1, 0, 0, 1, 0] >>> bulb_switcher(1) [1] >>> bulb_switcher(2) [1, 0] >>> bulb_switcher(9) [1, 0, 0, 1, 0, 0, 0, 0, 1] >>> bulb_switcher(100) [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0] from solution import bulb_switcher def test_example_case(): assert bulb_switcher(5) == [1, 0, 0, 1, 0] def test_single_bulb(): assert bulb_switcher(1) == [1] def test_two_bulbs(): assert bulb_switcher(2) == [1, 0] def test_perfect_square(): assert bulb_switcher(9) == [1, 0, 0, 1, 0, 0, 0, 0, 1] def test_large_case(): # Just a simple large test case to check performance result = bulb_switcher(100) expected_result = [1 if (i ** 0.5).is_integer() else 0 for i in range(1, 101)] assert result == expected_result","solution":"def bulb_switcher(n): Determines the final state of each bulb after toggling for each multiple of i. :param n: An integer representing the number of bulbs (1  n  10,000) :return: A list of integers representing the final state of the bulbs (0 for off, 1 for on) # Initialize all bulbs to off (0) bulbs = [0] * n # Toggle the bulbs according to the problem's requirements for i in range(1, n + 1): for j in range(i, n + 1, i): bulbs[j - 1] = 1 - bulbs[j - 1] return bulbs"},{"question":"def solve_maze_escape_problem(m, n, maze): Determine the minimum number of steps required to escape the maze starting from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). If it is not possible to escape the maze, return -1. Constraints: - 1  m, n  1000 Input: m : int : number of rows in the maze n : int : number of columns in the maze maze : List[str] : grid of characters representing the maze, where '#' is a wall and '.' is a path Output: int : minimum number of steps required to escape the maze or -1 if it is impossible Examples: >>> solve_maze_escape_problem(5, 5, [\\"..#.#\\", \\"#..#.\\", \\"#..#.\\", \\".#..#\\", \\"#.#..\\"]) 8 >>> solve_maze_escape_problem(5, 5, [\\".\\", \\"#.#\\", \\".\\", \\"#.#\\", \\"#.#\\"]) -1 pass # Unit Tests def test_maze_escape_example1(): m = 5 n = 5 maze = [ \\"...#.\\", \\"#..#.\\", \\"#..#.\\", \\".#..#\\", \\"#.#..\\" ] assert solve_maze_escape_problem(m, n, maze) == 8 def test_maze_escape_example2(): m = 5 n = 5 maze = [ \\".\\", \\"#.#\\", \\".\\", \\"#.#\\", \\"#.#\\" ] assert solve_maze_escape_problem(m, n, maze) == -1 def test_maze_escape_min_case(): m = 1 n = 1 maze = [ \\".\\" ] assert solve_maze_escape_problem(m, n, maze) == 0 def test_maze_escape_single_obstacle(): m = 2 n = 2 maze = [ \\".#\\", \\"..\\" ] assert solve_maze_escape_problem(m, n, maze) == 2 def test_maze_escape_path_blocked(): m = 3 n = 3 maze = [ \\".#.\\", \\"#\\", \\"..#\\" ] assert solve_maze_escape_problem(m, n, maze) == -1 def test_maze_escape_complex_path(): m = 3 n = 4 maze = [ \\"....\\", \\"..\\", \\"....\\" ] assert solve_maze_escape_problem(m, n, maze) == 5","solution":"from collections import deque def min_steps_to_escape_maze(m, n, maze): # Directions for movement: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and maze[x][y] == '.' # BFS from the top-left corner queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 def solve_maze_escape_problem(m, n, maze): maze = [list(row) for row in maze] return min_steps_to_escape_maze(m, n, maze) # Example usage: # m = 5 # n = 5 # maze = [ # \\"...#.\\", # \\"#..#.\\", # \\"#..#.\\", # \\".#..#\\", # \\"#.#..\\" # ] # print(solve_maze_escape_problem(m, n, maze)) # Output: 8"},{"question":"def sunset_views(buildings: List[int]) -> List[int]: Takes a list of integers representing building heights from east to west and returns a list of the heights of buildings that have a sunset view, ordered from west to east. -----Sample Input:----- sunset_views([4, 2, 3, 1]) -----Sample Output:----- [1, 3, 4]","solution":"def sunset_views(buildings): This function takes in a list of integers representing building heights from east to west and returns a list of the heights of buildings that have a sunset view, from west to east. n = len(buildings) if n == 0: return [] sunset_buildings = [] max_height = 0 for i in range(n - 1, -1, -1): if buildings[i] > max_height: sunset_buildings.append(buildings[i]) max_height = buildings[i] return sunset_buildings"},{"question":"def fibonacci_sequence(n: int) -> list: Write a function that takes a positive integer n and generates the first n numbers of the Fibonacci sequence as a list. Examples: >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(1) [0] from solution import fibonacci_sequence def test_fibonacci_sequence_5(): assert fibonacci_sequence(5) == [0, 1, 1, 2, 3] def test_fibonacci_sequence_1(): assert fibonacci_sequence(1) == [0] def test_fibonacci_sequence_10(): assert fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_fibonacci_sequence_0(): assert fibonacci_sequence(0) == [] def test_fibonacci_sequence_2(): assert fibonacci_sequence(2) == [0, 1] def test_fibonacci_sequence_edge_case(): assert fibonacci_sequence(3) == [0, 1, 1]","solution":"def fibonacci_sequence(n): Returns the first n numbers of the Fibonacci sequence as a list. if n <= 0: return [] sequence = [0, 1] if n > 1 else [0] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if a binary tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> is_balanced(root) True >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5, TreeNode(6))), TreeNode(3)) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced return check_height(root)[1]"},{"question":"def solve_tsp(N: int, bridges: List[List[int]]) -> int: Determine the minimum length of the path that visits each castle exactly once and returns to the starting castle. Parameters: N (int) - Number of castles bridges (list[list[int]]) - Matrix representing the lengths of the bridges between castles Returns: int: Minimum length of the path that visits each castle exactly once and returns to the starting castle >>> solve_tsp(4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) 80 >>> solve_tsp(3, [ [0, 29, 20], [29, 0, 35], [20, 35, 0] ]) 84","solution":"import itertools def solve_tsp(N, bridges): Solves the Traveling Salesman Problem for a given number of castles and bridge lengths. Parameters: N (int): Number of castles bridges (list[list[int]]): Matrix representing the lengths of the bridges between castles Returns: int: Minimum length of the path that visits each castle exactly once and returns to the starting castle # All permutations of visiting castles (not including the starting/ending castle) castles = [i for i in range(1, N)] permutations = itertools.permutations(castles) min_path_length = float('inf') # Iterate over all permutations to find the shortest path for permutation in permutations: current_path_length = 0 current_castle = 0 # Start from castle 0 # Calculate the length of the current path for next_castle in permutation: current_path_length += bridges[current_castle][next_castle] current_castle = next_castle # Adding the return to the starting castle current_path_length += bridges[current_castle][0] # Update the minimum path length min_path_length = min(min_path_length, current_path_length) return min_path_length"},{"question":"def isProductiveDay(t: str, m: int) -> bool: Checks if the sequence of activities follows the productivity guidelines. Parameters: t (str): A string representing a sequence of activities. m (int): The maximum number of consecutive work activities allowed. Returns: bool: True if the activities follow the guidelines, False otherwise. >>> isProductiveDay(\\"WWRWRW\\", 2) True >>> isProductiveDay(\\"WWW\\", 2) False >>> isProductiveDay(\\"RRRRR\\", 2) True >>> isProductiveDay(\\"WWWWWW\\", 5) False >>> isProductiveDay(\\"W\\", 1) True >>> isProductiveDay(\\"W\\", 0) False >>> isProductiveDay(\\"WRWRWRW\\", 1) True >>> isProductiveDay(\\"W\\" * 100000, 100000) True >>> isProductiveDay(\\"W\\" * 100001, 100000) False >>> isProductiveDay(\\"W\\" * 1, 0) False >>> isProductiveDay(\\"R\\" * 100, 0) True pass","solution":"def isProductiveDay(t, m): Checks if the sequence of activities follows the productivity guidelines. Parameters: t (str): A string representing a sequence of activities. m (int): The maximum number of consecutive work activities allowed. Returns: bool: True if the activities follow the guidelines, False otherwise. consecutive_work = 0 for activity in t: if activity == 'W': consecutive_work += 1 if consecutive_work > m: return False else: consecutive_work = 0 return True"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that all uppercase letters come before all lowercase letters, while maintaining their respective order within each group. >>> rearrange_string('dAeB') 'ABde' >>> rearrange_string('aBcDeFgH') 'BDFHaceg'","solution":"def rearrange_string(s): Rearranges the string such that all uppercase letters come before all lowercase letters, while maintaining their respective order within each group. uppercase_letters = [char for char in s if char.isupper()] lowercase_letters = [char for char in s if char.islower()] return ''.join(uppercase_letters) + ''.join(lowercase_letters)"},{"question":"from typing import List def count_valleys(sequence: List[int]) -> int: Counts the number of valleys in the given sequence of integer data points. A valley is defined as a contiguous subsequence of data points that has the same pattern as the capital letter 'V'. Parameters: sequence (list of int): A sequence of integer data points. Returns: int: The total number of valleys found in the sequence. >>> count_valleys([3, 2, 1, 2, 3, 4, 3, 2, 1, 0, 1, 2]) 2 >>> count_valleys([1, 2, 3, 4]) 0 >>> count_valleys([5, 1, 5, 1, 5, 1, 5]) 3 pass def process_input(input_string: str) -> List[int]: Processes the input string to convert it to a list of integers. Parameters: input_string (str): Input string with space-separated integers. Returns: list of int: List of integers extracted from the input string. >>> process_input(\\"3 2 1 2 3 4 3 2 1 0 1 2\\") [3, 2, 1, 2, 3, 4, 3, 2, 1, 0, 1, 2] >>> process_input(\\"1 2 3 4\\") [1, 2, 3, 4] >>> process_input(\\"5 1 5 1 5 1 5\\") [5, 1, 5, 1, 5, 1, 5] pass # Example unit tests def test_sample_input_1(): sequence = process_input(\\"3 2 1 2 3 4 3 2 1 0 1 2\\") assert count_valleys(sequence) == 2 def test_sample_input_2(): sequence = process_input(\\"1 2 3 4\\") assert count_valleys(sequence) == 0 def test_sample_input_3(): sequence = process_input(\\"5 1 5 1 5 1 5\\") assert count_valleys(sequence) == 3","solution":"def count_valleys(sequence): Counts the number of valleys in the given sequence of integer data points. A valley is defined as a contiguous subsequence of data points that has the same pattern as the capital letter 'V'. Parameters: sequence (list of int): A sequence of integer data points. Returns: int: The total number of valleys found in the sequence. valleys = 0 n = len(sequence) i = 1 while i < n - 1: if sequence[i - 1] > sequence[i] < sequence[i + 1]: valleys += 1 while i < n - 1 and sequence[i] <= sequence[i + 1]: i += 1 else: i += 1 return valleys def process_input(input_string): Processes the input string to convert it to a list of integers. Parameters: input_string (str): Input string with space-separated integers. Returns: list of int: List of integers extracted from the input string. return list(map(int, input_string.split()))"},{"question":"def max_minimized_diff(arr): Return the maximum minimized absolute difference of any subarray of the input array. pass def process_test_cases(test_cases): Process multiple test cases and return their results as a list. pass # Unit tests def test_max_minimized_diff(): assert max_minimized_diff([1, 3, 4, 9, 2]) == 0 assert max_minimized_diff([4, 4, 4, 4, 4, 4]) == 0 assert max_minimized_diff([10, 12, 24, 32, 45, 51]) == 0 assert max_minimized_diff([1, 1, 1, 2, 2, 2, 3, 3]) == 0 assert max_minimized_diff([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0 assert max_minimized_diff([10, 20, 30, 40]) == 0 def test_process_test_cases(): test_cases = [ (5, [1, 3, 4, 9, 2]), (6, [4, 4, 4, 4, 4, 4]), ] assert process_test_cases(test_cases) == [0, 0] test_cases = [ (6, [10, 12, 24, 32, 45, 51]), (8, [1, 1, 1, 2, 2, 2, 3, 3]), ] assert process_test_cases(test_cases) == [0, 0] test_cases = [ (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), (4, [10, 20, 30, 40]), ] assert process_test_cases(test_cases) == [0, 0]","solution":"def max_minimized_diff(arr): Return the maximum minimized absolute difference of any subarray of the input array. # Since we need to minimize the difference between max and min # to the lowest possible value, we know the best we can do is 0. # If there are any two or more consecutive identical elements, we can pick that subarray. for i in range(1, len(arr)): if arr[i] == arr[i-1]: return 0 # If there are no two consecutive identical elements, the best subarray we can take # is any one-element subarray, where obviously max and min are the same, thus their difference is 0. return 0 def process_test_cases(test_cases): Process multiple test cases and return their results as a list. results = [] for case in test_cases: n, arr = case result = max_minimized_diff(arr) results.append(result) return results"},{"question":"def max_non_overlapping_tasks(tasks): Given a list of tasks with start and finish times, returns the maximum number of non-overlapping tasks that can be scheduled. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (7, 8), (5, 9)]) == 3 >>> max_non_overlapping_tasks([(4, 5), (1, 2), (3, 4)]) == 3 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) == 6 pass def process_input(input_data): Processes the input data and returns the results for each test case. >>> input_data = ''' ... 5 ... 1 3 ... 2 5 ... 4 6 ... 7 8 ... 5 9 ... 3 ... 4 5 ... 1 2 ... 3 4 ... 6 ... 1 2 ... 2 3 ... 3 4 ... 4 5 ... 5 6 ... 6 7 ... 0 ... ''' >>> process_input(input_data) == [3, 3, 6] >>> input_data = \\"0\\" >>> process_input(input_data) == [] pass","solution":"def max_non_overlapping_tasks(tasks): Given a list of tasks with start and finish times, returns the maximum number of non-overlapping tasks that can be scheduled. # Sort tasks based on finishing times. If the finish times are the same, sort by start times. sorted_tasks = sorted(tasks, key=lambda x: (x[1], x[0])) # Initialize count of non-overlapping tasks count = 0 # Initialize the end time of the last selected task last_end_time = -1 for start, finish in sorted_tasks: # If the current task starts after the last selected task ends, it can be scheduled if start >= last_end_time: count += 1 last_end_time = finish return count def process_input(input_data): Processes the input data and returns the results for each test case. results = [] lines = input_data.strip().split(\\"n\\") i = 0 while i < len(lines): T = int(lines[i]) if T == 0: break i += 1 tasks = [] for _ in range(T): start, finish = map(int, lines[i].strip().split()) tasks.append((start, finish)) i += 1 results.append(max_non_overlapping_tasks(tasks)) return results"},{"question":"def minTransformations(str: str, dict: set) -> int: Given a string str and a dictionary of words dict, find the minimum number of transformations required to convert str to an element of dict. In each transformation, you can change exactly one character at any position of str to any other character. You can assume all dictionary words are of the same length as the input string. >>> minTransformations(\\"abc\\", {\\"adc\\", \\"bcc\\", \\"aeb\\"}) 1 >>> minTransformations(\\"hello\\", {\\"hella\\", \\"bello\\", \\"henlo\\"}) 1 >>> minTransformations(\\"git\\", {\\"get\\", \\"got\\", \\"bit\\"}) 1 def test_minTransformations_example1(): assert minTransformations(\\"abc\\", {\\"adc\\", \\"bcc\\", \\"aeb\\"}) == 1 def test_minTransformations_example2(): assert minTransformations(\\"hello\\", {\\"hella\\", \\"bello\\", \\"henlo\\"}) == 1 def test_minTransformations_example3(): assert minTransformations(\\"git\\", {\\"get\\", \\"got\\", \\"bit\\"}) == 1 def test_minTransformations_same_string(): assert minTransformations(\\"test\\", {\\"test\\", \\"best\\", \\"nest\\"}) == 0 def test_minTransformations_multiple_minimums(): assert minTransformations(\\"abcd\\", {\\"efgh\\", \\"ijkl\\", \\"mnop\\"}) == 4 def test_minTransformations_large_dict(): large_dict = {f\\"word{i:03d}\\" for i in range(1000)} assert minTransformations(\\"word000\\", large_dict) == 0","solution":"def minTransformations(str, dict): Returns the minimum number of transformations required to convert str to any element of dict. min_transformations = float('inf') for word in dict: transformations = sum(1 for s, w in zip(str, word) if s != w) min_transformations = min(min_transformations, transformations) return min_transformations"},{"question":"def rotateMatrix(N: int, M: int, Mat: List[List[int]]) -> List[List[int]]: Rotate the given NxM matrix by 90 degrees clockwise. :param N: Number of rows in the matrix :param M: Number of columns in the matrix :param Mat: The matrix to be rotated :return: Rotated matrix >>> rotateMatrix(3, 3, [[1,2,3],[4,5,6],[7,8,9]]) [[7,4,1], [8,5,2], [9,6,3]] >>> rotateMatrix(2, 3, [[1,2,3],[4,5,6]]) [[4,1], [5,2], [6,3]]","solution":"def rotateMatrix(N, M, Mat): Rotate the given NxM matrix by 90 degrees clockwise. :param N: Number of rows in the matrix :param M: Number of columns in the matrix :param Mat: The matrix to be rotated :return: Rotated matrix # Create a new matrix with dimensions MxN (transposed dimensions) rotated = [[0] * N for _ in range(M)] for i in range(N): for j in range(M): rotated[j][N-1-i] = Mat[i][j] return rotated"},{"question":"def has_circular_dependency(n, m, edges): Determines if there's a circular dependency in the given file system. Parameters: n (int): Number of folders. m (int): Number of relationships (either subfolder or symbolic links). edges (list of tuple): Each tuple (u, v) denotes an edge from folder u to folder v. Returns: str: \\"YES\\" if there exists a circular dependency, otherwise \\"NO\\". pass def test_has_circular_dependency(): assert has_circular_dependency(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 2), (3, 1)]) == \\"YES\\" assert has_circular_dependency(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"NO\\" assert has_circular_dependency(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"YES\\" assert has_circular_dependency(6, 6, [(1, 2), (2, 3), (3, 4), (4, 6), (6, 5), (5, 4)]) == \\"YES\\" assert has_circular_dependency(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"NO\\" assert has_circular_dependency(1, 0, []) == \\"NO\\" assert has_circular_dependency(2, 1, [(1, 2)]) == \\"NO\\" test_has_circular_dependency()","solution":"def has_circular_dependency(n, m, edges): Determines if there's a circular dependency in the given file system. Parameters: n (int): Number of folders. m (int): Number of relationships (either subfolder or symbolic links). edges (list of tuple): Each tuple (u, v) denotes an edge from folder u to folder v. Returns: str: \\"YES\\" if there exists a circular dependency, otherwise \\"NO\\". from collections import defaultdict, deque # Build graph representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Helper function to perform DFS and detect a cycle def is_cyclic(v, visited, stack): visited[v] = True stack[v] = True # Recur for all the vertices adjacent to this vertex for neighbour in graph[v]: if not visited[neighbour]: if is_cyclic(neighbour, visited, stack): return True elif stack[neighbour]: return True # The vertex needs to be popped from recursion stack before function ends stack[v] = False return False visited = [False] * (n + 1) stack = [False] * (n + 1) for node in range(1, n + 1): if not visited[node]: if is_cyclic(node, visited, stack): return \\"YES\\" return \\"NO\\""},{"question":"def calculate_grade(assignments, projects, exams): Calculates the final grade based on assignments, projects, and exams scores. - assignments: list of assignment scores - projects: list of project scores - exams: list of exam scores Returns the grade category: - \\"A\\" for a final grade >= 90 - \\"B\\" for a final grade >= 80 and < 90 - \\"C\\" for a final grade >= 70 and < 80 - \\"D\\" for a final grade >= 60 and < 70 - \\"F\\" for a final grade < 60 >>> calculate_grade([95, 92, 88, 96], [90, 91], [93, 94]) 'A' >>> calculate_grade([85, 82, 80, 88], [79, 85], [88, 84]) 'B' >>> calculate_grade([75, 72, 78, 70], [70, 68], [72, 75]) 'C' >>> calculate_grade([65, 62, 68, 60], [60, 65], [66, 64]) 'D' >>> calculate_grade([55, 52, 48, 50], [40, 45], [50, 55]) 'F'","solution":"def calculate_grade(assignments, projects, exams): Calculates the final grade based on assignments, projects, and exams scores. - assignments: list of assignment scores - projects: list of project scores - exams: list of exam scores Returns the grade category: - \\"A\\" for a final grade >= 90 - \\"B\\" for a final grade >= 80 and < 90 - \\"C\\" for a final grade >= 70 and < 80 - \\"D\\" for a final grade >= 60 and < 70 - \\"F\\" for a final grade < 60 avg_assignments = sum(assignments) / len(assignments) avg_projects = sum(projects) / len(projects) avg_exams = sum(exams) / len(exams) final_grade = (avg_assignments * 0.4) + (avg_projects * 0.3) + (avg_exams * 0.3) if final_grade >= 90: return \\"A\\" elif final_grade >= 80: return \\"B\\" elif final_grade >= 70: return \\"C\\" elif final_grade >= 60: return \\"D\\" else: return \\"F\\""},{"question":"def total_blocks_to_add(n, heights): Calculate the total number of blocks needed to make all blocks the same height as the tallest one. Parameters: n (int): The number of blocks. heights (list of int): The heights of the blocks. Returns: int: The total number of blocks to add. >>> total_blocks_to_add(4, [1, 3, 2, 4]) 6 >>> total_blocks_to_add(3, [5, 5, 5]) 0 >>> total_blocks_to_add(5, [2, 2, 2, 2, 2]) 0","solution":"def total_blocks_to_add(n, heights): Returns the total number of blocks needed to add to make all blocks of the same height as the tallest block. Parameters: n (int): The number of blocks. heights (list of int): The heights of the blocks. Returns: int: The total number of blocks to add. max_height = max(heights) total_adds = sum(max_height - height for height in heights) return total_adds"},{"question":"from typing import List def count_log_messages(log_entries: List[str], query: str) -> int: Count the number of log messages of a specific type within a specified time range. Log entries: - log_entries: List of log messages in the format \\"timestamp,message_type\\" Example: [\\"2023-01-01 10:15:30,ERROR\\", \\"2023-01-01 11:20:45,INFO\\"] Query: - query: A string in the format \\"start_timestamp,end_timestamp,message_type\\" Example: \\"2023-01-01 10:00:00,2023-01-01 11:00:00,ERROR\\" Returns: - The count of log messages matching the message type and within the time range specified in the query. >>> count_log_messages( ... [\\"2023-01-01 10:15:30,ERROR\\", \\"2023-01-01 11:20:45,INFO\\", \\"2023-01-01 10:30:00,ERROR\\", \\"2023-01-01 10:45:00,DEBUG\\"], ... \\"2023-01-01 10:00:00,2023-01-01 11:00:00,ERROR\\" ... ) 2 >>> count_log_messages( ... [\\"2023-01-01 10:15:30,INFO\\", \\"2023-01-01 11:20:45,INFO\\", \\"2023-01-01 10:30:00,DEBUG\\", \\"2023-01-01 10:45:00,DEBUG\\"], ... \\"2023-01-01 10:00:00,2023-01-01 11:00:00,ERROR\\" ... ) 0 >>> count_log_messages([], \\"2023-01-01 10:00:00,2023-01-01 11:00:00,ERROR\\") 0","solution":"from datetime import datetime from typing import List def count_log_messages(log_entries: List[str], query: str) -> int: start_timestamp, end_timestamp, message_type = query.split(',') start_time = datetime.strptime(start_timestamp, '%Y-%m-%d %H:%M:%S') end_time = datetime.strptime(end_timestamp, '%Y-%m-%d %H:%M:%S') count = 0 for entry in log_entries: entry_timestamp, entry_message_type = entry.split(',') entry_time = datetime.strptime(entry_timestamp, '%Y-%m-%d %H:%M:%S') if start_time <= entry_time <= end_time and entry_message_type == message_type: count += 1 return count"},{"question":"def perform_queries(n: int, q: int, arr: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Perform a series of type 1 and type 2 queries on the given array \`arr\`. Parameters: n (int): The length of the array \`arr\`. q (int): The number of queries. arr (List[int]): The initial array of integers. queries (List[Tuple[int, ...]]): A list of queries where each query is a tuple. The first element of the tuple is the query type (1 or 2). For Type 1: The tuple is (1, k, l, r) For Type 2: The tuple is (2, l, r) Returns: List[int]: The results of all Type 2 queries. >>> perform_queries(8, 5, [4, 2, 7, 1, 3, 5, 8, 6], [(1, 3, 2, 4), (2, 1, 4), (2, 5, 7), (1, -2, 1, 3), (2, 3, 6)]) [10, 8, 8] >>> perform_queries(5, 0, [1, 2, 3, 4, 5], []) [] >>> perform_queries(4, 4, [1, 2, 3, 4], [(1, 1, 1, 2), (1, 2, 2, 3), (1, 3, 3, 4), (1, 4, 1, 4)]) [] >>> perform_queries(5, 3, [5, 4, 3, 2, 1], [(2, 1, 1), (2, 1, 5), (2, 3, 5)]) [5, 5, 3] >>> perform_queries(6, 5, [1, 3, 5, 7, 9, 11], [(2, 1, 3), (1, 2, 2, 4), (2, 1, 4), (1, -3, 5, 6), (2, 5, 6)]) [5, 9, 8]","solution":"def perform_queries(n, q, arr, queries): This function performs a series of type 1 and type 2 queries on the given array \`arr\`. Parameters: n (int): The length of the array \`arr\`. q (int): The number of queries. arr (List[int]): The initial array of integers. queries (List[Tuple[int, ...]]): A list of queries where each query is a tuple. The first element of the tuple is the query type (1 or 2). For Type 1: The tuple is (1, k, l, r) For Type 2: The tuple is (2, l, r) Returns: List[int]: The results of all Type 2 queries. results = [] for query in queries: if query[0] == 1: # Type 1 query k, l, r = query[1], query[2], query[3] for i in range(l-1, r): arr[i] += k elif query[0] == 2: # Type 2 query l, r = query[1], query[2] results.append(max(arr[l-1:r])) return results"},{"question":"def sort_students_by_score(n: int, student_data: List[Tuple[str, int]]) -> List[str]: Sort students by scores in descending order. If scores are equal, sort by name in ascending order. :param n: number of students :param student_data: List of tuples, each containing student name and their score. :return: List of student names sorted based on specified criteria. >>> sort_students_by_score(4, [(\\"Alice\\", 85), (\\"Bob\\", 90), (\\"Charlie\\", 85), (\\"David\\", 92)]) [\\"David\\", \\"Bob\\", \\"Alice\\", \\"Charlie\\"] >>> sort_students_by_score(3, [(\\"Eve\\", 78), (\\"Mallory\\", 78), (\\"Trudy\\", 75)]) [\\"Eve\\", \\"Mallory\\", \\"Trudy\\"] >>> sort_students_by_score(1, [(\\"John\\", 100)]) [\\"John\\"] >>> sort_students_by_score(3, [(\\"John\\", 90), (\\"Doe\\", 90), (\\"Jane\\", 95)]) [\\"Jane\\", \\"Doe\\", \\"John\\"] >>> sort_students_by_score(5, [(\\"Student1\\", 60), (\\"Student2\\", 70), (\\"Student3\\", 70), (\\"Student4\\", 85), (\\"Student5\\", 85)]) [\\"Student4\\", \\"Student5\\", \\"Student2\\", \\"Student3\\", \\"Student1\\"] >>> sort_students_by_score(3, [(\\"Charlie\\", 85), (\\"Alice\\", 85), (\\"Bob\\", 85)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> sort_students_by_score(2, [(\\"Alice\\", 0), (\\"Bob\\", 0)]) [\\"Alice\\", \\"Bob\\"] >>> sort_students_by_score(3, [(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 100)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]","solution":"def sort_students_by_score(n, student_data): Sort students by scores in descending order. If scores are equal, sort by name in ascending order. :param n: number of students :param student_data: List of tuples, each containing student name and their score. :return: List of student names sorted based on specified criteria. # Sort primarily by score descending, secondarily by name ascending sorted_students = sorted(student_data, key=lambda x: (-x[1], x[0])) # Extract only the names sorted_names = [student[0] for student in sorted_students] return sorted_names"},{"question":"import heapq from typing import List, Tuple def shortest_paths_from_1(n: int, m: int, edges: List[Tuple[int, int, int]]) -> List[int]: Find the shortest paths from node 1 to all other nodes in an undirected connected graph. >>> shortest_paths_from_1(5, 6, [(1, 2, 7), (1, 3, 9), (1, 5, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (4, 5, 6)]) [0, 7, 9, 20, 14] >>> shortest_paths_from_1(4, 3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) [0, 3, 7, 12] >>> shortest_paths_from_1(4, 2, [(1, 2, 2), (3, 4, 8)]) [0, 2, -1, -1] >>> shortest_paths_from_1(3, 0, []) [0, -1, -1] >>> shortest_paths_from_1(6, 3, [(1, 2, 5), (3, 4, 10), (5, 6, 2)]) [0, 5, -1, -1, -1, -1]","solution":"import heapq def shortest_paths_from_1(n, m, edges): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dist = [float('inf')] * (n + 1) dist[1] = 0 priority_queue = [(0, 1)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, w in graph[u]: if dist[u] + w < dist[v]: dist[v] = dist[u] + w heapq.heappush(priority_queue, (dist[v], v)) return [dist[i] if dist[i] != float('inf') else -1 for i in range(1, n + 1)]"},{"question":"def calculate_discounted_price(fruit_type: str, value: int) -> int: Calculate the total price after discount for a given fruit type. Args: fruit_type (str): The type of the fruit (apple, orange, banana). value (int): The original price or quantity based on the fruit type. Returns: int: The total price after applying the respective discount. >>> calculate_discounted_price(\\"apple\\", 100) 80 >>> calculate_discounted_price(\\"orange\\", 4) 100 >>> calculate_discounted_price(\\"banana\\", 10) 75 >>> calculate_discounted_price(\\"apple\\", 50) 40 >>> calculate_discounted_price(\\"orange\\", 5) 150 >>> calculate_discounted_price(\\"banana\\", 3) 25 pass # Reading input and printing the result def main(): import sys input = sys.stdin.read data = input().strip().split('n') T = int(data[0]) for i in range(1, T + 1): fruit, value = data[i].split() value = int(value) print(calculate_discounted_price(fruit, value)) if __name__ == \\"__main__\\": main()","solution":"def calculate_discounted_price(fruit_type, value): Calculate the total price after discount for a given fruit type. Args: fruit_type (str): The type of the fruit (apple, orange, banana). value (int): The original price or quantity based on the fruit type. Returns: int: The total price after applying the respective discount. if fruit_type == \\"apple\\": return int(value * 0.8) elif fruit_type == \\"orange\\": quantity = value return (quantity // 2 + quantity % 2) * 50 elif fruit_type == \\"banana\\": quantity = value return quantity * 10 - (quantity // 2) * 5 else: raise ValueError(\\"Invalid fruit type\\") # Reading input and printing the result def main(): import sys input = sys.stdin.read data = input().strip().split('n') T = int(data[0]) for i in range(1, T + 1): fruit, value = data[i].split() value = int(value) print(calculate_discounted_price(fruit, value)) if __name__ == \\"__main__\\": main()"},{"question":"def product_except_self(nums): Given an array nums of n integers where n > 1, returns an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([4, 5, 1, 8, 2]) [80, 64, 320, 40, 160] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Given an array nums of n integers where n > 1, returns an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) output = [1] * n left = 1 right = 1 # Calculate the product of elements to the left of each index for i in range(n): output[i] = left left *= nums[i] # Calculate the product of elements to the right of each index and multiply it with # the current value in output for i in range(n - 1, -1, -1): output[i] *= right right *= nums[i] return output"},{"question":"from typing import List def find_peak_elements(matrix: List[List[int]]) -> List[int]: Given a matrix of integers, find the \\"peak elements\\". An element is considered a peak if it is not smaller than its neighbors. >>> find_peak_elements([ [10, 20, 15], [21, 30, 14], [7, 16, 32] ]) [30, 32] >>> find_peak_elements([ [10, 20, 15, 25, 5] ]) [20, 25] >>> find_peak_elements([ [10], [20], [15], [25], [5] ]) [20, 25] >>> find_peak_elements([ [10, 10, 10], [10, 10, 10], [10, 10, 10] ]) [10, 10, 10, 10, 10, 10, 10, 10, 10] >>> find_peak_elements([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [9] >>> find_peak_elements([[10]]) [10]","solution":"from typing import List def find_peak_elements(matrix: List[List[int]]) -> List[int]: def is_peak(matrix, i, j): rows, cols = len(matrix), len(matrix[0]) value = matrix[i][j] # Check top neighbor if i > 0 and matrix[i-1][j] > value: return False # Check bottom neighbor if i < rows - 1 and matrix[i+1][j] > value: return False # Check left neighbor if j > 0 and matrix[i][j-1] > value: return False # Check right neighbor if j < cols - 1 and matrix[i][j+1] > value: return False return True peaks = [] for i in range(len(matrix)): for j in range(len(matrix[0])): if is_peak(matrix, i, j): peaks.append(matrix[i][j]) return peaks"},{"question":"def bubble_sort(arr): Returns the array sorted in ascending order using bubble sort. n = len(arr) # Traverse through all array elements for i in range(n): # Last i elements are already in place for j in range(0, n-i-1): # Swap if the element found is greater than the next element if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def sort_array(inputs): Accepts a string of numbers separated by space, converts them to a list of integers, sorts the list using bubble sort algorithm and returns the sorted list as a space separated string. nums = list(map(int, inputs.split())) sorted_array = bubble_sort(nums) return ' '.join(map(str, sorted_array)) def test_sort_positive_numbers(): assert sort_array(\\"4 2 3 1 5\\") == \\"1 2 3 4 5\\" assert sort_array(\\"10 9 8 7 6 5\\") == \\"5 6 7 8 9 10\\" def test_sort_with_negative_numbers(): assert sort_array(\\"-1 -3 -2 -5 -4\\") == \\"-5 -4 -3 -2 -1\\" assert sort_array(\\"3 -3 2 -2 1 -1 0\\") == \\"-3 -2 -1 0 1 2 3\\" def test_sort_mixed_numbers(): assert sort_array(\\"4 -1 2 -3 0\\") == \\"-3 -1 0 2 4\\" assert sort_array(\\"0 0 1 -1 -1 1\\") == \\"-1 -1 0 0 1 1\\" def test_sort_all_zeros(): assert sort_array(\\"0 0 0 0 0 0 0\\") == \\"0 0 0 0 0 0 0\\" def test_empty_input(): assert sort_array(\\"\\") == \\"\\" def test_single_element(): assert sort_array(\\"10\\") == \\"10\\"","solution":"def bubble_sort(arr): Returns the array sorted in ascending order using bubble sort. n = len(arr) # Traverse through all array elements for i in range(n): # Last i elements are already in place for j in range(0, n-i-1): # Traverse the array from 0 to n-i-1 # Swap if the element found is greater # than the next element if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def sort_array(inputs): Accepts a string of numbers separated by space, converts them to a list of integers, sorts the list using bubble sort algorithm and returns the sorted list as a space separated string. nums = list(map(int, inputs.split())) sorted_array = bubble_sort(nums) return ' '.join(map(str, sorted_array))"},{"question":"def minimum_tour_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Ash wants to visit all the tourist attractions in his city. There are n attractions, and there are m direct roads connecting some of these attractions. Ash is currently at attraction 1, and he wants to visit all attractions at least once before returning to attraction 1. Each road has a travel time associated with it, and Ash wants to minimize the total travel time. Each road is described by two attractions that it connects and the time it takes to travel between them. Ash can start and end his journey at attraction 1, but he can visit the attractions in any order. If there is no direct road between two attractions, Ash cannot travel directly between them and must use other roads to reach his destination. If no such tour exists, return -1. Otherwise, return the minimum possible travel time needed to complete the tour starting and ending at attraction 1. >>> minimum_tour_time(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> minimum_tour_time(4, 3, [(1, 2, 10), (2, 3, 20), (3, 4, 30)]) -1","solution":"import itertools def tsp(graph, n, start=0): Solve the Travelling Salesman Problem using dynamic programming and bit masking. :param graph: 2D list representing the adjacency matrix of the graph. :param n: Number of vertices in the graph. :param start: The starting vertex. :return: Minimum travel cost to visit all vertices and return to the start. INF = float('inf') memo = [[INF] * (1 << n) for _ in range(n)] memo[start][1 << start] = 0 for mask in range(1 << n): for u in range(n): if mask & (1 << u): for v in range(n): if not (mask & (1 << v)) and graph[u][v] != INF: next_mask = mask | (1 << v) memo[v][next_mask] = min(memo[v][next_mask], memo[u][mask] + graph[u][v]) res = INF for u in range(n): if u != start and graph[u][start] != INF: res = min(res, memo[u][(1 << n) - 1] + graph[u][start]) return res if res != INF else -1 def minimum_tour_time(n, m, roads): INF = float('inf') graph = [[INF] * n for _ in range(n)] for a, b, t in roads: graph[a-1][b-1] = t graph[b-1][a-1] = t return tsp(graph, n, start=0)"},{"question":"def encode_signal(signal: str) -> str: Encodes the given signal such that the distance between each pair of adjacent characters is maximized. Returns the encoded signal. >>> encode_signal(\\"BRAVO\\") \\"OVRBA\\" >>> encode_signal(\\"A\\") \\"A\\" >>> encode_signal(\\"BA\\") \\"AB\\" or \\"BA\\" >>> encode_signal(\\"CAB\\") \\"CBA\\" >>> encode_signal(\\"AAABBB\\") \\"ABABAB\\" >>> encode_signal(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") \\"AZBYCXDWEVFUGTHSIRJQKPLOMN\\"","solution":"def encode_signal(signal): Encodes the given signal such that the distance between each pair of adjacent characters is maximized. Returns the encoded signal. sorted_signal = ''.join(sorted(signal)) n = len(sorted_signal) # We will split the sorted string into two halves and interleave them first_half = sorted_signal[:(n + 1) // 2] second_half = sorted_signal[(n + 1) // 2:] encoded = [] # Interleave the characters from the two halves i, j = 0, len(second_half) - 1 while i < len(first_half) or j >= 0: if i < len(first_half): encoded.append(first_half[i]) i += 1 if j >= 0: encoded.append(second_half[j]) j -= 1 return ''.join(encoded)"},{"question":"def knapsack(W, N, items): Determine the maximum value that fits within the given weight limit W using the list of items with their respective weights and values. >>> knapsack(50, 3, [(10, 60), (20, 100), (30, 120) ]) == 220 >>> knapsack(10, 1, [(10, 100)]) == 100 >>> knapsack(9, 1, [(10, 100)]) == 0 >>> knapsack(10, 3, [(1, 100), (2, 200), (3, 300)]) == 600 >>> knapsack(1, 1, [(1, 1)]) == 1 >>> knapsack(10000, 1, [(10000, 10000)]) == 10000 pass def parse_input(input_str): Parse the input string into the usable components for the knapsack function. >>> parse_input(\\"50 3n10 60n20 100n30 120n\\") == (50, 3, [(10, 60), (20, 100), (30, 120)]) >>> parse_input(\\"10 1n10 100n\\") == (10, 1, [(10, 100)]) >>> parse_input(\\"9 1n10 100n\\") == (9, 1, [(10, 100)]) >>> parse_input(\\"10 3n1 100n2 200n3 300n\\") == (10, 3, [(1, 100), (2, 200), (3, 300)]) >>> parse_input(\\"1 1n1 1n\\") == (1, 1, [(1, 1)]) >>> parse_input(\\"10000 1n10000 10000n\\") == (10000, 1, [(10000, 10000)]) pass","solution":"def knapsack(W, N, items): Function to determine the maximum value that fits within the given weight limit W using the list of items with their respective weights and values. # Initialize a DP array where dp[i] will be the max value for weight limit i dp = [0] * (W + 1) # Process each item in the list for weight, value in items: # Traverse the dp array backwards to ensure each item is only counted once for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) # The max value for the weight limit W is stored in dp[W] return dp[W] def parse_input(input_str): Parse the input string into usable components for the knapsack function. lines = input_str.strip().split('n') W, N = map(int, lines[0].split()) items = [tuple(map(int, line.split())) for line in lines[1:]] return W, N, items"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: Given a linked list, rotate the list to the right by k places, where k is a non-negative integer. Example: >>> head = array_to_list([1, 2, 3, 4, 5]) >>> result = list_to_array(rotate_right(head, 2)) >>> result [4, 5, 1, 2, 3] >>> head = array_to_list([0, 1, 2]) >>> result = list_to_array(rotate_right(head, 4)) >>> result [2, 0, 1] Note: - Try to solve it with O(1) extra space complexity.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Compute the length of the linked list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Make the list circular tail.next = head # Find the new head and tail k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"def caesar_cipher(s: str, k: int) -> str: Encrypts the input string s using Caesar Cipher with a shift of k. Parameters: s (str): The string to be encrypted. k (int): The shift value. Returns: str: The encrypted string. >>> caesar_cipher(\\"HELLO\\", 1) \\"IFMMP\\" >>> caesar_cipher(\\"hello\\", 3) \\"khoor\\" >>> caesar_cipher(\\"Zebra!\\", 2) \\"Bgdtc!\\" >>> caesar_cipher(\\"Cipher123\\", -3) \\"Zfmebo123\\" >>> caesar_cipher(\\"12345!@#%\\", 5) \\"12345!@#%\\" import unittest class TestCaesarCipher(unittest.TestCase): def test_positive_shift(self): self.assertEqual(caesar_cipher(\\"HELLO\\", 1), \\"IFMMP\\") self.assertEqual(caesar_cipher(\\"hello\\", 3), \\"khoor\\") self.assertEqual(caesar_cipher(\\"Zebra!\\", 2), \\"Bgdtc!\\") def test_negative_shift(self): self.assertEqual(caesar_cipher(\\"Cipher123\\", -3), \\"Zfmebo123\\") self.assertEqual(caesar_cipher(\\"hello\\", -3), \\"ebiil\\") self.assertEqual(caesar_cipher(\\"HELLO\\", -1), \\"GDKKN\\") def test_large_positive_shift(self): self.assertEqual(caesar_cipher(\\"HELLO\\", 27), \\"IFMMP\\") # Equivalent to shift of 1 self.assertEqual(caesar_cipher(\\"hello\\", 29), \\"khoor\\") # Equivalent to shift of 3 def test_large_negative_shift(self): self.assertEqual(caesar_cipher(\\"Cipher123\\", -29), \\"Zfmebo123\\") # Equivalent to shift of -3 self.assertEqual(caesar_cipher(\\"hello\\", -29), \\"ebiil\\") # Equivalent to shift of -3 def test_non_alpha_characters(self): self.assertEqual(caesar_cipher(\\"12345!@#%\\", 5), \\"12345!@#%\\") self.assertEqual(caesar_cipher(\\"HELLO WORLD!\\", 5), \\"MJQQT BTWQI!\\") self.assertEqual(caesar_cipher(\\"hello, world!\\", -5), \\"czggj, rjmgy!\\") def test_zero_shift(self): self.assertEqual(caesar_cipher(\\"Hello, World!\\", 0), \\"Hello, World!\\") if __name__ == \\"__main__\\": unittest.main()","solution":"def caesar_cipher(s, k): Encrypts the input string s using Caesar Cipher with a shift of k. Parameters: s (str): The string to be encrypted. k (int): The shift value. Returns: str: The encrypted string. encrypted = [] for char in s: if char.isalpha(): shift = k % 26 # Reduce the shift within the range of the alphabet new_char = '' if char.islower(): new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) elif char.isupper(): new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A')) encrypted.append(new_char) else: encrypted.append(char) return ''.join(encrypted)"},{"question":"def calculate_average_in_range(lower: float, upper: float, measurements: List[float]) -> str: Calculate the average of measurements that fall within the range [lower, upper]. >>> calculate_average_in_range(10.5, 20.75, [8.25, 15.0, 22.1, 18.5, 10.5]) == \\"14.666667\\" >>> calculate_average_in_range(10.0, 15.0, [9.9, 18.0, 20.1]) == \\"No measurements in range\\" def read_input(data: str) -> Tuple[float, float, List[float]]: Reads input data from a string and returns the lower and upper bounds, and a list of measurements. >>> read_input(\\"10.0 15.0n3n9.9n18.0n20.1\\") == (10.0, 15.0, [9.9, 18.0, 20.1])","solution":"def calculate_average_in_range(lower, upper, measurements): Calculate the average of measurements that fall within the range [lower, upper]. in_range_measurements = [m for m in measurements if lower <= m <= upper] if not in_range_measurements: return \\"No measurements in range\\" average = sum(in_range_measurements) / len(in_range_measurements) return f\\"{average:.6f}\\" # Input reading function def read_input(data): Reads input data from a string and returns the lower and upper bounds, and a list of measurements. lines = data.split('n') lower, upper = map(float, lines[0].split()) n = int(lines[1]) measurements = [float(lines[i + 2]) for i in range(n)] return lower, upper, measurements"},{"question":"def min_moves_to_target(grid, start, target): Determines the minimum number of moves needed for a drone to reach the target cell. :param grid: List[List[int]] -- The grid of altitudes. :param start: Tuple[int, int] -- Starting cell coordinates (sx, sy). :param target: Tuple[int, int] -- Target cell coordinates (tx, ty). :return: int -- Minimum number of moves to reach target cell or -1 if impossible. >>> grid = [ >>> [1, 2, 2, 3, 4], >>> [2, 3, 3, 4, 5], >>> [3, 3, 3, 3, 2], >>> [4, 5, 6, 5, 6] >>> ] >>> min_moves_to_target(grid, (0, 0), (3, 4)) 7 >>> grid = [ >>> [1, 2, 2], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> min_moves_to_target(grid, (0, 0), (2, 2)) -1 >>> grid = [ >>> [1, 2, 2], >>> [3, 4, 4], >>> [5, 5, 7] >>> ] >>> min_moves_to_target(grid, (1, 1), (1, 1)) 0 >>> grid = [ >>> [1] >>> ] >>> min_moves_to_target(grid, (0, 0), (0, 0)) 0 >>> grid = [ >>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], >>> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11], >>> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12], >>> [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], >>> [5, 6, 7, 8, 9, 10, 11, 12, 13, 14], >>> [6, 7, 8, 9, 10, 11, 12, 13, 14, 15], >>> [7, 8, 9, 10, 11, 12, 13, 14, 15, 16], >>> [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], >>> [9, 10, 11, 12, 13, 14, 15, 16, 17, 18], >>> [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] >>> ] >>> min_moves_to_target(grid, (9, 0), (0, 9)) 18 pass","solution":"from collections import deque def min_moves_to_target(grid, start, target): Determines the minimum number of moves needed for a drone to reach the target cell. :param grid: List[List[int]] -- The grid of altitudes. :param start: Tuple[int, int] -- Starting cell coordinates (sx, sy). :param target: Tuple[int, int] -- Target cell coordinates (tx, ty). :return: int -- Minimum number of moves to reach target cell or -1 if impossible. m, n = len(grid), len(grid[0]) sx, sy = start tx, ty = target if (sx == tx and sy == ty): return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(n)] for _ in range(m)] queue = deque([(sx, sy, 0)]) # Each element is (x, y, moves) visited[sx][sy] = True while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if abs(grid[nx][ny] - grid[x][y]) <= 1: if (nx == tx and ny == ty): return moves + 1 visited[nx][ny] = True queue.append((nx, ny, moves + 1)) return -1"},{"question":"def min_operations(source: str, target: str) -> int: Compute the minimum number of operations required to transform the source string into the target string. Args: source (str): The source string. target (str): The target string. Returns: int: The minimum number of operations to transform source into target. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2","solution":"def min_operations(source, target): Returns the minimum number of operations required to transform source string into target string. m = len(source) n = len(target) # Create a table to store results of subproblems dp = [[0 for x in range(n + 1)] for x in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If the source string is empty, then insert all characters of target if i == 0: dp[i][j] = j # Min. operations = j # If the target string is empty, then remove all characters of source elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are same, ignore the last character # and recur for the remaining substring elif source[i-1] == target[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all possibilities # and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def max_lights_on(N: int, K: int) -> int: Determines the maximum number of lights that can be turned ON after K button presses. Parameters: N (int): Number of lights and buttons. K (int): Number of button presses. Returns: int: Maximum number of lights turned ON. >>> max_lights_on(5, 3) 3 >>> max_lights_on(2, 5) 2 >>> max_lights_on(7, 7) 7 >>> max_lights_on(10, 0) 0 >>> max_lights_on(100000, 100000) 100000 >>> max_lights_on(100000, 50000) 50000 >>> max_lights_on(50000, 100000) 50000","solution":"def max_lights_on(N, K): Determines the maximum number of lights that can be turned ON after K button presses. Parameters: N (int): Number of lights and buttons. K (int): Number of button presses. Returns: int: Maximum number of lights turned ON. # The maximum number of lights that can be turned on is limited by the smaller of N and K. return min(N, K) # Example usage: # N, K = 5, 3 # print(max_lights_on(N, K)) # Output should be 3"},{"question":"def min_edges_to_remove(t: int, test_cases: list) -> list: Determine the minimum number of edges to remove so that the graph becomes a collection of trees. >>> min_edges_to_remove(2, [(4, 3, [(1, 2), (2, 3), (3, 4)]), (6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)])]) [0, 2] # Your code here def test_case_1(): t = 1 test_cases = [ (4, 3, [(1, 2), (2, 3), (3, 4)]) ] assert min_edges_to_remove(t, test_cases) == [0] def test_case_2(): t = 1 test_cases = [ (6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]) ] assert min_edges_to_remove(t, test_cases) == [2] def test_case_3(): t = 1 test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ] assert min_edges_to_remove(t, test_cases) == [0] def test_case_4(): t = 1 test_cases = [ (6, 5, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) ] assert min_edges_to_remove(t, test_cases) == [0] def test_case_5(): t = 1 test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]) ] assert min_edges_to_remove(t, test_cases) == [1]","solution":"def min_edges_to_remove(t, test_cases): def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if xroot != yroot: if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 results = [] for n, m, edges in test_cases: parent = [i for i in range(n)] rank = [0] * n excess_edges = 0 for u, v in edges: u, v = u - 1, v - 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) else: excess_edges += 1 results.append(excess_edges) return results # Test case example usage if __name__ == \\"__main__\\": t = 2 test_cases = [ (4, 3, [(1, 2), (2, 3), (3, 4)]), (6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]) ] results = min_edges_to_remove(t, test_cases) for result in results: print(result)"},{"question":"def find_max_edge_in_mst(num_cities, num_tracks, tracks): Function to find the maximum edge weight in the minimum spanning tree of the given graph. :param num_cities: Number of cities (vertices) in the graph :param num_tracks: Number of railway tracks (edges) in the graph :param tracks: List of tuples representing the edges (u, v, w) :return: Maximum edge weight in the minimum spanning tree >>> find_max_edge_in_mst(4, 5, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]) == 10 >>> find_max_edge_in_mst(3, 3, [(0, 1, 10), (0, 2, 6), (1, 2, 5)]) == 6 def process_input(input_lines): Processes the input lines and returns the output for each test case. >>> process_input([\\"4 5\\", \\"0 1 10\\", \\"0 2 6\\", \\"0 3 5\\", \\"1 3 15\\", \\"2 3 4\\", \\"0 0\\"]) == [10] >>> process_input([\\"4 5\\", \\"0 1 10\\", \\"0 2 6\\", \\"0 3 5\\", \\"1 3 15\\", \\"2 3 4\\", \\"3 3\\", \\"0 1 10\\", \\"0 2 6\\", \\"1 2 5\\", \\"0 0\\"]) == [10, 6]","solution":"def find_max_edge_in_mst(num_cities, num_tracks, tracks): Function to find the maximum edge weight in the minimum spanning tree of the given graph. :param num_cities: Number of cities (vertices) in the graph :param num_tracks: Number of railway tracks (edges) in the graph :param tracks: List of tuples representing the edges (u, v, w) :return: Maximum edge weight in the minimum spanning tree # Applying Kruskal's algorithm to find the MST parent = list(range(num_cities)) rank = [0] * num_cities def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 # Sort all the edges in the graph by weight tracks.sort(key=lambda x: x[2]) max_edge_weight = 0 mst_edges = 0 for u, v, w in tracks: if find(u) != find(v): union(u, v) max_edge_weight = max(max_edge_weight, w) mst_edges += 1 if mst_edges == num_cities - 1: break return max_edge_weight def process_input(input_lines): Processes the input lines and returns the output for each test case. index = 0 results = [] while index < len(input_lines): n, m = map(int, input_lines[index].split()) if n == 0 and m == 0: break index += 1 tracks = [] for _ in range(m): u, v, w = map(int, input_lines[index].split()) tracks.append((u, v, w)) index += 1 results.append(find_max_edge_in_mst(n, m, tracks)) return results"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the only number in the range [0, n] that is missing from the unsorted array of integers \`nums\`. Args: nums (List[int]): A list of distinct integers in the range [0, n]. Returns: int: The missing number in the range [0, n]. Examples: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8 >>> find_missing_number([0, 2, 3]) 1 >>> find_missing_number([1, 2, 3]) 0 >>> find_missing_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]) 11 >>> find_missing_number([0]) 1 >>> find_missing_number([1]) 0","solution":"def find_missing_number(nums): Finds the missing number in the range [0, n] from the given list of numbers. Parameters: nums (List[int]): A list of distinct integers in the range [0, n]. Returns: int: The missing number. n = len(nums) expected_sum = n * (n + 1) // 2 # Sum of first n natural numbers actual_sum = sum(nums) # Sum of elements in the given list return expected_sum - actual_sum"},{"question":"def create_acronym(s: str) -> str: Returns an acronym formed from the initial letters of each word in the given string, in uppercase. >>> create_acronym(\\"hyper text markup language\\") == \\"HTML\\" >>> create_acronym(\\"Python\\") == \\"P\\" >>> create_acronym(\\"Hyper Text Markup Language\\") == \\"HTML\\" >>> create_acronym(\\"hyper text markup\\") == \\"HTM\\" >>> create_acronym(\\"HYPER TEXT MARKUP LANGUAGE\\") == \\"HTML\\" >>> create_acronym(\\" hyper text markup language \\") == \\"HTML\\" >>> create_acronym(\\"a b c d e f g\\") == \\"ABCDEFG\\" >>> create_acronym(\\"\\") == \\"\\"","solution":"def create_acronym(s): Returns an acronym formed from the initial letters of each word in the given string, in uppercase. acronym = ''.join(word[0].upper() for word in s.split()) return acronym"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the total amount of water trapped between the terrains. :param height: List[int] - List of non-negative integers representing the elevation of a terrain. :return: int - Total amount of water trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"from typing import List def trap(height: List[int]) -> int: Calculate the total amount of water trapped between the terrains. :param height: List[int] - List of non-negative integers representing the elevation of a terrain. :return: int - Total amount of water trapped. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Given a 2D grid, find the minimum cost path from the top-left to the bottom-right corner. :param grid: List[List[int]] - 2D list representing the grid with non-negative costs. :return: int - the minimum cost to reach bottom-right corner. >>> minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7 >>> minPathSum([[1,2,3],[4,5,6]]) == 12 >>> minPathSum([[5]]) == 5 >>> minPathSum([[1,2],[1,1]]) == 3 >>> minPathSum([[1,2,3,4]]) == 10 >>> minPathSum([[1], [2], [3], [4]]) == 10 pass","solution":"def minPathSum(grid): Given a 2D grid, find the minimum cost path from the top-left to the bottom-right corner. :param grid: List[List[int]] - 2D list representing the grid with non-negative costs. :return: int - the minimum cost to reach bottom-right corner. n = len(grid) m = len(grid[0]) # Create a 2D dp array initialized to 0 dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Return the value in bottom-right corner return dp[n-1][m-1]"},{"question":"def catalogue(rows): Given a list of rows, where each row contains unique book IDs, return the catalogue with book IDs ordered by rows, and within each row sorted in ascending order. >>> catalogue([[5, 1, 3, 9, 7], [2, 4, 6, 8], [1, 0, -1]]) [[1, 3, 5, 7, 9], [2, 4, 6, 8], [-1, 0, 1]] pass def format_catalogue(catalogue): Given the sorted catalogue, return a formatted string with each row on a new line. >>> format_catalogue([[1, 3, 5, 7, 9], [2, 4, 6, 8], [-1, 0, 1]]) '1 3 5 7 9n2 4 6 8n-1 0 1' pass def main(input_string): Given an input string representing the book IDs in rows, return the formatted catalogue as a string. >>> main(\\"3n5 1 3 9 7n2 4 6 8n1 0 -1\\") '1 3 5 7 9n2 4 6 8n-1 0 1' pass","solution":"def catalogue(rows): sorted_catalogue = [] for row in rows: sorted_row = sorted(row) sorted_catalogue.append(sorted_row) return sorted_catalogue def format_catalogue(catalogue): return 'n'.join(' '.join(map(str, row)) for row in catalogue) def main(input_string): input_lines = input_string.strip().split('n') R = int(input_lines[0]) rows = [list(map(int, input_lines[i+1].split())) for i in range(R)] sorted_catalogue = catalogue(rows) return format_catalogue(sorted_catalogue)"},{"question":"def count_visible_flags(n: int, heights: List[int]) -> int: Count the number of buildings where flags can be placed. Parameters: n (int): Number of buildings. heights (list of int): Heights of the buildings. Returns: int: The number of buildings where flags can be placed. >>> count_visible_flags(5, [4, 3, 2, 5, 1]) 2 >>> count_visible_flags(6, [1, 2, 3, 4, 5, 6]) 6 >>> count_visible_flags(4, [4, 1, 2, 3]) 1 >>> count_visible_flags(3, [10, 20, 30]) 3 >>> count_visible_flags(8, [8, 7, 6, 5, 4, 3, 2, 9]) 1","solution":"def count_visible_flags(n, heights): Function to count the number of buildings where flags can be placed. Parameters: n (int): Number of buildings. heights (list of int): Heights of the buildings. Returns: int: The number of buildings where flags can be placed. if n == 0: return 0 max_height = heights[0] flag_count = 1 # The first building always has a flag for i in range(1, n): if heights[i] > max_height: flag_count += 1 max_height = heights[i] return flag_count"},{"question":"from typing import List def compress_string(s: str) -> str: Compress the given string using run-length encoding. Args: s (str): The string to be compressed. Returns: str: The compressed string. >>> compress_string(\\"aaabbccccddddd\\") \\"a3b2c4d5\\" >>> compress_string(\\"abacabadabacaba\\") \\"abacabadabacaba\\"","solution":"def compress_string(s): Compress the given string using run-length encoding. Args: s (str): The string to be compressed. Returns: str: The compressed string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"def find_winner(s: str) -> str: Determines the game winner based on who removes the last vowel in the string. Args: s (str): The input string of lowercase English letters. Returns: str: \\"Player 1\\" if the first player to move wins, otherwise \\"Player 2\\". Examples: >>> find_winner(\\"a\\") 'Player 1' >>> find_winner(\\"ae\\") 'Player 2' >>> find_winner(\\"abcde\\") 'Player 2' >>> find_winner(\\"aei\\") 'Player 1' >>> find_winner(\\"abracadabra\\") 'Player 1' >>> find_winner(\\"bcdfg\\") 'Player 2' >>> find_winner(\\"hElloHOWareYOU\\") 'Player 1'","solution":"def find_winner(s): Determines the game winner based on who removes the last vowel. Args: s (str): the input string of lowercase English letters. Returns: str: \\"Player 1\\" if the first player to move wins, otherwise \\"Player 2\\". vowels = set('aeiou') vowel_count = sum(1 for c in s if c in vowels) return \\"Player 1\\" if vowel_count % 2 != 0 else \\"Player 2\\""},{"question":"class Book: def __init__(self, title, author, publication_year, genre, page_count): self.title = title self.author = author self.publication_year = int(publication_year) self.genre = genre self.page_count = int(page_count) def matches_filter(self, filters): for attr, value in filters.items(): if str(getattr(self, attr)) != value: return False return True def __str__(self): return f\\"{self.title} {self.author} {self.publication_year} {self.genre} {self.page_count}\\" def parse_input(input_str): lines = input_str.strip().split('n') p = int(lines[0]) books = [] for i in range(1, p + 1): books.append(Book(*lines[i].split())) q = int(lines[p + 1]) queries = lines[p + 2:] return books, queries def parse_query(query): filter_part, sort_part = query.rsplit(' ', 1) filters = {} for condition in filter_part.split(' AND '): attr, value = condition.split('=') filters[attr] = value return filters, sort_part def process_queries(books, queries): results = [] for query in queries: filters, sort_by = parse_query(query) filtered_books = [book for book in books if book.matches_filter(filters)] if not filtered_books: results.append(\\"No books found\\") else: filtered_books.sort(key=lambda x: getattr(x, sort_by)) results.append(\\"n\\".join(str(book) for book in filtered_books)) return \\"nn\\".join(results) def digital_library(input_str): You are designing a new database system called DigiLib for a digital library to manage books. Each book has several attributes, including title, author, publication year, genre, and page count. Your system must support dynamic queries that allow users to retrieve a list of books based on different combinations of these attributes. Each query has a filtering condition (based on one or more attributes) and a sorting condition (based on one attribute). You must implement a software that satisfies these query requirements. Query results should be returned in lexicographical order for string attributes and numerical order for numerical attributes. Args: input_str (str): A multiline string where the first line contains an integer p giving the number of books, the next p lines each contain a book, with the attributes: title, author, publication year, genre, and page count, separated by single spaces. The next line contains an integer q giving the number of queries. Each query consists of a filter condition and a sort condition. Returns: str: Output for each query, with each book printed in a new line with attributes separated by single spaces. Examples: >>> input_str = '''5 Harry_Potter_1 J.K.Rowling 1997 Fantasy 223 Harry_Potter_2 J.K.Rowling 1998 Fantasy 251 The_Hobbit J.R.R.Tolkien 1937 Fantasy 310 1984 George_Orwell 1949 Dystopian 328 To_Kill_a_Mockingbird Harper_Lee 1960 Fiction 281 1 author=J.K.Rowling AND publication_year=1998 title''' >>> digital_library(input_str) 'Harry_Potter_2 J.K.Rowling 1998 Fantasy 251' >>> input_str = '''5 Harry_Potter_1 J.K.Rowling 1997 Fantasy 223 Harry_Potter_2 J.K.Rowling 1998 Fantasy 251 The_Hobbit J.R.R.Tolkien 1937 Fantasy 310 1984 George_Orwell 1949 Dystopian 328 To_Kill_a_Mockingbird Harper_Lee 1960 Fiction 281 1 publication_year=2020 title''' >>> digital_library(input_str) 'No books found'","solution":"class Book: def __init__(self, title, author, publication_year, genre, page_count): self.title = title self.author = author self.publication_year = int(publication_year) self.genre = genre self.page_count = int(page_count) def matches_filter(self, filters): for attr, value in filters.items(): if str(getattr(self, attr)) != value: return False return True def __str__(self): return f\\"{self.title} {self.author} {self.publication_year} {self.genre} {self.page_count}\\" def parse_input(input_str): lines = input_str.strip().split('n') p = int(lines[0]) books = [] for i in range(1, p + 1): books.append(Book(*lines[i].split())) q = int(lines[p + 1]) queries = lines[p + 2:] return books, queries def parse_query(query): filter_part, sort_part = query.rsplit(' ', 1) filters = {} for condition in filter_part.split(' AND '): attr, value = condition.split('=') filters[attr] = value return filters, sort_part def process_queries(books, queries): results = [] for query in queries: filters, sort_by = parse_query(query) filtered_books = [book for book in books if book.matches_filter(filters)] if not filtered_books: results.append(\\"No books found\\") else: filtered_books.sort(key=lambda x: getattr(x, sort_by)) results.append(\\"n\\".join(str(book) for book in filtered_books)) return \\"nn\\".join(results) def digital_library(input_str): books, queries = parse_input(input_str) return process_queries(books, queries)"},{"question":"def closest_sum_to_target(n, target, weights): Returns the closest sum to the target weight without exceeding it. :param n: int, number of weights :param target: int, target weight :param weights: list of int, weights of objects :return: int, closest sum to the target weight >>> closest_sum_to_target(5, 50, [10, 20, 30, 40, 50]) 50 >>> closest_sum_to_target(3, 10, [8, 3, 12]) 10 >>> closest_sum_to_target(5, 17, [8, 4, 7, 1, 2]) 17 >>> closest_sum_to_target(4, 7, [1, 6, 4, 3]) 7 >>> closest_sum_to_target(3, 10, [8, 5, 12]) 8 >>> closest_sum_to_target(3, 12, [7, 4, 6]) 11 >>> closest_sum_to_target(4, 5, [10, 20, 30, 40]) 0 >>> closest_sum_to_target(1, 0, []) 0","solution":"def closest_sum_to_target(n, target, weights): Returns the closest sum to the target weight without exceeding it. :param n: int, number of weights :param target: int, target weight :param weights: list of int, weights of objects :return: int, closest sum to the target weight possible_sums = {0} for weight in weights: new_sums = set() for s in possible_sums: if s + weight <= target: new_sums.add(s + weight) possible_sums.update(new_sums) return max(possible_sums)"},{"question":"def zigzagSequence(n): Generates the first n terms of the Zigzag Sequence. Parameters: n (int): Number of terms in the sequence Returns: list: A list containing the first n terms of the Zigzag sequence Example: >>> zigzagSequence(5) [1, 0, 2, 1, 3] >>> zigzagSequence(3) [1, 0, 2]","solution":"def zigzagSequence(n): Generates the first n terms of the Zigzag Sequence. Parameters: n (int): Number of terms in the sequence Returns: list: A list containing the first n terms of the Zigzag sequence if n == 1: return [1] sequence = [1] current_value = 1 for i in range(1, n): if i % 2 == 1: current_value -= 1 else: current_value += 2 sequence.append(current_value) return sequence"},{"question":"def count_divisible_pairs(N: int, M: int, A: List[int]) -> int: Given an array of integers of length N, A = [A_1, A_2, ..., A_N], and an integer M, determine the number of distinct pairs (i, j) where 1 <= i < j <= N such that (A_i + A_j) is divisible by M. pass def test_sample_input(): assert count_divisible_pairs(5, 4, [1, 2, 3, 4, 5]) == 2 def test_no_pairs(): assert count_divisible_pairs(3, 5, [1, 1, 1]) == 0 def test_all_pairs(): assert count_divisible_pairs(3, 1, [1, 1, 1]) == 3 def test_large_numbers(): assert count_divisible_pairs(5, 7, [14, 21, 35, 7, 28]) == 10 def test_even_m(): assert count_divisible_pairs(4, 10, [10, 20, 30, 40]) == 6 def test_single_pair(): assert count_divisible_pairs(2, 3, [2, 4]) == 1","solution":"def count_divisible_pairs(N, M, A): Returns the number of distinct pairs (i, j) where 1 <= i < j <= N such that (A[i] + A[j]) is divisible by M. remainder_count = [0] * M # Count frequencies of each remainder for num in A: remainder_count[num % M] += 1 total_pairs = 0 # Count pairs with remainders summing to 0 mod M total_pairs += (remainder_count[0] * (remainder_count[0] - 1)) // 2 # Count pairs of other complements for i in range(1, (M // 2) + 1): if i != M - i: total_pairs += remainder_count[i] * remainder_count[M - i] # For the middle element when M is even if M % 2 == 0: total_pairs += (remainder_count[M // 2] * (remainder_count[M // 2] - 1)) // 2 return total_pairs def parse_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) A = list(map(int, data[2:2+N])) return N, M, A if __name__ == \\"__main__\\": N, M, A = parse_input() print(count_divisible_pairs(N, M, A))"},{"question":"def rearrangeString(s: str) -> str: Rearranges the characters in the string s such that no two adjacent characters are the same. If it is not possible to rearrange, returns an empty string. >>> rearrangeString(\\"aabb\\") in {\\"abab\\", \\"baba\\"} True >>> rearrangeString(\\"aaab\\") \\"\\"","solution":"from collections import Counter import heapq def rearrangeString(s): Rearranges the characters in the string s such that no two adjacent characters are the same. If it is not possible to rearrange, returns an empty string. # Counter to count frequencies of each character count = Counter(s) # max-heap to store characters by frequency max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq: if prev_freq: # It's not possible to organize if not max_heap: return \\"\\" freq, char = heapq.heappop(max_heap) # append current character to the result result.append(char) # we have used one instance of this character if prev_freq: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 return \\"\\".join(result)"},{"question":"def is_balanced_parentheses(s: str) -> bool: Check if a string of parentheses is balanced. >>> is_balanced_parentheses(\\"()()\\") True >>> is_balanced_parentheses(\\"(())\\") True >>> is_balanced_parentheses(\\"(()\\") False >>> is_balanced_parentheses(\\"())(\\") False >>> is_balanced_parentheses(\\"\\") True","solution":"def is_balanced_parentheses(s: str) -> bool: Check if a string of parentheses is balanced. Parameters: s (str): A string containing only characters '(' and ')'. Returns: bool: True if the string is balanced, False otherwise. # Initialize a counter to keep track of the balance balance = 0 for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance goes negative, it means there are more closing parenthesis than opening if balance < 0: return False # In the end, the balance should be zero for the string to be balanced return balance == 0"},{"question":"def fibonacci_representation(n: int) -> List[int]: Returns the representation of the number n as a sum of distinct Fibonacci numbers in decreasing order. >>> fibonacci_representation(10) == [8, 2] >>> fibonacci_representation(19) == [13, 5, 1] >>> fibonacci_representation(100) == [89, 8, 3] >>> fibonacci_representation(1) == [1] >>> fibonacci_representation(2) == [2] >>> fibonacci_representation(21) == [21] pass","solution":"def fibonacci_representation(n): Returns the representation of the number n as a sum of distinct Fibonacci numbers in decreasing order. # Generate the Fibonacci sequence up to n fib_sequence = [1, 2] while fib_sequence[-1] <= n: fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) # Remove the last number if it is greater than n if fib_sequence[-1] > n: fib_sequence.pop() # Find the representation representation = [] for fib in reversed(fib_sequence): if n >= fib: representation.append(fib) n -= fib return representation"},{"question":"def num_decodings(s: str) -> int: Given a string of digits, return the total number of ways to decode it. Each digit or two-digit number can represent a letter of the alphabet, where 1 corresponds to 'A', 2 corresponds to 'B', up to 26 corresponding to 'Z'. Args: s (str): The string of digits to be decoded. Returns: int: The total number of different decoding ways. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"2101\\") 1 # Your code here def decode_ways(t: int, test_cases: List[str]) -> List[int]: Given a number of test cases, return the total number of ways to decode each string. Args: t (int): The number of test cases. test_cases (List[str]): A list containing the test case strings of digits. Returns: List[int]: A list containing the total number of decoding ways for each test case. >>> decode_ways(4, [\\"12\\", \\"226\\", \\"0\\", \\"2101\\"]) [2, 3, 0, 1] # Your code here # Unit Tests def test_num_decodings_single_digit(): assert num_decodings(\\"1\\") == 1 assert num_decodings(\\"2\\") == 1 assert num_decodings(\\"0\\") == 0 def test_num_decodings_double_digit(): assert num_decodings(\\"10\\") == 1 assert num_decodings(\\"12\\") == 2 assert num_decodings(\\"26\\") == 2 assert num_decodings(\\"20\\") == 1 assert num_decodings(\\"27\\") == 1 def test_num_decodings_multiple_digits(): assert num_decodings(\\"123\\") == 3 assert num_decodings(\\"226\\") == 3 assert num_decodings(\\"2101\\") == 1 assert num_decodings(\\"111\\") == 3 def test_decode_ways(): assert decode_ways(4, [\\"12\\", \\"226\\", \\"0\\", \\"2101\\"]) == [2, 3, 0, 1] def test_decode_ways_edge_cases(): assert decode_ways(2, [\\"\\", \\"101\\"]) == [0, 1]","solution":"def num_decodings(s): if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n] def decode_ways(t, test_cases): results = [] for case in test_cases: results.append(num_decodings(case)) return results"},{"question":"def calculate_coolness(word: str) -> int: Calculate the coolness of a word based on the number of unique letters and the length of the word. Each letter is considered case-insensitively. >>> calculate_coolness(\\"Hello\\") 20 >>> calculate_coolness(\\"World\\") 25 >>> calculate_coolness(\\"Programming\\") 88 >>> calculate_coolness(\\"aAaA\\") 4 >>> calculate_coolness(\\"Python\\") 36 def coolness_of_words(test_cases: List[str]) -> List[int]: Determines the coolness for each word in the provided list of test cases. Parameters: test_cases (list): List of words to determine the coolness Returns: list: List of coolness values for each word in the order they are provided >>> coolness_of_words([\\"Hello\\", \\"World\\", \\"Programming\\"]) [20, 25, 88] >>> coolness_of_words([\\"aAaA\\", \\"Python\\"]) [4, 36] from collections import Counter import math # Unit Test def test_calculate_coolness(): assert calculate_coolness(\\"Hello\\") == 20 assert calculate_coolness(\\"World\\") == 25 assert calculate_coolness(\\"Programming\\") == 88 assert calculate_coolness(\\"aAaA\\") == 4 assert calculate_coolness(\\"Python\\") == 36 def test_coolness_of_words(): test_cases = [\\"Hello\\", \\"World\\", \\"Programming\\"] expected_output = [20, 25, 88] assert coolness_of_words(test_cases) == expected_output test_cases = [\\"aAaA\\", \\"Python\\"] expected_output = [4, 36] assert coolness_of_words(test_cases) == expected_output","solution":"def calculate_coolness(word): Calculate the coolness of a word based on the number of unique letters and the length of the word. Each letter is considered case-insensitively. word_lowercase = word.lower() unique_letters = set(word_lowercase) unique_count = len(unique_letters) word_length = len(word) coolness = unique_count * word_length return coolness def coolness_of_words(test_cases): Determines the coolness for each word in the provided list of test cases. Parameters: test_cases (list): List of words to determine the coolness Returns: list: List of coolness values for each word in the order they are provided results = [] for word in test_cases: coolness = calculate_coolness(word) results.append(coolness) return results"},{"question":"def available_employees(schedules, start_time, end_time): Returns the list of employees who are available during the given time range. Parameters: - schedules: Dictionary with employee names as keys and list of \\"HH:MM-HH:MM\\" strings as values. - start_time: Start time of the range (inclusive), in the format \\"HH:MM\\". - end_time: End time of the range (exclusive), in the format \\"HH:MM\\". Returns: - List of employee names who are available during the given time range. Example: >>> schedules = { >>> \\"Alice\\": [\\"09:00-10:00\\", \\"12:00-13:00\\"], >>> \\"Bob\\": [\\"09:30-10:30\\", \\"13:00-14:00\\"], >>> \\"Charlie\\": [\\"11:00-12:00\\", \\"14:00-15:00\\"] >>> } >>> start_time = \\"10:00\\" >>> end_time = \\"11:00\\" >>> available_employees(schedules, start_time, end_time) [\\"Alice\\", \\"Charlie\\"]","solution":"def available_employees(schedules, start_time, end_time): Returns the list of employees who are available during the given time range. Parameters: - schedules: Dictionary with employee names as keys and list of \\"HH:MM-HH:MM\\" strings as values. - start_time: Start time of the range (inclusive), in the format \\"HH:MM\\". - end_time: End time of the range (exclusive), in the format \\"HH:MM\\". Returns: - List of employee names who are available during the given time range. available = [] for employee, times in schedules.items(): is_available = True for time_range in times: schedule_start, schedule_end = time_range.split('-') if not (end_time <= schedule_start or start_time >= schedule_end): is_available = False break if is_available: available.append(employee) return available"},{"question":"from typing import List, Dict def calculate_expenses(transactions: List[str]) -> Dict[str, float]: Returns a dictionary with categories as keys and total amounts spent as values. >>> calculate_expenses([ ... \\"01-08-2021 Groceries 50.75\\", ... \\"01-08-2021 Entertainment 15.20\\", ... \\"02-08-2021 Groceries 30.90\\", ... \\"03-08-2021 Bills 100.00\\", ... \\"03-08-2021 Entertainment 25.00\\", ... ]) == { ... \\"Groceries\\": 81.65, ... \\"Entertainment\\": 40.20, ... \\"Bills\\": 100.00 ... } >>> calculate_expenses([]) == {} def format_expenses(expense_dict: Dict[str, float]) -> List[str]: Formats the expense dictionary into a list of strings suitable for printing. >>> format_expenses({ ... \\"Groceries\\": 81.65, ... \\"Entertainment\\": 40.20, ... \\"Bills\\": 100.00 ... }) == [ ... \\"Groceries 81.65\\", ... \\"Entertainment 40.20\\", ... \\"Bills 100.00\\" ... ] >>> format_expenses({}) == [] def main(): import sys input = sys.stdin.read # Reading input data = input().strip().split(\\"n\\") n = int(data[0]) transactions = data[1:] # Calculating expenses expenses = calculate_expenses(transactions) # Formatting and printing expenses formatted_expenses = format_expenses(expenses) for expense in formatted_expenses: print(expense) if __name__ == \\"__main__\\": main()","solution":"def calculate_expenses(transactions): Returns a dictionary with categories as keys and total amounts spent as values. expense_dict = {} for transaction in transactions: _, category, amount = transaction.split(\\" \\", 2) amount = float(amount) if category in expense_dict: expense_dict[category] += amount else: expense_dict[category] = amount return expense_dict def format_expenses(expense_dict): Formats the expense dictionary into a list of strings suitable for printing. formatted_expenses = [] for category, amount in expense_dict.items(): formatted_expenses.append(f\\"{category} {amount:.2f}\\") return formatted_expenses"},{"question":"def min_weight_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible weight difference after all moves are considered. t: int - number of test cases test_cases: List of tuples, each tuple contains an integer n and a list of n integers representing the weights of the books. Returns a list of integers where each integer represents the minimum possible weight difference for the respective test case. >>> min_weight_difference(1, [(3, [3, 2, 1])]) [1] >>> min_weight_difference(2, [(3, [3, 2, 1]), (4, [4, 1, 3, 2])]) [1, 1] >>> min_weight_difference(1, [(3, [5, 5, 5])]) [0] >>> min_weight_difference(1, [(4, [1, 100, 500, 1000])]) [99] >>> min_weight_difference(1, [(6, [10, 20, 30, 40, 50, 5])]) [5] >>> min_weight_difference(1, [(1, [10])]) [float('inf')] >>> min_weight_difference(1, [(2, [10, 40])]) [30]","solution":"def min_weight_difference(t, test_cases): results = [] for case in test_cases: n, weights = case weights.sort() min_diff = float('inf') for i in range(1, n): min_diff = min(min_diff, abs(weights[i] - weights[i - 1])) results.append(min_diff) return results"},{"question":"def longest_t1(s: str) -> str: Returns the longest string t1 such that t1 concatenated with itself forms a substring of the given string s. >>> longest_t1(\\"abcabcabcabc\\") \\"abcabc\\" >>> longest_t1(\\"xyxyxyxyz\\") \\"xyxy\\" >>> longest_t1(\\"aaaaaa\\") \\"aaa\\" >>> longest_t1(\\"abcdefg\\") \\"\\" >>> longest_t1(\\"aaaaa\\") \\"aa\\" >>> longest_t1(\\"abcdefghij\\") \\"\\" >>> longest_t1(\\"abababab\\") \\"abab\\"","solution":"def longest_t1(s): Returns the longest string t1 such that t1 concatenated with itself forms a substring of the given string s. n = len(s) # Try lengths from n//2 to 1 for length in range(n//2, 0, -1): t1 = s[:length] if t1 + t1 in s: return t1 return ''"},{"question":"def is_possible_formation(n: int, points: List[Tuple[int, int]]) -> str: Determines if it is possible to create a formation such that every point is connected to exactly two other points and no two lines intersect except at the points. Args: n (int): Number of points. points (List[Tuple[int, int]]): A list of tuples representing the coordinates of each point. Returns: str: \\"POSSIBLE\\" if the formation is possible, otherwise \\"IMPOSSIBLE\\". >>> is_possible_formation(4, [(0, 0), (2, 2), (2, 0), (0, 2)]) == \\"POSSIBLE\\" >>> is_possible_formation(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == \\"IMPOSSIBLE\\"","solution":"def is_possible_formation(n, points): Determines if it is possible to create a formation such that every point is connected to exactly two other points in a way that no two lines intersect except at the points. # For this specific problem, the key observation is that the number of points # (n) must be even to arrange them in a cycle where each point is connected to # exactly two other points without any intersections. if n % 2 == 0: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def unique_items_in_baskets(T, baskets): Returns the total number of unique items across all gift baskets. :param T: int - the number of gift baskets :param baskets: list of lists - each inner list contains items in a basket :return: int - the number of unique items def parse_input(input_list): Parses the input in the required format and returns T and baskets :param input_list: list of strings - raw input lines :return: tuple(int, list of lists) - T and baskets def test_unique_items_in_baskets(): T = 3 baskets = [ [\\"apple\\", \\"banana\\", \\"orange\\", \\"mango\\"], [\\"banana\\", \\"grape\\", \\"apple\\"], [\\"pear\\", \\"mango\\"] ] assert unique_items_in_baskets(T, baskets) == 6 def test_unique_items_in_baskets_with_repeated_items(): T = 2 baskets = [ [\\"apple\\", \\"apple\\", \\"banana\\"], [\\"banana\\", \\"banana\\", \\"banana\\"] ] assert unique_items_in_baskets(T, baskets) == 2 def test_input_parser(): input_data = [ \\"3\\", \\"4 apple banana orange mango\\", \\"3 banana grape apple\\", \\"2 pear mango\\" ] T, baskets = parse_input(input_data) assert T == 3 assert baskets == [ [\\"apple\\", \\"banana\\", \\"orange\\", \\"mango\\"], [\\"banana\\", \\"grape\\", \\"apple\\"], [\\"pear\\", \\"mango\\"] ] def test_combined(): input_data = [ \\"3\\", \\"4 apple banana orange mango\\", \\"3 banana grape apple\\", \\"2 pear mango\\" ] T, baskets = parse_input(input_data) assert unique_items_in_baskets(T, baskets) == 6","solution":"def unique_items_in_baskets(T, baskets): Returns the total number of unique items across all gift baskets. :param T: int - the number of gift baskets :param baskets: list of lists - each inner list contains items in a basket :return: int - the number of unique items unique_items = set() for basket in baskets: for item in basket: unique_items.add(item) return len(unique_items) def parse_input(input_list): Parses the input in the required format and returns T and baskets :param input_list: list of strings - raw input lines :return: tuple(int, list of lists) - T and baskets T = int(input_list[0]) baskets = [line.split()[1:] for line in input_list[1:]] return T, baskets"},{"question":"from typing import List, Tuple def calculate_average_pollution(P: int, Q: int, grid: List[List[int]], sub_grids: List[Tuple[int, int, int, int]]) -> List[str]: Calculate the average pollution levels within specified sub-grids. The first line contains two integers P and Q indicating the number of rows and columns in the city grid. Each of the next P lines contains Q integers, where each integer represents the pollution level in that sector. The following line contains an integer T representing the number of sub-grids for which the average pollution level needs to be calculated. The next T lines each contain four integers a1, b1, a2, b2 (with a1  a2 and b1  b2), representing the top-left and bottom-right coordinates of a sub-grid. >>> calculate_average_pollution(3, 3, [ ... [12, 15, 9], ... [8, 10, 17], ... [5, 14, 7] ... ], [(1, 1, 2, 2)]) ['11.25'] >>> calculate_average_pollution(3, 3, [ ... [12, 15, 9], ... [8, 10, 17], ... [5, 14, 7] ... ], [(1, 1, 2, 2), (2, 2, 3, 3)]) ['11.25', '12.00'] >>> calculate_average_pollution(3, 3, [ ... [12, 15, 9], ... [8, 10, 17], ... [5, 14, 7] ... ], [(2, 2, 2, 2)]) ['10.00'] >>> calculate_average_pollution(3, 3, [ ... [12, 15, 9], ... [8, 10, 17], ... [5, 14, 7] ... ], [(1, 1, 3, 3)]) ['10.78']","solution":"def calculate_average_pollution(P, Q, grid, sub_grids): results = [] for sub_grid in sub_grids: a1, b1, a2, b2 = sub_grid total_pollution = 0 count = 0 for i in range(a1 - 1, a2): for j in range(b1 - 1, b2): total_pollution += grid[i][j] count += 1 average = total_pollution / count results.append(f\\"{average:.2f}\\") return results"},{"question":"def knapsack_max_value(W, N, items): Determines the maximum value of items that can be carried without exceeding the weight limit. Parameters: W (int): Maximum weight that can be carried. N (int): Number of items available. items (list of tuples): List of (weight, value) pairs for each item. Returns: int: Maximum value of items that can be carried without exceeding the weight limit. >>> knapsack_max_value(50, 3, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack_max_value(50, 0, []) 0 >>> knapsack_max_value(15, 3, [(10, 60), (20, 100), (30, 120)]) 60 >>> knapsack_max_value(40, 2, [(20, 100), (20, 100)]) 200 >>> knapsack_max_value(10, 1, [(5, 50)]) 50","solution":"def knapsack_max_value(W, N, items): Determines the maximum value of items that can be carried without exceeding the weight limit. Parameters: W (int): Maximum weight that can be carried. N (int): Number of items available. items (list of tuples): List of (weight, value) pairs for each item. Returns: int: Maximum value of items that can be carried without exceeding the weight limit. # Initialize a DP table with dimensions (N+1) x (W+1) dp = [[0] * (W + 1) for _ in range(N + 1)] # Populate the DP table for i in range(1, N + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] # The maximum value is found at dp[N][W] return dp[N][W]"},{"question":"def is_safe_path_exists(grid): Determines if there is a safe path from the top-left corner to the bottom-right corner of the grid. >>> is_safe_path_exists([ ... [0, 0, 1, 0, 1], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0] ... ]) == \\"true\\" >>> is_safe_path_exists([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) == \\"false\\" >>> is_safe_path_exists([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == \\"false\\" >>> is_safe_path_exists([ ... [0] ... ]) == \\"true\\" >>> is_safe_path_exists([ ... [1] ... ]) == \\"false\\" >>> is_safe_path_exists([[0]*999 + [1]] * 999 + [[0] * 1000]) ... == \\"true\\"","solution":"def is_safe_path_exists(grid): Determines if there is a safe path from the top-left corner to the bottom-right corner of the grid. from collections import deque M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return \\"false\\" directions = [(1, 0), (0, 1)] # Down, Right visited = [[False] * N for _ in range(M)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == M - 1 and y == N - 1: return \\"true\\" for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if 0 <= new_x < M and 0 <= new_y < N and not visited[new_x][new_y] and grid[new_x][new_y] == 0: visited[new_x][new_y] = True queue.append((new_x, new_y)) return \\"false\\""},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Return the zigzag level order traversal of a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]] >>> zigzagLevelOrder(TreeNode(1)) [[1]] >>> zigzagLevelOrder(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagLevelOrder(root) [[1], [3, 2]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5]]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [] next_level = [] for node in current_level: level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() result.append(level_values) current_level = next_level left_to_right = not left_to_right return result"},{"question":"def max_length_unique_subarray(arr): Returns the maximum length of a contiguous subarray with all unique elements. >>> max_length_unique_subarray([5]) == 1 >>> max_length_unique_subarray([1, 2, 3, 4, 5, 6]) == 6 >>> max_length_unique_subarray([2, 2, 2, 2, 2]) == 1 >>> max_length_unique_subarray([2, 3, 2, 4, 5]) == 4 >>> max_length_unique_subarray([1, 2, 3, 4, 5, 6]) == 6 >>> max_length_unique_subarray([2, 1, 3, 1, 2, 3, 4]) == 4 >>> max_length_unique_subarray([1, 2, 3, 1, 2, 3, 4, 5]) == 5","solution":"def max_length_unique_subarray(arr): Returns the maximum length of a contiguous subarray with all unique elements. start = 0 max_len = 0 seen = {} for end in range(len(arr)): if arr[end] in seen and seen[arr[end]] >= start: start = seen[arr[end]] + 1 seen[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def is_strong_password(password: str) -> str: Determines if the given password is strong based on specific criteria. A strong password must: 1. Be at least 8 characters long. 2. Contain at least one lowercase letter, one uppercase letter, and one digit. 3. Have at least one special character from the set: \\"!@#%^&*()-+\\". Args: password (str): The password to be checked. Returns: str: \\"STRONG\\" if the password meets all criteria, \\"WEAK\\" otherwise. >>> is_strong_password(\\"1faB9#c1d\\") 'STRONG' >>> is_strong_password(\\"abc123\\") 'WEAK' >>> is_strong_password(\\"A1!aaaaa\\") 'WEAK' >>> is_strong_password(\\"Ab1!Az@Y\\") 'STRONG'","solution":"def is_strong_password(password): Determines if the given password is strong based on specific criteria. Args: password (str): The password to be checked. Returns: str: \\"STRONG\\" if the password meets all criteria, \\"WEAK\\" otherwise. if len(password) < 8: return \\"WEAK\\" has_lower = has_upper = has_digit = has_special = False special_characters = \\"!@#%^&*()-+\\" for char in password: if char.islower(): has_lower = True elif char.isupper(): has_upper = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True if has_lower and has_upper and has_digit and has_special: return \\"STRONG\\" return \\"WEAK\\""},{"question":"def findPositionsOfTarget(M: int, scores: List[int], target: int) -> Tuple[int, int]: Returns a tuple containing the first and last positions of the target score in the sorted list of scores. >>> findPositionsOfTarget(8, [1, 3, 3, 5, 5, 5, 7, 8], 5) (3, 5) >>> findPositionsOfTarget(5, [1, 2, 3, 4, 5], 3) (2, 2) >>> findPositionsOfTarget(5, [1, 2, 3, 4, 5], 6) (-1, -1) >>> findPositionsOfTarget(5, [5, 5, 5, 5, 5], 5) (0, 4) >>> findPositionsOfTarget(0, [], 5) (-1, -1) >>> findPositionsOfTarget(1, [5], 5) (0, 0) >>> findPositionsOfTarget(1, [4], 5) (-1, -1)","solution":"def findPositionsOfTarget(M, scores, target): Returns a tuple containing the first and last positions of the target score in the sorted list of scores. scores.sort() first_position = -1 last_position = -1 for i in range(M): if scores[i] == target: if first_position == -1: first_position = i last_position = i return (first_position, last_position)"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Calculate the minimum number of moves required for the spaceship to reach the bottom-right corner of the grid from the top-left corner. If the bottom-right corner is unreachable, return -1. Args: grid (List[List[int]]): 2D list representing the grid. Returns: int: Minimum number of moves required to reach the bottom-right corner, or -1 if unreachable. Example: >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid) 4","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) if grid[0][0] != 0 or grid[rows-1][cols-1] != 0: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == rows-1 and col == cols-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def alice_wins(T, cases): Determines if Alice can guarantee a win given the initial configurations of the stacks. Args: T: Number of test cases. cases: List of tuples (a, b) where a and b are the number of stones in the two stacks. Returns: List of strings \\"Alice\\" or \\"Bob\\" for each test case. >>> alice_wins(3, [(1, 1), (2, 3), (5, 4)]) [\\"Bob\\", \\"Alice\\", \\"Alice\\"] >>> alice_wins(3, [(3, 3), (6, 9), (10, 20)]) [\\"Bob\\", \\"Alice\\", \\"Alice\\"] >>> alice_wins(3, [(1000000000, 1000000000), (2000000000, 1000000000), (500000000, 400000000)]) [\\"Bob\\", \\"Alice\\", \\"Alice\\"] >>> alice_wins(2, [(1, 10**9), (10**9, 10**9)]) [\\"Alice\\", \\"Bob\\"]","solution":"def alice_wins(T, cases): Determines if Alice can guarantee a win given the initial configurations of the stacks. Args: T: Number of test cases. cases: List of tuples (a, b) where a and b are the number of stones in the two stacks. Returns: List of strings \\"Alice\\" or \\"Bob\\" for each test case. results = [] for a, b in cases: if a + b == max(a, b) * 2: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results # To call: alice_wins(T, [(a1, b1), (a2, b2), ...])"},{"question":"def permutations(n: int, r: int) -> int: Returns the number of permutations of n items taken r at a time. >>> permutations(5, 3) == 60 >>> permutations(4, 4) == 24 >>> permutations(10, 2) == 90 >>> permutations(10, 0) == 1 # Anything taken 0 at a time should be 1 >>> permutations(10, 10) == 3628800 # 10! >>> permutations(0, 0) == 1 # 0! = 1 as a special case >>> permutations(1000, 1000) == 641419708 # This is 1000! % 1000000007 def solve_permutations(test_cases: List[Tuple[int, int]]) -> List[int]: Solves permutations for a list of test cases. >>> solve_permutations([(5, 3), (4, 4)]) == [60, 24] >>> solve_permutations([(10, 2), (6, 0)]) == [90, 1]","solution":"def permutations(n, r): Returns the number of permutations of n items taken r at a time. MOD = 1000000007 if r > n: return 0 result = 1 for i in range(n, n-r, -1): result = (result * i) % MOD return result def solve_permutations(test_cases): results = [] for n, r in test_cases: results.append(permutations(n, r)) return results if __name__ == \\"__main__\\": t = int(input().strip()) test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)] results = solve_permutations(test_cases) for result in results: print(result)"},{"question":"def are_readings_within_range(readings, lower_bound, upper_bound): Determines if all temperature readings are within the given range [lower_bound, upper_bound]. Args: readings (list of int): The list of temperature readings. lower_bound (int): The lower bound of the desired temperature range. upper_bound (int): The upper bound of the desired temperature range. Returns: bool: True if all readings are within the range, False otherwise. Examples: >>> are_readings_within_range([23, 25, 24, 22, 26], 20, 27) True >>> are_readings_within_range([19, 25, 24, 22, 26], 20, 27) False >>> are_readings_within_range([20, 27], 20, 27) True","solution":"def are_readings_within_range(readings, lower_bound, upper_bound): Determines if all temperature readings are within the given range [lower_bound, upper_bound]. Args: readings (list of int): The list of temperature readings. lower_bound (int): The lower bound of the desired temperature range. upper_bound (int): The upper bound of the desired temperature range. Returns: bool: True if all readings are within the range, False otherwise. for reading in readings: if reading < lower_bound or reading > upper_bound: return False return True"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of two numbers in nums such that they add up to target. If no such numbers exist, returns [-1, -1]. Args: nums: List of integers. target: The target sum. Returns: List containing two indices of the numbers that add up to the target. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 6) [1, 3] >>> two_sum([1, 2, 3, 4], 8) [-1, -1] >>> two_sum([1, 2], 3) [0, 1] >>> two_sum([1000000000, -1000000000], 0) [0, 1] >>> two_sum([-3, 4, 3, 90], 0) [0, 2]","solution":"def two_sum(nums, target): Returns the indices of two numbers in nums such that they add up to target. If no such numbers exist, returns [-1, -1]. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return [-1, -1]"},{"question":"from typing import List def countIslands(grid: List[List[str]]) -> int: Count the number of distinct islands in the grid. An island is formed by connecting adjacent lands horizontally or vertically. Parameters: grid (List[List[str]]): A 2D list representing the island where 'L' represents land and 'W' represents water. Returns: int: The number of distinct islands in the grid. Examples: >>> countIslands([['L', 'L', 'W', 'L', 'L'], ['L', 'W', 'W', 'L', 'W'], ['W', 'W', 'W', 'L', 'L'], ['L', 'L', 'L', 'W', 'L']]) 3 >>> countIslands([['L', 'L', 'L'], ['L', 'W', 'L'], ['L', 'L', 'L']]) 1 >>> countIslands([['L', 'W', 'L', 'W', 'L']]) 3","solution":"from typing import List def countIslands(grid: List[List[str]]) -> int: if not grid: return 0 n = len(grid) m = len(grid[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 'W': return grid[x][y] = 'W' # Mark as visited # Explore all four possible directions (up, down, left, right) dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': island_count += 1 dfs(i, j) return island_count"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): A list of integers k (int): Number of steps to rotate the array Returns: list: A new list that is rotated by k steps to the right >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([], 3) [] >>> rotate_array([1], 3) [1] >>> rotate_array([1, 2, 3, 4, 5], 100000) [1, 2, 3, 4, 5]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): A list of integers k (int): Number of steps to rotate the array Returns: list: A new list that is rotated by k steps to the right n = len(arr) if n == 0: return arr k = k % n return arr[-k:] + arr[:-k]"},{"question":"def maximum_skill_difference(n: int, skills: List[int], T: int) -> int: Calculate the maximum skill difference among the team members while ensuring the total skill score of the team does not exceed a given limit. >>> maximum_skill_difference(5, [1, 2, 3, 4, 5], 9) 4 >>> maximum_skill_difference(4, [5, 8, 12, 14], 15) 3","solution":"def maximum_skill_difference(n, skills, T): skills.sort() max_diff = -1 for i in range(n): for j in range(i + 1, n): team_score = skills[i] + skills[j] if team_score <= T: max_diff = max(max_diff, skills[j] - skills[i]) else: break return max_diff"},{"question":"class IntegerList: A class to efficiently manage a list of non-negative integers with operations to insert, delete, and query counts. Methods: - insert(x): Insert integer x to the list. If x already exists, increment its count. - delete(x): Decrement the count of x by 1. If the count becomes 0, remove x. - query(x): Return the count of x in the list. Example: >>> ilist = IntegerList() >>> ilist.insert(3) >>> ilist.insert(3) >>> ilist.insert(5) >>> ilist.query(3) 2 >>> ilist.query(5) 1 >>> ilist.delete(3) >>> ilist.query(3) 1 >>> ilist.delete(5) >>> ilist.query(5) 0 def __init__(self): pass def insert(self, x): pass def delete(self, x): pass def query(self, x): pass def test_insert(): ilist = IntegerList() ilist.insert(3) assert ilist.query(3) == 1 ilist.insert(3) assert ilist.query(3) == 2 def test_delete(): ilist = IntegerList() ilist.insert(5) ilist.insert(5) ilist.insert(5) ilist.delete(5) assert ilist.query(5) == 2 ilist.delete(5) assert ilist.query(5) == 1 ilist.delete(5) assert ilist.query(5) == 0 ilist.delete(5) assert ilist.query(5) == 0 # Deleting non-existing element def test_query(): ilist = IntegerList() assert ilist.query(10) == 0 # Querying non-existing element ilist.insert(7) assert ilist.query(7) == 1 ilist.delete(7) assert ilist.query(7) == 0 def test_combined(): ilist = IntegerList() ilist.insert(3) ilist.insert(3) ilist.insert(5) assert ilist.query(3) == 2 assert ilist.query(5) == 1 ilist.delete(3) assert ilist.query(3) == 1 ilist.delete(5) assert ilist.query(5) == 0","solution":"class IntegerList: def __init__(self): self.elements = {} def insert(self, x): if x in self.elements: self.elements[x] += 1 else: self.elements[x] = 1 def delete(self, x): if x in self.elements: if self.elements[x] > 1: self.elements[x] -= 1 else: del self.elements[x] def query(self, x): return self.elements.get(x, 0)"},{"question":"def anagram_pairs(strs): Returns the number of pairs of indices (i, j) (i < j) such that the strings at those indices are anagrams of each other. :param strs: List of strings :return: Number of anagram pairs as integer >>> anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\"]) == 4 >>> anagram_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) == 0 >>> anagram_pairs([\\"abc\\", \\"bca\\", \\"cab\\"]) == 3 >>> anagram_pairs([\\"abcd\\", \\"dcba\\", \\"efgh\\", \\"hgfe\\", \\"ijkl\\"]) == 2 >>> anagram_pairs([\\"abcd\\"]) == 0 >>> anagram_pairs([]) == 0 >>> anagram_pairs([\\"abcd\\", \\"abcd\\", \\"abcd\\"]) == 3","solution":"def anagram_pairs(strs): Returns the number of pairs of indices (i, j) (i < j) such that the strings at those indices are anagrams of each other. :param strs: List of strings :return: Number of anagram pairs as integer def sorted_string(s): return ''.join(sorted(s)) sorted_strs = [sorted_string(s) for s in strs] count = 0 for i in range(len(sorted_strs)): for j in range(i + 1, len(sorted_strs)): if sorted_strs[i] == sorted_strs[j]: count += 1 return count"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},P={key:0,class:"empty-state"},z=["disabled"],D={key:0},F={key:1};function I(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")},"  ")):l("",!0)]),t("div",C,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",F,"Loading...")):(s(),n("span",D,"See more"))],8,z)):l("",!0)])}const M=m(E,[["render",I],["__scopeId","data-v-1bb230f8"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/36.md","filePath":"guide/36.md"}'),O={name:"guide/36.md"},U=Object.assign(O,{setup(i){return(e,u)=>(s(),n("div",null,[w(M)]))}});export{B as __pageData,U as default};
