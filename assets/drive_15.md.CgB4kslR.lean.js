import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},A={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-1d4b5e60"]]),N=JSON.parse('[{"question":"# Question Context: You have been requested to develop a utility for encoding and decoding strings using a simple character shifting algorithm. This task will test your ability to implement string manipulation and basic encryption techniques. Problem Statement: Define two functions `encode_string(s: str, shift: int) -> str` and `decode_string(s: str, shift: int) -> str` that perform character shifting to encode and decode a string, respectively. The encoding shifts each character in the string `s` forward by `shift` positions in the alphabet, wrapping around if necessary. The decoding function reverses the process. Function Signatures: ```python def encode_string(s: str, shift: int) -> str: pass def decode_string(s: str, shift: int) -> str: pass ``` Input: * A string `s` comprised of lowercase English letters (1 ≤ `len(s)` ≤ 10^5). * An integer `shift` (0 ≤ `shift` < 26) - the number of positions each character in the string should be shifted. Output: * A string representing the encoded or decoded result. Constraints: 1. Handle edge cases where `s` is very small (e.g., `len(s) = 1`) or very large (e.g., `len(s) = 10^5`). 2. Ensure the `shift` value is within the specified range. 3. Optimize your solution for performance with respect to both encoding and decoding large strings. Performance Requirements: * Your solution should run efficiently for the maximum possible string length. Example: ```python assert encode_string(\\"abc\\", 1) == \\"bcd\\" assert encode_string(\\"xyz\\", 2) == \\"zab\\" assert decode_string(\\"bcd\\", 1) == \\"abc\\" assert decode_string(\\"zab\\", 2) == \\"xyz\\" assert encode_string(\\"hello\\", 13) == \\"uryyb\\" assert decode_string(\\"uryyb\\", 13) == \\"hello\\" ``` Additional Context: You might consider using modular arithmetic to simplify the character shifting process. The primary focus is to maintain simplicity and clarity in your algorithm while ensuring correctness and performance.","solution":"def encode_string(s: str, shift: int) -> str: Encodes the input string `s` by shifting its characters `shift` positions forward in the alphabet. encoded_chars = [] for char in s: if char.isalpha(): new_pos = (ord(char) - ord(\'a\') + shift) % 26 new_char = chr(new_pos + ord(\'a\')) encoded_chars.append(new_char) else: # If there\'s a non-alphabet character, append as it is encoded_chars.append(char) return \'\'.join(encoded_chars) def decode_string(s: str, shift: int) -> str: Decodes the input string `s` by shifting its characters `shift` positions backward in the alphabet. decoded_chars = [] for char in s: if char.isalpha(): new_pos = (ord(char) - ord(\'a\') - shift) % 26 new_char = chr(new_pos + ord(\'a\')) decoded_chars.append(new_char) else: # If there\'s a non-alphabet character, append as it is decoded_chars.append(char) return \'\'.join(decoded_chars)"},{"question":"# Problem Description You are tasked with implementing a simplified version of a file synchronization tool that can track file changes and synchronize them between two directories. The goal is to identify new, modified, and deleted files in one directory and mirror those changes in another directory. # Function Specifications 1. **track_changes(src_dir: str, dest_dir: str) -> tuple**: Tracks changes between the source and destination directories. - **Input**: Two strings `src_dir` and `dest_dir` representing paths to the source and destination directories, respectively. - **Output**: A tuple containing three lists: - A list of new files in the source directory not present in the destination directory. - A list of modified files in the source directory that have a different checksum compared to corresponding files in the destination directory. - A list of files deleted from the source directory that are present in the destination directory. - **Behavior**: The function should recursively compare the contents of the two directories taking into account all files and subdirectories. 2. **synchronize(src_dir: str, dest_dir: str)**: Synchronizes the destination directory with the changes tracked in the source directory. - **Input**: Two strings `src_dir` and `dest_dir` representing paths to the source and destination directories, respectively. - **Output**: None - **Behavior**: The function should ensure that the destination directory reflects all changes identified by `track_changes` - new files should be copied, modified files should be updated, and deleted files should be removed. # Constraints - The directory paths will always be valid and accessible. - File checksums can be computed using the `hashlib` library (e.g., using `md5` hash). - Assume the directories do not contain any symbolic links or special file types. # Example ```python # Directory structure for example # src_dir/ # ├── file1.txt (content \\"Hello, World!\\") # ├── dir1 # │ └── file2.txt (content \\"Python is awesome\\") # # dest_dir/ # ├── file1.txt (content \\"Hello, World!\\") # └── file3.txt (content \\"Old file\\") # track_changes example new_files, modified_files, deleted_files = track_changes(\'src_dir\', \'dest_dir\') print(new_files) # [\'dir1/file2.txt\'] print(modified_files) # [] print(deleted_files) # [\'file3.txt\'] # synchronize example synchronize(\'src_dir\', \'dest_dir\') # After synchronization, dest_dir should have the following structure: # dest_dir/ # ├── file1.txt (content \\"Hello, World!\\") # ├── dir1 # │ └── file2.txt (content \\"Python is awesome\\") ``` # Requirements - Implement the `track_changes` function to correctly identify new, modified, and deleted files. - Implement the `synchronize` function to update the destination directory to match the source directory. - Ensure your implementation handles nested directories efficiently. - Provide sufficient error handling for common edge cases such as empty directories.","solution":"import os import hashlib import shutil def calculate_checksum(file_path): Calculates the MD5 checksum of a file. hash_md5 = hashlib.md5() with open(file_path, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_md5.update(chunk) return hash_md5.hexdigest() def track_changes(src_dir, dest_dir): new_files = [] modified_files = [] deleted_files = [] src_files = {} dest_files = {} # Walk through the source directory to collect file paths and checksums for root, _, files in os.walk(src_dir): for file in files: file_path = os.path.join(root, file) relative_path = os.path.relpath(file_path, src_dir) src_files[relative_path] = calculate_checksum(file_path) # Walk through the destination directory to collect file paths and checksums for root, _, files in os.walk(dest_dir): for file in files: file_path = os.path.join(root, file) relative_path = os.path.relpath(file_path, dest_dir) dest_files[relative_path] = calculate_checksum(file_path) # Identify new files and modified files for relative_path, checksum in src_files.items(): if relative_path not in dest_files: new_files.append(relative_path) elif dest_files[relative_path] != checksum: modified_files.append(relative_path) # Identify deleted files for relative_path in dest_files.keys(): if relative_path not in src_files: deleted_files.append(relative_path) return new_files, modified_files, deleted_files def synchronize(src_dir, dest_dir): new_files, modified_files, deleted_files = track_changes(src_dir, dest_dir) # Add and update files for relative_path in new_files + modified_files: src_file_path = os.path.join(src_dir, relative_path) dest_file_path = os.path.join(dest_dir, relative_path) os.makedirs(os.path.dirname(dest_file_path), exist_ok=True) shutil.copy2(src_file_path, dest_file_path) # Delete files for relative_path in deleted_files: dest_file_path = os.path.join(dest_dir, relative_path) if os.path.exists(dest_file_path): os.remove(dest_file_path)"},{"question":"# Problem Statement You are given an array of integers, and your task is to move all the zeroes to the end of the array while maintaining the relative order of the non-zero elements. # Function to Implement ```python def move_zeroes(nums: list[int]) -> list[int]: Move all zeroes in the array to the end while maintaining the relative order of the non-zero elements. Parameters: nums (list[int]): The input list of integers. Returns: list[int]: The modified list with zeroes moved to the end. pass ``` # Example ```python nums = [0, 1, 0, 3, 12] result = move_zeroes(nums) # Output should be [1, 3, 12, 0, 0] nums = [0, 0, 1] result = move_zeroes(nums) # Output should be [1, 0, 0] ``` # Constraints 1. The input list will have at least one integer. 2. The list can have up to 10,000 integers. 3. Elements in the input array can be positive, negative, or zero. # Assumptions 1. The function should modify the input list in place. 2. The problem should be solved using constant space complexity. 3. The relative order of the non-zero elements must be preserved. # Performance Requirements Ensure that the solution handles large inputs efficiently, with a time complexity of O(n).","solution":"def move_zeroes(nums: list[int]) -> list[int]: Move all zeroes in the array to the end while maintaining the relative order of the non-zero elements. Parameters: nums (list[int]): The input list of integers. Returns: list[int]: The modified list with zeroes moved to the end. last_non_zero_found_at = 0 # Move all the non-zero elements to the beginning of the array for current in range(len(nums)): if nums[current] != 0: nums[last_non_zero_found_at] = nums[current] last_non_zero_found_at += 1 # Fill the rest of the array with zeroes for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0 return nums"},{"question":"# Dynamic Fibonacci Sequence Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, often starting with 0 and 1. However, let\'s generalize this concept to support dynamic starting points and sequence lengths. Problem Design a function `dynamic_fibonacci(start1: int, start2: int, length: int) -> list` that takes three parameters: the first two starting numbers of the sequence and the total length of the desired sequence. The function should return a list containing the first `length` numbers of this generalized Fibonacci sequence. Input and Output Formats * **Input**: Three integers - the first number (`start1`), the second number (`start2`), and the total length of the desired sequence (`length`). * **Output**: A list of integers representing the sequence. Constraints * `start1` and `start2` are integers. * `length` is a positive integer (≥ 1). * If `length` is 1, only `start1` should be returned. Example ```python >>> dynamic_fibonacci(0, 1, 10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> dynamic_fibonacci(2, 3, 5) [2, 3, 5, 8, 13] >>> dynamic_fibonacci(4, 7, 1) [4] >>> dynamic_fibonacci(3, 3, 6) [3, 3, 6, 9, 15, 24] ``` # Requirements * The solution must efficiently generate the Fibonacci sequence based on given dynamic starting points. * Ensure the function correctly handles edge cases such as very small or very large sequence lengths.","solution":"def dynamic_fibonacci(start1: int, start2: int, length: int) -> list: Generate a generalized Fibonacci sequence with specified starting points and length. Parameters: start1 (int): The first number in the sequence start2 (int): The second number in the sequence length (int): The total length of the desired sequence Returns: list: A list containing the first \'length\' numbers of the sequence if length <= 0: return [] elif length == 1: return [start1] sequence = [start1, start2] for _ in range(2, length): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"# Problem Statement Write a function called `merge_sorted_lists` that takes a list of non-empty sorted lists of integers and merges them into a single sorted list. The solution should be efficient in terms of both time and space complexity. # Function Signature ```python def merge_sorted_lists(lists: List[List[int]]) -> List[int]: pass ``` # Input * `lists`: A list of lists, where each list contains sorted integers. # Output * A single merged list containing all integers from the input lists, sorted in ascending order. # Constraints * `0 <= len(lists) <= 10^3` * `0 <= len(lists[i]) <= 10^3` * `-10^6 <= lists[i][j] <= 10^6` # Examples ```python assert merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] assert merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0]]) == [0, 1, 2, 3, 4, 5, 6] assert merge_sorted_lists([[], [3, 4, 5], [1, 2, 6]]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([[], [], []]) == [] assert merge_sorted_lists([[10, 20, 30]]) == [10, 20, 30] ``` # Additional Notes 1. Make sure the solution efficiently handles cases where input lists vary greatly in size. 2. Pay attention to edge cases such as lists being empty or containing negative numbers. 3. Aim for an optimal solution that leverages data structures that facilitate efficient merging of sorted lists. 4. Be mindful of space complexity, and try to use in-place strategies where possible within the constraints provided.","solution":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges a list of sorted integer lists into a single sorted list. min_heap = [] for i, sorted_list in enumerate(lists): if sorted_list: heapq.heappush(min_heap, (sorted_list[0], i, 0)) result = [] while min_heap: val, list_idx, elem_idx = heapq.heappop(min_heap) result.append(val) if elem_idx + 1 < len(lists[list_idx]): heapq.heappush(min_heap, (lists[list_idx][elem_idx + 1], list_idx, elem_idx + 1)) return result"},{"question":"# Password Complexity Checker **Scenario**: You have been tasked with developing a system for a company that checks the complexity of passwords set by their employees. The system needs to enforce certain security policies and guidelines for creating robust passwords. Your job is to implement functions that evaluate the strength of these passwords and provide feedback on their complexity. **Requirements**: 1. Write a function `check_password_complexity(password: str) -> str` that takes a password as input and returns a string indicating its complexity: `\\"Weak\\"`, `\\"Moderate\\"`, or `\\"Strong\\"`. 2. Write a function `suggest_password_improvements(password: str) -> List[str]` that takes a password as input and returns a list of suggestions to improve its complexity. **Function Signatures**: ```python def check_password_complexity(password: str) -> str: pass def suggest_password_improvements(password: str) -> List[str]: pass ``` **Input/Output**: * `check_password_complexity`: * **Input**: * A string `password` representing the password to be evaluated. * **Output**: * A string indicating password complexity: `\\"Weak\\"`, `\\"Moderate\\"`, or `\\"Strong\\"`. * `suggest_password_improvements`: * **Input**: * A string `password` representing the password to be evaluated. * **Output**: * A list of strings suggesting improvements to the given password. **Complexity Criteria**: - A password is considered `\\"Weak\\"` if it has fewer than 8 characters or consists only of letters. - A password is considered `\\"Moderate\\"` if it has at least 8 characters and includes letters and at least one digit but lacks special characters. - A password is considered `\\"Strong\\"` if it is at least 8 characters long and includes letters, digits, and special characters. **Constraint**: - The input password string will have at least 1 character and no more than 128 characters. **Example**: ```python >>> check_password_complexity(\\"abc\\") \\"Weak\\" >>> check_password_complexity(\\"abcdef123\\") \\"Moderate\\" >>> check_password_complexity(\\"abc123!@#\\") \\"Strong\\" >>> suggest_password_improvements(\\"abc\\") [\\"Use at least 8 characters\\", \\"Include digits\\", \\"Include special characters\\"] >>> suggest_password_improvements(\\"abcdef123\\") [\\"Include special characters\\"] ``` # Additional Notes: Your solution will be evaluated on correctness, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments. Handle any edge cases appropriately and provide meaningful feedback for password improvements.","solution":"import string from typing import List def check_password_complexity(password: str) -> str: Evaluates the complexity of the given password. if len(password) < 8: return \\"Weak\\" has_letter = any(char.isalpha() for char in password) has_digit = any(char.isdigit() for char in password) has_special = any(char in string.punctuation for char in password) if has_letter and has_digit and has_special: return \\"Strong\\" elif has_letter and has_digit: return \\"Moderate\\" else: return \\"Weak\\" def suggest_password_improvements(password: str) -> List[str]: Suggests improvements for the given password to enhance its complexity. suggestions = [] if len(password) < 8: suggestions.append(\\"Use at least 8 characters\\") if not any(char.isdigit() for char in password): suggestions.append(\\"Include digits\\") if not any(char.isalpha() for char in password): suggestions.append(\\"Include letters\\") if not any(char in string.punctuation for char in password): suggestions.append(\\"Include special characters\\") return suggestions"},{"question":"# Sentence Reverser **Description**: You are tasked with improving a basic text processing function that reverses the order of words in a given sentence. The function currently handles simple cases without any consideration for punctuation or multiple spaces between words. **Objective**: Enhance the existing `reverse_sentence(sentence: str)` function to handle more complex scenarios and ensure robustness. The function should: 1. Reverse the order of words in a given sentence while maintaining the original punctuation. 2. Handle multiple spaces between words efficiently, preserving them in the output. 3. Properly manage punctuation marks attached to words (e.g., \\"Hello, world!\\" should become \\"world! Hello,\\"). **Input**: * A single string containing a sentence with words, spaces, and punctuation (e.g., ` \\"Hello, world! This is a test.\\"`). **Output**: * A string where the order of words has been reversed, preserving spaces and punctuation (e.g., `\\"test. a is This world! Hello,\\"`). **Constraints**: * The sentence will not contain leading or trailing spaces. * Words are defined as sequences of characters separated by spaces. * Handle at least basic punctuation marks (e.g., `.,!?;:`). **Performance Requirements**: * Ensure that the function operates efficiently even for longer sentences of up to 100 words. # Implementation Complete the function `reverse_sentence(sentence: str) -> str`: ```python import re def reverse_sentence(sentence: str) -> str: # Match sequences of word characters or punctuation words_and_punctuation = re.findall(r\'bw+b|W+\', sentence) # Separate and reverse just the words words = [match for match in words_and_punctuation if match.strip()] words.reverse() result = \\"\\" index = 0 for match in words_and_punctuation: if match.strip(): result += words[index] index += 1 else: result += match return result if __name__ == \\"__main__\\": sentence = \\"Hello, world! This is a test.\\" reversed_sentence = reverse_sentence(sentence) print(f\\"Original: {sentence}\\") print(f\\"Reversed: {reversed_sentence}\\") ``` Use regular expressions to handle complex cases and ensure your implementation meets the objectives. Happy coding!","solution":"import re def reverse_sentence(sentence: str) -> str: # Match sequences of word characters and non-whitespace sequences (handles spaces and punctuation) matches = re.findall(r\'S+|s+\', sentence) # Separate words and spaces/punctuations into separate lists words = [match for match in matches if not match.isspace()] non_words = [match for match in matches if match.isspace()] # Reverse the words list words.reverse() # Integrate back the words and spaces/punctuations result = \\"\\" word_index = 0 for match in matches: if match.isspace(): result += match else: result += words[word_index] word_index += 1 return result if __name__ == \\"__main__\\": sentence = \\"Hello, world! This is a test.\\" reversed_sentence = reverse_sentence(sentence) print(f\\"Original: {sentence}\\") print(f\\"Reversed: {reversed_sentence}\\")"},{"question":"# Data Stream Processor As a data engineer, you have been tasked with creating a system to process a stream of data in real-time. You need to implement a stream processing engine with capabilities to add data to the stream, compute running statistics, and handle resets. The system should be capable of calculating the running mean and variance efficiently for potentially large data streams. **Requirements**: 1. Implement a function to initialize the system state. 2. Implement a function to add a new data point to the stream. 3. Implement functions to retrieve the current running mean and variance. 4. Implement a function to reset the system state to its initial parameters. # Objectives: - **Function**: `initialize_stream()` - **Input**: None - **Output**: Resets and initializes the stream system state. - **Function**: `add_data_point(value: float)` - **Input**: - `value`: A floating-point number representing a new data point. - **Output**: Updates the system state to include the new data point. - **Function**: `get_running_mean() -> float` - **Input**: None - **Output**: Returns the current running mean of the data points added to the stream. - **Function**: `get_running_variance() -> float` - **Input**: None - **Output**: Returns the current running variance of the data points added to the stream. - **Function**: `reset_stream()` - **Input**: None - **Output**: Resets the stream system state to its initial parameters. Constraints: - New data points will be floating-point numbers within the range of a double-precision floating-point format. - Ensure efficient use of memory and processing time when updating the mean and variance for each new data point. - The system should handle potentially thousands of data points without significant performance degradation. - Maintain numerical stability when computing the running variance. # Example Scenario: 1. Initialize the stream: ```python initialize_stream() ``` 2. Add data points to the stream: ```python add_data_point(10.0) add_data_point(20.0) add_data_point(30.0) ``` 3. Retrieve and print the running mean and variance: ```python mean = get_running_mean() # Should return 20.0 variance = get_running_variance() # Should return 100.0 ``` 4. Reset the stream system to its initial settings and verify initial conditions: ```python reset_stream() runnnig_mean_after_reset = get_running_mean() # Should return 0.0 runnnig_variance_after_reset = get_running_variance() # Should return 0.0 ``` # Guidelines: - Thoroughly test the functions with data streams of varying sizes. - Document any edge cases and ensure they are handled properly (such as division by zero). Are you ready to manage real-time data streams efficiently and effectively?","solution":"class DataStreamProcessor: def __init__(self): self.reset_stream() def initialize_stream(self): self.reset_stream() def add_data_point(self, value: float): self.count += 1 delta = value - self.mean self.mean += delta / self.count delta2 = value - self.mean self.M2 += delta * delta2 def get_running_mean(self) -> float: return self.mean def get_running_variance(self) -> float: if self.count <= 1: return 0.0 return self.M2 / (self.count - 1) def reset_stream(self): self.count = 0 self.mean = 0.0 self.M2 = 0.0 # Define the instance of the DataStreamProcessor stream_processor = DataStreamProcessor() def initialize_stream(): Reset and initialize the stream processor. stream_processor.initialize_stream() def add_data_point(value: float): Add a new data point to the stream processor. Args: value (float): The new data point to add. stream_processor.add_data_point(value) def get_running_mean() -> float: Get the current running mean of the data points. Returns: float: The current running mean. return stream_processor.get_running_mean() def get_running_variance() -> float: Get the current running variance of the data points. Returns: float: The current running variance. return stream_processor.get_running_variance() def reset_stream(): Reset the stream processor to its initial state. stream_processor.reset_stream()"},{"question":"# Scenario: You are developing a feature for a fitness tracking application that generates a weekly summary of exercise activities. The app takes user input in terms of time spent on various activities each day of the week and calculates the total time spent on each activity over the week. # Task: Implement a Python function `calculate_weekly_summary(data)` that processes the given dictionary of daily timings for various activities and returns a dictionary with the total time spent on each activity for the week. # Function Specification: Input: - A dictionary `data` where the keys are the days of the week (\'Monday\', \'Tuesday\', etc.) and the values are dictionaries. Each inner dictionary has activity names as keys and time spent (in minutes) as values. Output: - A dictionary where: * The keys are the activity names. * The values are the total time spent on each activity over the week, in minutes. Constraints: - Assume that each activity is consistently named across all days. - The function should correctly handle cases where certain days may have no recorded activities. # Example: Given the input: ```python data = { \'Monday\': {\'running\': 30, \'cycling\': 20}, \'Tuesday\': {\'swimming\': 25, \'running\': 40}, \'Wednesday\': {\'cycling\': 40, \'running\': 10}, \'Thursday\': {}, \'Friday\': {\'running\': 50, \'cycling\': 30}, \'Saturday\': {\'swimming\': 60}, \'Sunday\': {\'running\': 20, \'cycling\': 15, \'swimming\': 40} } ``` The expected output: ```python { \'running\': 150, \'cycling\': 105, \'swimming\': 125 } ``` # Example Usage: ```python weekly_summary = calculate_weekly_summary(data) print(weekly_summary) ```","solution":"def calculate_weekly_summary(data): Processes the given dictionary of daily timings for various activities and returns a dictionary with the total time spent on each activity for the week. Parameters: data (dict): A dictionary where the keys are the days of the week and the values are dictionaries of activity names and time spent (in minutes). Returns: dict: A dictionary where the keys are the activity names and the values are the total time spent on each activity over the week, in minutes. weekly_summary = {} for day, activities in data.items(): for activity, time in activities.items(): if activity in weekly_summary: weekly_summary[activity] += time else: weekly_summary[activity] = time return weekly_summary"},{"question":"# Exploring the Python `collections` Module You are tasked with writing a function that utilizes the `Counter` class from the Python `collections` module to determine the frequency of characters in a string. The function will process the string to count each character\'s occurrence and return a dictionary-like object that can provide this information. # Problem Statement Write a Python function `character_frequency(s: str) -> dict` that counts the frequency of each character in the input string and returns a dictionary where keys are characters and values are their respective counts. Implement: ```python def character_frequency(s: str) -> dict: pass ``` # Constraints: * The input must be a string; otherwise, raise a `TypeError`. * The string can include any characters, including special symbols and whitespace. * The function should handle an empty string by returning an empty dictionary. # Example: ```python >>> character_frequency(\\"hello\\") {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} >>> character_frequency(\\"abracadabra\\") {\'a\': 5, \'b\': 2, \'r\': 2, \'c\': 1, \'d\': 1} >>> character_frequency(\\"123#@!\\") {\'1\': 1, \'2\': 1, \'3\': 1, \'#\': 1, \'@\': 1, \'!\': 1} >>> character_frequency(\\"\\") {} >>> character_frequency(12345) Traceback (most recent call last): ... TypeError: Expected a string as input ``` # Notes: 1. Utilize `collections.Counter` for efficient character counting. 2. Ensure the function can handle all valid string inputs, including special characters and digits. 3. Handle empty strings appropriately as highlighted in the examples. 4. Raise appropriate exceptions for invalid input types as specified in the example. # Performance Requirements: * The function should perform efficiently, processing the string in O(n) time complexity, where n is the length of the string. Demonstrate your ability to work with Python\'s powerful `collections` module and ensure correctness by handling different types of input scenarios properly.","solution":"from collections import Counter def character_frequency(s: str) -> dict: Returns a dictionary with the frequency count of each character in the string s. :param s: A string whose characters frequency count is to be determined. :type s: str :return: A dictionary with characters as keys and their frequency as values. :rtype: dict :raises TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"Expected a string as input\\") return dict(Counter(s))"},{"question":"# Problem Statement Create a class named `BookLibrary` that can manage a collection of books. Each book has a unique ISBN number, a title, an author, and a publication year. The class should support adding new books, removing books by ISBN, searching for a book by ISBN, listing all books by a specific author, and retrieving the oldest and newest books. Implement the following functionalities in the `BookLibrary` class: 1. Adding a new book. 2. Removing a book by ISBN. 3. Searching for a book by ISBN. 4. Listing all books by a specific author. 5. Retrieving the oldest book. 6. Retrieving the newest book. # Function Specifications 1. **Add Book Function** ```python def add_book(self, isbn: str, title: str, author: str, year: int) -> None: ``` - **Input**: A string for ISBN, a string for title, a string for the author, and an integer for the publication year. - **Output**: None. - **Constraints**: ISBN should be unique. Raise ValueError for duplicate ISBN. 2. **Remove Book Function** ```python def remove_book(self, isbn: str) -> None: ``` - **Input**: A string value representing the ISBN of the book to be removed. - **Output**: None. - **Constraints**: Raise ValueError if the ISBN does not exist. 3. **Search Book Function** ```python def search_book(self, isbn: str) -> Dict[str, Any] | None: ``` - **Input**: A string value representing the ISBN. - **Output**: A dictionary containing book details (title, author, year) if the book exists, else None. 4. **List Books by Author Function** ```python def list_books_by_author(self, author: str) -> List[Dict[str, Any]]: ``` - **Input**: A string value representing the author\'s name. - **Output**: A list of dictionaries, each representing a book by the specified author. Each dictionary contains the book\'s ISBN, title, and year. If no books are found, return an empty list. 5. **Get Oldest Book Function** ```python def get_oldest_book(self) -> Dict[str, Any] | None: ``` - **Input**: None. - **Output**: A dictionary containing details of the oldest book (ISBN, title, author, year). If the library is empty, return None. 6. **Get Newest Book Function** ```python def get_newest_book(self) -> Dict[str, Any] | None: ``` - **Input**: None. - **Output**: A dictionary containing details of the newest book (ISBN, title, author, year). If the library is empty, return None. # Examples ```python library = BookLibrary() library.add_book(\\"978-3-16-148410-0\\", \\"Sample Book 1\\", \\"Author A\\", 2001) library.add_book(\\"978-1-4028-9467-2\\", \\"Sample Book 2\\", \\"Author B\\", 1999) library.add_book(\\"978-0-262-13472-9\\", \\"Sample Book 3\\", \\"Author A\\", 2010) assert library.search_book(\\"978-3-16-148410-0\\") == {\\"title\\": \\"Sample Book 1\\", \\"author\\": \\"Author A\\", \\"year\\": 2001} assert library.list_books_by_author(\\"Author A\\") == [ {\\"isbn\\": \\"978-3-16-148410-0\\", \\"title\\": \\"Sample Book 1\\", \\"year\\": 2001}, {\\"isbn\\": \\"978-0-262-13472-9\\", \\"title\\": \\"Sample Book 3\\", \\"year\\": 2010} ] assert library.get_oldest_book() == {\\"isbn\\": \\"978-1-4028-9467-2\\", \\"title\\": \\"Sample Book 2\\", \\"author\\": \\"Author B\\", \\"year\\": 1999} library.remove_book(\\"978-1-4028-9467-2\\") assert library.get_oldest_book() == {\\"isbn\\": \\"978-3-16-148410-0\\", \\"title\\": \\"Sample Book 1\\", \\"author\\": \\"Author A\\", \\"year\\": 2001} ```","solution":"from typing import Dict, Any, List class BookLibrary: def __init__(self): self.books = {} def add_book(self, isbn: str, title: str, author: str, year: int) -> None: if isbn in self.books: raise ValueError(f\\"A book with ISBN {isbn} already exists.\\") self.books[isbn] = { \\"title\\": title, \\"author\\": author, \\"year\\": year } def remove_book(self, isbn: str) -> None: if isbn not in self.books: raise ValueError(f\\"No book with ISBN {isbn} found.\\") del self.books[isbn] def search_book(self, isbn: str) -> Dict[str, Any] | None: return self.books.get(isbn) def list_books_by_author(self, author: str) -> List[Dict[str, Any]]: return [ {\\"isbn\\": isbn, \\"title\\": info[\\"title\\"], \\"year\\": info[\\"year\\"]} for isbn, info in self.books.items() if info[\\"author\\"] == author ] def get_oldest_book(self) -> Dict[str, Any] | None: if not self.books: return None oldest_book_isbn = min(self.books, key=lambda isbn: self.books[isbn][\\"year\\"]) return {\\"isbn\\": oldest_book_isbn, **self.books[oldest_book_isbn]} def get_newest_book(self) -> Dict[str, Any] | None: if not self.books: return None newest_book_isbn = max(self.books, key=lambda isbn: self.books[isbn][\\"year\\"]) return {\\"isbn\\": newest_book_isbn, **self.books[newest_book_isbn]} # Sample usage: # library = BookLibrary() # library.add_book(\\"978-3-16-148410-0\\", \\"Sample Book 1\\", \\"Author A\\", 2001) # library.add_book(\\"978-1-4028-9467-2\\", \\"Sample Book 2\\", \\"Author B\\", 1999) # library.add_book(\\"978-0-262-13472-9\\", \\"Sample Book 3\\", \\"Author A\\", 2010) # print(library.search_book(\\"978-3-16-148410-0\\")) # print(library.list_books_by_author(\\"Author A\\")) # print(library.get_oldest_book()) # library.remove_book(\\"978-1-4028-9467-2\\") # print(library.get_oldest_book())"},{"question":"# Matrix Transposition and Sum Checker In this problem, you need to implement a function that takes two matrices, performs matrix transposition, and checks if the sum of elements in the main diagonal of both matrices is the same. Requirements * Implement the function `check_transpose_sum(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool` that returns `True` if the sum of the elements in the main diagonal of the transpose of matrix1 and the main diagonal of matrix2 are equal, otherwise returns `False`. * The main diagonal is defined as the elements from the top-left to the bottom-right of the matrix. Function Signature ```python from typing import List def check_transpose_sum(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: pass ``` # Input * `matrix1`: A list of lists of integers representing the first matrix (1 ≤ len(matrix1), len(matrix1[0]) ≤ 100). * `matrix2`: A list of lists of integers representing the second matrix (1 ≤ len(matrix2), len(matrix2[0]) ≤ 100). # Output * Returns a boolean value, `True` if the sum of the main diagonal elements of the transpose of `matrix1` equals the sum of the main diagonal elements of `matrix2`, otherwise `False`. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [3, 1, 4], [1, 5, 9], [2, 6, 5] ] assert check_transpose_sum(matrix1, matrix2) == True matrix1 = [ [10, 20], [30, 40] ] matrix2 = [ [5, 6], [7, 8] ] assert check_transpose_sum(matrix1, matrix2) == False ``` # Constraints * Assume both matrices have the same dimensions. * The matrix elements are integers and can be both positive and negative. # Notes * Transpose of a matrix is obtained by swapping rows with columns. * Efficiently compute the diagonal sum as it involves simple arithmetic operations.","solution":"from typing import List def check_transpose_sum(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: n = len(matrix1) # Compute sum of the main diagonal of the transpose of matrix1 diagonal_sum_matrix1_transpose = 0 for i in range(n): diagonal_sum_matrix1_transpose += matrix1[i][i] # Compute sum of the main diagonal of matrix2 diagonal_sum_matrix2 = 0 for i in range(n): diagonal_sum_matrix2 += matrix2[i][i] # Compare the sums return diagonal_sum_matrix1_transpose == diagonal_sum_matrix2"},{"question":"# Question: Minimum Cost to Connect All Points You are given an array `points` of `n` unique integer coordinates `[x, y]` representing points on a 2D plane. Your task is to find the minimum cost to make all points connected, where the cost is the Manhattan distance between any two points. The Manhattan distance between two points `(x1, y1)` and `(x2, y2)` is `|x1 - x2| + |y1 - y2|`. # Function Signature ```python def min_cost_connect_points(points: List[List[int]]) -> int: ``` # Input * `points`: A list of `n` lists, where each list contains two integers `[x, y]` representing the coordinates of a point. # Output * Return an integer representing the minimum cost to connect all the given points. # Constraints * `1 <= n <= 1000` * `-10^6 <= points[i][0], points[i][1] <= 10^6` * All points are unique. # Example ```python print(min_cost_connect_points([[0,0],[2,2],[3,10],[5,2],[7,0]])) # Output: 20 print(min_cost_connect_points([[3,12],[-2,5],[-4,1]])) # Output: 18 ``` # Explanation - In the first example: - Connect point `[0,0]` to point `[2,2]`, cost is 4. - Connect point `[2,2]` to point `[5,2]`, cost is 3. - Connect point `[5,2]` to point `[7,0]`, cost is 4. - Connect point `[2,2]` to point `[3,10]`, cost is 8. - Total minimum cost is `4 + 3 + 4 + 8 = 20`. - In the second example: - Connect point `[3,12]` to point `[-2,5]`, cost is 12. - Connect point `[-2,5]` to point `[-4,1]`, cost is 6. - Total minimum cost is `12 + 6 = 18`. To solve this problem, you might consider algorithms like Prim\'s or Kruskal\'s to find the Minimum Spanning Tree (MST) for the given points.","solution":"from typing import List import heapq def min_cost_connect_points(points: List[List[int]]) -> int: def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) n = len(points) if n <= 1: return 0 min_heap = [(0, 0)] in_mst = [False] * n total_cost = 0 edges_used = 0 while edges_used < n: cost, u = heapq.heappop(min_heap) if in_mst[u]: continue in_mst[u] = True total_cost += cost edges_used += 1 for v in range(n): if not in_mst[v]: heapq.heappush(min_heap, (manhattan_distance(points[u], points[v]), v)) return total_cost"},{"question":"# Event Capacity Planner You are responsible for implementing a system that helps in planning event capacities. This system must ensure that events do not exceed their capacity limits and that all participants are assigned to an appropriate event. Requirements: 1. **Expand Event Management**: Create a way to manage multiple events, each with a specific capacity. 2. **Participant Assignment**: Implement a function `assign_participant(event_name: str, participant_name: str) -> str` that assigns a participant to an event if the event has available capacity. If the event is full, raise a ValueError with a descriptive message. # Input Specifications: 1. `create_event(event_name: str, capacity: int) -> None`: This function creates a new event with the given name and capacity. 2. `assign_participant(event_name: str, participant_name: str) -> str`: This function assigns a participant to the specified event if there is available capacity. # Output Specifications: 1. `create_event` should return nothing. 2. `assign_participant` should return a string confirming the participant’s assignment. # Constraints: 1. Participants can only be assigned to valid and existing events. 2. An event cannot have more participants than its capacity. # Scenarios and Examples: 1. **Creating and Assigning Participants to Events**: - `create_event(\\"Concert A\\", 100)` should initialize an event called \\"Concert A\\" with a capacity of 100. - `assign_participant(\\"Concert A\\", \\"Alice\\")` should return `\\"Alice has been assigned to Concert A\\"`. - If `assign_participant(\\"Concert A\\", \\"Bob\\")` is called when the event \\"Concert A\\" is already full, it should raise a `ValueError` with a message `\\"Event Concert A is full.\\"`. # Boilerplate Code ```python class Event: def __init__(self, name: str, capacity: int): self.name = name self.capacity = capacity self.participants = [] class EventManager: def __init__(self): self.events = {} def create_event(self, event_name: str, capacity: int) -> None: if event_name in self.events: raise ValueError(f\\"Event {event_name} already exists.\\") self.events[event_name] = Event(event_name, capacity) def assign_participant(self, event_name: str, participant_name: str) -> str: if event_name not in self.events: raise ValueError(f\\"Event {event_name} does not exist.\\") event = self.events[event_name] if len(event.participants) >= event.capacity: raise ValueError(f\\"Event {event_name} is full.\\") event.participants.append(participant_name) return f\\"{participant_name} has been assigned to {event_name}\\" if __name__ == \\"__main__\\": import doctest em = EventManager() em.create_event(\\"Concert A\\", 2) print(em.assign_participant(\\"Concert A\\", \\"Alice\\")) # Expected: Alice has been assigned to Concert A print(em.assign_participant(\\"Concert A\\", \\"Bob\\")) # Expected: Bob has been assigned to Concert A try: em.assign_participant(\\"Concert A\\", \\"Charlie\\") # Expected: ValueError: Event Concert A is full. except ValueError as e: print(e) try: em.assign_participant(\\"Nonexistent Event\\", \\"David\\") # Expected: ValueError: Event Nonexistent Event does not exist. except ValueError as e: print(e) ```","solution":"class Event: def __init__(self, name: str, capacity: int): self.name = name self.capacity = capacity self.participants = [] class EventManager: def __init__(self): self.events = {} def create_event(self, event_name: str, capacity: int) -> None: if event_name in self.events: raise ValueError(f\\"Event {event_name} already exists.\\") self.events[event_name] = Event(event_name, capacity) def assign_participant(self, event_name: str, participant_name: str) -> str: if event_name not in self.events: raise ValueError(f\\"Event {event_name} does not exist.\\") event = self.events[event_name] if len(event.participants) >= event.capacity: raise ValueError(f\\"Event {event_name} is full.\\") event.participants.append(participant_name) return f\\"{participant_name} has been assigned to {event_name}\\""},{"question":"# Array Manipulation Context You are provided with an array of integers. Your task is to perform a series of operations to manipulate this array. These operations include reversing the array, finding the minimum and maximum values, and computing the sum of elements in a given range. Task Implement the following functions: 1. **Reverse**: Reverses the array in place. 2. **Find Min and Max**: Finds and returns the minimum and maximum values in the array. 3. **Range Sum**: Computes the sum of elements in a given inclusive range `[left, right]`. Input and Output Define an ArrayManipulator class with the following methods: 1. `__init__(self, elements: List[int])` - Initializes the array manipulator with elements from the provided list. 2. `reverse(self) -> None` - Reverses the array in place. 3. `find_min_max(self) -> Tuple[int, int]` - Finds and returns a tuple containing the minimum and maximum values in the array. 4. `range_sum(self, left: int, right: int) -> int` - Computes the sum of elements from index `left` to index `right` (inclusive) and returns the result. Example: ```python am = ArrayManipulator([1, 3, 5, 32, 44, 12, 43]) print(am) # Outputs the array representation am.reverse() print(am) # After array is reversed min_val, max_val = am.find_min_max() print(min_val, max_val) # Outputs: (1, 44) sum_range = am.range_sum(2, 5) print(sum_range) # Outputs the sum of elements from index 2 to 5, inclusive ``` Constraints - The number of elements in the array will not exceed 10^4. - The values of the elements will be between -10^6 and 10^6. - For the `range_sum` method, `0 <= left <= right < len(elements)`. **Performance Requirements**: Your implementation should efficiently handle the operations within the expected input constraints.","solution":"from typing import List, Tuple class ArrayManipulator: def __init__(self, elements: List[int]): self.elements = elements def reverse(self) -> None: self.elements.reverse() def find_min_max(self) -> Tuple[int, int]: return (min(self.elements), max(self.elements)) def range_sum(self, left: int, right: int) -> int: return sum(self.elements[left:right + 1])"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a function to merge two sorted linked lists into a single, sorted linked list. The goal is to perform the merge in-place, meaning you should directly manipulate the pointers of the nodes without creating new nodes or temporary data structures. Using your knowledge of linked lists and their manipulation, write a function that accomplishes this task efficiently. Function Specification **Function Name**: `merge_sorted_lists` **Parameters**: - `l1`: The head node of the first sorted linked list. - `l2`: The head node of the second sorted linked list. **Returns**: - The head node of the merged sorted linked list. **Constraints**: - The linked lists are sorted in non-decreasing order. - The number of nodes in either linked list does not exceed 50. Example Consider the following example of ListNode class to be used for constructing the linked lists: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` ```python # Example linked list 1: 1 -> 2 -> 4 l1 = ListNode(1, ListNode(2, ListNode(4))) # Example linked list 2: 1 -> 3 -> 4 l2 = ListNode(1, ListNode(3, ListNode(4))) # Expected merged linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 merged_list = merge_sorted_lists(l1, l2) ``` Task 1. Write the function `merge_sorted_lists(l1, l2)` that merges two sorted linked lists in-place. 2. Ensure your implementation passes the provided example case. 3. Consider edge cases where one or both input lists might be empty. 4. Focus on maintaining the sorted order and directly manipulating the node pointers without using extra space for new nodes. Provide any additional notes or comments in your code to explain key steps or decisions in your implementation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_lists(l1, l2): Merges two sorted linked lists l1 and l2 in-place. Returns the head of the merged linked list. dummy = ListNode() # Dummy node to simplify the merge process tail = dummy # Pointer to the last node in the merged list while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # At this point, at least one of l1 or l2 is None # Attach the remaining part if l1: tail.next = l1 else: tail.next = l2 return dummy.next # The head of the new merged list is the next of dummy"},{"question":"# Coding Question Problem Statement You are given an array of integers where each element appears twice except for one element which appears only once. Your task is to identify the unique element in the array. Write a function `find_unique_element` that returns the unique element from the given array. Your solution should have a linear runtime complexity (O(n)) and constant space complexity (O(1)). Input - A list of integers `arr` where `2 <= len(arr) <= 3 * 10^4`. - Every element in the array except one occurs exactly twice. Output - An integer representing the unique element in the array. Constraints - Your solution should run in O(n) time complexity. - Your solution should use O(1) additional space. Performance Requirement - The runtime complexity of your solution should be O(n). - The space complexity should be O(1). Examples 1. `find_unique_element([2, 2, 3, 4, 4, 5, 5])` should return `3`. 2. `find_unique_element([1, 1, 2, 3, 3, 4, 4])` should return `2`. 3. `find_unique_element([7, 3, 5, 3, 7])` should return `5`. Function Signature ```python def find_unique_element(arr: list[int]) -> int: Returns the unique element in the array where every element except one appears twice. pass ``` Additional Notes - Use the properties of XOR operation to achieve the required time and space complexity since XORing a number with itself results in 0 and XORing a number with 0 results in the number itself. - Here\'s a quick tip on how XOR works for this problem: - If you XOR all the elements, every element that appears twice will cancel itself out and the only remaining value will be the unique element.","solution":"def find_unique_element(arr): Returns the unique element in the array where every element except one appears twice. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Problem: Fibonacci Sequence - Optimized Computation Your task is to create a function to compute the nth Fibonacci number using an optimized approach that focuses on both time and space efficiency. Instead of the simple recursive method, which has exponential time complexity, you will implement this using an iterative approach with constant space complexity. Input * **n**: Integer representing the position in Fibonacci sequence (0-indexed) whose Fibonacci number is to be found. Output * Return an integer which is the nth Fibonacci number. # Constraints 1. `0 <= n <= 10^6` # Example ```python print(fibonacci_optimized(0)) # Outputs: 0 print(fibonacci_optimized(1)) # Outputs: 1 print(fibonacci_optimized(10)) # Outputs: 55 print(fibonacci_optimized(50)) # Outputs: 12586269025 ``` # Notes * The function should run efficiently even for large values of `n`, taking into consideration both time and space complexity. * Ensure that the edge cases (such as n = 0 and n = 1) are handled correctly and that the function returns the expected results without any overflow issues. # Function Signature ```python def fibonacci_optimized(n: int) -> int: # You need to implement this function ``` # Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This problem tests your ability to optimize recursive processes by employing iterative solutions and managing computational resources efficiently.","solution":"def fibonacci_optimized(n: int) -> int: Compute the nth Fibonacci number using an optimized iterative approach. :param n: The position in the Fibonacci sequence (0-indexed) whose Fibonacci number is to be computed. :return: The nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Unique Identifier Generation Context: You are working on a project that requires generating unique identifiers for a list of items. Each identifier should follow specific rules to ensure they are unique and recognizable. The identifier should be composed of a prefix followed by a numeric value that increments based on the order of items in the list. Task: Write a function `generate_identifiers(items: list[str], prefix: str) -> list[str]` that generates unique identifiers for a given list of items. The identifiers should start with the provided prefix followed by a dash and an incrementing numeric value starting from 1. Input: * A list of strings `items`, where each string is a unique item name. * A string `prefix`, which will be used as the prefix for all identifiers. Output: * A list of strings, where each string is a unique identifier for the corresponding item in the input list. Example: ```python def generate_identifiers(items: list[str], prefix: str) -> list[str]: Example usage: >>> generate_identifiers([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"item\\") [\\"item-1\\", \\"item-2\\", \\"item-3\\"] >>> generate_identifiers([\\"table\\", \\"chair\\"], \\"furniture\\") [\\"furniture-1\\", \\"furniture-2\\"] ``` Constraints: * The input list `items` will always contain unique strings. * The `prefix` will be a non-empty string containing only alphanumeric characters. * The numeric value in the identifiers should start from 1 and increment by 1 for each subsequent item. * Ensure the function works efficiently for a list of up to 10^6 items. **Edge Cases to consider**: * Handling empty input list should return an empty list. * The function should validate that each identifier is unique even if the order of items were to change. Requirements: * Ensure the function correctly handles all valid and edge case inputs. * Make sure the output format is consistent with the described identifier pattern.","solution":"def generate_identifiers(items: list[str], prefix: str) -> list[str]: Generates unique identifiers for a given list of items, using the specified prefix. :param items: List of unique item names. :param prefix: Prefix to be used for the identifiers. :return: List of unique identifiers. Example usage: >>> generate_identifiers([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"item\\") [\\"item-1\\", \\"item-2\\", \\"item-3\\"] >>> generate_identifiers([\\"table\\", \\"chair\\"], \\"furniture\\") [\\"furniture-1\\", \\"furniture-2\\"] return [f\\"{prefix}-{i+1}\\" for i in range(len(items))]"},{"question":"# Coding Assessment Question **Problem Statement:** You are given an array of `n` integers where each element appears exactly twice except for one element that appears exactly once. Your task is to find the element that appears only once. Implement a function `findUniqueElement(arr: List[int]) -> int` that returns the unique element in the array. **Function Signature:** ```python def findUniqueElement(arr: List[int]) -> int: pass ``` **Input:** - A list of integers `arr` (1 ≤ len(arr) ≤ 10^6), where each element `arr[i]` (0 ≤ arr[i] ≤ 10^9). **Output:** - An integer representing the unique element. **Constraints:** - Each element in the array appears exactly twice, except for one element which appears exactly once. **Example:** 1. `findUniqueElement([2, 3, 2, 4, 4, 5, 5])` should return `3`. 2. `findUniqueElement([7, 7, 8, 1, 1, 8, 9])` should return `9`. **Explanation:** 1. All elements appear twice except `3`. 2. All elements appear twice except `9`. # Hints: 1. Utilize bitwise operations to solve the problem efficiently. 2. XOR operation can help to find the unique element in linear time.","solution":"def findUniqueElement(arr): Finds the element that appears exactly once in the array where every other element appears exactly twice. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Question Implement a Movie Recommendation System using Collaborative Filtering for a small dataset of user ratings of movies. Dataset Preparation 1. Download the dataset from the link: [MovieLens Dataset](https://grouplens.org/datasets/movielens/latest/). 2. The dataset contains `ratings.csv` with columns `userId`, `movieId`, `rating`, and `timestamp`. Recommendation System Implementation 1. Load the dataset and create a pivot table where the rows represent userIds, columns represent movieIds, and values are the ratings given by users. 2. Normalize the ratings to handle missing data. 3. Apply Singular Value Decomposition (SVD) to decompose the user-item interaction matrix. 4. Construct recommendations for users by predicting the ratings for movies they haven\'t rated. Requirements - **Input:** User ID for which recommendations are to be generated. - **Output:** List of top 5 recommended movie IDs for the user. - Handle cases where a user ID does not exist in the dataset by providing a generic list of popular movies. # Implementation Details 1. Set up the user-item interaction matrix. 2. Normalize the data to subtract the mean rating for each user. 3. Perform SVD and reduce the dimensionality of the matrix. 4. Predict ratings for all user-item pairs and obtain the top 5 recommendations for a given user. # Constraints - Implement recommendations based on SVD with K=50 for the latent factors. - Ensure the system can handle sparse data efficiently. # Example ```python import pandas as pd import numpy as np from sklearn.decomposition import TruncatedSVD from sklearn.metrics.pairwise import cosine_similarity # Load dataset ratings = pd.read_csv(\'path/to/ratings.csv\') # Create the user-item interaction matrix ratings_matrix = ratings.pivot(index=\'userId\', columns=\'movieId\', values=\'rating\').fillna(0) # Normalize the data (subtract mean rating of each user) mean_user_rating = ratings_matrix.mean(axis=1) ratings_normalized = ratings_matrix.sub(mean_user_rating, axis=0) # Perform SVD svd = TruncatedSVD(n_components=50) matrix_reduced = svd.fit_transform(ratings_normalized) # Compute predicted ratings predicted_ratings = np.dot(matrix_reduced, svd.components_) + mean_user_rating.values[:, np.newaxis] def recommend_movies(user_id, n_recommendations=5): if user_id not in ratings_matrix.index: return [\\"Limited user data, recommending popular movies.\\"] user_idx = ratings_matrix.index.get_loc(user_id) user_predicted_ratings = predicted_ratings[user_idx] unseen_movies_idx = np.where(ratings_matrix.iloc[user_idx] == 0)[0] top_recommendations_idx = unseen_movies_idx[np.argsort(-user_predicted_ratings[unseen_movies_idx])[:n_recommendations]] return ratings_matrix.columns[top_recommendations_idx].tolist() # Usage user_id = 1 # Specified user ID for whom to generate recommendations recommendations = recommend_movies(user_id) print(recommendations) # Output: List of top `n` recommended movie IDs ``` Implement the recommendation system based on the steps above and provide the function that generates movie recommendations for a given user ID based on Collaborative Filtering.","solution":"import pandas as pd import numpy as np from sklearn.decomposition import TruncatedSVD # Load dataset. Placeholder for actual dataset loading, update the path as necessary. # ratings = pd.read_csv(\'path/to/ratings.csv\') # Example dataframe for testing purposes data = { \'userId\': [1, 1, 1, 2, 2, 2, 3, 3, 3], \'movieId\': [1, 2, 3, 1, 2, 4, 2, 3, 5], \'rating\': [4, 5, 3, 5, 3, 4, 2, 5, 4] } ratings = pd.DataFrame(data) def prepare_matrix(ratings): # Create the user-item interaction matrix ratings_matrix = ratings.pivot(index=\'userId\', columns=\'movieId\', values=\'rating\').fillna(0) return ratings_matrix def normalize_matrix(ratings_matrix): # Normalize the data (subtract mean rating of each user) mean_user_rating = ratings_matrix.mean(axis=1) ratings_normalized = ratings_matrix.sub(mean_user_rating, axis=0) return ratings_normalized, mean_user_rating def perform_svd(ratings_normalized, n_components=50): # Perform SVD svd = TruncatedSVD(n_components=n_components) matrix_reduced = svd.fit_transform(ratings_normalized) return svd, matrix_reduced def predict_ratings(svd, matrix_reduced, mean_user_rating): # Compute predicted ratings predicted_ratings = np.dot(matrix_reduced, svd.components_) + mean_user_rating.values[:, np.newaxis] return predicted_ratings def recommend_movies(user_id, ratings_matrix, predicted_ratings, n_recommendations=5): if user_id not in ratings_matrix.index: return [] user_idx = ratings_matrix.index.get_loc(user_id) user_predicted_ratings = predicted_ratings[user_idx] unseen_movies_idx = np.where(ratings_matrix.iloc[user_idx] == 0)[0] top_recommendations_idx = unseen_movies_idx[np.argsort(-user_predicted_ratings[unseen_movies_idx])[:n_recommendations]] return ratings_matrix.columns[top_recommendations_idx].tolist() ratings_matrix = prepare_matrix(ratings) ratings_normalized, mean_user_rating = normalize_matrix(ratings_matrix) svd, matrix_reduced = perform_svd(ratings_normalized, n_components=2) # adjust n_components for small data predicted_ratings = predict_ratings(svd, matrix_reduced, mean_user_rating) # Usage user_id = 1 # Specified user ID for whom to generate recommendations recommendations = recommend_movies(user_id, ratings_matrix, predicted_ratings) print(recommendations) # Output: List of top `n` recommended movie IDs"},{"question":"# Coding Question: Fenwick Tree (Binary Indexed Tree) Range Query Context You are required to manage and operate on a list of numbers, supporting both updates and range sum queries efficiently. The Fenwick Tree (Binary Indexed Tree) is a powerful data structure that supports these operations in logarithmic time. Task Using the provided `FenwickTree` class, which implements a Fenwick Tree to manage prefix sums, write a function `range_query` that answers a series of operations on a dynamic list of numbers. Function Signature ```python def range_query(operations: list[tuple[str, int, int]]) -> list[int]: Processes a sequence of operations on a dynamic list of numbers using Fenwick Tree. Args: operations: List of tuples where each tuple represents an operation in the format (op_type, index, value) - op_type: Operation type - \\"update\\" or \\"query\\" - index: Index position for the operation (integer) - value: Value to update or the right index of the range query Returns: List of results of each \\"query\\" operation. Example: range_query([ (\\"update\\", 1, 5), (\\"update\\", 2, 6), (\\"query\\", 1, 2), (\\"update\\", 3, 7), (\\"query\\", 1, 3) ]) => [11, 18] ``` Requirements * Implement an efficient handling of updates and range sum queries using the Fenwick Tree class. * The input list `operations` consists of multiple tuples where each tuple represents an operation on the dynamic list: - \\"update\\": Adds the given value to the existing value at the specified index. - \\"query\\": Computes the sum of values in the range from the first index to the second index (inclusive). * You can assume the `FenwickTree` class is pre-defined and available. * The function should return a list of results for each \\"query\\" operation. Constraints - The tuple elements will always follow the format (\\"operation_type\\", index, value). - For \\"update\\" operations, the value parameter is the value to be added at the specified index. - For \\"query\\" operations, the value parameter represents the right index of the range (the first index is specified in the second element of the tuple). Here is the `FenwickTree` class for reference: ```python class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def update(self, index: int, value: int): while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left: int, right: int) -> int: return self.prefix_sum(right) - self.prefix_sum(left - 1) ```","solution":"from typing import List, Tuple class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def update(self, index: int, value: int): while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left: int, right: int) -> int: return self.prefix_sum(right) - self.prefix_sum(left - 1) def range_query(operations: List[Tuple[str, int, int]]) -> List[int]: # Determine the maximum index to initialize the Fenwick Tree max_index = 0 for operation in operations: op_type, index, value = operation if op_type == \\"update\\": max_index = max(max_index, index) elif op_type == \\"query\\": max_index = max(max_index, index, value) fenwick_tree = FenwickTree(max_index) results = [] for operation in operations: op_type, index, value = operation if op_type == \\"update\\": fenwick_tree.update(index, value) elif op_type == \\"query\\": results.append(fenwick_tree.range_sum(index, value)) return results"},{"question":"# Anagram Pair Counter You are tasked with implementing a function that counts the number of anagram pairs in a list of strings. The function should handle various edge cases and input formats. Function Signature ```python def count_anagram_pairs(words: List[str]) -> int: pass ``` Input and Output * **Input** * `words` (List[str]): A list of strings, where each string consists of lowercase alphabets. (1 <= len(words) <= 10^5, 1 <= len(words[i]) <= 100) * **Output** * (int): Returns the total number of anagram pairs in the list. Constraints * The function should raise a `ValueError` if any string in `words` is empty or contains characters other than lowercase alphabets. * The function should raise a `TypeError` if `words` is not a list of strings. Example ```python >>> count_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) 4 >>> count_anagram_pairs([\\"abcd\\", \\"dcba\\", \\"bcda\\", \\"abcd\\"]) 3 >>> count_anagram_pairs([\\"apple\\", \\"pale\\"]) 0 >>> count_anagram_pairs([\\"race\\", \\"care\\", \\"acer\\", \\"acme\\", \\"mace\\", \\"came\\"]) 6 >>> count_anagram_pairs([\\"dog\\", \\"god\\", \\"cat\\", \\"tac\\", \\"act\\"]) 4 ``` Notes * Consider using an efficient algorithm to handle large lists of strings. * Avoid unnecessary comparisons by utilizing data structures that can help in identifying anagram pairs quickly.","solution":"from typing import List def count_anagram_pairs(words: List[str]) -> int: if not isinstance(words, list) or not all(isinstance(word, str) for word in words): raise TypeError(\\"The input must be a list of strings.\\") anagram_map = {} for word in words: if not word.isalpha() or not word.islower(): raise ValueError(\\"Each word must consist of lowercase alphabets only.\\") sorted_word = \'\'.join(sorted(word)) if sorted_word in anagram_map: anagram_map[sorted_word] += 1 else: anagram_map[sorted_word] = 1 count = 0 for value in anagram_map.values(): if value > 1: count += value * (value - 1) // 2 return count"},{"question":"# Problem Statement: You are tasked with building a data validation utility for a customer database. The utility function must validate a list of customer records and identify any erroneous data entries based on predefined rules. # Requirements: 1. **Input Structure**: The function will receive a list of dictionaries, where each dictionary represents a customer record containing these fields: * `\\"name\\"`: a string representing the customer\'s name. * `\\"age\\"`: an integer representing the customer\'s age. * `\\"email\\"`: a string representing the customer\'s email address. 2. **Validation Rules**: * Name: Must be a non-empty string consisting of alphabetic characters and spaces only. * Age: Must be an integer between 18 and 100 (inclusive). * Email: Must be a valid email format (contains an \\"@\\" symbol and a dot \\".\\"). 3. **Return Value**: The function should return a list of tuples, each containing: * The index of the record in the input list (0-based). * The field name that failed validation. * A brief message describing the validation error. 4. **Skipping Valid Records**: If all fields in a record are valid, it should not be included in the output list. # Constraints: * The input list can have up to 10^4 customer records. * Assume the input structure is always correct, and there won\'t be any missing keys in the dictionaries. # Function Signature: ```python def validate_customer_records(records: list[dict]) -> list[tuple[int, str, str]]: pass ``` # Example: ```python # Input customer_records = [ {\\"name\\": \\"Alice\\", \\"age\\": 28, \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"Bob42\\", \\"age\\": 35, \\"email\\": \\"bob@example\\"}, {\\"name\\": \\"\\", \\"age\\": 17, \\"email\\": \\"charlie@yahoo.com\\"}, {\\"name\\": \\"David\\", \\"age\\": 105, \\"email\\": \\"david@example.com\\"}, ] # The function call should return: # [ # (1, \\"name\\", \\"Invalid name format\\"), # (1, \\"email\\", \\"Invalid email format\\"), # (2, \\"name\\", \\"Name cannot be empty\\"), # (2, \\"age\\", \\"Age must be between 18 and 100\\"), # (3, \\"age\\", \\"Age must be between 18 and 100\\"), # ] ``` # Task: Implement the `validate_customer_records` function which takes a list of customer records and validates each record based on the rules provided. # Hint: Consider using regular expressions to validate the email format and the characters in the name.","solution":"import re def validate_customer_records(records): errors = [] for idx, record in enumerate(records): name = record.get(\\"name\\", \\"\\") age = record.get(\\"age\\", 0) email = record.get(\\"email\\", \\"\\") if not isinstance(name, str) or not name or not name.replace(\\" \\", \\"\\").isalpha(): errors.append((idx, \\"name\\", \\"Invalid name format\\")) if not isinstance(age, int) or age < 18 or age > 100: errors.append((idx, \\"age\\", \\"Age must be between 18 and 100\\")) email_regex = r\\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\\" if not isinstance(email, str) or not re.match(email_regex, email): errors.append((idx, \\"email\\", \\"Invalid email format\\")) return errors"},{"question":"# Coding Assessment Question Context: You are tasked with implementing a simplified version of the A* (A-star) algorithm to find the shortest path in a 2-dimensional grid. The grid is represented as a 2D list of integers where 0s represent walkable cells and 1s represent obstacles. The algorithm needs to efficiently find the shortest path from a given start position to a target position if such a path exists. Task: Implement the function `find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]` which: 1. Accepts a 2D list of integers representing the grid. 2. Accepts two tuples of integers representing the start and target positions. 3. Returns a list of tuples representing the shortest path from the start position to the target position, including both the start and target positions. If no path exists, return an empty list. Input: - `grid`: A 2D list of integers representing the grid where 0 is a walkable cell and 1 is an obstacle. - `start`: A tuple `(x, y)` representing the starting coordinates. - `target`: A tuple `(x, y)` representing the target coordinates. Output: - A list of tuples representing the shortest path from the start to the target, inclusive of both. Return an empty list if no path exists. Constraints: 1. The grid size is `n x m` where `1 <= n, m <= 100`. 2. The start and target positions will always be within the grid\'s boundaries. Example: ```python grid = [ [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) target = (4, 4) assert find_shortest_path(grid, start, target) == [(0, 0), (1, 2), (2, 2), (3, 2), (4, 3), (4, 4)] or any other shortest valid path. grid = [ [0, 1], [1, 0] ] start = (0, 0) target = (1, 1) assert find_shortest_path(grid, start, target) == [] ``` Note: - You may assume that the paths can only move in the four possible directions (left, right, up, down) and cannot move diagonally. - Handle large grids efficiently as performance might be a concern. You may use the following function skeleton: ```python def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: pass ```","solution":"from typing import List, Tuple import heapq def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: def h(pos: Tuple[int, int]) -> int: # Heuristic function: Manhattan distance to the target return abs(pos[0] - target[0]) + abs(pos[1] - target[1]) def get_neighbors(pos: Tuple[int, int]) -> List[Tuple[int, int]]: x, y = pos neighbors = [] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors open_set = [] came_from = {} g_score = {start: 0} f_score = {start: h(start)} heapq.heappush(open_set, (f_score[start], start)) while open_set: _, current = heapq.heappop(open_set) if current == target: # Reconstruct path path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + h(neighbor) if all(neighbor != item[1] for item in open_set): heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Matrix Manipulation to Find Maximum Sum Submatrix You are tasked with writing a function that finds the submatrix with the maximum sum in a given 2D matrix. The submatrix should be at least 1x1 in size and can extend to the entire matrix. **Function Signature** ```python def max_sum_submatrix(matrix: List[List[int]]) -> int: ``` # Input 1. `matrix` (List[List[int]]): A 2D list of integers representing the matrix. # Output An `int` representing the sum of the submatrix with the maximum sum. # Constraints - ( 1 leq text{number of rows in matrix} leq 100 ) - ( 1 leq text{number of columns in matrix} leq 100 ) - (-1000 leq text{matrix[i][j]} leq 1000) # Examples ```python # Example 1 matrix = [ [1, -2, 3], [4, -1, -2], [3, 4, -1] ] print(max_sum_submatrix(matrix)) # Output: 10 (submatrix [[4, -1], [3, 4]] has the maximum sum) # Example 2 matrix = [ [-1, -1, -1], [-1, 5, -1], [-1, -1, -1] ] print(max_sum_submatrix(matrix)) # Output: 5 (submatrix [[5]] has the maximum sum) # Example 3 matrix = [ [-2, -3, 4, -1, -2], [1, 5, -3, 4, 2], [-3, -2, 4, -2, 2], [1, -1, 3, -1, -2] ] print(max_sum_submatrix(matrix)) # Output: 10 (submatrix [[1, -1, 3], [-2, 4, 2]] has the maximum sum) ``` # Hint To achieve this, you may use the Kadane’s algorithm for 1D arrays as a helper to extend it for the 2D matrix. Consider extending Kadane’s algorithm to each row and combining results for each possible row pair.","solution":"from typing import List def max_sum_submatrix(matrix: List[List[int]]) -> int: def kadane(arr: List[int]) -> int: max_end_here = max_so_far = arr[0] for i in range(1, len(arr)): max_end_here = max(arr[i], max_end_here + arr[i]) max_so_far = max(max_so_far, max_end_here) return max_so_far rows, cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"# Graph - Finding Strongly Connected Components You are tasked with developing a function to identify all the strongly connected components (SCCs) in a given directed graph using Tarjan\'s algorithm. A strongly connected component is a maximal subgraph where every pair of vertices is reachable from each other. **Expected Input and Output Formats**: * **Input**: A directed graph represented as an adjacency list. * **Output**: A list of lists, where each inner list represents the vertices in one SCC. **Constraints/Limitations**: * The graph may be empty; in this case, return an empty list. * The graph is represented as a dictionary where the keys are node identifiers, and the values are lists of nodes representing directed edges. * Node identifiers are integers. **Function Signature**: ```python def find_sccs(graph: dict[int, list[int]]) -> list[list[int]]: ... ``` # Example: ```python # Example input and validation graph = { 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3] } sccs = find_sccs(graph) print(sccs) # Should output components such as [[0, 2, 1], [3, 5, 4]] or any valid permutation of SCC representation # Edge case: empty graph empty_sccs = find_sccs({}) print(empty_sccs) # Should output [] ``` **Notes**: * Ensure the function handles all edge cases, including empty graphs. * The function should employ Tarjan\'s algorithm to ensure linear time complexity.","solution":"def find_sccs(graph): Finds all strongly connected components (SCCs) in a given directed graph using Tarjan\'s algorithm. :param graph: Directed graph represented as an adjacency list (dictionary). :return: A list of lists where each inner list is a SCC. index = { } lowlink = { } stack = [ ] result = [ ] index_counter = 0 def strongconnect(node): nonlocal index_counter index[node] = index_counter lowlink[node] = index_counter index_counter += 1 stack.append(node) for neighbor in graph[node]: if neighbor not in index: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif neighbor in stack: lowlink[node] = min(lowlink[node], index[neighbor]) if lowlink[node] == index[node]: scc = [ ] while True: w = stack.pop() scc.append(w) if w == node: break result.append(scc) for node in graph: if node not in index: strongconnect(node) return result"},{"question":"# Question: Log File Parser - Frequency Analysis Scenario You work for a monitoring company that tracks web server logs to analyze server usage patterns. The logs contain entries in the following format: ``` <timestamp> <log_level> <message> ``` For example: ``` 2023-10-01T12:34:56Z INFO User login successful 2023-10-01T12:35:01Z ERROR File not found 2023-10-01T12:36:22Z WARNING Disk space low ``` The log entries are stored in a text file where each line contains one entry. You need to write a parser to read this log file, count the occurrences of each log level, and provide a summary report. Task Implement a function `analyze_log_file(file_path: str) -> Dict[str, int]` that reads a log file and returns a dictionary with the frequencies of each log level. # Input and Output * **Input**: A string `file_path` representing the path to the log file. * **Output**: A dictionary where keys are log levels (`INFO`, `ERROR`, `WARNING`) and values are the counts of their occurrences. # Example Inputs and Outputs ```python # Given a log file with the following content: # 2023-10-01T12:34:56Z INFO User login successful # 2023-10-01T12:35:01Z ERROR File not found # 2023-10-01T12:36:22Z WARNING Disk space low # 2023-10-01T12:37:10Z INFO Page accessed print(analyze_log_file(\\"path/to/log/file.txt\\")) # Expected: {\'INFO\': 2, \'ERROR\': 1, \'WARNING\': 1} # Given a log file with the following content: # 2023-10-01T12:34:56Z INFO User login successful # 2023-10-01T12:35:01Z INFO User logout # 2023-10-01T12:36:22Z INFO Page accessed print(analyze_log_file(\\"path/to/another/log/file.txt\\")) # Expected: {\'INFO\': 3, \'ERROR\': 0, \'WARNING\': 0} ``` # Constraints * The log file is guaranteed to contain entries in the specified format. * Each log level (`INFO`, `ERROR`, `WARNING`) should be counted, even if its frequency is zero. # Requirements - Read and process the log file to extract log levels. - Keep a count of each log level and return the result as a dictionary. - Ensure that the function handles large log files efficiently. - Provide clear documentation and examples for the function.","solution":"from typing import Dict def analyze_log_file(file_path: str) -> Dict[str, int]: Reads a log file and returns a dictionary with the frequencies of each log level. Args: file_path (str): The path to the log file. Returns: Dict[str, int]: A dictionary with log levels as keys and their frequencies as values. log_levels = {\\"INFO\\": 0, \\"ERROR\\": 0, \\"WARNING\\": 0} with open(file_path, \'r\') as file: for line in file: parts = line.split(\' \') if len(parts) > 1: log_level = parts[1] if log_level in log_levels: log_levels[log_level] += 1 return log_levels"},{"question":"You are tasked with implementing a function that takes a list of integers and returns a new list where each integer is replaced by the sum of itself and its immediate neighbors in the list. # Requirements: Implement a function `sum_neighbors(arr: list[int]) -> list[int]` with the following parameter: * `arr` (list[int]): A list of integers. (1 ≤ len(arr) ≤ 10^5, -10^4 ≤ arr[i] ≤ 10^4 for each element arr[i]) # Expected Output: The function should return a new list of integers where each element is the sum of itself and its immediate neighbors in the input list. # Constraints: * For the first element, only consider itself and the next element. * For the last element, only consider itself and the previous element. * If the input list has only one element, the output should be the same single element. # Examples: ```python >>> sum_neighbors([1, 2, 3, 4, 5]) [3, 6, 9, 12, 9] >>> sum_neighbors([4, -2, 3]) [2, 5, 1] >>> sum_neighbors([1]) [1] >>> sum_neighbors([5, 5, 5, 5]) [10, 15, 15, 10] >>> sum_neighbors([-1, 0, 1]) [-1, 0, 1] ``` # Performance Considerations: Ensure the implementation can handle the potential upper limits of input sizes efficiently in terms of both time and space.","solution":"def sum_neighbors(arr): if len(arr) == 1: return arr res = [] n = len(arr) for i in range(n): # handle the first element if i == 0: res.append(arr[i] + arr[i+1]) # handle the last element elif i == n-1: res.append(arr[i] + arr[i-1]) # handle all other elements else: res.append(arr[i-1] + arr[i] + arr[i+1]) return res"},{"question":"# Context You are working with a tree data structure and need to implement additional functionality for a more efficient query. One critical operation, `find_lowest_common_ancestor`, already finds the lowest common ancestor of two nodes in the tree. # Task Implement a function `max_value_in_path(self, node1: int, node2: int) -> int` within the `BinaryTree` class that finds the maximum value encountered along the path between two nodes in the tree. # Function Signature ```python class BinaryTree: def max_value_in_path(self, node1: int, node2: int) -> int: # Your code here ``` # Input * Two integers `node1` and `node2`, representing the values of the two nodes between which you need to find the maximum value on the path. # Output * An integer representing the maximum value found between the nodes `node1` and `node2`. # Constraints * The tree contains at least one node and at most 1000 nodes. * All node values are unique integers within the range [1, 10000]. # Example ```python >>> bt = BinaryTree() >>> bt.add(3) >>> bt.add(1) >>> bt.add(4) >>> bt.add(0) >>> bt.add(2) >>> bt.add(5) >>> bt.max_value_in_path(0, 5) 5 >>> bt.max_value_in_path(1, 4) 4 ``` # Notes * The values of the nodes in the path include `node1`, `node2`, and all nodes in between. * You may assume that `node1` and `node2` exist in the tree. * The tree can be assumed to be a Binary Search Tree for which the constraint can hold true.","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, key): if not self.root: self.root = Node(key) else: self._add(self.root, key) def _add(self, root, key): if key < root.data: if not root.left: root.left = Node(key) else: self._add(root.left, key) else: if not root.right: root.right = Node(key) else: self._add(root.right, key) def find_lowest_common_ancestor(self, root, node1, node2): while root: if root.data > node1 and root.data > node2: root = root.left elif root.data < node1 and root.data < node2: root = root.right else: return root def max_value_in_path(self, node1, node2): lca = self.find_lowest_common_ancestor(self.root, node1, node2) max_value = lca.data max_value = max(max_value, self._max_value_from_node(lca, node1)) max_value = max(max_value, self._max_value_from_node(lca, node2)) return max_value def _max_value_from_node(self, root, target): max_value = root.data while root.data != target: if root.data < target: root = root.right else: root = root.left max_value = max(max_value, root.data) return max_value"},{"question":"# Scenario A retailer needs a system to manage its inventory and pricing dynamically. They have multiple items each identified by a unique SKU (Stock Keeping Unit). Each SKU has a list of prices given by various suppliers. The retailer’s goal is to always purchase items at the minimum possible cost, while keeping track of the current minimum price for each SKU. # Problem Given the details of items and their prices from different suppliers, implement the function `min_prices(items: list[tuple[int, list[float]]]) -> dict` that returns a dictionary where the key is the SKU and the value is the minimum price of that item currently available. Input * `items`: A list of tuples. Each tuple consists of two elements: * An integer representing the SKU of the item. * A list of floats representing the prices given by different suppliers for that SKU. Output * A dictionary where each key is an SKU, and its corresponding value is the minimum price available for that SKU. Constraints * The list of prices for each SKU will have at least one price. * Each price will be a positive float. * Each SKU will be a unique integer in the input list. # Example ```python def min_prices(items: list[tuple[int, list[float]]]) -> dict: # Function body here # Example data items = [ (101, [23.95, 19.99, 25.50]), (202, [34.95, 30.99]), (303, [99.99, 89.90, 95.50, 80.00]) ] result = min_prices(items) print(result) # Should print {101: 19.99, 202: 30.99, 303: 80.00} ``` Performance Requirement * The solution must efficiently find the minimum price for each SKU. # Note Ensure that your function correctly processes all given prices to find the minimum for each SKU and constructs the dictionary as per the problem requirements.","solution":"def min_prices(items: list[tuple[int, list[float]]]) -> dict: Returns a dictionary where the key is the SKU and the value is the minimum price of that item currently available. :param items: A list of tuples. Each tuple consists of: - An integer SKU. - A list of floats representing prices from different suppliers. :return: A dictionary mapping each SKU to its minimum price. min_price_dict = {} for sku, prices in items: min_price_dict[sku] = min(prices) return min_price_dict"},{"question":"# Task: You are required to implement a class `SparseVector` that provides efficient operations for vector addition, dot product, and retrieval of non-zero elements. This class will leverage a space-efficient representation to store only non-zero elements. # Requirements: - Implement the necessary methods to handle vector operations efficiently, ensuring the operations are optimized for sparse data. - Ensure any data structures used maintain efficiency in both time and space complexity. # Detailed Function Requirements: 1. **`__init__(self, size: int) -> None`**: Initializes a sparse vector of a given size. * **Input**: `size` - an integer representing the length of the vector. * **Output**: None. 2. **`set_value(self, index: int, value: int) -> None`**: Sets the element at `index` to `value`. * **Input**: `index` - the position in the vector, `value` - the value to be assigned at the specified index. * **Output**: None. * **Constraints**: If `value` is 0, it removes the element from the storage. 3. **`get_value(self, index: int) -> int`**: Retrieves the value at `index`. * **Input**: `index` - the position in the vector. * **Output**: The value at the specified index. * **Constraints**: Returns 0 if the element at the index is not stored (i.e., it was zero). 4. **`vector_add(self, other: \'SparseVector\') -> \'SparseVector\'`**: Adds the current vector instance with another `SparseVector` and returns the result as a new `SparseVector`. * **Input**: `other` - a `SparseVector` to add to the current vector. * **Output**: A new `SparseVector` representing the sum of the two vectors. * **Constraints**: Both vectors must be of the same size, otherwise raises `ValueError`. 5. **`dot_product(self, other: \'SparseVector\') -> int`**: Computes the dot product of the current vector instance with another `SparseVector`. * **Input**: `other` - a `SparseVector` to compute the dot product with. * **Output**: An integer representing the dot product of the two vectors. * **Constraints**: Both vectors must be of the same size, otherwise raises `ValueError`. 6. **`retrieve_non_zero(self) -> List[Tuple[int, int]]`**: Retrieves a list of tuples where each tuple contains an index and its corresponding non-zero value in the vector. * **Input**: None. * **Output**: A list of non-zero elements as (index, value) pairs. # Constraints: - The methods must efficiently handle large vectors with a sparse distribution of non-zero elements. - Considerations must be made for all edge cases, such as index out of bounds, type mismatches, and operations on empty vectors. # Example Usage: ```python vector1 = SparseVector(5) vector2 = SparseVector(5) vector1.set_value(0, 1) vector1.set_value(2, 3) vector2.set_value(1, 4) vector2.set_value(2, 5) print(vector1.get_value(0)) # Output: 1 print(vector1.get_value(1)) # Output: 0 print(vector2.get_value(1)) # Output: 4 result_vector = vector1.vector_add(vector2) print(result_vector.retrieve_non_zero()) # Output: [(0, 1), (1, 4), (2, 8)] print(vector1.dot_product(vector2)) # Output: 15 ``` # Note: Your implementation should ensure efficient storage and retrieval of elements, optimized for vectors with a large number of zero elements.","solution":"class SparseVector: def __init__(self, size: int) -> None: self.size = size self.values = {} def set_value(self, index: int, value: int) -> None: if index < 0 or index >= self.size: raise ValueError(\\"Index out of bounds\\") if value != 0: self.values[index] = value elif index in self.values: del self.values[index] def get_value(self, index: int) -> int: if index < 0 or index >= self.size: raise ValueError(\\"Index out of bounds\\") return self.values.get(index, 0) def vector_add(self, other: \'SparseVector\') -> \'SparseVector\': if self.size != other.size: raise ValueError(\\"Vectors must be of the same size\\") result = SparseVector(self.size) for index, value in self.values.items(): result.set_value(index, value + other.get_value(index)) for index, value in other.values.items(): if index not in self.values: result.set_value(index, value) return result def dot_product(self, other: \'SparseVector\') -> int: if self.size != other.size: raise ValueError(\\"Vectors must be of the same size\\") product_sum = 0 for index, value in self.values.items(): product_sum += value * other.get_value(index) return product_sum def retrieve_non_zero(self) -> list: return list(self.values.items())"},{"question":"# Scenario You are working on a project that involves processing large datasets of numerical sensor readings. These readings need to be continuously smoothed and filtered to remove noise before any further analysis. A common approach to this is using a moving average filter that computes the average of the last N readings to smooth out fluctuations. # Challenge Implement a `MovingAverage` class that maintains the moving average of a fixed number of latest readings from a stream of sensor data. # Task 1. Implement the `__init__` method to initialize the moving average with a specified window size. 2. Implement the `next_value` method that takes a new reading from the stream and returns the current moving average. 3. Ensure the `next_value` method operates efficiently with continuous data streams. # Requirements - Implement the methods as specified. - Use a deque to maintain a fixed-size list of the most recent readings. - Optimize for efficient updating of the moving average with each new reading. - Handle edge cases like the initial readings where the number of readings is less than the window size. # Input and Output - Input: Sequence of sensor readings as integers. - Output: For each reading, return the current moving average. # Example Suppose you have the following sequence of operations: ```python m = MovingAverage(window_size=3) print(m.next_value(1)) # Output: 1.0 (average of [1]) print(m.next_value(10)) # Output: 5.5 (average of [1, 10]) print(m.next_value(3)) # Output: 4.67 (average of [1, 10, 3]) print(m.next_value(5)) # Output: 6.0 (average of [10, 3, 5]) ``` # Constraints - Window size is a positive integer. - Readings are integers. - The number of readings can be significantly larger than the window size. Implement the `MovingAverage` class with the required methods and ensure it correctly maintains and computes the moving average in an efficient manner.","solution":"from collections import deque class MovingAverage: def __init__(self, window_size): Initializes the MovingAverage with a specified window size. self.window_size = window_size self.readings = deque(maxlen=window_size) self.sum = 0 def next_value(self, reading): Takes a new reading and returns the current moving average. if len(self.readings) == self.window_size: old_value = self.readings.popleft() self.sum -= old_value self.readings.append(reading) self.sum += reading return self.sum / len(self.readings)"},{"question":"# Coding Assessment Question: Normalized Hamming Distance **Scenario**: You are working on a string analysis tool and need to implement a specific metric to compare two binary strings. The Hamming distance counts the number of differing bits between two binary strings. For a more normalized comparison, your task is to compute the normalized Hamming distance between two binary strings of equal length. The normalized Hamming distance is calculated as the Hamming distance divided by the length of the strings. **Objective**: Write a function called `normalized_hamming_distance` that accepts two binary strings of equal length and returns their normalized Hamming distance. **Function Signature**: ```python def normalized_hamming_distance(str1: str, str2: str) -> float: pass ``` **Input**: - `str1` (str): A binary string (composed of \'0\'s and \'1\'s). - `str2` (str): Another binary string of the same length as `str1`. **Output**: - `float`: The normalized Hamming distance. **Constraints**: - Both input strings will have lengths between 1 and 1000. - Both input strings will only contain \'0\' and \'1\' characters. - The strings are guaranteed to be of the same length. **Performance Requirements**: - Your implementation should be efficient, with a time complexity of O(n), where n is the length of the strings. **Example**: ```python print(normalized_hamming_distance(\\"1101\\", \\"1001\\")) # Expected output: 0.25 print(normalized_hamming_distance(\\"101010\\", \\"010101\\")) # Expected output: 1.0 ``` Additionally, ensure your implementation passes the following test: ```python str1 = \\"11011001\\" str2 = \\"11011111\\" expected_output = 0.25 assert normalized_hamming_distance(str1, str2) == expected_output ```","solution":"def normalized_hamming_distance(str1: str, str2: str) -> float: Returns the normalized Hamming distance between two binary strings of equal length. if len(str1) != len(str2): raise ValueError(\\"Input strings must be of the same length.\\") distance = sum(c1 != c2 for c1, c2 in zip(str1, str2)) normalized_distance = distance / len(str1) return normalized_distance"},{"question":"# Coding Assessment Question **Objective**: Develop a function to calculate the average score of a student from a list of test scores, excluding the highest and the lowest scores. Ensure that the function handles invalid input scenarios smartly. # Problem Statement You are given a list of test scores, where each score is a non-negative integer. Write a function `average_score` that calculates the average score after excluding the highest and the lowest scores in the list. If the list has fewer than 3 scores, raise a `ValueError` indicating that the calculation cannot be performed. # Requirements: - If any score in the list is negative, raise a `ValueError` indicating invalid input. - If the list contains fewer than 3 scores, raise a `ValueError` indicating that the calculation cannot be performed. - Return the average score as a float, rounded to two decimal places. # Function Signature ```python def average_score(scores: List[int]) -> float: ``` # Input Format: - `scores` (List[int]): A list of non-negative integers representing test scores. # Output Format: - `float`: The average score after excluding the highest and the lowest scores, rounded to two decimal places. # Constraints: - Each score in `scores` ≥ 0 - Length of `scores` ≥ 3 # Example ```python # Example Input scores = [80, 90, 100, 70, 85] # Function Call print(average_score(scores)) # Expected Output 85.0 ``` # Additional Examples ```python >>> average_score([50, 60, 70, 80, 90]) 70.0 >>> average_score([100, 100, 100]) 100.0 >>> average_score([85, 95]) Traceback (most recent call last): ... ValueError: Calculation cannot be performed: the list must contain at least 3 scores. >>> average_score([85, 95, -70, 60]) Traceback (most recent call last): ... ValueError: Invalid input: all scores must be non-negative ``` # Notes: - Be strict on input validations. - Ensure the average calculation excludes only the single highest and lowest scores. - Ensure performance efficiency. - Perform thorough testing, particularly for edge cases.","solution":"from typing import List def average_score(scores: List[int]) -> float: if len(scores) < 3: raise ValueError(\\"Calculation cannot be performed: the list must contain at least 3 scores.\\") if any(score < 0 for score in scores): raise ValueError(\\"Invalid input: all scores must be non-negative\\") scores_sorted = sorted(scores) trimmed_scores = scores_sorted[1:-1] # Exclude the lowest and highest scores average = sum(trimmed_scores) / len(trimmed_scores) return round(average, 2)"},{"question":"# Rotate Matrix by 90 Degrees Your task is to implement a function to rotate an image represented by an n x n matrix by 90 degrees clockwise. # Objective Write a function `rotate_matrix` that takes as input an n x n matrix representing an image and outputs the image rotated by 90 degrees clockwise. # Implementation Details 1. The function should rotate the given matrix in-place. 2. You are allowed to use additional space for intermediate results, but the input matrix should be modified directly to produce the final rotated matrix. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: ... ``` # Input - **matrix**: a list of lists of integers where each list represents a row in the n x n matrix. # Outputs - The function should modify the input matrix in-place, and hence does not return anything. The matrix should be rotated by 90 degrees clockwise. # Constraints - The matrix dimensions (n, n) are such that 1 ≤ n ≤ 1000. - The elements of the matrix range from -1000 to 1000. # Example Given a 3x3 matrix: ```plaintext [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The output matrix (rotated by 90 degrees clockwise): ```plaintext [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Ensure the function operates efficiently and modifies the matrix in-place.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are given a non-negative integer `num`. Your task is to implement a function that converts the number into its equivalent binary string and then counts the number of consecutive sequences of \'1\'s within that binary representation. # Function Signature ```python def count_consecutive_ones(num: int) -> int: pass ``` # Input * `num`: a non-negative integer. # Output * An integer representing the number of consecutive sequences of \'1\'s in the binary representation of the input number. # Constraints * `0 <= num <= 10^9` # Example ```python >>> count_consecutive_ones(29) 2 # Explanation: The binary representation of 29 is \'11101\'. There are two consecutive sequences of \'1\'s: \'111\' and \'1\'. >>> count_consecutive_ones(15) 1 # Explanation: The binary representation of 15 is \'1111\'. There is one consecutive sequence of \'1\'s. >>> count_consecutive_ones(0) 0 # Explanation: The binary representation of 0 is \'0\'. There are no sequences of \'1\'s. >>> count_consecutive_ones(9) 2 # Explanation: The binary representation of 9 is \'1001\'. There are two consecutive sequences of \'1\'s: \'1\' and \'1\'. ``` # Notes * Make sure the function handles edge cases like 0 and very large numbers up to (10^9). * The binary conversion should be handled within the function.","solution":"def count_consecutive_ones(num: int) -> int: Converts the given non-negative integer to its binary representation and counts the number of consecutive sequences of \'1\'s. Parameters: num (int): A non-negative integer. Returns: int: The number of consecutive sequences of \'1\'s in the binary representation of num. binary_representation = bin(num)[2:] # Convert to binary and remove the \'0b\' prefix sequences = 0 is_in_sequence = False for char in binary_representation: if char == \'1\': if not is_in_sequence: sequences += 1 is_in_sequence = True else: is_in_sequence = False return sequences"},{"question":"# Problem Statement Develop a function that simulates the process of generating a secure password. The function should combine random letters (both uppercase and lowercase), digits, and special characters to create a password of a specified length. The password must include at least one character from each category (uppercase, lowercase, digits, special characters). # Function Signature ```python import string import random def generate_password(length: int) -> str: pass ``` # Input - `length`: A positive integer representing the desired length of the password. Must be at least 4, to ensure including one character from each category. # Output - A string representing the generated secure password. # Constraints - `length` must be a positive integer greater than or equal to 4. # Requirement - If `length` is less than 4, raise a `ValueError` with the message `\\"Password length must be at least 4\\"`. # Examples 1. `generate_password(8)` might return `\\"A8c!2Bd\\"` 2. `generate_password(12)` might return `\\"G3@f4dIe#9Pw\\"` 3. `generate_password(4)` might return `\\"T2h\\"` 4. `generate_password(3)` raises `ValueError` # Context This problem assesses your ability to manipulate strings and random modules in Python. It also tests your understanding of handling constraints and ensuring security features within generated content. # Detailed Instructions 1. Validate that the `length` parameter is at least 4. 2. Ensure the generated password includes at least one uppercase letter, one lowercase letter, one digit, and one special character. 3. Fill the remaining length of the password with a random selection of all acceptable characters. 4. Shuffle the result to avoid predictable sequences. 5. Return the final password as a string. ```python import string import random def generate_password(length: int) -> str: if length < 4: raise ValueError(\\"Password length must be at least 4\\") uppercase = random.choice(string.ascii_uppercase) lowercase = random.choice(string.ascii_lowercase) digit = random.choice(string.digits) special = random.choice(string.punctuation) remaining_length = length - 4 all_characters = string.ascii_letters + string.digits + string.punctuation # Generate the remaining characters password = [uppercase, lowercase, digit, special] + [random.choice(all_characters) for _ in range(remaining_length)] # Shuffle to ensure randomness random.shuffle(password) return \'\'.join(password) ```","solution":"import string import random def generate_password(length: int) -> str: if length < 4: raise ValueError(\\"Password length must be at least 4\\") uppercase = random.choice(string.ascii_uppercase) lowercase = random.choice(string.ascii_lowercase) digit = random.choice(string.digits) special = random.choice(string.punctuation) remaining_length = length - 4 all_characters = string.ascii_letters + string.digits + string.punctuation # Generate the remaining characters password = [uppercase, lowercase, digit, special] + [random.choice(all_characters) for _ in range(remaining_length)] # Shuffle to ensure randomness random.shuffle(password) return \'\'.join(password)"},{"question":"# Chessboard Pattern Generator Problem Statement: You are required to implement a function that generates a string representing a chessboard pattern. The pattern consists of alternating \'B\' (for black) and \'W\' (for white) characters, starting with \'B\' in the top-left corner. The function should handle edge cases such as zero or negative inputs gracefully. The dimensions of the chessboard should be `n` rows by `m` columns. Function Signature ```python def chessboard_pattern(n: int, m: int) -> str: Generates a chessboard pattern of size n x m where \'B\' and \'W\' are alternating. Args: n (int): The number of rows of the chessboard. m (int): The number of columns of the chessboard. Returns: str: The complete chessboard pattern, each row of the pattern separated by a newline character (`n`). Input: * `n` (int): Number of rows in the chessboard. * `m` (int): Number of columns in the chessboard. Output: * Return a string representing the complete chessboard pattern, each row of the pattern separated by a newline character (`n`). Constraints: * `n` and `m` can be any integer. Examples: ```python >>> print(chessboard_pattern(3, 3)) \'\'\' B W B W B W B W B \'\'\' >>> print(chessboard_pattern(4, 5)) \'\'\' B W B W B W B W B W B W B W B W B W B W \'\'\' >>> print(chessboard_pattern(0, 4)) \' ... nothing printing :(\' >>> print(chessboard_pattern(-3, 5)) \' ... nothing printing :(\' >>> print(chessboard_pattern(4, 0)) \' ... nothing printing :(\' ``` # Guidelines: 1. Use iteration constructs to build the pattern. 2. Consider edge cases such as when `n` or `m` is 0 or negative. 3. Ensure proper alternating of \'B\' and \'W\' characters in the pattern. 4. Aim for a clear and readable implementation, possibly breaking down the logic into helper functions if needed.","solution":"def chessboard_pattern(n: int, m: int) -> str: Generates a chessboard pattern of size n x m where \'B\' and \'W\' are alternating. Args: n (int): The number of rows of the chessboard. m (int): The number of columns of the chessboard. Returns: str: The complete chessboard pattern, each row of the pattern separated by a newline character (`n`). if n <= 0 or m <= 0: return \\"\\" pattern = [] for row in range(n): line = [] for col in range(m): if (row + col) % 2 == 0: line.append(\'B\') else: line.append(\'W\') pattern.append(\\" \\".join(line)) return \\"n\\".join(pattern)"},{"question":"# Coding Assessment Question **Problem Statement:** You are working with a system that keeps track of user login activity. Each user can log in and out multiple times, and each activity is logged with a timestamp and the action (\\"login\\" or \\"logout\\"). Your task is to determine the maximum number of users that were logged in simultaneously at any point in the given logs. Implement a function `maxConcurrentUsers(logs: List[Tuple[str, str]]) -> int` that returns the maximum number of users logged in at any time. **Function Signature:** ```python def maxConcurrentUsers(logs: List[Tuple[str, str]]) -> int: pass ``` **Input:** - A list of tuples `logs`, where each tuple `(timestamp, action)` represents a user activity. The `timestamp` is a string in the format `\\"HH:MM\\"`, and `action` is either `\\"login\\"` or `\\"logout\\"`. **Output:** - An integer representing the maximum number of users logged in simultaneously. **Constraints:** - The `timestamp` format ensures that the logs are sorted chronologically. - Log entries are non-empty and conform to the format. **Example:** 1. `maxConcurrentUsers([(\\"09:00\\", \\"login\\"), (\\"09:30\\", \\"login\\"), (\\"10:00\\", \\"logout\\"), (\\"10:30\\", \\"login\\"), (\\"11:00\\", \\"logout\\"), (\\"11:30\\", \\"logout\\")])` should return `2`. 2. `maxConcurrentUsers([(\\"08:00\\", \\"login\\"), (\\"09:00\\", \\"logout\\"), (\\"10:00\\", \\"login\\"), (\\"11:00\\", \\"logout\\")])` should return `1`. **Explanation:** 1. The maximum number of users logged in simultaneously is 2 (from 09:30 to 10:00). 2. The maximum number of users logged in simultaneously is 1 (between each login and the subsequent logout). # Hints: 1. Consider maintaining a counter to track current logged-in users as you process each log entry. 2. Keep a record of the peak number encountered during this process.","solution":"def maxConcurrentUsers(logs): Returns the maximum number of users logged in simultaneously at any point in the given logs. :param logs: List of tuples, where each tuple contains a timestamp and an action (\\"login\\" or \\"logout\\"). :type logs: List[Tuple[str, str]] :return: Max number of concurrent users logged in at any point. :rtype: int concurrent_users = 0 max_concurrent_users = 0 for timestamp, action in logs: if action == \\"login\\": concurrent_users += 1 elif action == \\"logout\\": concurrent_users -= 1 if concurrent_users > max_concurrent_users: max_concurrent_users = concurrent_users return max_concurrent_users"},{"question":"# Fibonacci Sequence with Caching Scenario: You are designing a system to efficiently compute the Fibonacci sequence. The classic recursive approach is known to be inefficient for large indices due to excessive recomputation. You need to implement a class that computes Fibonacci numbers using caching to optimize performance. Requirements: 1. **Memoization**: Implement a caching mechanism to store previously computed Fibonacci numbers. 2. **Lazy Initialization**: Ensure that the Fibonacci numbers are computed only when requested and stored for future calls. 3. **Error Handling**: Handle invalid input scenarios gracefully. Input & Output: * **Function Signatures**: ```python class Fibonacci: def __init__(self): # Initialize the cache pass def get_fibonacci(self, n: int) -> int: # return the nth Fibonacci number pass ``` * **Constraints**: * The input `n` should be a non-negative integer. * Return `ValueError` with message \\"Invalid input: n should be a non-negative integer\\" for negative inputs. Example: ```python # Example usage: fib = Fibonacci() # Compute Fibonacci numbers assert fib.get_fibonacci(5) == 5 assert fib.get_fibonacci(10) == 55 assert fib.get_fibonacci(15) == 610 # Using cached results should result in faster computations assert fib.get_fibonacci(5) == 5 # Retrieved from cache ``` Implementation Details: Provide your implementation for the `Fibonacci` class, employing an optimal caching mechanism to enhance the performance of computing Fibonacci numbers. Ensure that your solution handles potential input errors appropriately, and adheres to the provided function signatures.","solution":"class Fibonacci: def __init__(self): # Initialize the cache with base cases self.cache = {0: 0, 1: 1} def get_fibonacci(self, n: int) -> int: if n < 0: raise ValueError(\\"Invalid input: n should be a non-negative integer\\") if n not in self.cache: self.cache[n] = self.get_fibonacci(n - 1) + self.get_fibonacci(n - 2) return self.cache[n]"},{"question":"# User Authentication System In a secure application, user authentication is crucial to ensure that only authorized users can access sensitive data. Implement a user authentication system that supports two main operations: registering a new user and logging in an existing user. The system should utilize a hashing mechanism to securely store passwords. Implement the functions `register_user(username: str, password: str) -> bool` and `login_user(username: str, password: str) -> bool` to achieve this. **Requirements:** 1. Use an in-memory dictionary to store user credentials (`username` and `hashed_password`). 2. Use a hashing algorithm (e.g., SHA-256) to store passwords securely. 3. The `register_user` function should return `True` if the registration is successful and `False` if the username already exists. 4. The `login_user` function should return `True` if the login is successful (i.e., the username exists and the password matches) and `False` otherwise. 5. Handle edge cases such as empty `username` or `password` strings. **Input:** * `username` (str): A unique identifier for the user. * `password` (str): The password associated with the user. **Output:** * `register_user` (bool): A boolean indicating the success of the registration. * `login_user` (bool): A boolean indicating the success of the login. **Constraints:** * Passwords should be stored as hashed values to ensure security. * The in-memory dictionary should prevent storing plain text passwords. * Ensure that both functions handle potential edge cases gracefully, such as empty strings. **Example:** ```python # Example usage: print(register_user(\\"user1\\", \\"password123\\")) # Should return True print(register_user(\\"user1\\", \\"password123\\")) # Should return False (username already exists) print(login_user(\\"user1\\", \\"password123\\")) # Should return True print(login_user(\\"user1\\", \\"wrongpassword\\")) # Should return False print(login_user(\\"user2\\", \\"password123\\")) # Should return False (username does not exist) ```","solution":"import hashlib # In-memory dictionary to store user credentials user_credentials = {} def hash_password(password: str) -> str: Hash the given password using SHA-256. return hashlib.sha256(password.encode()).hexdigest() def register_user(username: str, password: str) -> bool: Register a new user with the given username and password. if not username or not password: return False if username in user_credentials: return False hashed_password = hash_password(password) user_credentials[username] = hashed_password return True def login_user(username: str, password: str) -> bool: Login a user with the given username and password. if not username or not password: return False if username not in user_credentials: return False hashed_password = hash_password(password) return user_credentials[username] == hashed_password"},{"question":"Problem Statement: Design and implement a Circular Doubly Linked List (CDLL) from scratch with the following functionalities. The list should allow bidirectional traversal and should loop back on itself in both directions. # Features to Implement: 1. **Add Node at End**: - Method: `add_node_at_end(value: T) -> None` - Description: Adds a new node with the specified value at the end of the list. 2. **Add Node at Start**: - Method: `add_node_at_start(value: T) -> None` - Description: Adds a new node with the specified value at the start of the list. 3. **Remove Node by Value**: - Method: `remove_node_by_value(value: T) -> None` - Description: Removes the first node with the specified value from the list. If no such node exists, raise a `ValueError`. 4. **Contains Value**: - Method: `contains_value(value: T) -> bool` - Description: Returns `True` if a node with the specified value is present in the list, `False` otherwise. 5. **Get Size**: - Method: `get_size() -> int` - Description: Returns the number of nodes present in the list. # Constraints: - You can assume that `T` will always be hashable and comparable. - Operations should be optimized for both time and space, especially handling edge cases like an empty list or single-element list. # Example: ```python # Example Usage cdll = CircularDoublyLinkedList[int]() cdll.add_node_at_end(1) cdll.add_node_at_end(2) cdll.add_node_at_start(0) assert cdll.contains_value(2) == True assert cdll.contains_value(3) == False cdll.remove_node_by_value(1) assert cdll.contains_value(1) == False assert cdll.get_size() == 2 cdll.remove_node_by_value(0) cdll.remove_node_by_value(2) assert cdll.get_size() == 0 ``` Implement the `CircularDoublyLinkedList` class following the above description and ensuring your implementation passes all necessary edge cases.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class CircularDoublyLinkedList: def __init__(self): self.head = None self.size = 0 def add_node_at_end(self, value): new_node = Node(value) if not self.head: self.head = new_node new_node.next = new_node new_node.prev = new_node else: tail = self.head.prev tail.next = new_node new_node.prev = tail new_node.next = self.head self.head.prev = new_node self.size += 1 def add_node_at_start(self, value): self.add_node_at_end(value) self.head = self.head.prev def remove_node_by_value(self, value): if not self.head: raise ValueError(f\\"Value {value} is not in the list.\\") current = self.head while True: if current.value == value: if current.next == current: self.head = None else: current.prev.next = current.next current.next.prev = current.prev if self.head == current: self.head = current.next self.size -= 1 return current = current.next if current == self.head: break raise ValueError(f\\"Value {value} is not in the list.\\") def contains_value(self, value): if not self.head: return False current = self.head while True: if current.value == value: return True current = current.next if current == self.head: break return False def get_size(self): return self.size"},{"question":"# Sorting Linked List: Merge Sort Implementation Background: Merging and sorting linked lists is a common problem that can be approached using different techniques. One of the efficient ways to sort a linked list is by implementing the merge sort algorithm. Merge sort operates on the \\"divide and conquer\\" principle and can work effectively with linked lists by splitting them into halves and then merging the sorted halves. Task: You need to extend the `LinkedList` class with two functionalities: 1. Implement the merge sort algorithm to sort the linked list. 2. Write a helper method to merge two sorted linked lists efficiently. Requirements: - Write a method `merge_sort(self)` that sorts the linked list using the merge sort algorithm. - Write a helper method `merge_two_sorted_lists(self, l1, l2)` that merges two sorted linked lists into one sorted list. Function Signature: ```python def merge_sort(self) -> \'Node\': # Your code here def merge_two_sorted_lists(self, l1: \'Node\', l2: \'Node\') -> \'Node\': # Your code here ``` Input: - A linked list object on which `merge_sort` and `merge_two_sorted_lists` will be called. - Helper method `merge_two_sorted_lists` will be called with two sorted linked list nodes. Output: - `merge_sort` returns the head node of the sorted linked list. - `merge_two_sorted_lists` returns the head node of the merged and sorted linked list. Constraints / Assumptions: - The linked list does not contain any cycles. - Consider creating any additional helper methods within the linked list class if necessary. - Assume the linked list structure has `Node` class defined with properties `value` and `next`. # Function Examples: ```python # Example 1 ll = LinkedList() ll.append(4).append(2).append(1).append(3) sorted_head = ll.merge_sort() current = sorted_head result = [] while current: result.append(current.value) current = current.next print(result) # Outputs [1, 2, 3, 4] # Example 2 ll1 = LinkedList() ll1.append(1).append(3).append(5) ll2 = LinkedList() ll2.append(2).append(4).append(6) merged_head = ll.merge_two_sorted_lists(ll1.head, ll2.head) current = merged_head result = [] while current: result.append(current.value) current = current.next print(result) # Outputs [1, 2, 3, 4, 5, 6] # Note: You can enhance your LinkedList\'s existing methods and properties, # Consider the provided methods within your implementation for practical results. ``` # Linked List and Node Class Example: ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) return self # Insert merge_sort and merge_two_sorted_lists methods here ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) return self def merge_sort(self): if not self.head or not self.head.next: return self.head def split(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None return head, mid def merge(l1, l2): dummy = Node(0) current = dummy while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next def merge_sort_rec(head): if not head or not head.next: return head left, right = split(head) left_sorted = merge_sort_rec(left) right_sorted = merge_sort_rec(right) return merge(left_sorted, right_sorted) self.head = merge_sort_rec(self.head) return self.head def merge_two_sorted_lists(self, l1, l2): dummy = Node(0) current = dummy while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next"},{"question":"# Coding Question Problem Statement You are required to implement a function `chunk_list` that splits a list into smaller lists (chunks) of a specified maximum length. Your function should ensure that the order of elements is preserved. Function Signature ```python def chunk_list(items: list, chunk_size: int) -> list[list]: pass ``` Input and Output Requirements * **Input**: - `items` (list): A list of elements to be split. - `chunk_size` (int): An integer specifying the maximum length of each chunk. * **Output**: - Returns a list of lists, where each inner list has at most `chunk_size` elements, except perhaps the last one which may have fewer. Constraints * The function should raise a `ValueError` with the message `\\"chunk_size must be greater than 0\\"` if `chunk_size` is less than or equal to zero. * If `items` is an empty list, return an empty list. Examples 1. `chunk_list([1, 2, 3, 4, 5], 2)` should return `[[1, 2], [3, 4], [5]]` 2. `chunk_list([1, 2, 3, 4, 5], 3)` should return `[[1, 2, 3], [4, 5]]` 3. `chunk_list([], 3)` should return `[]` 4. `chunk_list([1, 2, 3], 1)` should return `[[1], [2], [3]]` 5. `chunk_list([1, 2, 3, 4, 5], -1)` should raise `ValueError(\\"chunk_size must be greater than 0\\")` Make sure your implementation correctly handles edge cases and preserves the order of elements.","solution":"def chunk_list(items: list, chunk_size: int) -> list: Splits a list into smaller lists (chunks) of a specified maximum length. Parameters: items (list): A list of elements to be split. chunk_size (int): An integer specifying the maximum length of each chunk. Returns: list: A list of lists, where each inner list has at most chunk_size elements. Raises: ValueError: If chunk_size is less than or equal to zero. if chunk_size <= 0: raise ValueError(\\"chunk_size must be greater than 0\\") return [items[i:i + chunk_size] for i in range(0, len(items), chunk_size)]"},{"question":"# Problem: You are tasked with designing a function that performs matrix multiplication. Given two matrices, your task is to compute the product of these matrices. Matrix multiplication is a binary operation that takes a pair of matrices, and produces another matrix. Given two matrices **A** and **B**, the product **C = A * B** can be calculated as follows: - The resulting matrix **C** will have dimensions that are derived from **A** and **B**’s dimensions. If **A** is of dimensions *m x n* and **B** is *n x p*, then **C** will be of dimensions *m x p*. - Each element **c[i][j]** of **C** is computed as the dot product of the i-th row of **A** and the j-th column of **B**. # Function Signature: ```python def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiply two matrices A and B and return the resulting matrix. :param A: The first matrix (List of List of ints). :param B: The second matrix (List of List of ints). :return: The resulting matrix from the multiplication of A and B (List of List of ints). :raises ValueError: if the dimensions of the matrices are incompatible for multiplication. ``` # Input: * `A`: A list of lists of integers representing the first matrix. The dimensions of `A` are *m x n*. * `B`: A list of lists of integers representing the second matrix. The dimensions of `B` are *n x p*. # Output: * A list of lists of integers representing the product matrix `C` of dimensions *m x p*. # Constraints: * `A` and `B` will contain integers in the range [-10^3, 10^3]. * The number of columns in `A (n)` must equal the number of rows in `B (n)` for matrix multiplication to be possible. * The maximum dimensions of `A` and `B` combined will not exceed 200 (i.e., m * n + n * p ≤ 200). # Example Usage: ```python >>> matrix_multiply([[1, 2], [3, 4]], [[2, 0], [1, 2]]) [[4, 4], [10, 8]] >>> matrix_multiply([[1, 0, 2], [-1, 3, 1]], [[3, 1], [2, 1], [1, 0]]) [[5, 1], [4, 2]] ``` # Notes: * Handle cases where matrix dimensions do not align by raising a `ValueError` with a descriptive message. * Ensure efficiency in your implementation to handle edge cases for the largest input sizes within the given constraints. * You can assume that the inputs provided will always be valid matrices, but dimensions may need validation for multiplication compatibility.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Validate dimensions for matrix multiplication if len(A[0]) != len(B): raise ValueError(\\"Incompatible dimensions for matrix multiplication: Columns of A must match rows of B.\\") m = len(A) n = len(B) p = len(B[0]) # Initialize the result matrix with zeroes C = [[0 for _ in range(p)] for _ in range(m)] # Perform the matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"**Scenario**: You are given a string representing an encoded message where each letter is encoded as a number from \'1\' to \'26\' (inclusive). The task is to determine the total number of ways to decode it. Each substring of the string can be mapped to a letter according to a 1-to-1 correspondence with numbers, i.e., \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'. The encoding follows these rules: - \'1\' through \'9\' map to \'A\' through \'I\'. - \'10\' through \'26\' map to \'J\' through \'Z\'. # Task Write a function `num_decodings(s: str) -> int` that takes an encoded message string and returns the total number of ways to decode it. # Input * A string `s` consisting of digits representing the encoded message, where 1 <= `len(s)` <= 10^5. # Output * An integer representing the total number of ways to decode the input string. # Constraints * The input string will not contain any characters other than digits 0-9. * The input will not have leading zeros. # Examples ```python >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"06\\") 0 >>> num_decodings(\\"11106\\") 2 ``` # Note * In the first example, the input \\"12\\" can be decoded as either \\"AB\\" (1-2) or \\"L\\" (12), so there are 2 ways. * In the second example, the input \\"226\\" can be decoded as \\"BZ\\" (2-26), \\"VF\\" (22-6), or \\"BBF\\" (2-2-6), so there are 3 ways. * The encoding \\"0\\" and \\"06\\" are invalid because \'0\' does not map to any letter. * Consider edge cases such as a string with a single character, strings containing \'0\', or maximum length strings. **Function Signature** ```python def num_decodings(s: str) -> int: ```","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = s[i - 1:i] two_digits = s[i - 2:i] if \'1\' <= one_digit <= \'9\': dp[i] += dp[i - 1] if \'10\' <= two_digits <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"# Sorting a List of Tuples based on Multiple Criteria **Objective**: Given a list of tuples, sort the list based on multiple criteria. The tuples contain integers and each tuple should be sorted primarily by the first element. When there\'s a tie in the first element, sort based on the second element, and so on. **Problem Statement**: Write a function: `sort_tuples_multiple_criteria(tuples: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]`. 1. **sort_tuples_multiple_criteria**: * Given a list of tuples, sort it based on multiple criteria. * The tuples contain only integers. The length of each tuple is the same. **Function Signature**: ```python from typing import List, Tuple def sort_tuples_multiple_criteria(tuples: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: pass ``` **Requirements**: 1. **Input**: * A list `tuples` containing tuples of integers. * Each tuple in the list has the same fixed number of elements. 2. **Output**: * A list of tuples sorted based on the criteria. 3. **Constraints**: * The input list contains at least one tuple. * The tuples contain only integers. * Each tuple has at least one element. 4. **Edge Cases to Consider**: * Handling empty tuples or lists of tuples with varying lengths. **Examples**: ```python assert sort_tuples_multiple_criteria([(2, 3), (1, 2), (2, 1), (1, 3)]) == [(1, 2), (1, 3), (2, 1), (2, 3)] assert sort_tuples_multiple_criteria([(3, 2, 1), (2, 3, 1), (2, 2, 2), (1, 3, 2)]) == [(1, 3, 2), (2, 2, 2), (2, 3, 1), (3, 2, 1)] assert sort_tuples_multiple_criteria([(1, ), (3, ), (2, ), (1, )]) == [(1, ), (1, ), (2, ), (3, )] assert sort_tuples_multiple_criteria([(1, 1), (1, 1)]) == [(1, 1), (1, 1)] assert sort_tuples_multiple_criteria([(5, 6, 3), (5, 6, 2), (3, 8, 18)]) == [(3, 8, 18), (5, 6, 2), (5, 6, 3)] ``` **Explanation**: 1. **Step by Step Approach**: * Iterate through the input list of tuples. * Use sorting functions with key arguments that allow sorting based on multiple tuple elements. * Ensure that when elements are equal, the next tuple element is used for sorting. 2. **Implementation**: * Use Python\'s in-built `sorted` function. * Utilize the `itemgetter` from the `operator` module or a lambda function to specify multiple keys. * The sorting will be stable, respecting the order of elements in tied situations based on subsequent tuple elements. **Example Execution**: For input `[(2, 3), (1, 2), (2, 1), (1, 3)]`, the sorted output would be `[(1, 2), (1, 3), (2, 1), (2, 3)]`. This is because the primary sort is on the first element, and for ties, the second element in the tuple resolves the order.","solution":"from typing import List, Tuple def sort_tuples_multiple_criteria(tuples: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: Given a list of tuples, sorts the list based on multiple criteria. Tuples are sorted primarily by the first element, then second, and so on. return sorted(tuples)"},{"question":"# Coding Question Context You are working on an e-commerce platform that needs to manage a large inventory of products. Currently, the system is inefficient when searching for products with specific attributes, leading to slow query times, especially during peak usage hours. Task Write a function `search_products` that enhances the search functionality to handle large datasets efficiently. The function should be able to filter products based on various attributes such as name, category, and price range. Function Signature ```python def search_products(products: list, query: dict) -> list: pass ``` Requirements 1. **Input**: * `products` (list): A list of dictionaries, where each dictionary represents a product with attributes like `name`, `category`, `price`, and `stock`. * `query` (dict): A dictionary containing the search parameters. Possible keys include `name` (str), `category` (str), `min_price` (float), and `max_price` (float). 2. **Output**: * A list of dictionaries containing the filtered products based on the search parameters. 3. **Constraints**: * The search should be case-insensitive for string attributes. * Ensure the function can handle a large number of products efficiently. * Implement proper error handling (e.g., invalid query parameters). 4. **Performance**: * The function should remain performant with up to 10,000 products. * Optimize for quick search times even with multiple query parameters. Example: ```python products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 999.99, \\"stock\\": 10}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 699.99, \\"stock\\": 5}, {\\"name\\": \\"Coffee Mug\\", \\"category\\": \\"Home & Kitchen\\", \\"price\\": 9.99, \\"stock\\": 100} ] query = {\\"category\\": \\"Electronics\\", \\"min_price\\": 500, \\"max_price\\": 1000} result = search_products(products, query) # Expected output: [{\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 999.99, \\"stock\\": 10}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 699.99, \\"stock\\": 5}] ``` Notes: * Optimize the function for readability and maintainability. * Consider edge cases such as an empty product list or no matching products. * Write clean and well-documented code with appropriate comments.","solution":"def search_products(products: list, query: dict) -> list: Returns a list of products filtered based on the query parameters. Args: products (list): List of product dictionaries. query (dict): Dictionary containing search parameters. Returns: list: Filtered list of product dictionaries. def matches(product, query): name = query.get(\\"name\\", \\"\\").lower() category = query.get(\\"category\\", \\"\\").lower() min_price = query.get(\\"min_price\\", float(\'-inf\')) max_price = query.get(\\"max_price\\", float(\'inf\')) if name and name not in product[\\"name\\"].lower(): return False if category and category != product[\\"category\\"].lower(): return False if not (min_price <= product[\\"price\\"] <= max_price): return False return True return [product for product in products if matches(product, query)]"},{"question":"# Title: String Compression and Decompression - Medium Difficulty Scenario You have been contracted by a data storage company to help with optimizing the process of compressing and decompressing repetitive character strings to conserve space. You need to devise an encoding strategy that ensures significant reduction in size for inputs with numerous repetitions. Task Implement the function `compress_string` that compresses a given string using the following rules: 1. If a character appears consecutively in the string, replace the sequence with the character followed by its count. 2. If a character appears only once, it should not be followed by a count. Additionally, implement the function `decompress_string` that reconstructs the original string from the compressed format. Requirements * **Function Signature**: ```python def compress_string(s: str) -> str: def decompress_string(s: str) -> str: ``` * **Input**: - `s` (str): A string of arbitrary length containing alphabetic characters only. * **Output**: - `compress_string`: A string that represents the compressed version of the input. - `decompress_string`: A string that reconstructs the original string from the compressed version. * **Constraints**: - The string `s` will only contain uppercase (A-Z) and lowercase (a-z) alphabetic characters. - The compressed string should be as short as possible while accurately representing the original string. * **Examples**: ```python >>> compress_string(\\"aaabbcaaaa\\") \'a3b2ca4\' >>> compress_string(\\"abc\\") \'abc\' >>> decompress_string(\\"a3b2ca4\\") \'aaabbcaaaa\' >>> decompress_string(\\"abc\\") \'abc\' ```","solution":"def compress_string(s: str) -> str: Compresses the string by using the character followed by the count if more than one. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + (str(count) if count > 1 else \\"\\")) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else \\"\\")) return \'\'.join(compressed) def decompress_string(s: str) -> str: Decompresses the string by expanding the character and its count. decompressed = [] i = 0 while i < len(s): if i + 1 < len(s) and s[i + 1].isdigit(): count = 0 while i + 1 < len(s) and s[i + 1].isdigit(): i += 1 count = count * 10 + int(s[i]) decompressed.append(s[i - len(str(count))] * count) else: decompressed.append(s[i]) i += 1 return \'\'.join(decompressed)"},{"question":"# Coding Question Context: You are working on a system that processes financial transactions. To ensure the integrity of data, you need to implement a feature that verifies whether all transactions in a batch are within a specific range and calculate the sum of valid transactions. This is crucial for detecting outliers and maintaining accurate records. Requirements: 1. **Function Implementations**: * Implement the `are_transactions_valid` function to verify if all transactions fall within a given range. * Implement the `sum_of_valid_transactions` function to compute the sum of transactions within the specified range. 2. **Input Format**: * A list of non-negative float values representing transactions. * Two float values representing the lower and upper bounds of the valid range (inclusive). 3. **Output Format**: * `are_transactions_valid`: A boolean value (`True` if all transactions are within the range, `False` otherwise). * `sum_of_valid_transactions`: A float value representing the sum of transactions within the specified range. 4. **Constraints**: * The list can contain zero or more non-negative float values. * Handle the case of empty lists by raising `ValueError` where appropriate. * The sum of an empty list should be zero. Function Signatures: ```python def are_transactions_valid(transactions: list, lower_bound: float, upper_bound: float) -> bool: pass def sum_of_valid_transactions(transactions: list, lower_bound: float, upper_bound: float) -> float: pass ``` Example: ```python # Example for are_transactions_valid print(are_transactions_valid([50.0, 20.0, 30.0], 10.0, 50.0)) # Output: True print(are_transactions_valid([5.0, 100.0, 30.0], 10.0, 90.0)) # Output: False # Example for sum_of_valid_transactions print(sum_of_valid_transactions([50.0, 20.0, 30.0], 10.0, 50.0)) # Output: 100.0 print(sum_of_valid_transactions([5.0, 100.0, 30.0], 10.0, 90.0)) # Output: 30.0 print(sum_of_valid_transactions([], 0.0, 100.0)) # Output: 0.0 ``` Description: 1. **`are_transactions_valid` Function**: * Takes a list of transactions `transactions`, and two float values `lower_bound` and `upper_bound` as input. * Raises `ValueError` for non-list inputs or empty lists. * Returns `True` if all transactions are within the specified range (inclusive), `False` otherwise. 2. **`sum_of_valid_transactions` Function**: * Takes a list of transactions `transactions`, and two float values `lower_bound` and `upper_bound` as input. * Raises `ValueError` for non-list inputs or empty lists. * Calculates and returns the sum of transactions that fall within the specified range (inclusive). * Returns `0.0` if the list is empty.","solution":"def are_transactions_valid(transactions: list, lower_bound: float, upper_bound: float) -> bool: # Check if the input is a list and it\'s not empty if not isinstance(transactions, list) or not transactions: raise ValueError(\'Input must be a non-empty list of transactions.\') # Check if all transactions are within the given range return all(lower_bound <= transaction <= upper_bound for transaction in transactions) def sum_of_valid_transactions(transactions: list, lower_bound: float, upper_bound: float) -> float: # Check if the input is a list if not isinstance(transactions, list): raise ValueError(\'Input must be a list of transactions.\') # Sum of transactions that are within the given range return sum(transaction for transaction in transactions if lower_bound <= transaction <= upper_bound)"},{"question":"# Question: Implement a Deep Copy Function You are working on a project that involves complex data structures. Your task is to implement a function to perform a deep copy of nested lists. A deep copy means creating a new instance of the original object and all objects contained within it, recursively. Function Signature `def deep_copy(data: list) -> list` Requirements - The function should take a list, which may contain nested lists, integers, floats, and strings. - The function should create a new list that is a deep copy of the input list, meaning: - All nested lists should be recursively copied. - Changes to the original list or its nested elements should not affect the copied list, and vice versa. - Raise a `TypeError` if the input is not a list. Input * `data`: A list that may contain integers, floats, strings, and other nested lists. Example: `[[1, 2, [3, 4]], 5, \\"hello\\"]` Output * Return a new list that is a deep copy of the input list. Examples ```python data = [[1, 2, [3, 4]], 5, \\"hello\\"] copy_data = deep_copy(data) assert copy_data == data assert copy_data is not data # Ensure it is a new list assert copy_data[0] is not data[0] # Ensure nested lists are also new data[0][2][0] = 99 assert copy_data != data # Ensure the copy is not affected by changes to the original # Test with an empty list assert deep_copy([]) == [] # Test with a flat list assert deep_copy([1, 2, 3]) == [1, 2, 3] assert deep_copy([1, 2, 3]) is not [1, 2, 3] # Test with a list of strings assert deep_copy([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] assert deep_copy([\\"a\\", \\"b\\", \\"c\\"]) is not [\\"a\\", \\"b\\", \\"c\\"] try: deep_copy(\\"not a list\\") except TypeError: pass # This is expected ``` Constraints & Limitations * The input list may contain various data types within it, but you can assume it will not contain dictionaries, sets, or any other data structures beyond integers, floats, strings, and nested lists. * Ensure that your implementation performs a true deep copy and not just makes references to the original sublists. * Handle invalid input appropriately by raising a `TypeError`.","solution":"def deep_copy(data): Return a deep copy of the input list. if not isinstance(data, list): raise TypeError(\\"Input must be a list\\") def copy_recursive(item): if isinstance(item, list): return [copy_recursive(sub_item) for sub_item in item] return item return copy_recursive(data)"},{"question":"Matrix Rotation by 90 Degrees Context: Manipulating matrices is a common task in programming, frequently encountered in graphics, game development, and data transformation. One of the common operations is rotating a given matrix by 90 degrees clockwise. Problem: Write a function to rotate a given `n x n` matrix by 90 degrees clockwise in-place. The modification should be done without using any additional matrix to store the intermediate results. Function Signature: ```python def rotate_matrix(matrix: list[list[int]]) -> None: ``` Input: * `matrix` (2 ≤ len(matrix) ≤ 20): A square matrix (list of lists) where each sublist has the same length as the number of sublists, representing an `n x n` grid. Output: * The function does not return anything; it modifies the input matrix in place. Constraints: * The function should operate in-place, modifying the original matrix. * The function should handle edge cases and ensure that all cells in the matrix are appropriately rotated. Examples: ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # Expected Output: # matrix = [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix = [ [5, 1], [2, 4] ] rotate_matrix(matrix) # Expected Output: # matrix = [ # [2, 5], # [4, 1] # ] ``` Performance Consideration: Given the problem constraints of modifying the matrix in-place, ensure your solution does not consume more memory than required. The goal is to perform the rotation efficiently with a time complexity of O(n^2). Note: * Your solution should not use any additional lists or matrices for storage. * Focus on clarity and efficiency in your code, including appropriate comments and docstrings to explain your logical steps.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotate the given n x n matrix by 90 degrees clockwise in-place. Args: matrix (list[list[int]]): The n x n matrix to rotate. Returns: None: The matrix is modified in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement: You are tasked with designing an algorithm to compress a given string using Run-Length Encoding (RLE). Run-Length Encoding is a basic form of data compression where consecutive identical elements (called runs) are replaced with a single element and the number of times it appears. # Requirements: 1. Implement a function `rle_encode` that takes a single parameter: - `input_string`: A string consisting of uppercase and lowercase letters. 2. The function should return a compressed version of the string using the Run-Length Encoding format. 3. If the input string is empty, return an empty string. 4. The algorithm should traverse the string and count the runs of identical characters, and for each run, append the character followed by the count to the result. # Constraints: - **Characters**: The input string will consist of only uppercase and lowercase alphabets. - **Input validation**: Must handle the empty string case explicitly. # Function Signature: ```python def rle_encode(input_string: str) -> str: pass ``` # Example: ```python input_string = \\"aaabbbcccaaa\\" result = rle_encode(input_string) print(result) # Output: \\"a3b3c3a3\\" input_string = \\"abcccaaa\\" result = rle_encode(input_string) print(result) # Output: \\"a1b1c3a3\\" input_string = \\"\\" result = rle_encode(input_string) print(result) # Output: \\"\\" ``` # Note: - The compressed format should be concise, without any spaces or additional characters. - Ensure the algorithm is efficient and robust against various input lengths.","solution":"def rle_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = \\"\\" current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string += current_char + str(count) current_char = char count = 1 encoded_string += current_char + str(count) return encoded_string"},{"question":"# Question: Process and Analyze Text Files for Word Frequency You are required to implement a function that reads a given text file, processes its content, and returns a dictionary where the keys are the unique words and the values are their respective frequencies in the text. Function: `word_frequency(file_path: str) -> Dict[str, int]` Implement the function `word_frequency(file_path: str) -> Dict[str, int]`. **Input:** - `file_path`: A string representing the path to the text file. **Output:** - A dictionary where the keys are unique words (as strings) from the file, and the values are the frequency counts (as integers) of each word. **Constraints:** - The file will contain only text, including letters, numbers, and standard punctuation (e.g., periods, commas, exclamation points). - Words are case-insensitive, meaning \\"Word\\" and \\"word\\" should be counted as the same word. - Ignore punctuation and consider only the words. - The file can be large, so the function should handle large files efficiently. **Example:** Consider the content of the file located at `example.txt`: ``` Hello, world! Hello, Universe. The world is vast and full of wonders. Explore the universe. ``` **Expected output:** ```python { \\"hello\\": 2, \\"world\\": 2, \\"universe\\": 2, \\"the\\": 2, \\"is\\": 1, \\"vast\\": 1, \\"and\\": 1, \\"full\\": 1, \\"of\\": 1, \\"wonders\\": 1, \\"explore\\": 1 } ``` **Edge Cases to Consider:** - The function should handle empty files gracefully, returning an empty dictionary. - Ensure proper handling of different newline characters (e.g., `n` and `rn`). **Hints:** - You can use `str.lower()` to convert words to lowercase. - Use regular expressions to remove punctuation and split the text into words.","solution":"import re from typing import Dict def word_frequency(file_path: str) -> Dict[str, int]: word_counts = {} with open(file_path, \'r\', encoding=\'utf-8\') as file: text = file.read().lower() words = re.findall(r\'bw+b\', text) for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts"},{"question":"# String Pattern Matching You are tasked with creating a function to check if a given string `s` matches a specified pattern `p`. The pattern may include special characters: 1. `.` - Matches any single character. 2. `*` - Matches zero or more of the preceding element. Your function should determine whether the given string `s` matches the entire pattern `p`. Requirements: 1. Implement a function `is_match` which accepts two arguments: `s` (the string to match) and `p` (the pattern). 2. The function should return `True` if the string matches the pattern, and `False` otherwise. Input: * `s` (str): The string input to be matched against the pattern. * `p` (str): The pattern which the string `s` is to be matched against. Output: * `bool`: `True` if the string matches the pattern entirely, `False` otherwise. Example: Input: ```python s = \\"aab\\" p = \\"c*a*b\\" ``` Output: ```python True ``` Input: ```python s = \\"mississippi\\" p = \\"mis*is*p*.\\" ``` Output: ```python False ``` # Implementation Implement the following function: ```python def is_match(s: str, p: str) -> bool: Check if the input string matches the given pattern considering special characters \'.\' and \'*\'. Parameters: s (str): Input string to be checked. p (str): Pattern to be matched against. Returns: bool: True if the input string matches the pattern, False otherwise. # Establish a 2D table to hold the matches dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Matching two empty strings # Handling patterns like \'a*\', \'a*b*\' or \'.*\' with an initial empty string for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the table using dynamic programming for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or ((p[j - 2] == s[i - 1] or p[j - 2] == \'.\') and dp[i - 1][j]) return dp[len(s)][len(p)] ```","solution":"def is_match(s: str, p: str) -> bool: Check if the input string matches the given pattern considering special characters \'.\' and \'*\'. Parameters: s (str): Input string to be checked. p (str): Pattern to be matched against. Returns: bool: True if the input string matches the pattern, False otherwise. # Establish a 2D table to hold the matches dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Matching two empty strings # Handling patterns like \'a*\', \'a*b*\' or \'.*\' with an initial empty string for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the table using dynamic programming for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or ((p[j - 2] == s[i - 1] or p[j - 2] == \'.\') and dp[i - 1][j]) return dp[len(s)][len(p)]"},{"question":"# Problem Statement You are given a matrix where each element is an integer representing elevations on a 2D grid. Your task is to find the maximum difference between the elevation of any two elements, where one element is reachable from the other. An element is reachable from another if they are in the same connected component (connected orthogonally in 4 directions). # Function Signature ```python def max_connected_difference(matrix: List[List[int]]) -> int: pass ``` # Input - **matrix** (List[List[int]]): A 2D list (matrix) of integers representing elevations. # Output - **result** (int): The maximum elevation difference between the highest and lowest points in any connected component. # Constraints 1. The matrix will have at least 2 rows and 2 columns and at most 1000 rows and 1000 columns. 2. Each row will have the same number of elements. 3. The elevation values are integers that can be negative or positive and fit within the limits of a signed 32-bit integer. # Performance Requirements Optimize your implementation to handle the input size efficiently. # Examples ```python >>> max_connected_difference([[1, 2, 3], [4, 8, 6], [7, 5, 9]]) 8 >>> max_connected_difference([[-1, -3, 4], [2, 0, 5], [3, -2, 1]]) 8 >>> max_connected_difference([[10, 20, 15], [25, 30, 35], [20, 25, 30]]) 25 >>> max_connected_diff([[1,2],[3,4]]) Traceback (most recent call last): ... TypeError: Undefined for non-integers ``` # Implementation Notes 1. Use a depth-first search (DFS) or breadth-first search (BFS) to identify connected components in the grid. 2. For each connected component, determine the minimum and maximum elevations. 3. Compute the difference between the maximum and minimum elevations for each component and return the largest difference.","solution":"from typing import List def max_connected_difference(matrix: List[List[int]]) -> int: def dfs(row, col): stack = [(row, col)] elevations = [] while stack: r, c = stack.pop() if (r, c) not in visited: visited.add((r, c)) elevations.append(matrix[r][c]) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(matrix) and 0 <= nc < len(matrix[0]) and (nr, nc) not in visited: stack.append((nr, nc)) return max(elevations) - min(elevations) visited = set() directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_difference = 0 for row in range(len(matrix)): for col in range(len(matrix[0])): if (row, col) not in visited: max_difference = max(max_difference, dfs(row, col)) return max_difference"},{"question":"# Problem: Binary Search Tree (BST) Operations You are tasked with developing a system that can manage and manipulate a collection of numerical data using a Binary Search Tree (BST). This will enable efficient data storage, retrieval, and manipulation. Requirements: 1. **Implement a method `insert(data: int) -> None`**: - This method should insert the specified data into the BST, maintaining the BST property. - Duplicate values should not be inserted. 2. **Implement a method `delete(data: int) -> None`**: - This method should remove the specified data from the BST, maintaining the BST property. - If the data does not exist in the BST, do nothing. 3. **Implement a method `find_min() -> int | None`**: - This method should return the minimum value stored in the BST. - If the BST is empty, return `None`. 4. **Implement a method `find_max() -> int | None`**: - This method should return the maximum value stored in the BST. - If the BST is empty, return `None`. 5. **Implement a method `inorder_traversal() -> List[int]**: - This method should return a list of all values in the BST in ascending order. Function Signatures: ```python class BST: def __init__(self) -> None: # Initialization def insert(self, data: int) -> None: # Code for insert def delete(self, data: int) -> None: # Code for delete def find_min(self) -> int | None: # Code for find_min def find_max(self) -> int | None: # Code for find_max def inorder_traversal(self) -> List[int]: # Code for inorder_traversal ``` Input/Output Formats: - `insert(data: int) -> None` - Input: Data (integer) - Output: None - `delete(data: int) -> None` - Input: Data (integer) - Output: None - `find_min() -> int | None` - Input: None - Output: Minimum value (integer) or None - `find_max() -> int | None` - Input: None - Output: Maximum value (integer) or None - `inorder_traversal() -> List[int]` - Input: None - Output: List of integers in ascending order Constraints: - Ensure that all methods maintain the BST properties. - Handle edge cases such as empty BST for `delete`, `find_min`, `find_max`, and `inorder_traversal` methods.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self) -> None: self.root = None def insert(self, data: int) -> None: if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def delete(self, data: int) -> None: self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: return node if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.data = min_larger_node.data node.right = self._delete(node.right, min_larger_node.data) return node def find_min(self) -> int | None: if self.root is None: return None min_node = self._find_min(self.root) return min_node.data def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self) -> int | None: if self.root is None: return None max_node = self._find_max(self.root) return max_node.data def _find_max(self, node): current = node while current.right is not None: current = current.right return current def inorder_traversal(self) -> list[int]: return self._inorder_traversal(self.root) def _inorder_traversal(self, node) -> list[int]: result = [] if node: result = self._inorder_traversal(node.left) result.append(node.data) result.extend(self._inorder_traversal(node.right)) return result"},{"question":"# Question Write a Python function that takes a list of integers and an integer `k`, and returns `True` if there are two distinct elements in the list whose difference is exactly `k`. **Input**: * A list of integers: `nums`. * An integer: `k`. **Output**: * Return a boolean value: `True` if there are two distinct elements in the list whose difference is exactly `k`; otherwise, `False`. **Constraints**: * 1 <= len(nums) <= 10^6 * -10^9 <= nums[i] <= 10^9 * 0 <= k <= 10^9 # Example ```python >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) True >>> has_pair_with_difference([1, 5, 3, 4, 2], 7) False >>> has_pair_with_difference([1], 1) False ``` **Explanation**: - In the first example, the difference `(4 - 1)` equals `3`, hence the output is `True`. - In the second example, there are no two elements whose differences equal `7`, hence the output is `False`. - In the last example, the list contains only one element, so no pair exists, hence the output is `False`. Implement the function taking into account both time and space efficiency.","solution":"def has_pair_with_difference(nums, k): Return True if there are two distinct elements in nums whose difference is exactly k, otherwise return False. num_set = set(nums) for num in nums: if (num + k) in num_set or (num - k) in num_set: return True return False"},{"question":"# Problem Description You are required to simulate a rotation system based on the Least Recently Used (LRU) cache algorithm. Implement an LRU cache that supports normal operations and returns decisions based on certain querying scenarios. Function 1: Insert or Access Element Implement `lru_cache(size: int, operations: List[Tuple[str, int]]) -> List[str]`: * **Input**: - `size`: An integer representing the maximum number of elements in the LRU cache. - `operations`: A list of tuples where each tuple is one of two types: - `(\'access\', key)`: Represents accessing an element with the given `key`. - `(\'insert\', key)`: Represents inserting an element with the given `key`. * **Output**: A list of strings representing the result of each operation. For an `\'access\'` operation, return \'hit\' if the element is in the cache, otherwise \'miss\'. For an `\'insert\'` operation, always return \'done\'. Function 2: Insert Element and Return State Implement `lru_cache_verbose(size: int, operations: List[Tuple[str, int]]) -> List[str]`: * **Input**: - `size`: An integer representing the maximum number of elements in the LRU cache. - `operations`: A list of tuples as described above. * **Output**: A list of strings representing the result of each operation, alongside the state of the cache after each insertion. For an `\'access\'` operation, return either \'hit\' or \'miss\'. For an `\'insert\'` operation, return \'done\' followed by a comma-separated list of the current elements in the cache from most recently to least recently used. # Example ```python size = 3 operations = [(\'insert\', 1), (\'insert\', 2), (\'access\', 1), (\'insert\', 3), (\'insert\', 4), (\'access\', 2), (\'access\', 1)] assert lru_cache(size, operations) == [\'done\', \'done\', \'hit\', \'done\', \'done\', \'miss\', \'hit\'] assert lru_cache_verbose(size, operations) == [\'done,1\', \'done,2,1\', \'hit\', \'done,3,1,2\', \'done,4,3,1\', \'miss\', \'hit\'] ``` # Notes 1. Accessing an element moves it to the front of the cache, marking it as recently used. 2. Inserting an element that already exists should just move it to the front, not insert duplicate entries. 3. When the cache is full, inserting a new element should evict the least recently used element (the one at the end of the list). # Constraints 1. The cache size `size` will be between 1 and 100, inclusive. 2. The number of operations will not exceed 1000. 3. All keys will be non-negative integers. By following these guidelines, the new question aims to test candidates\' understanding of data structures, particularly the LRU cache mechanism, and their ability to handle elements dynamically within constraints.","solution":"from collections import OrderedDict from typing import List, Tuple def lru_cache(size: int, operations: List[Tuple[str, int]]) -> List[str]: cache = OrderedDict() result = [] for operation, key in operations: if operation == \'access\': if key in cache: cache.move_to_end(key) result.append(\'hit\') else: result.append(\'miss\') elif operation == \'insert\': if key in cache: cache.move_to_end(key) else: if len(cache) == size: cache.popitem(last=False) cache[key] = None result.append(\'done\') return result def lru_cache_verbose(size: int, operations: List[Tuple[str, int]]) -> List[str]: cache = OrderedDict() result = [] for operation, key in operations: if operation == \'access\': if key in cache: cache.move_to_end(key) result.append(\'hit\') else: result.append(\'miss\') elif operation == \'insert\': if key in cache: cache.move_to_end(key) else: if len(cache) == size: cache.popitem(last=False) cache[key] = None result.append(f\'done,{\\",\\".join(map(str, reversed(cache.keys())))}\') return result"},{"question":"# Coding Challenge: Inventory Management System As the lead developer for a retail company\'s inventory management system, you are tasked with implementing a feature to track and update inventory levels for various products. The system needs to handle sales, restocking, and inventory checks efficiently. **Objective**: Implement methods to add new products, update inventory levels when products are sold or restocked, and check current inventory levels. # Task **Class Definition**: ```python class Inventory: def __init__(self): self.items = {} def add_product(self, product_name: str, initial_quantity: int) -> None: pass def sell_product(self, product_name: str, quantity: int) -> bool: pass def restock_product(self, product_name: str, quantity: int) -> None: pass def check_inventory(self, product_name: str) -> int: pass ``` **Methods**: 1. `add_product(self, product_name: str, initial_quantity: int) -> None` - Adds a new product to the inventory with the given name and initial quantity. - If the product already exists, update the inventory to reflect the total quantity on hand. 2. `sell_product(self, product_name: str, quantity: int) -> bool` - Reduces the inventory of the specified product by the quantity sold. - Returns `True` if the sale is successful (i.e., enough stock is available), `False` otherwise. 3. `restock_product(self, product_name: str, quantity: int) -> None` - Increases the inventory of the specified product by the quantity restocked. 4. `check_inventory(self, product_name: str) -> int` - Returns the current inventory level of the specified product. # Example ```python inventory = Inventory() # Add products inventory.add_product(\\"Apple\\", 50) inventory.add_product(\\"Banana\\", 100) inventory.add_product(\\"Orange\\", 75) # Sell products print(inventory.sell_product(\\"Apple\\", 10)) # True print(inventory.sell_product(\\"Banana\\", 200)) # False # Restock products inventory.restock_product(\\"Apple\\", 20) inventory.restock_product(\\"Banana\\", 50) # Check inventory levels print(inventory.check_inventory(\\"Apple\\")) # 60 print(inventory.check_inventory(\\"Banana\\")) # 150 ``` # Implementation Requirements 1. Modify the `Inventory` class to include the required methods. 2. Ensure that inventory updates are correctly reflected. 3. Validate that sales cannot reduce inventory below zero. 4. Comprehensive test cases covering all core functional requirements and edge cases.","solution":"class Inventory: def __init__(self): self.items = {} def add_product(self, product_name: str, initial_quantity: int) -> None: if product_name in self.items: self.items[product_name] += initial_quantity else: self.items[product_name] = initial_quantity def sell_product(self, product_name: str, quantity: int) -> bool: if product_name in self.items and self.items[product_name] >= quantity: self.items[product_name] -= quantity return True return False def restock_product(self, product_name: str, quantity: int) -> None: if product_name in self.items: self.items[product_name] += quantity else: self.items[product_name] = quantity def check_inventory(self, product_name: str) -> int: return self.items.get(product_name, 0)"},{"question":"# Question: Implement a Custom Pascal Triangle Generator Description Implement a function that generates the first `n` rows of Pascal\'s Triangle. The function should handle errors for non-positive integers and non-integer types. Input - An integer `n` (1 ≤ n ≤ 20) Output - A list of lists, where each inner list represents a row in Pascal\'s Triangle Constraints 1. If `n` is not an integer, the function should raise a `TypeError` with the message: `Input value of [n={n}] must be an integer` 2. If `n` is less than 1, the function should raise a `ValueError` with the message: `Input value of [n={n}] must be > 0` Example ```plaintext Input: 5 Output: [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] Input: 3 Output: [ [1], [1, 1], [1, 2, 1] ] Input: 1 Output: [ [1] ] ``` Additional Notes - Ensure that the function validates the input as specified. - Consider that Pascal\'s Triangle can grow quickly in size but remains manageable within the given constraints. Template ```python def pascal_triangle(n: int) -> list: if not isinstance(n, int): msg = f\\"Input value of [n={n}] must be an integer\\" raise TypeError(msg) if n < 1: msg = f\\"Input value of [n={n}] must be > 0\\" raise ValueError(msg) triangle = [] for i in range(n): if i == 0: row = [1] else: row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] triangle.append(row) return triangle # Example Usage print(pascal_triangle(5)) # Output: [ # [1], # [1, 1], # [1, 2, 1], # [1, 3, 3, 1], # [1, 4, 6, 4, 1] #] print(pascal_triangle(3)) # Output: [ # [1], # [1, 1], # [1, 2, 1] #] print(pascal_triangle(1)) # Output: [ # [1] #] ```","solution":"def pascal_triangle(n: int) -> list: if not isinstance(n, int): msg = f\\"Input value of [n={n}] must be an integer\\" raise TypeError(msg) if n < 1: msg = f\\"Input value of [n={n}] must be > 0\\" raise ValueError(msg) triangle = [] for i in range(n): if i == 0: row = [1] else: row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] triangle.append(row) return triangle"},{"question":"# Palindrome Substring Problem You are tasked with implementing functions in Python to find and count palindromic substrings within a given string. A palindromic substring is a substring that reads the same backward as forward. Your task is to implement the following two functions: 1. `is_palindrome(s: str) -> bool`: This function checks if a given string is a palindrome: - **Input**: - `s` (str): The input string. - **Output**: - Returns `True` if the string is a palindrome, and `False` otherwise. - **Constraint**: - The function should be case-insensitive and ignore non-alphanumeric characters (e.g., \\"A man, a plan, a canal, Panama\\" should be treated as a palindrome). 2. `count_palindromic_substrings(text: str) -> int`: This function counts the number of distinct palindromic substrings within a given text: - **Input**: - `text` (str): The input text. - **Output**: - Returns the count of distinct palindromic substrings as an integer. - **Constraints**: - The function should consider substrings of length 1 and above. # Example ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> count_palindromic_substrings(\\"ababa\\") 9 # The palindromic substrings are: \\"a\\", \\"b\\", \\"a\\", \\"b\\", \\"a\\", \\"aba\\", \\"bab\\", \\"aba\\", \\"ababa\\" >>> count_palindromic_substrings(\\"racecar\\") 10 # The palindromic substrings are: \\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"cec\\", \\"aceca\\", \\"racecar\\" >>> count_palindromic_substrings(\\"abcd\\") 4 # The palindromic substrings are: \\"a\\", \\"b\\", \\"c\\", \\"d\\" ``` # Constraints - The input string can be of length up to (10^4). - Ensure your code handles large strings efficiently. # Performance - For `is_palindrome`, the time and space complexity should be (O(n)), where (n) is the length of the input string. - For `count_palindromic_substrings`, the time complexity should be (O(n^2)) and space complexity should be (O(1)), where (n) is the length of the input string. Happy coding!","solution":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, and False otherwise. # Filter and lowercase the alphanumeric characters filtered_string = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_string == filtered_string[::-1] def count_palindromic_substrings(text: str) -> int: Counts the number of distinct palindromic substrings within a given text. Args: text (str): The input text. Returns: int: The count of distinct palindromic substrings. n = len(text) count = 0 # Helper function to expand around center def expand_around_center(left: int, right: int) -> int: local_count = 0 while left >= 0 and right < n and text[left] == text[right]: local_count += 1 left -= 1 right += 1 return local_count for i in range(n): # Count palindromes of odd length count += expand_around_center(i, i) # Count palindromes of even length count += expand_around_center(i, i + 1) return count"},{"question":"# Coding Assessment Question Objective Create a function to accurately calculate a floating point division for large integers and handle edge cases effectively. Problem Statement Given two integers `a` and `b`, write a function `accurate_division` that returns the result of dividing `a` by `b` as a floating-point number, ensuring high precision for large values. The function should handle division by zero by raising an appropriate error. Function Signature ```python def accurate_division(a: int, b: int) -> float: ``` Input * Two integers `a` and `b`. Output * A float, the result of `a / b`. Constraints 1. `-10^18 <= a, b <= 10^18` 2. Division by zero should raise a `ZeroDivisionError` with the message \\"division by zero\\". 3. The function should ensure high precision for the result. 4. Negative values of `b` are valid, and the result should reflect the correct sign. Requirements * Do not use Python\'s built-in division functions directly (`/` or `//`). * Optimize for precision, especially when dealing with large integers. Example ```python # Example 1 print(accurate_division(10, 2)) # Output: 5.0 # Example 2 print(accurate_division(7, 3)) # Output: 2.3333333333333335 # Example 3 try: accurate_division(7, 0) except ZeroDivisionError as e: print(e) # Output: division by zero # Example 4 print(accurate_division(-7, 2)) # Output: -3.5 # Example 5 print(accurate_division(10**18, 10**3)) # Output: 1000000000000.0 ``` Hints * You might want to explore the use of floating-point arithmetic basics manually to ensure no direct usage of `/`. * Handle the precision by carefully dealing with integer division and then manually converting the result to floating point.","solution":"def accurate_division(a: int, b: int) -> float: Returns the result of dividing a by b as a floating-point number, ensuring high precision. Raises ZeroDivisionError if b is zero. if b == 0: raise ZeroDivisionError(\\"division by zero\\") return a * 1.0 / b"},{"question":"# Problem Statement You are given the task of analyzing and processing a list of log data entries from a web server. Each log entry includes the timestamp of the request, the HTTP status code, and the URL. Your task is to write a function that identifies and counts the occurrences of each unique status code and returns the counts as a dictionary. Additionally, the function should return the count of requests per URL. # Instructions 1. Write a function `analyze_log_data` that processes the provided list of log data entries. 2. Your function should count the occurrences of each unique HTTP status code. 3. Your function should also count the number of requests per URL. 4. The function should return a dictionary containing: * A dictionary with HTTP status codes as keys and their occurrences as values. * A dictionary with URLs as keys and their request counts as values. # Function Signature ```python def analyze_log_data( log_entries: list[tuple[str, int, str]] ) -> tuple[dict[int, int], dict[str, int]]: pass ``` # Input * `log_entries`: A list of log entries, where each entry is a tuple `(timestamp: str, status_code: int, url: str)`. # Output * A tuple containing: * A dictionary where keys are HTTP status codes (int) and values are their occurrences (int). * A dictionary where keys are URLs (str) and values are their request counts (int). # Example ```python >>> logs = [ (\\"2023-10-01T12:34:56\\", 200, \\"/home\\"), (\\"2023-10-01T12:35:01\\", 404, \\"/about\\"), (\\"2023-10-01T12:35:04\\", 200, \\"/home\\"), (\\"2023-10-01T12:35:08\\", 500, \\"/contact\\"), (\\"2023-10-01T12:35:10\\", 404, \\"/about\\"), ] >>> status_counts, url_counts = analyze_log_data(logs) >>> status_counts {200: 2, 404: 2, 500: 1} >>> url_counts {\'/home\': 2, \'/about\': 2, \'/contact\': 1} ``` # Constraints * The list of log entries can be empty. * Each log entry tuple will have exactly three elements: a valid ISO 8601 timestamp string, an integer status code, and a string URL. * The status codes and URLs are guaranteed to be valid and properly formatted. * Implement the solution in a manner that efficiently handles large lists of log entries.","solution":"def analyze_log_data( log_entries: list[tuple[str, int, str]] ) -> tuple[dict[int, int], dict[str, int]]: status_counts = {} url_counts = {} for timestamp, status_code, url in log_entries: if status_code in status_counts: status_counts[status_code] += 1 else: status_counts[status_code] = 1 if url in url_counts: url_counts[url] += 1 else: url_counts[url] = 1 return status_counts, url_counts"},{"question":"# Context You are developing a recommendation system for an online marketplace, and you want to implement a basic collaborative filtering algorithm to predict user ratings for items they have not yet rated. This will help you suggest items users might like. # Problem Statement Write a Python function to implement a collaborative filtering algorithm using matrix factorization with the following requirements: 1. **Initialization**: Must randomly initialize two matrices representing user and item latent features. 2. **Matrix Factorization**: Must perform matrix factorization using gradient descent to minimize the squared error between the actual and predicted ratings. 3. **Prediction Function**: Must predict the missing ratings using the dot product of the user and item latent feature matrices. # Function Signature ```python def collaborative_filtering(R: np.ndarray, K: int, alpha: float, beta: float, max_iterations: int) -> np.ndarray: Parameters: R: np.ndarray -> User-Item rating matrix (m x n) K: int -> Number of latent features alpha: float -> Learning rate for the gradient descent beta: float -> Regularization parameter to prevent overfitting max_iterations: int -> Number of iterations for the gradient descent Returns: np.ndarray -> Predicted User-Item rating matrix after training ``` # Input and Output - **Input**: - `R`: A `numpy` array of shape `(m, n)`, where `m` is the number of users and `n` is the number of items. Contains user ratings for items, with `NaN` representing missing ratings. - `K`: An integer representing the number of latent features. - `alpha`: A float representing the learning rate for gradient descent. - `beta`: A float representing the regularization parameter to prevent overfitting. - `max_iterations`: An integer specifying the number of iterations for gradient descent. - **Output**: - A `numpy` array of shape `(m, n)`, the predicted ratings based on matrix factorization. # Constraints - Missing ratings in the input matrix `R` are represented as `NaN` and must be handled during training. - The cost function should include a regularization term to prevent overfitting. - Gradient descent updates should be performed to minimize the cost function. # Example ```python import numpy as np R = np.array([[5, 3, NaN, 1], [4, NaN, NaN, 1], [1, 1, NaN, 5], [1, NaN, NaN, 4], [NaN, 1, 5, 4]]) K = 2 alpha = 0.01 beta = 0.01 max_iterations = 5000 predictions = collaborative_filtering(R, K, alpha, beta, max_iterations) print(predictions) # Example output might look like: # [[5.00, 3.00, 3.56, 1.00], # [4.00, 2.11, 2.79, 1.00], # [1.00, 1.00, 4.82, 5.00], # [1.00, 2.25, 3.99, 4.00], # [2.87, 1.00, 5.00, 4.00]] ``` # Test Case Validate your solution by: 1. Testing with a small toy dataset with known ratings. 2. Comparing your results with expected outputs or a library like Surprise for verification. 3. Ensuring edge cases are handled, for example matrices with many missing values, handling `NaN` appropriately during calculations and updates.","solution":"import numpy as np def collaborative_filtering(R: np.ndarray, K: int, alpha: float, beta: float, max_iterations: int) -> np.ndarray: Implements collaborative filtering using matrix factorization with gradient descent. Parameters: R: np.ndarray -> User-Item rating matrix (m x n) K: int -> Number of latent features alpha: float -> Learning rate for the gradient descent beta: float -> Regularization parameter to prevent overfitting max_iterations: int -> Number of iterations for the gradient descent Returns: np.ndarray -> Predicted User-Item rating matrix after training # Initialization m, n = R.shape P = np.random.rand(m, K) Q = np.random.rand(n, K) # Mask to deal with NaN values in R mask = ~np.isnan(R) # Gradient Descent for iteration in range(max_iterations): for i in range(m): for j in range(n): if mask[i, j]: error = R[i, j] - np.dot(P[i, :], Q[j, :]) for k in range(K): P[i, k] += alpha * (2 * error * Q[j, k] - beta * P[i, k]) Q[j, k] += alpha * (2 * error * P[i, k] - beta * Q[j, k]) # Compute total error total_error = 0 for i in range(m): for j in range(n): if mask[i, j]: total_error += (R[i, j] - np.dot(P[i, :], Q[j, :])) ** 2 # Regularization terms for k in range(K): total_error += (beta / 2) * (P[i, k] ** 2 + Q[j, k] ** 2) # Optionally print error or use it as a stopping criterion if (iteration + 1) % 1000 == 0: print(f\\"Iteration: {iteration + 1}, error: {total_error:.4f}\\") # Compute the full predicted rating matrix predicted_ratings = np.dot(P, Q.T) return predicted_ratings"},{"question":"# Duplicate Finder in List Your task is to implement a function that detects whether a list contains any duplicate elements. Function Signature ```python def has_duplicates(lst: List[int]) -> bool: ``` Input - A list of integers `lst`. Output - A boolean value, `True` if there are duplicates in the list, and `False` otherwise. Constraints - The list length is at most 10,000 elements. - The integer values in the list range from `-100,000` to `100,000`. - The function should be as efficient as possible with a suggested time complexity of O(n). Examples ```python - Input: [1, 2, 3, 4, 5] Output: False - Input: [10, 22, 10, 4, 1] Output: True - Input: [100000, -100000, 100000] Output: True - Input: [0, -1, 1, 2, 3] Output: False - Input: [42, 58, 39, 24, 42] Output: True ``` Additional requirements - You should not use any external libraries beyond Python standard library. - The implementation should be clear and efficient, utilizing appropriate data structures to check for duplicates. Write your code to implement the function based on the described behavior and constraints.","solution":"def has_duplicates(lst): Returns True if there are any duplicate elements in the list, otherwise False. seen = set() for num in lst: if num in seen: return True seen.add(num) return False"},{"question":"# Problem Statement: You are working on a banking software that handles a variety of transactions. A crucial feature of this software is to track and report fraudulent activities. One of the methods to detect fraud is to identify suspicious activities based on transaction patterns and locations. Your task is to implement a function to check for potential fraudulent activities based on the provided transaction history. # Requirements: 1. **Transaction Input**: Your function should accept a list of transactions, where each transaction is represented as a tuple: * User ID (integer). * Transaction amount (float). * Transaction location (string). * Transaction timestamp (integer). 2. **Fraud Detection Criteria**: The function should identify and return a list of user IDs that meet the following fraudulent conditions: * If a user has made more than a specified number of transactions within a given time window. * If a user has made transactions in more than a specified number of distinct locations within a given time window. 3. **Return Value**: The function should return a list of user IDs who meet either of the fraud detection criteria. The list should be sorted in ascending order and without duplicates. 4. **Function Parameters**: * `transaction_log`: List of transaction tuples as described above. * `max_transactions`: Maximum allowed transactions within the time window. * `max_locations`: Maximum allowed distinct locations within the time window. * `time_window`: Time window in seconds within which the transactions are evaluated. 5. **Error Handling**: Ensure your function can handle empty transaction logs gracefully and return an empty list in such cases. # Constraints: * The `transaction_log` can have up to 10^5 transactions. * The `time_window` is a positive integer within `[1, 86400]` (seconds in a day). * All user IDs and transaction timestamps are positive integers. * Locations are non-empty strings. # Function Signature: ```python def detect_fraudulent_activity( transaction_log: list[tuple[int, float, str, int]], max_transactions: int, max_locations: int, time_window: int ) -> list[int]: pass ``` # Example: ```python transaction_log = [ (1, 120.0, \\"New York\\", 1623437800), (2, 50.0, \\"Los Angeles\\", 1623439000), (1, 75.0, \\"Boston\\", 1623438100), (1, 200.0, \\"New York\\", 1623440000), (3, 300.0, \\"London\\", 1623443600), (1, 90.0, \\"Boston\\", 1623447200), (2, 60.0, \\"Los Angeles\\", 1623448100), (1, 100.0, \\"Miami\\", 1623448600), (3, 400.0, \\"Paris\\", 1623450500) ] # Example function call should return: # [1] # Explanation: # User 1 made more than 2 transactions in different locations (\\"New York\\", \\"Boston\\", \\"Miami\\") within the same time window. ``` # Task: Implement the `detect_fraudulent_activity` function which analyzes the transaction log and returns a list of user IDs who have potential fraudulent activities based on the provided criteria.","solution":"from collections import defaultdict def detect_fraudulent_activity( transaction_log, max_transactions, max_locations, time_window ): Detect potentially fraudulent user activities based on transaction patterns. Parameters: - transaction_log: List of tuples representing transactions (user_id, amount, location, timestamp). - max_transactions: Maximum allowed transactions within the time window. - max_locations: Maximum allowed distinct locations within the time window. - time_window: Time window in seconds to evaluate transactions. Returns: - List of user IDs with potential fraudulent activities, sorted in ascending order. user_transactions = defaultdict(list) for transaction in transaction_log: user_id, amount, location, timestamp = transaction user_transactions[user_id].append((amount, location, timestamp)) potential_fraud_users = set() for user_id, transactions in user_transactions.items(): transactions.sort(key=lambda x: x[2]) # Sort transactions by timestamp for i in range(len(transactions)): current_window = [] unique_locations = set() for j in range(i, len(transactions)): if transactions[j][2] - transactions[i][2] <= time_window: current_window.append(transactions[j]) unique_locations.add(transactions[j][1]) else: break if len(current_window) > max_transactions or len(unique_locations) > max_locations: potential_fraud_users.add(user_id) break return sorted(potential_fraud_users)"},{"question":"# Coding Question You are tasked with creating a function that takes a positive integer `n` as input and returns the nth number in the sequence composed of numbers that are both Palindromic and Prime. A palindromic number reads the same forward and backward (e.g., 121 or 141). A prime number only has two distinct divisors: 1 and itself (e.g., 2, 3, 5). To clarify, your function should identify prime numbers that are also palindromic and return the nth element in this sequence. **Function Signature**: ```python def nth_palindromic_prime(n: int) -> int: pass ``` **Input**: * `n` (int): A positive integer specifying the position in the sequence of palindromic prime numbers. **Output**: * Returns an integer which is the nth palindromic prime number. **Constraints**: * The function should handle reasonably large values of `n` efficiently. * You should ensure that the function operates within acceptable time complexity to handle such values. **Examples**: ```python assert nth_palindromic_prime(1) == 2 # The first palindromic prime assert nth_palindromic_prime(5) == 11 # The fifth palindromic prime ```","solution":"def nth_palindromic_prime(n: int) -> int: Returns the nth palindromic prime number. # Helper function to check primality def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Helper function to check if a number is palindromic def is_palindromic(num): return str(num) == str(num)[::-1] count = 0 candidate = 2 while True: if is_prime(candidate) and is_palindromic(candidate): count += 1 if count == n: return candidate candidate += 1"},{"question":"# Question: Implement a Circular Queue Using a Fixed-Size Array Implement a circular queue data structure using a fixed-size array (or list) in Python. You need to provide methods to enqueue, dequeue, and check if the queue is empty or full. This circular queue should be implemented following the First-In-First-Out (FIFO) principle. Function Signature: ```python class CircularQueue: def __init__(self, capacity: int): pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass ``` # Input - Initialize the queue with an integer `capacity`, which denotes the maximum number of elements the queue can hold. - `enqueue` method accepts an integer value to add to the queue. It should return `True` if the operation is successful, otherwise `False`. - `dequeue` method removes and returns the front item from the queue. If the queue is empty, it should return `-1`. - `is_empty` method returns `True` if the queue is empty, otherwise `False`. - `is_full` method returns `True` if the queue is full, otherwise `False`. # Constraints - The `capacity` will be a positive integer and will not exceed `1000`. - Each integer for the `enqueue` method will be between `-1000` and `1000`. # Example ```python cq = CircularQueue(3) assert cq.enqueue(1) == True # queue is now [1] assert cq.enqueue(2) == True # queue is now [1, 2] assert cq.enqueue(3) == True # queue is now [1, 2, 3] assert cq.enqueue(4) == False # queue is full, cannot enqueue, returns False assert cq.is_full() == True # queue is full assert cq.dequeue() == 1 # returns 1, queue is now [2, 3] assert cq.dequeue() == 2 # returns 2, queue is now [3] assert cq.dequeue() == 3 # returns 3, queue is now [] assert cq.is_empty() == True # queue is empty assert cq.dequeue() == -1 # queue is empty, cannot dequeue, returns -1 ``` # Notes - Ensure your implementation handles wrapping around the end of the list properly. - Test thoroughly to ensure your queue handles the edge cases of being empty and full correctly. - Pay attention to performance, aiming for O(1) time complexity for each operation.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.is_empty(): self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value return True def dequeue(self) -> int: if self.is_empty(): return -1 value = self.queue[self.front] if self.front == self.rear: self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.capacity return value def is_empty(self) -> bool: return self.front == -1 def is_full(self) -> bool: return (self.rear + 1) % self.capacity == self.front"},{"question":"# Scenario You are responsible for developing a functionality within a text editor that allows users to perform basic find-and-replace operations on their documents. The implementation needs to handle multiple occurrences of the search string and perform the replacement efficiently. Additionally, the users should be able to perform the operation case-insensitively if needed. # Task 1. **Implement `find_and_replace` function** - Input: A string `text`, a string `search`, a string `replace`, and a boolean `case_sensitive`. - Output: A new string where all occurrences of `search` in `text` are replaced by `replace`. - Constraints: - Perform the operation case-insensitively if `case_sensitive` is `False`. # Requirements - Your implementation should handle edge cases like empty strings and overlapping patterns gracefully. - Optimize the function for performance, especially for long texts and frequent operations. - Ensure proper handling of Unicode and multi-byte characters. # Function Specifications # `find_and_replace(text: str, search: str, replace: str, case_sensitive: bool = True) -> str` - **Input**: - `text`: The input text where replacements need to be performed. - `search`: The substring which needs to be found and replaced. - `replace`: The replacement string. - `case_sensitive`: A boolean flag to indicate case-sensitive or case-insensitive replacement. - **Output**: A string with the replacements made. # Example Usage ```python # Case-sensitive replacement text = \\"Hello World! Welcome to the world of programming.\\" search = \\"world\\" replace = \\"universe\\" result = find_and_replace(text, search, replace) print(result) # \\"Hello World! Welcome to the universe of programming.\\" # Case-insensitive replacement text = \\"Hello World! Welcome to the world of programming.\\" search = \\"world\\" replace = \\"universe\\" result = find_and_replace(text, search, replace, case_sensitive=False) print(result) # \\"Hello universe! Welcome to the universe of programming.\\" ``` # Additional Considerations - Ensure that the function handles special characters and different text encodings properly. - Pay attention to potential edge cases, such as the search string being a prefix or suffix of the text. - Aim for clear, readable, and maintainable code while ensuring good performance.","solution":"def find_and_replace(text, search, replace, case_sensitive=True): Replaces all occurrences of search in text with replace. Handles case-insensitive replacements based on the case_sensitive flag. if not text or not search: return text # Nothing to replace if case_sensitive: return text.replace(search, replace) else: import re pattern = re.compile(re.escape(search), re.IGNORECASE) return pattern.sub(replace, text)"},{"question":"**Context**: You are working as a software engineer in a company that processes large volumes of text data. One common task is to determine the frequency of certain patterns, such as substrings, within this data. For this, efficiently locating all occurrences of a substring within a string is crucial. **Task**: Write a function `find_substring_occurrences` that returns a list of all starting indices where the pattern `pat` is found in the string `text`. Implement an efficient algorithm, such as Knuth-Morris-Pratt (KMP), to perform the search. # Function Signature ```python def find_substring_occurrences(text: str, pat: str) -> List[int]: pass ``` # Input * `text`: A string of length (n). * `pat`: A string of length (m). # Output * Returns a list of integers, each representing the starting index of an occurrence of `pat` within `text`. # Constraints * 0 ≤ len(text) ≤ 10^6 * 0 ≤ len(pat) ≤ 10^5 # Performance Requirement * The implementation should have a time complexity of (O(n + m)). # Example ```python assert find_substring_occurrences(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_substring_occurrences(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] assert find_substring_occurrences(\\"hello world\\", \\"world\\") == [6] assert find_substring_occurrences(\\"abcdef\\", \\"gh\\") == [] assert find_substring_occurrences(\\"abcdef\\", \\"\\") == [] ``` Implement the `find_substring_occurrences` function such that it efficiently locates all occurrences of `pat` in `text` using the KMP algorithm.","solution":"from typing import List def find_substring_occurrences(text: str, pat: str) -> List[int]: if not pat: return [] n, m = len(text), len(pat) lps = compute_lps(pat) result = [] i = 0 # index for text j = 0 # index for pat while i < n: if pat[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pat[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result def compute_lps(pat: str) -> List[int]: m = len(pat) lps = [0] * m length = 0 i = 1 while i < m: if pat[i] == pat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps"},{"question":"# Genetic Algorithm Implementation for Travelling Salesman Problem Your task is to implement a Genetic Algorithm (GA) to solve the Travelling Salesman Problem (TSP). Extend the existing framework to optimize the route based on provided data and evaluate its performance. Objectives: 1. **Algorithm Design and Optimization**: - Develop a genetic algorithm to find an optimal or near-optimal route for the TSP. - The algorithm should accept datasets with arbitrary number of cities. 2. **Implementation Requirements**: - Implement a new **Chromosome** class to represent a potential solution. - Implement a **crossover function** to combine two parent chromosomes. - Implement a **mutation function** to introduce variation in the chromosome. - Extend the **GeneticAlgorithm** framework to support **fitness evaluation**, **selection**, and **elitism**. 3. **Input and Output Formats**: - **Input**: * **Distances Matrix**: (D) (shape: (N times N)), where (D[i][j]) represents the distance between city (i) and city (j). - **Output**: * Best route found and its total distance. 4. **Data Constraints**: - (N) (number of cities) ≤ 100 5. **Performance Requirement**: - The algorithm should run within a reasonable time frame even for larger values of (N). - The implementation should handle cases where initialization might provide suboptimal starting points and ensure diverse populations to avoid premature convergence. Context: You are developing a genetic algorithm to plan the most efficient route for a travelling salesman who needs to visit a number of cities and return to the starting point. The goal is to minimize the total distance travelled. Use genetic operators like selection, crossover, and mutation to evolve potential solutions and find the best route. You do not need to implement the city coordinates generation or the initial distances matrix calculation steps. Focus on extending the GA framework to solve the TSP effectively. Example Usage: ```python import numpy as np # Dummy Distances Matrix D = np.random.rand(10, 10) for i in range(10): D[i, i] = 0 # Distance from a city to itself is zero. # Model Building and Training ga = GeneticAlgorithm() ga.initialize_population(size=100, chromosome_length=10) ga.set_distance_matrix(D) best_route, best_distance = ga.evolve(generations=500, mutation_rate=0.02, elitism_count=2) print(f\'Best Route: {best_route}\') print(f\'Total Distance: {best_distance}\') ``` Remember to pay attention to all aspects of the genetic algorithm including initialization, fitness evaluation, selection, crossover, mutation, and termination condition to ensure it integrates well with the given specifications and expectations.","solution":"import numpy as np import random class Chromosome: def __init__(self, route): self.route = route self.fitness = None def evaluate_fitness(self, distance_matrix): self.fitness = 0 for i in range(len(self.route) - 1): self.fitness += distance_matrix[self.route[i]][self.route[i + 1]] self.fitness += distance_matrix[self.route[-1]][self.route[0]] # Return to the start return self.fitness def crossover(parent1, parent2): cut = random.randint(1, len(parent1.route) - 2) child1_route = parent1.route[:cut] + [city for city in parent2.route if city not in parent1.route[:cut]] child2_route = parent2.route[:cut] + [city for city in parent1.route if city not in parent2.route[:cut]] return Chromosome(child1_route), Chromosome(child2_route) def mutate(chromosome, mutation_rate): if random.random() < mutation_rate: i, j = random.sample(range(len(chromosome.route)), 2) chromosome.route[i], chromosome.route[j] = chromosome.route[j], chromosome.route[i] class GeneticAlgorithm: def __init__(self): self.population = [] self.distance_matrix = None def initialize_population(self, size, chromosome_length): self.population = [Chromosome(random.sample(range(chromosome_length), chromosome_length)) for _ in range(size)] def set_distance_matrix(self, distance_matrix): self.distance_matrix = distance_matrix def evolve(self, generations, mutation_rate, elitism_count): for generation in range(generations): self.population = sorted(self.population, key=lambda c: c.evaluate_fitness(self.distance_matrix)) new_population = self.population[:elitism_count] # Elitism while len(new_population) < len(self.population): parent1, parent2 = random.sample(self.population[:50], 2) # Random selection from top 50 child1, child2 = crossover(parent1, parent2) mutate(child1, mutation_rate) mutate(child2, mutation_rate) new_population.extend([child1, child2]) self.population = new_population[:len(self.population)] best_chromosome = sorted(self.population, key=lambda c: c.evaluate_fitness(self.distance_matrix))[0] return best_chromosome.route, best_chromosome.fitness"},{"question":"# Coding Question: Trie Operations for Autocomplete System Background: A company is developing an autocomplete system for its messaging application. The system will use a Trie (prefix tree) to efficiently manage strings (words, usernames, etc.) and quickly suggest completions based on user input. The system must support operations such as inserting new strings, checking for the existence of a string, and finding all strings with a given prefix. Task: Implement the following operations in your Trie class: 1. **Insert String**: Add a new string to the Trie. 2. **Search String**: Check if a given string exists in the Trie. 3. **Starts With Prefix**: Return all strings that start with a given prefix. Your Trie class must have the following methods implementing the required operations: ```python class TrieNode: def __init__(self): Initialize a Trie node with children and a boolean to track the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the root of the Trie. self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. :param word: String to be inserted. pass def search(self, word: str) -> bool: Search for a word in the Trie. :param word: String to be searched. :return: True if word exists in the Trie, otherwise False. pass def starts_with(self, prefix: str) -> list[str]: Find all words in the Trie that start with the given prefix. :param prefix: The prefix string. :return: List of all words in the Trie that start with the prefix. pass ``` Input/Output Format: * `insert(word: str)` - Adds a new word to the Trie. * `search(word: str)` - Returns `True` if the word exists in the Trie, `False` otherwise. * `starts_with(prefix: str)` - Returns a list of words that start with the given prefix. Constraints: * All strings consist of lowercase English letters. * The length of each string will not exceed 100. * The number of strings will not exceed 10^6. Example Usage: ```python # Example initialization and operations trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"helium\\") print(trie.search(\\"hello\\")) # Output: True print(trie.search(\\"helix\\")) # Output: False print(trie.starts_with(\\"he\\")) # Output: [\\"hello\\", \\"helium\\"] print(trie.starts_with(\\"hex\\")) # Output: [] ``` Ensure that your implementation efficiently supports the operations and maintains the properties of the Trie, allowing for fast retrieval of strings based on prefixes.","solution":"class TrieNode: def __init__(self): Initialize a Trie node with children and a boolean to track the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the root of the Trie. self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. :param word: String to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Search for a word in the Trie. :param word: String to be searched. :return: True if word exists in the Trie, otherwise False. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> list[str]: Find all words in the Trie that start with the given prefix. :param prefix: The prefix string. :return: List of all words in the Trie that start with the prefix. def dfs(node, prefix): results = [] if node.is_end_of_word: results.append(prefix) for char, next_node in node.children.items(): results.extend(dfs(next_node, prefix + char)) return results node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return dfs(node, prefix)"},{"question":"# Context Matrix manipulation is a common operation in various scientific and engineering applications. An important task is rotating a matrix, which is often used in computer graphics, image processing, and more. To rotate a matrix by 90 degrees clockwise, each element of the matrix must be moved to its new position in the resulting matrix. # Problem You are required to implement a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that accepts a 2-dimensional list (matrix) of integers and returns a new matrix that represents the original matrix rotated by 90 degrees clockwise. # Detailed Requirements 1. **Matrix Dimensions**: Ensure the matrix is not empty and has equal dimensions (NxN). 2. **Rotation Logic**: Each element `(i, j)` of the original matrix should be placed at `(j, N-1-i)` in the rotated matrix. 3. **Edge Case Handling**: - If the matrix is empty or not square, your function should raise a `ValueError` with the message \\"The matrix must be a non-empty square matrix.\\" 4. **Return Value**: The function returns a new 2-dimensional list representing the rotated matrix. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: ``` # Example ```python >>> rotate_matrix(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix(matrix=[[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix(matrix=[]) Traceback (most recent call last): ... ValueError: The matrix must be a non-empty square matrix. >>> rotate_matrix(matrix=[[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: The matrix must be a non-empty square matrix. ``` # Constraints 1. The input matrix will have at most `1000 x 1000` elements. 2. Each element in the matrix is an integer. # Notes - Ensure the function executes efficiently, considering the constraints. - Handle different edge cases appropriately to avoid errors.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a square matrix by 90 degrees clockwise. # Check if matrix is empty if not matrix or not matrix[0]: raise ValueError(\\"The matrix must be a non-empty square matrix.\\") # Check if matrix is square n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be a non-empty square matrix.\\") # Initialize the rotated matrix rotated_matrix = [[0] * n for _ in range(n)] # Fill the rotated matrix for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Coding Assessment Question Scenario You are developing a software for a library management system. One of the key features is managing the borrowing and return of books. Each book has a unique identifier (book ID) and can be borrowed by library members. To keep track of the borrowing status, you need to implement a borrowing system that handles multiple operations such as checking out a book, returning a book, and checking the current status of a book. Objective Write a class `Library` that: - Initializes with an empty dictionary to store book status. - Implements methods to handle the following operations: Class Methods 1. `checkout(book_id: str) -> str`: - Marks the book as checked out. - Returns \\"Success\\" if the book was successfully checked out, or \\"Already checked out\\" if it is already borrowed. 2. `return_book(book_id: str) -> str`: - Marks the book as returned. - Returns \\"Success\\" if the book was successfully returned, or \\"Not found\\" if the book is not found in the system. 3. `book_status(book_id: str) -> str`: - Returns \\"Available\\" if the book is not checked out, \\"Checked out\\" if it is currently borrowed, or \\"Not found\\" if the book is not found in the system. Function Signature ```python class Library: def __init__(self): pass def checkout(self, book_id: str) -> str: pass def return_book(self, book_id: str) -> str: pass def book_status(self, book_id: str) -> str: pass ``` Example ```python library = Library() print(library.checkout(\\"book1\\")) # Output: \\"Success\\" print(library.book_status(\\"book1\\")) # Output: \\"Checked out\\" print(library.checkout(\\"book1\\")) # Output: \\"Already checked out\\" print(library.return_book(\\"book1\\")) # Output: \\"Success\\" print(library.book_status(\\"book1\\")) # Output: \\"Available\\" print(library.return_book(\\"book2\\")) # Output: \\"Not found\\" ``` Constraints - The book ID is a non-empty string consisting of letters and digits. - Handle up to 1000 book records efficiently. Additional Notes - Ensure thread-safety if your implementation is meant to be used in a multi-threaded context. - Consider edge cases where methods are called with invalid or unexpected input.","solution":"class Library: def __init__(self): self.books = {} def checkout(self, book_id: str) -> str: if book_id in self.books and self.books[book_id] == \\"Checked out\\": return \\"Already checked out\\" self.books[book_id] = \\"Checked out\\" return \\"Success\\" def return_book(self, book_id: str) -> str: if book_id not in self.books: return \\"Not found\\" self.books[book_id] = \\"Available\\" return \\"Success\\" def book_status(self, book_id: str) -> str: if book_id not in self.books: return \\"Not found\\" return self.books[book_id]"},{"question":"# Question You are provided with helper functions that calculate the LCM (Least Common Multiple) and GCD (Greatest Common Divisor) of two integers. Given this, write a function named `complex_integer_analysis` that accomplishes the following: 1. Calculate the GCD of two integers. 2. Calculate the LCM of two integers. 3. Determine if the first integer is a prime number. 4. Return a dictionary containing the GCD, LCM, and a boolean indicating the primality of the first integer. # Required Function Signature ```python def complex_integer_analysis(a: int, b: int) -> dict: pass ``` # Helper Function Signatures (Do not modify these functions) ```python def gcd(x: int, y: int) -> int: while y: x, y = y, x % y return x def lcm(x: int, y: int) -> int: return abs(x * y) // gcd(x, y) def is_prime(n: int) -> bool: if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True ``` # Examples ```python >>> complex_integer_analysis(12, 15) {\'gcd\': 3, \'lcm\': 60, \'prime\': False} >>> complex_integer_analysis(17, 23) {\'gcd\': 1, \'lcm\': 391, \'prime\': True} >>> complex_integer_analysis(4, 24) {\'gcd\': 4, \'lcm\': 24, \'prime\': False} ``` # Constraints * Both `a` and `b` will be non-negative integers between 1 and 1,000,000. * The solution should handle all edge cases including very large numbers efficiently. # Notes * Ensure that the function uses the provided helper functions correctly. * The dictionary returned should have keys: `\'gcd\'`, `\'lcm\'`, and `\'prime\'`, with appropriate values.","solution":"def complex_integer_analysis(a: int, b: int) -> dict: Analyzes two integers to compute - GCD of the two integers. - LCM of the two integers. - Primality of the first integer. Returns a dictionary with the results. result = {} result[\'gcd\'] = gcd(a, b) result[\'lcm\'] = lcm(a, b) result[\'prime\'] = is_prime(a) return result def gcd(x: int, y: int) -> int: while y: x, y = y, x % y return x def lcm(x: int, y: int) -> int: return abs(x * y) // gcd(x, y) def is_prime(n: int) -> bool: if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True"},{"question":"# Zigzag Conversion **Context**: In programming, string manipulation and pattern generation are common tasks. One intriguing pattern is the \\"zigzag\\" conversion. This involves taking an input string and arranging its characters in a zigzag pattern on a given number of rows. Then, reading the characters row by row to produce a new string. This exercise tests your understanding of string manipulation and indexing. **Objective**: Implement a function that takes a string and converts it into a zigzag pattern based on a specified number of rows, then reads the characters row by row to form a new string. # Function Signature ```python def zigzag_conversion(s: str, num_rows: int) -> str: Convert a given string s into a zigzag pattern on num_rows. Parameters: - s (str): The input string to be converted. - num_rows (int): The number of rows to form the zigzag pattern. Returns: - str: The string formed by reading the zigzag pattern row by row. Examples: >>> zigzag_conversion(\\"PAYPALISHIRING\\", 3) \'PAHNAPLSIIGYIR\' >>> zigzag_conversion(\\"PAYPALISHIRING\\", 4) \'PINALSIGYAHRPI\' >>> zigzag_conversion(\\"A\\", 1) \'A\' >>> zigzag_conversion(\\"HELLO\\", 2) \'HLOEL\' pass ``` # Constraints * 1 <= len(s) <= 1000 * 1 <= num_rows <= 1000 * Input string will consist of uppercase English letters and digits. # Requirements * Complete the `zigzag_conversion(s: str, num_rows: int) -> str` function to achieve the objectives as described. * Design your solution to run in O(n) time complexity, where n is the length of the input string.","solution":"def zigzag_conversion(s: str, num_rows: int) -> str: Convert a given string s into a zigzag pattern on num_rows. Parameters: - s (str): The input string to be converted. - num_rows (int): The number of rows to form the zigzag pattern. Returns: - str: The string formed by reading the zigzag pattern row by row. if num_rows == 1 or num_rows >= len(s): return s rows = [\'\'] * num_rows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == num_rows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \'\'.join(rows) # Examples: # zigzag_conversion(\\"PAYPALISHIRING\\", 3) returns \'PAHNAPLSIIGYIR\' # zigzag_conversion(\\"PAYPALISHIRING\\", 4) returns \'PINALSIGYAHRPI\' # zigzag_conversion(\\"A\\", 1) returns \'A\' # zigzag_conversion(\\"HELLO\\", 2) returns \'HLOEL\'"},{"question":"# Question: Valid HTML Tag Checker You are given a string that represents an HTML fragment. Your task is to implement a function `is_valid_html_fragment` to check if the string contains valid nested HTML tags. A valid nested HTML fragment means that each opening tag has a corresponding and correctly nested closing tag. Function Signature ```python def is_valid_html_fragment(html_fragment: str) -> bool: ``` Parameters - `html_fragment`: A string representing the HTML fragment. Returns - bool: Returns `True` if the HTML fragment is valid, otherwise `False`. Assumptions - HTML fragment will contain only tags and text; no attributes are included within tags. - Tags will be in the format `<tag>` for opening tags and `</tag>` for closing tags. - Tags and text will consist of only lowercase letters. Constraints 1. The length of `html_fragment` will be between 1 and 1000 characters. 2. Tags will be strictly made up of alphabetic characters in lowercase. Examples ```python # Example 1 html_fragment = \\"<div><span>Text</span></div>\\" print(is_valid_html_fragment(html_fragment)) # Expected Output: True # Example 2 html_fragment = \\"<div><a>Link</a><div>\\" print(is_valid_html_fragment(html_fragment)) # Expected Output: False # Example 3 html_fragment = \\"<b>Hello</b><i>World</i>\\" print(is_valid_html_fragment(html_fragment)) # Expected Output: True # Example 4 html_fragment = \\"<div><p>Paragraph</div></p>\\" print(is_valid_html_fragment(html_fragment)) # Expected Output: False ``` Notes: * Ensure that your function efficiently parses and validates the HTML fragment. * Consider edge cases such as nested tags being incorrectly ordered or tags that are not closed. Your implementation must correctly identify whether the HTML fragment is properly nested and tagged.","solution":"def is_valid_html_fragment(html_fragment: str) -> bool: Checks if the given HTML fragment has valid nested HTML tags. import re tag_pattern = re.compile(r\'</?([a-z]+)>\') stack = [] for match in tag_pattern.finditer(html_fragment): tag = match.group(0) tag_name = match.group(1) if tag.startswith(\'</\'): if not stack or stack.pop() != tag_name: return False else: stack.append(tag_name) return len(stack) == 0"},{"question":"**Problem Statement**: Design and implement a Trie (prefix tree) data structure that supports adding words and searching for words with a given prefix. # Features to Implement: 1. **Insert**: - Method: `insert(word: str) -> None` - Description: Adds a new word to the Trie. If the word is already present, it should update the Trie accordingly (although no repetitive data storage is required). 2. **Search**: - Method: `search(word: str) -> bool` - Description: Returns `True` if the word is present in the Trie, `False` otherwise. 3. **Starts With**: - Method: `starts_with(prefix: str) -> bool` - Description: Returns `True` if there is any word in the Trie that starts with the given prefix, `False` otherwise. 4. **Delete**: - Method: `delete(word: str) -> None` - Description: Removes the word from the Trie. If the word is not present, raise a `ValueError`. # Constraints: - Words consist of lowercase English letters only. - The operations should be optimized for efficiency, especially for large datasets. # Example: ```python # Example Usage trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == False assert trie.starts_with(\\"app\\") == True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True trie.delete(\\"app\\") assert trie.search(\\"app\\") == False ``` ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._find_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._find_node(prefix) is not None def delete(self, word: str) -> None: def _delete(node, word, depth): if depth == len(word): if not node.is_end_of_word: raise ValueError(f\\"Word \'{word}\' not found in Trie\\") node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char not in node.children: raise ValueError(f\\"Word \'{word}\' not found in Trie\\") should_delete_child = _delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False _delete(self.root, word, 0) def _find_node(self, word: str) -> TrieNode: node = self.root for char in word: if char not in node.children: return None node = node.children[char] return node ``` Implement the `Trie` class and ensure your implementation passes all necessary edge cases.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._find_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._find_node(prefix) is not None def delete(self, word: str) -> None: def _delete(node, word, depth): if depth == len(word): if not node.is_end_of_word: raise ValueError(f\\"Word \'{word}\' not found in Trie\\") node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char not in node.children: raise ValueError(f\\"Word \'{word}\' not found in Trie\\") should_delete_child = _delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False _delete(self.root, word, 0) def _find_node(self, word: str) -> TrieNode: node = self.root for char in word: if char not in node.children: return None node = node.children[char] return node"},{"question":"# Alternating Case String You need to manipulate a given string so that its characters alternate between upper and lower case, starting with an upper case letter. The function should handle different types of input strings, including alphanumeric characters and punctuation. # Implementation Details Implement the function `alternate_case` that takes an input string and returns a new string where the case alternates starting with an uppercase character. Function Signature ```python def alternate_case(s: str) -> str: ... ``` Inputs - `s`: A string consisting of characters from the ASCII set (alphanumeric and punctuation). Outputs - Returns a new string where the case of each character alternates, starting with an uppercase character. Constraints - The input string will be non-empty with a length up to 1000 characters. - Non-alphabetical characters should remain unchanged but still count in the alternating sequence. Examples ```python s = \\"hello world!\\" print(alternate_case(s)) # Outputs: \\"HeLlO WoRlD!\\" s = \\"Python3.6\\" print(alternate_case(s)) # Outputs: \\"PyThOn3.6\\" s = \\"Data123\\" print(alternate_case(s)) # Outputs: \\"DaTa123\\" ``` Note - Ensure that non-alphabetical characters are counted for alternating but do not change their case. - Implement careful checking for the case of each character and alternate accordingly through the string.","solution":"def alternate_case(s: str) -> str: Returns a new string where the characters alternate between upper and lower case, starting with an uppercase character. Non-alphabetical characters remain unchanged but count in the alternation sequence. result = [] upper = True # Start with uppercase for char in s: if char.isalpha(): # Check if the character is a letter if upper: result.append(char.upper()) else: result.append(char.lower()) upper = not upper # Toggle the case else: result.append(char) upper = not upper # Non-alphabet chars still count in the alternation sequence return \'\'.join(result)"},{"question":"# Array Element Rearrangement **Context**: Arrays are fundamental data structures in computer science. A common problem with arrays is rearranging their elements to meet a specific criteria. Your task is to rearrange the elements of a given array in a specific manner. **Tasks**: 1. `rearrange_array(arr: List[int]) -> List[int]`: Rearranges the elements of the given array such that all even numbers appear before all odd numbers, while preserving their relative order within the even and odd groups. **Input and Output**: - **Input**: A list of integers `arr` with at most `10^5` elements. - **Output**: A new list of integers where all even numbers appear before all odd numbers, with their relative order preserved. **Constraints**: - `1 <= len(arr) <= 10^5` - `-10^9 <= arr[i] <= 10^9` **Performance Requirements**: The function should run in O(n) time and use O(n) extra space, where n is the length of `arr`. **Examples**: ```python assert rearrange_array([3, 1, 2, 4]) == [2, 4, 3, 1] assert rearrange_array([7, 8, 5, 6, 3, 10]) == [8, 6, 10, 7, 5, 3] assert rearrange_array([1, 3, 5, 7]) == [1, 3, 5, 7] # no even numbers assert rearrange_array([2, 4, 6]) == [2, 4, 6] # no odd numbers ``` **Note**: Implement the following function in a single file named `array_rearrangement.py`: ```python from typing import List def rearrange_array(arr: List[int]) -> List[int]: evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds ```","solution":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the given array such that all even numbers appear before all odd numbers, while preserving their relative order within the even and odd groups. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"# Task Implement a function `is_palindrome_permutation` that checks if the provided string can be rearranged to form a palindrome. # Scenarios Your function will help in determining if it is possible to rearrange a given string to create a palindrome, which is useful in various text processing applications like identifying anagrams. # Input - A single string `s` which can contain letters, digits, and whitespace. # Output - A boolean value `True` if the string can be rearranged to form a palindrome, and `False` otherwise. # Constraints 1. The input string will have at most 1000 characters. 2. The function must be case-insensitive. # Requirements - Ignore all whitespaces and consider only alphanumeric characters. - Normalize the input string to a consistent case (either all lower or all upper case) for the check. # Hint - A string can be rearranged to form a palindrome if at most one character occurs an odd number of times, and all other characters occur an even number of times. # Examples ```python def is_palindrome_permutation(s: str) -> bool: # Your implementation here pass # Example Test Cases: print(is_palindrome_permutation(\\"Tact Coa\\")) # Expected output: True print(is_palindrome_permutation(\\"Racecar\\")) # Expected output: True print(is_palindrome_permutation(\\"Hello\\")) # Expected output: False print(is_palindrome_permutation(\\"A man a plan a canal Panama\\")) # Expected output: True print(is_palindrome_permutation(\\"No lemon no melon\\")) # Expected output: True ```","solution":"def is_palindrome_permutation(s: str) -> bool: Checks if the provided string can be rearranged to form a palindrome. from collections import Counter # Normalize the string: remove non-alphanumeric characters and convert to lower case normalized_str = \'\'.join(filter(str.isalnum, s)).lower() # Count character frequencies char_count = Counter(normalized_str) # Check the number of characters that have odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"# Event Aggregator for Weather Application You are developing a client-side application that displays real-time weather updates from multiple sources for better accuracy and robustness. To effectively aggregate and present weather data, you decide to implement an `EventAggregator` class that: * Subscribes to multiple weather data sources (publishers). * Aggregates weather updates. * Notifies subscribers about the latest aggregated weather data. # Requirements 1. Implement the class `EventAggregator` with the following methods: * **`__init__(self)`**: * Initialize with an empty list of subscribers and an empty data dictionary for aggregating weather updates. * **`subscribe(self, subscriber: callable)`**: * Add a subscriber which is a callable (e.g., a function) to the list of subscribers. * **`unsubscribe(self, subscriber: callable)`**: * Remove a subscriber from the list of subscribers. * **`publish(self, source: str, weather_data: dict)`**: * Add or update the weather data from the specified source to the data dictionary. * Notify all subscribers about the aggregated weather data. * **`get_aggregated_data(self) -> dict`**: * Return the latest aggregated weather data from all sources. 2. Implement typical subscriber functions that handle notifications received from the `EventAggregator`. # Constraints * Subscribers can be any callable (e.g., functions or methods) that accept a single argument (the aggregated weather data). * Weather data from different sources might contain overlapping or complementary information (e.g., temperature, humidity, wind speed). # Example Usage ```python def display_weather(aggregated_data): # Example subscriber function to display weather data print(\\"Updated Weather Data:\\", aggregated_data) # Initialize the EventAggregator aggregator = EventAggregator() # Subscribe a function to receive updates aggregator.subscribe(display_weather) # Publish weather data from different sources aggregator.publish(\\"source_1\\", {\\"temperature\\": 22.5, \\"humidity\\": 60}) aggregator.publish(\\"source_2\\", {\\"wind_speed\\": 15, \\"temperature\\": 22.8}) # Get the latest aggregated data aggregated_weather = aggregator.get_aggregated_data() print(\\"Aggregated Weather Data:\\", aggregated_weather) # Unsubscribe the function aggregator.unsubscribe(display_weather) ``` # Expected Input & Output * **Input**: Weather data published from various sources. * **Output**: Aggregated weather data dictionary and notifications sent to subscribers. Implement the `EventAggregator` class and ensure it handles subscriptions, unsubscriptions, and publishes updates correctly while aggregating data from multiple sources.","solution":"class EventAggregator: def __init__(self): self.subscribers = [] self.data = {} def subscribe(self, subscriber: callable): if subscriber not in self.subscribers: self.subscribers.append(subscriber) def unsubscribe(self, subscriber: callable): if subscriber in self.subscribers: self.subscribers.remove(subscriber) def publish(self, source: str, weather_data: dict): self.data[source] = weather_data self.notify_subscribers() def notify_subscribers(self): # Create a merged dictionary from all data aggregated_data = {} for data in self.data.values(): aggregated_data.update(data) for subscriber in self.subscribers: subscriber(aggregated_data) def get_aggregated_data(self) -> dict: aggregated_data = {} for data in self.data.values(): aggregated_data.update(data) return aggregated_data"},{"question":"# Scenario You are working on developing a small library of mathematical functions to help visualize the properties of different shapes for a geometry course. One of the shapes you\'ll need to support is the right-angled triangle. The library should help calculate the length of one side given the other two sides, adhering to the Pythagorean Theorem. # Task You need to implement a function that calculates the length of one of the sides (either the hypotenuse or one of the legs) based on the other two sides. # Function Signature ```python def calculate_triangle_side( missing_side: str, side_a: float = None, side_b: float = None, hypotenuse: float = None ) -> float: ``` # Input 1. `missing_side` (str): The side that you want to compute. It can be one of `\\"side_a\\"`, `\\"side_b\\"`, or `\\"hypotenuse\\"`. 2. The other two parameters must be provided as positive floats. If the parameter is not relevant (i.e., the side we\'re solving for), it should be set to `None`. For example, if `missing_side` is `\\"side_a\\"`, then `side_a` should be `None`. # Output The function should return the computed value of the missing side as a float. # Constraints * Negative inputs, the absence of enough parameters, or impossible triangle configurations should raise a `ValueError`. * Use the Pythagorean Theorem (a^2 + b^2 = c^2), where (a) and (b) are the legs of the triangle and (c) is the hypotenuse. # Example ```python >>> calculate_triangle_side(\'side_a\', side_b=3, hypotenuse=5) 4.0 >>> calculate_triangle_side(\'side_b\', side_a=6, hypotenuse=10) 8.0 >>> calculate_triangle_side(\'hypotenuse\', side_a=5, side_b=12) 13.0 >>> calculate_triangle_side(\'side_b\', side_a=-3, hypotenuse=5) Traceback (most recent call last): ... ValueError: Invalid inputs. Enter positive values. >>> calculate_triangle_side(\'side_a\', side_b=3, hypotenuse=2) Traceback (most recent call last): ... ValueError: Impossible triangle configuration. ``` # Important Note Ensure your function validates for positive input values and raises a `ValueError` with the message `\\"Invalid inputs. Enter positive values.\\"` when negative values are passed. Additionally, check for possible triangle configurations and raise a `ValueError` with the message `\\"Impossible triangle configuration.\\"` when the input values do not form a valid right-angled triangle. # Hint You may find it useful to utilize or refer to the direct relationships expressed in the Pythagorean Theorem to achieve the solution.","solution":"import math def calculate_triangle_side( missing_side: str, side_a: float = None, side_b: float = None, hypotenuse: float = None ) -> float: Calculate the missing side of a right-angled triangle given two other sides. Parameters: missing_side (str): The side to be calculated, possible values are \'side_a\', \'side_b\', or \'hypotenuse\'. side_a (float): Length of side a, should be None if missing_side is \'side_a\'. side_b (float): Length of side b, should be None if missing_side is \'side_b\'. hypotenuse (float): Length of the hypotenuse, should be None if missing_side is \'hypotenuse\'. Returns: float: The length of the missing side. Raises: ValueError: For negative inputs, insufficient parameters, or impossible triangle configurations. if missing_side not in [\'side_a\', \'side_b\', \'hypotenuse\']: raise ValueError(\\"Invalid missing_side value. It must be \'side_a\', \'side_b\', or \'hypotenuse\'.\\") if missing_side == \'side_a\': if side_b is None or hypotenuse is None: raise ValueError(\\"Provide both side_b and hypotenuse values.\\") if side_b <= 0 or hypotenuse <= 0 or side_b >= hypotenuse: raise ValueError(\\"Invalid inputs. Enter positive values and ensure side_b < hypotenuse.\\") return math.sqrt(hypotenuse**2 - side_b**2) elif missing_side == \'side_b\': if side_a is None or hypotenuse is None: raise ValueError(\\"Provide both side_a and hypotenuse values.\\") if side_a <= 0 or hypotenuse <= 0 or side_a >= hypotenuse: raise ValueError(\\"Invalid inputs. Enter positive values and ensure side_a < hypotenuse.\\") return math.sqrt(hypotenuse**2 - side_a**2) elif missing_side == \'hypotenuse\': if side_a is None or side_b is None: raise ValueError(\\"Provide both side_a and side_b values.\\") if side_a <= 0 or side_b <= 0: raise ValueError(\\"Invalid inputs. Enter positive values.\\") return math.sqrt(side_a**2 + side_b**2)"},{"question":"# Coding Challenge: Unique Paths in a Grid Objective: Create a function that computes the number of unique paths from the top-left to the bottom-right corner of a `m` x `n` grid. Function Signature: ```python def unique_paths(grid_width: int, grid_height: int) -> int: pass ``` Input: * `grid_width`: An integer `1 <= grid_width <= 100` representing the width of the grid. * `grid_height`: An integer `1 <= grid_height <= 100` representing the height of the grid. Output: * An integer representing the number of unique paths from the top-left to the bottom-right corner of the grid. Example: ```python assert unique_paths(3, 2) == 3 # Paths: right->right->down, right->down->right, down->right->right assert unique_paths(7, 3) == 28 ``` # Task Description: 1. **Grid Navigation:** Implement a function that uses dynamic programming to count the number of unique ways to navigate from the top-left to the bottom-right of a `grid_width` x `grid_height` grid. 2. **Movement Constraints:** Movement is only allowed to the right or down. 3. **Optimization:** Ensure the implementation efficiently handles the largest grid size of 100 x 100.","solution":"def unique_paths(grid_width: int, grid_height: int) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a m x n grid. Movement is only allowed to the right or down. if grid_width <= 0 or grid_height <= 0: return 0 dp = [[0] * grid_width for _ in range(grid_height)] for i in range(grid_height): dp[i][0] = 1 for j in range(grid_width): dp[0][j] = 1 for i in range(1, grid_height): for j in range(1, grid_width): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[grid_height-1][grid_width-1]"},{"question":"# Question: Implementing Depth-First Search for a Graph You need to implement the Depth-First Search (DFS) algorithm to traverse a graph. The function should explore all vertices of a graph starting from a specified source vertex and return the order of visited vertices. # Scenario In a network analysis tool, you need to explore and log the nodes in a network starting from a particular node using Depth-First Search. This will help in understanding the structure and connectivity of the network. # Function Signature ```python def depth_first_search(graph: dict, start_vertex: int) -> list: pass ``` # Input - `graph` (dict): A dictionary representation of an undirected graph where the keys are vertex identifiers and the values are lists of adjacent vertices. - `start_vertex` (int): The starting vertex for the DFS traversal. # Output - Returns a list of vertices in the order they were visited during the DFS traversal. # Constraints - The graph can contain up to 1000 vertices. - The starting vertex is guaranteed to be a vertex in the graph. - The graph does not contain self-loops or parallel edges. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1] } assert depth_first_search(graph, 0) == [0, 1, 3, 4, 2] assert depth_first_search(graph, 1) == [1, 0, 2, 3, 4] ``` # Requirements - Implement the Depth-First Search algorithm using an iterative approach (preferably with a stack). - Ensure the function can handle the traversal correctly for disconnected graphs. - Optimize the function to handle larger graphs within the constraints. - Return the traversal order as a list, ensuring all vertices reachable from the start vertex are included. Make sure your solution is efficient and handles edge cases such as isolated vertices or single-node graphs.","solution":"def depth_first_search(graph, start_vertex): Perform a Depth-First Search (DFS) on the graph starting from the given vertex. Parameters: graph (dict): A dictionary representation of an undirected graph where the keys are vertex identifiers and the values are lists of adjacent vertices. start_vertex (int): The starting vertex for the DFS traversal. Returns: list: A list of vertices in the order they were visited during the DFS traversal. visited = set() stack = [start_vertex] dfs_order = [] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) dfs_order.append(vertex) # Add adjacent vertices to the stack in reverse order for neighbor in reversed(graph[vertex]): stack.append(neighbor) return dfs_order"},{"question":"# Scenario You are part of a development team that is working on a mobile app for a fitness tracking device. The device records steps taken throughout the day and stores them in an array where each element represents steps taken in a 5-minute interval. The app calculates various statistics from this data, including the longest streak of consecutive intervals with increasing steps. # Task Implement a Python function `longest_increasing_streak(steps: List[int]) -> int` that finds and returns the length of the longest consecutive subsequence of increasing steps taken. Input * A list `steps` of integers where each integer represents steps taken in a 5-minute interval. Output * Return an integer representing the length of the longest streak of consecutive intervals with increasing steps. Constraints * The length of `steps` can be from 1 to 10,000. * Each element in `steps` is an integer between 0 and 1000. Example Inputs and their corresponding outputs: ```python longest_increasing_streak([10, 12, 15, 9, 11, 13, 14, 6, 8, 9]) # Returns: 4 (subsequence: [9, 11, 13, 14]) longest_increasing_streak([5, 6, 3, 4, 2, 1, 0]) # Returns: 2 (subsequence: [5, 6] or [3, 4]) longest_increasing_streak([1, 2, 3, 4, 5]) # Returns: 5 (subsequence: [1, 2, 3, 4, 5]) longest_increasing_streak([7, 7, 7, 7]) # Returns: 1 (subsequence: [7]) ``` **Note**: Make sure to handle edge cases, such as lists with no increasing subsequences or with only one element.","solution":"def longest_increasing_streak(steps): Finds the length of the longest consecutive subsequence of increasing steps taken. Args: steps (List[int]): A list of integers where each integer represents steps taken in a 5-minute interval. Returns: int: The length of the longest streak of consecutive intervals with increasing steps. if not steps: return 0 max_length = 1 current_length = 1 for i in range(1, len(steps)): if steps[i] > steps[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Question: Develop a function that processes a list of dictionaries representing employees, calculates their yearly bonuses based on their department and years of service, and generates a summary report. The function should follow these steps: 1. Iterate through the list of employee dictionaries. 2. For each employee, determine their department and years of service. 3. Calculate the bonus based on the following criteria: - For \\"Engineering\\": 1000 for each year of service. - For \\"Sales\\": 1200 for each year of service plus an additional 500 if the years of service exceed 5 years. - For \\"HR\\": 800 for each year of service. - For any other department: 500 for each year of service. 4. Construct a summary report in the form of a list of strings, where each string details the employee\'s name, department, calculated bonus, and years of service. 5. Return the summary report. Specifications: * **Function Name**: `generate_bonus_report` * **Inputs**: - `employees`: A list of dictionaries, where each dictionary contains the keys: \'name\', \'department\', and \'years_of_service\'. * **Outputs**: - A list of strings, where each string summarizes an employee\'s bonus information. * **Constraints**: - Assume the input list is non-empty and each dictionary always contains all required keys. - The \'years_of_service\' value is always a non-negative integer. Example: ```python employees = [ {\\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"years_of_service\\": 3}, {\\"name\\": \\"Jane Smith\\", \\"department\\": \\"Sales\\", \\"years_of_service\\": 6}, {\\"name\\": \\"Emily Davis\\", \\"department\\": \\"HR\\", \\"years_of_service\\": 5}, {\\"name\\": \\"Mark Brown\\", \\"department\\": \\"Marketing\\", \\"years_of_service\\": 2} ] print(generate_bonus_report(employees)) # Expected output: # [ # \\"John Doe from Engineering receives a bonus of 3000 for 3 years of service.\\", # \\"Jane Smith from Sales receives a bonus of 7700 for 6 years of service.\\", # \\"Emily Davis from HR receives a bonus of 4000 for 5 years of service.\\", # \\"Mark Brown from Marketing receives a bonus of 1000 for 2 years of service.\\" # ] ``` **Note**: The report strings must follow the format: \\"[Name] from [Department] receives a bonus of [BonusAmount] for [Years] years of service.\\" Ensure the function handles different departments and varies bonus calculation accordingly.","solution":"def generate_bonus_report(employees): Processes a list of employee dictionaries to calculate yearly bonuses and generate a summary report. Parameters: employees (list): A list of dictionaries, each containing \'name\', \'department\', and \'years_of_service\'. Returns: list: A list of strings summarizing the bonus information for each employee. report = [] for employee in employees: name = employee[\'name\'] department = employee[\'department\'] years = employee[\'years_of_service\'] if department == \'Engineering\': bonus = 1000 * years elif department == \'Sales\': bonus = 1200 * years if years > 5: bonus += 500 elif department == \'HR\': bonus = 800 * years else: bonus = 500 * years report.append(f\\"{name} from {department} receives a bonus of {bonus} for {years} years of service.\\") return report"},{"question":"# Prefix Tree (Trie) Implementation Objective You are given the partial implementation of a Prefix Tree (Trie) that supports the `insert` and `search` operations. Your task is to complete the implementation by providing code for the `delete` and `starts_with` operations. Problem Statement A `Trie` (also known as a Prefix Tree) is a tree-like data structure used to efficiently store and search strings. You need to implement two additional methods: 1. **`delete(self, word: str)`** * **Description**: This method deletes a given word from the Trie. If the word does not exist in the Trie, it should raise an error. * **Input**: - `word`: a string representing the word to be deleted. * **Output**: None 2. **`starts_with(self, prefix: str)`** * **Description**: This method checks if there is any word in the Trie that starts with the given prefix. * **Input**: - `prefix`: a string representing the prefix to be checked. * **Output**: A boolean indicating whether there is any word in the Trie that starts with the given prefix. Constraints: 1. The Trie only contains lowercase English letters. 2. The input word and prefix consist of lowercase English letters only. Performance Requirements: The `delete` and `starts_with` operations should take (O(m)) time complexity, where (m) is the length of the word or prefix. Below is the scaffold of the `Trie` class. You need to complete the methods as described above. ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def delete(self, word: str) -> None: # Your implementation here pass def starts_with(self, prefix: str) -> bool: # Your implementation here pass ``` # Example Usage ```python # Create a Trie and insert words trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"banana\\") print(trie.search(\\"apple\\")) # Should print True print(trie.search(\\"app\\")) # Should print True print(trie.search(\\"ban\\")) # Should print False trie.delete(\\"app\\") print(trie.search(\\"app\\")) # Should print False print(trie.search(\\"apple\\")) # Should print True print(trie.starts_with(\\"app\\")) # Should print True print(trie.starts_with(\\"ban\\")) # Should print True print(trie.starts_with(\\"bat\\")) # Should print False ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def delete(self, word: str) -> None: def delete_recursive(node, word, index): if index == len(word): if not node.is_end_of_word: raise ValueError(\\"Word not found in Trie\\") node.is_end_of_word = False return len(node.children) == 0 char = word[index] if char not in node.children: raise ValueError(\\"Word not found in Trie\\") should_delete_child = delete_recursive(node.children[char], word, index + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False delete_recursive(self.root, word, 0) def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"**Balanced Subarray Problem** Your task is to develop a function that finds the longest balanced subarray in a given array of integers. A subarray is balanced if the sum of its elements is zero. # Function Signature ```python def longest_balanced_subarray(arr: List[int]) -> int: pass ``` # Input - `arr`: A list of integers, where the length of the list is between 1 and 10^5, and each element is between -10^4 and 10^4. # Output - The integer length of the longest balanced subarray. - Return `0` if no such subarray exists. # Constraints - The array can contain both positive and negative integers. - A subarray is defined as contiguous elements from the original array. # Example ```python longest_balanced_subarray([1, -1, 3, 2, -2, -3, 6]) # Output: 6, since the subarray [1, -1, 3, 2, -2, -3] has a sum of zero. longest_balanced_subarray([1, 2, 3, 4, 5]) # Output: 0, since no subarray has a sum of zero. ``` # Performance Requirements - The solution should be efficient enough to handle the upper limit constraint efficiently. - Use linear time complexity and linear space complexity techniques, such as prefix sums and hash mapping. # Scenario/Context You are working on a system that processes sequences of numbers and you need to identify the longest interval where the net effect of the sequence balances out to zero. This problem requires understanding and implementing efficient techniques to identify such balanced segments in large datasets.","solution":"from typing import List def longest_balanced_subarray(arr: List[int]) -> int: prefix_sum = 0 prefix_sum_indices = {0: -1} max_length = 0 for index, num in enumerate(arr): prefix_sum += num if prefix_sum in prefix_sum_indices: max_length = max(max_length, index - prefix_sum_indices[prefix_sum]) else: prefix_sum_indices[prefix_sum] = index return max_length"},{"question":"# Coding Question: Palindromic Passwords You are given a text file `passwords.txt` that contains a list of common passwords. A password is considered \\"palindromic\\" if it reads the same backward as forward. Write a Python function `count_palindromic_passwords(file_path)` that reads the file, processes the passwords, and returns the number of palindromic passwords. Input: - `file_path` (string): The path to the `passwords.txt` file. Output: - Returns an integer representing the number of palindromic passwords in the file. Constraints: - Each password in the file is on a new line. Example: If the `passwords.txt` contains: ``` 12321 password madam racecar hello ``` the function should return 3 (since \\"12321\\", \\"madam\\", and \\"racecar\\" are palindromic). Notes: * A password consists only of alphanumeric characters. * Handle potential edge cases such as empty files or files with unexpected formats gracefully. # Evaluation Criteria 1. **Correctness**: The function should return the correct number of palindromic passwords. 2. **Efficiency**: The solution should handle large input files efficiently. 3. **Robustness**: The function should manage various edge cases and input inconsistencies gracefully. 4. **Clarity**: The code should be readable and well-commented. **Sample Implementation Skeleton**: ```python def count_palindromic_passwords(file_path): # Define a function to check if a password is palindromic def is_palindrome(password): return password == password[::-1] # Read file and process passwords try: with open(file_path, \'r\') as file: passwords = file.read().splitlines() # Count palindromic passwords palindromic_passwords_count = sum(1 for password in passwords if is_palindrome(password)) return palindromic_passwords_count except Exception as e: print(f\\"An error occurred: {e}\\") return 0 # Example usage: # print(count_palindromic_passwords(\'path_to_passwords.txt\')) ```","solution":"def count_palindromic_passwords(file_path): def is_palindrome(password): Checks if the given password is a palindrome. return password == password[::-1] try: with open(file_path, \'r\') as file: passwords = file.read().splitlines() palindromic_passwords_count = sum(1 for password in passwords if is_palindrome(password)) return palindromic_passwords_count except Exception as e: print(f\\"An error occurred: {e}\\") return 0 # Example usage (uncomment to run): # print(count_palindromic_passwords(\'path_to_passwords.txt\'))"},{"question":"# String Pattern Matching with Wildcards Craft a function that checks if a given text matches a pattern where the pattern may include wildcards. The pattern will consist of lowercase alphabets and two special characters: `\'*\'` which can match zero or more characters of any kind, and `\'?\'` which matches exactly one character. Function Signature: ```python def is_match(text: str, pattern: str) -> bool: ``` Input: - `text` (str): The text to be checked, consisting of lowercase letters. - `pattern` (str): The pattern containing lowercase letters, `*`, and `?`. Output: - Returns a boolean indicating whether the text matches the pattern. Constraints: - Length of `text` is between 1 and 500. - Length of `pattern` is between 1 and 500. Performance Requirements: - The function should efficiently handle patterns and texts up to the maximum length constraint. Example: ```python print(is_match(\\"bab\\", \\"b*b\\")) # Expected output: True print(is_match(\\"bab\\", \\"ba?\\")) # Expected output: True print(is_match(\\"bab\\", \\"b?a*\\")) # Expected output: True print(is_match(\\"bab\\", \\"a*\\")) # Expected output: False ``` In these examples: - The pattern `\\"b*b\\"` matches the text `\\"bab\\"` because the `*` can match the middle character `a`. - The pattern `\\"ba?\\"` matches the text `\\"bab\\"` because the `?` matches the last character `b`. - The pattern `\\"b?a*\\"` matches the text `\\"bab\\"` because `?` matches the `a` and `*` can match the remaining characters. - The pattern `\\"a*\\"` does not match the text `\\"bab\\"` because it requires the text to start with `a`.","solution":"def is_match(text: str, pattern: str) -> bool: Checks if the given text matches the pattern where the pattern can contain \'*\' (matches zero or more characters) and \'?\' (matches exactly one character). # Initialize a 2D DP table with False values dp = [[False] * (len(text) + 1) for _ in range(len(pattern) + 1)] dp[0][0] = True # Empty pattern and empty text matches # Handle patterns with leading \'*\' characters, which can match empty text for i in range(1, len(pattern) + 1): if pattern[i - 1] == \'*\': dp[i][0] = dp[i - 1][0] # Fill the DP table for i in range(1, len(pattern) + 1): for j in range(1, len(text) + 1): if pattern[i - 1] == \'*\': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif pattern[i - 1] == \'?\' or pattern[i - 1] == text[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[-1][-1]"},{"question":"# Coding Question: Hexadecimal Color Inverter Scenario You have been assigned the task of developing a tool for web designers that can invert hexadecimal color codes. A hexadecimal color code is a six-digit code preceded by a `#`, where each pair of digits represents a color channel (red, green, and blue). Inverting a color means subtracting each color channel value from the maximum value (255 for each channel). Requirements - Implement a function `invert_hex_color` that takes a string representing a hexadecimal color code as input and returns the inverted color code as a string. - The input color code will always be valid with exactly 6 hexadecimal digits following a `#`, e.g., `#acb123`. - The output should also be a valid hexadecimal color code starting with `#`. Expected Format ```python def invert_hex_color(hex_code: str) -> str: # your implementation here pass ``` Constraints 1. The input will always be a valid hexadecimal color code in the format `#RRGGBB`. 2. The function should be case-insensitive, meaning it should handle both uppercase and lowercase letters in the hexadecimal input. 3. Follow O(1) space complexity in your solution. 4. Ensure that the output is a valid hexadecimal color code with six digits after the `#`. Examples ```python print(invert_hex_color(\'#000000\')) # \'#ffffff\' print(invert_hex_color(\'#ffffff\')) # \'#000000\' print(invert_hex_color(\'#123456\')) # \'#edcba9\' print(invert_hex_color(\'#abcdef\')) # \'#543210\' ``` Use these examples to verify your implementation.","solution":"def invert_hex_color(hex_code: str) -> str: hex_code = hex_code.lstrip(\'#\') inverted_code = \'\'.join(f\'{255 - int(hex_code[i:i+2], 16):02x}\' for i in range(0, 6, 2)) return f\'#{inverted_code}\'"},{"question":"# Question: Binary Search for Target Value You are given a sorted list of integers where each integer appears exactly twice, except for one integer which appears only once. Your task is to find that single integer using an efficient binary search approach. Objective Implement a binary search algorithm to find the unique integer in a given sorted list. Expected Input and Output * **Input**: A sorted list of integers. ```python [int, int, ..., int] ``` * **Output**: The single integer that appears only once. ```python int ``` Constraints * The input list will have at most 100,000 elements. * Each integer in the list will fit within the 32-bit signed integer range: [−2³¹, 2³¹ − 1]. * The list is sorted in ascending order. * All integers appear exactly twice except for one integer that appears only once. Performance Requirements * Time complexity: O(log n) * Space complexity: O(1) Scenario Imagine you are working as a software developer for a data monitoring company. Your task is to analyze and detect anomalies in logs. One of the requirements is to pinpoint a unique entry in a massive list of paired data efficiently. # Your Task: Write a Python function `find_unique` that takes a sorted list of integers and returns the single integer that only appears once. ```python def find_unique(collection): :param collection: sorted list of integers :return: single integer that appears only once # Implement your binary search logic here pass ``` **Note**: Do not use Python\'s built-in set or dictionary data structures. Focus on the binary search algorithm principles to solve this problem efficiently. **Example**: ```python >>> find_unique([1, 1, 2, 2, 3, 3, 4, 4, 5]) 5 >>> find_unique([0, 0, 1, 1, 2, 2, 3]) 3 ```","solution":"def find_unique(collection): Find the single integer in the sorted list that appears only once. :param collection: sorted list of integers :return: single integer that appears only once left, right = 0, len(collection) - 1 while left < right: mid = (left + right) // 2 # Ensure mid is even so pairs start at even indices if mid % 2 == 1: mid -= 1 if collection[mid] == collection[mid + 1]: left = mid + 2 else: right = mid return collection[left]"},{"question":"# Question: Implement a Cache System Using Least Recently Used (LRU) Policy Scenario: A web server needs to manage its cache efficiently to serve frequently accessed web pages quickly. Implementing a Least Recently Used (LRU) cache system ensures that the most recently accessed pages stay in the cache while less frequently accessed pages are removed when the cache reaches its maximum capacity. Requirements: Implement an `LRUCache` class which supports the following operations: 1. **put(key: int, value: int)**: Inserts or updates the value for the given key. If the cache reaches its capacity, it should invalidate the least recently used item before inserting the new one. 2. **get(key: int) -> int**: Returns the value for the given key if present, otherwise returns -1. 3. **delete(key: int)**: Removes the entry for the given key if it exists in the cache. Constraints: 1. The operations should be efficient. Aim for O(1) time complexity for inserts, gets, and deletions. 2. Assume the cache capacity is provided and is a positive integer. Input/Output Formats: * `put(key: int, value: int)` - no output * `get(key: int) -> int` - returns the value if found, otherwise returns -1 * `delete(key: int)` - no output Example: ```python cache = LRUCache(2) # Capacity of 2 entries cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Expected output: 1 cache.put(3, 3) # LRU key was 2, evicts key 2 print(cache.get(2)) # Expected output: -1 (not found) cache.put(4, 4) # LRU key was 1, evicts key 1 print(cache.get(1)) # Expected output: -1 (not found) print(cache.get(3)) # Expected output: 3 print(cache.get(4)) # Expected output: 4 cache.delete(3) print(cache.get(3)) # Expected output: -1 (not found) ```","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def put(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def delete(self, key: int): if key in self.cache: del self.cache[key]"},{"question":"# Problem Statement You are required to implement a function that simulates a basic calculator capable of evaluating a simple arithmetic expression. The expression will be a string containing non-negative integers and the operators `+`, `-`, `*`, and `/`. The division should be integer division (i.e., truncate towards zero). # Function Signature ```python def basic_calculator(expression: str) -> int: pass ``` # Input - **expression** (str): A string representing the arithmetic expression. # Output - **result** (int): The evaluated result of the arithmetic expression. # Constraints 1. The input string `expression` is non-empty and contains only digits (0-9), `+`, `-`, `*`, `/`, and spaces. 2. The length of `expression` does not exceed 1,000 characters. 3. The operators and operands are separated by single spaces. 4. The expression is always valid. 5. Division by zero will not occur. 6. The integer division truncates toward zero, which means if the result is negative, it will always round \'up\' towards zero. # Examples ```python >>> basic_calculator(\\"3 + 5 * 2\\") 13 >>> basic_calculator(\\"10 + 2 * 6\\") 22 >>> basic_calculator(\\"100 * 2 + 12\\") 212 >>> basic_calculator(\\"100 * ( 2 + 12 )\\") 1400 >>> basic_calculator(\\"100 * ( 2 + 12 ) / 14\\") 100 ``` # Implementation Notes To implement the basic calculator: 1. Parse the expression string, considering the precedence of operators (`*` and `/` have higher precedence than `+` and `-`). 2. Use a stack to handle operator precedence and compute the result in the correct order. 3. Carefully handle the integer division to ensure it truncates towards zero for both positive and negative results. 4. The function should correctly handle nested expressions even though the constraints specify valid input. Your implementation should be robust, efficient, and correctly handle various edge cases and the operation order, producing accurate results.","solution":"def basic_calculator(expression: str) -> int: Evaluates a simple arithmetic expression. def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # python behaves like truncating towards zero for negative # Removing all whitespaces from the expression to handle the simpler string expression = expression.replace(\\" \\", \\"\\") stack = [] current_number = 0 current_operator = \'+\' i = 0 while i < len(expression): char = expression[i] if char.isdigit(): current_number = current_number * 10 + int(char) # if char is an operator or it\'s the last character in the expression if char in \\"+-*/\\" or i == len(expression) - 1: if current_operator == \'+\': stack.append(current_number) elif current_operator == \'-\': stack.append(-current_number) elif current_operator in \\"*/\\": last = stack.pop() stack.append(operate(current_operator, current_number, last)) current_operator = char current_number = 0 i += 1 return sum(stack)"},{"question":"# Question: Balancing Workloads Using Genetic Algorithms **Context**: A company has decided to distribute tasks among its employees in such a way that the workloads are balanced. Each task has a different complexity level, and each employee has a limit to the total complexity they can handle. You need to optimize the distribution of tasks using a Genetic Algorithm to achieve the most balanced workloads across all employees. **Task**: 1. Write a class `Task` that represents an individual task. It should have properties like `name`, `complexity`, and a `__str__(self)` method to return a string representation of the task. 2. Write the method `genetic_algorithm_optimize` that uses a genetic algorithm to balance the tasks among employees to ensure the most balanced distribution possible. **Implementation**: 1. Define the `Task` class: - `__init__(self, name: str, complexity: float)` - `__str__(self)` method to provide a string representation of the task. 2. Define the function `genetic_algorithm_optimize`: - `genetic_algorithm_optimize(tasks: List[Task], num_employees: int, population_size: int, mutation_rate: float, generations: int) -> List[List[Task]]` - Perform genetic algorithm optimization to distribute tasks among employees. **Constraints**: - Each employee\'s total complexity should not exceed the pre-defined maximum they can handle. - Ensure that all tasks are assigned to employees. - The genetic algorithm should incorporate crossover and mutation operations. - Use a fitness function that evaluates how balanced the workload distribution is. **Expected Input/Output**: - **Input**: - A list of `Task` objects. - `num_employees`: An integer representing the number of employees. - `population_size`: An integer for the size of the population in the genetic algorithm. - `mutation_rate`: A float representing the mutation rate in the genetic algorithm. - `generations`: An integer for the number of generations the genetic algorithm runs. - **Output**: - A list of lists, where each sublist contains tasks assigned to one employee, optimized for balanced workloads. ```python from typing import List import random class Task: def __init__(self, name: str, complexity: float): self.name = name self.complexity = complexity def __str__(self): return f\\"Task({self.name}, Complexity: {self.complexity})\\" def genetic_algorithm_optimize(tasks: List[Task], num_employees: int, population_size: int, mutation_rate: float, generations: int) -> List[List[Task]]: # Genetic algorithm implementation goes here pass # Example Functions def fitness_function(task_distribution: List[List[Task]]) -> float: complexities = [sum(task.complexity for task in employee_tasks) for employee_tasks in task_distribution] return max(complexities) - min(complexities) def crossover(parent1: List[List[Task]], parent2: List[List[Task]]) -> List[List[Task]]: # Crossover operation implementation goes here pass def mutate(task_distribution: List[List[Task]], mutation_rate: float): # Mutation operation implementation goes here pass # Main function to test code if __name__ == \\"__main__\\": tasks = [ Task(\\"Task 1\\", 10), Task(\\"Task 2\\", 20), Task(\\"Task 3\\", 30), Task(\\"Task 4\\", 40), Task(\\"Task 5\\", 50) ] optimized_task_distribution = genetic_algorithm_optimize(tasks, num_employees=3, population_size=50, mutation_rate=0.01, generations=100) for idx, employee_tasks in enumerate(optimized_task_distribution): print(f\\"Employee {idx+1} Tasks: {[str(task) for task in employee_tasks]}\\") ``` This question assesses the understanding of genetic algorithms and their application to optimization problems, while testing object-oriented programming skills and the ability to handle complex algorithmic tasks.","solution":"from typing import List, Tuple import random class Task: def __init__(self, name: str, complexity: float): self.name = name self.complexity = complexity def __str__(self): return f\\"Task({self.name}, Complexity: {self.complexity})\\" def genetic_algorithm_optimize(tasks: List[Task], num_employees: int, population_size: int, mutation_rate: float, generations: int) -> List[List[Task]]: def initial_population() -> List[List[List[Task]]]: population = [] for _ in range(population_size): distribution = [[] for _ in range(num_employees)] for task in tasks: distribution[random.choice(range(num_employees))].append(task) population.append(distribution) return population def fitness(task_distribution: List[List[Task]]) -> float: complexities = [sum(task.complexity for task in employee_tasks) for employee_tasks in task_distribution] return max(complexities) - min(complexities) def select(population: List[Tuple[List[List[Task]], float]]) -> List[List[Task]]: population.sort(key=lambda x: x[1]) return [individual for individual, score in population[:population_size//2]] def crossover(parent1: List[List[Task]], parent2: List[List[Task]]) -> List[List[Task]]: child = [[] for _ in range(num_employees)] cut = random.randint(0, len(tasks) - 1) task_list1 = [task for employee_tasks in parent1 for task in employee_tasks] task_list2 = [task for employee_tasks in parent2 for task in employee_tasks] cut1 = task_list1[:cut] cut2 = [task for task in task_list2 if task not in cut1] merged_list = cut1 + cut2 idx = 0 for employee_tasks in child: while len(employee_tasks) < len(merged_list) // num_employees and idx < len(merged_list): employee_tasks.append(merged_list[idx]) idx += 1 return child def mutate(task_distribution: List[List[Task]]): for i in range(num_employees): if random.random() < mutation_rate and len(task_distribution[i]) > 0: task = task_distribution[i].pop(random.randrange(len(task_distribution[i]))) task_distribution[random.choice(range(num_employees))].append(task) population = initial_population() for generation in range(generations): population = [(individual, fitness(individual)) for individual in population] parents = select(population) next_generation = [] for _ in range(population_size): parent1, parent2 = random.choices(parents, k=2) child = crossover(parent1, parent2) mutate(child) next_generation.append(child) population = next_generation best_distribution = min(population, key=fitness) return best_distribution"},{"question":"# Coding Assessment Question Scenario You have been hired to develop a new sorting module for a data processing application. This module should not only sort the elements but also return the original indices of each element as they are placed in the sorted order. This is crucial for the application\'s integrity to maintain a reference to the original data positions. Task Write a function named `indexed_sort` which receives a list of integers `data`. Your function should return a list of tuples, where each tuple contains an element from the original list and its corresponding original index. The returned list should be sorted based on the elements. # Function Signature ```python def indexed_sort(data: list[int]) -> list[(int, int)]: ``` # Input * `data` - A list of integers (1 <= len(data) <= 10^4, -10^4 <= data[i] <= 10^4). # Output * A sorted list of tuples. Each tuple should contain an integer from the original list and its original index. # Constraints * The original structure and indices must be preserved in the returned list. * Handle edge cases such as an empty list or lists with all identical elements. # Example ```python >>> indexed_sort([4, 2, 9, 5, 2]) [(2, 1), (2, 4), (4, 0), (5, 3), (9, 2)] >>> indexed_sort([1, -1, 0, 5, 3]) [(-1, 1), (0, 2), (1, 0), (3, 4), (5, 3)] >>> indexed_sort([]) [] ``` Performance Requirements The solution should be efficient and able to handle the maximum constraints comfortably. Edge cases, including large lists and duplicate elements, must be managed effectively.","solution":"def indexed_sort(data): Sorts the elements of data while keeping track of their original indices. Args: data (list of int): A list of integers. Returns: list of tuple: A list of tuples, where each tuple contains an element from the original list and its original index, sorted based on the elements. return sorted((x, i) for i, x in enumerate(data))"},{"question":"Task Question Creation for Coding Assessment Objective Analyze the sample question provided and create an additional question that aligns with the existing set in terms of style, complexity, and scope. # Sample Question # Function Signature ```python def find_closest_pair(points: List[Tuple[int, int]]) -> float: pass ``` # Input - `points`: A list of tuples of integers where each tuple represents the x and y coordinates of a point on a 2D plane. The number of points `n` should be such that `2 <= n <= 10^5`. # Output - Return a float representing the minimum Euclidean distance between the closest pair of points. # Constraints - The coordinates of the points will always be such that `-10^6 <= x, y <= 10^6`. # Example ```python points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)] print(find_closest_pair(points)) # Output: approx 1.414213562 (Distance between (2, 3) and (3, 4)) points = [(1, 2), (3, 4), (5, 7), (8, 9)] print(find_closest_pair(points)) # Output: approx 2.236067977 (Distance between (1, 2) and (3, 4)) ``` # Explanation 1. Points are initially sorted based on X and Y coordinates separately. 2. The function should implement the divide and conquer approach, splitting the set of points into smaller subproblems. 3. Recursively find the minimum distance in the left and right partitions. 4. Construct a strip of points within a close range of middle partition and calculate closest pairs in this strip. 5. Return the minimal distance found during recursion and strip analysis. # Performance Requirements - The solution should run efficiently within (O(n log n)) to handle large input sizes up to 100,000 points. Ensure you utilize memory efficiently. --- # New Question # Function Signature ```python def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Input - `intervals`: A list of tuples of integers where each tuple represents the start and end of an interval. The number of intervals `n` should be such that `1 <= n <= 10^5`. # Output - Return a list of tuples representing the merged intervals. # Constraints - The intervals will always have `0 <= start <= end <= 10^6`. # Example ```python intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] print(merge_intervals(intervals)) # Output: [(1, 4), (5, 8)] intervals = [(1, 5), (2, 6), (8, 10)] print(merge_intervals(intervals)) # Output: [(1, 6), (8, 10)] ``` # Explanation 1. Sort the intervals by their start time. 2. Initialize a stack or result list to keep track of merged intervals. 3. Iterate through the list of intervals: - If the current interval overlaps with the last interval in the result stack, merge them. - Else, add the current interval to the result stack. 4. Continue this until all intervals are processed. 5. Output the list of merged intervals. # Performance Requirements - The solution should run efficiently within (O(n log n)) due to the sorting step to handle large input sizes up to 100,000 intervals. Ensure you utilize memory efficiently.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping intervals in a list. Args: intervals: List of tuples with each tuple representing interval start and end. Returns: List of merged intervals. if not intervals: return [] # Sort the intervals by their start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If there are no intervals or the current interval does not overlap with the previous, append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, so we merge the current and previous intervals. merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged"},{"question":"# Scenario You are tasked with developing a Python function that performs clustering on a dataset of two-dimensional points using the K-Means algorithm. The points are represented as coordinates on a 2D plane, and you need to group them into a specified number of clusters. # Task Write a Python function `kmeans_clustering(points, num_clusters)` that: 1. Performs K-Means clustering on the given list of points. 2. Returns a list of cluster labels corresponding to each point. # Input Format * `points` (list of list of floats): A list of points where each point is represented as a list of two floats (the x and y coordinates). * `num_clusters` (int): The number of clusters to form. # Output Format * A list of integers where each integer represents the cluster label assigned to the corresponding point in the `points` list. # Constraints 1. Assume `points` contains at least as many points as the number of clusters (`num_clusters`). 2. The coordinates in each point are finite and can be any real number. 3. The value of `num_clusters` is a positive integer and does not exceed the number of points. # Example ```python points = [[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.5], [9.0, 11.0]] num_clusters = 2 assert kmeans_clustering(points, num_clusters) == [0, 0, 1, 1, 0, 1] or [1, 1, 0, 0, 1, 0] ``` # Requirements 1. Use the `KMeans` class from `sklearn.cluster`. 2. Make sure the implementation is efficient and follows good coding practices.","solution":"from sklearn.cluster import KMeans def kmeans_clustering(points, num_clusters): Perform K-Means clustering on a dataset of 2D points. Args: points (list of list of floats): A list of points where each point is represented as a list of two floats (the x and y coordinates). num_clusters (int): The number of clusters to form. Returns: list of int: A list of cluster labels corresponding to each point. kmeans = KMeans(n_clusters=num_clusters, random_state=42) kmeans.fit(points) return kmeans.labels_.tolist()"},{"question":"# String Compression Develop a function to optimize the storage of a string by compressing it using the counts of repeated characters. Specifically, the function should use a Run Length Encoding (RLE) approach to compress strings where repeated characters are replaced by the character followed by the number of times it appears consecutively. # Problem Statement Write a function `compress_string(s: str) -> str` that takes a string `s` and compresses it using RLE. If the compressed string is not shorter than the original string, the function should return the original string. # Requirements Your implementation must correctly handle strings with both lowercase and uppercase letters, and numerical characters. Ensure efficiency in both space and time complexity. # Input * A single string `s` which: - Contains only alphanumeric characters. - Has a length between 1 and 10,000 characters inclusive. # Output * The compressed version of the string if it is shorter than the original string. * If the compressed string is not shorter, return the original string. # Examples Example 1: ```python s = \\"aabcccccaaa\\" print(compress_string(s)) # Output: \\"a2b1c5a3\\" ``` Example 2: ```python s = \\"abc\\" print(compress_string(s)) # Output: \\"abc\\" (compressed form \\"a1b1c1\\" is not shorter) ``` Example 3: ```python s = \\"AaaBBbCccDd\\" print(compress_string(s)) # Output: \\"AaaBBbCccDd\\" (since \\"A1a2B2b1C1c2D1d1\\" is not shorter) ``` # Explanation * In Example 1, the sequence \\"aabcccccaaa\\" is compressed to \\"a2b1c5a3\\", which is shorter than the original. * In Example 2, \\"abc\\" does not benefit from compression since \\"a1b1c1\\" has the same length as the original string, so the original string is returned. * In Example 3, \\"AaaBBbCccDd\\" is returned unmodified as compression results in a longer string. # Constraints * Ensure the function handles edge cases, such as a very high number of repetitions of a character or the absence of any repetition at all. * The solution should operate in O(n) time complexity where n is the length of the input string.","solution":"def compress_string(s: str) -> str: Compresses the string using Run Length Encoding, where repeated characters are replaced by the character followed by the number of repetitions. If the compressed string is not shorter than the original string, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Don\'t forget to add the last accumulated character and its count compressed.append(s[-1]) compressed.append(str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem: Longest Common Subsequence Length Context One of the common problems in computer science involves finding similarities between sequences. The Longest Common Subsequence (LCS) problem is of particular interest in various fields such as bioinformatics, text comparison, and version control systems. The LCS of two sequences is the longest subsequence present in both of them. Question Write a function `longest_common_subsequence_length(str1: str, str2: str) -> int` that computes the length of the longest common subsequence between two given strings. Input - A string `str1` representing the first sequence. - A string `str2` representing the second sequence. Output - Return an integer value representing the length of the longest common subsequence between `str1` and `str2`. Algorithm Requirements 1. Use dynamic programming to solve the LCS problem with an appropriate 2-dimensional table. 2. Consider edge cases such as empty strings. Constraints - The lengths of `str1` and `str2` are at most 1000. Example ```python def longest_common_subsequence_length(str1: str, str2: str) -> int: m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] # Example usage: print(longest_common_subsequence_length(\\"AGGTAB\\", \\"GXTXAYB\\")) # Expected output: 4, corresponding to \\"GTAB\\" print(longest_common_subsequence_length(\\"ABC\\", \\"AC\\")) # Expected output: 2, corresponding to \\"AC\\" print(longest_common_subsequence_length(\\"\\", \\"AC\\")) # Expected output: 0 ``` Performance Requirements - Ensure that the function runs efficiently within the constraints provided. - Optimize the memory usage where possible by using space optimization techniques.","solution":"def longest_common_subsequence_length(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) # dp array initialized to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array in bottom up manner for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"**Question 2]: Palindrome Substrings** In this exercise, you need to implement a function that finds all the unique palindromic substrings in a given string. A palindromic string is one that reads the same forward and backward. # Function Signature ```python def palindrome_substrings(s: str) -> set: pass ``` # Input * `s` (str): A non-empty string consisting of lowercase and/or uppercase English letters. # Output * **Returns** (set): A set of unique palindromic substrings. # Constraints * The function should handle strings of length up to `10^3`. * Palindromic substrings should be case-sensitive (e.g., \'Aba\' is not the same as \'aba\'). # Examples ```python >>> palindrome_substrings(\\"racecar\\") {\'r\', \'a\', \'c\', \'e\', \'cec\', \'aceca\', \'racecar\'} >>> palindrome_substrings(\\"abccba\\") {\'a\', \'b\', \'c\', \'cc\', \'bccb\', \'abccba\'} >>> palindrome_substrings(\\"abcd\\") {\'a\', \'b\', \'c\', \'d\'} ``` # Guidelines 1. **Expand Around Center**: One approach to find all palindromic substrings is to start from each index and expand outwards while checking for palindromes. 2. **Efficiency**: Optimize the solution to avoid redundant checks and ensure it runs efficiently for the upper constraint. **Tasks**: 1. Implement the `palindrome_substrings` function based on the provided specifications. 2. Ensure your implementation handles the input correctly and returns the set of all unique palindromic substrings.","solution":"def palindrome_substrings(s: str) -> set: This function returns a set of all unique palindromic substrings in the given string `s`. def expand_around_center(l, r): Helper function to expand around the center and collect palindromic substrings. while l >= 0 and r < len(s) and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 palindromes = set() for i in range(len(s)): # Each character is a center for an odd length palindrome expand_around_center(i, i) # Each pair of characters is a center for an even length palindrome expand_around_center(i, i+1) return palindromes"},{"question":"Employee Task Scheduling An organization has a set of tasks that need to be scheduled to employees such that the maximum number of tasks are completed within a given deadline. Each task has a start time, an end time, and a duration. A task can only be assigned to one employee, and an employee can only work on one task at a time. You need to implement a function to find the maximum number of tasks that can be scheduled without overlapping. Your Task 1. **Efficient Scheduling**: Implement an algorithm to maximize the number of non-overlapping tasks that can be scheduled. 2. **Function Implementation**: Implement a function that sorts and selects the tasks to ensure the maximum utilization of employee time. Requirements - Implement the function `max_task_scheduling(tasks: List[Tuple[int, int]]) -> int` where each task is represented as a tuple of `(start_time, end_time)`. - No two tasks should overlap, and the function should ensure as many tasks as possible are scheduled. Input - A list `tasks` consisting of tuples, where each tuple contains two integers representing the start and end times of a task. Output - An integer representing the maximum number of non-overlapping tasks that can be scheduled. Constraints - The length of the tasks list will be ≤ 10^4. - The start and end times are non-negative integers and can be in any order. Example ```python >>> max_task_scheduling([(1, 3), (2, 5), (4, 6)]) 2 >>> max_task_scheduling([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)]) 4 ``` Explanation In the first example, the tasks `(1, 3)` and `(4, 6)` can be scheduled without overlapping, resulting in two tasks being completed. In the second example, selecting `(1, 2)`, `(3, 4)`, `(5, 7)`, and `(8, 9)` results in four tasks being completed.","solution":"from typing import List, Tuple def max_task_scheduling(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (List[Tuple[int, int]]): A list of tasks represented by their start and end times. Returns: int: The maximum number of non-overlapping tasks. # Sort the tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping tasks count = 0 # Track the end time of the last selected task last_end_time = 0 for start, end in tasks: # If the current task starts after or when the last chosen task ends if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"# Problem Context In computer science, graph theory is a crucial area that involves the study of graphs, which are mathematical structures used to model pairwise relations between objects. One common problem in graph theory is finding the shortest path between two nodes. This type of problem has practical applications in various fields, such as network routing, urban planning, and logistics. # Problem Statement Write a Python function `shortest_path_length` that takes an adjacency matrix representation of an unweighted graph and two nodes as input, and returns the length of the shortest path between the provided nodes using the Breadth-First Search (BFS) algorithm. If no path exists, return -1. # Function Signature ```python def shortest_path_length(graph: List[List[int]], start: int, end: int) -> int: Returns the length of the shortest path between start and end nodes in an unweighted graph. ``` # Input - `graph` (List[List[int]]): A 2D list representing the adjacency matrix of the graph (must be square and contain only 0s and 1s). - `start` (int): The starting node (must be a valid node in the graph). - `end` (int): The target node (must be a valid node in the graph). # Output - An integer: The length of the shortest path between `start` and `end`. If no such path exists, return -1. # Constraints 1. The adjacency matrix is a square matrix with non-negative integers (0 or 1) only. 2. `start` and `end` must be valid nodes within the bounds of the graph. 3. The function must handle graphs with up to 1000 nodes efficiently. # Example ```python assert shortest_path_length([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]], 0, 2) == 2 assert shortest_path_length([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]], 0, 3) == 2 assert shortest_path_length([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 0, 3) == 3 assert shortest_path_length([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0, 3) == -1 ``` # Notes Ensure that the function correctly uses the BFS algorithm to determine the shortest path and handles the edge cases, such as disconnected graphs or invalid inputs. Include necessary error handling for invalid graph representations or node indices.","solution":"from collections import deque from typing import List def shortest_path_length(graph: List[List[int]], start: int, end: int) -> int: Returns the length of the shortest path between start and end nodes in an unweighted graph. :param graph: List[List[int]] adjacency matrix representation of the graph :param start: int starting node :param end: int target node :return: int length of the shortest path or -1 if no path exists if start == end: return 0 n = len(graph) visited = [False] * n queue = deque([(start, 0)]) visited[start] = True while queue: node, dist = queue.popleft() for neighbor, is_connected in enumerate(graph[node]): if is_connected and not visited[neighbor]: if neighbor == end: return dist + 1 visited[neighbor] = True queue.append((neighbor, dist + 1)) return -1"},{"question":"# Problem Statement: You are provided with an unsorted list of integers where each integer appears exactly twice, except for one integer which appears exactly once. Your task is to find and return the single integer that appears only once. The solution should have a linear runtime complexity and use constant extra space. Input: * A list of integers `nums` of length (2n + 1), where (n) is a non-negative integer. Output: * The single integer that appears only once. # Constraints: * The list of integers will have a length between 1 and (10^5). * Each integer in the list is between (-10^9) and (10^9). * There is exactly one integer that appears only once, with all other integers appearing exactly twice. # Example: ```python nums = [4, 1, 2, 1, 2] expected_output = 4 ``` Another Example: ```python nums = [2, 2, 1] expected_output = 1 ``` Function Signature: ```python def single_number(nums: List[int]) -> int: ... ``` Implement the function `single_number(nums: List[int]) -> int` to return the expected output for the given input list.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single number that appears only once in the list, with all other integers appearing twice. Args: nums (List[int]): The list of integers Returns: int: The single integer that appears only once # Approach: Using XOR result = 0 for num in nums: result ^= num return result"},{"question":"# Question **Requirements**: 1. Implement `can_transform` function that accepts two strings `s` and `t`. 2. The function should return `True` if `s` can be transformed into `t` by any number of circular shifts, and `False` otherwise. 3. The implementation should be optimized in terms of performance. **Function Signature**: ```python def can_transform(s: str, t: str) -> bool: # Your implementation here pass ``` **Input/Output**: - Input: Two strings `s` and `t`, both of which consist of lowercase alphabetic characters. - Output: A boolean value indicating whether `s` can be circularly shifted to match `t`. **Constraints**: - The lengths of `s` and `t` will be between 1 and 10^5. - Both strings will have the same length. **Examples**: ```python assert can_transform(\\"abcde\\", \\"cdeab\\") == True assert can_transform(\\"abcde\\", \\"abced\\") == False assert can_transform(\\"aaaaa\\", \\"aaaaa\\") == True assert can_transform(\\"abc\\", \\"xyz\\") == False assert can_transform(\\"a\\", \\"a\\") == True ``` Hint: Consider checking if `t` exists as a substring within some specific construction related to `s`.","solution":"def can_transform(s: str, t: str) -> bool: Returns True if `s` can be transformed into `t` by any number of circular shifts, otherwise False. if len(s) != len(t): return False concatenated_s = s + s return t in concatenated_s"},{"question":"# Problem Statement You are building a task scheduler that manages a list of tasks to be executed. Each task depends on some other tasks, and all tasks are independent of each other. Represent this system using a directed acyclic graph (DAG) where each vertex is a task and each directed edge (u -> v) signifies that task `v` depends on task `u`. Your task is to add functionality to the `TaskScheduler` class focusing on: 1. Finding the correct execution order of tasks that respects their dependencies. 2. Detecting if there\'s a circular dependency among the tasks. # Task Requirements 1. Implement two new methods in the `TaskScheduler` class: * `get_execution_order(self) -> list[T]`: Returns a list of tasks in the order they should be executed. If no valid order exists (i.e., there\'s a circular dependency), return an empty list. * `has_circular_dependency(self) -> bool`: Returns `True` if there is any circular dependency among the tasks, otherwise returns `False`. # Input - Vertices can be any hashable type (strings, integers, etc.). - The graph is directed and should not contain self-loops. # Output - For `get_execution_order`, return a list of tasks in the correct order. If a circular dependency is detected, return an empty list. - For `has_circular_dependency`, return a boolean. # Constraints 1. The graph can have up to `10^5` vertices. 2. Each vertex (task) will have at most `10^3` edges (dependencies). # Example ```python scheduler = TaskScheduler() scheduler.add_dependency(\'Task1\', \'Task2\').add_dependency(\'Task2\', \'Task3\').add_dependency(\'Task3\', \'Task4\') # Example usage: print(scheduler.get_execution_order()) # Output: [\'Task1\', \'Task2\', \'Task3\', \'Task4\'] print(scheduler.has_circular_dependency()) # Output: False scheduler.add_dependency(\'Task4\', \'Task2\') print(scheduler.get_execution_order()) # Output: [] print(scheduler.has_circular_dependency()) # Output: True ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned.","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): self.graph = defaultdict(list) self.in_degree = defaultdict(int) def add_dependency(self, u, v): self.graph[u].append(v) self.in_degree[v] += 1 if u not in self.in_degree: self.in_degree[u] = 0 return self def get_execution_order(self): zero_in_degree_tasks = deque([task for task in self.in_degree if self.in_degree[task] == 0]) execution_order = [] while zero_in_degree_tasks: current = zero_in_degree_tasks.popleft() execution_order.append(current) for neighbor in self.graph[current]: self.in_degree[neighbor] -= 1 if self.in_degree[neighbor] == 0: zero_in_degree_tasks.append(neighbor) if len(execution_order) == len(self.in_degree): return execution_order else: return [] def has_circular_dependency(self): return len(self.get_execution_order()) == 0"},{"question":"# Coding Question: Implement an Efficient Merge Sort for Linked Lists Merge Sort is a popular sorting algorithm that relies on the divide-and-conquer paradigm. Linked lists can benefit from merge sort since it can be implemented in O(n log n) time complexity and uses O(log n) space. Your task is to implement an efficient version of Merge Sort specifically for singly linked lists. The implementation should include robust handling of edge cases and efficient memory usage. **Instructions**: 1. Implement the `merge_sort` function for a linked list. 2. Ensure proper handling of edge cases, including empty lists and lists with only one element. 3. Write appropriate test cases to validate your implementation. 4. Optimize for time and space complexity where possible. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort(head: ListNode) -> ListNode: # Your implementation goes here pass def test_merge_sort() -> None: # Test cases to validate the implementation pass # Example of running tests if __name__ == \\"__main__\\": test_merge_sort() ``` **Function Specification**: - **Input**: - `head (ListNode)`: The head of the linked list to be sorted. - **Output**: - `ListNode`: The head of the sorted linked list. **Constraints**: - The linked list can have up to 10^5 nodes. - The values of the linked list nodes can be any integer within the range of standard 32-bit integer limits. **Performance Requirements**: - Efficient sorting with O(n log n) time complexity. - Ensure the space complexity is optimized and no additional arrays or lists are used. - Handle edge cases such as an empty list or a list with one element efficiently. Develop your solution iteratively and test thoroughly. Ensure your implementation maintains the structural integrity of the linked list throughout the sorting process. Good luck!","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort(head: ListNode) -> ListNode: if head is None or head.next is None: return head # Function to split the linked list into two halves def split(head: ListNode) -> ListNode: slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None return slow # Function to merge two sorted linked lists def merge(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next middle = split(head) left = merge_sort(head) right = merge_sort(middle) return merge(left, right)"},{"question":"# Problem Statement You are assigned to implement a simple queue data structure using two stacks. Your goal is to ensure that all queue operations (enqueue, dequeue, and size) are functioning correctly and efficiently. # Task 1. Implement the `Queue` class using two stacks internally. 2. Ensure the `enqueue`, `dequeue`, and `size` methods work correctly. 3. Handle empty queue scenarios gracefully and provide exception handling where necessary. 4. Validate the functionality of your `Queue` class using provided sample inputs. # Requirements - Create the `Queue` class using two internal stacks. - Implement `enqueue` to add elements to the queue. - Implement `dequeue` to remove and return the oldest element in the queue, raising an exception if the queue is empty. - Implement `size` to return the number of elements in the queue. - Ensure all operations are efficient and handle edge cases robustly. # Example Cases Here are some cases demonstrating the expected behavior of your `Queue`: ```python queue = Queue() assert queue.size() == 0 try: queue.dequeue() except IndexError: print(\\"Exception caught: Dequeue from an empty queue\\") queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.size() == 3 assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.size() == 1 queue.enqueue(4) assert queue.dequeue() == 3 assert queue.dequeue() == 4 assert queue.size() == 0 try: queue.dequeue() except IndexError: print(\\"Exception caught: Dequeue from an empty queue\\") ``` You need to implement the `Queue` class to meet the above requirements. # Expected Function Signatures ```python class Queue(Generic[T]): def __init__(self) -> None: ... def enqueue(self, data: T) -> None: ... def dequeue(self) -> T: ... def size(self) -> int: ... ``` # Constraints - Handle integer elements in the queue. - Focus on code efficiency and handle potential edge cases robustly.","solution":"class Queue: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, data): self.stack1.append(data) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"Dequeue from an empty queue\\") return self.stack2.pop() def size(self): return len(self.stack1) + len(self.stack2)"},{"question":"# Longest Common Subsequence Coding Question Context You are working on developing a feature for a text comparison tool that helps in finding the longest common subsequence (LCS) between two sequences. LCS is defined as the longest subsequence present in both sequences, where a subsequence is obtained by deleting some (or none) characters from the sequence without changing the order of the remaining elements. Your Task Write a function that takes two strings and returns their longest common subsequence. Function Signature ```python def longest_common_subsequence(str1: str, str2: str) -> str: # your code here ``` Input - `str1` (str): The first string. - `str2` (str): The second string. Output - Returns a string representing the longest common subsequence of the two input strings. If there are multiple results, return any one of them. Constraints - Both input strings have lengths ranging from 1 to 1000 characters. - The input strings consist of lowercase English letters only. Example ```python str1 = \\"abcde\\" str2 = \\"ace\\" output = \\"ace\\" >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") \\"ace\\" str1 = \\"abc\\" str2 = \\"def\\" output = \\"\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") \\"\\" ``` Algorithm To solve this problem, you can use dynamic programming to build a 2D table that keeps track of the lengths of the longest common subsequence up to each pair of indices in the input strings. After populating the table, the longest common subsequence can be reconstructed by backtracking through the table. Edge Cases to Consider - If the two strings do not share any common characters, the result should be an empty string. - If one of the input strings is a subsequence of the other, the result should be that string itself. - Handling ties efficiently when there are multiple longest common subsequences. Hint: Be mindful of the time complexity and space constraints when developing your solution.","solution":"def longest_common_subsequence(str1: str, str2: str) -> str: Find the longest common subsequence (LCS) between two strings. # Get the lengths of the input strings m, n = len(str1), len(str2) # Create a 2D DP table to store lengths of LCS dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence from the DP table lcs = [] i, j = m, n while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return \'\'.join(reversed(lcs))"},{"question":"# Problem Statement You have been given a list of access logs, where each log entry records the user ID of a user who accessed a certain resource. The logs are subject to analysis to determine the number of unique users and to also find out the user who accessed the resource the most times. Your task is to implement a function that processes the logs and returns both the number of unique users and the user ID of the top user. If there is a tie for the top user (multiple users accessed the resource the same number of times), return the user ID that appears first in the logs. # Function Signature ```python def analyze_access_logs(logs: List[str]) -> Tuple[int, str]: `logs`: A list of strings where each string represents a user ID. Returns a tuple with two elements: - An integer representing the number of unique users. - A string representing the user ID of the user with the highest number of accesses. Constraints: * Each user ID in the list `logs` is a non-empty string. * The logs list is non-empty and can contain up to 10^6 user IDs. Example: >>> analyze_access_logs([\'user1\', \'user2\', \'user1\', \'user3\', \'user2\', \'user2\', \'user1\']) (3, \'user2\') >>> analyze_access_logs([\'alpha\', \'beta\', \'alpha\', \'gamma\', \'gamma\', \'alpha\']) (3, \'alpha\') pass ``` # Guidelines 1. **Identify Unique Users**: Determine how many unique users accessed the resource. 2. **Count Accesses**: Track and count how often each user accessed the resource. 3. **Determine Top User**: Identify the user ID that accessed the resource the most times. In the case of a tie, select the first user ID from the logs with the highest number of accesses. 4. **Handling Large Inputs**: The function should efficiently handle up to 10^6 log entries. # Input and Output Format ```text analyze_access_logs([\'user1\', \'user2\', \'user1\', \'user3\', \'user2\', \'user2\', \'user1\']) => (3, \'user2\') analyze_access_logs([\'alpha\', \'beta\', \'alpha\', \'gamma\', \'gamma\', \'alpha\']) => (3, \'alpha\') ``` # Constraints * Each user ID in the list `logs` is a non-empty string. * The logs list is non-empty and can contain up to 10^6 user IDs. Notes - The solution should be optimized in both space and time complexity to handle the upper limit of input size efficiently. - Consider edge cases such as the list containing only one user ID multiple times, handling strings with different formats for user IDs, etc.","solution":"from typing import List, Tuple from collections import defaultdict def analyze_access_logs(logs: List[str]) -> Tuple[int, str]: unique_users = set() access_counts = defaultdict(int) max_access = 0 most_frequent_user = None for user in logs: unique_users.add(user) access_counts[user] += 1 if access_counts[user] > max_access: max_access = access_counts[user] most_frequent_user = user elif access_counts[user] == max_access and most_frequent_user == None: most_frequent_user = user return len(unique_users), most_frequent_user"},{"question":"# Matrix Path Finder You are tasked with implementing a function to find the number of distinct paths from the top-left corner to the bottom-right corner of a matrix, given that you can only move down or right at any point in time. The matrix is represented by a 2D list, where each cell contains an integer. The value at cell `(i, j)` of the matrix indicates if the cell is accessible if the value is `1` or blocked if the value is `0`. The starting cell `(0, 0)` and the destination cell are always accessible. Function: `num_paths` Write a function `num_paths` that calculates the number of distinct paths from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` of the matrix. ```python def num_paths(matrix: list[list[int]]) -> int: Calculate the number of distinct paths from the top-left corner to the bottom-right corner of the matrix, moving only downwards or rightwards. Parameters: matrix (list[list[int]]): A 2D list representing the accessible and blocked cells. Returns: int: The number of distinct paths from the top-left corner to the bottom-right corner. Raises: ValueError: If the matrix is empty or contains non-binary values. pass ``` # Constraints * The matrix dimensions are (1 leq m, n leq 100). * Each cell in the matrix contains either `0` (blocked) or `1` (accessible). * The function should handle cases where the matrix is not square (i.e., `m` is not equal to `n`). * You must ensure the input matrix is valid, i.e., it is not empty and contains only `0` and `1`. # Performance Requirements * The solution should have a time complexity of O(m * n) where (m) is the number of rows and (n) is the number of columns. * The space complexity should be minimized appropriately to fit within typical limits of a standard execution environment. # Example Usage ```python matrix1 = [ [1, 1, 0, 1], [1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 1, 1] ] assert num_paths(matrix1) == 4 matrix2 = [ [1, 0], [1, 1] ] assert num_paths(matrix2) == 1 matrix3 = [ [1, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 1], [0, 0, 0, 1] ] assert num_paths(matrix3) == 2 ``` Create additional test cases to ensure the robustness and accuracy of your implementation.","solution":"def num_paths(matrix: list[list[int]]) -> int: if not matrix or not matrix[0]: raise ValueError(\\"The matrix should not be empty\\") m, n = len(matrix), len(matrix[0]) # Validate the matrix contains only 0s and 1s for row in matrix: if any(cell not in (0, 1) for cell in row): raise ValueError(\\"The matrix should only contain binary values (0 and 1)\\") # Initialize a dp array to store the number of paths to each cell dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 if matrix[0][0] == 1 else 0 # Fill out the dp array for i in range(m): for j in range(n): if matrix[i][j] == 1: if i > 0: # If not in the first row, add the value from above dp[i][j] += dp[i - 1][j] if j > 0: # If not in the first column, add the value from the left dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"# Coding Task: Implement a Swish Activation Function # Background: The Swish activation function is a smooth, non-monotonic function that has been found to perform better than ReLU on deeper networks. The Swish function is defined as `f(x) = x * sigmoid(x)`, where `sigmoid(x)` is the sigmoid function given by `1 / (1 + exp(-x))`. The Swish function allows for better signal propagation compared to the traditional ReLU function. # Task: Implement the **Swish** function. For a given input vector of real numbers, the function should transform each element x using the Swish equation. # Function Signature: ```python def swish(vector: list[float]) -> np.array: pass ``` # Input: - A single parameter `vector`, which can be a list, tuple, or NumPy array of real numbers. # Output: - A NumPy array where each element has been transformed using the Swish function. # Examples: ```python >>> swish([-1, 0, 5]) array([-0.26894142, 0.0, 5.0]) >>> swish([-2, -1, 0]) array([-0.23840584, -0.26894142, 0.0]) ``` # Constraints: * Input contains at most 1000 elements. * Each element in the input vector is a real number in the range of -10^6 to 10^6. # Notes: - Ensure your implementation converts the input vector to a NumPy array if it is not already one. - The function should handle the edge cases such as empty input, all negative values, all zeros, and mixed values appropriately. --- # Implementation Example: Here\'s how you can start implementing the Swish function: ```python import numpy as np def swish(vector: list[float]) -> np.array: if not isinstance(vector, np.ndarray): vector = np.array(vector) sigmoid = 1 / (1 + np.exp(-vector)) return vector * sigmoid ``` This function first checks if the input `vector` is a NumPy array and converts it if it is not. Then it computes the sigmoid of the vector and finally returns the product of the vector and its sigmoid, effectively applying the Swish function to each element.","solution":"import numpy as np def swish(vector: list[float]) -> np.array: Apply the Swish activation function to each element in the input vector. Parameters: vector (list[float]): Input vector of real numbers. Returns: np.array: Transformed vector using the Swish function. if not isinstance(vector, np.ndarray): vector = np.array(vector) sigmoid = 1 / (1 + np.exp(-vector)) return vector * sigmoid"},{"question":"# Coding Assessment Question You have been provided with an implementation of a basic neural network activation function. To test your skills in working with matrix operations and activation functions, you are tasked with implementing a modified version of the Rectified Linear Unit (ReLU) called Parametric Rectified Linear Unit (PReLU). # Scenario Your task is to implement an activation function called PReLU (Parametric Rectified Linear Unit). PReLU introduces learnable parameters to rectify the input values and has shown to improve the performance of deep learning models. # Function Definition Implement the function `parametric_rectified_linear_unit` that takes a vector of K real numbers and a single real number `alpha`, and applies the PReLU function to each element of the vector. # Mathematical Definition For an input element x, the PReLU function f(x) is defined as follows: ``` f(x) = x if x > 0 f(x) = alpha * x if x <= 0 ``` where `alpha` is a predefined learnable parameter. # Function Signature ```python def parametric_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray: pass ``` # Input * `vector` (np.ndarray): An array containing K real numbers. * `alpha` (float): The alpha parameter which is multiplier for negative values of x, usually initialized to a small positive value such as 0.01. # Output * Returns (np.ndarray): An array in which the PReLU function has been applied to each element. # Constraints * The input vector must be a NumPy array of real numbers. * The value of alpha can be any real number. # Performance Requirements Your implementation must perform the calculation efficiently in O(K) time and use O(K) auxiliary space. # Examples ```python >>> parametric_rectified_linear_unit(vector=np.array([2.3, 0.6, -2, -3.8]), alpha=0.1) array([ 2.3 , 0.6 , -0.2 , -0.38]) >>> parametric_rectified_linear_unit(vector=np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.01) array([-0.092 , -0.003 , 0.45 , -0.0456]) ```","solution":"import numpy as np def parametric_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray: Applies the PReLU function to each element of the input vector. Parameters: vector (np.ndarray): A numpy array containing K real numbers. alpha (float): The parameter alpha which multiplies the negative values in the vector. Returns: np.ndarray: A new numpy array with the PReLU function applied to each element. return np.where(vector > 0, vector, alpha * vector)"},{"question":"# Image Segmentation - K-means Clustering You are provided with an implementation skeleton for K-means clustering, which is used to segment images into different regions based on color similarity. Your task is to complete the implementation of the `k_means_clustering` function that segments an image based on K-means clustering. Problem Statement You need to implement a function `k_means_clustering` that performs the K-means clustering algorithm on an image to segment it into `k` clusters. Specifically, you will calculate the cluster centroids and assign each pixel of the image to the nearest centroid. # Function Signature ```python def k_means_clustering(image, k, max_iterations): Perform K-means clustering on an image. :param image: A 2D list of pixels, where each pixel is represented as a tuple of RGB values. :param k: The number of clusters. :param max_iterations: The maximum number of iterations to perform. :return: A 2D list of cluster assignments where each element indicates the cluster ID of the corresponding pixel. pass ``` # Requirements 1. **Function Implementation**: Implement the `k_means_clustering` function. It should take an image, the number of clusters `k`, and the maximum number of iterations as input and return a 2D list of cluster assignments for each pixel. 2. **Cluster Initialization**: Initialize the cluster centroids by selecting `k` random pixels from the image. 3. **Centroid Update**: Iteratively update the centroids to be the mean of all pixels assigned to each cluster. 4. **Cluster Assignment**: Assign each pixel to the nearest centroid. 5. **Convergence Check**: Stop the clustering process if centroids do not change between iterations or if the maximum number of iterations is reached. 6. **Distance Measurement**: Use the Euclidean distance to measure the similarity between pixel colors. # Input - `image`: A 2D list of tuples representing RGB values of pixels. [(R, G, B), ...] - `k`: An integer representing the number of clusters. - `max_iterations`: Maximum number of iterations to perform. Example Input ```python image = [ [(255, 0, 0), (255, 0, 0), (0, 255, 0)], [(0, 255, 0), (0, 255, 0), (0, 0, 255)], [(0, 0, 255), (255, 0, 0), (0, 255, 0)] ] k = 2 max_iterations = 10 ``` # Output - Return a 2D list with the same dimensions as the input image, where each element is an integer representing the cluster ID of the corresponding pixel. Example Output ```python [ [0, 0, 1], [1, 1, 1], [1, 0, 1] ] ``` # Constraints - The size of the image will be at most 1000 x 1000 pixels. - The value of `k` will be at most 10. - The maximum number of iterations will not exceed 100.","solution":"import random import numpy as np def k_means_clustering(image, k, max_iterations): Perform K-means clustering on an image. :param image: A 2D list of pixels, where each pixel is represented as a tuple of RGB values. :param k: The number of clusters. :param max_iterations: The maximum number of iterations to perform. :return: A 2D list of cluster assignments where each element indicates the cluster ID of the corresponding pixel. # Convert the input image list to a numpy array for easier manipulation image = np.array(image) rows, cols = image.shape[:2] # Initialize centroids by choosing k random pixels from the image pixels = image.reshape(-1, 3) centroids = pixels[random.sample(range(len(pixels)), k)] for iteration in range(max_iterations): # Assign each pixel to the nearest centroid distances = np.sqrt(((pixels - centroids[:, np.newaxis])**2).sum(axis=2)) cluster_assignments = np.argmin(distances, axis=0) # Calculate new centroids new_centroids = np.array([pixels[cluster_assignments == idx].mean(axis=0) for idx in range(k)]) # Check for convergence (if centroids do not change) if np.all(new_centroids == centroids): break # Update centroids centroids = new_centroids # Reshape the cluster assignments to the original image shape segmented_image = cluster_assignments.reshape(rows, cols) return segmented_image.tolist()"},{"question":"# Coding Assessment Question: Implementing a Vigenère Cipher Scenario: As part of a cryptography module for a security application, you are tasked with implementing the Vigenère Cipher algorithm. This will allow users to encrypt and decrypt sensitive information securely. Problem Statement: Write two Python functions to encrypt and decrypt messages using the Vigenère Cipher. The functions should handle basic input validation and manage text files for reading input and writing output. Requirements: 1. Two functions: `vigenere_encrypt(key: str, message: str) -> str` and `vigenere_decrypt(key: str, message: str) -> str`. 2. The key should be a string composed of alphabetical characters. 3. Validate the input to ensure the key and message contain only alphabetical characters and spaces. 4. Provide clear error messages if the input file is missing or if there\'s an issue writing to the output file. 5. Optimize the solution for large text files to ensure efficiency. Input: - A string `key` used for the Vigenère cipher encryption. - A string `message` which is the text to be encrypted or decrypted. Output: - A string representing the encrypted or decrypted message. Constraints: - The key must contain only alphabetical characters (both uppercase and lowercase). - The message should contain only alphabetical characters and spaces. Example: ```python key = \\"KEY\\" message = \\"HELLO WORLD\\" # Encrypted Message encrypted_message = vigenere_encrypt(key, message) print(encrypted_message) # e.g., \\"RIJVS UYVJN\\" # Decrypted Message decrypted_message = vigenere_decrypt(key, encrypted_message) print(decrypted_message) # HELLO WORLD ``` Additional Notes: - Consider edge cases such as when the message or key is empty. - Maintain case sensitivity by treating the key and message as case-insensitive during encryption and decryption. - Ensure that spaces in the message are preserved in the encrypted and decrypted output. - Aim for a solution that is performant with large messages and keys.","solution":"def vigenere_encrypt(key: str, message: str) -> str: Encrypts the message using the Vigenère cipher with the given key. if not key.isalpha(): raise ValueError(\\"Key must contain only alphabetical characters.\\") if not all(char.isalpha() or char.isspace() for char in message): raise ValueError(\\"Message must contain only alphabetical characters and spaces.\\") key = key.upper() message = message.upper() encrypted_message = [] key_length = len(key) key_index = 0 for char in message: if char.isspace(): encrypted_message.append(char) else: shift = ord(key[key_index % key_length]) - ord(\'A\') encrypted_char = chr(((ord(char) - ord(\'A\') + shift) % 26) + ord(\'A\')) encrypted_message.append(encrypted_char) key_index += 1 return \'\'.join(encrypted_message) def vigenere_decrypt(key: str, message: str) -> str: Decrypts the message using the Vigenère cipher with the given key. if not key.isalpha(): raise ValueError(\\"Key must contain only alphabetical characters.\\") if not all(char.isalpha() or char.isspace() for char in message): raise ValueError(\\"Message must contain only alphabetical characters and spaces.\\") key = key.upper() message = message.upper() decrypted_message = [] key_length = len(key) key_index = 0 for char in message: if char.isspace(): decrypted_message.append(char) else: shift = ord(key[key_index % key_length]) - ord(\'A\') decrypted_char = chr(((ord(char) - ord(\'A\') - shift + 26) % 26) + ord(\'A\')) decrypted_message.append(decrypted_char) key_index += 1 return \'\'.join(decrypted_message)"},{"question":"# Program Description Sorting can be a tricky process, especially dealing with both numbers and words in a list. Your task is to implement a function that sorts a mixed list containing both integers and strings. The function should first separate the integers and strings, sort them independently (integers in ascending order and strings in case-insensitive alphabetical order), and then combine them back with integers first followed by strings. # Function Signature ```python def sort_mixed_list(mixed_list: list) -> list: ``` # Input - **mixed_list**: A list containing integers and strings. Strings can contain alphabetic characters only, and the list can be empty or have up to (10^5) items. # Output - A single sorted list with integers sorted in ascending order followed by strings sorted in case-insensitive alphabetical order. # Constraints - Do not use any built-in functions for sorting directly. Implement your own sorting mechanism such as quicksort, mergesort, or any other efficient sorting algorithm. - Strings should be sorted in a case-insensitive manner. # Example ```python >>> sort_mixed_list([3, \'apple\', 1, \'Banana\', 2, \'cherry\']) [1, 2, 3, \'apple\', \'Banana\', \'cherry\'] >>> sort_mixed_list([\'zebra\', \'Apple\', \'banana\', 10, 5]) [5, 10, \'Apple\', \'banana\', \'zebra\'] >>> sort_mixed_list([]) [] ``` # Implementation Notes - Separate the integers and strings into two different lists. - Implement an efficient sorting algorithm to sort both lists independently. - Combine the sorted lists with integers first followed by strings. - Ensure the function handles edge cases like empty input list gracefully.","solution":"def quicksort(arr, key=None): if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if (key(x) if key else x) < (key(pivot) if key else pivot)] middle = [x for x in arr if (key(x) if key else x) == (key(pivot) if key else pivot)] right = [x for x in arr if (key(x) if key else x) > (key(pivot) if key else pivot)] return quicksort(left, key) + middle + quicksort(right, key) def sort_mixed_list(mixed_list: list) -> list: Sorts a mixed list containing both integers and strings. Integers are sorted in ascending order. Strings are sorted in case-insensitive alphabetical order. # Separate integers and strings integers = [item for item in mixed_list if isinstance(item, int)] strings = [item for item in mixed_list if isinstance(item, str)] # Sort integers using quicksort sorted_integers = quicksort(integers) # Sort strings using quicksort with case-insensitive key sorted_strings = quicksort(strings, key=str.lower) # Combine sorted integers and strings return sorted_integers + sorted_strings"},{"question":"# Sorting a List of Tuples by Multiple Keys You are tasked with creating a utility function for sorting a list of tuples based on multiple keys. This is frequently needed in data processing and analytics. The input will be a list of tuples, where each tuple has three elements: - A string (name) - An integer (age) - A float (score) Your function should sort the list of tuples in the following order: 1. Alphabetically by the name in ascending order. 2. By age in descending order for entries with the same name. 3. By score in ascending order for entries with the same name and age. Task: Create a function named `sort_tuples(data: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]`. - **Parameters**: - `data` (List[Tuple[str, int, float]]): A list of tuples, each containing a string, an integer, and a float. - **Return**: A new list of tuples sorted based on the specified criteria. Constraints: - Consider that tuples could have the same values for all three elements. - The input list can be empty. **Example**: ```python data = [ (\\"John\\", 25, 90.5), (\\"Alice\\", 30, 85.3), (\\"John\\", 30, 91.2), (\\"Alice\\", 25, 88.8), (\\"Bob\\", 25, 75.0) ] sorted_data = sort_tuples(data) print(sorted_data) # Expected output: # [(\'Alice\', 30, 85.3), (\'Alice\', 25, 88.8), (\'Bob\', 25, 75.0), (\'John\', 30, 91.2), (\'John\', 25, 90.5)] ``` Performance Requirements: - The sorting should have a time complexity of O(m log m), where m is the number of tuples in the list. - Use built-in sorting methods provided by the programming language to handle the sorting logic efficiently.","solution":"from typing import List, Tuple def sort_tuples(data: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of tuples by name in ascending order, age in descending order, and score in ascending order. :param data: List of tuples, where each tuple contains a string (name), an integer (age), and a float (score) :return: Sorted list of tuples return sorted(data, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"# Letter Combinations from Phone Number You are tasked with generating all possible letter combinations that a given phone number could represent. The phone digits map to letters according to the classic telephone keypad layout as follows: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Digits 0 and 1 do not map to any letters. Function Signature: ```python def letter_combinations(digits: str) -> list[str]: ``` Input: - **digits**: A string representing the digits of the phone number. (e.g., \\"23\\") Output: - A list of strings, where each string represents a possible letter combination for the given number. Constraints: - The input string only contains digits from 2 to 9. Examples: ```python digits = \\"23\\" assert letter_combinations(digits) == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] digits = \\"\\" assert letter_combinations(digits) == [] digits = \\"2\\" assert letter_combinations(digits) == [\\"a\\", \\"b\\", \\"c\\"] ``` Scenario: Imagine you are trying to find all possible text messages that a user could type based on the digits they have pressed on their phone\'s keypad. Each digit maps to a set of letters, and you need to generate all possible combinations of these letters. **Note**: Since the digits may result in multiple combinations, any order of the combinations in the output list is acceptable.","solution":"def letter_combinations(digits: str) -> list: Returns all possible letter combinations that the given phone number could represent. if not digits: return [] digit_to_char = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_char[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Question: As a software developer, you\'re tasked to implement a caching mechanism to optimize the retrieval of expensive function calls. The cache should follow the Least Recently Used (LRU) policy. Function Signature: ```python class LRUCache: def __init__(self, capacity: int): self.cache = None self.capacity = capacity def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` # Requirements: 1. Implement the `LRUCache` class with the `get` and `put` methods. 2. Ensure that the cache follows the LRU eviction policy: - `get(key)`: Returns the value of the key if the key exists in the cache, otherwise returns -1. - `put(key, value)`: Adds or updates the key with its corresponding value in the cache. If the cache exceeds its capacity, the least recently used item should be evicted. 3. Handle edge cases such as: - Getting a key that is not in the cache. - Adding an item to a full cache. # Expected input and output formats: - **Input**: Capacity as an integer and subsequent calls to `get` and `put` methods. - **Output**: Values returned by the `get` method. # Performance requirements: - **Aim for O(1)** time complexity for both `get` and `put` operations, using appropriate data structures. # Sample Test Cases: ```python # Test Case 1: cache = LRUCache(2) cache.put(1, 1) # Cache is {1=1} cache.put(2, 2) # Cache is {1=1, 2=2} assert cache.get(1) == 1 # Returns 1 cache.put(3, 3) # LRU key is 2, evicts key 2, Cache is {1=1, 3=3} assert cache.get(2) == -1 # Returns -1 (not found) cache.put(4, 4) # LRU key is 1, evicts key 1, Cache is {4=4, 3=3} assert cache.get(1) == -1 # Returns -1 (not found) assert cache.get(3) == 3 # Returns 3 assert cache.get(4) == 4 # Returns 4 # Test Case 2: cache = LRUCache(1) cache.put(2, 1) # Cache is {2=1} assert cache.get(2) == 1 # Returns 1 cache.put(3, 2) # LRU key is 2, evicts key 2, Cache is {3=2} assert cache.get(2) == -1 # Returns -1 (not found) assert cache.get(3) == 2 # Returns 2 ``` # Additional Context: - Optimize using data structures such as dictionaries (hash maps) combined with doubly linked lists to achieve O(1) time complexity. - Ensure the cache retains only the most recently accessed elements within its capacity.","solution":"class Node: Node class for doubly linked list. def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node() # dummy head self.tail = Node() # dummy tail self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] def _remove(self, node): Removes node from the linked list. prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node): Adds node right before the tail. prev_node = self.tail.prev prev_node.next = node node.prev = prev_node node.next = self.tail self.tail.prev = node"},{"question":"# Problem Statement Write a function `find_distances(matrix: List[List[int]]) -> List[List[int]]` which takes a 2D matrix of 0s and 1s and returns a 2D matrix of the same size where each cell contains the distance to the nearest 0. # Function Signature ```python def find_distances(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input - **matrix**: A 2D matrix (list of lists) of integers (0s and 1s). # Output - A 2D matrix (list of lists) of integers where cell `[i][j]` contains the distance to the nearest 0. # Constraints - The input matrix will have at least one 0. - The dimensions of the matrix are `1 <= rows, cols <= 100`. - The distance between two adjacent cells is `1`. # Requirements - Use BFS (Breadth-First Search) to compute the distance from each cell to the nearest 0. - The distance between cells is calculated using the Manhattan distance. # Example ```python >>> find_distances([ [0, 1, 1], [1, 1, 1], [1, 1, 0] ]) [ [0, 1, 2], [1, 2, 1], [2, 1, 0] ] ``` # Notes - Handle various scenarios including when 1s are surrounded by 0s and vice versa. - Utilize an efficient approach to ensure the function executes within a reasonable timeframe for the given constraints.","solution":"from typing import List from collections import deque def find_distances(matrix: List[List[int]]) -> List[List[int]]: rows, cols = len(matrix), len(matrix[0]) distances = [[float(\'inf\')] * cols for _ in range(rows)] queue = deque() for r in range(rows): for c in range(cols): if matrix[r][c] == 0: distances[r][c] = 0 queue.append((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: if distances[nr][nc] > distances[r][c] + 1: distances[nr][nc] = distances[r][c] + 1 queue.append((nr, nc)) return distances"},{"question":"# Problem Statement You are given a grid-based game where a player starts at the top-left corner of an M x N grid and can move either right or down at each step until reaching the bottom-right corner of the grid. The player needs to avoid obstacles placed on the grid, denoted by the number 1. The cells the player can walk on are denoted by the number 0. You are required to find the number of unique paths the player can take to reach the bottom-right corner from the top-left corner without passing through any obstacles. # Function Specifications Function Signature ```python def unique_paths_with_obstacles(grid: List[List[int]]) -> int: ``` Input - `grid (List[List[int]])`: A 2D list of integers representing the grid. The cell `(i, j)` of the grid is either 0 (walkable) or 1 (obstacle). - 1 ≤ M, N ≤ 100 Output - `int`: The number of unique paths from the top-left corner to the bottom-right corner. If no such path exists, return 0. # Example ```python grid1 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] grid2 = [ [0, 1], [0, 0] ] print(unique_paths_with_obstacles(grid1)) # Output: 2 print(unique_paths_with_obstacles(grid2)) # Output: 1 ``` # Notes - You must start from the top-left corner at grid[0][0] and reach the bottom-right corner at grid[M-1][N-1]. - Consider edge cases such as the start or the destination being blocked. # Constraints - The function should run in O(M * N) time complexity. - Efficiently handle grids with obstacles and avoid paths that lead to dead ends.","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Create a 2D DP array initialized to 0 dp = [[0] * n for _ in range(m)] # Initialize the start point dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # No path through obstacles else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Problem Statement Develop a function that takes an integer `n` and generates the nth row of Pascal\'s Triangle. In Pascal\'s Triangle, each number is the sum of the two numbers directly above it. Write a function: ```python def pascals_triangle_row(n: int) -> List[int]: # your implementation here ``` The function should return a list representing the nth row of Pascal\'s Triangle. # Input - An integer `n (0 <= n <= 33)` # Output - A list of integers representing the nth row of Pascal\'s Triangle. # Constraints - `0 <= n <= 33` - You may assume that `n` will always be an integer within the specified range. # Example ```python >>> pascals_triangle_row(3) [1, 3, 3, 1] ``` **Explanation**: - The first few rows of Pascal\'s Triangle are: ``` Row 0: [1] Row 1: [1, 1] Row 2: [1, 2, 1] Row 3: [1, 3, 3, 1] ``` - As shown, the 3rd row of Pascal\'s Triangle is `[1, 3, 3, 1]`. # Notes - For efficiency, consider iterative or direct combinatorial approaches. - Ensure the solution handles the upper boundary efficiently given the constraints. - Remember Pascal\'s Triangle properties, such as symmetry and the binomial coefficient formula (nCr).","solution":"from typing import List def pascals_triangle_row(n: int) -> List[int]: Returns the nth row of Pascal\'s Triangle. row = [1] # Starting with the first element of the row for k in range(1, n + 1): # Using the previous value to calculate the next value in the row next_value = row[-1] * (n - k + 1) // k row.append(next_value) return row"},{"question":"# Maximum Subarray Sum Using Divide and Conquer Context You are given an array of integers, which can include both positive and negative numbers. Your task is to find the contiguous subarray that has the maximum sum using the divide-and-conquer approach, which is known as the Maximum Subarray Problem. Task Write a function `max_subarray_sum` that takes in a single parameter: 1. `nums`: A list of integers representing the array. The function should return the sum of the maximum subarray. Function Signature: ```python def max_subarray_sum(nums: list[int]) -> int: pass ``` Constraints * The length of the input list is at least 1. * The elements of the array can be both negative and positive integers. * The list may contain a mix of both very large positive numbers and very large negative numbers. Input * `nums`: A list of integers. (e.g., [-2, 1, -3, 4, -1, 2, 1, -5, 4]) Output * Return the sum of the maximum subarray. (e.g., 6 for the example above, as the subarray [4, -1, 2, 1] has the maximum sum). Example ```python assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 assert max_subarray_sum([3, -1, 2, -1]) == 4 ``` Edge Cases to Consider * The list contains only one element. * The list contains all negative numbers. * The list contains a mix of large positive and negative numbers. * The maximum subarray is at the beginning or end of the list. Performance Requirements Ensure the solution leverages the divide-and-conquer approach to achieve an efficient time complexity.","solution":"def max_crossing_sum(nums, left, mid, right): # Include elements on left of mid. left_sum = float(\'-inf\') sum = 0 for i in range(mid, left - 1, -1): sum += nums[i] if sum > left_sum: left_sum = sum # Include elements on right of mid. right_sum = float(\'-inf\') sum = 0 for i in range(mid + 1, right + 1): sum += nums[i] if sum > right_sum: right_sum = sum # Return sum of elements on left and right of mid. return left_sum + right_sum def max_subarray_sum_recursive(nums, left, right): # Base case: only one element. if left == right: return nums[left] # Find middle point. mid = (left + right) // 2 # Return maximum of following three possible cases: # a) Maximum subarray sum in left half. # b) Maximum subarray sum in right half. # c) Maximum subarray sum such that the subarray crosses the midpoint. return max(max_subarray_sum_recursive(nums, left, mid), max_subarray_sum_recursive(nums, mid + 1, right), max_crossing_sum(nums, left, mid, right)) def max_subarray_sum(nums): return max_subarray_sum_recursive(nums, 0, len(nums) - 1)"},{"question":"# Problem Statement: Create a function `merge_csv_files` that merges multiple CSV files into a single CSV file. Each CSV file contains data with the same structure (i.e., the same headers/columns). Your function should take the filenames of the input CSV files and the name of the output CSV file, read the data from the input files, and write the merged data to the output file. # Functions to Implement: 1. `merge_csv_files(input_files, output_file) -> None` **Parameters**: - `input_files` (list of str): List of filenames for the input CSV files. - `output_file` (str): Filename for the output CSV file where the merged data will be saved. **Requirements**: - The first row of each input CSV file contains the headers. - The headers in each input CSV file are identical. - The output CSV file should contain a single set of headers followed by the combined data from all input files. - Do not use any external libraries such as pandas. # Example: ```python # Assume the content of file1.csv is: # name,age # Alice,30 # Bob,25 # Assume the content of file2.csv is: # name,age # Carol,27 # David,22 input_files = [\'file1.csv\', \'file2.csv\'] output_file = \'merged.csv\' merge_csv_files(input_files, output_file) # The content of merged.csv should be: # name,age # Alice,30 # Bob,25 # Carol,27 # David,22 ``` # Hints: - Use file I/O operations to read from and write to CSV files. - Ensure to handle opening and closing the files properly to avoid file access issues. - Reading files line by line might help in efficiently managing the data.","solution":"def merge_csv_files(input_files, output_file): Merges multiple CSV files into a single CSV file. Parameters: - input_files (list of str): List of filenames for the input CSV files. - output_file (str): Filename for the output CSV file where the merged data will be saved. if not input_files: return # Open the output file in write mode with open(output_file, \'w\') as outfile: header_written = False for file in input_files: with open(file, \'r\') as infile: # Read the lines from the input file lines = infile.readlines() # Write the header if not already written # (header is the first line of the first file) if not header_written: outfile.write(lines[0]) header_written = True # Write the rest of the lines (excluding header) outfile.writelines(lines[1:])"},{"question":"# Coding Assessment Question: Implementing a Shift Cipher Scenario: You are working on an encryption module for a secure communication app. Your task is to implement the Shift Cipher (also known as the Caesar Cipher) to provide basic encryption and decryption of user messages. This simple cipher involves shifting each letter of the plaintext message by a fixed number of positions down the alphabet. Problem Statement: Write a Python function to encrypt and decrypt messages using the Shift Cipher. The function should handle both uppercase and lowercase letters, leaving other characters unchanged. Requirements: 1. Two functions: `shift_encrypt(shift: int, message: str) -> str` and `shift_decrypt(shift: int, message: str) -> str`. 2. Handle edge cases such as empty messages and large shift values (both positive and negative). 3. Maintain the case of the letters (i.e., \'A\' remains \'A\' and \'a\' remains \'a\'). Input: - An integer `shift` which indicates the number of positions each letter in the message is shifted. - A string `message` which is the text message to be encrypted or decrypted. Output: - A string representing the encrypted or decrypted message. Constraints: - The shift should be any integer (positive, negative, or zero). - The message should contain only printable ASCII characters. Example: ```python shift = 3 message = \\"Hello, World!\\" # Encrypted Message encrypted_message = shift_encrypt(shift, message) print(encrypted_message) # \\"Khoor, Zruog!\\" # Decrypted Message decrypted_message = shift_decrypt(shift, encrypted_message) print(decrypted_message) # \\"Hello, World!\\" ``` Additional Notes: - Consider edge cases where the shift value is larger than 26 or less than -26, by using modulus operation to wrap around the alphabet. - Ensure the solution is efficient and can handle messages of varying lengths within a reasonable time. - Remember to leave non-alphabet characters unchanged in the output.","solution":"def shift_encrypt(shift, message): Encrypt the given message using the Shift Cipher with the given shift value. Args: shift (int): The number of positions to shift each letter. message (str): The message to encrypt. Returns: str: The encrypted message. encrypted_message = [] for char in message: if char.isalpha(): if char.islower(): new_char = chr(((ord(char) - 97 + shift) % 26) + 97) else: new_char = chr(((ord(char) - 65 + shift) % 26) + 65) encrypted_message.append(new_char) else: encrypted_message.append(char) return \'\'.join(encrypted_message) def shift_decrypt(shift, message): Decrypt the given message using the Shift Cipher with the given shift value. Args: shift (int): The number of positions to shift each letter back. message (str): The message to decrypt. Returns: str: The decrypted message. return shift_encrypt(-shift, message)"},{"question":"# Coding Question You are tasked to design a Python function that processes transaction data from a JSON file and generates a summary report based on the criteria provided below. The function should handle the calculations efficiently, ensure data integrity by handling invalid records, and support different transaction types. Function Requirements: - **Function Name**: `generate_transaction_summary` - **Inputs**: - `file_path` (str): Path to the JSON file containing transaction data. - **Outputs**: - A dictionary summarizing the total transaction amount, transaction counts by type, and any invalid records. - **Constraints**: - The JSON file contains a list of transactions, each represented as a dictionary with the following keys: `id`, `amount`, `currency`, `type`, `timestamp`. - Valid transaction types are \\"deposit\\", \\"withdrawal\\", and \\"transfer\\". - If any transaction record is missing required fields or has a negative amount, mark it as invalid. - **Performance**: Optimize to handle large datasets efficiently, minimizing memory and computation overhead. - **Edge Cases**: - Invalid JSON file format. - Empty transaction record list. - Mixed valid and invalid transaction data. # Example Usage ```python summary = generate_transaction_summary(\'/path/to/transactions.json\') print(summary) ``` # Notes - The function should handle I/O errors and JSON decoding errors gracefully, returning a summary message indicating an error if encountered. - Focus on ensuring accurate calculations and robust error handling. # Example JSON File Structure ```json [ {\\"id\\": \\"txn1\\", \\"amount\\": 100.0, \\"currency\\": \\"USD\\", \\"type\\": \\"deposit\\", \\"timestamp\\": \\"2023-01-01T10:00:00Z\\"}, {\\"id\\": \\"txn2\\", \\"amount\\": -50.0, \\"currency\\": \\"USD\\", \\"type\\": \\"withdrawal\\", \\"timestamp\\": \\"2023-01-02T11:00:00Z\\"}, ... ] ``` # Example Summary Output ```python { \\"total_amount\\": 150.0, \\"transactions_count\\": { \\"deposit\\": 3, \\"withdrawal\\": 1, \\"transfer\\": 2 }, \\"invalid_records\\": [ {\\"id\\": \\"txn2\\", \\"amount\\": -50.0, \\"currency\\": \\"USD\\", \\"type\\": \\"withdrawal\\", \\"timestamp\\": \\"2023-01-02T11:00:00Z\\"} ] } ``` # Example Solution Signature ```python def generate_transaction_summary(file_path: str) -> dict: # Your code here pass ```","solution":"import json def generate_transaction_summary(file_path: str) -> dict: Processes transaction data from a JSON file and generates a summary report. :param file_path: Path to the JSON file containing transaction data. :return: Dictionary summarizing the total transaction amount, transaction counts by type, and invalid records. try: with open(file_path, \'r\') as file: transactions = json.load(file) except (IOError, json.JSONDecodeError): return {\'error\': \'Error reading or parsing the file\'} valid_types = {\\"deposit\\", \\"withdrawal\\", \\"transfer\\"} summary = { \\"total_amount\\": 0.0, \\"transactions_count\\": { \\"deposit\\": 0, \\"withdrawal\\": 0, \\"transfer\\": 0 }, \\"invalid_records\\": [] } for txn in transactions: if (not isinstance(txn, dict) or \'id\' not in txn or \'amount\' not in txn or \'currency\' not in txn or \'type\' not in txn or \'timestamp\' not in txn or not isinstance(txn[\'amount\'], (int, float)) or txn[\'amount\'] < 0 or txn[\'type\'] not in valid_types): summary[\\"invalid_records\\"].append(txn) else: summary[\\"total_amount\\"] += txn[\\"amount\\"] summary[\\"transactions_count\\"][txn[\\"type\\"]] += 1 return summary"},{"question":"# Problem Statement: Generate Prime Factors of a Number Context Prime factorization is the process of determining the set of prime numbers which multiply together to make the original number. This task is useful in a variety of applications ranging from cryptographic algorithms to numerical analysis. Objective Implement a function named `prime_factors` that generates the list of prime factors of a given integer. Function Specifications * **Function Name**: `prime_factors` * **Input**: - `n`: An integer `n` greater than 1. * **Output**: - Returns a list of integers representing the prime factors of `n` in non-decreasing order. Constraints * The function should handle integer inputs up to 10^9. * Consider efficiency in your algorithm to avoid excessive computation time for large integers. Requirements * Implement the function with at most O(√n) time complexity. * Ensure proper validation for input to prevent negative values or values less than 2. Example ```python >>> prime_factors(28) [2, 2, 7] >>> prime_factors(100) [2, 2, 5, 5] >>> prime_factors(13195) [5, 7, 13, 29] ``` Implementation Guidelines 1. Initialize an empty list to store the prime factors. 2. Check and include the number of times 2 divides `n`. 3. Iterate over odd integers starting from 3 to √n to find and store other prime factors. 4. If `n` remains greater than 2, it is a prime factor itself. ```python def prime_factors(n: int) -> list: # Your implementation here pass ``` Testing - Ensure to test cases including numbers with small prime factors, numbers with large prime factors, and numbers that are primes themselves. ```python # Example test cases print(prime_factors(28)) # Output: [2, 2, 7] print(prime_factors(100)) # Output: [2, 2, 5, 5] print(prime_factors(13195)) # Output: [5, 7, 13, 29] ```","solution":"def prime_factors(n: int) -> list: if n < 2: raise ValueError(\\"Input must be an integer greater than 1.\\") factors = [] # Handle factor of 2 while n % 2 == 0: factors.append(2) n //= 2 # Handle odd factors from 3 onwards up to √n factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still greater than 2, then it must be a prime factor if n > 2: factors.append(n) return factors"},{"question":"# Rotated Array Minimum Finder **Scenario:** You have been asked to write a function that finds the minimum element in a rotated sorted array. A rotated array means that some subarray of the array has been shifted from the beginning to the end of the array. An example is an array that starts as `[0, 1, 2, 4, 5, 6, 7]` then becomes `[4, 5, 6, 7, 0, 1, 2]` after a rotation. This minimum-finding process is crucial in various system optimizations where re-ordered data structures are analyzed. **Function Specification:** ```python def find_min_rotated(arr: List[int]) -> int: Finds the minimum element in a rotated sorted array. Parameters: arr (List[int]): The rotated sorted array. Returns: int: The minimum element in the array. Raises: ValueError: If the input array is empty. Example: >>> find_min_rotated([3, 4, 5, 1, 2]) 1 >>> find_min_rotated([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_min_rotated([1]) 1 >>> find_min_rotated([]) Traceback (most recent call last): ... ValueError: Input array must not be empty ``` **Requirements:** 1. The function should accept one parameter `arr` which is expected to be a list of integers representing the rotated sorted array. 2. The function should return the minimum integer element from the array. 3. If the input array is empty, raise a `ValueError`. 4. Optimize the search for the minimum element to be efficient even for large arrays. **Constraints:** - The input array is non-empty and contains distinct integers. # Examples: ```python assert find_min_rotated([3, 4, 5, 1, 2]) == 1 assert find_min_rotated([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_min_rotated([11, 13, 15, 17]) == 11 assert find_min_rotated([1]) == 1 assert find_min_rotated([2, 1]) == 1 assert find_min_rotated([]) == None # Raises ValueError ``` --- This new question integrates seamlessly with the existing set, maintaining the same tone, complexity, and domain while providing a unique problem scenario for candidates to solve.","solution":"from typing import List def find_min_rotated(arr: List[int]) -> int: Finds the minimum element in a rotated sorted array. Parameters: arr (List[int]): The rotated sorted array. Returns: int: The minimum element in the array. Raises: ValueError: If the input array is empty. if not arr: raise ValueError(\\"Input array must not be empty\\") left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: # Minimum is in the right half left = mid + 1 else: # Minimum is in the left half including mid right = mid return arr[left]"},{"question":"# Coding Question You are tasked to implement a function to simulate a simple banking system that processes a sequence of transactions on a user\'s account. Each transaction will be either a deposit or a withdrawal, and you need to keep track of the account balance after each transaction. If a withdrawal transaction exceeds the current balance, it should be ignored. Function Signature ```python def process_transactions(transactions: List[Dict[str, float]], initial_balance: float) -> float: pass ``` Input - `transactions` (List[Dict[str, float]]): A list of transactions, where each transaction is represented as a dictionary with two keys: - \\"type\\" (str): The type of the transaction, either \\"deposit\\" or \\"withdrawal\\". - \\"amount\\" (float): The amount of money for the transaction. It must be a non-negative value. - `initial_balance` (float): The initial balance in the account. It must be a non-negative value. Output - (float): The final balance in the account after processing all the transactions. Constraints - The value of `amount` in each transaction and `initial_balance` will always be non-negative. - Each transaction\'s \\"type\\" will be either \\"deposit\\" or \\"withdrawal\\". Examples ```python >>> transactions = [ ... {\\"type\\": \\"deposit\\", \\"amount\\": 100}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 50}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 30}, ... {\\"type\\": \\"deposit\\", \\"amount\\": 10}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 60} ... ] >>> process_transactions(transactions, 50) 50.0 >>> transactions = [ ... {\\"type\\": \\"deposit\\", \\"amount\\": 200}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 100}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 150}, ... {\\"type\\": \\"deposit\\", \\"amount\\": 50} ... ] >>> process_transactions(transactions, 100) 100.0 >>> transactions = [ ... {\\"type\\": \\"deposit\\", \\"amount\\": 300}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 100} ... ] >>> process_transactions(transactions, 0) 200.0 >>> transactions = [ ... {\\"type\\": \\"deposit\\", \\"amount\\": 120}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 100}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 50} ... ] >>> process_transactions(transactions, 50) 20.0 ``` Additional Notes - Assume that the transaction list can be empty, in which case the final balance should be the same as the initial balance. - Ensure that your function handles invalid \\"type\\" values gracefully by skipping over invalid transactions.","solution":"def process_transactions(transactions, initial_balance): Processes a list of transactions on the account starting with the initial balance. Parameters: transactions (List[Dict[str, float]]): List of transactions where each transaction is represented as a dictionary. initial_balance (float): The initial balance in the account. Returns: float: The final balance after processing all transactions. balance = initial_balance for transaction in transactions: t_type = transaction.get(\\"type\\") amount = transaction.get(\\"amount\\", 0) if t_type == \\"deposit\\" and amount >= 0: balance += amount elif t_type == \\"withdrawal\\" and amount >= 0: if amount <= balance: balance -= amount return balance"},{"question":"# Context You have been asked to create a simplified Console Menu system in Python that allows easy navigation and selection of menu options. This menu system should support adding new items, displaying the menu, handling user input to select an option, and executing associated functions. # Problem Statement Implement a `ConsoleMenu` class that supports the following methods: - `add_item(self, name, function)`: Adds a new item to the menu. `name` is a string representing the menu item, and `function` is a callable that gets executed when the item is selected. - `display(self)`: Displays the list of menu items with their corresponding selection numbers. - `run(self)`: Prompts the user to select an item by its number, and executes the corresponding function. The loop should terminate when a user inputs \'0\'. # Requirements 1. The menu should dynamically support adding any number of items. 2. The display format should print each menu item on a new line, prefixed with its corresponding number starting from 1. 3. Selecting item \'0\' should gracefully exit the menu loop. # Constraints - Each item name must be unique. - Handle cases where the user input is invalid (e.g., non-integer input, out-of-range numbers). # Input/Output - Your implementation should handle interactive input/output as specified. ```python class ConsoleMenu: def __init__(self): # Initialize your data structure pass def add_item(self, name, function): # Add a new item to the menu pass def display(self): # Display the list of menu items pass def run(self): # Run the menu loop to handle user input pass ``` # Example Usage Here is an example of how the `ConsoleMenu` class can be used: ```python def say_hello(): print(\\"Hello, world!\\") def say_goodbye(): print(\\"Goodbye, world!\\") menu = ConsoleMenu() menu.add_item(\\"Say Hello\\", say_hello) menu.add_item(\\"Say Goodbye\\", say_goodbye) menu.display() menu.run() ``` When `run()` is called, the application should display: ``` 1. Say Hello 2. Say Goodbye 0. Exit ``` If the user inputs \'1\', the program would execute `say_hello`, printing `Hello, world!`.","solution":"class ConsoleMenu: def __init__(self): self.items = [] def add_item(self, name, function): Adds a new item to the menu. :param name: A string representing the name of the menu item. :param function: A callable to execute when the menu item is selected. for item in self.items: if item[\'name\'] == name: raise ValueError(\\"Menu item names must be unique.\\") self.items.append({\'name\': name, \'function\': function}) def display(self): Displays the list of menu items. for i, item in enumerate(self.items, 1): print(f\\"{i}. {item[\'name\']}\\") print(\\"0. Exit\\") def run(self): Runs the menu loop to handle user input. while True: try: self.display() choice = int(input(\\"Select an option: \\")) if choice == 0: print(\\"Exiting the menu.\\") break elif 1 <= choice <= len(self.items): self.items[choice - 1][\'function\']() else: print(\\"Invalid choice. Please select a valid option.\\") except ValueError: print(\\"Invalid input. Please enter a number.\\")"},{"question":"```markdown # Data Structure Manipulation with Priority Queues You are given a series of operations to be performed on a priority queue. A priority queue is a data structure that allows insertion of elements and access to the smallest element efficiently. The goal is to simulate these operations and return the results of the \\"pop\\" operations in the order they are performed. # Task Implement a function `priority_queue_operations` that takes a list of operations and returns a list of results corresponding to \\"pop\\" operations. # Function Signature ```python def priority_queue_operations(operations: List[Tuple[str, int]]) -> List[int]: pass ``` # Input - **operations**: A list of tuples where each tuple represents an operation. The first element of the tuple is a string (\\"push\\" or \\"pop\\"), and the second element (provided only for \\"push\\" operations) is an integer to be pushed to the priority queue. # Output - Returns a list of integers which are the results of each \\"pop\\" operation performed on the priority queue. # Constraints - The total number of operations will not exceed 10^4. - The integers to be pushed will be in the range `-10^6` to `10^6`. # Example ```python operations = [(\\"push\\", 3), (\\"push\\", 1), (\\"pop\\", None), (\\"push\\", 2), (\\"pop\\", None)] output = priority_queue_operations(operations) print(output) # Expected output: [1, 2] ``` # Explanation 1. **Push 3**: The priority queue contains [3]. 2. **Push 1**: The priority queue contains [1, 3] (1 is the smallest element). 3. **Pop**: Removes and returns 1. The priority queue now contains [3]. 4. **Push 2**: The priority queue contains [2, 3]. 5. **Pop**: Removes and returns 2. The priority queue now contains [3]. # Note Use a heap data structure to implement the priority queue, which provides O(log n) time complexity for both the \\"push\\" and \\"pop\\" operations. ```","solution":"import heapq from typing import List, Tuple def priority_queue_operations(operations: List[Tuple[str, int]]) -> List[int]: min_heap = [] results = [] for operation in operations: if operation[0] == \\"push\\": heapq.heappush(min_heap, operation[1]) elif operation[0] == \\"pop\\": if min_heap: results.append(heapq.heappop(min_heap)) return results"},{"question":"# Problem Description In this coding challenge, you are required to implement a function that calculates and visualizes the Mandelbrot set. The Mandelbrot set is a famous fractal that is defined by the set of complex numbers (c) for which the function (f(z) = z^2 + c) does not diverge when iterated from (z = 0). Your implementation should use concurrent processing techniques to optimize the computation for high-resolution grids. # Function Specification You need to write a function `visualize_mandelbrot_set` with the following signature: ```python def visualize_mandelbrot_set(nb_iterations: int, escape_radius: float, window_size: float, nb_pixels: int) -> None: ``` Input: - `nb_iterations`: An integer indicating the maximum number of iterations for determining if a point belongs to the Mandelbrot set. - `escape_radius`: A float specifying the escape radius. Points with an absolute value greater than this radius are considered to have escaped. - `window_size`: A float specifying the range of real and imaginary values for the grid. The grid should cover from -window_size to +window_size on both axes. - `nb_pixels`: An integer specifying the resolution of the grid (nb_pixels x nb_pixels). Output: - Displays a plot visualizing the Mandelbrot set, where points within the set are colored differently from those that escape. # Constraints: - Use concurrent processing to speed up the computation for high-resolution grids. - Ensure robust handling of numerical issues, such as overflow. # Example Usage ```python import numpy as np from matplotlib import pyplot as plt visualize_mandelbrot_set(50, 2.0, 2.0, 1000) ``` This should display a plot of the Mandelbrot set for the specified parameters. # Performance Requirements - Optimize the computation using concurrent processing for grids larger than 500x500 pixels. - Efficiently manage memory, avoiding unnecessary data duplication during the computation.","solution":"import numpy as np from matplotlib import pyplot as plt import multiprocessing as mp def mandelbrot(c, max_iter, escape_radius): z = 0 for i in range(max_iter): if abs(z) > escape_radius: return i z = z * z + c return max_iter def compute_row(y, x_min, x_max, y_coord, nb_pixels, max_iter, escape_radius): row = np.zeros(nb_pixels) for x in range(nb_pixels): c = complex(x_min + (x / (nb_pixels - 1)) * (x_max - x_min), y_coord) row[x] = mandelbrot(c, max_iter, escape_radius) return row def visualize_mandelbrot_set(nb_iterations, escape_radius, window_size, nb_pixels): x_min, x_max = -window_size, window_size y_min, y_max = -window_size, window_size y_coords = np.linspace(y_min, y_max, nb_pixels) pool = mp.Pool(mp.cpu_count()) rows = [pool.apply_async(compute_row, args=(y, x_min, x_max, y_coords[y], nb_pixels, nb_iterations, escape_radius)) for y in range(nb_pixels)] pool.close() pool.join() mandelbrot_set = np.array([row.get() for row in rows]) plt.imshow(mandelbrot_set.T, extent=[x_min, x_max, y_min, y_max], cmap=\'hot\') plt.colorbar() plt.show()"},{"question":"# Problem Statement Write a function named `rotate_matrix_90` that takes an `n x n` square matrix and rotates it by 90 degrees clockwise. Your function should modify the matrix in place, meaning you should not create and return a new matrix, but instead directly update the given matrix. # Function Signature ```python def rotate_matrix_90(matrix: List[List[int]]) -> None: pass ``` # Input * `matrix`: A list of lists of integers. Each list represents a single row of the matrix, and the length of each list is equal to the number of lists (i.e., it\'s a square matrix). # Output * There is no return value. The function should modify the input matrix in place. # Constraints * `1 <= len(matrix) <= 1000` * `-10^9 <= matrix[i][j] <= 10^9` # Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [1, 2], [3, 4] ] rotate_matrix_90(matrix2) assert matrix2 == [ [3, 1], [4, 2] ] matrix3 = [ [1] ] rotate_matrix_90(matrix3) assert matrix3 == [ [1] ] ``` # Additional Notes 1. Ensure the function handles edge cases such as an empty matrix or a 1x1 matrix. 2. Optimize for clarity and efficiency. 3. Make sure to modify the matrix in place without using a secondary matrix. 4. Test the function with both small and large matrices to ensure correctness.","solution":"from typing import List def rotate_matrix_90(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Maximum Sum Subsequence with Non-Adjacent Elements Given an array of positive integers, you need to find the maximum sum of a subsequence such that no two elements in the subsequence are adjacent in the original array. Function Specification: **Function Name**: `max_non_adjacent_sum` **Parameters**: * `nums` (List[int]): An array of positive integers. **Returns**: * `int`: The maximum sum of a subsequence with no adjacent elements. Constraints: * The input list will have at least one element and no more than 10^4 elements. * Each integer in the array will be between 1 and 10^4. Examples: 1. **Input**: `[3, 2, 5, 10, 7]` **Output**: `15` **Explanation**: The maximum sum can be obtained by the subsequence `[3, 10, 2]` or `[3, 10, 7]`. 2. **Input**: `[3, 2, 7, 10]` **Output**: `13` **Explanation**: The maximum sum can be obtained by the subsequence `[3, 10]` or `[2, 10]`. 3. **Input**: `[5, 5, 10, 100, 10, 5]` **Output**: `110` **Explanation**: The maximum sum can be obtained by the subsequence `[5, 100, 5]`. Implement the function `max_non_adjacent_sum` to generate the maximum sum without picking two adjacent numbers in the provided list.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of a subsequence such that no two elements are adjacent. if not nums: return 0 if len(nums) == 1: return nums[0] # Let\'s define two variables to store the maximum sum including and excluding the previous element incl = nums[0] excl = 0 for i in range(1, len(nums)): # Current max excluding i (i.e., excluding current element) new_excl = max(incl, excl) # Current max including i (i.e., including current element) incl = excl + nums[i] excl = new_excl # Return the maximum value of incl and excl which means the max sum we can obtain # either by including or excluding the last element return max(incl, excl)"},{"question":"# Scenario In a banking system, you are tasked with implementing an alert feature that notifies users if their savings account balance exceeds a certain threshold at the end of each day. You need to write a function that evaluates the balance data and returns the dates when the balance exceeded the given threshold. # Function Implementation Implement a function `balance_alert(balances: List[Tuple[str, float]], threshold: float) -> List[str]` in Python, which checks daily balances and returns a list of dates when the balance exceeded the specified threshold. # Input and Output Formats * **Input**: - `balances`: A list of tuples where each tuple contains a string representing the date in \'YYYY-MM-DD\' format and a float representing the account balance on that date. - `threshold`: A float representing the threshold balance value. * **Output**: A list of strings where each string represents a date when the balance exceeded the specified threshold. # Constraints * Each date in the `balances` list is unique and is sorted in ascending order. * The balance value can be any positive or negative float value. * Ensure to handle edge cases where the balance list is empty or no balance exceeds the threshold. # Requirements 1. Iterate through the list and compare each balance to the threshold. 2. Extract and return the dates that satisfy the condition as a list. 3. Ensure the function handles input validation and cases correctly. # Example ```python # Example Usage balances = [ (\\"2023-01-01\\", 1500.00), (\\"2023-01-02\\", 2500.50), (\\"2023-01-03\\", 1200.00), (\\"2023-01-04\\", 1000.00), ] threshold = 2000.00 print(balance_alert(balances, threshold)) # Output: [\\"2023-01-02\\"] ``` # Detailed Steps 1. Initialize an empty list to store the dates when the balance exceeds the threshold. 2. Loop through each element in the `balances` list. 3. For each date and balance, compare the balance to the threshold. 4. If the balance exceeds the threshold, append the date to the output list. 5. Return the list of dates at the end of the process.","solution":"from typing import List, Tuple def balance_alert(balances: List[Tuple[str, float]], threshold: float) -> List[str]: Evaluates the balance data and returns the dates when the balance exceeded the given threshold. :param balances: List of tuples with date and balance :param threshold: Float representing the threshold balance value :return: List of dates when the balance exceeded the given threshold exceeded_dates = [date for date, balance in balances if balance > threshold] return exceeded_dates"},{"question":"# Image Manipulation and Filtering You are tasked with creating a simple image manipulation tool that allows for the application of various filters on grayscale images. Function Signature ```python def apply_filter(image: List[List[int]], filter_name: str) -> List[List[int]]: pass ``` # Instructions 1. **Functionality**: You are provided with a function `apply_filter` that, given `image`, a 2D list of integer pixel values (0-255), and `filter_name`, modifies the image according to the specified filter. 2. **Supported Filters**: Implement the following filters: - `\\"invert\\"`: Inverts the grayscale image by transforming each pixel value `p` to `255 - p`. - `\\"lighten\\"`: Lightens the image by increasing each pixel value `p` by 50, up to a maximum of 255. - `\\"darken\\"`: Darkens the image by decreasing each pixel value `p` by 50, down to a minimum of 0. - `\\"threshold\\"`: Converts the image to black and white by setting each pixel value `p` to 255 if `p` > 128, and to 0 otherwise. 3. **Invalid Input Handling**: Ensure the function raises a `ValueError` with a clear message if an invalid filter name is provided. # Expected Input and Output * **Input**: - `image`: A 2D list of integer pixel values (0-255), representing the grayscale image. - `filter_name`: A string representing the filter to be applied (e.g., \\"invert\\", \\"lighten\\"). * **Output**: - A 2D list of integer pixel values (0-255) representing the modified image after applying the specified filter. # Constraints 1. The `image` width and height will be between 1 and 1000 pixels. 2. Pixel values are always within the range 0-255. 3. The `filter_name` will be one of the supported filters exactly as specified or an invalid string. # Example ```python >>> image = [ [0, 100, 200], [50, 150, 250] ] >>> apply_filter(image, \\"invert\\") [[255, 155, 55], [205, 105, 5]] >>> apply_filter(image, \\"lighten\\") [[50, 150, 250], [100, 200, 255]] >>> apply_filter(image, \\"darken\\") [[0, 50, 150], [0, 100, 200]] >>> apply_filter(image, \\"threshold\\") [[0, 0, 255], [0, 255, 255]] ``` # Note Ensure that the function handles all specified filters accurately and raises informative errors for invalid filter names.","solution":"from typing import List def apply_filter(image: List[List[int]], filter_name: str) -> List[List[int]]: if filter_name not in {\\"invert\\", \\"lighten\\", \\"darken\\", \\"threshold\\"}: raise ValueError(f\\"Invalid filter name: {filter_name}\\") if filter_name == \\"invert\\": return [[255 - pixel for pixel in row] for row in image] if filter_name == \\"lighten\\": return [[min(pixel + 50, 255) for pixel in row] for row in image] if filter_name == \\"darken\\": return [[max(pixel - 50, 0) for pixel in row] for row in image] if filter_name == \\"threshold\\": return [[255 if pixel > 128 else 0 for pixel in row] for row in image]"},{"question":"# Task In this task, you need to create a function called `evaluate_polynomial` that evaluates a multi-variable polynomial given a specific set of variable values. Additionally, you need to implement a function called `test_evaluate_polynomial` to verify that the solution is correct by comparing outputs for test cases. # Requirements: * Implement `evaluate_polynomial`: - To calculate the value of a polynomial with given coefficients and variable values. - The polynomial is represented as a dictionary where keys are tuples representing the degrees of each variable, and values are the coefficients. - The variables are given as a list of values `[x1, x2, x3, ..., xn]`. * Implement `test_evaluate_polynomial`: - To test `evaluate_polynomial` with predefined test cases. - Print the expected and actual output for each test case. # Input Format: - `polynomial_terms`: A dictionary where keys are tuples representing the degrees of each variable, and values are the coefficients. - `variables`: A list of variable values. # Output Format: - For each test case in `test_evaluate_polynomial`, print the expected value and the computed value using evaluate_polynomial. # Example Usage: Given: ```python polynomial_terms = { (2, 1): 3, (1, 0): -4, (0, 1): 2, (0, 0): 5 } variables = [1, 2] ``` The polynomial can be represented as: ``` 3x1^2 * x2 + (-4)x1 + 2x2 + 5 ``` After running `evaluate_polynomial` function, the output might be: ```python The evaluated polynomial value: 6 ``` Given predefined test cases in `test_evaluate_polynomial`, the output might be: ```python Test Case 1: Expected value: 6 Computed value: 6 Test Case 2: Expected value: 15 Computed value: 15 ``` Implement the functions `evaluate_polynomial` and `test_evaluate_polynomial` to verify that your solution works correctly.","solution":"def evaluate_polynomial(polynomial_terms, variables): Evaluate a multi-variable polynomial. :param polynomial_terms: Dictionary where keys are tuples representing the degrees of each variable, and values are the coefficients. :param variables: List of variable values [x1, x2, ..., xn]. :return: Evaluated polynomial value. result = 0 for exponents, coefficient in polynomial_terms.items(): term_value = coefficient for i, exponent in enumerate(exponents): term_value *= variables[i] ** exponent result += term_value return result"},{"question":"# Palindrome Permutation Check A palindrome is a word or phrase that reads the same forward and backward, ignoring spaces, punctuation, and case. A permutation of a string is any arrangement of its characters. Given a string, determine if any permutation of it is a palindrome. Part 1: Check for Palindrome Permutation Implement the function `can_form_palindrome(s: str) -> bool` that checks if any permutation of the input string can form a palindrome. # Input * `s` (str): A string containing alphanumeric characters and spaces. # Output * `True` if any permutation of the input can form a palindrome, `False` otherwise. # Example ```python >>> can_form_palindrome(\\"Tact Coa\\") True # Permutations: \\"taco cat\\", \\"atco cta\\", etc. >>> can_form_palindrome(\\"Hello\\") False # No permutation can form a palindrome ``` Part 2: Generate Palindromic Permutation (Optional) If the string can form a palindrome, implement the function `generate_palindrome(s: str) -> str` that returns one possible palindromic permutation of the input string. If no permutation can form a palindrome, return an empty string. # Input * `s` (str): A string containing alphanumeric characters and spaces. # Output * A palindromic permutation of the input string, or an empty string if none is possible. # Example ```python >>> generate_palindrome(\\"Tact Coa\\") \'taco cat\' # One possible palindromic permutation >>> generate_palindrome(\\"Hello\\") \'\' # No permutation can form a palindrome ``` Constraints * Ignore spaces and consider characters case-insensitively for palindromic permutations. * Only consider alphanumeric characters for forming palindromes. Performance Requirements * Aim for O(n) time complexity, where `n` is the length of the input string, for checking if a palindrome permutation is possible. * The optional function for generating a palindromic permutation can have a higher complexity. ```python def can_form_palindrome(s: str) -> bool: # Your code here def generate_palindrome(s: str) -> str: # Your code here ```","solution":"def can_form_palindrome(s: str) -> bool: Determine if any permutation of the input string can form a palindrome. :param s: Input string containing alphanumeric characters and spaces :return: True if any permutation of the input can form a palindrome, False otherwise import collections # Normalize the string: remove spaces and convert to lowercase s = \'\'.join(filter(str.isalnum, s)).lower() # Count the frequency of each character char_count = collections.Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1 def generate_palindrome(s: str) -> str: Generate one possible palindromic permutation of the input string if possible. :param s: Input string containing alphanumeric characters and spaces :return: A palindromic permutation of the input string, or an empty string if none is possible if not can_form_palindrome(s): return \\"\\" import collections # Normalize the string: remove spaces and convert to lowercase s = \'\'.join(filter(str.isalnum, s)).lower() char_count = collections.Counter(s) half_palindrome = [] middle_char = \'\' # Build the half palindrome and identify the middle character if present for char, count in char_count.items(): half_palindrome.append(char * (count // 2)) if count % 2 == 1: middle_char = char half_palindrome = \'\'.join(half_palindrome) # Construct the full palindrome return half_palindrome + middle_char + half_palindrome[::-1]"},{"question":"# Problem Statement Create a class called `ItemTracker` that helps manage a collection of unique items and track their statuses in an efficient way. Each item has a unique identifier (string) and a status (boolean that represents whether the item is active or inactive). Implement the following methods for the `ItemTracker` class: 1. **`__init__`**: - Initialize a data structure to store items and their statuses. 2. **`add_item`**: - Given an item identifier (string), add the item to the tracker with a default status of `True` (active). - Raise an error if the item already exists in the tracker. 3. **`remove_item`**: - Given an item identifier (string), remove the item from the tracker. - Raise an error if the item does not exist in the tracker. 4. **`update_status`**: - Given an item identifier (string) and a status (boolean), update the status of the given item. - Raise an error if the item does not exist in the tracker. 5. **`list_active`**: - Return a list of all item identifiers that have a status of `True` (active). 6. **`find_item`**: - Given an item identifier (string), return the status (`True` or `False`) of the item. - Return `None` if the item does not exist in the tracker. # Requirements - Ensure efficient operations for adding, removing, and updating items. - The operations `add_item`, `remove_item`, and `update_status` should have an average time complexity of O(1). - The `list_active` method should return the active items in the order they were added. - Use appropriate data structures to manage the items and their statuses. # Example Usage ```python tracker = ItemTracker() tracker.add_item(\\"item1\\") tracker.add_item(\\"item2\\") tracker.add_item(\\"item3\\") assert tracker.find_item(\\"item1\\") == True tracker.update_status(\\"item1\\", False) assert tracker.find_item(\\"item1\\") == False assert tracker.list_active() == [\\"item2\\", \\"item3\\"] tracker.remove_item(\\"item2\\") assert tracker.list_active() == [\\"item3\\"] try: tracker.add_item(\\"item3\\") # This should raise an error because \'item3\' already exists. except ValueError as e: print(e) # Output: Item already exists in the tracker. tracker.remove_item(\\"item1\\") # \'item1\' is now removed from the tracker. assert tracker.find_item(\\"item1\\") == None ``` # Testing - Write thorough tests to cover all possible scenarios, including adding, removing, updating the status of items, and fetching the list of active items. - Make sure to include edge cases such as attempting to update or remove non-existent items.","solution":"class ItemTracker: def __init__(self): self.items = {} # Dictionary to store items and their statuses self.active_items = [] # List to keep track of the order of active items def add_item(self, identifier): if identifier in self.items: raise ValueError(\\"Item already exists in the tracker.\\") self.items[identifier] = True self.active_items.append(identifier) def remove_item(self, identifier): if identifier not in self.items: raise KeyError(\\"Item does not exist in the tracker.\\") if self.items[identifier]: # Only remove from active_items if it was active self.active_items.remove(identifier) self.items.pop(identifier) def update_status(self, identifier, status): if identifier not in self.items: raise KeyError(\\"Item does not exist in the tracker.\\") if self.items[identifier] != status: self.items[identifier] = status if status: # If setting to active self.active_items.append(identifier) else: # If setting to inactive self.active_items.remove(identifier) def list_active(self): return self.active_items def find_item(self, identifier): return self.items.get(identifier)"},{"question":"# Coding Assessment Question Context A blockchain is a growing list of records, called blocks, linked using cryptography. Each block contains a timestamp, a reference to the previous block, and transaction data. For simplicity, we\'ll focus on a single aspect of blockchain validation — ensuring that the hash of each block correctly incorporates the given nonce into the SHA-256 hash of its content. Task Implement a function `is_blockchain_valid(blocks: List[Dict[str, Any]]) -> bool` that verifies the integrity of a given blockchain by ensuring each block\'s SHA-256 hash is consistent with its content, incorporating the nonce, and that each block correctly references the hash of the previous block. Function Signature ```python from typing import List, Dict, Any import hashlib def is_blockchain_valid(blocks: List[Dict[str, Any]]) -> bool: pass ``` Input * `blocks`: A list of dictionaries, where each dictionary represents a block with the following keys: * `index`: An integer that represents the position of the block in the blockchain. * `timestamp`: A string representing the time the block was created. * `data`: A string of transaction data. * `nonce`: An integer used once in the cryptographic hash. * `previous_hash`: The hash of the previous block as a string. * `hash`: The SHA-256 hash of the current block including its `index`, `timestamp`, `data`, and `nonce`. Output * Returns `True` if the blockchain is valid. Returns `False` otherwise. Examples ```python blocks = [ { \\"index\\": 0, \\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"data\\": \\"Genesis Block\\", \\"nonce\\": 100, \\"previous_hash\\": \\"0\\", \\"hash\\": \\"6a09e667f3bcc9089deaf196c1bb4e9fe41e9748256173180800fc5f62e5f1b2\\" }, { \\"index\\": 1, \\"timestamp\\": \\"2023-01-02T00:00:00\\", \\"data\\": \\"Block 2\\", \\"nonce\\": 200, \\"previous_hash\\": \\"6a09e667f3bcc9089deaf196c1bb4e9fe41e9748256173180800fc5f62e5f1b2\\", \\"hash\\": \\"a7dcd71db153b1d7fa84d5b83826d18f544b62a92829cdc873d9a2672c1ad133\\" } ] assert is_blockchain_valid(blocks) == True blocks[1][\'nonce\'] = 300 # Tampering with the nonce assert is_blockchain_valid(blocks) == False ``` Constraints * Number of blocks in the blockchain should not exceed (10^5). * Each string field (`timestamp`, `data`, `previous_hash`, and `hash`) will be no longer than 255 characters. * You may assume that each `nonce` is a valid non-negative integer and the `index` keys are consecutive integers starting from 0. Performance Requirements * Ensure your implementation is efficient and runs with a time complexity of O(n) where n is the number of blocks. * The space complexity should be O(1), i.e., using constant extra space aside from the blocks list.","solution":"from typing import List, Dict, Any import hashlib def sha256_hash(data: str) -> str: return hashlib.sha256(data.encode()).hexdigest() def is_blockchain_valid(blocks: List[Dict[str, Any]]) -> bool: for i, block in enumerate(blocks): # Validate the hash of the current block block_content = f\\"{block[\'index\']}{block[\'timestamp\']}{block[\'data\']}{block[\'nonce\']}\\" expected_hash = sha256_hash(block_content) if block[\'hash\'] != expected_hash: return False # Validate the previous_hash link if i > 0 and block[\'previous_hash\'] != blocks[i - 1][\'hash\']: return False return True"},{"question":"# Problem Statement You are provided with a dictionary representing product inventories, where keys are product names and values are their respective quantities. Your task is to implement an `update_inventory` function that updates the inventory based on a list of sales transactions. Each transaction will either increase or decrease the quantity of a specific product. Function Signature ```python def update_inventory(inventory: dict[str, int], transactions: list[tuple[str, int]]) -> dict[str, int]: pass ``` # Input * **inventory**: A dictionary where keys are product names (strings) and values are their quantities (integers). * **transactions**: A list of tuples where each tuple contains a product name (string) and a quantity change (integer). # Output * **Return the updated inventory**: A dictionary with the same structure as the input inventory, reflecting the changes specified by the transactions. # Constraints * Each product name in the inventory is unique. * Transactions can contain product names not initially present in the inventory. For such products, if a transaction indicates a positive change, they should be added to the inventory with the specified quantity. Negative changes for non-existing products should be ignored. * The quantities in the inventory can be negative if the reduction specified by a transaction exceeds the current available quantity. # Example ```python # Input inventory = {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 8} transactions = [(\\"apple\\", -3), (\\"banana\\", 2), (\\"grape\\", 10), (\\"orange\\", -10), (\\"pear\\", -5)] # Output {\\"apple\\": 7, \\"banana\\": 7, \\"orange\\": -2, \\"grape\\": 10} ``` # Performance Requirements Your solution should handle up to `10^5` transactions efficiently. # Context You are developing a system for a retail store that needs to maintain accurate inventory levels. The store tracks sales and restocks continuously, and you need to ensure the inventory reflects these changes correctly. Note: Do **not** use any external libraries/modules for dictionary manipulation beyond what is provided by Python. Implement the logic yourself based on the principles of dictionary manipulation and basic arithmetic operations.","solution":"def update_inventory(inventory: dict[str, int], transactions: list[tuple[str, int]]) -> dict[str, int]: Updates the inventory dictionary based on the list of transactions. for product, change in transactions: if product in inventory: inventory[product] += change else: if change > 0: inventory[product] = change # Remove items with zero quantity inventory = {k: v for k, v in inventory.items() if v != 0} return inventory"},{"question":"# Question: Implement a Function to Merge Two Sorted Lists You are given two sorted lists of integers. Your task is to implement a function that merges these two lists into a single sorted list in ascending order. **Input**: 1. Two sorted lists of integers, `list1` and `list2`. **Output**: - A single list containing all the elements from `list1` and `list2`, sorted in ascending order. **Function Signature**: ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Constraints: 1. The input lists `list1` and `list2` will each contain at most 10^6 elements. 2. All elements in the lists are integers (not necessarily distinct). # Example: ```python >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 8, 10] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], [7, 8, 9]) [7, 8, 9] >>> merge_sorted_lists([], []) [] ``` # Explanation: - The first example returns a merged and sorted list of `[1, 2, 3, 4, 5, 6, 7, 8]`. - The second example returns a merged and sorted list of `[1, 2, 3, 4, 5, 6, 8, 10]`. - The third example returns a sorted list containing the elements of `list1` since `list2` is empty. - The fourth example returns a sorted list containing the elements of `list2` since `list1` is empty. - The fifth example returns an empty list because both `list1` and `list2` are empty. Make sure your implementation is optimized for time complexity and can handle the constraints efficiently. Test your function using various edge cases to ensure its correctness.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements from list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements from list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement: You need to develop a Python script that interacts with a weather API to fetch current weather data for a given city. The resulting data should be printed to the console and optionally saved to a file if a filename is provided. Your function should handle edge cases such as invalid API keys or network issues gracefully. # Function Signature: ```python def fetch_and_save_weather_data(api_key: str, city: str, filename: Optional[str] = None) -> None: Fetches current weather data for the specified city and prints the details. Optionally, saves the data to a provided file. Parameters: api_key (str): Weather API key. city (str): Name of the city to fetch weather data for. filename (Optional[str]): Name of the file to save the weather data. Default is None. Raises: ValueError: If `api_key` is blank or invalid. IOError: If there is an error while writing to the file. ``` # Input: - `api_key`: A string representing the API key for the weather API service. - `city`: A string representing the name of the city to fetch weather data for. - `filename`: An optional string representing the name of the file where to save the weather data. If not provided, data will not be saved to a file. # Output: - None (Details should be printed to the console and optionally saved to the provided file). # Example Invocation: ```python # Fetch weather data for the city \'London\' and save to \'weather.txt\' fetch_and_save_weather_data(\'your_api_key_here\', \'London\', \'weather.txt\') # Fetch weather data for the city \'Tokyo\' and print to the console only fetch_and_save_weather_data(\'your_api_key_here\', \'Tokyo\') ``` # Constraints: 1. **API Key Handling**: The function should raise a `ValueError` if `api_key` is blank. 2. **Error Handling**: Gracefully handle cases where the city is not found or there\'s a network failure. Include retries for transient network issues. 3. **File Operations**: Ensure proper writing to files only if a filename is provided. Handle file I/O errors appropriately. 4. **Performance**: Optimize network calls to avoid unnecessary delays while fetching weather data efficiently. Use the following Weather API endpoint for fetching current weather data: ``` https://api.openweathermap.org/data/2.5/weather?q=<city>&appid=<api_key> ``` # Notes: * **Authentication will be made via the API key**. The function should include the key in the request URL. * Do not hardcode the filename; pass it as a function argument. * Include comments and document the code thoroughly to explain the logic and error handling involved including how to interact with the web API and handle different types of errors (e.g., city not found, invalid API key, network issues).","solution":"import requests from typing import Optional def fetch_and_save_weather_data(api_key: str, city: str, filename: Optional[str] = None) -> None: Fetches current weather data for the specified city and prints the details. Optionally, saves the data to a provided file. Parameters: api_key (str): Weather API key. city (str): Name of the city to fetch weather data for. filename (Optional[str]): Name of the file to save the weather data. Default is None. Raises: ValueError: If `api_key` is blank or invalid. IOError: If there is an error while writing to the file. if not api_key: raise ValueError(\\"API key is required and cannot be blank.\\") url = f\\"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\\" try: response = requests.get(url) response.raise_for_status() except requests.exceptions.RequestException as e: print(f\\"Error fetching data from the API: {e}\\") return data = response.json() if data.get(\\"cod\\") != 200: print(f\\"Error fetching weather data for city: {data.get(\'message\')}\\") return weather_info = { \\"city\\": data[\\"name\\"], \\"temperature\\": data[\\"main\\"][\\"temp\\"], \\"weather\\": data[\\"weather\\"][0][\\"description\\"], \\"humidity\\": data[\\"main\\"][\\"humidity\\"] } print_weather_info(weather_info) if filename: try: with open(filename, \'w\') as file: file.write(str(weather_info)) except IOError as e: print(f\\"Error writing to file: {e}\\") def print_weather_info(weather_info: dict) -> None: Prints weather information to the console. Parameters: weather_info (dict): A dictionary containing weather information. print(f\\"Current weather in {weather_info[\'city\']}:\\") print(f\\"Temperature: {weather_info[\'temperature\']} Kelvin\\") print(f\\"Weather: {weather_info[\'weather\']}\\") print(f\\"Humidity: {weather_info[\'humidity\']}%\\")"},{"question":"# Coding Assessment Question Context You are developing a library of utility functions for string manipulation. One of the common tasks in text processing is to compress strings by eliminating consecutive duplicate characters. Task Implement a function that compresses a given string by replacing consecutive duplicate characters with a single instance of that character. This can help in scenarios where you need to remove needless redundancy in text. Requirements 1. **Function Definition**: Implement a function named `compress_string`. 2. **Input**: A string consisting of ASCII characters. 3. **Output**: A string where consecutive duplicate characters are reduced to a single instance. 4. **Constraints**: * Consider both uppercase and lowercase letters, as well as any non-alphabetical characters. * The function should handle edge cases such as an empty string or a string with no consecutive duplicates. 5. **Efficiency**: The implementation should operate in O(n) time complexity, where n is the length of the input string. Function Signature ```python def compress_string(s: str) -> str: pass ``` Example 1. Input: `\\"\\"` Output: `\\"\\"` 2. Input: `\\"aabcccccaaa\\"` Output: `\\"abcabc\\"` 3. Input: `\\"abcdef\\"` Output: `\\"abcdef\\"` 4. Input: `\\"AAABBBccDD\\"` Output: `\\"ABcD\\"` 5. Input: `\\"aaaAAA\\"` Output: `\\"aA\\"` Testing * Ensure to test your string compression implementation with a variety of test cases, including edge cases with special characters and different casing. * Compare the output with the expected results for validation.","solution":"def compress_string(s: str) -> str: Compress the given string by reducing consecutive duplicate characters to a single instance. Parameters: s (str): The input string. Returns: str: The compressed string with no consecutive duplicate characters. if not s: return s compressed = [s[0]] # Start with the first character for char in s[1:]: if char != compressed[-1]: # Add only if different from the last character in compressed compressed.append(char) return \\"\\".join(compressed)"},{"question":"# Problem Statement You are given an array of integers where some integers appear twice and others appear once. Your task is to implement a function that returns all the distinct integers that appear twice in the array. # Requirements * Implement a function `find_duplicates(nums: List[int]) -> List[int]` that returns a sorted list of distinct integers that appear exactly twice in the given array. # Function Definitions ```python def find_duplicates(nums: List[int]) -> List[int]: # Your code here ``` # Input/Output Examples ```python assert find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] assert find_duplicates([1, 1, 2]) == [1] assert find_duplicates([]) == [] assert find_duplicates([1, 2, 3, 4, 5]) == [] assert find_duplicates([10, 10, 20, 20, 30, 30, 30]) == [10, 20, 30] ``` # Constraints * The length of the array, `len(nums)`, will be between (0) and (10^4). * Each integer in the array will be in the range (-10^5 leq text{nums[i]} leq 10^5). # Additional Context Identifying and handling duplicate values in an array is a common task in data processing and database management. This problem helps in practicing the use of data structures like sets or hash maps, which are typical tools for solving such problems efficiently.","solution":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Returns a sorted list of distinct integers that appear exactly twice in the given array. num_count = {} # Count the occurrences of each number for num in nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 # Collect numbers that appear exactly twice duplicates = [num for num, count in num_count.items() if count == 2] # Return sorted list of duplicates return sorted(duplicates)"},{"question":"# Task Create a function `analyze_words` that takes a passage of text as input and returns a dictionary containing the count of each unique word in the passage. The function should ignore case and punctuation, and account for edge cases such as empty strings or strings with no words. # Function Signature ```python def analyze_words( passage: str ) -> dict[str, int]: ``` # Input * `passage`: A string variable containing a block of text. # Output * Returns a dictionary where the keys are unique words (in lowercase) and the values are the counts of those words in the input passage. # Constraints * The input text (`passage`) will contain only standard printable ASCII characters, punctuation marks, and whitespace. * Words are separated by spaces or punctuated, and punctuation should not be counted as part of the word. # Requirements Your solution should: * Convert all words to lowercase. * Remove punctuation marks from the word boundaries. * Handle empty strings and return an empty dictionary. * Be efficient in terms of time and space complexity. # Examples ```python >>> analyze_words(\\"Hello, world! Hello.\\") {\'hello\': 2, \'world\': 1} >>> analyze_words(\\"A journey of a thousand miles begins with a single step.\\") {\'a\': 3, \'journey\': 1, \'of\': 1, \'thousand\': 1, \'miles\': 1, \'begins\': 1, \'with\': 1, \'single\': 1, \'step\': 1} >>> analyze_words(\\"\\") {} >>> analyze_words(\\"To be, or not to be; that is the question.\\") {\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1, \'that\': 1, \'is\': 1, \'the\': 1, \'question\': 1} ``` # Notes * Ensure that common punctuation marks (e.g., periods, commas, semicolons) are properly handled and not included in the word counts. * Consider edge cases such as passages with special characters or continuous punctuation. * Provide clear and meaningful error messages where necessary.","solution":"import re from collections import defaultdict def analyze_words(passage: str) -> dict[str, int]: Analyzes the given text passage and returns the count of each unique word in the passage. The function is case-insensitive and ignores punctuation. :param passage: A string variable containing a block of text. :return: A dictionary where keys are unique words (in lowercase) and values are their counts. # Normalize the passage: convert to lowercase and remove punctuation using regex passage = passage.lower() words = re.findall(r\'bw+b\', passage) # Creating a dictionary to store word counts word_count = defaultdict(int) # Count the frequency of each word for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Traversing a Grid with Movement Constraints You are asked to implement an algorithm to determine if a robot can reach the bottom-right corner of a grid starting from the top-left corner. The grid is represented by a 2D list in which cells may contain obstacles. The robot can move right or down from any cell, but some cells have movement constraints that only allow movement in one specific direction (right or down). Context Consider a grid where: - `0` represents an empty cell the robot can traverse. - `1` represents an obstacle, which the robot cannot traverse. - `2` represents a cell that only allows the robot to move right. - `3` represents a cell that only allows the robot to move down. You need to create a function `can_reach_end(grid: List[List[int]]) -> bool:` that returns `True` if the robot can reach the bottom-right corner and `False` otherwise. Input - `grid` (List[List[int]]): A 2D list of integers representing the grid, where each element can be 0, 1, 2, or 3. Output - A boolean value indicating whether the robot can reach the bottom-right corner of the grid or not. Constraints - The grid will always have at least one cell. - The grid will be a valid rectangular matrix (all rows will have the same number of columns). - The top-left and bottom-right corners will always be empty cells (`0`). - The size of the grid will be at most 100x100. Example Function Calls ```python grid1 = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0] ] print(can_reach_end(grid1)) # Output: True grid2 = [ [0, 0, 1], [1, 0, 1], [1, 0, 0] ] print(can_reach_end(grid2)) # Output: True grid3 = [ [0, 1, 0], [1, 0, 0], [0, 1, 0] ] print(can_reach_end(grid3)) # Output: False grid4 = [ [0, 0, 2], [2, 1, 2], [2, 2, 0] ] print(can_reach_end(grid4)) # Output: False ``` Implement the `can_reach_end` function following the specified input and output formats.","solution":"from typing import List def can_reach_end(grid: List[List[int]]) -> bool: def dfs(x, y): if x == len(grid) - 1 and y == len(grid[0]) - 1: return True if not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or visited[x][y] or grid[x][y] == 1: return False visited[x][y] = True # Moving right if grid[x][y] in (0, 2) and not visited[x][y + 1] if y + 1 < len(grid[0]) else False: if dfs(x, y + 1): return True # Moving down if grid[x][y] in (0, 3) and not visited[x + 1][y] if x + 1 < len(grid) else False: if dfs(x + 1, y): return True return False visited = [[False] * len(grid[0]) for _ in range(len(grid))] return dfs(0, 0)"},{"question":"# Matrix Rotation: 90-Degree Challenge Matrix rotation is a fundamental operation in computer graphics and image processing. In this challenge, you are tasked with rotating a given NxN matrix 90 degrees clockwise. Task: Implement the matrix rotation with two different approaches: 1. A direct element swap approach. 2. An additional helper function approach that extracts rows into a new matrix. You will need to implement three functions: 1. `rotate_in_place(matrix: list[list[int]]) -> None`: Rotates the NxN matrix 90 degrees clockwise by directly swapping elements in place. 2. `extract_new_matrix(matrix: list[list[int]]) -> list[list[int]]`: Creates a new NxN matrix representing the original matrix rotated 90 degrees clockwise. 3. `rotate(matrix: list[list[int]], use_helper: bool) -> list[list[int]]`: Rotates the matrix by calling one of the above two functions based on the `use_helper` flag. Input: * A list of lists `matrix` representing the NxN matrix. * A boolean `use_helper` flag. Output: * Returns the rotated matrix, either in place or a new one based on the `use_helper` flag. Example Usage: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate(matrix, use_helper=True) print(rotated_matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate(matrix, use_helper=False) print(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Constraints: * `1 <= N <= 100` * The input `matrix` will be an NxN grid of integers. Performance: Optimize your implementation to handle larger matrices effectively. Additional Notes: * Ensure your solution handles edge cases such as very small (1x1) and very large (100x100) matrices. * Include tests that cover different matrix sizes and content variations to validate your implementation.","solution":"def rotate_in_place(matrix: list[list[int]]) -> None: Rotates the NxN matrix 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp def extract_new_matrix(matrix: list[list[int]]) -> list[list[int]]: Creates a new NxN matrix representing the original matrix rotated 90 degrees clockwise. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - i - 1] = matrix[i][j] return new_matrix def rotate(matrix: list[list[int]], use_helper: bool) -> list[list[int]]: Rotates the matrix by calling one of the above two functions based on the use_helper flag. if use_helper: return extract_new_matrix(matrix) else: rotate_in_place(matrix) return matrix"},{"question":"# Longest Common Subsequence Problem with Dynamic Programming Objective Given two strings, write a function to find the length of their longest common subsequence using dynamic programming to optimize the solution. Implementation Requirements * Implement a function `longest_common_subsequence(str1: str, str2: str) -> int` that returns the length of the longest common subsequence between the two given strings. * Utilize a dynamic programming approach to build a 2D table that captures the lengths of common subsequences for increasing prefixes of the two strings. Input Format: * `str1` (str): The first input string. * `str2` (str): The second input string. Output Format: * Return an integer value representing the length of the longest common subsequence. Constraints: * Both input strings will have lengths up to 1000 characters. Example: 1. **Input:** ```python str1 = \\"abcde\\" str2 = \\"ace\\" ``` **Output:** ```python 3 ``` 2. **Input:** ```python str1 = \\"abc\\" str2 = \\"def\\" ``` **Output:** ```python 0 ``` 3. **Input:** ```python str1 = \\"abcdefg\\" str2 = \\"bdf\\" ``` **Output:** ```python 3 ``` Implement the function as specified and ensure it handles the input constraints efficiently using dynamic programming.","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. len1, len2 = len(str1), len(str2) # Create a DP table with (len1 + 1) x (len2 + 1) dimensions dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Build the DP table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence is in the bottom-right cell return dp[len1][len2]"},{"question":"# Coding Assessment Question Implement a `merge_sorted` method for the given `LinkedList` class that merges the current sorted linked list with another sorted linked list, producing a single sorted linked list. The resultant linked list should be sorted in ascending order. Function Signature ```python class LinkedList: ... def merge_sorted(self, other: \'LinkedList\') -> \'LinkedList\': Merges the current sorted linked list with another sorted linked list. Parameters: other: Another sorted linked list. Returns: A new LinkedList object representing the merged sorted linked list. Example: >>> ll1 = LinkedList([1, 3, 5]) >>> ll2 = LinkedList([2, 4, 6]) >>> merged_ll = ll1.merge_sorted(ll2) >>> list(merged_ll) == [1, 2, 3, 4, 5, 6] True >>> empty_ll = LinkedList() >>> merged_ll = ll1.merge_sorted(empty_ll) >>> list(merged_ll) == [1, 3, 5] True >>> merged_ll = empty_ll.merge_sorted(empty_ll) >>> list(merged_ll) == [] True pass ``` # Requirements 1. Your implementation should operate in strict O(n + m) time complexity, where n and m are the lengths of the respective linked lists. 2. Handle edge cases where one or both linked lists are empty. 3. The method should not modify the original linked lists; instead, it should return a new linked list that is sorted. # Constraints - The linked lists are assumed to be sorted in ascending order. - Ensure the algorithm efficiently merges the linked lists without the use of additional data structures beyond basic node manipulations. # Example: ```python ll1 = LinkedList([1, 3, 5]) ll2 = LinkedList([2, 4, 6]) merged_ll = ll1.merge_sorted(ll2) print(list(merged_ll)) # Output: [1, 2, 3, 4, 5, 6] empty_ll = LinkedList() merged_ll = ll1.merge_sorted(empty_ll) print(list(merged_ll)) # Output: [1, 3, 5] merged_ll = empty_ll.merge_sorted(empty_ll) print(list(merged_ll)) # Output: [] ```","solution":"class LinkedList: class Node: def __init__(self, value=None): self.value = value self.next = None def __init__(self, values=None): self.head = None if values: for value in values: self.append(value) def append(self, value): new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __iter__(self): current = self.head while current: yield current.value current = current.next def merge_sorted(self, other: \'LinkedList\') -> \'LinkedList\': dummy_head = self.Node() current = dummy_head p1, p2 = self.head, other.head while p1 and p2: if p1.value < p2.value: current.next = self.Node(p1.value) p1 = p1.next else: current.next = self.Node(p2.value) p2 = p2.next current = current.next while p1: current.next = self.Node(p1.value) p1 = p1.next current = current.next while p2: current.next = self.Node(p2.value) p2 = p2.next current = current.next merged_linked_list = LinkedList() merged_linked_list.head = dummy_head.next return merged_linked_list"},{"question":"Problem Statement: Age-Grouped Employee Salary Analysis You are given a file containing employee data in CSV format. Each line contains information about an employee in the following format: `name,age,salary` (e.g., `John Doe,34,55000`). Your task is to calculate the average salary of employees grouped by their age group. The age groups are defined as follows: - Group 20-29: Employees aged 20 to 29 - Group 30-39: Employees aged 30 to 39 - Group 40-49: Employees aged 40 to 49 - Group 50-59: Employees aged 50 to 59 - Group 60+: Employees aged 60 or older # Detailed Steps: 1. **Read Data**: Read the employee data from the file named `employees.csv`. 2. **Process Data**: Parse the CSV data to extract information about each employee. 3. **Group by Age**: Classify employees into their respective age groups. 4. **Calculate Average Salary for Each Group**: * Sum the salaries of employees in each age group. * Divide the total salary of each group by the number of employees in that group. 5. **Return Results**: Output a dictionary where the key is the age group and the value is the average salary rounded to two decimal places. # Constraints: - The file `employees.csv` will be available in the same directory as the script. - Each employee entry in the file is valid and formatted correctly. - Age will always be a positive integer. # Function Signature: ```python def age_group_salary(file_path: str) -> dict: Calculate the average salary for each age group from the provided file. :param file_path: A string representing the path to the file containing employee data. :return: A dictionary where keys are age groups as strings and values are average salaries. ``` # Input: - `file_path`: A string representing the relative or absolute path to the `employees.csv` file. # Output: - A dictionary where the keys are strings representing age groups (e.g., \\"20-29\\", \\"30-39\\") and the values are floats representing the average salary of employees in that age group, rounded to two decimal places. # Example: Assuming the file `employees.csv` contains: ``` John Doe,34,55000 Jane Smith,28,48000 Alice Johnson,44,78000 Bob Brown,32,62000 ``` The function should return: ```python { \\"20-29\\": 48000.0, \\"30-39\\": 58500.0, \\"40-49\\": 78000.0, \\"50-59\\": 0.0, \\"60+\\": 0.0 } ``` # Implementation: Implement the `age_group_salary` function using the provided guidelines.","solution":"import csv def age_group_salary(file_path: str) -> dict: age_groups = { \\"20-29\\": [], \\"30-39\\": [], \\"40-49\\": [], \\"50-59\\": [], \\"60+\\": [] } with open(file_path, newline=\'\') as csvfile: reader = csv.reader(csvfile) for row in reader: name, age, salary = row age = int(age) salary = float(salary) if 20 <= age <= 29: age_groups[\\"20-29\\"].append(salary) elif 30 <= age <= 39: age_groups[\\"30-39\\"].append(salary) elif 40 <= age <= 49: age_groups[\\"40-49\\"].append(salary) elif 50 <= age <= 59: age_groups[\\"50-59\\"].append(salary) elif age >= 60: age_groups[\\"60+\\"].append(salary) avg_salaries = {} for group, salaries in age_groups.items(): if salaries: avg_salary = sum(salaries) / len(salaries) else: avg_salary = 0.0 avg_salaries[group] = round(avg_salary, 2) return avg_salaries"},{"question":"# Context: As a new hire in a robotics company, you\'re tasked with programming a sequence generator for a robot\'s movement. The robot moves according to a pattern defined by a sequence of letters (N, S, E, W) representing North, South, East, and West. Each letter specifies a step in a particular direction. # Problem Statement: Write a Python function `generate_movement_sequence(n: int, pattern: str) -> str` that generates a movement sequence for the robot. The sequence should repeat the given pattern `n` times and return the result as a single string. # Inputs: - `n (int)`: Number of times to repeat the pattern. - `pattern (string)`: A string of characters (N, S, E, W) representing the movement pattern. # Outputs: - A single string showing the repeated movement pattern. # Constraints: - `1 <= n <= 1000` - `1 <= len(pattern) <= 100` - Pattern will only contain the characters \'N\', \'S\', \'E\', \'W\'. # Example: ```python def generate_movement_sequence(n: int, pattern: str) -> str: pass # An example of the function in use: print(generate_movement_sequence(3, \\"NSE\\")) # Output: \\"NSENSENSE\\" print(generate_movement_sequence(2, \\"EWNS\\")) # Output: \\"EWNSEWNS\\" ``` # Notes: - The function should be efficient in handling large inputs. - Ensure the pattern is concatenated correctly without any spaces or additional characters.","solution":"def generate_movement_sequence(n: int, pattern: str) -> str: Generates a movement sequence by repeating the given pattern n times. Parameters: n (int): Number of times to repeat the pattern. pattern (str): The movement pattern containing \'N\', \'S\', \'E\', \'W\'. Returns: str: The repeated movement pattern as a single string. return pattern * n"},{"question":"# Question: Implementing a LinkedList Data Structure with Custom Operations Context You have been provided with a basic structure for a singly linked list. Your task is to enhance this data structure by adding custom operations that are frequently used in various applications. Task 1. Enhance the given `LinkedList` class by implementing three additional methods: - `insert_after_value(value, new_value)`: Inserts a new node with `new_value` after the first node that contains `value`. - `remove_by_value(value)`: Removes the first occurrence of the node that contains `value`. - `reverse()`: Reverses the entire linked list in place. 2. Demonstrate the functionality of these methods by performing a sequence of operations on a given linked list and printing the list after each operation to verify correctness. Requirements * **Data Structure Specification**: You will work with a singly linked list where each node contains a value and a reference to the next node. * **Input/Output**: - The `insert_after_value()` method will take the value to search for and the new value to insert. - The `remove_by_value()` method will take the value to be removed. - The `reverse()` method will take no parameters but will reverse the list in place. * **Constraints**: - The list will always contain integer values. - You can assume no duplicate values for simplicity. * **Performance**: - The methods should handle operations efficiently to maintain the overall time complexity as optimal as possible. # Example ```python class Node: def __init__(self, value: int) -> None: self.value = value self.next = None class LinkedList: def __init__(self) -> None: self.head = None def append(self, value: int) -> None: if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def insert_after_value(self, value: int, new_value: int) -> None: current = self.head while current and current.value != value: current = current.next if current: new_node = Node(new_value) new_node.next = current.next current.next = new_node def remove_by_value(self, value: int) -> None: if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def reverse(self) -> None: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def print_list(self) -> None: current = self.head values = [] while current: values.append(current.value) current = current.next print(values) # Example usage: ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) ll.append(5) ll.print_list() # Output: [1, 2, 3, 4, 5] ll.insert_after_value(3, 6) ll.print_list() # Output: [1, 2, 3, 6, 4, 5] ll.remove_by_value(2) ll.print_list() # Output: [1, 3, 6, 4, 5] ll.reverse() ll.print_list() # Output: [5, 4, 6, 3, 1] ```","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.next = None class LinkedList: def __init__(self) -> None: self.head = None def append(self, value: int) -> None: if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def insert_after_value(self, value: int, new_value: int) -> None: current = self.head while current and current.value != value: current = current.next if current: new_node = Node(new_value) new_node.next = current.next current.next = new_node def remove_by_value(self, value: int) -> None: if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def reverse(self) -> None: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self) -> list: current = self.head values = [] while current: values.append(current.value) current = current.next return values"},{"question":"# Question: Implement Word Frequency Counter Scenario: You are a software developer tasked with analyzing text data. One of the requirements is to gather word frequency statistics from a given piece of text. You need to write a function that counts the occurrences of each distinct word and returns the statistics in a sorted order. Task: Write a function `word_frequency(text: str) -> dict` that accepts a string of text and returns a dictionary where keys are words and values are their corresponding counts. The words in the dictionary should be sorted alphabetically. Function Signature: ```python def word_frequency(text: str) -> dict: pass ``` Input: * `text` (str): A string of text which can contain letters, numbers, and punctuation. Output: * Returns: A dictionary where words are keys and their counts are values, sorted alphabetically by the words. Constraints: * Ignore case differences (e.g., \\"word\\" and \\"Word\\" should be counted as the same word). * Words are defined as sequences of alphabetic characters. Non-alphabetic characters should be treated as word boundaries. * The result should be efficient in terms of both time and space complexities. Example: ```python >>> word_frequency(\\"Simple example of a simple text!\\") {\'a\': 1, \'example\': 1, \'of\': 1, \'simple\': 2, \'text\': 1} >>> word_frequency(\\"Hello, world! Hello!\\") {\'hello\': 2, \'world\': 1} >>> word_frequency(\\"Python is great, and programming in Python is fun.\\") {\'and\': 1, \'fun\': 1, \'great\': 1, \'in\': 1, \'is\': 2, \'programming\': 1, \'python\': 2} ``` Hints: * Use regular expressions to split the text into words. * Convert words to the same case (e.g., lowercase) for counting. * Utilize collections such as `defaultdict` from the `collections` module to simplify counting.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Returns a dictionary with word frequency count from the given text. The dictionary keys are words and values are their counts, sorted alphabetically. Parameters: text (str): The input text string. Returns: dict: A dictionary with words as keys and their counts as values. # Use regex to extract words, considering only alphabetic characters words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Create a defaultdict to store word counts freq_dict = defaultdict(int) # Count occurrences of each word for word in words: freq_dict[word] += 1 # Sort the dictionary and return return dict(sorted(freq_dict.items()))"},{"question":"# List Rotation Checker Problem Statement: Given two lists `A` and `B` of integers, your task is to determine if one list is a rotation of the other. A list `A` is a rotation of list `B` if it contains the same elements in the same order, but can start from any index and wrap around to the beginning. Input: - Two lists of integers `A` and `B`. Both lists have the same length (1 <= len(A) == len(B) <= 10^5). Output: - Return `True` if list `A` is a rotation of list `B`, otherwise return `False`. Example: ```python is_rotation([1, 2, 3, 4], [3, 4, 1, 2]) # Output: True is_rotation([1, 2, 3, 4], [4, 3, 2, 1]) # Output: False is_rotation([1], [1]) # Output: True ``` Constraints: - Consider edge cases where the lists may contain repeated elements. - Ensure your solution is efficient and handles large lists within reasonable time limits. Implementation Requirements: - Utilize concatenation and substring search techniques to check for rotations efficiently. Starter Code: ```python def is_rotation(A: list, B: list) -> bool: Determine if list A is a rotation of list B. :param A: list: the first list of integers :param B: list: the second list of integers :return: bool: True if A is a rotation of B, False otherwise if len(A) != len(B): return False # Concatenate list A with itself and check if B is a substring concatenate_A = A + A return str(B).strip(\'[]\') in str(concatenate_A).strip(\'[]\') # Example usage: if __name__ == \\"__main__\\": A = list(map(int, input(\\"Enter list A: \\").strip().split())) B = list(map(int, input(\\"Enter list B: \\").strip().split())) result = is_rotation(A, B) print(f\\"List A is {\'a\' if result else \'not a\'} rotation of List B.\\") ```","solution":"def is_rotation(A: list, B: list) -> bool: Determine if list A is a rotation of list B. :param A: The first list of integers :param B: The second list of integers :return: True if A is a rotation of B, False otherwise if len(A) != len(B): return False if not A: return True concatenate_A = A + A return any(concatenate_A[i:i+len(B)] == B for i in range(len(A)))"},{"question":"# Product Recommendation System You are tasked with building a simplified product recommendation system based on user purchase history. Your goal is to suggest products based on what other users, who bought similar items, have also bought. # Problem Statement Given a user\'s purchase history and a list of all purchases by various users, write a function `recommend_products(user_history: list[str], all_purchases: list[list[str]]) -> list[str]` that returns a list of recommended products. # Function Signature ```python def recommend_products(user_history: list[str], all_purchases: list[list[str]]) -> list[str]: pass ``` # Input * `user_history` (`list[str]`): A list of product IDs that the target user has purchased. * `all_purchases` (`list[list[str]]`): A list of lists, where each inner list represents the products purchased by a different user. # Output * `list[str]`: A list of product IDs recommended to the user based on the purchase history of other users. The recommended products should be sorted in descending order of how frequently they appear in the purchase history of other users who have at least one product in common with the target user. # Constraints * Each product ID is a string of alphanumeric characters. * Each user has purchased at least one product. * The number of users (1 leq text{len(all_purchases)} leq 10^5). * The number of products (1 leq text{sum(len(purchase) for purchase in all_purchases)} leq 10^6). # Example ```python user_history = [\'P1\', \'P2\'] all_purchases = [ [\'P1\', \'P3\'], [\'P2\', \'P4\'], [\'P1\', \'P2\', \'P5\'], [\'P6\'], [\'P1\', \'P2\', \'P3\', \'P4\'] ] result = recommend_products(user_history, all_purchases) print(result) # Expected output: [\'P3\', \'P4\', \'P5\'] ``` # Additional Notes * Only recommend products that the target user has not already purchased. * If two products have the same frequency, their order in the result list can be arbitrary. * Optimize for performance considering the large possible input sizes. * Handle edge cases such as scenarios where no other user\'s history overlaps with the target user\'s history.","solution":"from collections import Counter def recommend_products(user_history: list[str], all_purchases: list[list[str]]) -> list[str]: Suggest products to a user based on the purchase history of similar users. :param user_history: A list of product IDs the target user has purchased. :param all_purchases: A list of lists, where each inner list represents the products purchased by a different user. :return: A list of product IDs recommended to the user. similar_product_counts = Counter() user_history_set = set(user_history) for other_user_history in all_purchases: if any(product in user_history_set for product in other_user_history): for product in other_user_history: if product not in user_history_set: similar_product_counts[product] += 1 # Sorting products by their frequency in descending order recommended_products = [product for product, _ in similar_product_counts.most_common()] return recommended_products"},{"question":"# Rotational Cipher Coding Challenge You have been given the task to implement a rotational cipher (also known as Caesar cipher) to secure messages. The cipher works by shifting each letter in the message by a specified number of positions down the alphabet. If a shift moves past the end of the alphabet, it wraps around to the beginning. Task: Create the following two functions: 1. `encrypt_message(message: str, shift: int) -> str` 2. `decrypt_message(cipher: str, shift: int) -> str` Both functions should: - **Parameters**: - `message` (str): The input string to be encrypted or decrypted. - `shift` (int): The number of positions each character in the string should be shifted. - **Return**: A new string that is the result of encrypting or decrypting the input string using the provided shift. Constraints: - The input string will contain only uppercase and lowercase English letters. - The shift will be a non-negative integer. - The input string can be empty. **Example**: ```python # using the shift of 3 for simplicity encrypted = encrypt_message(\\"Hello\\", 3) print(encrypted) # prints \\"Khoor\\" decrypted = decrypt_message(encrypted, 3) print(decrypted) # prints \\"Hello\\" ``` Performance Requirements: - Aim for O(n) time complexity for both functions, where n is the length of the input string. - Use O(n) space complexity for storing the result.","solution":"def encrypt_message(message: str, shift: int) -> str: Encrypts the message by shifting each character by the given shift amount. :param message: The input string to be encrypted. :param shift: The number of positions each character in the string should be shifted. :return: The encrypted string. encrypted = [] for char in message: if \'a\' <= char <= \'z\': encrypted.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif \'A\' <= char <= \'Z\': encrypted.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: # Non-alphabetic characters are not encrypted encrypted.append(char) return \'\'.join(encrypted) def decrypt_message(cipher: str, shift: int) -> str: Decrypts the cipher by shifting each character back by the given shift amount. :param cipher: The encrypted string to be decrypted. :param shift: The number of positions each character in the string should be shifted back. :return: The decrypted string. decrypted = [] for char in cipher: if \'a\' <= char <= \'z\': decrypted.append(chr((ord(char) - ord(\'a\') - shift) % 26 + ord(\'a\'))) elif \'A\' <= char <= \'Z\': decrypted.append(chr((ord(char) - ord(\'A\') - shift) % 26 + ord(\'A\'))) else: # Non-alphabetic characters are not decrypted decrypted.append(char) return \'\'.join(decrypted)"},{"question":"# Problem Statement You are tasked with creating a function to analyze a sequence of numbers representing daily stock prices and provide insights on the best days to buy and sell stock for maximum profit. Your task: 1. **Identify the best day to buy and sell**: Find the pair of days (buy and sell) that maximize the profit. 2. **Calculate the maximum profit**: Determine the maximum profit that can be achieved with the identified buy and sell days. 3. **Return a summary of the results** in a structured format. Function Signature: ```python def analyze_stock_prices(prices: list[int]) -> dict: prices : list[int] : A list of integers representing daily stock prices. ``` Guidelines: 1. The function should be efficient, ideally with a time complexity of O(n). 2. If no profit is possible (i.e., prices are non-decreasing or the list is too short), return a buy day and sell day of -1 and a maximum profit of 0. 3. Edge cases should be handled gracefully, such as an empty list or a single day\'s price. 4. The function should return results as a dictionary containing keys `buy_day`, `sell_day`, and `max_profit`. Input and Output: * **Input** – `prices`: A list of integers where each integer represents the stock price for a day. - Example: `[7, 1, 5, 3, 6, 4]` * **Output** – A dictionary containing: - `buy_day`: The day (index) to buy the stock. - `sell_day`: The day (index) to sell the stock. - `max_profit`: The maximum profit obtainable. Constraints: * The length of `prices` will be at most 10^5. * The prices will be in range [0, 10^4]. Example: ```python # Basic invocation for calculating maximum profit results = analyze_stock_prices([7, 1, 5, 3, 6, 4]) # Output example { \\"buy_day\\": 1, \\"sell_day\\": 4, \\"max_profit\\": 5 } ```","solution":"def analyze_stock_prices(prices): Analyzes stock prices to determine the best days to buy and sell for maximum profit. :param prices: List of integers where each integer represents the stock price for a day. :return: A dictionary with keys \'buy_day\', \'sell_day\', and \'max_profit\'. if not prices or len(prices) < 2: return {\'buy_day\': -1, \'sell_day\': -1, \'max_profit\': 0} min_price_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_day]: min_price_day = current_day current_profit = prices[current_day] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = current_day if max_profit == 0: return {\'buy_day\': -1, \'sell_day\': -1, \'max_profit\': 0} return {\'buy_day\': buy_day, \'sell_day\': sell_day, \'max_profit\': max_profit}"},{"question":"# Problem Statement You are required to implement a function for a binary search tree (BST). Specifically, you need to provide a method to find the kth smallest element in the BST. The binary search tree class is already implemented and contains methods like `insert`, `delete`, and more. # Requirements Implement a method `find_kth_smallest` inside the `BST` class that: 1. Takes an integer `k` as its argument. 2. Returns the kth smallest element in the binary search tree. 3. Assume `k` is always valid, i.e., 1 ≤ k ≤ number of nodes in the BST. # Input & Output - **Input**: The function takes an integer `k`. - **Output**: The function returns the kth smallest element in the BST. # Constraints - The BST can contain any number of nodes, including zero. - The Node class has already been implemented and provides properties `left`, `right`, `value`, and their respective getters and setters. # Example ```python # Creating a new binary search tree and inserting values bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) # Finding the 3rd smallest element print(bst.find_kth_smallest(3)) # Output: 4 print(bst.find_kth_smallest(1)) # Output: 2 print(bst.find_kth_smallest(6)) # Output: 7 ``` # Note - You are only required to implement the `find_kth_smallest` method. The other methods and properties of the `BST` class have already been provided. # Function Signature ```python class BST: def find_kth_smallest(self, k: int) -> int: pass ```","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert(node.right, value) def find_kth_smallest(self, k): def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.value] + in_order_traversal(node.right) in_order = in_order_traversal(self.root) return in_order[k-1]"},{"question":"**Problem Statement: Cosine Similarity Calculation** You are required to write a function that calculates the cosine similarity between two vectors. The cosine similarity is measured using the following formula: [ text{cosine_similarity} = frac{A cdot B}{||A|| times ||B||} ] Where: - ( A cdot B ) is the dot product of vectors ( A ) and ( B ). - ( ||A|| ) and ( ||B|| ) are the magnitudes of vectors ( A ) and ( B ), respectively. # Function Signature ```python def cosine_similarity(vector_a: list, vector_b: list) -> float: pass ``` # Input: - `vector_a` (list of floats): The first vector. Must have the same length as `vector_b`. - `vector_b` (list of floats): The second vector. Must have the same length as `vector_a`. # Output: - A float value representing the cosine similarity between the two vectors. # Constraints: - The vectors must be non-empty and have the same length. # Example: ```python >>> cosine_similarity([1, 2, 3], [4, 5, 6]) 0.9746318461970762 >>> cosine_similarity([1, 0, 0], [0, 1, 0]) 0.0 >>> cosine_similarity([1, 1, 1], [1, 1, 1]) 1.0 ``` # Performance Requirements: - The function should operate in linear time, O(n), where n is the length of the input vectors. # Edge Cases: - Handle cases where the vectors contain all zeros (both magnitudes will be zero). - Handle cases where one vector is all zeros and the other is not (similarity should be zero). # Implementation: 1. Validate that the input vectors are non-empty and have the same length. 2. Compute the dot product of the two vectors. 3. Compute the magnitudes of the vectors. 4. Calculate and return the cosine similarity. Implement the function `cosine_similarity` accordingly.","solution":"import math def cosine_similarity(vector_a: list, vector_b: list) -> float: Calculates the cosine similarity between two vectors. :param vector_a: List of floats, the first vector. :param vector_b: List of floats, the second vector. :return: The cosine similarity between vector_a and vector_b. if len(vector_a) != len(vector_b): raise ValueError(\\"Vectors must have the same length\\") dot_product = sum(a * b for a, b in zip(vector_a, vector_b)) magnitude_a = math.sqrt(sum(a * a for a in vector_a)) magnitude_b = math.sqrt(sum(b * b for b in vector_b)) if magnitude_a == 0 or magnitude_b == 0: return 0.0 # To handle cases where one or both vectors are zero vectors return dot_product / (magnitude_a * magnitude_b)"},{"question":"# Binary Search Tree Implementation You are provided with a partial implementation of a Binary Search Tree (BST) in Python. Your task is to complete the implementation of the BST class by adding the following functionalities: 1. **Implement the `insert` method** to add a new element to the BST while maintaining the BST properties. 2. **Implement the `search` method** to check if a given element is present in the BST. 3. **Implement the `delete` method** to remove an element from the BST while maintaining the BST properties. 4. **Implement the `in_order_traversal` method** to return the elements of the BST in non-decreasing order. # Input * For the `insert` method: An integer representing the element to be added. * For the `search` method: An integer representing the element to be searched. * For the `delete` method: An integer representing the element to be removed. * For the `in_order_traversal` method: No input required. # Output * For the `insert` method: No output (it should update the internal state of the BST). * For the `search` method: Return `True` if the element is present in the BST, otherwise return `False`. * For the `delete` method: No output (it should update the internal state of the BST). * For the `in_order_traversal` method: Return a list of integers representing the elements of the BST in non-decreasing order. # Constraints * Each element in the BST should be a unique integer. * The BST should maintain its properties after each operation. # Example ```python # Initialize the BST bst = BST() # Insert elements into the BST bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) # Search for an element in the BST print(bst.search(4)) # Expected output: True print(bst.search(6)) # Expected output: False # Delete an element from the BST bst.delete(3) # Perform in-order traversal of the BST print(bst.in_order_traversal()) # Expected output: [2, 4, 5, 7] ``` # Notes * Ensure your implementation maintains the BST properties after each insertion and deletion. * Provide appropriate error handling for operations like deleting a non-existent element. * Optimize for efficiency where possible.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def search(self, key): return self._search_recursive(self.root, key) def _search_recursive(self, node, key): if node is None: return False if node.key == key: return True elif key < node.key: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete(self, key): self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node, key): if node is None: return node if key < node.key: node.left = self._delete_recursive(node.left, key) elif key > node.key: node.right = self._delete_recursive(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.key = min_larger_node.key node.right = self._delete_recursive(node.right, min_larger_node.key) return node def _find_min(self, node): current = node while current.left is not None: current = current.left return current def in_order_traversal(self): result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node is not None: self._in_order_recursive(node.left, result) result.append(node.key) self._in_order_recursive(node.right, result)"},{"question":"# Problem Statement: Longest Common Subsequence You are given two sequences, ( A ) and ( B ). Your task is to implement a function that finds the length of the longest common subsequence (LCS) between the two sequences. The LCS of two sequences is the longest sequence that appears in both of them, in the same order, but not necessarily consecutively. # Function Specifications longest_common_subsequence **Parameters**: - `A`: A sequence (string or list) representing the first sequence. - `B`: A sequence (string or list) representing the second sequence. **Returns**: - An integer representing the length of the longest common subsequence of ( A ) and ( B ). Example ```python def longest_common_subsequence(A: str, B: str) -> int: # Your implementation here ``` Input: ```python A = \\"AGGTAB\\" B = \\"GXTXAYB\\" ``` Output: ```python 4 ``` Explanation: The longest common subsequence is \\"GTAB\\", so the output is 4. Constraints - ( 0 leq |A|, |B| leq 100 ) # Notes - Ensure your function handles edge cases such as empty sequences efficiently. - Strive for a well-optimized solution, taking advantage of dynamic programming principles to avoid repeated calculations. - Test your solution with varied input to ensure correctness across different scenarios.","solution":"def longest_common_subsequence(A: str, B: str) -> int: m = len(A) b = len(B) # Create a 2D array to store the length of LCS dp = [[0] * (b+1) for _ in range(m+1)] # Fill the dp array for i in range(m+1): for j in range(b+1): if i == 0 or j == 0: dp[i][j] = 0 elif A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # The value in dp[m][b] contains the length of LCS of A and B return dp[m][b]"},{"question":"# Question: Implement a Simple Genetic Algorithm for Optimization You are required to implement a simple genetic algorithm (GA) for optimizing a real-valued function. A genetic algorithm is a heuristic search algorithm inspired by the process of natural selection. This particular GA will use tournament selection, single-point crossover, and mutation to evolve solutions. Function Signature ```python def genetic_algorithm( objective_func: Callable[[np.ndarray], float], bounds: List[Tuple[float, float]], population_size: int, generations: int, crossover_prob: float, mutation_prob: float ) -> np.ndarray: ``` Parameters: - `objective_func`: A function representing the objective function to be optimized. It takes an individual (array of real values) as input and returns a float representing the fitness. - `bounds`: A list of tuples specifying the lower and upper bounds for each dimension of the search space. - `population_size`: The number of individuals in the population. - `generations`: The number of generations to evolve the population. - `crossover_prob`: The probability of performing crossover between pairs of individuals. - `mutation_prob`: The probability of mutating an individual. Returns: - A numpy array representing the best individual found across all generations. # Constraints: - `population_size > 0` - `generations > 0` - `0 <= crossover_prob <= 1` - `0 <= mutation_prob <= 1` # Example: ```python # Define the objective function (e.g., Rastrigin function) def objective_func(x): return 10 * len(x) + sum([(xi**2 - 10 * np.cos(2 * np.pi * xi)) for xi in x]) # Define the bounds, population size, and algorithm parameters bounds = [(-5.12, 5.12)] * 2 # 2-dimensional problem with bounds [-5.12, 5.12] population_size = 50 generations = 100 crossover_prob = 0.8 mutation_prob = 0.2 # Compute the solution best_individual = genetic_algorithm(objective_func, bounds, population_size, generations, crossover_prob, mutation_prob) print(best_individual) # Expected output: A numpy array representing the best individual found, e.g., [0.0, 0.0] ``` # Notes: - Implement tournament selection to choose individuals for mating. - Apply single-point crossover to produce offspring. - Implement mutation by randomly flipping bits according to the mutation probability. - Use numpy for array manipulation and mathematical operations as needed. - Ensure the algorithm allows for exploration and exploitation in the search space. By following these guidelines, you will implement a genetic algorithm capable of optimizing numerical functions within defined bounds.","solution":"import numpy as np from typing import Callable, List, Tuple def genetic_algorithm( objective_func: Callable[[np.ndarray], float], bounds: List[Tuple[float, float]], population_size: int, generations: int, crossover_prob: float, mutation_prob: float ) -> np.ndarray: def create_individual(bounds): return np.array([np.random.uniform(low, high) for low, high in bounds]) def initialize_population(size, bounds): return np.array([create_individual(bounds) for _ in range(size)]) def tournament_selection(population, scores, k=3): selected = np.random.choice(len(population), k) selected_idx = max(selected, key=lambda idx: scores[idx]) return population[selected_idx] def crossover(parent1, parent2, crossover_prob): if np.random.rand() < crossover_prob: point = np.random.randint(1, len(parent1)) child1 = np.concatenate([parent1[:point], parent2[point:]]) child2 = np.concatenate([parent2[:point], parent1[point:]]) return child1, child2 else: return parent1.copy(), parent2.copy() def mutate(individual, mutation_prob, bounds): for i in range(len(individual)): if np.random.rand() < mutation_prob: individual[i] = np.random.uniform(bounds[i][0], bounds[i][1]) return individual def evaluate_population(population, objective_func): return np.array([objective_func(ind) for ind in population]) population = initialize_population(population_size, bounds) best_individual = None best_score = float(\'inf\') for generation in range(generations): scores = evaluate_population(population, objective_func) for i in range(len(scores)): if scores[i] < best_score: best_score = scores[i] best_individual = population[i].copy() new_population = [] while len(new_population) < population_size: parent1 = tournament_selection(population, scores) parent2 = tournament_selection(population, scores) child1, child2 = crossover(parent1, parent2, crossover_prob) new_population.append(mutate(child1, mutation_prob, bounds)) if len(new_population) < population_size: new_population.append(mutate(child2, mutation_prob, bounds)) population = np.array(new_population) return best_individual"},{"question":"# Problem Statement A coding competition is held where participants are given a sequence of bracket symbols, consisting of open and close round brackets, and are required to balance them by inserting the fewest number of additional bracket symbols. The task is to determine the smallest number of additional bracket symbols needed in order to make the sequence of brackets balanced. # Input ```txt The function should accept a string `s` of length `n`, consisting of round bracket characters only (`\'(\'` and `\')\'`). ``` # Output ```txt The function should return an integer representing the minimum number of bracket symbols required to balance the input string. ``` # Constraints * The length of the string `n` will be between 1 and 100. * The input string will consist only of characters `\'(\'` and `\')\'`. # Performance Requirements * The function should operate efficiently within the specified constraints. # Example Input ```python s = \\"()))((\\" ``` Expected Output ```python 4 ``` Explanation: Two `(` are needed to balance the first three `)`, and two `)` are needed to balance the last two `(`. Therefore, four additional brackets are required. # Implementation Implement the function `min_add_to_make_valid` which takes a string of bracket symbols and returns the number of additional bracket symbols needed to balance the sequence: ```python def min_add_to_make_valid(s: str) -> int: # implementation details pass ```","solution":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of additional bracket symbols required to balance the input string. Parameters: s (str): A string consisting of round bracket characters only (\'(\' and \')\'). Returns: int: The minimum number of additional bracket symbols needed to balance the input string. open_brackets_needed = 0 close_brackets_needed = 0 for char in s: if char == \'(\': open_brackets_needed += 1 elif char == \')\': if open_brackets_needed > 0: open_brackets_needed -= 1 else: close_brackets_needed += 1 return open_brackets_needed + close_brackets_needed"},{"question":"# Coding Assessment Question: You are given an array of integers where each element appears exactly twice, except for one odd integer that appears only once. Design and implement an efficient algorithm to find the element that appears only once. **Requirements**: - Your solution should have a time complexity of (O(n)) and a space complexity of (O(1)). - You must avoid using extra data structures such as hash tables or sets. **Function Specifications**: - **find_unique_element(arr: List[int]) -> int**: Takes a list of integers and returns the integer that appears exactly once. **Constraints**: - The length of the array will not exceed (10^6). - All integers in the array will be within the range of ([-10^9, 10^9]). **Example**: ```python >>> find_unique_element([1, 2, 4, 2, 1]) 4 >>> find_unique_element([7, 3, 5, 4, 5, 3, 7]) 4 >>> find_unique_element([9, 9, 1, 2, 2, 1, 8]) 8 >>> find_unique_element([10]) 10 ``` You may assume that the array has exactly one element that appears once and that all other elements appear exactly twice. Consider leveraging bitwise operations to achieve the optimal time and space complexity. --- In the above question, the core programming concept relates to the use of bitwise operations to efficiently identify the unique element in an array. The problem statement aligns well with the original coding assessment in terms of complexity, scope, and the required logical reasoning.","solution":"def find_unique_element(arr): Finds the unique element in an array where every other element appears exactly twice. Args: arr (List[int]): List of integers where each element appears exactly twice except for one. Returns: int: The unique element. unique_elem = 0 for num in arr: unique_elem ^= num return unique_elem"},{"question":"# Hotel Room Booking System You are tasked with developing a booking management system for a hotel. The system needs to handle reservations efficiently, ensuring that no double bookings occur and checking for room availability on specific dates. # Problem Statement Design a class `Hotel` that handles room booking. The hotel has multiple rooms, each identified by a unique room number. You need to implement methods to book a room, check availability, and retrieve the list of bookings for a given room. Class Definition: ```python class Hotel: def __init__(self): pass def book_room(self, room_number: int, start_date: str, end_date: str) -> bool: pass def is_room_available(self, room_number: int, target_date: str) -> bool: pass def get_bookings(self, room_number: int) -> list: pass ``` Method Descriptions: - `__init__()`: Initializes the hotel object. Initialize any necessary data structures to keep track of room bookings. - `book_room(room_number: int, start_date: str, end_date: str) -> bool`: Attempts to book a room for the specified date range (`start_date` to `end_date`). Dates are inclusive and are given in the format `YYYY-MM-DD`. If the booking is successful (no date overlap with existing bookings), returns `True`. Otherwise, returns `False`. - `is_room_available(room_number: int, target_date: str) -> bool`: Checks if the room is available on the given `target_date`. Returns `True` if the room is available, `False` otherwise. - `get_bookings(room_number: int) -> list`: Retrieves a list of all bookings for the given room number. Each booking is represented as a tuple `(start_date, end_date)`. Dates should be ordered from the earliest to the latest booking. Constraints: - Room numbers are positive integers. - Dates are given in the format `YYYY-MM-DD`. - The date ranges provided for bookings will always be valid (i.e., `start_date < end_date`). Example: ```python # Example Usage hotel = Hotel() print(hotel.book_room(101, \'2023-11-01\', \'2023-11-05\')) # True print(hotel.book_room(101, \'2023-11-04\', \'2023-11-08\')) # False print(hotel.book_room(102, \'2023-11-01\', \'2023-11-05\')) # True print(hotel.is_room_available(101, \'2023-11-03\')) # False print(hotel.is_room_available(101, \'2023-11-06\')) # True print(hotel.get_bookings(101)) # [(\'2023-11-01\', \'2023-11-05\')] print(hotel.get_bookings(102)) # [(\'2023-11-01\', \'2023-11-05\')] # More Examples hotel = Hotel() print(hotel.book_room(201, \'2023-12-20\', \'2023-12-25\')) # True print(hotel.book_room(201, \'2023-12-25\', \'2023-12-28\')) # True print(hotel.is_room_available(201, \'2023-12-25\')) # False print(hotel.get_bookings(201)) # [(\'2023-12-20\', \'2023-12-25\'), (\'2023-12-25\', \'2023-12-28\')] ``` Implementation Hint: - Use a dictionary to manage room bookings, where keys are room numbers, and values are lists of booked date ranges. - Consider sorting or managing date ranges efficiently to ensure correct handling of bookings and queries. Submission: Ensure your submission includes the implementation of the `Hotel` class with properly functioning methods as described.","solution":"from datetime import datetime class Hotel: def __init__(self): # Dictionary to store room bookings # Key: room_number, Value: list of tuple (start_date, end_date) self.bookings = {} def book_room(self, room_number: int, start_date: str, end_date: str) -> bool: # Initialize the booking list for the room if it does not exist if room_number not in self.bookings: self.bookings[room_number] = [] # Convert dates to datetime objects for comparison start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') # Check for overlapping bookings for booking in self.bookings[room_number]: existing_start, existing_end = (datetime.strptime(booking[0], \'%Y-%m-%d\'), datetime.strptime(booking[1], \'%Y-%m-%d\')) if end > existing_start and start < existing_end: return False # If no overlaps, add the booking self.bookings[room_number].append((start_date, end_date)) # Sort bookings by start date self.bookings[room_number].sort() return True def is_room_available(self, room_number: int, target_date: str) -> bool: # If no bookings for the room, it is available if room_number not in self.bookings: return True # Convert the target date to datetime object target = datetime.strptime(target_date, \'%Y-%m-%d\') # Check if the target date overlaps with any existing booking for booking in self.bookings[room_number]: start, end = (datetime.strptime(booking[0], \'%Y-%m-%d\'), datetime.strptime(booking[1], \'%Y-%m-%d\')) if start <= target <= end: return False # If no overlaps, the room is available return True def get_bookings(self, room_number: int) -> list: # Return the list of bookings for the room, or an empty list if none return self.bookings.get(room_number, [])"},{"question":"# Inventory Management System Scenario: You are tasked with creating an inventory management system for a small store. One of the requirements is to implement a functionality that can determine the most frequently purchased item in a given list of transactions. Each transaction contains the name of the item purchased. # Task Write a Python function that returns the name of the most frequently purchased item from a given list of transactions. If multiple items have the same highest frequency, return all of them in a list sorted in alphabetical order. Function Signature ```python def most_frequent_item(transactions: list) -> list: pass ``` Input * `transactions` (list): A list of strings where each string represents an item purchased in a transaction. Output * Returns a list of strings containing the name(s) of the most frequently purchased item(s). Constraints * Each item name in `transactions` is a non-empty string. * The list `transactions` may be empty. Examples ```python >>> most_frequent_item([\'apple\', \'banana\', \'apple\', \'orange\', \'banana\', \'banana\']) [\'banana\'] >>> most_frequent_item([\'apple\', \'banana\', \'apple\', \'orange\', \'banana\', \'orange\']) [\'apple\', \'banana\', \'orange\'] >>> most_frequent_item([]) [] >>> most_frequent_item([\'grape\', \'grape\', \'berry\']) [\'grape\'] ``` Validation and Error Handling Your function should handle the following conditions gracefully: * If `transactions` is empty, return an empty list `[]`. * Ensure that each element in the `transactions` list is a non-empty string. If an element is empty, the behavior is undefined.","solution":"def most_frequent_item(transactions: list) -> list: from collections import Counter if not transactions: return [] frequency_count = Counter(transactions) most_common_count = max(frequency_count.values()) most_frequent_items = [item for item, count in frequency_count.items() if count == most_common_count] return sorted(most_frequent_items)"},{"question":"# Fine-tune Temperature Conversion Functionality Context You are improving an existing temperature conversion utility that converts temperatures between Celsius, Fahrenheit, and Kelvin. The primary goal is to extend its functionality allowing bulk conversions and robust error handling. Objective * Enhance the existing `convert_temperature` function to process a list of temperatures along with their corresponding source and target units. * Implement comprehensive error handling to manage invalid or unsupported temperature scales. Function Signature ```python def convert_bulk_temperatures(temperatures: List[Tuple[float, str, str]]) -> Dict[str, List]: Convert a list of temperatures from one unit to another. Parameters: temperatures (List[Tuple[float, str, str]]): A list of tuples, each containing temperature value, source unit, and target unit. Returns: Dict[str, List]: A dictionary with two keys \\"conversions\\" and \\"errors\\". \\"conversions\\" is a list of converted temperature values in a tuple with original input. \\"errors\\" is a list of tuples with the invalid input that caused an error. Example: >>> convert_bulk_temperatures([(100, \'C\', \'F\'), (273.15, \'K\', \'C\'), (-40, \'F\', \'K\')]) {\'conversions\': [(100, \'C\', \'F\', 212.0), (273.15, \'K\', \'C\', 0.0)], \'errors\': [(-40, \'F\', \'K\')]} ``` Constraints and Requirements * **Input Constraints**: - Each entry in the list contains a temperature value, a source unit (\'C\', \'F\', \'K\'), and a target unit (\'C\', \'F\', \'K\'). * **Output**: - The function must return a dictionary containing successful conversions and any invalid inputs. * **Error Handling**: - If the source or target unit is not one of the recognized scales (\'C\', \'F\', \'K\'), add the input to the \\"errors\\" list. - Handle converting temperatures to/from valid scales only, ensuring computations stop for invalid configurations to avoid crashes. * Ensure the function operates efficiently and handles typical edge cases with appropriate exception management. ```python def convert_temperature(value: float, src_unit: str, tgt_unit: str) -> float: Convert a temperature value from one unit to another. if src_unit == \\"C\\": if tgt_unit == \\"F\\": return value * 9.0 / 5.0 + 32 elif tgt_unit == \\"K\\": return value + 273.15 elif src_unit == \\"F\\": if tgt_unit == \\"C\\": return (value - 32) * 5.0 / 9.0 elif tgt_unit == \\"K\\": return (value + 459.67) * 5.0 / 9.0 elif src_unit == \\"K\\": if tgt_unit == \\"C\\": return value - 273.15 elif tgt_unit == \\"F\\": return value * 9.0 / 5.0 - 459.67 raise ValueError(\\"Unsupported temperature conversion\\") def convert_bulk_temperatures(temperatures: List[Tuple[float, str, str]]) -> Dict[str, List]: conversions = [] errors = [] for temp, src_unit, tgt_unit in temperatures: try: if src_unit not in (\'C\', \'F\', \'K\') or tgt_unit not in (\'C\', \'F\', \'K\'): raise ValueError(\\"Invalid temperature scale(s)\\") converted_temp = convert_temperature(temp, src_unit, tgt_unit) conversions.append((temp, src_unit, tgt_unit, converted_temp)) except ValueError as e: errors.append((temp, src_unit, tgt_unit)) return {\\"conversions\\": conversions, \\"errors\\": errors} ```","solution":"def convert_temperature(value: float, src_unit: str, tgt_unit: str) -> float: Convert a temperature value from one unit to another. if src_unit == \\"C\\": if tgt_unit == \\"F\\": return value * 9.0 / 5.0 + 32 elif tgt_unit == \\"K\\": return value + 273.15 elif src_unit == \\"F\\": if tgt_unit == \\"C\\": return (value - 32) * 5.0 / 9.0 elif tgt_unit == \\"K\\": return (value + 459.67) * 5.0 / 9.0 elif src_unit == \\"K\\": if tgt_unit == \\"C\\": return value - 273.15 elif tgt_unit == \\"F\\": return value * 9.0 / 5.0 - 459.67 raise ValueError(\\"Unsupported temperature conversion\\") def convert_bulk_temperatures(temperatures): conversions = [] errors = [] for temp, src_unit, tgt_unit in temperatures: try: if src_unit not in (\'C\', \'F\', \'K\') or tgt_unit not in (\'C\', \'F\', \'K\'): raise ValueError(\\"Invalid temperature scale(s)\\") converted_temp = convert_temperature(temp, src_unit, tgt_unit) conversions.append((temp, src_unit, tgt_unit, converted_temp)) except ValueError as e: errors.append((temp, src_unit, tgt_unit)) return {\\"conversions\\": conversions, \\"errors\\": errors}"},{"question":"# Distance Between Points in a 3D Space Problem Statement You are given two points in a 3D space, defined by their x, y, and z coordinates. Write a function `calculate_distance(p1: tuple, p2: tuple) -> float` that calculates the Euclidean distance between these points. Requirements * Implement the function `calculate_distance(p1: tuple, p2: tuple) -> float`. * Your function should handle floating-point numbers effectively. * Make sure to use the appropriate mathematical operations to ensure accuracy of the distance. # Expected Input and Output * **Input**: * `p1 (tuple)`: a tuple containing three floats `(x1, y1, z1)` representing the first point. * `p2 (tuple)`: a tuple containing three floats `(x2, y2, z2)` representing the second point. * **Output**: * Return a float indicating the Euclidean distance between the two points. # Constraints 1. The function should be precise even with floating-point arithmetic. 2. Consider borderline cases such as points being at the same coordinates or having very small/larger values. # Example ```python def calculate_distance(p1: tuple, p2: tuple) -> float: # Your implementation here print(calculate_distance((0, 0, 0), (1, 1, 1))) # Output: 1.73205 print(calculate_distance((1, 2, 3), (4, 5, 6))) # Output: 5.19615 print(calculate_distance((0.5, 0.5, 0.5), (1.5, 1.5, 1.5))) # Output: 1.73205 ``` Tips * Use the formula `sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)` to calculate the distance. * Ensure that your function can handle typical floating-point precision issues.","solution":"import math def calculate_distance(p1: tuple, p2: tuple) -> float: Calculate the Euclidean distance between two points in 3D space. :param p1: A tuple containing three floats representing the first point (x1, y1, z1). :param p2: A tuple containing three floats representing the second point (x2, y2, z2). :return: A float representing the Euclidean distance between the two points. x1, y1, z1 = p1 x2, y2, z2 = p2 distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) return distance"},{"question":"# Finding Duplicate Elements in a List You are given a list of integers. Your task is to write a function `find_duplicates(nums)` that identifies all the duplicate elements in the list and returns them in a list. The returned list should not contain any duplicates and the order does not matter. # Input * `nums`: A list of integers. # Output * A list of integers that appear more than once in the input list. # Constraints * The input list can contain negative and positive integers as well as zero. * The duplicates should be returned without any specific order. * If there are no duplicates, return an empty list. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) # Examples ```python assert find_duplicates([1, 2, 3, 4, 5]) == [] assert find_duplicates([1, 2, 2, 3, 3, 3, 4]) == [2, 3] assert find_duplicates([0, 0, 0, 0, 0]) == [0] assert find_duplicates([5, 4, 3, 2, 1, 5, -1, -2, -2]) == [5, -2] assert find_duplicates([]) == [] assert find_duplicates([1]) == [] assert find_duplicates([1, 1, -1, -1]) == [1, -1] assert find_duplicates([-1, -2, -3, -4, -5]) == [] ``` # Additional Considerations Ensure that your solution handles: * Edge cases such as an empty list and a list with one element. * Lists containing negative numbers and zeros. # Function Signature ```python def find_duplicates(nums: list[int]) -> list[int]: # Your code here ```","solution":"def find_duplicates(nums): This function returns a list of duplicate elements in the given list. Elements in the output list are unique and their order does not matter. seen = set() duplicates = set() for num in nums: if num in seen: duplicates.add(num) else: seen.add(num) return list(duplicates)"},{"question":"# Task You are required to write a function `reverse_words(s: str) -> str` that reverses the order of the words in a given string `s`. # Input - A string `s` containing words separated by spaces. The string does not have leading or trailing spaces and each word is separated by a single space. # Output - A string where the order of the words is reversed, while the words themselves are not reversed. # Constraints - The length of `s` will not exceed (10^4). # Performance Requirements - The solution should work in linear time, targeting an overall time complexity of (O(n)), where (n) is the length of the string. # Scenario This function can be useful for text processing tasks where the order of words needs to be reversed. For instance, in creating concise summaries or altering sentence structures in NLP applications. # Example ```python >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\"this is a test\\") \\"test a is this\\" ``` # Implementation ```python def reverse_words(s: str) -> str: words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words) ```","solution":"def reverse_words(s: str) -> str: Reverses the order of words in a given string. :param s: Input string with words separated by spaces. :return: A string with the order of the words reversed. words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Problem Statement Write a function that finds the intersection of two sorted arrays of integers. The intersection of two arrays is a list containing all elements that are present in both arrays. The result should preserve the order of the first array. # Input Format * **arr1**: A sorted list of integers (1 ≤ len(arr1) ≤ 10^6) * **arr2**: A sorted list of integers (1 ≤ len(arr2) ≤ 10^6) # Output Format * A list of integers representing the intersection of both input arrays. # Example ```python >>> intersection([1, 2, 4, 5, 6], [2, 3, 5, 7]) [2, 5] >>> intersection([-5, -2, -1, 0, 1], [-3, -2, 0, 2]) [-2, 0] >>> intersection([1, 1, 2, 2, 3], [2, 2, 3, 3]) [2, 2, 3] >>> intersection([1, 3, 5, 7], [2, 4, 6, 8]) [] >>> intersection([7, 8, 10], [5, 7, 8, 10]) [7, 8, 10] ``` # Constraints * The given arrays will always be sorted. * You may assume that elements are distinct within each individual array (no duplicates within a single array). * Expected time complexity is O(n + m), where `n` and `m` are the lengths of the two arrays. # Performance Requirements Your implementation should be efficient enough to handle large arrays up to length 10^6. # Hints 1. Use two pointers to traverse both arrays and find common elements. 2. If elements are equal, add the element to the result list and move both pointers forward. If elements are not equal, move the pointer of the array with the smaller element forward.","solution":"def intersection(arr1, arr2): Returns the intersection of two sorted arrays, preserving the order of arr1. i, j = 0, 0 result = [] while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: result.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return result"},{"question":"# Coding Assessment Question Scenario & Context You have access to a list of tasks that need to be executed in a specific order based on their dependencies. Each task is represented by a number, and the dependencies are given as pairs where one task must be executed before another. This question will assess your ability to handle graph traversal and cycle detection in directed acyclic graphs (DAGs). Problem Statement Write a function `find_task_order` to determine the order in which the tasks should be executed. If it is impossible to execute all tasks due to cyclic dependencies, return an empty list. Function Signature ```python def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: pass ``` Input * `num_tasks` (Integer): The total number of tasks to be completed, labeled from 0 to num_tasks-1. * `dependencies` (List of Tuples): A list where each tuple `(a, b)` indicates that task `a` must be completed before task `b`. Output * Return a list of integers representing the order in which the tasks should be executed. If no valid order exists, return an empty list. Constraints * `1 ≤ num_tasks ≤ 10^4` * `0 ≤ len(dependencies) ≤ 10^5` Examples ```python >>> find_task_order(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) [0, 1, 2, 3] >>> find_task_order(2, [(1, 0), (0, 1)]) [] ``` Notes * You need to handle cases where there are no dependencies. * Use topological sorting to determine the order and detect cycles within the task graph. **Performance Requirement**: The solution should be efficient enough to handle the upper limits of the constraints within a reasonable runtime, ideally near O(V + E). # Coding Assessment Question Scenario & Context You are tasked with designing a system that manages a list of contacts and supports efficient searching by prefixes. This question evaluates your ability to work with string manipulation and data structures for optimizing search operations. Problem Statement Write a class `ContactList` that supports adding contacts and searching for contacts by a given prefix. Class Signature ```python class ContactList: def __init__(self): pass def add_contact(self, name: str): pass def search(self, prefix: str) -> List[str]: pass ``` Input * `add_contact(name: str)`: Adds a contact with the given name to the contact list. * `search(prefix: str) -> List[str]`: Returns a list of contact names that start with the given prefix, sorted in lexicographical order. Output * For `add_contact`, there is no return value. * For `search`, return a list of strings. Constraints * `1 ≤ len(name), len(prefix) ≤ 100` * All contact names and prefixes are composed of lowercase English letters only. * The total number of contacts added will not exceed 10^5. Examples ```python contacts = ContactList() contacts.add_contact(\\"alice\\") contacts.add_contact(\\"bob\\") contacts.add_contact(\\"alex\\") >>> contacts.search(\\"al\\") [\'alice\', \'alex\'] >>> contacts.search(\\"a\\") [\'alex\', \'alice\'] >>> contacts.search(\\"b\\") [\'bob\'] >>> contacts.search(\\"c\\") [] ``` Notes * Consider using a Trie (prefix tree) for efficient implementation of the search operation. * Ensure that the `search` method maintains appropriate performance given the constraints. **Performance Requirement**: The operations should be optimized to handle the maximum constraints efficiently, preferably with complexities suitable for Trie-based operations.","solution":"from collections import deque, defaultdict from typing import List, Tuple def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: # Create an adjacency list and a list for counting in-degrees adjacency_list = defaultdict(list) in_degrees = [0] * num_tasks # Build the graph for a, b in dependencies: adjacency_list[a].append(b) in_degrees[b] += 1 # Initialize a queue with tasks that have an in-degree of 0 queue = deque([task for task in range(num_tasks) if in_degrees[task] == 0]) order = [] while queue: current = queue.popleft() order.append(current) # Decrease the in-degree of the current node\'s neighbors for neighbor in adjacency_list[current]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) # If the order contains all tasks, return the order, else return an empty list return order if len(order) == num_tasks else []"},{"question":"# Coding Assessment Question Objective Create a Python function that processes a list of financial transactions and returns a summary of the net gains and losses for each unique stock symbol. Problem Statement You are given a list of financial transactions, where each transaction is represented by a dictionary containing the stock symbol, the type of transaction (either \'buy\' or \'sell\'), the number of shares, and the price per share. Your task is to implement a function that calculates the net gain or loss for each stock symbol. Function Specifications 1. **Function Name**: `calculate_net_gains` 2. **Input Parameters**: - `transactions`: list of dictionaries; Each dictionary represents a transaction with the following keys: - `symbol`: str; The stock symbol. - `type`: str; The transaction type, either \'buy\' or \'sell\'. - `shares`: int; The number of shares involved in the transaction. - `price`: float; The price per share in the transaction. 3. **Output**: - A dictionary where keys are stock symbols and the values are the net gain or loss (positive for gain, negative for loss) for that stock. - If the provided input values are invalid, raise a `ValueError` with a descriptive message. 4. **Constraints**: - The \'type\' of transaction must be either \'buy\' or \'sell\'. - The number of shares must be a positive integer. - The price per share must be a positive float. ```python def calculate_net_gains(transactions: list[dict]) -> dict | ValueError: Input Parameters: ----------------- transactions: List of dictionaries, where each dictionary has keys: - \'symbol\': str; The stock symbol. - \'type\': str; The transaction type, either \'buy\' or \'sell\'. - \'shares\': int; The number of shares involved in the transaction. - \'price\': float; The price per share in the transaction. Returns: -------- A dictionary where keys are stock symbols and values are the net gain or loss. If the inputs are invalid, raises a ValueError with an appropriate error message. Examples: --------- >>> transactions = [ ... {\'symbol\': \'AAPL\', \'type\': \'buy\', \'shares\': 10, \'price\': 150.0}, ... {\'symbol\': \'AAPL\', \'type\': \'sell\', \'shares\': 5, \'price\': 160.0}, ... {\'symbol\': \'GOOG\', \'type\': \'buy\', \'shares\': 8, \'price\': 1000.0}, ... {\'symbol\': \'GOOG\', \'type\': \'sell\', \'shares\': 8, \'price\': 1100.0}, ... ] >>> calculate_net_gains(transactions) {\'AAPL\': 50.0, \'GOOG\': 800.0} >>> transactions = [ ... {\'symbol\': \'AAPL\', \'type\': \'buy\', \'shares\': 10, \'price\': -150.0} ... ] >>> calculate_net_gains(transactions) ValueError(\'Input Error: Price per share must be positive.\') pass # Your code here ``` Notes: 1. Ensure proper error handling for invalid inputs. 2. The calculation of net gain or loss should consider the difference in total transaction amounts for \'buy\' and \'sell\' transactions. 3. Your solution should be efficient and readable.","solution":"def calculate_net_gains(transactions): if not isinstance(transactions, list): raise ValueError(\\"Input Error: Transactions must be provided as a list.\\") net_gains = {} for tx in transactions: if \'symbol\' not in tx or \'type\' not in tx or \'shares\' not in tx or \'price\' not in tx: raise ValueError(\\"Input Error: Each transaction must have \'symbol\', \'type\', \'shares\', and \'price\' keys.\\") symbol = tx[\'symbol\'] t_type = tx[\'type\'] shares = tx[\'shares\'] price = tx[\'price\'] if not isinstance(symbol, str): raise ValueError(\\"Input Error: Symbol must be a string.\\") if t_type not in [\'buy\', \'sell\']: raise ValueError(\\"Input Error: Transaction type must be either \'buy\' or \'sell\'.\\") if not (isinstance(shares, int) and shares > 0): raise ValueError(\\"Input Error: Shares must be a positive integer.\\") if not (isinstance(price, (int, float)) and price > 0): raise ValueError(\\"Input Error: Price per share must be positive.\\") if symbol not in net_gains: net_gains[symbol] = 0 amount = shares * price if t_type == \'buy\': net_gains[symbol] -= amount else: # t_type == \'sell\' net_gains[symbol] += amount return net_gains"},{"question":"# Longest Common Subsequence (LCS) Problem Context: In text comparisons, such as version control systems, finding the longest common subsequence between two strings can help identify changes and similarities. For this task, you will implement an algorithm to compute the LCS of two given strings. Problem Description: Write a function `longest_common_subsequence` that takes in two strings, `a` and `b`, and returns the length of their longest common subsequence. A subsequence refers to a sequence that appears in the same relative order but not necessarily contiguously. Function Signature: ```python def longest_common_subsequence(a: str, b: str) -> int: ``` Input: - `a`: A string representing the first input string. (0 <= len(a) <= 1000) - `b`: A string representing the second input string. (0 <= len(b) <= 1000) Output: - An integer representing the length of the longest common subsequence of `a` and `b`. Constraints: - Handle cases where one or both strings might be empty. - Optimization in terms of time and space complexity is essential for input limits. Examples: ```python >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") 4 >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"\\", \\"ABC\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") 0 ``` Notes: - The LCS calculation should be case-sensitive. - Dynamic programming is a recommended approach for solving this problem efficiently. - Ensure your implementation handles various edge cases and performs well within the given constraints.","solution":"def longest_common_subsequence(a: str, b: str) -> int: Returns the length of the longest common subsequence between two strings `a` and `b`. m, n = len(a), len(b) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"# Coding Question: Implement the following function to achieve the objectives described: 1. **Function to check if a tree is balanced**: Implement a method `is_balanced` for the `TreeNode` class which determines if the tree is height-balanced. A height-balanced tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. ```python class TreeNode: # existing methods... def is_balanced(self) -> bool: Determine if the tree is height-balanced. Returns: A boolean indicating if the tree is balanced. >>> TreeNode(1).is_balanced() True >>> TreeNode(1, TreeNode(2), TreeNode(3)).is_balanced() True >>> TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), None), None), None).is_balanced() False # Your implementation here ``` # Constraints: * The tree node values are integers. * The tree may be unbalanced. * The maximum depth of the tree is not greater than 1000. # Examples: ```python root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) print(root.is_balanced()) # Output: True root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), None), None), None) print(root.is_balanced()) # Output: False ``` # Additional Notes: * Ensure the method correctly handles trees with only one node and empty subtrees (`null` nodes). * The implementation should be efficient, ideally resulting in a time complexity of O(n) and a space complexity of O(h), where n is the number of nodes in the tree and h is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(self) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 is_current_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return current_height, is_current_balanced _, is_bal = check_balance(self) return is_bal"},{"question":"# Matrix Transpose You are asked to write a function `transpose_matrix` to transpose a given 2D matrix. Transposing a matrix means swapping the matrix\'s row and column indices. Function Specifications 1. **transpose_matrix** - **Input**: A 2D list `matrix` where each element is a list representing a row in the matrix. - **Output**: A 2D list representing the transposed matrix. Input and Output Specifications **Input**: - `matrix` of size `m x n`, where `m` is the number of rows and `n` is the number of columns. **Output**: - The function should return a new matrix that is the transpose of the input. # Example Test Cases ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert transpose_matrix([[1]]) == [[1]] assert transpose_matrix([[]]) == [] assert transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] ``` Implementation ```python def transpose_matrix(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[None] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed # Test Cases print(transpose_matrix([[1, 2, 3], [4, 5, 6]])) # Output: [[1, 4], [2, 5], [3, 6]] print(transpose_matrix([[1]])) # Output: [[1]] print(transpose_matrix([[]])) # Output: [] print(transpose_matrix([[1, 2], [3, 4], [5, 6]])) # Output: [[1, 3, 5], [2, 4, 6]] ``` Implement the `transpose_matrix` function such that it passes all the given example test cases.","solution":"def transpose_matrix(matrix): Transposes the given 2D matrix. :param matrix: List of lists where each sub-list represents a row in the matrix. :return: A new matrix that is the transpose of the input matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[None] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed"},{"question":"# K-Nearest Neighbors in a 2D Plane **Scenario**: You are developing software for a delivery service that optimizes routes for delivery drivers. One essential task is to find the k-nearest delivery points from a given location to provide efficient stops for the driver. **Task**: Implement a function `k_nearest_neighbors(points: List[Tuple[int, int]], location: Tuple[int, int], k: int) -> List[Tuple[int, int]]` that finds the `k` nearest points to a given location using the Euclidean distance. Input: - `points`: A list of tuples representing 2D coordinates, where each tuple contains two integers `x` and `y` (i.e., a point in a 2D plane). - `location`: A tuple containing two integers `x` and `y`, representing the location from which distances are measured. - `k`: An integer representing the number of nearest neighbors to find. Output: - A list of `k` tuples representing the `k` nearest points from the given location, sorted by ascending order of their distance to the location. If two points have the same distance, they should be sorted by their `x` coordinate, and if they still tie, by their `y` coordinate. Examples: ```python assert k_nearest_neighbors([(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)], (0, 0), 3) == [(2, 3), (3, 4), (5, 1)] assert k_nearest_neighbors([(1, 1), (3, 4), (6, 1), (6, 8)], (0, 0), 2) == [(1, 1), (3, 4)] assert k_nearest_neighbors([(1, 1), (2, 2), (1, 2), (2, 1)], (0, 0), 2) == [(1, 1), (1, 2)] ``` Constraints: - The points will have integer coordinates between -10^6 and 10^6. - 1 ≤ k ≤ N, where N is the number of points in the list. The list contains at least k points. Performance Requirements: - The algorithm should efficiently handle the sorting and selection process, with an expected time complexity of O(N log k). Instructions: 1. Implement the function `k_nearest_neighbors` ensuring it adheres to the specified constraints and requirements. 2. Use efficient sorting and selection techniques to handle a large dataset. ```python def k_nearest_neighbors(points, location, k): from heapq import nlargest from math import sqrt def distance(point): return sqrt((point[0] - location[0])**2 + (point[1] - location[1])**2) nearest = nlargest(k, points, key=lambda point: -distance(point)) nearest.sort(key=lambda point: (distance(point), point[0], point[1])) return nearest # Example usage: points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)] location = (0, 0) k = 3 print(\\"K-Nearest Neighbors:\\", k_nearest_neighbors(points, location, k)) ```","solution":"def k_nearest_neighbors(points, location, k): from heapq import nsmallest from math import sqrt def distance(point): return sqrt((point[0] - location[0])**2 + (point[1] - location[1])**2) # Find the k smallest distances using a heap for efficiency nearest_points = nsmallest(k, points, key=lambda point: (distance(point), point[0], point[1])) return nearest_points"},{"question":"# Coding Assessment Question Scenario & Context You are given an unsorted array of integers, and you need to find the k-th largest element in the array. This problem will test your understanding of sorting algorithms, selection algorithms, and efficient ways to handle large datasets. Problem Statement Write a function `find_kth_largest` to find the k-th largest element in an unsorted array. Function Signature ```python def find_kth_largest(nums: list[int], k: int) -> int: pass ``` Input * `nums` (List[int]): A list of unsorted integers. * `k` (Integer): An integer representing the k-th position in terms of largest elements. Output * Return the k-th largest element in the array. Constraints * `1 ≤ len(nums) ≤ 10^5` * `-10^4 ≤ nums[i] ≤ 10^4` * `1 ≤ k ≤ len(nums)` Examples ```python >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 ``` Notes * You can assume that all the inputs provided are valid according to constraints. * Consider the efficiency of your solution, especially for large arrays. Naive approaches that fully sort the array may not be optimal for upper constraint limits. * Think about using data structures like heaps or implementing partition-based algorithms to achieve optimal performance. **Performance Requirement**: Aim for a solution with a time complexity close to O(n) on average, particularly for large inputs.","solution":"import heapq def find_kth_largest(nums: list[int], k: int) -> int: Returns the k-th largest element in an unsorted array. # Use a min-heap to keep track of the largest k elements heap = [] for num in nums: heapq.heappush(heap, num) if len(heap) > k: heapq.heappop(heap) return heap[0]"},{"question":"# Coding Assessment Question Scenario You are working on an application that involves performing analytical operations on large datasets. One frequent task is to detect anomalous sequences within time-series data. Specifically, you\'re interested in finding the longest subsequence of consecutive numbers that are lower than a certain threshold value. Task Write a function `longest_subsequence_below_threshold(arr, threshold)` that finds the length of the longest contiguous subsequence within a given list of integers where each element in the subsequence is less than the specified threshold. Function Signature ```python def longest_subsequence_below_threshold(arr: list[int], threshold: int) -> int: ``` Input - `arr` (list of int): A list of integers representing the dataset. - `threshold` (int): The threshold value to check against the dataset. Must be a valid integer. Output - (int): The length of the longest valid contiguous subsequence in which all elements are less than the threshold. Constraints - The function should raise a `ValueError` if `arr` is not a list of integers or if `threshold` is not an integer. - Both `arr` and `threshold` should be valid inputs. If `arr` is empty, return 0. - The function should perform efficiently for length of `arr` up to 1,000,000. Example ```python >>> longest_subsequence_below_threshold([1, 2, 3, 4, 5, 6], 4) 3 >>> longest_subsequence_below_threshold([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 6) 5 >>> longest_subsequence_below_threshold([1, 2, 3], 0) 0 >>> longest_subsequence_below_threshold([], 5) 0 >>> longest_subsequence_below_threshold([1, \\"2\\", 3], 4) Traceback (most recent call last): ... ValueError: arr must be a list of integers >>> longest_subsequence_below_threshold([1, 2, 3], \\"4\\") Traceback (most recent call last): ... ValueError: threshold must be an integer >>> longest_subsequence_below_threshold([1, 2, 3], 2.5) Traceback (most recent call last): ... ValueError: threshold must be an integer ``` Note that your implementation should handle invalid inputs and edge cases as demonstrated in the example.","solution":"def longest_subsequence_below_threshold(arr, threshold): Returns the length of the longest contiguous subsequence within `arr` where each element in the subsequence is less than `threshold`. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"arr must be a list of integers\\") if not isinstance(threshold, int): raise ValueError(\\"threshold must be an integer\\") max_length = 0 current_length = 0 for num in arr: if num < threshold: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Advanced Data Structures: Implementing a Custom Priority Queue **Scenario**: You are developing a scheduling system for a multi-threaded application where tasks are executed based on priority. To efficiently manage the tasks, you need to implement a custom priority queue that supports dynamic priority adjustment. **Task**: Implement the `CustomPriorityQueue` class with methods to insert, extract, and adjust priorities while maintaining the queue\'s order for optimal performance. **Function Signatures**: ```python class CustomPriorityQueue: def __init__(self): pass def insert(self, task: str, priority: int) -> None: pass def extract_max(self) -> str: pass def adjust_priority(self, task: str, new_priority: int) -> None: pass ``` **Requirements**: 1. **Initialization (`__init__`)**: - Initializes an empty priority queue. 2. **Insertion Function (`insert`)**: - Takes a `task` (string) and its `priority` (integer) as input. - Adds the task to the queue with the specified priority. - If the task already exists, raise a `ValueError`. 3. **Extract Max Function (`extract_max`)**: - Removes and returns the task with the highest priority. - If the queue is empty, raise a `IndexError`. 4. **Adjust Priority Function (`adjust_priority`)**: - Takes a `task` and a `new_priority` as input. - Adjusts the priority of the specified task to `new_priority`. - If the task does not exist, raise a `ValueError`. **Constraints**: - Task names are unique strings containing only alphabetic characters. - Priorities are integers and can be both positive and negative. - The priority queue will not have more than 10,000 tasks at any time. **Example**: ```python >>> pq = CustomPriorityQueue() >>> pq.insert(\\"task1\\", 10) >>> pq.insert(\\"task2\\", 5) >>> pq.extract_max() \'task1\' >>> pq.adjust_priority(\\"task2\\", 15) >>> pq.extract_max() \'task2\' >>> pq.insert(\\"task3\\", 2) >>> pq.insert(\\"task4\\", 7) >>> pq.adjust_priority(\\"task4\\", 1) >>> pq.extract_max() \'task3\' ``` Ensure your implementation is efficient and handles errors gracefully. Validate your solution with multiple test cases covering different edge cases and potential errors. **Hints**: - Consider using a max-heap or a binary heap data structure to achieve an optimal time complexity for insertion and extraction operations. - Use a dictionary to maintain a task index for quick priority adjustments and lookups.","solution":"import heapq class CustomPriorityQueue: def __init__(self): self.heap = [] self.task_map = {} self.counter = 0 # This counter will help to maintain the order of insertion def insert(self, task: str, priority: int) -> None: if task in self.task_map: raise ValueError(\\"Task already exists.\\") entry = (-priority, self.counter, task) self.task_map[task] = entry heapq.heappush(self.heap, entry) self.counter += 1 def extract_max(self) -> str: if not self.heap: raise IndexError(\\"Priority queue is empty.\\") while self.heap: priority, count, task = heapq.heappop(self.heap) if task is not None: del self.task_map[task] return task def adjust_priority(self, task: str, new_priority: int) -> None: if task not in self.task_map: raise ValueError(\\"Task not found.\\") entry = self.task_map[task] self.task_map[task] = (-new_priority, entry[1], task) # Mark the old entry as empty self.heap[self.heap.index(entry)] = (-entry[0], entry[1], None) # Adding new entry heapq.heappush(self.heap, self.task_map[task])"},{"question":"# Problem Statement You are required to implement a function that minimizes a given list of non-negative integers by removing all instances of a specified integer from the list and then returns the modified list and the count of removed integers. Implement the function: * `minimize_list(nums: List[int], num_to_remove: int) -> Tuple[List[int], int]` Function Definition * **`minimize_list`**: * **Input**: * `nums` (List[int]): A list of non-negative integers. * `num_to_remove` (int): The integer to be removed from the list. * **Output**: * `Tuple[List[int], int]`: A tuple containing: * The modified list with all instances of `num_to_remove` removed. * The count of how many instances were removed. Constraints * `nums` should be a list of non-negative integers. * `num_to_remove` should be a non-negative integer present in the list. Error Handling * If `nums` is not a list, raise a `ValueError` with the message: `\\"minimize_list() requires a list for nums\\"`. * If `nums` contains any negative integers, raise a `ValueError` with the message: `\\"nums should contain only non-negative integers\\"`. * If `num_to_remove` is not a non-negative integer, raise a `ValueError` with the message: `\\"minimize_list() requires a non-negative integer for num_to_remove\\"`. Examples * `minimize_list([1, 2, 3, 2, 4, 2], 2)` should return `([1, 3, 4], 3)`. * `minimize_list([5, 9, 5, 5, 8], 5)` should return `([9, 8], 3)`. * `minimize_list([0, 0, 0, 0], 0)` should return `([], 4)`. * `minimize_list([1, 2, 3], 5)` should return `([1, 2, 3], 0)`.","solution":"from typing import List, Tuple def minimize_list(nums: List[int], num_to_remove: int) -> Tuple[List[int], int]: Removes all instances of num_to_remove from the nums list and returns the modified list along with the count of removed integers. if not isinstance(nums, list): raise ValueError(\\"minimize_list() requires a list for nums\\") if any(not isinstance(n, int) or n < 0 for n in nums): raise ValueError(\\"nums should contain only non-negative integers\\") if not isinstance(num_to_remove, int) or num_to_remove < 0: raise ValueError(\\"minimize_list() requires a non-negative integer for num_to_remove\\") count_removed = nums.count(num_to_remove) minimized_list = [n for n in nums if n != num_to_remove] return minimized_list, count_removed"},{"question":"# File System Path Normalizer Scenario You are designing a file system helper that transforms file paths into their canonical form. In a UNIX-like file system, a path can contain multiple references such as `./` (current directory), `../` (parent directory), and extra slashes (`//`). The canonical path should be the shortest absolute path that does not contain any of these redundant components. Task You are required to implement a function `normalize_path` that normalizes a given input path. Function Signature ```python def normalize_path(path: str) -> str: pass ``` Requirements 1. **Input Path**: An absolute UNIX path in string format, which may include redundant components like `./`, `../`, or multiple slashes. 2. **Normalization Rules**: * `./` refers to the current directory and can be ignored. * `../` moves up to the parent directory unless already at the root (`/`). * Consecutive slashes (`//`) are treated as a single slash (`/`). 3. **Return**: The function should return the canonical path as a string. Constraints * The input path starts with a `/` and consists only of ASCII characters. * The length of the input path will not exceed 10^4 characters. Examples ```python # Example 1 path = \\"/home/\\" print(normalize_path(path)) # Output: \\"/home\\" # Example 2 path = \\"/../\\" print(normalize_path(path)) # Output: \\"/\\" # Example 3 path = \\"/home//foo/\\" print(normalize_path(path)) # Output: \\"/home/foo\\" # Example 4 path = \\"/a/./b/../../c/\\" print(normalize_path(path)) # Output: \\"/c\\" ``` ```python def normalize_path(path: str) -> str: parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) normalized = \'/\' + \'/\'.join(stack) return normalized ``` This question maintains the style, complexity, and scope of the given `LRU Cache Photo Viewing Application` question, challenging the candidate to manipulate strings and handle edge cases effectively.","solution":"def normalize_path(path: str) -> str: Normalize the given UNIX-like file system path by removing redundant components. :param path: An absolute UNIX path in string format. :return: The canonical path as a string. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) normalized = \'/\' + \'/\'.join(stack) return normalized"},{"question":"# Matrix Zigzag Traverse **Context**: Traversing a matrix in a zigzag pattern can be useful in various image compression algorithms, such as the JPEG compression standard, which leverages the zigzag order to group low-frequency components together. **Task**: Write a function that takes a 2D matrix of integers and returns a list of integers representing the elements of the matrix traversed in a zigzag order. You should start at the top-left corner of the matrix and follow a zigzag pattern (moving down to the left and then up to the right). **Function Signature**: ```python def zigzag_traverse(matrix: List[List[int]]) -> List[int]: pass ``` **Input and Output**: * **Input**: * `matrix` - A 2D list of integers representing the input matrix. * **Output**: * A list of integers representing the elements of the matrix in zigzag order. **Constraints**: * The matrix dimensions will be between 1 and 1000 (1 ≤ rows, cols ≤ 1000). * The maximum value of an element in the matrix will be 10^6. * The minimum value of an element in the matrix will be -10^6. **Performance Requirements**: * Time Complexity: O(N * M) where N is the number of rows and M is the number of columns. * Space Complexity: O(N * M) for the output list. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Zigzag traversal: [1, 4, 2, 3, 5, 7, 8, 6, 9] output = zigzag_traverse(matrix) print(output) # Output: [1, 4, 2, 3, 5, 7, 8, 6, 9] ```","solution":"def zigzag_traverse(matrix): Given a 2D matrix of integers, returns a list of integers representing the elements of the matrix traversed in a zigzag order. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] row, col = 0, 0 going_down = True while row < rows and col < cols: result.append(matrix[row][col]) if going_down: if col == 0 or row == rows - 1: going_down = False if row == rows - 1: col += 1 else: row += 1 else: row += 1 col -= 1 else: if row == 0 or col == cols - 1: going_down = True if col == cols - 1: row += 1 else: col += 1 else: row -= 1 col += 1 return result"},{"question":"# Problem Statement: Word Ladder Transformation Path In a word ladder problem, you are given two words, a start word and a target word, along with a dictionary of words. Transform the start word into the target word by changing only one letter at a time. Each transformed word must exist in the dictionary. Your task is to determine the sequence of transformations that leads from the start word to the target word with the fewest transformations. # Implementation Details You need to define a function `find_ladder` to solve this problem: 1. **find_ladder**: ```python def find_ladder(start: str, target: str, word_list: List[str]) -> List[str] ``` - Transforms the start word into the target word by changing one letter at a time. - Each transformation must result in a valid word from the dictionary. - `start`: The starting word. - `target`: The target word. - `word_list`: List of valid words forming the dictionary. - Returns the sequence of transformations from the `start` word to the `target` word as a list of strings. If no transformation is possible, returns an empty list. # Example Usage Given the start word \\"hit\\", target word \\"cog\\", and the dictionary `[\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]`: ```python start = \\"hit\\" target = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] print(find_ladder(start, target, word_list)) ``` # Expected Output The function should return the sequence of transformations: ``` [\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'] ``` Or any other valid shortest sequence such as: ``` [\'hit\', \'hot\', \'lot\', \'log\', \'cog\'] ``` # Constraints - Each word in the input list has the same length. - All strings consist only of lowercase English letters. - The word list size (1 leq |word_list| leq 10^4). - The words in `word_list` are guaranteed to be unique. - There will always be exactly one transformation path that leads to the target word if the transformation is possible. If no transformation is possible, the function should return an empty list. Implement the function `find_ladder` to solve the problem. Make sure to handle corner cases and ensure the transformation sequence is valid.","solution":"from collections import deque from typing import List def find_ladder(start: str, target: str, word_list: List[str]) -> List[str]: if target not in word_list or not start or not target or not word_list: return [] word_set = set(word_list) queue = deque([(start, [start])]) while queue: current_word, path = queue.popleft() if current_word == target: return path for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, path + [next_word])) return []"},{"question":"# Skyline Problem You are required to implement a function `get_skyline` that takes a list of buildings represented by triples and returns a list of key points for the skyline formed by these buildings. Requirements: 1. **Input**: - A list of `buildings`, where each building is represented as a triple `[L, R, H]`: - `L` is the x-coordinate of the left edge. - `R` is the x-coordinate of the right edge. - `H` is the height of the building. - Each building is considered a rectangle. - The list of buildings is not necessarily sorted. 2. **Output**: - A list of key points forming the skyline. Each key point is represented as a pair `[x, y]` where `x` is the x-coordinate and `y` is the height of the skyline at that point. Input: * A list of buildings, where each building is a list of three integers `[L, R, H]`, with: - `1 ≤ len(buildings) ≤ 10^5` - `-10^4 ≤ L < R ≤ 10^4` - `0 ≤ H ≤ 10^4` Output: * A list of key points forming the skyline, with: - Each key point represented as a list of two integers `[x, y]`. Example: ```python buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] assert get_skyline(buildings) == [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` Explanation: - The buildings are represented as rectangles on the x-axis. - The skyline is a list of \\"critical points\\" where the height of the outline changes. This list should be sorted by the x-coordinate. - When two buildings overlap, the higher building (larger value of `H`) should be considered part of the skyline. Implementation Hint: * Utilize a priority queue (heap) to keep track of the buildings\' heights as you sweep through the sorted x-coordinates. * Consider including start and end points of the buildings in the events list and processing them to maintain the current heights. ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: # Implement the function to return the skyline key points pass ``` Note: The goal is to handle the problem efficiently. Prioritize optimization in terms of both time and space complexity for the given constraints.","solution":"from typing import List import heapq def get_skyline(buildings: List[List[int]]) -> List[List[int]]: # Generate events for start and end of buildings events = [(L, -H, R) for L, R, H in buildings] events += [(R, 0, None) for _, R, _ in buildings] # Sort events by x-coordinate, and by height descending for starts events.sort() # Resulting list of key points res = [] # Priority queue (max-heap) for active buildings live_heap = [(0, float(\'inf\'))] # (negative height, right endpoint) for x, negH, R in events: # Remove ending events from the heap (those that have passed the current x) while live_heap[0][1] <= x: heapq.heappop(live_heap) # If it\'s a start event, add to the heap if negH: heapq.heappush(live_heap, (negH, R)) # Get the highest building current height max_height = -live_heap[0][0] # If the current height changes from the last recorded point, it is a key point if not res or res[-1][1] != max_height: res.append([x, max_height]) return res"},{"question":"# Problem Description Create a function that simulates a simple library system to manage user checkouts and returns for books. The library has a limited number of copies for each book, and users need to follow specific rules for checkout and return processes. # Function Requirements Write a function `library_system` that processes a series of commands related to book checkouts and returns, updating the availability status of each book accordingly. Input * `commands` (List[str]): A list of commands, where each command is a string in one of the following formats: - `\\"checkout <user_id> <book_title>\\"`: Indicates that a user with ID `user_id` wants to check out the book titled `book_title`. - `\\"return <user_id> <book_title>\\"`: Indicates that a user with ID `user_id` wants to return the book titled `book_title`. - `\\"status <book_title>\\"`: Requests the current availability status of the book titled `book_title`. Output * List[str]: For each `\\"status\\"` command in the input, return a string indicating the availability status of the requested book in the format: - `\\"Book \'<book_title>\' is available\\"` if there is at least one copy available. - `\\"Book \'<book_title>\' is checked out by <user_id>\\"` if all copies are currently checked out. Constraints 1. There are at most 10,000 commands in the input list. 2. Each book\'s title is a string with a length of at most 100 characters. 3. Each `user_id` is a string with a length of at most 50 characters. 4. The initial stock of each book and the number of users are not given in the input and should be managed internally based on the commands. # Examples ```python assert library_system([\'checkout user1 HarryPotter\', \'status HarryPotter\', \'return user1 HarryPotter\', \'status HarryPotter\']) == [\\"Book \'HarryPotter\' is checked out by user1\\", \\"Book \'HarryPotter\' is available\\"] assert library_system([\'checkout user2 LOTR\', \'checkout user3 LOTR\', \'status LOTR\', \'return user2 LOTR\', \'status LOTR\']) == [\\"Book \'LOTR\' is checked out by user3\\", \\"Book \'LOTR\' is checked out by user3\\"] assert library_system([\'status PythonEssentials\']) == [\\"Book \'PythonEssentials\' is available\\"] ``` # Instructions 1. Implement a helper function or class to manage the library\'s inventory and user checkouts. 2. Write the `library_system` function that processes each command and maintains the proper state of the library. 3. Ensure your solution efficiently handles the constraints and edge cases as described. # Test your implementation with the provided examples to ensure correctness.","solution":"class Library: def __init__(self): self.books = {} # book_title -> [number_of_copies, {user_id}] def checkout(self, user_id, book_title): if book_title not in self.books: self.books[book_title] = [0, set()] self.books[book_title][1].add(user_id) def return_book(self, user_id, book_title): if book_title in self.books and user_id in self.books[book_title][1]: self.books[book_title][1].remove(user_id) def status(self, book_title): if book_title not in self.books or len(self.books[book_title][1]) == 0: return f\\"Book \'{book_title}\' is available\\" else: return f\\"Book \'{book_title}\' is checked out by {\', \'.join(sorted(self.books[book_title][1]))}\\" def library_system(commands): library = Library() result = [] for command in commands: parts = command.split() action = parts[0] if action == \\"checkout\\": library.checkout(parts[1], parts[2]) elif action == \\"return\\": library.return_book(parts[1], parts[2]) elif action == \\"status\\": result.append(library.status(parts[1])) return result"},{"question":"# Coding Question: Find and Replace Substring A publishing company is working on a project that involves processing a vast collection of text documents. They need a function that can identify and replace all instances of a specific substring within a given text. Given the varying lengths and structures of the documents, the function should be optimized for performance while ensuring that all occurrences of the substring are correctly identified and replaced. Task: Write a function that finds all occurrences of a target substring in a given text and replaces them with a specified replacement substring. Additionally, the function should return the number of replacements made. You should ensure the function handles edge cases effectively, including overlapping substrings and empty strings. Requirements: 1. **Input**: - A string `text`. - A string `target`. - A string `replacement`. 2. **Output**: - A tuple containing the modified text and the count of replacements made. Constraints: - The length of `text` (n) is between 0 and 10^6. - Both `target` and `replacement` strings are of length between 0 and 1000. - Handle scenarios where `text`, `target`, or `replacement` might be empty. Example: ```python >>> find_and_replace(\\"Hello world, hello!\\", \\"hello\\", \\"hi\\") (\'Hello world, hi!\', 1) >>> find_and_replace(\\"ababab\\", \\"aba\\", \\"ab\\") (\'abab\', 2) >>> find_and_replace(\\"aaaaa\\", \\"aa\\", \\"a\\") (\'aaa\', 2) >>> find_and_replace(\\"\\", \\"a\\", \\"b\\") (\'\', 0) ``` # Your task: 1. Implement the function `find_and_replace` with enhanced functionality. 2. Ensure that your function efficiently handles large texts and various edge cases. 3. Handle invalid cases gracefully where applicable. **Function signature**: ```python def find_and_replace(text: str, target: str, replacement: str) -> tuple: pass ``` Note: - You should not use any in-built replace or similar functions. - Provide a brief explanation of your approach and how you handle edge cases, including overlapping substrings.","solution":"def find_and_replace(text, target, replacement): Finds all occurrences of the target in text and replaces them with the replacement. Returns a tuple of (modified text, count of replacements). if target == \\"\\": # If target is empty, return the original text and zero replacements return text, 0 result = [] i = 0 replacements = 0 while i < len(text): if text[i:i+len(target)] == target: result.append(replacement) replacements += 1 i += len(target) else: result.append(text[i]) i += 1 modified_text = \\"\\".join(result) return modified_text, replacements"},{"question":"# Question: Determine the Balance Factor of a Binary Tree In this task, you need to write a Python function that takes the root of a binary tree and returns the balance factor of the tree. The balance factor of a binary tree is defined as the difference between the height of its left subtree and the height of its right subtree. Function Signature ```python def balance_factor(root: TreeNode) -> int: pass ``` Input * `root` (TreeNode): The root node of a binary tree. The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * An integer representing the balance factor of the binary tree. Constraints * The number of nodes in the tree will be in the range [0, 10^4]. * -10^5 <= Node.val <= 10^5 Example ```python # Test Case 1 # Input: [1, 2, 3, 4, 5, null, null] # Structure: 1 # / # 2 3 # / # 4 5 # Output: 1 (height of left subtree is 3, height of right subtree is 2) assert balance_factor(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == 1 # Test Case 2 # Input: [1, null, 2, null, 3] # Structure: 1 # # 2 # # 3 # Output: -2 (height of left subtree is 0, height of right subtree is 2) assert balance_factor(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) == -2 # Test Case 3 # Input: [] # Structure: (empty tree) # Output: 0 (height of both left and right subtrees is 0) assert balance_factor(None) == 0 ``` Implementation Requirements * You may implement additional helper functions to compute the height of a subtree if necessary. * Ensure proper handling of edge cases, particularly when the tree is empty. Tips * Reuse the `height` function or write a new one to recursively calculate the height of each subtree. * Consider using a bottom-up approach to avoid redundant height calculations and ensure efficiency. * Handle cases where the tree is empty. # Note Do not modify the provided `TreeNode` class definition.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height(node): if node is None: return 0 return 1 + max(height(node.left), height(node.right)) def balance_factor(root: TreeNode) -> int: if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return left_height - right_height"},{"question":"# Coding Question Instructions: You are given a list of words and a query string. Implement a function that finds all anagrams of the query string within the list of words. An anagram is a word formed by rearranging the letters of another word. Function Signature: ```python def find_anagrams(words: List[str], query: str) -> List[str]: pass ``` Input: * `words` (List[str]): A list of words (strings). * `query` (str): A query string. Output: * Returns a list of strings, where each string is an anagram of the query string found in the input list of words. Constraints: * 1 ≤ len(words) ≤ 1000 * 1 ≤ len(words[i]), len(query) ≤ 50 * All characters in `words` and `query` are lowercase alphabets. Example: ```python words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"golang\\"] query = \\"inlets\\" # Expected output [\\"listen\\", \\"silent\\", \\"enlist\\"] ``` Notes: * You should consider only valid anagrams that are fully formed (use all characters in the query string exactly once). * Handle cases where there are no anagrams in the list of words by returning an empty list. * Make sure your function performs efficiently for larger inputs within the given constraints.","solution":"from typing import List def find_anagrams(words: List[str], query: str) -> List[str]: Finds all anagrams of the query string within the list of words. from collections import Counter query_counter = Counter(query) result = [] for word in words: if Counter(word) == query_counter: result.append(word) return result"},{"question":"Problem Statement Imagine you are working on a program that analyzes user comments on a blog post. To detect and count the frequency of specific keywords (hashtags) in the comments, you need to implement a function that identifies these hashtags and tallies their occurrences. # Function Signature ```python def count_hashtags(comments: list[str], keywords: list[str]) -> dict[str, int]: pass ``` # Input - `comments`: A list of strings where each string represents a user\'s comment. - `keywords`: A list of strings where each string is a hashtag of interest. # Output - Returns a dictionary with keywords as keys and integers as values representing the number of times each keyword appears in the list of comments. # Constraints - `len(comments) <= 10^4` - `len(keywords) <= 100` - Each comment\'s length (`len(comments[i])`) is <= 200 - Keywords consist of only alphanumeric characters and prefixed with a `#`. # Requirements - The function should efficiently count occurrences of each keyword in the comments. - The function should be case-insensitive (e.g., `#Python` and `#python` should be treated as the same hashtag). # Example Example 1: ```python comments = [\\"I love #python and #data\\", \\"Learning #Python is fun!\\", \\"What\'s new in #PYTHON?\\"] keywords = [\\"#python\\", \\"#data\\"] count_hashtags(comments, keywords) ``` **Output**: `{\'#python\': 3, \'#data\': 1}` Example 2: ```python comments = [\\"#AI is the future\\", \\"Exploring the world of #AI\\", \\"#AI, #machinelearning, and #deeplearning are fascinating!\\"] keywords = [\\"#ai\\", \\"#machinelearning\\", \\"#deeplearning\\"] count_hashtags(comments, keywords) ``` **Output**: `{\'#ai\': 3, \'#machinelearning\': 1, \'#deeplearning\': 1}` Example 3: ```python comments = [\\"Nothing relevant here\\", \\"Another random comment\\"] keywords = [\\"#notfound\\"] count_hashtags(comments, keywords) ``` **Output**: `{\'#notfound\': 0}` # Additional Requirements - Your implementation should handle edge cases like comments with no keywords, keywords not appearing in any comment, and multiple occurrences of words in a single comment. # Hints - Consider using a data structure that allows quick lookup and insertion for counting. - Ensure your solution is scalable and performs well with a large number of comments.","solution":"def count_hashtags(comments: list[str], keywords: list[str]) -> dict[str, int]: from collections import defaultdict import re # Initialize the result dictionary with keyword counts set to 0 hashtag_counts = defaultdict(int) # Normalize keywords to lowercase for case-insensitive comparison normalized_keywords = {keyword.lower(): keyword for keyword in keywords} # Compile a regex to find hashtags hashtag_pattern = re.compile(r\'#w+\') for comment in comments: # Find all hashtags in the comment hashtags_in_comment = hashtag_pattern.findall(comment.lower()) # Count the hashtags that are in the list of keywords for hashtag in hashtags_in_comment: if hashtag in normalized_keywords: hashtag_counts[normalized_keywords[hashtag]] += 1 # Ensure all keywords are present in the result, even if their count is 0 for keyword in keywords: if keyword not in hashtag_counts: hashtag_counts[keyword] = 0 return dict(hashtag_counts)"},{"question":"# Problem Statement You have been assigned to build a simplified version of a web server log parser. This tool should help in identifying the IP addresses that have accessed the server and the frequency of their requests. # Requirements 1. Create a function `parse_logs(logs: List[str]) -> Dict[str, int]` that takes a list of web server log entries as input and returns a dictionary where keys are IP addresses and values are the count of how many requests have been made by each IP. 2. Each log entry follows the format: `\\"<IP> - - [timestamp] \\"request\\" status bytes\\"`. 3. Validate input to ensure: - Log entries are non-empty strings. - IP addresses follow the standard IPv4 format. 4. Handle and return appropriate error messages or exceptions for invalid inputs. # Input - **logs**: A list of strings, each string being a log entry. # Output - A dictionary with IP addresses as keys and request counts as values. # Examples ```python # Example 1 logs = [ \\"192.168.0.1 - - [01/Jan/2021:10:00:00 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024\\", \\"192.168.0.2 - - [01/Jan/2021:10:01:00 +0000] \\"POST /form HTTP/1.1\\" 200 2048\\", \\"192.168.0.1 - - [01/Jan/2021:10:02:00 +0000] \\"GET /about.html HTTP/1.1\\" 200 512\\" ] print(parse_logs(logs)) # Output: {\'192.168.0.1\': 2, \'192.168.0.2\': 1} # Example 2 logs = [ \\"10.0.0.1 - - [02/Feb/2021:14:20:00 +0000] \\"GET /home HTTP/1.1\\" 200 2048\\", \\"10.0.0.1 - - [02/Feb/2021:14:22:00 +0000] \\"POST /login HTTP/1.1\\" 401 512\\", \\"10.0.0.2 - - [02/Feb/2021:14:25:00 +0000] \\"GET /dashboard HTTP/1.1\\" 200 1024\\" ] print(parse_logs(logs)) # Output: {\'10.0.0.1\': 2, \'10.0.0.2\': 1} # Example 3 logs = [ \\"invalid-log-entry\\" ] print(parse_logs(logs)) # Output: ValueError: Invalid log entry format. # Example 4 logs = [ \\"256.256.256.256 - - [01/Jan/2021:10:00:00 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024\\" ] print(parse_logs(logs)) # Output: ValueError: Invalid IP address format. ``` # Constraints - The list `logs` should not exceed 10,000 log entries. - IP addresses should be validated against this regex pattern: `r\'^d{1,3}.d{1,3}.d{1,3}.d{1,3}\'`. - Assume a valid log entry can have an IP address with each octet in the range 0-255 and follows the format provided.","solution":"import re from typing import List, Dict def parse_logs(logs: List[str]) -> Dict[str, int]: Parses a list of web server logs and counts the frequency of requests per IP address. Args: logs (List[str]): A list of log entries. Returns: Dict[str, int]: A dictionary with IP addresses as keys and request counts as values. Raises: ValueError: If a log entry format or IP address format is invalid. ip_pattern = re.compile(r\'^d{1,3}.d{1,3}.d{1,3}.d{1,3}\') def is_valid_log(log: str) -> bool: parts = log.split() if len(parts) < 7: return False ip = parts[0] if not ip_pattern.match(ip): return False # Validate each octet is within the 0-255 range octets = ip.split(\'.\') for octet in octets: if not (0 <= int(octet) <= 255): return False return True log_count = {} for log in logs: if not is_valid_log(log): raise ValueError(\\"Invalid log entry format or invalid IP address format.\\") ip = log.split()[0] if ip in log_count: log_count[ip] += 1 else: log_count[ip] = 1 return log_count"},{"question":"# Coding Question Problem Statement You are given a list of integers called `numbers`. Write a Python function `find_longest_subsequence` that returns the length of the longest contiguous subsequence of `numbers` that contains at most three distinct integers. If the list is empty, return `0`. Your solution must handle invalid inputs gracefully by throwing a `ValueError` with the message \\"Input must be a list of integers\\". Requirements - Function Signature: `def find_longest_subsequence(numbers: list) -> int:` - **Input**: A list of integers `numbers`. - **Output**: An integer representing the length of the longest contiguous subsequence with at most three distinct integers. - **Constraints**: The length of `numbers` could be between 0 and 10^5, and the values in `numbers` are within the range of -10^9 to 10^9. Example ```python >>> find_longest_subsequence([1, 2, 1, 3, 4, 3, 5]) 4 >>> find_longest_subsequence([1, 2, 1, 2, 1, 2]) 6 >>> find_longest_subsequence([4, 5, 6, 7, 8, 9]) 3 >>> find_longest_subsequence([1]) 1 >>> find_longest_subsequence([]) 0 >>> find_longest_subsequence([10, \'test\', 20]) Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> find_longest_subsequence(123) Traceback (most recent call last): ... ValueError: Input must be a list of integers ``` Constraints - The function should handle input errors by raising `ValueError` with the message \\"Input must be a list of integers\\". - The function should be efficient enough to handle the largest possible input within the provided range. Additional Notes - Consider using a sliding window approach for optimal performance. - Make sure your implementation is robust and handles edge cases, including the empty list and cases where there aren\'t many distinct integers.","solution":"def find_longest_subsequence(numbers: list) -> int: if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") for num in numbers: if not isinstance(num, int): raise ValueError(\\"Input must be a list of integers\\") n = len(numbers) if n == 0: return 0 max_length = 0 start = 0 counts = {} for end in range(n): if numbers[end] in counts: counts[numbers[end]] += 1 else: counts[numbers[end]] = 1 while len(counts) > 3: counts[numbers[start]] -= 1 if counts[numbers[start]] == 0: del counts[numbers[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Question: Find Duplicate in Array Using XOR You are given an array of integers where each integer appears exactly twice, except for one integer that appears only once. Your task is to find the integer that appears only once using XOR bitwise operation. Implement the function `find_unique` that returns the unique integer. Function Signature: ```python def find_unique(arr: list) -> int: ``` Input: - `arr` (list): A list of integers where all elements appear exactly twice except for one element which appears only once. Output: - (int): Returns the integer that appears only once. Constraints: 1. The list will contain at least 1 and at most 10^5 integers. 2. You are not allowed to use any extra space, such as sets, dictionaries, or new lists. The solution should have O(1) extra space complexity. 3. Use bitwise XOR operation to achieve the solution. Example Usage: ```python assert find_unique([1, 2, 3, 2, 1]) == 3 assert find_unique([4, 1, 2, 1, 2]) == 4 assert find_unique([7, 3, 5, 4, 5, 4, 3]) == 7 assert find_unique([10, 12, 10]) == 12 ``` Additional Notes: - If the array is empty, raise a `ValueError` with the message `\\"array must not be empty\\"`. - Ensure to handle cases where input is not a list of integers, raising a `TypeError` with an appropriate message.","solution":"def find_unique(arr): Finds the integer that appears only once in the list using XOR bitwise operation. Parameters: arr (list): A list of integers where all elements appear exactly twice except for one element which appears only once. Returns: int: The integer that appears only once. Raises: ValueError: If the list is empty. TypeError: If the input is not a list of integers. if not arr: raise ValueError(\\"array must not be empty\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"all elements in array must be integers\\") unique = 0 for num in arr: unique ^= num return unique"},{"question":"# Coding Assessment Question **Scenario**: You are working on a file management system that helps users organize and manage files on their local disks. As a part of the feature set, you need to create a function that can group files based on their extensions. **Task**: Implement a function `group_files_by_extension` that reads all files from a given directory and groups them by their extensions. The function should return a dictionary where the keys are the file extensions, and the values are lists of file names with that extension. **Function Signature**: ```python def group_files_by_extension(directory: str) -> dict: Groups files in the given directory by their extensions. Args: directory (str): The path to the directory to scan for files. Returns: dict: A dictionary where keys are file extensions and values are lists of file names with that extension. ``` **Example**: For a directory with the following files: ``` document1.txt image1.png document2.txt presentation.pptx image2.jpg script.py ``` The function should output something like: ```python { \'txt\': [\'document1.txt\', \'document2.txt\'], \'png\': [\'image1.png\'], \'pptx\': [\'presentation.pptx\'], \'jpg\': [\'image2.jpg\'], \'py\': [\'script.py\'] } ``` **Constraints**: 1. Your function must: - Handle cases where the directory contains subdirectories (ignore subdirectories and only process files). - Handle cases with files that have no extensions and include them under an empty string key `\'\'`. - Use appropriate error handling to deal with cases where the directory does not exist or is not readable. - Output file names without the directory path. 2. Assume the directory will contain at most 10,000 files. **Performance Boundaries**: - Ensure that your function processes the files efficiently, minimizing the time complexity. **Additional Notes**: - You can use libraries like `os` or `pathlib` to interact with the file system. - Consider properly structuring and commenting your code for readability and maintainability. ```python import os from collections import defaultdict def group_files_by_extension(directory: str) -> dict: Groups files in the given directory by their extensions. Args: directory (str): The path to the directory to scan for files. Returns: dict: A dictionary where keys are file extensions and values are lists of file names with that extension. file_groups = defaultdict(list) # Check if the directory exists if not os.path.isdir(directory): raise ValueError(f\\"The directory {directory} does not exist or is not a directory.\\") # Iterate through the directory for item in os.listdir(directory): item_path = os.path.join(directory, item) if os.path.isfile(item_path): _, extension = os.path.splitext(item) extension = extension.lstrip(\'.\') file_groups[extension].append(item) return dict(file_groups) # Example usage: result = group_files_by_extension(\\"/path/to/directory\\") for ext, files in result.items(): print(f\\"Extension: .{ext}nFiles: {files}n\\") ```","solution":"import os from collections import defaultdict def group_files_by_extension(directory: str) -> dict: Groups files in the given directory by their extensions. Args: directory (str): The path to the directory to scan for files. Returns: dict: A dictionary where keys are file extensions and values are lists of file names with that extension. file_groups = defaultdict(list) # Check if the directory exists if not os.path.isdir(directory): raise ValueError(f\\"The directory {directory} does not exist or is not a directory.\\") # Iterate through the directory for item in os.listdir(directory): item_path = os.path.join(directory, item) if os.path.isfile(item_path): _, extension = os.path.splitext(item) extension = extension.lstrip(\'.\') file_groups[extension].append(item) return dict(file_groups)"},{"question":"# Efficient String Matching with Knuth-Morris-Pratt Algorithm **Scenario**: You are working for a company that specializes in text processing and analysis. A frequent task involves scanning large text documents to find specific patterns or keywords. To enhance the performance of your text scanning application, you have decided to implement the Knuth-Morris-Pratt (KMP) algorithm for efficient string matching. The dataset consists of a large text body and a pattern string that you need to search for within the text. Your goal is to detect the first occurrence of the pattern in the text, or determine that the pattern does not exist within the text. **Task**: Write a function `kmp_search` that implements the Knuth-Morris-Pratt algorithm to find the start index of the first occurrence of a given pattern string within a given text string. If the pattern is not found, the function should return -1. # Function Signature ```python def kmp_search(text: str, pattern: str) -> int: pass ``` # Input - A string, `text` (0 <= len(text) <= 10^7). - A string, `pattern` (0 <= len(pattern) <= 10^6). # Output - An integer indicating the start index of the first occurrence of `pattern` in `text`, or -1 if the `pattern` is not found. # Constraints 1. The length of the text and pattern strings can be large, up to 10 million and 1 million characters respectively. 2. The search should be efficient and make use of the KMP algorithm\'s linear time complexity. # Example ```python print(kmp_search(\\"abxabcabcaby\\", \\"abcaby\\")) # Output: 6 print(kmp_search(\\"hello world\\", \\"world\\")) # Output: 6 print(kmp_search(\\"a\\" * 10000000, \\"b\\" * 1000000)) # Output: -1 print(kmp_search(\\"\\", \\"pattern\\")) # Output: -1 print(kmp_search(\\"pattern\\", \\"\\")) # Output: 0 ``` # Evaluation Criteria 1. **Accuracy**: Correctly identifies the start index of the first occurrence of the pattern. 2. **Efficiency**: Demonstrates efficient performance with large text and pattern inputs using the KMP algorithm. 3. **Robustness**: Handles edge cases effectively, such as empty text or pattern strings. 4. **Clarity**: Code is well-structured and easily comprehensible. **Note**: While not mandatory, including detailed internal comments to explain your KMP preprocessing (partial match table / LPS array) and search steps could enhance the readability and comprehensibility of your solution.","solution":"def kmp_search(text: str, pattern: str) -> int: Implements the Knuth-Morris-Pratt (KMP) algorithm to find the start index of the first occurrence of the pattern string within the text string. Returns -1 if the pattern is not found. # Edge cases if not pattern: return 0 if not text or len(pattern) > len(text): return -1 # Preprocess pattern to create the longest prefix suffix (LPS) array lps = [0] * len(pattern) j = 0 # Length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # KMP search algorithm i = 0 # Index for text j = 0 # Index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j # Found the pattern elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1 # Pattern not found"},{"question":"# Music Playlist Shuffle Problem Description You are tasked with creating a function to shuffle a music playlist in a specific manner. The function needs to ensure that each song is played, but the order should appear random while avoiding consecutive repetitions of the same artist more than once. Requirements: 1. **Shuffle Playlist Function**: Implement the function `shuffle_playlist(playlist: list[tuple[str, str]]) -> list[tuple[str, str]]` that takes a list of songs where each song is represented by a tuple containing the song\'s title and the artist\'s name. 2. **Constraints**: - Ensure no two consecutive songs are by the same artist. - All songs in the input playlist must be included in the output in a \\"shuffled\\" manner. - If such a shuffle is not possible, return an empty list. Example: ```python playlist = [ (\\"Song1\\", \\"ArtistA\\"), (\\"Song2\\", \\"ArtistB\\"), (\\"Song3\\", \\"ArtistC\\"), (\\"Song4\\", \\"ArtistA\\"), (\\"Song5\\", \\"ArtistB\\") ] shuffled_playlist = shuffle_playlist(playlist) print(shuffled_playlist) ``` Possible Output: ```python [(\\"Song1\\", \\"ArtistA\\"), (\\"Song2\\", \\"ArtistB\\"), (\\"Song3\\", \\"ArtistC\\"), (\\"Song4\\", \\"ArtistA\\"), (\\"Song5\\", \\"ArtistB\\")] ``` or ```python [(\\"Song2\\", \\"ArtistB\\"), (\\"Song1\\", \\"ArtistA\\"), (\\"Song3\\", \\"ArtistC\\"), (\\"Song4\\", \\"ArtistA\\"), (\\"Song5\\", \\"ArtistB\\")] ``` Note that the sequence of songs may vary as long as the constraint regarding consecutive artists is satisfied. Solution Template: ```python from typing import List, Tuple import random def shuffle_playlist(playlist: List[Tuple[str, str]]) -> List[Tuple[str, str]]: # Implement the function logic to shuffle the playlist pass # Example Usage playlist = [ (\\"Song1\\", \\"ArtistA\\"), (\\"Song2\\", \\"ArtistB\\"), (\\"Song3\\", \\"ArtistC\\"), (\\"Song4\\", \\"ArtistA\\"), (\\"Song5\\", \\"ArtistB\\") ] shuffled_playlist = shuffle_playlist(playlist) print(shuffled_playlist) ``` Notes: - Your algorithm needs to handle cases where shuffling isn\'t straightforward due to a large number of consecutive songs by the same artist. - Consider using randomness and backtracking to find a suitable sequence. - Efficient implementation is important, but correctness is paramount. Test your function thoroughly to ensure it handles a wide range of scenarios, including edge cases such as small playlists or cases with one artist dominating the list.","solution":"from typing import List, Tuple import random from collections import defaultdict def shuffle_playlist(playlist: List[Tuple[str, str]]) -> List[Tuple[str, str]]: # First, group songs by artist artist_to_songs = defaultdict(list) for song, artist in playlist: artist_to_songs[artist].append((song, artist)) # Create a list of the artists with their songs sorted_artists = sorted(artist_to_songs.items(), key=lambda x: len(x[1]), reverse=True) result = [] last_artist = None while sorted_artists: new_sorted_artists = [] flag = False for artist, songs in sorted_artists: if artist != last_artist: result.append(songs.pop()) last_artist = artist flag = True if songs: new_sorted_artists.append((artist, songs)) if not flag: return [] sorted_artists = sorted(new_sorted_artists, key=lambda x: len(x[1]), reverse=True) return result"},{"question":"# Coding Question: Validating User Input for Form Submission **Scenario**: You are developing an online form for user registrations and need to ensure that all inputs meet specified requirements before saving them to the database. The form includes a username, password, and email. **Requirements**: 1. Implement a function `validate_user_input(username: str, password: str, email: str) -> bool` that validates the inputs based on the following criteria: - The `username` must be a non-empty string, contain only alphanumeric characters, and be between 5 and 20 characters in length. - The `password` must be a non-empty string, be at least 8 characters long, and include at least one uppercase letter, one lowercase letter, one digit, and one special character (`!@#%^&*()`). - The `email` must be a non-empty string that matches the pattern of a valid email address. 2. If all validations pass, the function should return `True`. Otherwise, it returns `False`. **Input**: * `username` - A string representing the username. * `password` - A string representing the password. * `email` - A string representing the email address. **Output**: * Returns `True` if all inputs are valid. * Returns `False` if any of the validations fail. **Constraints**: * The username, password, and email will each contain at most 100 characters. **Example**: ```python def validate_user_input(username: str, password: str, email: str) -> bool: # Your implementation here pass # Example use case valid = validate_user_input(\\"User123\\", \\"Passw0rd!\\", \\"user@example.com\\") print(valid) # Output: True valid = validate_user_input(\\"User\\", \\"Passw0rd!\\", \\"user@example.com\\") print(valid) # Output: False # Username is too short valid = validate_user_input(\\"User123\\", \\"password\\", \\"user@example.com\\") print(valid) # Output: False # Password does not include uppercase, digit, or special character valid = validate_user_input(\\"User123\\", \\"Passw0rd!\\", \\"userexample.com\\") print(valid) # Output: False # Invalid email format ``` **Hints**: * Utilize Python\'s `re` library for regex pattern matching. * Consider edge cases such as empty strings and special character handling.","solution":"import re def validate_user_input(username: str, password: str, email: str) -> bool: if not (5 <= len(username) <= 20 and username.isalnum()): return False if not (len(password) >= 8 and re.search(r\'[A-Z]\', password) and re.search(r\'[a-z]\', password) and re.search(r\'[0-9]\', password) and re.search(r\'[!@#%^&*()]\', password)): return False email_pattern = r\'^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' if not re.match(email_pattern, email): return False return True"},{"question":"# Question Context In many applications, it is necessary to validate numerical inputs to ensure they conform to certain rules before performing calculations or operations on them. For example, ensuring that a number is prime can be a critical step in tasks related to cryptography or in generating unique identifiers which are less likely to collide. Task Your task is to implement a function `is_prime` that takes a positive integer and returns a boolean indicating whether the number is prime or not. Handle the edge cases and provide validations for the input. Function Signature ```python def is_prime(number: int) -> bool: Determine whether the given integer is a prime number. :param number: The integer number to evaluate :return: True if the number is prime, False otherwise. Raises: TypeError: If the input is not an integer. ValueError: If the input is a negative number or zero. Examples: >>> is_prime(29) True >>> is_prime(15) False >>> is_prime(2) True >>> is_prime(1) False >>> is_prime(-5) ValueError: Number must be a positive integer greater than 1 ``` Constraints - The input number must be a positive integer greater than 1. - The function must raise a `TypeError` if the input is not an integer. - The function must raise a `ValueError` if the input is a negative number or zero. Requirements - The function should be efficient and avoid checking unnecessary cases. - Include proper exception handling. - Ensure proper docstrings and comments in your implementation. Example ```python number = 17 # 17 is a prime number since it is only divisible by 1 and 17 itself. print(is_prime(number)) # Output: True ``` Notes - Include proper docstrings and comments in your implementation. - Ensure to handle invalid inputs gracefully. - Optimize the algorithm where possible to handle large numbers efficiently.","solution":"def is_prime(number: int) -> bool: Determine whether the given integer is a prime number. :param number: The integer number to evaluate :return: True if the number is prime, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is a negative number or zero. Examples: >>> is_prime(29) True >>> is_prime(15) False >>> is_prime(2) True >>> is_prime(1) False >>> try: ... is_prime(-5) ... except ValueError as ve: ... print(ve) Number must be a positive integer greater than 1 if not isinstance(number, int): raise TypeError(\\"Input must be an integer.\\") if number <= 0: raise ValueError(\\"Number must be a positive integer greater than 1.\\") if number < 2: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True"},{"question":"# Coding Assessment Question: Subarray with a Given Sum Problem Statement: You are given an array of positive integers and a target sum. Your task is to find the smallest contiguous subarray whose sum is greater than or equal to the target sum. If no such subarray exists, return 0. Implement a function that solves this problem efficiently. Function Signature: ```python def min_subarray_length(target: int, arr: list) -> int: Find the length of the smallest contiguous subarray whose sum is greater than or equal to the target sum. ``` Constraints: 1. The length of the array `arr` will be between 1 and `10^5`. 2. The elements of the array will be positive integers up to `10^5`. 3. The target will be a positive integer. Example: 1. Input: `target = 7`, `arr = [2, 3, 1, 2, 4, 3]` Output: `2` Explanation: The subarray `[4, 3]` has the minimum length under the problem constraint. 2. Input: `target = 15`, `arr = [1, 2, 3, 4, 5]` Output: `5` Explanation: The whole array sums up to 15, which is the target sum. 3. Input: `target = 100`, `arr = [1, 2, 3, 4, 5]` Output: `0` Explanation: There is no subarray that sums up to 100 or more. Notes: - Consider using a sliding window technique to improve the efficiency of the solution. - Focus on ensuring the code is optimized for large inputs, as the constraints allow up to `10^5` elements. - The function should handle edge cases, such as when the array length is 1. Evaluation criteria: - Correctness: The algorithm should correctly identify the smallest contiguous subarray whose sum meets the criteria. - Efficiency: The solution should handle the input size constraints efficiently within acceptable time limits. - Edge Cases: Proper handling of edge cases and constraints compatibility.","solution":"def min_subarray_length(target: int, arr: list) -> int: n = len(arr) min_length = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"**Scenario**: You are tasked with developing a contact management system that allows users to store and retrieve contact details efficiently. The system should support basic functionalities such as adding a contact, searching for a contact by name, and listing all contacts in lexicographical order. **Challenge**: Implement the following functions: `add_contact`, `find_contact`, and `list_contacts`. Your implementations should adhere to the following specifications: 1. `add_contact(all_contacts: Dict[str, str], name: str, phone: str) -> None`: Adds a new contact to the dictionary of contacts. If the contact name already exists, update the phone number. 2. `find_contact(all_contacts: Dict[str, str], name: str) -> str`: Finds the phone number of the given contact name. If the contact does not exist, return \\"Contact not found\\". 3. `list_contacts(all_contacts: Dict[str, str]) -> List[Tuple[str, str]]`: Returns a list of all contacts in lexicographical order, where each contact is a tuple consisting of the name and the phone number. # Function Signatures ```python def add_contact(all_contacts: Dict[str, str], name: str, phone: str) -> None: pass def find_contact(all_contacts: Dict[str, str], name: str) -> str: pass def list_contacts(all_contacts: Dict[str, str]) -> List[Tuple[str, str]]: pass ``` # Example Usage ```python contacts = {} add_contact(contacts, \\"Alice\\", \\"12345\\") add_contact(contacts, \\"Bob\\", \\"67890\\") add_contact(contacts, \\"Alice\\", \\"54321\\") # Update Alice\'s phone number assert find_contact(contacts, \\"Alice\\") == \\"54321\\" assert find_contact(contacts, \\"Charlie\\") == \\"Contact not found\\" expected_contacts = [(\\"Alice\\", \\"54321\\"), (\\"Bob\\", \\"67890\\")] assert list_contacts(contacts) == expected_contacts ``` # Constraints and Performance Requirements * The phone number will be a string consisting of 5 to 15 digits. * The contact name will be a string consisting of 1 to 100 alphanumeric characters. * Ensure all operations (`add_contact`, `find_contact`, `list_contacts`) are efficient and handle up to 10,000 contacts smoothly. * Edge cases, such as adding an empty contact or searching for a non-existent contact, should be managed gracefully. # Notes * Your implementation should optimize for quick search and retrieval operations. * Ensure the contact listing is lexicographically sorted to make searching easier. * Consider using appropriate data structures to manage the contact list efficiently.","solution":"from typing import Dict, Tuple, List def add_contact(all_contacts: Dict[str, str], name: str, phone: str) -> None: Adds a new contact to the dictionary of contacts. If the contact name already exists, update the phone number. :param all_contacts: Dictionary containing all contacts. :param name: Name of the contact. :param phone: Phone number of the contact. all_contacts[name] = phone def find_contact(all_contacts: Dict[str, str], name: str) -> str: Finds the phone number of the given contact name. If the contact does not exist, return \\"Contact not found\\". :param all_contacts: Dictionary containing all contacts. :param name: Name of the contact to find. :return: Phone number of the contact or \\"Contact not found\\" if the contact does not exist. return all_contacts.get(name, \\"Contact not found\\") def list_contacts(all_contacts: Dict[str, str]) -> List[Tuple[str, str]]: Returns a list of all contacts in lexicographical order, where each contact is a tuple consisting of the name and the phone number. :param all_contacts: Dictionary containing all contacts. :return: List of tuples, each containing the contact name and phone number, in lexicographical order. return sorted(all_contacts.items())"},{"question":"# Nearest Neighbor Search in 2D Plane Problem Statement: You are given a list of points in a 2-dimensional plane. Your task is to implement the **nearest neighbor search** algorithm to find the point that is closest to a given target point. Implement this functionality using both brute force and an optimized approach using a KD-Tree. Function Signatures: 1. `def brute_force_nearest(points: list[tuple[int, int]], target: tuple[int, int]) -> tuple[int, int]:` 2. `def kd_tree_nearest(points: list[tuple[int, int]], target: tuple[int, int]) -> tuple[int, int]:` Input: - `points`: List of tuples representing points in a 2D plane, e.g., `[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]` - `target`: Tuple representing the target point in the 2D plane, e.g., `(4, 4)` Output: - Return the point (tuple) that is closest to the `target`. - If `points` list is empty, return `None`. Constraints: - Each point is a tuple containing two integers. - The list of points can be empty, in which case you should handle it gracefully. Performance Requirements: - The brute force implementation should have a time complexity of O(N), where N is the number of points. - The KD-Tree implementation should have an average time complexity of O(log N) for nearest neighbor queries. Testing: You should validate your solutions using various test cases including edge cases. Example: ```python # Example Input points = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)] target = (4, 4) # Example Output for Brute Force Nearest point: (3, 4) # Example Output for KD-Tree Nearest point: (3, 4) # Example Input points = [(0, 0), (2, 1), (3, 5)] target = (3, 3) # Example Output for Brute Force Nearest point: (2, 1) # Example Output for KD-Tree Nearest point: (2, 1) ``` # Additional Requirements: - Do not use any built-in KD-Tree implementations; write your own KD-Tree construction and search functions. - Ensure your KD-Tree search handles ties by returning any one of the equally closest points. - Implement error handling to manage scenarios where input constraints are violated.","solution":"import math def brute_force_nearest(points, target): Find the nearest neighbor to the target point using brute force approach. if not points: return None min_distance = float(\'inf\') nearest_point = None for point in points: distance = math.dist(point, target) if distance < min_distance: min_distance = distance nearest_point = point return nearest_point class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right def kd_tree_nearest(points, target): Find the nearest neighbor to the target point using KD-Tree. if not points: return None def build_kd_tree(points, depth=0): if not points: return None k = len(points[0]) # assumes all points have the same dimension axis = depth % k points.sort(key=lambda x: x[axis]) median = len(points) // 2 return KDTreeNode( point=points[median], left=build_kd_tree(points[:median], depth + 1), right=build_kd_tree(points[median + 1:], depth + 1) ) def kd_tree_nearest_rec(node, target, depth=0, best_node=None, best_dist=float(\'inf\')): if node is None: return best_node, best_dist k = len(target) axis = depth % k point = node.point d = math.dist(point, target) if d < best_dist: best_dist = d best_node = point diff = target[axis] - point[axis] if diff <= 0: best_node, best_dist = kd_tree_nearest_rec(node.left, target, depth + 1, best_node, best_dist) if abs(diff) < best_dist: best_node, best_dist = kd_tree_nearest_rec(node.right, target, depth + 1, best_node, best_dist) else: best_node, best_dist = kd_tree_nearest_rec(node.right, target, depth + 1, best_node, best_dist) if abs(diff) < best_dist: best_node, best_dist = kd_tree_nearest_rec(node.left, target, depth + 1, best_node, best_dist) return best_node, best_dist kd_tree_root = build_kd_tree(points) nearest_point, _ = kd_tree_nearest_rec(kd_tree_root, target) return nearest_point"},{"question":"# Group Anagrams Context You are given a list of strings, and you need to group the anagrams together. Two strings are considered to be anagrams if one is a rearrangement of the other. Objective Write a function that takes a list of strings and returns a list of lists of strings, where each sublist contains strings that are anagrams of each other. 1. Grouping must be done efficiently, taking into account both time and space complexity. 2. The output order of the groups and the order of words within each group does not need to be sorted. Requirements - **Input/Output Specifications**: * Function signature: `def group_anagrams(strs: List[str]) -> List[List[str]]:` * Input: A list of strings, `strs`, with 0 <= len(strs) <= 10^4 and each string having 1 <= len(str) <= 100. * Output: A list of lists, each containing strings that are anagrams of each other. - **Constraints**: * The solution should have an average time complexity of O(N * M log M), where N is the length of the list and M is the maximum length of a string. * Handling of edge cases where the input list is empty. Implementation The function should utilize a dictionary to group the strings by their sorted characters as the key. This approach enables efficient grouping. Here is a function definition for reference: ```python def group_anagrams(strs: List[str]) -> List[List[str]]: anagram_dict = {} for word in strs: sorted_word = \'\'.join(sorted(word)) if sorted_word in anagram_dict: anagram_dict[sorted_word].append(word) else: anagram_dict[sorted_word] = [word] result = list(anagram_dict.values()) return result ``` Example Usage: ```python print(group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"])) # Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] print(group_anagrams([\\"\\"])) # Output: [[\\"\\"]] print(group_anagrams([\\"a\\"])) # Output: [[\\"a\\"]] print(group_anagrams([])) # Output: [] ``` Ensure comprehensive testing with various cases, including large inputs, to confirm the solution\'s efficiency and correctness.","solution":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: anagram_dict = {} for word in strs: sorted_word = \'\'.join(sorted(word)) if sorted_word in anagram_dict: anagram_dict[sorted_word].append(word) else: anagram_dict[sorted_word] = [word] result = list(anagram_dict.values()) return result"},{"question":"# Coding Assessment Question **Problem Context**: You are building a software that involves handling multiple text files where you often need to count the frequency of each word. The requirement is to write a function to process text data and generate a dictionary with words as keys and their frequencies as values. Your solution should handle case sensitivity and punctuation correctly. **Task**: Implement a function, `word_count(text: str) -> dict`, that takes a string of text and returns a dictionary with each unique word in the text as keys and their corresponding frequencies as values. You should normalize the text to lower case and ignore punctuation. **Function Signature**: ```python def word_count(text: str) -> dict: pass ``` **Constraints**: 1. Ignore punctuations like `.,!?;:`. 2. Treat words with different cases as the same word (e.g., \\"Word\\" and \\"word\\" should be counted together). 3. Handle empty input gracefully by returning an empty dictionary. 4. Optimize the function for large text input. **Input Format**: - A single string containing words, spaces, and punctuation. **Output Format**: - A dictionary with words as keys and their frequencies as values. **Example**: ```python >>> word_count(\\"Hello, world! Hello again.\\") {\'hello\': 2, \'world\': 1, \'again\': 1} >>> word_count(\\"It\'s a test. A test, it is.\\") {\'its\': 1, \'a\': 2, \'test\': 2, \'it\': 1, \'is\': 1} >>> word_count(\\"\\") {} ``` **Hints and Considerations**: - Utilize regular expressions or string methods to remove punctuation. - Use a single scan approach to count the words efficiently. - Ensure the solution is case insensitive and handles multiple punctuations consecutively without errors.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Returns a dictionary with each unique word in the text as keys and their corresponding frequencies as values. # Convert text to lower case text = text.lower() # Remove punctuation using regular expressions text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Count the frequency of each word word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"# Data Structures and Arrays: Implement a Custom Linked List Given the partially implemented `CustomLinkedList` class below, your task is to complete the implementation details for a custom linked list that supports basic operations like adding, removing, and displaying elements. You will need to: 1. **Implement the `add` method** to add a new element at the end of the linked list. 2. **Implement the `remove` method** to remove the first occurrence of an element from the linked list. 3. **Implement the `display` method** to print all elements in the linked list in a readable format. # Implementation Details: 1. **`add` method** should: - Take a single argument, the value to be added to the list. - Append the new value at the end of the list. 2. **`remove` method** should: - Take a single argument, the value to be removed from the list. - Find the first node with the given value and remove it. - If no node with the given value exists, do not alter the list. 3. **`display` method** should: - Print all elements currently in the linked list in the format: `element1 -> element2 -> element3 -> ... -> elementN`. # Input/Output: - **Input**: - For `add` method: ```python def add(self, value): # value: The value to be added to linked list ``` - For `remove` method: ```python def remove(self, value): # value: The value to be removed from linked list ``` - For `display` method: ```python def display(self): # No input required for display method ``` # Constraints: 1. The elements of the linked list are integers. 2. Assume the linked list is initially empty upon creation. # Example Scenario: ```python # Initialize the linked list linked_list = CustomLinkedList() # Add elements to the list linked_list.add(10) linked_list.add(20) linked_list.add(30) linked_list.display() # Should output: 10 -> 20 -> 30 # Remove element from the list linked_list.remove(20) linked_list.display() # Should output: 10 -> 30 # Attempt to remove an element not in the list linked_list.remove(40) linked_list.display() # Should output: 10 -> 30 ``` # Partial Class Implementation: ```python class Node: def __init__(self, value=None, next_node=None): self.value = value self.next_node = next_node class CustomLinkedList: def __init__(self): self.head = None def add(self, value): # Your implementation here pass def remove(self, value): # Your implementation here pass def display(self): # Your implementation here pass ``` # Notes: - Focus on implementing the linked list such that it supports the required methods efficiently. - Pay attention to edge cases, such as removing elements from an empty list or removing all occurrences of an element if necessary. - Ensure the `display` method outputs the values in the correct format.","solution":"class Node: def __init__(self, value=None, next_node=None): self.value = value self.next_node = next_node class CustomLinkedList: def __init__(self): self.head = None def add(self, value): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next_node: current = current.next_node current.next_node = new_node def remove(self, value): current = self.head prev = None while current: if current.value == value: if prev: prev.next_node = current.next_node else: self.head = current.next_node return # Remove only the first occurrence prev = current current = current.next_node def display(self): elements = [] current = self.head while current: elements.append(str(current.value)) current = current.next_node print(\\" -> \\".join(elements))"},{"question":"Problem Statement You are required to implement a spell-checking system that can find and suggest corrections for misspelled words in a given string. The system should use a dictionary of correct words and should also provide the functionality to add new approved words dynamically. # Objectives 1. **Function `spell_check(input_text: str, dictionary: set) -> list`:** - **Input**: - `input_text`: a string containing words separated by spaces. - `dictionary`: a set of strings representing correctly spelled words. - **Output**: A list of tuples where each tuple contains a misspelled word from `input_text` and a list of suggested corrections from the `dictionary`. - **Constraints**: Words in `dictionary` are case-insensitive. - **Requirements**: - If a word in `input_text` is not found in `dictionary`, it is considered misspelled. - Suggested corrections should be case-insensitive matches from `dictionary`. - Suggestions should include words within one character edit (insertions, deletions, or substitutions) of the misspelled word. 2. **Function `add_word_to_dictionary(word: str, dictionary: set)`:** - **Input**: - `word`: A string representing the new word to be added. - `dictionary`: A set of strings representing correctly spelled words. - **Output**: None. - **Action**: Adds `word` to `dictionary`. # Examples ```python # Provided dictionary dictionary = {\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"example\\", \\"of\\", \\"spell\\", \\"checker\\"} # spell_check examples assert spell_check(\\"helo wrld tsst\\", dictionary) == [ (\'helo\', [\'hello\']), (\'wrld\', [\'world\']), (\'tsst\', [\'test\']) ] assert spell_check(\\"helloo wordl\\", dictionary) == [ (\'helloo\', [\'hello\']), (\'wordl\', [\'world\']) ] # add_word_to_dictionary examples add_word_to_dictionary(\\"helo\\", dictionary) assert spell_check(\\"helo wrld\\", dictionary) == [ (\'wrld\', [\'world\']) ] ``` You are expected to write and test your solutions to ensure all scenarios and edge cases are properly handled.","solution":"def spell_check(input_text: str, dictionary: set) -> list: from difflib import get_close_matches def edit_distance_one(word, dictionary): Finds words in the dictionary that are one edit distance away from the given word. suggestions = [] for dic_word in dictionary: if len(dic_word) == len(word) and sum(1 for a, b in zip(dic_word, word) if a != b) == 1: suggestions.append(dic_word) elif abs(len(dic_word) - len(word)) == 1: if len(dic_word) > len(word) and any(dic_word[:i]+dic_word[i+1:] == word for i in range(len(dic_word))): suggestions.append(dic_word) elif len(dic_word) < len(word) and any(word[:i]+word[i+1:] == dic_word for i in range(len(word))): suggestions.append(dic_word) return suggestions dictionary_lower = {word.lower() for word in dictionary} input_words = input_text.split() misspelled_words = [] for word in input_words: if word.lower() not in dictionary_lower: suggestions = get_close_matches(word.lower(), dictionary_lower, n=3, cutoff=0.8) suggestions.extend(edit_distance_one(word.lower(), dictionary_lower)) suggestions = list(set(suggestions)) # Remove duplicates misspelled_words.append((word, suggestions)) return misspelled_words def add_word_to_dictionary(word: str, dictionary: set): Adds a word to the dictionary in a case-insensitive manner. dictionary.add(word.lower())"},{"question":"# Prime Factorization Problem You are tasked with implementing a function in Python that performs prime factorization of a given positive integer. Prime factorization is the process of determining the prime numbers that multiply together to yield the original number. Your task is to implement the following function: 1. `prime_factors(n: int) -> List[int]`: This function calculates the prime factors of a given integer: - **Input**: - `n` (int): The positive integer to be factorized. - **Output**: - Returns a list of prime factors sorted in ascending order. - **Constraint**: - The function should raise a `ValueError` if `n` is less than 2. # Example ```python >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(37) [37] >>> prime_factors(1) Traceback (most recent call last): ... ValueError: Input must be greater than or equal to 2. ``` # Constraints - Ensure your code handles relatively large values efficiently. - Ensure the calculation and precision for finding factors are accurate. # Performance - Time complexity should be (O(sqrt{n}/log n + k)), where (k) is the number of prime factors. - Space complexity should be (O(k)), where (k) is the number of prime factors. Good luck, and remember to test edge cases such as prime numbers and very small values!","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns the prime factors of a given positive integer n. :param n: The integer to be factorized (must be >= 2) :return: A list of prime factors in ascending order if n < 2: raise ValueError(\\"Input must be greater than or equal to 2.\\") factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point, so we can skip one element (i = i + 2) for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n = n // i # If n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Tower of Hanoi Solver You are tasked with implementing a solution to the classic Tower of Hanoi problem. The objective is to move a given number of disks from the first peg to the last peg using a temporary peg, while adhering to the game\'s rules. Problem Statement Implement the Tower of Hanoi algorithm to solve for a given number of disks. Specifically, you need to complete the function `solve_hanoi(n: int, source: str, target: str, auxiliary: str) -> List[str]`. Input Format * `n`: An integer representing the number of disks. * `source`: A character naming the source peg. * `target`: A character naming the target peg. * `auxiliary`: A character naming the auxiliary peg. Output Format * Return a list of strings, where each string represents a move in the format \\"Move disk k from X to Y\\". * `k` is the disk number (ranging from 1 to n). * `X` and `Y` are the names of the source and target pegs, respectively, for that move. Constraints * `n` is a positive integer no greater than 20. * Each peg name is a single upper-case letter, and each peg name is distinct. Example ```python def solve_hanoi(n: int, source: str, target: str, auxiliary: str) -> List[str]: # Your implementation here # Example usage moves = solve_hanoi(3, \'A\', \'C\', \'B\') assert moves == [ \\"Move disk 1 from A to C\\", \\"Move disk 2 from A to B\\", \\"Move disk 1 from C to B\\", \\"Move disk 3 from A to C\\", \\"Move disk 1 from B to A\\", \\"Move disk 2 from B to C\\", \\"Move disk 1 from A to C\\" ] ``` # Implementation - Use recursion to break down the problem into smaller subproblems. - Ensure that you maintain the correct order of moves. - Implement base cases to handle the smallest subproblems. - Combine results from recursive calls to form the solution for the original problem.","solution":"from typing import List def solve_hanoi(n: int, source: str, target: str, auxiliary: str) -> List[str]: Solves the Tower of Hanoi problem and returns a list of moves. Parameters: - n: number of disks - source: the source peg - target: the target peg - auxiliary: the auxiliary peg Returns: A list of strings, where each string represents a move in the format \\"Move disk k from X to Y\\". if n == 1: return [f\\"Move disk 1 from {source} to {target}\\"] moves = [] moves += solve_hanoi(n-1, source, auxiliary, target) # Move n-1 disks from source to auxiliary moves.append(f\\"Move disk {n} from {source} to {target}\\") # Move the nth disk from source to target moves += solve_hanoi(n-1, auxiliary, target, source) # Move n-1 disks from auxiliary to target return moves"},{"question":"# Binary Tree Diameter You are given a binary tree with nodes containing integer values. Your task is to implement a method `diameter` for the `BinaryTree` class that calculates the diameter of the tree. The diameter (or width) of a tree is defined as the number of nodes on the longest path between two end nodes in the tree. Requirements: 1. **Input**: The `diameter` method should take no input parameters (other than `self` for the class method). 2. **Output**: The method should return an integer representing the diameter of the tree. 3. **Performance Constraints**: The method should ideally run in O(n) time complexity, where n is the number of nodes in the tree, and O(h) space complexity, where h is the height of the tree due to the recursion stack. 4. **Corner Cases**: Handle edge cases where the tree is empty or has a single node. Function Signature: ```python def diameter(self) -> int: ``` Example: ```python # Example 1 binary_tree = make_binary_tree([1, 2, 3, 4, 5, None, None]) # Tree structure: # 1 # / # 2 3 # / # 4 5 assert binary_tree.diameter() == 3 # The longest path is 4 -> 2 -> 1 -> 3 or 5 -> 2 -> 1 -> 3 # Example 2 binary_tree = make_binary_tree([1, 2]) # Tree structure: # 1 # / # 2 assert binary_tree.diameter() == 2 # The longest path is 2 -> 1 ``` **Note**: Ensure to thoroughly test your implementation with various edge cases such as trees with only left or right children and balanced trees to validate its correctness.","solution":"class Node: Class representing a node in the binary tree. def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: Class representing the binary tree. def __init__(self, root=None): self.root = root def diameter(self) -> int: Calculate the diameter of the binary tree. The diameter is the number of nodes on the longest path between two end nodes. def depth(node): Helper function to calculate the depth of a node and update the diameter. nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth + 1) return max(left_depth, right_depth) + 1 diameter = 0 depth(self.root) return diameter"},{"question":"# Problem Statement: Design and implement a MaxHeap class that supports insertion of elements with dynamic rearrangement to maintain heap properties, and retrieval (and removal) of the maximum value in constant time. The class should support the following functionalities: 1. **insert(key)**: Insert a new element into the heap while maintaining the heap properties. 2. **extract_max()**: Remove and return the maximum element from the heap. If the heap is empty, return `None`. 3. **heapify_down()**: Private method to maintain heap properties while moving downwards from the root. 4. **heapify_up()**: Private method to maintain heap properties while moving upwards. # Expected Input and Output Formats: * For `insert(key)`: * **Input**: A single integer `key` to be inserted. * **Output**: None. * For `extract_max()`: * **Output**: Return the maximum element value, or `None` if the heap is empty. # Constraints: 1. Assume no duplicate values are inserted. 2. The number of elements in the heap `n` can be up to `10^5`. # Example: ```python heap = MaxHeap() heap.insert(10) heap.insert(20) heap.insert(15) print(heap.extract_max()) # 20 print(heap.extract_max()) # 15 print(heap.extract_max()) # 10 print(heap.extract_max()) # None ``` # Solution Template: You may start with the provided code snippet and complete the class as described in the task. ```python class MaxHeap: def __init__(self): self.heap = [] def insert(self, key): self.heap.append(key) self.heapify_up(len(self.heap) - 1) def extract_max(self): if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self.heapify_down(0) return root def heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self.heapify_down(largest) def heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self.heapify_up(parent) # You can run your tests here heap = MaxHeap() heap.insert(10) heap.insert(20) heap.insert(15) print(heap.extract_max()) # Expected: 20 print(heap.extract_max()) # Expected: 15 print(heap.extract_max()) # Expected: 10 print(heap.extract_max()) # Expected: None ```","solution":"class MaxHeap: def __init__(self): self.heap = [] def insert(self, key): self.heap.append(key) self._heapify_up(len(self.heap) - 1) def extract_max(self): if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def _heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._heapify_down(largest) def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent)"},{"question":"# Scenario You are developing a string utility library for handling various string operations. One of the tasks in the library is to implement a function that finds the longest palindromic substring within a given string. # Task Implement a method `longest_palindromic_substring()` that processes a provided string and returns the longest contiguous palindromic substring within it. # Function Signature Below is the method you need to implement: ```python def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given string. Args: s (str): The input string to search within. Returns: str: The longest palindromic substring. ``` # Input * A single string `s` where 1 <= len(s) <= 10^3 # Output * A string which is the longest palindromic substring found in the input string. # Constraints * The input string `s` consists of printable ASCII characters. # Expected Complexity * Expected time complexity is O(N^2), where N is the length of the string. * Expected space complexity is O(1). # Example Usage ```python print(longest_palindromic_substring(\\"babad\\")) # Expected output: \\"bab\\" or \\"aba\\" print(longest_palindromic_substring(\\"cbbd\\")) # Expected output: \\"bb\\" ``` # Notes - In cases where multiple longest palindromic substrings exist, return any one of them. - A palindrome is a string that reads the same forward and backward (e.g., \\"madam\\", \\"racecar\\").","solution":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given string. Args: s (str): The input string to search within. Returns: str: The longest palindromic substring. if not s: return \\"\\" start, end = 0, 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1] def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1"},{"question":"# Scenario You are asked to create a system to efficiently manage a collection of files, specifically focusing on sorting, searching, and organizing them by their attributes. Each file has an identifier, size, and a timestamp indicating when it was last modified. # Task Description Implement a `FileManager` class that provides the following functionalities: 1. Add a new file. 2. Remove a file by its identifier. 3. Retrieve the file with the largest size. 4. Retrieve the most recently modified file. 5. List files sorted by their size. 6. List files sorted by their last modified timestamp. # Input and Output Formats The `FileManager` class should have the following methods: - `add_file(identifier: str, size: int, timestamp: int)`: Adds a new file with the given identifier, size, and last modified timestamp. - `remove_file(identifier: str)`: Removes the file with the specified identifier. - `get_largest_file() -> str`: Returns the identifier of the file with the largest size. - `get_recently_modified_file() -> str`: Returns the identifier of the file most recently modified. - `list_files_by_size() -> List[str]`: Returns a list of file identifiers sorted by their size in descending order. - `list_files_by_timestamp() -> List[str]`: Returns a list of file identifiers sorted by their last modified timestamp in descending order. # Constraints - File identifiers are unique. - Size and timestamp values are integers. - The number of files (`n`) will not exceed (10^5). # Example ```python file_manager = FileManager() file_manager.add_file(\\"file1\\", 100, 1620034800) file_manager.add_file(\\"file2\\", 200, 1620035800) file_manager.add_file(\\"file3\\", 50, 1620034801) assert file_manager.get_largest_file() == \\"file2\\" assert file_manager.get_recently_modified_file() == \\"file2\\" file_manager.remove_file(\\"file2\\") assert file_manager.get_largest_file() == \\"file1\\" assert file_manager.list_files_by_size() == [\\"file1\\", \\"file3\\"] assert file_manager.list_files_by_timestamp() == [\\"file3\\", \\"file1\\"] ``` # Requirements Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"class FileManager: def __init__(self): self.files = {} def add_file(self, identifier, size, timestamp): self.files[identifier] = {\'size\': size, \'timestamp\': timestamp} def remove_file(self, identifier): if identifier in self.files: del self.files[identifier] def get_largest_file(self): if not self.files: return None return max(self.files.keys(), key=lambda x: self.files[x][\'size\']) def get_recently_modified_file(self): if not self.files: return None return max(self.files.keys(), key=lambda x: self.files[x][\'timestamp\']) def list_files_by_size(self): return sorted(self.files.keys(), key=lambda x: self.files[x][\'size\'], reverse=True) def list_files_by_timestamp(self): return sorted(self.files.keys(), key=lambda x: self.files[x][\'timestamp\'], reverse=True)"},{"question":"# Scenario You are developing an e-commerce platform and need to implement a discount calculation feature based on customer inputs. The discount rules are complex and must be applied based on a set of conditions and customer details. # Problem Statement Write a Python function `calculate_discounted_prices(customers: List[Dict[str, Any]], rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]` to compute the discounted price for each customer based on given discount rules. # Requirements 1. **Input/Output Specifications**: * `calculate_discounted_prices(customers: List[Dict[str, Any]], rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]` - **customers**: A list of dictionaries where each dictionary contains customer details: * `customer_id`: Unique identifier for the customer. * `total_spent`: Total amount the customer has spent. * `items_purchased`: Number of items purchased by the customer. * `membership_level`: The membership level of the customer (\\"Silver\\", \\"Gold\\", or \\"Platinum\\"). - **rules**: A list of dictionaries where each dictionary contains discount rule details: * `membership_level`: The membership level that the discount applies to. * `min_items`: Minimum number of items that must be purchased to get the discount. * `min_spent`: Minimum amount that must be spent to get the discount. * `discount_percentage`: The discount percentage to be applied. - **Output**: A list of dictionaries where each dictionary contains the `customer_id` and `discounted_price`. 2. **Constraints**: * Assume `total_spent` is a positive float. * Assume `items_purchased` is a positive integer. * The discount should only be applied if all conditions (membership level, minimum items, and minimum spent) are satisfied. 3. **Performance Requirements**: * Ensure the solution can handle up to 10,000 customers and 50 discount rules efficiently. # Example ```python def calculate_discounted_prices(customers: List[Dict[str, Any]], rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]: # Your implementation here # Example inputs: customers = [ {\\"customer_id\\": 1, \\"total_spent\\": 200.0, \\"items_purchased\\": 5, \\"membership_level\\": \\"Gold\\"}, {\\"customer_id\\": 2, \\"total_spent\\": 100.0, \\"items_purchased\\": 2, \\"membership_level\\": \\"Silver\\"}, ] rules = [ {\\"membership_level\\": \\"Gold\\", \\"min_items\\": 3, \\"min_spent\\": 150.0, \\"discount_percentage\\": 10}, {\\"membership_level\\": \\"Silver\\", \\"min_items\\": 2, \\"min_spent\\": 50.0, \\"discount_percentage\\": 5}, ] # Example usage: result = calculate_discounted_prices(customers, rules) print(result) # Output: # [ # {\\"customer_id\\": 1, \\"discounted_price\\": 180.0}, # Gold member, qualifies for 10% discount # {\\"customer_id\\": 2, \\"discounted_price\\": 95.0} # Silver member, qualifies for 5% discount # ] ``` # Notes 1. Ensure you handle and apply multiple discount rules correctly. 2. If a customer does not meet any rule criteria, the discounted price should be the same as the total spent. 3. Ensure to document your solution thoroughly for ease of understanding and maintenance.","solution":"from typing import List, Dict, Any def calculate_discounted_prices(customers: List[Dict[str, Any]], rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]: def apply_discount(total_spent, discount_percentage): return total_spent * ((100 - discount_percentage) / 100.0) result = [] for customer in customers: customer_id = customer[\\"customer_id\\"] total_spent = customer[\\"total_spent\\"] items_purchased = customer[\\"items_purchased\\"] membership_level = customer[\\"membership_level\\"] applicable_discount = 0 for rule in rules: if (membership_level == rule[\\"membership_level\\"] and items_purchased >= rule[\\"min_items\\"] and total_spent >= rule[\\"min_spent\\"]): applicable_discount = max(applicable_discount, rule[\\"discount_percentage\\"]) discounted_price = apply_discount(total_spent, applicable_discount) result.append({ \\"customer_id\\": customer_id, \\"discounted_price\\": discounted_price }) return result"},{"question":"# Problem Statement You have been tasked with processing a large dataset of dictionary entries representing employee records. Each record contains various attributes such as name, age, department, and salary. Your goal is to implement two functions: one to filter out employees based on a minimum salary requirement and another to sort the filtered results by age in ascending order. # Task **Implement the following two functions:** 1. `filter_employees_by_salary(records, min_salary)` 2. `sort_employees_by_age(filtered_records)` **Specifications**: 1. `filter_employees_by_salary(records, min_salary)`: - This function should return a list of employee records where the salary is greater than or equal to `min_salary`. - If the input list `records` is empty or if no employee meets the salary requirement, return an empty list. 2. `sort_employees_by_age(filtered_records)`: - This function should take the list returned by the first function and return it sorted by the employee\'s age in ascending order. - If the input list `filtered_records` is empty, return an empty list. **Input Format**: - A list of dictionaries `records`, where each dictionary contains the following keys: - `\'name\'` (string): The name of the employee. - `\'age\'` (int): The age of the employee. - `\'department\'` (string): The department where the employee works. - `\'salary\'` (float): The salary of the employee. - An integer `min_salary` specifying the minimum salary. **Output Format**: - A list of dictionaries sorted by the employee\'s age in ascending order. **Examples**: ```python >>> employees = [ ... {\'name\': \'Alice\', \'age\': 30, \'department\': \'HR\', \'salary\': 40000.0}, ... {\'name\': \'Bob\', \'age\': 25, \'department\': \'Engineering\', \'salary\': 50000.0}, ... {\'name\': \'Charlie\', \'age\': 35, \'department\': \'Marketing\', \'salary\': 30000.0} ... ] >>> filtered_employees = filter_employees_by_salary(employees, 35000) >>> filtered_employees [ {\'name\': \'Alice\', \'age\': 30, \'department\': \'HR\', \'salary\': 40000.0}, {\'name\': \'Bob\', \'age\': 25, \'department\': \'Engineering\', \'salary\': 50000.0} ] >>> sorted_employees = sort_employees_by_age(filtered_employees) >>> sorted_employees [ {\'name\': \'Bob\', \'age\': 25, \'department\': \'Engineering\', \'salary\': 50000.0}, {\'name\': \'Alice\', \'age\': 30, \'department\': \'HR\', \'salary\': 40000.0} ] >>> filtered_employees = filter_employees_by_salary(employees, 60000) >>> filtered_employees [] >>> sorted_employees = sort_employees_by_age(filtered_employees) >>> sorted_employees [] ``` # Constraints: - Each employee\'s age is a positive integer. - The salary for each employee is a non-negative float. - There can be multiple employees with the same age. - The number of employee records can be up to 10^5.","solution":"def filter_employees_by_salary(records, min_salary): This function filters employee records based on a minimum salary requirement. Args: records (list of dict): The list of employee records. min_salary (int): The minimum salary requirement. Returns: list of dict: The filtered list of employee records. return [record for record in records if record[\'salary\'] >= min_salary] def sort_employees_by_age(filtered_records): This function sorts a list of employee records by age in ascending order. Args: filtered_records (list of dict): The list of filtered employee records. Returns: list of dict: The sorted list of employee records by age. return sorted(filtered_records, key=lambda x: x[\'age\'])"},{"question":"# Remove Duplicate Lines from a File You are provided with a class `FileProcessor` that currently has basic functionality to read from and write to text files. Your task is to extend the functionality of this class to remove duplicate lines from a file while preserving the order of the first occurrence of each line. 1. **Remove Duplicates**: * Implement a method `remove_duplicates(input_file: str, output_file: str) -> bool` that reads lines from `input_file`, removes any duplicate lines, and writes the unique lines to `output_file`. 2. **File Handling**: * Ensure that the method gracefully handles errors such as file not found, permission errors, and I/O errors. **Input**: - A string `input_file` specifying the name of the file to process. - A string `output_file` specifying the name of the file to write the processed content. **Output**: - Return `True` if the operation is successful, otherwise return `False`. **Constraints**: - Lines in the file can contain any characters including non-printable ones. - The method should preserve the original order of lines, keeping only the first occurrence of each line. **Example Usage**: ```python processor = FileProcessor() # Remove duplicate lines from file if processor.remove_duplicates(\\"input.txt\\", \\"unique_output.txt\\"): print(\\"Duplicates removed successfully\\") else: print(\\"Failed to remove duplicates\\") ``` Write the enhanced class `FileProcessor` with the specified functionality. # Example Suppose `input.txt` contains the following lines: ``` Hello World Hello Python Hello World ``` After processing, `unique_output.txt` should contain: ``` Hello World Python ``` Write the `FileProcessor` class with the `remove_duplicates` method to achieve the above functionality.","solution":"class FileProcessor: def __init__(self): pass def remove_duplicates(self, input_file: str, output_file: str) -> bool: try: with open(input_file, \'r\') as infile: lines = infile.readlines() unique_lines = [] seen_lines = set() for line in lines: if line not in seen_lines: seen_lines.add(line) unique_lines.append(line) with open(output_file, \'w\') as outfile: outfile.writelines(unique_lines) return True except (IOError, FileNotFoundError, PermissionError) as e: print(f\\"Error processing file: {e}\\") return False"},{"question":"# Message Encoder and Decoder You are tasked with creating a communication system that involves encoding and decoding messages using a specific letter shifting technique called \\"Caesar Cipher\\". **Task**: Implement the `MessageSystem` class that supports encoding and decoding text messages. **Class Definition**: ```python class MessageSystem: def __init__(self, shift): Initialize the MessageSystem with a given shift value. :param shift: The number of positions each letter in the alphabet is shifted. self.shift = shift def encode(self, message): Encode the provided message using Caesar Cipher technique. :param message: The input string message to be encoded. :return: An encoded string where each letter is shifted to the right by self.shift positions. pass def decode(self, message): Decode the provided message using Caesar Cipher technique. :param message: The encoded string message to be decoded. :return: A decoded string where each letter is shifted to the left by self.shift positions. pass ``` **Objective**: You need to define methods `encode` and `decode` such that they perform the Caesar Cipher encoding and decoding operations on the messages. **Encoding Rules**: - Shift each letter in the message to the right by the given shift value (wrapping around the alphabet if necessary). - Preserve the case of each letter. - Non-alphabet characters (such as spaces and punctuation) should remain unaffected. **Decoding Rules**: - Shift each letter in the encoded message to the left by the initially set shift value to retrieve the original message. - Preserve the case of each letter. - Non-alphabet characters should remain unaffected. **Input/Output**: * **Input**: `encode` and `decode` methods take a string message as input. * **Output**: `encode` returns the encoded message as a string. `decode` returns the decoded message as a string. **Constraints**: * The shift value is an integer in the range [0, 25]. * Message characters will be in the range [a-z] and [A-Z], with possible spaces or special characters. **Example**: ```python # Create an instance with a shift of 3 message_system = MessageSystem(3) # Example message message = \\"Hello, World!\\" # Encoding the message encoded_message = message_system.encode(message) # Expected output: \\"Khoor, Zruog!\\" # Decoding the message back decoded_message = message_system.decode(encoded_message) # Expected output: \\"Hello, World!\\" ``` Implement the methods `encode` and `decode` inside the `MessageSystem` class to achieve the described functionality and test based on the provided example.","solution":"class MessageSystem: def __init__(self, shift): Initialize the MessageSystem with a given shift value. :param shift: The number of positions each letter in the alphabet is shifted. self.shift = shift def encode(self, message): Encode the provided message using Caesar Cipher technique. :param message: The input string message to be encoded. :return: An encoded string where each letter is shifted to the right by self.shift positions. encoded_message = [] for char in message: if char.isalpha(): # Check if it\'s an alphabet character shift_base = ord(\'A\') if char.isupper() else ord(\'a\') encoded_char = chr((ord(char) - shift_base + self.shift) % 26 + shift_base) encoded_message.append(encoded_char) else: encoded_message.append(char) # Non-alphabet characters remain unchanged return \'\'.join(encoded_message) def decode(self, message): Decode the provided message using Caesar Cipher technique. :param message: The encoded string message to be decoded. :return: A decoded string where each letter is shifted to the left by self.shift positions. decoded_message = [] for char in message: if char.isalpha(): shift_base = ord(\'A\') if char.isupper() else ord(\'a\') decoded_char = chr((ord(char) - shift_base - self.shift) % 26 + shift_base) decoded_message.append(decoded_char) else: decoded_message.append(char) # Non-alphabet characters remain unchanged return \'\'.join(decoded_message)"},{"question":"# Question: Implementing Graph Search Algorithms In this task, you will implement two fundamental graph search algorithms, Depth-First Search (DFS) and Breadth-First Search (BFS). Understanding and implementing these search algorithms are essential for solving various graph-related problems. Objectives: 1. Implement the following graph search algorithms: 1. **Depth-First Search (DFS)** 2. **Breadth-First Search (BFS)** 2. Your implementation should be capable of exploring and traversing graphs represented as adjacency lists. Function Specifications: **Depth-First Search (DFS)** ```python def depth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: Parameters: - graph: Adjacency list representing the graph, where the keys are node identifiers and the values are lists of adjacent nodes. - start: The starting node for the DFS traversal. Returns: - List[int]: The nodes visited during the DFS traversal, in the order they were visited. ``` **Breadth-First Search (BFS)** ```python def breadth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: Parameters: - graph: Adjacency list representing the graph, where the keys are node identifiers and the values are lists of adjacent nodes. - start: The starting node for the BFS traversal. Returns: - List[int]: The nodes visited during the BFS traversal, in the order they were visited. ``` Constraints: 1. The input graph is a dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes (also integers). 2. Ensure the `start` node is a valid node present in the graph. 3. Handle graphs with multiple components (disconnected graphs) by traversing only the component that includes the `start` node. Example Usage: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1] } start_node = 0 print(depth_first_search(graph, start_node)) # Output: [0, 1, 3, 4, 2] print(breadth_first_search(graph, start_node)) # Output: [0, 1, 2, 3, 4] ``` You need to write these functions from scratch. Use standard data structures such as stacks and queues to facilitate the search algorithms. Good luck!","solution":"from typing import Dict, List def depth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) # Reverse to maintain order return visited def breadth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited"},{"question":"# Path Sum in a Binary Tree - Depth-First Search Challenge **Context**: Suppose you are given a binary tree and a target sum. You need to determine if the tree has a root-to-leaf path such that the sum of the values along the path equals the given target sum. This task involves using depth-first search (DFS) techniques in a recursive manner. **Function to Implement**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target: int) -> bool: pass ``` **Input**: - `root` (TreeNode): The root of the binary tree. - `target` (int): An integer representing the target sum. **Output**: - Returns a boolean value `True` if there exists a root-to-leaf path in the binary tree where the sum of the node values is equal to `target`, otherwise returns `False`. **Constraints**: - The number of nodes in the tree is in the range [0, 5000]. - -10^4 <= TreeNode.val <= 10^4 - -10^4 <= target <= 10^4 **Performance Requirements**: - Aim for an optimal solution with a time complexity of O(n), where n is the number of nodes in the tree. **Examples**: ```python # Example 1: # Input: # 5 # / # 4 8 # / / # 11 13 4 # / #7 2 1 # Target = 22 # Output: True (because the path 5->4->11->2 sums to 22) root1 = TreeNode(5) root1.left = TreeNode(4) root1.right = TreeNode(8) root1.left.left = TreeNode(11) root1.left.left.left = TreeNode(7) root1.left.left.right = TreeNode(2) root1.right.left = TreeNode(13) root1.right.right = TreeNode(4) root1.right.right.right = TreeNode(1) assert has_path_sum(root1, 22) == True # Example 2: # Input: # 1 # / # 2 3 # Target = 5 # Output: False root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) assert has_path_sum(root2, 5) == False # Example 3: # Input: # 1 # Target = 1 # Output: True root3 = TreeNode(1) assert has_path_sum(root3, 1) == True ``` **Hint**: - Consider approaching the problem using a recursive depth-first search (DFS), where you subtract the current node value from the target sum at each step, and check if you reach a leaf node with the remaining target sum equal to zero.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target: int) -> bool: if not root: return False if not root.left and not root.right: return target == root.val target -= root.val return has_path_sum(root.left, target) or has_path_sum(root.right, target)"},{"question":"# Question: Implementing a Simple Neural Network for Binary Classification Context You are required to implement a simple neural network from scratch for binary classification. The neural network should consist of one input layer, one hidden layer, and one output layer. You will use sigmoid activation function for the neurons in the hidden and output layer. Task Implement a class `SimpleNeuralNetwork` that can be trained on a given dataset to classify data points into two classes. The network should be able to make predictions once it is trained. Classes and Methods 1. **SimpleNeuralNetwork** - **Constructor**: - `__init__(self, input_size: int, hidden_size: int, output_size: int) -> None`: Initializes the network with specified number of neurons in the input layer, hidden layer, and output layer. - **Activation Function**: - `_sigmoid(x: np.ndarray) -> np.ndarray`: Applies the sigmoid activation function. - `_sigmoid_derivative(x: np.ndarray) -> np.ndarray`: Computes the derivative of the sigmoid function. - **Train Model**: - `train(self, X: np.ndarray, y: np.ndarray, epochs: int, learning_rate: float) -> None`: Trains the neural network using gradient descent for a specified number of epochs and learning rate. - **Predict Values**: - `predict(self, X: np.ndarray) -> np.ndarray`: Predicts values based on the trained model parameters. Input and Output Format - **Class Method: `train`** - **Input**: - `X`: 2D `np.ndarray` of shape (n_samples, n_features) for the input training data. - `y`: 1D `np.ndarray` of shape (n_samples,) for the target binary labels (0 or 1). - `epochs`: Integer representing the number of iterations for training. - `learning_rate`: Float representing the step size for the gradient descent. - **Output**: - `None` - **Class Method: `predict`** - **Input**: - `X`: 2D `np.ndarray` of shape (n_samples, n_features) for the input test data. - **Output**: - Returns a 1D `np.ndarray` of shape (n_samples,) with predicted binary labels (0 or 1). Example Usage ```python import numpy as np class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size # Initialize weights self.W1 = np.random.randn(input_size, hidden_size) self.b1 = np.zeros((1, hidden_size)) self.W2 = np.random.randn(hidden_size, output_size) self.b2 = np.zeros((1, output_size)) def _sigmoid(self, x): return 1 / (1 + np.exp(-x)) def _sigmoid_derivative(self, x): return x * (1 - x) def train(self, X, y, epochs, learning_rate): for epoch in range(epochs): # Forward pass z1 = np.dot(X, self.W1) + self.b1 a1 = self._sigmoid(z1) z2 = np.dot(a1, self.W2) + self.b2 a2 = self._sigmoid(z2) # Backward pass error_output = y - a2 d_output = error_output * self._sigmoid_derivative(a2) error_hidden = d_output.dot(self.W2.T) d_hidden = error_hidden * self._sigmoid_derivative(a1) # Update weights and biases self.W2 += a1.T.dot(d_output) * learning_rate self.b2 += np.sum(d_output, axis=0, keepdims=True) * learning_rate self.W1 += X.T.dot(d_hidden) * learning_rate self.b1 += np.sum(d_hidden, axis=0, keepdims=True) * learning_rate def predict(self, X): z1 = np.dot(X, self.W1) + self.b1 a1 = self._sigmoid(z1) z2 = np.dot(a1, self.W2) + self.b2 a2 = self._sigmoid(z2) predictions = np.round(a2) return predictions # Example Data X_train = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) y_train = np.array([0, 1, 1, 0]) # Create and train the neural network nn = SimpleNeuralNetwork(input_size=2, hidden_size=2, output_size=1) nn.train(X_train, y_train, epochs=10000, learning_rate=0.1) # Make predictions X_test = np.array([[0, 0], [1, 1]]) predictions = nn.predict(X_test) print(predictions) # Output should be close to [0, 0] ``` Constraints - Ensure input data `X` and `y` are numpy arrays. - Number of features (`input_size`) should match the second dimension of `X`.","solution":"import numpy as np class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size # Initialize weights self.W1 = np.random.randn(input_size, hidden_size) self.b1 = np.zeros((1, hidden_size)) self.W2 = np.random.randn(hidden_size, output_size) self.b2 = np.zeros((1, output_size)) def _sigmoid(self, x): return 1 / (1 + np.exp(-x)) def _sigmoid_derivative(self, x): return x * (1 - x) def train(self, X, y, epochs, learning_rate): for epoch in range(epochs): # Forward pass z1 = np.dot(X, self.W1) + self.b1 a1 = self._sigmoid(z1) z2 = np.dot(a1, self.W2) + self.b2 a2 = self._sigmoid(z2) # Backward pass error_output = y - a2 d_output = error_output * self._sigmoid_derivative(a2) error_hidden = d_output.dot(self.W2.T) d_hidden = error_hidden * self._sigmoid_derivative(a1) # Update weights and biases self.W2 += a1.T.dot(d_output) * learning_rate self.b2 += np.sum(d_output, axis=0, keepdims=True) * learning_rate self.W1 += X.T.dot(d_hidden) * learning_rate self.b1 += np.sum(d_hidden, axis=0, keepdims=True) * learning_rate def predict(self, X): z1 = np.dot(X, self.W1) + self.b1 a1 = self._sigmoid(z1) z2 = np.dot(a1, self.W2) + self.b2 a2 = self._sigmoid(z2) predictions = np.round(a2) return predictions"},{"question":"# Data Structures: Implement a Balanced Binary Search Tree (BBST) **Problem Statement**: You need to implement a class to represent a balanced binary search tree (BBST). The BBST should support insertion, deletion, and search in logarithmic time complexity. For simplicity, you can use an AVL tree or a Red-Black tree to maintain the balance. **Class Signature**: ```python class BalancedBST: def __init__(self): Initialize an empty balanced binary search tree. pass def insert(self, key: int) -> None: Insert a key into the balanced binary search tree. Parameters: key (int): The key to be inserted. pass def delete(self, key: int) -> None: Delete a key from the balanced binary search tree. Parameters: key (int): The key to be deleted. Raises: KeyError: When the key is not found in the tree. pass def search(self, key: int) -> bool: Search for a key in the balanced binary search tree. Parameters: key (int): The key to search for. Returns: bool: True if the key is found, otherwise False. pass ``` **Requirements**: - Your implementation should support the following operations in O(log n) time on average: - `insert(key: int) -> None`: Insert a key into the BBST. - `delete(key: int) -> None`: Delete a key from the BBST. - `search(key: int) -> bool`: Search for a key in the BBST and return a boolean indicating if the key exists. - Ensure that the tree remains balanced after each insert and delete operation to maintain O(log n) complexity for each operation. **Input/Output Examples**: ```python # Example 1: tree = BalancedBST() tree.insert(10) tree.insert(20) tree.insert(5) >>> tree.search(10) True >>> tree.search(15) False tree.delete(10) >>> tree.search(10) False # Example 2: tree = BalancedBST() tree.insert(30) tree.insert(40) tree.insert(35) tree.insert(25) tree.delete(40) tree.insert(5) tree.delete(30) >>> tree.search(30) False >>> tree.search(25) True >>> tree.search(5) True ``` **Constraints**: - All keys are unique integers. - Keys are within the range of -10^9 to 10^9. - The tree should handle up to 10^5 operations efficiently. # Hints: 1. Use self-balancing tree techniques like rotations to maintain the balanced property of the tree. 2. For an AVL tree, you need to calculate and maintain the height of nodes to balance the tree. 3. For a Red-Black tree, ensure the properties of red and black nodes are preserved during insertions and deletions.","solution":"class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right self.height = 1 class BalancedBST: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key: int) -> None: self.root, _ = self._delete(self.root, key) def _delete(self, node, key): if not node: raise KeyError(\\"Key not found\\") if key < node.key: node.left, deleted_node = self._delete(node.left, key) elif key > node.key: node.right, deleted_node = self._delete(node.right, key) else: deleted_node = node if not node.left: return node.right, deleted_node elif not node.right: return node.left, deleted_node temp = self._get_min_value_node(node.right) node.key = temp.key node.right, _ = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node), deleted_node if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node), deleted_node if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node), deleted_node if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node), deleted_node return node, deleted_node def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Coding Assessment Question: A security system logs the success and failure of login attempts. Each login attempt is recorded with a timestamp and a boolean indicating whether the login attempt was successful. Your task is to analyze these logs to determine the time period during which the longest stretch of consecutive failed login attempts occurred. # Objective: Write a function `longest_failed_login_period(logs: List[Tuple[int, bool]]) -> Tuple[int, int]` that returns the start and end timestamps of the longest period of consecutive failed login attempts. # Input: * `logs` (list of tuples): Each tuple contains two elements: - An integer `timestamp` (1 <= timestamp <= 1,000,000,000) representing the time the login attempt was made. - A boolean `status` where `True` indicates a successful login attempt and `False` indicates a failed login attempt. * The `logs` list may contain up to 100,000 entries. # Output: * A tuple containing two integers: - The start timestamp of the longest consecutive failed login attempt period. - The end timestamp of the same period. # Constraints: * Consecutive failed login attempts are logged in strictly increasing order of timestamps. * In case of multiple periods having the same length, return the earliest one. * The list is guaranteed to have at least one failed login attempt. # Example: ```python from typing import List, Tuple def longest_failed_login_period(logs: List[Tuple[int, bool]]) -> Tuple[int, int]: # Your implementation here... pass # Test the function with the example case logs = [ (1, False), (3, False), (7, True), (8, False), (9, False), (10, False), (15, True), (18, False) ] print(longest_failed_login_period(logs)) # Expected output: (8, 10) ``` # Explanation: In the example above, the logs cover several login attempts. The longest stretch of consecutive failed login attempts occurred between timestamps 8 and 10, consisting of 3 failed attempts. # Additional Notes: * Consider edge cases where logs contain only one failed login attempt or multiple equally long periods of failed login attempts. * Ensure the code efficiently handles the maximum constraint for the size of the `logs` list.","solution":"from typing import List, Tuple def longest_failed_login_period(logs: List[Tuple[int, bool]]) -> Tuple[int, int]: max_period_start = None max_period_end = None max_len = 0 current_start = None current_len = 0 for timestamp, status in logs: if not status: if current_start is None: current_start = timestamp current_len += 1 else: if current_len > max_len: max_len = current_len max_period_start = current_start max_period_end = logs[logs.index((timestamp, status)) - 1][0] current_start = None current_len = 0 if current_len > max_len: max_period_start = current_start max_period_end = logs[-1][0] return (max_period_start, max_period_end)"},{"question":"# Problem Statement In this problem, you are asked to work with binary trees. A binary tree is a hierarchical data structure with nodes that have at most two children. Each node in the binary tree contains an integer value, a left child, and a right child. # Task Your task is to implement a method called `mirror_tree` in the `BinaryTree` class. This method should transform the binary tree into its mirror image. In the mirror image, the left and right children of all nodes are swapped. # Method Signature ```python def mirror_tree(self) -> None: Transform the binary tree into its mirror image. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> BT = BinaryTree(root) >>> BT.mirror_tree() >>> print(BT) [1, 3, 2, None, None, 5, 4] ``` # Constraints * The tree may contain up to 10^3 nodes. * The node values are integers within the range [-10^3, 10^3]. * The method should modify the tree in place without using additional data structures apart from the necessary temporary variables. * The tree can be empty. # Expectations 1. The `mirror_tree` method should work without errors on an empty tree. 2. After executing the `mirror_tree` method, the tree should represent the mirror image of the original tree. 3. Ensure no nodes are lost or duplicated during the transformation process. 4. The efficiency of the transformation should be reasonable given the constraints. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root # Method to print tree in level order def __str__(self) -> str: if not self.root: return \\"[]\\" result = [] queue = [self.root] while queue: current = queue.pop(0) if current: result.append(current.val) queue.append(current.left) queue.append(current.right) else: result.append(None) while result and result[-1] is None: result.pop() return str(result) def mirror_tree(self) -> None: # Your code goes here # Example usage root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) BT = BinaryTree(root) BT.mirror_tree() assert str(BT) == \\"[1, 3, 2, None, None, 5, 4]\\" ``` Implement the `mirror_tree` method below: ```python def mirror_tree(self) -> None: # Your code goes here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root # Method to print tree in level order def __str__(self) -> str: if not self.root: return \\"[]\\" result = [] queue = [self.root] while queue: current = queue.pop(0) if current: result.append(current.val) queue.append(current.left) queue.append(current.right) else: result.append(None) while result and result[-1] is None: result.pop() return str(result) def mirror_tree(self) -> None: def _mirror(node): if node: node.left, node.right = node.right, node.left # Swap children _mirror(node.left) # Mirror left subtree _mirror(node.right) # Mirror right subtree _mirror(self.root)"},{"question":"# Memory-efficient Binary Tree Traversal Objective: Optimize binary tree traversal by implementing the Morris Traversal algorithm to reduce its space complexity to O(1). # Task: Write a function `morris_inorder_traversal` that performs inorder traversal of a binary tree without using additional stack or recursion. # Function Specifications: 1. **morris_inorder_traversal(root: TreeNode) -> List[int]**: * Traverses the binary tree in inorder fashion and returns the values of the nodes in a list. * **Input**: * root: The root node of the binary tree. * **Output**: List of integers representing the inorder traversal of the binary tree. # Constraints: - The algorithm should traverse the tree in O(n) time complexity, where n is the number of nodes in the tree. - Space complexity should be O(1) beyond the output list and the input tree. - Your implementation should work for any binary tree, including edge cases like empty trees or trees with only one node. # Example: ```python >>> class TreeNode: >>> def __init__(self, value=0, left=None, right=None): >>> self.value = value >>> self.left = left >>> self.right = right >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> morris_inorder_traversal(root) [1, 3, 2] >>> empty_tree = None >>> morris_inorder_traversal(empty_tree) [] ``` # Notes: - The binary tree node `TreeNode` should be assumed to be defined. - The `morris_inorder_traversal` function should handle any binary tree structure, ensuring pointers are correctly managed to avoid infinite loops or lost references.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def morris_inorder_traversal(root: TreeNode) -> list[int]: result = [] current = root while current: if current.left is None: result.append(current.value) current = current.right else: # Finding the inorder predecessor of current predecessor = current.left while predecessor.right and predecessor.right is not current: predecessor = predecessor.right if predecessor.right is None: # Make current as the right child of its inorder predecessor predecessor.right = current current = current.left else: # Revert the changes made predecessor.right = None result.append(current.value) current = current.right return result"},{"question":"# Question Design a class `PriorityQueue` that implements a priority queue using a min-heap. The class should support the following operations: 1. `insert(key, value)`: Inserts an element with the specified key and value into the priority queue. 2. `extract_min()`: Removes and returns the element with the smallest key. If the priority queue is empty, return `None`. 3. `decrease_key(value, new_key)`: Decreases the key of the specified value to the new key. If the new key is greater than the current key of the specified value, do nothing. 4. `is_empty()`: Returns `True` if the priority queue is empty, `False` otherwise. 5. `size()`: Returns the number of elements in the priority queue. **Class Signature:** ```python class PriorityQueue: def __init__(self): pass def insert(self, key: int, value: Any) -> None: pass def extract_min(self) -> Optional[Tuple[int, Any]]: pass def decrease_key(self, value: Any, new_key: int) -> None: pass def is_empty(self) -> bool: pass def size(self) -> int: pass ``` **Function Descriptions:** - `insert(key, value)`: Inserts an element with the specified key and value into the priority queue. - Parameters: - `key` (int): The key associated with the value, dictating its priority. - `value` (Any): The value to be inserted into the priority queue. - `extract_min()`: Removes and returns the element with the smallest key. - Returns: - `Optional[Tuple[int, Any]]`: A tuple containing the key and the value of the extracted element, or `None` if the queue is empty. - `decrease_key(value, new_key)`: Decreases the key of the specified value to the new key. - Parameters: - `value` (Any): The value whose key is to be decreased. - `new_key` (int): The new key which should be smaller than the current key of the value. - `is_empty()`: Checks if the priority queue is empty. - Returns: - `bool`: `True` if the priority queue is empty, `False` otherwise. - `size()`: Returns the number of elements in the priority queue. - Returns: - `int`: The number of elements in the priority queue. **Constraints:** - The keys are integers, and the values can be of any data type. - The priority queue should maintain the min-heap property for all operations. **Example:** ```python pq = PriorityQueue() pq.insert(4, \'task 1\') pq.insert(2, \'task 2\') pq.insert(5, \'task 3\') print(pq.extract_min()) # Output: (2, \'task 2\') print(pq.is_empty()) # Output: False print(pq.size()) # Output: 2 pq.decrease_key(\'task 1\', 1) print(pq.extract_min()) # Output: (1, \'task 1\') print(pq.size()) # Output: 1 print(pq.is_empty()) # Output: False print(pq.extract_min()) # Output: (5, \'task 3\') print(pq.is_empty()) # Output: True ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, key: int, value: any) -> None: entry = [key, self.counter, value] self.counter += 1 self.entry_finder[value] = entry heapq.heappush(self.heap, entry) def extract_min(self) -> tuple: while self.heap: key, count, value = heapq.heappop(self.heap) if value is not None: del self.entry_finder[value] return (key, value) return None def decrease_key(self, value: any, new_key: int) -> None: if value in self.entry_finder: entry = self.entry_finder[value] if new_key < entry[0]: entry[0] = new_key heapq.heapify(self.heap) def is_empty(self) -> bool: return not bool(self.size()) def size(self) -> int: return len(self.entry_finder)"},{"question":"# Image Compression with RLE **Problem Statement**: You need to compress a given image represented as a 2D grid of pixels using the Run-Length Encoding (RLE) algorithm. RLE is a simple form of data compression in which consecutive occurrences of the same value are stored as a single value and count. Implement a function that performs RLE compression on a 2D grid of pixels. **Function Signature** ```python def compress_image_rle(grid: list[list[int]]) -> list[list[tuple[int, int]]]: pass ``` **Input**: - `grid`: a list of lists (n x m grid) where each inner list represents a row of pixel values. Each pixel is represented by an integer. **Output**: - Returns a list of lists where each inner list represents a row of the compressed image using tuples of `(pixel_value, count)`. **Constraints**: - The grid dimensions are 1 <= n, m <= 100. - Pixel values are non-negative integers. # Example ```python grid = [ [1, 1, 1, 2, 2], [3, 3, 1, 1, 1], [4, 4, 4, 4, 2] ] compress_image_rle(grid) # Output: [ # [(1, 3), (2, 2)], # [(3, 2), (1, 3)], # [(4, 4), (2, 1)] # ] ``` **Notes**: - Ensure to group and count consecutive pixels for compression. - Handle edge cases such as a single-pixel row or column appropriately. - Optimize the function for both time and space complexity within the given constraints.","solution":"def compress_image_rle(grid): Compresses a 2D grid of pixels using the Run-Length Encoding (RLE) algorithm. Args: grid (list of lists of int): 2D list where each inner list represents a row of pixel values. Returns: list of lists of tuples: Compressed image using tuples of (pixel_value, count). compressed_image = [] for row in grid: compressed_row = [] current_val = row[0] count = 1 for pixel in row[1:]: if pixel == current_val: count += 1 else: compressed_row.append((current_val, count)) current_val = pixel count = 1 compressed_row.append((current_val, count)) # Append last run compressed_image.append(compressed_row) return compressed_image"},{"question":"# Coding Assessment Question Scenario You are developing a feature for a text processing software that involves analyzing and transforming strings. A common operation is to find the longest substring in a given string that consists of unique characters. Task Write a function `longest_unique_substring` that takes a string as input and returns the length of the longest substring that contains only unique characters. Function Signature ```python def longest_unique_substring(s: str) -> int: ``` Input * `s`: A string consisting of ASCII characters. Output * An integer representing the length of the longest substring with all unique characters. Constraints * The length of the input string `s` will not exceed 10,000 characters. Examples ```python >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"abcdefg\\") 7 ``` Explanation of Examples * For `longest_unique_substring(\\"abcabcbb\\")`, the longest substring with all unique characters is \\"abc\\", which has length 3. * For `longest_unique_substring(\\"bbbbb\\")`, the longest substring with all unique characters is \\"b\\", which has length 1. * For `longest_unique_substring(\\"pwwkew\\")`, the longest substring with all unique characters is \\"wke\\", which has length 3. Note that the result must be a substring, \\"pwke\\" is a subsequence and not a substring. * For `longest_unique_substring(\\"\\")`, since the string is empty, the length of the longest substring with all unique characters is 0. * For `longest_unique_substring(\\"abcdefg\\")`, the entire string consists of unique characters, so the length is 7. Performance Requirements * The function should execute in linear time O(n), where n is the length of the input string.","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. :param s: Input string consisting of ASCII characters. :return: The length of the longest substring with all unique characters. char_index_map = {} longest = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"# Coding Challenge # Problem Statement You are given a list of non-negative integers representing the amount of money of each house arranged in a circular manner. House robbers have targeted this neighborhood, and, as it is circular, the first house is the neighbor of the last house. Adjacent houses cannot be robbed on the same night. Your task is to find the maximum amount of money you can rob without alerting the police. # Input - A single string representing the list of integers where each integer is separated by space. # Output - An integer representing the maximum amount of money that can be robbed. # Example Input ``` 2 3 2 ``` Output ``` 3 ``` # Explanation In this example, since the houses are arranged in a circle, robbing house 1 and house 3 will alert the police. The optimal solution is to rob house 2 for a maximum of 3 units of money. # Function Signature ```python def rob_houses(houses_str: str) -> int: pass ``` # Constraints - 1 ≤ number of houses ≤ 100 - 0 ≤ amount of money in any house ≤ 10^4 # Scenario You are tasked with creating an optimized strategy for burglars attempting to rob houses in a circular neighborhood. The constraint of the circular arrangement adds an interesting edge case to consider in your planning. This problem involves elements of dynamic programming and optimal substructure recognition. Consider all given constraints to ensure efficiency and correctness in your solution.","solution":"def rob_houses(houses_str: str) -> int: houses = list(map(int, houses_str.split())) n = len(houses) def rob_linear(houses): rob1, rob2 = 0, 0 for h in houses: new_rob = max(rob1 + h, rob2) rob1 = rob2 rob2 = new_rob return rob2 if n == 0: return 0 if n == 1: return houses[0] return max(rob_linear(houses[1:]), rob_linear(houses[:-1]))"},{"question":"# Coding Challenge # Problem Statement Given two strings `str1` and `str2`, write a Python function called `longest_common_substring` that finds the longest common substring. A substring is a contiguous sequence of characters within a string. You have to ensure that the function is efficient with a time complexity of O(n*m), where n and m are the lengths of `str1` and `str2` respectively. # Input * Two strings `str1` and `str2`. # Output * A tuple of: 1. An integer representing the length of the longest common substring. 2. A string representing the longest common substring itself. # Constraints * Both input strings will have lengths ranging from 1 to 1000. * Both input strings will consist of lowercase English letters. # Example ```python def longest_common_substring(str1: str, str2: str) -> Tuple[int, str]: pass # Example usage: assert longest_common_substring(\\"babad\\", \\"ababd\\") == (3, \\"bab\\") assert longest_common_substring(\\"abc\\", \\"def\\") == (0, \\"\\") ``` # Instructions * Implement the `longest_common_substring` function. * Ensure the solution has a time complexity of O(n*m) and uses space efficiently. * Consider edge cases, such as entirely disjoint strings or strings that are identical. * You may include helper functions if necessary. # Performance considerations * Handle inputs efficiently to avoid excessive memory usage. * Process the strings in a manner that avoids redundant computations. # Note * You can assume common substrings have significance, such as shared features in text analysis or code similarities.","solution":"def longest_common_substring(str1: str, str2: str) -> (int, str): n, m = len(str1), len(str2) longest_length = 0 longest_substring = \\"\\" # Initialize a 2D list to keep track of the lengths of longest common suffixes dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest_length: longest_length = dp[i][j] longest_substring = str1[i - longest_length:i] else: dp[i][j] = 0 return longest_length, longest_substring"},{"question":"# Circuit Elements Allocator In this task, you are required to implement a function that allocates a list of circuit elements such that no two elements are placed next to each other in the same circuit slot. The elements are described by their start and end times on a common timeline. # Input * `elements`: A list of tuples where each tuple contains two integers representing the start and end times of an element. # Output * A list of lists, where each list represents a circuit slot and contains elements that are assigned to that slot. * Each element in a circuit slot is represented by its original tuple (start, end times). * No two elements in a single circuit slot can overlap in time. # Constraints * Each element\'s start and end times are unique. * The start time is always less than the end time. # Performance Requirements * The function should be efficient with respect to both time and space. # Example ```python elements = [(1, 4), (2, 5), (3, 7), (5, 6), (8, 9)] result = allocate_circuit_elements(elements) print(result) # Output: [ # [(1, 4), (5, 6), (8, 9)], # [(2, 5)], # [(3, 7)] # ] # Explanation: # - The first slot can accommodate elements (1, 4), (5, 6), and (8, 9) as they do not overlap. # - The second slot accommodates element (2, 5) which overlaps with (1, 4). # - The third slot accommodates element (3, 7) which overlaps with (1, 4) and (2, 5). ``` # Task Implement the `allocate_circuit_elements` function as described above. ```python from typing import List, Tuple def allocate_circuit_elements(elements: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]: # Your implementation here pass ```","solution":"from typing import List, Tuple def allocate_circuit_elements(elements: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]: # Sort the elements by their start times elements.sort(key=lambda x: x[0]) # List to store the allocated slots slots = [] for element in elements: placed = False # Try to place the element in an existing slot for slot in slots: if slot[-1][1] <= element[0]: # No overlap slot.append(element) placed = True break # If the element couldn\'t be placed in an existing slot, create a new slot if not placed: slots.append([element]) return slots"},{"question":"# Problem Statement You are developing software for an online store that processes customer orders. Each order includes a list of items purchased and their respective quantities. Your task is to implement a function that calculates the total cost of an order based on given prices for each item. # Task Design a function `calculate_total(order: Dict[str, int], prices: Dict[str, float]) -> float` that takes two inputs: 1. A dictionary `order` where the keys are item names (strings) and the values are the quantities purchased (integers). 2. A dictionary `prices` where the keys are item names (strings) and the values are the price per unit for each item (floats). The function should return the total cost of the order as a float. # Input - A dictionary `order` representing the items and their quantities. - A dictionary `prices` representing the item prices. # Output - A float representing the total cost of the order. # Constraints - All item names in the `order` dictionary will also be present in the `prices` dictionary. - There will be at least one item in the `order`. - Quantities in the `order` dictionary will be positive integers. - Prices in the `prices` dictionary will be positive floats with up to two decimal places. # Example ```python >>> order = {\'apple\': 3, \'banana\': 2} >>> prices = {\'apple\': 0.60, \'banana\': 0.50} >>> calculate_total(order, prices) 2.80 >>> order = {\'milk\': 1, \'bread\': 2} >>> prices = {\'milk\': 1.50, \'bread\': 0.80} >>> calculate_total(order, prices) 3.10 >>> order = {\'chocolate\': 5} >>> prices = {\'chocolate\': 1.00} >>> calculate_total(order, prices) 5.00 ``` # Detailed Requirements 1. Iterate over the `order` dictionary and calculate the total cost by summing up the product of quantity and price for each item. 2. Use the provided `prices` dictionary to find the price for each item. 3. Ensure the returned total cost is a float with the correct sum of all items in the order. 4. Ensure the function passes the provided example test cases.","solution":"def calculate_total(order, prices): Calculate the total cost of an order based on given prices for each item. Parameters: order (dict): A dictionary where keys are item names and values are quantities purchased. prices (dict): A dictionary where keys are item names and values are the price per unit. Returns: float: The total cost of the order. total_cost = 0.0 for item, quantity in order.items(): total_cost += quantity * prices[item] return round(total_cost, 2)"},{"question":"# Scenario You have joined a company that evaluates customer sentiment by analyzing textual reviews. Your task is to implement a basic Natural Language Processing (NLP) pipeline to classify reviews as positive or negative based on their content. You decide to use a Naive Bayes classifier for this task. # Task Implement the following functions necessary for the Naive Bayes model: 1. `tokenize`: Convert a string into a list of words. 2. `calculate_word_frequencies`: Calculate word frequencies for each class. 3. `calculate_class_probabilities`: Compute the probabilities of each class. 4. `predict_sentiment`: Implement the main prediction function using Naive Bayes. 5. `evaluate_accuracy`: Calculate the accuracy of the predictions. You will use a given dataset of labeled reviews and evaluate the model accuracy. # Function Definitions **Function 1**: `tokenize(review: str) -> list` - **Input**: A string containing a review. - **Output**: Return a list of lowercase words from the review. - **Example**: ```python review = \\"I loved this product! It was fantastic.\\" tokenize(review) # Output: [\'i\', \'loved\', \'this\', \'product\', \'it\', \'was\', \'fantastic\'] ``` **Function 2**: `calculate_word_frequencies(reviews: list) -> dict` - **Input**: A list of tokenized reviews. - **Output**: A dictionary of word frequencies for each class (positive, negative). - **Example**: ```python reviews = [[\'i\', \'love\', \'it\'], [\'hate\', \'this\', \'product\']] calculate_word_frequencies(reviews) # Output: {\'positive\': {\'i\': 1, \'love\': 1, \'it\': 1}, \'negative\': {\'hate\': 1, \'this\': 1, \'product\': 1}} ``` **Function 3**: `calculate_class_probabilities(review_counts: dict, total_reviews: int) -> dict` - **Input**: A dictionary of review counts for each class and the total number of reviews. - **Output**: A dictionary of class probabilities. - **Example**: ```python review_counts = {\'positive\': 30, \'negative\': 20} total_reviews = 50 calculate_class_probabilities(review_counts, total_reviews) # Output: {\'positive\': 0.6, \'negative\': 0.4} ``` **Function 4**: `predict_sentiment(review: list, word_frequencies: dict, class_probabilities: dict, vocab_size: int) -> str` - **Input**: A tokenized review, dictionary of word frequencies, dictionary of class probabilities, and the vocabulary size. - **Output**: Predicted class (\'positive\' or \'negative\') for the review. - **Example**: ```python review = [\'i\', \'love\', \'it\'] word_frequencies = {\'positive\': {\'i\': 2, \'love\': 3, \'it\': 1}, \'negative\': {\'i\': 1, \'hate\': 3, \'it\': 2}} class_probabilities = {\'positive\': 0.6, \'negative\': 0.4} vocab_size = 10 predict_sentiment(review, word_frequencies, class_probabilities, vocab_size) # Output: \'positive\' ``` **Function 5**: `evaluate_accuracy(actual_labels: list, predicted_labels: list) -> float` - **Input**: List of actual class labels and list of predicted class labels. - **Output**: Accuracy of the predictions. - **Example**: ```python actual_labels = [\'positive\', \'negative\', \'positive\'] predicted_labels = [\'positive\', \'positive\', \'positive\'] evaluate_accuracy(actual_labels, predicted_labels) # Output: 66.67 ``` # Constraints - The number of reviews and words are positive integers. - Reviews can belong to either \'positive\' or \'negative\' classes. - Handle edge cases where reviews have very few words or highly unbalanced classes. # Expected Workflow 1. Tokenize the reviews into words. 2. Calculate word frequencies for each class. 3. Compute class probabilities based on the number of reviews in each class. 4. Use the Naive Bayes model to predict the sentiment of new reviews. 5. Compute and report the accuracy of the sentiments predictions.","solution":"def tokenize(review): Convert a string into a list of words in lowercase. return review.lower().split() def calculate_word_frequencies(reviews, labels): Calculate word frequencies for each class. from collections import defaultdict word_frequencies = { \'positive\': defaultdict(int), \'negative\': defaultdict(int) } for review, label in zip(reviews, labels): for word in review: word_frequencies[label][word] += 1 return word_frequencies def calculate_class_probabilities(review_counts, total_reviews): Compute the probabilities of each class. return {cls: count / total_reviews for cls, count in review_counts.items()} def predict_sentiment(review, word_frequencies, class_probabilities, vocab_size): Predict the sentiment of the review using the Naive Bayes algorithm. import math def calculate_word_probability(word, label): word_freq = word_frequencies[label].get(word, 0) total_words_in_class = sum(word_frequencies[label].values()) return (word_freq + 1) / (total_words_in_class + vocab_size) # Add-1 smoothing class_scores = {} for cls in class_probabilities: class_scores[cls] = math.log(class_probabilities[cls]) for word in review: class_scores[cls] += math.log(calculate_word_probability(word, cls)) return max(class_scores, key=class_scores.get) def evaluate_accuracy(actual_labels, predicted_labels): Calculate the accuracy of the predictions. correct_predictions = sum(1 for actual, predicted in zip(actual_labels, predicted_labels) if actual == predicted) return (correct_predictions / len(actual_labels)) * 100"},{"question":"# Finding Unique Elements in a 2D Array Write a function that finds all unique elements in a 2D array of integers. The uniqueness of an element is determined by its absence elsewhere in the entire array. Function Signature ```python def find_unique_elements(matrix: List[List[int]]) -> List[int]: pass ``` Input * `matrix` (List[List[int]]): A 2D array containing integers. Output * `List[int]`: A list of integers representing the unique elements in the 2D array. Constraints * 1 ≤ len(matrix) ≤ 10^3 * 1 ≤ len(matrix[i]) ≤ 10^3 * -10^9 ≤ matrix[i][j] ≤ 10^9 Example ```python print(find_unique_elements([[1, 2, 2], [3, 1, 4], [5, 3, 5]])) # should output [4] print(find_unique_elements([[7, 8, 9], [6, 5, 4], [3, 2, 1]])) # should output [7, 8, 9, 6, 5, 4, 3, 2, 1] print(find_unique_elements([[1, 1], [1, 2]])) # should output [2] ``` Explanation The function should iterate through the 2D array and count the frequency of each element. Then, it should return a list of elements that appear exactly once within the array. The result list should maintain the order of appearance of unique elements. # Constraints & Guidelines * The function should be optimized to handle the largest size of inputs efficiently. * Consider edge cases with different matrix dimensions and values. * Ensure that the result does not include repeated elements and is in the order they first appear in the array.","solution":"from typing import List def find_unique_elements(matrix: List[List[int]]) -> List[int]: Finds all unique elements in a 2D array of integers. An element is unique if it appears exactly once in the 2D array. Parameters: matrix (List[List[int]]): A 2D array containing integers. Returns: List[int]: A list of integers representing the unique elements in the 2D array. # Dictionary to store the count of each element count_dict = {} # Iterate through each row for row in matrix: # Iterate through each element in the row for elem in row: if elem in count_dict: count_dict[elem] += 1 else: count_dict[elem] = 1 # Get the list of unique elements which appear exactly once unique_elements = [key for key, value in count_dict.items() if value == 1] return unique_elements"},{"question":"# Scenario: You are employed as a software engineer at a logistics company that manages delivery trucks. The company needs an efficient way to merge multiple daily delivery route schedules. Each schedule is a list of time intervals during which deliveries will be made. The goal is to combine these schedules into a single one, which optimizes the delivery process by merging overlapping intervals. # Problem Description: Implement the function `mergeIntervals(intervals: List[List[int]]) -> List[List[int]]` that merges overlapping intervals and returns the resulting schedule. Intervals are considered overlapping if they share at least one common point. # Function Signature: ```python def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: ``` # Input: 1. `intervals` (List[List[int]]): A list of lists where each sub-list contains two integers representing the start and end times of a delivery interval `[start, end]`. # Output: - Returns a list of lists representing the merged intervals in sorted order. # Constraints: - 1 <= len(intervals) <= 1000 - 0 <= start, end <= 1000 - `start` <= `end` for each interval # Requirements: 1. Sort the intervals by their start times. 2. Merge overlapping intervals efficiently. # Example: ```python from typing import List def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals by the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] if current[0] <= previous[1]: # There is an overlap, hence merge the intervals merged[-1] = [previous[0], max(previous[1], current[1])] else: # No overlap, add to the result merged.append(current) return merged # Example usage: intervals = [[1, 3], [2, 6], [8, 10], [15, 18]] print(mergeIntervals(intervals)) # Output: [[1, 6], [8, 10], [15, 18]] ``` Use the provided test case to validate your implementation.","solution":"from typing import List def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals by the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] if current[0] <= previous[1]: # There is an overlap, hence merge the intervals merged[-1] = [previous[0], max(previous[1], current[1])] else: # No overlap, add to the result merged.append(current) return merged"},{"question":"# Problem Context Hash tables are crucial data structures in computer science, providing efficient storage and retrieval of data using a hash function. Ensuring their optimal performance requires a good understanding of hash functions and collision resolution strategies. A common task is to implement a basic hash table with open addressing to handle collisions. # Task Create a simple hash table implementation in Python using open addressing for collision resolution. You\'ll need to support basic operations: insertion, deletion, and search. Use linear probing as the strategy for open addressing. # Requirements 1. **Implement a Hash Table Class**: - Include methods: `insert(key, value)`, `delete(key)`, and `search(key)`. - Use linear probing to resolve collisions. 2. **Handle Collisions**: Ensure your hash table can handle collisions efficiently using open addressing. 3. **Ensure Robustness**: Include checks to handle edge cases such as inserting duplicate keys or deleting keys that do not exist. # Input and Output Format 1. `insert` method: - **Input**: `key (int)` and `value (any type)`. - **Output**: None. Inserts the key-value pair into the hash table. 2. `delete` method: - **Input**: `key (int)`. - **Output**: None. Deletes the key from the hash table if it exists. 3. `search` method: - **Input**: `key (int)`. - **Output**: The value associated with the key or `None` if the key is not found. # Constraints * The keys will be integer type, and values can be of any type. * Assume a fixed table size for simplicity. # Edge Cases * Inserting a key when the table is full. * Inserting a duplicate key. * Deleting a key that does not exist. * Searching for a key that does not exist. # Example Implement the hash table and validate its correctness with test cases. **Sample Test** ```python class HashTable: def __init__(self, size=10): self.size = size self.table = [None] * size def _hash(self, key): return key % self.size def insert(self, key, value): idx = self._hash(key) original_idx = idx while self.table[idx] is not None and self.table[idx][0] != key: idx = (idx + 1) % self.size if idx == original_idx: raise Exception(\\"Hash table is full\\") self.table[idx] = (key, value) def delete(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None return idx = (idx + 1) % self.size if idx == original_idx: raise Exception(\\"Key not found\\") def search(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size if idx == original_idx: return None return None # Sample Test Cases hash_table = HashTable() hash_table.insert(10, \\"A\\") assert hash_table.search(10) == \\"A\\" hash_table.insert(20, \\"B\\") assert hash_table.search(20) == \\"B\\" hash_table.insert(30, \\"C\\") assert hash_table.search(30) == \\"C\\" hash_table.delete(20) assert hash_table.search(20) is None print(\\"All tests passed!\\") ```","solution":"class HashTable: def __init__(self, size=10): self.size = size self.table = [None] * size def _hash(self, key): return key % self.size def insert(self, key, value): idx = self._hash(key) original_idx = idx while self.table[idx] is not None and self.table[idx][0] != key: idx = (idx + 1) % self.size if idx == original_idx: raise Exception(\\"Hash table is full\\") self.table[idx] = (key, value) def delete(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None return idx = (idx + 1) % self.size if idx == original_idx: raise Exception(\\"Key not found\\") def search(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size if idx == original_idx: return None return None"},{"question":"# Task You are given a list of strings representing time of the day in a 24-hour format. Your goal is to write a function that finds the minimum difference in minutes between any two given times. If the list contains fewer than two times, return 0. # Function Signature ```python def find_min_time_difference(times: List[str]) -> int: pass ``` # Input * `times` (List[str]): A list of strings where each string represents time in \\"HH:MM\\" format. # Output * Returns an integer representing the minimum difference in minutes between any two times. If the input list contains fewer than two times, return 0. # Constraints * All times are in 24-hour format \\"HH:MM\\". * The input list can have at most 10,000 times. # Example ```python # Example 1: times = [\\"23:59\\", \\"00:00\\"] assert find_min_time_difference(times) == 1 # Example 2: times = [\\"01:24\\", \\"03:48\\", \\"00:23\\"] assert find_min_time_difference(times) == 61 ``` # Notes 1. Pay attention to the wrapping of time from one day to the next (i.e., from \\"23:59\\" to \\"00:00\\"). 2. Ensure your solution optimizes for both time and space complexity. 3. Consider edge cases such as times being far apart or very close together.","solution":"from typing import List def find_min_time_difference(times: List[str]) -> int: if len(times) < 2: return 0 def time_to_minutes(t: str) -> int: h, m = map(int, t.split(\':\')) return h * 60 + m minutes = sorted(time_to_minutes(t) for t in times) minutes.append(minutes[0] + 24 * 60) # Account for the wrap-around scenario min_diff = float(\'inf\') for i in range(1, len(minutes)): min_diff = min(min_diff, minutes[i] - minutes[i-1]) return min_diff"},{"question":"# Problem: Flatten Nested Lists with Depth Sum Context: You are developing an advanced data analysis tool that needs to process nested lists. One of the key operations is to flatten these nested lists, but with an added twist. In addition to flattening, you need to calculate the depth sum, where each element\'s value is multiplied by its depth in the original list structure. Task: 1. Implement a function to flatten a nested list and compute the depth sum. 2. Your function should handle any level of nested lists. 3. The resultant structure should be a flat list of integers. Requirements: * Flatten the nested list while keeping track of the depth of each element. * Multiply each element by its corresponding depth and sum all values. * Handle invalid input gracefully by raising appropriate errors. Function Signature: ```python def flatten_and_depth_sum(nested_list: List[Union[int, List]]) -> Tuple[List[int], int]: pass ``` Input: * `nested_list` - A nested list which can contain integers or other nested lists. Output: * A tuple with two elements: - A flat list of integers extracted from the nested list. - An integer representing the depth sum of the elements. Constraints: * Nested lists can go up to any reasonable depth, assume up to 5 levels deep. * Elements are integers in the range (-1000 leq a_{i,j} leq 1000). Examples: 1. For nested list: ```python nested_list = [1, [2, [3, 4], 5], 6] ``` The result should be: ```python ([1, 2, 3, 4, 5, 6], 1*1 + 2*2 + 3*3 + 4*3 + 5*2 + 6*1 = 1 + 4 + 9 + 12 + 10 + 6 = 42) ``` 2. For validation failures, such as non-integer elements: ```python nested_list = [1, [2, \'a\', [3]]] ``` Raise a `TypeError` with an appropriate message such as `\\"Invalid element type\\"`. # Solution: ```python def flatten_and_depth_sum(nested_list: List[Union[int, List]]) -> Tuple[List[int], int]: def helper(lst, depth): flat_list = [] depth_sum = 0 for elem in lst: if isinstance(elem, list): sub_list, sub_sum = helper(elem, depth + 1) flat_list.extend(sub_list) depth_sum += sub_sum elif isinstance(elem, int): flat_list.append(elem) depth_sum += elem * depth else: raise TypeError(\\"Invalid element type\\") return flat_list, depth_sum if not isinstance(nested_list, list): raise TypeError(\\"Input should be a list\\") return helper(nested_list, 1) ```","solution":"from typing import List, Union, Tuple def flatten_and_depth_sum(nested_list: List[Union[int, List]]) -> Tuple[List[int], int]: def helper(lst, depth): flat_list = [] depth_sum = 0 for elem in lst: if isinstance(elem, list): sub_list, sub_sum = helper(elem, depth + 1) flat_list.extend(sub_list) depth_sum += sub_sum elif isinstance(elem, int): flat_list.append(elem) depth_sum += elem * depth else: raise TypeError(\\"Invalid element type\\") return flat_list, depth_sum if not isinstance(nested_list, list): raise TypeError(\\"Input should be a list\\") return helper(nested_list, 1)"},{"question":"# Coding Assessment Question Context You have been provided with an existing function `encode_string` that takes a string and returns its encoded variant using a custom algorithm. The encoded string may contain a combination of uppercase and lowercase letters but no digits. Your task is to decode a list of encoded strings. Task Write a function `decode_strings(encoded_strings: list[str]) -> list[str]` that: 1. Decodes each encoded string in the provided list using the `encode_string` function\'s inverse logic. For this assessment, assume there exists an `inverse_encode_string` function that can decode the strings. 2. Returns a list of decoded strings. Input - `encoded_strings`: List of strings where each string is encoded using the `encode_string` function. Output - A list of strings where each string is the decoded version of the corresponding input string. Constraints - Each string in `encoded_strings` contains only uppercase and lowercase letters (no digits or special characters). - Assume all input strings are well-formed and valid encoded outputs of an `encode_string` function. - The length of each string in `encoded_strings` does not exceed 1000 characters. - The total number of strings in `encoded_strings` does not exceed 10⁴. Performance Requirements - Ensure the decoding process is efficient and can handle the upper constraints within reasonable time limits. Example ```python encoded_strings = [\\"BcDeF\\", \\"XyZiK\\", \\"LmNOp\\"] result = decode_strings(encoded_strings) print(result) # Expected output: A list of decoded strings # Example: [\\"aBcDe\\", \\"wXyZk\\", \\"KlmNo\\"] (actual decoded output depends on the specific logic of `encode_string`) ```","solution":"def inverse_encode_string(encoded_string): Decodes a single encoded string using the inverse of the encoding logic. The actual implementation of this inverse logic depends on the details of the encoding process. For the sake of illustration, we will assume a simple encoding logic where each letter was shifted by 1 position to the right in the alphabet, i.e., B->A, C->B, etc. This is just a hypothetical example. decoded_string = [] for char in encoded_string: # Example inverse logic: shift each character back by 1 if \'A\' <= char <= \'Z\': # For uppercase letters decoded_char = chr(((ord(char) - ord(\'A\') - 1) % 26) + ord(\'A\')) elif \'a\' <= char <= \'z\': # For lowercase letters decoded_char = chr(((ord(char) - ord(\'a\') - 1) % 26) + ord(\'a\')) decoded_string.append(decoded_char) return \'\'.join(decoded_string) def decode_strings(encoded_strings): Decodes a list of encoded strings using the inverse_encode_string function. decoded_strings = [inverse_encode_string(s) for s in encoded_strings] return decoded_strings"},{"question":"# Array Rotation Scenario Alice has an array and loves rotating it. A right rotation operation moves the last element of the array to the first position, and shifts all remaining elements to the right. Given an array and a number `k`, perform `k` right rotations and return the updated array. Function Signature ```python def rotate_array(arr: list, k: int) -> list: pass ``` Input - A list of integers `arr` (0 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). - An integer `k` (0 ≤ k ≤ 10^9). Output A list of integers representing the array after `k` right rotations. Example ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([4, 3, 2, 1], 1) == [1, 4, 3, 2] assert rotate_array([1, 2, 3], 3) == [1, 2, 3] ``` Constraints * The input list may be empty, in which case the function should return an empty list. * For large values of `k`, notice that rotating the array `n` times (where `n` is the length of the array) results in the same array. Thus, `k` can be reduced under modulo `n`. * Ensure your implementation handles the upper limits efficiently. Guidelines * Consider the properties of rotation and how modulo operation can help reduce unnecessary cycles. * Aim for a solution that modifies the array in place or by using slicing, while ensuring it works within time constraints for large inputs.","solution":"def rotate_array(arr: list, k: int) -> list: # Check for empty array if not arr: return arr n = len(arr) # Effective rotations needed k = k % n # If k is 0, or k is a multiple of n, the array remains unchanged if k == 0: return arr # Slicing to perform the rotation return arr[-k:] + arr[:-k]"},{"question":"# Matrix Multiplication Optimization You are to implement a naive matrix multiplication algorithm and improve it using the Strassen algorithm. Compare the performance of both algorithms using different sizes of square matrices. # Function Descriptions 1. **naive_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]** * Implement the naive matrix multiplication algorithm where each element of the resulting matrix is computed by performing the dot product. 2. **strassen_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]** * Implement the Strassen matrix multiplication algorithm to improve the efficiency over the naive approach. 3. **performance_comparison(sizes: List[int]) -> Dict[int, float]** * Compare the performance of naive and Strassen multiplication for different matrix sizes listed in `sizes`. * Return a dictionary where the keys are matrix sizes and the values are the speed-up factor of the Strassen algorithm relative to the naive algorithm. # Requirements * Implement the `naive_multiplication`, `strassen_multiplication`, and `performance_comparison` functions as described. * Utilize recursion in the Strassen algorithm for optimal performance. * Ensure the input matrices are square and their sizes are powers of 2 (e.g. 2x2, 4x4, 8x8). # Constraints * The matrix sizes (elements of `sizes`) are between 2 and 64, inclusive, and are powers of 2. * Matrices contain integer elements between -100 and 100. * Ensure that your implementations handle up to 64x64 matrices efficiently. # Example ```python import time from typing import List, Dict # Implement the functions def naive_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: size = len(mat1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += mat1[i][k] * mat2[k][j] return result def strassen_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: # Implement the Strassen algorithm def add_matrix(A, B): size = len(A) return [[A[i][j] + B[i][j] for j in range(size)] for i in range(size)] def sub_matrix(A, B): size = len(A) return [[A[i][j] - B[i][j] for j in range(size)] for i in range(size)] def split_matrix(A): mid = len(A) // 2 return A[:mid], A[mid:], [row[:mid] for row in A], [row[mid:] for row in A] if len(mat1) == 1: return [[mat1[0][0] * mat2[0][0]]] else: A, B, C, D = split_matrix(mat1) E, F, G, H = split_matrix(mat2) P1 = strassen_multiplication(A, sub_matrix(F, H)) P2 = strassen_multiplication(add_matrix(A, B), H) P3 = strassen_multiplication(add_matrix(C, D), E) P4 = strassen_multiplication(D, sub_matrix(G, E)) P5 = strassen_multiplication(add_matrix(A, D), add_matrix(E, H)) P6 = strassen_multiplication(sub_matrix(B, D), add_matrix(G, H)) P7 = strassen_multiplication(sub_matrix(A, C), add_matrix(E, F)) upper_left = add_matrix(sub_matrix(add_matrix(P5, P4), P2), P6) upper_right = add_matrix(P1, P2) lower_left = add_matrix(P3, P4) lower_right = sub_matrix(sub_matrix(add_matrix(P5, P1), P3), P7) mid = len(upper_left) size = mid * 2 result = [[0] * size for _ in range(size)] for i in range(mid): for j in range(mid): result[i][j] = upper_left[i][j] result[i][j + mid] = upper_right[i][j] result[i + mid][j] = lower_left[i][j] result[i + mid][j + mid] = lower_right[i][j] return result def performance_comparison(sizes: List[int]) -> Dict[int, float]: import random results = {} for size in sizes: mat1 = [[random.randint(-100, 100) for _ in range(size)] for _ in range(size)] mat2 = [[random.randint(-100, 100) for _ in range(size)] for _ in range(size)] start = time.time() naive_multiplication(mat1, mat2) naive_time = time.time() - start start = time.time() strassen_multiplication(mat1, mat2) strassen_time = time.time() - start results[size] = naive_time / strassen_time return results # Test the implementation with provided sizes sizes = [2, 4, 8] speed_up_factors = performance_comparison(sizes) print(speed_up_factors) # Expected Output: {2: approx. 1.0, 4: approx. 1.0, 8: approx. 1.5} ``` Your solution should handle the performance comparison correctly and exhibit the efficiency benefits demonstrated by the Strassen algorithm.","solution":"import time from typing import List, Dict def naive_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: Perform matrix multiplication using the naive approach. size = len(mat1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += mat1[i][k] * mat2[k][j] return result def strassen_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: Perform matrix multiplication using Strassen\'s algorithm. def add_matrix(A, B): Adds two matrices. size = len(A) return [[A[i][j] + B[i][j] for j in range(size)] for i in range(size)] def sub_matrix(A, B): Subtracts matrix B from matrix A. size = len(A) return [[A[i][j] - B[i][j] for j in range(size)] for i in range(size)] def split_matrix(A): Splits a given matrix into four submatrices. mid = len(A) // 2 return ( [row[:mid] for row in A[:mid]], [row[mid:] for row in A[:mid]], [row[:mid] for row in A[mid:]], [row[mid:] for row in A[mid:]] ) def strassen_recursive(A, B): Recursively computes the product of matrices A and B using Strassen\'s algorithm. size = len(A) if size == 1: return [[A[0][0] * B[0][0]]] else: A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) M1 = strassen_recursive(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_recursive(add_matrix(A21, A22), B11) M3 = strassen_recursive(A11, sub_matrix(B12, B22)) M4 = strassen_recursive(A22, sub_matrix(B21, B11)) M5 = strassen_recursive(add_matrix(A11, A12), B22) M6 = strassen_recursive(sub_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_recursive(sub_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(sub_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(sub_matrix(add_matrix(M1, M3), M2), M6) new_size = size // 2 result = [[0] * size for _ in range(size)] for i in range(new_size): for j in range(new_size): result[i][j] = C11[i][j] result[i][j + new_size] = C12[i][j] result[i + new_size][j] = C21[i][j] result[i + new_size][j + new_size] = C22[i][j] return result return strassen_recursive(mat1, mat2) def performance_comparison(sizes: List[int]) -> Dict[int, float]: Compare the performance of naive and Strassen matrix multiplication algorithms. import random results = {} for size in sizes: mat1 = [[random.randint(-100, 100) for _ in range(size)] for _ in range(size)] mat2 = [[random.randint(-100, 100) for _ in range(size)] for _ in range(size)] start = time.time() naive_multiplication(mat1, mat2) naive_time = time.time() - start start = time.time() strassen_multiplication(mat1, mat2) strassen_time = time.time() - start speed_up_factor = naive_time / strassen_time if strassen_time > 0 else float(\'inf\') results[size] = speed_up_factor return results"},{"question":"# Problem Statement As a software engineer at a logistics company, you are tasked with optimizing the scheduling of delivery routes based on delivery priority. Each delivery has a specific priority and must be scheduled such that higher priority deliveries are processed first. If two deliveries have the same priority, the delivery closest to the distribution center (considered at the origin `(0, 0)`) should be processed first. You need to write a function `schedule_deliveries` that takes a list of deliveries, each defined by their delivery ID, coordinates, and priority, and returns the list of delivery IDs in the order they should be processed. # Function Signature ```python from typing import List, Tuple Delivery = namedtuple(\\"Delivery\\", \\"id x y priority\\") def schedule_deliveries(deliveries: List[Delivery]) -> List[int]: ... ``` # Input * `deliveries` - A list of `Delivery` namedtuples, where each `Delivery` has: * `id (int)`: The unique identifier of the delivery. * `x (float)`: The x-coordinate of the delivery address. * `y (float)`: The y-coordinate of the delivery address. * `priority (int)`: The priority of the delivery (higher value means higher priority). # Output * A list of delivery IDs ordered by the specified scheduling criteria. # Constraints 1. The list `deliveries` can be empty, in which case return an empty list. 2. Each priority value is an integer and can range from `-10^3` to `10^3`. 3. The coordinates `x` and `y` are floating-point numbers that determine the distance from the origin where the deliveries are located. # Examples ```python >>> schedule_deliveries([ ... Delivery(id=1, x=1.0, y=2.0, priority=3), ... Delivery(id=2, x=0.5, y=1.5, priority=3), ... Delivery(id=3, x=4.0, y=1.0, priority=1), ... Delivery(id=4, x=2.0, y=3.0, priority=5) ... ]) [4, 2, 1, 3] >>> schedule_deliveries([ ... Delivery(id=1, x=1.0, y=2.0, priority=2), ... Delivery(id=2, x=0.5, y=1.5, priority=2), ... Delivery(id=3, x=4.0, y=1.0, priority=1) ... ]) [2, 1, 3] >>> schedule_deliveries([ ... Delivery(id=1, x=1.0, y=2.0, priority=1), ... Delivery(id=2, x=0.5, y=1.5, priority=2), ... Delivery(id=3, x=4.0, y=1.0, priority=1), ... Delivery(id=4, x=-1.0, y=2.0, priority=3) ... ]) [4, 2, 1, 3] >>> schedule_deliveries([]) [] ``` # Notes 1. The Euclidean distance from the origin can be calculated using the formula `distance = sqrt(x^2 + y^2)`, but for comparative purposes, using `x^2 + y^2` suffices to avoid unnecessary floating-point computations. 2. Ensure efficient sorting by making proper use of Python\'s sorting functionalities and custom comparator logic if required.","solution":"from typing import List, Tuple from collections import namedtuple Delivery = namedtuple(\\"Delivery\\", \\"id x y priority\\") def schedule_deliveries(deliveries: List[Delivery]) -> List[int]: def compute_distance_from_origin(delivery): # Square of the distance is sufficient for comparison return delivery.x**2 + delivery.y**2 # Sort deliveries by priority (descending), then by distance (ascending) sorted_deliveries = sorted(deliveries, key=lambda d: (-d.priority, compute_distance_from_origin(d))) # Extract and return the delivery IDs in the sorted order return [d.id for d in sorted_deliveries]"},{"question":"# Scenario You have joined a software company that is building a new text processing library. One component of this library involves handling strings and implementing essential text manipulation functions. Your task is to create a set of string utility functions which will be crucial for various features across the library. These implementations need to consider edge cases and should be optimized for performance. # Task Implement the following string operations as specified: 1. `reverse_string(s)`: Reverses a given string. 2. `is_palindrome(s)`: Checks if a given string is a palindrome. 3. `count_vowels(s)`: Counts the number of vowels in a given string. 4. `find_substring(s, substring)`: Finds the first occurrence index of a substring in a given string, or returns -1 if not found. 5. `capitalize_words(s)`: Capitalizes the first letter of each word in a given string. # Specifications - **Input**: - All functions: a string `s`. - `find_substring`: an additional string `substring`. - **Output**: - The result should be: - A string for `reverse_string` and `capitalize_words`. - A boolean for `is_palindrome`. - An integer for `count_vowels` and `find_substring`. # Example Implementations ```python def reverse_string(s): # Implement string reversal logic pass def is_palindrome(s): # Implement palindrome checking logic pass def count_vowels(s): # Implement vowel counting logic pass def find_substring(s, substring): # Implement substring finding logic pass def capitalize_words(s): # Implement word capitalization logic pass ``` # Constraints - You should handle invalid input cases gracefully by returning appropriate values (such as `False` for non-palindrome strings, `0` for no vowels). - Ensure that your methods are efficient and follow best practices for string manipulation. # Performance Requirements - The time complexity should be kept as low as practical within the constraints of typical use cases. - Your code will be tested for efficiency and should handle reasonably large strings (e.g., up to 10,000 characters) within acceptable time limits.","solution":"def reverse_string(s): Returns the given string reversed. return s[::-1] def is_palindrome(s): Checks if the given string is a palindrome. reversed_s = reverse_string(s) return s == reversed_s def count_vowels(s): Counts the number of vowels (a, e, i, o, u) in the given string. vowels = \\"aeiouAEIOU\\" return sum(1 for char in s if char in vowels) def find_substring(s, substring): Finds the first occurrence index of a substring in a given string, or returns -1 if not found. return s.find(substring) def capitalize_words(s): Capitalizes the first letter of each word in the given string. return \' \'.join(word.capitalize() for word in s.split())"},{"question":"# Sorting Books by Published Year You are provided with a list of dictionaries, where each dictionary represents a book with different attributes including \\"title\\" and \\"published_year\\". Objective: Your task is to implement a function called `sort_books_by_year()` which sorts a list of books based on their \\"published_year\\". The sorting must be done in ascending order. # Specifications: - **Function Name**: sort_books_by_year - **Input**: - `books`: a list of dictionaries where each dictionary represents a book with attributes such as \\"title\\" (str) and \\"published_year\\" (int). - **Output**: A list of dictionaries sorted by \\"published_year\\" in ascending order. # Constraints: - Each book dictionary is guaranteed to have the keys \\"title\\" and \\"published_year\\". - The \\"title\\" attribute is a non-empty string. - The \\"published_year\\" is an integer where the year is between 1000 and the current year. # Example: ```python books = [ {\\"title\\": \\"Book A\\", \\"published_year\\": 2001}, {\\"title\\": \\"Book B\\", \\"published_year\\": 1999}, {\\"title\\": \\"Book C\\", \\"published_year\\": 2010} ] print(sort_books_by_year(books)) # Expected Output: # [ # {\\"title\\": \\"Book B\\", \\"published_year\\": 1999}, # {\\"title\\": \\"Book A\\", \\"published_year\\": 2001}, # {\\"title\\": \\"Book C\\", \\"published_year\\": 2010} # ] ``` # Steps: 1. Define the function `sort_books_by_year` with an input parameter `books`. 2. Use an appropriate sorting algorithm or method to sort the list of dictionaries by \\"published_year\\". 3. Ensure the function returns the sorted list in ascending order based on \\"published_year\\". # Edge Cases to Consider: - The list of books is empty. - All the books have the same \\"published_year\\". - Books with future \\"published_year\\" (depending on constraints). --- Implement your solution in Python: ```python def sort_books_by_year(books): return sorted(books, key=lambda x: x[\'published_year\']) ```","solution":"def sort_books_by_year(books): Sort a list of books by their published_year in ascending order. Args: - books (list of dict): A list where each element is a dictionary containing \'title\' (str) and \'published_year\' (int). Returns: - list of dict: The sorted list of books based on the published year. return sorted(books, key=lambda x: x[\\"published_year\\"])"},{"question":"# Problem Statement You are tasked with creating an optimized and efficient system to validate international phone numbers. Your function will check if the provided phone number conforms to the international standard E.164 format. The E.164 format requires a phone number to be up to fifteen digits long and prefixed with a \'+\' followed immediately by the country code and subscriber number. # Task Implement the function `is_valid_phone_number(phone_number: str) -> bool` that: - Checks if the phone number is in the E.164 format. - Verifies that the phone number only contains digits after the \'+\' sign and has a length between 1 and 15 digits following the \'+\'. # Function Signature ```python def is_valid_phone_number(phone_number: str) -> bool: pass ``` # Input & Output - Input: `phone_number` - a string representing the phone number. - Output: `bool` - `True` if the phone number is valid according to the E.164 standard, `False` otherwise. # Constraints - The phone number must start with the \'+\' sign. - The phone number must be at most 16 characters in total, including the \'+\' sign. - The phone number must contain only digits after the \'+\' sign. # Example ```python assert is_valid_phone_number(\\"+15555555555\\") == True assert is_valid_phone_number(\\"+123\\") == True assert is_valid_phone_number(\\"15555555555\\") == False assert is_valid_phone_number(\\"+1234567890123456\\") == False assert is_valid_phone_number(\\"+123-456-789\\") == False assert is_valid_phone_number(\\"+12 34 56 78 90\\") == False ``` # Notes - Ensure that the function handles edge cases, such as very short or very long inputs. - Be mindful of potential input errors, such as missing the \'+\' sign or including invalid characters. # Additional Information This problem focuses on validating input strings to conform to a strict pattern, simulating real-world data validation scenarios in the context of telecommunication systems.","solution":"def is_valid_phone_number(phone_number: str) -> bool: Validates if the given phone number adheres to the E.164 format. Args: phone_number : str : The phone number to be validated. Returns: bool : True if the phone number is valid according to E.164 format, False otherwise. if not phone_number.startswith(\'+\'): return False digits = phone_number[1:] if not digits.isdigit(): return False if len(digits) < 1 or len(digits) > 15: return False return True"},{"question":"# Implement a Simple Key-Value Store with Expiration You are tasked with creating a simple in-memory key-value store that allows adding, retrieving, and deleting key-value pairs, as well as setting time-based expiration for each key. The key-value store should also provide a mechanism to persist the current state to a file and to load it back into memory. # Requirements: 1. **Class Definition**: Implement a class `KVStore` that supports the following methods: - **`__init__(self)`**: Initializes the key-value store and prepares any necessary data structures. - **`set(self, key: str, value: any, ttl: int=0)`**: Adds a key-value pair to the store, with an optional time-to-live (ttl) in seconds. - **`get(self, key: str) -> any`**: Retrieves the value associated with a key. If the key does not exist, or if it has expired, return `None`. - **`delete(self, key: str)`**: Removes a key-value pair from the store. - **`save(self, file_path: str)`**: Saves the current key-value store state to a file. - **`load(self, file_path: str)`**: Loads the key-value store state from a file. 2. **Constraints**: - The ttl (time-to-live) is an optional parameter. If not provided or set to 0, the key-value pair should never expire. - The expiration mechanism should be efficient and should not introduce significant overhead. - When the key-value store loads from a file, it should only load keys that have not expired. - Assume the file operations (`save` and `load`) can handle data serialization and deserialization. 3. **Implementation Hints**: - Consider using a dictionary to store the key-value pairs and another dictionary to store the expiration times. - To track expiration efficiently, you might use a priority queue or a sorting mechanism within the expiration dictionary. - For the save and load functionality, consider using JSON as a storage format for simplicity. - Ensure your solution can handle concurrent operations if implemented in a real-world application. ```python import time import json class KVStore: def __init__(self): self.store = {} self.expirations = {} def set(self, key: str, value: any, ttl: int=0): self.store[key] = value if ttl > 0: self.expirations[key] = time.time() + ttl elif key in self.expirations: del self.expirations[key] def get(self, key: str) -> any: if key in self.expirations and self.expirations[key] < time.time(): self.delete(key) return None return self.store.get(key, None) def delete(self, key: str): if key in self.store: del self.store[key] if key in self.expirations: del self.expirations[key] def save(self, file_path: str): with open(file_path, \'w\') as file: current_time = time.time() data = { \'store\': {k: v for k, v in self.store.items() if k not in self.expirations or self.expirations[k] >= current_time}, \'expirations\': {k: v for k, v in self.expirations.items() if v >= current_time} } json.dump(data, file) def load(self, file_path: str): with open(file_path, \'r\') as file: data = json.load(file) self.store = data[\'store\'] self.expirations = {k: v for k, v in data[\'expirations\'].items() if v >= time.time()} ``` # Scenario: As part of a distributed system, you are required to implement a key-value store that other parts of the system can use for temporary data storage. Keys might need to expire after a certain period to avoid stale data. Additionally, you need a way to persist the store\'s state periodically and reload it, possibly after a system restart. Your task is to implement the `KVStore` class as described, ensuring efficient management of key expirations and integration of file operations for state persistence. --- This question tests the ability to handle common tasks in building a data structure, manage time-based data, and work with file I/O. It aligns with concepts of data structures, algorithms, and practical application development, making it a fitting complement to the provided question.","solution":"import time import json class KVStore: def __init__(self): self.store = {} self.expirations = {} def set(self, key: str, value: any, ttl: int=0): Sets the value for the given key with an optional TTL (time to live). self.store[key] = value if ttl > 0: self.expirations[key] = time.time() + ttl elif key in self.expirations: del self.expirations[key] def get(self, key: str) -> any: Gets the value associated with the given key, considering TTL. if key in self.expirations and self.expirations[key] < time.time(): self.delete(key) return None return self.store.get(key, None) def delete(self, key: str): Deletes the value associated with the given key. if key in self.store: del self.store[key] if key in self.expirations: del self.expirations[key] def save(self, file_path: str): Saves the current state to a file. with open(file_path, \'w\') as file: current_time = time.time() data = { \'store\': {k: v for k, v in self.store.items() if k not in self.expirations or self.expirations[k] >= current_time}, \'expirations\': {k: v for k, v in self.expirations.items() if v >= current_time} } json.dump(data, file) def load(self, file_path: str): Loads the state from a file. with open(file_path, \'r\') as file: data = json.load(file) self.store = data[\'store\'] self.expirations = {k: v for k, v in data[\'expirations\'].items() if v >= time.time()}"},{"question":"Given a list of integers, find the length of the longest subarray that contains only even numbers. # Function Signature ```python def longest_even_subarray(arr: List[int]) -> int: pass ``` # Input * `arr` (List[int]): A list of integers. # Output * Returns an integer which is the length of the longest subarray consisting only of even numbers. # Constraints * `1 <= len(arr) <= 10^5` * All elements in the array are integers, possibly negative. # Performance Requirements * Aim for a solution with linear time complexity, O(n). # Example ```python longest_even_subarray([3, 2, 4, 6, 8, 1, 2, 4]) # Expected output: 4, since [2, 4, 6, 8] is the longest subarray of even numbers. longest_even_subarray([1, 3, 5, 7]) # Expected output: 0, since there are no even numbers in the list. ``` # Hint Utilize a sliding window approach to efficiently find the longest subarray of even numbers.","solution":"from typing import List def longest_even_subarray(arr: List[int]) -> int: max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Problem Statement: Develop a function that filters and formats a list of file paths based on specific criteria. The function should receive a list of file paths and a predicate function. It should return a new list containing only the file paths that satisfy the predicate, with each path formatted to replace all backslashes `\\"\\"` with forward slashes `\\"/\\"`. # Function Signature: ```python def filter_and_format_paths(paths: List[str], predicate: Callable[[str], bool]) -> List[str]: pass ``` # Requirements: 1. **Inputs**: - `paths`: A list of file path strings. Each path is represented as a string containing directory and subdirectory names separated by either backslashes or forward slashes. (1 ≤ len(paths) ≤ 1000) - `predicate`: A function that accepts a string (path) and returns a boolean indicating whether the path satisfies the filter condition. 2. **Outputs**: - A list of formatted file path strings that satisfy the predicate. 3. **Constraints**: - Each file path should be formatted to replace backslashes `\\"\\"` with forward slashes `\\"/\\"`. - The order of the file paths in the returned list should be the same as the input list, but only include the paths that pass the predicate filter. 4. **Performance Consideration**: - Ensure the function processes the file paths efficiently, taking into account the potential length of the path strings and the number of paths. # Example: ```python paths = [\\"userdocsreport.txt\\", \\"user/projects/main.py\\", \\"userdatadata.csv\\"] predicate = lambda x: x.endswith(\\".py\\") result = filter_and_format_paths(paths, predicate) print(result) # Output: [\\"user/projects/main.py\\"] ``` **Note**: - The function `filter_and_format_paths` should maintain the order of the input list. - Ensure the function correctly replaces backslashes with forward slashes across different operating systems.","solution":"from typing import List, Callable def filter_and_format_paths(paths: List[str], predicate: Callable[[str], bool]) -> List[str]: Filters and formats a list of file paths based on a given predicate function. Args: paths (List[str]): A list of file paths as strings. predicate (Callable[[str], bool]): A function that returns True if the path fits criteria, otherwise False. Returns: List[str]: A list of formatted file path strings that satisfy the predicate. formatted_paths = [path.replace(\\"\\", \\"/\\") for path in paths] return [path for path in formatted_paths if predicate(path)]"},{"question":"# AVL Tree: Balance and Height Management You are required to implement an AVL tree data structure that includes functions to maintain balance and manage node height efficiently. # Task Implement a class `AVLTree` with the following methods: 1. `insert`: Inserts a value into the AVL tree and ensures the tree remains balanced after every insertion. 2. `delete`: Deletes a value from the AVL tree and maintains the balance of the tree afterward. 3. `is_balanced`: Checks if the AVL tree is height-balanced. # Specifications Method 1: `insert` - **Input**: An integer value. - **Output**: The AVL tree should retain its properties, i.e., for any node in the tree, the height difference between its left and right subtrees is at most 1. Method 2: `delete` - **Input**: An integer value. - **Output**: The AVL tree should remain balanced after the deletion. Method 3: `is_balanced` - **Input**: None. - **Output**: A boolean indicating whether the AVL tree is balanced (True) or not (False). # Constraints 1. Duplicate values are not allowed. 2. The tree should automatically perform rotations when necessary to maintain balance. # Example ```python >>> avl_tree = AVLTree() >>> avl_tree.insert(10) >>> avl_tree.insert(20) >>> avl_tree.insert(30) >>> avl_tree.is_balanced() True >>> avl_tree.insert(40) >>> avl_tree.insert(50) >>> avl_tree.is_balanced() False # AVL tree should always return True after balancing itself >>> avl_tree.delete(50) >>> avl_tree.is_balanced() True ``` # Implementation ```python class AVLTree: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return self.Node(key) elif key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and key < root.left.key: return self._rotate_right(root) if balance < -1 and key > root.right.key: return self._rotate_left(root) if balance > 1 and key > root.left.key: root.left = self._rotate_left(root.left) return self._rotate_right(root) if balance < -1 and key < root.right.key: root.right = self._rotate_right(root.right) return self._rotate_left(root) return root def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if not root: return root if key < root.key: root.left = self._delete(root.left, key) elif key > root.key: root.right = self._delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = self._get_min_value_node(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and self._get_balance(root.left) >= 0: return self._rotate_right(root) if balance < -1 and self._get_balance(root.right) <= 0: return self._rotate_left(root) if balance > 1 and self._get_balance(root.left) < 0: root.left = self._rotate_left(root.left) return self._rotate_right(root) if balance < -1 and self._get_balance(root.right) > 0: root.right = self._rotate_right(root.right) return self._rotate_left(root) return root def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right) def _get_min_value_node(self, root): if root is None or root.left is None: return root return self._get_min_value_node(root.left) def is_balanced(self): def check_balance(node): if node is None: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = 1 + max(left_height, right_height) return balanced, height result, _ = check_balance(self.root) return result ```","solution":"class AVLTree: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return self.Node(key) elif key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and key < root.left.key: return self._rotate_right(root) if balance < -1 and key > root.right.key: return self._rotate_left(root) if balance > 1 and key > root.left.key: root.left = self._rotate_left(root.left) return self._rotate_right(root) if balance < -1 and key < root.right.key: root.right = self._rotate_right(root.right) return self._rotate_left(root) return root def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if not root: return root if key < root.key: root.left = self._delete(root.left, key) elif key > root.key: root.right = self._delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = self._get_min_value_node(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and self._get_balance(root.left) >= 0: return self._rotate_right(root) if balance < -1 and self._get_balance(root.right) <= 0: return self._rotate_left(root) if balance > 1 and self._get_balance(root.left) < 0: root.left = self._rotate_left(root.left) return self._rotate_right(root) if balance < -1 and self._get_balance(root.right) > 0: root.right = self._rotate_right(root.right) return self._rotate_left(root) return root def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right) def _get_min_value_node(self, root): if root is None or root.left is None: return root return self._get_min_value_node(root.left) def is_balanced(self): def check_balance(node): if node is None: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = 1 + max(left_height, right_height) return balanced, height result, _ = check_balance(self.root) return result"},{"question":"# Coding Assessment Question: Create a function that calculates the factorial of a given non-negative integer n using an iterative approach. **Function Details**: * Write a function `factorial(n: int) -> int` that computes the factorial of a number iteratively. **Input**: * `n` (int): A non-negative integer for which the factorial is to be calculated. **Output**: * A single integer representing the factorial of the input number. **Constraints**: * 0 <= n <= 20 (Factorials beyond 20 will be too large for typical integer storage and aren\'t necessary for this problem). **Performance Requirements**: * The implementation must be efficient and work within O(n) time complexity. **Scenario**: The factorial of a number is a crucial concept in mathematics and computer science, often used in permutations, combinations, and various algorithms. Implementing this function helps reinforce understanding of loops and iterative logic. **Example Use Cases**: * `factorial(5)` should return `120`. * `factorial(0)` should return `1`. * `factorial(7)` should return `5040`. **Edge Cases**: * An input like `factorial(-1)` should raise an exception: `\\"Input must be a non-negative integer\\"`. * An input like `factorial(21)` should raise an exception: `\\"Input must be <= 20\\"`. Here\'s an example implementation: ```python def factorial(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n > 20: raise ValueError(\\"Input must be <= 20\\") result = 1 for i in range(1, n + 1): result *= i return result # Example test cases for the implementation print(factorial(5)) # Output: 120 print(factorial(0)) # Output: 1 print(factorial(7)) # Output: 5040 ``` This question aims to test the understanding of loops, error handling, and iteratively solving factorial calculations.","solution":"def factorial(n: int) -> int: Computes the factorial of a non-negative integer n iteratively. Raises ValueError if n is negative or greater than 20. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n > 20: raise ValueError(\\"Input must be <= 20\\") result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Coding Assessment Question You are given a list of integers, which form a bitonic sequence — a sequence that is first strictly increasing and then strictly decreasing. Your task is to implement an efficient algorithm to find the k-th smallest element in the list using a modified binary search strategy. Function Signature ```python def find_kth_smallest_in_bitonic(lst: list[int], k: int) -> int: pass ``` Input - A list of integers `lst` (1 ≤ len(lst) ≤ 10^5) which follows the bitonic property: first strictly increasing and then strictly decreasing. - An integer `k` (1 ≤ k ≤ len(lst)) representing the 1-based index of the smallest element to find. Output - An integer representing the k-th smallest element in the bitonic list. # Constraints 1. The list will always have at least one valid result. 2. The list will conform to the bitonic property. 3. Any solution that runs in O(log n) per search or better will be accepted. # Examples ```python >>> find_kth_smallest_in_bitonic([1, 3, 8, 12, 4, 2], 1) 1 >>> find_kth_smallest_in_bitonic([1, 3, 8, 12, 4, 2], 4) 4 >>> find_kth_smallest_in_bitonic([10, 20, 30, 40, 30, 20, 10], 5) 30 >>> find_kth_smallest_in_bitonic([1, 3, 5, 7, 9, 8, 6, 4, 2], 7) 7 >>> find_kth_smallest_in_bitonic([1, 9, 8, 7, 6, 5], 3) 5 ``` # Notes 1. Your solution should leverage properties of the bitonic sequence to achieve efficient search performance. 2. Consider how to split the list at the peak and apply searching techniques on both sides as necessary. 3. Ensure that the k-th smallest element is correctly identified even with the split sequence.","solution":"def find_peak(lst): Returns the index of the peak element in the bitonic sequence using binary search. left, right = 0, len(lst) - 1 while left < right: mid = (left + right) // 2 if lst[mid] > lst[mid + 1]: right = mid else: left = mid + 1 return left def binary_search(lst, target, left, right): Returns the index of the target element in the lst within the range [left, right] if found, otherwise -1. while left <= right: mid = (left + right) // 2 if lst[mid] == target: return mid elif lst[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def find_kth_smallest_in_bitonic(lst, k): Finds the k-th smallest element in the bitonic sequence. peak_index = find_peak(lst) increasing_part = lst[:peak_index + 1] decreasing_part = lst[peak_index + 1:] combined_sorted = sorted(increasing_part + decreasing_part) return combined_sorted[k - 1]"},{"question":"# Palindrome Permutation Checker You\'ve been assigned to develop a feature for a new text processing application, which includes a function to determine if any permutation of a given string can form a palindrome. This functionality is crucial for optimizing certain text analysis algorithms. Task Implement a function `can_form_palindrome` to determine if any permutation of the input string can form a palindrome. Function Signature ```python def can_form_palindrome(string: str) -> bool: Checks if any permutation of the input string can form a palindrome. Parameters: string (str): The input string to check. Returns: bool: True if a palindrome permutation exists, False otherwise. ``` Requirements 1. **Palindrome Permutations**: - A string can form a palindrome if at most one character has an odd count. 2. **Case Insensitivity**: - The function should treat uppercase and lowercase letters as identical. 3. **Non-alphabetic Characters**: - Ignore non-alphabetic characters completely. Input and Output - **Input**: - A string `string` containing the input text. - **Output**: A boolean value indicating whether any permutation of the input string can form a palindrome. Example ```python print(can_form_palindrome(\\"Tact Coa\\")) # Output: True (permutations: \\"taco cat\\", \\"atco cta\\", etc.) print(can_form_palindrome(\\"Hello, World!\\")) # Output: False ``` Constraints - The input string can include non-alphabetic characters, which should be ignored. - The function should handle strings of reasonable length efficiently.","solution":"def can_form_palindrome(string: str) -> bool: Checks if any permutation of the input string can form a palindrome. Parameters: string (str): The input string to check. Returns: bool: True if a palindrome permutation exists, False otherwise. from collections import Counter import string as str_lib # Normalize string: convert to lowercase and remove non-alphabetic characters normalized_string = \'\'.join(filter(str_lib.ascii_letters.__contains__, string.lower())) # Count the frequency of each character char_count = Counter(normalized_string) # Check the frequency of characters (at most one character should have an odd count) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# File Word Counter **Context:** You are developing a text processing tool that performs various text analysis tasks. One of the required functionalities is counting the occurrence of each unique word in a file. This is useful for applications like generating word clouds or performing simple document analysis. **Objective:** Write a function `count_words` that reads a text file and returns a dictionary with words as keys and their respective counts as values. **Function Signature:** ```python def count_words(file_path: str) -> dict: ``` **Inputs:** * `file_path (str)`: a string representing the path to the text file. **Outputs:** * A `dict` where each key is a word (in lowercase) and the value is the count of that word in the file. **Constraints:** * Ignore case, i.e., \\"Word\\" and \\"word\\" should be counted as the same word. * Ignore punctuation (e.g., `!`, `.`, `,`), i.e., only alphabetic characters should be considered as part of words. * Ensure the function handles large files efficiently. * If the file does not exist, raise a `FileNotFoundError` with an appropriate message. **Example Usage:** ```python word_counts = count_words(\\"path_to_file.txt\\") print(word_counts) ``` **Notes:** * Consider edge cases such as empty files. * Tokenize the text properly to handle various punctuation marks and special characters. * You can use standard libraries such as `re` for regular expressions to help with word extraction and cleaning. # Example File Content If the file `document.txt` contains the following text: ``` Hello world! This is a test document. Hello again, world. ``` The function should output: ```python { \\"hello\\": 2, \\"world\\": 2, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"test\\": 1, \\"document\\": 1, \\"again\\": 1 } ```","solution":"import re from collections import defaultdict def count_words(file_path: str) -> dict: Reads a text file and returns a dictionary with words as keys and their respective counts as values. Parameters: file_path (str): Path to the text file Returns: dict: Dictionary with words as keys and their counts as values word_counts = defaultdict(int) try: with open(file_path, \'r\') as file: for line in file: # Use regex to find words and convert them to lowercase words = re.findall(r\'bw+b\', line.lower()) for word in words: word_counts[word] += 1 return dict(word_counts) except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} does not exist.\\")"},{"question":"# Problem Statement You are given an array of integers and an integer `x`. Your task is to determine whether there are three distinct elements in the array that add up to `x`. If such a triplet exists, return a list of the three integers; otherwise, return an empty list. # Function Signature ```python def find_triplet_sum(arr: list[int], x: int) -> list[int]: pass ``` # Input Format - `arr`: A list of integers (0 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6). - `x`: An integer representing the target sum (-10^6 <= x <= 10^6). # Output Format - A list of three integers from the array that add up to `x`. If there are multiple valid triplets, return any one of them. - If no such triplet exists, return an empty list. # Constraints 1. The integers should be distinct within the triplet. 2. The function should return an empty list if the array has fewer than three elements. # Performance Requirements - The function should run efficiently within given constraints. # Example ```python >>> find_triplet_sum([1, 2, 4, 5, 6], 10) [1, 4, 5] >>> find_triplet_sum([-1, 0, 1, 2, -1, -4], 0) [-1, -1, 2] >>> find_triplet_sum([1, 2, 3], 6) [1, 2, 3] >>> find_triplet_sum([2, 4], 6) [] ``` **Note**: You may assume that if an output list is returned, the integers will be in ascending order. If the array contains multiple identical triplets, any one valid list can be returned.","solution":"def find_triplet_sum(arr: list[int], x: int) -> list[int]: arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue target = x - arr[i] left, right = i + 1, n - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return [arr[i], arr[left], arr[right]] elif current_sum < target: left += 1 else: right -= 1 return [] # Example Usage: # print(find_triplet_sum([1, 2, 4, 5, 6], 10)) # print(find_triplet_sum([-1, 0, 1, 2, -1, -4], 0)) # print(find_triplet_sum([1, 2, 3], 6)) # print(find_triplet_sum([2, 4], 6))"},{"question":"```markdown # Task: Binary Search Tree (BST) Insertion and Traversal In this task, you are required to implement a Binary Search Tree (BST) and provide functions to insert nodes into the BST and to perform in-order traversal of the BST. # Expected Function Signatures 1. `def insert_into_bst(root: Optional[TreeNode], value: int) -> TreeNode:` 2. `def inorder_traversal(root: Optional[TreeNode]) -> List[int]:` # Inputs: 1. `root` (Optional[TreeNode]): The root node of the BST. It can be `None` if the tree is empty initially. 2. `value` (int): The value of the node to be inserted. 3. `root` (Optional[TreeNode]) for `inorder_traversal`: The root node of the BST to perform in-order traversal on. # Outputs: 1. `insert_into_bst`: Returns the root node of the BST after inserting the value. 2. `inorder_traversal`: Returns a list of integers representing the in-order traversal of the BST. # Constraints: - The values for the BST nodes are unique integers. # Requirements: 1. Implement the `TreeNode` class with attributes `val` (int), `left` (Optional[TreeNode]), and `right` (Optional[TreeNode]). 2. The `insert_into_bst` function should correctly insert a given value into the BST while maintaining the BST properties. 3. The `inorder_traversal` function should perform an in-order traversal (left-root-right) of the BST and return the values as a list. 4. Ensure that your solution handles edge cases, such as an empty tree or inserting into a single-node tree. # Example: ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def insert_into_bst(root: Optional[TreeNode], value: int) -> TreeNode: pass def inorder_traversal(root: Optional[TreeNode]) -> List[int]: pass # Example Usage: # Initialize an empty BST root = None # Insert values root = insert_into_bst(root, 5) root = insert_into_bst(root, 3) root = insert_into_bst(root, 7) root = insert_into_bst(root, 2) root = insert_into_bst(root, 4) # In-order traversal result = inorder_traversal(root) # Expected Output # [2, 3, 4, 5, 7] ``` # Instructions: 1. Implement the `insert_into_bst` function to correctly insert a new value into the BST. 2. Implement the `inorder_traversal` function to return the in-order traversal of the BST. 3. Test your implementation with various inputs to ensure correctness of insertion and traversal. ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def insert_into_bst(root: Optional[TreeNode], value: int) -> TreeNode: if root is None: return TreeNode(val=value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def inorder_traversal(root: Optional[TreeNode]) -> List[int]: if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)"},{"question":"# Image Blurring Blurring an image is a common technique used in image processing. In this task, you will implement a function that performs a Gaussian blur on an image. Gaussian blur smooths an image by averaging the pixel values within a neighborhood defined by a Gaussian function. Function Signature ```python def gaussian_blur(image: np.ndarray, kernel_size: int, sigma: float) -> np.ndarray: pass ``` # Input * `image`: A 2D or 3D numpy array representing the grayscale (2D) or color (3D) image to be blurred. * `kernel_size`: An integer representing the size of the Gaussian kernel. It will be an odd number between 3 and 15. * `sigma`: A float representing the standard deviation of the Gaussian distribution used to construct the kernel. # Output * A numpy array of the same dimensions as `image`, representing the blurred image. # Constraints * The pixel values will range from 0 to 255. * Images will have a maximum size of 2048 x 2048 pixels. # Performance Requirements * Your implementation should handle the maximum image size and kernel size efficiently. # Example ```python import numpy as np image = np.array([[0, 0, 0], [255, 255, 255], [127, 127, 127]]) kernel_size = 3 sigma = 1.0 # Expected output: a numpy array of the same shape as `image`, containing the blurred image print(gaussian_blur(image, kernel_size, sigma)) ```","solution":"import numpy as np from scipy.ndimage import gaussian_filter def gaussian_blur(image: np.ndarray, kernel_size: int, sigma: float) -> np.ndarray: Applies Gaussian blur to the given image using the specified kernel size and sigma. Args: image (np.ndarray): The input image which can be either 2D (grayscale) or 3D (color). kernel_size (int): The size of the Gaussian kernel, must be an odd number between 3 and 15. sigma (float): The standard deviation of the Gaussian distribution for kernel computation. Returns: np.ndarray: The blurred image. return gaussian_filter(image, sigma=sigma, truncate=((kernel_size - 1) / 2 - 0.5) / sigma)"},{"question":"# Question: Implement a Basic File System You are required to implement a basic in-memory file system that supports creating files, writing to them, and reading from them. Your task is to simulate a file system using a class-based approach. Class Definition ```python class BasicFileSystem: def __init__(self): ``` Detailed Requirements 1. **Methods**: - `create_file(path: str) -> None` - `write_file(path: str, content: str) -> None` - `read_file(path: str) -> str` 2. **Behavior**: - The `create_file` method should create a new file at the specified path. Raise an error if the file already exists. - The `write_file` method should write the given content to the file at the specified path. If the file does not exist, raise an error. - The `read_file` method should return the content of the file at the specified path as a string. If the file does not exist, raise an error. 3. **Constraints**: - The paths will be simple string names without directories (e.g., “file1.txt”). - File paths and content will be non-empty strings. - The content to be written will be a string with standard ASCII characters. 4. **Performance Requirements**: - File operations (create, read, write) should be completed efficiently within a reasonable time frame for a basic file system. Example ```python def main(): fs = BasicFileSystem() fs.create_file(\\"file1.txt\\") fs.write_file(\\"file1.txt\\", \\"Hello, world!\\") print(fs.read_file(\\"file1.txt\\")) # Output: \\"Hello, world!\\" if __name__ == \\"__main__\\": main() ``` This should demonstrate the ability to create, write, and read a file in the in-memory file system.","solution":"class BasicFileSystem: def __init__(self): self.files = {} def create_file(self, path: str) -> None: if path in self.files: raise FileExistsError(f\\"The file \'{path}\' already exists.\\") self.files[path] = \\"\\" def write_file(self, path: str, content: str) -> None: if path not in self.files: raise FileNotFoundError(f\\"The file \'{path}\' does not exist.\\") self.files[path] = content def read_file(self, path: str) -> str: if path not in self.files: raise FileNotFoundError(f\\"The file \'{path}\' does not exist.\\") return self.files[path]"},{"question":"# Problem Statement You are tasked with developing a simple book recommendation system for a library. Your function must help users by sorting books based on their ratings and recommending the top N books for a user. Additionally, implement functionality to find a specific book\'s rank based on its rating. # Function Signature ```python def recommend_books(books: List[Tuple[str, float]], N: int) -> List[str]: @param: books: A list of tuples where each tuple contains a book title (str) and its rating (float). @param: N: The number of top books to recommend (int). @return: A list of the top N book titles based on their ratings sorted in descending order. Example: >>> recommend_books([(\\"Book A\\", 4.5), (\\"Book B\\", 4.7), (\\"Book C\\", 4.6)], 2) [\'Book B\', \'Book C\'] pass def find_book_rank(books: List[Tuple[str, float]], book_title: str) -> int: @param: books: A list of tuples where each tuple contains a book title (str) and its rating (float). @param: book_title: The title of the book for which the rank is to be found (str). @return: The rank of the book based on its rating, where the highest-rated book is ranked 1. If the book is not found, return -1. Rankings are sorted in descending order of ratings, and ties are broken alphabetically by book title. Example: >>> find_book_rank([(\\"Book A\\", 4.5), (\\"Book B\\", 4.7), (\\"Book C\\", 4.6)], \\"Book B\\") 1 >>> find_book_rank([(\\"Book A\\", 4.5), (\\"Book B\\", 4.5), (\\"Book D\\", 4.6)], \\"Book A\\") 2 >>> find_book_rank([(\\"Book A\\", 4.5), (\\"Book B\\", 4.7), (\\"Book C\\", 4.6)], \\"Book X\\") -1 pass ``` # Input/Output * **Input**: - `recommend_books`: - `books`: A list of tuples where each tuple contains a book title and its rating. - `N`: The number of books to recommend. - `find_book_rank`: - `books`: A list of tuples where each tuple contains a book title and its rating. - `book_title`: The title of the book for which the rank is to be found. * **Output**: - `recommend_books`: A list of the top N book titles based on their ratings sorted in descending order. - `find_book_rank`: The rank of the book based on its rating, highest-rated book being ranked 1. If the book is not found, return -1. # Constraints * The length of books will be no more than 5000. * Each book will have a unique title. * Ratings are floating-point numbers ranging from 0.0 to 5.0. * N will be a positive integer and not exceed the number of books in the list. # Scenario Imagine a user in the library wants to find the best books to read based on ratings. This system helps identify the top-rated books and determines where a specific book stands in terms of popularity and quality. It sorts books by their ratings and provides recommendations to users based on the top N preferred books list.","solution":"from typing import List, Tuple def recommend_books(books: List[Tuple[str, float]], N: int) -> List[str]: books_sorted = sorted(books, key=lambda x: (-x[1], x[0])) return [book[0] for book in books_sorted[:N]] def find_book_rank(books: List[Tuple[str, float]], book_title: str) -> int: books_sorted = sorted(books, key=lambda x: (-x[1], x[0])) for rank, (title, rating) in enumerate(books_sorted, start=1): if title == book_title: return rank return -1"},{"question":"# Question: You are to design a system that categorizes a list of names based on their lengths and then sorts each category alphabetically. **Objective:** Write two functions, `categorize_names` and `rebuild_names`. 1. `categorize_names(names: list[str]) -> dict[int, list[str]]`: - Takes a list of names and categorizes them by the length of each name. - Each key in the returned dictionary should be the length of the names, and the corresponding value should be a sorted list of names of that length. 2. `rebuild_names(category: dict[int, list[str]]) -> list[str]`: - Takes a dictionary where keys are name lengths and values are sorted lists of names. - Combines all lists into a single list, sorted first by the length of the names and then alphabetically within each length category. **Constraints:** - The input list for `categorize_names` will only contain strings with alphabetic characters, no spaces or special characters. - The dictionary input for `rebuild_names` will always have lists that are sorted alphabetically. **Input and Output:** - For `categorize_names`: - **Input**: A list of alphabetic strings. - **Output**: A dictionary categorizing names by their lengths, with sorted lists of names. - For `rebuild_names`: - **Input**: A dictionary with integer keys and sorted list of strings as values. - **Output**: A single sorted list of names. **Examples:** 1. **Categorize Names Example:** ```python >>> categorize_names([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"]) {3: [\'Bob\', \'Eve\'], 5: [\'Alice\', \'David\'], 7: [\'Charlie\']} ``` 2. **Rebuild Names Example:** ```python >>> rebuild_names({3: [\'Bob\', \'Eve\'], 5: [\'Alice\', \'David\'], 7: [\'Charlie\']}) [\'Bob\', \'Eve\', \'Alice\', \'David\', \'Charlie\'] ``` **Function Signatures:** ```python def categorize_names(names: list[str]) -> dict[int, list[str]]: pass def rebuild_names(category: dict[int, list[str]]) -> list[str]: pass ``` **Performance Requirements:** - The solution should handle lists of names up to 10^6 elements efficiently.","solution":"def categorize_names(names: list[str]) -> dict[int, list[str]]: from collections import defaultdict # Create a default dictionary where each value is a list categories = defaultdict(list) # Categorize each name by its length for name in names: categories[len(name)].append(name) # Sort each list of names within the dictionary for length in categories: categories[length].sort() return dict(categories) def rebuild_names(category: dict[int, list[str]]) -> list[str]: # Initialize an empty result list result = [] # Get the keys in sorted order for length in sorted(category.keys()): # Extend the result list by the names of the current length result.extend(category[length]) return result"},{"question":"# Problem Statement You are developing a software for inventory management in a warehouse. The warehouse deals with a variety of items, each of which can be categorized into different types. Write a program that: 1. Takes a list of items where each item is represented by a tuple containing `item_id`, `category`, and `quantity`. 2. Aggregates the total quantity of items for each category. 3. Ensures that each item has a positive quantity, raising an appropriate error for invalid inputs. 4. Returns a sorted list of categories with their total quantities in descending order of quantities. # Input Format * A list of tuples, where each tuple contains: - `item_id` (string): Unique identifier for the item. - `category` (string): Category to which the item belongs. - `quantity` (integer): Quantity of the item, which must be positive. # Output Format * A list of tuples, where each tuple contains: - `category` (string): The category name. - `total_quantity` (integer): The total quantity of items in that category. * The list should be sorted in descending order of `total_quantity`. If two categories have the same total quantity, they should be sorted in ascending order of category name. # Constraints * All `quantity` values must be positive. # Example Input ```python [ (\\"item_1\\", \\"electronics\\", 10), (\\"item_2\\", \\"furniture\\", 5), (\\"item_3\\", \\"electronics\\", 4), (\\"item_4\\", \\"grocery\\", 15), (\\"item_5\\", \\"furniture\\", 5) ] ``` Output ```python [ (\\"grocery\\", 15), (\\"electronics\\", 14), (\\"furniture\\", 10) ] ``` # Function Signature The implementation should include a function: ```python def aggregate_inventory(items: list) -> list: pass ``` # Requirements 1. Ensure each item in the input list has a positive quantity. If any quantity is non-positive, raise a `ValueError` with the message \\"Quantity must be positive\\". 2. Use the provided input format and constraints to ensure correctness. 3. Clearly write and optimize your code for performance.","solution":"def aggregate_inventory(items): Aggregates the total quantity of items for each category and returns a sorted list of categories with their total quantities in descending order of quantities. Raises a ValueError if any of the quantities are non-positive. from collections import defaultdict category_totals = defaultdict(int) # Validate quantities and aggregate totals for item_id, category, quantity in items: if quantity <= 0: raise ValueError(\\"Quantity must be positive\\") category_totals[category] += quantity # Create a sorted list of categories by total quantity (descending), then by category name (ascending) sorted_totals = sorted(category_totals.items(), key=lambda x: (-x[1], x[0])) return sorted_totals"},{"question":"# Objective Implement a function that approximates the value of e (Euler\'s number) using its series expansion. # Background The mathematical constant e can be approximated using the following infinite series: [ e = sum_{n=0}^{infty} frac{1}{n!} ] Where `n!` denotes the factorial of `n`. Your task is to approximate e by summing the first `n` terms in this series. # Function Signature ```python def approximate_e(terms: int) -> float: pass ``` # Input - `terms` (int): The number of terms to be used in the approximation. # Output - A float representing the approximated value of e using the specified number of terms. # Constraints - If `terms` is not a positive integer, raise a `ValueError` with the message \\"`approximate_e() requires a positive integer for terms`\\". # Example ```python >>> approximate_e(1) 1.0 >>> approximate_e(5) 2.708333333333333 >>> approximate_e(10) 2.7182815255731922 ``` # Note - The more terms included in the series, the closer the approximation will be to the actual value of e. - Ensure proper handling of invalid input such as non-integer or negative values for `terms`.","solution":"import math def approximate_e(terms: int) -> float: if not isinstance(terms, int) or terms <= 0: raise ValueError(\\"approximate_e() requires a positive integer for terms\\") e_approx = sum(1 / math.factorial(i) for i in range(terms)) return e_approx"},{"question":"# Problem Statement You are tasked with implementing a k-Nearest Neighbors (kNN) classifier to predict the class of a point based on its nearest neighbors in a given dataset. The dataset consists of points in a 2D space, and each point has an associated class label. Your function needs to: 1. Calculate the Euclidean distance between points. 2. Identify the k nearest neighbors. 3. Predict the class based on the majority vote among the neighbors. # Function Signature ```python def knn_classify(train_points, train_labels, test_point, k): :param train_points: List[Tuple[float, float]] - List of tuples representing the coordinates of training points :param train_labels: List[int] - List of integer labels associated with each training point :param test_point: Tuple[float, float] - Tuple representing the coordinates of the point to classify :param k: int - The number of nearest neighbors to consider :return: int - Predicted class label for the test point ``` # Constraints & Input Format - `train_points` is a list of tuples where each tuple (x, y) represents the coordinates of a point in a 2D space. - `train_labels` is a list of integers (either 0 or 1) where `train_labels[i]` is the class label for `train_points[i]`. - `test_point` is a tuple (x, y) representing the coordinates of the point to be classified. - `len(train_points) == len(train_labels)` and `len(train_points) > 0`. - `1 <= k <= len(train_points)`. # Example ```python train_points = [(1.0, 2.0), (2.0, 3.0), (3.0, 4.0), (6.0, 7.0)] train_labels = [0, 1, 1, 0] test_point = (5.0, 5.0) k = 3 predicted_class = knn_classify(train_points, train_labels, test_point, k) print(predicted_class) # Expected output: 0 or 1, depending on the majority class among the neighbors ``` # Explanation 1. **Distance Calculation**: Compute the Euclidean distance between the `test_point` and each point in `train_points`. 2. **Finding Neighbors**: Sort these distances and select the k smallest to identify the nearest neighbors. 3. **Class Prediction**: Determine the class of `test_point` by taking a majority vote among the neighbors\' classes. In the given example, the `test_point` (5.0, 5.0) will have its class predicted by considering the 3 nearest points from the `train_points`. The majority class among these neighbors will be the predicted class.","solution":"import math from collections import Counter from typing import List, Tuple def knn_classify(train_points: List[Tuple[float, float]], train_labels: List[int], test_point: Tuple[float, float], k: int) -> int: Classifies a point based on k-nearest neighbors algorithm. :param train_points: List of tuples representing the coordinates of training points :param train_labels: List of integer labels associated with each training point :param test_point: Tuple representing the coordinates of the point to classify :param k: The number of nearest neighbors to consider :return: Predicted class label for the test point def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) distances = [(euclidean_distance(test_point, point), label) for point, label in zip(train_points, train_labels)] distances.sort(key=lambda x: x[0]) nearest_neighbors = distances[:k] neighbor_labels = [label for _, label in nearest_neighbors] most_common = Counter(neighbor_labels).most_common(1) return most_common[0][0]"},{"question":"# Coding Assessment Question: Basic Lisp Parentheses Balancer As a junior developer, you are tasked with creating a Python script that checks for balanced parentheses in a simplified version of Lisp expressions. In this basic Lisp, an expression is a sequence of characters containing only the following elements: `(`, `)`, spaces, numbers, and lower-case letters. Function: `is_balanced(expression: str) -> bool` - **Input**: - A string `expression`, representing the Lisp expression to verify. - **Output**: - A boolean value: `True` if the expression has balanced parentheses, `False` otherwise. - **Constraints**: - The input string will only contain valid characters: `0-9`, `a-z`, `(`, `)`, and spaces. - The expression can be an empty string, which should be considered as having balanced parentheses. # Example: ```python >>> is_balanced(\\"(a (b c) d)\\") True >>> is_balanced(\\"(a (b c d)\\") False >>> is_balanced(\\"((a b) c (d e))\\") True >>> is_balanced(\\")(\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"() ()\\") True ``` # Requirements: 1. Implement the function `is_balanced(expression: str) -> bool`. 2. Handle edge cases, such as empty strings, leading and trailing spaces, and the presence of multiple sets of balanced parentheses. 3. Ensure linear time O(n) complexity and aim for constant space complexity, where n is the length of the input string. 4. Avoid using any external libraries specific to parsing Lisp or expressions; implement all logic manually. Guidelines: * You should properly document your code with comments and explanations. * Include a main block that demonstrates the functionality of your function with valid test cases. * Ensure that your function is robust and can handle various valid and invalid input cases gracefully.","solution":"def is_balanced(expression: str) -> bool: Checks whether the given Lisp expression has balanced parentheses. Args: expression (str): The Lisp expression to check. Returns: bool: True if the expression has balanced parentheses, False otherwise. # Initialize a counter for open parentheses paren_count = 0 for char in expression: if char == \'(\': paren_count += 1 elif char == \')\': paren_count -= 1 # If at any point count becomes negative, parentheses are unbalanced if paren_count < 0: return False # At the end, all open parentheses should be matched with close parentheses return paren_count == 0"},{"question":"# Maximum Subarray Sum with Circumference Wrap-Around Scenario You are given an array of integers that represents periodic measurements (say temperature readings throughout the day). Therefore, the array should be considered circular, where the last element is followed by the first element. You need to find the maximum sum of a subarray, where the subarray can include elements wrapped around from the end to the beginning of the array. Objective Write a function `max_circular_subarray_sum` in Python that takes a list of integers and returns the maximum sum of a subarray, considering the circular nature of the array. Function Signature ```python def max_circular_subarray_sum(nums: list[int]) -> int: ``` Input: 1. `nums`: A list of integers representing periodic measurements. Output: An integer representing the maximum sum of any subarray, considering the circumference wrap-around of the array. Constraints: * The length of `nums` will be at least 1 and at most 10^6. * Each element in `nums` will be an integer between -10^4 and 10^4. Requirements: * The function should efficiently compute the maximum subarray sum considering both standard and circular subarrays. * Use appropriate methods and data structures to achieve the optimized solution. Example: ```python # Examples print(max_circular_subarray_sum([1, -2, 3, -2])) # Output: 3 (the subarray is [3]) print(max_circular_subarray_sum([5, -3, 5])) # Output: 10 (the subarray is [5, 5]) print(max_circular_subarray_sum([3, -2, 2, -3])) # Output: 3 (the subarray is [3]) print(max_circular_subarray_sum([-2, -3, -1])) # Output: -1 (the subarray is [-1]) print(max_circular_subarray_sum([8, -1, 3, 4])) # Output: 15 (the subarray is [8, -1, 3, 4]) ``` Use appropriate methods and data structures to achieve the optimized solution. Note: Ensure that the solution addresses cases where taking elements from the start and end of the array maximizes the sum, and consider standard non-circular subarrays as well.","solution":"def max_subarray_sum(nums): max_ending_here = max_so_far = nums[0] for x in nums[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def max_circular_subarray_sum(nums: list[int]) -> int: max_kadane = max_subarray_sum(nums) max_wrap = 0 for i in range(len(nums)): max_wrap += nums[i] nums[i] = -nums[i] max_wrap = max_wrap + max_subarray_sum(nums) if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"# Question Scenario: You are developing a module for an inventory management system at an e-commerce company. One of the functionalities required is to generate a summary of items in inventory. The summary should include the total count for each unique item present in the inventory. Task: Write a Python function `inventory_summary` that takes a list of strings representing items and returns a dictionary where the keys are the unique item names and the values are the counts of those items in the inventory. Function Signature: ```python def inventory_summary(items: list[str]) -> dict[str, int]: ``` Input: - A list of strings, `items` (0 <= len(items) <= 10^3). Output: - A dictionary where the keys are unique item names (strings) and values are integers representing the count of each item. Constraints: - Handle inventory lists efficiently, considering edge cases such as empty lists or lists with all identical items. - The items are case-sensitive, meaning \'item\' and \'Item\' should be counted separately. Example Usage: ```python >>> inventory_summary([\'apple\', \'orange\', \'apple\', \'banana\', \'apple\']) {\'apple\': 3, \'orange\': 1, \'banana\': 1} >>> inventory_summary([]) {} >>> inventory_summary([\'Apple\', \'apple\', \'APPLE\', \'apple\']) {\'Apple\': 1, \'apple\': 2, \'APPLE\': 1} >>> inventory_summary([\'banana\', \'banana\', \'banana\']) {\'banana\': 3} >>> inventory_summary([\'a\', \'b\', \'c\', \'a\', \'b\', \'a\']) {\'a\': 3, \'b\': 2, \'c\': 1} ```","solution":"def inventory_summary(items: list[str]) -> dict[str, int]: Generate a summary of items in the inventory. Parameters: items (list of str): A list of strings representing items. Returns: dict of {str: int}: A dictionary with unique item names as keys and their counts as values. summary = {} for item in items: if item in summary: summary[item] += 1 else: summary[item] = 1 return summary"},{"question":"# Binary Search Tree (BST) Insertion and Range Sum Query You are tasked with implementing a Binary Search Tree (BST) and creating a function to calculate the sum of all values within a given range. This exercise will test your understanding of fundamental data structures and tree traversal algorithms. Problem Statement Design and implement three functions: 1. `insert(root, value)`: Inserts a new value into the BST. 2. `range_sum_bst(root, low, high)`: Calculates the sum of all values in the BST that fall within the specified range [low, high] (inclusive). 3. `build_bst_from_list(values)`: Helper function to build a BST from a list of values. # Function Definitions: 1. **`insert(root, value)`**: - **Input**: A `root` node of the BST and an integer `value` to be inserted. - **Output**: The root node of the BST after the insertion. - **Constraints**: Assume the input value to be inserted is unique. 2. **`range_sum_bst(root, low, high)`**: - **Input**: The root node of a BST, and two integers `low` and `high` representing the range. - **Output**: The sum of all values within the range [low, high]. - **Constraints**: Assume `low <= high`. 3. **`build_bst_from_list(values)`**: - **Input**: A list of integer values. - **Output**: The root node of the constructed BST. Example: ```python values = [10, 5, 15, 3, 7, 18] root = build_bst_from_list(values) low = 7 high = 15 result = range_sum_bst(root, low, high) print(f\\"Range Sum: {result}\\") ``` Expected Output: - Range Sum: 32 (7 + 10 + 15) # Additional Requirements: - Handle edge cases such as an empty list of values. - Optimize your implementation to avoid unnecessary traversal of the BST. You may use the helper class and methods provided for defining `BSTNode`. # Supporting Classes and Methods: ```python class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, value): if root is None: return BSTNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root def range_sum_bst(root, low, high): if root is None: return 0 if root.value > high: return range_sum_bst(root.left, low, high) if root.value < low: return range_sum_bst(root.right, low, high) return root.value + range_sum_bst(root.left, low, high) + range_sum_bst(root.right, low, high) def build_bst_from_list(values): root = None for value in values: root = insert(root, value) return root ``` Your task is to implement the functions `insert`, `range_sum_bst`, and `build_bst_from_list` to handle BST insertion and range sum queries.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, value): if root is None: return BSTNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root def range_sum_bst(root, low, high): if root is None: return 0 if root.value > high: return range_sum_bst(root.left, low, high) if root.value < low: return range_sum_bst(root.right, low, high) return root.value + range_sum_bst(root.left, low, high) + range_sum_bst(root.right, low, high) def build_bst_from_list(values): root = None for value in values: root = insert(root, value) return root"},{"question":"# Coding Question: String Transformation Permutations You are given a string consisting of only lowercase English letters. The goal is to transform the string into all possible unique permutations where each letter can be either uppercase or lowercase. Write a function `count_unique_permutations(s: str) -> int` that takes a string `s` as input and returns the number of unique permutations where each letter in the string can be transformed independently to either its uppercase or lowercase form. **Input:** * A string `s` (1 ≤ len(s) ≤ 20) consisting only of lowercase English letters. **Output:** * An integer representing the number of unique permutations where each character can be in either lowercase or uppercase. **Example:** ```python >>> count_unique_permutations(\\"a\\") 2 >>> count_unique_permutations(\\"abc\\") 8 >>> count_unique_permutations(\\"aab\\") 4 ``` **Explanation:** - For `s = \\"a\\"`, the permutations are `\\"a\\"`, `\\"A\\"`. - For `s = \\"abc\\"`, the permutations are `\\"abc\\"`, `\\"abC\\"`, `\\"aBc\\"`, `\\"aBC\\"`, `\\"Abc\\"`, `\\"AbC\\"`, `\\"ABc\\"`, `\\"ABC\\"`. - For `s = \\"aab\\"`, the permutations are `\\"aab\\"`, `\\"aaB\\"`, `\\"aAb\\"`, `\\"aAB\\"`, `\\"Aab\\"`, `\\"AaB\\"`, `\\"AAb\\"`. **Constraints:** * The input string will not be empty and will contain lowercase English letters only. * The resulting permutations should be unique, meaning `\\"a\\"` and `\\"A\\"` are considered the same letter regardless of case. **Hint:** Consider using recursion or bit manipulation to generate all possible case permutations of the string efficiently. Use a set to avoid duplicate permutations.","solution":"def count_unique_permutations(s: str) -> int: Returns the number of unique permutations where each character in the string can be either lowercase or uppercase. from itertools import product s = s.lower() # Ensure the input string is in lowercase # Create permutations using product and sets unique_permutations = set() for transformation in product(*[(c.lower(), c.upper()) for c in s]): unique_permutations.add(\'\'.join(transformation)) return len(unique_permutations)"},{"question":"# Question **Robot Path Navigator** You are given a grid of `N x N` dimensions where each cell can either be empty (represented by `0`) or contain an obstacle (represented by `1`). Your task is to implement a function that determines if there exists a path for a robot to move from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1). The robot can move up, down, left, or right but cannot pass through cells containing obstacles. Additionally, the grid may dynamically change during the robot\'s traversal due to obstacles being added or removed in real-time. Your goal is to: 1. Ensure the robot always finds the shortest path if one exists. 2. Handle dynamic changes to the grid seamlessly during traversal. 3. Ensure the function is efficient and responsive to real-time grid updates. **Function Signature** ```python def robot_path_exists(grid: list[list[int]], updates: list[tuple[int, int, int]]) -> bool: ... ``` # Expected Input and Output Format * **Input**: * `grid` (list[list[int]]): A 2D list representing the initial grid configuration. * `updates` (list[tuple[int, int, int]]): A list of updates, where each update is a tuple containing `(row, col, value)`. Each update specifies the cell at `grid[row][col]` to be changed to `value` (either `0` or `1`). * **Output**: * A boolean value indicating whether there is a valid path from the top-left corner to the bottom-right corner after considering all updates. # Constraints * Ensure that the function handles edge cases where the grid size is 1x1 or all cells contain obstacles. * Number of updates can be large, and updates should be applied efficiently. # Scenario/Context Consider a scenario where a delivery robot operates in a warehouse setup represented by the grid. Obstacles such as boxes and pallets are frequently moved, requiring the robot to dynamically reassess its path to the destination. # Example **Example 1**: ```python >>> grid = [ ... [0, 1, 0], ... [0, 0, 0], ... [1, 0, 0] ... ] >>> updates = [(1, 1, 1), (2, 1, 1), (2, 2, 1)] >>> robot_path_exists(grid, updates) False ``` **Example 2**: ```python >>> grid = [ ... [0, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> updates = [(0, 2, 0), (1, 0, 0)] >>> robot_path_exists(grid, updates) True ``` **Example Edge Case**: ```python >>> grid = [ ... [0] ... ] >>> updates = [] >>> robot_path_exists(grid, updates) True ``` # Performance Considerations * Ensure optimal pathfinding even with large grids and numerous updates. * Minimize redundant calculations by efficiently incorporating grid updates.","solution":"from collections import deque def is_valid(grid, x, y, N): Checks if the given coordinates are within the grid bounds and if the cell is not an obstacle. return 0 <= x < N and 0 <= y < N and grid[x][y] == 0 def bfs(grid, N): Performs BFS to find if there is a path from top-left corner to bottom-right corner. if grid[0][0] == 1 or grid[N-1][N-1] == 1: return False queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == (N-1, N-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(grid, nx, ny, N) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False def robot_path_exists(grid, updates): Returns True if there is a path from the top-left to bottom-right corner after applying all updates. N = len(grid) # Apply updates to the grid for row, col, value in updates: grid[row][col] = value return bfs(grid, N)"},{"question":"# Coding Assessment Question Task You are required to write a Python function that identifies the most frequent word in a given string of text, excluding any given list of stop words. Function Specifications Write a function `most_frequent_word(text: str, stopwords: list) -> str` that: * Takes two inputs: * `text` (string): A string of text in which to search for the most frequent word. * `stopwords` (list): A list of words to be excluded from consideration. * Returns a string representing the most frequent word in the text that is not part of the stop words list. Constraints * The function should be case-insensitive, meaning that \\"Word\\" and \\"word\\" are considered the same. * Punctuation marks should be ignored. Thus, \\"word,\\" and \\"word.\\" are considered the same. * If there are multiple words with the same highest frequency, return any one of them. * The returned word should be in lowercase. Example **Input:** ```python text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" stopwords = [\\"the\\", \\"was\\", \\"not\\"] frequent_word = most_frequent_word(text, stopwords) print(frequent_word) ``` **Expected Output:** ```python \\"dog\\" ``` **Explanation:** In the input example, \\"the\\" and \\"was\\" appear frequently but are in the stop words list. The next most frequent and non-stop words are \\"dog\\" and \\"fox\\", among which \\"dog\\" was chosen. Performance Requirements * The function should efficiently handle text containing up to 10,000 words within a reasonable time frame (under 2 seconds). Additional Context Consider using Python\'s `collections.Counter` for counting word occurrences and `string.punctuation` for removing punctuation. Use `str.lower()` to convert words to lowercase.","solution":"import string from collections import Counter def most_frequent_word(text: str, stopwords: list) -> str: Identifies the most frequent word in the given text excluding the stop words. Arguments: text : str : The input text stopwords : list : List of stop words to be excluded Returns: str : the most frequent word not in the stopwords list # Convert the text to lowercase and remove punctuation text = text.lower() text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Split the text into words words = text.split() # Filter words that are not in the stopwords list filtered_words = [word for word in words if word not in stopwords] # Count the occurrence of each word word_counts = Counter(filtered_words) # Return the word with the highest frequency if word_counts: return word_counts.most_common(1)[0][0] return \\"\\""},{"question":"# Balanced Binary Tree Verification **Scenario**: You are a software developer tasked with ensuring that a binary tree remains balanced as nodes are inserted and deleted. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than one. This property is crucial for maintaining efficient operations, such as insertion, deletion, and lookups, which should have a time complexity close to O(log n). # Problem Statement Implement a function `is_balanced` which receives a binary tree\'s root node and returns a boolean indicating whether the tree is balanced or not. Additionally, provide an analysis of the function\'s time complexity. **Function Signature** ```python def is_balanced(root: Optional[TreeNode]) -> bool: pass ``` **Input/Output Format** * **Input**: - `root`: The root node of the binary tree, or `None` if the tree is empty. * **Output**: - A boolean value `True` if the binary tree is balanced, otherwise `False`. **Constraints** * A binary tree node is represented as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * The tree can have up to 10^5 nodes. * Node values can be any integer within the range of -10^6 to 10^6. # Constraints/Edge Cases to Consider 1. An empty tree (should be considered balanced). 2. A tree with a single node. 3. Trees with only left or right subtrees. 4. Large, completely balanced binary trees. 5. Large, completely unbalanced binary trees. # Requirements Besides implementing the `is_balanced` function, provide a discussion on the function\'s time complexity, explaining how it handles the worst and best-case scenarios in terms of height and balance of the tree. ```python def is_balanced(root: Optional[TreeNode]) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_height = max(left_height, right_height) + 1 current_balanced = (abs(left_height - right_height) <= 1) and left_balanced and right_balanced return current_height, current_balanced _, result = height_and_balance(root) return result ``` **Discussion**: The `is_balanced` function employs a recursive approach to calculate both the height of a subtree and its balanced status in a single traversal. This ensures that each subtree is visited only once, resulting in a time complexity of O(n), where n is the number of nodes in the tree. This efficiency is critical for handling large binary trees with up to 10^5 nodes.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_height = max(left_height, right_height) + 1 current_balanced = (abs(left_height - right_height) <= 1) and left_balanced and right_balanced return current_height, current_balanced _, result = height_and_balance(root) return result"},{"question":"# Problem Statement You are tasked to create a system that simulates a parking lot and allows users to park and retrieve their vehicles. The parking lot will have a limited number of parking spaces, each designated to a specific vehicle type (car, motorcycle, bus). Your task is to implement the functionality using a class-based approach. # Class Details Implement the class `ParkingLot` that will manage the parking lot and vehicle operations. The class should include methods to park and retrieve vehicles as well as to check the current status of the parking lot. # Class Definition ```python class ParkingLot: def __init__(self, car_spaces: int, motorcycle_spaces: int, bus_spaces: int): Initialize the parking lot with specific spaces for each vehicle type. Parameters: car_spaces (int): Number of parking spaces available for cars. motorcycle_spaces (int): Number of parking spaces available for motorcycles. bus_spaces (int): Number of parking spaces available for buses. pass def park_vehicle(self, vehicle_type: str) -> bool: Parks a vehicle in the parking lot. Parameters: vehicle_type (str): Type of the vehicle, can be either \\"car\\", \\"motorcycle\\", or \\"bus\\". Returns: bool: True if the vehicle was parked successfully, False if there is no available space. pass def retrieve_vehicle(self, vehicle_type: str) -> bool: Retrieves a vehicle from the parking lot. Parameters: vehicle_type (str): Type of the vehicle being retrieved, can be either \\"car\\", \\"motorcycle\\", or \\"bus\\". Returns: bool: True if the vehicle was retrieved successfully, False if there were no vehicles of that type to retrieve. pass def status(self) -> dict: Retrieves the current status of the parking lot. Returns: dict: A dictionary containing counts of available spaces for each vehicle type. pass ``` # Example ```python parking_lot = ParkingLot(5, 3, 2) # Park vehicles print(parking_lot.park_vehicle(\\"car\\")) # Output: True print(parking_lot.park_vehicle(\\"motorcycle\\")) # Output: True print(parking_lot.park_vehicle(\\"bus\\")) # Output: True print(parking_lot.park_vehicle(\\"car\\")) # Output: True print(parking_lot.park_vehicle(\\"car\\")) # Output: True print(parking_lot.park_vehicle(\\"car\\")) # Output: True print(parking_lot.park_vehicle(\\"bus\\")) # Output: True print(parking_lot.park_vehicle(\\"bus\\")) # Output: False (No more space for buses) # Retrieve vehicles print(parking_lot.retrieve_vehicle(\\"car\\")) # Output: True print(parking_lot.retrieve_vehicle(\\"bus\\")) # Output: True print(parking_lot.retrieve_vehicle(\\"bus\\")) # Output: True # Check status print(parking_lot.status()) # Output: {\'car\': 4, \'motorcycle\': 2, \'bus\': 2} ``` # Constraints - The parking lot should manage the spaces efficiently and without runtime errors. - All operations should run within reasonable time limits. - Assume valid inputs will be provided, but implement basic error handling for cases where spaces are unavailable or vehicles of specific types are not present for retrieval.","solution":"class ParkingLot: def __init__(self, car_spaces: int, motorcycle_spaces: int, bus_spaces: int): Initialize the parking lot with specific spaces for each vehicle type. Parameters: car_spaces (int): Number of parking spaces available for cars. motorcycle_spaces (int): Number of parking spaces available for motorcycles. bus_spaces (int): Number of parking spaces available for buses. self.spaces = { \\"car\\": car_spaces, \\"motorcycle\\": motorcycle_spaces, \\"bus\\": bus_spaces } self.parked_vehicles = { \\"car\\": 0, \\"motorcycle\\": 0, \\"bus\\": 0 } def park_vehicle(self, vehicle_type: str) -> bool: Parks a vehicle in the parking lot. Parameters: vehicle_type (str): Type of the vehicle, can be either \\"car\\", \\"motorcycle\\", or \\"bus\\". Returns: bool: True if the vehicle was parked successfully, False if there is no available space. if vehicle_type in self.spaces and self.parked_vehicles[vehicle_type] < self.spaces[vehicle_type]: self.parked_vehicles[vehicle_type] += 1 return True return False def retrieve_vehicle(self, vehicle_type: str) -> bool: Retrieves a vehicle from the parking lot. Parameters: vehicle_type (str): Type of the vehicle being retrieved, can be either \\"car\\", \\"motorcycle\\", or \\"bus\\". Returns: bool: True if the vehicle was retrieved successfully, False if there were no vehicles of that type to retrieve. if vehicle_type in self.spaces and self.parked_vehicles[vehicle_type] > 0: self.parked_vehicles[vehicle_type] -= 1 return True return False def status(self) -> dict: Retrieves the current status of the parking lot. Returns: dict: A dictionary containing counts of available spaces for each vehicle type. return { vehicle_type: self.spaces[vehicle_type] - count for vehicle_type, count in self.parked_vehicles.items() }"},{"question":"# Coding Assessment Question: Implement Merging Two Sorted Lists Context Given two sorted singly linked lists, the task is to write a function within the `LinkedList` class to merge them into a single sorted linked list. The function should merge the lists in-place, without using any extra space for another list. Input & Output *Input*: Two heads of singly linked lists. *Output*: The head of the new, merged, and sorted linked list. Constraints 1. The lists may vary in length. 2. The function should handle empty lists appropriately. 3. The function should merge the lists in O(n + m) time complexity, where n and m are the lengths of the two lists. 4. The function should operate with O(1) additional space complexity, modifying the original lists directly. Function Signature ```python class LinkedList: def __init__(self, head=None): self.head = head def merge_sorted_lists(self, l1, l2): Merges two sorted linked lists into one sorted linked list. Args: l1 (Node): The head of the first sorted linked list. l2 (Node): The head of the second sorted linked list. Returns: Node: The head of the merged and sorted linked list. ``` Scenario Consider the following scenario to further illustrate: ```python # Assume Node class and LinkedList.push() method are defined as necessary link1 = LinkedList() link1.push(4) link1.push(2) link1.push(1) link2 = LinkedList() link2.push(4) link2.push(3) link2.push(1) merged_head = link1.merge_sorted_lists(link1.head, link2.head) # Expected output is the head of the merged list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # The exact function to print the linked list is not provided, but the structure and linkage are merged appropriately. ``` In the example above, the initial lists are `1 -> 2 -> 4 -> None` and `1 -> 3 -> 4 -> None`. The merged linked list will be `1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None`. Complete the `merge_sorted_lists()` function to perform this task efficiently.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, head=None): self.head = head def push(self, new_value): new_node = Node(new_value) new_node.next = self.head self.head = new_node def merge_sorted_lists(self, l1, l2): dummy = Node(0) current = dummy while l1 and l2: if l1.value <= l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next def to_list(self): node = self.head output = [] while node: output.append(node.value) node = node.next return output"},{"question":"# Coding Assessment Question **Context**: You are developing a utility library for handling matrix operations, and a common requirement is to check certain properties of a matrix related to connectivity and traversal. **Problem Statement**: Implement a function to determine whether there exists a path from the top-left corner to the bottom-right corner of a matrix. The path can only be formed by traversing cells containing 1s. You can move up, down, left, or right, but not diagonally. # Function Signature: ```python def matrix_path_exists(matrix: list[list[int]]) -> bool: pass ``` # Input: 1. **matrix (list[list[int]])**: A 2D list where each element is either 0 or 1, representing the matrix. # Output: Returns a boolean value indicating whether there exists a path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of the matrix. The path can only traverse cells containing 1. # Constraints: 1. ( 1 leq m, n leq 1000 ) where ( m ) is the number of rows and ( n ) is the number of columns. 2. The top-left corner and the bottom-right corner always contain 1. # Example: ```python assert matrix_path_exists([ [1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [0, 1, 1, 1, 0], [1, 0, 1, 1, 1] ]) == True assert matrix_path_exists([ [1, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1] ]) == False ``` # Explanation: 1. In the first example, there is a path from the top-left to the bottom-right corner following cells with 1s. 2. In the second example, no such path exists. # Notes: - Use breadth-first search (BFS) or depth-first search (DFS) to find if such a path exists. - Ensure to handle matrices with edge cases like single rows or single columns. - Optimize the implementation for large matrices using appropriate traversal techniques.","solution":"def matrix_path_exists(matrix): if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) if matrix[0][0] == 0 or matrix[rows-1][cols-1] == 0: return False from collections import deque queue = deque([(0, 0)]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() visited.add((0, 0)) while queue: current_row, current_col = queue.popleft() if current_row == rows - 1 and current_col == cols - 1: return True for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] == 1 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col)) return False"},{"question":"# Coding Assessment Task Context You are tasked with implementing a calculator that can handle basic arithmetic operations and evaluate mathematical expressions given as strings. The calculator should support addition, subtraction, multiplication, and division operations and handle parentheses for operation precedence. Objective Create a `SimpleCalculator` class that can parse and evaluate arithmetic expressions. Your implementation needs to correctly follow the order of operations (also known as BODMAS/BIDMAS rules: Brackets, Orders (i.e. powers and square roots, etc.), Division and Multiplication, Addition and Subtraction). Requirements - Implement a method to parse strings and evaluate arithmetic expressions. - Support addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and parentheses. - Ensure proper exception handling for division by zero and invalid expressions. # Function Specifications `SimpleCalculator` * **Methods**: - `__init__(self)`: Initialize any necessary data structures. - `evaluate(self, expression)`: Parse and evaluate the given arithmetic expression string. # Constraints - The input expression will be a non-empty string containing only digits, operators (`+`, `-`, `*`, `/`), and parentheses `()`. - The calculator should handle integers and floating-point numbers. # Examples ```python calculator = SimpleCalculator() # Example 1 assert calculator.evaluate(\\"3+2*2\\") == 7 # Example 2 assert calculator.evaluate(\\" 3/2 \\") == 1.5 # Example 3 assert calculator.evaluate(\\"(2+3)*(4-2)\\") == 10 # Example 4 try: calculator.evaluate(\\"3/0\\") except ZeroDivisionError: print(\\"Cannot divide by zero.\\") # Example 5 try: calculator.evaluate(\\"3 +\\") except ValueError: print(\\"Invalid Expression.\\") ``` # Hints - Consider using the Shunting Yard algorithm or recursion to handle operator precedence and parentheses. - Use Python\'s built-in `eval` should be avoided for security reasons. - Exception handling should be robust to manage invalid operations and provide meaningful error messages.","solution":"class SimpleCalculator: def __init__(self): pass def evaluate(self, expression: str) -> float: def parse_expression(expression): tokens = [] number = \'\' for char in expression: if char.isdigit() or char == \'.\': number += char else: if number: tokens.append(float(number)) number = \'\' if char in \\"+-*/()\\": tokens.append(char) if number: tokens.append(float(number)) return tokens def shunting_yard(tokens): precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] operators = [] for token in tokens: if isinstance(token, float): output.append(token) elif token in precedence: while (operators and operators[-1] in precedence and precedence[token] <= precedence[operators[-1]]): output.append(operators.pop()) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return output def evaluate_rpn(rpn): stack = [] for token in rpn: if isinstance(token, float): stack.append(token) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': if b == 0: raise ZeroDivisionError(\\"Division by zero.\\") stack.append(a / b) return stack[0] try: tokens = parse_expression(expression) rpn = shunting_yard(tokens) return evaluate_rpn(rpn) except (IndexError, ValueError): raise ValueError(\\"Invalid Expression\\") calculator = SimpleCalculator()"},{"question":"# Coding Question Scenario You are creating a system to manage participants in a game tournament. Each participant has a unique identifier and a score, and you need to keep track of the top scoring participants dynamically as new scores are added. To accomplish this, you want to implement a leaderboard that can update with new scores and maintain the top scoring participants efficiently. Requirements Implement a class `Leaderboard` which supports the following methods: - `add_score`: Adds a new score for a participant. If the participant already exists, update their score by adding the new score to their existing score. - `top`: Returns a list of the top `k` participants sorted in descending order of their scores. If there are less than `k` participants, return all of them sorted by their scores. Class Signature ```python class Leaderboard: def __init__(self): self.scores = {} def add_score(self, participant_id: int, score: int) -> None: # Add or update the score for the participant def top(self, k: int) -> list[int]: # Return the top k participants\' IDs sorted by their scores ``` Method Descriptions * `add_score(participant_id: int, score: int) -> None`: - `participant_id`: The unique ID of the participant (an integer). - `score`: The score to be added for the participant (an integer). * `top(k: int) -> list[int]`: - `k`: The number of top participants to return (an integer). Constraints 1. All participant IDs and scores are integers. 2. You may assume that there will not be more than 10,000 participants. 3. `k` will not exceed the number of participants. Example ```python leaderboard = Leaderboard() leaderboard.add_score(1, 50) leaderboard.add_score(2, 60) leaderboard.add_score(1, 20) print(leaderboard.top(2)) # Output: [1, 2] leaderboard.add_score(3, 100) print(leaderboard.top(2)) # Output: [3, 1] ``` Edge Cases 1. Adding a score for a participant that does not exist. 2. Requesting more top participants than exist in the leaderboard. 3. Handling negative scores if they are added. Your implementation should ensure that the scores are maintained efficiently for frequent updates and requests for the top participants.","solution":"class Leaderboard: def __init__(self): self.scores = {} def add_score(self, participant_id: int, score: int) -> None: if participant_id in self.scores: self.scores[participant_id] += score else: self.scores[participant_id] = score def top(self, k: int) -> list[int]: sorted_participants = sorted(self.scores.items(), key=lambda x: x[1], reverse=True) return [participant_id for participant_id, score in sorted_participants[:k]]"},{"question":"# Problem Statement You are given a list of strings representing a collection of domain names. The goal is to categorize these domain names based on their respective top-level domains (TLDs) and return a summary of the counts for each TLD. # Requirements 1. Implement a function `count_tlds(domains: List[str]) -> Dict[str, int]` that: - Takes a list of domain names as input. - Categorizes the domain names by their TLDs. - Returns a dictionary where the keys are the TLDs and the values are the counts of domain names for each TLD. # Input - `domains`: A list of strings where each string represents a domain name. # Output - Returns a dictionary containing the counts of domain names for each TLD: ```python { \\"com\\": count, \\"org\\": count, \\"net\\": count, \\"io\\": count, ... } ``` # Constraints - The list of domain names will contain only lowercase alphanumeric characters and dots. - Assume that the TLD is the part of the domain that comes after the last dot. - The input list can have a maximum length of 1000 domain names, and each domain name can have a maximum length of 255 characters. # Example ```python domains = [\\"example.com\\", \\"test.org\\", \\"site.net\\", \\"platform.io\\", \\"app.com\\", \\"foo.org\\"] result = count_tlds(domains) print(result) # Expected Output # { # \\"com\\": 2, # \\"org\\": 2, # \\"net\\": 1, # \\"io\\": 1 # } ``` # Function Signature ```python from typing import List, Dict def count_tlds(domains: List[str]) -> Dict[str, int]: # Your implementation here pass ```","solution":"from typing import List, Dict def count_tlds(domains: List[str]) -> Dict[str, int]: Categorizes domain names by their TLDs and returns a dictionary where the keys are the TLDs and the values are the counts of domain names for each TLD. tld_counts = {} for domain in domains: tld = domain.split(\'.\')[-1] if tld in tld_counts: tld_counts[tld] += 1 else: tld_counts[tld] = 1 return tld_counts"},{"question":"# Problem Statement You are developing a feature for a music streaming service that involves generating user playlists. In order to create more personalized playlists based on listening habits, you need to compute a similarity score between two playlists. Given two playlists represented by lists of song IDs, your task is to compute the similarity score using the Jaccard index. # Function Specification **Function Name**: `playlist_similarity` **Input**: - `playlist1`: A list of integers representing the song IDs in the first playlist. - `playlist2`: A list of integers representing the song IDs in the second playlist. **Output**: - A float representing the Jaccard similarity score between the two playlists, rounded to two decimal places. # Constraints: - The playlists can have up to 10000 elements. - Each song ID is a unique positive integer between 1 and 100000 inclusive. - Assume that the playlists do not contain duplicate song IDs. # Examples 1. Example 1: ```python playlist1 = [1, 2, 3, 4] playlist2 = [3, 4, 5, 6] playlist_similarity(playlist1, playlist2) ``` Output: ```python 0.33 ``` 2. Example 2: ```python playlist1 = [10, 20, 30, 40, 50] playlist2 = [10, 20, 30, 60, 70] playlist_similarity(playlist1, playlist2) ``` Output: ```python 0.43 ``` 3. Example 3: ```python playlist1 = [100, 200, 300] playlist2 = [400, 500, 600] playlist_similarity(playlist1, playlist2) ``` Output: ```python 0.00 ``` # Requirements: - Your solution should have a time complexity of O(n). - Do not use any external libraries except `numpy`. *Note*: The Jaccard index between two sets A and B is given by the size of their intersection divided by the size of their union. Ensure your function handles cases where the union size is zero appropriately.","solution":"def playlist_similarity(playlist1, playlist2): Computes the Jaccard similarity score between two playlists. set1 = set(playlist1) set2 = set(playlist2) intersection = set1 & set2 union = set1 | set2 if len(union) == 0: return 0.0 similarity = len(intersection) / len(union) return round(similarity, 2)"},{"question":"# Coding Challenge: Fibonacci Sequence and Summation Context: You are doing research on mathematical sequences and need to implement functions related to the Fibonacci sequence. The Fibonacci numbers have applications in data structures, algorithms, and number theory. Function 1: Efficient Fibonacci Generation **Description**: Write a function, `fibonacci_sequence(n: int) -> List[int]`, that generates the first `n` Fibonacci numbers. The first two Fibonacci numbers are 0 and 1, and each subsequent number is the sum of the two preceding ones. - **Input**: An integer `n` (1 ≤ n ≤ 10^5) - **Output**: A list of the first `n` Fibonacci numbers. - **Constraints**: - Ensure the function handles the case where `n` is 1 by returning [0]. - Use an iterative approach to avoid excessive recursion depth and ensure the function is efficient even for large `n`. Function 2: Sum of Fibonacci Numbers in a Range **Description**: Write a function, `fibonacci_sum_range(start: int, end: int) -> int`, that takes two integers `start` and `end`, generates the Fibonacci sequence up to the `end`-th number, and returns the sum of the Fibonacci numbers between the `start`-th and `end`-th positions (inclusive, 1-based index). - **Input**: Two integers `start` and `end` (1 ≤ start ≤ end ≤ 10^5) - **Output**: An integer representing the sum of the specified range of Fibonacci numbers. - **Constraints**: - Ensure the function is efficient and handles large ranges gracefully. - Include input validation to handle cases where `start` is greater than `end` or if inputs are out of the allowed range. ```python from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n Fibonacci numbers. pass # Implement the function def fibonacci_sum_range(start: int, end: int) -> int: Returns the sum of Fibonacci numbers in the range specified by start and end (inclusive, 1-based index). pass # Implement the function # Example Usage: # fibonacci_sequence(10) -> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # fibonacci_sum_range(3, 6) -> 12 # (1 + 2 + 3 + 5 = 11) ``` Notes: 1. Ensure your solutions are optimized for the given constraints. 2. Your functions should include necessary input validation and handle edge cases appropriately.","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n Fibonacci numbers. if n == 1: return [0] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence def fibonacci_sum_range(start: int, end: int) -> int: Returns the sum of Fibonacci numbers in the range specified by start and end (inclusive, 1-based index). # Input validation if start > end or start < 1 or end < 1: return 0 # Generate Fibonacci up to `end` fib_sequence = fibonacci_sequence(end) # Sum the range return sum(fib_sequence[start-1:end]) # Example Usage: # print(fibonacci_sequence(10)) -> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # print(fibonacci_sum_range(3, 6)) -> 12 # (1 + 2 + 3 + 5 = 11)"},{"question":"# Scenario A library is automating the management of its book borrowing system. To better allocate the available books, the librarian wants to optimize the distribution so that the maximum number of books can be borrowed while minimizing the waiting period for the borrowers. Each borrower has a list of books they wish to borrow and can only borrow one book at a time. Each book can only be borrowed by one person at a time. # Problem Given the details of the borrower\'s book preferences and the list of books, implement the function `optimize_borrowing(borrower_pref: list[list[int]], available_books: list[bool]) -> list[int]` to find an optimal borrowing match where the maximum number of borrowers can get a book from their preference list. Input * `borrower_pref`: A list of lists. Each sublist represents a borrower\'s ranked preferences over books. * `available_books`: A list of boolean values indicating the availability of each book (True if available, False otherwise). Output * A list of integers where the ith index is the borrower and the value is the corresponding book they are matched with. If a borrower can\'t get any book from their preference list, return -1 for that borrower. Constraints * The number of borrowers and books might not be the same. * Each borrower\'s preference list will contain unique integers within the valid book indices. * Available books list will have True or False values only. # Example ```python def optimize_borrowing(borrower_pref: list[list[int]], available_books: list[bool]) -> list[int]: # Function body here # Example data borrower_pref = [[0, 1, 2], [2, 0, 1], [1, 2]] available_books = [True, False, True] result = optimize_borrowing(borrower_pref, available_books) print(result) # Should print a list such as [0, 2, -1] or other valid distribution ``` Performance Requirement * The solution must run in O(n*m) time complexity, where n is the number of borrowers and m is the number of books. # Note You need to ensure that the implemented function maximizes the number of borrowers who get a book from their preference list while ensuring efficiency in terms of time complexity.","solution":"def optimize_borrowing(borrower_pref, available_books): Optimize the borrowing so that maximum number of borrowers get a book from their preference list. Parameters: borrower_pref (list[list[int]]): List containing the book preferences of each borrower. available_books (list[bool]): List indicating the availability of each book. Returns: list[int]: List where the ith index is the borrower and the value is the corresponding book they are matched with. If a borrower can\'t get any book from their preference list, return -1 for that borrower. num_borrowers = len(borrower_pref) assignment = [-1] * num_borrowers for borrower, preferences in enumerate(borrower_pref): for book in preferences: if available_books[book]: assignment[borrower] = book available_books[book] = False break return assignment"},{"question":"# Binary Search Tree (BST) Level Order Traversal A Binary Search Tree (BST) is a node-based binary tree data structure where each node has at most two children referred to as the left child and the right child. For this question, you need to implement the function which performs a level-order traversal on a BST. A level-order traversal visits all nodes at the current level before moving on to the next level. Your task is to implement a function that returns the values of the nodes in level-order traversal. The input will be given as a list of integers that specifies the values of nodes inserted into the BST in the given order. Function Signature `def bst_level_order_traversal(values: List[int]) -> List[List[int]]:` Input - `values`: a list of integers (1 ≤ len(values) ≤ 10^5; -10^9 ≤ values[i] ≤ 10^9) representing the node values to be inserted into the BST, in the given order. Output - Returns a list of lists where each inner list contains the values of nodes at that level. Constraints - The function should efficiently handle large inputs up to 100,000 elements. # Example ```python >>> bst_level_order_traversal([10, 6, 15, 3, 8, 12, 18]) [[10], [6, 15], [3, 8, 12, 18]] >>> bst_level_order_traversal([7, 3, 9, 1, 4, 8, 10]) [[7], [3, 9], [1, 4, 8, 10]] >>> bst_level_order_traversal([1]) [[1]] >>> bst_level_order_traversal([]) [] ``` # Hints 1. Start by constructing the BST from the input list by defining a helper function to insert values. 2. Use a queue to accomplish the level-order traversal, where you process each level\'s nodes and enqueue their children.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: Optional[TreeNode], val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def bst_level_order_traversal(values: List[int]) -> List[List[int]]: if not values: return [] root = None for val in values: root = insert_into_bst(root, val) result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Scenario: You need to develop an algorithm that finds the majority element in a list of integers. A majority element is an element that appears more than half the time in the list. If no such element exists, the algorithm should return `None`. # Requirements: 1. Implement a function `find_majority_element` that takes a list of integers and returns the majority element or `None` if no majority element exists. 2. Your implementation should be efficient with a time complexity better than O(n^2). # Function Signature: ```python def find_majority_element(elements: list[int]) -> int | None: ``` # Input: - `elements`: A list of integers `elements` where `0 <= len(elements) <= 10^4`. # Output: - The majority element if it exists, otherwise `None`. # Constraints: - The majority element is the one that appears more than `len(elements) / 2` times. - If the list is empty, return `None`. # Example: ```python assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) == None assert find_majority_element([1]) == 1 assert find_majority_element([1, 1, 2, 2, 2, 2, 2]) == 2 assert find_majority_element([]) == None ``` # Hints: - Consider using the Boyer-Moore Voting Algorithm to achieve linear time complexity. - An alternative approach could involve using a hash map to count occurrences but this might increase space complexity. # Performance Requirements: - The expected time complexity should be O(n). - Space complexity should strive for O(1) if using Boyer-Moore Voting Algorithm, otherwise it may be O(n) if using additional data structures like a hash map.","solution":"def find_majority_element(elements: list[int]) -> int | None: Finds the majority element in a list of integers. A majority element is an element that appears more than half the time in the list. If no such element exists, returns None. Args: elements (list[int]): The list of integers. Returns: int | None: The majority element or None if no majority element exists. n = len(elements) if n == 0: return None # Boyer-Moore Voting Algorithm candidate = None count = 0 for element in elements: if count == 0: candidate = element count += (1 if element == candidate else -1) # Verify the candidate if elements.count(candidate) > n // 2: return candidate else: return None"},{"question":"# Reverse Words in a String **Background**: In natural language processing and communication systems, managing and manipulating text is a common requirement. Reversing the words in a string is a technique used in various applications, including data obfuscation, transformation, and certain text algorithms. **Task**: You are to implement two main functionalities involving string manipulation: reversing the words in a string and detecting if the reversed string matches a predetermined pattern. # Function Specifications 1. **Reversing Function (reverse_words)** - **Input**: - `sentence` (str): A string containing multiple words separated by spaces. - **Output**: - A string where the words in the input sentence are reversed in order but the characters within each word remain the same (e.g., if input is \\"hello world\\", output should be \\"world hello\\"). 2. **Pattern Matching Function (match_pattern)** - **Input**: - `sentence` (str): A string containing multiple words separated by spaces. - `pattern` (str): A string containing a word pattern to match against the reversed sentence. - **Output**: - Boolean value indicating whether the pattern matches the beginning of the reversed sentence (e.g., if reversed sentence is \\"world hello\\" and pattern is \\"world\\", output should be `True`). # Constraints - You may assume that input `sentence` will always be a valid string with words separated by single spaces and no leading or trailing spaces. - The `pattern` will always be a valid string with no spaces. - The length of `sentence` and `pattern` should be reasonable for typical text processing tasks. **Example**: ```python >>> reverse_words(\\"my name is python\\") \'python is name my\' >>> match_pattern(\\"python is great language\\", \\"great\\") False >>> match_pattern(\\"python is great language\\", \\"language\\") True ``` *For implementing these functionalities, you might find useful Python string methods such as `split()`, `join()`, and slice notation helpful for reversing word order.*","solution":"def reverse_words(sentence): Takes a string sentence containing multiple words and returns a string with the words in reverse order. Parameters: sentence (str): Input string with multiple words. Returns: str: A string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words) def match_pattern(sentence, pattern): Takes a string sentence and a string pattern, reverses the words in the sentence and checks if the beginning of the reversed sentence matches the pattern. Parameters: sentence (str): Input string with multiple words. pattern (str): A word pattern to match against reversed sentence. Returns: bool: True if pattern matches beginning of reversed sentence, False otherwise. reversed_sentence = reverse_words(sentence) return reversed_sentence.startswith(pattern)"},{"question":"# Question on Data Parsing and Summarization of Log Files Context Log files contain detailed information about various events that occur in software systems. Parsing and summarizing information from these logs is crucial for debugging, system monitoring, and performance analysis. Task Implement a function to parse log files and summarize specific events. Each log entry contains a timestamp, an event type, and a message. Your function should categorize events by their type and provide a summary of event counts and a list of unique messages per event type. Function Requirements 1. **Function Signature**: ```python def summarize_logs(log_file_path: str) -> tuple[dict, dict]: ``` 2. **Parameters**: * `log_file_path` (str): The path to the log file. Each line in the log file follows the format: `\\"[timestamp] [event_type] [message]\\"`. 3. **Return Values**: * `event_counts` (dict): A dictionary where keys are event types and values are the counts of each event type. * `unique_messages` (dict): A dictionary where keys are event types and values are sets of unique messages per event type. Constraints * The log file will always be present at the provided path and will be readable. * The timestamps are in the format `YYYY-MM-DD HH:MM:SS`. * Event types are single words with no spaces. * Messages can contain spaces and other characters. Performance Requirements Your solution should be efficient enough to handle large log files with potentially hundreds of thousands of entries. Example Consider a log file with the following content: ``` 2023-10-01 10:00:00 ERROR Failed to connect to database 2023-10-01 10:05:00 INFO User logged in 2023-10-01 10:10:00 ERROR Timeout occurred 2023-10-01 10:15:00 INFO User logged out 2023-10-01 10:20:00 INFO User logged in 2023-10-01 10:25:00 WARN Low disk space ``` After processing the log file, the function should return: ```python event_counts = { \\"ERROR\\": 2, \\"INFO\\": 3, \\"WARN\\": 1 } unique_messages = { \\"ERROR\\": {\\"Failed to connect to database\\", \\"Timeout occurred\\"}, \\"INFO\\": {\\"User logged in\\", \\"User logged out\\"}, \\"WARN\\": {\\"Low disk space\\"} } ``` Submit your implementation of the `summarize_logs` function below: ```python # Your code here ```","solution":"def summarize_logs(log_file_path: str) -> tuple[dict, dict]: event_counts = {} unique_messages = {} with open(log_file_path, \'r\') as file: for line in file: # Split the log entry parts = line.split(\' \', 2) timestamp = parts[0] + \' \' + parts[1] event_type = parts[2].strip().split(\' \', 1)[0] message = parts[2].strip().split(\' \', 1)[1] if \' \' in parts[2].strip() else \\"\\" # Update event counts if event_type in event_counts: event_counts[event_type] += 1 else: event_counts[event_type] = 1 # Update unique messages if event_type in unique_messages: unique_messages[event_type].add(message) else: unique_messages[event_type] = {message} return event_counts, unique_messages"},{"question":"**Developing a Custom Sort Algorithm for Optimized Item Retrieval** You are working on a retail application that requires frequent retrieval and display of items based on various priority rules. Currently, items are fetched from a database and displayed in the order they are retrieved. To enhance user experience, the items need to be sorted based on a custom set of rules before being displayed. **Objective**: Design and implement a function that sorts items based on custom priority rules. The sorting should handle multiple criteria such as item popularity, price, and availability status. **Tasks**: 1. **Sorting Algorithm**: Implement a custom sorting algorithm that prioritizes items based on the following order: - Highly demanded items first (popularity). - Lower priced items next. - Available items before out-of-stock items. 2. **Edge Cases Handling**: Ensure edge cases such as all items having the same popularity, varying values of prices, and all items being out-of-stock are handled correctly. 3. **Efficiency**: Optimize your sorting algorithm to ensure it handles large datasets efficiently in terms of time and space complexity. 4. **Documentation**: Clearly document the sorting criteria and explain how the sorting works. Additionally, demonstrate the function with various sample inputs and expected outputs. **Input and Output**: * Input: List of items, where each item is represented as a dictionary containing \'name\', \'popularity\', \'price\', and \'availability\'. * Output: List of items sorted based on the custom priority rules. **Constraints**: * The function should support items having string names, integer popularities, float prices, and boolean availability statuses. * The sorting function must not alter the original list of items but rather return a new sorted list. * Ensure the solution scales well with a large number of items. Here is the template for the sorting function: ```python from typing import List, Dict def custom_sort_items(items: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Sort items based on custom priority rules. Parameters: - items: List[Dict[str, Any]]: A list of items, where each item is represented as a dictionary. Returns: - List[Dict[str, Any]]: A new list of items sorted based on the custom priority rules. # Define the sorting criteria sorted_items = sorted( items, key=lambda item: ( -item[\'popularity\'], # Higher popularity first item[\'price\'], # Lower price next not item[\'availability\'] # Available items before out-of-stock ) ) return sorted_items # Example usage if __name__ == \\"__main__\\": items = [ {\'name\': \'Item1\', \'popularity\': 150, \'price\': 29.99, \'availability\': True}, {\'name\': \'Item2\', \'popularity\': 300, \'price\': 19.99, \'availability\': False}, {\'name\': \'Item3\', \'popularity\': 150, \'price\': 9.99, \'availability\': True}, {\'name\': \'Item4\', \'popularity\': 300, \'price\': 39.99, \'availability\': True}, {\'name\': \'Item5\', \'popularity\': 100, \'price\': 49.99, \'availability\': False} ] sorted_items = custom_sort_items(items) for item in sorted_items: print(f\\"{item[\'name\']}: {item}\\") ``` This function should correctly sort the items based on the criteria and handle edge cases appropriately.","solution":"from typing import List, Dict, Any def custom_sort_items(items: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Sort items based on custom priority rules. Parameters: - items: List[Dict[str, Any]]: A list of items, where each item is represented as a dictionary. Returns: - List[Dict[str, Any]]: A new list of items sorted based on the custom priority rules. # Define the sorting criteria sorted_items = sorted( items, key=lambda item: ( -item[\'popularity\'], # Higher popularity first item[\'price\'], # Lower price next not item[\'availability\'] # Available items before out-of-stock ) ) return sorted_items # Example usage if __name__ == \\"__main__\\": items = [ {\'name\': \'Item1\', \'popularity\': 150, \'price\': 29.99, \'availability\': True}, {\'name\': \'Item2\', \'popularity\': 300, \'price\': 19.99, \'availability\': False}, {\'name\': \'Item3\', \'popularity\': 150, \'price\': 9.99, \'availability\': True}, {\'name\': \'Item4\', \'popularity\': 300, \'price\': 39.99, \'availability\': True}, {\'name\': \'Item5\', \'popularity\': 100, \'price\': 49.99, \'availability\': False} ] sorted_items = custom_sort_items(items) for item in sorted_items: print(f\\"{item[\'name\']}: {item}\\")"},{"question":"# Frequency of Characters in a String **Context**: In many natural language processing (NLP) tasks, it\'s important to understand the frequency of characters in a given string. This is fundamental in tasks like text analysis, compression algorithms, and cryptography. **Task**: Write a Python function `frequency_of_characters(text: str) -> dict[str, int]` that calculates the frequency of each character in the input string. **Function Specification**: * **Input**: - `text`: A `str` representing the input string. - If the input is not a valid `str`, raise a `ValueError` with the message \\"Input must be a string\\". * **Output**: - A dictionary where the keys are characters and the values are their respective counts in the input string. **Examples**: ```python >>> frequency_of_characters(\\"hello\\") {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} >>> frequency_of_characters(\\"test case\\") {\'t\': 2, \'e\': 2, \'s\': 2, \' \': 1, \'c\': 1, \'a\': 1} >>> frequency_of_characters(1234) Traceback (most recent call last): ValueError: Input must be a string ``` **Performance Requirements**: * Ensure your function handles edge cases, such as an empty string, appropriately. * Aim for an O(n) complexity where n is the length of the string, as you need to traverse the string once. Implement the function keeping these considerations in mind.","solution":"def frequency_of_characters(text): Returns a dictionary with the frequency of each character in the input string. Parameters: - text: str, the input string Returns: - dict[str, int]: a dictionary where keys are characters and values are their counts Raises: - ValueError: if the input is not a string if not isinstance(text, str): raise ValueError(\\"Input must be a string\\") frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Binary Tree Level Order Traversal **Context**: Binary Tree Level Order Traversal, also known as Breadth-First Search (BFS) for a tree, is a method to traverse a tree level by level from left to right. This technique is useful in scenarios like finding the shortest path in an unweighted tree, printing nodes in a certain order, or level-wise processing of tree elements. **Task**: Write a function that takes the root node of a binary tree and returns a list of lists, where each inner list contains the values of the nodes at that level of the tree. **Function Signature**: ```python def level_order_traversal(root: TreeNode) -> List[List[int]]: pass ``` **Input and Output**: * **Input**: * `root` - A TreeNode object representing the root node of a binary tree. * **Output**: * A list of lists, where each inner list contains integer values of nodes at the corresponding tree level. **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * The tree node values are integers in the range [-10^9, 10^9]. * The depth of the tree will not exceed 1000. **Example**: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Usage: # Given binary tree [3,9,20,null,null,15,7]: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) output = level_order_traversal(root) # Output: [[3], [9, 20], [15, 7]] print(output) ```","solution":"from typing import List, Optional # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.pop(0) level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Coding Question: Implement a Rate Limiter for an API Objective: Design and implement a rate limiter function for an API. The function should ensure that a given client does not exceed a specified number of requests in a given time window. If the limit is breached, the function should return an error indicating the rate limit has been exceeded. Requirements: * **Function Signature**: ```python def rate_limiter(client_id: str, max_requests: int, window: int) -> bool: ``` * **Input**: - `client_id`: A string that identifies the client making a request. - `max_requests`: An integer indicating the maximum number of requests allowed for the client within the specified time window. - `window`: An integer that represents the time window in seconds within which the requests are counted. * **Output**: - Return `True` if the request is allowed, or `False` if the rate limit has been exceeded. * **Constraints**: - Only requests made within the last `window` seconds should be counted. - Assume a high volume of requests from multiple clients. - Optimize for average time complexity. Scenario: You are tasked with implementing a rate limiter for an API to prevent abuse due to excessive requests. This feature is essential for ensuring fair usage of resources and maintaining stable service. Your implementation should be efficient and capable of handling requests from a large number of clients without significant performance degradation. Examples: 1. **Usage**: ```python # Allow a maximum of 5 requests per minute (60 seconds) limiter = rate_limiter(\\"client_1\\", 5, 60) print(limiter) # Expected: True (1st request) print(limiter) # Expected: True (2nd request) print(limiter) # Expected: True (3rd request) print(limiter) # Expected: True (4th request) print(limiter) # Expected: True (5th request) print(limiter) # Expected: False (6th request - exceeds limit) ``` 2. **Handling Multiple Clients**: ```python limiter_1 = rate_limiter(\\"client_a\\", 3, 30) limiter_2 = rate_limiter(\\"client_b\\", 3, 30) print(limiter_1) # Expected: True (1st request for client_a) print(limiter_1) # Expected: True (2nd request for client_a) print(limiter_1) # Expected: True (3rd request for client_a) print(limiter_1) # Expected: False (4th request for client_a - exceeds limit) print(limiter_2) # Expected: True (1st request for client_b) print(limiter_2) # Expected: True (2nd request for client_b) ``` 3. **Automatic Window Reset**: ```python import time limiter = rate_limiter(\\"client_2\\", 2, 10) print(limiter) # Expected: True (1st request) print(limiter) # Expected: True (2nd request) print(limiter) # Expected: False (3rd request - exceeds limit) time.sleep(11) print(limiter) # Expected: True (1st request after window reset) ``` Hints: * Use a data structure that efficiently handles timestamps and lookups to keep track of requests per client. * Ensure that the implementation can scale with the number of clients and requests. * Consider edge cases such as overlapping windows and high-frequency requests.","solution":"import time from collections import defaultdict, deque class RateLimiter: def __init__(self): self.requests = defaultdict(deque) def rate_limiter(self, client_id: str, max_requests: int, window: int) -> bool: current_time = time.time() if client_id not in self.requests: self.requests[client_id] = deque() client_requests = self.requests[client_id] # Remove outdated requests while client_requests and client_requests[0] < current_time - window: client_requests.popleft() if len(client_requests) < max_requests: client_requests.append(current_time) return True else: return False"},{"question":"**Context**: You are developing a software application that needs to store user preferences and settings. For this purpose, you have chosen to use a SQLite database. Your goal is to create functions to initialize the database, insert new user settings, and retrieve user settings. **Task**: Implement the following functions to manage user settings in a SQLite database: 1. Write a function `initialize_database` that creates a SQLite database and a table named `user_settings` with four columns: `user_id` (INTEGER), `preference_key` (TEXT), `preference_value` (TEXT), and `last_updated` (TEXT). 2. Implement an `insert_user_setting` function to insert a new user setting into the `user_settings` table. 3. Write a function called `retrieve_user_setting` to retrieve a user setting by `user_id` and `preference_key`. **Function Specifications**: 1. `initialize_database(db_name: str) -> None` - Creates a SQLite database with the given name. - Creates a table named `user_settings` with columns: `user_id`, `preference_key`, `preference_value`, and `last_updated`. - `user_id` should be the primary key. 2. `insert_user_setting(db_name: str, user_id: int, preference_key: str, preference_value: str, last_updated: str) -> None` - Inserts a user setting into the `user_settings` table. - If a setting with the same `user_id` and `preference_key` already exists, update its `preference_value` and `last_updated`. 3. `retrieve_user_setting(db_name: str, user_id: int, preference_key: str) -> str` - Retrieves the `preference_value` for the given `user_id` and `preference_key`. - Returns the `preference_value`. **Constraints**: - Use the `sqlite3` module for SQLite operations. **Example**: ```python def main(): initialize_database(\\"settings.db\\") insert_user_setting(\\"settings.db\\", 1, \\"theme\\", \\"dark\\", \\"2023-10-01\\") setting = retrieve_user_setting(\\"settings.db\\", 1, \\"theme\\") print(\\"User 1 theme setting:\\", setting) if __name__ == \\"__main__\\": main() ```","solution":"import sqlite3 def initialize_database(db_name: str) -> None: Creates a SQLite database with the given name and a table named `user_settings`. conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(\'\'\' CREATE TABLE IF NOT EXISTS user_settings ( user_id INTEGER, preference_key TEXT, preference_value TEXT, last_updated TEXT, PRIMARY KEY (user_id, preference_key) ) \'\'\') conn.commit() conn.close() def insert_user_setting(db_name: str, user_id: int, preference_key: str, preference_value: str, last_updated: str) -> None: Inserts a user setting into the `user_settings` table or updates it if it already exists. conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(\'\'\' INSERT INTO user_settings (user_id, preference_key, preference_value, last_updated) VALUES (?, ?, ?, ?) ON CONFLICT(user_id, preference_key) DO UPDATE SET preference_value=excluded.preference_value, last_updated=excluded.last_updated \'\'\', (user_id, preference_key, preference_value, last_updated)) conn.commit() conn.close() def retrieve_user_setting(db_name: str, user_id: int, preference_key: str) -> str: Retrieves the `preference_value` for the given `user_id` and `preference_key`. conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(\'\'\' SELECT preference_value FROM user_settings WHERE user_id = ? AND preference_key = ? \'\'\', (user_id, preference_key)) result = cursor.fetchone() conn.close() return result[0] if result else None"},{"question":"**Scenario**: A logistics company uses a tracking system to monitor the movement of packages within their network. To optimize delivery routes, they want to predict the next location of the package based on its current location and historical data of its movements. You are responsible for implementing a predictive model using the Hidden Markov Model (HMM) to determine the most likely sequence of future locations for a package given its current path. # Problem Statement You need to implement a function with the following specifications: # Function Signature ```python def predict_next_locations( current_location: str, states_space: list, transition_probabilities: dict, steps: int ) -> list: pass ``` # Input Format 1. **current_location (str)**: The current location of the package, as a string. 2. **states_space (list)**: A list of all possible locations (strings) the package can move through. 3. **transition_probabilities (dict)**: A nested dictionary where the outer keys are current locations, inner keys are next locations, and values are the probabilities of moving to the next location. 4. **steps (int)**: The number of future steps/locations to predict. # Output Format **Returns (list)**: A list of predicted future locations. # Constraints - All probabilities provided are valid (i.e., between 0 and 1) and sum to 1 where applicable. - The states_space list contains only string elements. - The dictionary transition_probabilities must be well-formed with correct keys and value types. - The number of steps will be a positive integer. # Performance Requirements - Your function should handle cases where the number of states (locations) and steps can be large efficiently. # Examples ```python # Example 1 current_loc = \\"Warehouse\\" states = [\\"Warehouse\\", \\"Hub\\", \\"OutForDelivery\\", \\"Delivered\\"] trans_p = { \\"Warehouse\\": {\\"Warehouse\\": 0.1, \\"Hub\\": 0.7, \\"OutForDelivery\\": 0.2, \\"Delivered\\": 0.0}, \\"Hub\\": {\\"Warehouse\\": 0.2, \\"Hub\\": 0.3, \\"OutForDelivery\\": 0.4, \\"Delivered\\": 0.1}, \\"OutForDelivery\\": {\\"Warehouse\\": 0.1, \\"Hub\\": 0.1, \\"OutForDelivery\\": 0.3, \\"Delivered\\": 0.5}, \\"Delivered\\": {\\"Warehouse\\": 0.0, \\"Hub\\": 0.0, \\"OutForDelivery\\": 0.0, \\"Delivered\\": 1.0} } steps = 3 # Expected output might be [\\"Hub\\", \\"OutForDelivery\\", \\"Delivered\\"] print(predict_next_locations(current_loc, states, trans_p, steps)) # Example 2 current_loc = \\"Start\\" states = [\\"Start\\", \\"Middle\\", \\"End\\"] trans_p = { \\"Start\\": {\\"Start\\": 0.0, \\"Middle\\": 1.0, \\"End\\": 0.0}, \\"Middle\\": {\\"Start\\": 0.0, \\"Middle\\": 0.5, \\"End\\": 0.5}, \\"End\\": {\\"Start\\": 0.0, \\"Middle\\": 0.0, \\"End\\": 1.0} } steps = 2 # Expected output might be [\\"Middle\\", \\"End\\"] print(predict_next_locations(current_loc, states, trans_p, steps)) ``` You are required to implement the given function according to the above specifications, ensuring to handle all edge cases and input constraints properly.","solution":"def predict_next_locations( current_location: str, states_space: list, transition_probabilities: dict, steps: int ) -> list: Predicts the next locations for a package based on the current location, states space, transition probabilities, and number of steps. Args: - current_location (str): The current location of the package. - states_space (list): A list of all possible locations. - transition_probabilities (dict): A dictionary where keys are current locations and values are dictionaries for next locations with probabilities. - steps (int): The number of future steps/locations to predict. Returns: - list: A list of predicted future locations. import random def get_next_location(current_loc): next_locations = list(transition_probabilities[current_loc].keys()) probabilities = list(transition_probabilities[current_loc].values()) next_location = random.choices(next_locations, probabilities)[0] return next_location predicted_locations = [] for _ in range(steps): next_location = get_next_location(current_location) predicted_locations.append(next_location) current_location = next_location return predicted_locations"},{"question":"# Reverse Words in a String Problem Statement You are required to implement a function that reverses the order of words in a given string. The function should maintain the initial order of letters within each word and remove any additional spaces at the beginning and end, also ensuring that words are separated by a single space in the output. Function Signature ```python def reverse_words(s: str) -> str: ``` Input - `s` (str) : a sentence, where the length of `s` is 1 <= len(s) <= 10^6. Punctuation marks are part of the words and must be kept in the same order. Output - A string with the words reversed and custom spaces trimmed. Constraints - No leading or trailing spaces should be present in the output. - Words in the output should be separated by a single space. Examples ```python >>> reverse_words(\\"the sky is blue\\") \'blue is sky the\' >>> reverse_words(\\" hello world! \\") \'world! hello\' >>> reverse_words(\\"a good example\\") \'example good a\' >>> reverse_words(\\" Bob Loves Alice \\") \'Alice Loves Bob\' >>> reverse_words(\\" Alice does not even like bob \\") \'bob like even not does Alice\' ``` Additional Notes You may use Python\'s built-in string methods to split and join words effectively. However, ensure that the function appropriately handles all edge cases related to spaces within the input string.","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the given string `s`. Args: - s (str): The input string Returns: - str: The string with words reversed and extra spaces removed # Split the string into words based on whitespace words = s.split() # Reverse the order of words reversed_words = words[::-1] # Join the reversed words with a single space result = \\" \\".join(reversed_words) return result"},{"question":"# Problem Statement You are given a binary tree represented as a list of tuples where each tuple contains three values: the current node value, the left child value, and the right child value. The tree is uniquely identified, meaning no two nodes have the same value. Write a function `zigzag_traversal` that returns the zigzag level order traversal of the binary tree\'s nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). # Input Format - A list of tuples where each tuple contains three integers `(node_value, left_child_value, right_child_value)`. If a node does not have a left or right child, those values will be represented by `None`. # Output Format - A list of lists where each inner list corresponds to the node values at each level of the binary tree, following the zigzag order. # Constraints - The list will contain at least one tuple representing the root node. - Node values are unique integers. - The total number of nodes will not exceed 1000. # Performance Requirements - Time Complexity: O(N), where N is the number of nodes. - Space Complexity: O(N), where N is the number of nodes. # Function Signature ```python def zigzag_traversal(tree: list[tuple[int, int, int | None]]) -> list[list[int]]: pass ``` # Example ```python assert zigzag_traversal([ (1, 2, 3), (2, 4, 5), (3, 6, 7), (4, None, None), (5, None, None), (6, None, None), (7, None, None) ]) == [[1], [3, 2], [4, 5, 6, 7]] assert zigzag_traversal([ (1, 2, None), (2, 3, 4), (3, None, None), (4, 5, None), (5, None, None) ]) == [[1], [2], [4, 3], [5]] ``` Write your implementation of `zigzag_traversal` by considering different tree structures, such as a fully balanced tree, a single-sided tree, or an unbalanced tree, to ensure comprehensive functionality.","solution":"def zigzag_traversal(tree): if not tree: return [] from collections import deque, defaultdict # Create a mapping of node values to their children children = {} for node, left, right in tree: children[node] = (left, right) # Initialize BFS parameters result = [] queue = deque([1]) # assuming the root node is always `1` left_to_right = True while queue: level_size = len(queue) current_level = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: current_level.append(node) else: current_level.appendleft(node) left, right = children.get(node, (None, None)) if left: queue.append(left) if right: queue.append(right) result.append(list(current_level)) left_to_right = not left_to_right return result"},{"question":"# Problem: Counting Atoms in a Chemical Formula You are assigned the task of implementing a function that parses a given chemical formula and counts the number of each type of atom. This problem challenges your ability to handle strings and nested structures effectively. Function Signature ```python def count_atoms(formula: str) -> dict: Parses the given chemical formula and counts the number of each type of atom. Args: formula (str): A string representing the chemical formula. Returns: dict: A dictionary with atomic symbols as keys and their quantities as values. pass ``` Input: * **formula (str)**: A string representing the chemical formula, where `1 <= len(formula) <= 1000`. Output: * Returns a dictionary with atomic symbols as keys and their quantities as values. Constraints: * The formula consists of atomic symbols starting with an uppercase letter followed by zero or more lowercase letters. * Atomic symbols may follow an integer indicating the count of that atom; if no integer follows, the count is 1. * Parentheses `()` are used to group parts of the formula, and may be followed by an integer indicating the count for the entire group. * The formula is valid and does not contain invalid characters. Context: Imagine you are developing a chemistry software that helps in parsing complex chemical formulas into their respective components. This task is essential for further computations and analysis in the field of chemistry. Examples: ```python >>> count_atoms(\\"H2O\\") {\'H\': 2, \'O\': 1} >>> count_atoms(\\"Mg(OH)2\\") {\'Mg\': 1, \'O\': 2, \'H\': 2} >>> count_atoms(\\"K4[ON(SO3)2]2\\") {\'K\': 4, \'O\': 14, \'N\': 2, \'S\': 4} ``` Notes: * Use a stack to manage the nesting of parentheses. * Ensure the function handles nested parentheses correctly and multiplies the counts accordingly. * The function should be efficient enough to handle long formulas within the given length constraint. This problem helps in improving string manipulation skills and working with nested data structures in Python.","solution":"import re from collections import defaultdict def count_atoms(formula: str) -> dict: def parse(): stack = [defaultdict(int)] i, n = 0, len(formula) while i < n: if formula[i] == \'(\' or formula[i] == \'[\': stack.append(defaultdict(int)) i += 1 elif formula[i] == \')\' or formula[i] == \']\': top = stack.pop() i += 1 i_start = i while i < n and formula[i].isdigit(): i += 1 multiply = int(formula[i_start:i] or 1) for element in top: stack[-1][element] += top[element] * multiply else: i_start = i i += 1 while i < n and formula[i].islower(): i += 1 element = formula[i_start:i] i_start = i while i < n and formula[i].isdigit(): i += 1 count = int(formula[i_start:i] or 1) stack[-1][element] += count return stack.pop() return dict(parse())"},{"question":"# Coding Assessment Question **Scenario**: You are developing a task management system that needs to efficiently manage and query tasks based on their priority and execution time. Each task has a priority and an execution duration associated with it. You need to perform frequent updates to the tasks as well as execute queries to find tasks with the highest or lowest priority over a given range. To facilitate this, you decide to implement a collection of tasks as a balanced binary search tree (BST), where tasks are primarily sorted by their priority. You will also need to handle updates and range queries efficiently. **Task**: Implement a class `TaskManager` that supports dynamic management of tasks using a self-balancing binary search tree (e.g., AVL Tree, Red-Black Tree). **Requirements**: 1. **Initialization**: - Provide a class `TaskManager` that initializes with a list of tasks. Each task is represented as a tuple (priority, duration). 2. **Add Task**: - Implement an `add_task` method to insert a new task into the collection. 3. **Remove Task**: - Implement a `remove_task` method to remove an existing task by priority. 4. **Range Queries**: - Implement a `query_range` method that returns the task with the highest or lowest priority within a specified priority range. # Function Details - **Class**: `TaskManager` - **Constructor**: - `__init__(self, tasks: List[Tuple[int, int]]) -> None` - Initializes the task manager using the provided list of tasks. - **Methods**: - `add_task(self, priority: int, duration: int) -> None` - Inserts a new task with the specified priority and duration. - `remove_task(self, priority: int) -> None` - Removes the task with the specified priority. - `query_range(self, low: int, high: int, maximize: bool) -> Tuple[int, int]` - Returns the task with the highest (if maximize is True) or lowest (if maximize is False) priority within the range [low, high]. **Constraints**: - Initial number of tasks `N` where `0 <= N <= 10^4`. - Priority values and duration values range within `0` to `10^6`. - Support efficient insertions, deletions, and range queries. # Input Format: - The initial task list followed by multiple task operations. - Example: `tasks = [(3, 5), (1, 7), (4, 2)]` - Operations example: - `add_task(2, 6)` should add a new task with priority 2 and duration 6. - `remove_task(1)` should remove the task with priority 1. - `query_range(1, 4, True)` should return the task with the highest priority within range 1 to 4. # Output Format: - For each `query_range` operation, output the task (priority, duration). # Example: ```python tasks = [(3, 5), (1, 7), (4, 2)] tm = TaskManager(tasks) tm.add_task(2, 6) tm.remove_task(1) print(tm.query_range(1, 4, True)) # Output: (3, 5) print(tm.query_range(1, 4, False)) # Output: (2, 6) ```","solution":"class TaskManager: class Node: def __init__(self, priority, duration): self.priority = priority self.duration = duration self.left = None self.right = None self.height = 1 def __init__(self, tasks): self.root = None for priority, duration in tasks: self.root = self._insert(self.root, priority, duration) def _get_height(self, node): if not node: return 0 return node.height def _update_height(self, node): if not node: return node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) def _balance_factor(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self._update_height(y) self._update_height(x) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self._update_height(x) self._update_height(y) return y def _rebalance(self, node): self._update_height(node) balance = self._balance_factor(node) if balance > 1: if self._balance_factor(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._balance_factor(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _insert(self, node, priority, duration): if not node: return self.Node(priority, duration) elif priority < node.priority: node.left = self._insert(node.left, priority, duration) else: node.right = self._insert(node.right, priority, duration) node = self._rebalance(node) return node def add_task(self, priority, duration): self.root = self._insert(self.root, priority, duration) def _min_value_node(self, node): if node is None or node.left is None: return node return self._min_value_node(node.left) def _delete(self, node, priority): if not node: return node elif priority < node.priority: node.left = self._delete(node.left, priority) elif priority > node.priority: node.right = self._delete(node.right, priority) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.priority = temp.priority node.duration = temp.duration node.right = self._delete(node.right, temp.priority) if not node: return node node = self._rebalance(node) return node def remove_task(self, priority): self.root = self._delete(self.root, priority) def _query_range(self, node, low, high, maximize): if not node: return None if node.priority < low: return self._query_range(node.right, low, high, maximize) if node.priority > high: return self._query_range(node.left, low, high, maximize) left_result = self._query_range(node.left, low, high, maximize) right_result = self._query_range(node.right, low, high, maximize) best = node if left_result is not None and ((maximize and left_result.priority > best.priority) or (not maximize and left_result.priority < best.priority)): best = left_result if right_result is not None and ((maximize and right_result.priority > best.priority) or (not maximize and right_result.priority < best.priority)): best = right_result return best def query_range(self, low, high, maximize): result = self._query_range(self.root, low, high, maximize) if result: return (result.priority, result.duration) return None"},{"question":"# Compute the Area of Intersection of Two Rectangles Write a function `rectangle_intersection_area()` that calculates the area of intersection between two rectangles. Each rectangle is defined by its bottom-left and top-right coordinates. Function Signature ```python def rectangle_intersection_area(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> int: ``` Input * `rect1` (Tuple[int, int, int, int]): A tuple of four integers representing the bottom-left (x1, y1) and top-right (x2, y2) coordinates of the first rectangle. * `rect2` (Tuple[int, int, int, int]): A tuple of four integers representing the bottom-left (x3, y3) and top-right (x4, y4) coordinates of the second rectangle. Output * `int`: The area of intersection of the two rectangles. If they do not intersect, return `0`. Constraints * Rectangles are axis-aligned (their sides are parallel to the coordinate axes). * The coordinates are such that ( x1 < x2 ) and ( y1 < y2 ) for `rect1`, and ( x3 < x4 ) and ( y3 < y4 ) for `rect2`. * The coordinates will be within the range ([-10^4, 10^4]). Example ```python rect1 = (1, 1, 3, 3) rect2 = (2, 2, 4, 4) # Expected Output: 1 print(rectangle_intersection_area(rect1, rect2)) # 1 ``` Scenario Calculating the intersection area between two rectangles is a common problem in computer graphics and geographical information systems (GIS). For instance, map applications use this calculation to determine overlapping areas when rendering different map layers. **Hint**: To find the intersection area, you need to calculate the overlapping width and height: * Overlapping width is min(x2, x4) - max(x1, x3) * Overlapping height is min(y2, y4) - max(y1, y3) If either width or height is negative or zero, it means there is no intersection.","solution":"from typing import Tuple def rectangle_intersection_area(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> int: Calculate the area of intersection between two rectangles. rect1: (x1, y1, x2, y2) rect2: (x3, y3, x4, y4) # Unpacking the bottom-left and top-right coordinates of both rectangles x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Calculate the overlapping width and height overlap_width = min(x2, x4) - max(x1, x3) overlap_height = min(y2, y4) - max(y1, y3) # If there is no overlap, return 0 if overlap_width <= 0 or overlap_height <= 0: return 0 # Calculate and return the area of the intersection return overlap_width * overlap_height"},{"question":"# Question: You are tasked with implementing a function to simulate a banking system that processes transactions. Your task is to create a function `process_transactions` which takes a list of transactions and an initial account balance as input and returns the final balance. **Function Signature**: ```python def process_transactions(transactions: List[Tuple[str, float]], balance: float) -> float: # Implement the function ``` # Requirements: 1. **Input Format**: - `transactions`: A list of tuples where each tuple represents a transaction. Each tuple contains a string and a float, where the string indicates the type of transaction (`\\"DEPOSIT\\"` or `\\"WITHDRAWAL\\"`) and the float indicates the amount. - `balance`: A float representing the initial account balance. 2. **Output Format**: - A float representing the final account balance after processing all transactions. # Constraints: - The length of `transactions` will be in the range `0` to `10^6`. - The amounts in the transactions are non-negative floats. - The initial balance is a non-negative float. - A withdrawal transaction that would result in a negative balance should not be processed. # Performance Requirements: - The algorithm should run efficiently even for large input sizes, adhering to the given complexity constraints. # Example: ```python transactions = [(\\"DEPOSIT\\", 100.0), (\\"WITHDRAWAL\\", 50.0), (\\"DEPOSIT\\", 25.0)] initial_balance = 100.0 final_balance = process_transactions(transactions, initial_balance) print(final_balance) # Output: 175.0 ``` # Function Behavior: 1. Iterate over the transactions list and process each transaction based on its type. 2. If the transaction is a `\\"DEPOSIT\\"`, add the amount to the balance. 3. If the transaction is a `\\"WITHDRAWAL\\"`, subtract the amount from the balance only if the resulting balance is non-negative. 4. Return the final balance after processing all transactions. # Additional Notes: - Ensure to handle edge cases like an empty list of transactions. - The function must not allow the balance to go negative. # Hints: * Consider using efficient list iteration techniques to handle large inputs. * Implement necessary guards to prevent invalid state changes in the balance.","solution":"from typing import List, Tuple def process_transactions(transactions: List[Tuple[str, float]], balance: float) -> float: Process a list of transactions and return the final account balance. Args: transactions (List[Tuple[str, float]]): List of transactions, each a tuple of (type, amount). balance (float): Initial account balance. Returns: float: Final account balance after processing the transactions. for transaction in transactions: type_, amount = transaction if type_ == \\"DEPOSIT\\": balance += amount elif type_ == \\"WITHDRAWAL\\" and balance >= amount: balance -= amount return balance"},{"question":"# Coding Assessment Question **Problem Statement:** You are tasked with writing a function that finds the fixed point in a list of integers if it exists. A fixed point in a list is an index (i) such that (arr[i] = i). Your function should return the fixed point if it is present in the list, otherwise, return -1. The function should validate the input to ensure it is a list of integers. If the input is not a list or any element in the list is not an integer, the function should raise a `TypeError` with the message \\"Input must be a list of integers\\". **Function Signature:** ```python def find_fixed_point(arr: list) -> int: pass ``` # Input: - `arr`: A list of integers where each integer can be positive, negative, or zero. # Output: - Returns an integer representing the fixed point if it exists, otherwise -1. # Constraints: - The length of the input list will be between 0 and 10^4. # Example Usage: ```python print(find_fixed_point([-10, -5, 0, 3, 7])) # Output: 3 print(find_fixed_point([0, 2, 5, 8, 17])) # Output: 0 print(find_fixed_point([-10, -5, 3, 4, 7])) # Output: -1 ``` # Edge Cases: - If the input list is empty, the function should return -1. - If no fixed point exists in the list, the function should return -1. - If the input is not a list or any element is not an integer, the function should raise a `TypeError`. **Test Cases:** 1. `find_fixed_point([1, 2, 3, 4, 5])` should return `-1`. 2. `find_fixed_point([0, 1, 2, 3, 4])` should return `0`. 3. `find_fixed_point([-1, 0, 1, 2, 4])` should return `4`. 4. `find_fixed_point([])` should return `-1`. 5. `find_fixed_point(-1)` should raise `TypeError`.","solution":"def find_fixed_point(arr: list) -> int: Find the fixed point in a list where arr[i] == i. :param arr: List of integers. :return: The fixed point if it exists, otherwise -1. :raises TypeError: If the input is not a list or if the list contains non-integer elements. if not isinstance(arr, list): raise TypeError(\\"Input must be a list of integers\\") for element in arr: if not isinstance(element, int): raise TypeError(\\"Input must be a list of integers\\") for i in range(len(arr)): if arr[i] == i: return i return -1"},{"question":"# Enhancing Data Filtering and Statistical Analysis You are working on a project that involves analyzing datasets of student performance across various metrics. Your task is to filter the dataset based on specific criteria and then compute statistical measures for further analysis. # Requirements: 1. **Function Definition**: Implement a function `filter_and_analyze_grades(students: list, min_grade: float, subject: str) -> dict` that: - **Parameters**: - `students`: List of dictionaries, where each dictionary represents a student\'s data. - `min_grade`: Minimum grade threshold to filter students. - `subject`: Key representing the subject for which the grade filtering and analysis should be performed. - **Returns**: - A dictionary containing the following statistics for the students who meet the grade threshold: - `filtered_count`: Number of students who meet the grade threshold. - `filtered_average`: Average grade of the filtered students. - `filtered_min`: Minimum grade among the filtered students. - `filtered_max`: Maximum grade among the filtered students. 2. **Input**: - Each student dictionary contains keys like `student_id`, `name`, and other subjects\' keys with grades (0 to 100). - Subjects can include \'Math\', \'Science\', \'English\', etc. 3. **Output**: - A dictionary of computed statistics for the filtered list of students based on the grade threshold. 4. **Constraints**: - Ensure that the function handles cases where no students meet the grade threshold. - Validate input to ensure subject keys exist in the student data dictionaries. - Efficiently process large datasets with potentially thousands of student records. ```python # Define your function here def filter_and_analyze_grades(students: list, min_grade: float, subject: str) -> dict: Filter students based on a minimum grade threshold and compute statistical measures of filtered students\' grades. Parameters: - students <type: list>: List of student data dictionaries. - min_grade <type: float>: Minimum grade threshold for filtering. - subject <type: str>: Subject key for which the filtering and analysis should be performed. Returns: - <type: dict>: Dictionary of statistics of filtered grades including \'filtered_count\', \'filtered_average\', \'filtered_min\', \'filtered_max\'. pass # Implementation here ``` # Scenario: You are part of a data analytics team working on evaluating student performance metrics for an educational program. One of the tasks at hand is filtering out students who do not meet a specific grade requirement in a particular subject and then computing some statistical measures for the remaining students. This information is vital for generating reports and making data-driven decisions based on student performance trends. Use the provided function template to implement the solution. Your function will be integrated into a larger analytics system that continuously processes and evaluates student data.","solution":"def filter_and_analyze_grades(students: list, min_grade: float, subject: str) -> dict: Filter students based on a minimum grade threshold and compute statistical measures of filtered students\' grades. Parameters: - students <type: list>: List of student data dictionaries. - min_grade <type: float>: Minimum grade threshold for filtering. - subject <type: str>: Subject key for which the filtering and analysis should be performed. Returns: - <type: dict>: Dictionary of statistics of filtered grades including \'filtered_count\', \'filtered_average\', \'filtered_min\', \'filtered_max\'. filtered_grades = [student[subject] for student in students if student.get(subject) is not None and student[subject] >= min_grade] if not filtered_grades: return {\'filtered_count\': 0, \'filtered_average\': 0, \'filtered_min\': 0, \'filtered_max\': 0} filtered_count = len(filtered_grades) filtered_average = sum(filtered_grades) / filtered_count filtered_min = min(filtered_grades) filtered_max = max(filtered_grades) return { \'filtered_count\': filtered_count, \'filtered_average\': filtered_average, \'filtered_min\': filtered_min, \'filtered_max\': filtered_max }"},{"question":"# Transitive Closure of a Graph Objective Implement a function to determine the transitive closure of a given directed graph using the Floyd-Warshall algorithm. Function Signature ```python def transitive_closure(graph: List[List[int]]) -> List[List[int]]: pass ``` Input - `graph`: A 2D list representing the adjacency matrix of a directed graph, where `graph[i][j]` is `1` if there is a direct edge from vertex `i` to vertex `j`, and `0` otherwise. The matrix is guaranteed to be square with `V` rows and `V` columns. Output - A 2D list (adjacency matrix) representing the transitive closure of the graph where `result[i][j]` is `1` if there is a path from vertex `i` to vertex `j`, and `0` otherwise. Constraints - The number of vertices (`V`) is (1 leq V leq 500). Example ```python # Given the adjacency matrix representation of the graph: graph = [ [0, 1, 0], [0, 0, 1], [0, 0, 0] ] # The expected output is the transitive closure of the graph: # There is a path from 0 to 1, from 1 to 2, and thus from 0 to 2. expected_output = [ [0, 1, 1], [0, 0, 1], [0, 0, 0] ] print(transitive_closure(graph)) # Output: [[0, 1, 1], [0, 0, 1], [0, 0, 0]] ``` Notes - The Floyd-Warshall algorithm has a time complexity of (O(V^3)), which should be efficient enough for the given constraint. - Ensure to test edge cases such as graphs with no edges, self-loops, and fully connected graphs.","solution":"def transitive_closure(graph): Determine the transitive closure of a given directed graph using the Floyd-Warshall algorithm. Args: graph (list of list of int): Adjacency matrix representing the graph. Returns: list of list of int: Adjacency matrix representing the transitive closure of the graph. V = len(graph) # Initialize the transitive closure matrix closure = [[graph[i][j] for j in range(V)] for i in range(V)] # Apply Floyd-Warshall algorithm to find transitive closure for k in range(V): for i in range(V): for j in range(V): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"# Question: Recursive Fibonacci Sequence Calculation You are tasked with implementing a function to calculate the `n`-th Fibonacci number using recursion. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Function Specifications: 1. **Function Name:** `recursive_fibonacci` 2. **Functionality:** Recursively calculates and returns the `n`-th Fibonacci number. 3. **Input:** - `n` (int): The position in the Fibonacci sequence (0-indexed) for which the Fibonacci number is to be calculated. Must be a non-negative integer. 4. **Output:** Returns the `n`-th Fibonacci number as an integer. 5. **Constraint:** The input `n` must be a non-negative integer. Example: ```python # Calculate the 0-th Fibonacci number print(recursive_fibonacci(0)) # Output: 0 # Calculate the 1st Fibonacci number print(recursive_fibonacci(1)) # Output: 1 # Calculate the 5th Fibonacci number print(recursive_fibonacci(5)) # Output: 5 # Calculate the 10th Fibonacci number print(recursive_fibonacci(10)) # Output: 55 ``` Detailed Requirements: - Ensure the function raises a `ValueError` if `n` is a negative integer. - Use a recursive approach to solve the problem. - Write adequate tests to validate your implementation, including edge and error cases. Hint: Utilize the base cases provided and ensure your recursion follows the mathematical definition of the Fibonacci sequence.","solution":"def recursive_fibonacci(n): Recursively calculates the n-th Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0-indexed). Must be a non-negative integer. Returns: int: The n-th Fibonacci number. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2)"},{"question":"# Context In the realm of distributed computing, effective utilization of resources through optimal task scheduling is crucial. You are introduced to the concept of job scheduling on multiple machines where each job has a specific processing time and deadline. # Task Your objective is to implement a class to manage jobs and their scheduling on multiple machines such that the total tardiness (sum of delays beyond job deadlines) is minimized. # Function Implementation 1. Implement operations for the `Job` class which should include properties: processing time, deadline, start time, and machine assigned. 2. Ensure a method to calculate job tardiness is available. 3. Implement the `JobScheduler` class to manage multiple jobs and machine schedules while minimizing total tardiness. # Function Specification and Implementation Requirements * **Class 1: Job** * **Constructor**: `__init__(self, processing_time: int, deadline: int)` * **Properties**: * `self.processing_time` * `self.deadline` * `self.start_time` (initialized to None) * `self.machine` (initialized to None, indicating unassigned) * **Method**: * `calculate_tardiness(self) -> int` - Calculate tardiness based on `start_time` and `deadline`. * `assign_to_machine(self, machine_id: int, start_time: int)` * **Class 2: JobScheduler** * Ensure scheduling manages jobs on multiple machines. * Implement methods: * `schedule_job(self, job: Job) -> None` - Assign job to the next available machine with minimal tardiness. * `total_tardiness(self) -> int` - Calculate the total tardiness for all jobs. * `_find_next_available_time(self, machine_id: int) -> int` - Helper method to find the next available start time on a machine. # Constraints and Limitations * There are a maximum of 10 machines. * The `Job` processing time and deadline are positive integers. * Jobs are non-preemptive and must run to completion once started. # Example ```python scheduler = JobScheduler() jobs = [Job(3, 10), Job(1, 8), Job(4, 7), Job(2, 5)] for job in jobs: scheduler.schedule_job(job) assert scheduler.total_tardiness() == <calculated_tardiness> ``` The `JobScheduler` will effectively distribute jobs across machines to minimize the total tardiness.","solution":"class Job: def __init__(self, processing_time, deadline): self.processing_time = processing_time self.deadline = deadline self.start_time = None self.machine = None def calculate_tardiness(self): if self.start_time is None: return 0 completion_time = self.start_time + self.processing_time return max(0, completion_time - self.deadline) def assign_to_machine(self, machine_id, start_time): self.machine = machine_id self.start_time = start_time class JobScheduler: def __init__(self): self.machines = [[] for _ in range(10)] # Assume 10 machines self.jobs = [] def _find_next_available_time(self, machine_id): # Machines are initialized as an empty list of jobs if not self.machines[machine_id]: return 0 last_job = self.machines[machine_id][-1] return last_job.start_time + last_job.processing_time def schedule_job(self, job): # Find the machine with the earliest available time best_machine = None best_start_time = None best_tardiness = float(\'inf\') for machine_id in range(10): start_time = self._find_next_available_time(machine_id) job.assign_to_machine(machine_id, start_time) tardiness = job.calculate_tardiness() if tardiness < best_tardiness: best_machine = machine_id best_start_time = start_time best_tardiness = tardiness # Assign the job to the best machine job.assign_to_machine(best_machine, best_start_time) self.machines[best_machine].append(job) self.jobs.append(job) def total_tardiness(self): return sum(job.calculate_tardiness() for job in self.jobs)"},{"question":"# Problem Statement You are developing a part of a library management system and need to create a function that checks if a given book title is already present in the library\'s catalog. If the title is not present, it should be added. Write a function `add_book(catalog: List[str], title: str) -> Tuple[bool, List[str]]` that takes a list of strings `catalog` representing the existing book titles in the library and a string `title` representing the new book title to add. The function should return a tuple where the first element is a boolean indicating whether the title was added (`True` if it was added, `False` if it was already present) and the second element is the updated catalog list. # Input - A list of strings `catalog` where each string is a book title already present in the library. The list can be empty. - A string `title` which is the new book title to add to the catalog. # Output - A tuple `(added: bool, updated_catalog: List[str])` where `added` is `True` if the title was added to the catalog, `False` otherwise, and `updated_catalog` is the updated list of book titles in the library. # Constraints - The length of `catalog` will not exceed 10^3. - Each title in `catalog` and `title` will not exceed 100 characters and will consist of alphanumeric characters and spaces. - Title comparison should be case insensitive. # Example - `add_book([\\"A Tale of Two Cities\\", \\"The Great Gatsby\\"], \\"1984\\")` should return `(True, [\\"A Tale of Two Cities\\", \\"The Great Gatsby\\", \\"1984\\"])`. - `add_book([\\"A Tale of Two Cities\\", \\"The Great Gatsby\\"], \\"a tale of two cities\\")` should return `(False, [\\"A Tale of Two Cities\\", \\"The Great Gatsby\\"])`. # Implementation Note Ensure that your implementation correctly handles case insensitive comparisons when checking for the presence of a title in the catalog.","solution":"from typing import List, Tuple def add_book(catalog: List[str], title: str) -> Tuple[bool, List[str]]: Checks if a given book title is already present in the library\'s catalog. If the title is not present, it is added. Args: catalog (List[str]): A list of strings representing the existing book titles in the library. title (str): A new book title to add to the catalog. Returns: Tuple[bool, List[str]]: A tuple where the first element is a boolean indicating whether the title was added (True if it was added, False if it was already present) and the second element is the updated catalog list. lower_catalog = [t.lower() for t in catalog] lower_title = title.lower() if lower_title in lower_catalog: return False, catalog else: return True, catalog + [title]"},{"question":"# Question: Implement a Simplified Bookstore Inventory System In this exercise, you are to implement a Python class that simulates basic functionalities of a bookstore inventory management system. Your class should be able to add new books, sell books, and check current inventory. Class Definition ```python class Bookstore: ``` Methods 1. `__init__(self)`: Initializes an empty inventory. 2. `add_book(self, title: str, author: str, isbn: str, quantity: int, price: float) -> None`: - Adds a book to the inventory with the given title, author, ISBN, quantity, and price. - If the book already exists (identified by ISBN), increase the quantity accordingly. 3. `sell_book(self, isbn: str, quantity: int) -> float`: - Sells a specified quantity of a book identified by its ISBN. - If the book doesn\'t exist or there isn\'t enough quantity, raise an appropriate error. - Return the total price of the sold books. 4. `check_inventory(self) -> dict`: - Returns the current inventory as a dictionary where the keys are ISBNs and the values are dictionaries with `title`, `author`, `quantity`, and `price`. Constraints * All input strings (title, author, ISBN) are non-empty. * Quantity and price are non-negative. * A book\'s ISBN is unique. Requirements * The class should handle adding new books and selling existing ones robustly. * The inventory check should accurately reflect the current state of the bookstore. * Raise appropriate errors for invalid operations such as selling non-existent books or insufficient stock. # Example Usage ```python store = Bookstore() store.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\", 10, 15.99) store.add_book(\\"1984\\", \\"George Orwell\\", \\"2345678901\\", 5, 12.49) print(store.check_inventory()) # Should show both books with their details earnings = store.sell_book(\\"1234567890\\", 2) print(earnings) # Should print 31.98 print(store.check_inventory()) # Should reflect the reduced quantity of \\"The Great Gatsby\\" ```","solution":"class Bookstore: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, isbn: str, quantity: int, price: float) -> None: if isbn in self.inventory: self.inventory[isbn][\'quantity\'] += quantity else: self.inventory[isbn] = { \'title\': title, \'author\': author, \'quantity\': quantity, \'price\': price } def sell_book(self, isbn: str, quantity: int) -> float: if isbn not in self.inventory: raise ValueError(f\\"Book with ISBN {isbn} does not exist in the inventory.\\") if self.inventory[isbn][\'quantity\'] < quantity: raise ValueError(f\\"Not enough stock of book with ISBN {isbn} to sell {quantity} copies.\\") self.inventory[isbn][\'quantity\'] -= quantity total_price = self.inventory[isbn][\'price\'] * quantity return total_price def check_inventory(self) -> dict: return self.inventory"},{"question":"# Background You are working with strings consisting of alphabetical characters and spaces. Each string can have multiple words, and the words can be mixed between uppercase and lowercase letters. Your task is to normalize these strings by changing all characters to lowercase and removing any extra spaces, ensuring that there is only one space between words and no leading or trailing spaces. # Problem Write a function `normalize_text` that takes a string as input and returns a new string that is normalized according to the rules above. # Function Signature ```python def normalize_text(text: str) -> str: pass ``` # Input * `text` (str): A string containing words and spaces. The string may have leading, trailing, or multiple consecutive spaces. # Output * Returns a string that is a normalized version of the input text, with all letters in lowercase and a single space separating each word. # Example ```python normalize_text(\\" Hello World \\") # Returns \\"hello world\\" normalize_text(\\"This is a Test String\\") # Returns \\"this is a test string\\" ``` # Constraints * The input string length will not exceed 10,000 characters. * The input string will only contain alphabetical characters and spaces. # Additional Notes * You may use Python\'s built-in functions and methods to manipulate strings. * Consider edge cases such as strings with only spaces or empty strings.","solution":"def normalize_text(text: str) -> str: Normalize the string by changing all characters to lowercase, removing extra spaces, and ensuring a single space between words. return \' \'.join(text.lower().split())"},{"question":"# Context A company is developing an application to monitor and analyze weather data. They need to summarize historical temperature data from multiple cities to detect trends and anomalies. Your task is to implement a simulation that processes the temperature data for multiple cities, calculates basic statistics, and generates a summary report. # Requirements 1. Implement a function to process temperature records and calculate statistics. 2. Calculate the mean, median, variance, min, and max temperatures for each city. 3. Generate a summary report of the statistics for each city. # Input/Output 1. **Function**: `process_temperature_data(data)` - **Arguments**: - `data`: Dictionary where keys are city names and values are lists of temperature readings. `{\'City1\': [temp1, temp2, ...], \'City2\': [temp1, temp2, ...], ...}`. - **Returns**: Dictionary where keys are city names and values are dictionaries containing calculated statistics (`{\'City1\': {\'mean\': value, \'median\': value, \'variance\': value, \'min\': value, \'max\': value}, ...}`). # Constraints - Each city has at least one temperature reading. - All temperature readings are integer values. - Assume data is already cleaned and no missing or invalid temperatures exist. # Example ```python data = { \'New York\': [22, 21, 25, 26, 24], \'Los Angeles\': [16, 17, 15, 14, 18], \'Chicago\': [10, 8, 12, 11, 9] } summary_report = process_temperature_data(data) print(summary_report) # Output: # { # \'New York\': {\'mean\': 23.6, \'median\': 24, \'variance\': 3.2, \'min\': 21, \'max\': 26}, # \'Los Angeles\': {\'mean\': 16, \'median\': 16, \'variance\': 2.5, \'min\': 14, \'max\': 18}, # \'Chicago\': {\'mean\': 10, \'median\': 10, \'variance\': 2.5, \'min\': 8, \'max\': 12} # } ``` # Criteria - Correct calculation of mean, median, variance, min, and max temperatures. - Proper handling of the input data structure. - Efficient and accurate implementation of statistical calculations.","solution":"from statistics import mean, median, variance def process_temperature_data(data): Processes the temperature data for multiple cities and calculates statistics. Args: data (dict): Dictionary with city names as keys and lists of temperature readings as values. Returns: dict: Dictionary with city names as keys and dictionaries of statistics as values. statistics = {} for city, temps in data.items(): city_stats = { \'mean\': mean(temps), \'median\': median(temps), \'variance\': variance(temps) if len(temps) > 1 else 0.0, # variance requires at least two data points \'min\': min(temps), \'max\': max(temps), } statistics[city] = city_stats return statistics"},{"question":"# Context You are working on a data processing application that frequently involves parsing and extracting information from strings containing various forms of whitespace and special characters. To assist with this task, you need to write a utility function that sanitizes these strings by removing all leading and trailing whitespace as well as any specified special characters. # Task Write a function `sanitize_string(input_string: str, special_chars: str) -> str` that removes all leading and trailing whitespace and specified special characters from the `input_string`. # Specifications 1. **Input Format**: * A string `input_string` which may contain any characters. * A string `special_chars` which specifies the special characters to be removed, e.g., `\\"#@\\"`. 2. **Output Format**: * A string with all leading and trailing whitespace and special characters removed. # Constraints * The `input_string` can have a maximum length of 2000. * The `special_chars` can have a maximum length of 20. * If the `input_string` is empty, the function should return an empty string. # Performance Requirements * The solution should efficiently handle the maximum input size within a reasonable time frame. # Examples * `sanitize_string(\' hello world! \', \'!\')` should return `\'hello world\'` * `sanitize_string(\'@@goodbye\', \'@#\')` should return `\'goodbye\'` * `sanitize_string(\'***Python***\', \'*\')` should return `\'Python\'` * `sanitize_string(\' \', \' \')` should return an empty string `\'\'` * `sanitize_string(\'\', \'@\')` should return an empty string `\'\'` # Additional Notes * The function should strictly handle removing the exact characters specified in `special_chars` and should not alter the original sequence inside the main string except for trimming the undesired characters.","solution":"def sanitize_string(input_string: str, special_chars: str) -> str: Removes all leading and trailing whitespace and specified special characters from the input_string. if not input_string: return \\"\\" # Create a set of characters to be removed remove_chars = set(special_chars) # Remove leading characters start = 0 while start < len(input_string) and (input_string[start] in remove_chars or input_string[start].isspace()): start += 1 # Remove trailing characters end = len(input_string) - 1 while end >= 0 and (input_string[end] in remove_chars or input_string[end].isspace()): end -= 1 # Extract the cleaned string if start <= end: return input_string[start:end+1] else: return \\"\\""},{"question":"**Context:** You have been tasked with implementing a system that can take an input string and determine if the string is an anagram of a palindrome. An anagram is a rearrangement of the characters in the original string. A palindrome is a string that reads the same forward and backward. **Objective:** Write a program that checks if any permutation of a given string can form a palindrome. This is useful in the context of various text-processing and cryptographic applications where understanding string permutations is crucial. **Task:** Create a function `is_anagram_of_palindrome(input_string: str) -> bool` that takes a single string and returns a boolean indicating whether any permutation of the string can be rearranged to form a palindrome. # Expected Input and Output: * **Input**: - `input_string`: A single string containing lowercase and uppercase letters. The length of the string will be up to 100,000 characters. * **Output**: - A boolean value `True` if any permutation of the input string can form a palindrome. `False` otherwise. # Constraints: - Your implementation should efficiently handle strings of up to 100,000 characters in length, with considerations for both time and space complexity. **Example:** ```python input_string = \\"civic\\" assert is_anagram_of_palindrome(input_string) == True input_string = \\"ivicc\\" assert is_anagram_of_palindrome(input_string) == True input_string = \\"hello\\" assert is_anagram_of_palindrome(input_string) == False input_string = \\"Aab\\" assert is_anagram_of_palindrome(input_string) == True ``` # Notes: - The solution should be case-insensitive, meaning \\"A\\" and \\"a\\" are considered the same character. - Ignore spaces, punctuation, and any non-letter characters in the input string.","solution":"def is_anagram_of_palindrome(input_string: str) -> bool: from collections import Counter import re # Clean the input: ignore non-letter characters and convert to lowercase cleaned_string = re.sub(r\'[^a-zA-Z]\', \'\', input_string).lower() # Count the frequency of each character char_count = Counter(cleaned_string) # To form a palindrome, at most one character can have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Coding Challenge: Building a Custom Queue Context As a software engineer working on a priority task scheduling system, it is crucial to have a robust and efficient queue data structure. Your current implementation uses a list, but the system faces performance issues under heavy load. To resolve this, you decide to implement a custom queue using a doubly linked list. Task Write a class `CustomQueue` that implements a queue using a doubly linked list. Your queue should support the following operations: - `enqueue(value)`: Adds an element to the back of the queue. - `dequeue()`: Removes an element from the front of the queue and returns it. - `peek()`: Returns the front element without removing it. - `is_empty()`: Checks if the queue is empty. Additionally, implement a helper class `Node` to represent elements of the doubly linked list. Class Definitions ```python class Node: def __init__(self, value: int): self.value = value self.next = None self.prev = None class CustomQueue: def __init__(self): self.head = None self.tail = None def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def peek(self) -> int: pass def is_empty(self) -> bool: pass ``` Input * `enqueue` method takes an integer `value`. * No inputs are required for `dequeue`, `peek`, and `is_empty` methods. Output * `enqueue` does not return anything. * `dequeue` returns an integer which is the front element of the queue. * `peek` returns an integer which is the front element of the queue without removing it. * `is_empty` returns a boolean indicating whether the queue is empty. Constraints * The elements in the queue will be integers in the range [-10^5, 10^5]. * There will be no attempts to dequeue from an empty queue. Example ```python queue = CustomQueue() print(queue.is_empty()) # Output: True queue.enqueue(5) queue.enqueue(10) print(queue.peek()) # Output: 5 print(queue.dequeue()) # Output: 5 print(queue.dequeue()) # Output: 10 print(queue.is_empty()) # Output: True ``` Notes * Ensure that your queue maintains the correct order of elements as elements are enqueued and dequeued. * Handle edge cases such as dequeuing from an empty queue gracefully (though the input constraints state this won\'t occur, your code should not break if it does).","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None self.prev = None class CustomQueue: def __init__(self): self.head = None self.tail = None def enqueue(self, value: int) -> None: new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def dequeue(self) -> int: if self.head is None: raise IndexError(\\"Dequeue from empty queue\\") value = self.head.value self.head = self.head.next if self.head is None: self.tail = None else: self.head.prev = None return value def peek(self) -> int: if self.head is None: raise IndexError(\\"Peek from empty queue\\") return self.head.value def is_empty(self) -> bool: return self.head is None"},{"question":"# Checking a Binary Tree Symmetry Problem Statement: Given the root of a binary tree, check whether the tree is a mirror of itself (i.e., symmetric around its center). Function Signature: ```python def is_symmetric(root: \'TreeNode\') -> bool: ``` Input: * **root**: The root node of the binary tree. Each node is represented as a `TreeNode` object with the following attributes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: * Returns `True` if the tree is symmetric, otherwise returns `False`. Example: ```python # Example 1: # Input: # 1 # / # 2 2 # / / # 3 4 4 3 root = TreeNode(1) root.left = TreeNode(2, TreeNode(3), TreeNode(4)) root.right = TreeNode(2, TreeNode(4), TreeNode(3)) expected_output = True assert is_symmetric(root) == expected_output # Example 2: # Input: # 1 # / # 2 2 # # 3 3 root = TreeNode(1) root.left = TreeNode(2, right=TreeNode(3)) root.right = TreeNode(2, right=TreeNode(3)) expected_output = False assert is_symmetric(root) == expected_output ``` Instructions: 1. **Define Helper Function**: Create a helper function `is_mirror` which checks if two trees are mirror images of each other: ```python def is_mirror(left: \'TreeNode\', right: \'TreeNode\') -> bool: # If both nodes are None, they are mirrors if left is None and right is None: return True # If only one of the nodes is None, they are not mirrors if left is None or right is None: return False # Check if the current nodes are equal and the subtrees are mirrors return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) ``` 2. **Check Symmetry**: Call the `is_mirror` function with the left and right children of the root: ```python def is_symmetric(root: \'TreeNode\') -> bool: if root is None: return True return is_mirror(root.left, root.right) ``` Hints: * Two trees are a mirror reflection of each other if they have equal root values, their left subtree is a mirror reflection of the right subtree, and their right subtree is a mirror reflection of the left subtree. * Handle edge cases where the tree is empty, i.e., `root` is `None`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_mirror(left: \'TreeNode\', right: \'TreeNode\') -> bool: # If both nodes are None, they are mirrors if left is None and right is None: return True # If only one of the nodes is None, they are not mirrors if left is None or right is None: return False # Check if the current nodes are equal and the subtrees are mirrors return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) def is_symmetric(root: \'TreeNode\') -> bool: if root is None: return True return is_mirror(root.left, root.right)"},{"question":"# AVL Tree Implementation and Range Sum Query You are to implement an AVL Tree and perform a range sum query. AVL Trees are self-balancing binary search trees that maintain height balance for efficient querying. Task 1: AVL Tree Construction Write a function, `insert(root: AVLNode, key: int) -> AVLNode`, that inserts a new key into the AVL Tree and ensures the tree remains balanced. Task 2: Range Sum Query Additionally, implement a function, `range_sum(root: AVLNode, low: int, high: int) -> int`, that computes the sum of keys within a given range `[low, high]` in the AVL Tree. Input: 1. A list of `n` integer keys, `keys: list[int]`. 2. A range defined by two integers, `low: int` and `high: int`. Output: 1. The sum of all keys within the specified range `[low, high]`. Example: ```python # Given keys keys = [20, 4, 15, 10, 22, 18, 80] # Range for summation low, high = 10, 22 # Construct the AVL Tree root = None for key in keys: root = insert(root, key) # Compute the range sum total = range_sum(root, low, high) # Output: The sum of keys within the range, e.g., 20 + 15 + 10 + 18 + 22 = 85 ``` Constraints: - The number of keys `n` will be such that `1 ≤ n ≤ 1000`. Performance Requirements: - Ensure that the insert operation maintains the tree\'s balance, resulting in `O(log n)` time complexity for insertion. - The range sum query should operate efficiently, ideally in `O(log n + m)` time complexity where `m` is the number of keys in the range.","solution":"class AVLNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None def get_height(node): if not node: return 0 return node.height def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def right_rotate(y): x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def left_rotate(x): y = x.right T2 = y.left y.left = x x.right = T2 update_height(x) update_height(y) return y def insert(root, key): if not root: return AVLNode(key) elif key < root.key: root.left = insert(root.left, key) else: root.right = insert(root.right, key) update_height(root) balance = get_balance(root) if balance > 1 and key < root.left.key: return right_rotate(root) if balance < -1 and key > root.right.key: return left_rotate(root) if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root def range_sum(root, low, high): if not root: return 0 if root.key < low: return range_sum(root.right, low, high) elif root.key > high: return range_sum(root.left, low, high) else: return root.key + range_sum(root.left, low, high) + range_sum(root.right, low, high)"},{"question":"# Question: Determine the Smallest Prime Factor Write a function `smallest_prime_factor` that calculates the smallest prime factor of a given integer greater than 1. The function should return the smallest prime number that divides the given integer exactly. # Function Signature ```python def smallest_prime_factor(n: int) -> int: ``` # Input Parameters - `n` (int): A positive integer greater than 1. # Output - Returns an integer representing the smallest prime factor of `n`. # Constraints - `n` > 1 # Example ```python >>> smallest_prime_factor(15) 3 >>> smallest_prime_factor(29) 29 >>> smallest_prime_factor(60) 2 ``` # Notes - If the input integer `n` is a prime number, the function should return `n` itself because a prime number\'s smallest prime factor is the number itself. - Ensure that the function handles larger numbers efficiently by implementing an optimized algorithm. # Hints - Consider using the trial division method for finding the smallest prime factor. - You only need to check up to the square root of `n` for factors other than 2, reducing the number of iterations significantly. # Test Cases ```python # Edge cases and small numbers assert smallest_prime_factor(2) == 2 assert smallest_prime_factor(9) == 3 # Medium-sized numbers assert smallest_prime_factor(49) == 7 assert smallest_prime_factor(101) == 101 # Larger number assert smallest_prime_factor(1000) == 2 ``` By following the above question format and structure, the new question integrates seamlessly with the existing set while introducing a unique problem related to prime factorization in number theory.","solution":"def smallest_prime_factor(n: int) -> int: Returns the smallest prime factor of a given integer n greater than 1. if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") # Check divisibility by 2 if n % 2 == 0: return 2 # Check divisibility by odd numbers starting from 3 factor = 3 max_factor = int(n ** 0.5) + 1 while factor <= max_factor: if n % factor == 0: return factor factor += 2 # If no factor found, n must be prime return n"},{"question":"# Question: Missing Number in Arithmetic Progression Problem Statement You are given a list of numbers that is supposed to represent an arithmetic progression (AP) except that exactly one number is missing from it. Your task is to find the missing number. An arithmetic progression is a sequence of numbers in which the difference between any two consecutive numbers is the same. Input: * A list of integers `arr` of length ( n ) (( 3 leq n leq 10^5 )), which represents an almost complete AP with one element missing. Output: * An integer representing the missing number in the AP. Constraints: * The input list will always contain integers. * The list will have at least 3 elements and contain exactly one missing number. Examples: ```python def find_missing_number(arr: List[int]) -> int: pass # Test Cases print(find_missing_number([2, 4, 6, 10])) # Output: 8 print(find_missing_number([1, 3, 7, 9])) # Output: 5 print(find_missing_number([5, 10, 15, 25])) # Output: 20 print(find_missing_number([10, 20, 30, 50])) # Output: 40 ``` Explanation: 1. For the first example, the AP should be (2, 4, 6, 8, 10). The missing number is (8). 2. For the second example, the AP should be (1, 3, 5, 7, 9). The missing number is (5). # Implementation Hints: * Calculate the expected common difference ((d)) of the AP. * Iterate through the list to identify where the gap occurs and determine the missing number. * Keep in mind that the given list is sorted in ascending order.","solution":"def find_missing_number(arr): Finds the missing number in the arithmetic progression. n = len(arr) total_sum = (n + 1) * (arr[0] + arr[-1]) // 2 actual_sum = sum(arr) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Problem Statement A major shipping company needs to optimize delivery routes to minimize travel distance. The company uses a basic algorithm to determine the shortest path between multiple delivery points. Your task is to implement a simplified version of this algorithm using a weighted graph to find the minimum distance from a starting point to all other points. # Requirements 1. **Function Signature**: ```python def shortest_delivery_route(n: int, edges: list[tuple[int, int, int]], start: int) -> list[int]: ``` - **Input**: * `n`: An integer representing the number of delivery points (nodes). * `edges`: A list of tuples, each containing three integers (u, v, w) representing a directed edge from point `u` to point `v` with weight `w` (distance between the points). * `start`: An integer representing the starting delivery point. - **Output**: * Return a list of integers where the i-th element is the minimum distance from the start point to point `i`. If a point is unreachable from the start, the distance should be represented as -1. # Details 1. Implement Dijkstra\'s algorithm to determine the shortest path from the starting point to all other points. 2. Use a priority queue or a min-heap to optimize the algorithm\'s performance. # Example ```python def test_shortest_delivery_route(): assert shortest_delivery_route(5, [(0, 1, 10), (0, 4, 3), (1, 2, 2), (4, 1, 1), (4, 2, 8), (4, 3, 2), (2, 3, 7), (3, 2, 4)], 0) == [0, 4, 6, 5, 3] assert shortest_delivery_route(3, [(0, 1, 4), (1, 2, 1), (2, 0, 6)], 0) == [0, 4, 5] assert shortest_delivery_route(4, [(0, 1, 1), (0, 2, 4), (1, 2, 2), (2, 3, 1)], 1) == [-1, 0, 2, 3] if __name__ == \\"__main__\\": test_shortest_delivery_route() ``` # Constraints and Performance Requirements 1. Assume 1 <= n <= 500. 2. Assume 0 <= u, v < n. 3. Assume 1 <= w <= 1000. 4. Assume there are no negative weights in the graph. 5. Your solution should be efficient in terms of both time and space complexity. Ensure your implementation handles edge cases appropriately and maintains optimal performance for larger graphs.","solution":"import heapq def shortest_delivery_route(n: int, edges: list[tuple[int, int, int]], start: int) -> list[int]: Computes the shortest delivery route from the start point to all other points in the graph. Parameters: n (int): Number of nodes (delivery points). edges (list of tuples): Each tuple (u, v, w) representing a directed edge from point u to point v with weight (distance) w. start (int): The starting delivery point. Returns: list[int]: List where the i-th element is the minimum distance from start point to point i. If a point is unreachable, the distance should be -1. graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((w, v)) distances = [float(\'inf\')] * n distances[start] = 0 pq = [(0, start)] # Priority queue to store (distance, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > distances[u]: continue for weight, v in graph[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return [d if d != float(\'inf\') else -1 for d in distances]"},{"question":"# Coding Assessment Question Scenario/Context Efficiently finding subarrays within an array is a common problem in computer science, intersecting areas such as data structures, algorithms, and optimization techniques. This problem will assess your ability to manipulate arrays and apply algorithmic thinking to solve specific array-based challenges. Problem Statement Write a function `max_contiguous_subarray_sum(arr: List[int]) -> int` that returns the maximum sum of any contiguous subarray within the given array `arr`. # Function Signature `def max_contiguous_subarray_sum(arr: List[int]) -> int:` # Input * `arr` (List[int]): A list of integers, representing the array. # Output * Returns an integer, the maximum sum of any contiguous subarray within the input array `arr`. # Constraints * `1 <= len(arr) <= 10^5` * `-100 <= arr[i] <= 100`, where `arr[i]` is any element in the array. # Example ```python >>> max_contiguous_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_contiguous_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_contiguous_subarray_sum([5, 4, -1, 7, 8]) 23 ``` # Explanation 1. For the input `arr = [1, -3, 2, 1, -1]`; the maximum sum of any contiguous subarray is 3, from subarray `[2, 1]`. 2. For the input `arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`; the maximum sum of any contiguous subarray is 6, from subarray `[4, -1, 2, 1]`. 3. For the input `arr = [5, 4, -1, 7, 8]`; the maximum sum of any contiguous subarray is 23, from subarray `[5, 4, -1, 7, 8]`. # Additional Points - Consider edge cases such as arrays with all negative numbers, which will require choosing the largest (or least negative) single element. - Efficient algorithm behavior is crucial due to potential large input size, consider using Kadane\'s Algorithm for optimal performance. --- This question aligns with the given sample by focusing on array manipulation and algorithmic problem-solving, maintaining the complexity and style required.","solution":"from typing import List def max_contiguous_subarray_sum(arr: List[int]) -> int: max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Coding Question: Bitwise AND Sum of Arrays You are given two lists of integers, `list1` and `list2`. Each list contains at least one positive integer. For each pair of integers (i, j) where `i` is from `list1` and `j` is from `list2`, compute the bitwise AND of these integers. Your task is to return the sum of all such bitwise AND computations. Function Signature ```python def bitwise_and_sum(list1: list[int], list2: list[int]) -> int: pass ``` Input * `list1` (list of int): A list of positive integers. * `list2` (list of int): A list of positive integers. Output * Returns an integer, the sum of all bitwise AND computations between pairs of integers from `list1` and `list2`. Constraints * Both `list1` and `list2` should contain at least one positive integer. * The length of each list does not exceed 1000. Example ```python assert bitwise_and_sum([1, 2], [3, 4]) == 9 # Pairs: (1 & 3), (1 & 4), (2 & 3), (2 & 4). Computations: 1 & 3 = 1, 1 & 4 = 0, 2 & 3 = 2, 2 & 4 = 0. Sum = 1 + 0 + 2 + 0 = 3. assert bitwise_and_sum([5], [1, 2, 3]) == 0 # Pairs: (5 & 1), (5 & 2), (5 & 3). Computations: 5 & 1 = 1, 5 & 2 = 0, 5 & 3 = 1. Sum = 1 + 0 + 1 = 2. ``` Notes * Ensure your function performs efficiently, especially for large inputs. * Handle edge cases, such as lists containing only one element or lists with very large numbers, gracefully.","solution":"def bitwise_and_sum(list1: list[int], list2: list[int]) -> int: Returns the sum of all bitwise AND computations between pairs of integers from list1 and list2. total_sum = 0 for i in list1: for j in list2: total_sum += i & j return total_sum"},{"question":"Merge Sort Implementation Merge Sort is a classic divide-and-conquer algorithm that efficiently sorts a list of elements by recursively dividing the list into smaller sublists, sorting those sublists, and then merging them back together. # Problem Statement You are required to implement the Merge Sort algorithm to sort a list of integers in ascending order. # Input * A list `arr` of `n` integers. # Output * Return a new list that contains all the elements of `arr` sorted in ascending order. # Constraints * The elements of the list can be any type that supports comparison operators. * The list `arr` can be of size `0 <= len(arr) <= 10^6`. * Be prepared to handle both positive and negative integers. # Example: ```python >>> merge_sort([4, 5, 6, 7]) [4, 5, 6, 7] >>> merge_sort([4, 5, 6, 7, -10]) [-10, 4, 5, 6, 7] >>> merge_sort([]) [] >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Task Implement the `merge_sort` function as described.","solution":"def merge_sort(arr): Performs merge sort on the provided list of integers. Args: arr (list): The list of integers to sort. Returns: list: A new list containing the sorted integers. if len(arr) <= 1: return arr def merge(left, right): sorted_array = [] while left and right: if left[0] <= right[0]: sorted_array.append(left.pop(0)) else: sorted_array.append(right.pop(0)) sorted_array.extend(left) sorted_array.extend(right) return sorted_array mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Problem Scenario You are working on a project that involves image processing. One task is to create an algorithm that detects edges in an image. You will use the Sobel operator, a popular edge detection technique that computes the gradient of the image intensity at each point. # Task: Implement a class `SobelEdgeDetector` that detects edges in a grayscale image using the Sobel operator. # Key Requirements: 1. Initialize an edge detector for a given image. 2. Compute the magnitude of the gradient at each point using the Sobel operator. 3. Produce the edge-detected image. # Specifications: 1. **Class**: `SobelEdgeDetector` 2. **Methods**: * `__init__(self, image: list[list[int]])`: Initializes the edge detector with a given grayscale image represented as a 2D list of integers. * `detect_edges(self) -> list[list[int]]`: Applies the Sobel operator to detect edges and returns the edge-detected image as a 2D list of integers. 3. **Input/Output**: * The `__init__` method takes a single parameter `image`, which is a 2D list of integers representing the pixel intensities of the grayscale image. * The `detect_edges` method returns a 2D list of integers representing the edge-detected image. # Constraints: * The image is represented as a 2D list with `N` rows and `M` columns, where `1 <= N, M <= 1000`. * Each element in the image is an integer in the range `[0, 255]`. # Example: ```python # Example Usage image = [ [100, 100, 100, 100], [100, 0, 0, 100], [100, 0, 0, 100], [100, 100, 100, 100] ] detector = SobelEdgeDetector(image) edges = detector.detect_edges() # edges should be similar to: # [[0, 255, 255, 0], # [255, 0, 0, 255], # [255, 0, 0, 255], # [0, 255, 255, 0]] ``` # Notes: * The Sobel operator uses two 3x3 convolution kernels, one for detecting the horizontal gradient (Gx) and one for detecting the vertical gradient (Gy): ``` Gx: [-1, 0, 1] [-2, 0, 2] [-1, 0, 1] Gy: [-1, -2, -1] [ 0, 0, 0] [ 1, 2, 1] ``` * The magnitude of the gradient at a point is computed as: `sqrt(Gx^2 + Gy^2)`. * Take care of the image boundaries where the Sobel kernels can\'t be applied completely. * You may use any standard image processing library for efficient computation, if needed.","solution":"import numpy as np class SobelEdgeDetector: def __init__(self, image): Initializes the edge detector with a given grayscale image represented as a 2D list of integers. self.image = np.array(image, dtype=np.int32) def detect_edges(self): Applies the Sobel operator to detect edges and returns the edge-detected image as a 2D list of integers. Gx_kernel = np.array([ [-1, 0, 1], [-2, 0, 2], [-1, 0, 1] ]) Gy_kernel = np.array([ [-1, -2, -1], [ 0, 0, 0], [ 1, 2, 1] ]) rows, cols = self.image.shape edge_image = np.zeros((rows, cols), dtype=np.int32) for i in range(1, rows - 1): for j in range(1, cols - 1): gx = np.sum(Gx_kernel * self.image[i - 1:i + 2, j - 1:j + 2]) gy = np.sum(Gy_kernel * self.image[i - 1:i + 2, j - 1:j + 2]) edge_magnitude = min(int(np.sqrt(gx**2 + gy**2)), 255) edge_image[i, j] = edge_magnitude return edge_image.tolist()"},{"question":"# Question: Implement a Function to Find the Longest Common Prefix You are tasked with implementing a function that finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. This is a common problem often encountered in text processing and bioinformatics. # Function Signature ```python def longest_common_prefix(strs: List[str]) -> str: pass ``` # Input - `strs`: A list of strings `List[str]` where each string contains only lowercase alphabets (1 ≤ len(strs[i]) ≤ 200). # Output - A string representing the longest common prefix. # Constraints - 1 ≤ len(strs) ≤ 200. - Strings consist of only lowercase English letters. # Examples 1. **Input**: `[\\"flower\\", \\"flow\\", \\"flight\\"]` - **Output**: `\\"fl\\"` 2. **Input**: `[\\"dog\\", \\"racecar\\", \\"car\\"]` - **Output**: `\\"\\"` 3. **Input**: `[\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]` - **Output**: `\\"inters\\"` # Sample Test ```python assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" ``` # Hint Consider the most efficient way to compare the prefix of strings. A common approach is to use binary search or carefully iterate through the strings to find the common prefix without excessive comparisons.","solution":"def longest_common_prefix(strs): Returns the longest common prefix of an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Start by assuming the longest common prefix is the first string prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] if not prefix: break return prefix"},{"question":"# Question: Encode and Decode Information You are required to implement a class that can encode a list of strings into a single string and then decode that string back into the original list of strings. The encoded string should be in a format that ensures no information is lost and can be uniquely decrypted to get the original list. Write a class `Codec` with the following methods: 1. `encode(self, strs: List[str]) -> str`: This method takes a list of strings and returns a single encoded string. 2. `decode(self, s: str) -> List[str]`: This method takes an encoded string and returns the original list of strings. The encoding and decoding process should handle any characters, including escape sequences and special characters that might be present in the strings. **Class Signature:** ```python class Codec: def encode(self, strs: List[str]) -> str: pass def decode(self, s: str) -> List[str]: pass ``` # Input: - `strs` (List[str]): A list of strings to be encoded. - `s` (str): The encoded string to be decoded. # Output: - For `encode`: A single string that encodes the given list of strings. - For `decode`: A list of strings that was originally encoded. # Examples: ```python codec = Codec() # Encoding example strs = [\\"hello\\", \\"world\\"] encoded_string = codec.encode(strs) print(encoded_string) # \\"hello#world#\\" # Decoding example decoded_list = codec.decode(encoded_string) print(decoded_list) # [\\"hello\\", \\"world\\"] ``` **Explanation:** - For encoding the list `[\\"hello\\", \\"world\\"]`, the output could be `\\"hello#world#\\"` (or any method you choose that ensures the encoded string can be uniquely decoded back to the original list). - For decoding the string `\\"hello#world#\\"`, the output list should be `[\\"hello\\", \\"world\\"]`. Ensure that your implementation is robust, handles edge cases, and can encode and decode strings with special characters and escape sequences correctly. Python should be assumed as the programming language to implement the solution.","solution":"class Codec: def encode(self, strs): Encodes a list of strings to a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(self, s): Decodes a single string back to a list of strings. res = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 size = int(s[i:j]) res.append(s[j+1:j+1+size]) i = j+1+size return res"},{"question":"# Inventory Management System Optimization You are responsible for maintaining the backend of an inventory management system used by a large retail store. Recently, there have been issues with performance, particularly in the function that updates inventory levels after processing bulk sales transactions. Your task is to optimize this function to ensure it runs efficiently even with large datasets. **Function Signature:** ```python def update_inventory_levels(inventory: dict[str, int], transactions: list[tuple[str, int]]) -> None: ``` # Requirements: 1. The function should efficiently update the inventory based on a list of sales transactions. 2. Each transaction is represented as a tuple containing the product ID (a string) and the quantity sold (an integer). 3. The inventory is represented as a dictionary where keys are the product IDs and values are the current stock levels. 4. The function should handle large numbers of transactions and ensure that the inventory dictionary is updated accurately. 5. Implement efficient data handling to ensure the function runs optimally even with a large number of products and transactions. # Input: - `inventory`: A dictionary with product IDs as keys and current stock levels as values. - `transactions`: A list of tuples where each tuple contains a product ID and a quantity sold. # Output: - The function should update the inventory dictionary in place, reducing the stock levels based on the transactions list. It does not return a value. # Constraints: - Ensure that the function handles edge cases like negative or zero quantities and non-existent product IDs in the inventory. - The function should be designed for performance, aiming for O(n) complexity where possible. # Example: Assume the following input: ```python inventory = { \\"product_001\\": 50, \\"product_002\\": 30, \\"product_003\\": 100 } transactions = [ (\\"product_001\\", 5), (\\"product_002\\", 3), (\\"product_003\\", 10), (\\"product_004\\", 2), (\\"product_001\\", 1) ] ``` After calling the function `update_inventory_levels(inventory, transactions)`, the `inventory` dictionary should be updated as follows: ```python inventory = { \\"product_001\\": 44, # 50 - 5 - 1 \\"product_002\\": 27, # 30 - 3 \\"product_003\\": 90, # 100 - 10 \\"product_004\\": -2 # Edge case: Product ID not initially in inventory, added with negative quantity } ``` # Implementation: Create the function `update_inventory_levels` as described and ensure it processes the transactions efficiently. ```python def update_inventory_levels(inventory: dict[str, int], transactions: list[tuple[str, int]]) -> None: for product_id, quantity in transactions: if product_id in inventory: inventory[product_id] -= quantity else: inventory[product_id] = -quantity ```","solution":"def update_inventory_levels(inventory: dict[str, int], transactions: list[tuple[str, int]]) -> None: Updates the inventory levels based on a list of sales transactions. Args: inventory (dict[str, int]): The current inventory levels. transactions (list[tuple[str, int]]): The list of transactions to process. Returns: None: The function updates the inventory in place. for product_id, quantity in transactions: if product_id in inventory: inventory[product_id] -= quantity else: inventory[product_id] = -quantity"},{"question":"# Question **Sparse Matrix Multiplication** You are tasked with implementing a function that multiplies two sparse matrices. Sparse matrices are matrices in which most of the elements are zero, and a common representation of sparse matrices is using a dictionary of keys (DOK) format. In this format, only the non-zero entries are stored, significantly reducing the memory usage and computational time for operations. Function Signature ```python def sparse_matrix_multiplication(matrix1: dict, matrix2: dict, dim1: tuple, dim2: tuple) -> dict: ... # Your implementation here ``` Input * `matrix1` : A dictionary representing the first sparse matrix. The keys are tuples `(i, j)` where `i` is the row index and `j` is the column index, and the values are the non-zero elements of the matrix. * `matrix2` : A dictionary representing the second sparse matrix. The keys are tuples `(i, j)` where `i` is the row index and `j` is the column index, and the values are the non-zero elements of the matrix. * `dim1` : A tuple `(n1, m1)` representing the dimensions of the first matrix. * `dim2` : A tuple `(n2, m2)` representing the dimensions of the second matrix. Output * A dictionary representing the product of the two matrices in sparse format. Example ```python matrix1 = {(0, 0): 1, (1, 2): 2} matrix2 = {(0, 1): 3, (2, 1): 4} dim1 = (2, 3) dim2 = (3, 2) print(sparse_matrix_multiplication(matrix1, matrix2, dim1, dim2)) # Output: {(0, 1): 3, (1, 1): 8} matrix1 = {(0, 1): 2} matrix2 = {(1, 0): 3} dim1 = (3, 4) dim2 = (4, 3) print(sparse_matrix_multiplication(matrix1, matrix2, dim1, dim2)) # Output: {(0, 0): 6} ``` Constraints * Assume `1 ≤ n1, m1, n2, m2 ≤ 1000`. * The function should handle edge cases like empty matrices and mismatched dimensions (multiplication should only proceed if `m1 == n2`). * The solution should be optimized for sparse data, focusing on necessary computations only. Context Sparse matrix operations are crucial in various applications like computer graphics, scientific simulations, and optimization algorithms due to their memory efficiency. By focusing only on non-zero elements, we can leverage significant computational savings. This problem will deepen your understanding of sparse data structures and efficient mathematical operations on them.","solution":"def sparse_matrix_multiplication(matrix1: dict, matrix2: dict, dim1: tuple, dim2: tuple) -> dict: Multiplies two sparse matrices represented in dictionary of keys (DOK) format. Args: matrix1 (dict): The first sparse matrix. matrix2 (dict): The second sparse matrix. dim1 (tuple): Dimensions of the first matrix (n1, m1). dim2 (tuple): Dimensions of the second matrix (n2, m2). Returns: dict: The product of the two sparse matrices in DOK format. n1, m1 = dim1 n2, m2 = dim2 if m1 != n2: raise ValueError(\\"Inner matrix dimensions must agree for multiplication (m1 == n2).\\") result = {} # Iterate only over non-zero elements in matrix1 for (i, k), v1 in matrix1.items(): # If the column index of matrix1 exists in any row index of matrix2 for j in range(m2): if (k, j) in matrix2: v2 = matrix2[(k, j)] if (i, j) not in result: result[(i, j)] = 0 result[(i, j)] += v1 * v2 return result"},{"question":"# Question: Find Longest Subsequence with Difference Constraint You need to write a function `longest_subsequence_with_diff(arr, diff)` that accepts a list of integers and an integer representing the maximum allowed difference. The function should return the length of the longest subsequence such that the absolute difference between any two consecutive elements is less than or equal to the given difference. Function Signature ```python def longest_subsequence_with_diff(arr: List[int], diff: int) -> int: ``` Input * `arr` (List[int]): A list of integers. * `diff` (int): An integer representing the maximum allowed difference between consecutive elements in the subsequence. Output * An integer representing the length of the longest subsequence meeting the difference constraint. Constraints * The array length will be at most (10^5). * All integers in the array will be within the range ([-10^4, 10^4]). * The given difference will be a non-negative integer. Example ```python longest_subsequence_with_diff([1, 5, 3, 6, 7], 2) # Should return 3 because the subsequence [5, 3, 1] or [7, 6, 5] all have differences <= 2 longest_subsequence_with_diff([1, 3, 5, 7], 0) # Should return 1 because the only subsequences possible in this case are individual elements as no two elements have the difference exactly 0. longest_subsequence_with_diff([10, 13, 15, 18, 11], 3) # Should return 4 because the subsequence [10, 13, 15, 18] has differences <= 3 ``` Notes 1. The function should efficiently handle large lists, implying considerations for optimal algorithms for subsequence finding. 2. Make sure to correctly handle cases where the given difference is zero, which would restrict subsequences to elements of the same value. 3. Focus on ensuring time complexity to perform within O(n log n) for efficiency with large inputs.","solution":"def longest_subsequence_with_diff(arr, diff): Finds the length of the longest subsequence such that the absolute difference between any two consecutive elements is less than or equal to the given difference. :param arr: List of integers :param diff: Maximum allowed difference between consecutive elements in the subsequence :return: Length of the longest subsequence meeting the difference constraint if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will store the length of the longest subsequence ending at index i for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) <= diff: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Problem Statement You are given two integers `n` and `m`. Your task is to compute the GCD (Greatest Common Divisor) and LCM (Least Common Multiple) of these two integers and return them as a tuple. Implement the following function: 1. `compute_gcd_lcm(n: int, m: int) -> tuple[int, int]` * **Input**: Two integers `n` and `m`. * **Output**: A tuple of two integers, where the first integer is the GCD of `n` and `m`, and the second integer is the LCM of `n` and `m`. # Constraints: * `1 <= n, m <= 10^9` # Examples 1. `compute_gcd_lcm(8, 12)` should return `(4, 24)`. * Explanation: The GCD of 8 and 12 is 4, and the LCM of 8 and 12 is 24. 2. `compute_gcd_lcm(5, 11)` should return `(1, 55)`. * Explanation: The GCD of 5 and 11 is 1, and the LCM of 5 and 11 is 55. 3. `compute_gcd_lcm(7, 21)` should return `(7, 21)`. * Explanation: The GCD of 7 and 21 is 7, and the LCM of 7 and 21 is 21. # Directions: * You may use Euclid\'s algorithm to compute the GCD. * The LCM can be computed using the relation `LCM(a, b) = abs(a * b) // GCD(a, b)`. * Ensure your solution handles large inputs efficiently. # Hints: * Consider edge cases where `n` or `m` is a prime number. * Think about the properties of divisors and multiples when implementing your solution.","solution":"import math def compute_gcd_lcm(n, m): Returns the GCD and LCM of two given integers n and m. gcd = math.gcd(n, m) lcm = abs(n * m) // gcd return (gcd, lcm)"},{"question":"# Coding Exercise: Identifying Primes in a Matrix **Objective**: Leverage the techniques from matrix operations and number theory to identify prime numbers within a 2D matrix and replace all prime numbers with their respective index pairs. # Specification: 1. Implement a function `is_prime(n: int) -> bool` that checks whether a given number is a prime or not. 2. Write a function `update_matrix(matrix: list[list[int]]) -> list[list[tuple[int, int]]]` that takes a 2D matrix of integers, replaces each prime number with a tuple containing the row and column indices of that prime number, and returns the updated matrix. 3. Non-prime numbers should remain unchanged. 4. Handle edge cases such as empty matrices and non-square matrices. # Function Signatures: ```python def is_prime(n: int) -> bool: Check if a number is a prime. Parameters: n (int): The number to check. Returns: bool: True if n is a prime number, otherwise False. pass def update_matrix(matrix: list[list[int]]) -> list[list[tuple[int, int] | int]]: Update the matrix by replacing primes with their index tuples. Parameters: matrix (list[list[int]]): The 2D matrix to update. Returns: list[list[tuple[int, int] | int]]: The updated matrix. pass ``` # Constraints: * Elements in the matrix are non-negative integers. * A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Examples: ```python >>> is_prime(5) True >>> is_prime(4) False >>> matrix = [ ... [29, 18, 9], ... [15, 22, 31], ... [24, 11, 14] ... ] >>> update_matrix(matrix) [[(0, 0), 18, 9], [15, 22, (1, 2)], [24, (2, 1), 14]] >>> update_matrix([]) [] ``` # Context: In scenarios where data analysis involves matrix operations, identifying specific data points, such as prime numbers, can be crucial for various calculations and optimizations. This exercise ensures that prime number detection within matrices and subsequent reporting or modification can be carried out efficiently.","solution":"def is_prime(n: int) -> bool: Check if a number is a prime. Parameters: n (int): The number to check. Returns: bool: True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def update_matrix(matrix: list[list[int]]) -> list[list[tuple[int, int] | int]]: Update the matrix by replacing primes with their index tuples. Parameters: matrix (list[list[int]]): The 2D matrix to update. Returns: list[list[tuple[int, int] | int]]: The updated matrix. for i in range(len(matrix)): for j in range(len(matrix[i])): if is_prime(matrix[i][j]): matrix[i][j] = (i, j) return matrix"},{"question":"# `heapq`-Based Priority Queue You are given a list of integers. Implement a class `PriorityQueue` using Python\'s `heapq` to support the following operations: insert a new element, extract the minimum element, and decrease the priority of a specific element. Use a min-heap for internal storage. Class Definition: ```python class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = \'<removed>\' self.counter = 0 def insert(self, item: int, priority: int): Add a new item or update the priority of an existing item. pass def extract_min(self) -> int: Remove and return the lowest priority task. Raise KeyError if empty. pass def decrease_priority(self, item: int, new_priority: int): Decrease the priority of the given item. pass ``` Input: * The `insert` method takes an integer `item` and an integer `priority`. * The `extract_min` method takes no parameters and returns an integer. * The `decrease_priority` method takes an integer `item` and an integer `new_priority`. Output: * The `insert` method modifies the heap but returns nothing. * The `extract_min` method returns the item with the smallest priority. * The `decrease_priority` method modifies the heap but returns nothing. Constraints: * There will be at most `10^5` operations performed. * The priorities are integers and can be negative. Performance Requirements: * Insertion, extraction, and decrease priority should run in O(log N) time complexity. * Space complexity should be O(N). Examples: 1. **Example 1**: ```python pq = PriorityQueue() pq.insert(\'task1\', 5) pq.insert(\'task2\', 3) pq.insert(\'task3\', 6) pq.decrease_priority(\'task3\', 2) print(pq.extract_min()) # Output: \'task3\' ``` 2. **Example 2**: ```python pq = PriorityQueue() pq.insert(\'task1\', 4) pq.insert(\'task2\', 1) pq.insert(\'task3\', 7) print(pq.extract_min()) # Output: \'task2\' pq.decrease_priority(\'task1\', 0) print(pq.extract_min()) # Output: \'task1\' ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = \'<removed>\' self.counter = 0 def insert(self, item: int, priority: int): Add a new item or update the priority of an existing item. if item in self.entry_finder: self.remove_item(item) count = self.counter entry = [priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_item(self, item: int): Mark an existing item as REMOVED. Raise KeyError if not found. entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED def extract_min(self) -> int: Remove and return the lowest priority task. Raise KeyError if empty. while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def decrease_priority(self, item: int, new_priority: int): Decrease the priority of the given item. self.insert(item, new_priority)"},{"question":"# Scenario You are a botanist developing an algorithm to identify the types of vegetation in a forest. You need to create a function that classifies a given list of plants based on their features and similarities to known plant types. # Coding Task Implement the function `classify_plants` as described below. The function should return a list of plant types, one for each plant in the input list based on provided criteria. Function Signature ```python def classify_plants(plants: List[dict], known_types: List[dict]) -> List[str]: ``` Input Parameters * `plants` (List[dict]): A list of dictionaries, where each dictionary represents a plant\'s features. * `known_types` (List[dict]): A list of dictionaries, where each dictionary represents known plant types with their corresponding features. Output * Returns a list of strings, where each string represents the classified type of the corresponding plant. # Constraints * Each plant dictionary has the same structure with keys being the feature names and values being feature values. * The function should handle cases where a plant does not match any known types by returning \\"Unknown\\" for that plant. # Classification Rule * A plant matches a known type if all its features match exactly with those of one of the known types. # Example Usage ```python plant_list = [ {\\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, {\\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, ] known_types = [ {\\"type\\": \\"Pine\\", \\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"type\\": \\"Maple\\", \\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, {\\"type\\": \\"Oak\\", \\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, ] >>> classify_plants(plant_list, known_types) [\\"Oak\\", \\"Pine\\", \\"Maple\\"] plant_list = [ {\\"leaf_shape\\": \\"oval\\", \\"color\\": \\"yellow\\", \\"height\\": 12}, {\\"leaf_shape\\": \\"needle\\", \\"color\\": \\"blue\\", \\"height\\": 25}, ] >>> classify_plants(plant_list, known_types) [\\"Unknown\\", \\"Unknown\\"] ``` # Performance Requirements * Ensure the function performs the classification in a time complexity that is efficient with respect to the input sizes.","solution":"from typing import List, Dict def classify_plants(plants: List[Dict[str, any]], known_types: List[Dict[str, any]]) -> List[str]: classified_types = [] for plant in plants: matched_type = \\"Unknown\\" for known in known_types: if all(plant.get(feature) == known.get(feature) for feature in plant): matched_type = known[\\"type\\"] break classified_types.append(matched_type) return classified_types"},{"question":"# Sum of Distinct Prime Factors Problem Statement: You are provided with an integer `n`. Your task is to calculate the sum of all distinct prime factors of `n`. Function Signature ```python def sum_of_distinct_prime_factors(n: int) -> int: ``` Input: * An integer `n` for which you need to find the sum of its distinct prime factors. Output: * Returns the sum of all distinct prime factors as an integer. Constraints: * `2 <= n <= 10^12` * Ensure that your implementation efficiently calculates the sum of distinct prime factors while dealing with potentially large values of `n`. Performance Requirement: * The algorithm should have a time complexity approximately O(√n) for prime factorization. Detailed Description: A prime factor is a prime number that divides `n` exactly, leaving no remainder. Each prime factor should be considered only once. Example: * For `n = 28`, the prime factors are 2 and 7. * For `n = 50`, the prime factors are 2 and 5. Example: ```python >>> sum_of_distinct_prime_factors(28) 9 >>> sum_of_distinct_prime_factors(50) 7 >>> sum_of_distinct_prime_factors(97) # Since 97 is a prime itself 97 ``` **Note:** Handle large integer calculations efficiently within the constraints provided. Good luck!","solution":"def sum_of_distinct_prime_factors(n: int) -> int: def get_prime_factors(n): prime_factors = set() # Check for number of 2s that divide n while n % 2 == 0: prime_factors.add(2) n //= 2 # n must be odd at this point, thus skip even numbers by incrementing by 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: prime_factors.add(i) n //= i # This condition is to check if n is a prime number greater than 2 if n > 2: prime_factors.add(n) return prime_factors prime_factors = get_prime_factors(n) return sum(prime_factors)"},{"question":"# Coding Assessment Question Scenario Understanding and manipulating string data is crucial in many programming tasks, particularly when dealing with text processing and entry validation. Your objective is to develop a function that performs specific manipulations and checks on string inputs. Problem Statement Implement a function `validate_password(password: str) -> bool` that determines whether a given password meets the specified criteria to be considered valid. A \\"valid\\" password must: 1. Be at least 8 characters long. 2. Contain at least one uppercase letter. 3. Contain at least one lowercase letter. 4. Contain at least one digit. 5. Contain at least one special character from the set: `!@#%^&*()-_+=`. Input - A string `password` where ( 1 leq len(password) leq 1000 ). Output - Returns `True` if the password meets all criteria, else returns `False`. Constraints - Ensure the function handles various edge cases such as passwords at the limit of lengths, missing various character types, and mixed types. Example ```python assert validate_password(\\"A1b@0000\\") == True # Meets all criteria assert validate_password(\\"abcdefG1@\\") == True # Meets all criteria assert validate_password(\\"password\\") == False # No digits and special characters assert validate_password(\\"P@ssw0rd\\") == True # meets all criteria assert validate_password(\\"Passw0r\\") == False # Less than 8 characters assert validate_password(\\"12345678\\") == False # No letters and special characters ```","solution":"import re def validate_password(password: str) -> bool: Validates if the password meets the specified criteria: 1. At least 8 characters long. 2. Contains at least one uppercase letter. 3. Contains at least one lowercase letter. 4. Contains at least one digit. 5. Contains at least one special character from the set: !@#%^&*()-_+= :param password: str - The password to validate. :return: bool - True if valid, False otherwise. # Check length if len(password) < 8: return False # Define regular expressions for validation has_upper = re.search(r\'[A-Z]\', password) has_lower = re.search(r\'[a-z]\', password) has_digit = re.search(r\'d\', password) has_special = re.search(r\'[!@#%^&*()-_+=]\', password) # Validate all criteria if has_upper and has_lower and has_digit and has_special: return True else: return False"},{"question":"# Coding Challenge You are tasked with developing a feature for a library management system to enhance book recommendation accuracy based on previous borrower histories and genre preferences. The system shall analyze user borrowing patterns and deliver a tailored selection of recommended books. Requirements: 1. **Implement** a book recommendation system with the following approaches: - **Collaborative Filtering** (`collaborative_filtering_recommendation`). - **Content-Based Filtering** (`content_based_recommendation`). - **Hybrid Filtering** (`hybrid_recommendation` combining the above two). 2. **Implement** a method to evaluate recommendation accuracy: - **Precision@K Calculation** (`precision_at_k`). - **Recommendation Accuracy Checker** (`recommendation_accuracy_checker` ensures precision meets a specified threshold). 3. **Process** a provided sample user borrowing history and genre preferences data to recommend books and calculate recommendation precision. # Input: - User borrowing history as a list of tuples (book_id, genre). - Genre preferences as a list of genres the user is interested in. - Library book catalog as a list of tuples (book_id, genre). - List of books already borrowed by the user. - Variable `K` representing the number of recommendations to be made. # Output: - A list of book_ids representing the recommended books. - A boolean value indicating if the recommendation accuracy meets the threshold (True for meeting/exceeding, False otherwise). # Constraints: - All lists will have a minimum size of 5. - All book_ids and genres will be represented by positive integers. - Precision@K threshold will be specified within the problem constraints. # Implementation Details: - Implement recommendation functions `collaborative_filtering_recommendation`, `content_based_recommendation`, `hybrid_recommendation`. - Implement accuracy checking functions `precision_at_k` and `recommendation_accuracy_checker`. # Example: ```python borrowing_history = [(1, \'Fiction\'), (2, \'Science Fiction\'), (3, \'Science\')] genre_preferences = [\'Fiction\', \'Science Fiction\'] library_catalog = [(4, \'Fiction\'), (5, \'Science Fiction\'), (6, \'Science\'), (7, \'Fantasy\'), (8, \'Fiction\')] already_borrowed = [1, 3] K = 3 precision_threshold = 0.7 # You need to process the user data # Implement recommendation functions # Implement accuracy checking system # Example output: # [4, 5, 6], True (indicating if recommendation precision meets the threshold) ```","solution":"from collections import defaultdict def collaborative_filtering_recommendation(borrowing_history, library_catalog, already_borrowed): # Placeholder function: Assumes borrowed books influence recommendation based on genre popularity genre_count = defaultdict(int) for _, genre in borrowing_history: genre_count[genre] += 1 recommended_books = [] for book_id, genre in library_catalog: if book_id not in already_borrowed and genre_count[genre] > 0: recommended_books.append(book_id) return recommended_books def content_based_recommendation(genre_preferences, library_catalog, already_borrowed): recommended_books = [] for book_id, genre in library_catalog: if genre in genre_preferences and book_id not in already_borrowed: recommended_books.append(book_id) return recommended_books def hybrid_recommendation(borrowing_history, genre_preferences, library_catalog, already_borrowed): collaborative_books = set(collaborative_filtering_recommendation(borrowing_history, library_catalog, already_borrowed)) content_books = set(content_based_recommendation(genre_preferences, library_catalog, already_borrowed)) return list(collaborative_books | content_books) def precision_at_k(recommended_books, K, genre_preferences, library_catalog): recommended_genres = set() for book_id in recommended_books[:K]: for book in library_catalog: if book[0] == book_id: recommended_genres.add(book[1]) break relevant_recommendations = sum(genre in genre_preferences for genre in recommended_genres) return relevant_recommendations / K def recommendation_accuracy_checker(recommended_books, K, genre_preferences, library_catalog, precision_threshold): precision = precision_at_k(recommended_books, K, genre_preferences, library_catalog) return precision >= precision_threshold"},{"question":"# Coding Assessment Question Develop a program to manage and evaluate employees’ performance metrics in a company. Each employee has a unique ID and is evaluated based on three categories: productivity score, punctuality score, and teamwork score. You are given five functions: 1. `average_score(employee_id: int) -> float`: This function calculates the average score of an employee across all three categories. 2. `highest_score_category(employee_id: int) -> str`: This function returns the category in which the employee has the highest score among productivity, punctuality, and teamwork. 3. `lowest_score_category(employee_id: int) -> str`: This function returns the category in which the employee has the lowest score among productivity, punctuality, and teamwork. 4. `improve_score(employee_id: int, category: str, increment: float) -> None`: This function increases the score of a specific category for an employee by a specified increment. 5. `is_promotion_eligible(employee_id: int) -> bool`: This function checks if the employee is eligible for a promotion. An employee is eligible for promotion if their average score is 85 or above and they have no category score below 75. Implement the `employee_evaluation` function which performs different evaluations based on the provided operation. Function Signature ```python def employee_evaluation(employee_id: int, operation: str, category: str = None, increment: float = None) -> float or str or bool: ``` Input - `employee_id`: An integer representing the unique ID of the employee. - `operation`: A string indicating the type of evaluation to be performed. It can be \\"average\\", \\"highest\\", \\"lowest\\", \\"improve\\", or \\"promotion\\". - `category`: A string representing the category to be used for improvement. It is required only for the \\"improve\\" operation. - `increment`: A float representing the increment value for improving the score. It is required only for the \\"improve\\" operation. Output - For \\"average\\" operation, return the average score as a float. - For \\"highest\\" and \\"lowest\\" operations, return the category name as a string. - For \\"improve\\" operation, return `None` after updating the score. - For \\"promotion\\" operation, return a boolean indicating whether the employee is eligible for promotion. Constraints - Ensure the `employee_id` is valid and exists in the system. - `operation` must be one of the defined operations, handle invalid operations gracefully. - Score increments must be positive values. Examples 1. `employee_evaluation(101, \\"average\\")` should return approximately `86.66`. 2. `employee_evaluation(101, \\"highest\\")` should return `\\"productivity\\"`. 3. `employee_evaluation(101, \\"lowest\\")` should return `\\"teamwork\\"`. 4. `employee_evaluation(101, \\"improve\\", \\"punctuality\\", 5.0)` should return `None` and update the punctuality score. 5. `employee_evaluation(101, \\"promotion\\")` should return `True`. Implement the function `employee_evaluation` using the provided functions to execute the necessary evaluations based on the operation specified.","solution":"# Sample employee data for demonstration purposes employees_data = { 101: {\'productivity\': 90, \'punctuality\': 88, \'teamwork\': 82}, 102: {\'productivity\': 75, \'punctuality\': 80, \'teamwork\': 78}, 103: {\'productivity\': 85, \'punctuality\': 88, \'teamwork\': 90}, } def average_score(employee_id): data = employees_data[employee_id] return sum(data.values()) / len(data) def highest_score_category(employee_id): data = employees_data[employee_id] return max(data, key=data.get) def lowest_score_category(employee_id): data = employees_data[employee_id] return min(data, key=data.get) def improve_score(employee_id, category, increment): if increment <= 0: raise ValueError(\\"Increment must be positive\\") employees_data[employee_id][category] += increment def is_promotion_eligible(employee_id): data = employees_data[employee_id] avg_score = average_score(employee_id) return avg_score >= 85 and all(score >= 75 for score in data.values()) def employee_evaluation(employee_id, operation, category=None, increment=None): if employee_id not in employees_data: raise ValueError(\\"Invalid employee_id\\") if operation == \\"average\\": return average_score(employee_id) elif operation == \\"highest\\": return highest_score_category(employee_id) elif operation == \\"lowest\\": return lowest_score_category(employee_id) elif operation == \\"improve\\": if category is None or increment is None: raise ValueError(\\"Category and increment are required for improve operation\\") improve_score(employee_id, category, increment) return None elif operation == \\"promotion\\": return is_promotion_eligible(employee_id) else: raise ValueError(\\"Invalid operation\\")"},{"question":"# File Comparison Using Hash Context You\'ve just been hired by a software company that heavily relies on data integrity and security. One of the tasks you have been assigned is to create a utility that checks if two files are identical. This is critical for ensuring that backups, file transfers, and other operations are performed correctly without data corruption or tampering. To achieve this, you decide to use hash functions to compare the files. Task Your task is to implement a function `are_files_identical(file_path1: str, file_path2: str) -> bool` that takes the paths of two files as input and returns a boolean indicating whether the files are identical. The function should calculate the SHA-256 hash of each file and compare the hashes to determine if the files are the same. Input and Output Formats * **Input**: Two strings representing the paths to the files to be compared (e.g., `file_path1 = \\"path/to/file1.txt\\"`, `file_path2 = \\"path/to/file2.txt\\"`) * **Output**: A boolean value, `True` if the files are identical, otherwise `False`. Example * **Example 1**: ```python result = are_files_identical(\\"file1.txt\\", \\"file2.txt\\") ``` *Output*: ``` False ``` * **Example 2**: ```python result = are_files_identical(\\"duplicate_file1.txt\\", \\"file1.txt\\") ``` *Output*: ``` True ``` Constraints * Both input file paths are valid and refer to files that exist on the disk. * The files to be compared can be of any type and size. * Ensure the function handles the reading of large files efficiently without running out of memory. Additional Information * You should use the hashlib library for computing SHA-256 hashes. * Make sure to read the files in chunks to avoid memory issues with very large files. * Handle any potential exceptions that may occur during file I/O operations, such as file not found or access denied errors.","solution":"import hashlib def are_files_identical(file_path1: str, file_path2: str) -> bool: Checks if the two files at the given paths are identical by comparing their SHA-256 hashes. :param file_path1: Path to the first file :param file_path2: Path to the second file :return: True if the files are identical, otherwise False def compute_file_hash(file_path: str) -> str: sha256_hash = hashlib.sha256() try: with open(file_path, \\"rb\\") as f: for byte_block in iter(lambda: f.read(4096), b\\"\\"): sha256_hash.update(byte_block) return sha256_hash.hexdigest() except IOError: return None hash1 = compute_file_hash(file_path1) hash2 = compute_file_hash(file_path2) if hash1 is None or hash2 is None: raise FileNotFoundError(\\"One or both of the files cannot be read.\\") return hash1 == hash2"},{"question":"# Task: Longest Palindromic Substring Problem Statement: Write a function `longest_palindromic_substring` that takes a string `s` and returns the longest palindromic substring within `s`. If there are multiple palindromic substrings with the same maximum length, return the first one that appears. Input: - A string `s` Output: - A string representing the longest palindromic substring. Examples: ``` assert longest_palindromic_substring(\\"babad\\") == \\"bab\\" # Explanation: \\"bab\\" is the longest palindrome. \\"aba\\" is another option, but \\"bab\\" appears first. assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" # Explanation: \\"bb\\" is the longest palindrome. assert longest_palindromic_substring(\\"a\\") == \\"a\\" # Explanation: Single character strings are palindromes by definition. assert longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" # Explanation: Longest palindrome is \\"geeksskeeg\\". ``` Constraints: - `1 <= len(s) <= 1000` - The function should handle various character sets, including lowercase and uppercase letters, digits, and special characters. - Characters in the string may not necessarily be alphanumeric. Requirements: - Your implementation should handle single-character strings correctly. - Edge cases such as empty input and strings with no palindromes need to be considered explicitly. - Optimize for both time and space complexity, if possible. Optimization: - Aim for a time complexity of O(n^2) or better, where `n` is the length of the string. - Minimize space usage without compromising on clarity and correctness. Sample Function Signature: ```python def longest_palindromic_substring(s: str) -> str: pass ```","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. If there are multiple with the same length, returns the first one that appears. def expand_around_center(left: int, right: int) -> str: Expands around the center and returns the longest palindrome for that center. while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s: return \\"\\" longest = \\"\\" for i in range(len(s)): # Odd length palindromes (single center) odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes (double center) even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"# Coding Assessment Question **Title**: Generate Subsets of a Set Using Backtracking **Objective**: Implement a function that generates all possible subsets (the power set) of a given set using backtracking. **Context**: Given a set of unique elements (numbers or characters), generate all possible subsets. The subsets should be printed one by one, each on a new line in lexicographical order of the elements within the subset and the subset order. **Function Signature**: ```python def find_all_subsets(sequence: list[int | str]) -> None: pass ``` **Input/Output Format**: * **Input**: A list of elements (`sequence`), which can be integers or characters. You can assume the sequence will not be empty and will have at most 8 elements. * **Output**: Print each subset on a new line in lexicographical order, sorted by subset length and then lexicographically within the subset. **Constraints**: * No element repeats in the input sequence. * The input list has a maximum length of 8. * Subsets should be sorted in ascending order within themselves and by length. **Examples**: Example 1: ```python sequence = [1, 2, 3] find_all_subsets(sequence) ``` Output: ``` [] [1] [2] [3] [1, 2] [1, 3] [2, 3] [1, 2, 3] ``` Example 2: ```python sequence = [\'A\', \'B\', \'C\'] find_all_subsets(sequence) ``` Output: ``` [] [\'A\'] [\'B\'] [\'C\'] [\'A\', \'B\'] [\'A\', \'C\'] [\'B\', \'C\'] [\'A\', \'B\', \'C\'] ``` **Hints**: 1. Use backtracking to generate subsets. 2. Ensure you explore both including and excluding each element to form subsets. 3. The order of subsets in the output should reflect ascending order by length, and within subsets should also be in lexicographical order. **Implementation Note**: Utilize backtracking to systematically generate all subsets, carefully ensuring that the subsets remain sorted both in content and by their lengths. Implement carefully to practice effectively generating power sets.","solution":"def find_all_subsets(sequence): def backtrack(start, path): result.append(path[:]) for i in range(start, len(sequence)): path.append(sequence[i]) backtrack(i + 1, path) path.pop() # Sort the input sequence to satisfy lexicographical requirement sequence.sort() result = [] backtrack(0, []) # Print all subsets in lexicographical order as per specification result.sort(key=lambda x: (len(x), x)) for subset in result: print(subset)"},{"question":"You are tasked with implementing an algorithm that finds the longest contiguous subarray with a sum equal to a given target value `k`. # Objective Write a function `longest_subarray_sum_k(nums: List[int], k: int) -> int` that: 1. Takes a list of integers `nums` and an integer `k` as inputs. 2. Returns the length of the longest contiguous subarray whose elements add up to `k`. # Input * A list of integers `nums` (-10^4 ≤ nums[i] ≤ 10^4, 1 ≤ len(nums) ≤ 10^5). * An integer `k` (-10^9 ≤ k ≤ 10^9). # Output * An integer representing the length of the longest contiguous subarray with a sum of `k`. # Constraints 1. Optimize to handle large input sizes efficiently. 2. Utilize a linear or near-linear time complexity solution to ensure performance. # Performance Requirement * The solution should run efficiently for very large arrays (up to 100,000 elements). # Scenarios 1. If `nums` is [1, -1, 5, -2, 3] and `k` is 3, the function should return 4 because the subarray [1, -1, 5, -2] sums to 3. 2. If `nums` is [-2, -1, 2, 1] and `k` is 1, the function should return 2 because the subarray [-1, 2] sums to 1. 3. If `nums` is [1, 2, 3] and `k` is 6, the function should return 3 because the entire array sums to 6. # Example ```python print(longest_subarray_sum_k([1, -1, 5, -2, 3], 3)) # Output: 4 print(longest_subarray_sum_k([-2, -1, 2, 1], 1)) # Output: 2 print(longest_subarray_sum_k([1, 2, 3], 6)) # Output: 3 print(longest_subarray_sum_k([1, 2, 3], 0)) # Output: 0 (no subarray sums to 0) print(longest_subarray_sum_k([], 0)) # Output: 0 (empty list, no subarray) ``` Implement the function to solve the problem accurately and efficiently for all valid inputs.","solution":"from typing import List def longest_subarray_sum_k(nums: List[int], k: int) -> int: Finds the length of the longest subarray with sum equal to k. sum_indices = {} curr_sum = 0 max_length = 0 for i in range(len(nums)): curr_sum += nums[i] if curr_sum == k: max_length = i + 1 if (curr_sum - k) in sum_indices: max_length = max(max_length, i - sum_indices[curr_sum - k]) if curr_sum not in sum_indices: sum_indices[curr_sum] = i return max_length"},{"question":"# Coding Task: Finding the Missing Number in a Consecutive Sequence Given an unsorted list of distinct integers in the range from 1 to ( n ) (inclusive), with exactly one integer missing, your task is to find and return the missing integer. This type of question is common in programming interviews and tests your ability to efficiently manipulate and analyze arrays. # Problem Description Write a function `find_missing_number` that takes a list of distinct integers and returns the missing number in the sequence. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: ``` # Input * `nums`: A list of distinct integers in the range from 1 to ( n ) (inclusive) with one integer missing. The length of `nums` is ( n-1 ). # Output * Returns the missing integer in the range from 1 to ( n ). # Constraints * The length of the list `nums` is ( n-1 ), where ( n ) is at most (10^5). # Performance Requirements Your solution should have a time complexity of (O(n)). # Examples ```python # Example 1 nums = [3, 7, 1, 2, 8, 4, 5] print(find_missing_number(nums)) # Output: 6 # Example 2 nums = [1, 2, 3, 5] print(find_missing_number(nums)) # Output: 4 # Example 3 nums = [6, 2, 3, 4, 5, 1] print(find_missing_number(nums)) # Output: 7 # Example 4 nums = [2] print(find_missing_number(nums)) # Output: 1 ``` # Instructions 1. Read the problem description and examples carefully. 2. Implement the `find_missing_number` function. 3. Ensure your solution is efficient and meets the performance requirements.","solution":"def find_missing_number(nums: list[int]) -> int: This function takes a list of distinct integers in the range from 1 to n (inclusive) with one integer missing, and returns the missing integer. n = len(nums) + 1 # Since one number is missing total_sum = n * (n + 1) // 2 # Sum of all integers from 1 to n actual_sum = sum(nums) # Sum of integers present in the list missing_number = total_sum - actual_sum # The missing number return missing_number"},{"question":"# Exploratory Data Analysis and Visualization with Pandas and Matplotlib For this assessment, you are tasked with performing exploratory data analysis (EDA) and visualizations on a dataset representing various movies. You will be given a dataset consisting of features such as movie titles, genres, release years, ratings, and box office collections. Your objective is to analyze the dataset and generate meaningful insights using Pandas and Matplotlib. **Problem**: 1. Implement a function `load_data` that reads the input dataset. 2. Implement a function `data_exploration` that performs exploratory data analysis. 3. Implement a function `generate_visualizations` that creates visual representations of the data. 4. Implement a `main` function to run the entire process and generate the report. # Input: 1. A string `file_path` representing the path to the CSV file containing the dataset. # Output: 1. Print summary statistics and insights gathered from the exploratory data analysis. 2. Save plots representing the data distributions and correlations. # Constraints: * Use Pandas for data manipulations and Matplotlib for visualizations. * Ensure the analysis covers key aspects such as summary statistics, missing data handling, and data distributions. * Handle any missing or incorrect input data rationally. # Example: ```python # Sample dataset format (movies.csv) # title,genre,release_year,rating,box_office # Movie 1,Action,2015,7.8,123456.78 # Movie 2,Comedy,2016,6.5,234567.89 # ... # Define the functions import pandas as pd import matplotlib.pyplot as plt def load_data(file_path): Loads the data from the given file path. data = pd.read_csv(file_path) return data def data_exploration(data): Performs exploratory data analysis on the dataset. print(\\"Summary Statistics:n\\", data.describe()) print(\\"Missing Data:n\\", data.isnull().sum()) print(\\"Data Types:n\\", data.dtypes) def generate_visualizations(data): Generates visualizations for the dataset. plt.figure(figsize=(10, 6)) data[\'rating\'].hist(bins=20) plt.title(\'Distribution of Movie Ratings\') plt.xlabel(\'Rating\') plt.ylabel(\'Frequency\') plt.savefig(\'rating_distribution.png\') plt.figure(figsize=(10, 6)) data[\'box_office\'].plot(kind=\'box\') plt.title(\'Box Office Revenue Distribution\') plt.ylabel(\'Revenue\') plt.savefig(\'box_office_boxplot.png\') def main(file_path): Main function to run the data analysis and visualization process. data = load_data(file_path) data_exploration(data) generate_visualizations(data) if __name__ == \\"__main__\\": file_path = \'path_to_your_csv_file/movies.csv\' main(file_path) ``` # Evaluation: Evaluate your solution based on: 1. Correctness: Does the function accurately analyze and visualize the dataset? 2. Efficiency: Is your solution optimized for given constraints? 3. Presentation: Are the visualizations clear and informative? 4. Robustness: Does your solution handle edge cases and missing data gracefully?","solution":"import pandas as pd import matplotlib.pyplot as plt def load_data(file_path): Loads the data from the given file path. data = pd.read_csv(file_path) return data def data_exploration(data): Performs exploratory data analysis on the dataset. summary_stats = data.describe() missing_data = data.isnull().sum() data_types = data.dtypes print(\\"Summary Statistics:n\\", summary_stats) print(\\"nMissing Data:n\\", missing_data) print(\\"nData Types:n\\", data_types) return summary_stats.to_dict(), missing_data.to_dict(), data_types.to_dict() def generate_visualizations(data): Generates visualizations for the dataset. # Plotting rating distribution plt.figure(figsize=(10, 6)) data[\'rating\'].dropna().hist(bins=20) plt.title(\'Distribution of Movie Ratings\') plt.xlabel(\'Rating\') plt.ylabel(\'Frequency\') plt.savefig(\'rating_distribution.png\') plt.close() # Plotting box office revenue distribution plt.figure(figsize=(10, 6)) data[\'box_office\'].dropna().plot(kind=\'box\') plt.title(\'Box Office Revenue Distribution\') plt.ylabel(\'Revenue\') plt.savefig(\'box_office_boxplot.png\') plt.close() def main(file_path): Main function to run the data analysis and visualization process. data = load_data(file_path) data_exploration(data) generate_visualizations(data) if __name__ == \\"__main__\\": file_path = \'path_to_your_csv_file/movies.csv\' main(file_path)"},{"question":"# Scenario You are developing a temperature tracking system for a smart thermostat. The system needs to predict the expected temperature after a given period based on the current temperature trend. You need to implement a function that calculates the future temperature given the current trend rate and the number of hours. # Problem Statement Implement the function `predict_temperature(current_temp: float, trend_rate: float, hours: int) -> float` that calculates and returns the expected temperature after a given number of hours. The future temperature can be calculated using the formula: [ text{Future Temperature} = text{current_temp} + (text{trend_rate} times text{hours}) ] # Function Signature ```python def predict_temperature(current_temp: float, trend_rate: float, hours: int) -> float: pass ``` # Input * `current_temp`: A floating-point number representing the current temperature in degrees Celsius. * `trend_rate`: A floating-point number representing the rate of temperature change per hour (in degrees Celsius per hour). * `hours`: An integer representing the number of hours into the future (hours >= 0). # Output * A floating-point number representing the predicted temperature after the given number of hours. # Constraints * The current temperature can be any real number. * The trend rate can be any real number. * The number of hours will be a non-negative integer. # Examples ```python >>> predict_temperature(22.5, 0.5, 10) 27.5 >>> predict_temperature(15.0, -0.2, 24) 10.2 >>> predict_temperature(30.0, -1.0, 5) 25.0 ``` # Notes 1. The function should correctly handle cases where the trend rate is zero, which means the temperature stays constant. 2. It should also handle both positive and negative trend rates, indicating increasing or decreasing temperatures, respectively. 3. Make sure to account for the possibility that `hours` is zero, in which case the future temperature should be the same as the current temperature.","solution":"def predict_temperature(current_temp: float, trend_rate: float, hours: int) -> float: Calculates and returns the expected temperature after a given number of hours based on the current trend rate. Parameters: - current_temp (float): The current temperature in degrees Celsius. - trend_rate (float): The rate of temperature change per hour in degrees Celsius. - hours (int): The number of hours into the future. Returns: - float: The predicted temperature after the given number of hours. return current_temp + (trend_rate * hours)"},{"question":"# Problem Statement: Write a function `find_common_elements(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[int]` that takes in two 2D lists of integers (`matrix1` and `matrix2`) and returns a sorted list of unique common elements found in both matrices. # Input: * Two 2D lists of integers `matrix1` and `matrix2`, where each list represents a matrix with dimensions `m x n`. # Output: * A list of integers containing unique elements found in both matrices, sorted in ascending order. If there are no common elements, return an empty list. # Constraints: * The function should handle the typical constraints with matrix sizes up to 100x100. * Assume the function should handle typical input values within these constraints efficiently. * Optimize for time complexity where possible. # Examples: ```python find_common_elements( [[1, 2, 3], [4, 5, 6]], [[3, 6, 9], [12, 1, 4]] ) -> [1, 3, 4, 6] find_common_elements( [[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]] ) -> [] find_common_elements( [[7, 8], [9, 10]], [[10, 8], [11, 9]] ) -> [8, 9, 10] ``` # Directions: 1. Follow the provided function signature exactly. 2. Ensure your solution works for edge cases such as empty matrices or no common elements. 3. Consider possible optimizations based on problem analysis.","solution":"from typing import List def find_common_elements(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[int]: # Flatten both matrices into sets of unique elements set1 = {element for row in matrix1 for element in row} set2 = {element for row in matrix2 for element in row} # Find the intersection of both sets common_elements = set1.intersection(set2) # Convert to a sorted list and return return sorted(common_elements)"},{"question":"# Prime Numbers Summary Given an integer `n`, write a function to create a summary of all prime numbers up to and including `n`. The function should return a string summarizing the primes in a specific format. Function Signature ```python def prime_numbers_summary(n: int) -> str: ``` Expected Input and Output * **Input**: * `n` (int): An integer representing the upper limit for generating prime numbers. * **Output**: * A string summarizing the prime numbers in the format \\"Prime count: X, Sum: Y, Average: Z\\". - `X` is the count of prime numbers up to and including `n`. - `Y` is the sum of these prime numbers. - `Z` is the average of these prime numbers up to two decimal places. Constraints * `n` should be a positive integer greater than 1 and less than or equal to 10^6. Examples ```python assert prime_numbers_summary(10) == \\"Prime count: 4, Sum: 17, Average: 4.25\\" assert prime_numbers_summary(20) == \\"Prime count: 8, Sum: 77, Average: 9.62\\" assert prime_numbers_summary(5) == \\"Prime count: 3, Sum: 10, Average: 3.33\\" assert prime_numbers_summary(2) == \\"Prime count: 1, Sum: 2, Average: 2.00\\" assert prime_numbers_summary(100) == \\"Prime count: 25, Sum: 1060, Average: 42.40\\" ``` Instructions 1. **Implement the function**: Implement the `prime_numbers_summary` function to find all prime numbers up to the provided integer `n`. 2. **Prime calculation**: Use an efficient algorithm, such as the Sieve of Eratosthenes, to find prime numbers up to `n`. 3. **Edge cases**: Handle edge cases where there might be no primes (for values of `n` < 2, which although excluded by constraints, should still be considered for sanity). 4. **Validation**: Ensure that your function can handle values up to 10^6 efficiently. 5. **Formatting**: Make sure the output string is formatted exactly as \\"Prime count: X, Sum: Y, Average: Z\\" with the average rounded to two decimal places. # Explanation - The function will first calculate all prime numbers up to `n` using an efficient algorithm. - It will then count these primes, compute their sum, and calculate the average. - Finally, the function will return a formatted string with the count, sum, and average of the primes.","solution":"import math def prime_numbers_summary(n: int) -> str: def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for i in range(2, int(math.sqrt(limit)) + 1): if is_prime[i]: for j in range(i * i, limit + 1, i): is_prime[j] = False primes = [i for i in range(2, limit + 1) if is_prime[i]] return primes primes = sieve_of_eratosthenes(n) prime_count = len(primes) prime_sum = sum(primes) prime_average = round(prime_sum / prime_count, 2) if prime_count > 0 else 0 return f\\"Prime count: {prime_count}, Sum: {prime_sum}, Average: {prime_average:.2f}\\""},{"question":"# Question You are tasked with developing a Python function to solve a graph problem involving social network analysis. The goal is to identify the most influential person in a network. Specifically, you need to implement the PageRank algorithm to rank nodes in the graph based on their importance. Given the following requirements: - Implement a Python function `page_rank()` that calculates the PageRank of each node in the graph using the iterative approach. - The graph is directed, and each node represents a person in the social network. Edges represent the influence or connections from one person to another. # Function Signature ```python def page_rank(graph: Dict[str, List[str]], d: float, iterations: int) -> Dict[str, float]: pass ``` # Parameters - `graph`: A dictionary where keys are node identifiers (strings) and values are lists of strings representing the nodes to which there are outgoing edges. - `d`: A float representing the damping factor, typically set to 0.85. - `iterations`: An integer representing the number of iterations to perform the PageRank calculation. # Returns - A dictionary where keys are node identifiers (strings) and values are their corresponding PageRank scores (floats). # Constraints - All nodes in the graph have unique identifiers. - Nodes may not necessarily have outgoing edges (in which case they are considered dangling nodes). # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [\'C\'] } d = 0.85 iterations = 100 print(page_rank(graph, d, iterations)) # Example Output: {\'A\': 0.3282, \'B\': 0.2131, \'C\': 0.3667, \'D\': 0.0920} ``` # Additional Note Ensure your implementation handles graphs with dangling nodes and those with no outgoing edges appropriately. Incorporate a convergence check to prevent unnecessary calculations if the PageRank values stabilize before the maximum number of iterations.","solution":"def page_rank(graph, d: float, iterations: int): Implements the PageRank algorithm on a directed graph. Parameters: - graph: A dictionary where keys are node identifiers (strings) and values are lists of strings representing the nodes to which there are outgoing edges. - d: A float representing the damping factor, typically set to 0.85. - iterations: An integer representing the number of iterations to perform the PageRank calculation. Returns: - A dictionary where keys are node identifiers (strings) and values are their corresponding PageRank scores (floats). # Initialize the rank of each node to 1 divided by the number of nodes num_nodes = len(graph) rank = {node: 1/num_nodes for node in graph} # Create a set of dangling nodes (nodes with no outgoing edges) dangling_nodes = {node for node in graph if not graph[node]} for iteration in range(iterations): new_rank = {} dangling_sum = d * sum(rank[node] for node in dangling_nodes) for node in graph: new_rank[node] = (1 - d) / num_nodes new_rank[node] += dangling_sum / num_nodes for incoming_node in graph: if node in graph[incoming_node]: new_rank[node] += d * rank[incoming_node] / len(graph[incoming_node]) rank = new_rank return rank"},{"question":"# Scenario You are tasked with developing an algorithm for a vending machine. The machine stocks a finite set of beverages, where each beverage has a unique integer identifier, price, and quantity. The machine accepts coins of certain denominations and can provide change if possible. The goal is to determine if a particular transaction (i.e., purchasing a beverage with a given set of coins) can be successfully completed, considering both the price of the beverage and the change-making capability of the machine. # Task Implement a function `def can_purchase(beverage_id: int, coins: List[int], inventory: Dict[int, Tuple[int, int]], change_available: Dict[int, int]) -> bool:` that, given a beverage identifier, a list of coins inserted, the inventory of beverages with their prices and quantities, and the current available change in the machine, returns a boolean indicating whether the purchase can be successfully completed. # Input and Output Formats 1. **Input**: - `beverage_id` (an integer representing the beverage to purchase). - `coins` (a list of integers where each integer represents a coin denomination inserted). - `inventory` (a dictionary where keys are beverage IDs and values are tuples containing price and quantity respectively). - `change_available` (a dictionary where keys are coin denominations and values are the counts of those denominations available for making change). 2. **Output**: - A boolean (`True` if the transaction can be completed, `False` otherwise). # Constraints 1. `0 <= len(coins) <= 100` 2. Each coin denomination will be one of [1, 5, 10, 25, 50, 100]. 3. There can be up to 50 different beverages in the inventory. 4. Prices will be positive integers up to 1000. 5. All beverage quantities and counts of coin denominations in `change_available` are non-negative integers. 6. The transaction should use the least number of coins for making change if possible. # Examples ```python def can_purchase(beverage_id: int, coins: List[int], inventory: Dict[int, Tuple[int, int]], change_available: Dict[int, int]) -> bool: from collections import defaultdict def make_change(amount, change_available): denominations = sorted(change_available.keys(), reverse=True) change_to_give = defaultdict(int) for denom in denominations: while change_available[denom] > 0 and amount >= denom: change_available[denom] -= 1 change_to_give[denom] += 1 amount -= denom if amount != 0: # Revert the changes if we couldn\'t provide the exact change for denom, count in change_to_give.items(): change_available[denom] += count return False return True if beverage_id not in inventory or inventory[beverage_id][1] == 0: return False price, quantity = inventory[beverage_id] total_inserted = sum(coins) change_needed = total_inserted - price if change_needed < 0: return False temp_change_available = change_available.copy() for coin in coins: if coin in temp_change_available: temp_change_available[coin] += 1 else: temp_change_available[coin] = 1 if not make_change(change_needed, temp_change_available): return False return True # Example usage inventory = { 1: (150, 5), 2: (250, 2), 3: (100, 0), # out of stock } change_available = { 1: 10, 5: 10, 10: 10, 25: 10, 50: 5, 100: 2, } assert can_purchase(1, [100, 100], inventory, change_available) == True # valid purchase assert can_purchase(2, [100, 100], inventory, change_available) == False # not enough coins assert can_purchase(3, [100, 100], inventory, change_available) == False # out of stock assert can_purchase(1, [50, 50, 50, 25], inventory, change_available) == False # cannot make change ``` Be sure to handle edge cases such as trying to buy an out-of-stock beverage, insufficient coins, and the inability to provide exact change.","solution":"from typing import List, Dict, Tuple from collections import defaultdict def can_purchase(beverage_id: int, coins: List[int], inventory: Dict[int, Tuple[int, int]], change_available: Dict[int, int]) -> bool: def make_change(amount, change_available): denominations = sorted(change_available.keys(), reverse=True) change_to_give = defaultdict(int) for denom in denominations: while change_available[denom] > 0 and amount >= denom: change_available[denom] -= 1 change_to_give[denom] += 1 amount -= denom if amount != 0: # Revert the changes if we couldn\'t provide the exact change for denom, count in change_to_give.items(): change_available[denom] += count return False return True if beverage_id not in inventory or inventory[beverage_id][1] == 0: return False price, quantity = inventory[beverage_id] total_inserted = sum(coins) change_needed = total_inserted - price if change_needed < 0: return False temp_change_available = change_available.copy() for coin in coins: if coin in temp_change_available: temp_change_available[coin] += 1 else: temp_change_available[coin] = 1 if not make_change(change_needed, temp_change_available): return False return True"},{"question":"# Scenario You are working on signal processing and need to implement a basic moving average filter. Your task is to write a function that computes the moving average of a given list of numbers, using a fixed window size. # Task Implement the function `moving_average_filter(numbers: List[float], window_size: int) -> List[float]` which computes the moving average of the input list with a specified window size. # Function Signature ```python def moving_average_filter(numbers: List[float], window_size: int) -> List[float]: pass ``` # Input: * `numbers` (List[float]): A list of floating-point numbers representing the input signal. * `window_size` (int): An integer defining the size of the moving window. # Output: * Returns a list of floating-point numbers where each element is the moving average of the corresponding window in the input list. # Constraints: * The list `numbers` can have 0 or more elements. * The window size `window_size` is a positive integer (1 <= window_size <= len(numbers)). # Examples: 1. Input: `numbers = [1, 2, 3, 4, 5]`, `window_size = 3` Output: `[2.0, 3.0, 4.0]` 2. Input: `numbers = [5, 6, 7, 8, 9, 10]`, `window_size = 2` Output: `[5.5, 6.5, 7.5, 8.5, 9.5]` 3. Input: `numbers = [10, 20, 30, 40]`, `window_size = 4` Output: `[25.0]` # Note: Ensure that the function handles edge cases such as an empty list or a window size equal to the length of the list efficiently. The calculation should be well-suited for potentially large input lists typical in signal processing applications.","solution":"from typing import List def moving_average_filter(numbers: List[float], window_size: int) -> List[float]: Computes the moving average of the input list with a specified window size. Parameters: numbers (List[float]): A list of floating-point numbers representing the input signal. window_size (int): An integer defining the size of the moving window. Returns: List[float]: A list of floating-point numbers where each element is the moving average of the corresponding window in the input list. if not numbers or window_size <= 0 or window_size > len(numbers): return [] moving_averages = [] window_sum = sum(numbers[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(numbers)): window_sum = window_sum - numbers[i - window_size] + numbers[i] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"Binary Search Tree (BST) Challenge Your task is to implement a binary search tree (BST) with specific functionalities. This ensures that the insertion, search, and traversal operations are efficient, adhering to the properties of a BST. # Function Requirements Implement a `BST` class with the following methods: - `__init__(self)`: Initialize an empty BST. - `insert(self, value: int) -> None`: Insert a value into the BST. This should maintain the BST properties. - `search(self, value: int) -> bool`: Check if a value is present in the BST. Return `True` if found, otherwise `False`. - `delete(self, value: int) -> None`: Delete a value from the BST if it exists. This should maintain the BST properties. - `inorder(self) -> List[int]`: Return a list of values representing the inorder traversal of the BST. - `preorder(self) -> List[int]`: Return a list of values representing the preorder traversal of the BST. - `postorder(self) -> List[int]`: Return a list of values representing the postorder traversal of the BST. # Expected Input and Output - The input is a series of operations to be executed on the BST. - The output is the result of the operations, where applicable. # Constraints - Assume all input values are integers. - The number of operations will not exceed 10^5. # Performance Requirements - Efficient implementations are expected, ensuring that each operation is completed in close to O(log n) time complexity on average. # Example ```python # Example usage: bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.inorder()) # Should return [3, 5, 7] print(bst.search(3)) # Should return True print(bst.search(4)) # Should return False bst.insert(4) print(bst.inorder()) # Should return [3, 4, 5, 7] bst.delete(3) print(bst.inorder()) # Should return [4, 5, 7] print(bst.preorder()) # Should return [5, 4, 7] print(bst.postorder()) # Should return [4, 7, 5] ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def search(self, value): return self._search(self.root, value) def _search(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value) def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right = self._delete(node.right, min_larger_node.value) return node def _get_min(self, node): while node.left is not None: node = node.left return node def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.value) self._inorder(node.right, result) def preorder(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node: result.append(node.value) self._preorder(node.left, result) self._preorder(node.right, result) def postorder(self): result = [] self._postorder(self.root, result) return result def _postorder(self, node, result): if node: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.value)"},{"question":"# Subarray Sum Challenge In this challenge, you will find the maximum sum of any contiguous subarray within a given integer array using Kadane’s Algorithm. Scenario Consider you are writing an analytics feature for a financial software application that deals with tracking net profit over time. The software needs to compute the period during which the net profit was maximized. To achieve this, you need to implement a function that finds the maximum sum of any contiguous subarray within a provided list of integers (representing net profit/loss over days). Function Signature ```python def max_subarray_sum(nums: List[int]) -> int: Finds the maximum sum of any contiguous subarray in the given list of integers. Args: nums (List[int]): A list of integers representing net profit/loss over days. Returns: int: The maximum sum of any contiguous subarray. ``` Input - A list `nums` of integers which can be positive, zero, or negative. Output - A single integer representing the maximum sum of any contiguous subarray within the given list. Constraints - The length of `nums` is at least 1 and does not exceed (10^5). - The elements of `nums` are within the range of [-1000, 1000]. Examples ```python >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5,4,-1,7,8]) 23 >>> max_subarray_sum([-1,-2,-3,-4]) -1 ``` Requirements - Run in linear time O(n). - Ensure to handle edge cases like all negative numbers. Tips - Initialize variables to store the current subarray sum and the maximum sum encountered so far. - Iterate through the array, updating these variables appropriately to find the maximum sum of a contiguous subarray. Implement the function `max_subarray_sum` and verify its correctness with various test cases.","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Finds the maximum sum of any contiguous subarray in the given list of integers. Args: nums (List[int]): A list of integers representing net profit/loss over days. Returns: int: The maximum sum of any contiguous subarray. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Statement You are developing a social media application that requires determining the optimal time slot to schedule a post to maximize user engagement. For simplicity, the app divides each day into 24 hourly slots from 0 to 23. You have access to user activity data which indicates the number of active users for each hour of the day. Given this user activity data, implement a function `optimal_posting_time` that determines the hour of the day when the maximum number of users is active. # Function Signature ```python def optimal_posting_time(user_activity: list[int]) -> int: pass ``` # Input - `user_activity`: a list of 24 integers, where the i-th integer represents the number of active users at the i-th hour of the day. # Output - Returns an integer representing the hour of the day (range from 0 to 23) when the maximum number of users is active. If there are multiple hours with the same number of active users, return the earliest hour. # Constraints - The length of the list `user_activity` will always be 24. - Each integer in `user_activity` will be between 0 and (10^6). # Example ```python >>> optimal_posting_time([50, 55, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270]) 23 >>> optimal_posting_time([10, 20, 30, 40, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900]) 23 >>> optimal_posting_time([500, 400, 300, 200, 100, 50, 40, 30, 20, 10, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8]) 0 ``` # Notes - Ensure the function performs efficiently within the given constraints. - If two or more hours have the same number of active users, return the earliest hour.","solution":"def optimal_posting_time(user_activity): Returns the hour of the day when the maximum number of users is active. :param user_activity: List[int], a list of 24 integers representing active users for each hour. :return: int, the hour with the maximum user activity. max_users = max(user_activity) return user_activity.index(max_users)"},{"question":"# Problem Statement Given a list of integers, implement a function `rotate_right(sequence: List[int], k: int) -> List[int]` that rotates the elements of the list to the right by `k` steps. # Function Signature ```python def rotate_right(sequence: List[int], k: int) -> List[int]: pass ``` # Input - `sequence`: A list of integers that can contain duplicates and may be of any size, including empty. - `k`: An integer representing the number of steps to rotate the list to the right. `k` can be any non-negative integer. # Output - Return a new list that is a result of rotating the input list `sequence` to the right by `k` steps. # Constraints - The sequence length `n` is 0 ≤ n ≤ 10^6. - The elements in the sequence are within the range of standard 32-bit integers. # Requirements - Do not use any built-in functions or libraries to perform the rotation. - Ensure the function handles large values of `k` efficiently by using modulo operation. # Example ```python assert rotate_right([1, 2, 3, 4, 5], 1) == [5, 1, 2, 3, 4] assert rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_right([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_right([], 3) == [] assert rotate_right([1], 3) == [1] assert rotate_right([1, 2], 3) == [2, 1] ``` # Notes - Make sure to handle cases where `k` is greater than the length of the list. Use modulo operation to determine the effective rotation steps. - Consider edge cases such as an empty list, list with a single element, and large rotations efficiently. - Focus on writing clean and efficient code to handle lists of large sizes within the given constraints.","solution":"from typing import List def rotate_right(sequence: List[int], k: int) -> List[int]: Rotates the elements of the list to the right by k steps. n = len(sequence) if n == 0: return [] k = k % n return sequence[-k:] + sequence[:-k]"},{"question":"# Coding Assessment Question Design and implement a Python class called `MatrixManipulator` that offers various matrix operations such as addition, subtraction, multiplication, and inverse. Your implementation should include: 1. Initialization of the matrix from a 2D array. 2. Methods for addition, subtraction, and multiplication with another matrix. 3. A method to compute the inverse of the matrix. Requirements 1. **Input Format**: The class should initialize with a list of lists representing the matrix, where each inner list is a row of the matrix. 2. **Output Format**: Methods should return a new `MatrixManipulator` object for addition, subtraction, and multiplication, and a list of lists representing the matrix for the inverse method. 3. **Edge Cases**: Your implementation should handle cases such as matrix addition or subtraction involving matrices of different dimensions appropriately. For matrix multiplication, ensure compatibility between the dimensions of the matrices. For the inverse method, handle non-invertible matrices by raising an appropriate exception. Constraints * You may not use any external library functions for matrix operations. Implement the operations from scratch. * Ensure proper handling of floating-point arithmetic for the inverse method. * The dimensions of the matrices involved in the operations should not exceed 100x100 for this task. Performance * The solution should handle matrix operations efficiently, considering the typical computational complexities for matrix addition, subtraction, multiplication, and inversion. Context You are developing a mathematical toolkit for a company that offers services in scientific computing. Efficient and accurate matrix manipulation functionalities are crucial for the success of the toolkit. Here is a skeleton class to get you started: ```python class MatrixManipulator: def __init__(self, matrix: list) -> None: self.matrix = matrix def add(self, other: \'MatrixManipulator\') -> \'MatrixManipulator\': # Implement matrix addition pass def subtract(self, other: \'MatrixManipulator\') -> \'MatrixManipulator\': # Implement matrix subtraction pass def multiply(self, other: \'MatrixManipulator\') -> \'MatrixManipulator\': # Implement matrix multiplication pass def inverse(self) -> list: # Implement matrix inversion pass # Example usage matrix1 = MatrixManipulator([[1, 2], [3, 4]]) matrix2 = MatrixManipulator([[5, 6], [7, 8]]) # Matrix Addition result_add = matrix1.add(matrix2) print(result_add.matrix) # Expected output: [[6, 8], [10, 12]] # Matrix Subtraction result_subtract = matrix1.subtract(matrix2) print(result_subtract.matrix) # Expected output: [[-4, -4], [-4, -4]] # Matrix Multiplication result_multiply = matrix1.multiply(matrix2) print(result_multiply.matrix) # Expected output: [[19, 22], [43, 50]] # Matrix Inverse result_inverse = matrix1.inverse() print(result_inverse) # Expected output: [[-2.0, 1.0], [1.5, -0.5]] ``` Testing Ensure your implementation matches the expected results for basic matrix operations and edge cases: ```python import numpy as np def test_matrix_operations(): mat1 = np.array([[1, 2], [3, 4]]) mat2 = np.array([[5, 6], [7, 8]]) # Test addition result_add = MatrixManipulator(mat1.tolist()).add(MatrixManipulator(mat2.tolist())).matrix assert result_add == (mat1 + mat2).tolist(), f\\"Addition failed: {result_add}\\" # Test subtraction result_subtract = MatrixManipulator(mat1.tolist()).subtract(MatrixManipulator(mat2.tolist())).matrix assert result_subtract == (mat1 - mat2).tolist(), f\\"Subtraction failed: {result_subtract}\\" # Test multiplication result_multiply = MatrixManipulator(mat1.tolist()).multiply(MatrixManipulator(mat2.tolist())).matrix assert result_multiply == (mat1 @ mat2).tolist(), f\\"Multiplication failed: {result_multiply}\\" # Test inverse result_inverse = MatrixManipulator(mat1.tolist()).inverse() assert np.allclose(result_inverse, np.linalg.inv(mat1)), f\\"Inverse failed: {result_inverse}\\" test_matrix_operations() ```","solution":"class MatrixManipulator: def __init__(self, matrix: list) -> None: self.matrix = matrix def add(self, other: \'MatrixManipulator\') -> \'MatrixManipulator\': if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices must have the same dimensions for addition\\") result = [ [self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixManipulator(result) def subtract(self, other: \'MatrixManipulator\') -> \'MatrixManipulator\': if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices must have the same dimensions for subtraction\\") result = [ [self.matrix[i][j] - other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixManipulator(result) def multiply(self, other: \'MatrixManipulator\') -> \'MatrixManipulator\': if len(self.matrix[0]) != len(other.matrix): raise ValueError(\\"Number of columns in A must be equal to the number of rows in B\\") result = [ [sum(self.matrix[i][k] * other.matrix[k][j] for k in range(len(other.matrix))) for j in range(len(other.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixManipulator(result) def inverse(self) -> list: n = len(self.matrix) # Create the identity matrix I identity_matrix = [[float(i == j) for i in range(n)] for j in range(n)] # Create a copy of the matrix temp_matrix = [row[:] for row in self.matrix] for i in range(n): # Find the pivot and scale the row pivot = temp_matrix[i][i] if pivot == 0: raise ValueError(\\"Matrix is not invertible.\\") for j in range(n): temp_matrix[i][j] /= pivot identity_matrix[i][j] /= pivot # Eliminate the other rows for k in range(n): if k != i: factor = temp_matrix[k][i] for j in range(n): temp_matrix[k][j] -= factor * temp_matrix[i][j] identity_matrix[k][j] -= factor * identity_matrix[i][j] return identity_matrix"},{"question":"# Unique Paths in a Grid Given a grid of size `m x n`, where you can only move to the right or down from a given cell, find the number of unique paths to get from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. Input - Two integers `m` and `n`, representing the number of rows and columns of the grid respectively. Output - The function should return an integer, representing the number of unique paths. Constraints - `1 <= m, n <= 100` Performance Requirements - The implementation should have a time complexity of O(m * n) and a space complexity of O(m * n). Example ```python def unique_paths(m: int, n: int) -> int: pass # Example Test Cases assert unique_paths(3, 3) == 6 # 6 unique paths assert unique_paths(1, 1) == 1 # Only 1 unique path assert unique_paths(2, 2) == 2 # 2 unique paths assert unique_paths(3, 7) == 28 # 28 unique paths assert unique_paths(10, 10) == 48620 # 48620 unique paths ``` Implementation Notes: 1. Define a 2D array `dp` of size `m x n` to store the number of unique paths to reach each cell. 2. Initialize `dp[i][0]` to 1 for all `i` and `dp[0][j]` to 1 for all `j`, since there is only one way to reach any cell in the first row or first column (straight right or straight down). 3. Fill in the rest of the `dp` array using the relation `dp[i][j] = dp[i-1][j] + dp[i][j-1]`, which represents the number of ways to reach cell `(i, j)` either from the cell above it `(i-1, j)` or the cell to its left `(i, j-1)`. 4. The final value `dp[m-1][n-1]` will be the total number of unique paths to reach the bottom-right corner from the top-left corner.","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in a m x n grid. # Create a 2D array initialized to 1s for the base cases (first row and first column) dp = [[1] * n for _ in range(m)] # Fill in the dp array using the recurrence relation for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the answer return dp[m-1][n-1]"},{"question":"# Problem Statement A company is building a logistics management system that optimizes delivery routes for drones. The goal is to minimize the total distance covered by the drones when delivering packages to multiple locations. Your task is to implement the Simulated Annealing algorithm to find the shortest route starting from the depot, visiting all delivery locations exactly once, and returning to the depot (a classic Traveling Salesman Problem). # Requirements 1. Implement the Simulated Annealing algorithm. 2. Ensure temperature cooling schedule, acceptance probabilities, and edge cases are handled. 3. Provide visualization of the optimization process. # Function Signature ```python class DeliveryRoute: def __init__(self, locations: List[Tuple[int, int]]): # constructor def total_distance(self) -> float: # returns total distance based on current route def get_neighbors(self): # returns list of neighboring states def simulated_annealing( initial_route: DeliveryRoute, initial_temp: float = 1000, cooling_rate: float = 0.99, min_temp: float = 1, max_iter: int = 10000, visualization: bool = False ) -> DeliveryRoute: # implementation ``` # Input Constraints 1. **Locations**: List of tuples representing coordinates of delivery locations. 2. **Initial Temperature**: Positive float value for the initial temperature. 3. **Cooling Rate**: A float value between 0 and 1 representing the cooling rate. 4. **Minimum Temperature**: Temperature at which the algorithm terminates. 5. **Maximum Iterations**: Limit iterations to prevent infinite loops. # Output Return the state (DeliveryRoute) object with the shortest route found based on the specified objective. # Example **Test the function with the following:** ```python def distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) locations = [(0, 0), (2, 3), (5, 4), (6, 1), (8, 8)] initial_route = DeliveryRoute(locations=locations) optimal_route = simulated_annealing( initial_route=initial_route, initial_temp=1000, cooling_rate=0.95, min_temp=1, max_iter=2000, visualization=True ) print(f\\"Optimal route found: {optimal_route}\\") print(f\\"Total distance: {optimal_route.total_distance()}\\") ``` # Notes * You may need to implement additional helper functions for calculating distances and generating neighboring states. * Ensure that the optimization process is well-visualized if the `visualization` flag is set to True. * Use appropriate initial values and cooling schedules to balance exploration and exploitation during the optimization process.","solution":"import math import random import matplotlib.pyplot as plt from typing import List, Tuple class DeliveryRoute: def __init__(self, locations: List[Tuple[int, int]]): self.locations = locations self.route = locations.copy() random.shuffle(self.route) def total_distance(self) -> float: distance = 0 for i in range(len(self.route)): start = self.route[i] end = self.route[(i + 1) % len(self.route)] distance += math.dist(start, end) return distance def get_neighbors(self): neighbors = [] for i in range(len(self.route)): for j in range(i + 1, len(self.route)): neighbor = self.route.copy() neighbor[i], neighbor[j] = neighbor[j], neighbor[i] neighbors.append(neighbor) return [DeliveryRoute(neighbor) for neighbor in neighbors] def simulated_annealing( initial_route: DeliveryRoute, initial_temp: float = 1000, cooling_rate: float = 0.99, min_temp: float = 1, max_iter: int = 10000, visualization: bool = False ) -> DeliveryRoute: current_route = initial_route best_route = initial_route current_temp = initial_temp distances = [current_route.total_distance()] for iteration in range(max_iter): if current_temp < min_temp: break neighbors = current_route.get_neighbors() next_route = random.choice(neighbors) current_distance = current_route.total_distance() next_distance = next_route.total_distance() if next_distance < current_distance or random.uniform(0, 1) < math.exp((current_distance - next_distance) / current_temp): current_route = next_route if current_route.total_distance() < best_route.total_distance(): best_route = current_route current_temp *= cooling_rate if visualization: distances.append(best_route.total_distance()) if visualization: plt.plot(distances) plt.xlabel(\'Iteration\') plt.ylabel(\'Distance\') plt.title(\'Simulated Annealing Optimization Process\') plt.show() return best_route"},{"question":"# Traverse a Binary Tree in Zigzag Level Order Write a function `zigzag_level_order` that takes a binary tree and returns its zigzag level order traversal as a list of lists. In a zigzag traversal, the nodes are visited in a level-order but alternate levels are traversed from right to left. Function Signature ```python def zigzag_level_order(root: TreeNode) -> List[List[int]]: pass ``` # Input - A binary tree rooted at `root` of type `TreeNode`. # Output - A list of lists where each sublist contains the values of tree nodes at each level of the tree, ordered in a zigzag manner. # Constraints - The binary tree nodes contain integer values. - Efficient time complexity for traversal is expected. - Handle different tree structures including empty trees, trees with only one node, and multi-level trees. # Example ```python # Example binary tree structure # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) # Example output result = zigzag_level_order(root) print(result) # Output: [[3], [20, 9], [15, 7]] ``` **Note**: You are given the `TreeNode` class definition as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Additional Requirements - Implement necessary edge case checks like handling null root or single node trees. - Ensure the traversal alternates correctly between left-to-right and right-to-left at each level. - Utilize appropriate data structures to maintain traversal order and efficiency.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.val) else: current_level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(current_level)) left_to_right = not left_to_right return results"},{"question":"Problem Statement You are helping a museum to track visitor statistics. The museum records the entry and exit times of each visitor through a turnstile. Your task is to write a Python function that calculates the maximum number of visitors present in the museum at any given time based on these time logs. # Function Signature: ```python def max_visitors(entries: List[int], exits: List[int]) -> int: Calculate the maximum number of visitors present in the museum at any given time. Args: entries (List[int]): A list of integers representing the entry times of visitors. exits (List[int]): A list of integers representing the exit times of visitors. Returns: int: The maximum number of visitors present in the museum at any given time. ``` # Input - `entries` (List[int]): A list of integers where each integer represents the time (in minutes) a visitor enters the museum. - `exits` (List[int]): A list of integers where each integer represents the time (in minutes) a visitor exits the museum. Both lists will have the same length, and for each visitor, the entry time will be less than the exit time. # Output - An integer representing the maximum number of visitors present in the museum at any given time. # Constraints - 1 ≤ len(entries) = len(exits) ≤ 1000 - 0 ≤ entries[i] < exits[i] ≤ 10^6 # Example ```python print(max_visitors([1, 2, 4], [3, 5, 6])) # Output: 2 print(max_visitors([5, 3, 8, 7], [10, 6, 9, 11])) # Output: 2 ``` # Additional Notes - Assume entry times and exit times are strictly in minutes and represent continuous time. - Ensure the solution handles the data efficiently, considering the constraints given.","solution":"from typing import List def max_visitors(entries: List[int], exits: List[int]) -> int: Calculate the maximum number of visitors present in the museum at any given time. Args: entries (List[int]): A list of integers representing the entry times of visitors. exits (List[int]): A list of integers representing the exit times of visitors. Returns: int: The maximum number of visitors present in the museum at any given time. # Create a list of all events with +1 for entry and -1 for exit events = [] for entry in entries: events.append((entry, 1)) for exit in exits: events.append((exit, -1)) # Sort events first by time; in case of tie, sort by type to ensure exits come first events.sort(key=lambda x: (x[0], x[1])) max_visitors = 0 current_visitors = 0 for event in events: current_visitors += event[1] if current_visitors > max_visitors: max_visitors = current_visitors return max_visitors"},{"question":"# Context: You are designing a digital library system, and part of the system requires a way to manage and query books efficiently. One of the features needed is the ability to search for books that match certain criteria from the inventory. # Problem Statement: Implement a function `search_books` that filters a list of books based on a given keyword in the title or author\'s name. The search should be case-insensitive. # Function Signature: ```python def search_books(inventory: List[Dict[str, str]], keyword: str) -> List[Dict[str, str]]: pass ``` # Input: - `inventory` (List[Dict[str, str]]): A list of dictionaries where each dictionary represents a book with the following keys: - \'title\' (str): The title of the book. - \'author\' (str): The author of the book. - `keyword` (str): The keyword to search for in the \'title\' or \'author\' fields. # Output: - Returns a list of dictionaries representing books that contain the keyword either in the \'title\' or \'author\'. # Constraints: - The keyword search should be case-insensitive. - If no books match the keyword, return an empty list. - There will be at most 1000 books in the inventory. - Each book will have a title and author field. # Examples: ```python books = [ {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\'}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\'}, {\'title\': \'1984\', \'author\': \'George Orwell\'}, {\'title\': \'Gatsby Revisited\', \'author\': \'Jane Doe\'} ] assert search_books(books, \'gatsby\') == [ {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\'}, {\'title\': \'Gatsby Revisited\', \'author\': \'Jane Doe\'} ] assert search_books(books, \'orwell\') == [ {\'title\': \'1984\', \'author\': \'George Orwell\'} ] assert search_books(books, \'not found\') == [] ``` # Additional Notes: * Ensure the solution is efficient for the provided constraints. * Normalize the case for consistent comparison during the search. * You may assume that all input data is well-formed. # Evaluation: Your solution will be evaluated based on: * Correctness * Efficiency * Clarity and readability of the code * Handling of edge cases","solution":"from typing import List, Dict def search_books(inventory: List[Dict[str, str]], keyword: str) -> List[Dict[str, str]]: Filters books based on a keyword found in the title or author\'s name. The search is case-insensitive. :param inventory: List of dictionaries containing \'title\' and \'author\' of books. :param keyword: The keyword to search for in the title or author fields. :return: A list of dictionaries for books that match the keyword. matching_books = [] keyword_lower = keyword.lower() for book in inventory: if keyword_lower in book[\'title\'].lower() or keyword_lower in book[\'author\'].lower(): matching_books.append(book) return matching_books"},{"question":"# Question: Implement a Custom Derivative Function for ReLU Activation You are working with Rectified Linear Unit (ReLU) activation functions in a neural network and need to implement its derivative for backpropagation. The derivative function helps in updating the weights during the training process. Description: The ReLU function is defined as: [ f(x) = max(0, x) ] Its derivative, which we need to implement, is: [ f\'(x) = begin{cases} 1 & text{if } x > 0 0 & text{if } x leq 0 end{cases} ] Function Signature: ```python import numpy as np def relu_derivative(vector: np.ndarray) -> np.ndarray: Implements the derivative of the ReLU activation function. Parameters: vector (ndarray): A vector that consists of numeric values. Returns: vector (ndarray): Input vector after applying the ReLU derivative function. ``` Input: * `vector`: A numpy array of numeric values. Output: * A numpy array of the same shape as the input vector, where each element is replaced by 1 if the corresponding input element is greater than 0, or 0 otherwise. Constraints: * The input vector will contain only numeric values. * Utilize vectorized operations for performance efficiency. Example: ```python >>> import numpy as np >>> vector = np.array([-0.5, 0.0, 1.5, 2.5, -1.1, 0.3]) >>> relu_derivative(vector) array([0, 0, 1, 1, 0, 1]) ``` Implement the `relu_derivative` function according to the above specifications.","solution":"import numpy as np def relu_derivative(vector: np.ndarray) -> np.ndarray: Implements the derivative of the ReLU activation function. Parameters: vector (ndarray): A vector that consists of numeric values. Returns: vector (ndarray): Input vector after applying the ReLU derivative function. return np.where(vector > 0, 1, 0)"},{"question":"# Question **Roman Numerals to Decimal Conversion** You are tasked with implementing a function that converts a Roman numeral string to its decimal equivalent. Roman numerals use combinations of letters from the Latin alphabet (I, V, X, L, C, D, M) to signify values. Each symbol has a fixed integer value: I=1, V=5, X=10, L=50, C=100, D=500, M=1000. The ordering of the letters follows specific rules which must be considered for an accurate conversion. Your goal is to write a function: ```python def roman_to_decimal(roman_string: str) -> int: pass ``` # Input The input to your function is a string `roman_string` which represents a Roman numeral. The string may contain uppercase and lowercase letters and might include leading/trailing whitespace. # Output The function should return the decimal integer equivalent of the input Roman numeral string. # Constraints * The input string will only contain valid Roman numeral characters (I, V, X, L, C, D, M). * Leading and trailing spaces should be ignored. * The function must handle both uppercase and lowercase letters appropriately. * The input string will not be longer than 15 characters. # Examples ```python >>> roman_to_decimal(\\"III\\") 3 >>> roman_to_decimal(\\"iv\\") 4 >>> roman_to_decimal(\\"ix\\") 9 >>> roman_to_decimal(\\"LVIII\\") 58 >>> roman_to_decimal(\\" MCMXCIV \\") 1994 >>> roman_to_decimal(\\"MMXXI\\") 2021 >>> roman_to_decimal(\\"MMXXi\\") Traceback (most recent call last): ... ValueError: Invalid Roman numeral string >>> roman_to_decimal(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> roman_to_decimal(\\"IIII\\") Traceback (most recent call last): ... ValueError: Invalid Roman numeral string ``` Implement the function `roman_to_decimal` to fulfill all the given requirements. Ensure your function passes all the above examples. **Note**: A valid Roman numeral will not have more than three consecutive identical symbols and will follow the correct subtractive combination rules (e.g., IV for 4, IX for 9, etc.). Any deviation should raise a `ValueError` with an appropriate error message.","solution":"def roman_to_decimal(roman_string: str) -> int: Convert a Roman numeral string to its decimal equivalent. Args: roman_string: A string representing a Roman numeral. Returns: An integer equivalent of the Roman numeral. Raises: ValueError: If the roman_string is empty or invalid. # Define the value of each Roman numeral character roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Normalize the input by stripping whitespace and converting to uppercase roman_string = roman_string.strip().upper() if not roman_string: raise ValueError(\\"Empty string was passed to the function\\") # Helper function to validate the string def is_valid_roman(numeral): valid_numerals = {\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'} for ch in numeral: if ch not in valid_numerals: return False return True if not is_valid_roman(roman_string): raise ValueError(\\"Invalid Roman numeral string\\") # Special case handling for invalid patterns import re if re.search(r\'(IIII|VV|XXXX|LL|CCCC|DD|MMMM)\', roman_string): raise ValueError(\\"Invalid Roman numeral string\\") total = 0 prev_value = 0 for char in roman_string[::-1]: value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Coding Assessment Question Question: You need to write a function that evaluates the scores of students based on their grades and categorizes them into different performance bands. The function should process a dictionary where each key is a student\'s name and the value is their grade. The grading criteria are as follows: - A: 90-100 - B: 80-89 - C: 70-79 - D: 60-69 - F: Below 60 Function Details: * **Function Name**: `categorize_students` * **Input**: A single argument `grades` which is a dictionary `{name: grade}`. * **Output**: A dictionary where each key is a performance band (`\\"A\\"`, `\\"B\\"`, `\\"C\\"`, `\\"D\\"`, `\\"F\\"`) and the value is a list of the students\' names who fall into that band. * **Constraints**: * The input grades dictionary will have at most 1000 entries. * Grades are integers between 0 and 100. * **Performance Requirement**: The function should run efficiently within O(n) time complexity where n is the number of students. Example: ```python >>> print(categorize_students({\\"Alice\\": 85, \\"Bob\\": 92, \\"Charlie\\": 77, \\"Diana\\": 59})) {\'A\': [\'Bob\'], \'B\': [\'Alice\'], \'C\': [\'Charlie\'], \'D\': [], \'F\': [\'Diana\']} >>> print(categorize_students({\\"Eve\\": 100, \\"Frank\\": 0, \\"Grace\\": 70, \\"Heidi\\": 65})) {\'A\': [\'Eve\'], \'B\': [], \'C\': [\'Grace\'], \'D\': [\'Heidi\'], \'F\': [\'Frank\']} >>> print(categorize_students({})) {\'A\': [], \'B\': [], \'C\': [], \'D\': [], \'F\': []} ``` Remember to handle cases where the input dictionary is empty. Also, ensure that your function efficiently categorizes each student based on their grade. Include appropriate documentation for your code.","solution":"def categorize_students(grades): Categorizes students into performance bands based on their grades. :param grades: Dictionary {name: grade} where grade is an integer between 0 and 100. :return: Dictionary with keys as performance bands (\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"F\\") and values as lists of students\' names. result = {\\"A\\": [], \\"B\\": [], \\"C\\": [], \\"D\\": [], \\"F\\": []} for student, grade in grades.items(): if 90 <= grade <= 100: result[\\"A\\"].append(student) elif 80 <= grade <= 89: result[\\"B\\"].append(student) elif 70 <= grade <= 79: result[\\"C\\"].append(student) elif 60 <= grade <= 69: result[\\"D\\"].append(student) else: result[\\"F\\"].append(student) return result"},{"question":"Context You are provided with a problem where you need to design a data structure that efficiently supports basic operations with minimum overhead. The task involves implementing a stack that, in addition to the standard stack operations (push and pop), supports retrieving the minimum element in constant time. Task Write a Python class to implement a stack that supports push, pop, and retrieving the minimum element in constant time (O(1)). Requirements - Write a class `MinStack` that: - Implements a `push` method to add elements to the stack. - Implements a `pop` method to remove elements from the stack. - Implements a `top` method to get the top element from the stack. - Implements a `get_min` method to retrieve the minimum element from the stack. Function Signatures ```python class MinStack: def __init__(self) -> None: ... def push(self, x: int) -> None: ... def pop(self) -> None: ... def top(self) -> int: ... def get_min(self) -> int: ... ``` Input Format - The `push` method accepts an integer `x`. - The `pop` method does not accept any parameters. - The `top` method does not accept any parameters. - The `get_min` method does not accept any parameters. Output Format - The `top` method returns an integer. - The `get_min` method returns an integer. - If the `top` or `get_min` methods are called on an empty stack, raise an `IndexError`. Example ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Output: -3 min_stack.pop() print(min_stack.top()) # Output: 0 print(min_stack.get_min()) # Output: -2 ``` Constraints - All elements are integers. - The operations must be performed in constant time (O(1)). --- **Solution**: ```python class MinStack: def __init__(self) -> None: self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if not self.stack: raise IndexError(\\"Pop from empty stack\\") if self.stack.pop() == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if not self.stack: raise IndexError(\\"Top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"Get min from empty stack\\") return self.min_stack[-1] ``` This problem and solution provide an added layer of complexity and efficient algorithm implementation, aligning well with the scope and difficulty of the provided questions.","solution":"class MinStack: def __init__(self) -> None: self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if not self.stack: raise IndexError(\\"Pop from empty stack\\") if self.stack.pop() == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if not self.stack: raise IndexError(\\"Top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"Get min from empty stack\\") return self.min_stack[-1]"},{"question":"# Coding Challenge: Implement the Least Recently Used (LRU) Cache Context An LRU (Least Recently Used) Cache is a data structure that stores a limited number of items. When the cache exceeds its capacity, it removes the least recently accessed item before adding a new one. This scenario is common in memory management of operating systems and web browsers. Task Implement an LRU Cache using the provided `LRUCache` class template. Complete the following methods: 1. **`get`** - Retrieve the value of the key if the key exists in the cache, otherwise return -1. 2. **`put`** - Add a key-value pair to the cache. If the cache reaches its capacity, you must evict the least recently used item before inserting the new item. 3. **Helper Methods**: - `move_to_front` - Update the key\'s position as most recently used. - `evict` - Remove the least recently used item from the cache. Requirements 1. **Function Signatures**: - `get`: `(self, key: int) -> int` - `put`: `(self, key: int, value: int) -> None` - `move_to_front`: `(self, key: int) -> None` - `evict`: `(self) -> None` 2. **Input/Output**: - Input: Sequence of operations (`get` and `put`). - Output: Results of the `get` operations. 3. **Performance**: - Your implementation should provide O(1) time complexity for both `get` and `put` operations using appropriate data structures. 4. **Constraints**: - The capacity of the cache is a positive integer. - The keys and values will be non-negative integers. Example ```python cache = LRUCache(2) # capacity = 2 cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` ```python if __name__ == \\"__main__\\": import doctest doctest.testmod(extraglobs={\\"cache\\": LRUCache(2)}) # Test cases cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1, f\\"Expected 1, got {cache.get(1)}\\" cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1, f\\"Expected -1, got {cache.get(2)}\\" cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1, f\\"Expected -1, got {cache.get(1)}\\" assert cache.get(3) == 3, f\\"Expected 3, got {cache.get(3)}\\" assert cache.get(4) == 4, f\\"Expected 4, got {cache.get(4)}\\" print(\\"All test cases passed!\\") ``` ```python from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.move_to_front(key) # Move the accessed key to the front. return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.move_to_front(key) else: if len(self.cache) >= self.capacity: self.evict() self.cache[key] = value self.cache[key] = value self.move_to_front(key) # Ensure the key is in the front after put. def move_to_front(self, key: int) -> None: self.cache.move_to_end(key, last=False) def evict(self) -> None: self.cache.popitem(last=True) ```","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with the given capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Retrieve the value of the key if the key exists in the cache, otherwise return -1. if key not in self.cache: return -1 else: self.move_to_front(key) return self.cache[key] def put(self, key: int, value: int) -> None: Add a key-value pair to the cache. If the cache reaches its capacity, evict the least recently used item before inserting the new item. if key in self.cache: self.move_to_front(key) else: if len(self.cache) >= self.capacity: self.evict() self.cache[key] = value self.cache[key] = value self.move_to_front(key) def move_to_front(self, key: int) -> None: Update the key\'s position as most recently used. self.cache.move_to_end(key, last=False) def evict(self) -> None: Remove the least recently used item from the cache. self.cache.popitem(last=True)"},{"question":"# Find the Shortest Subarray with a Given Sum Problem Statement Your task is to write a function that finds the shortest continuous subarray within a list of integers that sums up to a given target sum. If no such subarray exists, the function should return an empty list. Function Signature ```python def shortest_subarray_with_sum(nums: list[int], target: int) -> list[int]: pass ``` Input * `nums`: A list of integers. * `target`: An integer representing the target sum. Output * Returns a list of integers representing the shortest subarray that sums up to the target. If no such subarray exists, return an empty list. Constraints * The length of `nums` (N) can be in the range [0, 10^4]. * Each element in `nums` can be in the range [-10^4, 10^4]. * The target sum is an integer in the range [-10^4, 10^4]. Example Consider the following input: * Input: ```python nums = [1, 4, 20, 3, 10, 5] target = 33 result = shortest_subarray_with_sum(nums, target) ``` * Output: ```python [20, 3, 10] ``` Explanation * The continuous subarray `[20, 3, 10]` sums up to the target value 33. This is the shortest such subarray in the given list. Notes * Ensure the function handles edge cases such as empty lists, lists with no subarray matching the target sum, and lists containing negative integers. * Aim to implement the solution in a manner that efficiently handles large lists.","solution":"def shortest_subarray_with_sum(nums: list[int], target: int) -> list[int]: Finds the shortest subarray with a given sum. Parameters: nums (list[int]): The list of integers. target (int): The target sum. Returns: list[int]: The shortest subarray that sums up to the target sum or an empty list if none exists. from collections import defaultdict # Dictionary to store the sum of the elements up to each index sum_indices = defaultdict(lambda: -1) sum_indices[0] = -1 # Initialize with sum 0 at index -1 current_sum = 0 min_length = float(\'inf\') start_index, end_index = -1, -1 for i in range(len(nums)): current_sum += nums[i] if (current_sum - target) in sum_indices: start = sum_indices[current_sum - target] if (i - start) < min_length: min_length = i - start start_index, end_index = start + 1, i sum_indices[current_sum] = i # Update the dictionary with the current cumulative sum # If a valid subarray is found, return it if start_index == -1: return [] return nums[start_index:end_index+1]"},{"question":"Problem Statement You are given a non-negative integer `n`. Your task is to write a function that generates a string representing a sequence of numbers from 1 to `n`, but with a twist: - For multiples of 3, append \\"Fizz\\" instead of the number to the string. - For multiples of 5, append \\"Buzz\\" instead of the number. - For multiples of both 3 and 5, append \\"FizzBuzz\\" instead of the number. Each element in the sequence should be separated by a comma and a space. # Function Signature ```python def generate_fizz_buzz_sequence(n: int) -> str: ``` # Input - `n` (Integer): A non-negative integer. # Output - Returns a string that constructs the sequence as described. # Examples 1. `generate_fizz_buzz_sequence(5)` should return `\'1, 2, Fizz, 4, Buzz\'`. 2. `generate_fizz_buzz_sequence(10)` should return `\'1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz\'`. 3. `generate_fizz_buzz_sequence(0)` should return `\'\'`. 4. `generate_fizz_buzz_sequence(15)` should return `\'1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz\'`. # Constraints - Ensure the function handles the edge case where `n` is 0 correctly. - You may assume the input will be a valid non-negative integer. # Performance Requirements - Your solution should be efficient in both space and time complexity.","solution":"def generate_fizz_buzz_sequence(n: int) -> str: Generates a FizzBuzz sequence as a string from 1 to n. - For multiples of 3, append \\"Fizz\\" - For multiples of 5, append \\"Buzz\\" - For multiples of both 3 and 5, append \\"FizzBuzz\\" result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return \', \'.join(result)"},{"question":"# Matrix Transposition and Summation **Scenario**: You are developing a linear algebra library that supports various matrix operations. One fundamental task is the transposition of a matrix. Additionally, the library should provide the capability to compute the summation of all elements in a transposed matrix. **Task**: Implement the following function: ```python def transpose_and_sum(matrix): Transpose the given matrix and calculate the sum of all its elements. Parameters: matrix : list of lists A 2D list (matrix) where each inner list represents a row of the matrix. Returns: float : The sum of all elements in the transposed matrix. Raises: ValueError : If the input is not a list of lists or is not rectangular. pass ``` **Input and Output Formats**: - `matrix`: A 2D list (list of lists) of numbers (integers or floats), representing a rectangular matrix. - The function should return a single floating-point number, which is the sum of all elements in the transposed matrix. **Constraints**: 1. `matrix` must be a list of lists where each inner list has the same length, representing a rectangular matrix. **Performance Requirements**: Your solution should efficiently handle matrices up to size 100x100 (time complexity O(n*m), space complexity O(n*m)). **Examples**: ```python # Matrix transposition: # Input: [[1, 2], [3, 4]] # Transposed: [[1, 3], [2, 4]] # Sum: 1+2+3+4 => 10 assert transpose_and_sum([[1, 2], [3, 4]]) == 10 # Matrix transposition: # Input: [[0.5, -0.5], [-1, 1]] # Transposed: [[0.5, -1], [-0.5, 1]] # Sum: 0.5+(-0.5)+(-1)+1 => 0.0 assert transpose_and_sum([[0.5, -0.5], [-1, 1]]) == 0.0 # Matrix transposition: # Input: [[1, 2, 3], [4, 5, 6]] # Transposed: [[1, 4], [2, 5], [3, 6]] # Sum: 1+2+3+4+5+6 => 21 assert transpose_and_sum([[1, 2, 3], [4, 5, 6]]) == 21 # Matrix transposition: # Input: [[1]] # Transposed: [[1]] # Sum: 1 assert transpose_and_sum([[1]]) == 1 ``` **Note**: Be sure to handle invalid inputs gracefully by raising appropriate errors.","solution":"def transpose_and_sum(matrix): Transpose the given matrix and calculate the sum of all its elements. Parameters: matrix : list of lists A 2D list (matrix) where each inner list represents a row of the matrix. Returns: float : The sum of all elements in the transposed matrix. Raises: ValueError : If the input is not a list of lists or is not rectangular. if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists.\\") row_length = len(matrix[0]) if not all(len(row) == row_length for row in matrix): raise ValueError(\\"All rows in the matrix must have the same length.\\") transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(row_length)] return sum(sum(row) for row in transposed_matrix)"},{"question":"You are tasked with writing a Python function that simulates a digital clock display. The digital clock displays the time in a 24-hour format (HH:MM format). Your function should take two integers representing the hours and minutes, and return a string representing the time in the format \\"HH:MM\\". You must ensure that the hours are in the range 0-23 and the minutes are in the range 0-59, otherwise a `ValueError` should be raised. # Function Signature ```python def digital_clock(hours: int, minutes: int) -> str: Format the given hours and minutes into a 24-hour digital clock format. :param hours: The hour value (0 through 23). :param minutes: The minute value (0 through 59). :return: The formatted time as a string in \\"HH:MM\\" format. Examples: >>> digital_clock(0, 0) \'00:00\' >>> digital_clock(13, 5) \'13:05\' >>> digital_clock(23, 59) \'23:59\' >>> digital_clock(24, 0) Traceback (most recent call last): ... ValueError: Hours must be in the range 0-23 and minutes must be in the range 0-59 >>> digital_clock(12, 60) Traceback (most recent call last): ... ValueError: Hours must be in the range 0-23 and minutes must be in the range 0-59 ``` # Constraints 1. The value for `hours` must be between 0 and 23 (inclusive). 2. The value for `minutes` must be between 0 and 59 (inclusive). 3. If `hours` or `minutes` are out of the specified ranges, raise a `ValueError`. # Task Implement the `digital_clock` function so that it correctly formats the given hours and minutes into a 24-hour time display, with proper error handling for invalid inputs.","solution":"def digital_clock(hours: int, minutes: int) -> str: Format the given hours and minutes into a 24-hour digital clock format. :param hours: The hour value (0 through 23). :param minutes: The minute value (0 through 59). :return: The formatted time as a string in \\"HH:MM\\" format. :raises: ValueError if hours are not in the range 0-23 or minutes are not in the range 0-59. if not (0 <= hours <= 23) or not (0 <= minutes <= 59): raise ValueError(\\"Hours must be in the range 0-23 and minutes must be in the range 0-59\\") return f\\"{hours:02}:{minutes:02}\\""},{"question":"# Find Kth Largest Element in an Array Scenario You are tasked with developing software for data analysis which includes finding the k-th largest element in a list of numbers. This is a common requirement in statistical analysis and data processing workflows. Task Write a function `find_kth_largest(nums: List[int], k: int) -> int` that takes a list of integers and an integer `k`, and returns the k-th largest element in the list. Input The function will receive the following parameters: - `nums`: a list of integers where the i-th element can be any integer. - `k`: an integer representing the position (1-based) of the largest element to find. Output The function should return an integer: - The k-th largest element in the list `nums`. Constraints - `1 ≤ len(nums) ≤ 10^4` - `-10^4 ≤ nums[i] ≤ 10^4` - It is guaranteed that `k` is always valid (1 ≤ k ≤ len(nums)). Example ```python # Example 1 nums = [3, 2, 1, 5, 6, 4] k = 2 find_kth_largest(nums, k) # Output: 5 # Example 2 nums = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 find_kth_largest(nums, k) # Output: 4 ``` # Additional Notes - You may assume that the input list `nums` will not be modified. - Aim for efficient solutions, as the input list can be large. - Explore different approaches like sorting, using a heap, or quickselect algorithm for optimized performance.","solution":"from typing import List import heapq def find_kth_largest(nums: List[int], k: int) -> int: Finds the k-th largest element in the list nums. # Using the n-largest function to find the k-th largest element return heapq.nlargest(k, nums)[-1]"},{"question":"Problem Statement You are tasked with developing a function that, given a list of integers, determines the smallest window that must be sorted (in ascending order) so that the entire list becomes sorted. The function should return the starting and ending indices of this window. If the list is already sorted, return (-1, -1). # Function Signature ```python def find_unsorted_subarray(nums: List[int]) -> Tuple[int, int]: ``` # Input - `nums`: A list of integers. # Output - Return a tuple of two integers representing the starting and ending indices of the smallest window that needs to be sorted. # Constraints - The length of the list will be between 1 and 10^4. - All integers in the list will be in the range [-10^5, 10^5]. # Example Consider the list: ``` nums = [2, 6, 4, 8, 10, 9, 15] ``` For this list: ```python assert find_unsorted_subarray(nums) == (1, 5) # Sorting from index 1 to 5 would make the whole array sorted. ``` Consider the list: ``` nums = [1, 2, 3, 4] ``` For this list: ```python assert find_unsorted_subarray(nums) == (-1, -1) # The whole list is already sorted. ``` # Notes - Pay attention to efficiency, especially for the upper bounds of 10^4 elements. - The problem assesses the student\'s ability to detect unsorted segments and their approach to minimizing the sorting window. - Edge cases include lists that might be entirely sorted or have only a single element perturbation.","solution":"from typing import List, Tuple def find_unsorted_subarray(nums: List[int]) -> Tuple[int, int]: n = len(nums) start, end = 0, -1 max_seen, min_seen = float(\'-inf\'), float(\'inf\') # Traverse from the start to identify the end of the window for i in range(n): max_seen = max(max_seen, nums[i]) if nums[i] < max_seen: end = i # Traverse from the end to identify the start of the window for i in range(n - 1, -1, -1): min_seen = min(min_seen, nums[i]) if nums[i] > min_seen: start = i if end == -1: # The array is already sorted return (-1, -1) else: return (start, end)"},{"question":"# Most Frequent Element in Subarray Ranges You are given an array of integers and a list of subarray ranges. For each subarray range, find the element that appears most frequently within that subarray. If more than one element has the maximum frequency, return the smallest one. Implement a function `most_frequent_element_in_subarrays` which takes a list of integers `arr` and a list of tuples `ranges`. Each tuple contains two integers, representing the start and end indices of a subarray. Return a list of integers where each integer is the most frequent element in the corresponding subarray defined by the ranges. Input: * A list of integers `arr` of size up to 10^5. * A list of tuples `ranges` where each tuple contains two integers representing subarray ranges. The number of ranges is up to 10^3. Output: * A list of integers representing the most frequent elements in each subarray range. Constraints: * The array can contain positive or negative integers, as well as zero. * The subarray ranges are inclusive and 0-based. * Each subarray range is valid within the bounds of the array. Example ```python arr = [3, 1, 4, 4, 5, 2, 6, 1, 1, 1] ranges = [(2, 5), (3, 9)] output = [4, 1] arr = [1, 2, 2, 3, 3, 3, 4, 4] ranges = [(0, 3), (2, 6)] output = [2, 3] ``` # Notes: 1. Ensure your implementation handles edge cases, like subarrays with all elements being the same. 2. Focus on performance to handle the constraint limits efficiently. 3. Implement and utilize a helper function if needed to manage repeated range queries effectively. Below is a skeleton code to get you started: ```python def most_frequent_element_in_subarrays(arr: list[int], ranges: list[tuple[int, int]]) -> list[int]: # Your implementation here pass # Example usage: if __name__ == \\"__main__\\": arr = [3, 1, 4, 4, 5, 2, 6, 1, 1, 1] ranges = [(2, 5), (3, 9)] print(most_frequent_element_in_subarrays(arr, ranges)) # Output: [4, 1] ``` Your task is to complete the function `most_frequent_element_in_subarrays`.","solution":"def most_frequent_element_in_subarrays(arr, ranges): from collections import Counter result = [] for start, end in ranges: subarray = arr[start:end + 1] frequency = Counter(subarray) most_common = frequency.most_common() max_frequency = most_common[0][1] candidate_elements = [elem for elem, freq in most_common if freq == max_frequency] result.append(min(candidate_elements)) return result"},{"question":"# Coding Assessment Question Context You are given an array of integers, and your task is to determine a specific numeric property of this array by performing mathematical operations on its subarrays. Problem Statement Given an array `arr` of integers of length `n`, compute and return the maximum product of a contiguous subarray in the array. Write a function `max_product_subarray` that implements this computation. Function Signature ```python def max_product_subarray(arr: list) -> int: Returns the maximum product of a contiguous subarray within the given array of integers. Args: arr : list : a list of integers with length \'n\' (1 ≤ n ≤ 10^4) Returns: int: The maximum product obtained from any of the contiguous subarrays. pass ``` Constraints - The input list `arr` will contain at least one integer. - The length of the array ( n ) will be such that ( 1 le n le 10^4 ). - The elements of the array will be in the range ([-10^2, 10^2]). Examples ```python # Example 1 print(max_product_subarray([2, 3, -2, 4])) # Output: 6 Explanation: The subarray [2, 3] has the largest product 6. # Example 2 print(max_product_subarray([-2, 0, -1])) # Output: 0 Explanation: The result cannot be 2 because [-2, -1] is not a subarray. # Example 3 print(max_product_subarray([-2, -3, 0, -2, -40])) # Output: 80 Explanation: The subarray [-2, -40] has the largest product 80. ``` **Note**: The function should efficiently handle arrays up to the maximum constraint.","solution":"def max_product_subarray(arr: list) -> int: Returns the maximum product of a contiguous subarray within the given array of integers. Args: arr : list : a list of integers with length \'n\' (1 ≤ n ≤ 10^4) Returns: int: The maximum product obtained from any of the contiguous subarrays. if not arr: return 0 max_so_far = arr[0] min_so_far = arr[0] result = arr[0] for i in range(1, len(arr)): curr = arr[i] temp_max = max(curr, max_so_far * curr, min_so_far * curr) min_so_far = min(curr, max_so_far * curr, min_so_far * curr) max_so_far = temp_max result = max(result, max_so_far) return result"},{"question":"# Question: Implement Custom Data Structure and Optimize Operations of a Trie Context You are provided with a Trie (prefix tree) that supports insertion and search operations. Your task involves extending the Trie functionality to support additional operations while also optimizing the existing implementation for both time and space. Task 1. **Extend Operations**: Enhance the Trie to include operations for deleting a word, checking for prefixes, and finding all words with a given prefix in a sorted manner. 2. **Optimization**: Optimize the current implementation of insertion, search, and the new operations to minimize time complexity. 3. **Space Efficiency**: Ensure that the Trie implementation is space-efficient, particularly focusing on reducing the memory footprint of nodes. Requirements 1. **New Operations**: * `delete_word(word: str) -> bool`: Remove a word from the Trie. It should return `True` if the word was successfully deleted and `False` if the word did not exist. * `check_prefix(prefix: str) -> bool`: Check if any word in the Trie starts with the given prefix. * `find_with_prefix(prefix: str) -> List[str]`: Find and return all words starting with the provided prefix, sorted lexically. 2. **Optimization**: * Ensure the operations (insertion, search, delete, check prefix, and find with prefix) are optimized for both time and space. * Implement techniques to reduce the time complexity for searching and inserting words. 3. **Space Efficiency**: * Reduce redundant nodes in the Trie by implementing node-sharing where appropriate. * Avoid excessive memory usage, particularly when handling large datasets. Input/Output Here is an example of how the extended operations should be used: ```python >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") True >>> trie.delete_word(\\"apple\\") True >>> trie.search(\\"apple\\") False >>> trie.check_prefix(\\"ap\\") True >>> trie.find_with_prefix(\\"ap\\") [\'app\'] >>> trie.insert(\\"ape\\") >>> trie.insert(\\"apricot\\") >>> trie.find_with_prefix(\\"ap\\") [\'ape\', \'app\', \'apricot\'] ``` Constraints * Words contain only lowercase alphabetical characters. * All operations are case-insensitive. * Ensure memory efficiency especially when dealing with large collections of words.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._search_prefix(word) return node is not None and node.is_end_of_word def delete_word(self, word: str) -> bool: def _delete(node, word, depth): if node is not None: if depth == len(word): if not node.is_end_of_word: return False node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if _delete(node.children.get(char), word, depth + 1): del node.children[char] return not node.is_end_of_word and len(node.children) == 0 return False return _delete(self.root, word, 0) def check_prefix(self, prefix: str) -> bool: return self._search_prefix(prefix) is not None def find_with_prefix(self, prefix: str) -> list: result = [] node = self._search_prefix(prefix) self._dfs(node, prefix, result) return sorted(result) def _search_prefix(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node def _dfs(self, node, prefix, result): if node is None: return if node.is_end_of_word: result.append(prefix) for char, child_node in node.children.items(): self._dfs(child_node, prefix + char, result)"},{"question":"# Coding Assessment Question Context: You are building a basic integer calculator that supports addition, subtraction, multiplication, and division operations. The calculator should read from a given list of operations. Each operation will be a tuple where: - the first element is a string indicating the operation: `\\"add\\"`, `\\"sub\\"`, `\\"mul\\"`, or `\\"div\\"`. - the second and third elements are integers on which the operation should be performed. The calculator should process each operation in the list sequentially and store the results in an output list. Task: Implement a function `process_operations` that takes a list of operations and returns a list of results for each operation. The function should handle division by zero by returning `None` for such cases and continue processing the subsequent operations. Expected Input and Output Formats: Function signature: ```python def process_operations(operations: list) -> list: # your implementation here ``` - **Input**: `operations` (list of tuples) - List of operations. Each tuple is in the format `(operation: str, operand1: int, operand2: int)`. - **Output**: A list of results (integers or `None` for division by zero). Constraints and Assumptions: - The operations list will have at least one and at most 1000 operations. - Each operation is guaranteed to have a valid format `(operation: str, operand1: int, operand2: int)`. - Operations are \\"add\\", \\"sub\\", \\"mul\\", and \\"div\\" only. - Operand values are between -10^6 and 10^6. Example: ```python operations = [ (\\"add\\", 1, 2), (\\"sub\\", 10, 5), (\\"mul\\", 3, 4), (\\"div\\", 8, 2), (\\"div\\", 10, 0) ] result = process_operations(operations) print(result) # Expected Output: [3, 5, 12, 4, None] ``` Implementation Example: ```python def process_operations(operations): results = [] for op in operations: oper, operand1, operand2 = op if oper == \\"add\\": results.append(operand1 + operand2) elif oper == \\"sub\\": results.append(operand1 - operand2) elif oper == \\"mul\\": results.append(operand1 * operand2) elif oper == \\"div\\": if operand2 != 0: results.append(operand1 // operand2) else: results.append(None) return results ``` Additional Notes: - Use integer division for the \\"div\\" operation. - Consider edge cases such as division by zero or extremely large/small operand values that are within the given constraints.","solution":"def process_operations(operations): results = [] for op in operations: oper, operand1, operand2 = op if oper == \\"add\\": results.append(operand1 + operand2) elif oper == \\"sub\\": results.append(operand1 - operand2) elif oper == \\"mul\\": results.append(operand1 * operand2) elif oper == \\"div\\": if operand2 != 0: results.append(operand1 // operand2) else: results.append(None) return results"},{"question":"# Programming Assessment Question **Context**: You are developing a social media platform, and one of the functionalities is to identify trending hashtags. To implement this, you need to find the top K most frequently occurring hashtags from user posts. Each post can contain multiple hashtags. **Task**: Implement a function `top_k_trending_hashtags()` that finds the top K most frequent hashtags from a given list of posts using a min-heap. Function Signature: ```python def top_k_trending_hashtags(posts: list[str], k: int) -> list[str]: pass ``` Input: * `posts`: List of strings, where each string represents a user post which includes hashtags. Each hashtag starts with \'#\' and is followed by alphanumeric characters. * `k`: Integer, representing the number of top trending hashtags to return. Output: * List of strings, representing the top K trending hashtags, sorted in non-increasing order of their frequency. Constraints: * The input list `posts` will contain at most 500,000 posts. * Each post has a maximum length of 280 characters. * The value of `k` will be a non-negative integer. * A hashtag can appear multiple times in a single post. Each appearance should count separately. Requirements: * Use a min-heap to efficiently determine the most frequent hashtags. * If `k` is greater than the number of distinct hashtags, return all distinct hashtags sorted by frequency. * If the list of `posts` is empty or `k` is 0, return an empty list. Example: ```python top_k_trending_hashtags([\'#summer #vacation\', \'#vacation #fun #summer\', \'#fun #fun #beach\'], 2) # Output: [\'#fun\', \'#summer\'] top_k_trending_hashtags([\'#happy #day\', \'#happy\', \'#joy\'], 1) # Output: [\'#happy\'] top_k_trending_hashtags([], 1) # Output: [] ``` Additional Notes: * Focus on the efficiency of your solution by ensuring the min-heap operations are correct and performant. * Consider edge cases such as empty post list and `k` larger than the number of distinct hashtags carefully. * Ensure the function handles the constraints correctly and efficiently.","solution":"import heapq from collections import Counter import re def top_k_trending_hashtags(posts, k): if k == 0 or not posts: return [] hashtag_counter = Counter() hashtag_pattern = re.compile(r\'#w+\') for post in posts: hashtags = hashtag_pattern.findall(post) hashtag_counter.update(hashtags) if k >= len(hashtag_counter): return [tag for tag, _ in hashtag_counter.most_common()] return [tag for tag, _ in hashtag_counter.most_common(k)]"},{"question":"# Rotated Array Search You are given a sorted array that has been rotated at an unknown pivot. Your task is to implement a function to find the index of a given target value within this rotated array. If the target cannot be found, return `-1`. 1. **find_in_rotated_array(nums, target)**: - **Input**: A list of integers `nums` that has been rotated and an integer `target`. - **Output**: Return the index of `target` if it is in `nums`, otherwise return `-1`. - **Constraints**: * The array `nums` does not contain duplicates. * Elements in the array are in ascending order but may have been shifted due to rotation. **Function Signature**: ```python def find_in_rotated_array(nums: list[int], target: int) -> int: pass ``` # Example ```python # Example usage: nums1 = [4, 5, 6, 7, 0, 1, 2] target1 = 0 assert find_in_rotated_array(nums1, target1) == 4 nums2 = [4, 5, 6, 7, 0, 1, 2] target2 = 3 assert find_in_rotated_array(nums2, target2) == -1 nums3 = [1] target3 = 0 assert find_in_rotated_array(nums3, target3) == -1 nums4 = [1] target4 = 1 assert find_in_rotated_array(nums4, target4) == 0 ``` **Note**: - Your implementation should be efficient, with time complexity ideally being O(log n).","solution":"def find_in_rotated_array(nums: list[int], target: int) -> int: This method returns the index of the target in a rotated sorted array. If the target does not exist in the array, it returns -1. left, right = 0, len(nums) - 1 while left <= right: middle = (left + right) // 2 if nums[middle] == target: return middle # Check if left part is sorted if nums[left] <= nums[middle]: if nums[left] <= target < nums[middle]: # Target is in the left part right = middle - 1 else: left = middle + 1 else: # Right part is sorted if nums[middle] < target <= nums[right]: # Target is in the right part left = middle + 1 else: right = middle - 1 return -1"},{"question":"# Question: Implement a Snake Case Converter Problem Statement You are required to implement a function that converts a given string to snake_case. Snake case is a naming convention where each word is in lowercase and separated by underscores. Words can be separated by spaces, hyphens, or can be joined together in camelCase or PascalCase. Function Signature ```python def to_snake_case(s: str) -> str: ``` Input * **s**: A string containing alphabetic characters and potentially spaces or other delimiters. The input string can be of length 0 to 10^5. Output * Returns a new string where the input is converted to snake_case. Constraints * The input string will consist of English letters and separator characters (spaces, hyphens, or camelCase formats). * There will be no punctuation or numerical digits in the input string. Examples ```python >>> to_snake_case(\\"ThisIsCamelCase\\") \'this_is_camel_case\' >>> to_snake_case(\\"this-is-snake-case\\") \'this_is_snake_case\' >>> to_snake_case(\\"Some Mixed-caseFormat\\") \'some_mixed_case_format\' >>> to_snake_case(\\"singleword\\") \'singleword\' >>> to_snake_case(\\" ALittle Bit of Space \\") \'a_little_bit_of_space\' ``` Instructions 1. Handle the conversion of camelCase and PascalCase to snake_case by appropriately inserting underscores and lowercasing characters. 2. Convert any hyphens and spaces to underscores. 3. Ensure that the function is efficient and handles input strings of length up to 10^5. Additional Information * You may utilize helper functions if required, but the main logic should reside in the `to_snake_case` function. * Avoid using built-in functions that directly perform this conversion, your implementation should demonstrate the steps manually.","solution":"import re def to_snake_case(s: str) -> str: Converts a given string to snake_case. Words are lowercase and separated by underscores. Words can be separated by spaces, hyphens, or joined in camelCase or PascalCase. # Handle camelCase and PascalCase by inserting underscores before uppercase letters s = re.sub(r\'([a-z0-9])([A-Z])\', r\'1_2\', s) s = re.sub(r\'([A-Z])([A-Z][a-z0-9])\', r\'1_2\', s) # Replace spaces and hyphens with underscores s = re.sub(r\'[s-]+\', \'_\', s) # Convert entire string to lowercase s = s.lower() # Remove leading and trailing underscores, if any s = s.strip(\'_\') return s"},{"question":"# Implement a Stack Using a Queue Scenario You are tasked with implementing a stack data structure using two queues. The stack should support standard push, pop, and top operations, as well as checking if the stack is empty. Requirements Implement the `QueueStack` with the following methods: 1. **`__init__(self)`**: Initialize the stack using two queues. 2. **`push(self, x)`**: Push element x onto the stack. 3. **`pop(self)`**: Remove the element on top of the stack and return it. 4. **`top(self)`**: Get the top element of the stack without removing it. 5. **`is_empty(self)`**: Return `True` if the stack is empty, `False` otherwise. Input and Output Format - The stack will handle integer elements. - **Input**: You will receive a sequence of operations in the format: - `\\"push x\\"` to push an element onto the stack. - `\\"pop\\"` to remove the top element of the stack. - `\\"top\\"` to retrieve the top element of the stack without removing it. - `\\"is_empty\\"` to check if the stack is empty. - `\\"exit\\"` to end the operations sequence. - **Output**: For each pop operation, print the removed element. For each top operation, print the current top element. For each is_empty operation, print `True` or `False` depending on whether the stack is empty. Constraints - All operations must be performed using the two queues. - Assume all input and stack elements are non-negative integers. Function Signature ```python from collections import deque from typing import List, Optional class QueueStack: def __init__(self): pass def push(self, x: int): pass def pop(self) -> Optional[int]: pass def top(self) -> Optional[int]: pass def is_empty(self) -> bool: pass def process_operations(operations: List[str]) -> List[str]: pass ``` Example ```python qs = QueueStack() qs.push(10) qs.push(20) print(qs.top()) # Output: 20 print(qs.pop()) # Output: 20 print(qs.is_empty()) # Output: False qs.push(30) print(qs.pop()) # Output: 30 print(qs.pop()) # Output: 10 print(qs.is_empty()) # Output: True ``` Implement the `QueueStack` and ensure it handles all edge cases and performance requirements as described.","solution":"from collections import deque from typing import List, Optional class QueueStack: def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int): self.queue1.append(x) def pop(self) -> Optional[int]: if self.is_empty(): return None while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) popped_element = self.queue1.popleft() self.queue1, self.queue2 = self.queue2, self.queue1 return popped_element def top(self) -> Optional[int]: if self.is_empty(): return None while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1[0] self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def is_empty(self) -> bool: return not self.queue1 def process_operations(operations: List[str]) -> List[str]: result = [] qs = QueueStack() for op in operations: if \'push\' in op: _, num = op.split() qs.push(int(num)) elif op == \'pop\': result.append(str(qs.pop())) elif op == \'top\': result.append(str(qs.top())) elif op == \'is_empty\': result.append(str(qs.is_empty())) elif op == \'exit\': break return result"},{"question":"# Coding Assessment Question **Context**: You are tasked with developing part of an online bookstore\'s system. The system should manage an inventory of books, process transactions, and provide efficient lookups for available books based on various criteria. **Objective**: Write a class `BookStore` that manages the inventory of books and allows for efficient querying and book transaction processing. This class should support the following operations: 1. **Initialize**: `__init__(self, books: List[Tuple[str, str, int]])` - Initializes the bookstore with a list of books, where each book is represented as a tuple containing the title (str), author (str), and number of copies (int). 2. **Add Book**: `add_book(self, title: str, author: str, copies: int)` - Adds a specified number of copies of a book to the inventory. 3. **Sell Book**: `sell_book(self, title: str, copies: int) -> bool` - Sells a specified number of copies of a book, returning True if the transaction is successful and False if there are insufficient copies. 4. **Books by Author**: `books_by_author(self, author: str) -> List[str]` - Returns a list of titles by the specified author. 5. **Total Inventory**: `total_inventory(self) -> int` - Returns the total number of books in the inventory. **Input/Output Formats**: * **Input**: * Initialization: `__init__(self, books: List[Tuple[str, str, int]])` - books (List of tuples, each containing title, author, and number of copies). * Add Book: `add_book(self, title: str, author: str, copies: int)` - title (string), author (string), copies (integer). * Sell Book: `sell_book(self, title: str, copies: int)` - title (string), copies (integer). * Books by Author: `books_by_author(self, author: str)` - author (string). * Total Inventory: `total_inventory(self)` - no parameters. * **Output**: * `sell_book(self, title: str, copies: int) -> bool` - Boolean indicating success or failure. * `books_by_author(self, author: str) -> List[str]` - List of titles. * `total_inventory(self) -> int` - Total number of books. **Performance Requirements**: * All operations should be efficient, aimed for logarithmic or better time complexity where applicable. * The `books_by_author` method should preferably operate in **O(M)** time complexity, where M is the number of books by the specified author. **Constraints**: * The bookstore\'s initial inventory will contain between 1 and 10^4 books. * Number of book copies is an integer between 0 and 10^3. * Number of `add_book`, `sell_book`, `books_by_author`, and `total_inventory` operations will be less than or equal to 10^4. **Example**: ```python # Initialize the bookstore initial_books = [(\\"Pride and Prejudice\\", \\"Jane Austen\\", 10), (\\"1984\\", \\"George Orwell\\", 5), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 8)] bookstore = BookStore(initial_books) # Add book bookstore.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) # Sell books assert bookstore.sell_book(\\"1984\\", 2) == True assert bookstore.sell_book(\\"1984\\", 4) == False # Query books by author assert bookstore.books_by_author(\\"George Orwell\\") == [\\"1984\\"] assert bookstore.books_by_author(\\"F. Scott Fitzgerald\\") == [\\"The Great Gatsby\\"] # Get total inventory assert bookstore.total_inventory() == 26 ```","solution":"from typing import List, Tuple, Dict class BookStore: def __init__(self, books: List[Tuple[str, str, int]]): self.inventory = {} # Store books by title self.authors = {} # Store authors and their books for title, author, copies in books: self.add_book(title, author, copies) def add_book(self, title: str, author: str, copies: int): if title in self.inventory: self.inventory[title][1] += copies else: self.inventory[title] = [author, copies] if author in self.authors: self.authors[author].append(title) else: self.authors[author] = [title] def sell_book(self, title: str, copies: int) -> bool: if title in self.inventory and self.inventory[title][1] >= copies: self.inventory[title][1] -= copies return True return False def books_by_author(self, author: str) -> List[str]: return self.authors.get(author, []) def total_inventory(self) -> int: return sum(copies for _, copies in self.inventory.values())"},{"question":"# Question You are designing a task management system where tasks are prioritized based on their importance and deadline. Each task has a `priority` level (an integer where a higher number means higher priority) and a `deadline` (a datetime object). Your system must allow adding new tasks, and retrieving tasks based on their priority and deadline. Function Specifications: 1. **add_task(task_name: str, priority: int, deadline: datetime) -> None** * Adds a new task with the given `task_name`, `priority`, and `deadline` to the task management system. 2. **get_next_task() -> Tuple[str, int, datetime]** * Retrieves the task with the highest priority that is due the soonest. * If there are multiple tasks with the same priority and deadline, returns any one of them. 3. **remove_task(task_name: str) -> bool** * Removes a task by its `task_name`. * Returns `True` if the task was successfully removed, or `False` if the task was not found. Input/Output Requirements: * Tasks will be managed in memory (i.e., you don\'t need to persist data to a file or database). * `task_name` is a unique string identifier for the task. * `priority` is an integer. * `deadline` is a datetime object from the `datetime` module. * If `get_next_task` is called with no tasks available, it should return `None`. Constraints: * Ensure that adding tasks and removing tasks both run in O(1) time complexity. * Retrieving the next task should run in O(log n) time complexity, where n is the number of tasks. * Use the `heapq` module to manage tasks efficiently. Example: ```python from datetime import datetime import heapq class TaskManager: def __init__(self): self.tasks = [] self.task_map = {} def add_task(self, task_name, priority, deadline): entry = (priority, deadline, task_name) heapq.heappush(self.tasks, entry) self.task_map[task_name] = entry def get_next_task(self): while self.tasks: priority, deadline, task_name = heapq.heappop(self.tasks) if task_name in self.task_map: del self.task_map[task_name] return task_name, priority, deadline return None def remove_task(self, task_name): if task_name in self.task_map: entry = self.task_map.pop(task_name) self.tasks.remove(entry) heapq.heapify(self.tasks) return True return False # Test TaskManager class def test_task_manager(): tm = TaskManager() tm.add_task(\\"Task1\\", 2, datetime(2023, 10, 4, 10, 0)) tm.add_task(\\"Task2\\", 1, datetime(2023, 10, 3, 12, 0)) tm.add_task(\\"Task3\\", 2, datetime(2023, 10, 4, 9, 0)) assert tm.get_next_task() == (\\"Task3\\", 2, datetime(2023, 10, 4, 9, 0)) assert tm.remove_task(\\"Task1\\") == True assert tm.remove_task(\\"Task1\\") == False assert tm.get_next_task() == (\\"Task2\\", 1, datetime(2023, 10, 3, 12, 0)) test_task_manager() ``` Additional Context: This system will help a team manage their tasks efficiently by always working on the most urgent and important tasks first. This is particularly useful in a collaborative environment where team members need to be aware of the most pressing tasks. Implement the mentioned functions ensuring that task addition, retrieval, and removal work correctly and efficiently.","solution":"import heapq from datetime import datetime from typing import Dict, Tuple, Optional class TaskManager: def __init__(self): self.tasks_heap = [] self.task_map: Dict[str, Tuple[int, datetime, str]] = {} def add_task(self, task_name: str, priority: int, deadline: datetime) -> None: task = (-priority, deadline, task_name) heapq.heappush(self.tasks_heap, task) self.task_map[task_name] = task def get_next_task(self) -> Optional[Tuple[str, int, datetime]]: while self.tasks_heap: priority, deadline, task_name = heapq.heappop(self.tasks_heap) if task_name in self.task_map: del self.task_map[task_name] return (task_name, -priority, deadline) return None def remove_task(self, task_name: str) -> bool: if task_name in self.task_map: del self.task_map[task_name] return True return False"},{"question":"# **Coding Assessment Question** **Objective**: You are required to efficiently implement Conway\'s Game of Life algorithm for extremely large grids. The given implementation should update cell behaviors according to the classic rules, with an emphasis on handling large datasets effectively. **Problem Statement**: Implement a modified version of the `GameOfLife` class to simulate the game on a vast grid while ensuring performance is optimized. Additionally, add functionality to load an initial configuration from a file and handle the edges of the grid using a toroidal array. **Function Signature**: ```python class GameOfLife: def __init__(self, width: int, height: int) -> None: def load_initial_state(self, file_path: str) -> None: def evolve(self) -> None: def display(self, steps: int = 100) -> None: ``` **Input Format**: - Initialize `GameOfLife` with width and height of the grid. - Load the initial state from a file, where `file_path` is the path to a text file containing initial live cell coordinates. - The file format is as follows: each line contains two integers x and y separated by a space, each representing the coordinates of a live cell. - Evolve the grid for the specified number of steps using the `display` method. **Output Format**: - No direct output. The board state is updated internally and visualization displayed using `matplotlib` or similar tools. **Constraints**: - width, height ≤ 10^4. - The file is guaranteed to contain valid coordinates within the grid dimensions. **Performance Requirements**: - Optimize both time and space. Use efficient data structures to manage large grids. - Implement toroidal array behavior to wrap cells around the grid edges seamlessly. **Example Usage**: ```python gol = GameOfLife(10_000, 10_000) gol.load_initial_state(\'initial_state.txt\') gol.display(steps=100) ``` **Additional Notes**: - Focus on both initial state handling from a file and optimizing the evolution process for large grids. - Incorporate sparse data representation where feasible to manage space efficiently. - Ensure the implementation correctly follows Conway\'s Game of Life rules and manages edge cases appropriately. The implementation should prioritize performance and correctness on large grids, handling the computations in an efficient manner while allowing for proper visualization and edge wrapping.","solution":"import numpy as np class GameOfLife: def __init__(self, width: int, height: int) -> None: self.width = width self.height = height self.grid = np.zeros((height, width), dtype=bool) def load_initial_state(self, file_path: str) -> None: with open(file_path, \'r\') as f: for line in f: x, y = map(int, line.split()) self.grid[y][x] = True def evolve(self) -> None: new_grid = np.zeros((self.height, self.width), dtype=bool) for y in range(self.height): for x in range(self.width): live_neighbors = self._live_neighbor_count(x, y) if self.grid[y][x]: if live_neighbors == 2 or live_neighbors == 3: new_grid[y][x] = True else: if live_neighbors == 3: new_grid[y][x] = True self.grid = new_grid def _live_neighbor_count(self, x: int, y: int) -> int: neighbors = [ ((x - 1) % self.width, (y - 1) % self.height), (x, (y - 1) % self.height), ((x + 1) % self.width, (y - 1) % self.height), ((x - 1) % self.width, y), ((x + 1) % self.width, y), ((x - 1) % self.width, (y + 1) % self.height), (x, (y + 1) % self.height), ((x + 1) % self.width, (y + 1) % self.height) ] return sum(self.grid[ny][nx] for nx, ny in neighbors) def display(self, steps: int = 100) -> None: import matplotlib.pyplot as plt import matplotlib.animation as animation fig, ax = plt.subplots() mat = ax.matshow(self.grid, cmap=\'binary\') def update(data): self.evolve() mat.set_data(self.grid) return [mat] ani = animation.FuncAnimation(fig, update, interval=50, save_count=steps) plt.show()"},{"question":"# Matrix Rotation Challenge You are given a square matrix of integers. The task is to rotate the matrix 90 degrees clockwise in place. The matrix is represented as a 2D list and you should modify it directly without using additional space. Requirements: 1. **Function**: Implement the function `rotate_matrix(matrix: List[List[int]]) -> None` which takes the square matrix and rotates it 90 degrees clockwise. 2. **In-place Modification**: Modify the matrix in-place without using additional storage space for another matrix. 3. **Swap Operations**: The rotation should be achieved by a series of element swaps. # Input: * `matrix: List[List[int]]` - A 2D list representing the square matrix. # Output: * No return value is required as the matrix should be modified in-place. # Constraints: * The size of the matrix (`n x n`) will not exceed `100 x 100`. * Each element in the matrix is an integer within the 32-bit signed integer range. # Example: Given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` After rotating 90 degrees clockwise, the matrix should become: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Note: - Ensure that the rotation algorithm handles corner cases, such as matrices of size 1x1 or 2x2 correctly. - Avoid using additional data structures to maintain the in-place requirement. - You can use helper functions for clean and understandable code but ensure the primary logic complies with the constraints. Good luck and happy coding!","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates a square matrix 90 degrees clockwise in-place. Args: matrix (List[List[int]]): 2D list representing the square matrix. Returns: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# String Permutation Check **Problem Statement**: You need to implement a function `are_permutations(s1: str, s2: str) -> bool` that checks if two given strings are permutations of each other. Two strings are considered permutations if they contain the same characters with the same frequencies. **Input and Output**: - **Input**: Two strings `s1` and `s2`. - **Output**: Returns `True` if the strings are permutations of each other, `False` otherwise. **Constraints**: - The input strings will only contain lowercase English letters. - The length of each string can be up to 1000 characters. **Examples**: ```python def are_permutations(s1: str, s2: str) -> bool: # Your implementation here print(are_permutations(\\"abc\\", \\"bca\\")) # True print(are_permutations(\\"apple\\", \\"pplae\\")) # True print(are_permutations(\\"hello\\", \\"bello\\")) # False print(are_permutations(\\"anagram\\", \\"nagaram\\")) # True print(are_permutations(\\"test\\", \\"tset\\")) # True print(are_permutations(\\"test\\", \\"tsett\\")) # False ``` **Guidelines**: 1. Verify that the lengths of the two strings are the same. If not, return `False`. 2. Use a collections.Counter or another method to count the frequency of each character in both strings. 3. Compare the frequency counts of both strings. If they match, return `True`; otherwise, return `False`. 4. Ensure the solution handles different scenarios (e.g., empty strings, strings with repeated characters).","solution":"from collections import Counter def are_permutations(s1: str, s2: str) -> bool: if len(s1) != len(s2): return False return Counter(s1) == Counter(s2)"},{"question":"# Problem Statement You are given a list of integers. Your task is to implement a function that finds all unique pairs in the list which sum up to a specific target value. The order of the pairs and the numbers within each pair do not matter, but each pair should be a distinct combination. # Implementation Details * Function Name: `find_target_sum_pairs` * Input: * A list of integers `nums` (e.g., `[1, 2, 3, 4, 5, 6]`) * An integer `target` (e.g., `7`) * Output: A list of lists where each sublist contains exactly two integers that sum to the target value (e.g., `[[1, 6], [2, 5], [3, 4]]`) # Constraints 1. Your function should handle an empty list by returning an empty list. 2. If there are fewer than two elements in the input list, return an empty list. 3. The solution should leverage hashing to achieve a time complexity of O(N). 4. Avoid returning duplicate pairs in any order. # Example ```python def find_target_sum_pairs(nums: list[int], target: int) -> list[list[int]]: # Your implementation here # Test Cases print(find_target_sum_pairs([1, 2, 3, 4, 5, 6], 7)) # Expected: [[1, 6], [2, 5], [3, 4]] print(find_target_sum_pairs([], 7)) # Expected: [] print(find_target_sum_pairs([1, 2], 3)) # Expected: [[1, 2]] print(find_target_sum_pairs([1, 2, 2, 3], 4)) # Expected: [[1, 3], [2, 2]] ``` **Restrictions**: * Solve the problem without using itertools. * Ensure the returned list is in the non-decreasing order of the elements. # Notes 1. Consider implementing helper functions if needed to enhance clarity. 2. Carefully handle edge cases and duplicates to ensure the correctness of the solution.","solution":"def find_target_sum_pairs(nums, target): Finds all unique pairs in the list which sum up to a specific target value. result = set() seen = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) result.add(pair) seen.add(num) return [list(pair) for pair in result]"},{"question":"# Coding Assessment Question: Implement Run-Length Encoding (RLE) and Decoding You are tasked to implement the Run-Length Encoding (RLE) algorithm for compressing and decompressing strings. **Context**: Run-Length Encoding is a form of lossless data compression in which runs of data (sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count. **Instructions**: 1. **Function 1**: Implement `run_length_encode`. 2. **Function 2**: Implement `run_length_decode`. # Function Definitions: 1. `run_length_encode(input_string: str) -> str`: * **Input**: * `input_string`: A string containing the message to be encoded with run-length encoding. * **Output**: * Returns the run-length encoded string. 2. `run_length_decode(encoded_string: str) -> str`: * **Input**: * `encoded_string`: A string containing the run-length encoded message. * **Output**: * Returns the original uncompressed message (decoded string). # Specifications: * A run of data is represented as the data value followed by the count of repetitions. * If a data value should appear once, it is followed by the count `1`. * The function should handle any printable ASCII characters. # Constraints: * Input strings will only contain printable ASCII characters. * The run length for any character will not exceed 9. # Example: ```python input_string = \\"AAAABBBCCDAA\\" # Call the encode function encoded_string = run_length_encode(input_string) print(encoded_string) # Expected Output: \'A4B3C2D1A2\' # Call the decode function using the encoded string decoded_string = run_length_decode(encoded_string) print(decoded_string) # Expected Output: \'AAAABBBCCDAA\' ``` Good luck and demonstrate your ability to handle basic data compression and decompression algorithms using Run-Length Encoding!","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = \\"\\" count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_string += previous_char + str(count) previous_char = char count = 1 encoded_string += previous_char + str(count) return encoded_string def run_length_decode(encoded_string: str) -> str: if not encoded_string: return \\"\\" decoded_string = \\"\\" i = 0 while i < len(encoded_string): char = encoded_string[i] count = int(encoded_string[i + 1]) decoded_string += char * count i += 2 return decoded_string"},{"question":"# Smallest Subarray with Sum Greater Than a Given Value You are given an array of integers and a target sum. Write a function to find the length of the smallest contiguous subarray whose sum is greater than or equal to the target sum. If no such subarray exists, return 0. Function Signature ```python def smallest_subarray_with_given_sum(target_sum: int, arr: list) -> int: pass ``` Input - `target_sum`: An integer, the target sum (1 ≤ target_sum ≤ 10^9). - `arr`: A list of integers, the array (1 ≤ len(arr) ≤ 10^5, 1 ≤ arr[i] ≤ 10^4). Output - Return the length of the smallest contiguous subarray whose sum is greater than or equal to the target_sum. If no such subarray exists, return 0. Constraints - The function should be efficient and handle large arrays within time limits. - Elements of the array will be positive integers. Examples ```python # Example 1 target_sum = 7 arr = [2, 1, 5, 2, 3, 2] # Expected Output: 2 # Example 2 target_sum = 15 arr = [1, 2, 3, 4, 5] # Expected Output: 5 # Example 3 target_sum = 3 arr = [1, 1] # Expected Output: 0 ``` Note 1. You may use a sliding window or other optimized technique to achieve an acceptable performance. 2. Ensure the implementation handles edge cases gracefully.","solution":"def smallest_subarray_with_given_sum(target_sum: int, arr: list) -> int: n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target_sum: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Sum of Unique Elements Context: Given an integer array, some elements may appear multiple times and some may be unique. Your task is to find the sum of all unique elements in the array. Task: Write a Python function named `sum_of_unique` that takes a list of integers as input and returns the sum of the elements that appear exactly once in the array. Detailed Requirements: - Iterate through the input list and identify elements that appear exactly once. - Sum these unique elements and return the result. - You may use additional data structures like dictionaries or sets to keep track of element frequency. Function Signature: ```python def sum_of_unique(nums: list[int]) -> int: pass ``` Example: ```python >>> sum_of_unique([1, 2, 3, 2]) 4 >>> sum_of_unique([1, 1, 1, 2]) 2 >>> sum_of_unique([5, 5, 5, 5]) 0 >>> sum_of_unique([10, 20, 30, 40]) 100 ``` Constraints: - The input list will contain integers within the range `-10^6` to `10^6`. - The list can have up to `10^5` elements. Performance Requirements: The solution should have a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the input list.","solution":"def sum_of_unique(nums: list[int]) -> int: Returns the sum of elements that appear exactly once in the array. # Dictionary to store the frequency of each element frequency = {} # Iterate over the list to count the frequency of each element for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Sum the elements that appear exactly once unique_sum = 0 for num, count in frequency.items(): if count == 1: unique_sum += num return unique_sum"},{"question":"# Question: Matrix Diagonal Product You are provided with a square matrix of integers. Your task is to write a function `diagonal_product(matrix: List[List[int]]) -> int` which calculates the product of the diagonal elements of the matrix. The matrix could be either a small (2x2) to a moderately large matrix (50x50). The diagonal elements are those elements `(i, j)` where `i == j`. You need to handle edge cases such as when the matrix is empty or contains zero. # Constraints * The provided matrix is a list of lists, where each inner list represents a row of integers. * The matrix will have dimensions of `nxn`, where `n` will be between 0 and 50 (inclusive). * Each element of the matrix will be an integer within the range -100 to 100. # Input * `matrix`: List[List[int]] - a square matrix of integers # Output * An integer representing the product of the diagonal elements of the matrix. If the matrix is empty or contains only zero, the function should return 1. # Examples Example 1 ```python matrix = [ [2, 3], [4, 5] ] output = 10 ``` Explanation: The diagonal elements are `2` and `5`, and their product is `2 * 5 = 10`. Example 2 ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output = 45 ``` Explanation: The diagonal elements are `1`, `5`, and `9`, and their product is `1 * 5 * 9 = 45`. Example 3 ```python matrix = [ [0, 1], [2, 0] ] output = 0 ``` Explanation: The diagonal elements are `0` and `0`, and their product is `0`. Example 4 ```python matrix = [] output = 1 ``` Explanation: The matrix is empty, so the function returns `1`. # Additional Notes * Ensure the function handles various edge cases, including an empty matrix, matrices with `0`s on the diagonal, and single-element matrices. * Do not use any libraries beyond the standard library. Implement the function `diagonal_product(matrix: List[List[int]]) -> int`, ensuring it meets the specified requirements efficiently.","solution":"from typing import List def diagonal_product(matrix: List[List[int]]) -> int: Returns the product of the diagonal elements of a square matrix. If the matrix is empty, it returns 1 (since the product of no numbers is considered 1). if not matrix: return 1 product = 1 n = len(matrix) for i in range(n): product *= matrix[i][i] return product"},{"question":"# Question Scenario: You are provided with data about students and their scores in different subjects. You have to process this data to calculate the average score of each student. Task: Write a function `calculate_average_scores(student_scores: dict) -> dict:` that takes in a dictionary where the key is the student\'s name and the value is a list of their scores in various subjects. Your function should return a dictionary where the keys are student names and the values are their average scores. **Input:** - `student_scores` (dict): A dictionary with student names as keys and lists of their scores as values. **Output:** - `dict`: A dictionary with student names as keys and their average scores as values rounded to two decimal places. **Constraints:** - The dictionary will have at most `100` students. - Each list of scores will have at least `1` and at most `10` scores. - Scores are integers between `0` and `100`. Example: ```python assert calculate_average_scores({\\"Alice\\": [90, 80, 70], \\"Bob\\": [100, 90]}) == {\\"Alice\\": 80.0, \\"Bob\\": 95.0} assert calculate_average_scores({\\"Charlie\\": [70, 85, 90, 95], \\"David\\": [80]}) == {\\"Charlie\\": 85.0, \\"David\\": 80.0} assert calculate_average_scores({\\"Eve\\": [50, 60, 40], \\"Frank\\": [90, 87, 85, 92]}) == {\\"Eve\\": 50.0, \\"Frank\\": 88.5} ``` **Additional Example:** **Input:** ```python student_scores = { \\"Grace\\": [100, 75, 80, 90], \\"Hannah\\": [60, 80, 70, 85, 90, 95], \\"Ivy\\": [88, 92, 85, 89] } ``` **Output:** ```python { \\"Grace\\": 86.25, \\"Hannah\\": 80.0, \\"Ivy\\": 88.5 } ```","solution":"def calculate_average_scores(student_scores: dict) -> dict: Calculate the average score for each student. Args: student_scores (dict): A dictionary with student names as keys and lists of their scores as values. Returns: dict: A dictionary with student names as keys and their average scores as values rounded to two decimal places. average_scores = {} for student, scores in student_scores.items(): average = round(sum(scores) / len(scores), 2) average_scores[student] = average return average_scores"},{"question":"# Container With Most Water Problem Statement You are given `n` non-negative integers representing the heights of vertical lines drawn on a graph. These lines are placed such that the two endpoints of the ith line are at (i, 0) and (i, height[i]). Find two lines, which together with the x-axis form a container, such that the container can hold the most water. Return the maximum amount of water a container can store. Function Signature ```python def max_area(height: List[int]) -> int: pass ``` Input * `height`: A list of integers `height[0..n-1]` where `height[i]` represents the height of the ith vertical line. Output * Return an integer representing the maximum amount of water that can be contained. Constraints * All elements in `height` are non-negative integers. * The length of `height` is between 2 and 10^4. Example ```python # Example 1 height = [1,8,6,2,5,4,8,3,7] print(max_area(height)) # Output: 49 # Example 2 height = [1,1] print(max_area(height)) # Output: 1 ``` Hint Use two pointers to scan from both ends of the array to find the maximum area efficiently.","solution":"def max_area(height): Calculate the maximum amount of water that can be contained. :param height: List of integers representing the heights of vertical lines. :return: Integer, maximum amount of water that can be contained. left, right = 0, len(height) - 1 max_water = 0 while left < right: # Calculate the height and width of the container h = min(height[left], height[right]) w = right - left # Calculate the current area current_area = h * w # Update max_water if the current area is greater max_water = max(max_water, current_area) # Move the pointers inward if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Fibonacci Sequence Memory Optimization Problem Statement You are required to compute the nth Fibonacci number using a memory-optimized approach. The Fibonacci sequence is defined as: [ F(0) = 0 ] [ F(1) = 1 ] [ F(n) = F(n-1) + F(n-2) ,, text{for} ,, n geq 2 ] Write a function `fib(n: int) -> int` that computes the nth Fibonacci number using only ( O(1) ) extra space. Requirements * Implement the function `fib(n: int) -> int`. * Optimize your solution to use constant extra space. * Your solution should handle values as large as `n = 10^6` efficiently. # Expected Input and Output * **Input**: * `n (int)`: an integer representing the position in the Fibonacci sequence, where `0 ≤ n ≤ 10^6`. * **Output**: * Return the nth Fibonacci number as an integer. # Constraints 1. Ensure the solution runs in ( O(n) ) time. 2. You must use constant extra space, no recursion or dynamic programming with arrays. # Example ```python def fib(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b print(fib(0)) # Output: 0 print(fib(1)) # Output: 1 print(fib(10)) # Output: 55 print(fib(50)) # Output: 12586269025 ``` Tips * Utilize two variables to store the last two Fibonacci numbers and iteratively update them through a loop. * Avoid using arrays to store Fibonacci numbers as it increases space complexity. * Ensure your function handles large numbers efficiently by using Python\'s built-in integer type capabilities.","solution":"def fib(n: int) -> int: Returns the nth Fibonacci number using constant space. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Prime Path Challenge You are tasked with implementing a function to determine if there is a path of prime numbers between two given points in a matrix. A prime path is a sequence of moves from one cell to an adjacent cell (vertically or horizontally) where all cells in the path contain prime numbers. Function to implement: Implement the function to check if a valid prime path exists: ```python def is_prime_path(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: ``` * **Input**: * A 2D list of integers `matrix` representing the grid. * A tuple `start` (i, j) where `i` and `j` are the row and column of the starting cell. * A tuple `end` (i, j) where `i` and `j` are the row and column of the ending cell. * **Output**: A boolean `True` if there exists a prime path from the start to the end cell, `False` otherwise. # Constraints * The matrix dimensions are 1 ≤ m, n ≤ 100. * All elements in the matrix are positive integers. * The starting and ending points are valid indices in the matrix. # Example ```python matrix = [ [2, 4, 3], [5, 9, 7], [11, 13, 8] ] start = (0, 0) end = (2, 1) assert is_prime_path(matrix, start, end) == True start = (0, 0) end = (2, 2) assert is_prime_path(matrix, start, end) == False ``` # Additional Rules 1. Ensure that you write a helper function to determine if a number is prime. 2. Consider edge cases with no possible path and single cell paths. 3. Your solution should be efficient and handle the boundary conditions appropriately. **Good luck! Ensure your code is clean, well-commented, and tested for various edge cases.**","solution":"from typing import List, Tuple from collections import deque def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def is_prime_path(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Determine if there is a prime path from start to end in the matrix. if not is_prime(matrix[start[0]][start[1]]) or not is_prime(matrix[end[0]][end[1]]): return False m, n = len(matrix), len(matrix[0]) visited = [[False]*n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and is_prime(matrix[nx][ny]): visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"# Color Palette Optimization **Context**: You are developing a software for a digital artist who frequently changes the color palette in their work. The artist wishes to have their colors sorted in a way that they transition smoothly from one hue to another to facilitate better artistic workflow. **Task**: Write a function to sort a list of colors represented by their RGB values in such a way that the colors transition smoothly from one hue to another. You should use the concept of color distance to determine the smoothest transition. **Function Signature**: ```python def smooth_color_sort(colors: list) -> list: pass ``` **Input**: * A list of tuples, where each tuple represents a color in RGB format `colors` where each tuple (r, g, b) has values between 0 and 255. * The maximum length for `colors` is 1000. **Output**: * A list of colors (tuples) sorted to transition smoothly in terms of hue. **Constraints**: * Use the Euclidean distance between RGB values to determine the smoothness of transition. * The function should handle edge cases, such as an empty list or a list with one color. **Examples**: ```python assert smooth_color_sort([(255, 0, 0), (0, 255, 0), (0, 0, 255)]) == [(255, 0, 0), (0, 255, 0), (0, 0, 255)] assert smooth_color_sort([(123, 234, 123), (45, 78, 255), (0, 0, 0)]) == [(0, 0, 0), (45, 78, 255), (123, 234, 123)] ``` **Additional Information**: * If there\'s ambiguity in sorting due to equal distances, maintain the original order as much as possible. * The Euclidean distance between two colors (r1, g1, b1) and (r2, g2, b2) is given by: [ sqrt{(r2 - r1)^2 + (g2 - g1)^2 + (b2 - b1)^2} ] **Hint**: * Consider using a greedy algorithm or any suitable heuristic to achieve a near-optimal solution.","solution":"import math def color_distance(color1, color2): Helper function to calculate the Euclidean distance between two RGB colors. return math.sqrt((color2[0] - color1[0]) ** 2 + (color2[1] - color1[1]) ** 2 + (color2[2] - color1[2]) ** 2) def smooth_color_sort(colors): Sorts a list of RGB colors such that the transitions between colors are smooth. if not colors: return [] sorted_colors = [colors.pop(0)] while colors: last_color = sorted_colors[-1] next_color = min(colors, key=lambda color: color_distance(last_color, color)) sorted_colors.append(next_color) colors.remove(next_color) return sorted_colors"},{"question":"# Bank Account Management System You are tasked with creating a Bank Account Management System in Python. This system will allow users to create accounts, deposit money, withdraw money, and check their balance. Additionally, you need to implement a feature to transfer money between accounts. Below are the required functionalities: 1. **Create Account (`create_account`)**: Method to create a new bank account with a unique account number and an initial balance (defaulting to 0 if not provided). 2. **Deposit (`deposit`)**: Method to deposit a specified amount of money into a bank account. 3. **Withdraw (`withdraw`)**: Method to withdraw a specified amount of money from a bank account, ensuring that the account does not go into overdraft. 4. **Check Balance (`check_balance`)**: Method to check the current balance of a bank account. 5. **Transfer (`transfer`)**: Method to transfer a specified amount of money from one bank account to another. Constraints * `create_account` should ensure each account number is unique. * `deposit`, `withdraw`, and `transfer` should raise appropriate exceptions for invalid operations (e.g., insufficient funds, non-existent account numbers). * Methods should handle amounts as non-negative integers. Function Signatures ```python class BankAccountSystem: def __init__(self): self.accounts = {} def create_account(self, account_number: int, initial_balance: int = 0): # Implement create_account here def deposit(self, account_number: int, amount: int): # Implement deposit here def withdraw(self, account_number: int, amount: int): # Implement withdraw here def check_balance(self, account_number: int) -> int: # Implement check_balance here def transfer(self, from_account: int, to_account: int, amount: int): # Implement transfer here ``` Example Usage ```python # Example Usage bank = BankAccountSystem() bank.create_account(1001, 500) bank.create_account(1002, 1000) bank.deposit(1001, 300) print(bank.check_balance(1001)) # Output: 800 bank.withdraw(1002, 200) print(bank.check_balance(1002)) # Output: 800 bank.transfer(1001, 1002, 100) print(bank.check_balance(1001)) # Output: 700 print(bank.check_balance(1002)) # Output: 900 ``` Implement the Bank Account Management System by completing the features above and include tests to verify the correctness of your implementations.","solution":"class BankAccountSystem: def __init__(self): self.accounts = {} def create_account(self, account_number: int, initial_balance: int = 0): if account_number in self.accounts: raise ValueError(\\"Account number already exists.\\") if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.accounts[account_number] = initial_balance def deposit(self, account_number: int, amount: int): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") if amount < 0: raise ValueError(\\"Deposit amount cannot be negative.\\") self.accounts[account_number] += amount def withdraw(self, account_number: int, amount: int): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") if amount < 0: raise ValueError(\\"Withdrawal amount cannot be negative.\\") if self.accounts[account_number] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_number] -= amount def check_balance(self, account_number: int) -> int: if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") return self.accounts[account_number] def transfer(self, from_account: int, to_account: int, amount: int): if from_account not in self.accounts: raise ValueError(\\"From account does not exist.\\") if to_account not in self.accounts: raise ValueError(\\"To account does not exist.\\") if amount < 0: raise ValueError(\\"Transfer amount cannot be negative.\\") if self.accounts[from_account] < amount: raise ValueError(\\"Insufficient funds in from account.\\") self.accounts[from_account] -= amount self.accounts[to_account] += amount"},{"question":"# Minimum Edit Distance You are required to calculate the minimum number of operations needed to convert one string into another using dynamic programming. **Scenario**: A text editor provides three operations that can be performed on a string: insertion of a character, deletion of a character, and substitution of a character. Given two strings, `source` and `target`, determine the minimum number of operations required to transform the `source` string into the `target` string. **Function Specification**: ```python def min_edit_distance(source: str, target: str) -> int: :param source: The source string. :param target: The target string. :return: The minimum number of operations to convert source to target. ``` **Input and Output Formats**: * Input: * `source` – A string containing the initial text. * `target` – A string containing the target text. * Output: * An integer representing the minimum number of operations required to convert the source string to the target string. **Constraints**: * `1 <= len(source), len(target) <= 1000` * `source` and `target` consist of lowercase English letters only. **Performance Requirements**: * Use dynamic programming to ensure the solution runs efficiently within the provided constraints. **Examples**: ```python # Example 1 print(min_edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 # Explanation: # kitten -> sitten (substitution of \'k\' with \'s\') # sitten -> sittin (substitution of \'e\' with \'i\') # sittin -> sitting (insertion of \'g\') # Example 2 print(min_edit_distance(\\"intention\\", \\"execution\\")) # Output: 5 # Explanation: # intention -> inention (remove \'t\') # inention -> enention (replace \'i\' with \'e\') # enention -> exention (replace \'n\' with \'x\') # exention -> exection (replace \'n\' with \'c\') # exection -> execution (insert \'u\') ``` Ensure your function handles edge cases properly and runs efficiently within the provided constraints.","solution":"def min_edit_distance(source: str, target: str) -> int: Calculates the minimum number of operations required to convert the source string to the target string using dynamic programming. :param source: The source string. :param target: The target string. :return: The minimum number of operations to convert source to target. n = len(source) m = len(target) # Create a (n+1) x (m+1) dp array dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize dp array for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[n][m]"},{"question":"# Temperature Conversion Context Temperature conversion between different units is a common task in various scientific and engineering fields. Being able to programmatically convert temperatures between Celsius, Fahrenheit, and Kelvin is an essential skill. Task Write a function `convert_temperature(value: float, from_unit: str, to_unit: str) -> float` that converts a given temperature from one unit to another. The function should adhere to the following characteristics: 1. The function should handle conversions between Celsius (\'C\'), Fahrenheit (\'F\'), and Kelvin (\'K\'). 2. If the `from_unit` or `to_unit` is invalid (not \'C\', \'F\', or \'K\'), raise a `ValueError` with the message \\"Invalid temperature unit\\". 3. The function should return the converted temperature rounded to two decimal places. Input - `value`: A floating-point number representing the temperature value to be converted. - `from_unit`: A string representing the unit of the input temperature value. Must be one of \'C\', \'F\', or \'K\'. - `to_unit`: A string representing the unit of the output temperature value. Must be one of \'C\', \'F\', or \'K\'. Output - Return the converted temperature as a floating-point number rounded to two decimal places. Constraints - Assume the input temperature value is within a reasonable range for conversion (e.g., no extremely unrealistic physical conditions). Example ```python convert_temperature(100, \'C\', \'F\') # Output: 212.00 convert_temperature(0, \'C\', \'K\') # Output: 273.15 convert_temperature(32, \'F\', \'C\') # Output: 0.00 ``` Hints - Remember the formulas for temperature conversion: - Celsius to Fahrenheit: ( text{F} = text{C} times frac{9}{5} + 32 ) - Fahrenheit to Celsius: ( text{C} = (text{F} - 32) times frac{5}{9} ) - Celsius to Kelvin: ( text{K} = text{C} + 273.15 ) - Kelvin to Celsius: ( text{C} = text{K} - 273.15 ) - Consider breaking down the problem into smaller conversion functions for clarity and modularity. This question matches the style, length, difficulty, and topic alignment with the provided sample question while introducing a different but related area of programming.","solution":"def convert_temperature(value: float, from_unit: str, to_unit: str) -> float: Converts a given temperature from one unit to another (Celsius, Fahrenheit, Kelvin). units = {\'C\', \'F\', \'K\'} if from_unit not in units or to_unit not in units: raise ValueError(\\"Invalid temperature unit\\") # Convert from `from_unit` to Celsius first if from_unit == \'C\': temp_in_celsius = value elif from_unit == \'F\': temp_in_celsius = (value - 32) * 5 / 9 elif from_unit == \'K\': temp_in_celsius = value - 273.15 # Convert from Celsius to `to_unit` if to_unit == \'C\': converted_temp = temp_in_celsius elif to_unit == \'F\': converted_temp = temp_in_celsius * 9 / 5 + 32 elif to_unit == \'K\': converted_temp = temp_in_celsius + 273.15 return round(converted_temp, 2)"},{"question":"# Coding Question Introduction: Sorting algorithms are foundational in computer science and crucial for optimizing data processing. One classic comparison-based sorting algorithm is Merge Sort, which divides the array into two halves, recursively sorts them, and then merges the sorted halves. Task: Write a function `merge_sort` that takes a list of integers and returns a sorted list using the Merge Sort algorithm. Ensure your implementation handles large lists efficiently and validates inputs correctly. Function Signature: ```python def merge_sort(arr: list) -> list: ``` Input: - `arr`: A list of integers, can be of any length including empty lists. Output: - A new list of integers, sorted in ascending order. Constraints: - The function should handle empty lists and lists with negative integers. - Do not use Python\'s built-in `sort` or `sorted` functions. Example: ```python # Example call sorted_list = merge_sort([34, 7, 23, 32, 5, 62]) # Example output # [5, 7, 23, 32, 34, 62] ``` Notes: 1. Implement the Merge Sort algorithm, including the steps to divide the list, recursively sort each half, and merge the sorted halves. 2. Ensure the function handles edge cases such as empty lists and lists with one element. 3. The sorting algorithm must be implemented from scratch, without the use of library sorting functions. 4. Test your function with various inputs to ensure it works correctly and efficiently.","solution":"def merge_sort(arr: list) -> list: Sort a list using the merge sort algorithm. if len(arr) <= 1: return arr def merge(left, right): Merge two sorted lists into one sorted list. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Question: Matrix Diagonal Sum and Trace You are provided with two individual tasks. Write two functions to achieve the following: Task 1: Sum of Matrix Diagonal Write a function `sum_of_diagonal(matrix: List[List[int]]) -> int` that calculates the sum of all the elements on the main diagonal of a given square matrix. The main diagonal of a matrix consists of the elements located at positions where the row index and column index are the same. **Input** - A square matrix `matrix` represented as a list of lists of integers. **Output** - Return the sum of the main diagonal elements as an integer. **Examples** ```python >>> sum_of_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> sum_of_diagonal([[5, 0, 0], [0, 5, 0], [0, 0, 5]]) 15 >>> sum_of_diagonal([[2, 1], [1, 2]]) 4 ``` Task 2: Trace of a Matrix Write a function `matrix_trace(matrix: List[List[int]]) -> int` that returns the trace of a given square matrix. The trace of a matrix is defined as the sum of the main diagonal elements of the matrix. **Input** - A square matrix `matrix` represented as a list of lists of integers. **Output** - Return the trace of the matrix as an integer. **Examples** ```python >>> matrix_trace([[1, 4, 6], [2, 5, 3], [9, 8, 7]]) 13 >>> matrix_trace([[5, 3], [2, 8]]) 13 >>> matrix_trace([[1, 1], [1, 1]]) 2 ``` **Constraints**: - Both functions should raise a `ValueError` if the input is not a square matrix or if the matrix is empty. ```python def sum_of_diagonal(matrix: list) -> int: # your code here pass def matrix_trace(matrix: list) -> int: # your code here pass ``` Use the following assertions to verify the correctness of your code: ```python assert sum_of_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 15 assert sum_of_diagonal([[5, 0, 0], [0, 5, 0], [0, 0, 5]]) == 15 assert sum_of_diagonal([[2, 1], [1, 2]]) == 4 assert matrix_trace([[1, 4, 6], [2, 5, 3], [9, 8, 7]]) == 13 assert matrix_trace([[5, 3], [2, 8]]) == 13 assert matrix_trace([[1, 1], [1, 1]]) == 2 ```","solution":"def sum_of_diagonal(matrix: list) -> int: if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Input must be a non-empty square matrix.\\") return sum(matrix[i][i] for i in range(len(matrix))) def matrix_trace(matrix: list) -> int: return sum_of_diagonal(matrix)"},{"question":"# Coding Assessment Question Problem Statement You are given a linked list implemented as a class, with methods to insert nodes and traverse the list. Your task is to extend this class to support additional functionality. Objective 1. Write a function `reverse_in_groups` that reverses the nodes of the linked list in groups of a given size `k`. The function should return nothing but modify the linked list in place. 2. Handle edge cases effectively (e.g., when `k` is larger than the length of the linked list). Implementation Details Extend the provided class with the following function: ```python def reverse_in_groups(self, head: ListNode, k: int) -> None: ``` - **Input**: - `head`: The head of the linked list (type `ListNode`). - `k`: The size of the groups to reverse (type `int`). - **Output**: - Modifies the linked list in place to reverse the nodes in groups of size `k`. - If `k` is greater than the size of the linked list or `k` <= 1, the entire list should remain unchanged. Constraints - The linked list contains at least one node. - The value of `k` is a positive integer. Performance Requirements - The solution should run in O(n) time complexity, where n is the number of nodes in the linked list. - Optimize for space as much as possible and aim for O(1) additional space. Example ```python # Example usage: linked_list = LinkedList() linked_list.insert(10) linked_list.insert(20) linked_list.insert(30) linked_list.insert(40) linked_list.insert(50) # This reverses the list in groups of 2: [20->10->40->30->50] linked_list.reverse_in_groups(linked_list.head, 2) # Example to display the list after reversing in groups: current = linked_list.head while current: print(current.value, end=\\" -> \\") current = current.next # Output: # 20 -> 10 -> 40 -> 30 -> 50 -> ``` Notes - Ensure to handle the input constraints and verify if the input `k` is valid. - Consider edge cases like a single node in the list or when `k` is 1.","solution":"class ListNode: def __init__(self, value:int = 0, next: \'ListNode\' = None) -> None: self.value = value self.next = next class LinkedList: def __init__(self) -> None: self.head = None def insert(self, value: int) -> None: if self.head is None: self.head = ListNode(value) else: current = self.head while current.next is not None: current = current.next current.next = ListNode(value) def reverse_in_groups(self, head: \'ListNode\', k: int) -> None: if k <= 1 or head is None: return dummy = ListNode(0) dummy.next = head prev_group_end = dummy while True: group_start = prev_group_end.next kth = self.get_kth_node(prev_group_end, k) if not kth: break group_end = kth.next kth.next = None # temporarily break the list self.reverse_list(group_start) prev_group_end.next = kth group_start.next = group_end prev_group_end = group_start self.head = dummy.next def get_kth_node(self, start: \'ListNode\', k: int) -> \'ListNode\': while k > 0 and start: start = start.next k -= 1 return start def reverse_list(self, head: \'ListNode\') -> \'ListNode\': prev = None current = head while current: nxt = current.next current.next = prev prev = current current = nxt return prev def to_list(self): current = self.head result = [] while current: result.append(current.value) current = current.next return result"},{"question":"# String Pattern Matching with Wildcards You are provided with a predefined function `matches_pattern` that checks if a given `text` matches a `pattern` which may include wildcard characters. Objective: Your task is to implement a function called `wildcard_matcher` which evaluates whether the provided `text` string matches the given `pattern` string. The pattern may include the special character `*` that can match any sequence of characters (including an empty sequence) and `?` which matches any single character. # Specifications: - **Function Name**: wildcard_matcher - **Input**: - `pattern`: a string containing the pattern, which may include `*` and `?` as wildcard characters. - `text`: a string of the text to be matched against the pattern. - **Output**: A boolean indicating whether the `text` matches the `pattern`. # Constraints: - `pattern` and `text` will be non-empty strings with lengths not exceeding 1000 characters. - The `pattern` string contains only alphanumeric characters and the wildcards `*` and `?`. - Your function should handle edge cases efficiently, where wildcards appear at various positions in the `pattern`. # Example: ```python print(wildcard_matcher(\\"a*b\\", \\"abab\\")) # Expected: True print(wildcard_matcher(\\"a?b\\", \\"acb\\")) # Expected: True print(wildcard_matcher(\\"a?b\\", \\"ab\\")) # Expected: False print(wildcard_matcher(\\"*a\\", \\"aa\\")) # Expected: True print(wildcard_matcher(\\"?\\", \\"a\\")) # Expected: True print(wildcard_matcher(\\"?\\", \\"\\")) # Expected: False ``` # Steps: 1. Implement the `wildcard_matcher` utilizing dynamic programming or recursion with memoization to efficiently handle the pattern matching. 2. Ensure the function can handle all combinations of `*` and `?` appearing in the `pattern`. # Edge Cases to Consider: - Patterns with consecutive `*` characters. - Patterns with `*` at the beginning or end. - Texts that are much shorter or longer than the pattern, especially with many wildcards present.","solution":"def wildcard_matcher(pattern, text): Returns whether the text matches the pattern, with the pattern containing wildcards \'*\' and \'?\'. memo = {} def dp(i, j): if (i, j) in memo: return memo[(i, j)] if j == len(pattern): result = i == len(text) else: if j < len(pattern) and pattern[j] == \'*\': result = (i < len(text) and dp(i + 1, j)) or dp(i, j + 1) else: match = i < len(text) and (pattern[j] == text[i] or pattern[j] == \'?\') result = match and dp(i + 1, j + 1) memo[(i, j)] = result return result return dp(0, 0)"},{"question":"# Minimum Insertions for Palindrome Given a string `s`, your task is to find the minimum number of insertions required to make the string a palindrome. A palindrome is a string that reads the same forward and backward. Input: - A string `s`. Output: - The function should return an integer representing the minimum number of insertions needed. Constraints: - The input string `s` can have a maximum length of 500. Performance Requirements: - The implementation should have a time complexity of O(n^2) and a space complexity of O(n^2), where n is the length of the input string `s`. Example ```python def min_insertions_for_palindrome(s: str) -> int: pass # Example Test Cases assert min_insertions_for_palindrome(\\"ab\\") == 1 # \\"aba\\" assert min_insertions_for_palindrome(\\"race\\") == 3 # \\"ecarace\\" assert min_insertions_for_palindrome(\\"a\\") == 0 # Already a palindrome assert min_insertions_for_palindrome(\\"abcda\\") == 2 # \\"abcdcba\\" assert min_insertions_for_palindrome(\\"\\") == 0 # Empty string is already a palindrome ``` Implementation Notes: 1. Define a 2D array `dp` of size (n x n) where `dp[i][j]` represents the minimum number of insertions needed to make the substring `s[i...j]` a palindrome. 2. Initialize `dp[i][i]` to 0 for all `i` since a single character is already a palindrome. 3. Fill the `dp` array using the following relations: - If `s[i] == s[j]`, then `dp[i][j] = dp[i+1][j-1]` since the characters match. - Otherwise, `dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1` since you need to insert a character to make it a palindrome. 4. The final value `dp[0][n-1]` will represent the minimum number of insertions needed for the entire string `s`.","solution":"def min_insertions_for_palindrome(s: str) -> int: n = len(s) if n == 0: return 0 # Create a 2D dp array dp = [[0] * n for _ in range(n)] # Loop over the length of substrings for length in range(2, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] if i+1 <= j-1 else 0 else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 return dp[0][n-1]"},{"question":"# Question: Most Frequent Element **Context**: In data analysis and processing, it is commonly necessary to identify the most frequently occurring item in a dataset. This problem evaluates your ability to count occurrences and efficiently determine the most commonly appearing element. **Problem Statement**: Write a function named `most_frequent_element` that accepts a list of integers and returns the element that appears the most times. If there are multiple elements with the same highest frequency, return the one which appears first. **Function Signature**: ```python def most_frequent_element(numbers: list) -> int: ``` **Input**: * `numbers` (list of int): A list of integers where each integer represents a number in the dataset. **Output**: * Returns an integer representing the element that occurs most frequently in the list. If there is a tie, return the one that appears first in the list. **Constraints**: * `0 <= len(numbers) <= 10^5` * `-10^6 <= numbers[i] <= 10^6` for all valid `i` **Example**: ```python print(most_frequent_element([1, 3, 3, 2, 1, 2, 1])) # Output: 1 print(most_frequent_element([4, 4, 5, 2, 5, 5, 4])) # Output: 5 print(most_frequent_element([1, 2, 3, 4, 5])) # Output: 1 print(most_frequent_element([])) # Output: None ``` **Explanation**: 1. In the first example, \'1\' appears 3 times which is more frequent than any other number in the list. 2. In the second example, both \'4\' and \'5\' appear 3 times but \'5\' appears first. 3. In the third example, no number appears more than once, so the first element \'1\' is returned. 4. For an empty list, since there are no elements, return `None`.","solution":"def most_frequent_element(numbers: list) -> int: Returns the most frequently occurring element in the list. If there is a tie, returns the element that appears first. If the list is empty, returns None. if not numbers: return None frequency = {} max_freq = 0 most_frequent = None for number in numbers: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 if frequency[number] > max_freq: max_freq = frequency[number] most_frequent = number return most_frequent"},{"question":"# Coding Assessment Question **Title**: Build and Test a Recommendation System **Task**: Using the provided dataset management and collaborative filtering methods, implement a function to process a dataset, generate movie recommendations for a specific user, and evaluate the recommendations using precision and recall metrics. **Background**: Given the MovieLens dataset, you need to create a recommendation system using collaborative filtering techniques to suggest movies to users based on their past ratings. You are provided with code snippets for data handling, recommendation generation, and functions to calculate precision and recall. Your task is to integrate these processes and ensure a robust recommendation pipeline. **Function Specification**: **Function Name**: `evaluate_recommendation_system` **Input**: - `dataset` (pd.DataFrame): A pandas DataFrame containing the dataset with columns \'userId\', \'movieId\', \'rating\'. - `user_id` (int): The ID of the user for whom to generate recommendations. - `test_size` (float): A float between 0 and 1 representing the proportion of the dataset to include in the test split. **Output**: - Prints the precision and recall of the recommendation system for the specified user. **Constraints**: - Ensure the test_size is between 0.1 and 0.4 to avoid inappropriate splits. - Handle missing or invalid data gracefully. - Ensure that recommendations are efficient for datasets that fit into memory. **Requirements**: - Implement a data handling function to process the input dataset. - Generate movie recommendations for the specified user using collaborative filtering. - Evaluate the recommendations using precision and recall metrics, and display the results. **Example**: Assume `movielens_data` is a pandas DataFrame containing the dataset as described. ```python import pandas as pd movielens_data = pd.read_csv(\\"movielens_dataset.csv\\") evaluate_recommendation_system(movielens_data, user_id=1, test_size=0.25) ``` Expected Output: - Precision and recall scores for the user\'s movie recommendations. **Skeleton Code**: ```python import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import precision_score, recall_score # Provided function def data_handling(data: pd.DataFrame) -> tuple: # Assuming data has columns \'userId\', \'movieId\', \'rating\' users = data[\'userId\'].unique() movies = data[\'movieId\'].unique() return users, movies # Provided function def collaborative_filtering(data: pd.DataFrame, user_id: int) -> list: # Dummy implementation for the sake of example # Replace with actual collaborative filtering technique user_data = data[data[\'userId\'] == user_id] recommended_movie_ids = user_data[\'movieId\'].sample(5).tolist() return recommended_movie_ids # Implement the required function def evaluate_recommendation_system(dataset: pd.DataFrame, user_id: int, test_size: float) -> None: # Ensure valid test_size assert 0.1 <= test_size <= 0.4, \\"Test size should be between 0.1 and 0.4\\" # Split the dataset train_data, test_data = train_test_split(dataset, test_size=test_size) # Get users and movies from training data users, movies = data_handling(train_data) # Generate recommendations for the specified user recommended_movies = collaborative_filtering(train_data, user_id) # Evaluate precision and recall true_positives = test_data[(test_data[\'userId\'] == user_id) & (test_data[\'movieId\'].isin(recommended_movies))] relevant_items = test_data[test_data[\'userId\'] == user_id] precision = precision_score(relevant_items[\'movieId\'], true_positives[\'movieId\'], average=\'binary\') recall = recall_score(relevant_items[\'movieId\'], true_positives[\'movieId\'], average=\'binary\') print(f\\"Precision for user {user_id}: {precision:.2f}\\") print(f\\"Recall for user {user_id}: {recall:.2f}\\") # Example usage if __name__ == \\"__main__\\": movielens_data = pd.read_csv(\\"movielens_dataset.csv\\") evaluate_recommendation_system(movielens_data, user_id=1, test_size=0.25) ``` Note: Make sure to have the `movielens_dataset.csv` file downloaded and available in the working directory. Adjust the implementation of `collaborative_filtering` to use an appropriate algorithm for generating recommendations.","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import precision_score, recall_score def data_handling(data: pd.DataFrame) -> tuple: Handle the data processing step. Args: - data (pd.DataFrame): The dataset containing \'userId\', \'movieId\', and \'rating\' columns. Returns: - users (np.array): Unique user IDs. - movies (np.array): Unique movie IDs. users = data[\'userId\'].unique() movies = data[\'movieId\'].unique() return users, movies def collaborative_filtering(data: pd.DataFrame, user_id: int) -> list: Generate movie recommendations using collaborative filtering. Args: - data (pd.DataFrame): The dataset containing \'userId\', \'movieId\', and \'rating\' columns. - user_id (int): The ID of the user for recommendations. Returns: - recommended_movie_ids (list): List of recommended movie IDs. # Dummy implementation for the sake of example # Replace with actual collaborative filtering technique user_data = data[data[\'userId\'] == user_id] recommendable_movies = data[\'movieId\'].unique() if len(user_data) == 0: return list(np.random.choice(recommendable_movies, 5)) # Dummy recommendation user_watched_movies = set(user_data[\'movieId\']) other_users_data = data[data[\'userId\'] != user_id] other_users_data = other_users_data[~other_users_data[\'movieId\'].isin(user_watched_movies)] recommended_movie_ids = other_users_data[\'movieId\'].value_counts().head(5).index.tolist() return recommended_movie_ids def evaluate_recommendation_system(dataset: pd.DataFrame, user_id: int, test_size: float) -> None: Evaluate the recommendation system for a specific user. Args: - dataset (pd.DataFrame): The dataset containing \'userId\', \'movieId\', and \'rating\' columns. - user_id (int): The ID of the user. - test_size (float): The proportion of the dataset to be used as the test split. Prints the precision and recall of the recommendations. # Ensure valid test_size assert 0.1 <= test_size <= 0.4, \\"Test size should be between 0.1 and 0.4\\" # Split the dataset train_data, test_data = train_test_split(dataset, test_size=test_size) # Get users and movies from training data users, movies = data_handling(train_data) # Generate recommendations for the specified user recommended_movies = collaborative_filtering(train_data, user_id) # Create series of true positives and relevant items for precision and recall score true_positives = test_data[(test_data[\'userId\'] == user_id) & (test_data[\'movieId\'].isin(recommended_movies))] relevant_items = test_data[test_data[\'userId\'] == user_id] # Avoid potential empty series for precision and recall calculation if len(relevant_items) == 0: print(f\\"No true items for user {user_id} in test data for calculation.\\") return relevant_set = set(relevant_items[\'movieId\']) recommended_set = set(recommended_movies) precision = len(recommended_set & relevant_set) / len(recommended_set) if len(recommended_set) else 0 recall = len(recommended_set & relevant_set) / len(relevant_set) if len(relevant_set) else 0 print(f\\"Precision for user {user_id}: {precision:.2f}\\") print(f\\"Recall for user {user_id}: {recall:.2f}\\")"},{"question":"# Coding Question Context You have been tasked with developing an algorithm that processes a specific type of data structure known as a string matrix. This matrix is represented as a list of lists, where each inner list contains strings. The rows in the matrix may have varying lengths. Problem Statement Write a function called `column_concatenation` that takes a single argument: 1. `matrix` (a list of lists): A string matrix where each inner list represents a row and contains strings. Your function should return a list of strings where each string is formed by concatenating the corresponding elements from each row in the matrix. If one row is shorter than others, assume empty strings for missing elements. Input Format * `matrix`: A list of lists representing a string matrix. - `1 <= len(matrix) <= 100` (number of rows) - `0 <= len(matrix[i]) <= 100` (length of each row, number of columns per row) - Each element in the matrix is a string composed of alphabetical characters with length between 1 and 10 Output Format * A list of strings where each string is formed by concatenating corresponding elements of each row. Example * Example 1: ```python matrix = [ [\\"a\\", \\"b\\", \\"c\\"], [\\"d\\", \\"e\\", \\"f\\"], [\\"g\\", \\"h\\", \\"i\\"] ] column_concatenation(matrix) # Should return [\'adg\', \'beh\', \'cfi\'] ``` * Example 2: ```python matrix = [ [\\"cat\\", \\"dog\\"], [\\"fish\\"], [\\"parrot\\", \\"hamster\\"] ] column_concatenation(matrix) # Should return [\'catfishparrot\', \'doghamster\'] ``` Constraints and Performance Requirements - Ensure your solution efficiently handles the expected size of the matrix. - Be mindful of handling rows with different lengths, treating missing elements as empty strings.","solution":"def column_concatenation(matrix): Concatenates elements from each column in the matrix. :param matrix: A list of lists representing a string matrix. :return: A list of strings where each string is formed by concatenating corresponding elements from each row. if not matrix: return [] max_columns = max(len(row) for row in matrix) result = [\'\' for _ in range(max_columns)] for row in matrix: for col_idx in range(max_columns): if col_idx < len(row): result[col_idx] += row[col_idx] else: result[col_idx] += \'\' return result"},{"question":"# Question: Longest Increasing Subsequence **Context**: You are organizing a series of workshops and want to select a subsequence of workshops that can be attended in strictly increasing order of their difficulty levels. **Task**: Implement a function `longest_increasing_subsequence` that determines the length of the longest subsequence of workshops that can be attended in increasing order of difficulty. **Function signature**: ```python def longest_increasing_subsequence(difficulties: List[int]) -> int: pass ``` **Input**: - `difficulties` (List[int]): A list of integers where each integer represents the difficulty level of a workshop. **Output**: - Returns the length of the longest subsequence of workshops that have strictly increasing difficulty levels. **Constraints**: - The input list of difficulties can be of any length from 0 to 2500. - All elements in the list are non-negative integers. **Sample Input**: ```python difficulties = [10, 22, 9, 33, 21, 50, 41, 60, 80] ``` **Sample Output**: ```python 6 ``` **Explanation**: The longest subsequence of workshops with strictly increasing difficulty levels is [10, 22, 33, 50, 60, 80], which has a length of 6.","solution":"from typing import List def longest_increasing_subsequence(difficulties: List[int]) -> int: if not difficulties: return 0 n = len(difficulties) lis = [1] * n # Initialize LIS values for all indexes as 1 # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(i): if difficulties[i] > difficulties[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Find the maximum of all LIS values return max(lis)"},{"question":"# Coding Assessment Question: String Permutation in Lexicographical Order Objective Given two strings, the goal is to determine whether one string is a permutation of the other, and, if they are permutations, return the lexicographically smallest permutation. Task Write a function `smallest_permutation_if_permutation(s1: str, s2: str) -> str` which takes two strings `s1` and `s2` as input. This function should: 1. Check if the two strings are permutations of each other. 2. If they are permutations, return the lexicographically smallest permutation among all possible permutations of the string. 3. If they are not permutations of each other, return an empty string `\\"\\"`. Input - Two strings `s1` and `s2` (1 ≤ len(s1), len(s2) ≤ 1000), consisting of lowercase English letters. Output Format - A string representing the lexicographically smallest permutation of the input strings if they are permutations of each other, otherwise an empty string. Example ```python assert smallest_permutation_if_permutation(\\"abc\\", \\"bca\\") == \\"abc\\" assert smallest_permutation_if_permutation(\\"hello\\", \\"bello\\") == \\"\\" assert smallest_permutation_if_permutation(\\"abcd\\", \\"dcba\\") == \\"abcd\\" assert smallest_permutation_if_permutation(\\"aabbcc\\", \\"ccbbaa\\") == \\"aabbcc\\" assert smallest_permutation_if_permutation(\\"xyz\\", \\"zyxw\\") == \\"\\" ``` Constraints Use efficient algorithms to handle the computations since the input size can be large. Ensure that the solution handles various cases, including smallest and largest possible values of string lengths. Guidelines - Make use of sorting to easily determine the lexicographically smallest permutation. - Ensure the check for permutations is conducted efficiently. - Minimize the number of unnecessary operations to handle large inputs gracefully. Code Snippet ```python def smallest_permutation_if_permutation(s1: str, s2: str) -> str: # Your implementation if sorted(s1) == sorted(s2): return \'\'.join(sorted(s1)) return \'\' # Examples print(smallest_permutation_if_permutation(\\"abc\\", \\"bca\\")) # Should output: \\"abc\\" print(smallest_permutation_if_permutation(\\"hello\\", \\"bello\\")) # Should output: \\"\\" print(smallest_permutation_if_permutation(\\"abcd\\", \\"dcba\\")) # Should output: \\"abcd\\" print(smallest_permutation_if_permutation(\\"aabbcc\\", \\"ccbbaa\\")) # Should output: \\"aabbcc\\" print(smallest_permutation_if_permutation(\\"xyz\\", \\"zyxw\\")) # Should output: \\"\\" ```","solution":"def smallest_permutation_if_permutation(s1: str, s2: str) -> str: Return the lexicographically smallest permutation of s1 if s1 and s2 are permutations of each other. Otherwise, return an empty string. if sorted(s1) == sorted(s2): return \'\'.join(sorted(s1)) return \'\'"},{"question":"**Scenario**: You have been tasked with creating a file system simulation to help understand and test file operations. The system will consist of directories and files, with functionalities to create, delete, and list files and directories. # Task 1. **Class Definitions**: - Define a `File` class with attributes: * `name`: a string representing the file name. * `content`: a string representing the file content. - Define a `Directory` class with attributes: * `name`: a string representing the directory name. * `contents`: a list to hold `File` and `Directory` objects. 2. **Functionalities**: - Implement a method `create_file` in the `Directory` class that accepts a file name and file content, and adds a new `File` to the directory. - Implement a method `create_directory` in the `Directory` class that accepts a directory name and adds a new `Directory` to the current directory. - Implement a method `delete` in the `Directory` class that accepts a name (file or directory) and removes it from the current directory. - Implement a method `list_contents` in the `Directory` class that returns a list of names of all files and directories in the current directory. # Input and Output Format - **Input**: * For `create_file`: params `name` (str), `content` (str) * For `create_directory`: params `name` (str) * For `delete`: params `name` (str) * For `list_contents`: no parameters - **Output**: * For `create_file` and `create_directory`: return a confirmation message (str) such as \\"File created\\" or \\"Directory created\\". * For `delete`: return a confirmation message (str) such as \\"Deleted successfully\\". * For `list_contents`: return a list of names (list of str) # Constraints - File and directory names will be unique within a directory. - Operations will be case-sensitive. - Directory class should initialize with an empty list of contents. # Example ```python root = Directory(name=\\"root\\") # Create files and directories print(root.create_file(name=\\"example.txt\\", content=\\"This is an example file.\\")) # Outputs: \\"File created\\" print(root.create_directory(name=\\"photos\\")) # Outputs: \\"Directory created\\" # List contents print(root.list_contents()) # Outputs: [\'example.txt\', \'photos\'] # Delete a file print(root.delete(name=\\"example.txt\\")) # Outputs: \\"Deleted successfully\\" # List contents after deletion print(root.list_contents()) # Outputs: [\'photos\'] ```","solution":"class File: def __init__(self, name, content): self.name = name self.content = content class Directory: def __init__(self, name): self.name = name self.contents = [] def create_file(self, name, content): new_file = File(name, content) self.contents.append(new_file) return \\"File created\\" def create_directory(self, name): new_directory = Directory(name) self.contents.append(new_directory) return \\"Directory created\\" def delete(self, name): for item in self.contents: if item.name == name: self.contents.remove(item) return \\"Deleted successfully\\" return \\"Item not found\\" def list_contents(self): return [item.name for item in self.contents]"},{"question":"# Question Scenario: You are developing a system to manage a collection of files and their related operations. One essential aspect of this system is organizing the files in such a way that allows for quick retrieval, insertion, and removal. To achieve this, you decide to implement a Min-Heap data structure, which ensures that the minimum element is always accessible in constant time. Task: Implement the following functions: 1. **insert(heap: List[int], new_value: int) -> None**: - Inserts a `new_value` into the Min-Heap and maintains the heap property. 2. **remove_min(heap: List[int]) -> int**: - Removes and returns the minimum element from the Min-Heap while maintaining the heap property. 3. **heapify(values: List[int]) -> List[int]**: - Given a list of integer `values`, transforms it into a Min-Heap and returns the heap. Function Definitions: ```python def insert(heap: List[int], new_value: int) -> None: pass def remove_min(heap: List[int]) -> int: pass def heapify(values: List[int]) -> List[int]: pass ``` Constraints: - Assume all values for `heapify` are integers. - `values` list lengths can vary from 0 to 10^4. - The heap is implemented as a list where index 0 represents the root of the heap. Example: ```python heap = heapify([15, 10, 25, 6, 14, 20, 60]) assert heap == [6, 10, 20, 15, 14, 25, 60] # Example state of the min-heap insert(heap, 5) assert heap[0] == 5 # Ensure the minimum value is at the root min_value = remove_min(heap) assert min_value == 5 # The removed minimum value assert heap[0] == 6 # New minimum value at the root after removal ``` Performance Requirements: - Ensure the `insert` and `remove_min` operations remain efficient, ideally O(log n) where n is the number of elements in the heap. - The `heapify` operation should run in O(n) time.","solution":"def insert(heap, new_value): Inserts a new_value into the Min-Heap and maintains the heap property. heap.append(new_value) _bubble_up(heap, len(heap) - 1) def remove_min(heap): Removes and returns the minimum element from the Min-Heap while maintaining the heap property. if len(heap) == 0: raise IndexError(\'remove_min from an empty heap\') if len(heap) == 1: return heap.pop() min_value = heap[0] heap[0] = heap.pop() _bubble_down(heap, 0) return min_value def heapify(values): Given a list of integer values, transforms it into a Min-Heap and returns the heap. n = len(values) for i in reversed(range(n // 2)): _bubble_down(values, i) return values def _bubble_up(heap, index): Moves the element at index \'index\' up to maintain the heap property. parent_index = (index - 1) // 2 if index > 0 and heap[index] < heap[parent_index]: heap[index], heap[parent_index] = heap[parent_index], heap[index] _bubble_up(heap, parent_index) def _bubble_down(heap, index): Moves the element at index \'index\' down to maintain the heap property. smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(heap) and heap[left_child_index] < heap[smallest]: smallest = left_child_index if right_child_index < len(heap) and heap[right_child_index] < heap[smallest]: smallest = right_child_index if smallest != index: heap[index], heap[smallest] = heap[smallest], heap[index] _bubble_down(heap, smallest)"},{"question":"# Coding Assessment Question Context You are developing a system that needs to predict the next item that a user is likely to interact with based on historical interaction data. The system leverages a sequence prediction approach using a sliding window technique on the interaction sequence. Problem Description Implement a function `predict_next_item` that predicts the next item in a user\'s interaction sequence using a frequency-based method within a fixed window size. **Function Signature**: ```python def predict_next_item(sequences: list[list[int]], window_size: int) -> list[tuple[list[int], int]]: pass ``` Input - `sequences` (list[list[int]]): A list of sequences where each sequence is a list of integers representing item interactions. - `window_size` (int): An integer representing the size of the sliding window used to analyze each sequence. Output - Returns a list of tuples, where each tuple contains: - The sliding window (as a list of integer values). - The most frequently interacted item in the window (as an integer). Constraints - Each sequence in `sequences` should contain at least `window_size` items. - If there is a tie for the most frequent item within a window, any one of the most frequent items can be returned. - Ensure proper error handling for invalid input sizes, shapes, and data types. Example ```python sequences = [ [1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6] ] window_size = 3 result = predict_next_item(sequences, window_size) # Expected Output: [([1, 2, 3], 1), ([2, 3, 1], 2), ([3, 1, 2], 3), ([4, 5, 6], 4), ([5, 6, 4], 5), ([6, 4, 5], 6)] ``` Requirements 1. Implement a sliding window mechanism to go through each sequence. 2. Within each window, determine the most frequently interacted item. 3. Handle edge cases such as empty sequences or sequences shorter than the window size. 4. Optimize for efficiency to handle large sequences within reasonable time limits.","solution":"from collections import Counter from typing import List, Tuple def predict_next_item(sequences: List[List[int]], window_size: int) -> List[Tuple[List[int], int]]: result = [] for sequence in sequences: if len(sequence) < window_size: continue # skip sequences shorter than the window size for i in range(len(sequence) - window_size + 1): window = sequence[i:i + window_size] most_common_item = Counter(window).most_common(1)[0][0] result.append((window, most_common_item)) return result"},{"question":"# Coding Assessment Question: Fibonacci Sequence **Context**: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence appears in many different areas of mathematics and computer science. Your task is to implement a function that computes the nth number in the Fibonacci sequence. **Requirements**: 1. Implement the function `fibonacci(n: int) -> int`: * The function should take an integer n as input and return the nth Fibonacci number. * You should handle the sequence starting with `fibonacci(0) = 0`, `fibonacci(1) = 1`. 2. Ensure that your function handles edge cases and provides correct results for: * n = 0 * n = 1 * n > 1 3. Your implementation should have: * **Time Complexity**: O(n) * **Space Complexity**: O(1) 4. Validate your function with the following assertions: ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(30) == 832040 ``` **Function Signature**: ```python def fibonacci(n: int) -> int: pass ```","solution":"def fibonacci(n: int) -> int: Computes the nth Fibonacci number using an iterative approach. :param n: The position in the Fibonacci sequence to compute. :return: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement You are required to implement a function that transposes a given rectangular matrix. The transpose of a matrix is achieved by swapping the rows and columns of the matrix. # Function Signature Implement the following function: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input - `matrix`: A rectangular matrix represented as a list of lists of integers. Each inner list represents a row of the matrix. The dimensions of the matrix are `m x n` where `m` is the number of rows and `n` is the number of columns. # Output - A new matrix which is the transpose of the input matrix, represented as a list of lists of integers. # Constraints - The matrix can have any dimensions within the range of `1 <= m, n <= 1000`. - The integers in the matrix can be any valid 32-bit signed integers. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6] ] transposed = transpose_matrix(matrix) print(transposed) ``` Output: ``` [ [1, 4], [2, 5], [3, 6] ] ``` # Hints 1. Use nested loops to iterate over the matrix elements and construct the transposed matrix. 2. The number of rows in the transposed matrix will be equal to the number of columns in the original matrix, and vice versa.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a rectangular matrix, return its transpose. if not matrix or not matrix[0]: return [] # Get the number of rows and columns in the original matrix rows, cols = len(matrix), len(matrix[0]) # Initialize the transposed matrix with cols rows and rows columns transposed = [[0] * rows for _ in range(cols)] # Fill the transposed matrix with elements from the original matrix for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed"},{"question":"# Number System Validation and Conversion Implement a set of functions to validate and convert different representations of numbers: binary (base-2), octal (base-8), decimal (base-10), and hexadecimal (base-16). The functions should be able to: 1. Validate if a given string can be a valid representation of a number in a specified base. 2. Convert a valid number from one base to another. Implementation Requirements 1. **Functions to Implement**: - `is_valid_number(number_str: str, base: int) -> bool` - `convert_number(number_str: str, from_base: int, to_base: int) -> str` 2. **Function Details**: - `is_valid_number`: This function takes a string `number_str` and an integer `base` (which can be 2, 8, 10, 16). It returns `True` if the string is a valid number in the specified base, and `False` otherwise. - `convert_number`: This function takes a string `number_str` representing a number in the base specified by `from_base` and converts it to its string representation in the `to_base`. Both bases are one of the following: 2, 8, 10, 16. The function should raise a `ValueError` with an appropriate error message if the input number is not valid in the `from_base`. 3. **Edge Cases**: - Handle leading zeros appropriately. - Ensure conversion handles both uppercase and lowercase letters for hexadecimal numbers. - Handle invalid inputs gracefully by raising `ValueError` with appropriate error messages. 4. **Expected Output**: - Functions should operate correctly for standard cases, such as binary to decimal, decimal to hexadecimal, etc. - For invalid inputs, appropriate validation checks should raise `ValueError`. 5. **Error Handling**: - For `is_valid_number`, return `False` if the string is not a valid number in the given base. - For `convert_number`, raise a `ValueError` if any invalid number string is provided or if the bases are not supported. **Function Signatures**: ```python def is_valid_number(number_str: str, base: int) -> bool: ... def convert_number(number_str: str, from_base: int, to_base: int) -> str: ... ``` **Constraints**: - Use only Python standard libraries. - Base must be one of the following: 2, 8, 10, 16. - Implement appropriate docstrings and unit tests to ensure functionality. **Example**: ```python # Validation examples assert is_valid_number(\\"1010\\", 2) == True assert is_valid_number(\\"123\\", 2) == False assert is_valid_number(\\"1F4\\", 16) == True assert is_valid_number(\\"1G4\\", 16) == False assert is_valid_number(\\"745\\", 8) == True assert is_valid_number(\\"985\\", 8) == False # Conversion examples assert convert_number(\\"1010\\", 2, 10) == \\"10\\" assert convert_number(\\"10\\", 10, 2) == \\"1010\\" assert convert_number(\\"1A\\", 16, 10) == \\"26\\" assert convert_number(\\"26\\", 10, 16) == \\"1A\\" assert convert_number(\\"745\\", 8, 2) == \\"111100101\\" # Invalid conversion examples should raise ValueError try: convert_number(\\"745\\", 10, 2) except ValueError as e: print(e) # Invalid number in the specified base ```","solution":"def is_valid_number(number_str: str, base: int) -> bool: Checks if the given string is a valid number in the specified base. try: int(number_str, base) return True except ValueError: return False def convert_number(number_str: str, from_base: int, to_base: int) -> str: Converts a number string from one base to another. if not is_valid_number(number_str, from_base): raise ValueError(f\\"Invalid number \'{number_str}\' in base {from_base}\\") # Convert number_str from from_base to an integer number_in_decimal = int(number_str, from_base) if to_base == 2: return bin(number_in_decimal)[2:] elif to_base == 8: return oct(number_in_decimal)[2:] elif to_base == 10: return str(number_in_decimal) elif to_base == 16: return hex(number_in_decimal)[2:].upper() else: raise ValueError(f\\"Unsupported base: {to_base}\\")"},{"question":"# Task Write a function that determines the length of the longest contiguous subsequence of unique integers in an unsorted array. The subsequence must be contiguous in the array but the elements themselves must all be distinct. # Input and Output * **Function Signature**: ```python def longest_unique_subsequence(arr: List[int]) -> int: ``` * **Input**: * `arr` - A list of integers `arr` where 1 ≤ len(arr) ≤ 10^5. * **Output**: * An integer representing the length of the longest contiguous subsequence of unique integers. # Example Your function should behave as follows: ```python print(longest_unique_subsequence([1, 2, 3, 1, 2, 3, 4, 5, 6])) # returns 6 print(longest_unique_subsequence([1, 2, 2, 3, 4, 5])) # returns 4 print(longest_unique_subsequence([5, 5, 5, 5])) # returns 1 print(longest_unique_subsequence([])) # returns 0 ``` # Constraints 1. The solution should have a time complexity of O(n) as the array length can be large. 2. Use only standard modules. # Expectation * Implement a sliding window technique to ensure the solution is efficient. * The algorithm should dynamically adjust the window size to maintain uniqueness within the window.","solution":"from typing import List def longest_unique_subsequence(arr: List[int]) -> int: Determines the length of the longest contiguous subsequence of unique integers in an unsorted array. if not arr: return 0 max_length = 0 current_start = 0 seen_elements = {} for current_end, value in enumerate(arr): if value in seen_elements and seen_elements[value] >= current_start: current_start = seen_elements[value] + 1 seen_elements[value] = current_end max_length = max(max_length, current_end - current_start + 1) return max_length"},{"question":"# Coding Question Scenario You are developing a data visualization tool that processes geospatial data to generate maps and visual summaries. One part of the tool requires you to compute the convex hull of a set of points in a 2D plane. The convex hull is the smallest convex polygon that can enclose all the given points. Task Implement a function `compute_convex_hull` that computes the convex hull of a set of 2D points using the Graham scan algorithm. Function Signature ```python def compute_convex_hull(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]: Compute the convex hull of a set of 2D points using Graham scan algorithm. args: points: A list of tuples representing the (x, y) coordinates of the points. Returns: A list of tuples representing the vertices of the convex hull in counterclockwise order. ``` Constraints * There will be at least three points. * No three points will be collinear. Example Input and Output Example 1: ```python points = [(0, 0), (1, 1), (2, 2), (3, 1), (1, 3), (3, 3)] output = compute_convex_hull(points) expected_output = [(0, 0), (3, 1), (3, 3), (1, 3)] # The points in expected_output correspond to the vertices of the convex hull in counterclockwise order. ``` Example 2: ```python points = [(0, 0), (-1, 1), (-1, -1), (1, -1), (1, 1)] output = compute_convex_hull(points) expected_output = [(-1, -1), (1, -1), (1, 1), (-1, 1)] # The points in expected_output correspond to the vertices of the convex hull in counterclockwise order. ``` Notes * Ensure that your function correctly computes the convex hull and returns the points in the correct order. * Make use of the Graham scan algorithm which involves sorting the points by polar angle and using a stack to detect and eliminate concavities in the point sequence. * The results should precisely match the expected vertices of the convex hull based on the provided input points.","solution":"from typing import List, Tuple def compute_convex_hull(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]: def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) points = sorted(points) if len(points) <= 1: return points lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1]"},{"question":"Sorting Employee Data # Context: A company needs to maintain a sorted list of its employees. Each employee has a unique ID, a name, and a department. The company frequently queries the list to get employees filtered by a particular department, sorted by name, and each of these queries should start with an initial sorted list to ensure results are consistently ordered. # Task: You need to implement a function that takes a list of employee dictionaries and sorts it first by the department and then by the name within each department. # Requirements: 1. **Function Signature**: ```python def sort_employees(employees: list[dict[str, str]]) -> list[dict[str, str]]: pass ``` 2. **Input**: - `employees` (list of dicts): A list where each element is a dictionary containing the keys `id`, `name`, and `department`. 3. **Output**: - A sorted list of employees, where the list is sorted by `department` in ascending order, and within each department, by `name` in ascending order. # Constraints: - Each `id` is a unique string of alphanumeric characters. - `name` and `department` are strings containing primarily alphabetic characters. - The input list can have zero or more employees. # Hints: - You may use Python’s built-in sorting functions which allow for a key parameter where you can define multiple sorting keys. - Consider using the `sorted()` function instead of modifying the input list directly for clarity and immutability. # Example: ```python # Sample usage employees = [ {\\"id\\": \\"e1\\", \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"}, {\\"id\\": \\"e2\\", \\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, {\\"id\\": \\"e3\\", \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\"}, {\\"id\\": \\"e4\\", \\"name\\": \\"Dave\\", \\"department\\": \\"Engineering\\"}, {\\"id\\": \\"e5\\", \\"name\\": \\"Eve\\", \\"department\\": \\"Engineering\\"} ] sorted_employees = sort_employees(employees) print(sorted_employees) # Expected output: # [ # {\\"id\\": \\"e2\\", \\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, # {\\"id\\": \\"e4\\", \\"name\\": \\"Dave\\", \\"department\\": \\"Engineering\\"}, # {\\"id\\": \\"e5\\", \\"name\\": \\"Eve\\", \\"department\\": \\"Engineering\\"}, # {\\"id\\": \\"e1\\", \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"}, # {\\"id\\": \\"e3\\", \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\"} # ] ``` # Edge Cases: - Empty input list should return an empty list. - Employees with identical names but different departments. - Departments and names containing special characters.","solution":"def sort_employees(employees): Sorts a list of employee dictionaries first by department and then by name within each department. return sorted(employees, key=lambda emp: (emp[\'department\'], emp[\'name\']))"},{"question":"# Problem Statement You are given an undirected, connected graph with `N` nodes and `M` edges. Each edge has a weight associated with it. Your task is to preprocess the graph so that you can efficiently answer multiple queries about the maximum weighted edge in the path between two given nodes. You need to implement functions for: 1. **Depth-First Search (DFS)** for setting up depth levels, immediate parent links, and maximum weighted edges information. 2. **Sparse Table Construction** for efficient maximum edge weight queries. 3. **Maximum Edge Weight Query** using the sparse table. # Functions to Implement You need to implement the following three functions: 1. `depth_first_search(node: int, parent_node: int, level: List[int], parent: List[List[int]], max_edge: List[List[int]], graph: Dict[int, List[Tuple[int, int]]], depth: int=0) -> None`: - **Input**: - `node`: The current node being visited. - `parent_node`: The parent node of the current node. - `level`: A list initialized with -1 of size `max_node + 10` to store the depth of each node. - `parent`: A 2D list initialized with 0\'s of size `[20][max_node + 10]` to store the immediate parent of nodes. - `max_edge`: A 2D list initialized with 0\'s of size `[20][max_node + 10]` to store the maximum weighted edge in the path. - `graph`: A dictionary representation of the graph where keys represent a node and values are lists of tuples (neighbor, weight). - `depth`: The depth of the current node in the DFS traversal. - **Output**: This function modifies the `level`, `parent`, and `max_edge` lists in place. 2. `create_sparse(max_node: int, parent: List[List[int]], max_edge: List[List[int]]) -> None`: - **Input**: - `max_node`: An integer representing the maximum number of nodes in the graph. - `parent`: A 2D list representing the immediate parent of nodes. - `max_edge`: A 2D list representing the maximum weighted edge in paths. - **Output**: These lists are updated to store 2^i-th parent and maximum weighted edge for each node in place. 3. `max_edge_weight(u: int, v: int, level: List[int], parent: List[List[int]], max_edge: List[List[int]]) -> int`: - **Input**: - `u`: The first node in the query. - `v`: The second node in the query. - `level`: The list representing depth of each node. - `parent`: The 2D list representing 2^i-th parents. - `max_edge`: The 2D list representing maximum weighted edges. - **Output**: An integer representing the maximum weighted edge in the path between the nodes `u` and `v`. # Example ```python max_node = 9 parent = [[0 for _ in range(max_node + 10)] for _ in range(20)] max_edge = [[0 for _ in range(max_node + 10)] for _ in range(20)] level = [-1 for _ in range(max_node + 10)] graph = { 1: [(2, 3), (3, 1)], 2: [(1, 3), (4, 2)], 3: [(1, 1), (5, 4)], 4: [(2, 2)], 5: [(3, 4), (6, 5)], 6: [(5, 5), (7, 6), (8, 7)], 7: [(6, 6)], 8: [(6, 7), (9, 8)], 9: [(8, 8)], } depth_first_search(1, -1, level, parent, max_edge, graph) create_sparse(max_node, parent, max_edge) print(\\"Maximum edge weight in the path between 1 and 3 is:\\", max_edge_weight(1, 3, level, parent, max_edge)) print(\\"Maximum edge weight in the path between 5 and 9 is:\\", max_edge_weight(5, 9, level, parent, max_edge)) ``` # Constraints - Ensure that the `parent` and `max_edge` lists are initialized correctly. - Handle nodes that may have multiple edges appropriately. - The graph will have `N` nodes and `M` edges where `1 <= N, M <= 10^5`.","solution":"def depth_first_search(node, parent_node, level, parent, max_edge, graph, depth=0): Depth-First Search to initialize levels, parent and max_edge arrays. level[node] = depth parent[0][node] = parent_node for neighbor, weight in graph[node]: if neighbor != parent_node: max_edge[0][neighbor] = weight depth_first_search(neighbor, node, level, parent, max_edge, graph, depth + 1) def create_sparse(max_node, parent, max_edge): Sparse table construction to allow fast LCA computation and max edge retrieval. for i in range(1, 20): for node in range(1, max_node + 1): if parent[i-1][node] != -1: parent[i][node] = parent[i-1][parent[i-1][node]] max_edge[i][node] = max(max_edge[i-1][node], max_edge[i-1][parent[i-1][node]]) def max_edge_weight(u, v, level, parent, max_edge): Returns the maximum edge weight in the path between nodes u and v, using the precomputed sparse tables. if level[u] < level[v]: u, v = v, u # Lift u to the same level as v diff = level[u] - level[v] max_edge_in_path = 0 for i in range(19, -1, -1): if (diff >> i) & 1: max_edge_in_path = max(max_edge_in_path, max_edge[i][u]) u = parent[i][u] if u == v: return max_edge_in_path for i in range(19, -1, -1): if parent[i][u] != parent[i][v]: max_edge_in_path = max(max_edge_in_path, max_edge[i][u], max_edge[i][v]) u = parent[i][u] v = parent[i][v] max_edge_in_path = max(max_edge_in_path, max_edge[0][u], max_edge[0][v]) return max_edge_in_path"},{"question":"# Merge Two Sorted Linked Lists Scenario A company needs to merge data from two different sorted sources into a single sorted list for further processing. You are tasked with writing a function to accomplish this. Task Write a function `merge_sorted_lists(list1: Node, list2: Node) -> Node` that takes two sorted singly linked lists and merges them into a single sorted linked list. Input The function will receive the heads of two singly linked lists: - `list1`: a `Node` instance where `Node` is defined as follows: ```python @dataclass class Node: data: int next: Node | None = None ``` - `list2`: a `Node` instance with the same structure as `list1`. Output The function should return the head of the merged singly linked list that is sorted. Constraints - The `data` values in the nodes are integers. - Both `list1` and `list2` are already sorted in non-decreasing order. - Either or both of `list1` and `list2` can be empty (None). Example ```python # Example of two sorted linked lists # list1: 1 -> 3 -> 5 # list2: 2 -> 4 -> 6 list1 = Node(data=1, next=Node(data=3, next=Node(data=5))) list2 = Node(data=2, next=Node(data=4, next=Node(data=6))) merged_list = merge_sorted_lists(list1, list2) # Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6 # If one of the lists is empty # list1: 1 -> 2 -> 3 # list2: None list1 = Node(data=1, next=Node(data=2, next=Node(data=3))) list2 = None merged_list = merge_sorted_lists(list1, list2) # Output: 1 -> 2 -> 3 ``` # Additional Notes - Ensure the function handles edge cases like both lists being empty or one being significantly longer than the other. - Optimize the function to maintain efficient time complexity.","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: data: int next: Optional[\'Node\'] = None def merge_sorted_lists(list1: Optional[Node], list2: Optional[Node]) -> Optional[Node]: Merge two sorted linked lists into a single sorted linked list. :param list1: The head of the first sorted linked list. :param list2: The head of the second sorted linked list. :return: The head of the merged sorted linked list. if list1 is None: return list2 if list2 is None: return list1 # Initialize a dummy node to build the merged list upon dummy = Node(0) tail = dummy # Merge the two lists while list1 and list2: if list1.data <= list2.data: tail.next = list1 list1 = list1.next else: tail.next = list2 list2 = list2.next tail = tail.next # Attach the remaining elements, if any if list1: tail.next = list1 elif list2: tail.next = list2 # The merged list is next to the dummy node return dummy.next"},{"question":"# Coding Question **Context**: Lina, an avid runner, wants to keep track of her running routes and the corresponding mileages. She needs a program to compute the total distance run over different days based on her jogging routes. **Task**: Write a Python class `JoggingTracker` that: 1. Manages a list of jogging routes, where each route has a name and a distance. 2. Allows adding new routes, removing existing ones, and retrieving the total distance run so far. **Class Signature**: ```python class JoggingTracker: A class used to track jogging routes and total distance run. Methods ------- add_route(name: str, distance: float) -> None Adds a new jogging route with the given name and distance. remove_route(name: str) -> None Removes an existing jogging route by name. get_total_distance() -> float Returns the total distance run across all routes. pass ``` **Constraints**: * The distance should be a non-negative floating-point number. * The route names should be unique. * The class should handle attempts to remove routes that do not exist gracefully. **Example**: ```python tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) tracker.add_route(\\"Evening Run\\", 3.8) print(tracker.get_total_distance()) # Output: 9.0 tracker.remove_route(\\"Morning Run\\") print(tracker.get_total_distance()) # Output: 3.8 tracker.add_route(\\"Night Run\\", 2.5) print(tracker.get_total_distance()) # Output: 6.3 ``` Additionally, ensure your implementation handles edge cases, such as adding routes with zero distance or removing routes that are not present in the list.","solution":"class JoggingTracker: A class used to track jogging routes and total distance run. def __init__(self): self.routes = {} def add_route(self, name: str, distance: float) -> None: Adds a new jogging route with the given name and distance. if distance < 0: raise ValueError(\\"Distance cannot be negative\\") self.routes[name] = distance def remove_route(self, name: str) -> None: Removes an existing jogging route by name. if name in self.routes: del self.routes[name] def get_total_distance(self) -> float: Returns the total distance run across all routes. return sum(self.routes.values())"},{"question":"# Question: Fibonacci Subsequence Check In this problem, you need to determine whether a given list of integers is a subsequence of the Fibonacci sequence. A subsequence is a sequence derived by deleting zero or more elements from another sequence without changing the order of the remaining elements. Write a function `is_fibonacci_subsequence(lst: list) -> bool` to determine if the list `lst` is a subsequence of the Fibonacci sequence. **Function Signature**: ```python def is_fibonacci_subsequence(lst: list) -> bool: ``` **Input**: - `lst`: a list of integers where each integer is within the range [0, 10^9]. **Output**: - A boolean indicating whether `lst` is a subsequence of the Fibonacci sequence. **Examples**: ```python >>> is_fibonacci_subsequence([1, 3, 13]) True >>> is_fibonacci_subsequence([2, 8, 21]) True >>> is_fibonacci_subsequence([4, 6, 9]) False >>> is_fibonacci_subsequence([1, 2, 3, 5, 13]) True ``` # Constraints: - The elements in the list `lst` are non-negative integers. - The input list can have up to 10^5 elements. # Notes: - The Fibonacci sequence starts with F0 = 0, F1 = 1, and each subsequent term is the sum of the previous two terms, i.e., Fi = Fi−1 + Fi−2 for i ≥ 2. - Your solution should efficiently handle large lists and large numbers by generating the necessary Fibonacci terms up to the maximum value found in the list `lst`. # Approach: 1. Generate the Fibonacci sequence up to the maximum possible value in the `lst`. 2. Use this sequence to check if `lst` is a subsequence by iterating through both the list and the Fibonacci sequence in tandem.","solution":"def is_fibonacci_subsequence(lst: list) -> bool: Determine if the given list is a subsequence of the Fibonacci sequence. if not lst: return True # Find the maximum value in the list max_val = max(lst) # Generate Fibonacci sequence up to the maximum value fib = [0, 1] while fib[-1] < max_val: fib.append(fib[-1] + fib[-2]) # Convert to set for quick lookup fib_set = set(fib) # Check if all elements in lst are found in the Fibonacci set for num in lst: if num not in fib_set: return False return True"},{"question":"# Coding Challenge: Path Planning in a Weighted Grid Scenario: You are a robotics engineer designing a pathfinding system for a robot in a warehouse. The warehouse is represented as a grid where each cell has a certain cost to traverse. The robot needs to find the path with the minimum total cost from the top-left corner to the bottom-right corner of the grid. The robot can move in four possible directions: up, down, left, or right. Task: Implement an algorithm using Dijkstra\'s shortest path algorithm to find the minimum cost path from the top-left to the bottom-right corner of the grid. Input: * An integer `n` representing the number of rows in the grid. * An integer `m` representing the number of columns in the grid. * A 2D list `cost` of integers where `cost[i][j]` represents the cost to traverse cell `(i, j)`. Output: An integer representing the minimum cost to reach the bottom-right corner from the top-left corner of the grid. Constraints: * (1 leq n, m leq 1000) * (0 leq cost[i][j] leq 100) Example: Input: ``` n = 3 m = 3 cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` Output: ``` 7 ``` Implementation Details: - Define a function `minimum_cost_path(n: int, m: int, cost: List[List[int]]) -> int` to perform the task. - Ensure your function adheres to the provided input and output formats. - Use appropriate data structures, such as a priority queue, to ensure efficiency. ```python from heapq import heappush, heappop from typing import List def minimum_cost_path(n: int, m: int, cost: List[List[int]]) -> int: directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(cost[0][0], 0, 0)] # (cost, row, col) visited = [[False] * m for _ in range(n)] visited[0][0] = True while min_heap: current_cost, row, col = heappop(min_heap) if row == n - 1 and col == m - 1: return current_cost for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < m and not visited[r][c]: visited[r][c] = True heappush(min_heap, (current_cost + cost[r][c], r, c)) return float(\'inf\') # In case there is no valid path, which shouldn\'t happen as per constraints # Example usage: if __name__ == \\"__main__\\": n = 3 m = 3 cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(minimum_cost_path(n, m, cost)) # Output should be 7 ```","solution":"from heapq import heappush, heappop from typing import List def minimum_cost_path(n: int, m: int, cost: List[List[int]]) -> int: directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(cost[0][0], 0, 0)] # (cost, row, col) visited = [[False] * m for _ in range(n)] visited[0][0] = True while min_heap: current_cost, row, col = heappop(min_heap) if row == n - 1 and col == m - 1: return current_cost for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < m and not visited[r][c]: visited[r][c] = True heappush(min_heap, (current_cost + cost[r][c], r, c)) return float(\'inf\') # In case there is no valid path, which shouldn\'t happen as per constraints # Example usage: if __name__ == \\"__main__\\": n = 3 m = 3 cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(minimum_cost_path(n, m, cost)) # Output should be 7"},{"question":"# Coding Assessment Question Custom Stack Implementation with Minimum Retrieval You are required to implement a custom stack that, alongside standard stack operations, provides the ability to retrieve the minimum element in constant time. Optimize your data structures and methods to ensure efficiency. Task 1. Implement a `CustomStack` class with the following methods: - `push(element)`: Pushes an element onto the stack. - `pop()`: Removes the top element from the stack. - `top()`: Retrieves the top element without removing it. - `get_min()`: Retrieves the minimum element in the stack. 2. Ensure all operations are performed in O(1) time complexity. Function Signatures and Behavioral Outline ```python class CustomStack: def __init__(self): # Initialize your stack structure here. pass def push(self, element): # Push element onto the stack pass def pop(self): # Pop the top element off the stack and return it, or return None if the stack is empty pass def top(self): # Return the top element, or None if the stack is empty pass def get_min(self): # Return the minimum element in the stack, or None if the stack is empty pass ``` Input Examples and Output Expectations ```python # Create custom stack instance stack = CustomStack() # Perform stack operations stack.push(5) stack.push(3) stack.push(8) stack.push(1) print(stack.get_min()) # Output: 1 (minimum element) stack.pop() print(stack.get_min()) # Output: 3 (minimum element after popping 1) print(stack.top()) # Output: 8 (top element without removing it) stack.pop() print(stack.top()) # Output: 3 (top element after popping 8) print(stack.get_min()) # Output: 3 (minimum element remains 3) ``` - **Constraints**: - Elements pushed onto the stack are integers. - Stack operations will not exceed 100,000 calls in total. - **Performance Requirements**: - Ensure that the `get_min` method maintains constant time complexity. - Optimize the `push` and `pop` methods to maintain the efficiency of the stack operations. Test your implementation comprehensively to ensure it adheres to the requirements and performs optimally under high operation counts.","solution":"class CustomStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, element): self.stack.append(element) if not self.min_stack or element <= self.min_stack[-1]: self.min_stack.append(element) def pop(self): if not self.stack: return None top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() return top_element def top(self): if not self.stack: return None return self.stack[-1] def get_min(self): if not self.min_stack: return None return self.min_stack[-1]"},{"question":"# Problem Statement **Array Rotation Counter** You are given a rotated sorted array, which is originally a sorted array that has been rotated a number of times. For example, the sorted array `[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]` after a rotation. Your task is to determine the number of rotations performed on the original sorted array to obtain the given rotated array. # Specific Requirements 1. **Function Signature**: ```python def count_rotations(rotated_array: list[int]) -> int: ``` 2. **Input**: - `rotated_array`: List of integers in a rotated sorted order (e.g., [4, 5, 6, 7, 0, 1, 2]). 3. **Output**: - Return an integer representing the number of rotations to make the array from the initial sorted form. 4. **Constraints**: - The array will have no duplicate values. - The array will contain at least one element and at most 10^5 elements. - Each element in the array will have a value between -10^5 and 10^5. 5. **Edge Cases**: - The function should correctly handle an array of length 1. - The function should correctly handle arrays that have not been rotated at all. # Example ```python assert count_rotations([4, 5, 6, 7, 0, 1, 2]) == 4 assert count_rotations([7, 9, 11, 12, 15]) == 0 assert count_rotations([15, 18, 2, 3, 6, 12]) == 2 assert count_rotations([1, 2, 3, 4]) == 0 assert count_rotations([2, 3, 4, 1]) == 3 ``` Explanation - The array `[4, 5, 6, 7, 0, 1, 2]` is a rotated version of the sorted array `[0, 1, 2, 4, 5, 6, 7]`, and it takes four rotations to achieve this. - The array `[7, 9, 11, 12, 15]` is already sorted and has not been rotated, so the rotation count is 0. - The array `[15, 18, 2, 3, 6, 12]` had to be rotated twice to achieve this order from the sorted array `[2, 3, 6, 12, 15, 18]`. - The array `[1, 2, 3, 4]` is already sorted and thus not rotated, resulting in 0 rotations. - The array `[2, 3, 4, 1]` required three rotations starting from the sorted array `[1, 2, 3, 4]`.","solution":"def count_rotations(rotated_array: list[int]) -> int: Given a rotated sorted array, return the number of rotations performed on the original sorted array. low, high = 0, len(rotated_array) - 1 # If array is not rotated at all if rotated_array[low] < rotated_array[high]: return 0 while low <= high: mid = (low + high) // 2 # Check if mid+1 is the minimum element if mid < high and rotated_array[mid] > rotated_array[mid + 1]: return mid + 1 # Check if mid is the minimum element if mid > low and rotated_array[mid] < rotated_array[mid - 1]: return mid # Decide the sub-array to search if rotated_array[mid] >= rotated_array[low]: low = mid + 1 else: high = mid - 1 return 0"},{"question":"# Problem Statement You are given an array of integers representing an elevation map where the width of each bar is 1. Imagine that the elevation map is filled with water. The maximum water that can be trapped in the elevation map is calculated by summing the water at every bar. Your task is to determine how much water it can trap after raining. Write a function `trap_water` that takes in a list of integers representing the elevation map and returns an integer value indicating the total amount of trapped water. Function Signature ```python def trap_water(height: list[int]) -> int: pass ``` Input * `height` (list): A list of non-negative integers representing the elevation map with length `0 <= len(height) <= 1000`. Output * An integer value: The total amount of water trapped. Example ```python assert trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert trap_water([4,2,0,3,2,5]) == 9 ``` Constraints * You can assume that the list contains only non-negative integers. * Optimize for both time and space complexities. # Additional Context You can refer to algorithmic techniques and data structures for efficient calculation such as using two pointers or dynamic programming to handle the problem efficiently.","solution":"def trap_water(height: list[int]) -> int: if not height: return 0 left = 0 right = len(height) - 1 left_max = height[left] right_max = height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"# Problem Statement You are provided with a `LinkedList` class that supports various operations like insertion, deletion, and search. Enhance this class by adding a new functionality that finds and returns the middle element of the linked list in a single pass. # Requirements 1. **Function to Implement**: `find_middle()` method inside the `LinkedList` class. 2. **Input**: The `LinkedList` object itself. 3. **Output**: The value of the middle node. If the list has an even number of nodes, return the value of the second middle node. 4. **Performance**: Aim for (O(n)) time complexity and (O(1)) space complexity. 5. **Constraints**: You may assume that the linked list contains at least one node. # Example ```python ll = LinkedList() ll.insert(1) ll.insert(2) ll.insert(3) ll.insert(4) ll.insert(5) print(ll.find_middle()) # Output: 3 ll.insert(6) print(ll.find_middle()) # Output: 4 ``` # Notes - You must use the two-pointer technique to achieve the task in a single pass. - The first pointer (slow) moves one step at a time, while the second pointer (fast) moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the middle.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def find_middle(self): slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.value"},{"question":"**Problem Statement**: A Fibonacci series is a sequence of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The nth Fibonacci number `Fₙ` is given by the recursive formula: [ Fₙ = Fₙ₋₁ + Fₙ₋₂ ] with initial conditions: [ F₀ = 0, quad F₁ = 1 ] Given a positive integer `n`, write a Python function `fibonacci_series(n: int) -> list[int]` that returns a list of the first `n` Fibonacci numbers. **Function Signature**: ```python def fibonacci_series(n: int) -> list[int]: ``` # Input * A positive integer `n` which indicates the number of first Fibonacci numbers to generate. # Output * A list of integers containing the first `n` Fibonacci numbers. # Constraints * `n` should be a positive integer (greater than zero). # Examples ```python >>> fibonacci_series(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_series(5) [0, 1, 1, 2, 3] >>> fibonacci_series(1) [0] ``` # Notes * Ensure the function raises a `ValueError` if the input is not a positive integer. * Optimize for performance to handle reasonably large values of `n` without recursion to avoid excessive call stack usage.","solution":"def fibonacci_series(n: int) -> list[int]: if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") fibs = [0, 1] # Initial values for the first two Fibonacci numbers if n == 1: return [0] for i in range(2, n): fibs.append(fibs[-1] + fibs[-2]) return fibs[:n]"},{"question":"# Problem Statement In a social media platform, users can follow each other, forming a complex web of connections. You are required to determine the shortest path of connections between two users. If no such path exists, return -1. # Function Signature ```python def shortest_connection_path(connections: list[list[int]], start: int, end: int) -> int: pass ``` # Input - `connections` : A list of lists where each sub-list `[a, b]` represents a directed connection from user `a` to user `b`. - `start` : An integer representing the starting user\'s ID. - `end` : An integer representing the target user\'s ID. # Output - Return the length of the shortest path of connections from `start` to `end` as an integer. If there\'s no path, return -1. # Constraints 1. The number of users will be between 1 and 10^5. 2. The number of connections will be between 0 and 10^5. 3. User IDs are unique and range from 0 to the maximum number of users. # Examples ```python assert shortest_connection_path([[0, 1], [1, 2], [2, 3], [3, 4]], 0, 4) == 4 assert shortest_connection_path([[0, 1], [1, 2], [2, 3], [3, 4]], 0, 5) == -1 assert shortest_connection_path([], 0, 0) == 0 assert shortest_connection_path([[0, 1], [2, 3]], 0, 3) == -1 ``` # Explanation 1. For the first example: - There exists a direct path from user 0 to 4: `0 -> 1 -> 2 -> 3 -> 4`, with a length of 4 connections. 2. For the second example: - There is no path connecting user 0 to user 5, hence -1 is returned. 3. For the third example: - The start and end user are the same, requiring no connections, thus the length is 0. 4. For the fourth example: - Users 0 and 3 are not connected, resulting in -1. Implement the function to efficiently find the shortest connection path using appropriate graph traversal algorithms such as Breadth-First Search (BFS). # Scenario The platform needs to suggest the shortest sequence of connections for networking opportunities or to efficiently propagate information across the network. Your task is to analyze the network structure and determine the shortest path between specified users, if it exists.","solution":"from collections import deque, defaultdict def shortest_connection_path(connections, start, end): if start == end: return 0 graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) # Assume bi-directional connections unless specified visited = {start} queue = deque([(start, 0)]) # (current node, distance) while queue: current, distance = queue.popleft() for neighbor in graph[current]: if neighbor == end: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1"},{"question":"# Knapsack Problem using Dynamic Programming Alice is a logistician responsible for optimizing the load of a spacecraft. She needs to determine the maximum value that can be carried in the spacecraft given a weight limit and an array of items, each with a specific weight and value. To solve this, she wants to use the dynamic programming approach to the 0/1 Knapsack problem. Function Signature: ```python def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: pass ``` # Input * `max_weight`: An integer representing the maximum weight the spacecraft can carry. * `weights`: A list of integers where each element represents the weight of an item. * `values`: A list of integers where each element represents the value of an item. # Output * An integer representing the maximum value that can be carried in the spacecraft without exceeding the given weight limit. # Constraints * `1 <= len(weights) == len(values) <= 100` * `1 <= weights[i], values[i] <= 1000` * `1 <= max_weight <= 1000` # Example ```python weights = [10, 20, 30] values = [60, 100, 120] max_weight = 50 assert knapsack(max_weight, weights, values) == 220 ``` # Additional Requirements 1. Consider typical edge cases such as zero capacity in the spacecraft and items with zero weight or value. 2. Ensure the function is efficient and can handle the upper limits of the input sizes. 3. Explain your approach, particularly why dynamic programming is appropriate for this problem and any time complexity considerations. Implement the `knapsack` function to achieve the above requirements.","solution":"from typing import List def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: n = len(weights) dp = [[0] * (max_weight + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_weight + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][max_weight]"},{"question":"# Problem You are given an integer array and an integer threshold. Your task is to implement a new sorting technique known as Threshold-Pivot Quick Sort. This technique is similar to Quick Sort but incorporates a threshold to switch to Bubble Sort once the sublist size falls below a certain threshold. This hybrid sorting algorithm aims to optimize the sorting for various input sizes and distributions. # Function Signature ```python def threshold_pivot_quick_sort(arr: list[int], threshold: int) -> list[int]: ... ``` # Input * `arr`: A list of integers with length `n` where (1 leq n leq 10^5). * `threshold`: An integer where (1 leq text{threshold} leq 50). # Output * Returns the sorted list in ascending order. # Requirements/Constraints 1. Your solution should maintain an average time complexity of O(n log n) for a well-chosen threshold. 2. Space complexity should be O(log n) due to recursion stack. 3. You should avoid unnecessary comparisons and operations. 4. Ensure that the solution gracefully handles edge cases (e.g., empty lists, lists with duplicates, lists where all items are in reverse order). # Example ```python assert threshold_pivot_quick_sort([35, 23, 1, 4, 53], 10) == [1, 4, 23, 35, 53] assert threshold_pivot_quick_sort([99], 5) == [99] assert threshold_pivot_quick_sort([-8, 0, 7, -3, 3], 3) == [-8, -3, 0, 3, 7] ``` # Detailed Explanation 1. **Partition Array**: Choose a pivot and partition the array into two subarrays, one with elements less than the pivot and the other with elements greater than or equal to the pivot. 2. **Recursive Sorting**: Recursively apply the Threshold-Pivot Quick Sort to both subarrays. 3. **Switching to Bubble Sort**: When the subarray size is less than or equal to the provided threshold, switch from Quick Sort to Bubble Sort for better performance on small arrays. 4. **Combining Results**: Merge the sorted subarrays to produce the final sorted array. By using Threshold-Pivot Quick Sort, the algorithm optimizes for scenarios where small subarrays can be sorted more efficiently using Bubble Sort, thereby potentially reducing the overall comparision operations and improving performance on average.","solution":"def threshold_pivot_quick_sort(arr: list[int], threshold: int) -> list[int]: def bubble_sort(subarr): n = len(subarr) for i in range(n): for j in range(0, n-i-1): if subarr[j] > subarr[j+1]: subarr[j], subarr[j+1] = subarr[j+1], subarr[j] return subarr def quick_sort_recursive(lst): if len(lst) <= 1: return lst elif len(lst) <= threshold: return bubble_sort(lst) else: pivot = lst[len(lst) // 2] left = [x for x in lst if x < pivot] middle = [x for x in lst if x == pivot] right = [x for x in lst if x > pivot] return quick_sort_recursive(left) + middle + quick_sort_recursive(right) return quick_sort_recursive(arr)"},{"question":"# Coding Challenge: Generating All Unique Permutations You are tasked with generating all unique permutations of a given list of integers, which might contain duplicates. # Task **Function to Implement:** ```python def unique_permutations(nums): Given a list of integers `nums` which might contain duplicates, return a list of all unique permutations. Parameters: nums (List[int]): The list of integers to permute. Returns: List[List[int]]: A list of unique permutations, where each permutation is itself a list of integers. pass ``` **Expected Input and Output:** - **Input**: - `nums`: A list of integers, which may contain duplicates. - **Output**: - A list of unique permutations, where each permutation is a list of integers. # Constraints - The length of `nums` will not exceed 8. - The list may contain any integer, from negative to positive. # Example ```python print(unique_permutations([1, 1, 2])) # Output should be [[1, 1, 2], [1, 2, 1], [2, 1, 1]] print(unique_permutations([2, 2, 1, 1])) # Output should be [[2, 2, 1, 1], [2, 1, 2, 1], [2, 1, 1, 2], [1, 2, 2, 1], [1, 2, 1, 2], [1, 1, 2, 2]] print(unique_permutations([3, 3, 3])) # Output should be [[3, 3, 3]] ``` # Implementation Notes - Use a backtracking approach to generate permutations. - To handle duplicates, ensure the permutations are generated in a way that avoids redundant results. You might consider sorting the input list and using a boolean array to track used elements to achieve this.","solution":"from typing import List from itertools import permutations def unique_permutations(nums: List[int]) -> List[List[int]]: Given a list of integers `nums` which might contain duplicates, return a list of all unique permutations. Parameters: nums (List[int]): The list of integers to permute. Returns: List[List[int]]: A list of unique permutations, where each permutation is itself a list of integers. return list(map(list, set(permutations(nums))))"},{"question":"# Problem Statement Given an encoded string where repetitions of substrings are expressed as `k[substring]`, where `k` is a positive integer and can be nested within other substrings, implement a function to decode it. # Input and Output - **Input**: A single string, `s`, which is the encoded string. - **Output**: A decoded string. # Constraints - The length of the string `s` is between 1 and 10<sup>5</sup>. - `k` is guaranteed to be a positive integer. - The string `s` contains only lowercase English letters, digits, and square brackets. - The input string is always valid, without extra spaces, and well-formed. # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Example ```python # Example 1 s = \\"3[a]2[bc]\\" print(decode_string(s)) # Output should be \\"aaabcbc\\" # Example 2 s = \\"3[a2[c]]\\" print(decode_string(s)) # Output should be \\"accaccacc\\" # Example 3 s = \\"2[abc]3[cd]ef\\" print(decode_string(s)) # Output should be \\"abcabccdcdcdef\\" # Example 4 s = \\"abc3[cd]xyz\\" print(decode_string(s)) # Output should be \\"abccdcdcdxyz\\" ``` # Requirements 1. Implement the function to decode nested encoded strings. 2. Optimize the function to handle large inputs efficiently. 3. Handle cases where multiple nested levels are present within the encoded string.","solution":"def decode_string(s: str) -> str: def decode_helper(s: str, idx: int): decoded_string = [] k = 0 while idx < len(s): if s[idx].isdigit(): k = k * 10 + int(s[idx]) elif s[idx] == \'[\': idx, substr = decode_helper(s, idx + 1) decoded_string.append(substr * k) k = 0 elif s[idx] == \']\': return idx, \'\'.join(decoded_string) else: decoded_string.append(s[idx]) idx += 1 return \'\'.join(decoded_string) return decode_helper(s, 0)"},{"question":"# Connected Components in a Graph Context You are developing a social network platform that visually represents user connections through a graph. Each user is a node, and an edge between two nodes indicates a friendship. To recommend new friends, you need to identify isolated groups or communities within this network, known as connected components. Problem Statement Implement a function `connected_components(network: List[List[int]]) -> int` that returns the number of connected components in an undirected graph represented by an adjacency matrix. Input * A list of lists of integers `network`, where `network[i][j]` is `1` if there is an edge between node `i` and node `j`, and `0` otherwise. The size of `network` is `n x n` where `n` is the number of nodes (2 ≤ n ≤ 100). Output * An integer representing the number of connected components in the graph. Constraints * Assume the input `network` will always be a square matrix of integers within the given range. * Each node is connected to itself, i.e., `network[i][i]` is always `1`. Performance Requirements * The solution should efficiently handle the maximum value of `n`. Example ```python def connected_components(network: List[List[int]]) -> int: Calculates the number of connected components in the graph. Args: network (List[List[int]]): Adjacency matrix of the graph. Returns: int: Number of connected components. n = len(network) visited = [False] * n def dfs(node): stack = [node] while stack: s = stack.pop() for neighbor in range(n): if network[s][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) count = 0 for i in range(n): if not visited[i]: dfs(i) count += 1 return count # Test Cases print(connected_components([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ])) # Output: 2 print(connected_components([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 1] ])) # Output: 3 print(connected_components([ [1] ])) # Output: 1 print(connected_components([ [1, 0], [0, 1] ])) # Output: 2 ```","solution":"def connected_components(network): Calculates the number of connected components in the graph. Args: network (List[List[int]]): Adjacency matrix of the graph. Returns: int: Number of connected components. n = len(network) visited = [False] * n def dfs(node): stack = [node] while stack: s = stack.pop() for neighbor in range(n): if network[s][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) count = 0 for i in range(n): if not visited[i]: dfs(i) count += 1 return count"},{"question":"# Coding Assessment Question Context You are working on a utility that processes log files for a server. The logs record user actions, including login and logout times, in CSV format. Your task is to analyze these logs to determine the average session duration for all users. Task Create a function `calculate_average_session_duration(log_file_path: str) -> str` which: 1. Reads the log file specified by the `log_file_path`. 2. Parses the CSV data to extract login and logout times for each user. 3. Calculates the session durations for each user. 4. Computes the average session duration and returns it as a formatted string. Requirements 1. Implement the function `calculate_average_session_duration(log_file_path: str) -> str`. 2. The function should return the average session duration in \\"HH:MM:SS\\" format. 3. Handle scenarios where users might have multiple sessions and compute the duration for each session. 4. Assume each session will have a corresponding login and logout time. 5. Handle potential inconsistencies or missing data gracefully. Input and Output * **Input**: A string `log_file_path` representing the path to the CSV log file. * **Output**: A string representing the average session duration in \\"HH:MM:SS\\" format. Constraints * The CSV log file contains at least one record of a login and logout time for each user. * The CSV format is: ``` user_id,action,timestamp 1,login,2023-01-01 08:00:00 1,logout,2023-01-01 10:00:00 2,login,2023-01-01 09:00:00 2,logout,2023-01-01 11:00:00 ``` * Assume the environment has access to required libraries like `pandas` or `csv` for reading CSV files. * Your solution should handle edge cases such as improper file paths or corrupted data entries. Example: ```python >>> average_duration = calculate_average_session_duration(\\"/path/to/log_file.csv\\") >>> print(average_duration) \'02:00:00\' ```","solution":"import pandas as pd def calculate_average_session_duration(log_file_path: str) -> str: Calculate the average session duration from the log file. Args: log_file_path (str): Path to the CSV log file. Returns: str: The average session duration formatted as \\"HH:MM:SS\\". try: # Load the log file df = pd.read_csv(log_file_path) # Ensure data integrity by sorting and grouping df = df.sort_values(by=[\'user_id\', \'timestamp\']) # Calculate session durations session_durations = [] for user_id, group in df.groupby(\'user_id\'): logins = group[group.action == \'login\'][\'timestamp\'] logouts = group[group.action == \'logout\'][\'timestamp\'] durations = (pd.to_datetime(logouts.values) - pd.to_datetime(logins.values)).total_seconds() session_durations.extend(durations) # Calculate the average session duration average_duration_sec = sum(session_durations) / len(session_durations) # Convert to HH:MM:SS format hours, remainder = divmod(average_duration_sec, 3600) minutes, seconds = divmod(remainder, 60) average_duration = f\'{int(hours):02}:{int(minutes):02}:{int(seconds):02}\' return average_duration except Exception as e: return \\"Error processing log file: \\" + str(e)"},{"question":"# Problem Statement You have been hired as a software developer at a logistics company to help manage the loading and unloading of containers at their facilities. Your task is to implement an algorithm that helps in maintaining the order of containers efficiently. Write a program that simulates the management of containers using a data structure that allows: 1. Adding a container at the top. 2. Removing the top container. 3. Retrieving the current number of containers. Your task is to implement a class `ContainerStack` with the following methods: - `push(container_id: int) -> None`: Adds a container with the given `container_id` to the top. - `pop() -> int`: Removes and returns the container_id from the top. If the stack is empty, return -1. - `size() -> int`: Returns the current number of containers in the stack. # Class Signature ```python class ContainerStack: def __init__(self): # Initialize your data structure here pass def push(self, container_id: int) -> None: pass def pop(self) -> int: pass def size(self) -> int: pass ``` # Input * `container_id` (an integer 1 <= `container_id` <= 10^6): The unique identifier of each container. # Output * `push` method does not return any value. * `pop` method returns the `container_id` of the container being removed from the stack. If the stack is empty, it should return `-1`. * `size` method returns the number of containers present in the stack. # Constraints - All `container_id` values are unique. - You must ensure that all operations are performed efficiently. # Performance Requirements - The operations must handle up to 10^5 operations efficiently. # Example ```python stack = ContainerStack() stack.push(1001) stack.push(1002) print(stack.size()) # Output: 2 print(stack.pop()) # Output: 1002 print(stack.size()) # Output: 1 print(stack.pop()) # Output: 1001 print(stack.pop()) # Output: -1 print(stack.size()) # Output: 0 ``` # Additional Notes Considerations: 1. Ensure that your implementation is optimal for the given constraints. 2. Handle edge cases where the stack might be empty when calling the `pop` method. 3. The implementation should be intuitive and maintain the appropriate stack operations (LIFO - Last In First Out).","solution":"class ContainerStack: def __init__(self): # Initialize the stack as an empty list self.stack = [] def push(self, container_id: int) -> None: # Append the container_id to the stack self.stack.append(container_id) def pop(self) -> int: # Pop the top container_id if stack is not empty, else return -1 return self.stack.pop() if self.stack else -1 def size(self) -> int: # Return the current size of the stack return len(self.stack)"},{"question":"# Binary Tree Level Order Traversal You are required to implement a function that performs a level order traversal on a binary tree. A level order traversal visits all the nodes at each depth level, from left to right, before moving to nodes at the next depth level. # Input and Output Formats: - **Input**: A binary tree. * Each node in the tree has a value, and references to the left and right child nodes. * The binary tree structure is provided as a class `TreeNode` with attributes `val`, `left`, and `right`. - **Output**: A list of lists where each sublist contains the node values at each level. # Constraints: - The tree will have at most 10,000 nodes. - Node values are non-negative integers. - Implement the function with O(N) time complexity, where N is the number of nodes in the tree. # Context Example: Suppose you are given a binary tree to represent a company\'s hierarchy. A level order traversal can be used to print the hierarchy level by level. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode): Performs a level order traversal of the binary tree. Returns a list of lists where each sublist contains the node values at each level. pass # Example # Given binary tree [3, 9, 20, None, None, 15, 7]: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert level_order_traversal(root) == [ [3], [9, 20], [15, 7] ] # Additional Tests # Empty tree => [] empty_tree = None assert level_order_traversal(empty_tree) == [] # Single node tree [1] => [[1]] single_node_tree = TreeNode(1) assert level_order_traversal(single_node_tree) == [[1]] ``` # Note: - Use a queue data structure to help with the level order traversal. - Initialize the queue with the root node and process each node level by level, appending its left and right children to the queue. - Ensure that the final output format is a list of lists containing the node values at each level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode): Performs a level order traversal of the binary tree. Returns a list of lists where each sublist contains the node values at each level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Coding Question Develop an algorithm that takes a string representing an arithmetic expression and validates if the parentheses in the expression are balanced. Your task is to implement the function `is_expression_balanced(expression: str) -> bool`. Function Signature ```python def is_expression_balanced(expression: str) -> bool: # implementation goes here ``` # Requirements 1. **Input**: - `expression` (str): A string containing an arithmetic expression, which consists of digits, operators (`+`, `-`, `*`, `/`, `%`), and parentheses (`(`, `)`). 2. **Output**: - Returns a boolean value indicating whether the parentheses in the expression are balanced. # Constraints 1. The length of the input string can be up to 1000 characters. 2. Only the characters mentioned (digits, `+`, `-`, `*`, `/`, `%`, `(`, `)`) are provided. # Example Scenarios Example 1: ```python print(is_expression_balanced(\\"3 + (2 - (7 * 4)) / (5)\\")) # Expected Output: True ``` Example 2: ```python print(is_expression_balanced(\\"5 + (3 * (9 / 2)) - (4 * 3))\\")) # Expected Output: False ``` Example 3: ```python print(is_expression_balanced(\\"((3 + 5) * (6)) / 2)\\")) # Expected Output: False ``` # Notes - Consider using a stack data structure to efficiently check the balance of parentheses. - The function should handle cases where there are no parentheses and return `True` in such scenarios. - Ensure the function runs efficiently within the constraints. Compose the function in a clean, readable format with appropriate comments to explain your implementation logic.","solution":"def is_expression_balanced(expression: str) -> bool: Check if the parentheses in the expression are balanced. Args: expression (str): Arithmetic expression containing digits, operators, and parentheses. Returns: bool: True if parentheses are balanced, False otherwise. stack = [] # Iterate through each character in the expression for char in expression: # If the character is an opening parenthesis, push it onto the stack if char == \'(\': stack.append(char) # If the character is a closing parenthesis, check the stack elif char == \')\': # If stack is empty or top of the stack is not an opening parenthesis, it\'s unbalanced if not stack or stack[-1] != \'(\': return False # Pop the top of the stack stack.pop() # If the stack is not empty after processing the entire expression, it\'s unbalanced return len(stack) == 0"},{"question":"# Coding Assessment Question Scenario You are tasked with enhancing an existing library application by implementing a new feature: the ability to generate call numbers for books based on the Dewey Decimal Classification (DDC) system. Each call number is composed of the DDC number followed by the first three letters of the author\'s last name and the publication year. Your implementation must correctly format the call number, which is essential for library cataloging and search functionalities. Objectives Implement a function that generates a call number string for a book using the DDC number, author\'s last name, and year of publication. Function Signature ```python def generate_call_number(ddc: float, author_last_name: str, year: int) -> str: pass ``` Input * A float `ddc` representing the Dewey Decimal Classification number. * A string `author_last_name` representing the last name of the author. * An integer `year` representing the year of publication. Output * A string representing the call number in the format specified in the instructions. Constraints * The `ddc` number will be a float between 0.00 and 999.99 inclusive. * The `author_last_name` will be a non-empty string containing only alphabetical characters and will have a length between 1 and 100 characters. * The `year` will be an integer between 1000 and the current year (inclusive). Performance Requirements * The function should run efficiently with respect to both time and space complexity. Example ```python >>> generate_call_number(813.54, \\"Rowling\\", 1997) \'813.54 ROW 1997\' >>> generate_call_number(950.1, \\"Murakami\\", 2002) \'950.10 MUR 2002\' ``` Instructions 1. Format the Dewey Decimal number (`ddc`) to two decimal places, even if unnecessary (e.g., 813 should be shown as 813.00). 2. Extract the first three uppercase letters from the author\'s last name. If the last name is shorter than three letters, use the available letters. 3. Concatenate these components in the order: DDC number, author\'s last name (first three letters), and the publication year, separated by spaces. 4. Ensure no unnecessary leading or trailing spaces are included in the final output. 5. Handle edge cases such as short author last names properly.","solution":"def generate_call_number(ddc: float, author_last_name: str, year: int) -> str: Generates a call number for a book based on the Dewey Decimal Classification system, author\'s last name, and publication year. :param ddc: A float representing the Dewey Decimal Classification number. :param author_last_name: A string representing the last name of the author. :param year: An integer representing the year of publication. :return: A string representing the call number. # Format the DDC number to two decimal places. ddc_formatted = f\\"{ddc:.2f}\\" # Extract the first three uppercase letters from the author\'s last name. author_code = author_last_name[:3].upper() # Construct the call number. call_number = f\\"{ddc_formatted} {author_code} {year}\\" return call_number"},{"question":"# Distinct Random Numbers in a List You are tasked with implementing a function to generate a list of unique random integers within a specified range. The range and the number of unique integers required are provided as input parameters. The function should ensure that no two integers in the result are the same. # Key Information * The range is defined by two integers: `lower_bound` and `upper_bound`. * The requested number of unique integers is given by `number_count`. # Expected Input and Output * **Input**: * `lower_bound` (int): The lower limit of the range inclusive. * `upper_bound` (int): The upper limit of the range inclusive. * `number_count` (int): The number of unique integers to generate. * **Output**: * List of unique integers sorted in ascending order. # Function Signature `def generate_unique_random_numbers(lower_bound: int, upper_bound: int, number_count: int) -> list:` # Example ```python # Example 1: generate_unique_random_numbers(1, 10, 5) # Output: [2, 4, 5, 7, 9] # Example 2: generate_unique_random_numbers(10, 15, 3) # Output: [10, 12, 14] ``` # Constraints * The `lower_bound` must be less than or equal to the `upper_bound`. * The `number_count` must not exceed the total numbers available in the range (i.e., `upper_bound - lower_bound + 1`). * All inputs must be integers. # Notes * Ensure the list contains exactly `number_count` unique integers. * Utilize appropriate error handling to manage erroneous inputs. * If `number_count` exceeds the available unique numbers in the range, raise a `ValueError`. Write a function that implements the above logic, produces the correct output, and handles edge cases appropriately. Happy coding!","solution":"import random def generate_unique_random_numbers(lower_bound: int, upper_bound: int, number_count: int) -> list: Generate a sorted list of unique random integers within the specified range. Parameters: lower_bound (int): The lower limit of the range inclusive. upper_bound (int): The upper limit of the range inclusive. number_count (int): The number of unique integers to generate. Returns: list: A sorted list of unique random integers. Raises: ValueError: If the number_count exceeds the available unique numbers in the range. if lower_bound > upper_bound: raise ValueError(\\"Lower bound cannot be greater than upper bound\\") total_numbers = upper_bound - lower_bound + 1 if number_count > total_numbers: raise ValueError(\\"number_count exceeds the number of available unique numbers in the specified range\\") unique_numbers = random.sample(range(lower_bound, upper_bound + 1), number_count) unique_numbers.sort() return unique_numbers"},{"question":"# Problem Statement You are given a grid of size m x n representing an area filled with water and land. A cell is a water cell if its value is 0 and a land cell if its value is 1. An island is a maximal group of connected land cells, where a cell is considered connected to its adjacent cells horizontally or vertically (not diagonally). Write a function `num_islands(grid: List[List[int]]) -> int` that finds the number of islands in the grid. # Function Signature ```python def num_islands(grid: List[List[int]]) -> int: ``` # Input * `grid`: A list of lists of integers (1s and 0s) representing the grid. # Output * An integer representing the number of islands. # Constraints * The grid will have at most dimensions 300 x 300. * The grid will contain only 0s and 1s. # Example ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] print(num_islands(grid)) # Output: 3 ``` **Note**: Use Depth First Search (DFS) or Breadth First Search (BFS) to efficiently solve the problem. # Requirements * Implement the function to handle edge cases such as no land or all land cells. * Ensure the function has optimal time and space complexity for large grids.","solution":"from typing import List def num_islands(grid: List[List[int]]) -> int: if not grid: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the cell as visited dfs(i + 1, j) # Visit down dfs(i - 1, j) # Visit up dfs(i, j + 1) # Visit right dfs(i, j - 1) # Visit left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) count += 1 return count"},{"question":"# List of Employees: Data Organization and Querying In this task, you are required to create a system to organize and query employee data. You will implement a class `EmployeeRegistry` that includes functionalities to add employee records, find employees by their department, and list all employees with a specific job title. # Class and Methods Specification: Class: ```python class EmployeeRegistry: def __init__(self): pass def add_employee(self, employee_id: int, name: str, department: str, job_title: str) -> None: pass def find_by_department(self, department: str) -> list: pass def list_by_job_title(self, job_title: str) -> list: pass ``` # Method Description: * `__init__(self)`: Initialize the `EmployeeRegistry` instance and create an empty registry. * `add_employee(self, employee_id: int, name: str, department: str, job_title: str) -> None`: Adds an employee to the registry with the given `employee_id`, `name`, `department`, and `job_title`. Each attribute should be stored in the registry. * `find_by_department(self, department: str) -> list`: Returns a list of all employee names that belong to the specified department. * `list_by_job_title(self, job_title: str) -> list`: Returns a list of all employee names that have the specified job title. # Constraints: - The `employee_id` is a unique integer for each employee. - The `name` is a string containing the employee\'s name. - The `department` and `job_title` are strings describing the employee\'s department and job title respectively. - All string inputs are case-insensitive. The system should treat inputs such as \\"Human Resources\\" and \\"human resources\\" as identical. - Employee names should be stored and returned in the same format as they were provided when the `add_employee` method was called. # Examples: ```python employee_registry = EmployeeRegistry() # Adding employees employee_registry.add_employee(1, \\"Alice\\", \\"Human Resources\\", \\"Recruiter\\") employee_registry.add_employee(2, \\"Bob\\", \\"Engineering\\", \\"Software Engineer\\") employee_registry.add_employee(3, \\"Charlie\\", \\"Engineering\\", \\"DevOps Engineer\\") employee_registry.add_employee(4, \\"David\\", \\"Human Resources\\", \\"HR Manager\\") # Finding employees by department hr_employees = employee_registry.find_by_department(\\"human resources\\") print(hr_employees) # Output: [\\"Alice\\", \\"David\\"] engineering_employees = employee_registry.find_by_department(\\"Engineering\\") print(engineering_employees) # Output: [\\"Bob\\", \\"Charlie\\"] # Listing employees by job title recruiters = employee_registry.list_by_job_title(\\"recruiter\\") print(recruiters) # Output: [\\"Alice\\"] devops_engineers = employee_registry.list_by_job_title(\\"DevOps Engineer\\") print(devops_engineers) # Output: [\\"Charlie\\"] ``` Additional validation: 1. If the `add_employee` method is called with a duplicate `employee_id`, ignore the addition and do not throw an error. 2. Ensure that the `find_by_department` and `list_by_job_title` methods return employee names in the order they were added.","solution":"class EmployeeRegistry: def __init__(self): self.registry = {} def add_employee(self, employee_id: int, name: str, department: str, job_title: str) -> None: if employee_id not in self.registry: self.registry[employee_id] = { \\"name\\": name, \\"department\\": department.lower(), \\"job_title\\": job_title.lower() } def find_by_department(self, department: str) -> list: department = department.lower() return [info[\\"name\\"] for info in self.registry.values() if info[\\"department\\"] == department] def list_by_job_title(self, job_title: str) -> list: job_title = job_title.lower() return [info[\\"name\\"] for info in self.registry.values() if info[\\"job_title\\"] == job_title]"},{"question":"# Problem Statement You are given a binary tree represented as a list of lists, where each list corresponds to a level of the tree. Your task is to write a function that, given this level-order representation, converts it into a binary tree data structure and then returns the post-order traversal of the tree. **Function Signature**: ```python def post_order_traversal(levels: List[List[int]]) -> List[int]: ``` # Input: * `levels` (List[List[int]]): A 2D list where each sublist contains the nodes at that level of the tree. # Output: * Returns a list of integers representing the nodes in post-order traversal. # Example: ```python levels = [ [1], [2, 3], [4, 5, 6, 7] ] print(post_order_traversal(levels)) # Output: [4, 5, 2, 6, 7, 3, 1] ``` # Constraints: * The number of nodes will not exceed 1000. * The values of the nodes are unique integers. # Notes: - You should first reconstruct the binary tree from the level-order input. - Post-order traversal is defined as visiting the left subtree, the right subtree, and then the node. - Handle the case where the tree is empty, i.e., `levels` is an empty list. # Hints: - Consider using a queue to help with building the binary tree level by level. - Recursion can be helpful when implementing post-order traversal.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def build_tree(levels: List[List[int]]) -> Optional[TreeNode]: if not levels: return None root = TreeNode(levels[0][0]) queue = deque([root]) i = 1 while queue and i < len(levels): num_nodes_at_current_level = len(queue) for _ in range(num_nodes_at_current_level): node = queue.popleft() left_val = levels[i].pop(0) if levels[i] else None right_val = levels[i].pop(0) if levels[i] else None if left_val is not None: node.left = TreeNode(left_val) queue.append(node.left) if right_val is not None: node.right = TreeNode(right_val) queue.append(node.right) if not levels[i]: i += 1 return root def post_order_traversal(levels: List[List[int]]) -> List[int]: def post_order(node: Optional[TreeNode], result: List[int]): if node: post_order(node.left, result) post_order(node.right, result) result.append(node.val) root = build_tree(levels) result = [] post_order(root, result) return result"},{"question":"# Question: Build a Binary Tree from Preorder and Inorder Traversals Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]: ``` # Input - `preorder` (List[int]): A list of integers representing the preorder traversal of the binary tree. - `inorder` (List[int]): A list of integers representing the inorder traversal of the binary tree. # Output - Returns the root `TreeNode` of the constructed binary tree. # Constraints 1. `1 <= len(preorder), len(inorder) <= 3000` 2. `preorder` and `inorder` consist of unique integers. # Example ```python >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> root = build_tree(preorder, inorder) >>> print(root.val) 3 >>> print(root.left.val) 9 >>> print(root.right.val) 20 >>> print(root.right.left.val) 15 >>> print(root.right.right.val) 7 ``` # Explanation The given input represents the preorder traversal `[3, 9, 20, 15, 7]` and inorder traversal `[9, 3, 15, 20, 7]` of a binary tree. The function should reconstruct and return the binary tree based on these traversals. The tree constructed from the input example would look like: ``` 3 / 9 20 / 15 7 ``` # Hints 1. The first element in the `preorder` list is the root of the tree. 2. Use the `inorder` list to determine the left and right subtrees of the root. 3. Recursively build the tree by partitioning the `preorder` and `inorder` lists accordingly.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]: if not preorder or not inorder: return None # The first element in preorder is the root of the tree root_val = preorder[0] root = TreeNode(root_val) # Find the index of the root in inorder to split left and right subtrees inorder_index = inorder.index(root_val) # Recursively build the left and right subtrees root.left = build_tree(preorder[1:1 + inorder_index], inorder[:inorder_index]) root.right = build_tree(preorder[1 + inorder_index:], inorder[inorder_index + 1:]) return root"},{"question":"# Objective: Develop a function to evaluate the validity of a string of parentheses and return the correct sequence according to specified rules. # Problem Statement: You are given a string `s` consisting of characters \'(\' and \')\'. Your task is to write a function `valid_parentheses_sequence(s: str) -> str` that returns a well-formed parentheses subsequence of the input string `s` that is the longest possible. # Function Signature ```python def valid_parentheses_sequence(s: str) -> str: pass ``` # Input * `s` (str): A string where `1 <= len(s) <= 10^5` and the characters are only \'(\' and \')\'. # Output * Return a string representing the longest possible well-formed parentheses subsequence. # Constraints 1. The input string can be empty, in which case the output should also be an empty string. 2. The solution should manage the maximum length for efficient computation within given constraints. # Example ```python assert valid_parentheses_sequence(\\"(()())\\") == \\"(()())\\" assert valid_parentheses_sequence(\\"()()\\") == \\"()()\\" assert valid_parentheses_sequence(\\")()())\\") == \\"()()\\" assert valid_parentheses_sequence(\\"(((((\\") == \\"\\" assert valid_parentheses_sequence(\\"))\\") == \\"\\" assert valid_parentheses_sequence(\\"())()(((\\") == \\"()()\\" ``` # Notes * The expected solution should function in `O(N)` time complexity. * Use a stack or a counter to verify and construct the valid parentheses sequence. * Consider the order of parentheses when adding them to the result string to ensure they form a well-formed sequence. # Additional Information * Ensure the algorithm processes each parenthesis only once to adhere to the time complexity constraint. * Return any longest well-formed subsequence if there are multiple correct answers.","solution":"def valid_parentheses_sequence(s: str) -> str: Returns a well-formed parentheses subsequence of the input string `s` that is the longest possible. # Counters for open and close parentheses open_count = 0 close_count = 0 # First pass to determine the maximum number of matching pairs for char in s: if char == \'(\': open_count += 1 elif char == \')\' and open_count > 0: open_count -= 1 close_count += 1 # We can form `close_count` pairs, so we need exactly `close_count` open and `close_count` close parentheses result = [] open_needed = close_count close_needed = close_count for char in s: if char == \'(\' and open_needed > 0: result.append(char) open_needed -= 1 elif char == \')\' and close_needed > 0 and open_needed < close_count: result.append(char) close_needed -= 1 close_count -= 1 return \'\'.join(result)"},{"question":"# Find Minimum Subarray Sum # Background In many financial and data analysis applications, it is important to identify trends or patterns in a sequence of numbers. One common problem is to determine the smallest possible sum of contiguous subarrays within a given array, which can reveal negative trends or losses over a period. # Task You are required to implement a Python function that finds the minimum possible sum of any contiguous subarray within a given list of integers. # Input - A list of integers, `nums`. # Output - An integer representing the minimum sum of any contiguous subarray within the input list. # Constraints - The length of the list `nums` is between 1 and 10^5. - Each element in the list `nums` is between -10^4 and 10^4. # Function Signature ```python def min_subarray_sum(nums: list) -> int: :param nums: list[int] - The list of integers to evaluate. :return: int - The minimum sum of any contiguous subarray. ``` # Example Suppose the input list `nums` is: ``` [-2, 1, -3, 4, -1, 2, 1, -5, 4] ``` The function should return `-6`, which is the sum of the subarray `[-3, 4, -1, 2, 1, -5]`. # Hints - Consider the properties of Kadane\'s Algorithm, which is typically used to find the maximum sum of contiguous subarrays, and how it might be adapted to find the minimum sum. - Be mindful of edge cases, such as when the input list has only one element. # Solution Template ```python def min_subarray_sum(nums: list) -> int: current_min = nums[0] global_min = nums[0] for num in nums[1:]: current_min = min(num, current_min + num) if current_min < global_min: global_min = current_min return global_min # Example usage: if __name__ == \\"__main__\\": example_nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] print(min_subarray_sum(example_nums)) # Output: -6 ```","solution":"def min_subarray_sum(nums: list) -> int: Returns the minimum sum of any contiguous subarray within the input list. current_min = nums[0] global_min = nums[0] for num in nums[1:]: current_min = min(num, current_min + num) if current_min < global_min: global_min = current_min return global_min"},{"question":"# Problem Statement You need to implement a function to perform matrix-vector multiplication and write another function to check if a matrix is invertible, and if so, compute its inverse. These tasks are fundamental in linear algebra and have applications in various fields such as computer graphics, engineering, and optimization. # Function Definitions 1. `matrix_vector_multiplication(matrix: np.ndarray, vector: np.ndarray) -> np.ndarray` - **Input**: - `matrix`: A 2D numpy array representing an m x n matrix. - `vector`: A 1D numpy array of length n. - **Output**: A 1D numpy array of length m, which is the result of multiplying the matrix by the vector. 2. `inverse_matrix(matrix: np.ndarray) -> np.ndarray` - **Input**: A square matrix represented as a 2D NumPy array. - **Output**: The inverse of the matrix, also as a 2D NumPy array. - **Constraints**: - Ensure that the matrix is invertible before performing calculations. - Raise an error if the matrix is not invertible or not square. # Example ```python import numpy as np A = np.array([ [4, 7], [2, 6] ]) v = np.array([1, 1]) result_vector = matrix_vector_multiplication(A, v) assert np.array_equal(result_vector, np.array([11, 8])) inverse_A = inverse_matrix(A) expected_inverse_A = np.array([ [0.6, -0.7], [-0.2, 0.4] ]) assert np.allclose(inverse_A, expected_inverse_A) ``` # Note - Make use of numpy\'s built-in functions for matrix operations to ensure efficiency and simplicity. - Ensure that the functions handle edge cases appropriately, such as checking for non-square matrices, singular matrices, or mismatched dimensions in the multiplication function. - Include proper error-handling mechanisms and informative messages where applicable.","solution":"import numpy as np def matrix_vector_multiplication(matrix: np.ndarray, vector: np.ndarray) -> np.ndarray: Performs matrix-vector multiplication. Parameters: matrix (np.ndarray): The m x n matrix vector (np.ndarray): The vector of length n Returns: np.ndarray: The resulting vector of length m if matrix.shape[1] != vector.shape[0]: raise ValueError(\\"Matrix columns and vector length must match.\\") return np.dot(matrix, vector) def inverse_matrix(matrix: np.ndarray) -> np.ndarray: Computes the inverse of the given square matrix. Parameters: matrix (np.ndarray): The square matrix Returns: np.ndarray: The inverse of the matrix Raises: ValueError: If the matrix is not square or not invertible if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"Matrix must be square to be invertible.\\") try: inverse = np.linalg.inv(matrix) except np.linalg.LinAlgError: raise ValueError(\\"Matrix is not invertible.\\") return inverse"},{"question":"Sure, here is an additional question that aligns with the provided sample question in terms of style, length, complexity, and scope: # [Question 2] You are given a string `s` that represents a sequence of parentheses, braces, and brackets. Your task is to determine if the sequence of characters is valid. A sequence is considered valid if all brackets are closed in the correct order. # Function Signature ```python def is_valid_sequence(s: str) -> bool: s : str : The input string containing only \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Returns a boolean indicating whether the input string is a valid sequence. ``` # Input * `s` (str): A string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Length of the string `s` can be up to 10^4. # Output * Returns a boolean indicating whether the input string is a valid sequence of brackets. # Constraints 1. The function must handle the calculation efficiently within a time complexity of O(n). 2. No additional libraries should be used for the implementation. # Example ```python def test_is_valid_sequence(): assert is_valid_sequence(\\"()\\") == True assert is_valid_sequence(\\"()[]{}\\") == True assert is_valid_sequence(\\"(]\\") == False assert is_valid_sequence(\\"([)]\\") == False assert is_valid_sequence(\\"{[]}\\") == True test_is_valid_sequence() ``` # Explanation 1. The example shows five test cases: * `\\"()\\"` is valid because both brackets match. * `\\"()[]{}\\"` is valid because each type of bracket matches in the correct order. * `\\"(]\\"` is not valid because the order of brackets is incorrect. * `\\"([)]\\"` is not valid because the brackets are not closed in the correct order. * `\\"{[]}\\"` is valid because each pair of brackets is closed in the correct order. 2. Your solution should use a stack to keep track of the matching brackets and ensure that every opening bracket has a corresponding closing bracket in the correct order. 3. The function should return a boolean indicating whether the string is a valid sequence of brackets. # Note * You should ensure to handle all edge cases as demonstrated in the test cases. For instance, empty strings should also be considered valid.","solution":"def is_valid_sequence(s: str) -> bool: s : str : The input string containing only \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Returns a boolean indicating whether the input string is a valid sequence. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"**Dynamic Programming: Longest Common Subsequence (LCS)** You’ve been hired by a software development company to implement a feature that finds the longest common subsequence between two given sequences. This feature is crucial for their version control system to help developers identify common code snippets between files, aiding in merge conflict resolution. # Problem Statement You are given two strings, `str1` and `str2`. Your task is to find the length of the longest subsequence that is common to both strings. A subsequence is a sequence derived from another sequence by deleting some elements while keeping the order of the remaining elements. # Task Implement the function `longest_common_subsequence(str1, str2)` that returns the length of the longest common subsequence between `str1` and `str2`. # Expected Input and Output Formats ```python def longest_common_subsequence(str1: str, str2: str) -> int: pass ``` - `str1`: A string consisting of lowercase letters. - `str2`: A string consisting of lowercase letters. **Output**: An integer representing the length of the longest common subsequence between the two strings. # Constraints 1. `1 <= len(str1) <= 1000` 2. `1 <= len(str2) <= 1000` 3. `str1` and `str2` consist of lowercase English letters only. # Performance Requirements Your solution should employ dynamic programming to run efficiently within the size constraints. # Scenario Consider you are trying to find common code segments between two versions of the same piece of software to understand similarities and differences, and aid in automated merging processes. # Example ```python str1 = \\"abcde\\" str2 = \\"ace\\" print(longest_common_subsequence(str1, str2)) # Output: 3 ``` In this example, the longest common subsequence between `str1` and `str2` is \\"ace\\", which has a length of 3. # Additional Example ```python str1 = \\"abc\\" str2 = \\"def\\" print(longest_common_subsequence(str1, str2)) # Output: 0 ``` In this example, there is no common subsequence between `str1` and `str2`, hence the output is 0. **Note**: The solution should utilize a dynamic programming approach to efficiently compute the LCS length within the given constraints.","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) # Initialize a 2D array to store the lengths of longest common subsequences dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of longest common subsequence is in the bottom-right cell return dp[m][n]"},{"question":"# Coding Challenge: Fibonacci Sequence and Query Context: You are required to implement functions that deal with the Fibonacci sequence, a famous series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. These functions are crucial for various applications in computer science and mathematics. # Function 1: N-th Fibonacci Number **Description**: Write a function, `nth_fibonacci(n: int) -> int`, that takes a positive integer `n` and returns the n-th Fibonacci number. The sequence starts with `0, 1, ...` - **Input**: An integer `n` (0 ≤ n ≤ 10^5) - **Output**: An integer representing the n-th Fibonacci number. - **Constraints**: - Ensure the function is optimized and uses matrix exponentiation or memoization to handle large values efficiently. - The function should handle the base cases where `n=0` returns `0` and `n=1` returns `1`. # Function 2: Fibonacci Range Query **Description**: Write a function, `fibonacci_in_range(start: int, end: int) -> List[int]`, that takes two integers `start` and `end`, and returns a list of all Fibonacci numbers within that range (inclusive). - **Input**: Two integers `start` and `end` (0 ≤ start ≤ end ≤ 10^6) - **Output**: A list of integers containing the Fibonacci numbers between `start` and `end` (inclusive). ```python from typing import List def nth_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. pass # Implement the function def fibonacci_in_range(start: int, end: int) -> List[int]: Returns a list of Fibonacci numbers in the range [start, end]. pass # Implement the function # Example Usage: # nth_fibonacci(7) -> 13 # fibonacci_in_range(10, 100) -> [13, 21, 34, 55, 89] ``` Notes: 1. Ensure your solutions are optimized for the given constraints. 2. Your functions should include necessary input validation and handle edge cases appropriately.","solution":"from typing import List def nth_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_in_range(start: int, end: int) -> List[int]: Returns a list of Fibonacci numbers in the range [start, end]. fibs = [] a, b = 0, 1 while a <= end: if a >= start: fibs.append(a) a, b = b, a + b return fibs"},{"question":"**Context**: You are designing a sparse matrix class to handle large matrices with many zero elements efficiently. This class supports basic operations like insertion and printing of the matrix. However, there is a need to implement a feature that adds two sparse matrices. **Objective:** Implement the `add` method in the given `SparseMatrix` class that adds two sparse matrices. This method must ensure that the sum of two sparse matrices is also represented as a sparse matrix. **Function Signature:** ```python class SparseMatrix: def __init__(self): self.elements = {} # dictionary to store non-zero elements {(row, col): value} def insert(self, row: int, col: int, value: int) -> None: if value != 0: self.elements[(row, col)] = value def print_matrix(self, rows: int, cols: int) -> None: for i in range(rows): for j in range(cols): print(self.elements.get((i, j), 0), end=\' \') print() def add(self, other: \'SparseMatrix\') -> \'SparseMatrix\': Add two sparse matrices and return the resultant sparse matrix. Args: other (SparseMatrix): Another sparse matrix to add to self. Returns: SparseMatrix: The resultant sparse matrix. Example: >>> matrix1 = SparseMatrix() >>> matrix1.insert(0, 0, 1) >>> matrix1.insert(1, 2, 3) >>> matrix2 = SparseMatrix() >>> matrix2.insert(0, 0, 4) >>> matrix2.insert(1, 2, 5) >>> matrix_sum = matrix1.add(matrix2) >>> matrix_sum.print_matrix(2, 3) 5 0 0 0 0 8 ``` **Constraints:** - Both matrices to be added are of the same dimensions. - The matrices are sparse, meaning they contain a large number of zero elements. **Examples:** 1. Adding two matrices: ```python matrix1 = SparseMatrix() matrix1.insert(0, 0, 1) matrix1.insert(1, 2, 3) matrix2 = SparseMatrix() matrix2.insert(0, 0, 4) matrix2.insert(1, 2, 5) matrix_sum = matrix1.add(matrix2) matrix_sum.print_matrix(2, 3) # Output should be: # 5 0 0 # 0 0 8 ``` 2. Adding a matrix to an empty matrix: ```python matrix1 = SparseMatrix() matrix2 = SparseMatrix() matrix2.insert(0, 1, 2) matrix_sum = matrix1.add(matrix2) matrix_sum.print_matrix(1, 2) # Output should be: # 0 2 ``` 3. Adding two matrices with all zero elements: ```python matrix1 = SparseMatrix() matrix2 = SparseMatrix() matrix_sum = matrix1.add(matrix2) matrix_sum.print_matrix(1, 1) # Output should be: # 0 ```","solution":"class SparseMatrix: def __init__(self): self.elements = {} # dictionary to store non-zero elements {(row, col): value} def insert(self, row: int, col: int, value: int) -> None: if value != 0: self.elements[(row, col)] = value elif (row, col) in self.elements: del self.elements[(row, col)] def print_matrix(self, rows: int, cols: int) -> None: for i in range(rows): for j in range(cols): print(self.elements.get((i, j), 0), end=\' \') print() def add(self, other: \'SparseMatrix\') -> \'SparseMatrix\': Add two sparse matrices and return the resultant sparse matrix. Args: other (SparseMatrix): Another sparse matrix to add to self. Returns: SparseMatrix: The resultant sparse matrix. result = SparseMatrix() # Add elements from the first matrix for (row, col), value in self.elements.items(): result.insert(row, col, value) # Add elements from the second matrix for (row, col), value in other.elements.items(): if (row, col) in result.elements: result.insert(row, col, result.elements[(row, col)] + value) else: result.insert(row, col, value) return result"},{"question":"# Question Write a function `convert_to_base` that converts a given non-negative integer to its representation in a specified base between 2 and 36. **Function Signature**: ```python def convert_to_base(number: int, base: int) -> str: ``` **Input**: - `number` (int): A non-negative integer to be converted. (0 <= number <= 10^12) - `base` (int): The base to which the number should be converted. (2 <= base <= 36) **Output**: - A string representation of the number in the specified base. **Constraints**: - The function should handle bases between 2 and 36 inclusive. - The digit values for bases greater than 10 should be represented using lowercase English letters (e.g., a for 10, b for 11, ..., z for 35). # Examples ```python # Example 1 number = 255 base = 16 print(convert_to_base(number, base)) # Output: \'ff\' # Example 2 number = 100 base = 2 print(convert_to_base(number, base)) # Output: \'1100100\' # Example 3 number = 1234567890 base = 36 print(convert_to_base(number, base)) # Output: \'kf12oi\' # Example 4 number = 0 base = 10 print(convert_to_base(number, base)) # Output: \'0\' ``` **Notes**: - Consider edge cases, such as when the number is zero. - Ensure your function correctly handles upper bounds for both `number` and `base`. - You may not use Python\'s built-in functions (`bin`, `oct`, `hex`, etc.) directly but can use standard string and list methods to achieve the conversion. - Remember to account for both digits and characters in bases greater than 10.","solution":"def convert_to_base(number: int, base: int) -> str: Converts a given non-negative integer to its representation in a specified base between 2 and 36. if number == 0: return \'0\' digits = \\"0123456789abcdefghijklmnopqrstuvwxyz\\" result = \\"\\" while number > 0: digit = number % base result = digits[digit] + result number //= base return result"},{"question":"# Problem Statement: Circuit Power Consumption Calculation You are tasked with creating a library to help engineers and hobbyists calculate the power consumption of a simple resistive circuit powered by a constant voltage source. You\'ll write functions to compute the total power consumption using the voltage and resistor values in the circuit. **Context and Functions:** An electric circuit consists of a voltage source and one or more resistors connected in series. The calculations for power consumption, voltage drop across each resistor, and current are as follows: 1. **Total Power Consumption (in watts)**: [ text{Power} = V^2 / R_{total} ] Where ( R_{total} = R1 + R2 + ... + Rn ) is the sum of the resistances. 2. **Voltage Drop across each resistor (Ri) (in volts)**: [ V_{drop_i} = I cdot Ri ] Where ( I = V / R_{total} ) is the current through the circuit. **Tasks**: 1. **Implement the function `total_power(voltage: float, resistances: List[float]) -> float`.** * The function should calculate and return the total power consumption of the circuit. * Ensure that it raises a `ValueError` if the voltage is non-positive, or if any of the resistances are non-positive. **Example**: ```python >>> total_power(12, [10, 20, 30]) 2.4 >>> total_power(5, [-10, 20, 30]) Traceback (most recent call last): ... ValueError: Voltage and resistances must be positive ``` 2. **Implement the function `voltage_drops(voltage: float, resistances: List[float]) -> List[float]`.** * The function should calculate and return a list of voltage drops across each resistor in the same order as provided. * Ensure that it raises a `ValueError` if the voltage is non-positive, or if any of the resistances are non-positive. **Example**: ```python >>> voltage_drops(12, [10, 20, 30]) [2.0, 4.0, 6.0] >>> voltage_drops(5, [10, 0, 30]) Traceback (most recent call last): ... ValueError: Voltage and resistances must be positive ``` **Input Constraints**: - (0 < V leq 1000) - (0 < R1, R2, ..., Rn leq 10^6) **Assumptions**: - The circuit configuration and components are within physically plausible ranges. Your implementation should be robust and handle edge cases such as zero or negative inputs appropriately.","solution":"from typing import List def total_power(voltage: float, resistances: List[float]) -> float: Calculate and return the total power consumption of the circuit. :param voltage: The voltage across the series circuit. :param resistances: A list of individual resistances in the circuit. :return: The total power consumption. :raises ValueError: If voltage is non-positive or if any resistance is non-positive. if voltage <= 0 or any(r <= 0 for r in resistances): raise ValueError(\\"Voltage and resistances must be positive\\") total_resistance = sum(resistances) power = (voltage ** 2) / total_resistance return power def voltage_drops(voltage: float, resistances: List[float]) -> List[float]: Calculate and return the list of voltage drops across each resistor. :param voltage: The voltage across the series circuit. :param resistances: A list of individual resistances in the circuit. :return: A list of voltage drops across each resistor. :raises ValueError: If voltage is non-positive or if any resistance is non-positive. if voltage <= 0 or any(r <= 0 for r in resistances): raise ValueError(\\"Voltage and resistances must be positive\\") total_resistance = sum(resistances) current = voltage / total_resistance voltage_drops = [current * r for r in resistances] return voltage_drops"},{"question":"# Find the Majority Element from a List **Scenario**: You are developing a software module to analyze survey results. One of the tasks is to determine the majority opinion from the list of survey responses. A majority element in a list is an element that appears more than n/2 times, where n is the length of the list. **Problem Statement**: Implement a function `find_majority_element` that takes a list of integers as input and returns the majority element. **Constraints**: 1. You can assume that the input list always contains a majority element. 2. The function should have a time complexity of O(n) and space complexity of O(1). **Function Signature**: ```python def find_majority_element(nums: list[int]) -> int: pass ``` # Example ```python >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([2, 2, 1, 1, 2, 2, 1, 2, 2]) 2 ``` # Notes: 1. Utilize the Boyer-Moore Voting Algorithm for achieving the required time and space complexity. 2. The list will have at least one majority element as per the problem constraints. **Steps**: 1. Initialize two variables, candidate and count, where candidate is the current candidate for majority and count is the count of the candidate. 2. Iterate through the list, updating the candidate and count as needed. When count reaches zero, update the candidate to the current number. 3. Return the candidate after processing the list.","solution":"def find_majority_element(nums: list[int]) -> int: Finds and returns the majority element from the list nums. A majority element is an element that appears more than n/2 times in the list, where n is the length of the list. candidate = None count = 0 for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"# Extract Unique Elements from Multiple Lists **Background:** In data processing tasks, one might frequently need to merge multiple collections into one while ensuring all elements are unique. This problem can arise in scenarios such as consolidating data from various sources, eliminating duplicates, or preparing a dataset for analysis. Given a list of lists, your task is to implement a function that returns a single list containing all the unique elements from the provided lists. You should preserve the order of the first occurrence of each unique element. **Function Signature:** ```python def merge_unique_lists(lists: list[list[int]]) -> list[int]: Merge multiple lists into one, preserving the order of first occurrences of unique elements. Parameters: lists (list of lists): A list of lists with integer elements. Returns: list: A list containing unique elements in the order of their first occurrence. ``` # Input and Output: - **Input:** - A list of lists, where each internal list contains integers. - **Output:** - A single list of integers where each element is unique and appears in the order of its first occurrence across all input lists. # Constraints: - The input list of lists will contain integers in the range of `-10^6` to `10^6`. - The total number of integers in all sublists combined will not exceed `10^5`. # Performance Requirements: - The solution should operate in linear time, i.e., O(n), where n is the total number of integers in all sublists combined. # Function Implementation: Design and implement the function to merge multiple lists into one while ensuring all integers are unique and appear in their first encountered order. **Examples:** 1. `merge_unique_lists([[1, 2, 3], [3, 4, 5], [5, 6, 7]])` should return `[1, 2, 3, 4, 5, 6, 7]`. 2. `merge_unique_lists([[10, 20, 30], [40, 50], [10, 60, 70], [70, 80]])` should return `[10, 20, 30, 40, 50, 60, 70, 80]`. 3. `merge_unique_lists([[], [1], [2, 1], [3, 2, 1]])` should return `[1, 2, 3]`. 4. `merge_unique_lists([[5, 10, 5], [10, 20], [5], [30]])` should return `[5, 10, 20, 30]`. Make sure to cover possible edge cases and handle large input sizes efficiently.","solution":"def merge_unique_lists(lists): Merge multiple lists into one, preserving the order of first occurrences of unique elements. Parameters: lists (list of lists): A list of lists with integer elements. Returns: list: A list containing unique elements in the order of their first occurrence. seen = set() result = [] for sublist in lists: for item in sublist: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Sorting Nested Lists Objective: Create a Python function that sorts nested lists (lists containing lists) based on a given key which specifies the index of the sub-elements to sort by. Problem Description: You need to implement a function `sort_nested_lists(nested_lists: list[list], key_index: int) -> list[list]` that accepts a list of lists and an integer `key_index`. The function should return a new list of lists sorted in ascending order based on the elements at the `key_index` of each sub-list. Handle edge cases where sub-lists may not have sufficient length to provide an element at `key_index`. Input: - `nested_lists`: a list of lists containing comparable elements. - `key_index`: an integer indicating the index of the elements in the sub-lists to sort by. Output: - A new list of lists, sorted in ascending order based on the sub-list elements at `key_index`. Constraints: - The `nested_lists` input will have at most 100 sub-lists, each with 1 to 10 elements. - The `key_index` will be a non-negative integer. - If a sub-list does not have enough elements to provide an element at `key_index`, it should be considered smaller than any sub-list that provides an element at `key_index`. Requirements: 1. Use a sorting algorithm that handles edge cases with missing indices. 2. The function should not modify the original input list. 3. You should ensure the sorting is stable and the relative order of equal elements is preserved. Example Usage: ```python nested = [[3, 4, 5], [1, 2], [7, 8, 9], [1, 4, 4]] sorted_nested = sort_nested_lists(nested, 2) print(sorted_nested) # Output: [[1, 2], [1, 4, 4], [3, 4, 5], [7, 8, 9]] ``` Implementation Strategy: 1. Define a helper function to handle cases where `key_index` is out of bounds. 2. Use the `sorted()` function with a custom key function. 3. Ensure to create a new list without modifying the original input. ```python def sort_nested_lists(nested_lists: list[list], key_index: int) -> list[list]: Sort nested lists based on the specified key index. :param nested_lists: List of lists to be sorted. :param key_index: Index of the element to sort by. :return: New list of lists sorted by the specified index. def get_key(sub_list): # Handle cases where key_index may be out of bounds return sub_list[key_index] if len(sub_list) > key_index else float(\'-inf\') # Use sorted() to avoid modifying the original list return sorted(nested_lists, key=get_key) # Example Usage nested = [[3, 4, 5], [1, 2], [7, 8, 9], [1, 4, 4]] sorted_nested = sort_nested_lists(nested, 2) print(sorted_nested) # Output: [[1, 2], [1, 4, 4], [3, 4, 5], [7, 8, 9]] ``` Implement the function and include detailed comments/documentation to explain the logic, especially how edge cases are managed.","solution":"def sort_nested_lists(nested_lists: list[list], key_index: int) -> list[list]: Sort nested lists based on the specified key index. :param nested_lists: List of lists to be sorted. :param key_index: Index of the element to sort by. :return: New list of lists sorted by the specified index. def get_key(sub_list): # Handle cases where key_index may be out of bounds by assigning smallest value return sub_list[key_index] if len(sub_list) > key_index else float(\'-inf\') # Use sorted() to avoid modifying the original list return sorted(nested_lists, key=get_key) # Example Usage nested = [[3, 4, 5], [1, 2], [7, 8, 9], [1, 4, 4]] sorted_nested = sort_nested_lists(nested, 2) print(sorted_nested) # Output: [[1, 2], [1, 4, 4], [3, 4, 5], [7, 8, 9]]"},{"question":"# Question: Implement Custom Cache with Time-Based Expiration You are tasked with implementing a custom cache that supports time-based expiration of entries. This cache should provide the following features: 1. **Set Entry with Expiration**: A function to add a key-value pair to the cache with a specific time-to-live (TTL) value. 2. **Get Entry**: A function to retrieve a value from the cache by its key. 3. **Expiration Handling**: Automatically remove entries from the cache once their TTL has expired. 4. **Size Limit**: An option to set a maximum number of entries the cache can hold. When this limit is reached, the oldest entries by insertion time should be removed. Function Specifications: 1. **Set Entry with Expiration**: * Function Name: `set` * Input: Key (string), Value (any type), TTL (integer in seconds) * Output: None 2. **Get Entry**: * Function Name: `get` * Input: Key (string) * Output: Value associated with the key if it exists and has not expired; otherwise return None. 3. **Size Limit Initialization**: * Function within the constructor to set a maximum number of entries `max_entries`. * Input: Max entries count as an integer. 4. **Auto Expiration Handling**: * Automatically check and remove expired entries before any operation (set or get). Example Usage: ```python # Initialize cache with a maximum of 3 entries cache = CustomCache(max_entries=3) # Set entries with different TTL values cache.set(\\"a\\", 1, 10) # Expires in 10 seconds cache.set(\\"b\\", 2, 5) # Expires in 5 seconds cache.set(\\"c\\", 3, 15) # Expires in 15 seconds # Get entries before expiration print(cache.get(\\"a\\")) # Expected Output: 1 print(cache.get(\\"b\\")) # Expected Output: 2 # Wait for 6 seconds (assuming synchronous sleep for simplicity) import time time.sleep(6) # Get entries after some have expired print(cache.get(\\"a\\")) # Expected Output: 1 print(cache.get(\\"b\\")) # Expected Output: None # Add a new entry to exceed max_entries limit cache.set(\\"d\\", 4, 10) # At this point, the oldest entry (\\"a\\") should be removed to make space print(cache.get(\\"a\\")) # Expected Output: None print(cache.get(\\"c\\")) # Expected Output: 3 print(cache.get(\\"d\\")) # Expected Output: 4 ``` Constraints: - Ensure thread-safety if the cache is intended to be used in a multi-threaded environment. - Operations should aim to be efficient in terms of time complexity. - Perform necessary cleanup and checks to maintain the integrity of the cache. Implementing an efficient and effective caching mechanism can significantly improve the performance of applications that require frequent access to certain data.","solution":"import time import heapq class CustomCache: def __init__(self, max_entries): self.cache = {} self.expiration_queue = [] self.max_entries = max_entries def _cleanup(self): current_time = time.time() while self.expiration_queue and self.expiration_queue[0][0] <= current_time: expire_time, key = heapq.heappop(self.expiration_queue) if key in self.cache and self.cache[key][1] <= current_time: del self.cache[key] def _evict_if_needed(self): if len(self.cache) > self.max_entries: oldest_key = min(self.cache, key=lambda k: self.cache[k][2]) del self.cache[oldest_key] def set(self, key, value, ttl): self._cleanup() expire_time = time.time() + ttl self.cache[key] = (value, expire_time, time.time()) heapq.heappush(self.expiration_queue, (expire_time, key)) self._evict_if_needed() def get(self, key): self._cleanup() if key in self.cache and self.cache[key][1] > time.time(): return self.cache[key][0] return None"},{"question":"# Duplicate Character Counting You are given a string consisting of lowercase and uppercase alphabets. You need to write a function that counts the number of characters that appear more than once in the string, regardless of their case (i.e., \'a\' is considered the same as \'A\'). # Function Signature ```python def count_duplicate_characters(s: str) -> int: ``` # Input - `s`: A string containing alphabets (both lowercase and uppercase). # Output - An integer representing the number of characters that appear more than once when ignoring case. # Constraints - The string length will be between 1 and 1000, inclusive. - The string will only contain alphabetic characters (\'a\'-\'z\' and \'A\'-\'Z\'). # Example ```python s = \\"Indivisibilities\\" print(count_duplicate_characters(s)) # Output: 2 (\'i\' and \'s\') s = \\"Mississippi\\" print(count_duplicate_characters(s)) # Output: 3 (\'m\', \'i\', and \'s\') s = \\"abcdef\\" print(count_duplicate_characters(s)) # Output: 0 s = \\"AaBbCcDdEe\\" print(count_duplicate_characters(s)) # Output: 5 (\'a\', \'b\', \'c\', \'d\', \'e\') ``` # Note - Your solution should be case insensitive. - Only count each character once, regardless of how many times it appears more than once.","solution":"def count_duplicate_characters(s: str) -> int: Returns the number of characters that appear more than once in the string s, ignoring case. from collections import Counter # Convert the string to lowercase s = s.lower() # Count the frequency of each character char_count = Counter(s) # Count the number of characters that appear more than once duplicate_count = sum(1 for count in char_count.values() if count > 1) return duplicate_count"},{"question":"# Coding Assessment Question Scenario You are developing a navigation system for an autonomous robot. The system needs to determine if the robot can move from one position to another on a grid while avoiding obstacles. The robot can move one step up, down, left, or right but cannot move diagonally or through obstacles. Task Implement a Python function to determine if there is a path for the robot to move from its starting position to its target position on the grid. Function Signature ```python def is_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: ``` Input - `grid`: A list of lists of integers where `0` represents an empty cell and `1` represents an obstacle. - `start`: A tuple of two integers representing the starting coordinates (row, column) on the grid. - `end`: A tuple of two integers representing the target coordinates (row, column) on the grid. Output - A boolean value indicating whether there is a valid path from the starting position to the target position, avoiding obstacles. Constraints - The grid will contain at least one cell and can be as large as 100x100. - Both `start` and `end` will be valid indices within the grid. - There will be no obstacles at the `start` or `end` positions. Example ```python grid1 = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] start1 = (0, 0) end1 = (3, 3) assert is_path(grid1, start1, end1) == True grid2 = [ [0, 1], [1, 0] ] start2 = (0, 0) end2 = (1, 1) assert is_path(grid2, start2, end2) == False ``` Note Make sure to consider edge cases such as when the grid is completely filled with obstacles except for the start and end positions, or when the start and end positions are the same. Describe the methodology used in your solution, such as the search algorithm chosen and any assumptions made.","solution":"from typing import List, Tuple from collections import deque def is_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Determines if there is a valid path from the start position to the end position on the grid, avoiding obstacles where 0 represents an empty cell and 1 represents an obstacle. :param grid: List of lists of integers representing the grid :param start: Tuple of two integers representing the start coordinates (row, column) :param end: Tuple of two integers representing the end coordinates (row, column) :return: Boolean value indicating whether there is a valid path from start to end rows, cols = len(grid), len(grid[0]) # Directions for moving: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue queue = deque() queue.append(start) # Set to keep track of visited positions visited = set() visited.add(start) while queue: current_position = queue.popleft() if current_position == end: return True for direction in directions: new_row = current_position[0] + direction[0] new_col = current_position[1] + direction[1] new_position = (new_row, new_col) if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and new_position not in visited: queue.append(new_position) visited.add(new_position) return False"},{"question":"# Array Rotation and Search **Problem Statement:** You are asked to implement two functions that handle array manipulation and search operations: 1. `rotate_array(nums: List[int], k: int) -> List[int]`: - Rotate an array `nums` to the right by `k` steps. - **Input**: A list of integers `nums` and an integer `k`. - **Output**: A list of integers representing the array after `k` rotations. 2. `search_rotated_array(nums: List[int], target: int) -> int`: - Search for a `target` number in a rotated sorted array and return its index, or `-1` if it is not found. - **Input**: A list of integers `nums` and an integer `target`. - **Output**: The index of `target` in the array `nums` if it exists, otherwise `-1`. # Function Signature ```python from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: pass def search_rotated_array(nums: List[int], target: int) -> int: pass ``` # Constraints - The input array `nums` will have a length between 0 and (10^5). - Each element in `nums` is guaranteed to be a unique integer within the range of a 32-bit signed integer. - The integer `k` is in the range [0, (10^5)]. - The integer `target` is a 32-bit signed integer. # Example Input/Output ```python # Example for rotate_array assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] # Example for search_rotated_array assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == -1 assert search_rotated_array([], 3) == -1 ``` **Notes:** 1. `rotate_array` should handle cases where `k` is larger than the length of `nums` efficiently by using the modulo operation. 2. `search_rotated_array` should leverage the characteristics of the rotated sorted array to achieve better than linear complexity, ideally using binary search principles. 3. Ensure robust handling of edge cases, such as empty arrays or small `k` values.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotate the array to the right by k steps. if not nums or k < 0: return nums n = len(nums) k = k % n # In case k is greater than the length of nums return nums[-k:] + nums[:-k] def search_rotated_array(nums: List[int], target: int) -> int: Search for target in a rotated sorted array and return its index or -1 if not found. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine the sorted part of the array if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Word Ladder Transformation Checker Given two words, `beginWord` and `endWord`, along with a list of `wordList`, write a function to determine if there is a sequence of word transformations leading from `beginWord` to `endWord`. Each transformation changes exactly one character and must be an intermediate word in the wordList. If such a sequence exists, return the number of transformations (including `beginWord` and `endWord`). If there is no such sequence, return 0. # Requirements 1. **Create a function `word_ladder_steps(beginWord, endWord, wordList)`**: This function should determine the minimum number of steps to transform `beginWord` into `endWord` using the transformations defined. 2. **Ensure that each intermediate word from `beginWord` to `endWord` must exist in the `wordList`.** 3. **Include robustness checks**: Ensure that the words are of the same length and consist of lowercase alphabets. Constraints * All words have the same length. * All words consist of lowercase alphabetic characters. * The `wordList` does not contain duplicates. * It\'s guaranteed that `beginWord` and `endWord` are non-empty and appear only once in the list if present. # Function Signature ```python from typing import List def word_ladder_steps(beginWord: str, endWord: str, wordList: List[str]) -> int: ... ``` Input * `beginWord`, a string. * `endWord`, a string. * `wordList`, a list of strings. Output - The function should return an integer representing the minimum number of transformation steps from `beginWord` to `endWord`. If there is no such sequence, return 0. # Example ```python print(word_ladder_steps(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"])) # Output: 5 # Explanation: The sequence is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\" print(word_ladder_steps(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"])) # Output: 0 # Explanation: There is no possible transformation from \\"hit\\" to \\"cog\\" ``` # Additional Example ```python print(word_ladder_steps(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"])) # Output: 2 # Explanation: The sequence is \\"a\\" -> \\"c\\" ``` # Note - The algorithm should utilize a graph traversal technique (such as BFS) to effectively find the shortest transformation path. The sequence of transformations forms a set of nodes (words) connected when they differ by a single character.","solution":"from typing import List from collections import deque def word_ladder_steps(beginWord: str, endWord: str, wordList: List[str]) -> int: if endWord not in wordList: return 0 word_set = set(wordList) queue = deque([(beginWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i + 1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"# Coding Assessment Question Context You are developing a feature for an aquarium simulation application that helps users understand the characteristics and requirements of different types of tanks. One of the tank shapes you need to support is a cylindrical tank. You previously implemented features for rectangular and spherical tanks, and now you need to extend the application\'s capability to include cylindrical tanks. Task Implement functions to compute the surface area and volume for a cylindrical tank. A cylindrical tank\'s surface area and volume can be calculated using the height (h) and the radius (r) of the base. Here are the formulas: * **Surface Area (S)**: ( S = 2 times pi times r times (r + h) ) * **Volume (V)**: ( V = pi times r^2 times h ) Requirements * **Function Names**: - `cylindrical_tank_surface_area(radius: float, height: float) -> float` - `cylindrical_tank_volume(radius: float, height: float) -> float` * **Input**: - Two floats `radius` and `height`, representing the radius of the base and the height of the cylinder, respectively. * **Output**: - For `cylindrical_tank_surface_area`, return the surface area as a float. - For `cylindrical_tank_volume`, return the volume as a float. * **Constraints**: - `radius` and `height` must be positive numbers; raise a `ValueError` if not. * **Performance**: - The implementation should be efficient, with each method operating in constant time. * **Tests**: - Include tests to validate your solution. For example: ```python >>> cylindrical_tank_surface_area(3, 5) 150.79644737231007 >>> cylindrical_tank_volume(3, 5) 141.3716694115407 >>> cylindrical_tank_surface_area(-3, 5) Traceback (most recent call last): ... ValueError: Radius and height must be positive. ``` Bonus Extend your solution to include a third function `describe_cylindrical_tank(radius: float, height: float) -> dict`, which returns a dictionary containing both surface area and volume.","solution":"import math def cylindrical_tank_surface_area(radius, height): Calculate the surface area of a cylindrical tank. Parameters: radius (float): The radius of the cylinder base. Must be a positive number. height (float): The height of the cylinder. Must be a positive number. Returns: float: The surface area of the cylindrical tank. Raises: ValueError: If radius or height is not positive. if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") return 2 * math.pi * radius * (radius + height) def cylindrical_tank_volume(radius, height): Calculate the volume of a cylindrical tank. Parameters: radius (float): The radius of the cylinder base. Must be a positive number. height (float): The height of the cylinder. Must be a positive number. Returns: float: The volume of the cylindrical tank. Raises: ValueError: If radius or height is not positive. if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") return math.pi * radius**2 * height"},{"question":"# Coding Assessment Question **Context**: In this problem, you are tasked with evaluating the efficiency of a word transformation process using a specific set of allowed operations. You are given a source word and a target word, and you must determine the minimum number of operations required to transform the source word into the target word. The allowed operations are: 1. Insertion of a single character. 2. Deletion of a single character. 3. Substitution of a single character with another character. You must write a function `min_transformations` to compute the minimum number of operations required to transform the source word into the target word. This problem is a variation of the well-known Levenshtein distance problem. # Function Signature ```python def min_transformations(source: str, target: str) -> int: Compute the minimum number of operations required to transform the source word into the target word. Args: source (str): The initial word that needs to be transformed. target (str): The target word to transform the source word into. Returns: int: The minimum number of operations required. ``` # Inputs * `source (str)`: A string representing the initial word. * `target (str)`: A string representing the target word. # Outputs * `int`: The minimum number of operations required to transform the source word into the target word. # Constraints 1. The length of both `source` and `target` will be between 1 and 1000. 2. All characters in `source` and `target` are lowercase English letters. # Examples 1. **Example 1**: * `min_transformations(\\"kitten\\", \\"sitting\\")` * Returns: `3` * Explanation: Transformations are \\"kitten\\" → \\"sitten\\" (substitute \'k\' with \'s\'), \\"sitten\\" → \\"sittin\\" (substitute \'e\' with \'i\'), \\"sittin\\" → \\"sitting\\" (insert \'g\'). 2. **Example 2**: * `min_transformations(\\"flaw\\", \\"lawn\\")` * Returns: `2` * Explanation: Transformations are \\"flaw\\" → \\"law\\" (delete \'f\'), \\"law\\" → \\"lawn\\" (insert \'n\'). 3. **Example 3**: * `min_transformations(\\"intention\\", \\"execution\\")` * Returns: `5` * Explanation: Transformations are \\"intention\\" → \\"inention\\" (delete \'t\'), \\"inention\\" → \\"enention\\" (substitute \'i\' with \'e\'), \\"enention\\" → \\"exention\\" (substitute \'n\' with \'x\'), \\"exention\\" → \\"exection\\" (substitute \'n\' with \'c\'), \\"exection\\" → \\"execution\\" (insert \'u\'). # Implementation Notes * You may use dynamic programming to achieve an optimal solution. * A traditional approach would involve creating a matrix where m and n denote the lengths of the source and target words, respectively. * Ensure that your solution efficiently handles the upper limits of the input sizes.","solution":"def min_transformations(source: str, target: str) -> int: Compute the minimum number of operations required to transform the source word into the target word. Args: source (str): The initial word that needs to be transformed. target (str): The target word to transform the source word into. Returns: int: The minimum number of operations required. m, n = len(source), len(target) # Initialize a (m+1) x (n+1) matrix dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the matrix for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Coding Challenge: String Permutation Check Background: In string manipulation tasks, one common problem is to determine if two strings are permutations of each other. This can have applications in anagram detection, password security checks, and more. Objective: Write a function to check if two given strings are permutations of each other. Your function must also handle edge cases appropriately. Task: Implement the function `are_permutations(str1: str, str2: str) -> bool` that: - Takes two strings, `str1` and `str2` as arguments. - Returns `True` if `str1` and `str2` are permutations of each other, `False` otherwise. Input: - Two strings `str1` and `str2` where ( 0 leq text{len}(str1), text{len}(str2) leq 10^6 ). Output: - Returns a boolean value indicating whether the strings are permutations of each other. Constraints: - The function should not be case-sensitive. For example, \\"abc\\" and \\"CBA\\" should be recognized as permutations. - If either input is not a string, the function should raise a `TypeError` with the message: \\"Inputs must be strings\\". - Whitespace characters should be considered as part of the strings. Examples: ```python >>> are_permutations(\\"abc\\", \\"cba\\") True >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"Hello\\", \\"oLleh\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False >>> are_permutations(\\"test\\", \\"\\") False >>> are_permutations(123, \\"321\\") Traceback (most recent call last): ... TypeError: Inputs must be strings >>> are_permutations(\\"abc\\", 123) Traceback (most recent call last): ... TypeError: Inputs must be strings ``` Requirements: 1. The function should handle differences in character case. 2. Validate inputs and handle errors gracefully. 3. Ensure the solution is optimized for large lengths up to ( 10^6 ).","solution":"def are_permutations(str1, str2): Returns True if str1 and str2 are permutations of each other, False otherwise. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Inputs must be strings\\") # Normalize case str1 = str1.lower() str2 = str2.lower() # If lengths are not equal, they cannot be permutations if len(str1) != len(str2): return False # Count character occurrences char_count1 = {} char_count2 = {} for c in str1: if c in char_count1: char_count1[c] += 1 else: char_count1[c] = 1 for c in str2: if c in char_count2: char_count2[c] += 1 else: char_count2[c] = 1 # Compare character counts return char_count1 == char_count2"},{"question":"# Question: Implement Matrix Transpose Context You are developing a machine learning algorithm that frequently requires manipulating matrices. One of the operations you need to perform is transposing a given matrix. Your task is to write a function that takes in a 2D list (matrix) and returns its transpose. Requirements 1. **Function: Transpose Matrix** ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Take in a 2D list (matrix) and return the transpose of the matrix. In a transposed matrix, the rows become columns and the columns become rows. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] ``` Constraints - The matrix will have at least one element. - The matrix will be well-formed, i.e., all rows will have the same number of elements. Performance Requirements - Aim for an implementation with a time complexity of O(m*n), where m is the number of rows and n is the number of columns. Edge Cases - Handle cases where the matrix is empty or contains only one row or one column. - Ensure the function raises appropriate errors for invalid inputs, such as non-rectangular matrices or non-numeric elements. Write code that performs this operation, verifying through provided examples.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Take in a 2D list (matrix) and return the transpose of the matrix. In a transposed matrix, the rows become columns and the columns become rows. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] if not matrix: # Handle empty matrix input. return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Scenario You are given a matrix representing a 2D grid where some cells contain items. Each cell can either be empty or contain an item with a positive integer value representing its total worth. Your task is to determine the maximum value path from the top-left corner of the grid to the bottom-right corner, moving only right or down at each step. # Task Implement a function to compute the maximum worth that can be collected starting from the top-left corner and reaching the bottom-right corner following the allowed movements. # Function Signature ```python def max_path_value(grid: List[List[int]]) -> int: ``` # Input - `grid`: A 2D list of integers, where each integer represents the value of the item in that cell. - Each integer is non-negative. - `grid` is not empty and has dimensions `m` x `n` where `1 ≤ m, n ≤ 100`. # Output - The function should return an integer representing the maximum worth that can be collected along the path. # Constraints - The size of the grid (`m` and `n`) is between `1` and `100` (inclusive). - All values in the grid are non-negative integers. # Example ```python grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] print(max_path_value(grid)) # Output: 12 ``` Expected Output ``` 12 ``` # Explanation - The path that achieves the maximum worth is: Start at `grid[0][0]` -> Move right to `grid[0][1]` (collects 3) -> Move right to `grid[0][2]` (collects 1) -> Move down to `grid[1][2]` -> Move down to `grid[2][2]` (collects 3) -> Move right to `grid[2][3]` (collects 1). - The total worth collected is 3 + 1 + 3 + 1 = 8. - Note that another path that can be taken is: Start at `grid[0][0]` -> Move down to `grid[1][0]` (collects 2) -> Move down to `grid[2][0]` (collects 1) -> Move right to `grid[2][1]` (collects 5) -> Move right to `grid[2][2]` (collects 3) -> Move right to `grid[2][3]` (collects 1). - The total worth collected is 2 + 1 + 5 + 3 + 1 = 12, which is the maximum value.","solution":"from typing import List def max_path_value(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize dp array with same dimensions as grid dp = [[0] * cols for _ in range(rows)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Data Structure Simulation: Hierarchical File System You are a software engineer designing a basic hierarchical file system for a new operating system. The system should support the creation of directories and files, navigation between directories, and displaying the contents in a tree-like structure. **Requirements**: 1. Implement a function to initialize the root directory. 2. Implement a function to create a new directory within the current directory. 3. Implement a function to create a new file within the current directory. 4. Implement a function to navigate into a specified directory. 5. Implement a function to navigate up to the parent directory. 6. Implement a function to display the current directory\'s contents in a tree-like structure. # Objectives: - **Function**: `initialize_root()` - **Input**: None - **Output**: Initializes the root directory of the file system. - **Function**: `create_directory(name: str)` - **Input**: - `name`: String, the name of the new directory. - **Output**: Creates a new directory with the specified name in the current directory. - **Function**: `create_file(name: str)` - **Input**: - `name`: String, the name of the new file. - **Output**: Creates a new file with the specified name in the current directory. - **Function**: `navigate_to_directory(name: str)` - **Input**: - `name`: String, the name of the directory to navigate into. - **Output**: Navigates into the specified directory if it exists; otherwise, raises an error. - **Function**: `navigate_up()` - **Input**: None - **Output**: Navigates up to the parent directory; if already at the root directory, stays at the root. - **Function**: `display_tree()` - **Input**: None - **Output**: Prints the tree-like structure of the current directory and all its subdirectories and files. Constraints: - Directory and file names should be unique within their parent directory. - The root directory should be the initial directory and should not have a parent. - Handle edge cases such as attempting to navigate to a non-existent directory or creating directories/files with invalid names (e.g., empty strings or duplicates). # Example Scenario: 1. Initialize the root directory using: ```python initialize_root() ``` 2. Create directories and files: ```python create_directory(\\"Documents\\") create_directory(\\"Photos\\") create_file(\\"README.txt\\") navigate_to_directory(\\"Documents\\") create_file(\\"Resume.docx\\") navigate_up() ``` 3. Display the structure of the current directory: ```python display_tree() ``` Expected output: ``` / (root) ├── Documents │ └── Resume.docx ├── Photos └── README.txt ``` # Guidelines: - Ensure the functions handle various edge cases gracefully. - Comment on the performance and efficiency of the implemented hierarchy traversal and navigation. Can you build a robust hierarchical file system for tomorrow\'s operating systems?","solution":"class Node: def __init__(self, name, is_file=False): self.name = name self.is_file = is_file self.children = {} self.parent = None class FileSystem: def __init__(self): self.root = Node(name=\\"/\\") self.current = self.root def initialize_root(self): self.__init__() def create_directory(self, name): if not name or name in self.current.children: raise ValueError(\\"Invalid directory name or directory already exists\\") new_dir = Node(name) new_dir.parent = self.current self.current.children[name] = new_dir def create_file(self, name): if not name or name in self.current.children: raise ValueError(\\"Invalid file name or file already exists\\") new_file = Node(name, is_file=True) new_file.parent = self.current self.current.children[name] = new_file def navigate_to_directory(self, name): if name not in self.current.children or self.current.children[name].is_file: raise ValueError(\\"Directory not found\\") self.current = self.current.children[name] def navigate_up(self): if self.current.parent is not None: self.current = self.current.parent def display_tree(self): self._display_tree_helper(self.current, \\"\\") def _display_tree_helper(self, node, indent): print(indent + node.name) indent += \\" \\" for child in node.children.values(): self._display_tree_helper(child, indent)"},{"question":"# Binary Tree Level Order Traversal Problem Statement You are given a binary tree data structure. Your task is to implement a function that performs level order traversal of the binary tree. In level order traversal, nodes are visited level by level from left to right. Requirements Implement the following method in the `BinaryTree` class: ```python def level_order_traversal(self) -> List[List[int]]: Perform a level order traversal of the binary tree. Returns: List[List[int]]: A list of lists, where each list contains the values of the nodes at that level. Example: >>> bt = BinaryTree() >>> bt.insert(3) >>> bt.insert(9) >>> bt.insert(20) >>> bt.insert(None) >>> bt.insert(None) >>> bt.insert(15) >>> bt.insert(7) >>> bt.level_order_traversal() [[3], [9, 20], [15, 7]] class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value): Insert a value into the binary tree using level order insertion. pass # Omitted for brevity ``` Your implementation must: - Handle nodes with `None` values appropriately. - Return a list of lists, where each sublist contains the values of nodes at each level from left to right. - Follow the binary tree structure and insert elements level-by-level. Input and Output - **Input**: No direct input. The binary tree is constructed using the `insert` method before calling `level_order_traversal`. - **Output**: A list of lists with integers representing the node values at each level. Constraints - The binary tree can have up to 10^4 nodes. - Optimize the level order traversal to handle trees with a large number of nodes efficiently. Performance Requirements - Ensure that the traversal is done in O(n) time complexity, where n is the number of nodes in the binary tree. Example ```python class BinaryTree: def __init__(self): self.root = None def insert(self, value): # Method to insert values (Omitted for brevity) pass def level_order_traversal(self): from collections import deque if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() if node: level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if level: result.append(level) return result bt = BinaryTree() bt.insert(3) bt.insert(9) bt.insert(20) bt.insert(None) bt.insert(None) bt.insert(15) bt.insert(7) print(bt.level_order_traversal()) # Output: [[3], [9, 20], [15, 7]] ``` # Note - Ensure that nodes with `None` values only affect the structure but are not included in the output lists. - Use a queue to facilitate the level order traversal efficiently.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value): Insert a value into the binary tree using level order insertion. if not self.root: if value is not None: self.root = TreeNode(value) return queue = [self.root] while queue: node = queue.pop(0) if node.left is None: if value is not None: node.left = TreeNode(value) return else: queue.append(node.left) if node.right is None: if value is not None: node.right = TreeNode(value) return else: queue.append(node.right) def level_order_traversal(self): from collections import deque if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Question You are tasked with writing a function that finds all the unique substrings of a given length `k` in a string. The substrings must maintain the order of characters as per their occurrence in the original string. **Function Signature:** ```python def unique_substrings(s: str, k: int) -> List[str]: Find all unique substrings of length k in the given string. Args: s (str): The input string. k (int): The length of substrings to find. Returns: List[str]: A list of unique substrings of length k. Examples: >>> unique_substrings(\\"abcabc\\", 3) [\'abc\', \'bca\', \'cab\'] >>> unique_substrings(\\"abacab\\", 2) [\'ab\', \'ba\', \'ac\', \'ca\'] >>> unique_substrings(\\"aaaaa\\", 1) [\'a\'] ``` **Input and Output Formats:** - **Input**: A string `s` (1 ≤ length of `s` ≤ 1000) and an integer `k` (1 ≤ `k` ≤ length of `s`). - **Output**: A list of unique substrings of length `k`. **Constraints:** 1. The string `s` can contain any ASCII characters. 2. Substrings are considered unique if their content and order both are different from each other. **Performance Requirements**: Your solution should run efficiently, ideally in linear time O(n) relative to the length of the string `s`, where space complexity considerations are secondary to time. **Scenario/Context**: This function is necessary for efficiently analyzing patterns within a string, which is useful in fields like bioinformatics (for analyzing genetic sequences), text processing, and data compression. The primary challenge is to ensure no duplicate substrings are returned, and the algorithm remains time-efficient even for longer strings.","solution":"from typing import List def unique_substrings(s: str, k: int) -> List[str]: Find all unique substrings of length k in the given string. Args: s (str): The input string. k (int): The length of substrings to find. Returns: List[str]: A list of unique substrings of length k. seen = set() unique_subs = [] for i in range(len(s) - k + 1): substring = s[i:i+k] if substring not in seen: seen.add(substring) unique_subs.append(substring) return unique_subs"},{"question":"# Binary Search in a Rotated Sorted Array You are building a search feature for a library catalog system. The system stores book IDs in a special format: a rotated sorted array. A rotated sorted array is an array that has been sorted in ascending order and then rotated (shifted) at a certain pivot point. For instance, `[4, 5, 6, 7, 0, 1, 2, 3]` is a rotated version of `[0, 1, 2, 3, 4, 5, 6, 7]`. Task: Write a function `search_rotated_array` to find the index of a target book ID in a rotated sorted array. ```python def search_rotated_array(nums: List[int], target: int) -> int: # implement the function pass ``` Parameters: * **nums** (List[int]): A list of integers representing a rotated sorted array of unique book IDs. * **target** (int): The book ID to search for. Returns: * **int**: The index of the target book ID in the array `nums`. Returns `-1` if the target is not found. Examples: ```python >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search_rotated_array([1], 0) -1 >>> search_rotated_array([2, 3, 4, 5, 6, 1], 5) 3 ``` Constraints: * The list `nums` has no duplicate elements. * `1 <= nums.length <= 10^5` * `-10^4 <= nums[i], target <= 10^4` Notes: * Design an algorithm with `O(log n)` runtime complexity. * Consider edge cases like an empty array or a single-element array. * Ensure the function handles cases where the target is outside the range of the array values.","solution":"from typing import List def search_rotated_array(nums: List[int], target: int) -> int: Finds the index of a target book ID in a rotated sorted array. Parameters: nums (List[int]): A list of integers representing a rotated sorted array of unique book IDs. target (int): The book ID to search for. Returns: int: The index of the target book ID in the array `nums`. Returns `-1` if the target is not found. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check if the left half is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Right half is sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Log File Analyzer Scenario: You are required to write a Python function that analyzes a log file and extracts information about the number of errors that occurred within a given time frame. The log file is in plain text and follows a specific format for each entry. Each log entry consists of a timestamp, a log level, and a message. Task: Write a function `log_file_analyzer(log_file_path: str, start_time: str, end_time: str) -> int` that: 1. Reads the log file from the given path. 2. Parses each log entry to extract the timestamp, log level, and message. 3. Counts the number of log entries with the log level \\"ERROR\\" that fall within the given time frame. 4. Returns the count of such log entries. Log File Format: Each log entry is on a new line and follows the format: ``` YYYY-MM-DD HH:MM:SS [LOG LEVEL] Message ``` For example: ``` 2023-01-01 12:00:00 [INFO] Starting application 2023-01-01 12:05:00 [ERROR] Failed to connect to database 2023-01-01 12:10:00 [WARNING] Low on memory 2023-01-01 12:15:00 [ERROR] Timeout while connecting to server ``` Requirements: * Use Python\'s built-in `datetime` module for parsing and comparing timestamps. * Include error handling for file read issues and incorrect log file formats. * The function should correctly handle cases where no errors are found within the given time frame. Input: * `log_file_path` (str): The path to the log file. * `start_time` (str): The start of the time frame in the format \\"YYYY-MM-DD HH:MM:SS\\". * `end_time` (str): The end of the time frame in the format \\"YYYY-MM-DD HH:MM:SS\\". Output: * Returns an integer representing the number of \\"ERROR\\" log entries within the given time frame. Constraints: * Assume the log file contains valid entries with correct timestamps. * All timestamps and log entries are in the correct format as described. Example: ```python log_file_path = \\"application.log\\" start_time = \\"2023-01-01 12:00:00\\" end_time = \\"2023-01-01 12:20:00\\" result = log_file_analyzer(log_file_path, start_time, end_time) print(result) # Output should be 2 ``` This function will analyze the log entries and count the number of errors that occurred between \\"2023-01-01 12:00:00\\" and \\"2023-01-01 12:20:00\\".","solution":"import datetime def log_file_analyzer(log_file_path, start_time, end_time): Analyzes a log file and counts the number of ERROR log entries within a given time frame. :param log_file_path: Path to the log file :param start_time: Start of the time frame in the format \\"YYYY-MM-DD HH:MM:SS\\" :param end_time: End of the time frame in the format \\"YYYY-MM-DD HH:MM:SS\\" :return: Count of ERROR log entries within the given time frame start_time = datetime.datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") error_count = 0 try: with open(log_file_path, \\"r\\") as file: for line in file: parts = line.split(\\" \\", 2) if len(parts) < 3: continue # skip malformed log entry timestamp_str = parts[0] + \\" \\" + parts[1] log_level = parts[2].split()[0][1:-1] # Extract log level within brackets message = parts[2].split(\\" \\", 1)[1] if len(parts[2].split(\\" \\", 1)) > 1 else \\"\\" try: timestamp = datetime.datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") if start_time <= timestamp <= end_time and log_level == \\"ERROR\\": error_count += 1 except ValueError: continue # skip log entry with invalid timestamp format except FileNotFoundError: print(f\\"Error: The file {log_file_path} was not found.\\") return 0 except Exception as e: print(f\\"An error occurred: {e}\\") return 0 return error_count"},{"question":"# Problem: Polynomial Regression Model Evaluation Background Polynomial regression is a form of regression analysis in which the relationship between the independent variable ( x ) and the dependent variable ( y ) is modeled as an ( n )-th degree polynomial. One key task in polynomial regression is evaluating the performance of the model on test data by calculating the Mean Squared Error (MSE). Objective You will implement a class that fits a polynomial regression model to provided training data and then evaluates its performance on test data by computing the MSE. Requirements 1. **PolynomialRegression Class**: - Implement the `__init__` method to initialize the polynomial degree. - Implement the `fit` method to train the model using the least squares method. - Implement the `predict` method to predict the output for given input data. - Implement the `mse` method to compute and return the Mean Squared Error of the model on given test data. 2. **Function Signature**: ```python class PolynomialRegression: def __init__(self, degree: int): # constructor def fit(self, x_train: List[float], y_train: List[float]) -> None: # Fit the model to training data def predict(self, x: List[float]) -> List[float]: # Predict the output using the polynomial model def mse(self, x_test: List[float], y_test: List[float]) -> float: # Compute and return the Mean Squared Error on test data def evaluate_polynomial_regression(degree: int, x_train: List[float], y_train: List[float], x_test: List[float], y_test: List[float]) -> float: # Your implementation ``` Constraints - The degree will always be a non-negative integer. - The `x_train` and `y_train` lists will have the same length, always greater than 1. - The `x_test` and `y_test` lists will also have the same length, always greater than 1. - All x and y values will be floats. Example ```python >>> x_train = [1.0, 2.0, 3.0, 4.0, 5.0] >>> y_train = [1.2, 1.9, 3.05, 4.8, 5.25] >>> x_test = [1.5, 2.5, 3.5, 4.5] >>> y_test = [1.5, 2.5, 3.5, 4.7] >>> evaluate_polynomial_regression(degree=2, x_train=x_train, y_train=y_train, x_test=x_test, y_test=y_test) 0.060625 ``` **Note**: The outputs above are for reference; your implementation should determine the actual MSE based on the polynomial fitting. You may find it helpful to use matrix operations for the least squares solution for the `fit` method. **Hints**: 1. Use NumPy for efficient polynomial fitting and evaluation. 2. Recall that MSE is calculated as the average of the squared differences between predicted and actual values.","solution":"import numpy as np class PolynomialRegression: def __init__(self, degree: int): self.degree = degree self.coefficients = None def fit(self, x_train: list, y_train: list) -> None: # Create the Vandermonde matrix X = np.vander(x_train, self.degree + 1) Y = np.array(y_train) # Solve for coefficients using the least squares solution self.coefficients = np.linalg.lstsq(X, Y, rcond=None)[0] def predict(self, x: list) -> list: X = np.vander(x, self.degree + 1) predictions = X @ self.coefficients return predictions.tolist() def mse(self, x_test: list, y_test: list) -> float: predictions = self.predict(x_test) mse = np.mean((np.array(y_test) - np.array(predictions)) ** 2) return mse def evaluate_polynomial_regression(degree: int, x_train: list, y_train: list, x_test: list, y_test: list) -> float: model = PolynomialRegression(degree) model.fit(x_train, y_train) return model.mse(x_test, y_test)"},{"question":"# Question Style Observe the given sample question which is a coding task that involves networking, parsing HTML, and implementing caching. The question is technical and requires knowledge in Python, web scraping, and handling edge cases. # New Question You are tasked with writing a function to process a log file and extract meaningful analytics from it. The log file contains entries with timestamps, user IDs, and action types. Log Format Each line in the log file follows this format: ``` YYYY-MM-DD HH:MM:SS, UserID, ActionType ``` For example: ``` 2023-10-03 08:15:27, 12345, login 2023-10-03 08:17:03, 12345, logout 2023-10-03 09:20:29, 67890, login 2023-10-03 09:22:11, 67890, logout ``` Task Requirements: 1. **File Reading and Parsing**: Read the log file and parse the entries. 2. **Unique Users Calculation**: Calculate the number of unique users who have logged in. 3. **Session Duration Calculation**: For each user, calculate the average session duration (from login to logout) in seconds. 4. **Activity Count**: Determine the number of occurrences for each action type (e.g., login, logout). Function Specification Write a function `process_log_file` that accepts the following parameter: - `file_path` (str): The file path of the log file. The function should return a tuple containing: - An integer representing the number of unique users. - A dictionary where the keys are user IDs and the values are their average session durations in seconds. - A dictionary where the keys are action types and the values are counts of occurrences. Requirements: 1. **Input and Output**: - The input is `file_path` (string). - The output is a tuple (integer, dictionary, dictionary). 2. **Constraints**: - Assume the log file is well-formed and entries are ordered by timestamp. - To simplify, assume each login is paired with exactly one logout (no nested or overlapping sessions). ```python from typing import Dict, Tuple from datetime import datetime def process_log_file(file_path: str) -> Tuple[int, Dict[str, float], Dict[str, int]]: Process the log file to extract the number of unique users, average session durations, and action counts. unique_users = set() user_sessions = {} action_counts = {} with open(file_path, \'r\') as file: for line in file: timestamp, user_id, action_type = line.strip().split(\', \') timestamp = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') unique_users.add(user_id) if action_type in action_counts: action_counts[action_type] += 1 else: action_counts[action_type] = 1 if user_id not in user_sessions: user_sessions[user_id] = {\'login_times\': [], \'total_duration\': 0} if action_type == \\"login\\": user_sessions[user_id][\'login_times\'].append(timestamp) elif action_type == \\"logout\\" and user_sessions[user_id][\'login_times\']: login_time = user_sessions[user_id][\'login_times\'].pop(0) duration = (timestamp - login_time).total_seconds() user_sessions[user_id][\'total_duration\'] += duration average_durations = {user_id: session_data[\'total_duration\'] / (session_data[\'total_duration\'] > 0) for user_id, session_data in user_sessions.items()} return len(unique_users), average_durations, action_counts # Example of function usage if __name__ == \\"__main__\\": file_path = \\"user_logs.txt\\" unique_users, avg_sessions, action_counts = process_log_file(file_path) print(f\\"Unique Users: {unique_users}\\") print(f\\"Average Session Durations: {avg_sessions}\\") print(f\\"Action Counts: {action_counts}\\") ``` Test your function with different log files to ensure it correctly handles the different tasks and edge cases.","solution":"from typing import Dict, Tuple from datetime import datetime def process_log_file(file_path: str) -> Tuple[int, Dict[str, float], Dict[str, int]]: Read the log file and return the number of unique users, average session durations for each user, and action counts. unique_users = set() user_sessions = {} action_counts = {} with open(file_path, \'r\') as file: for line in file: timestamp, user_id, action_type = line.strip().split(\', \') timestamp = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') unique_users.add(user_id) if action_type in action_counts: action_counts[action_type] += 1 else: action_counts[action_type] = 1 if user_id not in user_sessions: user_sessions[user_id] = {\'login_times\': [], \'total_duration\': 0, \'session_count\': 0} if action_type == \\"login\\": user_sessions[user_id][\'login_times\'].append(timestamp) elif action_type == \\"logout\\" and user_sessions[user_id][\'login_times\']: login_time = user_sessions[user_id][\'login_times\'].pop(0) duration = (timestamp - login_time).total_seconds() user_sessions[user_id][\'total_duration\'] += duration user_sessions[user_id][\'session_count\'] += 1 average_durations = { user_id: session_data[\'total_duration\'] / session_data[\'session_count\'] for user_id, session_data in user_sessions.items() if session_data[\'session_count\'] > 0 } return len(unique_users), average_durations, action_counts"},{"question":"# Problem Statement You are tasked with writing a function that aggregates rainfall data collected over a series of days. Each entry in the data set represents the amount of rainfall for a specific day. The function should calculate the total amount of rainfall and determine the day with the highest and lowest recorded rainfall. # Function Signature ```python def analyze_rainfall(data: List[Tuple[str, float]]) -> Tuple[float, str, str]: pass ``` # Input * `data` (List[Tuple[str, float]]): A list of tuples where each tuple contains: - A string representing the date in the format \\"YYYY-MM-DD.\\" - A float representing the amount of rainfall recorded on that day. # Output * The function should return a tuple containing: - A float indicating the total amount of rainfall. - A string representing the date with the highest recorded rainfall. - A string representing the date with the lowest recorded rainfall. # Example ```python assert analyze_rainfall([(\\"2023-01-01\\", 5.0), (\\"2023-01-02\\", 7.2), (\\"2023-01-03\\", 2.8)]) == (15.0, \\"2023-01-02\\", \\"2023-01-03\\") assert analyze_rainfall([(\\"2023-02-01\\", 0.0), (\\"2023-02-02\\", 0.1), (\\"2023-02-03\\", 0.0)]) == (0.1, \\"2023-02-02\\", \\"2023-02-01\\") ``` # Constraints * Assume `data` will have at least one entry. * The format of the date string will always be valid. * The amount of rainfall is guaranteed to be a non-negative float value. # Notes * Your implementation should handle the input efficiently, keeping in mind that it could contain a large number of entries. * Consider edge cases such as multiple days having the same maximum or minimum rainfall.","solution":"from typing import List, Tuple def analyze_rainfall(data: List[Tuple[str, float]]) -> Tuple[float, str, str]: if not data: return (0, \\"\\", \\"\\") total_rainfall = 0.0 max_rainfall = float(\'-inf\') min_rainfall = float(\'inf\') max_date = \'\' min_date = \'\' for date, rainfall in data: total_rainfall += rainfall if rainfall > max_rainfall: max_rainfall = rainfall max_date = date if rainfall < min_rainfall: min_rainfall = rainfall min_date = date return (total_rainfall, max_date, min_date)"},{"question":"# Coding Question: Calculate the Longest Uniform Substring You are required to write a function that calculates the length of the longest uniform substring in a given string. A \\"uniform\\" substring is defined as a contiguous substring where all characters are the same. For example: - In the string `\\"aaabbcc\\"`, the longest uniform substring is `\\"aaa\\"`. - In the string `\\"aabbb\\"`, the longest uniform substring is `\\"bbb\\"`. - In the string `\\"abc\\"`, the longest uniform substring is any single character in the string. Function Specification You need to implement the function `longest_uniform_substring(s: str) -> int` which calculates the length of the longest uniform substring in the given string. Here is the function signature: ```python def longest_uniform_substring(s: str) -> int: pass ``` Parameters - `s (str)`: The input string. Output - Return an integer that represents the length of the longest uniform substring. Constraints - The input string will only contain lowercase alphabets. - The length of the string will be at most (10^3). Example ```python assert longest_uniform_substring(\\"aaabbcc\\") == 3 assert longest_uniform_substring(\\"aabbb\\") == 3 assert longest_uniform_substring(\\"abc\\") == 1 assert longest_uniform_substring(\\"aaa\\") == 3 ``` Performance Requirements - Time Complexity: (O(n)), where (n) is the length of the string. - Space Complexity: (O(1)). Edge Cases to Consider - Empty string should return 0. - Strings with all identical characters should return the length of the string. - Strings with no repeated characters should return 1.","solution":"def longest_uniform_substring(s: str) -> int: if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Final check at the end of the loop max_length = max(max_length, current_length) return max_length"},{"question":"# Question: You are asked to implement a function `rotate_2d_matrix(matrix: List[List[int]]) -> None` that rotates an (N times N) 2D matrix 90 degrees clockwise in-place. This means you are not allowed to modify the data structure outside of its original boundaries. To solve this, follow these instructions: 1. Swap elements diagonally from the upper left to the lower right. 2. Reverse the order of elements in each row. **Function Signature**: ```python def rotate_2d_matrix(matrix: List[List[int]]) -> None: pass ``` **Input**: - matrix: A square matrix (a list of lists), where each list has the same number of integers as its length ((N times N)). **Output**: - The function modifies the input matrix in-place. No return value is expected. **Constraints**: - Assume that the matrix will always be a square matrix. - You should raise a `ValueError` if the given matrix is not square. **Examples**: 1. Given matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_2d_matrix(matrix) # After rotation, the matrix should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` 2. Given matrix: ```python matrix = [ [1, 2], [3, 4] ] rotate_2d_matrix(matrix) # After rotation, the matrix should be: # [ # [3, 1], # [4, 2] # ] ``` Implement the `rotate_2d_matrix` function in Python. Ensure to handle non-square matrix inputs correctly by raising appropriate exceptions.","solution":"from typing import List def rotate_2d_matrix(matrix: List[List[int]]) -> None: n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Input matrix must be square\\") # Transpose the matrix by swapping elements diagonally for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Scenario You are developing a library system where users can borrow and return books. The system keeps track of borrowed books and available books in separate collections. Implement a function to manage the book borrowing process, ensuring that users cannot borrow more than a specified limit of books at any one time and that a book cannot be borrowed if it is already checked out. # Task Write a function `borrow_book(user_id, book_id, user_books, available_books, max_books)` that: 1. Checks if the user has reached the borrowing limit. 2. Checks if the requested book is available. 3. If both checks pass, updates the collections to reflect the borrowed book. 4. Returns an appropriate message indicating the success or failure of the operation. # Requirements 1. Implement the `borrow_book` function. 2. Ensure the function performs the necessary checks and updates the collections correctly. 3. Handle edge cases such as borrowing a book that is not available or the user exceeding the borrowing limit. # Input & Output - **Input**: - `user_id` (int): The ID of the user attempting to borrow a book. - `book_id` (int): The ID of the book to be borrowed. - `user_books` (dict): A dictionary where keys are user IDs and values are lists of book IDs currently borrowed by each user. - `available_books` (list): A list of book IDs currently available to be borrowed. - `max_books` (int): The maximum number of books a user can borrow. - **Output**: A message (str) stating the result of the borrowing attempt (`\\"Book borrowed successfully\\"`, `\\"User has reached the borrowing limit\\"`, or `\\"Book is not available\\"`). # Example - **Input**: ```python user_id = 1 book_id = 101 user_books = { 1: [102, 103], 2: [104] } available_books = [101, 105, 106] max_books = 3 ``` - **Output**: `\\"Book borrowed successfully\\"` - **Explanation**: User 1 currently has 2 books borrowed (102, 103) and can borrow up to 3 books. Book 101 is available, so the book borrowing process is successful and the collections are updated accordingly.","solution":"def borrow_book(user_id, book_id, user_books, available_books, max_books): Manages the book borrowing process for a library system. Parameters: user_id (int): The ID of the user attempting to borrow a book. book_id (int): The ID of the book to be borrowed. user_books (dict): A dictionary where keys are user IDs and values are lists of book IDs currently borrowed by each user. available_books (list): A list of book IDs currently available to be borrowed. max_books (int): The maximum number of books a user can borrow. Returns: str: A message indicating the result of the borrowing attempt. # Check if user has reached the borrowing limit borrowed_books = user_books.get(user_id, []) if len(borrowed_books) >= max_books: return \\"User has reached the borrowing limit\\" # Check if the requested book is available if book_id not in available_books: return \\"Book is not available\\" # If both checks pass, update collections to reflect the borrowed book borrowed_books.append(book_id) user_books[user_id] = borrowed_books available_books.remove(book_id) return \\"Book borrowed successfully\\""},{"question":"# Question You need to implement a function called `find_longest_substring` that finds the longest substring of a given string that contains all unique characters. Specifications - Function: `find_longest_substring(s: str) -> str` - **Input**: - `s`: A single string consisting of alphabetic characters. - **Output**: - A string, which is the longest substring with all unique characters. If there are multiple substrings of the same maximum length, return the one which appears first. Constraints - The input string will have a maximum length of 10,000 characters. - All characters in the string are lower-case English letters. Example ```python >>> s = \\"abcabcbb\\" >>> find_longest_substring(s) \\"abc\\" >>> s = \\"bbbb\\" >>> find_longest_substring(s) \\"b\\" >>> s = \\"pwwkew\\" >>> find_longest_substring(s) \\"wke\\" ``` Notes - Use an efficient algorithm to handle the maximum string length. - Consider using a sliding window technique to optimize performance.","solution":"def find_longest_substring(s: str) -> str: Finds the longest substring with all unique characters. Args: s (str): The input string consisting of alphabetic characters. Returns: str: The longest substring with all unique characters. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 0 max_substring = \\"\\" char_index_map = {} for end in range(n): char = s[end] if char in char_index_map: start = max(start, char_index_map[char] + 1) char_index_map[char] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end+1] return max_substring"},{"question":"# Task: You are given a list of strings where each string is a digit from \'0\' to \'9\', a lowercase alphabetic character (\'a\' to \'z\'), or an uppercase alphabetic character (\'A\' to \'Z\'). Your task is to write a function `most_common_character(strings: list[str]) -> str` that returns the character that appears most frequently across all strings, along with its count. If there is a tie, return the lexicographically smallest character. # Requirements: * **Input**: * `strings`: A list of strings, each consisting of a single character from \'0\'-\'9\', \'a\'-\'z\', or \'A\'-\'Z\'. * Constraints: * 1 ≤ len(strings) ≤ 10^5 * Each string is exactly one character long * **Output**: * A tuple containing the most frequent character and its count. # Example: ```python assert most_common_character([\'a\', \'b\', \'b\', \'c\', \'a\', \'a\']) == (\'a\', 3) assert most_common_character([\'a\', \'A\', \'b\', \'B\', \'a\', \'b\']) == (\'a\', 2) assert most_common_character([\'0\', \'1\', \'0\', \'0\', \'2\', \'3\', \'0\']) == (\'0\', 4) assert most_common_character([\'W\', \'X\', \'Y\', \'W\', \'X\', \'Y\', \'W\']) == (\'W\', 3) assert most_common_character([\'z\', \'y\', \'x\', \'w\', \'x\', \'y\', \'z\', \'z\']) == (\'z\', 3) strings = [chr(i % 62 + ord(\'0\')) if i % 62 < 10 else (chr(i % 62 + ord(\'A\') - 10) if i % 62 < 36 else chr(i % 62 + ord(\'a\') - 36)) for i in range(100000)] assert most_common_character(strings) == (\'0\', 1613) # resulting character and count may vary based on implementation ``` # Note: * Make sure to handle both lowercase and uppercase alphabetic characters separately. * Use an efficient algorithm to count occurrences and determine the most common character with O(n) time complexity, where n is the number of strings. # Additional Scenario for Testing: ```python strings = [\'9\']*25000 + [\'a\']*25000 + [\'B\']*25000 + [\'9\']*25000 assert most_common_character(strings) == (\'9\', 50000) ```","solution":"from collections import Counter def most_common_character(strings: list[str]) -> tuple: Returns the character that appears most frequently in the list of strings and its count. If there is a tie, returns the lexicographically smallest character. counter = Counter(strings) most_common_char, most_common_count = min(counter.items(), key=lambda x: (-x[1], x[0])) return most_common_char, most_common_count"},{"question":"# Question: Write a Python function `find_largest_perfect_square` that takes a list of integers and returns the largest perfect square number from the list. If there is no perfect square in the input list, return `None`. A number is considered a perfect square if it is the square of an integer. Function Signature ```python def find_largest_perfect_square(numbers: list[int]) -> int: ``` # Input - `numbers`: A list of integers. # Output - Returns the largest perfect square number from the list or `None` if none exists. # Constraints - The list may contain positive and negative integers, and zero. - The list may contain duplicate numbers. - The list could be empty, in which case the function should return `None`. # Examples ```python assert find_largest_perfect_square([1, 4, 9, 16, 25, 30, 40]) == 25 assert find_largest_perfect_square([3, 5, 7, 10, 12]) == None assert find_largest_perfect_square([0, -1, -4, -9]) == 0 assert find_largest_perfect_square([16, 20, 24, 36, 49]) == 49 assert find_largest_perfect_square([]) == None ``` # Requirements 1. Ensure the function handles an empty list and lists with no perfect square numbers gracefully. 2. Validate the input to ensure it contains only integers; raise a `ValueError` for invalid inputs. 3. Optimize the function to perform efficiently even for larger lists of numbers. # Scenario You are tasked with analyzing a dataset containing various integers to extract relevant statistics. As part of the analysis, you need to identify the largest perfect square within the dataset. Implement this function to assist in quickly isolating perfect squares from the list of numbers provided.","solution":"import math def find_largest_perfect_square(numbers: list[int]) -> int: Returns the largest perfect square number from the list or None if none exists. Args: numbers (list[int]): A list of integers. Returns: int: The largest perfect square number from the list or None if none exists. if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"All elements of the input list must be integers.\\") largest_perfect_square = None for num in numbers: if num >= 0 and int(math.sqrt(num)) ** 2 == num: if largest_perfect_square is None or num > largest_perfect_square: largest_perfect_square = num return largest_perfect_square"},{"question":"# Prefix Sum Array You are required to compute the prefix sum of an array of integers. A prefix sum array is one where each element at index ( i ) is the sum of the elements from the original array from index 0 to ( i ). **Problem Statement:** Write a function `prefix_sum` that takes a list of integers and returns the prefix sum array. The prefix sum array ( P ) is defined as: [ P[i] = A[0] + A[1] + ... + A[i] ] where ( A ) is the original array. **Function Signature:** ```python def prefix_sum(arr: list[int]) -> list[int]: ``` **Input Format:** - `arr`: A list of integers of length ( n ). **Output Format:** - Return a list of integers where each integer is the cumulative sum up to that index in the original array. **Examples:** ```python >>> prefix_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> prefix_sum([4, -1, 2, 1]) [4, 3, 5, 6] >>> prefix_sum([0, 0, 0, 0]) [0, 0, 0, 0] ``` **Constraints:** - The length of `arr` will be in the range [1, 10^5]. - The elements of `arr` will be bounded within [-10^4, 10^4]. **Scoring:** - Correctness: Solutions will be verified based on correct computation of prefix sums. - Efficiency: Solutions must handle the upper range of inputs efficiently.","solution":"def prefix_sum(arr: list[int]) -> list[int]: Computes the prefix sum array of the given list of integers. Parameters: arr (list[int]): A list of integers Returns: list[int]: A list of integers representing the prefix sum if not arr: return [] prefix_sums = [0] * len(arr) prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums"},{"question":"# Palindromic Product of Two 3-Digit Numbers A palindromic number reads the same forward and backward (e.g., 121 or 989). Write a function to find the largest palindromic number that is a product of two 3-digit numbers. **Function Signature**: ```python def largest_palindromic_product() -> int: ``` Input/Output Specification: - **Input**: None (the function should compute within the hard-coded range of 3-digit numbers, i.e., 100 to 999) - **Output**: The largest palindromic number that is a product of two 3-digit numbers as an integer. Constraints/Key Points: - Each factor in the product should be a 3-digit number. - The algorithm must go through all possible pairs of 3-digit numbers, check their product, and determine if it is a palindrome. - The function should return the largest such palindromic product. Example: ```python assert is_palindrome(12321) == True assert largest_palindromic_product() == 906609 ``` **Scenario/Context**: Imagine you are working on a project involving symmetric structures and you need to identify the largest palindromic structure that can be formed using two 3-digit elements. This task requires efficient iteration and checking for palindromic properties within a specified numerical range.","solution":"def is_palindrome(number): Check if a number is a palindrome. return str(number) == str(number)[::-1] def largest_palindromic_product(): Finds the largest palindromic number that is a product of two 3-digit numbers. max_palindrome = 0 # Iterate over all pairs of 3-digit numbers for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if is_palindrome(product) and product > max_palindrome: max_palindrome = product return max_palindrome"},{"question":"# Anagram Detection Context Anagrams are words or phrases that are made by rearranging the letters of another word or phrase using all the original letters exactly once. Anagram detection is a common task in natural language processing, cryptography, and game development. Task You are required to write a Python function that checks if two given strings are anagrams of each other. The function should ignore case, spaces, and punctuation. Input - Two strings representing the words or phrases to be checked. Output - A boolean value: `True` if the input strings are anagrams of each other, `False` otherwise. Constraints - The input strings can contain alphanumeric characters, spaces, and punctuation. - The function should ignore case and ignore all spaces and punctuation. - Raise a `ValueError` with an appropriate message if either input is empty or not a string. Examples ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"Dormitory\\", \\"Dirty room\\") True >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"Hello\\", \\"Goodbye\\") False >>> are_anagrams(\\"Night\\", \\"Thing!\\") True >>> are_anagrams(\\"\\", \\"Empty\\") Traceback (most recent call last): ... ValueError: One or both input strings are empty or not strings >>> are_anagrams(\\"123\\", \\"231!\\") True ``` Function Signature ```python def are_anagrams(str1: str, str2: str) -> bool: pass ``` # Requirements 1. The function should handle input sanitization. 2. Proper exception handling should be implemented for invalid inputs. 3. Efficient comparison methods should be used to verify anagrams. This question matches the style, complexity, and scope of the original questions by introducing a problem related to string manipulation and algorithmic thinking, focusing on anagram detection by handling various input constraints and sanitization.","solution":"import re def are_anagrams(str1: str, str2: str) -> bool: Check if two given strings are anagrams of each other, ignoring case, spaces, and punctuation. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. Raises: ValueError: If either of the inputs is not a string or is empty. if not isinstance(str1, str) or not isinstance(str2, str): raise ValueError(\\"One or both input strings are empty or not strings\\") if not str1 or not str2: raise ValueError(\\"One or both input strings are empty or not strings\\") # Normalize the strings by removing non-alphanumeric characters and converting to lowercase normalized_str1 = re.sub(r\'[^a-zA-Z0-9]\', \'\', str1).lower() normalized_str2 = re.sub(r\'[^a-zA-Z0-9]\', \'\', str2).lower() # Compare the sorted characters of both normalized strings return sorted(normalized_str1) == sorted(normalized_str2)"},{"question":"# CSV Data Transformation **Objective**: Implement a function to read a CSV file, process its contents, and write the transformed data back to another CSV file. **Scenario**: In a data processing pipeline, you need to transform a given CSV file by applying certain operations to its content and then save the result. The CSV file contains rows of numerical data, and each row represents a different set of measurements. **Requirements**: - Define a function `process_csv(input_file: str, output_file: str) -> None` that: - Reads the input CSV file where each row contains integers separated by commas. - For each row, compute the sum and the average of the numerical values. - Write the transformed data to the output CSV file, appending two new columns: `sum` and `average`. - Handle cases where the input file might be empty. - Ensure the output is formatted correctly, with rows matched accurately. **Function Signature**: ```python def process_csv(input_file: str, output_file: str) -> None: pass ``` **Constraints**: - The input file is a valid CSV file containing only integers. - The input file is not excessively large, i.e., it can be processed in memory. **Examples**: 1. Given `input.csv`: ``` 1,2,3 4,5,6,7 8,9 ``` After processing, `output.csv` should be: ``` 1,2,3,6,2.0 4,5,6,7,22,5.5 8,9,17,8.5 ``` 2. Given `input.csv`: ``` 10,20 30,40,50 ``` After processing, `output.csv` should be: ``` 10,20,30,15.0 30,40,50,120,40.0 ``` 3. Given an empty `input.csv` should create an empty `output.csv` with no errors.","solution":"import csv def process_csv(input_file: str, output_file: str) -> None: Process the input CSV file by computing the sum and average of each row and write the result to the output CSV file. Args: input_file (str): The path to the input CSV file. output_file (str): The path to the output CSV file. # Read the input file with open(input_file, mode=\'r\', newline=\'\') as infile: reader = csv.reader(infile) rows = list(reader) # Transform data transformed_data = [] for row in rows: if row: # If row is not empty numbers = list(map(int, row)) total = sum(numbers) average = total / len(numbers) transformed_row = row + [str(total), f\\"{average:.1f}\\"] transformed_data.append(transformed_row) # Write to the output file with open(output_file, mode=\'w\', newline=\'\') as outfile: writer = csv.writer(outfile) writer.writerows(transformed_data)"},{"question":"# Problem Statement You are tasked with developing an algorithm that validates and formats a given list of phone numbers based on certain rules. The phone numbers will be deemed valid if they adhere to one of the specified formats. If a phone number is valid, it should be reformatted according to a standard format for consistency. Function Descriptions 1. **is_valid_phone_number(phone: str) -> bool** - Input: A phone number string. - Output: A boolean indicating if the phone number is valid. - A valid phone number can be in one of the following formats: - (xxx) xxx-xxxx - xxx-xxx-xxxx - xxx.xxx.xxxx - Example: ```python is_valid_phone_number(\\"(123) 456-7890\\") # returns True is_valid_phone_number(\\"123-456-7890\\") # returns True is_valid_phone_number(\\"123.456.7890\\") # returns True is_valid_phone_number(\\"123 456 7890\\") # returns False ``` 2. **reformat_phone_number(phone: str) -> str** - Input: A valid phone number string. - Output: A reformatted phone number string in the format (xxx) xxx-xxxx. - Example: ```python reformat_phone_number(\\"123-456-7890\\") # returns \\"(123) 456-7890\\" reformat_phone_number(\\"123.456.7890\\") # returns \\"(123) 456-7890\\" ``` 3. **validate_and_reformat(numbers: list[str]) -> list[str]** - Input: A list of phone number strings. - Output: A list of reformatted phone number strings if valid, ignoring invalid numbers. - Example: ```python validate_and_reformat([\\"(123) 456-7890\\", \\"123-456-7890\\", \\"123.456.7890\\", \\"123 456 7890\\"]) # returns [\\"(123) 456-7890\\", \\"(123) 456-7890\\", \\"(123) 456-7890\\"] ``` # Constraints: - The input phone numbers will only contain digits, spaces, parentheses, periods, and hyphens. - The phone numbers should be processed in a case-sensitive manner. - Any invalid phone number should be ignored in the final output. # Implementation Implement the following functions: ```python def is_valid_phone_number(phone: str) -> bool: # Your implementation here pass def reformat_phone_number(phone: str) -> str: # Your implementation here pass def validate_and_reformat(numbers: list[str]) -> list[str]: # Your implementation here pass ```","solution":"import re def is_valid_phone_number(phone: str) -> bool: Returns True if the phone number is valid, False otherwise. Valid formats: - (xxx) xxx-xxxx - xxx-xxx-xxxx - xxx.xxx.xxxx pattern = re.compile(r\\"^(?:(d{3})s|d{3}[-.])d{3}[-.]d{4}\\") return bool(pattern.match(phone)) def reformat_phone_number(phone: str) -> str: Reformats a valid phone number to the format (xxx) xxx-xxxx. digits = re.sub(r\'D\', \'\', phone) # Remove all non-digit characters return f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" def validate_and_reformat(numbers: list[str]) -> list[str]: Validates and reformats a list of phone numbers. Returns a list of reformatted phone numbers if valid, ignoring invalid numbers. valid_numbers = [num for num in numbers if is_valid_phone_number(num)] return [reformat_phone_number(num) for num in valid_numbers if is_valid_phone_number(num)]"},{"question":"# Coding Assessment Question Context In modern web applications, efficient data handling and processing are crucial. One common task is to filter large datasets based on specific conditions. Let\'s implement a simplified version of this, where you simulate filtering data entries based on a given condition using a modular approach. Problem Statement **Task**: Implement a `filter_data` function in Python that filters a list of data entries (dictionaries) according to specified conditions passed as a second argument function. * **Function Specifications**: - **Function 1**: `filter_data` - **Input**: - `data`: A list of dictionaries, where each dictionary represents a data entry. - `condition`: A function that takes a single dictionary and returns `True` or `False` based on whether the dictionary meets the condition. - **Output**: A list of dictionaries that meet the given condition. * **Constraints**: - Each dictionary in the input list may contain varying keys and should be evaluated separately by the condition function. - The condition function must be applied to each dictionary entry one by one. - The input list can be empty, in which case the output should also be an empty list. * **Performance Requirements**: - The solution should process the input list in a single pass (O(n) complexity). Example Usage ```python def filter_data(data: list, condition: callable) -> list: Filters data entries based on the provided condition function. >>> data = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, ... {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ... ] >>> condition = lambda entry: entry.get(\\"age\\", 0) > 28 >>> filtered = filter_data(data, condition) >>> filtered [{\'name\': \'Alice\', \'age\': 30, \'city\': \'New York\'}, {\'name\': \'Charlie\', \'age\': 35, \'city\': \'Chicago\'}] if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"def filter_data(data: list, condition: callable) -> list: Filters data entries based on the provided condition function. Parameters: data (list): List of dictionaries to be filtered. condition (callable): Condition function to evaluate each dictionary. Returns: list: List of dictionaries that meet the condition. return [entry for entry in data if condition(entry)]"},{"question":"# Problem Statement You are required to implement a function that performs matrix multiplication on two matrices and returns the result. Matrix multiplication is an essential operation in numerous fields such as linear algebra, graphics, and machine learning. # Requirements Implement a function `matrix_multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]` that performs the following: 1. **Validates the matrices**: Ensure that the number of columns in `matrix_a` is equal to the number of rows in `matrix_b`. 2. **Performs matrix multiplication**: Calculate the resultant matrix by multiplying `matrix_a` with `matrix_b`. # Input Constraints: - Each matrix is represented as a list of lists. - The elements of each matrix are integers. - The dimensions of the matrices will be compatible for multiplication. # Expected Output: The function should return the resultant matrix after multiplication as a list of lists. # Example: ```python # Example usage: matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(matrix_a, matrix_b) print(result) # Expected output: [[58, 64], [139, 154]] ``` # Notes: 1. Ensure to handle edge cases such as empty matrices and return an appropriate result. 2. Your function should handle large matrices efficiently in terms of time and space complexity. 3. Validate input dimensions and throw an appropriate error if the matrices cannot be multiplied. This problem tests your understanding of matrix operations, particularly matrix multiplication, and your ability to handle nested lists.","solution":"def matrix_multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Multiplies two matrices and returns the resultant matrix. :param matrix_a: List of lists, where each list represents a row in matrix A. :param matrix_b: List of lists, where each list represents a row in matrix B. :returns: The resultant matrix after multiplying matrix_a with matrix_b. :raises ValueError: If the number of columns in matrix_a is not equal to the number of rows in matrix_b. # Validate dimensions if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must be equal to number of rows in matrix_b.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Unique Filename Generator Scenario In a cloud storage system, users can upload files with custom names. However, no two files in the same directory can have the same name. If a file with the same name is uploaded, the system should automatically append a number in parentheses to create a unique filename. Task Write a function `generate_unique_filename` that accepts a list of existing filenames and a new filename, then generates a unique filename by appending a number in parentheses if needed. Function Signature ```python def generate_unique_filename(existing_files: list[str], new_file: str) -> str: Generates a unique filename by appending a number in parentheses. :param existing_files: List of filenames that already exist in the target directory. :param new_file: The desired filename for the new file. :returns: A unique filename that does not exist in the existing_files list. Examples: >>> generate_unique_filename([\\"file.txt\\", \\"file(1).txt\\", \\"file(2).txt\\"], \\"file.txt\\") \'file(3).txt\' >>> generate_unique_filename([\\"data.csv\\", \\"data(1).csv\\"], \\"data.csv\\") \'data(2).csv\' >>> generate_unique_filename([\\"report.doc\\", \\"report(1).doc\\"], \\"summary.doc\\") \'summary.doc\' ``` Input and Output Format - **Input**: - `existing_files`: A list of strings representing filenames that already exist in the directory. - `new_file`: A string representing the desired filename for a new file. - **Output**: - A string that represents a unique filename, created by appending a numeric suffix if the desired filename already exists in the list. Constraints - The filenames can have any valid characters and extensions. - The numeric suffix should start from 1 and increment by 1 for each collision. - Filenames without collision will remain unchanged. - The function should handle cases where multiple suffixes are required to find a unique filename. Example ```python assert generate_unique_filename([\\"file.txt\\", \\"file(1).txt\\", \\"file(2).txt\\"], \\"file.txt\\") == \'file(3).txt\' assert generate_unique_filename([\\"data.csv\\", \\"data(1).csv\\"], \\"data.csv\\") == \'data(2).csv\' assert generate_unique_filename([\\"report.doc\\", \\"report(1).doc\\"], \\"summary.doc\\") == \'summary.doc\' ```","solution":"def generate_unique_filename(existing_files: list[str], new_file: str) -> str: if new_file not in existing_files: return new_file base_name, ext = new_file.rsplit(\'.\', 1) counter = 1 while f\\"{base_name}({counter}).{ext}\\" in existing_files: counter += 1 return f\\"{base_name}({counter}).{ext}\\""},{"question":"# Scenario You are working on a data analysis project that involves processing a large dataset of user activity logs from a web application. These logs are stored in a simple text format, where each line represents an individual log entry. Each log entry contains a timestamp, user ID, page URL, and action type, separated by commas. # Task You need to implement a function that extracts user activity summaries from the logs. Specifically, your function should calculate the total number of unique pages visited and the total number of actions performed by each user. # Function Signature ```python def user_activity_summary(log_entries: List[str]) -> Dict[str, Dict[str, int]]: ``` # Input 1. `log_entries` (List[str]): A list of strings, where each string is a log entry in the format `\\"timestamp,user_id,page_url,action_type\\"`. - `timestamp` (str): The time at which the action was performed. - `user_id` (str): A unique identifier for the user. - `page_url` (str): The URL of the page visited. - `action_type` (str): The type of action performed (e.g., \\"click\\", \\"view\\", \\"purchase\\"). # Output The function should return a dictionary where the keys are user IDs and the values are dictionaries with two keys: `\\"unique_pages\\"` and `\\"total_actions\\"`. - `\\"unique_pages\\"` (int): The number of unique pages visited by the user. - `\\"total_actions\\"` (int): The total number of actions performed by the user. # Constraints * The log entries list can contain duplicate or malformed entries. Malformed entries are those that don\'t adhere to the specified format and should be ignored. * Page URLs and action types are case-sensitive. # Example ```python >>> log_entries = [ \\"2023-04-21T10:00:00,user123,/home,view\\", \\"2023-04-21T10:05:00,user123,/about,click\\", \\"2023-04-21T10:10:00,user123,/home,view\\", \\"2023-04-21T10:15:00,user456,/home,purchase\\", \\"2023-04-21T10:20:00,user456,/browse,view\\", \\"2023-04-21T10:25:00,user123,/home,view\\", \\"2023-04-21T10:30:00,user456,/home,view\\", \\"malformed_entry\\" ] >>> user_activity_summary(log_entries) { \'user123\': { \'unique_pages\': 2, \'total_actions\': 4 }, \'user456\': { \'unique_pages\': 2, \'total_actions\': 3 } } ``` # Important Note Ensure your function can handle duplicate and malformed entries gracefully, processing only valid entries for summarizing user activity.","solution":"from typing import List, Dict def user_activity_summary(log_entries: List[str]) -> Dict[str, Dict[str, int]]: user_summary = {} for entry in log_entries: parts = entry.split(\',\') if len(parts) != 4: continue # Skip malformed entries timestamp, user_id, page_url, action_type = parts if user_id not in user_summary: user_summary[user_id] = { \'unique_pages\': set(), \'total_actions\': 0 } user_summary[user_id][\'unique_pages\'].add(page_url) user_summary[user_id][\'total_actions\'] += 1 # Final pass to convert sets to counts for user_id in user_summary: user_summary[user_id][\'unique_pages\'] = len(user_summary[user_id][\'unique_pages\']) return user_summary"},{"question":"# Matrix Rotation with Constraints Context In computer graphics, image processing, and various scientific computations, manipulating and transforming large matrices is a common task. Rotating a matrix is a fundamental operation, and optimizing it for large datasets is crucial for performance in real-time applications. Task Your task is to implement a function that rotates an `N x N` matrix (2D list) 90 degrees clockwise. Furthermore, ensure that the rotation is performed **in-place** without using any extra memory for another matrix. Requirements 1. **Function Prototype**: Implement the function `rotate_matrix(matrix: List[List[int]]) -> None`. 2. **Input and Output**: - **Input**: - `matrix` (List[List[int]]): 2D list representing the matrix to rotate. - **Output**: This function should modify the input matrix in-place; it does not return anything. 3. **Constraints**: - The matrix must be `NxN`, i.e., it should always have the same number of rows and columns. - The size of `N` can be any integer up to 1000. Expectations - Handle edge cases where the matrix is already optimal for rotation (e.g., a 1x1 matrix). - Focus on modifying the matrix in-place to ensure minimal memory usage. - Document your code clearly for readability and maintainability. Implementation Example Here is a template to get you started: ```python from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element temp = matrix[i][j] # Move left element to top matrix[i][j] = matrix[n - j - 1][i] # Move bottom element to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # Move right element to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # Assign top element to right matrix[j][n - i - 1] = temp # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output should be [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` Ensure you thoroughly test your function with various matrix sizes and configurations to validate the in-place rotation.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an N x N matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): 2D list representing the matrix to rotate. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element temp = matrix[i][j] # Move left element to top matrix[i][j] = matrix[n - j - 1][i] # Move bottom element to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # Move right element to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # Assign top element to right matrix[j][n - i - 1] = temp # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output should be [[7, 4, 1], [8, 5, 2], [9, 6, 3]]"},{"question":"# Question: Write a function `is_unique_character_string(s)` that determines whether all characters in a given string `s` are unique. The function should return a boolean value: `True` if all characters are unique, and `False` otherwise. Function Signature ```python def is_unique_character_string(s: str) -> bool: ``` Input * `s` (str): A string containing ASCII characters. Output * `bool`: Returns `True` if all characters in the string are unique, otherwise `False`. Constraints * The input string `s` will have a length between 0 and 10^6. * Only ASCII characters will be present in the string (i.e., characters with values between 0 and 127). Example ```python is_unique_character_string(\\"abcdef\\") # Should return True, since all characters are unique. is_unique_character_string(\\"hello\\") # Should return False, since \'l\' is repeated. is_unique_character_string(\\"\\") # Should return True, as an empty string has no characters and thus no repetitions. ``` Notes 1. Implement the function to ensure it handles large strings efficiently. 2. Avoid using extra data structures if not necessary. 3. Consider edge cases such as empty strings and strings with all identical characters. 4. **Performance requirements**: Ensure the function runs in linear time, O(n), where n is the length of the string `s`. # Answer: ```python def is_unique_character_string(s: str) -> bool: # If the length of the string exceeds the number of unique ASCII characters, # we can directly return False as one of them must be repeated. if len(s) > 128: return False seen_characters = set() for char in s: if char in seen_characters: return False seen_characters.add(char) return True ```","solution":"def is_unique_character_string(s: str) -> bool: # If the length of the string exceeds the number of unique ASCII characters, # we can directly return False as one of them must be repeated. if len(s) > 128: return False seen_characters = set() for char in s: if char in seen_characters: return False seen_characters.add(char) return True"},{"question":"# Road Network Optimization - Shortest Path with Constraints Background You are given a road network represented as a graph where nodes represent cities and edges represent the roads connecting these cities. Each road has a corresponding travel time. However, due to road maintenance, certain roads might be closed, impacting the travel route. Your task is to implement an algorithm that finds the shortest path between two cities, considering potential road blockages. You will write code that takes the road network, the source city, the destination city, and a list of blocked roads, and returns the shortest travel time from the source to the destination. Task Implement a function `shortest_path_with_constraints` that calculates the shortest travel time between two cities given a set of blocked roads. **Function Signature:** ```python def shortest_path_with_constraints(roads: list[tuple[int, int, int]], source: int, destination: int, blocked: list[tuple[int, int]]) -> int: ``` **Parameters:** - `roads`: A list of tuples where each tuple represents a road between two cities. Each tuple consists of three integers `(u, v, t)` where `u` and `v` are the cities connected by the road and `t` is the travel time required. - `source`: An integer representing the starting city. - `destination`: An integer representing the target city. - `blocked`: A list of tuples where each tuple consists of two integers representing a road that is blocked (i.e., the road between these two cities cannot be used). **Returns:** - An integer representing the shortest travel time from the source city to the destination city if a path exists, otherwise `-1` if no path exists due to blocked roads. **Constraints:** - (1 leq text{nodes} leq 1000) - (1 leq text{edges} leq 5000) - (1 leq text{travel time} leq 100) - The graph is connected and undirected before any roads are blocked. - You can assume the source and destination cities are always valid and different. Example ```python roads = [(1, 2, 10), (2, 3, 10), (1, 3, 20)] source = 1 destination = 3 blocked = [(1, 2)] output = shortest_path_with_constraints(roads, source, destination, blocked) # The shortest path is: 1 -> 3 with travel time 20. # The road (1, 2) is blocked, so the only available path is through city 3 directly. # Expected output: # 20 ``` Note 1. You may use any shortest path algorithm like Dijkstra\'s algorithm, ensuring blocked roads are removed from the graph before computing the path. 2. Carefully handle edge cases such as all possible paths being blocked leading to no feasible route. 3. Ensure optimized performance given the constraints on the number of nodes and edges.","solution":"import heapq def shortest_path_with_constraints(roads, source, destination, blocked): # Create an adjacency list for graph representation graph = {} for u, v, t in roads: if (u, v) in blocked or (v, u) in blocked: continue if u not in graph: graph[u] = [] if v not in graph: graph[v] = [] graph[u].append((v, t)) graph[v].append((u, t)) # Use a priority queue to implement Dijkstra\'s algorithm pq = [(0, source)] # (distance, node) distances = {source: 0} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == destination: return current_distance if current_distance > distances.get(current_node, float(\'inf\')): continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1"},{"question":"# String Compression Algorithm: Simple Text Compression Context: You are building a simple text compression utility that optimizes storage by reducing the size of the text strings. The compression algorithm will follow a straightforward approach by replacing sequences of repeated characters with the character followed by the number of repetitions. Problem: Implement a function `compress` that takes a string and returns a new string where sequences of the same character are replaced by that character followed by the number of times it is repeated. If the compressed string is not shorter than the original, the function should return the original string instead. Specifications: 1. **Function Signature:** ```python def compress(input_string: str) -> str: Compresses the input string by replacing sequences of repeated characters with the character followed by the number of repetitions. :param input_string: The string to be compressed. :return: The compressed string if shorter, otherwise the original string. ``` 2. **Input:** - `input_string`: A string of arbitrary length and characters. 3. **Output:** - A compressed version of the input string, or the original string if the compressed version is not shorter. 4. **Constraints:** - Handle edge cases such as an empty input string or strings without any repeated characters. Example Usage: ```python print(compress(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compress(\\"abcdef\\")) # Output: \\"abcdef\\" (since the compression \\"a1b1c1d1e1f1\\" is not shorter) print(compress(\\"\\")) # Output: \\"\\" print(compress(\\"aa\\")) # Output: \\"aa\\" (since the compression \\"a2\\" is not shorter) ``` **Important:** - Ensure the function correctly handles different types of input strings. - Implement the function in an efficient manner with appropriate handling of edge cases.","solution":"def compress(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) compressed_string = \\"\\".join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"# Problem Statement: You are tasked with designing a function to simulate a simplified task scheduling system that operates on a single machine. The system processes tasks in different priority levels, ensuring higher priority tasks get executed first. Each task has a duration and a priority level. **Objective:** Write a function `schedule_tasks(n: int, tasks: List[Tuple[int, int, int]]) -> List[int]` that schedules the tasks based on their priority and returns the order in which the tasks should be executed. If two tasks have the same priority, the task that appears first in the input should be executed first. **Input:** * An integer `n` representing the number of tasks. * A list of `tasks` where each task is represented as a tuple of three integers: `(task_id, duration, priority)`. - `task_id` is a unique identifier for the task. - `duration` is the time it takes to execute the task. - `priority` is an integer representing the priority of the task (higher value means higher priority). **Output:** * A list of task IDs representing the execution order. **Constraints:** * 1 ≤ n ≤ 10^5 * Each task ID will be unique. * Durations and priorities will be non-negative integers and can be large, but are not explicitly constrained. **Example:** ```python assert schedule_tasks(5, [(1, 4, 2), (2, 3, 3), (3, 2, 1), (4, 2, 3), (5, 1, 2)]) == [2, 4, 1, 5, 3] assert schedule_tasks(3, [(1, 5, 1), (2, 3, 2), (3, 7, 1)]) == [2, 1, 3] assert schedule_tasks(4, [(1, 2, 5), (2, 3, 5), (3, 1, 4), (4, 4, 3)]) == [1, 2, 3, 4] ``` **Scenario:** Imagine you are responsible for building a backend for a task scheduling application for a data processing pipeline. The pipeline has limited resources and can only process one task at a time, with priorities determining the order of task processing. Your function will ensure tasks are processed in the correct order, optimally utilizing resource time.","solution":"from typing import List, Tuple def schedule_tasks(n: int, tasks: List[Tuple[int, int, int]]) -> List[int]: Schedules task based on their priority and returns the order of execution. # Sort tasks first by priority (descending), then by their appearance (order in input) sorted_tasks = sorted(tasks, key=lambda x: (-x[2], tasks.index(x))) # Extract the task IDs in the sorted order task_order = [task[0] for task in sorted_tasks] return task_order"},{"question":"You are tasked with creating a function `alphabet_frequency` that analyzes the frequency of each letter in a string and returns a dictionary where the keys are the letters and the values are the counts. Ensure that the function is not case-sensitive and only counts alphabetic characters. # Requirements: 1. The input string can contain any characters but the function should only count alphabetic characters. 2. The function should ignore case, considering \'A\' and \'a\' as the same letter. 3. Return a dictionary with lowercase letters as keys and their respective counts as values. 4. The function should handle empty strings and return an empty dictionary if there are no alphabetic characters. # Function Signature: ```python def alphabet_frequency(text: str) -> dict: Input Parameters ---------------- text : str The input string to be analyzed for letter frequency. Returns ------- frequency_dict : dict A dictionary with lowercase alphabetic characters as keys and their counts as values. Examples -------- >>> alphabet_frequency(\\"Hello World!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> alphabet_frequency(\\"1234 @#!\\") {} >>> alphabet_frequency(\\"\\") {} pass ``` # Constraints: * The input string can contain any type of characters including numbers, punctuation marks, and whitespace. * The dictionary should have only alphabetic characters as keys and their frequency as values. Implement the function `alphabet_frequency` and ensure it handles various edge cases.","solution":"def alphabet_frequency(text: str) -> dict: Returns a dictionary with the frequency of each alphabetical character in the input text. The function ignores case and only counts alphabetic characters. Parameters: text (str): The input string to be analyzed for letter frequency. Returns: dict: A dictionary with lowercase alphabetic characters as keys and their counts as values. # Initialize an empty dictionary to hold the frequency counts frequency_dict = {} # Iterate over each character in the text after converting it to lowercase for char in text.lower(): if char.isalpha(): # Increment the count for this character frequency_dict[char] = frequency_dict.get(char, 0) + 1 return frequency_dict"},{"question":"# Flatten Nested Dictionary You are tasked with writing a function to flatten a nested dictionary. The function should convert a dictionary with nested dictionaries into a flattened dictionary where keys are merged into a single key separated by dots (`.`). Function Signature ```python def flatten_dict(dictionary: dict, parent_key: str = \'\') -> dict: ``` Inputs - `dictionary` (dict): The input dictionary to be flattened. - `parent_key` (str, optional): The base key used during the recursive calls (default is an empty string). Output - (dict): A single-level dictionary with the flattened keys. Constraints - The input dictionary can be empty (`{}`). - Keys in the resulting dictionary should be concatenated by dots (`.`). - The dictionary can have nested dictionaries at any level. Example Usage ```python >>> flatten_dict({\'a\': 1, \'b\': {\'c\': 2, \'d\': {\'e\': 3}}}) {\'a\': 1, \'b.c\': 2, \'b.d.e\': 3} >>> flatten_dict({\'key\': {\'subkey\': {\'subsubkey\': \'value\'}}}) {\'key.subkey.subsubkey\': \'value\'} >>> flatten_dict({\'x\': {\'y\': {\'z\': {}}}}) {\'x.y.z\': {}} >>> flatten_dict({}) {} ``` Explanation Write a function that: 1. Reads in the input dictionary and an optional base key. 2. Iterates through the dictionary, checking if the value is another dictionary. 3. Recursively flattens the dictionary, concatenating keys with `.` if the value is a nested dictionary. 4. Combines the results into a single dictionary. 5. Ensures that the function correctly handles empty dictionaries and nested structures. Ensure your solution is efficient and handles all outlined edge cases.","solution":"def flatten_dict(dictionary: dict, parent_key: str = \'\') -> dict: Flattens a nested dictionary into a single-level dictionary with keys concatenated by dots. items = [] for k, v in dictionary.items(): new_key = f\\"{parent_key}.{k}\\" if parent_key else k if isinstance(v, dict): if v: items.extend(flatten_dict(v, new_key).items()) else: items.append((new_key, {})) else: items.append((new_key, v)) return dict(items)"},{"question":"# Coding Assessment Question Context: You are given a grid filled with numbers from 1 to n^2 where n is the length of the grid\'s side. Every number from 1 to n^2 appears exactly once. You need to find the longest increasing path where each step can move in any of the four cardinal directions (up, down, left, or right). Given a 2D grid, your task is to write a function that computes the length of the longest increasing path in the grid. Task: Write a function `longest_increasing_path(grid: List[List[int]]) -> int` that computes the length of the longest increasing path in the grid. The function should implement the following steps: 1. Iterate through each cell in the grid. 2. From each cell, perform a Depth-First Search (DFS) or Dynamic Programming to explore the longest increasing path. 3. Keep track of the longest path found in the process. 4. Return the length of the longest increasing path. Input: * `grid` (2 <= len(grid) <= 50, 2 <= len(grid[0]) <= 50): A 2D list of integers where each integer is unique and ranges from 1 to n^2. Output: * Integer representing the length of the longest increasing path in the grid. Constraints: * You may assume the input grid is always valid and of the given constraints. Performance Requirements: * The algorithm should efficiently handle the upper edge case (50 x 50 grid). * Optimize space and ensure minimal time complexity. Example: ```python assert longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ]) == 4 assert longest_increasing_path([ [3, 4, 5], [3, 2, 6], [2, 2, 1] ]) == 4 assert longest_increasing_path([ [1, 2], [4, 3] ]) == 4 ``` Good luck! Ensure you handle edge cases and optimize your solution for large grid sizes.","solution":"def longest_increasing_path(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) memo = [[-1] * cols for _ in range(rows)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] > grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length longest = 0 for i in range(rows): for j in range(cols): longest = max(longest, dfs(i, j)) return longest"},{"question":"# Question: Minimum Window Substring Context You are tasked with finding a small window within a given string that contains all the characters of another string. This problem is crucial in scenarios such as text processing, where you need to identify patterns or substrings efficiently. Task Implement the `min_window_substring` function that takes in two strings, `s` (the main string) and `t` (the pattern), and returns the smallest window in `s` which contains all the characters in `t`. If no such window exists, return an empty string. Function Signature ```python def min_window_substring(s: str, t: str) -> str: pass ``` Input - `s`: A string (length m, where 1 <= m <= 10^4) - `t`: A string (length n, where 1 <= n <= 10^4) Output - Return the smallest window in `s` that contains all characters in `t`; if no such window exists, return an empty string. Constraints - The function should aim for a time complexity of O(m + n). - The function should have a space complexity of O(t), where t is the number of unique characters in `t`. Example ```python assert min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" assert min_window_substring(\\"a\\", \\"a\\") == \\"a\\" assert min_window_substring(\\"a\\", \\"aa\\") == \\"\\" assert min_window_substring(\\"abcde\\", \\"aa\\") == \\"\\" assert min_window_substring(\\"abcdabcalsa\\", \\"abc\\") == \\"abc\\" ``` Note Your implementation should handle edge cases, such as when `t` contains duplicate characters, or when `t` is larger than `s`. The comparison is case-sensitive, i.e., \'A\' and \'a\' are considered different characters.","solution":"def min_window_substring(s: str, t: str) -> str: from collections import Counter, defaultdict if not s or not t: return \\"\\" t_counter = Counter(t) current_counter = defaultdict(int) required_balance = len(t_counter) left = 0 matched_balance = 0 min_len = float(\'inf\') min_window = \\"\\" for right in range(len(s)): character = s[right] current_counter[character] += 1 if character in t_counter and current_counter[character] == t_counter[character]: matched_balance += 1 while left <= right and matched_balance == required_balance: window_length = right - left + 1 if window_length < min_len: min_len = window_length min_window = s[left:right + 1] current_counter[s[left]] -= 1 if s[left] in t_counter and current_counter[s[left]] < t_counter[s[left]]: matched_balance -= 1 left += 1 return min_window"},{"question":"# Context You have been asked to develop a simple order management system for a small bookstore. One of the tasks is to implement a function that checks the availability of a requested book in the bookstore\'s inventory. # Task Write a Python function that checks if a specified book (by its title) is available in the bookstore\'s inventory. Your function should handle various edge cases and return meaningful messages based on different scenarios. # Function Signature ```python def check_book_availability(inventory: list, book_title: str) -> dict: ``` # Requirements - Your function should return a dictionary with two keys: `\\"available\\"` and `\\"message\\"`. - `\\"available\\"`: A boolean indicating if the book is available. - `\\"message\\"`: A string message describing the status of the requested book. - If the book is available, the `\\"message\\"` should be `\\"The book \'book_title\' is available.\\"`. - If the book is not available, the `\\"message\\"` should be `\\"The book \'book_title\' is not available.\\"`. - If the provided book title is an empty string, return the message `\\"Invalid book title.\\"`. - If the provided inventory is not a list, return the message `\\"Invalid inventory data.\\"`. # Constraints - The inventory list contains dictionaries with at least one key, `\\"title\\"`. - Example inventory: `[{\\"title\\": \\"To Kill a Mockingbird\\"}, {\\"title\\": \\"1984\\"}, {\\"title\\": \\"The Great Gatsby\\"}]` # Example Usage ```python inventory = [{\\"title\\": \\"To Kill a Mockingbird\\"}, {\\"title\\": \\"1984\\"}, {\\"title\\": \\"The Great Gatsby\\"}] result = check_book_availability(inventory, \\"1984\\") print(result) # Output: {\'available\': True, \'message\': \\"The book \'1984\' is available.\\"} result = check_book_availability(inventory, \\"\\") print(result) # Output: {\'available\': False, \'message\': \\"Invalid book title.\\"} ``` # Notes - Use proper condition checks and error handling to ensure the function returns correct and meaningful messages. - The function should be case-insensitive when checking the book title in the inventory (e.g., \\"1984\\" and \\"1984\\" should be treated as the same book).","solution":"def check_book_availability(inventory, book_title): Checks if a specified book is available in the bookstore\'s inventory. Parameters: - inventory (list): A list of dictionaries, where each dictionary represents a book and contains a \'title\' key. - book_title (str): The title of the book to check availability for. Returns: - dict: A dictionary with keys \'available\' (bool) and \'message\' (str) indicating the availability status and a message. # Check if the inventory is a list if not isinstance(inventory, list): return {\'available\': False, \'message\': \\"Invalid inventory data.\\"} # Check if the book title is valid if not isinstance(book_title, str) or not book_title.strip(): return {\'available\': False, \'message\': \\"Invalid book title.\\"} # Normalize the book title for case-insensitive comparison normalized_title = book_title.strip().lower() # Check if the book is in the inventory for book in inventory: if \'title\' in book and book[\'title\'].strip().lower() == normalized_title: return {\'available\': True, \'message\': f\\"The book \'{book_title}\' is available.\\"} return {\'available\': False, \'message\': f\\"The book \'{book_title}\' is not available.\\"}"},{"question":"Context: You are building a mini social network application, and you need to manage user connections efficiently. Given the importance of quickly finding mutual connections and tracking direct relationships, you\'ll implement several methods on a `UserConnections` class that uses a graph data structure. # Task: 1. Implement a method `add_connection(self, user1: str, user2: str) -> None` that creates a bidirectional connection between `user1` and `user2`. 2. Implement a method `remove_connection(self, user1: str, user2: str) -> None` that removes the bidirectional connection between `user1` and `user2`. 3. Implement a method `mutual_connections(self, user1: str, user2: str) -> List[str]` that returns a list of mutual connections between `user1` and `user2`. 4. Implement a method `direct_connections(self, user: str) -> List[str]` that returns a list of all direct connections of the given `user`. # Function Signature: ```python def add_connection(self, user1: str, user2: str) -> None: Adds a bidirectional connection between user1 and user2. def remove_connection(self, user1: str, user2: str) -> None: Removes the bidirectional connection between user1 and user2. def mutual_connections(self, user1: str, user2: str) -> List[str]: Returns a list of mutual connections between user1 and user2. def direct_connections(self, user: str) -> List[str]: Returns a list of all direct connections for the given user. ``` # Input & Output Formats: * The `add_connection` method takes two strings `user1` and `user2` and returns `None`. It modifies the internal graph structure. * The `remove_connection` method takes two strings `user1` and `user2` and returns `None`. It modifies the internal graph structure. * The `mutual_connections` method takes two strings `user1` and `user2` and returns a list of strings representing the mutual connections. * The `direct_connections` method takes one string `user` and returns a list of strings representing the direct connections of the user. # Constraints: * Assume usernames are unique and case-insensitive. * Connections are bidirectional; if `user1` is connected to `user2`, then `user2` is also connected to `user1`. * The graph should handle up to approximately 10,000 users efficiently. * Methods should operate efficiently to handle high-frequency operations typical in social network applications. # Performance Requirements: * Adding and removing connections should operate within O(1) on average. * Finding mutual connections should be within O(min(d1, d2)), where `d1` and `d2` are the degrees of `user1` and `user2` respectively. * Finding direct connections should operate within O(1). # Example: ```python # Initialize UserConnections uc = UserConnections() # Add connections uc.add_connection(\\"Alice\\", \\"Bob\\") uc.add_connection(\\"Alice\\", \\"Charlie\\") uc.add_connection(\\"Bob\\", \\"Charlie\\") uc.add_connection(\\"Bob\\", \\"David\\") # Direct connections of Bob print(uc.direct_connections(\\"Bob\\")) # Expected Output: [\\"Alice\\", \\"Charlie\\", \\"David\\"] # Mutual connections between Alice and Bob print(uc.mutual_connections(\\"Alice\\", \\"Bob\\")) # Expected Output: [\\"Charlie\\"] # Remove connection between Bob and Charlie uc.remove_connection(\\"Bob\\", \\"Charlie\\") # Updated direct connections of Bob print(uc.direct_connections(\\"Bob\\")) # Expected Output: [\\"Alice\\", \\"David\\"] # Updated mutual connections between Alice and Bob print(uc.mutual_connections(\\"Alice\\", \\"Bob\\")) # Expected Output: [] ```","solution":"from typing import List class UserConnections: def __init__(self): self.connections = {} def add_connection(self, user1: str, user2: str) -> None: user1, user2 = user1.lower(), user2.lower() if user1 not in self.connections: self.connections[user1] = set() if user2 not in self.connections: self.connections[user2] = set() self.connections[user1].add(user2) self.connections[user2].add(user1) def remove_connection(self, user1: str, user2: str) -> None: user1, user2 = user1.lower(), user2.lower() if user1 in self.connections: if user2 in self.connections[user1]: self.connections[user1].remove(user2) if user2 in self.connections: if user1 in self.connections[user2]: self.connections[user2].remove(user1) def mutual_connections(self, user1: str, user2: str) -> List[str]: user1, user2 = user1.lower(), user2.lower() if user1 in self.connections and user2 in self.connections: mutuals = self.connections[user1].intersection(self.connections[user2]) return list(mutuals) return [] def direct_connections(self, user: str) -> List[str]: user = user.lower() if user in self.connections: return list(self.connections[user]) return []"},{"question":"# Coding Assessment Question Problem Statement You are given a linked list where each node contains an integer value. Your task is to reverse the linked list in groups of size `k` and return the modified list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is. Requirements * **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: ``` * **Input**: * `head`: The head node of the linked list. * `k`: An integer where 1 <= k <= 100. * **Output**: * The head node of the reversed linked list. Constraints * The function must reverse the linked list in place. * The function should be able to handle an empty linked list (i.e., when `head` is `None`). Example ```python # Helper function to create a linked list from a list of values def create_linked_list(lst): dummy = ListNode(0) curr = dummy for val in lst: curr.next = ListNode(val) curr = curr.next return dummy.next # Helper function to convert linked list to list of values def linked_list_to_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst # Example usage: head = create_linked_list([1, 2, 3, 4, 5]) k = 2 new_head = reverse_k_group(head, k) print(linked_list_to_list(new_head)) # Output: [2, 1, 4, 3, 5] head = create_linked_list([1, 2, 3, 4, 5]) k = 3 new_head = reverse_k_group(head, k) print(linked_list_to_list(new_head)) # Output: [3, 2, 1, 4, 5] ``` Explanation 1. Traverse the linked list to find groups of size `k`. 2. Reverse each group of `k` nodes. 3. Connect the reversed segments properly to form the final modified linked list. 4. If there are fewer than `k` nodes left at the end, leave them as they are. Edge Cases to Consider 1. An empty linked list. 2. A linked list with fewer than `k` nodes. 3. A linked list where `k` is 1. 4. The situation where the list size is not evenly divisible by `k`. Implement the function `reverse_k_group` according to the specifications above and ensure it passes all the given test cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: if k == 1 or not head: return head dummy = ListNode() dummy.next = head prev_group_end = dummy while True: kth_node = get_kth_node(prev_group_end, k) if not kth_node: break group_start = prev_group_end.next next_group_start = kth_node.next # Reverse the group prev, curr = kth_node.next, prev_group_end.next while curr != next_group_start: tmp = curr.next curr.next = prev prev = curr curr = tmp tmp = prev_group_end.next prev_group_end.next = kth_node prev_group_end = tmp return dummy.next def get_kth_node(curr, k): while curr and k > 0: curr = curr.next k -= 1 return curr"},{"question":"# Coding Assessment Question: In this task, you will create a function that sorts products in a warehouse based on their expiration dates and removes expired products from the list. **Function Details**: * Write a function `filter_and_sort_products(products: List[Dict[str, Any]]) -> List[Dict[str, Any]]` that filters out expired products and returns a sorted list of the remaining products. **Input**: * `products` (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a product with the following keys: - \'name\' (str): The product name. - \'expiration_date\' (str): The expiration date in the format \\"YYYY-MM-DD\\". - \'quantity\' (int): The quantity of the product in the warehouse. **Output**: * A list of dictionaries representing the remaining products, sorted in ascending order by `expiration_date`. **Constraints**: * Assume all dates are valid and strictly in \\"YYYY-MM-DD\\" format. * Real-life constraints apply (e.g., list may be large, handle sorting efficiently). * Current date should be taken as `datetime.date.today()`. **Performance Requirements**: * Process and filter the list in linear time, O(n), and sort it in O(n log n). **Scenario**: The warehouse management system should keep track of products and ensure items with expired dates are not considered in operations. Sorting by expiration dates helps in knowing which products need to be moved out first. **Example Use Cases**: * `filter_and_sort_products([{\\"name\\": \\"Milk\\", \\"expiration_date\\": \\"2023-10-15\\", \\"quantity\\": 10}, {\\"name\\": \\"Cheese\\", \\"expiration_date\\": \\"2023-10-12\\", \\"quantity\\": 5}, {\\"name\\": \\"Yogurt\\", \\"expiration_date\\": \\"2023-10-10\\", \\"quantity\\": 7}])` with the current date being \\"2023-10-11\\" should return: `[{\\"name\\": \\"Cheese\\", \\"expiration_date\\": \\"2023-10-12\\", \\"quantity\\": 5}, {\\"name\\": \\"Milk\\", \\"expiration_date\\": \\"2023-10-15\\", \\"quantity\\": 10}]`. **Edge Cases**: * Input like `filter_and_sort_products([{\\"name\\": \\"Milk\\", \\"expiration_date\\": \\"2023-10-05\\", \\"quantity\\": 10}])` must return an empty list if the current date is \\"2023-10-06\\". * If all products are expired, the result should be an empty list.","solution":"from datetime import datetime from typing import List, Dict, Any def filter_and_sort_products(products: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Filters out expired products and returns a sorted list of remaining products based on their expiration dates. today = datetime.today().date() filtered_products = [product for product in products if datetime.strptime(product[\'expiration_date\'], \\"%Y-%m-%d\\").date() > today] filtered_and_sorted_products = sorted(filtered_products, key=lambda x: x[\'expiration_date\']) return filtered_and_sorted_products"},{"question":"# Most Frequent Element Objective Write a function that returns the most frequent element in a list of integers. In case of a tie, return the smallest element. Function Signature ```python def most_frequent_element(numbers: list[int]) -> int: ``` Parameters * `numbers` (list[int]): A list of integers which can include negative numbers. Returns * `int`: The most frequent integer in the list. In case of a tie, the smallest integer among the most frequent ones. Constraints 1. The list `numbers` contains at least one integer. 2. The integers in the list can be both negative and positive. Examples ```python >>> most_frequent_element([1, 3, 1, 3, 2, 1]) 1 >>> most_frequent_element([3, 3, 1, 1, 3, 1]) 1 >>> most_frequent_element([1, 2, 2, 3, 3, 3, 4, 4]) 3 >>> most_frequent_element([-1, -1, 2, 3, 4, 2, -1]) -1 >>> most_frequent_element([4]) 4 ``` Edge Cases * The list contains only one element. * All elements in the list are the same. * The list contains negative and positive numbers. Instructions 1. Implement `most_frequent_element` adhering to the function signature above. 2. Ensure to handle invalid inputs gracefully: - Raise `ValueError` with an appropriate message if `numbers` is not a list of integers. - Handle edge cases where the list might have elements with the same frequency. 3. Utilize efficient operations for counting and determining the result to ensure performance. Testing Use the provided examples and edge cases to validate your implementation.","solution":"def most_frequent_element(numbers: list[int]) -> int: Returns the most frequent element in a list of integers. In case of a tie, returns the smallest element among the most frequent ones. if not isinstance(numbers, list) or not all(isinstance(x, int) for x in numbers): raise ValueError(\\"Input must be a list of integers\\") frequency_map = {} for num in numbers: if num in frequency_map: frequency_map[num] += 1 else: frequency_map[num] = 1 most_frequent = None max_frequency = -1 for num, freq in frequency_map.items(): if freq > max_frequency or (freq == max_frequency and num < most_frequent): most_frequent = num max_frequency = freq return most_frequent # Example Usage: # print(most_frequent_element([1, 3, 1, 3, 2, 1])) # Should return 1 # print(most_frequent_element([3, 3, 1, 1, 3, 1])) # Should return 1 # print(most_frequent_element([1, 2, 2, 3, 3, 3, 4, 4])) # Should return 3 # print(most_frequent_element([-1, -1, 2, 3, 4, 2, -1])) # Should return -1 # print(most_frequent_element([4])) # Should return 4"},{"question":"# Problem Statement Implement a function `reverse_subarray(arr: list[int], start: int, end: int) -> list[int]` that takes a list of integers `arr` and two integers `start` and `end`, and returns the list where the subarray from `start` to `end` indices is reversed. Indices are assumed to be zero-based. # Function Signature ```python def reverse_subarray(arr: list[int], start: int, end: int) -> list[int]: ``` # Input * A list of integers `arr` (1 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6). * Two integers `start` and `end` (0 <= start <= end < len(arr)) representing the start and end indices of the subarray to reverse. # Output * A list of integers with the specified subarray reversed. # Constraints * The function should not modify the input list, but return a new list with the modifications. * Ensure efficient handling of the subarray reversal. # Example ```python print(reverse_subarray([1, 2, 3, 4, 5], 1, 3)) # Output: [1, 4, 3, 2, 5] print(reverse_subarray([9, 8, 7, 6], 0, 3)) # Output: [6, 7, 8, 9] print(reverse_subarray([10], 0, 0)) # Output: [10] print(reverse_subarray([1, 2, 3, 4], 1, 1)) # Output: [1, 2, 3, 4] ``` # Guidelines * Test your function rigorously with various inputs including edge cases. * Make sure to handle cases where `start` and `end` are the same efficiently.","solution":"def reverse_subarray(arr: list[int], start: int, end: int) -> list[int]: Returns a new list with the subarray from start to end indices reversed. if start == end: return arr.copy() # If start and end are the same, return a copy of the array # Create a copy of the array to avoid modifying the original result = arr[:] # Reverse the subarray in the result result[start:end+1] = result[start:end+1][::-1] return result"},{"question":"# Question You are to implement a monitoring system for network packets using the Segment Tree data structure. This system will be used to calculate the maximum packet size in a specified range of indices quickly. # Function to Implement Function Signature ```python class NetworkMonitor: def __init__(self, packet_sizes: List[int]): Initialize the NetworkMonitor with a list of packet sizes. Args: packet_sizes (List[int]): A list of integers representing the sizes of packets. def update_packet_size(self, index: int, new_size: int) -> None: Update the size of the packet at the specified index. Args: index (int): The index of the packet to update. new_size (int): The new size of the packet. def get_max_packet_size(self, left_index: int, right_index: int) -> int: Retrieve the maximum packet size within a specified range of indices. Args: left_index (int): The left boundary (inclusive) of the range. right_index (int): The right boundary (inclusive) of the range. Returns: int: The maximum packet size in the given range. ``` # Examples ```python # Example 1 packet_sizes = [5, 3, 8, 6, 2, 7, 4] monitor = NetworkMonitor(packet_sizes) assert monitor.get_max_packet_size(1, 4) == 8 # Maximum packet size in range [1, 4] is 8 monitor.update_packet_size(3, 10) assert monitor.get_max_packet_size(1, 4) == 10 # After updating index 3, maximum packet size in range [1, 4] is now 10 # Example 2 packet_sizes = [2, 9, 1, 3, 4] monitor = NetworkMonitor(packet_sizes) assert monitor.get_max_packet_size(0, 2) == 9 # Maximum packet size in range [0, 2] is 9 monitor.update_packet_size(2, 12) assert monitor.get_max_packet_size(0, 2) == 12 # After updating index 2, maximum packet size in range [0, 2] is now 12 ``` # Constraints * The length of the packet sizes list will not exceed 10^5. * The packet sizes will be non-negative integers and will not exceed 10^6. * The number of update operations will be at most 10^5. * The number of range queries will be at most 10^5. * 0 <= index < length of packet sizes.","solution":"from typing import List class NetworkMonitor: def __init__(self, packet_sizes: List[int]): Initialize the NetworkMonitor with a list of packet sizes. self.n = len(packet_sizes) self.packet_sizes = packet_sizes[:] self.tree = [0] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.tree[node] = self.packet_sizes[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(left_child, start, mid) self.build(right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def update_packet_size(self, index: int, new_size: int) -> None: Update the size of the packet at the specified index. self._update(0, 0, self.n - 1, index, new_size) def _update(self, node, start, end, idx, value): if start == end: self.packet_sizes[idx] = value self.tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: self._update(left_child, start, mid, idx, value) else: self._update(right_child, mid + 1, end, idx, value) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def get_max_packet_size(self, left_index: int, right_index: int) -> int: Retrieve the maximum packet size within a specified range of indices. return self._query(0, 0, self.n - 1, left_index, right_index) def _query(self, node, start, end, L, R): if R < start or L > end: return -float(\'inf\') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_query = self._query(left_child, start, mid, L, R) right_query = self._query(right_child, mid + 1, end, L, R) return max(left_query, right_query)"},{"question":"# Problem: Generate All Unique Subsequences of a String You are tasked with writing a Python function that generates and returns all unique subsequences of a given string. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Function Signature ```python def generate_unique_subsequences(s: str) -> List[str]: pass ``` # Description Given: - `s`: A string consisting of lowercase English letters. Your implementation should: 1. Return a list of unique subsequences of `s` in lexicographical order. 2. Ensure that the result does not contain any duplicate subsequences. # Constraints - The length of the string `s` is between `1` and `16` inclusive. # Input/Output Examples ```python # Example 1 s = \\"abc\\" print(generate_unique_subsequences(s)) # Output: [\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] # Example 2 s = \\"aba\\" print(generate_unique_subsequences(s)) # Output: [\\"\\", \\"a\\", \\"aa\\", \\"ab\\", \\"aba\\", \\"b\\", \\"ba\\"] # Example 3 s = \\"a\\" print(generate_unique_subsequences(s)) # Output: [\\"\\", \\"a\\"] ``` # Edge Cases to Consider - The string `s` contains repeated characters which should not result in duplicate subsequences in the output. # Important Notes - Use recursive or iterative methods to generate all subsequences. - Ensure the results are unique and sorted in lexicographical order. # Detailed Example Consider the input string `s = \\"aba\\"`: - The subsequences are: `[\\"\\", \\"a\\", \\"b\\", \\"aa\\", \\"ab\\", \\"ba\\", \\"aba\\"]` - The list of subsequences must be sorted in lexicographical order: `[\\"\\", \\"a\\", \\"aa\\", \\"ab\\", \\"aba\\", \\"b\\", \\"ba\\"]`","solution":"from typing import List def generate_unique_subsequences(s: str) -> List[str]: def subsequences(s, index, curr, result): if index == len(s): result.add(curr) return subsequences(s, index + 1, curr, result) # Exclude the current character subsequences(s, index + 1, curr + s[index], result) # Include the current character result = set() subsequences(s, 0, \\"\\", result) return sorted(result)"},{"question":"# Binary Tree Depth Sum Given a binary tree, compute the sum of the values of all nodes at each depth level. The root node is considered to be at depth 0, its children are at depth 1, their children are at depth 2, and so on. # Task Write a function `depth_sum(root: Optional[TreeNode]) -> List[int]` that returns a list of sums of node values at each depth level of the binary tree. # Details - **Input**: A binary tree represented by its `root` node, which is of type `Optional[TreeNode]`. The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - **Output**: A list of integers, where the i-th element is the sum of node values at depth i. - **Constraints**: Handle empty trees (i.e., `root` is `None`) gracefully. # Example ```python def depth_sum(root: Optional[TreeNode]) -> List[int]: pass # Your implementation here # Example usages # Binary tree: # 1 # / # 2 3 # / / # 4 5 6 7 # Expected output: [1, 5, 22] root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) print(depth_sum(root)) # Expected output: [1, 5, 22] # Binary tree: # 7 # / # 0 -2 # # 3 # Expected output: [7, -2, 3] root = TreeNode(7, TreeNode(0), TreeNode(-2, None, TreeNode(3))) print(depth_sum(root)) # Expected output: [7, -2, 3] ``` # Explanation 1. **Traversal**: Traverse the binary tree level by level (breadth-first search can be useful). 2. **Summation**: For each level, accumulate the sum of node values. 3. **Return**: The list of sum results, one for each level from 0 up to the deepest level containing nodes. # Constraints 1. The depth of the tree can be substantial (e.g., tens or hundreds of levels), so an efficient traversal mechanism is critical. 2. Handle edge cases such as empty trees or trees with only one node.","solution":"from typing import List, Optional from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] level_sum = [] queue = deque([(root, 0)]) while queue: node, depth = queue.popleft() if len(level_sum) <= depth: level_sum.append(0) level_sum[depth] += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return level_sum"},{"question":"# Question: Implement an Alarm Scheduler As a software developer, you need to build a utility for scheduling and managing alarms. An alarm consists of a time in 24-hour format and a message. Your utility should allow setting multiple alarms, removing alarms, and checking which alarms need to go off at a given time. Your Task 1. Implement a class `AlarmScheduler` that supports setting, removing, and checking alarms. 2. Implement the following methods: - `set_alarm(time: str, message: str) -> None`: Adds a new alarm with the given time and message. - `remove_alarm(time: str) -> bool`: Removes the alarm set for the given time. Returns `True` if the alarm existed and was removed, `False` otherwise. - `check_alarms(current_time: str) -> list[str]`: Returns a list of messages for all alarms that match the current time. Class Signature ```python class AlarmScheduler: def __init__(self): pass def set_alarm(self, time: str, message: str) -> None: pass def remove_alarm(self, time: str) -> bool: pass def check_alarms(self, current_time: str) -> list[str]: pass ``` # Parameters * **time, current_time (str)**: The time in \'HH:MM\' format (24-hour). * **message (str)**: The message to be displayed when the alarm goes off. # Returns For the `check_alarms` method: * A list of messages for the alarms that match the current time. # Examples ```python # Example usage scheduler = AlarmScheduler() scheduler.set_alarm(\\"08:00\\", \\"Morning workout\\") scheduler.set_alarm(\\"09:00\\", \\"Meeting with team\\") print(scheduler.check_alarms(\\"08:00\\")) # Expected: [\\"Morning workout\\"] print(scheduler.remove_alarm(\\"08:00\\")) # Expected: True print(scheduler.check_alarms(\\"08:00\\")) # Expected: [] print(scheduler.check_alarms(\\"09:00\\")) # Expected: [\\"Meeting with team\\"] print(scheduler.remove_alarm(\\"10:00\\")) # Expected: False ``` # Constraints * The time strings will always be in the specified 24-hour format. * Multiple alarms can be set for different times. * The system should handle edge cases gracefully, such as trying to remove a non-existent alarm.","solution":"class AlarmScheduler: def __init__(self): self.alarms = {} def set_alarm(self, time: str, message: str) -> None: if time in self.alarms: self.alarms[time].append(message) else: self.alarms[time] = [message] def remove_alarm(self, time: str) -> bool: if time in self.alarms: del self.alarms[time] return True return False def check_alarms(self, current_time: str) -> list[str]: return self.alarms.get(current_time, [])"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},F={class:"card-container"},z={key:0,class:"empty-state"},O=["disabled"],R={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",R,"See more"))],8,O)):u("",!0)])}const j=h(S,[["render",P],["__scopeId","data-v-20645f71"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/15.md","filePath":"drive/15.md"}'),Y={name:"drive/15.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{B as __pageData,V as default};
