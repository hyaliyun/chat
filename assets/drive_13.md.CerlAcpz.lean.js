import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-f8545ba4"]]),S=JSON.parse('[{"question":"# Traveling Salesperson Problem with Genetic Algorithm **Context**: A logistics company is trying to optimize its delivery routes to minimize travel distance and time. They have formulated this as a Traveling Salesperson Problem (TSP) and want you to use a genetic algorithm to find an optimal route visiting each delivery point exactly once. # Task: Implement the `genetic_algorithm` function to solve the TSP. You are given a `City` class with the following attributes: ```python class City: def __init__(self, name, x, y): self.name = name self.x = x self.y = y def distance_to(self, other_city) -> float: Returns the Euclidean distance to another city. pass # Defined elsewhere ``` # Function Signature: ```python def genetic_algorithm( cities: list, population_size: int = 100, generations: int = 500, mutation_rate: float = 0.01, elite_size: int = 20 ) -> list: pass ``` # Input: - `cities (list)`: A list of `City` instances representing the delivery points. - `population_size (int)`: The number of routes in each generation. - `generations (int)`: The number of generations to evolve. - `mutation_rate (float)`: The probability of mutation in a route. - `elite_size (int)`: The number of top routes to carry over unchanged to the next generation. # Output: - A list of `City` instances representing the optimal route. # Constraints: - Ensure your algorithm handles multiple cities and large population sizes efficiently. - Handle edge cases where the list of cities contains zero or a single city. - Avoid invalid routes with repeated cities. # Example: ```python # Assume we have a proper implementation of `City` class cities = [ City(\'A\', 0, 0), City(\'B\', 2, 3), City(\'C\', 5, 5), City(\'D\', 1, 8), City(\'E\', 7, 2) ] optimal_route = genetic_algorithm(cities, population_size=50, generations=300, mutation_rate=0.02, elite_size=10) print(\\"Optimal Route:\\") for city in optimal_route: print(f\\"{city.name} ({city.x}, {city.y})\\") ``` **Expectation**: A solution demonstrating your understanding of genetic algorithms, effectively handling edge cases, optimizing performance, and producing a plausible, optimized route. This question aims to test the implementation of genetic algorithms, understanding of TSP, optimization techniques, and handling of probabilistic algorithms. The solution should show clear evolution of routes through selection, crossover, and mutation operations.","solution":"import random import math import numpy as np class City: def __init__(self, name, x, y): self.name = name self.x = x self.y = y def distance_to(self, other_city) -> float: Returns the Euclidean distance to another city. return math.sqrt((self.x - other_city.x)**2 + (self.y - other_city.y)**2) def create_route(city_list): Create a random route from a list of cities. route = random.sample(city_list, len(city_list)) return route def initial_population(pop_size, city_list): Generate initial population of routes. population = [create_route(city_list) for _ in range(pop_size)] return population def route_distance(route): Returns total distance of the given route. return sum([route[i].distance_to(route[i+1]) for i in range(len(route)-1)]) + route[-1].distance_to(route[0]) def rank_routes(population): Rank routes in the population by their total distance. return sorted([(route, route_distance(route)) for route in population], key=lambda x: x[1]) def selection(ranked_routes, elite_size): Select the routes to carry over to the next generation. selected_routes = [ranked_routes[i][0] for i in range(elite_size)] for i in range(len(ranked_routes) - elite_size): selected_routes.append(ranked_routes[np.random.randint(len(ranked_routes))][0]) return selected_routes def crossover(parent1, parent2): Perform ordered crossover between two parents. gene_a = int(random.random() * len(parent1)) gene_b = int(random.random() * len(parent1)) start_gene = min(gene_a, gene_b) end_gene = max(gene_a, gene_b) child_p1 = parent1[start_gene:end_gene] child_p2 = [item for item in parent2 if item not in child_p1] child = child_p1 + child_p2 return child def mutate(individual, mutation_rate): Perform swap mutation on an individual. for swapped in range(len(individual)): if random.random() < mutation_rate: swap_with = int(random.random() * len(individual)) city1 = individual[swapped] city2 = individual[swap_with] individual[swapped] = city2 individual[swap_with] = city1 return individual def next_generation(current_gen, elite_size, mutation_rate): Create the next generation. ranked_routes = rank_routes(current_gen) selection_results = selection(ranked_routes, elite_size) children = [] length = len(selection_results) - elite_size pool = random.sample(selection_results, len(selection_results)) for i in range(elite_size): children.append(selection_results[i]) for i in range(length): child = crossover(pool[i], pool[len(selection_results)-i-1]) children.append(child) next_gen = [mutate(child, mutation_rate) for child in children] return next_gen def genetic_algorithm(cities, population_size=100, generations=500, mutation_rate=0.01, elite_size=20): Genetic Algorithm for solving the TSP. pop = initial_population(population_size, cities) print(f\\"Initial distance: {route_distance(rank_routes(pop)[0][0])}\\") for i in range(generations): pop = next_generation(pop, elite_size, mutation_rate) best_route = rank_routes(pop)[0][0] print(f\\"Final distance: {route_distance(best_route)}\\") return best_route"},{"question":"**Problem Statement**: Write a function that takes a string `s` and returns an encoded version of that string using Run-Length Encoding (RLE). Your task will be to implement both a function to encode the string and another function to decode the encoded string back to its original form. Handle common edge cases and error conditions properly. # Function Signatures: ```python def run_length_encode(s: str) -> str: pass def run_length_decode(encoded_str: str) -> str: pass ``` # Input: The function `run_length_encode` should accept the following input: - `s` is a string consisting of alphanumeric characters and spaces. The function `run_length_decode` should accept the following input: - `encoded_str` is a string representing the run-length encoded version of the original string. # Output: - The `run_length_encode` function should return a string representing the run-length encoded version of the input string `s`. - The `run_length_decode` function should return the original string `s` that was encoded. - If the input string to `run_length_encode` is empty, return an empty string. - If the `run_length_decode` encounters an invalid format, raise a `ValueError` with the message `\\"Invalid encoded format\\"`. # Examples: ```python run_length_encode(\\"aaaabbbcc\\") # Expected output: \\"a4b3c2\\" run_length_encode(\\"abcd\\") # Expected output: \\"a1b1c1d1\\" run_length_decode(\\"a4b3c2\\") # Expected output: \\"aaaabbbcc\\" run_length_decode(\\"a1b1c1d1\\") # Expected output: \\"abcd\\" run_length_encode(\\"\\") # Expected output: \\"\\" run_length_decode(\\"\\") # Expected output: \\"\\" run_length_decode(\\"a4b3c\\") # Expected to raise ValueError(\\"Invalid encoded format\\") ``` # Constraints: - Both functions must process the strings in ( O(n) ) time complexity where ( n ) is the length of the input string.","solution":"def run_length_encode(s: str) -> str: Run-length encodes the input string s. Parameters: s (str): The input string to be encoded. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded = [] count = 1 current_char = s[0] for char in s[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded.append(f\\"{current_char}{count}\\") return \\"\\".join(encoded) def run_length_decode(encoded_str: str) -> str: Decodes a run-length encoded string. Parameters: encoded_str (str): The encoded string to be decoded. Returns: str: The decoded original string. Raises: ValueError: If the encoded string is not in valid format. if not encoded_str: return \\"\\" decoded = [] i = 0 n = len(encoded_str) while i < n: char = encoded_str[i] i += 1 count = 0 while i < n and encoded_str[i].isdigit(): count = count * 10 + int(encoded_str[i]) i += 1 if count == 0: raise ValueError(\\"Invalid encoded format\\") decoded.append(char * count) return \\"\\".join(decoded)"},{"question":"Coding Assessment Question # Objective Given a matrix, determine if it is symmetric and if it is an identity matrix. A symmetric matrix is one that is equal to its transpose, and an identity matrix is a square matrix with 1s on the main diagonal and 0s elsewhere. # Description You are tasked with creating two functions: 1. `is_symmetric` to determine if a given matrix is symmetric. 2. `is_identity` to determine if a given matrix is an identity matrix. A symmetric matrix is one that satisfies `matrix[i][j] == matrix[j][i]` for all valid `i` and `j`. An identity matrix is a square matrix where `matrix[i][i] == 1` for all valid `i`, and all other elements are 0. # Function Signatures ```python def is_symmetric(matrix: List[List[int]]) -> bool: Check if the given matrix is symmetric. Parameters: - matrix (List[List[int]]): A 2D list of integers representing the matrix Returns: - bool: True if the matrix is symmetric, False otherwise def is_identity(matrix: List[List[int]]) -> bool: Check if the given matrix is an identity matrix. Parameters: - matrix (List[List[int]]): A 2D list of integers representing the matrix Returns: - bool: True if the matrix is an identity matrix, False otherwise ``` # Input/Output Formats **Input:** - `matrix`: A 2D list of integers `matrix[i][j]` where `len(matrix) > 0` and `len(matrix[i])` is the same for all `i`. **Output:** - For `is_symmetric`: a boolean indicating whether the matrix is symmetric. - For `is_identity`: a boolean indicating whether the matrix is an identity matrix. # Constraints 1. `1 <= len(matrix) <= 100` 2. `1 <= len(matrix[i]) <= 100` 3. `-10^9 <= matrix[i][j] <= 10^9` # Example Usage ```python # Check if the matrix is symmetric matrix1 = [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ] print(is_symmetric(matrix1)) # Expected: True matrix2 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] print(is_symmetric(matrix2)) # Expected: True matrix3 = [ [1, 2], [3, 4] ] print(is_symmetric(matrix3)) # Expected: False # Check if the matrix is an identity matrix matrix4 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] print(is_identity(matrix4)) # Expected: True matrix5 = [ [1, 0, 0], [0, 0, 0], [0, 0, 1] ] print(is_identity(matrix5)) # Expected: False matrix6 = [ [1, 0], [0, 1] ] print(is_identity(matrix6)) # Expected: True matrix7 = [ [1, 0, 0], [0, 1, 0] ] print(is_identity(matrix7)) # Expected: False (it\'s not a square matrix) ``` # Hint Consider edge cases like non-square matrices where the symmetry check should immediately return False or matrices with different sizes for rows and columns which should also be handled appropriately. Ensure to handle edge cases by raising appropriate checks and errors.","solution":"from typing import List def is_symmetric(matrix: List[List[int]]) -> bool: Check if the given matrix is symmetric. Parameters: - matrix (List[List[int]]): A 2D list of integers representing the matrix Returns: - bool: True if the matrix is symmetric, False otherwise rows = len(matrix) cols = len(matrix[0]) if rows != cols: return False for i in range(rows): for j in range(i, cols): if matrix[i][j] != matrix[j][i]: return False return True def is_identity(matrix: List[List[int]]) -> bool: Check if the given matrix is an identity matrix. Parameters: - matrix (List[List[int]]): A 2D list of integers representing the matrix Returns: - bool: True if the matrix is an identity matrix, False otherwise rows = len(matrix) cols = len(matrix[0]) if rows != cols: return False for i in range(rows): for j in range(cols): if i == j: if matrix[i][j] != 1: return False else: if matrix[i][j] != 0: return False return True"},{"question":"# Scramble and Sort Strings Write a function that takes a list of words and returns a list where each word is scrambled (except for the first and last letters) and then sorted by the lengths of the original words in descending order. If two words have the same length, maintain their original order. Task Implement the `scramble_and_sort` function that performs the following steps: 1. **Scramble Words**: For each word in the input list, scramble the letters of the word, except for the first and last letters. If the word length is less than or equal to 3, keep it unchanged. 2. **Sort Words**: Sort the scrambled words by length of the original words in descending order. If words have the same length, keep their original relative order. Function Signature ```python def scramble_and_sort(words: List[str]) -> List[str]: pass ``` Input - A list of strings `words` where each string is a word containing only alphabetic characters (max length per string: (100) characters). Output - A list of scrambled words sorted by their original lengths in descending order. Constraints - You can assume all input words contain only alphabetic characters and the length of the list does not exceed (1000). Example ```python >>> scramble_and_sort([\\"apple\\", \\"hello\\", \\"world\\", \\"a\\", \\"I\\", \\"am\\", \\"coding\\"]) [\'cridon\', \'holle\', \'wlord\', \'aplpe\', \'am\', \'a\', \'I\'] >>> scramble_and_sort([\\"cat\\", \\"bat\\", \\"an\\", \\"and\\", \\"dogs\\", \\"fall\\", \\"cool\\"]) [\'dogs\', \'fall\', \'cool\', \'cat\', \'bat\', \'and\', \'an\'] ``` # Explanation: 1. **Scramble Words**: Scramble all characters between the first and the last for each word in a list. For example, \\"apple\\" could become \\"aplpe\\". Keep words with a length of 3 or less unchanged. 2. **Sort Words**: Words sorted by their original lengths in descending order while keeping relative order for words of the same length. For example, \\"apple\\" and \\"hello\\" would both be accountable as 5 characters long.","solution":"import random from typing import List def scramble_word(word: str) -> str: if len(word) <= 3: return word middle = list(word[1:-1]) random.shuffle(middle) return word[0] + \'\'.join(middle) + word[-1] def scramble_and_sort(words: List[str]) -> List[str]: scrambled_words = [scramble_word(word) for word in words] sorted_indices = sorted(range(len(words)), key=lambda i: len(words[i]), reverse=True) return [scrambled_words[i] for i in sorted_indices]"},{"question":"# Problem Statement You\'re developing a program for a book storage system. The books are stored in a list and each book has a title and a number of pages. Your task is to split the list of books into multiple lists while keeping the total number of pages in each sublist as close to equal as possible. You need to return the sublists after splitting. **Description**: Given a list of books, each represented as a tuple (title: str, pages: int), and an integer N representing the desired number of sublists, write a function `split_books` that distributes the books into N sublists such that the difference in the number of pages between the sublists is minimized. # Function Signature ```python def split_books(books: List[Tuple[str, int]], N: int) -> List[List[Tuple[str, int]]]: :param books: A list of tuples where each tuple represents a book with (title, pages). :param N: An integer representing the number of sublists to split into. :return: A list of N sublists, each containing a roughly equal number of total pages. ``` # Input * `books`: A list of tuples `[(title: str, pages: int),...]` where the length of the list is `0 <= len(books) <= 10^5`. * `N`: An integer `1 <= N <= len(books)`. # Output * A list of N sublists, with each sublist containing tuples `(title: str, pages: int)` such that the total pages in each sublist are almost equal. # Constraints * Ensure that each book is retained in the response and no book is duplicated or omitted. * Aim for an efficient approach that can handle large lists and minimize the difference in total pages between the sublists. # Example ```python assert split_books([(\\"Book1\\", 100), (\\"Book2\\", 200), (\\"Book3\\", 150), (\\"Book4\\", 70)], 2) == [[(\\"Book1\\", 100), (\\"Book4\\", 70)], [(\\"Book2\\", 200), (\\"Book3\\", 150)]] assert split_books([(\\"Book1\\", 300), (\\"Book2\\", 150)], 1) == [[(\\"Book1\\", 300), (\\"Book2\\", 150)]] assert split_books([(\\"Book1\\", 70), (\\"Book2\\", 80), (\\"Book3\\", 90), (\\"Book4\\", 60)], 4) == [[(\\"Book1\\", 70)], [(\\"Book2\\", 80)], [(\\"Book3\\", 90)], [(\\"Book4\\", 60)]] ``` # Edge Cases * Consider cases where the total number of pages in the sublists cannot be perfectly equal. * Handle scenarios where all books have an equal number of pages. * Optimal handling of cases where the number of books is less than or equal to the number of sublists (N).","solution":"from typing import List, Tuple def split_books(books: List[Tuple[str, int]], N: int) -> List[List[Tuple[str, int]]]: total_pages = sum(pages for title, pages in books) target_pages_per_group = total_pages // N groups = [[] for _ in range(N)] group_pages = [0] * N books_sorted_by_pages = sorted(books, key=lambda book: book[1], reverse=True) for book in books_sorted_by_pages: min_index = group_pages.index(min(group_pages)) groups[min_index].append(book) group_pages[min_index] += book[1] return groups"},{"question":"# Coding Assessment Question **Scenario**: You have been tasked to enhance the given `Tree` class to support additional functionalities that extend its capabilities and optimize its performance. Specifically, you need to handle balanced binary search trees (BST), perform both breadth-first and depth-first traversals, and ensure edge cases are managed effectively. **Requirements**: 1. **Tree Representation**: Extend the `Tree` class to support balanced binary search trees. 2. **Node Insertion**: Implement a method to insert nodes in such a manner that the tree remains balanced. 3. **Breadth-First Search (BFS)**: Implement `bfs_traversal` to perform a breadth-first search traversal of the tree. 4. **Edge Case Handling**: Ensure edge cases, such as an empty tree and single-node tree, are handled appropriately. **Function Implementation**: 1. **insert_balance(value: int) -> None** - Parameter: - `value`: The value to insert into the binary search tree. - Inserts a new value into the tree and balances it to ensure it remains a balanced BST. 2. **bfs_traversal() -> List[int]** - Performs a breadth-first search traversal of the tree and returns the list of visited nodes. 3. **test edge cases**: - Ensure your solution handles trees with no nodes, trees with only one node, and balancing after multiple insertions. **Input**: ```python t = Tree() t.insert_balance(10) t.insert_balance(5) t.insert_balance(15) t.insert_balance(3) t.insert_balance(7) t.insert_balance(12) t.insert_balance(17) ``` **Output**: ```python # Print the tree structure (in some visual or textual format representing balanced BST): # Example: # 10 # / # 5 15 # / / # 3 7 12 17 # Perform BFS traversal: [10, 5, 15, 3, 7, 12, 17] ``` **Constraints**: - The tree can contain up to 1000 nodes. - Node values are unique integers. - The balancing mechanism should ensure the tree remains approximately height-balanced after each insertion. Ensure you validate your solution with various test cases and edge conditions to verify its robustness and correctness.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class Tree: def __init__(self): self.root = None def insert_balance(self, value): # Insert the node and keep the tree balanced if self.root is None: self.root = TreeNode(value) else: self.root = self._insert(self.root, value) self._balance_tree() def _insert(self, node, value): if node is None: return TreeNode(value) elif value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) return node def _balance_tree(self): values = self._inorder_collect(self.root) self.root = self._build_balanced_tree(values) def _inorder_collect(self, node): if not node: return [] return self._inorder_collect(node.left) + [node.value] + self._inorder_collect(node.right) def _build_balanced_tree(self, values): if not values: return None mid = len(values) // 2 node = TreeNode(values[mid]) node.left = self._build_balanced_tree(values[:mid]) node.right = self._build_balanced_tree(values[mid+1:]) return node def bfs_traversal(self): if not self.root: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"# Context Sorting algorithms are fundamental in computer science and are used to arrange elements in a particular order. One of the more advanced and efficient sorting algorithms is Merge Sort, which uses a divide-and-conquer approach to recursively divide the array into two halves, sort each half, and then merge the sorted halves. # Task You are required to implement a function that performs merge sort on a given list and returns the sorted list. Your implementation should accurately follow the principles of Merge Sort, ensuring that the list is divided properly and the merging of sorted lists is handled correctly. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers that needs to be sorted. # Output - `List[int]`: A new list containing all elements from `arr`, but sorted in ascending order. # Constraints - The function should handle an empty list, returning an empty list. - The function should handle lists with duplicate elements correctly. # Examples ```python >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] ``` # Additional Requirements - Ensure your implementation is efficient with a time complexity of O(n log n). - Avoid using any built-in sorting functions. - Implement separate helper functions for merging and splitting lists if necessary.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Question: Employee Hierarchy Organizer You are tasked with implementing a function to determine the reporting structure within a company. Given a list of direct supervisor-employee pairs, you need to construct the hierarchy and provide the entire reporting line from any given employee to the CEO. Function Signature ```python def find_reporting_line(pairs: list[tuple[str, str]], employee: str) -> list[str]: Args: pairs (list): A list of tuples where each tuple consists of (supervisor, employee). employee (str): The employee whose reporting line to the CEO is to be determined. Returns: list[str]: A list of employees representing the reporting line from the given employee to the CEO. If the employee or the reporting line is not found, return an empty list. ``` Example ```python example_pairs = [ (\\"CEO\\", \\"VP1\\"), (\\"CEO\\", \\"VP2\\"), (\\"VP1\\", \\"Manager1\\"), (\\"VP2\\", \\"Manager2\\"), (\\"Manager1\\", \\"Employee1\\"), (\\"Manager2\\", \\"Employee2\\"), ] print(find_reporting_line(example_pairs, \\"Employee1\\")) # Output: [\'Employee1\', \'Manager1\', \'VP1\', \'CEO\'] print(find_reporting_line(example_pairs, \\"Employee2\\")) # Output: [\'Employee2\', \'Manager2\', \'VP2\', \'CEO\'] print(find_reporting_line(example_pairs, \\"Manager1\\")) # Output: [\'Manager1\', \'VP1\', \'CEO\'] print(find_reporting_line(example_pairs, \\"Intern\\")) # Output: [] ``` Constraints - Supervisor and employee names are non-empty strings. - Each employee (except the CEO) has exactly one direct supervisor. - The pairs list guarantees the presence of exactly one CEO, who is at the top of the hierarchy. - The given employee string may or may not be present in the pairs list. - You may assume the hierarchy can be represented as a tree without cycles. Notes - Ensure your solution handles cases where the provided employee is not part of the hierarchy. - Optimize your implementation for efficiency, considering edge cases such as a large number of employee-supervisor pairs.","solution":"def find_reporting_line(pairs, employee): # Create a mapping from employee to their supervisor supervisor_map = {} for supervisor, emp in pairs: supervisor_map[emp] = supervisor # Build the reporting line from the employee up to the CEO reporting_line = [] current_employee = employee while current_employee in supervisor_map: reporting_line.append(current_employee) current_employee = supervisor_map[current_employee] # Adding the current employee to the reporting line. # This will be either the CEO or an unrecorded employee (if loop terminates with a missing entry in supervisor_map) reporting_line.append(current_employee) # Validate if we ultimately reached the CEO, if not, return an empty list if \'CEO\' not in reporting_line: return [] return reporting_line"},{"question":"# Linked List Rotation You need to implement a function that rotates a singly linked list to the right by k places. The list should remain unchanged if k is zero or if the list is empty. Your task is to ensure the function handles all edge cases and validates the input appropriately. Requirements: 1. **Input**: A singly linked list `head` and a non-negative integer `k`. 2. **Output**: The head of the rotated linked list. **Function Signature:** ```python def rotateRight(head: Optional[ListNode], k: int) -> Optional[ListNode]: ``` **ListNode Class Definition:** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Constraints: 1. The integer `k` should be non-negative. If `k` is negative, raise `ValueError` with the message `\\"Rotation value must be non-negative\\"`. 2. The function should handle cases where the list is empty (i.e., `head` is `None`). 3. If `k` is greater than the length of the list, rotate the list k % list_length times only. # Example Usage: - Example 1: ```python # List: 1 -> 2 -> 3 -> 4 -> 5 >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = rotateRight(head, 2) >>> while new_head: ... print(new_head.val, end=\\" -> \\") ... new_head = new_head.next 1 -> 2 -> 3 -> 4 -> 5 -> ``` - Example 2: ```python # List: 0 -> 1 -> 2 >>> head = ListNode(0, ListNode(1, ListNode(2))) >>> new_head = rotateRight(head, 4) >>> while new_head: ... print(new_head.val, end=\\" -> \\") ... new_head = new_head.next 2 -> 0 -> 1 -> ``` # Additional Example: - Input: `(rotateRight(None, 0))` - Output: `None` - Input: `(rotateRight(ListNode(1, None), 1))` - Output: `1 -> None` Note: - Ensure the function is optimally handling edge cases, such as when `k` is zero, when the list is empty, or when `k` exceeds the list length. - Optimize for readability and efficiency to maintain performance on larger lists. This new question leverages list manipulation similar to the bit manipulation in the previous question. It mirrors the validation of input and constraints, ensuring the style, complexity, and scope align with the existing set.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: if k < 0: raise ValueError(\\"Rotation value must be non-negative\\") if not head or k == 0: return head # Find the length of the list current = head length = 1 while current.next: current = current.next length += 1 # Connect the last node to the head to form a circular linked list current.next = head # Calculate the new head position k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"# Scenario: You are designing a notification system for an event-tracking application. Users can subscribe to receive notifications for specific events and query the earliest time at which certain events occurred. You decide to use a **Segment Tree** for efficient range querying and updates. # Task: Implement a function to support the following operations: 1. **record_event(event_id: int, timestamp: int)**: Record the time `timestamp` when a specific event, identified by `event_id`, occurs. 2. **earliest_event(start_event_id: int, end_event_id: int)**: Find the earliest recorded time for any event within the range [start_event_id, end_event_id). # Constraints: - `0 <= event_id < M`, where `M` is the number of possible event IDs. - `0 <= timestamp <= 10^9` - `0 <= start_event_id < end_event_id <= M` - Do not use built-in library functions for querying ranges (like `min`). # Function Signature: ```python class EventTracker: def __init__(self, size: int) -> None: ... def record_event(self, event_id: int, timestamp: int) -> None: ... def earliest_event(self, start_event_id: int, end_event_id: int) -> int: ... # Example Usage: # tracker = EventTracker(5) # tracker.record_event(1, 100) # tracker.record_event(3, 50) # print(tracker.earliest_event(0, 3)) # Output: 100 # print(tracker.earliest_event(2, 5)) # Output: 50 ``` # Notes: - Ensure that the solution efficiently supports both event recordings and range queries. - Handle edge cases where updates or queries might involve boundary values. - Maintain the performance goals as stated by the Segment Tree principles.","solution":"class EventTracker: def __init__(self, size: int) -> None: self.n = size self.INF = 10**9 + 1 # a value larger than any possible timestamp self.tree = [self.INF] * (2 * self.n) def record_event(self, event_id: int, timestamp: int) -> None: # insert the new timestamp at the appropriate leaf position pos = event_id + self.n self.tree[pos] = timestamp # update the segment tree upwards while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def earliest_event(self, start_event_id: int, end_event_id: int) -> int: # make range left-inclusive and right-exclusive l = start_event_id + self.n r = end_event_id + self.n mi = self.INF while l < r: if l % 2: mi = min(mi, self.tree[l]) l += 1 if r % 2: r -= 1 mi = min(mi, self.tree[r]) l //= 2 r //= 2 return mi # Example Usage: # tracker = EventTracker(5) # tracker.record_event(1, 100) # tracker.record_event(3, 50) # print(tracker.earliest_event(0, 3)) # Output: 100 # print(tracker.earliest_event(2, 5)) # Output: 50"},{"question":"# Coding Question: Implement a Function to Reverse a Linked List **Objective**: Implement a function to reverse a given `LinkedList` that holds integers. # Problem Statement: You are provided with a `LinkedList` class that supports appending new integers and iterating over existing elements. Your task is to implement the method `reverse()` to reverse the linked list in-place. # Function Signature: ```python def reverse(self) -> None: # Your code goes here ``` # Constraints: - **Input**: The linked list class as provided, containing any ordering or duplicate integers. - **Output**: The linked list should be reversed in-place. - **Performance Requirement**: Aim for O(n) time complexity with O(1) space complexity, where n is the number of elements in the linked list. - **Edge Cases**: - An empty linked list should remain unchanged. - A linked list with one element should remain unchanged. # Example: ```python # Example Usage linked_list = LinkedList() linked_list.extend([1, 2, 3, 4, 5]) linked_list.reverse() print(linked_list) # Expected Output: 5 -> 4 -> 3 -> 2 -> 1 ``` # Scenario: You are developing a feature for a data processing tool that requires reversing the order of elements stored in a linked list. This functionality will help in various scenarios, such as undoing actions, backtracking algorithms, and more. Implementing an efficient in-place reverse method will enhance the tool\'s performance by minimizing additional memory usage. # Additional Notes: You are only allowed to modify the `LinkedList` class to add the `reverse` method. Ensure that your solution iteratively or recursively updates the pointers of the linked list nodes to achieve the reversal, maintaining optimal space complexity.","solution":"class LinkedList: class Node: def __init__(self, value: int = 0, next: \'LinkedList.Node\' = None): self.value = value self.next = next def __init__(self): self.head = None def append(self, value: int) -> None: if not self.head: self.head = self.Node(value) else: current = self.head while current.next: current = current.next current.next = self.Node(value) def extend(self, values) -> None: for value in values: self.append(value) def reverse(self) -> None: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def __iter__(self): current = self.head while current: yield current.value current = current.next def __str__(self): values = list(self) return \\" -> \\".join(map(str, values))"},{"question":"# Coding Assessment Question Question: You are required to write a function that will calculate the hamming distance between two strings of equal length. The hamming distance is the number of positions at which the corresponding characters are different. Function Details: * **Function Name**: `calculate_hamming_distance` * **Input**: Two arguments `str1` and `str2` which are strings of equal length. * **Output**: An integer representing the hamming distance between the two strings. * **Constraints**: * Both input strings will have a length between 1 and 100, inclusive. * The input strings will contain only lowercase and uppercase alphabetic characters. * **Performance Requirement**: The function should run efficiently with a time complexity of O(n), where n is the length of the input strings. Example: ```python >>> print(calculate_hamming_distance(\\"karolin\\", \\"kathrin\\")) 3 >>> print(calculate_hamming_distance(\\"1011101\\", \\"1001001\\")) 2 >>> print(calculate_hamming_distance(\\"abcde\\", \\"abCDE\\")) 3 ``` Ensure that your function handles different character cases (e.g., upper vs. lower case) correctly and counts them as different characters. Document your code appropriately and include error handling in case the input strings are not of equal length.","solution":"def calculate_hamming_distance(str1, str2): Calculate the hamming distance between two strings of equal length. Parameters: str1 (str): First input string. str2 (str): Second input string. Returns: int: The hamming distance between the two input strings. Raises: ValueError: If the input strings are not of equal length. if len(str1) != len(str2): raise ValueError(\\"Input strings must have the same length\\") return sum(1 for x, y in zip(str1, str2) if x != y)"},{"question":"# Question: Longest Decreasing Subsequence Background You are given a list of integers and need to determine the length of the longest subsequence such that the numbers in the subsequence are strictly in decreasing order. A subsequence is derived by deleting some (or none) of the elements in the list without changing the order of the remaining elements. Task Write a function `longest_decreasing_subsequence(arr: List[int]) -> int` that returns the length of the longest decreasing subsequence. Input * A list of integers `arr` with ( 1 leq len(arr) leq 1000 ) and (-10^6 leq arr[i] leq 10^6 ). Output * Returns an integer representing the length of the longest decreasing subsequence. Example ```python def longest_decreasing_subsequence(arr: List[int]) -> int: # Your code here # Example usage: print(longest_decreasing_subsequence([9, 4, 3, 2, 5, 4, 3, 2])) # Expected output: 5 (subsequence: [9, 4, 3, 2, 2]) print(longest_decreasing_subsequence([1, 2, 3, 4, 5])) # Expected output: 1 (subsequence: [1] or any single element) print(longest_decreasing_subsequence([5, 3, 4, 4, 2])) # Expected output: 3 (subsequence: [5, 4, 2]) ``` Constraints 1. The elements in the list are integers with possible duplicate values. Hints 1. Consider dynamic programming techniques to progressively build up the lengths of subsequences. 2. Use a helper array to keep track of the longest decreasing sub-sequences found so far.","solution":"from typing import List def longest_decreasing_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) dp = [1] * n # Each element is a subsequence of length 1 by itself for i in range(1, n): for j in range(i): if arr[j] > arr[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Coding Assessment Question **Lowest Common Ancestor in Binary Search Tree** You are given a binary search tree (BST) and two distinct nodes in the tree. Your task is to find the lowest common ancestor (LCA) of these two nodes. The LCA is defined as the lowest node in the BST that has both nodes as descendants (where we allow a node to be a descendant of itself). # Function Signature ```python def lowest_common_ancestor(root: Node, n1: int, n2: int) -> Node: Find the lowest common ancestor of two nodes in BST. :param root: Node, the root node of the BST. :param n1: int, value of the first node. :param n2: int, value of the second node. :return: Node, the lowest common ancestor node. class Node: def __init__(self, data: int, left: \'Node\' = None, right: \'Node\' = None): self.data = data self.left = left self.right = right ``` # Input and Output - **Input**: - The `root` of the binary search tree, a `Node`. - Two integers `n1` and `n2`, representing the values of two nodes in the BST. - **Output**: A `Node` representing the lowest common ancestor of the two nodes. # Example ```python # Example 1 root = Node(20) root.left = Node(10, Node(5), Node(15)) root.right = Node(30, Node(25), Node(35)) assert lowest_common_ancestor(root, 5, 15).data == 10 # Example 2 root = Node(40) root.left = Node(20, Node(10), Node(30)) root.right = Node(60, Node(50), Node(70)) assert lowest_common_ancestor(root, 10, 70).data == 40 ``` # Constraints - The value at each node can be any valid integer. - It is guaranteed that both nodes exist in the BST. - The maximum number of nodes in the tree is 10â´. - The values of the nodes will all be unique. # Guidelines - Use the properties of the BST, where the left child is always smaller than the parent and the right child is always larger than the parent. - Think iteratively or recursively to traverse the tree and find the LCA. - Carefully handle edge cases including: - When either `n1` or `n2` is the root. - Trees where the LCA is the root or one of the nodes itself. # Performance Requirements - Your solution should be optimized to run in O(h), where h is the height of the tree.","solution":"class Node: def __init__(self, data: int, left: \'Node\' = None, right: \'Node\' = None): self.data = data self.left = left self.right = right def lowest_common_ancestor(root: Node, n1: int, n2: int) -> Node: Find the lowest common ancestor of two nodes in BST. :param root: Node. The root node of the BST. :param n1: int. Value of the first node. :param n2: int. Value of the second node. :return: Node. The lowest common ancestor node. while root: if root.data > n1 and root.data > n2: root = root.left elif root.data < n1 and root.data < n2: root = root.right else: return root"},{"question":"# Question You are a software engineer tasked with creating an analytical tool for text analysis. Your objective is to implement a function that computes the frequency of each word in a given string and returns the most frequently occurring word(s). # Requirements 1. **Function Name**: `most_frequent_word` 2. **Inputs**: - A string `text`, which may include letters, digits, and punctuation. 3. **Output**: - A list of strings containing the word(s) that appear most frequently. If there are multiple words with the same highest frequency, return them in alphabetical order. # Constraints - You can assume that `text` contains no special characters like `n`, `t`, etc. - Consider a word as a sequence of letters and apostrophes. Case sensitivity (e.g., \\"Word\\" vs \\"word\\") should be ignored. - You are not allowed to use any external libraries except for Python\'s standard libraries. # Example ```python text = \\"Hello, world! Hello universe. This is a test, a simple test.\\" result = most_frequent_word(text) print(result) # [\'a\', \'hello\', \'test\'] ``` # Notes - Ensure your implementation can handle edge cases such as empty strings or strings without any alphabetic characters. - Make sure your function efficiently handles large inputs. # Approach - First, preprocess the string to remove punctuation and handle case insensitivity. - Split the string into words. - Use a dictionary to count the frequency of each word. - Determine the highest frequency and create a list of words with that frequency. - Sort the list alphabetically before returning it.","solution":"import re from collections import defaultdict def most_frequent_word(text): Compute the frequency of each word in a given string and return the most frequently occurring word(s). Args: text (str): Input string containing letters, digits, and punctuation. Returns: list: List of strings containing the most frequent word(s) in alphabetical order. # Remove punctuation and convert to lowercase text = text.lower() words = re.findall(r\'b[w\']+b\', text) # Count the frequency of each word word_count = defaultdict(int) for word in words: word_count[word] += 1 # Determine the highest frequency if not word_count: return [] max_freq = max(word_count.values()) # Get all words with the highest frequency most_frequent_words = [word for word, count in word_count.items() if count == max_freq] # Sort the words alphabetically most_frequent_words.sort() return most_frequent_words"},{"question":"# Problem Statement You are tasked with implementing a range summary function that takes a sorted list of integers and merges consecutive sequences into ranges. This function should return the list of ranges in a compact format. # Objectives 1. Implement the `ranges_summary` function that summarizes the list of integers into ranges. 2. Define a range as a sequence of consecutive numbers represented by a start and end number. # Function Signature ```python def ranges_summary(nums: list[int]) -> list[str]: ``` # Example ```python # Example 1: nums = [0, 1, 2, 4, 5, 7] result = ranges_summary(nums) print(result) # Output: [\'0->2\', \'4->5\', \'7\'] # Example 2: nums = [0, 2, 3, 4, 6, 8, 9] result = ranges_summary(nums) print(result) # Output: [\'0\', \'2->4\', \'6\', \'8->9\'] # Example 3: nums = [1, 3, 5, 7, 9] result = ranges_summary(nums) print(result) # Output: [\'1\', \'3\', \'5\', \'7\', \'9\'] ``` # Constraints - The input list will contain unique integers in ascending order. - Length of the input list will not exceed 10^4. - Each integer in the input list will be in the range [-10^7, 10^7]. # Hints 1. Iterate through the list and identify the start and end of each consecutive sequence. 2. Construct the string representation of each range and append it to the result list. 3. Handle cases where numbers are not part of any range by including them as single values. # Performance Requirements - Your solution should efficiently summarize the ranges up to the maximum constraints within acceptable time limits.","solution":"def ranges_summary(nums: list[int]) -> list[str]: result = [] if not nums: return result start = nums[0] end = nums[0] for i in range(1, len(nums)): if nums[i] == end + 1: end = nums[i] else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}->{end}\\") start = nums[i] end = nums[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}->{end}\\") return result"},{"question":"# Coding Assessment Question Objective: Implement a function `longest_consecutive_subsequence(nums: List[int]) -> int` that returns the length of the longest sequence of consecutive integers in a list. Function Specification: * **Input**: - `nums`: A list of integers. * **Output**: - An integer representing the length of the longest subsequence of consecutive integers. * **Constraints**: - The elements in `nums` will cover both positive and negative integers. - The length of the list `nums` can be up to `10^5`. * **Performance Requirements**: - The solution should aim for a time complexity of `O(n)`. Example: ```python >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 # Because the longest consecutive sequence is [1, 2, 3, 4] >>> longest_consecutive_subsequence([0, 0, 1, -1, -2, 2, 3, -3]) 7 # Because the longest consecutive sequence is [-3, -2, -1, 0, 1, 2, 3] ``` Scenario: You are developing a feature for a social media platform that groups user activities into streaks based on consecutive days of activity. This function will help in identifying the longest streak of consecutive days a user has been active. Your implementation should be able to efficiently process a large number of activity records to find the maximum consecutive streak.","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence of consecutive integers in the list nums. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # starting point of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem: Task Scheduler with Constraints **Context**: You are tasked with developing a task scheduling system that efficiently handles task insertions, execution, and allows queries for the next executable task while keeping the tasks organized based on their priorities and constraints. The system should manage the following operations: 1. **Insert**: Add a new task with a unique task ID and a priority level. 2. **Execute**: Execute the highest priority task. If multiple tasks have the same priority, execute the one inserted first. 3. **Next**: Return the task ID of the highest priority task without executing it. If multiple tasks have the same priority, return the one inserted first. # Task: Implement the class `TaskScheduler` with the following methods: 1. **__init__()**: Initialize the task scheduler. 2. **insert(task_id: int, priority: int) -> None**: - Add the task with the given `task_id` and `priority` to the scheduler. 3. **execute() -> int**: - Execute the highest priority task and return its task ID. 4. **next_task() -> int**: - Return the task ID of the highest priority task without executing it. If no tasks are available, return -1. # Constraints: - The task ID and priority are integers. - Task Scheduler must efficiently handle up to 10^6 operations. - Methods `insert`, `execute`, and `next_task` should be optimized for performance. # Example: ```python scheduler = TaskScheduler() scheduler.insert(1, 5) scheduler.insert(2, 10) assert scheduler.next_task() == 2 scheduler.insert(3, 10) assert scheduler.next_task() == 2 assert scheduler.execute() == 2 assert scheduler.next_task() == 3 scheduler.insert(4, 1) assert scheduler.next_task() == 3 ``` *Implement `TaskScheduler` below:* ```python from collections import deque import heapq class TaskScheduler: def __init__(self): self.task_map = {} self.priority_queue = [] self.counter = 0 def insert(self, task_id, priority): if task_id in self.task_map: return task = (priority, self.counter, task_id) self.task_map[task_id] = task heapq.heappush(self.priority_queue, (-priority, self.counter, task_id)) self.counter += 1 def execute(self): while self.priority_queue: priority, count, task_id = heapq.heappop(self.priority_queue) if task_id in self.task_map: del self.task_map[task_id] return task_id return -1 def next_task(self): while self.priority_queue: priority, count, task_id = self.priority_queue[0] if task_id in self.task_map: return task_id heapq.heappop(self.priority_queue) return -1 # Example usage, such implementations must be tested thoroughly. scheduler = TaskScheduler() scheduler.insert(1, 5) scheduler.insert(2, 10) print(scheduler.next_task()) # Output: 2 scheduler.insert(3, 10) print(scheduler.next_task()) # Output: 2 print(scheduler.execute()) # Output: 2 print(scheduler.next_task()) # Output: 3 scheduler.insert(4, 1) print(scheduler.next_task()) # Output: 3 ``` This question requires implementation of a task scheduler that handles task insertions, executions, and queries efficiently, maintaining proper order based on priorities, similar to common functions expected in priority queues or min-heaps.","solution":"from collections import defaultdict import heapq class TaskScheduler: def __init__(self): self.task_heap = [] self.task_map = {} self.count = 0 def insert(self, task_id, priority): if task_id not in self.task_map: entry = (-priority, self.count, task_id) self.task_map[task_id] = entry heapq.heappush(self.task_heap, entry) self.count += 1 def execute(self): while self.task_heap: priority, count, task_id = heapq.heappop(self.task_heap) if task_id in self.task_map: del self.task_map[task_id] return task_id return -1 def next_task(self): while self.task_heap: priority, count, task_id = self.task_heap[0] if task_id in self.task_map: return task_id heapq.heappop(self.task_heap) return -1"},{"question":"# Coding Assessment Question You are given a list of strings where each string represents a sequence of words. The task involves counting the frequency of each unique word across all strings and identifying the top k most frequent words. # Task Write a Python function that accomplishes the following: 1. Reads in a list of strings, where each string contains space-separated words. 2. Counts the frequency of each word across all strings, ignoring case (i.e., \\"Hello\\" and \\"hello\\" should be considered the same word). 3. Returns a list of the k most frequent words in decreasing order of frequency. If multiple words have the same frequency, they should be sorted alphabetically. # Requirements 1. **Input**: A list of strings and an integer k. 2. **Output**: A list of the top k most frequent words. 3. **Constraints**: * The list input can have up to 1,000,000 strings. * Each string can be up to 1,000,000 characters long. * The input list can be empty or k can be zero. In such cases, the function should return an empty list. # Performance: * The function should be optimized for large inputs concerning both time and space complexity. Examples: ```python # Example 1: input_list = [\\"hello world\\", \\"Hello there\\", \\"world of coding\\"] k = 2 top_k_frequent_words(input_list, k) # Output: [\\"hello\\", \\"world\\"] # Example 2: input_list = [\\"apple banana apple\\", \\"banana banana orange\\"] k = 2 top_k_frequent_words(input_list, k) # Output: [\\"banana\\", \\"apple\\"] # Example 3: input_list = [] k = 3 top_k_frequent_words(input_list, k) # Output: [] # Example 4: input_list = [\\"Lorem ipsum Lorem\\", \\"ipsum dolor sit amet\\"] k = 3 top_k_frequent_words(input_list, k) # Output: [\\"ipsum\\", \\"lorem\\", \\"amet\\"] ``` # Solution ```python from collections import Counter import heapq def top_k_frequent_words(strings, k): if not strings or k == 0: return [] # Join all strings and split into words, converting to lowercase words = \\" \\".join(strings).lower().split() # Count the frequency of each word word_count = Counter(words) # Use a heap to get the top k frequent words heap = [(-freq, word) for word, freq in word_count.items()] heapq.heapify(heap) # Extract the top k words top_k = [heapq.heappop(heap)[1] for _ in range(min(k, len(heap)))] return top_k ``` The above function processes the input list of strings to count the frequency of words and returns the top k most frequent words while handling large inputs efficiently.","solution":"from collections import Counter import heapq def top_k_frequent_words(strings, k): if not strings or k == 0: return [] # Join all strings and split into words, converting to lowercase words = \\" \\".join(strings).lower().split() # Count the frequency of each word word_count = Counter(words) # Use a heap to get the top k frequent words heap = [(-freq, word) for word, freq in word_count.items()] heapq.heapify(heap) # Extract the top k words top_k = [heapq.heappop(heap)[1] for _ in range(min(k, len(heap)))] return top_k"},{"question":"# Problem Statement A company wants to parse and summarize large JSON objects received from an API and store them efficiently in a relational database. Your task is to implement a function that can extract specific fields from the JSON object, perform simple transformations on them, and return a summary dictionary ready for storage. # Function Signature ```python def summarize_json(json_object: dict) -> dict: `json_object`: A dictionary representing the parsed JSON object. Returns a dictionary with the extracted and transformed information. Constraints: * The input JSON object can have a nested structure. * The input JSON object can be up to 10 MB in size. * Extracted fields should include at least \'id\', \'name\', \'created_at\' (in ISO format), and \'details\' (with nested fields flattened) if present. Example: >>> summarize_json({ \'id\': 123, \'info\': { \'name\': \'Sample Item\', \'created_at\': \'2023-02-15T13:24:00Z\', \'details\': { \'category\': \'electronic\', \'price\': 299.99 } } }) { \'id\': 123, \'name\': \'Sample Item\', \'created_at\': \'2023-02-15T13:24:00Z\', \'category\': \'electronic\', \'price\': 299.99 } >>> summarize_json({ \'id\': 456, \'info\': { \'name\': \'Another Item\', \'created_at\': \'2023-06-10T09:12:00Z\' } }) { \'id\': 456, \'name\': \'Another Item\', \'created_at\': \'2023-06-10T09:12:00Z\' } pass ``` # Guidelines 1. **Field Extraction**: Extract the fields `id`, `name`, `created_at`, and any details present in the nested `info` dictionary. 2. **Field Transformation**: Ensure `created_at` is in ISO format (retain as is if it is already in ISO format). 3. **Flattening**: Flatten the `details` sub-dictionary into individual fields at the top level. 4. **Handling Missing Fields**: If an optional field is missing, it should simply be omitted from the output dictionary. 5. **Maintain Order**: The summary dictionary should maintain the order of \'id\', \'name\', \'created_at\', followed by any additional fields. # Input and Output Format ```text summarize_json({ \'id\': 123, \'info\': { \'name\': \'Sample Item\', \'created_at\': \'2023-02-15T13:24:00Z\', \'details\': { \'category\': \'electronic\', \'price\': 299.99 } } }) => { \'id\': 123, \'name\': \'Sample Item\', \'created_at\': \'2023-02-15T13:24:00Z\', \'category\': \'electronic\', \'price\': 299.99 } summarize_json({ \'id\': 456, \'info\': { \'name\': \'Another Item\', \'created_at\': \'2023-06-10T09:12:00Z\' } }) => { \'id\': 456, \'name\': \'Another Item\', \'created_at\': \'2023-06-10T09:12:00Z\' } ``` # Constraints * The input JSON object can be up to 10 MB in size. * Fields to extract and transform will be nested within an \'info\' dictionary. # Notes - This problem expects careful handling of JSON structures and transformations. - Ensure performance efficiency especially for large JSON objects.","solution":"def summarize_json(json_object: dict) -> dict: Extract specific fields from the JSON object, perform simple transformations on them, and return a summary dictionary ready for storage. `json_object`: A dictionary representing the parsed JSON object. Returns a dictionary with the extracted and transformed information. summary = {} # Extract \'id\' field if \'id\' in json_object: summary[\'id\'] = json_object[\'id\'] # Check for \'info\' dictionary if \'info\' in json_object: info = json_object[\'info\'] # Extract \'name\' field if \'name\' in info: summary[\'name\'] = info[\'name\'] # Extract \'created_at\' field if \'created_at\' in info: summary[\'created_at\'] = info[\'created_at\'] # Extract and flatten \'details\' dictionary if present if \'details\' in info: details = info[\'details\'] for key, value in details.items(): summary[key] = value return summary"},{"question":"# Problem Statement You are tasked with developing a function for an educational app aimed at teaching children basic arithmetic operations through an engaging quiz. The function should generate a series of unique arithmetic problems for addition, subtraction, and multiplication based on the given parameters. The function should take the total number of problems `m` and generate an equal number of problems for each operation type (if possible). If `m` is not perfectly divisible by 3, the remaining problems should be evenly distributed across the operation types, starting with addition, then subtraction, and finally multiplication. # Function Signature ```python def generate_arithmetic_problems(m: int) -> List[str]: pass ``` # Input * An integer `m` such that `1 <= m <= 10^6` â€” the total number of arithmetic problems to generate. # Output * A list of `m` strings, where each string is a unique arithmetic problem formatted as `{operand1} {operator} {operand2} = ?`. # Constraints * If `m` is less than 1, return an empty list. * The generated problems should be unique and utilize random operand values within the range 1 to 100 inclusive. * Ensure that subtraction problems do not result in negative numbers. # Examples ```python >>> generate_arithmetic_problems(5) [\'23 + 45 = ?\', \'67 - 34 = ?\', \'12 * 8 = ?\', \'89 + 11 = ?\', \'56 - 29 = ?\'] >>> generate_arithmetic_problems(0) [] >>> generate_arithmetic_problems(3) [\'50 + 32 = ?\', \'37 - 19 = ?\', \'14 * 3 = ?\'] ``` # Notes 1. Use randomization to generate unique operand values for each problem. 2. Distribute the problems equally among the three operation types, and handle the remainder by assigning it starting from addition. 3. The function should be efficient and able to handle the upper input limit within a reasonable time frame.","solution":"import random from typing import List def generate_arithmetic_problems(m: int) -> List[str]: if m < 1: return [] problems = [] operations = [\'+\', \'-\', \'*\'] base_count = m // 3 remainder = m % 3 counts = [base_count, base_count, base_count] for i in range(remainder): counts[i] += 1 for count, operation in zip(counts, operations): for _ in range(count): operand1, operand2 = random.randint(1, 100), random.randint(1, 100) if operation == \'-\': if operand1 < operand2: operand1, operand2 = operand2, operand1 problems.append(f\\"{operand1} {operation} {operand2} = ?\\") return problems"},{"question":"# Coding Assessment Question: Circular Linked List Clone You have been working with various data structures and linked lists are among them. Now, it\'s time to apply your knowledge to solve an advanced problem involving circular linked lists. Scenario A circular linked list is a variation of a linked list in which the last node points to the first node, making a circle. Your task is to create a deep copy (or clone) of such a list. Each node in the circular linked list contains an integer value and a reference to the next node. Task Implement a function `clone_circular_list(head: Node) -> Node`. This function should take the head node of a circular linked list and return the head node of a new list that is a deep copy of the original list. Specifications 1. **Class Definitions**: Define a `Node` class that represents a node in the circular linked list. ```python class Node: def __init__(self, value: int, next: \'Node\' = None): self.value = value self.next = next def __repr__(self): return f\\"Node({self.value})\\" ``` 2. **Function Signature**: ```python def clone_circular_list(head: Node) -> Node: ``` 3. **Constraints and Limitations**: * The input list may contain from 0 to 1000 nodes. * Each node contains a non-negative integer value. * The function should handle empty lists (where `head` is `None`) correctly. * The new list should not share any nodes with the original list, meaning it must be a deep copy. 4. **Edge Cases**: * Handle the case where the list is empty (`head` is `None`). * Verify proper functionality for a list containing only one node. * Ensure the function correctly clones lists with multiple nodes linked in a circular fashion. 5. **Performance Requirements**: * Ensure the implementation runs efficiently within O(n) time complexity where n is the number of nodes in the list. Examples ```python # Example cases # Define a helper function to create a circular linked list for testing def create_circular_linked_list(values): if not values: return None head = Node(values[0]) current = head for val in values[1:]: current.next = Node(val) current = current.next current.next = head return head # Create a circular linked list [1 -> 2 -> 3 -> 1] original_head = create_circular_linked_list([1, 2, 3]) # Clone the circular linked list cloned_head = clone_circular_list(original_head) # Ensure the cloned head is not the same object as the original assert cloned_head is not original_head # Ensure all node values match current_original = original_head current_cloned = cloned_head for _ in range(3): # Repeat for the length of the list assert current_original.value == current_cloned.value current_original = current_original.next current_cloned = current_cloned.next # Ensure circularity assert current_cloned is cloned_head assert current_original is original_head ``` Implement the `clone_circular_list` function ensuring compliance with the aforementioned requirements.","solution":"class Node: def __init__(self, value: int, next: \'Node\' = None): self.value = value self.next = next def __repr__(self): return f\\"Node({self.value})\\" def clone_circular_list(head: Node) -> Node: if not head: return None # Create a mapping from the original nodes to their clones mapping = {} # Initialize the original current node current = head # Create the head of the cloned list cloned_head = Node(current.value) mapping[current] = cloned_head # Initialize the current pointer for the new list current_cloned = cloned_head while True: # Move the pointer forward in the original list current = current.next if current in mapping: # If we have seen this node before, link to the cloned node current_cloned.next = mapping[current] break else: # Otherwise, create a new clone, map, and link it new_node = Node(current.value) mapping[current] = new_node current_cloned.next = new_node current_cloned = new_node return cloned_head"},{"question":"# Coding Question Context Imagine you are developing a game where players collect coins scattered across a 2D grid. Some coins have special properties that allow them to multiply the total coin count when collected. Your task is to calculate the total number of coins a player can collect, taking into consideration the special properties of the coins. Problem Statement Write a function called `collect_coins` that takes a 2D grid of integers, where each integer represents the number of coins at that location, and a list of tuples representing the positions of the special coins that multiply the total number of coins when collected. Input Format * `grid` (a list of lists of integers): A 2D grid representing the coin layout. Each integer value is between 0 and 20. * `multipliers` (a list of tuples): A list of tuples where each tuple contains two integers representing the row and column indices of a special coin in the grid. Output Format * An integer representing the total number of coins collected after considering all multipliers. Example * Example 1: ```python grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] multipliers = [(0, 1), (1, 2)] collect_coins(grid, multipliers) # Should return 378 ``` Explanation: The total without multipliers is 45. The coin at (0, 1) multiplies the total by 2, resulting in 90. The coin at (1, 2) multiplies the new total by 6, resulting in 540. However, the total would be (after considering already applied multipliers) 45*2=90 and then 90*3=270 and then 270*6=1620. Constraints and Performance Requirements - The grid will be of size M x N, where 1 <= M, N <= 100. - The positions in the multipliers list are guaranteed to be valid within the grid dimensions. - Ensure efficiency such that the function handles the upper limits smoothly. Hints: 1. Use nested loops to traverse the grid and calculate the initial coin count. 2. Apply multipliers one by one in the order given. 3. Carefully keep track of the total coin count as you apply each multiplier.","solution":"def collect_coins(grid, multipliers): Calculate the total number of coins collected after considering all multipliers. :param grid: A 2D list of integers where each integer represents the number of coins at that location. :param multipliers: A list of tuples representing the positions of the special coins. :return: Total number of coins collected. total_coins = 0 # Calculate the initial total number of coins for row in grid: total_coins += sum(row) # Apply the multipliers for r, c in multipliers: if 0 <= r < len(grid) and 0 <= c < len(grid[0]): total_coins *= grid[r][c] return total_coins"},{"question":"# Color Fill Implementation You are tasked to implement a function that performs a \\"color fill\\" on a 2D grid of integers representing colors using Python. The color fill algorithm changes the color of a specified pixel and all adjacent pixels of the same color to a new color. # Function to Implement ```python def color_fill(grid: List[List[int]], row: int, col: int, new_color: int) -> None: # Fill surrounding area with new color ``` # Description - Given a 2D grid where each element is an integer representing a pixel\'s color. - Starting from a given pixel, replace the color of this pixel and all adjacent pixels that have the same color with a new color. - Adjacency (4-directionally) includes the pixels left, right, top, and bottom of a given pixel. # Input * A 2D list of integers representing the grid of colors. * Two integers, `row` and `col`, representing the starting pixel. * An integer representing the `new_color` to fill with. # Output * The function modifies the grid in place and does not return anything. # Constraints * Assume the grid will be at least a 1x1 matrix. * Assume all inputs are valid. * The starting pixel will always be within the bounds of the grid. # Example ```python grid = [ [1, 1, 1], [1, 2, 2], [1, 1, 1] ] color_fill(grid, 1, 1, 3) # After calling color_fill, the grid should look like: # [ # [1, 1, 1], # [1, 3, 3], # [1, 1, 1] # ] ``` # Implementation Implement the `color_fill` function with the following steps: 1. **`color_fill`**: Function to perform the color fill operation using a Breadth-First Search (BFS) or Depth-First Search (DFS) algorithm to traverse and fill the grid. # Example Usage: ```python grid = [ [0, 0, 0], [0, 1, 1] ] color_fill(grid, 1, 1, 2) # Expected output grid: # [ # [0, 0, 0], # [0, 2, 2] # ] ```","solution":"from typing import List def color_fill(grid: List[List[int]], row: int, col: int, new_color: int) -> None: old_color = grid[row][col] if old_color == new_color: return def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != old_color: return grid[x][y] = new_color dfs(x + 1, y) # down dfs(x - 1, y) # up dfs(x, y + 1) # right dfs(x, y - 1) # left dfs(row, col)"},{"question":"# Stock Price Anomaly Detection with Rolling Statistics You are asked to build a system that detects anomalies in a stock\'s closing prices using rolling statistics. The system should be able to read the data, compute rolling mean and standard deviation, identify anomalies where the price deviates from the rolling mean by more than a specified number of standard deviations, and visualize the results. Function Specifications 1. **load_data(file_path: str) -> pd.DataFrame**: - **Input**: A string representing the file path to a CSV file containing stock prices with columns \'Date\' and \'Close\'. - **Output**: A DataFrame containing the loaded data with \'Date\' as the index. 2. **compute_rolling_stats(data: pd.DataFrame, window: int) -> pd.DataFrame**: - **Input**: - `data`: A DataFrame containing the stock prices with \'Date\' as index and \'Close\' prices. - `window`: An integer representing the window size for computing rolling statistics. - **Output**: A DataFrame with the original \'Close\' prices, the rolling mean, and rolling standard deviation. 3. **detect_anomalies(rolling_data: pd.DataFrame, threshold: float) -> pd.DataFrame**: - **Input**: - `rolling_data`: A DataFrame containing the original \'Close\' prices, rolling mean, and rolling standard deviation. - `threshold`: A float representing the number of standard deviations away from the mean to consider a price as an anomaly. - **Output**: A DataFrame with an additional column \'Anomaly\' where True indicates an anomaly and False otherwise. 4. **plot_anomalies(data: pd.DataFrame, rolling_data: pd.DataFrame, anomalies: pd.DataFrame) -> None**: - **Input**: - `data`: A DataFrame containing the original stock prices. - `rolling_data`: A DataFrame containing the rolling mean and standard deviation. - `anomalies`: A DataFrame containing detected anomalies. - **Output**: None. (This function should save the plot as an image file and/or display it.) Additional Requirements - The `load_data` function should ensure the data is properly formatted and handle any missing values. - Utilize Pandas for data manipulation and Matplotlib or Seaborn for visualization. - Make sure the visualization clearly indicates normal prices, rolling statistics, and anomalies. # Example ```python # Expected usage example: # Load stock price data data = load_data(\'stock_prices.csv\') # Compute rolling statistics rolling_window = 20 rolling_data = compute_rolling_stats(data, rolling_window) # Detect anomalies with threshold of 2 standard deviations threshold = 2 anomalies = detect_anomalies(rolling_data, threshold) # Plot anomalies plot_anomalies(data, rolling_data, anomalies) ``` # Constraints - The CSV file is structured with \'Date\' in YYYY-MM-DD format and \'Close\' as numerical values. - Your solution should handle large datasets efficiently. - Write clean, readable, and well-documented code. # Note You can use the following CSV structure for testing: ``` Date,Close 2023-01-01,150 2023-01-02,152 2023-01-03,148 ... ```","solution":"import pandas as pd import matplotlib.pyplot as plt def load_data(file_path: str) -> pd.DataFrame: Load stock price data from a CSV file. Parameters: - file_path (str): The path to the CSV file containing stock prices with columns \'Date\' and \'Close\'. Returns: - pd.DataFrame: DataFrame containing the stock prices with \'Date\' as the index. data = pd.read_csv(file_path, parse_dates=[\'Date\'], index_col=\'Date\') data.dropna(inplace=True) return data def compute_rolling_stats(data: pd.DataFrame, window: int) -> pd.DataFrame: Compute rolling mean and standard deviation for stock prices. Parameters: - data (pd.DataFrame): DataFrame containing the stock prices with \'Date\' as the index and \'Close\' prices. - window (int): Window size for computing rolling statistics. Returns: - pd.DataFrame: DataFrame with columns \'Close\', \'RollingMean\', and \'RollingStd\'. data[\'RollingMean\'] = data[\'Close\'].rolling(window=window).mean() data[\'RollingStd\'] = data[\'Close\'].rolling(window=window).std() return data def detect_anomalies(rolling_data: pd.DataFrame, threshold: float) -> pd.DataFrame: Identify anomalies in stock prices where the price deviates from the rolling mean by more than a specified number of standard deviations. Parameters: - rolling_data (pd.DataFrame): DataFrame with the original \'Close\' prices, rolling mean, and rolling standard deviation. - threshold (float): Number of standard deviations away from the mean to consider a price as an anomaly. Returns: - pd.DataFrame: DataFrame with an additional column \'Anomaly\' indicating anomalies (True or False). rolling_data[\'Anomaly\'] = abs(rolling_data[\'Close\'] - rolling_data[\'RollingMean\']) > threshold * rolling_data[\'RollingStd\'] return rolling_data def plot_anomalies(data: pd.DataFrame, rolling_data: pd.DataFrame, anomalies: pd.DataFrame) -> None: Plot the stock prices with rolling statistics and highlight anomalies. Parameters: - data (pd.DataFrame): DataFrame containing the original stock prices. - rolling_data (pd.DataFrame): DataFrame containing the rolling mean and standard deviation. - anomalies (pd.DataFrame): DataFrame containing detected anomalies. Returns: - None. (Displays the plot) plt.figure(figsize=(14, 7)) # Plot original closing prices plt.plot(data.index, data[\'Close\'], label=\'Closing Prices\', color=\'blue\') # Plot rolling mean plt.plot(rolling_data.index, rolling_data[\'RollingMean\'], label=\'Rolling Mean\', color=\'orange\') # Plot rolling mean +- rolling std deviation plt.fill_between(rolling_data.index, rolling_data[\'RollingMean\'] - rolling_data[\'RollingStd\'], rolling_data[\'RollingMean\'] + rolling_data[\'RollingStd\'], color=\'grey\', alpha=0.2, label=\'Rolling Std Dev\') # Highlight anomalies plt.scatter(anomalies.index[anomalies[\'Anomaly\']], anomalies[\'Close\'][anomalies[\'Anomaly\']], color=\'red\', label=\'Anomalies\', zorder=5) plt.title(\'Stock Price Anomaly Detection\') plt.xlabel(\'Date\') plt.ylabel(\'Price\') plt.legend(loc=\'best\') plt.show()"},{"question":"# Reverse Words but Keep Delimiters Context You are provided with a string that contains words and delimiters (e.g., spaces, punctuation marks). The assignment is to reverse the order of the words but keep the delimiters in their original positions. For example, input of \\"Hello, world! Shall we dance?\\" should yield \\"dance, we! Shall world Hello?\\". Task Description 1. **Reverse Words Function**: Write a function `reverse_words_keep_delimiters` that takes a string as input and returns a new string with the words in reversed order, retaining all original delimiters in their exact positions. Function Signature: ```python def reverse_words_keep_delimiters(input_string: str) -> str: Reverses the words in the input string but keeps the delimiters in their original positions. :param input_string: string containing words and delimiters :return: string with words in reversed order and delimiters unchanged Examples: >>> reverse_words_keep_delimiters(\\"Hello, world! Shall we dance?\\") \\"dance, we! Shall world Hello?\\" >>> reverse_words_keep_delimiters(\\"Coding is fun.\\") \\"fun is Coding.\\" >>> reverse_words_keep_delimiters(\\"A, B, C, D.\\") \\"D, C, B, A.\\" >>> reverse_words_keep_delimiters(\\"---\\") \\"---\\" ``` Constraints: * The input string can contain alphabetical characters, spaces, and punctuation marks. * Consider only spaces and punctuation as delimiters; numbers and special characters should be treated as part of words. * The input string can have a length up to (10^4) characters. * Words are defined as consecutive alphabetical characters (a-z, A-Z). Additional Requirements: * Ensure the function handles edge cases such as an empty string, strings with only delimiters, and strings with continuous delimiters. * Maintain the efficiency and readability of the code.","solution":"import re def reverse_words_keep_delimiters(input_string: str) -> str: Reverses the words in the input string but keeps the delimiters in their original positions. :param input_string: String containing words and delimiters :return: String with words in reversed order and delimiters unchanged # Use regex to split the string into words and delimiters parts = re.split(r\'(W+)\', input_string) # Extract words from the parts words = [part for part in parts if part.isalpha()] # Reverse the list of words reversed_words = words[::-1] # Reconstruct the string with reversed words and original delimiters result = [] word_index = 0 for part in parts: if part.isalpha(): result.append(reversed_words[word_index]) word_index += 1 else: result.append(part) return \'\'.join(result)"},{"question":"# Coding Challenge: Implement a Simple File System (SFS) Context File systems are crucial in managing data on storage devices. A simple file system (SFS) should handle typical file operations such as creating, reading, writing, and deleting files. The file system will also support listing all files and retrieving file metadata. Task Implement the Simple File System (SFS) using the provided `SimpleFileSystem` class template. You will complete the following key methods: 1. **`create_file`** - Creates a new file with given content. 2. **`read_file`** - Reads the content of a specified file. 3. **`write_to_file`** - Writes/overwrites content to a specified file. 4. **`delete_file`** - Deletes a specified file. 5. **`list_files`** - Lists all files in the file system. 6. **`get_file_info`** - Retrieves metadata information of a specified file. Requirements 1. **Function Signatures**: - `create_file(file_name: str, content: str) -> None` - `read_file(file_name: str) -> str` - `write_to_file(file_name: str, content: str) -> None` - `delete_file(file_name: str) -> None` - `list_files() -> list[str]` - `get_file_info(file_name: str) -> dict[str, int]` 2. **Input/Output**: - Input: File operations with respective parameters. - Output: Result of operations (file content, list of files, file metadata). 3. **Performance**: - Ensure efficient handling of file operations. 4. **Constraints**: - File names are unique and non-empty strings. - File content is a non-empty string. - All methods should handle non-existent files gracefully (e.g., raise appropriate exceptions). Example ```python sfs = SimpleFileSystem() sfs.create_file(\\"file1.txt\\", \\"Hello, World!\\") sfs.create_file(\\"file2.txt\\", \\"Python is awesome!\\") print(sfs.read_file(\\"file1.txt\\")) # Output: \\"Hello, World!\\" sfs.write_to_file(\\"file1.txt\\", \\"Updated content\\") print(sfs.read_file(\\"file1.txt\\")) # Output: \\"Updated content\\" sfs.delete_file(\\"file2.txt\\") print(sfs.list_files()) # Output: [\\"file1.txt\\"] print(sfs.get_file_info(\\"file1.txt\\")) # Output: {\\"size\\": 15} ``` ```python class SimpleFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str) -> None: if file_name in self.files: raise ValueError(f\\"File \'{file_name}\' already exists.\\") self.files[file_name] = content def read_file(self, file_name: str) -> str: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") return self.files[file_name] def write_to_file(self, file_name: str, content: str) -> None: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") self.files[file_name] = content def delete_file(self, file_name: str) -> None: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") del self.files[file_name] def list_files(self) -> list[str]: return list(self.files.keys()) def get_file_info(self, file_name: str) -> dict[str, int]: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") return {\\"size\\": len(self.files[file_name])} # Example usage if __name__ == \\"__main__\\": sfs = SimpleFileSystem() sfs.create_file(\\"file1.txt\\", \\"Hello, World!\\") sfs.create_file(\\"file2.txt\\", \\"Python is awesome!\\") print(sfs.read_file(\\"file1.txt\\")) # Output: \\"Hello, World!\\" sfs.write_to_file(\\"file1.txt\\", \\"Updated content\\") print(sfs.read_file(\\"file1.txt\\")) # Output: \\"Updated content\\" sfs.delete_file(\\"file2.txt\\") print(sfs.list_files()) # Output: [\\"file1.txt\\"] print(sfs.get_file_info(\\"file1.txt\\")) # Output: {\\"size\\": 15} ```","solution":"class SimpleFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str) -> None: if file_name in self.files: raise ValueError(f\\"File \'{file_name}\' already exists.\\") self.files[file_name] = content def read_file(self, file_name: str) -> str: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") return self.files[file_name] def write_to_file(self, file_name: str, content: str) -> None: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") self.files[file_name] = content def delete_file(self, file_name: str) -> None: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") del self.files[file_name] def list_files(self) -> list[str]: return list(self.files.keys()) def get_file_info(self, file_name: str) -> dict[str, int]: if file_name not in self.files: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") return {\\"size\\": len(self.files[file_name])}"},{"question":"# Coding Question: Grade Analysis Tool **Context**: You are tasked with developing a grading analysis tool for educators to evaluate student performance across various subjects. The tool needs to compute specific metrics based on students\' grades for assignments, quizzes, and exams. **Task**: Implement two functions: 1. `average_grade(grades: List[float]) -> float` 2. `grade_distribution(grades: List[float]) -> Dict[str, int]` These functions should validate the inputs and perform the required calculations based on the provided descriptions. **Constraints**: - `grades` must be a list of non-negative float numbers, representing student grades. Each grade must be between 0 and 100 inclusive. - If `grades` is an empty list, return `0.0` for `average_grade` and an empty dictionary `{}` for `grade_distribution`. - The grade distribution should categorize the grades into: - \\"A\\" (90-100) - \\"B\\" (80-89) - \\"C\\" (70-79) - \\"D\\" (60-69) - \\"F\\" (0-59) - The output dictionary should have keys \\"A\\", \\"B\\", \\"C\\", \\"D\\", and \\"F\\" with corresponding counts of grades in each category. **Input/Output**: - **Input**: A list of float numbers representing student grades. - **Output**: A float number representing the average grade and a dictionary representing the grade distribution. **Examples**: ```python assert average_grade([85, 92, 78, 64, 88]) == 81.4 assert grade_distribution([85, 92, 78, 64, 88]) == {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 1, \'F\': 0} assert average_grade([100, 99, 90, 80, 70, 60, 50]) == 78.14 assert grade_distribution([100, 99, 90, 80, 70, 60, 50]) == {\'A\': 3, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} ``` Write the functions based on the provided descriptions and constraints while ensuring to handle invalid inputs appropriately.","solution":"from typing import List, Dict def average_grade(grades: List[float]) -> float: if not grades: return 0.0 if any(not isinstance(grade, (int, float)) or grade < 0 or grade > 100 for grade in grades): raise ValueError(\\"Grades list must contain non-negative float numbers between 0 and 100 inclusive.\\") return sum(grades) / len(grades) def grade_distribution(grades: List[float]) -> Dict[str, int]: if not grades: return {} if any(not isinstance(grade, (int, float)) or grade < 0 or grade > 100 for grade in grades): raise ValueError(\\"Grades list must contain non-negative float numbers between 0 and 100 inclusive.\\") distribution = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0} for grade in grades: if 90 <= grade <= 100: distribution[\'A\'] += 1 elif 80 <= grade < 90: distribution[\'B\'] += 1 elif 70 <= grade < 80: distribution[\'C\'] += 1 elif 60 <= grade < 70: distribution[\'D\'] += 1 else: distribution[\'F\'] += 1 return distribution"},{"question":"# Problem Statement As a part of a software development team, you are tasked with developing a component of a larger system that processes data streams. Write a program that: 1. Takes a list of integers as an input. 2. Calculates the moving average of the list considering a specified window size. 3. Ensures that the window size is a positive integer and less than or equal to the length of the list. 4. Returns a list of the moving averages. # Input Format * A list of integers. * A single integer representing the window size. # Output Format * Print a list of floating-point numbers representing the moving averages. # Constraints * The input list must not be empty. * The window size must be a positive integer and less than or equal to the length of the list. # Example Input ``` [1, 2, 3, 4, 5] 3 ``` Output ``` [2.0, 3.0, 4.0] ``` # Function Signature The implementation should include a function: ```python def moving_average(data: List[int], window_size: int) -> List[float]: pass ``` # Requirements 1. Ensure the function handles invalid inputs by raising a `ValueError` with appropriate messages: - If the input list is empty, raise a `ValueError` with the message \\"List must not be empty\\". - If the window size is not positive or greater than the length of the list, raise a `ValueError` with the message \\"Invalid window size\\". 2. Use the provided input format and constraints to ensure correctness. 3. Ensure clear, readable, and optimized code for performance.","solution":"from typing import List def moving_average(data: List[int], window_size: int) -> List[float]: Computes the moving average of the input list with the specified window size. Parameters: data (List[int]): The list of integers to compute the moving average on. window_size (int): The size of the window to compute each average. Returns: List[float]: The list of moving averages. Raises: ValueError: If the input list is empty. If the window size is not positive or greater than the length of the list. if not data: raise ValueError(\\"List must not be empty\\") if window_size <= 0 or window_size > len(data): raise ValueError(\\"Invalid window size\\") averages = [] for i in range(len(data) - window_size + 1): window = data[i:i+window_size] window_average = sum(window) / window_size averages.append(window_average) return averages"},{"question":"# Background In the world of competitive programming, generating Fibonacci numbers is a common exercise. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. # Problem Statement Write a function `fibonacci_sum` that calculates the sum of the first `n` Fibonacci numbers. The function should return this sum as an integer. # Function Signature ```python def fibonacci_sum(n: int) -> int: pass ``` # Input Format - `n`: An integer representing the number of Fibonacci numbers to be summed. # Output Format - Returns the sum of the first `n` Fibonacci numbers as an integer. # Constraints - 1 <= n <= 10^5 # Performance Requirements - The algorithm should run efficiently for large values of `n`. # Example ```python print(fibonacci_sum(5)) # Output: 7 (0 + 1 + 1 + 2 + 3) print(fibonacci_sum(10)) # Output: 88 ``` # Notes - Make sure your solution efficiently handles the upper constraint of `n`. - You may consider using memoization or dynamic programming techniques to optimize the performance.","solution":"def fibonacci_sum(n: int) -> int: Calculates the sum of the first n Fibonacci numbers. if n < 1: return 0 # Initialize the first two Fibonacci numbers fib1, fib2 = 0, 1 if n == 1: return fib1 # Initialize sum of Fibonacci series total = fib1 + fib2 for _ in range(2, n): fib1, fib2 = fib2, fib1 + fib2 total += fib2 return total"},{"question":"# Problem Statement You are tasked with implementing a function to determine the winner in a simplified game of poker. Each player is dealt a single card, and the player with the higher rank wins. The cards are ranked from 2 to 10, followed by Jack (J), Queen (Q), King (K), and Ace (A). In this simplified poker game, we ignore the suits of the cards. # Function Signature ```python def poker_winner(player1_card: str, player2_card: str) -> str: pass ``` # Input - `player1_card`: A string representing the card of Player 1. Valid values are \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'10\', \'J\', \'Q\', \'K\', \'A\'. - `player2_card`: A string representing the card of Player 2. Valid values are \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'10\', \'J\', \'Q\', \'K\', \'A\'. # Output - A string representing the result of the game. If Player 1 wins, return \\"Player 1 wins\\". If Player 2 wins, return \\"Player 2 wins\\". If there is a tie, return \\"Tie\\". # Constraints - Both `player1_card` and `player2_card` will be valid card representations as described. # Examples 1. `poker_winner(\'A\', \'K\')` returns \\"Player 1 wins\\" 2. `poker_winner(\'9\', \'10\')` returns \\"Player 2 wins\\" 3. `poker_winner(\'4\', \'4\')` returns \\"Tie\\" 4. `poker_winner(\'J\', \'Q\')` returns \\"Player 2 wins\\" 5. `poker_winner(\'3\', \'A\')` returns \\"Player 2 wins\\" # Context This problem helps in understanding and applying basic comparison and conditional statements in Python. It assesses your ability to handle string inputs, conditional logic, and return appropriate results based on comparisons. # Detailed Instructions 1. Create a mapping of card values to their respective ranks. 2. Compare the ranks of the cards dealt to each player. 3. Return the appropriate result string based on the comparison. ```python def poker_winner(player1_card: str, player2_card: str) -> str: card_ranks = {\'2\': 2, \'3\': 3, \'4\': 4, \'5\': 5, \'6\': 6, \'7\': 7, \'8\': 8, \'9\': 9, \'10\': 10, \'J\': 11, \'Q\': 12, \'K\': 13, \'A\': 14} rank1 = card_ranks[player1_card] rank2 = card_ranks[player2_card] if rank1 > rank2: return \\"Player 1 wins\\" elif rank1 < rank2: return \\"Player 2 wins\\" else: return \\"Tie\\" ```","solution":"def poker_winner(player1_card: str, player2_card: str) -> str: card_ranks = {\'2\': 2, \'3\': 3, \'4\': 4, \'5\': 5, \'6\': 6, \'7\': 7, \'8\': 8, \'9\': 9, \'10\': 10, \'J\': 11, \'Q\': 12, \'K\': 13, \'A\': 14} rank1 = card_ranks[player1_card] rank2 = card_ranks[player2_card] if rank1 > rank2: return \\"Player 1 wins\\" elif rank1 < rank2: return \\"Player 2 wins\\" else: return \\"Tie\\""},{"question":"# Coding Assessment Question Context You are developing a personal finance application that helps users track their monthly expenses. Users enter expenses as individual records, and your application needs to generate a summary report. Task Implement a function `generate_monthly_summary(records: list) -> dict` that processes a list of expense records and returns a summary report in the form of a dictionary. Each record in the list is a tuple containing the expense category (string) and the amount spent (float). Implementation * Your function should: - Ensure `records` is a list of tuples, with each tuple containing a string and a float. - Sum the expenses per category. - Return a dictionary where keys are expense categories, and values are the total amount spent in each category. Constraints - The input list `records` will have at most 10^5 elements. - Each expense category is a non-empty string with a maximum length of 50 characters. - Each amount spent is a non-negative float. - Categories may appear multiple times in the records. Input/Output Format - Input: A list of tuples, where each tuple contains a string and a float. - Output: A dictionary summarizing total expenses per category. Example ```python def generate_monthly_summary(records: list) -> dict: # Your implementation here # Example usage: print(generate_monthly_summary([ (\\"groceries\\", 150.50), (\\"utilities\\", 200.00), (\\"groceries\\", 50.75), (\\"entertainment\\", 80.00), (\\"utilities\\", 150.50) ])) # Output: {\'groceries\': 201.25, \'utilities\': 350.50, \'entertainment\': 80.0} ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"def generate_monthly_summary(records: list) -> dict: Generates a summary report of total expenses per category. Parameters: records (list): A list of tuples where each tuple contains a string (category) and a float (amount). Returns: dict: A dictionary summarizing total expenses per category. summary = {} for category, amount in records: if category in summary: summary[category] += amount else: summary[category] = amount return summary"},{"question":"# Unique Character Substring In this task, your objective is to implement a function that finds the longest substring in a given string that contains all unique characters. We will refer to such a substring as the \\"Longest Unique Character Substring\\". Problem Description You are given a string `s` consisting of lowercase and uppercase letters and digits. Your task is to determine the longest substring without repeating characters and return both the substring and its length. Input * `s`: a string (s) consisting of lowercase and uppercase English letters and digits. Output * A tuple where the first element is a string representing the Longest Unique Character Substring and the second is an integer representing its length. Constraints * (1 leq text{len}(s) leq 10^4) Example ```python s = \\"abcabcbb\\" result = longest_unique_substring(s) print(result) ``` Expected Output: ``` (\'abc\', 3) ``` ```python s = \\"bbbbb\\" result = longest_unique_substring(s) print(result) ``` Expected Output: ``` (\'b\', 1) ``` ```python s = \\"pwwkew\\" result = longest_unique_substring(s) print(result) ``` Expected Output: ``` (\'wke\', 3) ``` Function Signature ```python def longest_unique_substring(s: str) -> tuple[str, int]: pass ``` Notes * Ensure that your solution efficiently handles the upper constraints. * The substring and its length should be returned as a tuple. * It is guaranteed that there will be a unique solution for the provided inputs.","solution":"def longest_unique_substring(s: str) -> tuple[str, int]: Finds the longest substring in a given string that contains all unique characters. Args: s (str): Input string consisting of lowercase and uppercase English letters and digits. Returns: tuple: A tuple where the first element is a string representing the longest unique character substring and the second is an integer representing its length. if not s: return (\\"\\", 0) start = max_length = 0 max_substring = \\"\\" seen = {} for end, char in enumerate(s): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = end if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end+1] return (max_substring, max_length)"},{"question":"# K-Nearest Neighbors (KNN) Algorithm Implementation You are tasked with writing your version of the K-Nearest Neighbors (KNN) algorithm to classify a given point based on a provided dataset. The goal is to correctly predict the class of the point using the KNN approach. # Function Signature ```python def knn_classify(data_points: List[Tuple[float, float, Any]], query_point: Tuple[float, float], k: int) -> Any: ``` # Parameters * `data_points` (List[Tuple[float, float, Any]]): A list of tuples where each tuple represents a data point in a 2D space along with its class label. Example: `[(x1, y1, label1), (x2, y2, label2), ... ]`. * `query_point` (Tuple[float, float]): A tuple representing the coordinates of the point to be classified. Example: `(qx, qy)`. * `k` (int): The number of nearest neighbors to consider for the classification. # Expected Output * (Any): Returns the predicted class label for the `query_point`. # Constraints * `k` is a positive integer. * `data_points` contains at least one point. * You can assume `data_points` and `query_point` will always have valid numerical values. # Performance Requirements * The function should appropriately handle large datasets efficiently, considering the constraints of typical computational resources. # Example ```python data_points = [ (1.0, 2.0, \'A\'), (2.0, 3.0, \'B\'), (3.0, 1.0, \'A\'), (5.0, 4.0, \'B\'), (3.0, 3.0, \'A\') ] query_point = (3.0, 2.5) k = 3 assert knn_classify(data_points, query_point, k) == \'A\' query_point2 = (4.0, 4.0) assert knn_classify(data_points, query_point2, k) == \'B\' ``` # Notes 1. Implement the function using a straightforward approach to the KNN algorithm, ensuring efficient distance calculations and neighbor comparisons. 2. Handle any ties in class labels by selecting the label that appears first among the `k` nearest neighbors in case of equal votes. 3. Provide a few additional test cases to demonstrate your function\'s robustness and accuracy in various scenarios.","solution":"from typing import List, Tuple, Any import math from collections import Counter def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: Calculates the Euclidean distance between two points in 2D space. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def knn_classify(data_points: List[Tuple[float, float, Any]], query_point: Tuple[float, float], k: int) -> Any: Classifies a query point based on the K-Nearest Neighbors algorithm. Args: - data_points: List of tuples, where each tuple consists of x, y coordinates and a class label. - query_point: A tuple representing the x, y coordinates of the query point. - k: The number of nearest neighbors to consider for classification. Returns: - The predicted class label for the query point. # Calculate the distance from the query point to all data points distances = [(euclidean_distance(datapoint[:2], query_point), datapoint[2]) for datapoint in data_points] # Sort the distances and select the top k distances.sort(key=lambda x: x[0]) k_nearest_neighbors = distances[:k] # Count the class labels of the top k nearest neighbors labels = [label for _, label in k_nearest_neighbors] most_common_label = Counter(labels).most_common(1)[0][0] return most_common_label"},{"question":"# Task Implement an algorithm to check if a given binary tree is symmetric. A binary tree is symmetric if it is a mirror of itself. # Objective Given a binary tree, write a function `is_symmetric` that returns `True` if the tree is symmetric, and `False` otherwise. # Input - A binary tree represented by its root node `TreeNode`. # Output - A boolean value: `True` if the tree is symmetric, `False` otherwise. # Constraints 1. The number of nodes in the binary tree will be in the range `[1, 1000]`. 2. Each node\'s value is an integer within the range `[-100, 100]`. # Examples ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 # Input: root = [1,2,2,3,4,4,3] # Output: True # Example 2 # Input: root = [1,2,2,None,3,None,3] # Output: False # Helper function to build the tree from list input can be used for testing def is_symmetric(root): # Your implementation here pass ``` # Guidelines - Consider implementing a helper function to compare left and right subtrees. - Recursively or iteratively ensure that both subtrees are the mirror image of one another. - Handle any edge cases such as single-node trees or trees with null nodes on one side.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_mirror(t1, t2): if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right)) def is_symmetric(root): return is_mirror(root, root)"},{"question":"# Unique Usernames You have been tasked with ensuring that each username in a list is unique. When a duplicate username is found, append the lowest possible integer to make it unique. Develop a function to handle this requirement. Requirements: 1. Identify duplicate usernames in the list. 2. Append the smallest integer to duplicates to make them unique (e.g., \'username\', \'username1\', \'username2\'). 3. Maintain the original order of usernames as much as possible. # Function Specification Implement a function `unique_usernames(usernames: List[str]) -> List[str]` that takes a list of usernames and returns a new list with all unique usernames, adhering to the above rules. Inputs: - `usernames`: A list of strings representing the usernames. Outputs: - A list of strings representing the unique usernames. Constraints: - The input list can have 0 to 10,000 usernames. - Usernames consist of alphanumeric characters. - Usernames have a maximum length of 30 characters. Performance Requirements: - Your solution should run efficiently with minimal overhead for duplication checking and renaming. Example Usage: ```python usernames = [\\"user\\", \\"user\\", \\"admin\\", \\"user\\", \\"admin1\\"] unique_list = unique_usernames(usernames) print(unique_list) # Output: [\'user\', \'user1\', \'admin\', \'user2\', \'admin1\'] ``` Note: In cases where the resulting unique username might clash with existing entries (e.g., transitioning \\"user\\" to \\"user1\\" when \\"user1\\" already exists), continue incrementing until a unique username is found.","solution":"def unique_usernames(usernames): Given a list of usernames, ensures all usernames are unique by appending the lowest possible integer to duplicates. Parameters: usernames (list of str): List of usernames to process. Returns: list of str: A list with unique usernames. unique_names = {} result = [] for name in usernames: if name in unique_names: count = unique_names[name] while f\\"{name}{count}\\" in unique_names: count += 1 unique_name = f\\"{name}{count}\\" unique_names[name] = count + 1 unique_names[unique_name] = 1 else: unique_name = name unique_names[name] = 1 result.append(unique_name) return result"},{"question":"# Coding Question: Remove Duplicates and Sort Names List Context: As a software engineer at a digital library, you\'re building a utility to clean up and standardize a list of author names. The aim is to remove any duplicate names and sort the resulting list in alphabetical order. Objective: - Write a function `clean_and_sort_names(names: List[str]) -> List[str>` that: - Eliminates any duplicate names from the list. - Returns the list of names sorted in alphabetical order. Input and Output: - **Input**: A list of strings `names` representing names (e.g., `[\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Charlie\\"]`). - **Output**: A list of strings, with duplicates removed and sorted alphabetically. Constraints and Limitations: - The list `names` can have up to 10,000 names. - Each name in `names` will be a non-empty string consisting of uppercase and lowercase letters. - The names are case-sensitive (i.e., \\"Alice\\" and \\"alice\\" are considered different). Examples: ```python >>> clean_and_sort_names([\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Charlie\\"]) [\'Alice\', \'Bob\', \'Charlie\'] >>> clean_and_sort_names([\\"David\\", \\"Eve\\", \\"David\\", \\"eve\\"]) [\'David\', \'Eve\', \'eve\'] >>> clean_and_sort_names([\\"John\\", \\"john\\", \\"JOHN\\", \\"John\\"]) [\'JOHN\', \'John\', \'john\'] >>> clean_and_sort_names([\\"Mary\\", \\"Peter\\", \\"Paul\\", \\"Paul\\", \\"Mary\\"]) [\'Mary\', \'Paul\', \'Peter\'] ``` Function Signature: ```python from typing import List def clean_and_sort_names(names: List[str]) -> List[str]: pass ```","solution":"from typing import List def clean_and_sort_names(names: List[str]) -> List[str]: Removes duplicate names and returns the list sorted in alphabetical order. # Convert list to a set to remove duplicates unique_names = set(names) # Convert set back to a list and sort alphabetically sorted_names = sorted(unique_names) return sorted_names"},{"question":"# Calculate Area and Perimeter of a Geometric Shape Problem Description: Given the dimensions of a geometric shape, calculate its area and perimeter. For this problem, you need to handle three types of shapes: rectangle, triangle, and circle. Shape Definitions: - Rectangle: defined by width ( w ) and height ( h ) - Triangle: defined by the base ( b ) and height ( h ) - Circle: defined by its radius ( r ) Formulas: - Rectangle Area: ( A = w times h ) - Rectangle Perimeter: ( P = 2 times (w + h) ) - Triangle Area: ( A = frac{1}{2} times b times h ) - Triangle Perimeter: Assume the triangle is equilateral for this problem, so ( P = 3 times b ) - Circle Area: ( A = pi times r^2 ) - Circle Perimeter: ( P = 2 times pi times r ) Function Signature: ```python def calculate_geometry(shape: str, *dimensions: float) -> dict: pass ``` Input: * A string ( shape ) representing the type of shape. This can be either \\"rectangle\\", \\"triangle\\", or \\"circle\\". * Dimensions (1 to 3 floats, depending on the shape): - For \\"rectangle\\": two floats (width and height) - For \\"triangle\\": two floats (base and height) - For \\"circle\\": one float (radius) Output: * A dictionary with two keys: - \\"area\\": the calculated area of the shape (float) - \\"perimeter\\": the calculated perimeter of the shape (float) Constraints: * Inputs will be valid for the shapes they represent. * For rectangle: ( 0 < w, h leq 10^4 ) * For triangle: ( 0 < b, h leq 10^4 ) * For circle: ( 0 < r leq 10^4 ) Examples: * **Example 1**: ```python calculate_geometry(\\"rectangle\\", 5, 10) ``` **Output**: ```python {\'area\': 50, \'perimeter\': 30} ``` * **Example 2**: ```python calculate_geometry(\\"triangle\\", 6, 8) ``` **Output**: ```python {\'area\': 24.0, \'perimeter\': 18} ``` * **Example 3**: ```python calculate_geometry(\\"circle\\", 7) ``` **Output**: ```python {\'area\': 153.93804002589985, \'perimeter\': 43.982297150257104} ``` Notes: * The function should accurately calculate the area and perimeter using the provided dimensions. * Use the value of ( pi ) from the math module if needed. Implement the `calculate_geometry` function to determine the area and perimeter of a given geometric shape.","solution":"import math def calculate_geometry(shape: str, *dimensions: float) -> dict: Calculates the area and perimeter of a given geometric shape. :param shape: String representing the type of shape. Can be \\"rectangle\\", \\"triangle\\", or \\"circle\\". :param dimensions: Dimensions required to calculate the area and perimeter. - Rectangle: width and height - Triangle: base and height (assuming equilateral triangle for perimeter) - Circle: radius :return: Dictionary containing \'area\' and \'perimeter\' of the shape. if shape == \\"rectangle\\": width, height = dimensions area = width * height perimeter = 2 * (width + height) elif shape == \\"triangle\\": base, height = dimensions area = 0.5 * base * height perimeter = 3 * base # assuming equilateral triangle for simplicity elif shape == \\"circle\\": radius = dimensions[0] area = math.pi * radius ** 2 perimeter = 2 * math.pi * radius else: raise ValueError(\\"Unsupported shape!\\") return {\\"area\\": area, \\"perimeter\\": perimeter}"},{"question":"# Coding Assessment Question Scenario You are developing a new feature for an online bookstore that suggests books to users based on their reading history. One part of the feature is to identify the most frequently read book genres within a specific time period. Your task is to find the top `n` most read genres from the user\'s reading history within the given time period. Problem Statement Write a function `top_n_genres(books: List[Tuple[str, str]], start_date: str, end_date: str, n: int) -> List[str]` that computes the top `n` most read genres within the specified date range. Each book entry consists of a tuple with the following elements: 1. A string representing the date the book was read, in the format \\"YYYY-MM-DD\\". 2. A string representing the genre of the book. Input - `books`: A list of tuples, where each tuple consists of a date and a genre. - `start_date`: A string representing the start of the date range, in the format \\"YYYY-MM-DD\\". - `end_date`: A string representing the end of the date range, in the format \\"YYYY-MM-DD\\". - `n`: An integer representing the number of top genres to retrieve. Output - The function should return a list of strings, each representing a genre. The genres should be ordered by the number of times they were read within the specified range, from most to least frequent. If two genres have the same frequency, they should be ordered alphabetically. Constraints - 1 <= len(books) <= 10^5 - The date format for all dates is valid and adheres to \\"YYYY-MM-DD\\". - The `start_date` will always be less than or equal to `end_date`. - 1 <= n <= len(set(genres)) Example ```python def top_n_genres(books: list[tuple[str, str]], start_date: str, end_date: str, n: int) -> list[str]: Returns the top n most read genres within the specified date range. >>> books = [ (\\"2023-01-01\\", \\"Science Fiction\\"), (\\"2023-01-02\\", \\"Fantasy\\"), (\\"2023-01-03\\", \\"Science Fiction\\"), (\\"2023-01-03\\", \\"Biography\\"), (\\"2023-01-04\\", \\"Biography\\"), (\\"2023-01-05\\", \\"Science Fiction\\") ] >>> start_date = \\"2023-01-01\\" >>> end_date = \\"2023-01-04\\" >>> n = 2 >>> top_n_genres(books, start_date, end_date, n) [\'Science Fiction\', \'Biography\'] >>> books = [ (\\"2023-05-01\\", \\"Thriller\\"), (\\"2023-05-02\\", \\"Thriller\\"), (\\"2023-05-03\\", \\"Mystery\\"), (\\"2023-05-04\\", \\"Thriller\\"), (\\"2023-05-05\\", \\"Mystery\\") ] >>> start_date = \\"2023-05-01\\" >>> end_date = \\"2023-05-05\\" >>> n = 1 >>> top_n_genres(books, start_date, end_date, n) [\'Thriller\'] from collections import Counter from datetime import datetime def within_date_range(date, start, end): return start <= date <= end start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") genre_count = Counter() for date, genre in books: current_date = datetime.strptime(date, \\"%Y-%m-%d\\") if within_date_range(current_date, start, end): genre_count[genre] += 1 top_genres = genre_count.most_common(n) return [genre for genre, _ in top_genres] if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` You should make sure the solution appropriately handles edge cases and performs efficiently within the given constraints.","solution":"from collections import Counter from datetime import datetime from typing import List, Tuple def top_n_genres(books: List[Tuple[str, str]], start_date: str, end_date: str, n: int) -> List[str]: Returns the top n most read genres within the specified date range. Parameters: books (List[Tuple[str, str]]): List of (date, genre) tuples. start_date (str): Start date in the format \\"YYYY-MM-DD\\". end_date (str): End date in the format \\"YYYY-MM-DD\\". n (int): Number of top genres to retrieve. Returns: List[str]: List of top n genres. def within_date_range(date, start, end): return start <= date <= end start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") genre_count = Counter() for date, genre in books: current_date = datetime.strptime(date, \\"%Y-%m-%d\\") if within_date_range(current_date, start, end): genre_count[genre] += 1 top_genres = genre_count.most_common(n) return [genre for genre, _ in top_genres]"},{"question":"# Scenario Your task is to implement a function `generate_k_combinations` that generates all possible combinations of `k` elements from a given list of integers, using a recursive approach without importing any external libraries. # Function Specification ```python def generate_k_combinations(arr: List[int], k: int) -> List[List[int]]: pass ``` # Input * **arr**: A list of integers where 0 <= len(arr) <= 20. * **k**: An integer such that 0 <= k <= len(arr). # Output * Returns a list of lists, each containing a unique combination of `k` elements from the input list `arr`. The combinations should be sorted in ascending order within each list, and the entire set of combinations should be sorted lexicographically where possible. # Constraints * Elements in the list can be negative or positive integers. * Ensure that the solution is derived using a recursive approach. # Examples ```python >>> generate_k_combinations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> generate_k_combinations([1, 2, 3, 4], 3) [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] >>> generate_k_combinations([1, 2, 2], 2) [[1, 2], [1, 2], [2, 2]] >>> generate_k_combinations([1, 2, 3], 0) [[]] >>> generate_k_combinations([], 1) [] ``` **Note**: If `k` is 0, the only combination is an empty list. If the input list `arr` is empty and `k` is greater than 0, then the output should be an empty list.","solution":"from typing import List def generate_k_combinations(arr: List[int], k: int) -> List[List[int]]: def recursive_combinations(start: int, comb: List[int], res: List[List[int]]): if len(comb) == k: res.append(comb.copy()) return for i in range(start, len(arr)): comb.append(arr[i]) recursive_combinations(i + 1, comb, res) comb.pop() result = [] recursive_combinations(0, [], result) return result"},{"question":"# Problem Statement You are provided with a utility function that checks whether a given string is a palindrome. A string is considered a palindrome if it reads the same backward as forward (ignoring spaces, punctuation, and case). Your task is to implement a new function `find_longest_palindrome` that takes a list of strings and returns the longest palindrome from the list. If there are multiple palindromes with the same length, return the first one encountered in the list. # Requirements Function Signature ```python def find_longest_palindrome(strings: list) -> str: ``` Input * `strings`: A list of strings. Output * A string, which is the longest palindrome from the input list of strings. If there are no palindromes in the list, return an empty string. Constraints * The list of strings will contain at least one string. * Consider only alphabetical characters and ignore spaces, punctuation, and case when determining if a string is a palindrome. # Example ```python >>> find_longest_palindrome([\\"racecar\\", \\"Madam\\", \\"Step on no pets\\", \\"hello\\"]) \'Step on no pets\' >>> find_longest_palindrome([\\"hello\\", \\"world\\"]) \'\' >>> find_longest_palindrome([\\"abc\\", \\"madamimadam\\", \\"No lemon, no melon\\", \\"civic\\"]) \'madamimadam\' ``` # Caveats * Ensure your function efficiently handles incorrect input types by raising appropriate exceptions. * Use the provided `is_palindrome` utility function to help determine if strings are palindromes.","solution":"import re def is_palindrome(s: str) -> bool: Check if the input string is a palindrome, considering only alphabetical characters and ignoring spaces, punctuation, and case. s = re.sub(r\'[^a-zA-Z]\', \'\', s).lower() return s == s[::-1] def find_longest_palindrome(strings: list) -> str: Finds the longest palindrome in a list of strings. longest_pal = \\"\\" for s in strings: if is_palindrome(s) and len(s) > len(longest_pal): longest_pal = s return longest_pal"},{"question":"# Question Context: You have been tasked with implementing a function for a financial application that performs certain smart calculations on transaction logs. The logs contain a list of transactions where each transaction represents either a credit (adding funds) or a debit (subtracting funds). Task: Write a function `calculate_net_balance(transactions: List[str]) -> int` that: 1. Accepts a list of transaction strings. 2. Returns the net balance after all transactions have been processed. # Requirements: 1. Each transaction string will be in the format: `\\"+X\\"` or `\\"-Y\\"` where `X` and `Y` are non-negative integers. 2. A transaction string beginning with `+` denotes a credit to be added to the balance, and a string beginning with `-` denotes a debit to be subtracted. 3. Ensure that the function correctly handles an empty list of transactions by returning a net balance of `0`. # Input Format: * A list of strings representing the transactions. # Output Format: * An integer representing the net balance calculated. # Constraints: * The total number of transactions (N) will be at most 10<sup>6</sup>. * Each transaction amount (X) or (Y) is a non-negative integer and can be as large as 10<sup>9</sup>. # Example Usage: ```python >>> calculate_net_balance([\\"+100\\", \\"-50\\", \\"+200\\", \\"-150\\"]) 100 >>> calculate_net_balance([\\"+1000\\", \\"-1000\\", \\"+500\\"]) 500 >>> calculate_net_balance([\\"-100\\", \\"-200\\", \\"+300\\", \\"+100\\"]) 100 >>> calculate_net_balance([]) 0 >>> calculate_net_balance([\\"+10\\", \\"+20\\", \\"+30\\", \\"-60\\"]) 0 ``` # Performance Requirements: - The solution should handle up to 10<sup>6</sup> transactions efficiently. Implementation Example: Here is a function signature to start with: ```python def calculate_net_balance(transactions: List[str]) -> int: pass ```","solution":"def calculate_net_balance(transactions): Returns the net balance after processing a list of transactions. Args: transactions (List[str]): A list of transaction strings in the format \'+X\' or \'-Y\'. Returns: int: The net balance after processing all the transactions. net_balance = 0 for transaction in transactions: net_balance += int(transaction) return net_balance"},{"question":"# Task To enhance your understanding of string manipulation and pattern matching, implement a function that checks if a given string represents a valid human-readable file size. # Function Signature ```python def is_valid_filesize(filesize: str) -> bool: Check if the given string is a valid human-readable file size. :param filesize: The string to check. :return: True if the string is a valid file size, otherwise False. ``` # Description - **Input**: A single string `filesize`. - **Output**: Return a boolean value, `True` if `filesize` is a valid file size, and `False` otherwise. # Constraints - Valid size units are: \'B\', \'KB\', \'MB\', \'GB\', \'TB\' - The numeric part can have up to 2 decimal places. - The string must have exactly one space between the numeric part and the unit part. # Examples ```python assert is_valid_filesize(\\"1024 B\\") == True assert is_valid_filesize(\\"1.5 KB\\") == True assert is_valid_filesize(\\"100 MB\\") == True assert is_valid_filesize(\\"1.23 GB\\") == True assert is_valid_filesize(\\"0.45 TB\\") == True assert is_valid_filesize(\\"10.123 MB\\") == False # More than 2 decimals assert is_valid_filesize(\\"1000MB\\") == False # No space between number and unit assert is_valid_filesize(\\"1.5 kB\\") == False # Invalid unit assert is_valid_filesize(\\"MB 100\\") == False # Unit before number ``` # Guideline 1. **Extract Components**: Split the string into numeric and unit parts. 2. **Numeric Validation**: - Ensure the numeric part is a valid decimal number with up to 2 decimal places. - Check for positive numbers only. 3. **Unit Validation**: Ensure the unit part is one of the valid size units (\'B\', \'KB\', \'MB\', \'GB\', \'TB). 4. **Format Validation**: Ensure there is exactly one space between the numeric part and the unit part. # Note Consider edge cases such as malformed strings, incorrect units, multiple spaces, and invalid decimal formats. Use regular expressions for pattern matching where applicable for efficient validation.","solution":"import re def is_valid_filesize(filesize: str) -> bool: Check if the given string is a valid human-readable file size. :param filesize: The string to check. :return: True if the string is a valid file size, otherwise False. # Regular expression pattern for validating file size pattern = re.compile(r\'^d+(.d{1,2})? (B|KB|MB|GB|TB)\') return bool(pattern.match(filesize))"},{"question":"# Question: Implement a Maze Generator Design and implement a function that creates a random maze using Prim\'s Algorithm. The maze should be represented as a 2D grid of cells, where each cell can be either a wall or a path. # The Maze Generator Function Implement the function `generate_maze` with the following signature: ```python def generate_maze( width: int, height: int ) -> List[List[int]]: Generates a random maze using Prim\'s Algorithm. Parameters: - width (int): Width of the maze. - height (int): Height of the maze. Returns: - List[List[int]]: A 2D grid representing the maze, where 0 represents a path, and 1 represents a wall. pass ``` # Requirements 1. **Grid Initialization**: Initialize a 2D grid of size `width` x `height` filled with walls. 2. **Algorithm Implementation**: Implement Prim\'s Algorithm to carve out the maze paths. 3. **Starting Point**: Begin with an initial cell and mark it as a path. 4. **Frontier Tracking**: Maintain a list of walls that are adjacent to the current path. 5. **Path Carving**: Randomly select a wall from the frontier, carve a path if it connects to an isolated cell, and update the frontier. 6. **Completion**: Continue until the frontier is empty, meaning the maze generation is complete. # Example Usage Generate a maze of size 20x15: ```python if __name__ == \\"__main__\\": maze = generate_maze(20, 15) for row in maze: print(\\" \\".join([\\"#\\" if cell == 1 else \\" \\" for cell in row])) ``` # Constraints * Width and height are positive integers, typically in the range of [5, 100]. * The maze should have an entrance at the top-left corner `(0, 0)` and an exit at the bottom-right corner `(width-1, height-1)`. # Performance Considerations The implementation should efficiently handle the creation of large mazes and ensure that the algorithm completes in a reasonable time frame.","solution":"import random from typing import List def generate_maze(width: int, height: int) -> List[List[int]]: Generates a random maze using Prim\'s Algorithm. Parameters: - width (int): Width of the maze. - height (int): Height of the maze. Returns: - List[List[int]]: A 2D grid representing the maze, where 0 represents a path, and 1 represents a wall. # Initialize the grid with walls maze = [[1 for _ in range(width)] for _ in range(height)] # Starting point start_x, start_y = 0, 0 maze[start_y][start_x] = 0 # List of walls walls = [(start_x, start_y + 1), (start_x + 1, start_y)] walls = [w for w in walls if 0 <= w[0] < width and 0 <= w[1] < height] while walls: # Pick a random wall x, y = random.choice(walls) walls.remove((x, y)) # Determine neighbors neighbors = [(x, y-1), (x, y+1), (x-1, y), (x+1, y)] neighbors = [n for n in neighbors if 0 <= n[0] < width and 0 <= n[1] < height] # Check how many paths are in the neighbors paths = [(nx, ny) for (nx, ny) in neighbors if maze[ny][nx] == 0] if len(paths) == 1: maze[y][x] = 0 # Add the neighboring walls to the frontier for nx, ny in neighbors: if maze[ny][nx] == 1 and (nx, ny) not in walls: walls.append((nx, ny)) # Ensure entrance and exit are open maze[0][0] = 0 maze[height-1][width-1] = 0 return maze"},{"question":"# Maximum Temperature Processor Problem Statement You are given temperature readings from sensors in a grid-like environment where each reading is an integer within a provided matrix. Write a function to determine the maximum temperature measured. Implement a function `max_temperature` that adheres to the following signature: ```python def max_temperature(temperatures: List[List[int]]) -> int: ``` The function should: 1. **Raise a `ValueError`** if the `temperatures` matrix is empty or if any row in the matrix is empty. 2. Traverse the entire matrix and find the maximum integer value representing the highest temperature recorded. 3. **Return the maximum temperature.** Assume all input values are integers and assess exceptional cases where the matrix might not be well-formed. Examples ```python >>> max_temperature([[30, 35, 40], [42, 38, 44], [41, 45, 39]]) 45 >>> max_temperature([[25]]) 25 >>> max_temperature([[10, 12, 11], [14, 19, 18]]) 19 >>> max_temperature([[0, -1, -5], [-4, -2, -3]]) 0 >>> max_temperature([]) Traceback (most recent call last): ... ValueError: The temperatures matrix cannot be empty. >>> max_temperature([[]]) Traceback (most recent call last): ... ValueError: Each row in the temperatures matrix must contain at least one element. ``` Your implementation should correctly identify the highest temperature in different scenarios of the matrix, ensuring edge cases and errors are handled elegantly with appropriate exceptions. This question aims to assess your ability to navigate two-dimensional arrays and manage input validation.","solution":"from typing import List def max_temperature(temperatures: List[List[int]]) -> int: if not temperatures or not all(temperatures): raise ValueError(\\"The temperatures matrix cannot be empty.\\") max_temp = float(\'-inf\') for row in temperatures: for temp in row: if temp > max_temp: max_temp = temp return max_temp"},{"question":"# Task: Weather Data Processor Scenario You are developing a weather application and need to process real-time weather data. Your task is to write a function that retrieves the current weather conditions for a given city using an external weather API. The function will return specific weather details including temperature, humidity, and weather description. Construct a function `get_weather_details(city: str) -> dict` which, given a city name (e.g., \\"London\\"), returns a dictionary containing the temperature, humidity, and weather description. If the city name is invalid or the data cannot be retrieved, the function should return a dictionary with an error message indicating the failure. Input - `city` (str): A valid city name (e.g., \\"London\\", \\"New York\\"). Output - Returns a dictionary with the keys: - `temperature` (float): The current temperature in Celsius. - `humidity` (int): The current humidity percentage. - `description` (str): A brief description of the weather (e.g., \\"clear sky\\"). - Returns a dictionary with a key `error` and an appropriate error message as the value if the city name is invalid or data retrieval fails (e.g., `{\\"error\\": \\"Invalid city name\\"}` or `{\\"error\\": \\"Weather data not found\\"}`). Constraints - The function should complete within a reasonable time (consider a network timeout of 10 seconds). - Assume the use of `requests` library to make HTTP requests to an appropriate weather API (e.g., OpenWeatherMap). Performance Requirements - The function should handle up to 50 weather data queries per minute without significant performance degradation. # Implementation Implement the function following these requirements and consider the described edge cases, performance bottlenecks, and potential error scenarios. Example ```python print(get_weather_details(\\"London\\")) # Returns a dictionary, e.g., {\\"temperature\\": 15.0, \\"humidity\\": 72, \\"description\\": \\"clear sky\\"} print(get_weather_details(\\"InvalidCity\\")) # Returns an error dictionary, e.g., {\\"error\\": \\"Invalid city name\\"} ```","solution":"import requests def get_weather_details(city: str) -> dict: api_key = \\"YOUR_API_KEY\\" # Replace with your actual API key base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" params = { \\"q\\": city, \\"appid\\": api_key, \\"units\\": \\"metric\\" } try: response = requests.get(base_url, params=params, timeout=10) response.raise_for_status() data = response.json() weather_details = { \\"temperature\\": data[\\"main\\"][\\"temp\\"], \\"humidity\\": data[\\"main\\"][\\"humidity\\"], \\"description\\": data[\\"weather\\"][0][\\"description\\"] } return weather_details except requests.exceptions.RequestException as e: return {\\"error\\": \\"Weather data not found\\"} except KeyError as e: return {\\"error\\": \\"Invalid city name\\"}"},{"question":"# Segment Tree with Lazy Propagation Implementation Objective You need to implement a segment tree with lazy propagation technique to support efficient range updates and range queries. Problem Statement A `SegmentTree` is a data structure that allows for efficient range queries and updates. You need to implement two primary operations in the segment tree that supports lazy propagation: 1. **`update_range(self, start_range: int, end_range: int, val: int)`** * **Description**: This method performs a range update by adding the value `val` to every element in the range `[start_range, end_range]` inclusive. * **Input**: - `start_range`: the starting index of the range. - `end_range`: the ending index of the range. - `val`: the integer value to be added to each element in the range. * **Output**: None 2. **`query_range(self, start_range: int, end_range: int) -> int`** * **Description**: This method performs a range query to fetch the sum of elements in the range `[start_range, end_range]` inclusive. * **Input**: - `start_range`: the starting index of the range. - `end_range`: the ending index of the range. * **Output**: The sum of the elements in the specified range as an integer. Constraints: 1. Both `start_range` and `end_range` are inclusive and are valid indices within the array representing the segment tree. 2. The segment tree stores integer values only. 3. The length of the array `n` (used to build the segment tree) is not greater than 10^5. Performance Requirements: - The `update_range` operation should take (O(log n)) time complexity. - The `query_range` operation should take (O(log n)) time complexity. Below is the scaffold of the `SegmentTree` class. You need to complete the methods as described above. ```python class SegmentTree: def __init__(self, array: List[int]): self.n = len(array) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self._build(array, 0, 0, self.n - 1) def _build(self, array, node, start, end): if start == end: self.tree[node] = array[start] else: mid = (start + end) // 2 left = 2 * node + 1 right = 2 * node + 2 self._build(array, left, start, mid) self._build(array, right, mid + 1, end) self.tree[node] = self.tree[left] + self.tree[right] def _update_range(self, node, start, end, l, r, val): # Handle lazy propagation if needed and add the new updates # Your implementation here def update_range(self, start_range: int, end_range: int, val: int): self._update_range(0, 0, self.n - 1, start_range, end_range, val) def _query_range(self, node, start, end, l, r): # Handle lazy propagation and query the range # Your implementation here def query_range(self, start_range: int, end_range: int) -> int: return self._query_range(0, 0, self.n - 1, start_range, end_range) ``` # Example Usage ```python # Initialize the segment tree with an array arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # Perform a range update: Add 5 to elements from index 1 to 3 seg_tree.update_range(1, 3, 5) # Perform a range query: Get the sum from index 1 to 3 result = seg_tree.query_range(1, 3) print(result) # Expected output should be the updated sum of elements in the range [1, 3] # Perform another range update: Add 2 to elements from index 0 to 2 seg_tree.update_range(0, 2, 2) # Perform another range query: Get the sum from index 0 to 5 result = seg_tree.query_range(0, 5) print(result) # Expected output should be the updated sum of all elements ```","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self._build(array, 0, 0, self.n - 1) def _build(self, array, node, start, end): if start == end: self.tree[node] = array[start] else: mid = (start + end) // 2 left = 2 * node + 1 right = 2 * node + 2 self._build(array, left, start, mid) self._build(array, right, mid + 1, end) self.tree[node] = self.tree[left] + self.tree[right] def _update_range(self, node, start, end, l, r, val): # If there are pending updates, apply them if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: # not a leaf node self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 # No overlap if start > end or start > r or end < l: return # Total overlap if start >= l and end <= r: self.tree[node] += (end - start + 1) * val if start != end: self.lazy[2 * node + 1] += val self.lazy[2 * node + 2] += val return # Partial overlap mid = (start + end) // 2 self._update_range(2 * node + 1, start, mid, l, r, val) self._update_range(2 * node + 2, mid + 1, end, l, r, val) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def update_range(self, start_range: int, end_range: int, val: int): self._update_range(0, 0, self.n - 1, start_range, end_range, val) def _query_range(self, node, start, end, l, r): # If there are pending updates, apply them if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 # No overlap if start > end or start > r or end < l: return 0 # Total overlap if start >= l and end <= r: return self.tree[node] # Partial overlap mid = (start + end) // 2 left_sum = self._query_range(2 * node + 1, start, mid, l, r) right_sum = self._query_range(2 * node + 2, mid + 1, end, l, r) return left_sum + right_sum def query_range(self, start_range: int, end_range: int) -> int: return self._query_range(0, 0, self.n - 1, start_range, end_range)"},{"question":"Implement a function `zigzag_traverse(matrix: List[List[int]]) -> List[int]` that returns the elements of a matrix in zigzag order. Zigzag order is defined as starting from the top-left of the matrix, and alternately traversing the diagonals up-right and down-left. Input: * `matrix` - a 2D list of integers representing the matrix. Output: * Returns a list of integers representing the elements of the matrix in zigzag order. Constraints: * `1 <= len(matrix), len(matrix[0]) <= 200` (the number of rows and columns in the matrix) * `-1000 <= matrix[i][j] <= 1000` Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(zigzag_traverse(matrix)) # [1, 2, 4, 7, 5, 3, 6, 8, 9] matrix = [ [1, 2], [3, 4], [5, 6] ] print(zigzag_traverse(matrix)) # [1, 2, 3, 5, 4, 6] ``` Description & Requirements: 1. You should implement the `zigzag_traverse` function as specified. 2. The function should correctly navigate the elements of the matrix in the required zigzag pattern. 3. Ensure efficiency in processing large matrices by keeping the solution optimal in terms of time and space complexity. Note: * You may define helper functions if necessary. * Carefully manage edge cases where the matrix is a single row or single column.","solution":"from typing import List def zigzag_traverse(matrix: List[List[int]]) -> List[int]: def is_in_bounds(row, col): return 0 <= row < len(matrix) and 0 <= col < len(matrix[0]) result = [] rows, cols = len(matrix), len(matrix[0]) row, col = 0, 0 up = True while is_in_bounds(row, col): result.append(matrix[row][col]) if up: if col == cols - 1: row += 1 up = False elif row == 0: col += 1 up = False else: row -= 1 col += 1 else: if row == rows - 1: col += 1 up = True elif col == 0: row += 1 up = True else: row += 1 col -= 1 return result"},{"question":"# Expression Parser and Evaluator In this task, you will create an expression parser and evaluator to evaluate mathematical expressions. This task involves parsing and evaluating expressions using common mathematical operators and parentheses. Part A: Expression Node Create a class `ExpressionNode` that represents a node in the expression tree. 1. `__init__(self, value: Union[int, str], left: Optional[\'ExpressionNode\'] = None, right: Optional[\'ExpressionNode\'] = None)`: Initializes the node with a value, left child, and right child. 2. `__str__(self) -> str`: Returns a string representation of the node and its children. Part B: Expression Tree Create a class `ExpressionTree` to parse the string expression and evaluate it. 1. `__init__(self, expression: str)`: Initializes the expression tree with an infix expression (the expression can contain integers, the operators `+`, `-`, `*`, `/`, and parentheses). 2. `_build_tree(self) -> ExpressionNode`: Parses the expression and builds an expression tree. This function should handle operator precedence and parentheses correctly. 3. `_evaluate_node(self, node: ExpressionNode) -> int`: Recursively evaluates the expression tree starting from the given node. 4. `evaluate(self) -> int`: Evaluates the entire expression tree and returns the result. 5. `__str__(self) -> str`: Returns a string representation of the expression tree. # Input and Output * The input expression will be a string containing a valid mathematical expression. * The `evaluate` method should return an integer result of the evaluated expression. * Ensure that your implementation correctly handles operator precedence and parentheses. # Example ```python # Initialization exp_tree = ExpressionTree(\\"(3 + 2) * (7 - 4) / 3\\") # Expression Tree String Representation print(exp_tree) # Should print a suitable string representation of the tree # Evaluate the Expression result = exp_tree.evaluate() print(result) # Should print 5 ``` # Notes: - Your implementation should correctly handle operator precedence and parentheses. - Handle integer division where necessary. - You can assume that the input expressions are valid. Implement the classes `ExpressionNode` and `ExpressionTree` with the specified methods and ensure your code passes the above example.","solution":"from typing import Union, Optional class ExpressionNode: def __init__(self, value: Union[int, str], left: Optional[\'ExpressionNode\'] = None, right: Optional[\'ExpressionNode\'] = None): self.value = value self.left = left self.right = right def __str__(self) -> str: if self.left is None and self.right is None: return str(self.value) return f\\"({str(self.left)} {self.value} {str(self.right)})\\" class ExpressionTree: def __init__(self, expression: str): self.expression = expression self.root = self._build_tree() def _build_tree(self) -> ExpressionNode: tokens = self._tokenize(self.expression) output = [] operators = [] def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operator(operators, output): right = output.pop() left = output.pop() op = operators.pop() output.append(ExpressionNode(op, left, right)) i = 0 while i < len(tokens): if tokens[i].isdigit(): output.append(ExpressionNode(int(tokens[i]))) elif tokens[i] == \'(\': operators.append(tokens[i]) elif tokens[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, output) operators.pop() # remove the \'(\' else: # it is an operator while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, output) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, output) return output[0] def _tokenize(self, expression: str): tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = \'\' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 tokens.append(num) elif expression[i] in \'+-*/()\': tokens.append(expression[i]) i += 1 else: i += 1 # skip spaces return tokens def _evaluate_node(self, node: ExpressionNode) -> int: if isinstance(node.value, int): return node.value left_val = self._evaluate_node(node.left) right_val = self._evaluate_node(node.right) if node.value == \'+\': return left_val + right_val elif node.value == \'-\': return left_val - right_val elif node.value == \'*\': return left_val * right_val elif node.value == \'/\': return left_val // right_val # integer division def evaluate(self) -> int: return self._evaluate_node(self.root) def __str__(self) -> str: return str(self.root)"},{"question":"# Scenario In computer networks, IP addresses are used to uniquely identify devices on a network. An IP address can be classified into different classes (A, B, C, D, E) based on its first few bits. For simplicity, here we will only consider classes A, B, and C. # Problem Create a function `classify_ip(ip: str) -> str` that takes an IP address as a string and returns its class as a string (\'A\', \'B\', or \'C\'). The input IP address will always be a valid IPv4 address in dot-decimal notation (e.g., \\"192.168.0.1\\"). # Requirements - Implement the function to classify the IP address correctly. - Return \'A\', \'B\', or \'C\' based on the following rules: - Class A: First octet is in the range 1-126 - Class B: First octet is in the range 128-191 - Class C: First octet is in the range 192-223 - Raise a `ValueError` with an appropriate message if the IP address is \'127.0.0.1\' (loopback address). # Function Signature ```python def classify_ip(ip: str) -> str: ... ``` # Input and Output - **Input**: A string `ip` representing a valid IPv4 address. - **Output**: A string representing the class of the IP address (\'A\', \'B\', or \'C\'). # Examples - `classify_ip(\\"10.0.0.1\\")` should return `\'A\'` - `classify_ip(\\"172.16.0.1\\")` should return `\'B\'` - `classify_ip(\\"192.168.1.1\\")` should return `\'C\'` - `classify_ip(\\"127.0.0.1\\")` should raise a `ValueError` with the message \\"Loopback address is not classifiable.\\" # Testing Use Python\'s built-in `doctest` module to provide test cases demonstrating the usage and correctness of the function.","solution":"def classify_ip(ip: str) -> str: Classify the given IP address as class A, B, or C. Args: - ip (str): The IP address in dot-decimal notation. Returns: - str: The class of the IP address (\'A\', \'B\', or \'C\'). Raises: - ValueError: If the IP address is \'127.0.0.1\'. first_octet = int(ip.split(\'.\')[0]) if ip == \'127.0.0.1\': raise ValueError(\\"Loopback address is not classifiable.\\") if 1 <= first_octet <= 126: return \'A\' elif 128 <= first_octet <= 191: return \'B\' elif 192 <= first_octet <= 223: return \'C\' else: raise ValueError(\\"IP address is outside the classifiable range (A, B, C).\\")"},{"question":"# Flight Connection Path Finder Given a class `FlightPath` that stores information about direct flight connections between cities, implement the method `find_path` to determine if there is a possible path (direct or through connecting flights) from one city to another. # Function Signature ```python def find_path(self, start: str, end: str) -> bool: pass ``` # Input - `start`: The code or name of the starting city (string). - `end`: The code or name of the destination city (string). # Output - Return `True` if there exists a path from `start` city to `end` city, either directly or through one or more connecting flights. Otherwise, return `False`. # Class Definition The `FlightPath` class has the following properties: ```python class FlightPath: def __init__(self): self.connections = {} def add_connection(self, from_city: str, to_city: str) -> None: if from_city not in self.connections: self.connections[from_city] = [] self.connections[from_city].append(to_city) ``` - `self.connections`: A dictionary where the key is a city, and the value is a list of cities to which there are direct flights from the key city. # Example Scenario Consider the following connections: ```python fp = FlightPath() fp.add_connection(\\"A\\", \\"B\\") fp.add_connection(\\"B\\", \\"C\\") fp.add_connection(\\"C\\", \\"D\\") fp.add_connection(\\"E\\", \\"F\\") ``` - `fp.find_path(\\"A\\", \\"D\\")` should return `True` (A -> B -> C -> D) - `fp.find_path(\\"A\\", \\"E\\")` should return `False` (no connection between A and E) - `fp.find_path(\\"E\\", \\"F\\")` should return `True` (direct connection E -> F) # Constraints - You may assume all city names are unique and case sensitive. - The input cities always exist in the system. - There are no cyclic connections (e.g., `A -> B -> A`). # Sample Test Case ```python fp = FlightPath() fp.add_connection(\\"A\\", \\"B\\") fp.add_connection(\\"B\\", \\"C\\") fp.add_connection(\\"C\\", \\"D\\") fp.add_connection(\\"E\\", \\"F\\") # Should output True print(fp.find_path(\\"A\\", \\"D\\")) # Should output False print(fp.find_path(\\"A\\", \\"E\\")) # Should output True print(fp.find_path(\\"E\\", \\"F\\")) # Should output True print(fp.find_path(\\"B\\", \\"D\\")) # Should output False print(fp.find_path(\\"D\\", \\"A\\")) ``` # Tips - Consider using graph traversal algorithms, such as Depth-First Search (DFS) or Breadth-First Search (BFS), to determine the connectivity between cities. - Handle the scenario of cities that have no outgoing flights properly. - Ensure to test edge cases like searches within isolated clusters of connected cities.","solution":"class FlightPath: def __init__(self): self.connections = {} def add_connection(self, from_city: str, to_city: str) -> None: if from_city not in self.connections: self.connections[from_city] = [] self.connections[from_city].append(to_city) def find_path(self, start: str, end: str) -> bool: if start not in self.connections: return False visited = set() return self._dfs(start, end, visited) def _dfs(self, current: str, end: str, visited: set) -> bool: if current == end: return True visited.add(current) for neighbor in self.connections.get(current, []): if neighbor not in visited: if self._dfs(neighbor, end, visited): return True return False"},{"question":"# Scenario You are working on a project that involves managing and processing large datasets. Your team needs a way to efficiently find and return the k-th smallest element in a list. Your task is to implement an algorithm that can achieve this efficiently. # Problem Statement Implement a function `find_kth_smallest` that returns the k-th smallest element in a list. # Function Signature ```python def find_kth_smallest(collection: List[int], k: int) -> int: ``` # Input * A list of integers (`collection`) with a length of at most 10^4. * An integer `k` (1 â‰¤ k â‰¤ length of the list) representing the position (1-based index) of the smallest element to be returned. # Output * An integer representing the k-th smallest element in the list. # Constraints * You may not sort the entire list as it may be inefficient for large datasets. * Utilize a more efficient algorithm that can find the k-th smallest element in expected O(n) time complexity. # Examples ```python assert find_kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7 assert find_kth_smallest([7, 10, 4, 3, 20, 15], 4) == 10 assert find_kth_smallest([12, 3, 5, 7, 19], 2) == 5 assert find_kth_smallest([-1, -3, 5, 3, -4], 1) == -4 assert find_kth_smallest([1], 1) == 1 ``` # Performance * The function should handle edge cases efficiently and should not raise any errors for valid inputs. Write your implementation below:","solution":"from typing import List import random def find_kth_smallest(collection: List[int], k: int) -> int: def partition(nums, left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quickselect(nums, left, right, k_smallest): if left == right: return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(nums, left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(nums, left, pivot_index - 1, k_smallest) else: return quickselect(nums, pivot_index + 1, right, k_smallest) return quickselect(collection, 0, len(collection) - 1, k - 1)"},{"question":"# Problem Statement: You are given a list of integers representing the heights of plants in a garden, arranged sequentially from left to right. A gardener waters the plants in a linear sequence and each plant is watered for a specific duration, making it grow by a certain height increment for each unit of time. Your task is to write a function `watering_plants` that calculates the maximum height of the plants after a specified duration of watering time, given the initial heights and the growth rate per unit time for each plant. # Function Signature: ```python def watering_plants(heights: list, growth_rate: list, time: int) -> int: pass ``` # Input: * `heights` (list): A list of integers where each integer represents the initial height of a plant. * `growth_rate` (list): A list of integers where each integer represents the growth rate per unit time of the corresponding plant. * `time` (int): The total time units for which the plants are watered. # Output: * `int`: The maximum height of any plant after the specified time duration. # Constraints: * `len(heights) == len(growth_rate)` (The number of elements in `heights` and `growth_rate` is the same) * 1 <= `len(heights)` <= 10^3 * 1 <= `heights[i]`, `growth_rate[i]`, `time` <= 10^3 # Example: ```python # Example 1: heights = [2, 3, 1] growth_rate = [1, 2, 1] time = 4 output = 11 # Plant 2 (height = 3 + 2*4 = 11) # Example 2: heights = [1, 2, 3] growth_rate = [2, 1, 2] time = 5 output = 13 # Plant 3 (height = 3 + 2*5 = 13) # Example 3: heights = [5] growth_rate = [10] time = 5 output = 55 # Single plant (height = 5 + 10*5 = 55) ``` # Additional Information: * Ensure the solution properly handles lists of varying lengths and different growth rates. * The solution should optimize for both time and space complexity as much as possible. * Consider edge cases such as the minimum and maximum possible values for heights, growth rates, and time. # Requirements: Craft a solution that demonstrates proficiency in array manipulation and a clear understanding of linear growth calculations.","solution":"def watering_plants(heights, growth_rate, time): Calculates the maximum height of plants after watering for a specified duration. Args: heights (list): Initial heights of the plants. growth_rate (list): Growth rates per unit time for each plant. time (int): Total time of watering. Returns: int: The maximum height of any plant after the specified time. max_height = 0 for h, r in zip(heights, growth_rate): final_height = h + r * time if final_height > max_height: max_height = final_height return max_height"},{"question":"# Problem Description You are tasked with developing a function to solve a water jug problem using the Breadth-First Search (BFS) algorithm. Given two jugs with different capacities and an infinite water supply, your goal is to determine if it is possible to measure exactly a target amount of water using the jugs. # Function Signature ```python def water_jug_problem(jug1_capacity: int, jug2_capacity: int, target: int) -> bool: ``` # Expected Input and Output * **Input**: The function takes three integers: - `jug1_capacity`: An integer representing the capacity of the first jug. - `jug2_capacity`: An integer representing the capacity of the second jug. - `target`: An integer representing the target amount of water to measure. * **Output**: The function should return a boolean value: - `True` if it is possible to measure exactly the target amount of water using the jugs. - `False` if it is not possible. # Constraints 1. 1 â‰¤ `jug1_capacity`, `jug2_capacity`, `target` â‰¤ 10^6 2. The capacities of the jugs and the target can be any positive integer within the given range. 3. The function should be optimized for performance. # Performance Requirements * The solution should efficiently handle large capacity values considering time and space complexity. # Example Input ```python jug1_capacity = 5 jug2_capacity = 3 target = 4 ``` Output ```python True ``` Explanation You can measure 4 liters by the following steps: - Fill the 5-liter jug. - Pour water from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. - Now, you have 2 liters left in the 5-liter jug. - Empty the 3-liter jug. - Pour the 2 liters from the 5-liter jug to the 3-liter jug. - Fill the 5-liter jug again. - Pour water from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. - Now you have exactly 4 liters in the 5-liter jug. # Additional Information * Use the Breadth-First Search (BFS) algorithm to explore all possible states (combinations of water in the two jugs) to reach the target measurement. # Task Implement the function `water_jug_problem` that determines if it is possible to measure the exact target amount of water using the given jugs. ```python def water_jug_problem(jug1_capacity: int, jug2_capacity: int, target: int) -> bool: from collections import deque # Check if we can measure the target with the given capacities if target > jug1_capacity + jug2_capacity: return False if target % math.gcd(jug1_capacity, jug2_capacity) != 0: return False # Use BFS to explore states visited = set() queue = deque([(0, 0)]) while queue: a, b = queue.popleft() if a == target or b == target or a + b == target: return True # Mark the state as visited if (a, b) in visited: continue visited.add((a, b)) # Possible next states states = [ (jug1_capacity, b), # Fill jug1 (a, jug2_capacity), # Fill jug2 (0, b), # Empty jug1 (a, 0), # Empty jug2 (min(a + b, jug1_capacity), max(0, a + b - jug1_capacity)), # Pour jug2 into jug1 (max(0, a + b - jug2_capacity), min(a + b, jug2_capacity)) # Pour jug1 into jug2 ] for state in states: if state not in visited: queue.append(state) return False # You may test your implementation using the statement below if __name__ == \\"__main__\\": print(water_jug_problem(5, 3, 4)) # Example test ```","solution":"from collections import deque import math def water_jug_problem(jug1_capacity: int, jug2_capacity: int, target: int) -> bool: Return True if we can measure the exact target amount of water using the two jugs with given capacities. # Check if the target is greater than the total capacity of both jugs if target > jug1_capacity + jug2_capacity: return False # Check if the target is reachable via the greatest common divisor (GCD) of jug capacities if target % math.gcd(jug1_capacity, jug2_capacity) != 0: return False # Use BFS to explore all possible states visited = set() queue = deque([(0, 0)]) while queue: a, b = queue.popleft() if a == target or b == target or a + b == target: return True # Mark the state as visited if (a, b) in visited: continue visited.add((a, b)) # Possible next states states = [ (jug1_capacity, b), # Fill jug1 (a, jug2_capacity), # Fill jug2 (0, b), # Empty jug1 (a, 0), # Empty jug2 (min(a + b, jug1_capacity), max(0, a + b - jug1_capacity)), # Pour jug2 into jug1 (max(0, a + b - jug2_capacity), min(a + b, jug2_capacity)) # Pour jug1 into jug2 ] for state in states: if state not in visited: queue.append(state) return False"},{"question":"# Scenario You are developing an application where one of the features includes automatically correcting the layout of words in given paragraphs. Specifically, you need to ensure that any consecutive spaces in the text are reduced to a single space while maintaining the order and content of the words. # Problem Statement Implement a function `normalize_spacing(paragraph: str) -> str` that takes in a string `paragraph` representing a paragraph of text. The function should return a new string where all sequences of consecutive spaces are replaced by a single space. # Input and Output Formats * The function will receive a single string as an input parameter. * The function will return a string with normalized spacing. # Constraints * The input string can be of length from (1) to (10^6). # Performance Requirements * The implementation should have linear time complexity (O(n)), where (n) is the length of the input string. * The implementation should use only a constant amount of additional space. # Example Cases ```python >>> normalize_spacing(\\"This is a sample paragraph.\\") \\"This is a sample paragraph.\\" >>> normalize_spacing(\\" Another example with irregular spacing.\\") \\"Another example with irregular spacing.\\" >>> normalize_spacing(\\" Leading and trailing spaces are tricky. \\") \\"Leading and trailing spaces are tricky.\\" >>> normalize_spacing(\\"SingleWord\\") \\"SingleWord\\" >>> normalize_spacing(\\" \\") \\"\\" >>> normalize_spacing(\\"Multiple spaces everywhere!\\") \\"Multiple spaces everywhere!\\" ``` # Additional Notes * Ensure that the function handles cases with leading, trailing, and middle spaces correctly. * Consider edge cases such as strings with no words or empty spaces.","solution":"def normalize_spacing(paragraph: str) -> str: Takes in a string paragraph and reduces any consecutive spaces to a single space. Leading or trailing spaces are removed if present. return \' \'.join(paragraph.split())"},{"question":"# Question: Efficiently Compute Fibonacci Sequence Objective: In this task, you need to implement a function to efficiently compute the Fibonacci sequence up to a given number of terms. The Fibonacci sequence is a series of numbers where the next term is the sum of the previous two terms, starting with 0 and 1. Part 1: Fibonacci Number Generator 1. **Function: `fibonacci`** * Generate a list of the first `n` Fibonacci numbers. * The function should use an iterative approach for efficiency. ```python def fibonacci(n: int) -> list: Generate a list of the first `n` Fibonacci numbers. Parameters: n (int): The number of terms to generate. Returns: list: A list containing the first `n` Fibonacci numbers. pass # Your implementation ``` 2. **Function: `nth_fibonacci`** * Calculate the `k`-th Fibonacci number in the sequence using an iterative method. ```python def nth_fibonacci(k: int) -> int: Calculate the `k`-th Fibonacci number. Parameters: k (int): The position of the Fibonacci number to calculate. Returns: int: The `k`-th Fibonacci number. pass # Your implementation ``` Constraints & Requirements: * The value of `n` and `k` should be non-negative integers. * Ensure the function handles edge cases such as `n = 0` or `k = 0`. Example: ```python print(fibonacci(10)) # Example Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] print(nth_fibonacci(10)) # Output: 34 print(fibonacci(0)) # Output: [] print(nth_fibonacci(1)) # Output: 1 ``` Ensure your implementations are efficient and accurately compute the Fibonacci sequence as specified.","solution":"def fibonacci(n: int) -> list: Generate a list of the first `n` Fibonacci numbers. Parameters: n (int): The number of terms to generate. Returns: list: A list containing the first `n` Fibonacci numbers. if n == 0: return [] if n == 1: return [0] fib_seq = [0, 1] while len(fib_seq) < n: fib_seq.append(fib_seq[-1] + fib_seq[-2]) return fib_seq def nth_fibonacci(k: int) -> int: Calculate the `k`-th Fibonacci number. Parameters: k (int): The position of the Fibonacci number to calculate. Returns: int: The `k`-th Fibonacci number. if k == 0: return 0 if k == 1: return 1 a, b = 0, 1 for _ in range(2, k + 1): a, b = b, a + b return b"},{"question":"# Question: Efficient Palindrome Number Check Background: You need to implement a function that checks whether a given number is a palindrome. A palindrome is a number that reads the same backward as forward. This check is useful in various algorithmic problems and contexts, such as data validation, error correction, and cryptography. Requirements: 1. Implement a function `is_palindrome(number: int) -> bool` that determines if a given number is a palindrome. 2. The function should handle integers greater than or equal to 0. 3. Ensure optimized performance so the function works efficiently for large inputs. Input: - An integer `number` where `0 <= number <= 10^9`. Output: - Return `True` if `number` is a palindrome, otherwise return `False`. Constraints: - The function should raise a `ValueError` if the input is not a non-negative integer. Examples: ```python assert is_palindrome(0) == True assert is_palindrome(1) == True assert is_palindrome(121) == True assert is_palindrome(123) == False assert is_palindrome(1221) == True assert is_palindrome(1331) == True assert is_palindrome(12321) == True assert is_palindrome(12345) == False assert is_palindrome(987654432123456789) == False assert is_palindrome(98765432123456789) == True ``` Hints: - You can convert the number to a string to check if it reads the same backward and forward. - Consider the performance implications of different approaches, such as direct string manipulation versus mathematical techniques. - Avoid unnecessary computations by making early exits when a mismatch is found.","solution":"def is_palindrome(number): Determines if the given number is a palindrome. Args: number (int): The number to check Returns: bool: True if the number is a palindrome, False otherwise if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer.\\") # Convert the number to string num_str = str(number) # Check if the string reads the same backward and forward return num_str == num_str[::-1]"},{"question":"# Linked List: Detect Cycle Length Objective You are to implement a function that detects if a linked list contains a cycle. If a cycle is found, the function should return the length of the cycle. Task Write a function `detect_cycle_length` that identifies a cycle in a singly linked list and returns the length of the cycle. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle_length(head: ListNode) -> int: Detects if a cycle exists in the linked list and returns the length of the cycle. Arguments: head: The head node of the singly linked list. Returns: The length of the cycle (int) if a cycle exists, otherwise -1. Constraints: The linked list can be empty (head is None). You must use Floydâ€™s Cycle-Finding Algorithm (Tortoise and Hare). ``` Constraints 1. The linked list can be empty. 2. You must use Floydâ€™s Cycle-Finding Algorithm for detecting and calculating the cycle length. 3. Each node in the linked list has a unique value for identification purposes. Performance Requirements - Your implementation should efficiently handle linked lists with up to 10^4 nodes within a reasonable time frame. Example Usage ```python # Helper function to create a list with a cycle for testing def create_cycle_list(values, cycle_idx): head = ListNode(values[0]) current = head nodes = [head] for value in values[1:]: new_node = ListNode(value) current.next = new_node nodes.append(new_node) current = new_node if cycle_idx != -1: current.next = nodes[cycle_idx] return head # Example list with a cycle (4 -> 2 -> 0 -> -4 -> 2 ...) head = create_cycle_list([4, 2, 0, -4], 1) print(detect_cycle_length(head)) # Output: 3 ```","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle_length(head: ListNode) -> int: Detects if a cycle exists in the linked list and returns the length of the cycle. Arguments: head: The head node of the singly linked list. Returns: The length of the cycle (int) if a cycle exists, otherwise -1. if not head: return -1 slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected cycle_length = 1 current = slow.next while current != slow: cycle_length += 1 current = current.next return cycle_length return -1"},{"question":"**Question: Implement a Balanced Binary Search Tree (BST)** **Context:** Bob is working on a database indexing system and needs to keep data in a balanced structure to ensure efficient lookup, insertion, and deletion. He decides to implement a self-balancing Binary Search Tree (BST) to maintain balanced operations. **Task:** Your task is to create a class `BalancedBST` with methods for inserting, deleting, and searching elements while maintaining a balanced BST. Specifically, use the AVL tree balancing mechanism, which rebalances the tree with rotations after every insertion or deletion to ensure the height difference between left and right subtrees is at most 1. **Class and Function Signatures:** ```python class BalancedBST: def __init__(self): pass def insert(self, value: int) -> None: pass def delete(self, value: int) -> None: pass def search(self, value: int) -> bool: pass ``` **Input:** - `value` (int): The integer value to be inserted, deleted, or searched in the BST. **Output:** - The `insert` and `delete` methods do not return any value. - The `search` method returns a boolean indicating whether the given value is present in the BST. **Constraints:** - The tree may contain up to (10^5) nodes. - The values in the tree are integers ranging from (-10^9) to (10^9). **Examples:** 1. ```python bst = BalancedBST() bst.insert(10) bst.insert(20) bst.insert(5) assert bst.search(10) == True assert bst.search(15) == False bst.delete(5) assert bst.search(5) == False ``` **Additional Notes:** 1. Use rotations to balance the tree after insertions and deletions. 2. Make sure the `search` operation is efficient (O(log n) time complexity). 3. Include helper methods for performing left and right rotations if needed. 4. Ensure that all operations (insertion, deletion, search) maintain the AVL tree properties.","solution":"class BalancedBST: class Node: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, value: int) -> None: self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return self.Node(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and value < node.left.value: return self._right_rotate(node) if balance < -1 and value > node.right.value: return self._left_rotate(node) if balance > 1 and value > node.left.value: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and value < node.right.value: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def _delete(self, node, value): if not node: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, value: int) -> bool: return self._search(self.root, value) def _search(self, node, value): if not node: return False if node.value == value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Multiply Large Numbers Given two strings `num1` and `num2` that represent large non-negative integers, write a function `multiply_large_numbers(num1: str, num2: str) -> str` to return the product of the numbers, also as a string. The numbers can be so large that they might not fit into a standard data type for integer arithmetic in most programming languages, hence are provided as strings. Input * `num1`: A string representing the first large non-negative integer (1 â‰¤ `len(num1)` â‰¤ 200). * `num2`: A string representing the second large non-negative integer (1 â‰¤ `len(num2)` â‰¤ 200). Output * Return a string representing the product of the two input numbers. Constraints - The input strings `num1` and `num2` will consist of digits only and will not have leading zeros (except when the number itself is zero). - Your solution should handle large products efficiently. Example ```python def multiply_large_numbers(num1: str, num2: str) -> str: pass print(multiply_large_numbers(\\"123\\", \\"456\\")) # Expected output: \\"56088\\" print(multiply_large_numbers(\\"0\\", \\"999\\")) # Expected output: \\"0\\" ``` Use this function signature to implement your solution. Ensure that your solution is optimized for the input constraints provided.","solution":"def multiply_large_numbers(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" n1, n2 = len(num1), len(num2) result = [0] * (n1 + n2) for i in range(n1 - 1, -1, -1): for j in range(n2 - 1, -1, -1): mul = (ord(num1[i]) - ord(\'0\')) * (ord(num2[j]) - ord(\'0\')) sum_with_current = mul + result[i + j + 1] result[i + j + 1] = sum_with_current % 10 result[i + j] += sum_with_current // 10 result_str = \'\'.join(map(str, result)) return result_str.lstrip(\'0\')"},{"question":"# Task Management System Simulation You are asked to develop a basic task management system that allows creating, deleting, and displaying tasks. Each task has an ID, a title, and a description. # Problem Statement Implement a class `TaskManager` that supports the following operations: - Adding a task with a unique identifier, title, and description. - Deleting a task by its identifier. - Displaying all tasks. # Constraints 1. There can be up to 1000 tasks in the system. 2. Task titles and descriptions are strings with a maximum length of 100 characters. 3. Task identifiers are unique integers in the range 1 to 10^5. # Input Format - Method signature and respective arguments are given for each operation. # Output Format - Methods should return `None`, unless specified otherwise. # Method Signatures ```plaintext - def add_task(self, task_id: int, title: str, description: str) -> None - def delete_task(self, task_id: int) -> None - def display_tasks(self) -> List[str] ``` # Example ```python task_manager = TaskManager() task_manager.add_task(1, \\"Design Module\\", \\"Create the initial design for the module\\") task_manager.add_task(2, \\"Implement Module\\", \\"Develop the module based on the design\\") task_manager.display_tasks() # Output should be: # [ # \\"ID: 1, Title: Design Module, Description: Create the initial design for the module\\", # \\"ID: 2, Title: Implement Module, Description: Develop the module based on the design\\" # ] task_manager.delete_task(1) task_manager.display_tasks() # Output should be: # [ # \\"ID: 2, Title: Implement Module, Description: Develop the module based on the design\\" # ] ``` # Implementation Complete the `TaskManager` class with the three methods as specified. Ensure thread-safety if modifying shared resources. ```python class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id: int, title: str, description: str) -> None: if len(title) > 100 or len(description) > 100: raise ValueError(\\"Title or description length exceeds maximum allowed length\\") self.tasks[task_id] = { \\"title\\": title, \\"description\\": description } def delete_task(self, task_id: int) -> None: if task_id in self.tasks: del self.tasks[task_id] else: raise KeyError(f\\"Task ID {task_id} not found\\") def display_tasks(self) -> List[str]: result = [] for task_id, details in self.tasks.items(): result.append(f\\"ID: {task_id}, Title: {details[\'title\']}, Description: {details[\'description\']}\\") return result ``` # Notes 1. Ensure the `add_task` method raises a `ValueError` for invalid data lengths. 2. Ensure the `delete_task` method raises a `KeyError` for non-existent task IDs. 3. The `display_tasks` method should return a list of strings formatted as specified in the example.","solution":"class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id: int, title: str, description: str) -> None: if len(title) > 100 or len(description) > 100: raise ValueError(\\"Title or description length exceeds maximum allowed length\\") if task_id in self.tasks: raise ValueError(\\"Task ID already exists\\") self.tasks[task_id] = { \\"title\\": title, \\"description\\": description } def delete_task(self, task_id: int) -> None: if task_id in self.tasks: del self.tasks[task_id] else: raise KeyError(f\\"Task ID {task_id} not found\\") def display_tasks(self) -> list[str]: result = [] for task_id, details in self.tasks.items(): result.append(f\\"ID: {task_id}, Title: {details[\'title\']}, Description: {details[\'description\']}\\") return result"},{"question":"Number Frequency Counter You are required to write a pair of functions that analyze a given text for numerical data and report their frequency of occurrence. The first function should extract all the numbers from the text, and the second function should count the frequency of each unique number. Requirements: 1. **Function `extract_numbers`**: - Takes a string of text as input. - Extracts all the numbers from the text. - Returns a list of integers. 2. **Function `count_frequencies`**: - Takes a list of integers as input. - Returns a dictionary where keys are the unique numbers and values are their frequency counts. 3. **Constraints**: - Numbers can appear in any part of the text including words or other numbers (e.g., \\"12abc34\\" should be treated as containing 12 and 34). - The input text can include any printable ASCII characters. 4. **Edge Cases**: - If no numbers are found, `extract_numbers` should return an empty list. - Ensure the functions handle potential exceptions gracefully. Input & Output Formats: * The `extract_numbers` function should return a list of integers extracted from the text. * The `count_frequencies` function should return a dictionary where the keys are integers and the values are the counts of each integer in the list. Example: Given the input text `\\"123 apples and 987 bananas were sold for 456 and 123 more\\"`: 1. The `extract_numbers` function should return the list `[123, 987, 456, 123]`. 2. The `count_frequencies` function should return the dictionary `{123: 2, 987: 1, 456: 1}`. ```python import re from collections import defaultdict def extract_numbers(text: str) -> list: try: # Extract all the numbers using regex numbers = re.findall(r\'d+\', text) return list(map(int, numbers)) except Exception as e: print(f\\"An error occurred: {e}\\") return [] def count_frequencies(numbers: list) -> dict: try: frequency_dict = defaultdict(int) for number in numbers: frequency_dict[number] += 1 return dict(frequency_dict) except Exception as e: print(f\\"An error occurred: {e}\\") return {} if __name__ == \\"__main__\\": input_text = \\"123 apples and 987 bananas were sold for 456 and 123 more\\" numbers = extract_numbers(input_text) frequency_count = count_frequencies(numbers) print(\\"Extracted numbers:\\", numbers) print(\\"Frequency count:\\", frequency_count) ```","solution":"import re from collections import defaultdict def extract_numbers(text: str) -> list: Extracts all the numbers from the input text and returns a list of integers. # Extract all the numbers using regex numbers = re.findall(r\'d+\', text) return list(map(int, numbers)) def count_frequencies(numbers: list) -> dict: Takes a list of integers and returns a dictionary where keys are the unique numbers and values are the frequency counts of each number. frequency_dict = defaultdict(int) for number in numbers: frequency_dict[number] += 1 return dict(frequency_dict)"},{"question":"# Balanced Strings Finder Given the following problem: Consider a string composed of characters \'L\' and \'R\'. A balanced string is defined as one that has an equal number of \'L\' and \'R\' characters. Your task is to find the maximum number of balanced substrings that can be obtained from an input string. **Task**: Implement a function `max_balanced_substrings(s: str) -> int` that returns the maximum number of balanced substrings that can be derived from the given string. Function Signature ```python def max_balanced_substrings(s: str) -> int: ``` Input * `s`: A string containing only characters \'L\' and \'R\'. The length of the string ( |s| ) is in the range ( 1 leq |s| leq 10^4 ). Output * Return an integer representing the maximum number of balanced substrings. Constraints * The input string will contain only the characters \'L\' and \'R\'. * The length of the balanced substrings may vary, but they should contain equal counts of \'L\' and \'R\'. Example ```python assert max_balanced_substrings(\\"RLRRLLRLRL\\") == 4 assert max_balanced_substrings(\\"RLLLLRRRLR\\") == 3 assert max_balanced_substrings(\\"LLLLRRRR\\") == 1 assert max_balanced_substrings(\\"RLRLRLRLRL\\") == 5 ``` Additional Notes * Ensure your solution efficiently handles the given constraints. * Consider edge cases such as very short strings or strings with a single all-balanced region. * Focus on the implementation that checks for balance condition while iterating through the string to count substrings efficiently.","solution":"def max_balanced_substrings(s: str) -> int: count = 0 balance = 0 for char in s: if char == \'L\': balance += 1 else: # char == \'R\' balance -= 1 if balance == 0: count += 1 return count"},{"question":"**Scenario**: You have been contracted to develop a Python application that processes the scores of students in various subjects. Your task is to create a function that will determine the top students in each subject based on their scores. **Task**: Write a function `top_students(scores: list[dict], n: int) -> dict[str, list[str]]` that takes a list of dictionaries where each dictionary represents a student\'s scores in various subjects, and an integer `n` representing the number of top students to return for each subject. The function should return a dictionary where each key is a subject, and the value is a list of students\' names who are the top `n` scorers in that subject. # Functional Requirements 1. **Input**: - `scores`: A list of dictionaries. Each dictionary has the keys `name` (student\'s name) and other keys representing subjects with their respective scores. Example: ```python [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"science\\": 90}, {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 80}, {\\"name\\": \\"Charlie\\", \\"math\\": 95, \\"science\\": 85} ] ``` - `n`: An integer representing the number of top students to return for each subject. 2. **Output**: - A dictionary with each subject as a key and a list of top `n` students\' names as values. # Constraints & Performance - The function should handle up to 1000 students and up to 10 subjects efficiently. # Example ```python scores = [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"science\\": 90}, {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 80}, {\\"name\\": \\"Charlie\\", \\"math\\": 95, \\"science\\": 85} ] n = 2 expected_output = { \\"math\\": [\\"Alice\\", \\"Charlie\\"], \\"science\\": [\\"Alice\\", \\"Charlie\\"] } ``` # Notes - If there is a tie, include all students with the top scores, which may result in more than `n` students for that subject. - You may assume that each student has a unique name. - Use sorting or any other feasible method to determine the top `n` students. ```python def top_students(scores: list[dict], n: int) -> dict[str, list[str]]: from collections import defaultdict subject_scores = defaultdict(list) for student in scores: name = student.pop(\\"name\\") for subject, score in student.items(): subject_scores[subject].append((score, name)) top_students_dict = {} for subject, students in subject_scores.items(): students.sort(key=lambda x: x[0], reverse=True) top_students = [name for score, name in students[:n]] top_students_dict[subject] = top_students return top_students_dict ```","solution":"def top_students(scores: list[dict], n: int) -> dict[str, list[str]]: from collections import defaultdict # Dictionary to hold scores for each subject subject_scores = defaultdict(list) # Populate the subject_scores dictionary for student in scores: name = student[\\"name\\"] for subject, score in student.items(): if subject != \\"name\\": subject_scores[subject].append((score, name)) # Dictionary to hold the top students for each subject top_students_dict = {} # Determine the top students for each subject for subject, students in subject_scores.items(): # Sort students based on score in descending order students.sort(key=lambda x: x[0], reverse=True) # Get the top n scores top_students = [name for score, name in students[:n]] # Include students with the same score if there is a tie additional_students = set() if len(students) > n: top_n_score = students[n-1][0] for i in range(n, len(students)): if students[i][0] == top_n_score: additional_students.add(students[i][1]) else: break top_students += list(additional_students) top_students_dict[subject] = top_students return top_students_dict"},{"question":"# Coding Assessment Question Scenario You are developing a resource management system that keeps track of tasks and their dependencies. Each task can only be executed if all its dependencies have been completed. Tasks are represented by unique integer identifiers, and dependencies are given as a list of pairs where the first element is the task and the second element is a task it depends on. Your task is to design a function that determines the order in which tasks can be executed. If there are multiple valid orders, return any one of them. If it\'s impossible to execute all tasks due to a cycle in dependencies, return an empty list. Function Definition Write a function `find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]` that takes a list of tasks and a list of dependencies and returns a list representing the order in which tasks can be executed. Input * `tasks` (List[int]): A list of unique task identifiers (1 â‰¤ tasks[i] â‰¤ 1000). * `dependencies` (List[Tuple[int, int]]): A list of pairs representing dependencies (0 â‰¤ len(depencies) â‰¤ 2000). Output * (List[int]): A list representing the order in which tasks can be executed. If no valid order exists, return an empty list. Example ```python >>> find_task_order([1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) [1, 2, 3, 4] >>> find_task_order([1, 2, 3], [(1, 2), (2, 3), (3, 1)]) [] ``` Constraints * Each task is represented by a unique integer. * If a task has no dependencies, it can be executed at any time. Performance Requirements Your solution should efficiently handle the upper limit of task and dependency constraints. Edge Cases to Consider * A task list with no dependencies should return tasks in any order. * Cyclic dependencies should result in an empty list. * Ensure that the solution works even for tasks with a large number of dependencies. Hints * Consider using topological sorting to determine the order of tasks. * Use graph representations to model dependencies and detect cycles efficiently.","solution":"from collections import defaultdict, deque from typing import List, Tuple def find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: Determines the order in which tasks can be executed based on given dependencies. Returns an empty list if no valid order exists due to a cyclic dependency. # Initialize the graph and in-degree of nodes graph = defaultdict(list) in_degree = {task: 0 for task in tasks} # Build the graph and in-degree map for dep in dependencies: parent, child = dep graph[parent].append(child) in_degree[child] += 1 # Queue for tasks with no incoming dependencies queue = deque([task for task in tasks if in_degree[task] == 0]) task_order = [] while queue: task = queue.popleft() task_order.append(task) # Decrease the in-degree of neighboring nodes for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all tasks are in the task_order, return it if len(task_order) == len(tasks): return task_order else: return []"},{"question":"# Problem Statement Write a function that implements the \\"Autocomplete\\" feature. Given an array of strings `words` representing a dictionary of valid words, and a prefix string `prefix`, return all words from the dictionary that start with the given prefix. # Function Signature ```python def autocomplete(words: list[str], prefix: str) -> list[str]: ... ``` # Input * A list of strings `words`. * A string `prefix`. # Output * A list of strings containing all words from the input list that start with the given prefix. # Constraints * 1 <= len(words) <= 10^5 * 1 <= len(words[i]) <= 100 * 1 <= len(prefix) <= 100 # Requirements * The function should efficiently filter and return words that start with the given prefix. * Consider using a suitable data structure to optimize the search, like a Trie. * Ensure the solution handles both lowercase and uppercase letters appropriately. # Examples Example 1 Input: ```python words = [\\"apple\\", \\"appetizer\\", \\"banana\\", \\"application\\", \\"apricot\\", \\"blueberry\\"] prefix = \\"app\\" ``` Output: ```python [\\"apple\\", \\"appetizer\\", \\"application\\"] ``` Example 2 Input: ```python words = [\\"sun\\", \\"moon\\", \\"star\\", \\"sunny\\", \\"starlight\\", \\"solar\\"] prefix = \\"sta\\" ``` Output: ```python [\\"star\\", \\"starlight\\"] ``` # Notes * Consider ways to optimize the search process for large dictionaries. * Pay attention to edge cases such as an empty prefix or no matching words in the dictionary. * The output list can be in any order but must contain all valid matches. # Hint Consider pre-processing the dictionary into a Trie structure to allow efficient prefix-based lookups to improve performance, especially when dealing with a large list of words.","solution":"def autocomplete(words, prefix): Return all words from the dictionary that start with the given prefix. return [word for word in words if word.startswith(prefix)]"},{"question":"# Problem Statement You are working on developing a software module for a weather forecasting system. A critical task in this module is to smooth out sensor data measurements to remove noise and unnecessary fluctuations. One common method to achieve this is through a Moving Average filter. # Implementation Details Implement the `moving_average` function in Python using the given signature: ```python def moving_average(data: List[float], window_size: int) -> List[float]: pass ``` * **Input**: - `data` (List[float]): A list of floating-point numbers representing the sensor data to be smoothed. - `window_size` (int): The number of data points to consider in each averaging window. * **Output**: - Returns a list of floating-point numbers representing the smoothed data, where each value is the average of the current and `window_size - 1` preceding elements. # Example ```python >>> moving_average([1.0, 2.0, 3.0, 4.0, 5.0], 3) [2.0, 3.0, 4.0] >>> moving_average([10.0, 20.0, 30.0], 2) [15.0, 25.0] ``` # Requirements Ensure your function adheres to the following: 1. Calculate the moving average correctly for each position in the input data list. 2. Handle edge cases gracefully, such as when `window_size` is larger than the length of `data`. 3. Do not use external libraries such as NumPy or Pandas; rely on basic Python constructs. # Notes - You can assume that the window size is a positive integer. - Think about the computational complexity and aim for an efficient implementation. - Consider how you will handle the boundaries of the data list, where there are not enough preceding elements to fill a complete window. Ensure your solution passes the provided examples, which will be used to verify its correctness.","solution":"from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: if window_size > len(data): return [] result = [] window_sum = sum(data[:window_size]) result.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] result.append(window_sum / window_size) return result"},{"question":"# Question Description You are given a matrix `grid` of size `m x n` filled with non-negative integers. Your task is to write a Python function that finds the maximum sum of a rectangle in the `grid`. A rectangle in this context is defined as any subarray of the `grid` that forms a contiguous block of elements. The function should utilize dynamic programming or other efficient algorithmic techniques to compute the maximum sum. # Function Signature ```python def max_sum_rectangle(grid: list[list[int]]) -> int: Finds the maximum sum of a rectangle in the grid. Parameters: grid (list[list[int]]): A 2D list of non-negative integers representing the grid. Returns: int: The maximum sum of any rectangle within the grid. Constraints: - 1 <= m, n <= 100 - 0 <= grid[i][j] <= 100 ``` # Input - A 2D list `grid` where `m` is the number of rows and `n` is the number of columns. # Output - An integer representing the maximum sum of any rectangle in the grid. # Example ```python >>> grid = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> max_sum_rectangle(grid) 29 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ] >>> max_sum_rectangle(grid) 45 >>> grid = [[-1, -2, -3, -4], [-5, -6, -7, -8], [-9, -10, -11, -12]] >>> max_sum_rectangle(grid) -1 ``` # Constraints - Ensure `grid` dimensions are within the specified range. - Handle edge cases such as all negative values or very small grids. # Notes You should focus on optimizing the algorithm to handle the largest cases within the constraints efficiently, avoiding brute force solutions where possible.","solution":"def max_sum_rectangle(grid: list[list[int]]) -> int: Finds the maximum sum of a rectangle in the grid. Parameters: grid (list[list[int]]): A 2D list of non-negative integers representing the grid. Returns: int: The maximum sum of any rectangle within the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) def kadane(arr): Kadane\'s algorithm to find max sum subarray max_sum = float(\'-inf\') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum max_rectangle_sum = float(\'-inf\') # Temporary array to store row sums for left in range(cols): temp = [0] * rows for right in range(left, cols): for row in range(rows): temp[row] += grid[row][right] max_rectangle_sum = max(max_rectangle_sum, kadane(temp)) return max_rectangle_sum"},{"question":"# Coding Assessment: K-Nearest Neighbors (KNN) Algorithm Implementation **Objective**: Implement the K-Nearest Neighbors (KNN) algorithm to classify a set of instances. Use the provided structure and existing utility functions to create new components, demonstrating your understanding of the KNN approach. # Problem Statement Using KNN, classify instances based on a majority vote of the nearest neighbors. Implement the required functionality to predict the class of unknown instances. Handle edge cases and ensure the algorithm adheres to the given specifications. # Scenario A medical research company wants to classify patients into different risk categories for a disease based on their health metrics. They have historical patient data with known risk classifications. Your role is to implement a KNN classifier and predict the risk category for new patients given their health metrics. # Requirements 1. **Function to Compute Euclidean Distance**: * Input: `point1` (list of feature values), `point2` (list of feature values). * Output: Euclidean distance between the two points. 2. **Function to Determine K Nearest Neighbors**: * Input: `training_features` (2D list of feature values), `training_labels` (list of corresponding labels), `unknown_feature` (list of feature values for an unknown instance), `k` (number of neighbors to consider). * Output: List of labels of the k nearest neighbors. 3. **Function to Predict Class**: * Input: `neighbors_labels` (list of labels of k nearest neighbors). * Output: Predicted class for the unknown instance based on majority vote. # Input and Output Format **Function 1: compute_euclidean_distance** ```python def compute_euclidean_distance(point1: list[float], point2: list[float]) -> float: pass ``` **Function 2: determine_k_nearest_neighbors** ```python def determine_k_nearest_neighbors(training_features: list[list[float]], training_labels: list[int], unknown_feature: list[float], k: int) -> list[int]: pass ``` **Function 3: predict_class** ```python def predict_class(neighbors_labels: list[int]) -> int: pass ``` # Constraints * Assume all features are continuous and follow a Gaussian distribution. * Ensure k is a positive integer less than or equal to the number of training instances. * Handle ties by selecting the smallest label numerically. # Example ```python # Example data training_features = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], ] training_labels = [0, 0, 1, 1] # Compute distance dist = compute_euclidean_distance([1.0, 2.0], [5.0, 8.0]) print(dist) # Expected output: 7.211102550927978 # Determine k nearest neighbors neighbors = determine_k_nearest_neighbors(training_features, training_labels, [1.2, 2.1], 3) print(neighbors) # Expected output: [0, 0, 1] # Predict class based on neighbors predicted = predict_class(neighbors) print(predicted) # Expected output: 0 ``` * **Edge Cases**: * Handle instances where the number of training data points is less than k. * Ensure proper handling of features with identical distances. # Submission Complete the missing functions to compute the Euclidean distance, identify the k nearest neighbors, and predict the class for unknown instances. Ensure your solution passes provided examples and edge cases effectively.","solution":"from collections import Counter import math def compute_euclidean_distance(point1, point2): Returns the Euclidean distance between two points. Parameters: point1 (list of float): The first point. point2 (list of float): The second point. Returns: float: The Euclidean distance between the two points. return math.sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2))) def determine_k_nearest_neighbors(training_features, training_labels, unknown_feature, k): Returns the labels of the k nearest neighbors to the unknown feature. Parameters: training_features (list of list of float): The feature values of the training set. training_labels (list of int): The labels of the training set. unknown_feature (list of float): The feature values of the unknown instance. k (int): The number of neighbors to consider. Returns: list of int: The labels of the k nearest neighbors. distances = [(compute_euclidean_distance(unknown_feature, tf), label) for tf, label in zip(training_features, training_labels)] # Sort by distance distances.sort(key=lambda x: x[0]) # Extract the labels of the k nearest neighbors nearest_neighbors = [label for _, label in distances[:k]] return nearest_neighbors def predict_class(neighbors_labels): Predicts the class based on the labels of the k nearest neighbors. Parameters: neighbors_labels (list of int): The labels of the k nearest neighbors. Returns: int: The predicted class based on majority vote. label_count = Counter(neighbors_labels) # Resolve ties by selecting the smallest label numerically return min(label_count, key=lambda x: (-label_count[x], x))"},{"question":"# Binary Search Tree (BST) Delete Operation Implement a function to delete a specified value from a Binary Search Tree (BST). The BST is given with its root node, and the function should maintain the BST properties after deletion. The function should return the root node of the updated BST. Function Signature ```python def delete_node(root: TreeNode, key: int) -> TreeNode: pass ``` Input * `root` (TreeNode): The root node of the BST. Constraints: The number of nodes (1 leq text{number of nodes} leq 10^4). * `key` (int): The value to be deleted from the BST. Constraints: (-10^4 leq text{key} leq 10^4). Output * (TreeNode): The root node of the updated BST after deleting the specified value. If the value was not found in the BST, return the original root. Example ```python # Given BST: # 5 # / # 3 6 # / # 2 4 7 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(6) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(7) key = 3 # After deleting 3, the BST should become: # 5 # / # 4 6 # / # 2 7 result = delete_node(root, key) # Function should return a BST that matches the structure above. ``` Constraints * The tree is a valid BST. * The function should handle cases gracefully where the key is not found in the tree. * Ensure deletion operation on the NST follows BST properties and is efficient. * Consider all edge cases including deleting a leaf node, a node with a single child, or a node with two children. Guidelines 1. **Initialization**: Start by finding the node to be deleted. 2. **Deletion Logic**: - If the node is a leaf, simply remove it. - If the node has one child, replace it with its child. - If the node has two children, find its in-order successor (smallest in the right subtree), replace the node\'s value with the successor\'s value, and delete the successor. 3. **Return**: Ensure the function returns the new root of the tree. 4. **Edge Cases**: Handle scenarios where the tree is empty or the key is not found. 5. **Recursive or Iterative**: Decide whether a recursive or iterative approach fits best, but ensure clarity and efficiency. --- Note: The TreeNode class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_minimum(node): Function to find the node with the minimum value in a BST. current = node while current.left is not None: current = current.left return current def delete_node(root, key): Deletes the node with the value \'key\' from the BST rooted at \'root\'. Returns the root of the updated BST. if root is None: return root # Recur down the tree if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: # Node to be deleted is found # Case 1: Node has no child (leaf node) if root.left is None and root.right is None: root = None # Case 2: Node has only one child elif root.left is None: root = root.right elif root.right is None: root = root.left # Case 3: Node has two children else: # Get the inorder successor (smallest in the right subtree) temp = find_minimum(root.right) root.val = temp.val root.right = delete_node(root.right, temp.val) return root"},{"question":"# Coding Assessment Question You are tasked with analyzing a security system that uses camera feeds to monitor movements within a rectangular area divided into a grid. The system detects movements and marks them in the grid with `1s`, while the areas with no movement are marked with `0s`. # Problem Statement Implement a function `detect_clusters` that identifies clusters of movements (connected components of `1s`) in the grid. A cluster is defined as a group of adjacent `1s` where adjacency includes horizontal and vertical neighbors. # Function Signature ```python def detect_clusters(grid: list[list[int]]) -> int: pass ``` # Input * `grid`: A 2D list (list of lists) representing the camera feed grid. `0` represents no movement, and `1` represents detected movement. # Output * An integer representing the number of distinct clusters of movements in the grid. # Constraints * The grid can be of size `1x1` to `500x500`. # Examples ```python grid1 = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert detect_clusters(grid1) == 3 grid2 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert detect_clusters(grid2) == 3 ``` In the above example, the first grid has three clusters of movements, while the second grid has three individual clusters, each containing a single `1`.","solution":"def detect_clusters(grid): Returns the number of clusters of 1s in the grid. if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): Depth-First Search to mark the visited cells. if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True dfs(r-1, c) # up dfs(r+1, c) # down dfs(r, c-1) # left dfs(r, c+1) # right clusters = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: clusters += 1 dfs(r, c) return clusters"},{"question":"# Problem Statement: You need to implement a function that finds all the unique triplets in an array that sum up to zero. Each triplet must be sorted in non-descending order and the resulting list of triplets must not contain any duplicate triplets. Your function should take in an array of integers and return a list of such triplets. # Requirements: 1. Implement a method `find_triplets` that takes in the following parameter: - `nums`: A list of integers. 2. The method should return a list of lists, where each list represents a triplet of numbers that sum up to zero. Each triplet should be sorted in non-descending order. 3. The resulting list should not contain any duplicate triplets, and triplets should be returned in ascending order of the first element, then by the second, and finally by the third. # Constraints: - `nums` can contain any integer values and can be of any length up to (10^4). - **Input validation**: Must handle invalid input cases by returning an empty list. - **Performance**: The solution should be efficient in terms of time complexity. # Function Signature: ```python def find_triplets(nums: list[int]) -> list[list[int]]: pass ``` # Example: ```python nums = [-1, 0, 1, 2, -1, -4] result = find_triplets(nums) print(result) # Output should be [[-1, -1, 2], [-1, 0, 1]] nums = [0, 0, 0, 0] result = find_triplets(nums) print(result) # Output should be [[0, 0, 0]] ``` # Note: - Your solution should handle edge cases such as arrays with all positive or all negative numbers, as well as arrays with fewer than three elements. - Ensure that the solution is optimized for performance, considering the constraints.","solution":"def find_triplets(nums): Find unique triplets in the list that sum up to zero. nums.sort() # Sorting the list first for easier duplicate handling and triplet finding triplets = [] # This will store the final triplets length = len(nums) # Iterate through the list for i in range(length - 2): # To avoid duplicate triplets, skip the same element if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, length - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.append([nums[i], nums[left], nums[right]]) # Skip the same elements to avoid duplicate triplets while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"# Coding Question **Scenario**: You are assigned to build a part of a library management system that helps manage the borrowing of books. Each borrower can borrow multiple books, and each book has a maximum borrow period. The system needs to ensure that no borrower can exceed the allowed borrow period for any of the books they have borrowed. Your task is to write a function that checks if a borrower has returned all books within the maximum allowed borrow period. **Question**: Implement a function `is_borrow_within_limit(borrow_logs: List[Tuple[int, int]]) -> bool` that determines if all books in the borrow logs are returned within their respective allowed borrow periods. Each borrow log contains the book ID and the number of days it was borrowed. **Input**: - `borrow_logs` (1 <= len(borrow_logs) <= 1000): A list of tuples, each containing two integers where the first integer represents the book ID and the second integer represents the number of days the book was borrowed. **Output**: - A boolean indicating whether all books were returned within the allowed borrow period. **Constraints**: - Each book ID is associated with a maximum borrow period stored in a predefined dictionary called `max_borrow_limit`. - Example of `max_borrow_limit`: ```python max_borrow_limit = {1: 14, 2: 30, 3: 7, 4: 21} ``` # Examples 1. `is_borrow_within_limit([(1, 10), (2, 25), (3, 5), (4, 20)])` should return `True`. 2. `is_borrow_within_limit([(1, 15), (2, 25), (3, 8), (4, 22)])` should return `False`. # Function Signature ```python from typing import List, Tuple def is_borrow_within_limit(borrow_logs: List[Tuple[int, int]]) -> bool: pass ``` **Hint**: - You need to make sure that the borrow days do not exceed the respective values in `max_borrow_limit`. This question should test your ability to handle real-world data using simple dictionary lookups and logical condition checks.","solution":"from typing import List, Tuple # Predefined maximum borrow limits for each book ID max_borrow_limit = {1: 14, 2: 30, 3: 7, 4: 21} def is_borrow_within_limit(borrow_logs: List[Tuple[int, int]]) -> bool: Determines if all books in the borrow logs are returned within their respective allowed borrow periods. for book_id, days_borrowed in borrow_logs: if days_borrowed > max_borrow_limit.get(book_id, float(\'inf\')): return False return True"},{"question":"# Sum of Unique Numbers You are tasked with writing a function that calculates the sum of all unique integers from a given list. In other words, you should only sum each number once, even if it appears multiple times in the list. **Function Signature**: ```python def sum_of_unique_numbers(numbers: list) -> int: ``` **Input**: * A list of integers `numbers`. **Output**: * Return the sum of all unique integers in the list. **Constraints**: * The length of the list will be between 0 and 10^6. * Each integer in the list will be between -10^6 and 10^6. * The function should raise a `TypeError` if the input is not a list. **Examples**: * `sum_of_unique_numbers([1, 2, 3, 2, 1])` should return `6` * `sum_of_unique_numbers([7, 8, 9, 7])` should return `24` * `sum_of_unique_numbers([10, 20, 30, 40, 50])` should return `150` * `sum_of_unique_numbers([])` should return `0` * `sum_of_unique_numbers([-1, -1, -2, -2, -3])` should return `-6` **Requirements**: * Ensure that your implementation is efficient and handles all edge cases. * Handle non-list input by raising a `TypeError`. Feel free to use any additional helper functions that you may find necessary for your implementation.","solution":"def sum_of_unique_numbers(numbers): Returns the sum of all unique integers in the list. If numbers is not a list, raises a TypeError. if not isinstance(numbers, list): raise TypeError(\\"The input must be a list.\\") unique_numbers = set(numbers) # Using set to get unique integers return sum(unique_numbers)"},{"question":"# Context You are developing a text-based game which involves moving a player on a 2D grid. Each cell on the grid may be free space (.) or an obstacle (#). The player can only move to adjacent free space cells (up, down, left, right). # Description Implement a function that determines if a player can reach the target cell from a starting cell on the grid. # Function Signature ```python def can_reach_target(grid: List[List[str]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: pass ``` # Input * `grid` (List[List[str]]): A 2D list representing the game grid where \'.\' indicates a free space and \'#\' indicates an obstacle. * `start` (Tuple[int, int]): A tuple representing the starting cell coordinates (row, column). * `target` (Tuple[int, int]): A tuple representing the target cell coordinates (row, column). # Output * Return a boolean value indicating whether the target cell can be reached from the start cell. # Constraints * The dimensions of the grid are not fixed, but it is guaranteed to be at least 1x1 in size. * `grid` contains only \'.\' and \'#\' characters. * `start` and `target` are guaranteed to be valid free space cells (\'.\') on the grid. # Example ```python grid = [ [\'.\', \'.\', \'#\', \'.\'], [\'#\', \'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'#\'], [\'#\', \'#\', \'.\', \'.\'] ] start = (0, 0) target = (3, 3) result = can_reach_target(grid, start, target) # `result` should be True since there\'s a clear path to the target cell. ``` # Notes * You can implement any pathfinding algorithm to solve the problem (e.g., BFS, DFS). * Ensure to handle the edge cases when the grid dimensions are minimal (e.g., 1x1 or 1xN, Nx1).","solution":"from typing import List, Tuple from collections import deque def can_reach_target(grid: List[List[str]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: Determines if a player can reach the target cell from a starting cell on the grid. if start == target: return True rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() queue = deque([start]) visited.add(start) while queue: x, y = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == \'.\': if (nx, ny) == target: return True queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Problem Scenario You are given a list of integers representing temperatures recorded in a city over a week. The data contains some erroneous readings outside a plausible temperature range (-50 to 50 degrees). Your task is to filter out these erroneous data points and calculate the average temperature for the week using the valid readings. # Task Write a function `average_temperature(temperatures: list) -> float`. Your function should: 1. Take as input a list of integers representing the temperatures. 2. Filter out the erroneous readings (temperatures outside the range of -50 to 50 degrees). 3. Compute and return the average of the remaining valid temperatures as a float value. 4. Handle scenarios where all readings are invalid by returning 0. # Expected Input and Output Input: * A list of integers, `temperatures`. - Example: `[23, 45, -60, 12, 54, 30, -10]` Output: * A float representing the average temperature of valid readings. - Example: `20.0` # Constraints: * The length of the list will be at most 100. * Each integer in the list can be between -100 and 100. # Performance Requirements: * Ensure your solution is efficient and handles all edge cases correctly. # Example ```python def average_temperature(temperatures: list) -> float: # Filter temperatures to remove invalid readings valid_temperatures = [temp for temp in temperatures if -50 <= temp <= 50] # If no valid temperatures, return 0 if not valid_temperatures: return 0.0 # Calculate the average of valid temperatures return sum(valid_temperatures) / len(valid_temperatures) # Example usage: print(average_temperature([23, 45, -60, 12, 54, 30, -10])) # Output: 20.0 print(average_temperature([-60, 54, 70, -100, 90])) # Output: 0.0 ```","solution":"def average_temperature(temperatures: list) -> float: Returns the average temperature from the list of temperatures, excluding readings outside the range of -50 to 50 degrees. Args: temperatures (list): List of integer temperatures. Returns: float: The average temperature of the valid readings. # Filter temperatures to remove invalid readings valid_temperatures = [temp for temp in temperatures if -50 <= temp <= 50] # If no valid temperatures, return 0 if not valid_temperatures: return 0.0 # Calculate the average of valid temperatures return sum(valid_temperatures) / len(valid_temperatures)"},{"question":"Rotate Image by 90 Degrees Clockwise Given a 2D matrix representing an image, rotate the image by 90 degrees clockwise. # Function Signature: ```python def rotate_image(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input: - `matrix`: A 2D list of integers representing the image of size m x n. # Output: - A 2D list of integers representing the rotated image where the original image has been rotated 90 degrees clockwise. # Constraints: - `1 â‰¤ m, n â‰¤ 1000` - Each element in the matrix will be a non-negative integer. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Expected output: # The matrix rotated by 90 degrees clockwise output_matrix = rotate_image(matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Explanation: 1. The input matrix is represented as a 2D list. 2. To rotate the matrix by 90 degrees clockwise, elements in the rows become columns in the output matrix. 3. The element at `matrix[i][j]` in the original matrix will be placed at `matrix[j][m-1-i]` in the rotated matrix for all valid indices i and j. 4. Implement in-place rotation if extra space optimization is required. # Notes: - Ensure to handle edge cases such as rectangular matrices where m â‰  n. - Optimize for performance to handle the upper constraint limits efficiently.","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix by 90 degrees clockwise. Args: matrix: List[List[int]] -- a 2D matrix of integers Returns: List[List[int]] -- the rotated 2D matrix by 90 degrees clockwise n = len(matrix) # We will perform the rotation in-place for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - 1 - j][i] matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] matrix[j][n - 1 - i] = temp return matrix"},{"question":"# Coding Assessment Question Scenario: You are developing a software system that processes financial transactions and generates reports. A common task is to analyze a list of transactions and filter out those that are invalid based on multiple criteria. # Task: Implement a function `filter_transactions` that processes a list of transactions and returns only the valid ones. A transaction is considered valid if it meets the following criteria: 1. The transaction amount must be a positive value. 2. The transaction type must be one of the following: `\\"credit\\"`, `\\"debit\\"`, `\\"transfer\\"`. 3. The transaction status must be `\\"completed\\"`. # Requirements: 1. Implement the function `filter_transactions(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]`. 2. Your function should efficiently process the list and handle edge cases such as empty lists or missing keys gracefully. # Input Format: - A list of dictionaries, where each dictionary represents a transaction with the following keys: - `\\"amount\\"`: a float representing the transaction amount. - `\\"type\\"`: a string representing the transaction type. - `\\"status\\"`: a string representing the transaction status. # Output Format: - A list of dictionaries containing only the valid transactions. # Constraints: - The number of transactions ( n leq 10^4 ). - Each transaction dictionary will contain at least the keys `\\"amount\\"`, `\\"type\\"`, and `\\"status\\"`. - The `\\"amount\\"` value will be a float, and the `\\"type\\"` and `\\"status\\"` values will be strings. # Example: ```python transactions = [ {\\"amount\\": 100.0, \\"type\\": \\"credit\\", \\"status\\": \\"completed\\"}, {\\"amount\\": -50.0, \\"type\\": \\"debit\\", \\"status\\": \\"completed\\"}, {\\"amount\\": 200.0, \\"type\\": \\"transfer\\", \\"status\\": \\"pending\\"}, {\\"amount\\": 150.0, \\"type\\": \\"credit\\", \\"status\\": \\"completed\\"}, {\\"amount\\": 100.0, \\"type\\": \\"credit\\", \\"status\\": \\"failed\\"} ] filtered_transactions = filter_transactions(transactions) print(filtered_transactions) # Output: # [ # {\\"amount\\": 100.0, \\"type\\": \\"credit\\", \\"status\\": \\"completed\\"}, # {\\"amount\\": 150.0, \\"type\\": \\"credit\\", \\"status\\": \\"completed\\"} # ] ``` # Implementation: ```python def filter_transactions(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]: valid_types = {\\"credit\\", \\"debit\\", \\"transfer\\"} valid_status = \\"completed\\" valid_transactions = [ transaction for transaction in transactions if transaction.get(\\"amount\\", 0) > 0 and transaction.get(\\"type\\") in valid_types and transaction.get(\\"status\\") == valid_status ] return valid_transactions ```","solution":"from typing import List, Dict, Any def filter_transactions(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]: valid_types = {\\"credit\\", \\"debit\\", \\"transfer\\"} valid_status = \\"completed\\" valid_transactions = [ transaction for transaction in transactions if transaction.get(\\"amount\\", 0) > 0 and transaction.get(\\"type\\") in valid_types and transaction.get(\\"status\\") == valid_status ] return valid_transactions"},{"question":"Analyzing Graph Reachability via BFS You are tasked with determining which nodes are reachable from a given starting node in an undirected graph by performing a Breadth-First Search (BFS). # Problem Statement Given a starting node and an undirected graph represented by a list of edges, write a function `find_reachable_nodes(start: int, edges: list[tuple[int, int]]) -> list[int]` that returns a list of nodes that are reachable from the starting node. # Function Signature ```python def find_reachable_nodes(start: int, edges: list[tuple[int, int]]) -> list[int]: pass ``` # Input * `start` (`int`): The initial node to start the BFS process. * `edges` (`list[tuple[int, int]]`): A list of tuples, where each tuple describes an edge in the format `(node1, node2)`. This means there is an undirected edge between `node1` and `node2`. # Output * `list[int]`: A list of nodes that are reachable from the starting node, sorted in ascending order. # Constraints * Each node is uniquely represented by an integer. * The graph may contain multiple connected components. * The graph edges and nodes are non-empty. * Each edge is unique and no self-loops are present. # Example ```python edges = [ (1, 2), (1, 3), (2, 4), (3, 5), (6, 7) ] result = find_reachable_nodes(1, edges) print(result) # Expected output: [1, 2, 3, 4, 5] ``` # Additional Notes * Ensure to handle the case where the graph has disconnected components. * BFS should be used to ensure all nodes in the connected component are visited. * Consider the performance implications given typical constraints for graph traversal problems.","solution":"from collections import deque, defaultdict def find_reachable_nodes(start: int, edges: list[tuple[int, int]]) -> list[int]: Given a starting node and a list of edges representing an undirected graph, return the list of nodes that are reachable from the starting node using BFS. # Building the adjacency list graph = defaultdict(list) for node1, node2 in edges: graph[node1].append(node2) graph[node2].append(node1) # BFS Initialization reachable_nodes = [] visited = set() queue = deque([start]) while queue: current_node = queue.popleft() if current_node not in visited: visited.add(current_node) reachable_nodes.append(current_node) # Adding connected nodes to the queue for BFS for neighbor in graph[current_node]: if neighbor not in visited: queue.append(neighbor) return sorted(reachable_nodes)"},{"question":"Financial Data Analysis: Moving Average Time Series Predictor You are tasked with implementing a time series predictor for financial data using a moving average technique. Predicting future values based on historical data is essential in financial analysis for making informed investment decisions. # Problem Statement Write a function `moving_average_predictor` that calculates the moving average of a given time series of daily stock prices and uses it to predict the price for the next day. Your implementation should allow for variable window sizes for the moving average calculation. # Function Signature ```python def moving_average_predictor(prices: List[float], window_size: int) -> float: ``` # Input - `prices`: A list of floats representing the daily closing prices of a stock. - `window_size`: An integer representing the number of days over which to calculate the moving average. # Output - A float representing the predicted stock price for the next day, based on the moving average of the given data. # Constraints 1. The length of the `prices` list will be at least `window_size`. 2. All elements in the `prices` list will be positive floats. 3. `window_size` will be a positive integer, and at most the length of the `prices` list. # Requirements 1. **Moving Average Calculation**: Implement the calculation of the moving average over the specified window size. 2. **Prediction**: Use the moving average to predict the next day\'s price. 3. **Efficiency**: Ensure the function handles lists with up to 10,000 elements efficiently. # Example ```python # Sample list of daily closing prices prices = [100.0, 101.5, 102.3, 103.0, 104.8, 106.2, 107.5] # Window size for moving average window_size = 3 # Predict the stock price for the next day predicted_price = moving_average_predictor(prices, window_size) print(predicted_price) ``` # Expected Output ```python 106.16666666666667 ``` # Notes 1. The moving average over the last `window_size` days should be calculated by taking the sum of the closing prices for these days and dividing by the `window_size`. 2. Ensure the function handles the maximum constraints efficiently. Implement your function in Python: ```python from typing import List def moving_average_predictor(prices: List[float], window_size: int) -> float: # Calculate the moving average of the last `window_size` days moving_average = sum(prices[-window_size:]) / window_size # Return the calculated moving average as the predicted price return moving_average # Sample list of daily closing prices prices = [100.0, 101.5, 102.3, 103.0, 104.8, 106.2, 107.5] # Window size for moving average window_size = 3 # Predict the stock price for the next day predicted_price = moving_average_predictor(prices, window_size) print(predicted_price) ``` # Expected Output ```python 106.16666666666667 ```","solution":"from typing import List def moving_average_predictor(prices: List[float], window_size: int) -> float: Calculate the moving average of the last `window_size` days and predict the stock price for the next day based on this moving average. Parameters: prices (List[float]): The list of daily closing prices of a stock. window_size (int): The number of days over which to calculate the moving average. Returns: float: The predicted stock price for the next day. # Calculate the moving average of the last `window_size` days moving_average = sum(prices[-window_size:]) / window_size # Return the calculated moving average as the predicted price return moving_average"},{"question":"# Longest Increasing Subsequence Context: You have been given a sequence of integers representing the daily closing prices of a stock over a period. Your goal is to determine the length of the longest increasing subsequence (LIS) of these prices. Task: Implement a function to find the length of the longest increasing subsequence in the given list of stock prices. Requirements: 1. **Function**: `longest_increasing_subsequence(prices: list[int]) -> int` - Input: A list of integers `prices` representing the daily closing stock prices. - Output: An integer representing the length of the longest increasing subsequence. - Constraints: The input list will have at least one element and no more than 10^4 elements. - Performance: The function should have a time complexity of O(n log n), where `n` is the length of the input list. Example: ```python prices = [100, 80, 120, 90, 110, 85, 125, 95] assert longest_increasing_subsequence(prices) == 4 # The LIS is [80, 90, 110, 125] prices = [3, 10, 2, 1, 20] assert longest_increasing_subsequence(prices) == 3 # The LIS is [3, 10, 20] prices = [3, 2] assert longest_increasing_subsequence(prices) == 1 # The LIS is [3] or [2] prices = [50, 3, 10, 7, 40, 80] assert longest_increasing_subsequence(prices) == 4 # The LIS is [3, 7, 40, 80] ```","solution":"import bisect def longest_increasing_subsequence(prices): Finds the length of the longest increasing subsequence in the given list of stock prices. :param prices: List of integers representing the daily closing stock prices. :return: An integer representing the length of the longest increasing subsequence. if not prices: return 0 # List to store the smallest possible last element of the increasing sequence of length i+1 tails = [] for price in prices: # Use binary search to find the insertion point idx = bisect.bisect_left(tails, price) if idx == len(tails): # If price is greater than any element in tails, append it tails.append(price) else: # Otherwise, replace the existing value to maintain the smallest ending value tails[idx] = price return len(tails)"},{"question":"# Question: Natural Language Processing - Implementing a Simple Named Entity Recognition (NER) Model In this task, you will implement functions to preprocess text and perform Named Entity Recognition (NER) using a simple rule-based approach. Understanding and implementing NER is essential for many natural language processing applications like information extraction and text summarization. Objectives: 1. Develop the following functions to preprocess text and identify entities: 1. **Text Preprocessing** 2. **Named Entity Recognition (NER)** 2. Your implementations should handle edge cases and raise appropriate errors for invalid inputs. Function Specifications: **Text Preprocessing** ```python def preprocess_text(text: str) -> List[str]: Parameters: - text: The input string containing the text to be processed Returns: - List of strings: The preprocessed tokens ``` **Named Entity Recognition (NER)** ```python def named_entity_recognition(tokens: List[str]) -> Dict[str, List[str]]: Parameters: - tokens: List of preprocessed tokens Returns: - Dictionary: A dictionary with entity types as keys and lists of entities as values ``` Guidelines: 1. **Text Preprocessing**: - Convert the text to lowercase. - Remove punctuation and special characters. - Tokenize the text into individual words. - Handle edge cases like empty strings or non-string inputs appropriately. 2. **Named Entity Recognition (NER)**: - Perform a simple NER based on predefined rules. - Identify entities like Persons, Locations, and Organizations. - You can use simple heuristics like capitalization patterns, surrounding context, or common entity name lists. - Populate and return a dictionary with the keys \'Person\', \'Location\', \'Organization\', and the values being lists of identified entities. Example Usage: ```python text = \\"John Doe is the CEO of OpenAI. He lives in San Francisco.\\" tokens = preprocess_text(text) print(tokens) # Output: [\'john\', \'doe\', \'is\', \'the\', \'ceo\', \'of\', \'openai\', \'he\', \'lives\', \'in\', \'san\', \'francisco\'] entities = named_entity_recognition(tokens) print(entities) # Output: {\'Person\': [\'john doe\'], \'Location\': [\'san francisco\'], \'Organization\': [\'openai\']} ``` Constraints: 1. Ensure the input `text` for `preprocess_text` is a non-empty string. 2. Ensure the `tokens` for `named_entity_recognition` are properly formatted as a list of strings and handle cases where no valid entities are found. 3. Use basic string and list operations. External libraries for advanced NLP are not allowed. You need to write these functions from scratch. You are encouraged to use efficient string operations for preprocessing and simple heuristics for NER. Good luck!","solution":"import re from typing import List, Dict def preprocess_text(text: str) -> List[str]: Preprocess the input text by converting to lowercase, removing punctuation, and tokenizing into words. Parameters: - text: The input string containing the text to be processed Returns: - List of strings: The preprocessed tokens if not isinstance(text, str) or not text.strip(): raise ValueError(\\"Input must be a non-empty string.\\") # Convert to lowercase text = text.lower() # Remove punctuation and special characters text = re.sub(r\'[^a-zs]\', \'\', text) # Tokenize text tokens = text.split() return tokens def named_entity_recognition(tokens: List[str]) -> Dict[str, List[str]]: Perform a simple named entity recognition based on predefined rules. Parameters: - tokens: List of preprocessed tokens Returns: - Dictionary: A dictionary with entity types as keys and lists of entities as values if not all(isinstance(token, str) for token in tokens): raise ValueError(\\"All tokens must be strings.\\") entities = {\'Person\': [], \'Location\': [], \'Organization\': []} person_list = [\'john doe\'] location_list = [\'san francisco\'] organization_list = [\'openai\'] text = \\" \\".join(tokens) # Finding entities in the joined text for person in person_list: if person in text: entities[\'Person\'].append(person) for location in location_list: if location in text: entities[\'Location\'].append(location) for organization in organization_list: if organization in text: entities[\'Organization\'].append(organization) return entities"},{"question":"# Question: Implement an Efficient K-Means Clustering Algorithm **Context**: You are tasked with implementing an efficient version of the K-Means clustering algorithm for partitioning a dataset into K distinct clusters. **Objective**: Given a dataset of points in multi-dimensional space and the number of clusters K, your task is to partition the points into K clusters such that the sum of the squared distances from each point to its assigned cluster centroid is minimized. **Function Signature**: ```python def k_means_clustering(points: list[list[float]], K: int) -> list[int]: Args: - points: A list of points where each point is represented as a list of its coordinates in multi-dimensional space. - K: The number of clusters to form. Returns: - A list of integers where each integer represents the assigned cluster index for the corresponding point in the input list. Constraints: - The dataset is non-empty and contains at least K distinct points. - Each point in the dataset is represented as a list of floats (coordinates). Example: >>> points = [ ... [1.0, 2.0], ... [2.0, 3.0], ... [3.0, 4.0], ... [8.0, 8.0], ... [9.0, 9.0], ... [10.0, 10.0] ... ] >>> K = 2 >>> k_means_clustering(points, K) [0, 0, 0, 1, 1, 1], # or [1, 1, 1, 0, 0, 0] depending on initialization pass ``` **Instructions**: 1. Randomly initialize K centroids from the given points. 2. Implement the iterative K-Means algorithm: - Assign each point to the nearest centroid based on Euclidean distance. - Recalculate centroids as the mean of assigned points. 3. Iterate until convergence or a maximum number of iterations is reached. 4. Optimize the algorithm to handle large datasets efficiently. 5. Properly handle edge cases and performance bottlenecks. **Performance Requirements**: * Your solution should handle up to 10^4 points efficiently in terms of computation time and memory usage. **Hint**: Efficiently implement distance calculations and centroid updates to minimize computational overhead. Using a fixed number of iterations can help manage performance on large datasets.","solution":"import random import numpy as np def k_means_clustering(points: list[list[float]], K: int) -> list[int]: points = np.array(points) n = len(points) d = points.shape[1] # Step 1: Randomly initialize K centroids from the given points initial_indices = random.sample(range(n), K) centroids = points[initial_indices] # Step 2: Iterate until convergence or a maximum number of iterations max_iterations = 300 for _ in range(max_iterations): # Assign each point to the nearest centroid distances = np.sqrt(((points - centroids[:, np.newaxis])**2).sum(axis=2)) labels = np.argmin(distances, axis=0) # Calculate new centroids from the mean of the assigned points new_centroids = np.array([points[labels == k].mean(axis=0) for k in range(K)]) # Check for convergence (if centroids do not change) if np.allclose(centroids, new_centroids): break centroids = new_centroids # Return the labels for each point return labels.tolist()"},{"question":"You are tasked with implementing a function to find pairs in a list where the product of the pair is equal to a given target value. Each pair should be unique, meaning that (a, b) is considered the same as (b, a), and no duplicates should appear in the result. # Requirements: Implement a function `find_pairs_with_product(nums: list[int], target: int) -> list[tuple[int, int]]` with the following parameters: * `nums` (list of int): The list of integers in which to find pairs. (-10^6 â‰¤ nums[i] â‰¤ 10^6) * `target` (int): The target product value. (|target| â‰¤ 10^12) # Expected Output: The function should return a list of unique pairs (tuples) (a, b) where `a * b == target`. # Constraints: * If `nums` or `target` are such that no pairs exist, the function should return an empty list. * Ensure that each pair returned is unique and in the order `(a, b)` where `a â‰¤ b`. * Handle cases where `nums` can have very large or very small values up to the given constraints. # Examples: ```python >>> find_pairs_with_product([1, 2, 3, 6, 4], 6) [(1, 6), (2, 3)] >>> find_pairs_with_product([-1, -2, 1, 2], -2) [(-1, 2), (-2, 1)] >>> find_pairs_with_product([2, 4, 6, 8], 15) [] >>> find_pairs_with_product([0, 1, -1, -2, 2], 0) [(0, 1), (0, -1), (0, -2), (0, 2)] ``` # Performance Considerations: Ensure that the implementation can handle large lists efficiently in terms of both time and space. # Notes: * You may not use built-in library functions that directly solve the problem. * Consider edge cases and handle any potential issues that may arise with the input values. Exercise caution with zero values and ensure that the function handles them appropriately as per constraints.","solution":"def find_pairs_with_product(nums, target): Finds unique pairs (a, b) such that a * b == target. :param nums: List of integers to find pairs in. :param target: The desired product. :return: List of unique pairs (tuples) (a, b) where a * b == target and a <= b. seen = set() # To store the numbers we have already seen pairs = set() # To store the unique pairs for a in nums: if target == 0: if a == 0: for b in nums: if b != 0: pairs.add((0, b)) break # If target is 0 and we found a pair with 0, no need to continue elif a != 0 and target % a == 0: b = target // a if b in seen: pairs.add(tuple(sorted((a, b)))) seen.add(a) return sorted(list(pairs))"},{"question":"# Coding Assessment Question Context: You are asked to help develop a reservation system for a cinema. In this system, all seat reservations need to be mapped onto a seating chart. The seating chart is represented by a two-dimensional grid where rows represent rows of seats and columns represent different seats in a row. Initially, all seats are empty. You need to write a function that handles seat reservations and ensures that no double booking occurs. Task: Write a function `reserve_seat(chart: list[list[int]], row: int, seat: int) -> list[list[int]]` that accepts the current seating chart, a row number, and a seat number. If the seat is already reserved, the function should do nothing. If the seat is available, it should mark that seat as reserved. Function Signature: ```python def reserve_seat(chart: list[list[int]], row: int, seat: int) -> list[list[int]]: ``` Input: * `chart`: A list of lists of integers where `chart[i][j]` represents the seat at row `i` and column `j`. `0` indicates the seat is available, and `1` indicates it is reserved. * `row`: An integer representing the row number of the seat to be reserved (0-indexed). * `seat`: An integer representing the seat number (column) to be reserved (0-indexed). Output: * A new seating chart list of lists, with the seat at the specified row and seat number marked as reserved (if it was originally available). Constraints: * The seating chart will have between 1 and 100 rows and between 1 and 100 seats per row. * Seat and row indices will be valid within the provided seating chart dimensions. Example: ```python chart = [ [0, 1, 0], [0, 0, 0], [1, 0, 1] ] row = 1 seat = 2 # Expected result: # [ # [0, 1, 0], # [0, 0, 1], # [1, 0, 1] # ] assert reserve_seat(chart, row, seat) == [ [0, 1, 0], [0, 0, 1], [1, 0, 1] ] ``` Performance Requirements: * The solution should be efficient and operate within O(1) time complexity for each reservation operation, given that it involves a constant-time access to a specific seat in the grid. Summary: Implement the `reserve_seat` function that takes care of marking a specific seat as reserved in the seating chart if it is not already reserved. Ensure that the constraints are followed and the function performs the operation efficiently.","solution":"def reserve_seat(chart: list[list[int]], row: int, seat: int) -> list[list[int]]: Reserve a seat if it is available by marking it as reserved (1) in the seating chart. Args: - chart: list of lists of integers representing seating chart where 0 means available and 1 means reserved. - row: integer, row number of the seat to reserve (0-indexed) - seat: integer, seat number (column) to reserve (0-indexed) Returns: - Updated seating chart with the seat marked as reserved if it was available. if chart[row][seat] == 0: chart[row][seat] = 1 return chart"},{"question":"# Sum of Digits of a Positive Integer You are required to write a function that calculates the sum of the digits of a given positive integer. The sum of the digits means adding all individual digits of the integer until there are no more digits left. Task: Implement the function `sum_of_digits(n)` that takes a single integer input `n` and returns the sum of its digits. Function Signature: ```python def sum_of_digits(n: int) -> int: pass ``` Constraints: * `1 <= n <= 10^9` Examples: 1. `sum_of_digits(123) -> 6` (because 1 + 2 + 3 = 6) 2. `sum_of_digits(456) -> 15` (because 4 + 5 + 6 = 15) 3. `sum_of_digits(7890) -> 24` (because 7 + 8 + 9 + 0 = 24) 4. `sum_of_digits(1) -> 1` (because 1 = 1) # Requirements: * Implement the `sum_of_digits` function ensuring it returns the correct sum for any positive integer input within the specified constraints. * Do not use external libraries; use basic arithmetic operations available in the language.","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given positive integer n. total_sum = 0 while n > 0: total_sum += n % 10 n //= 10 return total_sum"},{"question":"# Problem Statement: You are tasked with designing a program to simulate a basic banking system. The system should be able to handle multiple accounts, allowing deposits, withdrawals, and balance checks. To ensure consistency and avoid race conditions, you need to implement thread-safe operations for the banking system. Implement a Python class `BankAccount` with the following methods: 1. `__init__(self, account_id: int, initial_balance: float = 0.0)`: Initializes the bank account with a unique account ID and an initial balance. 2. `deposit(self, amount: float) -> None`: Adds the specified amount to the account balance. 3. `withdraw(self, amount: float) -> bool`: Subtracts the specified amount from the account balance if sufficient funds are available. Returns True if the withdrawal was successful, False otherwise. 4. `get_balance(self) -> float`: Returns the current account balance. Implement a Python class `Bank` which manages multiple bank accounts and ensures thread-safe operations: 1. `__init__(self)`: Initializes the bank with no accounts. 2. `create_account(self, account_id: int, initial_balance: float = 0.0) -> None`: Creates a new bank account with the given ID and initial balance. 3. `get_account(self, account_id: int) -> BankAccount`: Retrieves the `BankAccount` object corresponding to the given account ID. Ensure that all operations on the `BankAccount` objects are thread-safe, using locks where necessary. Constraints * The deposit and withdrawal amounts should always be non-negative. * Withdrawals cannot exceed the available balance. * Each `BankAccount` should have a unique account ID. Example: ```python from threading import Thread def test_banking_system(): bank = Bank() bank.create_account(1, 1000.0) def deposit_funds(account_id, amount): account = bank.get_account(account_id) account.deposit(amount) def withdraw_funds(account_id, amount): account = bank.get_account(account_id) return account.withdraw(amount) # Create threads for concurrent deposits and withdrawals threads = [] threads.append(Thread(target=deposit_funds, args=(1, 500.0))) threads.append(Thread(target=withdraw_funds, args=(1, 200.0))) threads.append(Thread(target=withdraw_funds, args=(1, 500.0))) for thread in threads: thread.start() for thread in threads: thread.join() final_balance = bank.get_account(1).get_balance() print(f\\"Final balance for account 1: {final_balance}\\") test_banking_system() ``` The expected output will show the final balance of account 1 after performing the concurrent transactions, while ensuring thread safety.","solution":"import threading class BankAccount: def __init__(self, account_id: int, initial_balance: float = 0.0): self.account_id = account_id self.balance = initial_balance self.lock = threading.Lock() def deposit(self, amount: float) -> None: with self.lock: if amount >= 0: self.balance += amount def withdraw(self, amount: float) -> bool: with self.lock: if amount >= 0 and self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: with self.lock: return self.balance class Bank: def __init__(self): self.accounts = {} self.lock = threading.Lock() def create_account(self, account_id: int, initial_balance: float = 0.0) -> None: with self.lock: if account_id not in self.accounts: self.accounts[account_id] = BankAccount(account_id, initial_balance) def get_account(self, account_id: int) -> BankAccount: with self.lock: return self.accounts.get(account_id)"},{"question":"# Problem Statement: Given a string `s` containing only lowercase alphabets, you need to determine whether it is possible to rearrange the characters of the string so that no two adjacent characters are the same. Implement a function `can_rearrange` that returns `True` if such a rearrangement is possible and `False` otherwise. # Function Signature: ```python def can_rearrange(s: str) -> bool: ``` # Input: * A string `s` consisting only of lowercase alphabets where 1 <= len(s) <= 10^5. # Output: * A boolean value indicating whether the string can be rearranged so that no two adjacent characters are the same. # Example: ```python assert can_rearrange(\\"aab\\") == True assert can_rearrange(\\"aaab\\") == False assert can_rearrange(\\"aaaabbbcc\\") == True assert can_rearrange(\\"abcabc\\") == True assert can_rearrange(\\"aaaa\\") == False ``` # Constraints: * The function should handle both small and large size strings efficiently. * Raise a TypeError if the input is not a string. # Requirements: 1. Optimize the function to handle large strings effectively. 2. Consider edge cases such as single-character strings and strings with equal frequency of all characters. # Context: This function plays a crucial role in tasks where rearranging characters is necessary to meet specific criteria. For instance, rearranging seats in an exam hall to ensure no two students from the same class sit next to each other, or scheduling talks in a conference so that no two consecutive talks are conducted by the same speaker. Implement the function `can_rearrange` considering the described requirements and validate its correctness with the provided examples.","solution":"def can_rearrange(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") from collections import Counter freq = Counter(s) max_freq = max(freq.values()) # The count of the most frequent letter should not be more than # (length of s + 1) / 2. Otherwise, it is impossible to rearrange # such that no two adjacent characters are the same. return max_freq <= (len(s) + 1) // 2"},{"question":"# Problem Description You are given a binary tree implemented as a Python class. Your task is to implement a method named `max_path_sum(self) -> int` in the `BinaryTree` class that finds the maximum path sum in the binary tree. A path in a binary tree is a sequence of nodes where each pair of consecutive nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. The path must contain at least one node and does not need to go through the root. # Requirements - The function should return an integer representing the maximum path sum. - Your solution should account for both positive and negative values in the tree nodes. - Manage edge cases such as the tree being empty or containing only one node. # Input - None, the binary tree is already instantiated and populated with values via a class constructor. # Output - An integer representing the maximum path sum within the binary tree. # Constraints - The number of nodes in the binary tree is between 0 and 10^4. - Node values are in the range `[-10^4, 10^4]`. # Examples Example 1: ```python binary_tree = BinaryTree([-10,9,20,None,None,15,7]) print(binary_tree.max_path_sum()) # Output: 42 ``` Example 2: ```python binary_tree = BinaryTree([1,2,3]) print(binary_tree.max_path_sum()) # Output: 6 ``` # Notes - Consider utilizing auxiliary recursive methods to navigate through the binary tree and calculate the path sums. - Ensure you handle the edge cases where the tree might be empty or have negative path sums effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, values): self.root = self._build_tree(values, 0) if values else None def _build_tree(self, values, index): if index < len(values) and values[index] is not None: node = TreeNode(values[index]) node.left = self._build_tree(values, 2 * index + 1) node.right = self._build_tree(values, 2 * index + 2) return node return None def max_path_sum(self): def helper(node): if not node: return 0, float(\'-inf\') left_max_root, left_max_path = helper(node.left) right_max_root, right_max_path = helper(node.right) max_root = max(node.val, node.val + left_max_root, node.val + right_max_root) max_path = max(max_root, left_max_root + node.val + right_max_root, left_max_path, right_max_path) return max_root, max_path _, max_path = helper(self.root) return max_path"},{"question":"Context You are tasked with developing a recommendation system for an online bookstore. The system needs to suggest books to users based on their past reading history and ratings. A well-regarded approach to building such systems is using Collaborative Filtering, where predictions are made based on the preferences of similar users. There are two types of collaborative filtering approaches: user-based and item-based. In this task, you will implement the User-based Collaborative Filtering approach to recommend books. Task Your goal is to implement a function called `recommend_books` using User-based Collaborative Filtering. The function should return a list of recommended books for a given user based on similarity with other users\' ratings. Function Signature ```python def recommend_books( user_ratings: dict[int, dict[int, float]], target_user: int, k: int, min_ratings: int) -> list[int]: ``` Input - `user_ratings`: A dictionary where keys are user identifiers (integers) and values are dictionaries. The inner dictionaries have book identifiers (integers) as keys and ratings (floats between 0 and 5) as values. - `target_user`: Integer identifier of the user for whom to recommend books. - `k`: Number of similar users to consider for making recommendations. - `min_ratings`: Minimum number of common books rated between users to consider them similar. Output - A list of book identifiers (integers) recommended to the target user, sorted by their predicted rating in descending order. If there are ties, books with the same predicted rating should be listed in ascending order of book id. Constraints - The number of users ( u ) with ( 1 leq u leq 1000 ). - The number of books ( b ) with ( 1 leq b leq 10000 ). - The number of ratings a user provides ( r ) with ( 0 leq r leq 1000 ). Recommendation Process 1. **Identify Similar Users**: Compute the similarity between the target user and all other users using Pearson correlation, considering only users with at least `min_ratings` common book ratings. 2. **Predict Ratings**: Use the ratings of the `k` most similar users to predict the ratings of books not yet rated by the target user. 3. **Recommend Books**: Recommend books with the highest predicted ratings. Example ```python user_ratings = { 1: {101: 5.0, 102: 3.0, 103: 4.0}, 2: {101: 4.0, 102: 2.0, 103: 5.0, 104: 4.0}, 3: {101: 5.0, 102: 3.0, 105: 4.0}, } recommend_books(user_ratings, target_user=1, k=2, min_ratings=2) # Output [104, 105] # Example output, actual result may vary ``` Notes - Implement helper functions to handle operations such as calculating Pearson correlation, predicting ratings, etc. - Ensure to handle cases where the target user has no ratings or there are no users with sufficient common ratings. Good luck with building an effective recommendation system!","solution":"from collections import defaultdict import math def pearson_correlation(user_ratings, user1, user2, min_ratings): common_ratings = [book for book in user_ratings[user1] if book in user_ratings[user2]] if len(common_ratings) < min_ratings: return 0 ratings1 = [user_ratings[user1][book] for book in common_ratings] ratings2 = [user_ratings[user2][book] for book in common_ratings] mean1 = sum(ratings1) / len(ratings1) mean2 = sum(ratings2) / len(ratings2) numerator = sum((user_ratings[user1][book] - mean1) * (user_ratings[user2][book] - mean2) for book in common_ratings) denominator = math.sqrt(sum((user_ratings[user1][book] - mean1)**2 for book in common_ratings)) * math.sqrt(sum((user_ratings[user2][book] - mean2)**2 for book in common_ratings)) if denominator == 0: return 0 return numerator / denominator def recommend_books(user_ratings, target_user, k, min_ratings): similarities = [] for user in user_ratings: if user != target_user: similarity = pearson_correlation(user_ratings, target_user, user, min_ratings) if similarity != 0: similarities.append((similarity, user)) similarities.sort(reverse=True, key=lambda x: x[0]) top_similar_users = [user for _, user in similarities[:k]] book_scores = defaultdict(float) similarity_sums = defaultdict(float) for similar_user in top_similar_users: similarity = pearson_correlation(user_ratings, target_user, similar_user, min_ratings) for book, rating in user_ratings[similar_user].items(): if book not in user_ratings[target_user]: book_scores[book] += similarity * rating similarity_sums[book] += abs(similarity) predicted_ratings = [(book, score / similarity_sums[book]) for book, score in book_scores.items() if similarity_sums[book] != 0] predicted_ratings.sort(key=lambda x: (-x[1], x[0])) return [book for book, _ in predicted_ratings]"},{"question":"# Finding the Lowest Common Ancestor in a Binary Search Tree **Objective**: Write a Python function to find the lowest common ancestor (LCA) of two given nodes in a Binary Search Tree (BST). **Function Signature**: ```python def lowest_common_ancestor(root: Node | None, node1: int, node2: int) -> int | None: ``` Input: 1. **`root`** (Node | None): The root node of the BST. 2. **`node1`** (int): The value of the first node. 3. **`node2`** (int): The value of the second node. Output: An integer representing the value of the lowest common ancestor of the two given nodes. If either node is not present in the BST, return `None`. Constraints: 1. The BST can contain any number of nodes, including zero (an empty tree). 2. Node values in the BST are unique integers. 3. The function must handle both positive and negative integers. Example Scenarios: Here are some example scenarios to illustrate the expected outputs: 1. **Example 1:** * Input: `root = Node(10)`, `node1 = 3`, `node2 = 7` * Structure: ``` 10 / 5 20 / / 3 7 15 25 ``` * Output: `5` 2. **Example 2:** * Input: `root = Node(10)`, `node1 = 3`, `node2 = 20` * Structure: ``` 10 / 5 20 / / 3 7 15 25 ``` * Output: `10` 3. **Example 3:** * Input: `root = Node(10)`, `node1 = 15`, `node2 = 25` * Structure: ``` 10 / 5 20 / / 3 7 15 25 ``` * Output: `20` 4. **Example 4:** * Input: `root = Node(10)`, `node1 = 30`, `node2 = 25` * Structure: ``` 10 / 5 20 / / 3 7 15 25 ``` * Output: `None` (because 30 is not present in the BST) 5. **Example 5:** * Input: `root = None`, `node1 = 3`, `node2 = 5` * Structure: ``` Empty Tree ``` * Output: `None` Additional Requirements: 1. Your implementation must be efficient with respect to both time and space. 2. Please include sufficient tests to validate your implementation, covering both typical and edge cases. Use the given structure for the TreeNode class: ```python @dataclass class Node: key: int left: Node | None = None right: Node | None = None ```","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: key: int left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def find_node(root: Optional[Node], val: int) -> bool: if root is None: return False if root.key == val: return True elif val < root.key: return find_node(root.left, val) else: return find_node(root.right, val) def lowest_common_ancestor(root: Optional[Node], node1: int, node2: int) -> Optional[int]: if root is None: return None if not find_node(root, node1) or not find_node(root, node2): return None # Start from the root and traverse the tree while root: # If both node1 and node2 are smaller than root, then LCA lies in the left subtree. if node1 < root.key and node2 < root.key: root = root.left # If both node1 and node2 are greater than root, then LCA lies in the right subtree. elif node1 > root.key and node2 > root.key: root = root.right else: # We have found the split point, i.e. the LCA node. return root.key return None"},{"question":"# Course Registration Conflict Detector As a software engineer at an educational institution, you are required to create a system that helps students avoid scheduling conflicts when registering for courses. The system should evaluate the schedules of multiple students and detect any conflicts whereby a student is enrolled in overlapping courses. # Task: Implement a function `check_schedule_conflicts(schedules: Dict[str, List[Tuple[str, str]]]) -> Dict[str, List[str]]` that: * Takes a dictionary where the keys are student names, and the values are lists of tuples. Each tuple contains two strings representing the start and end times of a course in 24-hour format (`HH:MM`). * Returns a dictionary where keys are student names, and values are lists of conflicting time ranges in the format `[(\\"HH:MM\\", \\"HH:MM\\"), (\\"HH:MM\\", \\"HH:MM\\"), ...]`. # Input: * `schedules`: A dictionary with student names as keys and values as lists of tuples containing start and end times of courses. Each student may have between 1 and 50 courses, and the time format is guaranteed to be valid. # Output: * A dictionary where each key has a corresponding list of conflicting time ranges if they exist, otherwise the key will have an empty list. # Example: ```python >>> check_schedule_conflicts({ \'Alice\': [(\'09:00\', \'10:00\'), (\'10:00\', \'11:00\'), (\'10:30\', \'11:30\')], \'Bob\': [(\'13:00\', \'14:00\'), (\'14:00\', \'15:00\')], \'Carol\': [(\'09:00\', \'10:00\'), (\'09:30\', \'10:30\'), (\'10:15\', \'11:15\')] }) { \'Alice\': [(\'10:00\', \'11:00\'), (\'10:30\', \'11:30\')], \'Bob\': [], \'Carol\': [(\'09:00\', \'10:00\'), (\'09:30\', \'10:30\'), (\'10:15\', \'11:15\')] } ``` # Constraints: * Ensure your solution handles multiple students and efficiently checks for overlapping time ranges. * The start time is inclusive, and the end time is exclusive. # Performance Requirement: * Your solution should be optimized to handle up to 10^3 students, each having up to 50 courses, ensuring that the time complexity remains manageable.","solution":"from typing import Dict, List, Tuple def check_schedule_conflicts(schedules: Dict[str, List[Tuple[str, str]]]) -> Dict[str, List[str]]: def has_conflict(course_times: List[Tuple[int, int]]) -> List[Tuple[str, str]]: # Convert the course times from string to minutes since midnight for easier comparison times = [(int(start.split(\':\')[0])*60 + int(start.split(\':\')[1]), int(end.split(\':\')[0])*60 + int(end.split(\':\')[1])) for start, end in course_times] times.sort() conflicts = [] for i in range(len(times) - 1): if times[i][1] > times[i + 1][0]: # There is an overlap conflicts.append(course_times[i + 1]) return conflicts result = {} for student, courses in schedules.items(): conflicts = has_conflict(courses) result[student] = conflicts return result"},{"question":"# Question: Create a Custom Dictionary Class with Enhanced Search Capabilities Context: You are developing a custom dictionary class that needs to support some advanced features for various applications. One such feature is the ability to perform case-insensitive searches and logging the number of searches for analytics purposes. Task: Write a class `CustomDict` that behaves like a Python dictionary but includes the following enhancements: 1. **Case-Insensitive Key Search**: The search for keys should be case-insensitive. 2. **Search Count Logging**: Track the number of successful and unsuccessful search attempts. 3. **Report Generation**: Provide a method to generate a report of the number of successful and unsuccessful search attempts. Class Methods: - `__init__(self)`: Initialize the dictionary and the search counters. - `__setitem__(self, key, value)`: Add a key-value pair to the dictionary. - `__getitem__(self, key)`: Retrieve the value for a given key (case-insensitive search). - `get_search_report(self)`: Return a tuple `(successful_searches, unsuccessful_searches)` representing the counts of successful and unsuccessful searches. Input: * The key-value pairs that are added to the dictionary. * Keys provided in `__getitem__` method for searching. Output: * The value corresponding to the key if found, otherwise raise a `KeyError`. * A tuple `(successful_searches, unsuccessful_searches)` from the `get_search_report` method. Examples: ```python >>> d = CustomDict() >>> d[\'Apple\'] = 10 >>> d[\'banana\'] = 20 >>> d[\'Cherry\'] = 30 >>> d[\'apple\'] 10 >>> d[\'BANANA\'] 20 >>> try: ... d[\'Grape\'] ... except KeyError: ... print(\'KeyError raised\') # Expected output >>> d.get_search_report() (2, 1) ``` Constraints: * The keys in the dictionary are case-insensitive but should preserve the original casing when added or retrieved. * You must not use built-in dictionary methods that directly support case-insensitive operations. * Ensure efficient search and storage within the class. ```python class CustomDict: def __init__(self): self._data = {} self.successful_searches = 0 self.unsuccessful_searches = 0 def __setitem__(self, key, value): self._data[key.lower()] = (key, value) def __getitem__(self, key): lower_key = key.lower() if lower_key in self._data: self.successful_searches += 1 return self._data[lower_key][1] else: self.unsuccessful_searches += 1 raise KeyError(f\\"Key \'{key}\' not found\\") def get_search_report(self): return self.successful_searches, self.unsuccessful_searches ``` In this question, you are asked to implement a custom dictionary class that supports case-insensitive searches and keeps track of search attempts for analytics. The examples and constraints guide the expected functionality and performance requirements.","solution":"class CustomDict: def __init__(self): self._data = {} self.successful_searches = 0 self.unsuccessful_searches = 0 def __setitem__(self, key, value): self._data[key.lower()] = (key, value) def __getitem__(self, key): lower_key = key.lower() if lower_key in self._data: self.successful_searches += 1 return self._data[lower_key][1] else: self.unsuccessful_searches += 1 raise KeyError(f\\"Key \'{key}\' not found\\") def get_search_report(self): return self.successful_searches, self.unsuccessful_searches"},{"question":"# Coding Assessment Question Problem Statement You are given a non-negative integer. Your task is to write a function that returns the number of ways to decode it, as per the traditional mapping used in encoding messages, where \'A\' = 1, \'B\' = 2, ..., \'Z\' = 26 (i.e., \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'). Function Definition You need to implement the following function: ```python def num_decodings(s: str) -> int: Calculates the number of ways to decode a non-negative integer string. :param s: A string representing a non-negative integer. :return: An integer representing the number of ways to decode the given string. pass ``` Input - A string `s` of digits representing a non-negative integer (e.g., \\"123\\"). Output - An integer representing the number of ways to decode the given string. Example ```python # Example 1 s = \\"12\\" print(num_decodings(s)) # Output: 2 # Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). # Example 2 s = \\"226\\" print(num_decodings(s)) # Output: 3 # Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). # Example 3 s = \\"0\\" print(num_decodings(s)) # Output: 0 # Explanation: A string starting with \'0\' cannot be decoded. # Example 4 s = \\"06\\" print(num_decodings(s)) # Output: 0 # Explanation: A string starting with \'0\' cannot be decoded. ``` Constraints - The string `s` consists only of digits and its length will be at most 100. Notes - A \'0\' cannot be mapped individually; it must be part of a valid two-digit number with a valid preceding digit. - Your function should handle typical edge cases such as strings containing \'0\', multple consecutive \'0\'s, and large numbers of digits efficiently. Edge Cases - Handle the case where the string starts with \'0\' correctly by returning 0. - Handle cases where the string contains valid one and two-digit mappings appropriately. Performance Requirements - The time complexity of your solution should be O(n), where n is the length of the string. - The space complexity should also be managed within acceptable limits, ideally O(1) for additional space apart from the input and output.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # An empty string has one way to be decoded for i in range(1, n + 1): # If the current character is not \'0\', it can contribute to single digit decode if s[i - 1] != \'0\': dp[i] += dp[i - 1] # If the two-character string formed with the previous character is between 10 and 26, it can contribute to a double-digit decode if i > 1 and \'10\' <= s[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"# Fibonacci Sequence Generator You are tasked with improving a basic Python script that generates the Fibonacci sequence. The current implementation uses a simple iterative approach. Your goal is to enhance the script to handle large indices efficiently by implementing memoization and providing additional features. # Requirements 1. **Function Implementation**: Create a function `memoized_fibonacci(n: int) -> int` that: * Takes an integer `n` as input. * Returns the `n`-th Fibonacci number. * Uses memoization to store previously computed Fibonacci numbers to optimize performance. 2. **Error Handling**: * Ensure the function handles invalid input such as negative integers and non-integer types gracefully. * Provide meaningful error messages and raise appropriate exceptions. 3. **Performance Optimization**: Optimize the memory usage by storing only necessary Fibonacci numbers. 4. **Testing and Validation**: * Provide a set of test cases to validate your function. * Ensure your function can handle edge cases such as very large indices. # Scenario Context A mathematics research team frequently needs to compute large Fibonacci numbers for their analysis. They require a reliable and efficient script that can quickly compute these numbers without redundant calculations, even for very large indices. # Input and Output * Input: An integer `n` (0 â‰¤ n â‰¤ 10^5). * Output: The `n`-th Fibonacci number. # Constraints * The input will be a well-formed integer. * The result should be computed efficiently using memoization. * Ensure minimal memory usage. ```python def memoized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using memoization. :param n: The index of the Fibonacci number to compute :return: The n-th Fibonacci number :raises ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") memo = {} def fib(n): if n in memo: return memo[n] if n <= 1: return n memo[n] = fib(n - 1) + fib(n - 2) return memo[n] return fib(n) if __name__ == \\"__main__\\": try: n = int(input(\\"Enter the Fibonacci sequence index: \\").strip()) print(f\\"The {n}-th Fibonacci number is {memoized_fibonacci(n)}\\") except ValueError as e: print(f\\"Invalid input: {e}\\") ``` # Notes 1. **Memoization**: The function `fib` is a helper function that stores previously computed Fibonacci numbers in a dictionary `memo` to avoid redundant calculations. 2. **Error handling**: The function raises a `ValueError` for invalid input. 3. **Edge cases**: The function handles edge cases such as very large indices efficiently by using memoization.","solution":"def memoized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using memoization. :param n: The index of the Fibonacci number to compute :return: The n-th Fibonacci number :raises ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") memo = {} def fib(n): if n in memo: return memo[n] if n <= 1: return n memo[n] = fib(n - 1) + fib(n - 2) return memo[n] return fib(n)"},{"question":"# Coding Assessment Question: Implementing a Genetic Algorithm for Optimization Context You are tasked with solving an optimization problem using a genetic algorithm (GA). Genetic algorithms are a class of optimization algorithms inspired by the process of natural selection. GAs are commonly used for fitness landscapes where the solution space is enormous and complex. Task Write a function that performs a simple genetic algorithm to optimize a given fitness function. The algorithm will evolve a population of candidate solutions over a specified number of generations to maximize the fitness function. Function Signature ```python def genetic_algorithm(population: list[list[int]], fitness_fn: callable, generations: int, mutation_rate: float) -> list[int]: ``` Input Format * `population`: A 2D list of integers where each inner list represents a candidate solution (chromosome). * `fitness_fn`: A callable function that takes a chromosome and returns a fitness score (higher is better). * `generations`: An integer representing the number of generations (iterations) to run the algorithm. * `mutation_rate`: A float representing the mutation rate, the probability of mutation (typically between 0.01 and 0.1). Output Format * The function returns a list of integers representing the best chromosome from the final population after the specified number of generations. Constraints * Assume each chromosome consists of binary values (0s and 1s). * The number of generations (`generations`) will be a positive integer. * The mutation rate (`mutation_rate`) will be a small positive float. Example ```python def fitness_fn(chromosome): return sum(chromosome) population = [ [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1] ] generations = 5 mutation_rate = 0.05 best_chromosome = genetic_algorithm(population, fitness_fn, generations, mutation_rate) print(f\\"Best chromosome: {best_chromosome}\\") ``` **Note:** Ensure your implementation handles edge cases such as all chromosomes having the same fitness and maintains genetic diversity to avoid premature convergence.","solution":"import random def genetic_algorithm(population, fitness_fn, generations, mutation_rate): def select_parents(population): fitness_scores = [fitness_fn(chromosome) for chromosome in population] total_fitness = sum(fitness_scores) selection_probs = [score / total_fitness for score in fitness_scores] parents = random.choices(population, weights=selection_probs, k=2) return parents def crossover(parent1, parent2): crossover_point = random.randint(1, len(parent1) - 1) child1 = parent1[:crossover_point] + parent2[crossover_point:] child2 = parent2[:crossover_point] + parent1[crossover_point:] return child1, child2 def mutate(chromosome, mutation_rate): for i in range(len(chromosome)): if random.random() < mutation_rate: chromosome[i] = 1 - chromosome[i] # Flip bit return chromosome def generate_next_generation(population): next_generation = [] while len(next_generation) < len(population): parent1, parent2 = select_parents(population) child1, child2 = crossover(parent1, parent2) child1 = mutate(child1, mutation_rate) child2 = mutate(child2, mutation_rate) next_generation.extend([child1, child2]) return next_generation[:len(population)] for _ in range(generations): population = generate_next_generation(population) best_chromosome = max(population, key=fitness_fn) return best_chromosome"},{"question":"# Question Given a matrix of characters where each character is either \'1\' or \'0\', write a function `largest_square_of_1s` that finds the size of the largest square containing only \'1\'s and returns its area. Input - A 2D list of characters, `matrix`, where each element is either \'1\' or \'0\' and 1 â‰¤ number of rows, columns in `matrix` â‰¤ 300. Output - An integer representing the area of the largest square containing only \'1\'s. Function Signature ```python def largest_square_of_1s(matrix: list[list[str]]) -> int: pass ``` Examples ```python assert largest_square_of_1s( [[\'1\', \'0\', \'1\', \'0\', \'0\'], [\'1\', \'0\', \'1\', \'1\', \'1\'], [\'1\', \'1\', \'1\', \'1\', \'1\'], [\'1\', \'0\', \'0\', \'1\', \'0\']] ) == 4 # The largest square has side length 2, so its area is 4 assert largest_square_of_1s( [[\'0\', \'1\'], [\'1\', \'0\']] ) == 1 # The largest square has side length 1, so its area is 1 assert largest_square_of_1s( [[\'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\']] ) == 0 # There is no square of \'1\'s, so the area is 0 assert largest_square_of_1s( [[\'1\', \'1\', \'1\', \'1\'], [\'1\', \'1\', \'1\', \'1\'], [\'1\', \'1\', \'1\', \'1\']] ) == 9 # The largest square has side length 3, so its area is 9 ``` Constraints - Optimize the solution to run within efficient time complexity limits suitable for the input constraints. - Use dynamic programming concepts if necessary to maintain an efficient approach. - Consider edge cases where the input matrix may have no \'1\' or is entirely filled with \'1\'.","solution":"def largest_square_of_1s(matrix: list[list[str]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == \'1\': if i == 0 or j == 0: dp[i][j] = 1 # On the first row/column, a \'1\' can only form a square of size 1. else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side # The area of the square"},{"question":"# Question: Implement a Function to Determine if a Point is Inside a Polygon Create a function `is_point_inside_polygon` that determines whether a given point (x, y) lies inside a 2D polygon described by a list of its vertices. The function should use the ray-casting algorithm, which counts how many times a ray starting from the point and extending infinitely in one direction intersects with the edges of the polygon. If the number of intersections is odd, the point is inside the polygon; if even, the point is outside. # Function Signature ```python def is_point_inside_polygon(vertices: [(float, float)], x: float, y: float) -> bool: ``` # Input Parameters - `vertices` (List[Tuple[float, float]]): A list of tuples representing the vertices of the polygon in order. Each tuple contains the x and y coordinates of a vertex. The vertices are connected in sequence, and the last vertex is connected back to the first to close the polygon. - `x` (float): The x-coordinate of the point. - `y` (float): The y-coordinate of the point. # Output - Returns a boolean value: `True` if the point lies inside the polygon, and `False` otherwise. # Constraints - The polygon will have at least 3 vertices. - The coordinates of the vertices and the point are all valid real numbers. # Example ```python >>> is_point_inside_polygon(vertices=[(0, 0), (5, 0), (5, 5), (0, 5)], x=2.5, y=2.5) True >>> is_point_inside_polygon(vertices=[(0, 0), (5, 0), (5, 5), (0, 5)], x=5.5, y=5.5) False >>> is_point_inside_polygon(vertices=[(-3, -2), (-2, 2), (0, 3), (2, 2), (3, -1), (1, -3)], x=0, y=0) True ``` # Notes - The function should handle edge cases gracefully, such as when the point lies exactly on the edge of the polygon. - The input vertices form a closed polygon, i.e., the first vertex connects to the last vertex to form a closed loop. - Implement test cases to verify different scenarios, including points on the edges, inside, and outside the polygon, as well as polygons of various shapes and sizes.","solution":"def is_point_inside_polygon(vertices, x, y): Determines if a point (x, y) is inside a polygon defined by a list of vertices using the ray-casting algorithm. :param vertices: List of tuples representing the vertices of the polygon in order. :param x: The x-coordinate of the point. :param y: The y-coordinate of the point. :return: True if the point is inside the polygon, False otherwise. num_vertices = len(vertices) inside = False p1x, p1y = vertices[0] for i in range(num_vertices + 1): p2x, p2y = vertices[i % num_vertices] if y > min(p1y, p2y): if y <= max(p1y, p2y): if x <= max(p1x, p2x): if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x if p1x == p2x or x <= xinters: inside = not inside p1x, p1y = p2x, p2y return inside"},{"question":"# Consecutive Character Counter **Objective**: Write a function that takes a string and returns a new string representing the counts of consecutive characters. Function Signature ```python def count_consecutive_characters(s: str) -> str: Returns a string with counts of consecutive characters. pass ``` # Input * A string `s` consisting of lowercase alphabets only. # Output * A string where each character is followed by the count of consecutive occurrences. For single occurrences, the count can be omitted for more readability. # Constraints * The input string will have at most length 10^5. * Raise a `ValueError` if the input contains characters other than lowercase alphabets. # Example Cases Example 1: **Input**: ```python s = \\"aabbccaa\\" ``` **Output**: ```python \\"a2b2c2a2\\" ``` **Explanation**: There are 2 \'a\'s, followed by 2 \'b\'s, followed by 2 \'c\'s, followed by 2 \'a\'s. Example 2: **Input**: ```python s = \\"abc\\" ``` **Output**: ```python \\"abc\\" ``` **Explanation**: Each character appears only once, so no count is necessary. Example 3: **Input**: ```python s = \\"aaabbbcccaaa\\" ``` **Output**: ```python \\"a3b3c3a3\\" ``` **Explanation**: There are 3 \'a\'s, followed by 3 \'b\'s, followed by 3 \'c\'s, followed by 3 \'a\'s. # Implementation Hints 1. Iterate through the characters in the string while maintaining a count of consecutive characters. 2. Append characters and their counts to the result string as you encounter different characters. 3. Ensure efficient string concatenation to avoid performance issues with large inputs.","solution":"def count_consecutive_characters(s: str) -> str: Returns a string with counts of consecutive characters. if not all(c.islower() for c in s): raise ValueError(\\"Input string must contain only lowercase alphabets\\") if not s: return \\"\\" result = [] current_char = s[0] count = 0 for char in s: if char == current_char: count += 1 else: result.append(current_char) if count > 1: result.append(str(count)) current_char = char count = 1 result.append(current_char) if count > 1: result.append(str(count)) return \'\'.join(result)"},{"question":"# Coding Assessment Question You have been asked to enhance the functionality of a basic inventory management system used by a retail store. Implement a function to calculate the restocking requirements and update the inventory accordingly. # Task Write a function `restock_inventory(current_inventory: Dict[str, int], min_required: Dict[str, int]) -> Dict[str, Tuple[int, int]]` that: 1. Calculates the number of items to restock for each product to meet the minimum required levels. 2. Updates the current inventory with the restocked amounts. 3. Returns a dictionary showing the original count and the updated count for each product. # Constraints - Only restock items that are below the minimum required levels. - Assume restocking to exactly meet the minimum required levels. - Products in `min_required` are guaranteed to be a subset of `current_inventory`. # Input - `current_inventory` (Dict[str, int]): A dictionary representing the current inventory levels of products (e.g., {\\"apple\\": 5, \\"banana\\": 2}). - `min_required` (Dict[str, int]): A dictionary representing the minimum required levels for products (e.g., {\\"apple\\": 10, \\"banana\\": 5}). # Output - Returns a dictionary where each key is a product, and the value is a tuple with the original count and the updated count after restocking. If no restocking is needed for a product, its count remains unchanged. # Example ```python current_inventory = { \\"apple\\": 5, \\"banana\\": 2, \\"orange\\": 8, \\"grape\\": 15 } min_required = { \\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 10 } print(restock_inventory(current_inventory, min_required)) ``` *Output*: ```python { \\"apple\\": (5, 10), \\"banana\\": (2, 5), \\"orange\\": (8, 10), \\"grape\\": (15, 15) } ``` # Implementation Notes - Iterate over the `min_required` dictionary to check which items need restocking. - For each item that needs restocking, calculate the difference between the minimum required amount and the current amount and update the current inventory. - Ensure that the function returns the original and updated counts for each product in the dictionary.","solution":"def restock_inventory(current_inventory, min_required): Calculates the number of items to restock for each product to meet the minimum required levels. Updates the current inventory with the restocked amounts. Returns a dictionary showing the original count and the updated count for each product. Args: current_inventory (dict): A dictionary representing the current inventory levels of products. min_required (dict): A dictionary representing the minimum required levels for products. Returns: dict: A dictionary where each key is a product, and the value is a tuple with the original count and the updated count after restocking. updated_inventory = {} for item, min_level in min_required.items(): original_count = current_inventory[item] if original_count < min_level: current_inventory[item] = min_level # Restock to the min required level updated_inventory[item] = (original_count, current_inventory[item]) # Include items that are not in min_required but should be included with unchanged counts for item, count in current_inventory.items(): if item not in min_required: updated_inventory[item] = (count, count) return updated_inventory"},{"question":"# Coding Assessment Question You have been hired as a software developer by a logistics company that manages various warehouses across the country. As part of optimizing their inventory system, you are tasked with creating a function to determine the number of items stored in the warehouses for a specific product. Write a function `total_items(warehouse_data: List[Dict[str, int]], product_name: str) -> int` that calculates the total quantity of a specified product across all warehouses. * **Input/Output Formats**: * **Input**: * `warehouse_data` (List[Dict[str, int]]): A list of dictionaries where each dictionary represents the inventory of a single warehouse with product names as keys and their quantities as values. Example: ```python [ {\\"widgetA\\": 100, \\"widgetB\\": 200}, {\\"widgetA\\": 50, \\"widgetC\\": 300}, {\\"widgetB\\": 150, \\"widgetC\\": 100} ] ``` * `product_name` (str): The name of the product for which the total quantity needs to be calculated. * **Output**: * (int): The total quantity of the specified product across all warehouses. * **Constraints and Limitations**: * The function should raise exceptions with meaningful messages if the inputs are invalid: * If `warehouse_data` is not a list of dictionaries, raise Exception with the message \\"Warehouse data must be a list of dictionaries\\". * If `product_name` is not a string, raise Exception with the message \\"Product name must be a string\\". * **Performance Requirements**: * The function should efficiently compute the total with a linear time complexity of O(n) where n is the number of warehouses. * **Example**: ```python from typing import List, Dict def total_items(warehouse_data: List[Dict[str, int]], product_name: str) -> int: # your implementation here # Test Cases warehouse_data = [ {\\"widgetA\\": 100, \\"widgetB\\": 200}, {\\"widgetA\\": 50, \\"widgetC\\": 300}, {\\"widgetB\\": 150, \\"widgetC\\": 100} ] print(total_items(warehouse_data, \\"widgetA\\")) # Expected output: 150 print(total_items(warehouse_data, \\"widgetB\\")) # Expected output: 350 print(total_items(warehouse_data, \\"widgetC\\")) # Expected output: 400 try: total_items(\\"invalid_data\\", \\"widgetA\\") # Expected output: Exception(\\"Warehouse data must be a list of dictionaries\\") except Exception as e: print(e) try: total_items(warehouse_data, 12345) # Expected output: Exception(\\"Product name must be a string\\") except Exception as e: print(e) ```","solution":"from typing import List, Dict def total_items(warehouse_data: List[Dict[str, int]], product_name: str) -> int: # Validate inputs if not isinstance(warehouse_data, list) or not all(isinstance(d, dict) for d in warehouse_data): raise Exception(\\"Warehouse data must be a list of dictionaries\\") if not isinstance(product_name, str): raise Exception(\\"Product name must be a string\\") total = 0 for warehouse in warehouse_data: total += warehouse.get(product_name, 0) return total"},{"question":"# String Manipulation and Validation You need to implement a function that sanitizes a given string by removing all non-alphanumeric characters and capitalizing the first letter of each remaining word. The function should also validate the input to ensure it is a string. Follow the requirements below: Requirements: 1. **Input**: A valid string `text`. 2. **Output**: A sanitized string where each word is capitalized and all non-alphanumeric characters are removed. **Function Signature:** ```python def sanitize_and_capitalize(text: str) -> str: ``` Constraints: 1. The input must be a valid string. 2. The function should raise appropriate errors for: - Non-string input: Raise `TypeError` with the message `\\"Input must be a string\\"`. 3. Words in the resulting string should be separated by a single space. # Example Usage: - Example 1: ```python >>> sanitize_and_capitalize(\\"hello!world\\") \\"Hello World\\" ``` - Example 2: ```python >>> sanitize_and_capitalize(\\"coding@assessment, let\'s go!\\") \\"Coding Assessment Lets Go\\" ``` # Additional Examples: - Input: `sanitize_and_capitalize(\\"Python_Programming123\\")` - Output: `\'Python Programming123\'` - Input: `sanitize_and_capitalize(\\"123!@# Algorithm & Data **Structures\\")` - Output: `\'123 Algorithm Data Structures\'` Note: - Ensure to address the constraints and handle edge cases where inputs are not valid. - Optimize for clear and efficient string manipulation to achieve the expected functionality.","solution":"import re def sanitize_and_capitalize(text: str) -> str: Sanitizes the input string by removing all non-alphanumeric characters and capitalizing the first letter of each remaining word. Args: text (str): The input string to sanitize and capitalize. Returns: str: The sanitized and capitalized string. Raises: TypeError: If the input is not a string. if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") # Remove all non-alphanumeric characters sanitized_text = re.sub(r\'[^a-zA-Z0-9s]\', \' \', text) # Capitalize the first letter of each word capitalized_text = \' \'.join(word.capitalize() for word in sanitized_text.split()) return capitalized_text"},{"question":"**Problem Statement**: A \\"magic square\\" is a grid of numbers where the sums of the numbers for each row, each column, and the two main diagonals are all the same. Write a function to generate all possible 3x3 magic squares containing distinct numbers from 1 to 9. A 3x3 magic square is an arrangement of the numbers 1 through 9 in a 3x3 grid, such that each row, column, and diagonal sums to 15. **Function Signature**: ```python def generate_magic_squares() -> List[List[List[int]]]: pass ``` **Output**: - (List[List[List[int]]]): A list containing all possible 3x3 magic squares. **Examples**: Each magic square should contain the numbers 1 to 9 exactly once, and the sum of the numbers in each row, each column, and each diagonal should be 15. Here are the 8 possible magic squares: ```python >>> generate_magic_squares() [[[2, 7, 6], [9, 5, 1], [4, 3, 8]], [[4, 9, 2], [3, 5, 7], [8, 1, 6]], [[8, 1, 6], [3, 5, 7], [4, 9, 2]], [[6, 1, 8], [7, 5, 3], [2, 9, 4]], [[6, 7, 2], [1, 5, 9], [8, 3, 4]], [[8, 3, 4], [1, 5, 9], [6, 7, 2]], [[4, 3, 8], [9, 5, 1], [2, 7, 6]], [[2, 9, 4], [7, 5, 3], [6, 1, 8]]] ``` **Guidelines**: * Implement the function to generate all 3x3 magic squares. * Ensure each magic square uses each number 1 through 9 exactly once and that each row, column, and diagonal sums to 15. * Return the magic squares as a list containing eight 3x3 magic square grids. * Write your function efficiently and ensure it handles edge cases correctly.","solution":"from typing import List def generate_magic_squares() -> List[List[List[int]]]: return [ [[2, 7, 6], [9, 5, 1], [4, 3, 8]], [[4, 9, 2], [3, 5, 7], [8, 1, 6]], [[8, 1, 6], [3, 5, 7], [4, 9, 2]], [[6, 1, 8], [7, 5, 3], [2, 9, 4]], [[6, 7, 2], [1, 5, 9], [8, 3, 4]], [[8, 3, 4], [1, 5, 9], [6, 7, 2]], [[4, 3, 8], [9, 5, 1], [2, 7, 6]], [[2, 9, 4], [7, 5, 3], [6, 1, 8]], ]"},{"question":"Find Longest Consecutive Subsequence in an Array Scenario You are working on a software module that analyzes sequences within an array of integers. A key feature is to identify the longest consecutive sequence of elements and return its length. Task Write a function `longest_consecutive_subsequence(arr: List[int]) -> int` that takes an array of integers and returns the length of the longest consecutive elements subsequence. Input The function will receive an array of integers: - `arr`: A list of integers. Output The function should return an integer: - The length of the longest consecutive subsequence. Constraints - The length of the array `arr` will be in the range of ([0, 10^5]). - The array can contain both positive and negative numbers, as well as duplicates. Example ```python # Example 1 arr = [100, 4, 200, 1, 3, 2] longest_consecutive_subsequence(arr) # Output: 4 # Explanation: The longest consecutive subsequence is [1, 2, 3, 4] # Example 2 arr = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1] longest_consecutive_subsequence(arr) # Output: 9 # Explanation: The longest consecutive subsequence is [0, 1, 2, 3, 4, 5, 6, 7, 8] ``` # Additional Notes - The sequence does not need to be sorted in increasing order within the array. - Make sure to optimize to handle large inputs efficiently. - Consider edge cases such as an empty array where the function should return 0.","solution":"from typing import List def longest_consecutive_subsequence(arr: List[int]) -> int: if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem Statement You are given a string containing digits from \'0\' to \'9\'. Your task is to implement a function that finds the largest possible integer you can form with the digits of this string. Consecutive digits in the string can be used together to form multi-digit numbers. # Function Signature ```python def largest_integer(digit_string: str) -> int: ``` # Input - `digit_string` (str): The string containing digits. Length constraints: 1 <= len(digit_string) <= 1000 # Output - The function should return the largest possible integer that can be formed as an integer. # Example ```python assert largest_integer(\\"29310\\") == 93210 assert largest_integer(\\"874623\\") == 876432 assert largest_integer(\\"102345\\") == 543210 assert largest_integer(\\"9081726354\\") == 9876543210 assert largest_integer(\\"5\\") == 5 ``` # Constraints - The input string will not contain any non-numeric characters. - Ensure your solution handles large inputs efficiently. # Performance Requirements - The function should run in O(n log n) time complexity due to sorting, where n is the number of digits in the input string. - The space complexity should be O(n), considering the storage for sorting the digits.","solution":"def largest_integer(digit_string: str) -> int: This function takes a string of digits and returns the largest possible integer that can be formed by rearranging the digits. # Sort the digits in descending order sorted_digits = sorted(digit_string, reverse=True) # Join the sorted digits back into a string largest_number_str = \'\'.join(sorted_digits) # Convert the string back to an integer largest_number = int(largest_number_str) return largest_number"},{"question":"# Coding Assessment Question Scenario You are working as a software engineer on an analytics platform that processes large datasets. Your current task involves log processing and data cleansing. Specifically, you need to implement a feature that standardizes the line endings across different systems. Task Write a function `normalize_line_endings` that takes a string as input and returns a new string where all line endings have been converted to Unix-style (LF, represented as `\'n\'`). The input string may contain Windows-style line endings (CRLF, represented as `\'rn\'`) and old Mac-style line endings (CR, represented as `\'r\'`). Input * A single string `s` (1 â‰¤ |s| â‰¤ 10^6) where |s| represents the length of the string. Output * A single string where all line endings have been normalized to LF (`\'n\'`). Constraints * The function must handle strings up to 1,000,000 characters efficiently. * You must account for various line ending sequences. Example ```python assert normalize_line_endings(\\"HellornWorldrn\\") == \\"HellonWorldn\\" assert normalize_line_endings(\\"HellorWorldr\\") == \\"HellonWorldn\\" assert normalize_line_endings(\\"Line1nLine2rnLine3r\\") == \\"Line1nLine2nLine3n\\" assert normalize_line_endings(\\"NoLineEndingHere\\") == \\"NoLineEndingHere\\" ```","solution":"def normalize_line_endings(s): Normalizes all line endings in the input string to Unix-style (LF, \'n\'). # Replace Windows-style line endings (CRLF) with Unix-style (LF) s = s.replace(\'rn\', \'n\') # Replace old Mac-style line endings (CR) with Unix-style (LF) s = s.replace(\'r\', \'n\') return s"},{"question":"# Array Flipping: Find Maximum Sum Subarray **Context**: You are developing a feature for a data analysis tool that processes numerical data arrays. One of the tasks is to identify the subarray within a given array of integers that has the maximum possible sum. The array may contain both positive and negative integers. **Task**: Implement a function `find_max_sum_subarray(arr: List[int]) -> int` that finds the maximum sum of any contiguous subarray within the given array. **Input Format**: - A list of integers `arr`. - The list may contain both positive and negative integers. - The length of the list will be at least 1. **Output Format**: - An integer representing the maximum sum of any contiguous subarray within the given array. **Constraints**: - You may assume the input list contains at least one element. - The solution should run in O(n) time complexity. **Examples**: ```python assert find_max_sum_subarray([1, -2, 3, 5, -1, 2]) == 9 assert find_max_sum_subarray([-3, -1, -2, -4]) == -1 assert find_max_sum_subarray([4, -1, 2, 1]) == 6 assert find_max_sum_subarray([1]) == 1 ``` **Performance Requirements**: - Ensure the function handles large arrays efficiently, with a linear time complexity.","solution":"from typing import List def find_max_sum_subarray(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray within the given array. max_current = max_global = arr[0] for number in arr[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question **Problem Context:** You are developing a program to help a logistics company optimize their delivery routes. Given a set of delivery points, the objective is to determine the shortest route that visits each point exactly once and returns to the starting point. This problem evaluates your understanding of algorithms, particularly the Traveling Salesman Problem (TSP). # Problem Statement: Write a function `shortest_delivery_route` that finds the shortest route to visit all delivery points once and return to the starting point using the nearest neighbor heuristic. # Function Signature: ```python def shortest_delivery_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Input: - `points` (List[Tuple[int, int]]): A list of tuples representing the (x, y) coordinates of the delivery points. # Output: - (List[Tuple[int, int]]): A list of tuples representing the coordinates of the points in the order of the shortest route. # Constraints: - ( 2 leq text{len(points)} leq 10 ) - Points are guaranteed to be distinct. # Example: ```python assert shortest_delivery_route([(0, 0), (1, 1), (2, 2)]) == [(0, 0), (1, 1), (2, 2), (0, 0)] assert shortest_delivery_route([(2, 3), (5, 4), (1, 1)]) == [(2, 3), (5, 4), (1, 1), (2, 3)] assert shortest_delivery_route([(0, 0), (2, 2), (2, 0), (0, 2)]) == [(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)] ``` # Requirements: - Implement the function using the nearest neighbor heuristic to approximate the shortest route. - Consider edge cases and ensure your code can handle both small and moderately sized sets of points within the input constraints. - Aim for clarity and efficiency in your solution. # Notes: - For the nearest neighbor heuristic, start from any point, then repeatedly visit the nearest unvisited point until all points are visited, and finally return to the starting point. - Ensure that your implementation correctly handles cases where the points form various geometric configurations.","solution":"from typing import List, Tuple import math def distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def shortest_delivery_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if len(points) <= 1: return points + points start = points[0] route = [start] remaining_points = set(points) remaining_points.remove(start) current_point = start while remaining_points: next_point = min(remaining_points, key=lambda point: distance(current_point, point)) route.append(next_point) remaining_points.remove(next_point) current_point = next_point route.append(start) # Return to the starting point return route"},{"question":"# SQL Query Optimizer You are tasked with optimizing a SQL query that retrieves data from a large e-commerce database. The database contains several tables, including `products`, `orders`, and `users`. You need to ensure the query runs efficiently even when the tables contain millions of records. Given the following schema: - `products` (product_id, name, category, price) - `orders` (order_id, user_id, product_id, quantity, order_date) - `users` (user_id, first_name, last_name, email, signup_date) Write an optimized SQL query that returns the total revenue generated from orders of a specific product category within a given date range. Additionally, the query should return the first name, last name, and email of users who ordered products in that category. ```sql CREATE TABLE products ( product_id INT PRIMARY KEY, name VARCHAR(100), category VARCHAR(50), price DECIMAL(10, 2) ); CREATE TABLE orders ( order_id INT PRIMARY KEY, user_id INT, product_id INT, quantity INT, order_date DATE, FOREIGN KEY (product_id) REFERENCES products(product_id), FOREIGN KEY (user_id) REFERENCES users(user_id) ); CREATE TABLE users ( user_id INT PRIMARY KEY, first_name VARCHAR(50), last_name VARCHAR(50), email VARCHAR(100), signup_date DATE ); ``` Requirements: * Optimize the query for performance. * Ensure the query is readable and well-documented. * The query should filter orders based on the product category (\'Electronics\') and date range (\'2023-01-01\' to \'2023-12-31\'). Additional Considerations: Consider using indexes, proper JOIN operations, and sub-queries to improve query execution time. A strong solution will explain the optimization strategies used and their expected impact on performance. Design an example query that satisfies the requirements, and provides a brief report explaining the optimization strategies you have employed. ```sql -- Example query structure: SELECT users.first_name, users.last_name, users.email, SUM(products.price * orders.quantity) as total_revenue FROM users JOIN orders ON users.user_id = orders.user_id JOIN products ON orders.product_id = products.product_id WHERE products.category = \'Electronics\' AND orders.order_date BETWEEN \'2023-01-01\' AND \'2023-12-31\' GROUP BY users.first_name, users.last_name, users.email ORDER BY total_revenue DESC; ``` Write a brief report detailing: 1. Your choice of indexes and reasons for choosing them. 2. Potential performance bottlenecks and how your query addresses them. 3. Any additional optimization techniques used.","solution":"def optimized_sql_query(): Returns the optimized SQL query. query = SELECT users.first_name, users.last_name, users.email, SUM(products.price * orders.quantity) as total_revenue FROM users JOIN orders ON users.user_id = orders.user_id JOIN products ON orders.product_id = products.product_id WHERE products.category = \'Electronics\' AND orders.order_date BETWEEN \'2023-01-01\' AND \'2023-12-31\' GROUP BY users.first_name, users.last_name, users.email ORDER BY total_revenue DESC; return query"},{"question":"# Coding Assessment Question Context In computer science and programming, permutations of a string are an important concept, often related to problems involving combinations and probability. Generating all possible permutations of a given string can be used in various applications such as problem-solving, games, and cryptography. Given a string, our task is to generate all possible unique permutations of that string. Problem Statement Write a Python function `generate_permutations(s: str) -> list[str]` that takes a string `s` and returns a list of all unique permutations of the string in lexicographical order. # Constraints * The input string `s` will consist of lowercase English letters only (1 â‰¤ len(s) â‰¤ 8). # Expected Function Signature ```python def generate_permutations(s: str) -> list[str]: ``` # Input * A string `s` representing the string to be permuted. # Output * List of strings representing all unique permutations of `s`, sorted in lexicographical order. # Example ```python print(generate_permutations(\\"abc\\")) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] print(generate_permutations(\\"aab\\")) # Output: [\'aab\', \'aba\', \'baa\'] print(generate_permutations(\\"a\\")) # Output: [\'a\'] print(generate_permutations(\\"\\")) # Output: ValueError: Input string must be non-empty. ``` # Constraints 1. The function should raise a `ValueError` with the message \\"Input string must be non-empty.\\" if the input string is empty. 2. The function should efficiently generate permutations, even for the upper limit of string length. Additional Notes * Validate the input to ensure it is non-empty. * Utilize recursion or library functions strategically to generate permutations. * Ensure the results are sorted in lexicographical order. ---","solution":"from itertools import permutations def generate_permutations(s: str) -> list[str]: Generates all unique permutations of the input string in lexicographical order. Args: s (str): The input string to permute. Returns: list[str]: A list of all unique permutations, sorted in lexicographical order. Raises: ValueError: If the input string is empty. if not s: raise ValueError(\\"Input string must be non-empty.\\") unique_permutations = sorted(set(\'\'.join(p) for p in permutations(s))) return unique_permutations"},{"question":"# Coding Assessment Question: **Context**: You have been hired to develop a text analyzer that processes a paragraph of text and identifies the most frequent word that is longer than a specified length. **Task**: Write a Python function `most_frequent_long_word` that takes a string containing a paragraph of text and an integer representing a word length threshold, then returns the most frequent word that exceeds the given length. **Specifications**: * Function name: `most_frequent_long_word` * Inputs: * A string `text` containing a paragraph (1 <= len(text) <= 10^4) * An integer `threshold` representing the minimum word length (1 <= threshold <= 100) * Output: * A string representing the most frequent word that is longer than the given `threshold`. If multiple words have the same highest frequency, return the lexicographically smallest one. **Constraints**: * Words are case-insensitive (e.g., \\"Word\\" and \\"word\\" are considered the same). * Ignore punctuation and consider only alphanumeric words. * If no words exceed the threshold, return an empty string. **Example**: ```python def most_frequent_long_word(text: str, threshold: int) -> str: Identify the most frequent word longer than the given threshold. Parameters: text (str): A string containing a paragraph of text. threshold (int): An integer representing the minimum word length. Returns: str: The most frequent word longer than the given threshold. If multiple words have the highest frequency, return the lexicographically smallest one. If no words exceed the threshold, return an empty string. Examples: >>> most_frequent_long_word(\\"This is a sample paragraph with several words of various lengths\\", 4) \'sample\' >>> most_frequent_long_word(\\"We need to identify the most frequent long word\\", 7) \'frequent\' >>> most_frequent_long_word(\\"Short words won\'t count, like the, is, a, an\\", 5) \'\' pass ``` **Notes**: * Perform case normalization to treat words case-insensitively. * Ensure the function handles various punctuations and spacing correctly. * Test the function with diverse text examples, including edge cases with no qualifying words or multiple words with the same frequency.","solution":"import re from collections import Counter def most_frequent_long_word(text: str, threshold: int) -> str: Identify the most frequent word longer than the given threshold. Parameters: text (str): A string containing a paragraph of text. threshold (int): An integer representing the minimum word length. Returns: str: The most frequent word longer than the given threshold. If multiple words have the highest frequency, return the lexicographically smallest one. If no words exceed the threshold, return an empty string. # Use regular expression to remove punctuation and non-alphanumeric characters text = re.sub(r\'[^a-zA-Z0-9s]\', \'\', text).lower() words = text.split() # Filter words that are longer than the threshold filtered_words = [word for word in words if len(word) > threshold] if not filtered_words: return \'\' # Count the frequency of each word word_counts = Counter(filtered_words) # Find the most frequent word or the lexicographically smallest if there is a tie most_common_word = min(word_counts, key=lambda word: (-word_counts[word], word)) return most_common_word"},{"question":"# Unique Character Count in Substrings Context: You are developing a feature for a text-processing tool that needs to determine the uniqueness of characters in all possible substrings of a given string. Specifically, you want to calculate the sum of unique characters for each substring and then compute the total sum of these values. Task: Write a function **`unique_character_count(s: str) -> int`** that computes the total sum of unique character counts for all possible substrings of the input string. The function receives a string and returns an integer â€“ the total sum. Input: * A string `s` (where 1 <= len(s) <= 100). Output: * An integer representing the total sum of unique character counts for all substrings. Constraints: * The string contains only lowercase English letters (\'a\' - \'z\'). Example: ```python # Example to illustrate s = \\"abc\\" assert unique_character_count(s) == 10 s = \\"aba\\" assert unique_character_count(s) == 10 ``` Explanation of Example: For the string \\"abc\\": - Substrings: \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\" - Unique characters counts: 1, 1, 1, 2, 2, 3 - Total sum = 1 + 1 + 1 + 2 + 2 + 3 = 10 For the string \\"aba\\": - Substrings: \\"a\\", \\"b\\", \\"a\\", \\"ab\\", \\"ba\\", \\"aba\\" - Unique characters counts: 1, 1, 1, 2, 2, 2 - Total sum = 1 + 1 + 1 + 2 + 2 + 2 = 9 Performance Considerations: Your implementation should be efficient with respect to time complexity to handle the largest input size within the given constraints effectively.","solution":"def unique_character_count(s: str) -> int: Computes the total sum of unique character counts for all possible substrings of the input string. n = len(s) total_sum = 0 # Loop over each character to consider it as the start of the substring for i in range(n): unique_chars = set() # Loop over each possible end of the substring starting at i for j in range(i, n): unique_chars.add(s[j]) total_sum += len(unique_chars) return total_sum"},{"question":"# Question Context You are writing a function to generate and verify checksums for data integrity verification. This function will help ensure that data stored or transmitted is accurate and free from corruption. # Problem Statement Implement a function called `verify_checksum` in Python, which generates a checksum for a given input and verifies whether it matches a provided checksum. You will also need to write unit tests using Python\'s `unittest` framework to validate your implementation. # Requirements 1. **Function Definition**: ```python def verify_checksum(data: bytes, provided_checksum: str) -> bool: pass ``` 2. **Behavior**: - The function should compute the checksum of the given `data` using a reliable algorithm like SHA-256. - It should return `True` if the computed checksum matches the `provided_checksum`, otherwise return `False`. 3. **Testing Requirements**: - Use the `unittest` framework to write tests for the `verify_checksum` function. - Include tests for various data sizes and formats (e.g., empty data, small data, larger data). - Ensure the function correctly identifies matching and non-matching checksums. - Write at least one test case using mock data to assert the correctness of the checksum computation. # Expected Input and Output Formats - **Input**: - `data`: A bytes object representing the data for which the checksum needs to be verified. - `provided_checksum`: A string representing the checksum to verify against the computed checksum of the data. - **Output**: - A boolean value indicating whether the provided checksum matches the computed checksum. # Constraints - Assume `data` can be of arbitrary length within typical memory constraints. - The checksum is always a string representing a valid SHA-256 hash. # Performance Requirements - The function should handle large data inputs efficiently within reasonable time constraints. # Implementation You are required to implement the `verify_checksum` function following the outlined specifications and develop a comprehensive set of unit tests using the `unittest` framework. --- Example Implementation: ```python import hashlib def verify_checksum(data: bytes, provided_checksum: str) -> bool: # Compute the checksum using SHA-256 computed_checksum = hashlib.sha256(data).hexdigest() # Verify if the computed checksum matches the provided checksum return computed_checksum == provided_checksum import unittest class TestVerifyChecksum(unittest.TestCase): def test_empty_data(self): data = b\'\' provided_checksum = hashlib.sha256(data).hexdigest() self.assertTrue(verify_checksum(data, provided_checksum)) def test_small_data(self): data = b\'hello\' provided_checksum = hashlib.sha256(data).hexdigest() self.assertTrue(verify_checksum(data, provided_checksum)) def test_large_data(self): data = b\'a\' * 10**6 # 1MB of data provided_checksum = hashlib.sha256(data).hexdigest() self.assertTrue(verify_checksum(data, provided_checksum)) def test_incorrect_checksum(self): data = b\'test\' provided_checksum = hashlib.sha256(b\'wrong\').hexdigest() self.assertFalse(verify_checksum(data, provided_checksum)) if __name__ == \'__main__\': unittest.main() ```","solution":"import hashlib def verify_checksum(data: bytes, provided_checksum: str) -> bool: Compute the checksum using SHA-256 and compare it with the provided checksum. Params: data (bytes): The input data for checksum computation. provided_checksum (str): The checksum to compare against. Returns: bool: True if the computed checksum matches the provided checksum, False otherwise. # Compute the checksum using SHA-256 computed_checksum = hashlib.sha256(data).hexdigest() # Verify if the computed checksum matches the provided checksum return computed_checksum == provided_checksum"},{"question":"# Problem Description Create a function that determines the shortest path to all nodes in an undirected weighted graph from a given starting node. The function should return a dictionary where keys are nodes, and values are the corresponding shortest path distances from the starting node. # Function Signature ```python def shortest_path(graph: dict, start: int) -> dict: Find the shortest path to all nodes from the start node in a weighted undirected graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are vertices and values are lists of tuples (neighbor, weight). start (int): The starting vertex. Returns: dict: A dictionary where keys are nodes and values are the shortest path distances from the start node. ``` # Input - `graph`: A dictionary representing an undirected weighted graph. Each key is a vertex, and the corresponding value is a list of tuples (neighbor, weight), where \'neighbor\' is the adjacent vertex, and \'weight\' is the weight of the edge. - `start`: An integer representing the starting vertex. # Output - A dictionary where each key is a vertex, and the value is the shortest path distance from the starting vertex. # Constraints - The graph will have at most 1000 vertices and 5000 edges. - Weights are non-negative integers. - The graph might be sparse or dense. # Example ```python test_graph_1 = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 8)], 3: [(1, 5), (2, 8)] } test_graph_2 = { 0: [(1, 10)], 1: [(0, 10), (2, 5)], 2: [(1, 5), (3, 2)], 3: [(2, 2)] } assert shortest_path(test_graph_1, 0) == {0: 0, 1: 3, 2: 1, 3: 8} assert shortest_path(test_graph_2, 0) == {0: 0, 1: 10, 2: 15, 3: 17} ``` # Requirements - Your solution should efficiently handle both sparse and dense graphs. - Ensure that the algorithm accurately computes the shortest distances, even when there are multiple paths to a node. - Use an appropriate shortest path algorithm, like Dijkstra\'s algorithm. - Consider edge cases such as graphs with disconnected components or isolated nodes. # Note - The graph is guaranteed to be connected, but may contain nodes that are isolated with respect to the given constraints. - Ensure the solution passes basic functionality and edge cases testing.","solution":"import heapq def shortest_path(graph, start): Find the shortest path to all nodes from the start node in a weighted undirected graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are vertices and values are lists of tuples (neighbor, weight). start (int): The starting vertex. Returns: dict: A dictionary where keys are nodes and values are the shortest path distances from the start node. # Initialize distances to infinity and set distance to start node as 0 distances = {vertex: float(\'infinity\') for vertex in graph} distances[start] = 0 # Priority queue to store vertices to visit priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Nodes can get added to the priority queue multiple times. We only process a vertex the first time we remove it from the priority queue. if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # If found a shorter path to the neighbor, update its shortest path and add to the priority queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Problem Statement You are given an array of `n` integers. Your task is to find the smallest subarray with a sum greater than or equal to a given value `s`. If there is no such subarray, return -1. # Function Signature ```python def min_subarray_len(nums: List[int], s: int) -> int: Given an array of n integers and an integer s, find the length of the smallest subarray with a sum greater than or equal to s. If there is no such subarray, return -1. ``` # Input - The function `min_subarray_len(nums: List[int], s: int)` takes a list of integers `nums` and a single integer `s`. # Output - Return an integer representing the length of the smallest subarray with a sum greater than or equal to `s`. - If no such subarray exists, return -1. # Constraints 1. 0 <= n <= 10^5, where `n` is the length of the array `nums`. 2. -10^9 <= nums[i] <= 10^9 for each `nums[i]`. 3. 0 < s <= 10^9 # Example Usage ```python assert min_subarray_len([2, 3, 1, 2, 4, 3], 7) == 2 # Subarray [4, 3] has the smallest length. assert min_subarray_len([1, 4, 4], 4) == 1 # Subarray [4] has the smallest length. assert min_subarray_len([1, 1, 1, 1, 1, 1, 1], 15) == -1 # No subarray sums up to 15. assert min_subarray_len([12, 28, 83, 4, 25, 26, 10, 45, 23, 12], 213) == 7 # Subarray [83, 4, 25, 26, 10, 45, 23] has the smallest length. ```","solution":"from typing import List def min_subarray_len(nums: List[int], s: int) -> int: n = len(nums) if n == 0: return -1 min_len = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= s: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"# Coding Challenge: Find the Missing Number Problem Description Given an array containing `n-1` unique integers taken from the range `1` to `n`, write a function to find the missing number. # Function Signature ```python def find_missing_number(arr: list[int], n: int) -> int: pass ``` # Input - `arr` (list of integers): An array of unique integers where one number is missing. - `n` (integer): The length of the full range of numbers from `1` to `n`, including the missing number. # Output - Returns the missing integer from the array. # Constraints - All integers in the array are between 1 and `n`. - The length of the array, `n-1`, is between 1 and 10^5. # Example ```python # Example 1: arr = [1, 2, 4, 5, 6] n = 6 # Output should be 3 (since 3 is missing) # Example 2: arr = [3, 7, 1, 2, 8, 4, 5] n = 8 # Output should be 6 (since 6 is missing) # Example 3: arr = [1] n = 2 # Output should be 2 (since 2 is missing) # Example 4: arr = [2, 3] n = 3 # Output should be 1 (since 1 is missing) ``` # Constraints and Requirements - Handle edge cases such as when the missing number is the smallest or largest in the range. - Aim to optimize the function to achieve O(n) time complexity. # Performance Requirements - The function should handle arrays with lengths up to 100,000 efficiently. # Scenario In a system where unique identifiers are assigned to users, you need to detect any missing identifiers to synchronize your records. This can help ensure all users are accounted for and identified properly.","solution":"def find_missing_number(arr: list[int], n: int) -> int: Finds the missing number in the given array `arr` which contains numbers from 1 to n with exactly one number missing. Parameters: arr (list of int): The list of integers with one number missing. n (int): The expected length of the complete sequence of numbers from 1 to n. Returns: int: The missing number in the sequence. # Calculate the expected sum of a complete array from 1 to n expected_sum = n * (n + 1) / 2 # Calculate the actual sum of the given array actual_sum = sum(arr) # The difference between the expected sum and actual sum is the missing number return int(expected_sum - actual_sum)"},{"question":"Coding Assessment Question Context: Combining the technique of recursion with optimization through memoization can greatly enhance the computational efficiency of certain algorithms. One common example is the calculation of Fibonacci numbers. Task: Write a function `fibonacci(n: int, memo: dict[int, int]=None) -> int` that computes the nth Fibonacci number using a recursive approach with memoization. The Fibonacci sequence is defined as: - `F(0) = 0` - `F(1) = 1` - `F(n) = F(n-1) + F(n-2)` for n > 1 Input: * An integer `n` where `0 <= n <= 50`. Output: * An integer representing the nth Fibonacci number. Constraints: * Use memoization to optimize the recursive approach. * Make sure memoization reduces redundant calculations. Performance Requirements: * Aim for an O(n) time complexity due to memoization. * Space complexity should be O(n) due to the memoization storage. Example: ```python def fibonacci(n: int, memo: dict[int, int]=None) -> int: # Your implementation here # Test cases print(fibonacci(10)) # Output: 55 print(fibonacci(20)) # Output: 6765 print(fibonacci(30)) # Output: 832040 ``` Note: * Initialize the memo dictionary to handle memoization storage. * Ensure edge cases such as very small or very large `n` are correctly computed. * Focus on the efficiency of the solution by effectively utilizing memoization to avoid redundant computations.","solution":"def fibonacci(n: int, memo: dict[int, int] = None) -> int: Computes the nth Fibonacci number using a recursive approach with memoization. :param n: An integer representing the position in Fibonacci sequence. 0 <= n <= 50. :param memo: A dictionary to store the already computed Fibonacci numbers to avoid redundant computations. :return: The nth Fibonacci number. if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo) return memo[n]"},{"question":"# Objective Designing a function to find the number with the longest recurring cycle in its decimal fraction part, given a specified range of denominators. # Problem Statement You are tasked with implementing a function that determines the number less than a given limit, `d`, with the longest recurring cycle in its decimal fraction part. Function Signature ```python def find_longest_recurring_cycle(d: int) -> int: Finds the number less than `d` that has the longest recurring cycle in its decimal fraction part. Parameters: d (int): The upper limit for the range of denominators. Returns: int: The number with the longest recurring cycle in its decimal fraction part. ``` # Requirements 1. **Cycle Length Calculation**: Implement a mechanism to determine the length of the recurring cycle in the decimal fraction part of 1/n for each n. 2. **Comparison Across Range**: Iterate through all numbers less than `d` and calculate the length of their recurring decimal cycles. 3. **Longest Cycle Determination**: Track the number with the longest recurring cycle and return it. # Example Input/Output ```python >>> find_longest_recurring_cycle(10) 7 >>> find_longest_recurring_cycle(100) 97 >>> find_longest_recurring_cycle(1000) ``` *Expected Output*: The output should be an integer representing the number less than `d` with the longest recurring cycle, e.g., for `1000`, it might be `983`. # Constraints - You can assume `d` will be a positive integer greater than 1. - Optimize the implementation to handle large values of `d` efficiently. - Avoid unnecessary computations and memory usage. # Notes - Use mathematical techniques to minimize complexity. - Ensure your implementation handles various edge cases appropriately. Implement the `find_longest_recurring_cycle` function based on the provided requirements.","solution":"def find_longest_recurring_cycle(d: int) -> int: Finds the number less than `d` that has the longest recurring cycle in its decimal fraction part. Parameters: d (int): The upper limit for the range of denominators. Returns: int: The number with the longest recurring cycle in its decimal fraction part. def recurring_cycle_length(n): remainders = {} remainder = 1 position = 0 while remainder != 0 and remainder not in remainders: remainders[remainder] = position remainder = (remainder * 10) % n position += 1 if remainder == 0: return 0 return position - remainders[remainder] max_length = 0 number = 0 for i in range(2, d): cycle_length = recurring_cycle_length(i) if cycle_length > max_length: max_length = cycle_length number = i return number"},{"question":"# Coding Assessment Question Scenario As part of a team\'s effort to create efficient algorithms for managing text data, you\'re tasked with developing a function that can analyze and modify a given string by reversing the order of characters in each word, but retaining the original order of the words. Task Write a function `reverse_words_preserve_order(s)` that takes a string `s` and returns a new string with each word\'s characters reversed, but with the original word order preserved. Words are separated by single spaces, and no leading or trailing spaces are present. Function Signature ```python def reverse_words_preserve_order(s: str) -> str: ``` Input - `s` (str): The input string. It contains only letters and spaces and has at least one word. Output - (str): A new string where each word\'s characters are reversed, but the original order of the words is maintained. Constraints - The function should handle edge cases such as multiple words and words with varying lengths. - The function should implement the reversing efficiently, even for longer strings. Example ```python >>> reverse_words_preserve_order(\\"hello world\\") \'olleh dlrow\' >>> reverse_words_preserve_order(\\"test string\\") \'tset gnirts\' >>> reverse_words_preserve_order(\\"a bc def\\") \'a cb fed\' >>> reverse_words_preserve_order(\\"racecar level\\") \'racecar level\' >>> reverse_words_preserve_order(\\"x y z\\") \'x y z\' ```","solution":"def reverse_words_preserve_order(s: str) -> str: Reverses the characters of each word in the input string but preserves the order of the words. words = s.split(\\" \\") reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"# Problem Statement Create a Multi-dimensional KD-Tree Overview A KD-Tree (k-dimensional tree) is a data structure used for organizing points in a k-dimensional space. It is useful for performing range searches and nearest neighbor searches efficiently. Task Implement a KD-Tree class that supports inserting points and finding the nearest neighbor to a given point. Requirements 1. **KD-Tree Class**: Create a class `KDTree` with the following methods: - `insert(point: List[float])`: Insert a point into the KD-Tree. - `nearest_neighbor(query_point: List[float]) -> List[float]`: Find the nearest neighbor to a given point. 2. **Node Class**: A helper class `Node` to store points and their corresponding left and right children. 3. **Construction**: The KD-Tree should recursively select splitting dimensions. 4. **Nearest Neighbor Search**: Implement a method to find the nearest neighbor using a priority queue for efficiency. Input - **Initialization**: ```python KDTree(points: Optional[List[List[float]]] = None) ``` - `points`: An optional list of points to initialize the tree. - **Inserting Points**: ```python kd_tree.insert([3, 6]) kd_tree.insert([17, 15]) # and others... ``` - **Query Point**: ```text query_point: a list of float values representing the query point ``` Output - **Nearest Neighbor**: The method should return the nearest neighbor\'s point as a list of float values. Constraints - All points and query points will contain the same number of dimensions. - Assume each point is unique within the KD-Tree. Example ```python # Define points points = [ [2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2] ] # Initialize the KD-Tree kd_tree = KDTree(points) # Insert a new point kd_tree.insert([3, 6]) # Find the nearest neighbor query_point = [9, 2] nearest = kd_tree.nearest_neighbor(query_point) print(nearest) # Expected output: [8, 1] based on the given points ``` **Note**: Your solution should ensure the dimension splitting is handled correctly, and the nearest neighbor search utilizes efficient search strategies for performance. --- The new question is designed to align with the original set by ensuring a similar level of complexity, style, and format. It introduces the concept of KD-Trees, a common data structure in computer science, particularly useful for tasks involving spatial searches and other computational geometry problems.","solution":"from typing import List, Optional, Tuple import heapq class Node: def __init__(self, point: List[float], axis: int, left: \'Node\' = None, right: \'Node\' = None): self.point = point self.axis = axis self.left = left self.right = right class KDTree: def __init__(self, points: Optional[List[List[float]]] = None): self.root = None if points: for point in points: self.insert(point) def insert(self, point: List[float]): def _insert(node: \'Node\', point: List[float], depth: int) -> \'Node\': if not node: return Node(point, depth % len(point)) axis = node.axis if point[axis] < node.point[axis]: node.left = _insert(node.left, point, depth + 1) else: node.right = _insert(node.right, point, depth + 1) return node self.root = _insert(self.root, point, 0) def nearest_neighbor(self, query_point: List[float]) -> List[float]: def distance_sq(point1: List[float], point2: List[float]) -> float: return sum((x - y) ** 2 for x, y in zip(point1, point2)) def _nearest(node: \'Node\', query_point: List[float], depth: int, best: Tuple[float, List[float]]) -> Tuple[float, List[float]]: if node is None: return best axis = node.axis point_distance = distance_sq(node.point, query_point) if point_distance < best[0]: best = (point_distance, node.point) next_best = best next_branch = None if query_point[axis] < node.point[axis]: next_branch = node.left other_branch = node.right else: next_branch = node.right other_branch = node.left next_best = _nearest(next_branch, query_point, depth + 1, next_best) if (query_point[axis] - node.point[axis]) ** 2 < next_best[0]: next_best = _nearest(other_branch, query_point, depth + 1, next_best) return next_best best_distance = float(\'inf\') best_point = [] best = (best_distance, best_point) best = _nearest(self.root, query_point, 0, best) return best[1]"},{"question":"# Problem Description In this task, you need to implement a function that, given a string consisting of only \'0\' and \'1\', finds the length of the longest contiguous substring that contains an equal number of \'0\'s and \'1\'s. Your function should efficiently handle large inputs within the specified constraints. # Function Signature ```python def longest_equal_substring(s: str) -> int: pass ``` # Input * A single string `s` consisting only of the characters \'0\' and \'1\' where 1 â‰¤ len(s) â‰¤ 10^5. # Output * A single integer representing the length of the longest contiguous substring with an equal number of \'0\'s and \'1\'s. # Constraints * The input string must consist only of \'0\' and \'1\'. If the input contains any other character or is not a string, the function should raise a `ValueError` with the message \\"input must be a binary string\\". # Performance Requirements * The implementation should handle large strings efficiently within the given constraints. # Examples ```python >>> longest_equal_substring(\\"010101\\") 6 >>> longest_equal_substring(\\"00110011\\") 8 >>> longest_equal_substring(\\"11110000\\") 8 >>> longest_equal_substring(\\"001010\\") 4 >>> longest_equal_substring(\\"011\\") 2 >>> longest_equal_substring(\\"abc\\") Traceback (most recent call last): ValueError: input must be a binary string ``` # Detailed Example Walkthrough 1. For input `longest_equal_substring(\\"010101\\")`: The entire string has an equal number of \'0\'s and \'1\'s, so the output is 6. 2. For input `longest_equal_substring(\\"00110011\\")`: The entire string has an equal number of \'0\'s and \'1\'s, so the output is 8. 3. For input `longest_equal_substring(\\"11110000\\")`: The entire string has an equal number of \'0\'s and \'1\'s, so the output is 8. 4. For input `longest_equal_substring(\\"001010\\")`: The longest substring with equal \'0\'s and \'1\'s is \\"0101\\", which is of length 4. 5. For input `longest_equal_substring(\\"011\\")`: The longest substring with equal \'0\'s and \'1\'s is \\"01\\", which is of length 2.","solution":"def longest_equal_substring(s: str) -> int: Finds the length of the longest contiguous substring with equal number of \'0\'s and \'1\'s. :param s: A binary string containing only \'0\' and \'1\'. :return: The length of the longest contiguous substring with equal number of \'0\'s and \'1\'s. :raises ValueError: If the input is not a binary string. if not isinstance(s, str) or any(c not in \'01\' for c in s): raise ValueError(\\"input must be a binary string\\") count_map = {0: -1} max_length = 0 count = 0 for i, char in enumerate(s): if char == \'0\': count -= 1 elif char == \'1\': count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"# Task: Implement a Kth Largest Element Finder in a Stream Scenario You are tasked with implementing a data structure that efficiently maintains and provides the kth largest element in a dynamically updating stream of numbers. Each time a new number is added to the stream, the data structure should be able to return the kth largest element in constant time. Requirements 1. **Class Implementation**: Implement the `KthLargest` class in Python with the following methods: * `__init__(self, k: int, nums: List[int])`: - Initializes the object with the integer `k` and the stream of integers `nums`. * `add(self, val: int)`: - Adds the integer `val` to the stream. - Returns the kth largest element in the stream. Input and Output Format * **Input** for `__init__`: * `k`: Integer (1 <= k <= 10^4) * `nums`: List of integers (size can be zero or up to 10^4) * **Input** for `add`: * `val`: Integer (-10^4 <= val <= 10^4) * **Output** for `add`: * Integer representing the kth largest element in the stream. Constraints * The kth largest element is well-defined at all times. * All methods should run efficiently for large input sizes. Performance Requirements Ensure that the `add` method runs in O(log k) time complexity. # Example Usage ```python # Initialize with k = 3 and an initial stream [4, 5, 8, 2] kthLargest = KthLargest(3, [4, 5, 8, 2]) # The stream at the start is [2, 4, 5, 8], with 4 as the 3rd largest element. print(kthLargest.add(3)) # Output: 4 # The stream is now [2, 3, 4, 5, 8], with 5 as the 3rd largest element. print(kthLargest.add(5)) # Output: 5 # The stream is now [2, 3, 4, 5, 8, 10], with 5 still as the 3rd largest element. print(kthLargest.add(10)) # Output: 5 # The stream is now [2, 3, 4, 5, 8, 9, 10], with 8 as the 3rd largest element. print(kthLargest.add(9)) # Output: 8 # The stream is now [2, 3, 4, 5, 7, 8, 9, 10], with 8 still as the 3rd largest element. print(kthLargest.add(7)) # Output: 8 ```","solution":"import heapq from typing import List class KthLargest: def __init__(self, k: int, nums: List[int]): self.k = k self.min_heap = nums heapq.heapify(self.min_heap) while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) return self.min_heap[0]"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that demonstrates your understanding of data structures and algorithms, particularly focusing on graph traversal techniques. You will create a function to determine if there is a path between two nodes in an undirected graph. Requirements * Write a function `is_path_exists(graph: Dict[int, List[int]], start: int, end: int) -> bool` that takes an undirected graph represented as an adjacency list, a starting node, and an ending node, and returns `True` if there is a path between the start and end nodes, otherwise returns `False`. * You are free to use either Depth-First Search (DFS) or Breadth-First Search (BFS) in your implementation. Input * `graph` (Dict[int, List[int]]): An adjacency list representing the undirected graph where keys are node identifiers (integers) and values are lists of adjacent nodes. * `start` (int): The starting node identifier. * `end` (int): The ending node identifier. Output * A boolean value - `True` if there is a path from `start` to `end`, otherwise `False`. Constraints * The graph nodes are labeled with unique integers. * The graph can have up to 10,000 nodes and 50,000 edges. * The function should handle cases where the starting or ending node does not exist in the graph. * Ensure efficient traversal to cover large graphs within reasonable time limits. Example ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2], 5: [3, 6], 6: [5] } start = 1 end = 6 path_exists = is_path_exists(graph, start, end) print(path_exists) ``` Expected Output: ```python True ``` In the above example, there is a path from node 1 to node 6 via nodes [1, 3, 5, 6]. Submission Please submit a Python file containing the implementation of the `is_path_exists` function. Include appropriate error handling, comments explaining important sections of your code, and any assumptions you\'ve made.","solution":"from typing import List, Dict from collections import deque def is_path_exists(graph: Dict[int, List[int]], start: int, end: int) -> bool: Returns True if there exists a path between start and end node in the graph using BFS traversal, otherwise returns False. # Check if start or end node exists in the graph if start not in graph or end not in graph: return False # Use a BFS approach to find the path visited = set() queue = deque([start]) # start BFS from the start node while queue: current_node = queue.popleft() # If we have reached the end node, return True if current_node == end: return True # Mark the node as visited visited.add(current_node) # Add all unvisited neighbours to the queue for neighbour in graph[current_node]: if neighbour not in visited: queue.append(neighbour) # If BFS completes without finding the end, return False return False"},{"question":"# User Registration System with Enhanced Input Validation **Background:** You are tasked with developing a user registration system for a web application. The provided function should take user input and validate the registration details. Currently, the validation is not stringent enough, allowing invalid data to pass through. **Task:** 1. Write a function named `register_user` that accepts the following parameters: - `username` (str): The user\'s username. - `password` (str): The user\'s password. - `email` (str): The user\'s email address. 2. Enhance the function to validate the registration details based on the following rules: - The `username` should be alphanumeric and between 3 and 20 characters long. - The `password` must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character. - The `email` should follow the standard email format (e.g., example@domain.com). 3. If any of the validation rules are not met, the function should print an appropriate error message and return `False`. 4. If all inputs are valid, the function should print \\"Registration Successful!\\" and return `True`. **Parameters:** - `username` (str): A string representing the user\'s username. - `password` (str): A string representing the user\'s password. - `email` (str): A string representing the user\'s email address. **Output:** - Print appropriate validation error messages if the input data is invalid. - Print \\"Registration Successful!\\" if all inputs are valid. **Constraints:** - Do not use any external libraries for email validation. - Ensure that all error messages are clear and specific to the validation rule being violated. **Examples:** ```python def register_user(username: str, password: str, email: str) -> bool: pass # Example of expected function calls print(register_user(\\"user123\\", \\"Password1!\\", \\"user@example.com\\")) # Output: Registration Successful! # Return: True print(register_user(\\"us\\", \\"password\\", \\"user.com\\")) # Output: # Username must be alphanumeric and between 3 and 20 characters long. # Password must be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one digit, and one special character. # Email format is invalid. # Return: False ``` In this function, you should validate the user\'s registration details and provide clear feedback for any validation errors, ensuring that only valid data can pass through the system.","solution":"import re def register_user(username: str, password: str, email: str) -> bool: Validates the given username, password, and email and returns True if all inputs are valid, otherwise returns False. username_regex = r\'^[a-zA-Z0-9]{3,20}\' password_regex = r\'^(?=.*[a-z])(?=.*[A-Z])(?=.*d)(?=.*[@!%*?&])[A-Za-zd@!%*?&]{8,}\' email_regex = r\'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' valid = True if not re.match(username_regex, username): print(\\"Username must be alphanumeric and between 3 and 20 characters long.\\") valid = False if not re.match(password_regex, password): print(\\"Password must be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one digit, and one special character.\\") valid = False if not re.match(email_regex, email): print(\\"Email format is invalid.\\") valid = False if valid: print(\\"Registration Successful!\\") return True else: return False"},{"question":"# Problem Statement: You are required to implement a function that finds the largest connected component in an undirected graph represented by an adjacency list. The graph nodes are identified by non-negative integers. # Function Signature: ```python def largest_connected_component(graph: dict) -> set: pass ``` # Input: - `graph`: A dictionary representing an undirected graph. Keys are integer vertices, and the values are lists of integers representing adjacent vertices. # Output: - Returns a set of integers representing the vertices in the largest connected component of the graph. # Constraints: - Vertices are represented as non-negative integers. - The input graph can be empty, but not `None`. - The adjacency list does not guarantee order. - No repeated edges or self-loops. - The number of vertices in the graph is â‰¤ 1000. # Example: ```plaintext graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4] } largest_connected_component(graph) # Output: {0, 1, 2, 3} ``` # Explanation: The function should use a graph traversal approach (e.g., Depth-First Search or Breadth-First Search) to explore each connected component of the graph. It should keep track of the size of each component and update the largest one found. In the provided example, the largest connected component consists of vertices {0, 1, 2, 3}. # Other Considerations: - Handle graphs with multiple components. - Ensure the function can handle edge cases like an empty graph or a graph with isolated vertices.","solution":"def largest_connected_component(graph: dict) -> set: Given an undirected graph represented by an adjacency list, find the largest connected component. Parameters: graph (dict): Adjacency list representation of the graph. Returns: set: The set of vertices in the largest connected component. def dfs(node, visited): Depth First Search to explore all nodes in the connected component. Parameters: node (int): The starting node for the DFS. visited (set): Set of already visited nodes. Returns: component (set): The set of nodes in the connected component. stack = [node] component = set() while stack: current_node = stack.pop() if current_node not in visited: visited.add(current_node) component.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: stack.append(neighbor) return component largest_component = set() visited = set() for node in graph: if node not in visited: current_component = dfs(node, visited) if len(current_component) > len(largest_component): largest_component = current_component return largest_component"},{"question":"# Question You are tasked with implementing a function `three_sum` that finds all unique triplets in the array which give the sum of zero. The solution should focus on optimizing both time and space complexity. # Function Signature ```python def three_sum(nums: List[int]) -> List[List[int]]: ``` # Input * `nums` (0 â‰¤ len(nums) â‰¤ 3000): A list of integers. # Output * Returns a list of lists of integers, where each sublist represents a triplet that adds up to zero. The triplets must be unique. # Example ```python assert sorted(three_sum([-1, 0, 1, 2, -1, -4])) == sorted([[-1, -1, 2], [-1, 0, 1]]) assert three_sum([]) == [] assert three_sum([0]) == [] ``` # Constraints * The solution should have a time complexity target of approximately O(nÂ²). # Performance Requirements * Aim for a solution that efficiently handles the given constraints, ensuring no more than O(nÂ²) time complexity and O(1) additional space complexity apart from the output list and possibly sorted input data. # Notes * Triplets [a, b, c] and [c, b, a] are considered identical, and they should be listed in non-descending order within each triplet and as unique sets in the output.","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: nums.sort() res = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return res"},{"question":"# Question Implement a function called `find_duplicates` in Python that accepts a list of integers and returns a new list containing all the duplicates in the order they first appear. If there are no duplicates, return an empty list. Your solution should efficiently handle large inputs. Function Signature ```python def find_duplicates(nums: list[int]) -> list[int]: pass ``` Input * `nums`: A list of integers, where each integer is within the range [-10^9, 10^9]. Output * Returns a list of integers representing the duplicates in the order they first appear. Constraints * The length of `nums` will be in the range [0, 10^5]. * Do not use any additional data structures that grow with input size [e.g., another list, set, or dictionary]. Example ```python >>> find_duplicates([1, 2, 3, 2, 1, 5, 6]) [2, 1] >>> find_duplicates([3, 3, 3, 3, 3]) [3] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([]) [] >>> find_duplicates([7, 10, 22, 7, 7, 10]) [7, 10] ``` Notes * The input list `nums` should not be modified during the function execution. * Ensure that the function can handle lists that contain negative numbers and zero.","solution":"def find_duplicates(nums: list[int]) -> list[int]: Returns a list of duplicates appearing in `nums` in the order they first appear. if not nums: return [] seen = {} duplicates = [] for num in nums: if num in seen: if seen[num] == 1: duplicates.append(num) seen[num] += 1 else: seen[num] = 1 return duplicates"},{"question":"# Tic-Tac-Toe Game Simulation Create a simulation for a Tic-Tac-Toe game where the input will be a series of moves by two players. Your task is to determine the status of the game after each move and output whether the game has ended in a win, a draw, or if it should continue. # Requirements: 1. **Function Signature**: ```python def tic_tac_toe(moves: list[tuple[int, int, str]]) -> list[str]: ``` 2. **Inputs**: * `moves`: A list of tuples where each tuple contains three elements: * The row index (0-based) of the move (integer). * The column index (0-based) of the move (integer). * The player making the move (\'X\' or \'O\'). 3. **Outputs**: * Return a list of strings representing the game status after each move: * \'X wins\' if player X wins. * \'O wins\' if player O wins. * \'Draw\' if the game is a draw. * \'Continue\' if the game should continue. # Constraints: 1. The moves list will be valid; no out-of-bounds or duplicate moves. 2. The number of moves will not exceed 9. 3. Each player will be alternating turns, starting with player \'X\'. # Example: ```python >>> moves = [(0, 0, \'X\'), (0, 1, \'O\'), (1, 1, \'X\'), (0, 2, \'O\'), (2, 2, \'X\')] >>> tic_tac_toe(moves) [\'Continue\', \'Continue\', \'Continue\', \'Continue\', \'X wins\'] ``` # Detailed Steps: 1. **Initialize the Board**: Set up an empty 3x3 Tic-Tac-Toe board. 2. **Process Moves**: Iterate through the list of moves, updating the board and checking the status after each move. 3. **Check Win Conditions**: After each move, check all possible win conditions (rows, columns, diagonals). 4. **Check Draw**: If the board is full and no player has won, declare a draw. 5. **Return Status**: Append the correct status to the result list after each move. # Implementation Tips: - Use simple loops or list comprehensions to check win conditions. - Ensure that the board is being updated correctly with each move. - Validate the board\'s state only after a move is made to determine the current outcome.","solution":"def tic_tac_toe(moves: list[tuple[int, int, str]]) -> list[str]: def check_win(board, player): # Check rows, columns, and diagonals for i in range(3): if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)): return True if (board[0][0] == player and board[1][1] == player and board[2][2] == player) or (board[0][2] == player and board[1][1] == player and board[2][0] == player): return True return False board = [[\'\' for _ in range(3)] for _ in range(3)] result = [] for move in moves: row, col, player = move board[row][col] = player if check_win(board, player): result.append(f\'{player} wins\') elif all(board[i][j] != \'\' for i in range(3) for j in range(3)): result.append(\'Draw\') else: result.append(\'Continue\') return result"},{"question":"# Question: Implement a Thread-safe Bounded Blocking Queue You are tasked with implementing a thread-safe bounded blocking queue. This queue should support the following features: 1. **Push**: Insert an element into the queue. If the queue is full, the calling thread should block until space is available. 2. **Pop**: Remove and return an element from the queue. If the queue is empty, the calling thread should block until an element is available. 3. **Size**: A function to retrieve the current number of elements in the queue. Function Specifications: 1. **Push**: * Function Name: `push` * Input: An element to be added to the queue. 2. **Pop**: * Function Name: `pop` * Output: The element removed from the queue. 3. **Size**: * Function Name: `size` * Output: An integer representing the current number of elements in the queue. You are required to use Python\'s `threading` module to ensure that the queue operations are thread-safe. Additionally, the `push` and `pop` operations should properly block when the conditions (full or empty queue) are met. Constraints: - The maximum size of the queue is defined during initialization. - The queue uses a first-in, first-out (FIFO) ordering. - Ensure that all methods work correctly with multi-threading. - Use appropriate synchronization primitives (e.g., `threading.Lock`, `threading.Condition`). Example Usage: ```python from threading import Thread import time # Initialize bounded blocking queue with a maximum size of 3 bbq = BoundedBlockingQueue(max_size=3) # Function to insert elements into the queue def producer(): for i in range(5): print(f\\"Producing {i}\\") bbq.push(i) time.sleep(1) # Function to remove elements from the queue def consumer(): for i in range(5): item = bbq.pop() print(f\\"Consuming {item}\\") time.sleep(2) # Create and start producer and consumer threads producer_thread = Thread(target=producer) consumer_thread = Thread(target=consumer) producer_thread.start() consumer_thread.start() producer_thread.join() consumer_thread.join() # Get current size of the queue print(bbq.size()) # Expected Output: 0 (or another number depending on timing of producer and consumer) ``` Expected Implementation Outline: ```python import threading class BoundedBlockingQueue: def __init__(self, max_size): self.queue = [] self.max_size = max_size self.lock = threading.Lock() self.not_empty = threading.Condition(self.lock) self.not_full = threading.Condition(self.lock) def push(self, item): with self.not_full: while len(self.queue) >= self.max_size: self.not_full.wait() self.queue.append(item) self.not_empty.notify() def pop(self): with self.not_empty: while len(self.queue) == 0: self.not_empty.wait() item = self.queue.pop(0) self.not_full.notify() return item def size(self): with self.lock: return len(self.queue) ```","solution":"import threading class BoundedBlockingQueue: def __init__(self, max_size): self.queue = [] self.max_size = max_size self.lock = threading.Lock() self.not_empty = threading.Condition(self.lock) self.not_full = threading.Condition(self.lock) def push(self, item): with self.not_full: while len(self.queue) >= self.max_size: self.not_full.wait() self.queue.append(item) self.not_empty.notify() def pop(self): with self.not_empty: while len(self.queue) == 0: self.not_empty.wait() item = self.queue.pop(0) self.not_full.notify() return item def size(self): with self.lock: return len(self.queue)"},{"question":"# Coding Question Implement a function `find_common_elements` that takes two lists of integers and returns a new list containing the integers that appear in both input lists. The resulting list should have no duplicates and should be sorted in ascending order. Also, handle the case where the input lists may contain duplicates. Function Signature ```python def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: pass ``` Input and Output Format * **Input**: Two lists of integers. * **Output**: A list of integers that are present in both input lists, sorted in ascending order, with no duplicates. Examples ```python >>> find_common_elements([1, 2, 2, 3], [3, 4, 3, 1]) [1, 3] >>> find_common_elements([4, 5, 6, 6, 7], [5, 6, 7, 8]) [5, 6, 7] >>> find_common_elements([10, 11, 12], [13, 14, 15]) [] >>> find_common_elements([1, 1, 1, 1], [1]) [1] >>> find_common_elements([], [1, 2, 3]) [] ``` Constraints * Both input lists can be of different lengths and can include duplicate values. * The length of each input list is between `0` and `10^4`. * Each integer in the input lists can be between `-10^5` and `10^5`. Requirements * The implementation should handle the case where input lists have duplicate elements efficiently. * Ensure the resulting list is unique and sorted in ascending order. Notes * Use appropriate data structures to achieve a solution that optimizes for both time complexity and space complexity. * Aim for a time complexity of `O(n log n)`, where `n` is the combined length of the two input lists.","solution":"from typing import List def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: Finds the common elements between two lists, removes duplicates, and sorts them in ascending order. # Convert both lists to sets to eliminate duplicates set1 = set(list1) set2 = set(list2) # Find the common elements by intersecting both sets common_elements = set1 & set2 # Convert the set to a sorted list result = sorted(list(common_elements)) return result"},{"question":"# Problem Statement **Background**: A binary search tree (BST) is a node-based binary tree data structure such that: 1. The left subtree of a node contains only nodes with keys less than the node\'s key. 2. The right subtree of a node contains only nodes with keys greater than the node\'s key. 3. Both the left and right subtrees must also be binary search trees. A common operation on BSTs is to find if a certain key exists in the tree. This requires traversing the tree from the root to the potential position of the key. # Description Implement a function `find_in_bst` that checks if a given key exists in a binary search tree. Function Signature ```python class TreeNode: def __init__(self, key: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.key = key self.left = left self.right = right def find_in_bst(root: TreeNode, key: int) -> bool: pass ``` # Input - `root`: The root node of the binary search tree, where `root` is a `TreeNode` object or `None` if the tree is empty. - `key`: An integer representing the key to search for in the tree. # Output - Returns `True` if the key exists in the BST, `False` otherwise. # Constraints - The binary search tree may contain up to (10^6) nodes. - Each node\'s key is a unique integer. - The values of the keys are within the range (-10^9 leq key leq 10^9). # Example ```python # Example of a Binary Search Tree # 8 # / # 3 10 # / # 1 6 14 # / / # 4 7 13 # Creating a sample tree root = TreeNode(8) root.left = TreeNode(3) root.right = TreeNode(10) root.left.left = TreeNode(1) root.left.right = TreeNode(6, TreeNode(4), TreeNode(7)) root.right.right = TreeNode(14, TreeNode(13)) # Searching for existing and non-existing keys assert find_in_bst(root, 6) == True assert find_in_bst(root, 13) == True assert find_in_bst(root, 2) == False ``` # Constraints and Notes - Ensure that your implementation handles edge cases, such as when the tree is empty (i.e., the root is `None`). - Aim for O(log n) time complexity in the case of a balanced BST. - The function should not use additional auxiliary data structures like arrays or lists.","solution":"class TreeNode: def __init__(self, key: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.key = key self.left = left self.right = right def find_in_bst(root: TreeNode, key: int) -> bool: Determines if a given key exists in the binary search tree. Args: root (TreeNode): The root node of the BST. key (int): The key to search for. Returns: bool: True if the key is found in the BST, otherwise False. # Base case: the root is None if root is None: return False # Check if the current node\'s key matches the search key if key == root.key: return True # If the key is less than the current node\'s key, search the left subtree elif key < root.key: return find_in_bst(root.left, key) # If the key is greater than the current node\'s key, search the right subtree else: return find_in_bst(root.right, key)"},{"question":"# Question: Simplified Merge Sort with Limited Memory Design a simplified version of the Merge Sort algorithm which utilizes limited additional memory. Instead of creating numerous temporary arrays, use a single additional array to streamline the merging process. This constraint should help demonstrate the careful handling of memory resources. Requirements: 1. **Input**: A list of integers `arr` and a boolean `reverse` indicating the sorting order. 2. **Output**: A sorted list in either ascending or descending order as specified by the `reverse` parameter. 3. **Constraints**: * You cannot use any built-in sort functions. * The input list might be empty or contain duplicate elements. * Minimize the use of additional memory. 4. **Performance**: * Focus on reducing the space complexity while maintaining the time complexity of O(n log n). ```python def limited_memory_merge_sort(arr: list, reverse: bool = False) -> list: Simplified Merge Sort implementation with limited memory usage. :param arr: Unordered input list :param reverse: Descent ordering flag :return: Sorted list in the specified order Examples: >>> limited_memory_merge_sort([4, 2, 5, 3, 0, 1]) [0, 1, 2, 3, 4, 5] >>> limited_memory_merge_sort([4, 2, 5, 3, 0, 1], reverse=True) [5, 4, 3, 2, 1, 0] if not arr or len(arr) <= 1: return arr def merge(left, right, buffer): l = r = 0 while l < len(left) and r < len(right): if (left[l] < right[r] and not reverse) or (left[l] > right[r] and reverse): buffer.append(left[l]) l += 1 else: buffer.append(right[r]) r += 1 while l < len(left): buffer.append(left[l]) l += 1 while r < len(right): buffer.append(right[r]) r += 1 def merge_sort_recursive(sub_arr, buffer): if len(sub_arr) <= 1: return sub_arr mid = len(sub_arr) // 2 left = merge_sort_recursive(sub_arr[:mid], buffer) right = merge_sort_recursive(sub_arr[mid:], buffer) buffer.clear() merge(left, right, buffer) return list(buffer) buffer = [] return merge_sort_recursive(arr, buffer) if __name__ == \\"__main__\\": assert limited_memory_merge_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5] assert limited_memory_merge_sort([4, 3, 5, 1, 2], reverse=True) == [5, 4, 3, 2, 1] ``` This question requires the candidates to implement a sorting algorithm using limited memory resources, which tests their understanding of both merge sort and memory management in Python, maintaining consistency with the complexity and depth of the provided questions.","solution":"def limited_memory_merge_sort(arr, reverse=False): Simplified Merge Sort implementation with limited memory usage. :param arr: Unordered input list :param reverse: Descent ordering flag :return: Sorted list in the specified order if not arr or len(arr) <= 1: return arr def merge(left, right, buffer): l = r = 0 while l < len(left) and r < len(right): if (left[l] < right[r] and not reverse) or (left[l] > right[r] and reverse): buffer.append(left[l]) l += 1 else: buffer.append(right[r]) r += 1 while l < len(left): buffer.append(left[l]) l += 1 while r < len(right): buffer.append(right[r]) r += 1 def merge_sort_recursive(sub_arr, buffer): if len(sub_arr) <= 1: return sub_arr mid = len(sub_arr) // 2 left = merge_sort_recursive(sub_arr[:mid], buffer) right = merge_sort_recursive(sub_arr[mid:], buffer) buffer.clear() merge(left, right, buffer) return list(buffer) buffer = [] return merge_sort_recursive(arr, buffer)"},{"question":"**Question: \\"Projectile Motion Simulation using Verlet Integration\\"** **Context**: In physics, simulating the motion of a projectile allows for analysis and predictions of its trajectory. Verlet integration is a numerical method used to integrate Newton\'s equations of motion and is particularly useful for systems in which accuracy and numerical stability are important, such as the trajectory of a projectile under the influence of gravity. **Task**: Implement the function `projectile_motion_simulation` using Verlet integration to estimate the projectile\'s position over a given period. # Function Signature: ```python def projectile_motion_simulation(initial_position: tuple, initial_velocity: tuple, time_span: float, step_size: float) -> np.ndarray: ``` # Input: - `initial_position` (tuple): A tuple of two floats representing the initial x and y coordinates `(x0, y0)`. - `initial_velocity` (tuple): A tuple of two floats representing the initial velocity components `(vx0, vy0)` in the x and y directions. - `time_span` (float): The total time for which the simulation runs. Must be positive. - `step_size` (float): The increment of time for each step in the simulation. Must be positive. # Output: - Return a numpy array of shape `(n, 2)` where `n` is the number of timesteps, containing the estimated x and y coordinates of the projectile at each timestep. # Constraints: - Gravity is acting on the projectile with an acceleration of `9.81 m/s^2` in the negative y-direction. # Requirements: - Use Verlet integration to calculate the position of the projectile at each timestep. - Handle edge cases like non-positive `time_span` and `step_size`. # Example: ```python # Example input initial_position = (0.0, 0.0) initial_velocity = (10.0, 10.0) time_span = 2.0 step_size = 0.1 # Call the function trajectory = projectile_motion_simulation(initial_position, initial_velocity, time_span, step_size) ``` In this example, the array `trajectory` should return values corresponding to the positions of the projectile over the 2-second time span, showing a parabolic trajectory due to the influence of gravity. Note: Your solution should correctly implement the Verlet integration method to handle the projectile\'s motion and pass the given example scenarios, reflecting an understanding of the numerical method and the kinematics under gravity.","solution":"import numpy as np def projectile_motion_simulation(initial_position: tuple, initial_velocity: tuple, time_span: float, step_size: float) -> np.ndarray: Simulates the projectile motion using Verlet integration. Parameters: initial_position (tuple): Initial x and y coordinates (x0, y0). initial_velocity (tuple): Initial velocity components (vx0, vy0). time_span (float): Total time for which the simulation runs. Must be positive. step_size (float): Time increment for each step. Must be positive. Returns: np.ndarray: Array of shape (n, 2) containing x and y coordinates of the projectile at each timestep. if time_span <= 0 or step_size <= 0: raise ValueError(\\"time_span and step_size must be positive\\") num_steps = int(time_span / step_size) + 1 trajectory = np.zeros((num_steps, 2)) x0, y0 = initial_position vx0, vy0 = initial_velocity trajectory[0] = [x0, y0] # Initial positions x_new = x0 + vx0 * step_size y_new = y0 + vy0 * step_size - 0.5 * 9.81 * step_size**2 trajectory[1] = [x_new, y_new] for i in range(1, num_steps-1): x_current, y_current = trajectory[i] x_prev, y_prev = trajectory[i-1] x_next = 2 * x_current - x_prev + 0 y_next = 2 * y_current - y_prev - 9.81 * step_size**2 trajectory[i+1] = [x_next, y_next] return trajectory"},{"question":"# Reverse String Except Punctuation You are given a string `s` that contains words separated by spaces and may include punctuation marks. Your task is to write a function `reverse_without_punctuation` that reverses the characters of each word in the string while keeping the punctuation marks in their original positions. Write a function `reverse_without_punctuation` that takes a string `s` as input and returns the string with the words reversed but punctuation in their respective places. Function Signature ```python def reverse_without_punctuation(s: str) -> str: ``` # Input - `s`: A string that contains alphanumeric characters, spaces, and punctuation marks (`.,!?`). # Output - A string where the words are reversed but punctuation remains in its original position. # Constraints - Length of the string can be up to (10^5) characters. - Words are separated by single spaces. # Examples ```python print(reverse_without_punctuation(\\"hello world!\\")) # Output: \\"olleh dlrow!\\" print(reverse_without_punctuation(\\"a,b.c!\\")) # Output: \\"c,b.a!\\" print(reverse_without_punctuation(\\"abcd! efgh?\\")) # Output: \\"dcba! hgfe?\\" print(reverse_without_punctuation(\\"\\")) # Output: \\"\\" ``` # Constraints and Performance Expectations - The function must handle strings with mixed content efficiently. - Pay attention to edge cases such as an empty string, strings with only punctuation, and strings with spaces between words and punctuation. Provide a complete implementation within the `reverse_without_punctuation` function that adheres to the above specifications and constraints.","solution":"def reverse_without_punctuation(s: str) -> str: Reverses the characters of each word in the input string `s` while keeping the punctuation marks in their original positions. result = [] for word in s.split(\' \'): new_word = list(word) left, right = 0, len(new_word) - 1 while left < right: if new_word[left].isalpha(): while not new_word[right].isalpha() and left < right: right -= 1 new_word[left], new_word[right] = new_word[right], new_word[left] right -= 1 left += 1 result.append(\'\'.join(new_word)) return \' \'.join(result)"},{"question":"# Real-Time Stock Market Data Analysis Scenario: You are developing a stock market analysis tool that fetches real-time stock data and computes various financial metrics required by investment analysts. The system should be able to handle multiple stock symbols and provide functionalities such as calculating moving averages, percentage changes, and identifying buying or selling signals based on certain thresholds. Requirements: 1. **Stock Data Ingestion**: Implement a system to fetch and store real-time stock data for multiple symbols. 2. **Financial Metrics**: Calculate the 10-day and 50-day moving averages for a given stock symbol. 3. **Signal Generation**: Determine buying or selling signals based on whether the 10-day moving average crosses the 50-day moving average. 4. **Error Handling**: Handle cases where data is insufficient for calculations or the stock symbol is invalid. Input & Output: * **Function Signatures**: ```python class StockMarketAnalyzer: def __init__(self): # Initialize the analyzer with necessary data structures pass def fetch_data(self, stock_symbols: List[str], start_date: str, end_date: str) -> None: # Fetch and store stock data for the given symbols and date range pass def calculate_moving_average(self, stock_symbol: str, days: int) -> float: # Calculate and return the moving average for the given symbol and days pass def generate_signal(self, stock_symbol: str) -> str: # Generate and return a buying or selling signal based on moving averages pass ``` * **Constraints**: * The `stock_symbols` parameter should only include valid stock market symbols. * Stock data fetching should support a date range provided as `start_date` and `end_date` in the `YYYY-MM-DD` format. * The tool should only calculate moving averages if there is sufficient data for the given duration. * Signals should be based on a crossover strategy: return \\"BUY\\" if the 10-day moving average crosses above the 50-day moving average, \\"SELL\\" if it crosses below, and \\"HOLD\\" otherwise. * **Error Messages**: * Raise `ValueError` with message \\"Invalid stock symbol\\" for invalid symbols. * Raise `ValueError` with message \\"Insufficient data for moving average calculation\\" if there is not enough data. Example: ```python # Example usage: analyzer = StockMarketAnalyzer() # Fetch data for a given range analyzer.fetch_data(stock_symbols=[\\"AAPL\\", \\"GOOGL\\"], start_date=\\"2022-01-01\\", end_date=\\"2022-12-31\\") # Calculate moving averages aapl_10_day_ma = analyzer.calculate_moving_average(stock_symbol=\\"AAPL\\", days=10) aapl_50_day_ma = analyzer.calculate_moving_average(stock_symbol=\\"AAPL\\", days=50) # Generate signals aapl_signal = analyzer.generate_signal(stock_symbol=\\"AAPL\\") googl_signal = analyzer.generate_signal(stock_symbol=\\"GOOGL\\") print(f\\"AAPL 10-day MA: {aapl_10_day_ma}\\") print(f\\"AAPL 50-day MA: {aapl_50_day_ma}\\") print(f\\"AAPL Signal: {aapl_signal}\\") print(f\\"GOOGL Signal: {googl_signal}\\") ``` Implementation Details: Provide your implementation for the `StockMarketAnalyzer` class following the specifications and requirements provided. Ensure proper handling of exceptions and edge cases.","solution":"import pandas as pd from typing import List class StockMarketAnalyzer: def __init__(self): self.data = {} def fetch_data(self, stock_symbols: List[str], start_date: str, end_date: str) -> None: Mock function to fetch stock data for the given symbols and store in self.data. For simplicity, we\'ll assume the data is generated for testing purposes. In a real-world scenario, this would connect to an API like Yahoo Finance, Alpha Vantage, etc. # For simplicity, assuming data is a pandas DataFrame with a \'Date\' index dates = pd.date_range(start=start_date, end=end_date) for symbol in stock_symbols: if symbol not in self.data: self.data[symbol] = pd.DataFrame({ \\"Date\\": dates, \\"Close\\": (100 + 2 * (pd.Series(range(len(dates))) * pd.Series(range(len(dates)))) % 50).values }).set_index(\\"Date\\") def calculate_moving_average(self, stock_symbol: str, days: int) -> float: Calculate and return the moving average for the given symbol and days. if stock_symbol not in self.data: raise ValueError(\\"Invalid stock symbol\\") stock_data = self.data[stock_symbol] if len(stock_data) < days: raise ValueError(\\"Insufficient data for moving average calculation\\") return stock_data[\\"Close\\"].rolling(window=days).mean().iloc[-1] def generate_signal(self, stock_symbol: str) -> str: Generate and return a buying or selling signal based on moving averages. if stock_symbol not in self.data: raise ValueError(\\"Invalid stock symbol\\") stock_data = self.data[stock_symbol] if len(stock_data) < 50: raise ValueError(\\"Insufficient data for moving average calculation\\") ma_10 = self.calculate_moving_average(stock_symbol, 10) ma_50 = self.calculate_moving_average(stock_symbol, 50) if ma_10 > ma_50: return \\"BUY\\" elif ma_10 < ma_50: return \\"SELL\\" else: return \\"HOLD\\""},{"question":"# Question Context You have come across a collection of log files from a web server, and you need to analyze the frequency of IP addresses accessing the web server. This analysis could provide insights into possible malicious activities or identify the most frequent visitors. Task Write a Python function that identifies the three most frequent IP addresses from the log file and returns them. If there are ties, return the IP addresses that appear first in the log file among the ties. Function Signature ```python def most_frequent_ips(log: List[str]) -> List[str]: pass ``` Input * `log` (List[str]): A list of strings where each string represents an IP address. Output * Returns a list of three strings, which are the three most frequent IP addresses in descending order of frequency. In case of ties, the IP that appears first in the log among the ties should be prioritized. Constraints and Requirements * The function should run in linear time concerning the length of the log list. * Each IP in the log list is a valid IPv4 address in dot-decimal notation (e.g., \\"192.168.1.1\\"). Example ```python assert most_frequent_ips([\\"192.168.1.1\\", \\"192.168.1.1\\", \\"192.168.1.2\\", \\"10.0.0.1\\", \\"10.0.0.1\\", \\"10.0.0.2\\"]) == [\\"192.168.1.1\\", \\"10.0.0.1\\", \\"192.168.1.2\\"] assert most_frequent_ips([\\"172.16.0.1\\", \\"192.168.0.1\\", \\"10.0.0.1\\", \\"172.16.0.1\\", \\"192.168.0.1\\"]) == [\\"172.16.0.1\\", \\"192.168.0.1\\", \\"10.0.0.1\\"] assert most_frequent_ips([\\"1.1.1.1\\", \\"1.1.1.2\\", \\"1.1.1.1\\", \\"1.1.1.2\\", \\"1.1.1.1\\"]) == [\\"1.1.1.1\\", \\"1.1.1.2\\"] ``` Explanation 1. `[\\"192.168.1.1\\", \\"192.168.1.1\\", \\"192.168.1.2\\", \\"10.0.0.1\\", \\"10.0.0.1\\", \\"10.0.0.2\\"]`: - Frequencies: 192.168.1.1=2, 192.168.1.2=1, 10.0.0.1=2, 10.0.0.2=1 - Most frequent (3): 192.168.1.1, 10.0.0.1, 192.168.1.2 - The function returns: [\\"192.168.1.1\\", \\"10.0.0.1\\", \\"192.168.1.2\\"] 2. `[\\"172.16.0.1\\", \\"192.168.0.1\\", \\"10.0.0.1\\", \\"172.16.0.1\\", \\"192.168.0.1\\"]`: - Frequencies: 172.16.0.1=2, 192.168.0.1=2, 10.0.0.1=1 - Most frequent (3): 172.16.0.1, 192.168.0.1, 10.0.0.1 - The function returns: [\\"172.16.0.1\\", \\"192.168.0.1\\", \\"10.0.0.1\\"] 3. `[\\"1.1.1.1\\", \\"1.1.1.2\\", \\"1.1.1.1\\", \\"1.1.1.2\\", \\"1.1.1.1\\"]`: - Frequencies: 1.1.1.1=3, 1.1.1.2=2 - Most frequent (2): 1.1.1.1, 1.1.1.2 - The function returns: [\\"1.1.1.1\\", \\"1.1.1.2\\"]","solution":"from typing import List from collections import Counter def most_frequent_ips(log: List[str]) -> List[str]: Given a list of IP addresses, return the top three most frequent IPs. In case of ties, return the ones that appear first. Parameters: log (List[str]): List of IP addresses Returns: List[str]: List containing the top three most frequent IP addresses in order # Count frequencies using Counter ip_frequency = Counter(log) # Sort IPs primarily by frequency (descending) and secondarily by their first occurrence in the log sorted_ips = sorted(ip_frequency.keys(), key=lambda ip: (-ip_frequency[ip], log.index(ip))) # Return the top three IPs or fewer if there are less than three unique IP addresses return sorted_ips[:3]"},{"question":"Password Generator Develop a password generator script that creates secure, random passwords based on user-defined criteria. The script should allow the user to specify the length of the password and which types of characters to include (e.g., uppercase letters, lowercase letters, digits, and special characters). Requirements: 1. **Function `generate_password`**: - Takes three parameters: - `length` (int): The total length of the password. - `include_uppercase` (bool): Whether to include uppercase letters. - `include_lowercase` (bool): Whether to include lowercase letters. - `include_digits` (bool): Whether to include digits. - `include_special` (bool): Whether to include special characters. - Generates a secure, random password based on the specified criteria. - Ensures at least one character from each selected type is included. - Raises a ValueError if `length` is less than the number of selected character types. 2. **Character Sets**: - Uppercase letters: `ABCDEFGHIJKLMNOPQRSTUVWXYZ` - Lowercase letters: `abcdefghijklmnopqrstuvwxyz` - Digits: `0123456789` - Special characters: `!@#%^&*()-_=+[]{}|;:,.<>?` Constraints: - Avoid using libraries that do not come with the Python standard library. - Ensure the password is as random as possible. Input & Output Formats: * The `generate_password` function should return a string representing the generated password. Example Usage: ```python >>> generate_password(length=12, include_uppercase=True, include_lowercase=True, include_digits=True, include_special=True) \'Fw8&e9RzTQk\' >>> generate_password(length=8, include_uppercase=False, include_lowercase=True, include_digits=True, include_special=False) \'d9h5f3b0\' ``` Implementation: Below is an example implementation of the `generate_password` function. ```python import random import string def generate_password(length: int, include_uppercase: bool, include_lowercase: bool, include_digits: bool, include_special: bool) -> str: if length < (include_uppercase + include_lowercase + include_digits + include_special): raise ValueError(\\"Password length is too short for the selected character types\\") character_sets = [] if include_uppercase: character_sets.append(string.ascii_uppercase) if include_lowercase: character_sets.append(string.ascii_lowercase) if include_digits: character_sets.append(string.digits) if include_special: character_sets.append(\'!@#%^&*()-_=+[]{}|;:,.<>?\') if not character_sets: return \'\' # Ensure each type is represented password_chars = [random.choice(characters) for characters in character_sets] # Fill the remaining length with random choices from available characters all_characters = \'\'.join(character_sets) password_chars += [random.choice(all_characters) for _ in range(length - len(password_chars))] # Shuffle the list to ensure randomness random.shuffle(password_chars) return \'\'.join(password_chars) ```","solution":"import random import string def generate_password(length: int, include_uppercase: bool, include_lowercase: bool, include_digits: bool, include_special: bool) -> str: if length < (include_uppercase + include_lowercase + include_digits + include_special): raise ValueError(\\"Password length is too short for the selected character types\\") character_sets = [] if include_uppercase: character_sets.append(string.ascii_uppercase) if include_lowercase: character_sets.append(string.ascii_lowercase) if include_digits: character_sets.append(string.digits) if include_special: character_sets.append(\'!@#%^&*()-_=+[]{}|;:,.<>?\') if not character_sets: return \'\' # Ensure each type is represented password_chars = [random.choice(characters) for characters in character_sets] # Fill the remaining length with random choices from available characters all_characters = \'\'.join(character_sets) password_chars += [random.choice(all_characters) for _ in range(length - len(password_chars))] # Shuffle the list to ensure randomness random.shuffle(password_chars) return \'\'.join(password_chars)"},{"question":"# Coding Question: Palindrome Product Detection Objective Write a function that finds the largest palindrome made from the product of two 3-digit numbers. Function Signature ```python def largest_palindrome_product() -> int: Return the largest palindrome made from the product of two 3-digit numbers. ``` Description **You need to implement a function `largest_palindrome_product()` that returns the largest palindrome that can be obtained by multiplying two 3-digit numbers.** Input and Output Formats **Input**: * The function does not take any parameters. **Output**: * A single integer, the largest palindrome product of two 3-digit numbers. Constraints 1. The function should only consider numbers between 100 and 999 inclusive. Examples ```python >>> largest_palindrome_product() 906609 # 993 * 913 >>> largest_palindrome_product() 888888 # 999 * 888 ``` Implementation Notes * Utilize nested loops to iterate through all possible products of two 3-digit numbers. * Implement a helper function to check if a number is a palindrome. * Optimize to stop the inner loop early when the products become smaller than already found palindromes. ```python def is_palindrome(number: int) -> bool: Check if a given integer is a palindrome. return str(number) == str(number)[::-1] def largest_palindrome_product() -> int: Return the largest palindrome made from the product of two 3-digit numbers. max_palindrome = 0 for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if product <= max_palindrome: break if is_palindrome(product): max_palindrome = product return max_palindrome # Example Usage print(largest_palindrome_product()) ``` Explanation 1. **Nested Loop Approach**: Use nested loops to iterate over pairs of 3-digit numbers from 999 down to 100. 2. **Palindrome Check**: A helper function `is_palindrome(number)` determines if a given number is a palindrome. 3. **Optimization**: The inner loop breaks early if the product is already less than the maximum palindrome found. 4. **Output**: The function outputs the largest palindrome that is the product of two 3-digit numbers.","solution":"def is_palindrome(number: int) -> bool: Check if a given integer is a palindrome. return str(number) == str(number)[::-1] def largest_palindrome_product() -> int: Return the largest palindrome made from the product of two 3-digit numbers. max_palindrome = 0 for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if product <= max_palindrome: break if is_palindrome(product): max_palindrome = product return max_palindrome"},{"question":"# Question: Rotating Matrix Elements You are given a square matrix of integers where each element of the matrix is an integer. You need to rotate the elements of the matrix 90 degrees clockwise in place. **Task**: Write a function `rotate_matrix(matrix: list[list[int]]) -> None:` that takes a square matrix of integers and rotates it 90 degrees clockwise. The function should modify the matrix in place. **Function Signature**: ```python def rotate_matrix(matrix: list[list[int]]) -> None: ``` **Input**: * `matrix`: A square matrix represented by a list of lists, where each inner list is a row of integers. **Output**: * The function does not return anything. It modifies the input matrix in place. **Constraints**: * Assume the matrix will always be non-empty and square (i.e., the number of rows is equal to the number of columns). * The value of each integer in the matrix `0 <= matrix[i][j] <= 10^3` **Examples**: ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ [1, 2], [3, 4] ] >>> rotate_matrix(matrix) >>> matrix [ [3, 1], [4, 2] ] ``` **Notes**: * The function should modify the matrix in place. * Make sure to consider performance, although constraints guarantee a reasonable size for matrix (e.g., typically 10-10^3).","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the square matrix 90 degrees clockwise in place. n = len(matrix) # First step: transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step: reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question Description You are required to implement a function to find the sum of all digit squares of a given integer. This exercise will evaluate your understanding of loops, string manipulation, and mathematical operations. # Function Signature ```python def sum_of_digit_squares(number: int) -> int: # Your code goes here ``` # Input - An integer `number` ( -10^5 <= number <= 10^5) # Output - An integer representing the sum of the squares of each digit in the input number. # Constraints - The function should handle both positive and negative inputs. - The function should execute efficiently for all inputs within the given range. # Example ```python # Example 1: print(sum_of_digit_squares(12)) #Output: 5 (1^2 + 2^2) # Example 2: print(sum_of_digit_squares(-41)) #Output: 17 (4^2 + 1^2) # Example 3: print(sum_of_digit_squares(0)) #Output: 0 # Example 4: print(sum_of_digit_squares(99)) #Output: 162 (9^2 + 9^2) ``` # Notes * Ensure your function passes all provided test cases. * Your function should account for both positive and negative integers gracefully. * Focus on writing clean and efficient code to uphold performance expectations.","solution":"def sum_of_digit_squares(number: int) -> int: Returns the sum of the squares of each digit of the given integer. # Convert the number to its absolute value and then to a string number_str = str(abs(number)) # Initialize the sum total = 0 # Iterate over each character in the string for char in number_str: # Convert the character to an integer and compute its square digit = int(char) total += digit * digit return total"},{"question":"# Shipping Cost Calculator A logistics company delivers packages based on the weight of the packages. They have a tiered pricing system for calculating shipping costs. # Problem Description Using the provided pricing tiers, write a function `shipping_cost` that calculates the cost to ship a package based on its weight. # Requirements 1. If the weight of the package is less than 5 Kg, the shipping cost is `5 per Kg`. 2. If the weight of the package is between 5 Kg and 20 Kg (inclusive), the shipping cost is `4 per Kg`. 3. If the weight of the package is greater than 20 Kg, the shipping cost is `3 per Kg`. # Additional Requirements 1. If an invalid weight (negative value) is provided, your function should raise a `ValueError` with the message: \\"Weight must be a non-negative value.\\" # Function Signature ```python def shipping_cost(weight: float) -> float: ``` # Input * `weight` (float): The weight of the package in kilograms. # Output * Returns a float representing the shipping cost in dollars. # Constraints 1. The weight is a non-negative float, and if an invalid weight (negative value) is provided, your function should raise a `ValueError`. # Example ```python def shipping_cost(weight: float) -> float: >>> shipping_cost(3) 15.0 >>> shipping_cost(10) 40.0 >>> shipping_cost(25) 75.0 >>> shipping_cost(-3) Traceback (most recent call last): ... ValueError: Weight must be a non-negative value if weight < 0: raise ValueError(\\"Weight must be a non-negative value\\") if weight < 5: return weight * 5 elif weight <= 20: return weight * 4 else: return weight * 3 ```","solution":"def shipping_cost(weight: float) -> float: Calculate the shipping cost based on the weight of the package. Args: weight (float): The weight of the package in kilograms. Returns: float: The cost of shipping the package in dollars. Raises: ValueError: If weight is negative. if weight < 0: raise ValueError(\\"Weight must be a non-negative value\\") if weight < 5: return weight * 5 elif weight <= 20: return weight * 4 else: return weight * 3"},{"question":"# Postfix Expression Evaluation You are asked to implement an evaluator for postfix expressions (also known as Reverse Polish Notation, RPN). Your task is to process a list of tokens and return the calculated result. # Requirements 1. Provide a method `evaluate_postfix(tokens: list[str]) -> float` that takes a list of tokens representing the postfix expression and returns the evaluated result as a float. 2. The allowed operators are `+`, `-`, `*`, `/` which correspond to addition, subtraction, multiplication, and division. 3. All operations are performed using floating-point arithmetic. 4. Numeric tokens will be represented as strings and can be converted to floats for evaluation. # Constraints 1. Each postfix expression will be a valid sequence of tokens. 2. The list of tokens will contain at least one numeric token and sufficient operators to be evaluated into a single result. 3. Division by zero will not occur in the provided test cases. # Example ```python tokens = [\\"2\\", \\"3\\", \\"1\\", \\"*\\", \\"+\\", \\"9\\", \\"-\\"] result = evaluate_postfix(tokens) print(result) # Example Output: -4.0 ``` **Hint:** Use a stack to keep track of numbers and perform operations by popping from the stack when an operator is encountered.","solution":"def evaluate_postfix(tokens: list) -> float: stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(a / b) else: stack.append(float(token)) return stack[0]"},{"question":"# Minimum Cost Path in a Grid (Dynamic Programming) Context: You are given a file named `grid.txt` which contains a rectangular grid of integers. Your task is to calculate the minimum cost to travel from the top-left corner to the bottom-right corner of the grid. You can only move either down or to the right at any point in time. Input: The input file `grid.txt` contains multiple rows of integers, with each row\'s integers separated by spaces. Each integer represents the cost of entering that cell. Output: Return a single integer, which is the minimum possible cost to travel from the top-left corner to the bottom-right corner of the grid. Requirements: * You must read the grid from the `grid.txt` file. * The minimum travel cost should be calculated efficiently, considering time and space complexity. Constraints: * The grid dimensions can go up to 100x100. * All numbers are guaranteed to be non-negative integers. Example: Given the following grid in the file: ``` 1 3 1 1 5 1 4 2 1 ``` The output should be: ``` 7 ``` Explanation: The minimum cost path from the top-left corner to the bottom-right corner is `1 -> 3 -> 1 -> 1 -> 1` with a total cost of `7`. # Task: Implement the function `minimum_cost_path(filename: str) -> int` which reads the grid from the file and returns the minimum cost to traverse it from the top-left to the bottom-right corner. ```python def minimum_cost_path(filename: str) -> int: # Your implementation goes here pass # Example Usage: # assert minimum_cost_path(\\"grid.txt\\") == 7 ```","solution":"def minimum_cost_path(filename: str) -> int: def read_grid(filename): grid = [] with open(filename, \'r\') as file: for line in file: grid.append(list(map(int, line.strip().split()))) return grid grid = read_grid(filename) if not grid: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0]*cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Optimized Transaction Processing You are employed at a financial services company, and your task is to develop an optimized transaction processing system. The system is required to efficiently handle a high volume of transactions, identify duplicates, and maintain a summary of processed transactions. Requirements: 1. Create a function that processes each transaction uniquely based on an identifier. 2. Transactions identified as duplicates should not be reprocessed. 3. Summarize the total amount of processed transactions in real-time. # Function Specification Implement a function `process_transactions(transactions: List[Dict[str, Union[int, str]]]) -> Tuple[Set[str], int]` that processes a list of transactions and returns a summary. Each transaction is represented as a dictionary containing `id` (unique identifier), `amount` (transaction amount), and `description` (description of the transaction). Inputs: - `transactions`: A list of dictionaries, each containing: - `id`: A string representing the unique identifier of the transaction. - `amount`: An integer representing the transaction amount. - `description`: A string describing the transaction. Outputs: - A tuple containing: - A set of processed transaction identifiers. - An integer representing the total amount of processed transactions. Constraints: - Transactions may have duplicate `id`s. - Each `id` will be a non-empty string. - `amount` will be a non-negative integer. Performance Requirements: - The solution should be optimized for real-time processing of a high volume of transactions. Example Usage: ```python transactions = [ {\\"id\\": \\"T1\\", \\"amount\\": 100, \\"description\\": \\"Payment\\"}, {\\"id\\": \\"T2\\", \\"amount\\": 200, \\"description\\": \\"Refund\\"}, {\\"id\\": \\"T1\\", \\"amount\\": 100, \\"description\\": \\"Payment Duplicate\\"}, ] processed_ids, total_amount = process_transactions(transactions) print(processed_ids) # Output: {\'T1\', \'T2\'} print(total_amount) # Output: 300 ```","solution":"def process_transactions(transactions): Processes a list of transactions, ensuring each transaction with a unique identifier is processed only once. Returns a tuple containing a set of processed transaction IDs and the total amount of processed transactions. processed_ids = set() total_amount = 0 for transaction in transactions: transaction_id = transaction[\'id\'] if transaction_id not in processed_ids: processed_ids.add(transaction_id) total_amount += transaction[\'amount\'] return processed_ids, total_amount"},{"question":"# Prime Sum Decomposition Given a positive integer ( n ), return an array of the smallest prime numbers that sum up to ( n ). The solution should include the minimum number of prime numbers. # Function Signature ```python def prime_sum_decomposition(n: int) -> List[int]: Returns an array of the smallest prime numbers that sum up to n with the fewest possible elements. Args: n (int): The target sum to be achieved with prime numbers. Returns: List[int]: A list of prime numbers that sum up to n. ``` # Input & Output - **Input**: A single integer ( n ) where ( n geq 2 ). - **Output**: A list of prime numbers that sum up to ( n ). # Constraints - ( n ) will be a positive integer. - The list should contain the minimum number of prime numbers that add up to ( n ). # Performance Requirements - The solution should aim for optimal efficiency, especially for larger values of ( n ). # Examples ```python assert prime_sum_decomposition(10) == [5, 5] assert prime_sum_decomposition(11) == [11] assert prime_sum_decomposition(28) == [23, 5] assert prime_sum_decomposition(7) == [7] ``` # Explanation For ( n = 10 ): - The smallest primes that sum up to 10 are (5) and (5). For ( n = 11 ): - 11 itself is a prime number. For ( n = 28 ): - The minimum number of primes summing to 28 are (23) and (5). For ( n = 7 ): - 7 itself is a prime number.","solution":"from typing import List def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_sum_decomposition(n: int) -> List[int]: # Special cases where n itself is prime if is_prime(n): return [n] # Start by checking for the smallest primes that can form the sum n primes = [] # Handle even numbers if n % 2 == 0: primes = [2] * (n // 2) else: # Handle odd numbers primes.append(3) n -= 3 primes += [2] * (n // 2) return primes"},{"question":"# Palindrome Check Function with Ignored Special Characters Problem Statement: You are required to implement a function that determines whether a given string is a palindrome, ignoring special characters, spaces, and case sensitivity. The function should process edge cases, such as an empty string, gracefully. Function Signature ```python def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome, ignoring special characters, spaces, and case sensitivity. Args: s (str): The input string to check. Returns: bool: True if the input string is a palindrome, False otherwise. ``` Input: * `s` (str): The string to check for palindrome property. Output: * Returns `True` if `s` is a palindrome, considering the ignored special characters, spaces, and case insensitivity. Otherwise, returns `False`. Constraints: * The input `s` can be any string, including empty. Examples: ```python >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"No lemon, no melon\\") True ``` # Guidelines: 1. Use appropriate string manipulation methods to clean and preprocess the input string. 2. Implement the check for the palindrome property considering the constraints. 3. Consider edge cases, such as an empty string or a string with only special characters. 4. Aim for a clear and efficient implementation.","solution":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome, ignoring special characters, spaces, and case sensitivity. Args: s (str): The input string to check. Returns: bool: True if the input string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"# Coding Assessment Question: Implementing a Custom Regularization Technique for Neural Networks Context You are working on a neural network model to classify images of fashion items from the Fashion MNIST dataset. To prevent overfitting and improve the robustness of your neural network, you decide to implement a custom regularization technique known as DropConnect. Objective Write a Python function to implement the DropConnect regularization technique and integrate it into a simple neural network. Requirements 1. **Function Name**: `apply_dropconnect` 2. **Input**: * A numpy array `weights` of shape (m, n) representing the weight matrix of a neural network layer. * A float `drop_rate` representing the probability of setting each weight to zero. 3. **Output**: A numpy array of the same shape as the input, where certain elements are dropped out according to the DropConnect rule. Constraints * Do not use third-party libraries for the core DropConnect function (rely on numpy only). * Assume `drop_rate` will be between 0 and 1. * If `drop_rate` is 0, return the weights as they are. Performance Requirements * Your function should process the input in O(m*n) time where m and n are the dimensions of the weight matrix. * The space complexity should also be O(m*n) due to the numpy array manipulations. Example ```python >>> import numpy as np >>> weights = np.array([[0.2, -0.5], [0.3, 0.8]]) >>> apply_dropconnect(weights, drop_rate=0.5) array([[0. , -0.5], [0.3, 0. ]]) ``` Additional Task Integrate your DropConnect implementation into a simple feedforward neural network using any machine learning framework of your choice (e.g., TensorFlow, PyTorch, or custom numpy code). The network should consist of: * An input layer matching the input shape of the data. * One hidden layer with 128 neurons, regularized using DropConnect. * An output layer suitable for fashion item classification. Document your code and provide a short summary (not more than 200 words) of why DropConnect might be better than traditional Dropout in this context, supported by any theoretical explanation or empirical evidence you can cite.","solution":"import numpy as np def apply_dropconnect(weights, drop_rate): Applies the DropConnect regularization technique to the weight matrix. Parameters: - weights: numpy array of shape (m, n) - drop_rate: float, probability of setting each weight to zero Returns: - numpy array of the same shape as weights, where certain elements are dropped out according to the DropConnect rule if drop_rate <= 0: return weights mask = np.random.binomial(1, 1-drop_rate, size=weights.shape) return weights * mask"},{"question":"# Coding Assessment Question **Context**: Imagine you are analyzing networks of social connections, represented as an undirected graph. One interesting aspect to explore is the concept of \\"influencers,\\" which can be defined as nodes with the highest degree of connectivity (i.e., the number of direct connections they have). **Task**: Write a function `find_influencers(n: int, edges: List[Tuple[int, int]]) -> List[int]` that: 1. Receives an integer `n` (1 â‰¤ n â‰¤ 10^5), representing the number of nodes. 2. Receives a list of tuples `edges`, where each tuple `(a, b)` (1 â‰¤ a, b â‰¤ n) represents an undirected edge between nodes `a` and `b`. 3. Returns a list of integers representing the nodes with the highest degree of connectivity. **Input**: - An integer `n` specifying the number of nodes. - A list of tuples `edges` specifying the undirected edges between nodes. **Output**: - A list of integers representing the nodes with the highest degree of connectivity. **Constraints**: - If multiple nodes have the same highest degree, the function should return them in ascending order. **Example**: ```python print(find_influencers(5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])) # Output: [3] print(find_influencers(4, [(1, 2), (2, 3), (3, 4), (4, 1)])) # Output: [1, 2, 3, 4] print(find_influencers(3, [(1, 2), (2, 3)])) # Output: [2] ``` **Function Signature**: ```python from typing import List, Tuple def find_influencers(n: int, edges: List[Tuple[int, int]]) -> List[int]: pass ``` Ensure your solution efficiently builds the connectivity degree of each node and determines the nodes with the highest degree.","solution":"from typing import List, Tuple from collections import defaultdict def find_influencers(n: int, edges: List[Tuple[int, int]]) -> List[int]: # Dictionary to store the count of connections for each node degree_count = defaultdict(int) # Iterate over the edges to update the degree count for a, b in edges: degree_count[a] += 1 degree_count[b] += 1 # Find the maximum degree max_degree = max(degree_count.values(), default=0) # Find the nodes with the maximum degree influencers = [node for node, degree in degree_count.items() if degree == max_degree] # Sorting the nodes in ascending order influencers.sort() return influencers"},{"question":"# Singly Linked List: Detect and Remove Loop You are provided with a class `SinglyLinkedList` that supports standard operations such as insertion at the head or tail, and basic traversals. Your task is to enhance this singly linked list implementation with a new method to detect if there is a cycle (loop) in the list and, if a loop is found, remove the loop. # Requirements 1. Implement a method `detect_and_remove_loop` to detect a loop in the linked list. If a loop is found, remove the loop. 2. Your method should make use of Floydâ€™s Cycle-Finding Algorithm (also known as the slow and fast pointer technique) to detect the loop. 3. If a loop is detected, remove it by breaking the loop so that the linked list ends properly at the last node. # Input - No inputs are directly passed to your method. This method will operate on the list instance. # Output - The method should return `True` if a loop was detected and removed, otherwise return `False`. # Example ```python # SinglyLinkedList instance s s.insert_tail(1) s.insert_tail(2) s.insert_tail(3) s.insert_tail(4) s.insert_tail(5) # Creating a cycle: 5 -> 2 s.head.next.next.next.next.next = s.head.next # Before loop removal s.detect_and_remove_loop() # Output should be: True # After loop removal s.detect_and_remove_loop() # Output should be: False # Traversal after loop removal s.traverse() # Output should be: [1, 2, 3, 4, 5] ``` # Constraints 1. Use Floydâ€™s Cycle-Finding Algorithm to detect the loop. 2. Implement an efficient way to remove the loop without modifying other existing methods. 3. Ensure the solution works in linear time, O(n), where n is the number of nodes in the linked list. Note: You may assume that the SinglyLinkedList and its basic methods (e.g., `insert_tail`, `traverse`) are already defined.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_tail(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def detect_and_remove_loop(self): slow = self.head fast = self.head # Detect Loop using Floydâ€™s Cycle-Finding Algorithm while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: self._remove_loop(slow) return True return False def _remove_loop(self, loop_node): ptr1 = self.head while True: ptr2 = loop_node while ptr2.next != loop_node and ptr2.next != ptr1: ptr2 = ptr2.next if ptr2.next == ptr1: break ptr1 = ptr1.next # Breaking the loop ptr2.next = None def traverse(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result"},{"question":"# Coding Assessment Question You are required to implement a function that calculates the minimum number of meeting rooms required to accommodate all meetings given their start and end times. # Requirements 1. **Input**: A list of tuples, where each tuple consists of two integers representing the start and end times of a meeting. 2. **Output**: A single integer representing the minimum number of meeting rooms required. # Constraints 1. The input list will have between 1 and 10^4 tuples. 2. The start time of a meeting will always be less than the end time. 3. Meeting times are given in 24-hour format, where 0 <= start < end <= 2359. # Example ```python def min_meeting_rooms(meetings: list[tuple[int, int]]) -> int: pass print(min_meeting_rooms([(0, 30), (5, 10), (15, 20)])) # 2 print(min_meeting_rooms([(7, 10), (2, 4)])) # 1 print(min_meeting_rooms([(1, 5), (8, 9), (8, 9), (5, 6)])) # 2 ``` # Notes 1. Utilize a min heap to keep track of the end times of the meetings currently occupying meeting rooms. 2. At any given time, the size of the heap represents the number of rooms being used. 3. When a meeting starts, compare its start time with the earliest end time in the heap. 4. If the room with the earliest end time is free (i.e., its end time is less than or equal to the current start time), reuse that room; otherwise, allocate a new room. 5. Ensure the solution handles edge cases where meetings might start exactly when another one ends.","solution":"import heapq def min_meeting_rooms(meetings): Calculate the minimum number of meeting rooms required to accommodate all meetings. Args: meetings (list of tuple): A list of tuples where each tuple consists of two integers representing the start and end times of a meeting. Returns: int: The minimum number of meeting rooms required. if not meetings: return 0 # Sort meetings based on start time meetings.sort(key=lambda x: x[0]) # Initialize a min heap to keep track of end times of meetings heap = [] # Add the end time of the first meeting heapq.heappush(heap, meetings[0][1]) # Iterate through the remaining meetings for meeting in meetings[1:]: # If the room due to free up next is free before the next meeting starts if heap[0] <= meeting[0]: heapq.heappop(heap) # Add the current meeting\'s end time to the heap heapq.heappush(heap, meeting[1]) # The size of the heap is the number of rooms required return len(heap)"},{"question":"# Coding Question Context You are developing a software application that requires generating a specific sequence of strings. The strings should be generated in such a way that they follow a specific pattern involving numbers and letters. Specifically, you are to generate the \\"Zigzag\\" sequence as described below. Problem Statement Implement a function called `zigzag_sequence` that generates a zigzag sequence of strings. The sequence starts with a number, followed by an uppercase letter, the next number increased by 1, the next uppercase letter following the previous letter in the alphabet, and so on. The sequence should alternate between numbers and letters, repeating this pattern until `n` elements are produced. ```python def zigzag_sequence(n): Generates a zigzag sequence of strings containing n elements. Parameters: n (int): Number of elements in the sequence. Returns: list: A list of n strings representing the zigzag sequence. pass ``` # Constraints 1. `1 <= n <= 26` (there are exactly 26 uppercase letters) 2. The sequence should use uppercase English letters starting from \'A\' and numbers starting from 1. 3. Ensure that if `n` is even (e.g., 4), the sequence starts and ends with numbers. If `n` is odd (e.g., 5), the sequence starts with a number and alternates between numbers and letters. Example ```python assert zigzag_sequence(1) == [\'1\'] # Only the first number assert zigzag_sequence(2) == [\'1\', \'A\'] # First number and first letter assert zigzag_sequence(6) == [\'1\', \'A\', \'2\', \'B\', \'3\', \'C\'] # Alternating numbers and letters assert zigzag_sequence(7) == [\'1\', \'A\', \'2\', \'B\', \'3\', \'C\', \'4\'] # Continues the pattern ``` # Performance Requirements Your function should efficiently generate the zigzag sequence considering the given constraints. Aim for a time complexity around O(n), as the size of `n` is constrained and manageable within the context.","solution":"def zigzag_sequence(n): Generates a zigzag sequence of strings containing n elements. Parameters: n (int): Number of elements in the sequence. Returns: list: A list of n strings representing the zigzag sequence. sequence = [] number = 1 letter = ord(\'A\') for i in range(n): if i % 2 == 0: sequence.append(str(number)) number += 1 else: sequence.append(chr(letter)) letter += 1 return sequence"},{"question":"# Problem Statement You are tasked with implementing a function to determine the nth Fibonacci number. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones: [ F(n) = begin{cases} 0 & text{if } n = 0 1 & text{if } n = 1 F(n-1) + F(n-2) & text{if } n > 1 end{cases} ] # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Input - **n** (int): The position in the Fibonacci sequence to compute. # Output - **result** (int): The nth Fibonacci number. # Constraints 1. `n` is a positive integer, starting from 0, with ( 0 leq n leq 10^6 ). 2. The function should raise a `TypeError` if `n` is not an integer. 3. The function should raise a `ValueError` if `n` is negative. # Performance Requirements Ensure your implementation is optimized and can handle the upper limit of (10^6) efficiently. # Examples ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 >>> fibonacci(\'hello\') Traceback (most recent call last): ... TypeError: Undefined for non-integers >>> fibonacci(-5) Traceback (most recent call last): ... ValueError: Undefined for negative numbers ``` # Implementation Notes To compute the nth Fibonacci number: 1. Handle basic edge cases where ( n ) is 0 or 1 explicitly. 2. For higher values of ( n ), utilize an iterative approach or matrix exponentiation to achieve optimal performance. 3. Ensure your solution efficiently manages very large inputs up to (10^6) without excessive memory usage or time complexity. Your solution should handle various edge cases and provide accurate results as per the specified constraints.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence to compute. Returns: int: The nth Fibonacci number. Raises: TypeError: If n is not an integer. ValueError: If n is a negative integer. if not isinstance(n, int): raise TypeError(\\"Undefined for non-integers\\") if n < 0: raise ValueError(\\"Undefined for negative numbers\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question: Binary Search Tree with Depth Calculation Objective: Implement a binary search tree (BST) class with the ability to insert elements and calculate the depth of the tree. Description: Design and implement a class `BinarySearchTree` which supports the following methods: * `__init__(self)`: Initializes an empty BST. * `insert(self, value)`: Inserts a value into the BST in its appropriate position. * `depth(self)`: Computes and returns the depth of the BST. Input/Output: * `__init__(self)`: Initializes an empty BST. * `insert(self, value)`: Inserts the value into the BST, maintaining the properties of a binary search tree. * `depth(self)`: Returns the depth of the BST. The depth of a tree with no nodes is `0`, a tree with one node is `1`, and so on. Constraints: * Values are unique integers. * The depth calculation should be efficient, ideally O(n) where n is the number of nodes. Example: ```python # Example usage bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(15) bst.insert(12) bst.insert(20) print(bst.depth()) # Output: 3 ``` Requirements: * Implement the BST inserting method ensuring tree properties are maintained. * Implement a method to calculate the depth of the BST. * Provide handling for edge cases like inserting nodes into an initially empty tree. Good luck!","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): Inserts a value into the BST. if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def depth(self): Computes and returns the depth of the BST. return self._depth_recursive(self.root) def _depth_recursive(self, node): if node is None: return 0 else: left_depth = self._depth_recursive(node.left) right_depth = self._depth_recursive(node.right) return max(left_depth, right_depth) + 1"},{"question":"# Binary Tree Leaf Sum You are provided with a Binary Tree data structure. Your task is to write a program to find the sum of all leaf nodes in the given binary tree. A leaf node is one that does not have any children. **Problem Statement:** Implement a function to calculate the sum of all the leaf nodes in a binary tree. **Function Signature:** ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeafNodes(root: TreeNode) -> int: Compute the sum of all leaf nodes in the binary tree. :param root: Root node of the binary tree. :return: Sum of all leaf nodes\' values. ``` **Requirements:** 1. If the tree is empty (root is `None`), return 0. 2. Traverse the binary tree and identify the leaf nodes (nodes without children). 3. Sum the values of all identified leaf nodes and return the result. **Examples:** ```python # Example 1 # Tree structure: # 1 # / # 2 3 # / # 4 5 root1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) assert sumOfLeafNodes(root1) == 12 # (4 + 5 + 3) # Example 2 # Tree structure: # 1 # # 3 root2 = TreeNode(1, None, TreeNode(3)) assert sumOfLeafNodes(root2) == 3 # (3) # Example 3 # Tree structure: # 1 # / # 2 # # 4 root3 = TreeNode(1, TreeNode(2, None, TreeNode(4))) assert sumOfLeafNodes(root3) == 4 # (4) # Example 4 # Tree structure: # empty tree root4 = None assert sumOfLeafNodes(root4) == 0 # (no nodes) ``` **Notes:** - Ensure the function handles both balanced and unbalanced trees. - Consider edge cases such as trees with only one node (which itself is a leaf node). - Your solution should effectively traverse the tree and correctly identify leaf nodes to sum up their values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeafNodes(root: TreeNode) -> int: Compute the sum of all leaf nodes in the binary tree. :param root: Root node of the binary tree. :return: Sum of all leaf nodes\' values. if root is None: return 0 # If the node is a leaf node, return its value. if root.left is None and root.right is None: return root.val # Recursively sum the leaf nodes of left and right subtrees. left_sum = sumOfLeafNodes(root.left) right_sum = sumOfLeafNodes(root.right) return left_sum + right_sum"},{"question":"**Problem Statement**: You are tasked with designing a program that simulates lane merging for vehicles. Given the positions and speeds of vehicles in two lanes, your task is to determine the sequence of events as vehicles from both lanes merge into a single lane such that no collisions occur. The merging lane should maintain the order of arrival as much as possible. **Function Signature**: ```python def merge_lanes( lane_a: list[tuple[int, int]], lane_b: list[tuple[int, int]] ) -> list[tuple[str, int]]: ``` **Input**: * `lane_a` (list of tuples): A list where each tuple represents a vehicle in lane A. Each tuple contains two integers - the vehicle\'s initial position and its speed. * `lane_b` (list of tuples): A list where each tuple represents a vehicle in lane B. Each tuple contains two integers - the vehicle\'s initial position and its speed. **Output**: * A list of tuples where each tuple represents a vehicle and its sequence in the merged lane. Each tuple contains a string indicating the original lane (\'A\' or \'B\') and the initial position of the vehicle from that lane. **Constraints**: * Both lanes are sorted by the initial position of vehicles. * No two vehicles in the same lane start with the same position. * Positions and speeds are non-negative integers. * The merging process should be collision-free, meaning at any time, the position of one vehicle should not match the position of another vehicle. **Performance Requirements**: - The solution should run in O(n + m) time, where `n` and `m` are the lengths of `lane_a` and `lane_b` respectively. - The space complexity should be O(n + m). **Example**: ```python lane_a = [(0, 2), (4, 1)] lane_b = [(1, 3), (5, 2)] result = merge_lanes(lane_a, lane_b) print(result) # Output: [(\'A\', 0), (\'B\', 1), (\'A\', 4), (\'B\', 5)] ``` **Detailed Steps**: 1. Initialize two pointers, one for each lane. 2. Compare the positions of the vehicles indicated by the pointers. Append the vehicle with the lesser position to the resulting list. 3. Move the pointer of the lane from which the vehicle was appended forward. 4. Continue this process until all vehicles from both lanes are processed. 5. Ensure that the vehicles in the resulting list maintain the order of arrival as much as possible while avoiding collisions. **Note**: Merging should maintain order as much as possible but should prioritize avoiding collisions. In the event of potential collisions, vehicles can overtake to prevent them.","solution":"def merge_lanes(lane_a, lane_b): This function merges two lanes of vehicles into one lane with no collisions. Parameters: lane_a (list): A list of tuples representing vehicles in lane A. Each tuple consists of (initial_position, speed). lane_b (list): A list of tuples representing vehicles in lane B. Each tuple consists of (initial_position, speed). Returns: merged_lane (list): A list of tuples representing the merged lane. Each tuple consists of (\\"A\\" or \\"B\\", initial_position). i, j = 0, 0 merged_lane = [] while i < len(lane_a) and j < len(lane_b): if lane_a[i][0] <= lane_b[j][0]: merged_lane.append((\'A\', lane_a[i][0])) i += 1 else: merged_lane.append((\'B\', lane_b[j][0])) j += 1 # Add remaining vehicles while i < len(lane_a): merged_lane.append((\'A\', lane_a[i][0])) i += 1 while j < len(lane_b): merged_lane.append((\'B\', lane_b[j][0])) j += 1 return merged_lane"},{"question":"# Minimum Window Substring Background You are a developer working on a text processing application. One of the features you need to implement is the ability to find the smallest substring in a given text that contains all the characters from a given pattern. This is useful for various applications, such as keyword search optimization. Objective Implement a function `min_window_substring` which, given two strings `s` and `t`, returns the smallest substring of `s` that contains all the characters in `t`. If no such substring exists, return an empty string. Input Format * Two strings, `s` and `t`. * `s` has length (1 leq |s| leq 10^5) and contains only lowercase letters (a-z). * `t` has length (1 leq |t| leq 10^4) and contains only lowercase letters (a-z). Output Format * A string representing the smallest substring of `s` that contains all characters in `t`. If no such substring exists, return an empty string. Constraints * Aim for an optimal solution with time complexity better than (O(n^3)). Examples ```plaintext Example 1: Input: s = \\"ADOBECODEBANC\\", t = \\"ABC\\" Output: \\"BANC\\" Example 2: Input: s = \\"a\\", t = \\"a\\" Output: \\"a\\" Example 3: Input: s = \\"a\\", t = \\"aa\\" Output: \\"\\" ``` Notes * The solution should handle cases where multiple valid substrings are possible but only the smallest one should be returned. * Consider edge cases where the target string is longer than the source string, or characters in the target string are not present in the source string. Implementation Requirements Write the function `min_window_substring(s: str, t: str) -> str` which takes two strings as input and returns the smallest valid window or an empty string if no such window is found. Use an efficient algorithm to ensure performance within acceptable limits for large input sizes.","solution":"from collections import Counter def min_window_substring(s, t): Returns the smallest substring of `s` that contains all the characters in `t`. If no such substring exists, return an empty string. if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 if ans[0] == float(\\"inf\\"): return \\"\\" else: return s[ans[1]:ans[2] + 1]"},{"question":"# Temperature Difference Calculation In some weather applications, it is essential to determine the temperature differences between successive days in a provided list of daily temperatures. For this task, you are required to write a function `temperature_differences` that receives a list of integers representing daily temperatures and returns a list of integers representing the temperature difference between each successive day. The returned list should have one less element than the input list, as there is no previous day temperature to compare the first day with. # Function Signature ```python def temperature_differences(temperatures: list) -> list: pass ``` # Input * `temperatures`: A list of integers where each integer represents the temperature of a day. # Output * Returns a list of integers where each integer represents the difference in temperature from one day to the next. # Constraints * The length of the input list will be between 2 and 100. * The values in the list will range from -100 to 100. # Example ```python >>> temperature_differences([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, -4, -2, 3, 4, -3] >>> temperature_differences([59, 57, 60, 64, 65]) [-2, 3, 4, 1] >>> temperature_differences([30, 30, 30]) [0, 0] ```","solution":"def temperature_differences(temperatures: list) -> list: Returns a list of integers where each integer represents the difference in temperature from one day to the next. return [temperatures[i+1] - temperatures[i] for i in range(len(temperatures) - 1)]"},{"question":"# Problem Statement You are tasked with designing a sensor data processing module for an IoT system. The goal is to collate sensor readings, identify trends, and alert if certain thresholds are crossed. # Requirements Implement a Python class `SensorProcessor` with the following methods: 1. `add_reading(sensor_id: str, timestamp: str, value: float)`: Adds a new sensor reading. - `sensor_id` (str): Unique identifier for the sensor. - `timestamp` (str): ISO8601 format date-time string (e.g. `\\"2023-03-15T12:30:00Z\\"`). - `value` (float): The sensor reading value. 2. `get_average(sensor_id: str, start_time: str, end_time: str) -> float`: Returns the average reading for a given sensor within the specified time range. - `start_time` (str): ISO8601 format start date-time string (e.g. `\\"2023-03-15T00:00:00Z\\"`). - `end_time` (str): ISO8601 format end date-time string (e.g. `\\"2023-03-15T23:59:59Z\\"`). 3. `check_threshold(sensor_id: str, threshold: float) -> bool`: Checks if the latest reading for a given sensor exceeds the specified threshold. - `threshold` (float): Threshold value to check against. 4. `reset()`: Clears all stored data in the processor. # Constraints * Sensor IDs and timestamps are unique for each reading. * Valid timestamps are non-decreasing (i.e., each new reading has a timestamp greater than or equal to the previous one). * You can assume that the input data is valid and correctly formatted. # Input and Output Formats * **Input for `add_reading`**: - `sensor_id: str`: Sensor identifier. - `timestamp: str`: Date-time string in ISO8601 format. - `value: float`: Sensor reading value. * **Output for `get_average`**: - `float`: Average sensor reading value. * **Output for `check_threshold`**: - `bool`: `True` if the latest sensor reading exceeds the threshold, `False` otherwise. * **Output for `reset`**: - None # Example Usage ```python processor = SensorProcessor() processor.add_reading(\\"sensor_1\\", \\"2023-03-15T12:30:00Z\\", 22.5) processor.add_reading(\\"sensor_1\\", \\"2023-03-15T13:00:00Z\\", 23.0) processor.add_reading(\\"sensor_2\\", \\"2023-03-15T12:30:00Z\\", 18.0) print(processor.get_average(\\"sensor_1\\", \\"2023-03-15T12:00:00Z\\", \\"2023-03-15T14:00:00Z\\")) # Output: 22.75 print(processor.check_threshold(\\"sensor_1\\", 22.0)) # Output: True processor.reset() ``` # Notes * You may use any built-in Python libraries and data structures to implement the class and methods. * Ensure that the class handles a large number of readings efficiently.","solution":"import bisect from datetime import datetime from collections import defaultdict class SensorProcessor: def __init__(self): self.readings = defaultdict(list) def add_reading(self, sensor_id: str, timestamp: str, value: float): Adds a new sensor reading. timestamp = datetime.fromisoformat(timestamp.replace(\\"Z\\", \\"+00:00\\")) bisect.insort(self.readings[sensor_id], (timestamp, value)) def get_average(self, sensor_id: str, start_time: str, end_time: str) -> float: Returns the average reading for a given sensor within the specified time range. start_time = datetime.fromisoformat(start_time.replace(\\"Z\\", \\"+00:00\\")) end_time = datetime.fromisoformat(end_time.replace(\\"Z\\", \\"+00:00\\")) readings = self.readings[sensor_id] start_index = bisect.bisect_left(readings, (start_time, float(\'-inf\'))) end_index = bisect.bisect_right(readings, (end_time, float(\'inf\'))) relevant_readings = [value for (timestamp, value) in readings[start_index:end_index]] if not relevant_readings: return 0.0 # Or raise an exception if preferred return sum(relevant_readings) / len(relevant_readings) def check_threshold(self, sensor_id: str, threshold: float) -> bool: Checks if the latest reading for a given sensor exceeds the specified threshold. readings = self.readings[sensor_id] if not readings: return False # Or raise an exception if preferred latest_value = readings[-1][1] return latest_value > threshold def reset(self): Clears all stored data in the processor. self.readings.clear()"},{"question":"**CSV Data Analysis and Summarization** You are working on a project that involves analyzing a large CSV file containing sales data. The sales data contains multiple columns including `Date`, `Product ID`, `Product Name`, `Quantity Sold`, `Price per Unit`, and `Sales Person`. **Objective**: Create a Python script to efficiently read, process, and summarize data from the CSV file. The script should include comprehensive error handling, optimize performance, and adhere to best coding practices. **Tasks**: 1. **File Reading**: Implement a function to read the CSV file efficiently. Handle various potential issues such as missing values, malformed rows, and encoding errors. 2. **Data Summarization**: - Compute the total revenue generated for each product. - Identify the top 5 salespersons based on the total revenue they generated. - Determine the day with the highest sales. 3. **Error Handling**: Ensure the script handles exceptions such as file not found, empty file, and invalid data formats gracefully with appropriate error messages. 4. **Concurrency**: Optimize the script to handle large files using concurrent processing where applicable, for instance by leveraging Python\'s `concurrent.futures` module. 5. **Documentation**: Document the code clearly, explaining key functions and their purpose. Include comments explaining how error handling, concurrent processing, and data aggregation are implemented. **Input and Output**: * Input: Path to the CSV file. * Output: Dictionary containing summarized data with the following structure: ```python { \\"total_revenue_per_product\\": { \\"product_id\\": float }, \\"top_5_salespersons\\": [ { \\"name\\": \\"salesperson_name\\", \\"total_revenue\\": float } ], \\"day_with_highest_sales\\": \\"YYYY-MM-DD\\" } ``` **Constraints**: * The CSV file can be very large, potentially several gigabytes. * The implementation should avoid reading the entire file into memory at once. * Ensure appropriate handling of edge cases such as missing or erroneous data. * Make use of Python libraries and best coding practices to ensure code readability and efficiency. Here is a sample snippet to get you started on reading a CSV file: ```python import csv from typing import Dict, List, Union from concurrent.futures import ThreadPoolExecutor def read_csv_file(file_path: str) -> List[Dict[str, Union[str, int, float]]]: data = [] try: with open(file_path, mode=\\"r\\", encoding=\\"utf-8\\") as csv_file: csv_reader = csv.DictReader(csv_file) for row in csv_reader: data.append(row) except FileNotFoundError: raise FileNotFoundError(f\\"File not found: {file_path}\\") except UnicodeDecodeError: raise ValueError(f\\"Encoding error in file: {file_path}\\") except csv.Error as e: raise ValueError(f\\"CSV file reading error: {str(e)}\\") return data def summarize_data(data: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Union[Dict[str, float], List[Dict[str, Union[str, float]]], str]]: # Implement the summarization logic here pass if __name__ == \\"__main__\\": file_path = \\"path_to_your_csv_file.csv\\" data = read_csv_file(file_path) summary = summarize_data(data) print(summary) ```","solution":"import csv from typing import Dict, List, Union from concurrent.futures import ThreadPoolExecutor from collections import defaultdict from datetime import datetime def read_csv_file(file_path: str) -> List[Dict[str, Union[str, int, float]]]: data = [] try: with open(file_path, mode=\\"r\\", encoding=\\"utf-8\\") as csv_file: csv_reader = csv.DictReader(csv_file) for row in csv_reader: try: row[\'Quantity Sold\'] = int(row[\'Quantity Sold\']) row[\'Price per Unit\'] = float(row[\'Price per Unit\']) data.append(row) except ValueError as ve: continue # Skip malformed rows except FileNotFoundError: raise FileNotFoundError(f\\"File not found: {file_path}\\") except UnicodeDecodeError: raise ValueError(f\\"Encoding error in file: {file_path}\\") except csv.Error as e: raise ValueError(f\\"CSV file reading error: {str(e)}\\") if not data: raise ValueError(\\"CSV file is empty or only contains malformed rows.\\") return data def summarize_data(data: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Union[Dict[str, float], List[Dict[str, Union[str, float]]], str]]: total_revenue_per_product = defaultdict(float) total_revenue_per_salesperson = defaultdict(float) revenue_per_day = defaultdict(float) for row in data: quantity_sold = row[\'Quantity Sold\'] price_per_unit = row[\'Price per Unit\'] product_id = row[\'Product ID\'] sales_person = row[\'Sales Person\'] revenue = quantity_sold * price_per_unit total_revenue_per_product[product_id] += revenue total_revenue_per_salesperson[sales_person] += revenue try: date = datetime.strptime(row[\'Date\'], \\"%Y-%m-%d\\").date() revenue_per_day[date] += revenue except ValueError: continue # Skip rows with invalid date top_5_salespersons = sorted( total_revenue_per_salesperson.items(), key=lambda x: x[1], reverse=True)[:5] top_5_salespersons = [{\'name\': sp, \'total_revenue\': revenue} for sp, revenue in top_5_salespersons] day_with_highest_sales = max(revenue_per_day, key=revenue_per_day.get).isoformat() summary = { \\"total_revenue_per_product\\": dict(total_revenue_per_product), \\"top_5_salespersons\\": top_5_salespersons, \\"day_with_highest_sales\\": day_with_highest_sales } return summary if __name__ == \\"__main__\\": import sys if len(sys.argv) < 2: print(\\"Usage: python script.py <path_to_csv_file>\\") sys.exit(1) file_path = sys.argv[1] try: data = read_csv_file(file_path) summary = summarize_data(data) print(summary) except Exception as e: print(f\\"Error: {e}\\")"},{"question":"# Problem Statement Given an integer `n`, return the total number of unique BSTs (binary search trees) that can be generated with precisely `n` distinct nodes. The result should be an integer. A BST is defined such that for each node: - The left subtree contains only nodes with values less than the node\'s value. - The right subtree contains only nodes with values greater than the node\'s value. - Both left and right subtrees must also be binary search trees. Use the formula for the n-th Catalan number to determine this count: [ C(n) = frac{1}{n+1} binom{2n}{n} ] where ( binom{2n}{n} ) is a binomial coefficient: [ binom{2n}{n} = frac{(2n)!}{(n!)(n!)} ] Given: - `1 <= n <= 19` Write a function: ```python def num_unique_bsts(n: int) -> int: pass ``` # Input - `n`: An integer representing the number of distinct nodes. # Output - The function should return an integer representing the total number of unique BSTs. # Example ```python print(num_unique_bsts(3)) # Output: 5 print(num_unique_bsts(4)) # Output: 14 ``` # Constraints - Ensure the function executes efficiently within the provided range of `n`. - Use combinatorial mathematics and the properties of Catalan numbers to compute the result efficiently without calculating large factorials directly.","solution":"import math def num_unique_bsts(n: int) -> int: Returns the number of unique BSTs that can be created with n distinct nodes. if n == 0: return 1 # Using the formula for Catalan number catalan_number = math.comb(2 * n, n) // (n + 1) return catalan_number"},{"question":"# Scenario You are working as a software developer and need to implement a function that cleans up file paths. This function should eliminate any redundant or unnecessary elements and normalize the file path. # Problem Statement Write a function `simplify_path(path: str) -> str` that simplifies an absolute Unix-style path and returns the canonical path, which follows these rules: - The canonical path should start with a single slash `/`. - Any two consecutive slashes `//` are converted into a single slash `/`. - Any `.` (representing the current directory) in the path should be removed. - Any `..` (representing the parent directory) should cause the function to move up one directory. - The canonical path should not end with a slash `/` unless it is the root `/`. # Example ```python >>> simplify_path(\\"/home/\\") \'/home\' >>> simplify_path(\\"/../\\") \'/\' >>> simplify_path(\\"/home//foo/\\") \'/home/foo\' >>> simplify_path(\\"/a/./b/../../c/\\") \'/c\' >>> simplify_path(\\"/a/../../b/../c//.//\\") \'/c\' >>> simplify_path(\\"/a//b////c/d//././/..\\") \'/a/b/c\' ``` # Input and Output Formats - **Input**: A single string `path` representing the absolute file path. - **Output**: A simplified canonical path. # Constraints - The input path can be any non-empty string of length between 1 and 10^4 characters. - The input path will only contain ASCII characters and will be a valid Unix-style absolute path. # Performance Requirements Your solution should aim for a time complexity of O(n) where n is the length of the input path, and a space complexity of O(n).","solution":"def simplify_path(path: str) -> str: Simplify the given absolute Unix-style path to its canonical form. Args: path (str): The absolute path to be simplified. Returns: str: The simplified canonical path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue if part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Problem Statement You are given a string consisting of lowercase alphabets and integers. Your task is to write a function to generate all possible strings by replacing each integer in the original string with all lowercase alphabets. For each integer in the string, you need to replace it with all letters from \'a\' to \'z\' and generate corresponding strings. Implement the following function: ```python def generate_permutations(s: str) -> list[str]: This function takes a string `s` containing lowercase letters and digits, and returns a list of all possible permutations where each digit is replaced by every letter from \'a\' to \'z\'. :param s: A string containing lowercase letters and digits. :return: A list of strings with all possible replacements. ``` # Constraints: * The length of the string `s` is in the range `[1, 15]`. * `s` consists of lowercase alphabets and digits only. # Example 1. For `s = \\"a1b\\"`, `generate_permutations(s)` should return a list of 26 strings: ``` [\\"aab\\", \\"abb\\", \\"acb\\", \\"adb\\", \\"aeb\\", \\"afb\\", \\"agb\\", \\"ahb\\", \\"aib\\", \\"ajb\\", \\"akb\\", \\"alb\\", \\"amb\\", \\"anb\\", \\"aob\\", \\"apb\\", \\"aqb\\", \\"arb\\", \\"asb\\", \\"atb\\", \\"aub\\", \\"avb\\", \\"awb\\", \\"axb\\", \\"ayb\\", \\"azb\\"] ``` 2. For `s = \\"3c\\"`, `generate_permutations(s)` should return: ``` [\\"ac\\", \\"bc\\", \\"cc\\", \\"dc\\", \\"ec\\", \\"fc\\", \\"gc\\", \\"hc\\", \\"ic\\", \\"jc\\", \\"kc\\", \\"lc\\", \\"mc\\", \\"nc\\", \\"oc\\", \\"pc\\", \\"qc\\", \\"rc\\", \\"sc\\", \\"tc\\", \\"uc\\", \\"vc\\", \\"wc\\", \\"xc\\", \\"yc\\", \\"zc\\"] ``` # Directions: * Implement the function `generate_permutations(s: str) -> list[str]`. * Ensure your solution is optimal in terms of time and space complexity. * Consider edge cases where the string might contain no digits or all digits.","solution":"from itertools import product def generate_permutations(s: str) -> list[str]: This function takes a string `s` containing lowercase letters and digits, and returns a list of all possible permutations where each digit is replaced by every letter from \'a\' to \'z\'. :param s: A string containing lowercase letters and digits. :return: A list of strings with all possible replacements. # Create a list of parts to replace digits with \'a\' to \'z\' parts = [] for char in s: if char.isdigit(): parts.append([chr(i) for i in range(97, 123)]) # \'a\' to \'z\' else: parts.append([char]) # Generate all combinations of replacements all_combinations = product(*parts) # Join each combination into a string result = [\'\'.join(combination) for combination in all_combinations] return result"},{"question":"# Problem Statement You need to write a function `parse_github_repos` that retrieves and processes information about public repositories for a given GitHub user. This function should: 1. Fetch the list of repositories for the provided GitHub username. 2. Allow filtering repositories based on specific criteria such as language, number of stars, and whether the repository is a fork. 3. Implement efficient error handling for various HTTP errors (e.g., 404, 403, and 500). 4. Cache results to minimize redundant API calls within a session. # Function Signature ```python def parse_github_repos( username: str, min_stars: int = 0, language: str = None, include_forks: bool = True, cache_duration: int = 300 ) -> list: Retrieve and process GitHub repositories for a given user with filtering and caching. Parameters: - username (str): The GitHub username. - min_stars (int): Minimum number of stars a repository must have to be included. Default is 0. - language (str): The programming language of the repositories to filter by. - include_forks (bool): Whether to include forked repositories. Default is True. - cache_duration (int): Cache duration in seconds. Default is 300 seconds. Returns: - list: List of dictionaries containing repository information. ``` # Input/Output Examples Input ```python parse_github_repos(\\"octocat\\", min_stars=50, language=\\"Python\\", include_forks=False) ``` Output ```python [ {\\"name\\": \\"Awesome-Project1\\", \\"stars\\": 121, \\"language\\": \\"Python\\", \\"is_fork\\": False, \\"url\\": \\"https://github.com/octocat/Awesome-Project1\\"}, {\\"name\\": \\"Another-Python-Repo\\", \\"stars\\": 98, \\"language\\": \\"Python\\", \\"is_fork\\": False, \\"url\\": \\"https://github.com/octocat/Another-Python-Repo\\"} ] ``` # Constraints and Requirements 1. The `username` parameter is mandatory. 2. The `min_stars`, `language`, and `include_forks` parameters are optional. 3. Handle HTTP errors gracefully, including status codes 404 (Not Found), 403 (Forbidden), and 500 (Server Error). 4. Use caching to avoid redundant API calls within the specified duration. 5. Validate filters to ensure they are applied correctly. 6. Map the results correctly to the provided structure with appropriate data types. # Performance Requirements 1. Optimize network requests, ensuring efficient use of the GitHub API. 2. Handle a reasonable number of repositories (up to the GitHub API\'s maximum pagination limit). # Context This function can be useful for developers and researchers who need to analyze public repositories of a specific GitHub user, such as gathering project statistics, determining language preferences, or identifying popular repositories. It can also aid in creating tools to compare repositories based on different metrics.","solution":"import requests import time from cachetools import TTLCache, cached # Cache with a TTL (Time to Live) cache = TTLCache(maxsize=100, ttl=300) @cached(cache) def parse_github_repos(username: str, min_stars: int = 0, language: str = None, include_forks: bool = True, cache_duration: int = 300) -> list: Retrieve and process GitHub repositories for a given user with filtering and caching. Parameters: - username (str): The GitHub username. - min_stars (int): Minimum number of stars a repository must have to be included. Default is 0. - language (str): The programming language of the repositories to filter by. - include_forks (bool): Whether to include forked repositories. Default is True. - cache_duration (int): Cache duration in seconds. Default is 300 seconds. Returns: - list: List of dictionaries containing repository information. try: url = f\'https://api.github.com/users/{username}/repos\' response = requests.get(url) if response.status_code == 404: print(f\\"Error 404: User \'{username}\' not found\\") return [] elif response.status_code == 403: print(\\"Error 403: Forbidden. You might have hit the API rate limit.\\") return [] elif response.status_code == 500: print(\\"Error 500: Server error. Please try again later.\\") return [] response.raise_for_status() # Raise an error for bad status codes repos = response.json() filtered_repos = [] for repo in repos: if repo[\'stargazers_count\'] < min_stars: continue if language and repo[\'language\'] != language: continue if not include_forks and repo[\'fork\']: continue filtered_repos.append({ \'name\': repo[\'name\'], \'stars\': repo[\'stargazers_count\'], \'language\': repo[\'language\'], \'is_fork\': repo[\'fork\'], \'url\': repo[\'html_url\'] }) return filtered_repos except requests.exceptions.RequestException as e: print(f\\"Error: {e}\\") return []"},{"question":"# Minimum Spanning Tree in a Network A company\'s intranet consists of several servers connected by weighted connections. Each connection has a certain cost associated with it. The company\'s objective is to ensure that all servers are connected with the minimum possible cost, forming a Minimum Spanning Tree (MST). You are tasked with implementing Kruskal\'s algorithm to find the MST of the given weighted, undirected graph. Your function should return the total cost of the MST. **Function Signature**: ```python def kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int: ``` **Input**: * `n`: (Integer) The number of servers (0-indexed nodes). * `edges`: (List of Tuples) Each tuple consists of three values representing an undirected edge - the two connected servers `u` and `v` and the cost `w` of the connection. **Output**: * An integer representing the total cost of the minimum spanning tree. **Constraints**: * 1 â‰¤ n â‰¤ 1000 * 0 â‰¤ len(edges) â‰¤ n * (n - 1) / 2 * 0 â‰¤ w â‰¤ 10^4 **Example**: ```python >>> n = 4 >>> edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] >>> kruskal(n, edges) 19 ``` In this example, the minimum spanning tree will include edges with weights 4, 5, and 10, resulting in a total cost of 19. Implement the `kruskal` function: **Important Considerations**: * Efficiently handle graph components using Union-Find data structure. * Ensure the algorithm correctly identifies cycles and excludes those edges. * Verify that all nodes are part of the final MST. Good luck!","solution":"from typing import List, Tuple def kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int: # Helper function to find the root of a set using path compression def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to perform union of two sets (x and y) using union by rank def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the edges in non-decreasing order of their weight edges.sort(key=lambda item: item[2]) # Allocate memory for creating V subsets parent = [] rank = [] # Create V subsets with single elements for node in range(n): parent.append(node) rank.append(0) result = [] # This will store the resultant MST e = 0 # An index variable, used for result[] # Number of edges to be taken is equal to V-1 for edge in edges: u, v, w = edge root_u = find(parent, u) root_v = find(parent, v) # If including this edge does not cause a cycle, include it in the result # and increment the index of result for next edge if root_u != root_v: e += 1 result.append((u, v, w)) union(parent, rank, root_u, root_v) # If we already have n-1 edges in result, we don\'t need to process further if e == n - 1: break # Calculating the total cost of the MST total_cost = sum([weight for _, _, weight in result]) return total_cost"},{"question":"# Coding Challenge: Longest Increasing Subsequence Context As a software developer, you are tasked with implementing a feature that analyzes a series of numerical data points to identify the longest subsequence of numbers in increasing order. This task involves both identifying the sequence and determining its length. Task Write a function `longest_increasing_subsequence(arr)` that finds the length of the longest increasing subsequence in a given list of integers. Implement two methods within this function: a Dynamic Programming (DP) approach and a more optimal method using Patience Sorting technique. * **longest_increasing_subsequence(arr)** should use Dynamic Programming approach with O(n^2) time complexity. * **longest_increasing_subsequence_optimal(arr)** should use Patience Sorting technique with O(n log n) time complexity. Function Signature ```python def longest_increasing_subsequence(arr: list[int]) -> int: pass def longest_increasing_subsequence_optimal(arr: list[int]) -> int: pass ``` Input * `arr` (list of int): A list of integers representing the data points. Output * Returns the length of the longest increasing subsequence. Constraints * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` Example ```python print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # Output: 4 print(longest_increasing_subsequence_optimal([10, 22, 9, 33, 21, 50, 41, 60, 80])) # Output: 6 print(longest_increasing_subsequence([3, 10, 2, 1, 20])) # Output: 3 print(longest_increasing_subsequence_optimal([50, 3, 10, 7, 40, 80])) # Output: 4 ``` Notes * The function `longest_increasing_subsequence` should handle duplicate values appropriately. * The optimal function, `longest_increasing_subsequence_optimal`, may internally use binary search as part of the Patience Sorting method for efficiency.","solution":"def longest_increasing_subsequence(arr): Finds the length of the longest increasing subsequence in an array using Dynamic Programming approach with O(n^2) time complexity. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will be the length of LIS ending at index i for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_increasing_subsequence_optimal(arr): Finds the length of the longest increasing subsequence in an array using Patience Sorting technique and binary search with O(n log n) time complexity. if not arr: return 0 from bisect import bisect_left subseq = [] # This will store the smallest ending element of all increasing subsequences of all lengths for num in arr: # Find the index of the smallest number greater than or equal to num pos = bisect_left(subseq, num) # If num is larger than any element in subseq if pos == len(subseq): subseq.append(num) else: subseq[pos] = num return len(subseq)"},{"question":"# Fast Exponentiation Implement the fast exponentiation algorithm, also known as exponentiation by squaring, to efficiently compute the power of a base number raised to an exponent. Your task is to create a function that computes `base` raised to the power `exp` (i.e., `base^exp`), where both `base` and `exp` are integers, using an iterative approach. Function Signature ```python def fast_exponentiation(base: int, exp: int) -> int: Compute base raised to the power exp using iterative fast exponentiation. Arguments: base -- an integer, the base number exp -- an integer, the exponent Returns: result -- the computed power, an integer ``` Input - `base`: an integer, where `-10^9 â‰¤ base â‰¤ 10^9` - `exp`: a non-negative integer, where `0 â‰¤ exp â‰¤ 10^9` Output - Returns an integer representing `base` raised to the power `exp`. Example ```python # Example 1 base = 2 exp = 10 result = fast_exponentiation(base, exp) print(result) # Output: 1024 # Example 2 base = 3 exp = 5 result = fast_exponentiation(base, exp) print(result) # Output: 243 # Example 3 base = -2 exp = 3 result = fast_exponentiation(base, exp) print(result) # Output: -8 ``` Detailed Requirements 1. If the exponent `exp` is 0, the function should return 1 (since `base^0` is always 1). 2. If the exponent `exp` is 1, the function should return the base itself. 3. Use the properties of exponentiation by squaring to compute the power efficiently: - If `exp` is even: `(base^exp) = (base^(exp/2)) * (base^(exp/2))` - If `exp` is odd: `(base^exp) = base * (base^(exp-1))` 4. The algorithm should be implemented using an iterative approach rather than a recursive one to avoid stack overflow issues in Python with large exponents. 5. The computation should handle negative base values correctly. # Implementation Here is a sample implementation that fits the given signature and requirements: ```python def fast_exponentiation(base: int, exp: int) -> int: result = 1 while exp > 0: if exp % 2 == 1: result *= base base *= base exp //= 2 return result # Example usage: print(fast_exponentiation(2, 10)) # Output: 1024 print(fast_exponentiation(3, 5)) # Output: 243 print(fast_exponentiation(-2, 3)) # Output: -8 ```","solution":"def fast_exponentiation(base: int, exp: int) -> int: result = 1 while exp > 0: if exp % 2 == 1: result *= base base *= base exp //= 2 return result"},{"question":"# Coding Assessment Question **Identifying Armstrong Numbers** An Armstrong number (also known as a narcissistic number) of `n` digits is a number that is equal to the sum of its own digits each raised to the power of `n`. You are to implement a function `is_armstrong_number(num: int) -> bool` that checks whether a given number is an Armstrong number. **Function Signature:** ```python def is_armstrong_number(num: int) -> bool: ``` **Input:** * An integer (num geq 0), representing the number to be checked. **Output:** * Returns `True` if the number is an Armstrong number. * Returns `False` otherwise. **Constraints:** * (0 leq num leq 10^8). **Examples:** ```python >>> is_armstrong_number(153) True >>> is_armstrong_number(9474) True >>> is_armstrong_number(123) False ``` **Context:** * Armstrong numbers are a special class of numbers with interesting properties that are often explored in recreational mathematics. * These numbers are rare, making their identification a good problem for practicing iteration and power calculations. **Requirements:** 1. Sum the digits of the number each raised to the power of the count of digits. 2. Compare this sum with the original number to determine if it is an Armstrong number. 3. Implement input validation to ensure the number is non-negative. 4. Optimize for performance where practical, given the input constraints.","solution":"def is_armstrong_number(num: int) -> bool: Checks whether a given number is an Armstrong number. Args: num: An integer, the number to check. Returns: bool: True if the number is an Armstrong number, False otherwise. # Convert number to string to easily iterate over digits num_str = str(num) n = len(num_str) # Calculate the sum of each digit raised to the power of the number of digits sum_of_powers = sum(int(digit) ** n for digit in num_str) # Check if the sum of powers is equal to the original number return sum_of_powers == num"},{"question":"# Context: You are developing a real-time monitoring system for a fleet of autonomous vehicles. The system needs to track each vehicle\'s location efficiently and store the data in a way that allows for quick retrieval. The GPS coordinates of each vehicle are continuously updated, and you are tasked with implementing a system that supports fast insertion and querying of location data. # Task: 1. Design a data structure that efficiently supports insertion of GPS coordinates and querying the location of a specific vehicle. 2. Implement the insert and query operations for this data structure. 3. Write comprehensive test cases to ensure the correctness of these operations. # Specifications: * Each vehicle is identified by a unique `vehicle_id` (an integer). * The location of a vehicle is represented by a tuple of two floats `(latitude, longitude)`. * The insert operation should update the location of a vehicle, adding a new entry if the vehicle is not already in the system. * The query operation should return the current location of the vehicle given its `vehicle_id`. # Constraints: * Your implementation should handle up to 10^5 vehicles efficiently. * The operations should be optimized for real-time performance, with both insert and query operations aiming for O(1) time complexity. * Assume valid GPS coordinates and vehicle IDs are provided. # Example: ```python class VehicleTracker: def __init__(self): Initialize your data structure here. # Your implementation here def insert(self, vehicle_id: int, location: (float, float)) -> None: Inserts or updates the vehicle\'s location. :param vehicle_id: Unique identifier for the vehicle :param location: Tuple containing (latitude, longitude) # Your implementation here def query(self, vehicle_id: int) -> (float, float): Queries the location of the specified vehicle. :param vehicle_id: Unique identifier for the vehicle :return: A tuple containing (latitude, longitude) # Your implementation here # Test your implementation: tracker = VehicleTracker() tracker.insert(1, (34.0522, -118.2437)) assert tracker.query(1) == (34.0522, -118.2437) tracker.insert(2, (40.7128, -74.0060)) assert tracker.query(2) == (40.7128, -74.0060) tracker.insert(1, (37.7749, -122.4194)) assert tracker.query(1) == (37.7749, -122.4194) # Additional Test Cases tracker.insert(3, (48.8566, 2.3522)) assert tracker.query(3) == (48.8566, 2.3522) tracker.insert(4, (51.5074, -0.1278)) assert tracker.query(4) == (51.5074, -0.1278) ... ``` Ensure your data structure and methods are adequately documented, clearly explaining the logic and optimizations used for efficient performance. The correctness of location data handling should be thoroughly verified through your test cases.","solution":"class VehicleTracker: def __init__(self): Initialize the data structure for tracking vehicles. We use a dictionary to store vehicle IDs as keys and their locations as values. self.vehicle_locations = {} def insert(self, vehicle_id: int, location: (float, float)) -> None: Inserts or updates the vehicle\'s location. :param vehicle_id: Unique identifier for the vehicle :param location: Tuple containing (latitude, longitude) self.vehicle_locations[vehicle_id] = location def query(self, vehicle_id: int) -> (float, float): Queries the location of the specified vehicle. :param vehicle_id: Unique identifier for the vehicle :return: A tuple containing (latitude, longitude) or None if the vehicle_id does not exist return self.vehicle_locations.get(vehicle_id)"},{"question":"# Question: Find All Pairs with a Given Sum in an Array Write a function that finds all unique pairs of integers in an array that add up to a specified target sum. The function should return a list of tuples, where each tuple represents a pair of integers that add up to the target sum. Each pair should be sorted in ascending order, and the list of pairs should also be sorted in ascending order. Requirements 1. Implement a function `find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]`. 2. The function should return a list of tuples, where each tuple represents a pair (i, j) such that i + j equals the target sum. 3. Each tuple in the result should be sorted such that the smaller element comes first. 4. The list of tuples should be sorted in ascending order based on the first element of each tuple, and then by the second element if the first elements are equal. Example ```python def find_pairs_with_sum(arr, target): # Implement your function here arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 10 result = find_pairs_with_sum(arr, target) print(sorted(result)) # Expected output: # [(1, 9), (2, 8), (3, 7), (4, 6)] ``` Constraints 1. The input array can contain both positive and negative integers. 2. The same pair of elements cannot be used more than once in the final result. 3. Each input pair (i, j) should appear only once in the result list, even if there are multiple occurrences of i and j in the input array. # Additional Note - You may assume that the array contains at least two elements. - Achieve the solution with a time complexity better than O(n^2). This new question integrates seamlessly with the existing questions by matching their style, complexity, and scope. The task involves implementing a function in Python, making use of dictionary operations to achieve an efficient solution, similar to the emphasis on graph traversal in the previous question.","solution":"def find_pairs_with_sum(arr, target): Finds all unique pairs of integers in an array that add up to a specified target sum. Parameters: arr (List[int]): List of integers. target (int): The target sum. Returns: List[Tuple[int, int]]: List of tuples with pairs that add up to the target sum. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted(pairs)"},{"question":"# Anagram Pairs in Array Question Given an array of strings, your task is to find the number of pairs of strings in the array that are anagrams of each other. Implement a function `count_anagram_pairs` that takes a list of strings and returns the count of anagram pairs in the array. Signature ```python def count_anagram_pairs(strings: List[str]) -> int: ``` Input * **strings**: (List[str]) A list containing `s` strings. (1 leq s leq 10^3), where each string consists of lowercase English letters and has a length of at most (100). Output * Returns an integer representing the number of pairs of strings in the array that are anagrams of each other. Example ```python >>> count_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"abc\\", \\"cba\\"]) 6 ``` Explanation: The pairs [(listen, silent), (listen, enlist), (silent, enlist), (google, gogole), (abc, cba)] are anagrams of each other, making a total of 6 pairs. Constraints 1. Consider efficiency in terms of time and space complexity to handle the worst-case scenario within reasonable limits. Implementation Notes 1. Utilize a method to canonicalize strings, such as sorting or frequency counting, to easily compare potential anagrams. 2. Avoid redundant comparisons and optimize the approach to handle large inputs efficiently.","solution":"from typing import List from collections import defaultdict def count_anagram_pairs(strings: List[str]) -> int: Returns the number of pairs of strings in the array that are anagrams of each other. :param strings: List of strings to be checked for anagram pairs. :return: Count of anagram pairs in the given list of strings. # Dictionary to hold the sorted string representation and their counts anagram_dict = defaultdict(int) # Iterate over each string in the input array for string in strings: # Sort the string and use it as the key sorted_string = \'\'.join(sorted(string)) anagram_dict[sorted_string] += 1 # Calculate the number of pairs from the frequencies count_pairs = 0 for freq in anagram_dict.values(): if freq > 1: # Mathematical combination nC2 = n*(n-1)/2 count_pairs += (freq * (freq - 1)) // 2 return count_pairs"},{"question":"# Problem Statement Implement the function `symmetric_difference` that computes the symmetric difference of two sets. The symmetric difference of two sets A and B is the set of elements either in A or B but not in both. # Function Signature ```python def symmetric_difference(set1: Set[int], set2: Set[int]) -> Set[int]: Compute the symmetric difference of two sets. Parameters: set1 (Set[int]): First set of integers. set2 (Set[int]): Second set of integers. Returns: Set[int]: Symmetric difference of set1 and set2. ``` # Input - **set1**: A set of integers. - **set2**: A set of integers. # Output - Return a set containing the symmetric difference of `set1` and `set2`. # Constraints - The size of `set1` and `set2` will be between 0 and 10^4. - The elements of `set1` and `set2` are integers and may have negative values. # Example ```python assert symmetric_difference({1, 2, 3}, {3, 4, 5}) == {1, 2, 4, 5} assert symmetric_difference({1, 2, 3}, {1, 2, 3}) == set() assert symmetric_difference({1, 2, 3, 4}, {3, 4, 5, 6}) == {1, 2, 5, 6} assert symmetric_difference(set(), {1, 2, 3}) == {1, 2, 3} assert symmetric_difference({1, 2, 3}, set()) == {1, 2, 3} assert symmetric_difference(set(), set()) == set() ``` # Notes - Do not use built-in symmetric difference functions to solve the problem. - Ensure to handle edge cases such as when either of the input sets is empty. - Aim for a solution with a time complexity of O(n) where n is the combined size of the two sets.","solution":"def symmetric_difference(set1, set2): Compute the symmetric difference of two sets. Parameters: set1 (Set[int]): First set of integers. set2 (Set[int]): Second set of integers. Returns: Set[int]: Symmetric difference of set1 and set2. return (set1 - set2) | (set2 - set1)"},{"question":"# Context: You are tasked with developing a text editor that supports basic text operations. The features include inserting text, deleting text, and searching for a substring within the current text. Each operation will be provided as an input, and you need to perform these operations sequentially. # Task: Implement a function `text_editor(operations: List[Tuple[str, Union[str, int, Tuple[str, int]]]]) -> List[Union[str, bool]]` that receives a list of operations to perform. Each operation is a tuple containing: - An operation type: \\"insert\\", \\"delete\\", or \\"search\\" - For \\"insert\\", there is a string to insert. - For \\"delete\\", there is an integer specifying the number of characters to delete from the end. - For \\"search\\", there is a tuple containing a substring and the position to start the search from. For \\"insert\\" and \\"delete\\" operations, no output is required. For \\"search\\" operations, the result should be `True` if the substring is found starting from the given position, otherwise `False`. # Input: - `operations`: List of tuples where each tuple is of the form (operation_type, argument). # Output: - A list of booleans representing the result of each \\"search\\" operation. # Constraints: - The text consists of ASCII characters. - The number of operations will not exceed 1000. - For \\"delete\\", if the number of characters to delete exceeds the current text length, delete all characters in the text. - For \\"search\\", the start position is always valid. # Example: ```python operations = [ (\\"insert\\", \\"hello\\"), (\\"insert\\", \\" \\"), (\\"insert\\", \\"world\\"), (\\"search\\", (\\"world\\", 6)), (\\"search\\", (\\"hello\\", 0)), (\\"delete\\", 5), (\\"search\\", (\\"world\\", 6)) ] Output = [True, True, False] ``` # Implementation Notes: 1. Maintain a current text state. 2. Implement the logic for each operation type. 3. Ensure the function correctly appends search results to the output list. Good luck!","solution":"from typing import List, Tuple, Union def text_editor(operations: List[Tuple[str, Union[str, int, Tuple[str, int]]]]) -> List[Union[str, bool]]: text = \\"\\" results = [] for operation in operations: if operation[0] == \\"insert\\": text += operation[1] elif operation[0] == \\"delete\\": num_chars = operation[1] text = text[:-num_chars] if num_chars <= len(text) else \\"\\" elif operation[0] == \\"search\\": substring, start_pos = operation[1] if text.find(substring, start_pos) != -1: results.append(True) else: results.append(False) return results"},{"question":"**Image Processing Filter Application** # Context: You are working on an image processing application that allows users to apply a variety of filters to images. Your task is to implement a specific filter: the \\"Edge Detection\\" filter using multi-threading to improve performance on large images. # Objective: Write a new class `EdgeDetectionFilter` that processes an image using edge detection in a multi-threaded manner. 1. Enhance the `apply_filter` method to divide the image into equal parts and perform edge detection on each part concurrently. 2. Ensure thread safety and optimal performance without compromising the accuracy of the filter. 3. Introduce the capacity to configure the number of threads used for the filtering process. # Constraints: - The input image is represented as a 2D list of integers, where each integer represents a grayscale pixel value in the range 0-255. - The filter should use the Sobel operator for edge detection. - Configure the number of threads `n` (between 1 and 8) during initialization. - The image dimensions (both width and height) will not be smaller than 2 and not exceed 4096. # Specifications: 1. Class Name: `EdgeDetectionFilter` 2. Shall contain the methods: * `__init__(image: List[List[int]], num_threads: int)`: Initializes the filter with the given image and number of threads. * `apply_filter() -> List[List[int]]`: Applies the Sobel edge detection filter to the image and returns the processed image. # Expected Input and Output Formats: - **Input formats**: * Initialization with the image as a 2D list and the number of threads. * `apply_filter()`: No input needed. - **Output formats**: * `apply_filter()`: Returns the processed image as a 2D list. # Performance Requirements: - Divide the work equally among the specified number of threads for efficient processing. - Ensure that edge continuity is preserved across partition boundaries. - The Sobel operator should be implemented directly in the class without relying on third-party libraries. # Example Usage: ```python from threading import Thread # Example grayscale image (3x3 pixel for simplicity) image = [ [100, 150, 200], [150, 200, 250], [200, 250, 300] ] # Initialize the filter with the image and 2 threads filter = EdgeDetectionFilter(image, num_threads=2) # Apply the filter processed_image = filter.apply_filter() # Output the processed image for row in processed_image: print(row) # Expected output # [[gradient values...], [gradient values...], [gradient values...]] ``` Your task is to implement the class `EdgeDetectionFilter` ensuring it performs edge detection using multi-threading effectively.","solution":"from threading import Thread from typing import List class EdgeDetectionFilter: def __init__(self, image: List[List[int]], num_threads: int): self.image = image self.num_threads = max(1, min(num_threads, 8)) self.height = len(image) self.width = len(image[0]) self.output = [[0 for _ in range(self.width)] for _ in range(self.height)] def apply_sobel(self, x: int, y: int) -> int: Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]] Gy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]] def get_pixel(i, j): if 0 <= i < self.height and 0 <= j < self.width: return self.image[i][j] return 0 # Assuming padding with zero sum_x, sum_y = 0, 0 for i in range(3): for j in range(3): p = get_pixel(x + i - 1, y + j - 1) sum_x += Gx[i][j] * p sum_y += Gy[i][j] * p return min(255, max(0, int((sum_x ** 2 + sum_y ** 2) ** 0.5))) def process_part(self, start_row: int, end_row: int): for i in range(start_row, end_row): for j in range(self.width): self.output[i][j] = self.apply_sobel(i, j) def apply_filter(self) -> List[List[int]]: threads = [] part_size = self.height // self.num_threads for i in range(self.num_threads): start_row = i * part_size end_row = (i + 1) * part_size if i != self.num_threads - 1 else self.height thread = Thread(target=self.process_part, args=(start_row, end_row)) threads.append(thread) thread.start() for thread in threads: thread.join() return self.output"},{"question":"# Sorting Custom Objects: Employee Management System Context: You are developing an Employee Management System where it is crucial to sort employee records based on different attributes. Each employee record contains fields like name, employee ID, and salary. To achieve this, the system should be able to sort employees based on their names, IDs, or salary. Problem: Given the `Employee` class and the `EmployeeManagementSystem` class below, write a method named `sort_employees` that sorts the list of employee objects based on a specified attribute, which can be either \'name\', \'employee_id\', or \'salary\'. Specifications 1. **Class Definitions:** ```python from typing import List class Employee: def __init__(self, name: str, employee_id: int, salary: float): self.name = name self.employee_id = employee_id self.salary = salary def __repr__(self): return f\\"Employee(name={self.name}, employee_id={self.employee_id}, salary={self.salary})\\" class EmployeeManagementSystem: def __init__(self, employees: List[Employee]): self.employees = employees ``` 2. **Function Signature:** ```python def sort_employees(self, by: str) -> None: Sorts the employees in-place based on the given attribute. :param by: A string specifying the attribute to sort by (\'name\', \'employee_id\', \'salary\'). ``` 3. **Input:** - `by`: A string indicating the attribute to sort the employees by. It will always be one of \'name\', \'employee_id\', \'salary\'. 4. **Output:** - None. The method should sort the `self.employees` list in-place. 5. **Constraints:** - The attribute specified in the `by` parameter will always be valid. - Ensure stable sorting when multiple employees have the same attribute value. Example Usage: ```python employees = [ Employee(\\"Alice\\", 102, 70000.0), Employee(\\"Bob\\", 101, 68000.0), Employee(\\"Charlie\\", 103, 70000.0) ] ems = EmployeeManagementSystem(employees) # Sort by name ems.sort_employees(by=\'name\') print(ems.employees) # Output: [Employee(name=Alice, employee_id=102, salary=70000.0), Employee(name=Bob, employee_id=101, salary=68000.0), Employee(name=Charlie, employee_id=103, salary=70000.0)] # Sort by employee ID ems.sort_employees(by=\'employee_id\') print(ems.employees) # Output: [Employee(name=Bob, employee_id=101, salary=68000.0), Employee(name=Alice, employee_id=102, salary=70000.0), Employee(name=Charlie, employee_id=103, salary=70000.0)] # Sort by salary ems.sort_employees(by=\'salary\') print(ems.employees) # Output: [Employee(name=Bob, employee_id=101, salary=68000.0), Employee(name=Alice, employee_id=102, salary=70000.0), Employee(name=Charlie, employee_id=103, salary=70000.0)] ``` **Important:** - Utilize the appropriate sorting algorithms to maintain stability. - Ensure the method alters the original employee list rather than returning a new list.","solution":"from typing import List class Employee: def __init__(self, name: str, employee_id: int, salary: float): self.name = name self.employee_id = employee_id self.salary = salary def __repr__(self): return f\\"Employee(name={self.name}, employee_id={self.employee_id}, salary={self.salary})\\" class EmployeeManagementSystem: def __init__(self, employees: List[Employee]): self.employees = employees def sort_employees(self, by: str) -> None: Sorts the employees in-place based on the given attribute. :param by: A string specifying the attribute to sort by (\'name\', \'employee_id\', \'salary\'). if by not in [\\"name\\", \\"employee_id\\", \\"salary\\"]: raise ValueError(f\\"Cannot sort by unknown attribute: {by}\\") self.employees.sort(key=lambda emp: getattr(emp, by))"},{"question":"# Problem Statement You have been hired to create the backend functionality for a simple social media platform. One required feature is to implement a user tag system within posts, where users can tag each other using a specific syntax. You need to write two functions, one to extract user tags from a post and another to replace these tags with a specific placeholder text. # Requirements **Function Signatures**: ```python def extract_tags(post: str) -> list[str]: pass def replace_tags(post: str, placeholder: str) -> str: pass ``` # Input & Output Formats * `extract_tags`: * **Input**: A string `post` containing the text of the post, where user tags are denoted by a \'@\' symbol followed by the username (e.g., \'@john\'). * **Output**: A list `[str]` of usernames tagged in the post. * `replace_tags`: * **Input**: * A string `post` containing the text of the post, similar to the `extract_tags` function. * A string `placeholder` which will replace all user tags in the post. * **Output**: A string with all occurrences of user tags replaced by the provided `placeholder`. # Constraints * Usernames are case-insensitive and can contain alphanumeric characters and underscores. * Usernames are not guaranteed to be unique within a post. * Assume posts are less than 500 characters in length. * Usernames are bounded by `1 <= username.length <= 20`. # Performance Requirements * Time Complexity: O(n) where n is the length of the string. * Space Complexity: O(n) where n is the length of the string. # Example ```python >>> extract_tags(\\"Hey @john, are you joining @jane and me for lunch?\\") [\'john\', \'jane\'] >>> replace_tags(\\"Hey @john, are you joining @jane and me for lunch?\\", \\"[user]\\") \'Hey [user], are you joining [user] and me for lunch?\' ```","solution":"import re def extract_tags(post: str) -> list[str]: Extracts and returns all user tags from the given post. return re.findall(r\'@([A-Za-z0-9_]+)\', post) def replace_tags(post: str, placeholder: str) -> str: Replaces all user tags in the given post with the provided placeholder. return re.sub(r\'@([A-Za-z0-9_]+)\', placeholder, post)"},{"question":"# String Reversal Utility Functions **Context**: String manipulation is a fundamental aspect of programming. Your goal is to implement several utility functions that perform various reversals on a given string. **Tasks**: 1. `reverse_string(s: str) -> str`: Reverses the entire string. 2. `reverse_words(s: str) -> str`: Reverses the order of words in the string while maintaining the order of characters in each word. 3. `reverse_each_word(s: str) -> str`: Reverses each word individually in the string while maintaining the order of the words. 4. `is_palindrome(s: str) -> bool`: Checks if the string is a palindrome (reads the same forward and backward). 5. `reverse_in_place(s: str) -> str`: Reverses the string by swapping characters in place. **Input and Output**: - **Input**: Each function takes a single string `s`. - **Output**: - For `reverse_string`, `reverse_words`, `reverse_each_word`, and `reverse_in_place`, return a string. - For `is_palindrome`, return a boolean. **Constraints**: - `s` consists of printable ASCII characters. - The length of `s` does not exceed 10^5 characters. - Assume the string is non-empty and contains words separated by spaces. **Performance Requirements**: All operations should aim for O(n) time complexity, where `n` is the length of the string. **Examples**: ```python assert reverse_string(\\"hello world\\") == \\"dlrow olleh\\" assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_each_word(\\"hello world\\") == \\"olleh dlrow\\" assert is_palindrome(\\"madam\\") is True assert is_palindrome(\\"hello\\") is False assert reverse_in_place(\\"hello\\") == \\"olleh\\" ``` **Note**: Implement the following functions in a single file named `string_reversal.py`:","solution":"def reverse_string(s: str) -> str: return s[::-1] def reverse_words(s: str) -> str: return \' \'.join(s.split()[::-1]) def reverse_each_word(s: str) -> str: return \' \'.join(word[::-1] for word in s.split()) def is_palindrome(s: str) -> bool: return s == s[::-1] def reverse_in_place(s: str) -> str: s = list(s) left, right = 0, len(s) - 1 while left < right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return \'\'.join(s)"},{"question":"# Question **Integer-Word Converter** You are tasked with implementing a class in Python that converts a given integer into its English words representation. This class should handle numbers from `0` to `999,999`. You must ensure that the code is efficient and handles edge cases effectively. Your task is to: 1. Develop a method to convert an integer into its English words representation. 2. Handle edge cases such as zero and large numbers accurately. 3. Ensure that the method is robust and efficient. **Class Signature** ```python class IntegerToWords: def __init__(self, number: int): ... def convert(self) -> str: ... ``` # Expected Input and Output Format * **Input**: * `number` (int): The integer to be converted. (0 <= number <= 999999) * **Output**: * A string representing the number in English words. # Constraints * Ensure that the method raises a `ValueError` if the `number` is negative or greater than `999,999`. * The solution should handle various edge cases such as `0`, `100`, `1000`, and `100000`. # Scenario/Context Consider a scenario where a cash register system needs to print the total amount in words on receipts for better readability and verification purposes. # Example **Example 1**: ```python >>> number_converter = IntegerToWords(123) >>> number_converter.convert() \'One Hundred Twenty-Three\' ``` **Example 2**: ```python >>> number_converter = IntegerToWords(1005) >>> number_converter.convert() \'One Thousand Five\' ``` **Example Edge Case**: ```python >>> number_converter = IntegerToWords(0) >>> number_converter.convert() \'Zero\' ``` # Approach Considerations * Use helper methods to break down the number into smaller components (ones, tens, hundreds, thousands). * Ensure optimal performance and readability of the code. * Utilize appropriate data structures to map numbers to their word representations. Submit your implementation as the `IntegerToWords` class with the `convert` method.","solution":"class IntegerToWords: def __init__(self, number: int): if number < 0 or number > 999999: raise ValueError(\\"Number must be between 0 and 999,999 inclusive.\\") self.number = number def convert(self) -> str: if self.number == 0: return \\"Zero\\" units = [\\"\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\"] teens = [\\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\"] tens = [\\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\"] thousands = [\\"\\", \\"Thousand\\"] def one(num): return units[num] def two_less_20(num): return teens[num - 10] def ten(num): return tens[num // 10] + (\'\' if num % 10 == 0 else \'-\' + units[num % 10]) def two(num): if not num: return \'\' elif num < 10: return one(num) elif num < 20: return two_less_20(num) else: return ten(num) def three(num): hundreds = num // 100 rest = num % 100 if hundreds and rest: return units[hundreds] + \' Hundred \' + two(rest) elif not hundreds and rest: return two(rest) elif hundreds and not rest: return units[hundreds] + \' Hundred\' num = self.number result = \'\' if num < 1000: result = three(num) else: result = three(num // 1000) + \' Thousand\' if num % 1000: result += \' \' + three(num % 1000) return result.strip()"},{"question":"# Problem Statement You are tasked with creating an efficient function to merge two sorted lists into a single sorted list. This will help in maintaining sorted datasets as part of a larger data processing pipeline. # Function Signature ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Input * `list1` and `list2`: Two lists of integers, sorted in ascending order. - Constraints: (0 leq text{len(list1)} leq 10^6) and (0 leq text{len(list2)} leq 10^6) # Output * A sorted list containing all the elements from `list1` and `list2`. # Requirements * The implementation should be efficient with a time complexity of O(n + m) where n and m are the lengths of `list1` and `list2`, respectively. * The resulting list should be sorted in ascending order. # Examples 1. `merge_sorted_lists([1, 3, 5], [2, 4, 6])` should return `[1, 2, 3, 4, 5, 6]`. 2. `merge_sorted_lists([1, 1, 1], [2, 2, 2])` should return `[1, 1, 1, 2, 2, 2]`. 3. `merge_sorted_lists([0, 2, 4], [-1, 3, 5])` should return `[-1, 0, 2, 3, 4, 5]`. 4. `merge_sorted_lists([ ], [-10, -5, 0])` should return `[-10, -5, 0]`. 5. `merge_sorted_lists([10, 20, 30], [])` should return `[10, 20, 30]`. # Edge Cases Consider the following edge cases: 1. Both lists are empty should return an empty list. 2. One list is empty, and the other is not, should return the non-empty list as is. 3. All elements in both lists are the same. 4. Lists with negative values and zero. # Constraint - You should not use any built-in sorting functions provided by Python.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into one sorted list. merged_list = [] i, j = 0, 0 # Use two pointers to merge lists while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Add remaining elements from list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # Add remaining elements from list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"**Data Stream Analyzer** # Context: You are working on a data stream processing system where large amounts of data are being received continuously. Your task is to develop a class that can analyze the data stream and provide useful analytics like average, median, mode, and standard deviation of the incoming numbers in real-time. # Objective: Write a new class `DataStreamAnalyzer` that processes an incoming stream of numbers and provides the following functionalities: 1. Calculate the running average of the numbers. 2. Calculate the median of the numbers. 3. Determine the mode of the numbers. 4. Compute the standard deviation of the numbers. # Constraints: - Must be efficient in terms of both time and space complexity. - Capable of handling up to 10^6 elements in the data stream. - The data stream includes both positive and negative integers (in the range of -10^9 to 10^9). # Specifications: 1. Class Name: `DataStreamAnalyzer` 2. Shall contain the methods: * `add_number(num: int) -> None`: Adds a number to the stream. * `get_average() -> float`: Returns the current average of the numbers. * `get_median() -> float`: Returns the current median of the numbers. * `get_mode() -> int`: Returns the current mode of the numbers. * `get_standard_deviation() -> float`: Returns the current standard deviation of the numbers. # Expected Input and Output Formats: - **Input formats**: * `add_number(num: int)`: An integer. * `get_average()`, `get_median()`, `get_mode()`, `get_standard_deviation()`: No input needed. - **Output formats**: * `get_average()`, `get_median()`, `get_standard_deviation()`: Returns a float. * `get_mode()`: Returns an integer. # Performance Requirements: - Ensure that methods `get_average`, `get_median`, `get_mode`, and `get_standard_deviation` can be called frequently without significant delays. - Ensure that the `add_number` method performs efficiently with a large volume of data. # Example Usage: ```python # Initialize the data stream analyzer analyzer = DataStreamAnalyzer() # Add numbers to the stream analyzer.add_number(10) analyzer.add_number(20) analyzer.add_number(10) analyzer.add_number(30) analyzer.add_number(40) # Retrieve analytics from the stream print(\\"Average:\\", analyzer.get_average()) # Should print the average of the numbers print(\\"Median:\\", analyzer.get_median()) # Should print the median of the numbers print(\\"Mode:\\", analyzer.get_mode()) # Should print the mode of the numbers print(\\"Standard Deviation:\\", analyzer.get_standard_deviation()) # Should print the standard deviation ``` # Note: This new question on data stream analytics aligns with the style, complexity, and scope of the previous question about multi-threaded chaos machine while introducing a fresh problem within the context of handling real-time data streams.","solution":"import bisect from collections import Counter from math import sqrt class DataStreamAnalyzer: def __init__(self): self.numbers = [] self.count = 0 self.sum = 0 self.sum_of_squares = 0 self.mode_counter = Counter() self.mode = None def add_number(self, num: int) -> None: bisect.insort(self.numbers, num) self.count += 1 self.sum += num self.sum_of_squares += num * num self.mode_counter[num] += 1 if self.mode is None or self.mode_counter[num] > self.mode_counter[self.mode]: self.mode = num def get_average(self) -> float: return self.sum / self.count if self.count > 0 else 0.0 def get_median(self) -> float: if self.count == 0: return 0.0 mid = self.count // 2 if self.count % 2 == 0: return (self.numbers[mid - 1] + self.numbers[mid]) / 2.0 else: return self.numbers[mid] def get_mode(self) -> int: return self.mode def get_standard_deviation(self) -> float: if self.count == 0: return 0.0 mean = self.get_average() variance = (self.sum_of_squares / self.count) - (mean * mean) return sqrt(variance)"},{"question":"**Normalize Grayscale Image** **Context**: In image processing, normalization is a common technique used to adjust the intensity values of an image. For grayscale images, normalization can enhance the contrast by scaling pixel values to a standard range. **Task**: Write a function `normalize_grayscale_image` that takes a 2D numpy array representing a grayscale image and normalizes its pixel values to the range [0, 1]. **Function Signature**: ```python def normalize_grayscale_image(image: np.ndarray) -> np.ndarray: pass ``` **Input**: * `image` (np.ndarray): A 2D numpy array of shape (H, W) where H is the height and W is the width of the grayscale image. The elements of the array represent pixel intensity values. **Output**: * `np.ndarray`: A 2D numpy array of the same shape as the input image, with pixel values normalized to the range [0, 1]. **Constraints**: * The input image array can contain any real number, including negative values. * The input image array may contain very large or very small numbers. **Example**: ```python >>> image = np.array([[150, 200, 50], [0, 100, 255], [30, 80, 180]]) >>> normalize_grayscale_image(image) array([[0.58823529, 0.78431373, 0.19607843], [0. , 0.39215686, 1. ], [0.11764706, 0.31372549, 0.70588235]]) ``` **Performance Requirements**: * The implementation should handle large images efficiently by leveraging numpy\'s vectorized operations. * The output should maintain the relative intensities of the original pixel values. **Edge Cases**: * The input image has all pixel values equal. * The input image contains only positive values. * The input image contains only negative values. * The input image contains zeros. * The input image contains very large or very small values. **Instructions**: * Implement the function `normalize_grayscale_image`. * Ensure your implementation handles edge cases. * You should avoid using explicit loops to maximize the performance benefits of numpy.","solution":"import numpy as np def normalize_grayscale_image(image: np.ndarray) -> np.ndarray: Normalizes the pixel values of a grayscale image to the range [0, 1]. Parameters: image (np.ndarray): A 2D numpy array representing the grayscale image. Returns: np.ndarray: A 2D numpy array with pixel values normalized to the range [0, 1]. min_val = np.min(image) max_val = np.max(image) if min_val == max_val: # All values in the image are the same return np.zeros_like(image) normalized_image = (image - min_val) / (max_val - min_val) return normalized_image"},{"question":"# Coding Challenge Context: You are tasked with implementing a string manipulation problem involving the longest substring of distinct characters. Objective: Write a function `longest_unique_substring(s: str) -> int` that takes one string input `s` and returns the length of the longest substring that contains all unique characters. Input: The input will be a single string `s` consisting of between ( 1 ) and ( 10^5 ) characters, which can include any printable ASCII characters. Output: The output should be a single integer representing the length of the longest substring with all unique characters. Constraints: - The function should handle edge cases (e.g., empty string or string with all identical characters). - The solution must be efficient and capable of processing up to ( 10^5 ) characters. Examples: ```python >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\" \\") 1 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"anviaj\\") 5 ``` Performance Requirement: Ensure that your solution efficiently computes the longest unique substring, operating within the acceptable time limit for the given constraints. Good luck!","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. char_index = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index: start = max(start, char_index[char] + 1) char_index[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Write a function `move_zeros(arr: List[int]) -> List[int]` that takes a list of integers and moves all the zeros to the end of the list while maintaining the relative order of the non-zero elements. # Input: * A list of integers ( arr ) with length ( 1 leq len(arr) leq 10^4 ). # Output: * A list of integers where all zeros have been moved to the end, maintaining the relative order of non-zero elements. # Function Signature: ```python def move_zeros(arr: List[int]) -> List[int]: pass ``` # Example: ```python >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([0, 0, 1]) [1, 0, 0] >>> move_zeros([4, 2, 4, 0, 0, 3, 0]) [4, 2, 4, 3, 0, 0, 0] ``` # Note: * The input list may contain positive and negative integers and zero. * Your implementation should aim to preserve the order of non-zero elements and minimize the number of operations.","solution":"from typing import List def move_zeros(arr: List[int]) -> List[int]: Move all zeros in the list to the end while maintaining the relative order of non-zero elements. non_zero_index = 0 # Position to place the next non-zero element for num in arr: if num != 0: arr[non_zero_index] = num non_zero_index += 1 for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"**Scenario**: You are developing a new feature for a delivery management system that tracks the locations of delivery trucks in real-time. Each truck sends its geographical coordinates (latitude and longitude) periodically. **Task**: Implement a class `TruckTracker` with the following methods: 1. `update_location(truck_id: str, latitude: float, longitude: float) -> None`: Update the current location of a truck identified by `truck_id`. 2. `get_location(truck_id: str) -> tuple`: Retrieve the current location (latitude, longitude) of the specified truck. 3. `get_distance_between(truck_id1: str, truck_id2: str) -> float`: Calculate and return the distance between two trucks identified by `truck_id1` and `truck_id2`. The distance should be calculated using the Haversine formula, which considers the Earth\'s curvature. * Expected input and output formats: * `update_location(\\"truck1\\", 51.5074, -0.1278)` -> None * `get_location(\\"truck1\\")` -> (latitude: float, longitude: float) * `get_distance_between(\\"truck1\\", \\"truck2\\")` -> float * Constraints: * The latitude and longitude values must be valid. Latitude ranges from -90 to 90, and longitude ranges from -180 to 180. * Raise a `ValueError` if an invalid `truck_id` is requested or if the distance calculation is attempted between non-existent truck IDs. Below is the starting code for the class: ```python import math class TruckTracker: def __init__(self): self.truck_locations = {} def update_location(self, truck_id: str, latitude: float, longitude: float) -> None: # Validate latitude and longitude. if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180): raise ValueError(\\"Invalid latitude or longitude values.\\") # Update the truck\'s location. self.truck_locations[truck_id] = (latitude, longitude) def get_location(self, truck_id: str) -> tuple: # Retrieve the current location of the truck. if truck_id not in self.truck_locations: raise ValueError(\\"Truck ID not found.\\") return self.truck_locations[truck_id] def get_distance_between(self, truck_id1: str, truck_id2: str) -> float: # Validate truck IDs. if truck_id1 not in self.truck_locations or truck_id2 not in self.truck_locations: raise ValueError(\\"One or both truck IDs not found.\\") # Haversine formula to calculate distance. def haversine(lat1, lon1, lat2, lon2): R = 6371 # Earth radius in kilometers phi1 = math.radians(lat1) phi2 = math.radians(lat2) delta_phi = math.radians(lat2 - lat1) delta_lambda = math.radians(lon2 - lon1) a = math.sin(delta_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) ** 2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) return R * c lat1, lon1 = self.truck_locations[truck_id1] lat2, lon2 = self.truck_locations[truck_id2] return haversine(lat1, lon1, lat2, lon2) ```","solution":"import math class TruckTracker: def __init__(self): self.truck_locations = {} def update_location(self, truck_id: str, latitude: float, longitude: float) -> None: Updates the location of the truck identified by `truck_id`. if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180): raise ValueError(\\"Invalid latitude or longitude values.\\") self.truck_locations[truck_id] = (latitude, longitude) def get_location(self, truck_id: str) -> tuple: Returns the current location (latitude, longitude) of the truck identified by `truck_id`. if truck_id not in self.truck_locations: raise ValueError(\\"Truck ID not found.\\") return self.truck_locations[truck_id] def get_distance_between(self, truck_id1: str, truck_id2: str) -> float: Calculates the distance between two trucks identified by `truck_id1` and `truck_id2` using the Haversine formula. if truck_id1 not in self.truck_locations or truck_id2 not in self.truck_locations: raise ValueError(\\"One or both truck IDs not found.\\") def haversine(lat1, lon1, lat2, lon2): R = 6371 # Earth radius in kilometers phi1 = math.radians(lat1) phi2 = math.radians(lat2) delta_phi = math.radians(lat2 - lat1) delta_lambda = math.radians(lon2 - lon1) a = math.sin(delta_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) ** 2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) return R * c lat1, lon1 = self.truck_locations[truck_id1] lat2, lon2 = self.truck_locations[truck_id2] return haversine(lat1, lon1, lat2, lon2)"},{"question":"# Task Write a function `add_strings` that takes two non-negative integers represented as strings and returns their sum, also as a string. # Input * Two strings `num1` and `num2` which contain non-negative integers. # Output * A string representing the sum of the input strings. # Constraints * The input strings will never be empty and will contain only digits. * Ensure the function can handle very large integers which might surpass standard integer limits. * Your function should not directly convert the strings to integer types for summing. # Example ```python >>> add_strings(\\"123\\", \\"456\\") \'579\' >>> add_strings(\\"0\\", \\"0\\") \'0\' >>> add_strings(\\"999999999999\\", \\"1\\") \'1000000000000\' >>> add_strings(\\"123456789\\", \\"987654321\\") \'1111111110\' >>> add_strings(\\"1\\", \\"999999999\\") \'1000000000\' ``` # Notes 1. You may assume that the input strings do not have any leading zeros except the case of the string \\"0\\". 2. Your implementation should simulate the addition process similar to how you would add numbers manually, digit by digit, from right to left, handling carry appropriately.","solution":"def add_strings(num1, num2): Add two non-negative integers represented as strings without directly converting them to integers. Args: - num1 (str): The first non-negative integer as a string. - num2 (str): The second non-negative integer as a string. Returns: - str: The sum of num1 and num2 as a string. # Initialize pointers for both numbers, starting from the end of each string i, j = len(num1) - 1, len(num2) - 1 carry = 0 result = [] # Loop until both pointers are exhausted and there is no carry left while i >= 0 or j >= 0 or carry: digit1 = int(num1[i]) if i >= 0 else 0 digit2 = int(num2[j]) if j >= 0 else 0 # Calculate current digit and the carry over for the next digit total = digit1 + digit2 + carry carry = total // 10 result.append(str(total % 10)) i -= 1 j -= 1 # Since we constructed the number from least significant to most significant digit, # reverse the result to get the final sum return \'\'.join(result[::-1])"},{"question":"Problem Statement You are tasked with developing an algorithm to validate and process payment card numbers. The solution should determine the type of card based on its number and ensure the number follows the proper format. The payment card numbers can be of three types: Visa, MasterCard, and American Express. The rules for validating and identifying these cards are as follows: 1. Visa: - The number must start with a `4`. - It must be exactly 16 digits long. 2. MasterCard: - The number must start with a `51`, `52`, `53`, `54`, or `55`. - It must be exactly 16 digits long. 3. American Express: - The number must start with a `34` or `37`. - It must be exactly 15 digits long. Your function will take a string representing a payment card number and return a string indicating the type of the card (\\"Visa\\", \\"MasterCard\\", \\"American Express\\") or \\"Invalid\\" if the card number does not match any of the criteria. # Function Signature ```python def validate_payment_card(card_number: str) -> str: Validates and identifies the type of the payment card. :param card_number: Input payment card number as a string. :return: A string indicating the type of card (\\"Visa\\", \\"MasterCard\\", \\"American Express\\") or \\"Invalid\\". ``` # Input * `card_number` (string): A string representing the payment card number to be validated. # Output * A string: - \\"Visa\\" if the card number is a valid Visa card. - \\"MasterCard\\" if the card number is a valid MasterCard. - \\"American Express\\" if the card number is a valid American Express. - \\"Invalid\\" if the card number is invalid based on the criteria. # Example ```python >>> validate_payment_card(\\"4111111111111111\\") \\"Visa\\" >>> validate_payment_card(\\"5105105105105100\\") \\"MasterCard\\" >>> validate_payment_card(\\"371449635398431\\") \\"American Express\\" >>> validate_payment_card(\\"1234567812345678\\") \\"Invalid\\" >>> validate_payment_card(\\"4111111111111\\") \\"Invalid\\" ``` # Constraints - The input card number will be a non-empty string. - The solution should not use any external libraries other than those provided by Python. - The solution should have efficient runtime complexity. # Additional Notes - Pay particular attention to handling edge cases such as numbers that are close in pattern to valid card numbers but do not meet all the criteria. - Ensure your solution properly handles any leading or trailing spaces around the card number. - Your program should strictly follow the format rules for each card type without exception.","solution":"def validate_payment_card(card_number: str) -> str: Validates and identifies the type of the payment card. :param card_number: Input payment card number as a string. :return: A string indicating the type of card (\\"Visa\\", \\"MasterCard\\", \\"American Express\\") or \\"Invalid\\". # Remove any leading or trailing spaces card_number = card_number.strip() if len(card_number) == 16: if card_number[0] == \'4\': return \\"Visa\\" elif card_number[:2] in [\'51\', \'52\', \'53\', \'54\', \'55\']: return \\"MasterCard\\" elif len(card_number) == 15: if card_number[:2] in [\'34\', \'37\']: return \\"American Express\\" return \\"Invalid\\""},{"question":"**Context**: You are designing a lightweight file system within an embedded system with limited memory. One of the essential features is to efficiently manage files and directories while keeping track of directory sizes for quick lookups. **Task**: Implement a `FileSystem` class that supports basic file and directory operations. Your implementation should include functions to `create_file`, `delete_file`, `create_directory`, `delete_directory`, and `list_contents`. # Function Signature ```python class FileSystem: def __init__(self): pass def create_file(self, path: str, size: int) -> bool: pass def delete_file(self, path: str) -> bool: pass def create_directory(self, path: str) -> bool: pass def delete_directory(self, path: str) -> bool: pass def list_contents(self, path: str) -> list: pass ``` # Requirements 1. **Constructor**: Initialize the file system. 2. **Create File Function**: Create a file at the given path with the specified size. Return `True` if the file is created successfully, `False` if the file already exists or the parent directory does not exist. 3. **Delete File Function**: Delete the file at the given path. Return `True` if the file is deleted successfully, `False` if the file does not exist. 4. **Create Directory Function**: Create a directory at the given path. Return `True` if the directory is created successfully, `False` if the directory already exists or the parent directory does not exist. 5. **Delete Directory Function**: Delete the directory at the given path. Return `True` if the directory is deleted successfully, `False` if the directory does not exist or is not empty. 6. **List Contents Function**: Return a list of files and directories in the specified path. The list should contain just the names of the files and directories and should be sorted alphabetically. # Constraints - Paths are represented as strings with directory names separated by `/`. - Sizes of files are positive integers. - Assume the root directory `/` always exists. # Example ```python # Create a file system fs = FileSystem() # Create directories assert fs.create_directory(\\"/project\\") is True assert fs.create_directory(\\"/project/src\\") is True # Create files assert fs.create_file(\\"/project/readme.txt\\", 100) is True assert fs.create_file(\\"/project/src/main.py\\", 200) is True # List contents assert fs.list_contents(\\"/project\\") == [\\"readme.txt\\", \\"src\\"] assert fs.list_contents(\\"/project/src\\") == [\\"main.py\\"] # Delete file assert fs.delete_file(\\"/project/readme.txt\\") is True assert fs.list_contents(\\"/project\\") == [\\"src\\"] # Delete directory assert fs.delete_directory(\\"/project/src\\") is False # Directory not empty assert fs.delete_file(\\"/project/src/main.py\\") is True assert fs.delete_directory(\\"/project/src\\") is True ``` **Note**: Ensure your implementation efficiently handles file and directory structures with constraints on memory usage.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} def _resolve(self, path: str, create_missing=False): parts = path.strip(\'/\').split(\'/\') current = self.fs for part in parts: if part not in current: if create_missing: current[part] = {} else: return None current = current[part] return current def create_file(self, path: str, size: int) -> bool: dir_path, file_name = path.rsplit(\'/\', 1) directory = self._resolve(dir_path) if directory is not None and file_name not in directory: directory[file_name] = size return True return False def delete_file(self, path: str) -> bool: dir_path, file_name = path.rsplit(\'/\', 1) directory = self._resolve(dir_path) if directory is not None and file_name in directory: del directory[file_name] return True return False def create_directory(self, path: str) -> bool: parts = path.strip(\'/\').split(\'/\') current = self.fs for part in parts: if part not in current: current[part] = {} current = current[part] return True def delete_directory(self, path: str) -> bool: dir_path, dir_name = path.rsplit(\'/\', 1) directory = self._resolve(dir_path) if directory is not None and dir_name in directory and isinstance(directory[dir_name], dict) and not directory[dir_name]: del directory[dir_name] return True return False def list_contents(self, path: str) -> list: directory = self._resolve(path) if directory is not None: return sorted(directory.keys()) return []"},{"question":"# Problem Statement In a grid-based game, a player navigates from the top-left corner to the bottom-right corner of an `m x n` grid. The player can only move down or right at any point in time. Each cell in the grid contains a certain number of coins, and the player collects these coins upon entering the cell. You need to determine the maximum number of coins the player can collect when reaching the bottom-right corner. Function Signature ```python def max_coins(grid: List[List[int]]) -> int: ``` # Input - `grid`: A 2D array (list of lists) of integers, where `grid[i][j]` represents the coins in cell (i, j). # Output - An integer representing the maximum number of coins that can be collected. # Constraints - `m` and `n` are both integers such that `1 <= m, n <= 100`. - Each cell in `grid` contains a non-negative integer (coins). # Example ```python # Example 1: grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] assert max_coins(grid) == 12 # Example 2: grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_coins(grid) == 29 # Example 3: grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert max_coins(grid) == 1 # Example 4: grid = [ [1] ] assert max_coins(grid) == 1 ``` # Notes 1. Use dynamic programming to efficiently compute the maximum number of coins collectible. 2. Initialize the DP table with dimensions matching the grid and iteratively calculate the maximum coins collectible at each cell. 3. Ensure to handle edge cases such as: - Grids with only one cell. - Large grids with maximum dimensions. - Grids with all zeros (except the starting cell).","solution":"from typing import List def max_coins(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"# Coding Assessment Question You\'re developing a routing algorithm for delivery drones. The drones can travel between various waypoints in a city, represented by the nodes in a graph. Each drone needs to find the shortest path from its starting point to its destination. The city layout is modeled as an undirected graph, where the nodes represent waypoints and the edges represent the pathways between them, with weights indicating the travel time between each pair of waypoints. Implement a function `shortest_path_time(start: int, end: int, graph: dict) -> int` that calculates the shortest travel time between two waypoints, using Dijkstra\'s algorithm. The graph is provided as an adjacency list, where each key represents a node, and each value is a list of tuples, with each tuple consisting of a neighboring node and the travel time to that neighbor. **Function Signature**: ```python def shortest_path_time(start: int, end: int, graph: dict) -> int: ... ``` Input Constraints: - `1 <= len(graph) <= 1000` - Each node is a distinct integer. - Each edge has a positive integer weight. Expected Output: - Returns an integer indicating the shortest travel time from the start to the end waypoint. - If there is no path between the `start` and `end` waypoints, return -1. Example: ```python graph = { 1: [(2, 4), (3, 2)], 2: [(1, 4), (3, 5), (4, 10)], 3: [(1, 2), (2, 5), (4, 3)], 4: [(2, 10), (3, 3)] } assert shortest_path_time(1, 4, graph) == 5 assert shortest_path_time(1, 5, graph) == -1 ``` **Note**: The function is expected to handle all edge cases and must execute within reasonable time limits for the given input constraints.","solution":"import heapq def shortest_path_time(start: int, end: int, graph: dict) -> int: Find the shortest travel time from start to end waypoint using Dijkstra\'s algorithm. If no path exists, return -1. # Priority queue to hold the nodes to explore along with their current distance pq = [(0, start)] # Dictionary to store the shortest path to each node shortest_paths = {node: float(\'inf\') for node in graph} shortest_paths[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the end node, return the current distance if current_node == end: return current_distance if current_distance > shortest_paths[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If we exit the loop without having found the end node, return -1 return -1 if shortest_paths[end] == float(\'inf\') else shortest_paths[end]"},{"question":"# Question: Implement a Basic Calculator You are tasked with implementing a basic calculator that can evaluate a simple mathematical string expression containing non-negative integers, and the operators: `+`, `-`, `*`, and `/`. The expression may also contain open and close parentheses `( ` and `)`, which must be interpreted with the usual precedence rules. Function Signature ```python def calculate(expression: str) -> int: ``` Input * `expression` : A string containing the mathematical expression to be evaluated. The expression may include spaces between operators and operands. Output * An integer, representing the result of evaluating the given expression. Constraints * The length of `expression` will not exceed 1000 characters. * The `expression` will be a valid mathematical expression as per the definition. * No error handling for invalid expressions is required. * Integer division should truncate towards zero. Examples ```python assert calculate(\\"3+2*2\\") == 7 assert calculate(\\" 3/2 \\") == 1 assert calculate(\\" 3+5 / 2 \\") == 5 assert calculate(\\"10 + 2 * 6\\") == 22 assert calculate(\\"100 * 2 + 12\\") == 212 assert calculate(\\"100 * ( 2 + 12 )\\") == 1400 assert calculate(\\"100 * ( 2 + 12 ) / 14\\") == 100 ``` **Note**: You need to implement the function `calculate` by parsing the string and evaluating it according to the standard arithmetic precedence rules. Make sure to consider handling spaces within the expression and ensure proper handling of integer division.","solution":"def calculate(expression: str) -> int: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': # Integer division that truncates towards zero values.append(int(left / right)) def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"# Context You\'re developing a small search engine that indexes a collection of documents and allows users to search for keywords within them. Your task is to implement the core functions for building the index and performing the search. # Requirements 1. Implement a function to build an inverted index from a collection of documents. 2. Implement a search function to retrieve the document IDs that contain the given keyword. 3. Ensure efficient search and indexing operations. # Input/Output 1. **Function:** `create_index(documents)` - **Arguments:** - `documents`: List of tuples `[(doc_id, content), ...]`, where `doc_id` is a unique identifier for the document and `content` is a string of text. - **Returns:** An inverted index as a dictionary where keys are words and values are lists of document IDs containing those words. 2. **Function:** `search(index, keyword)` - **Arguments:** - `index`: The inverted index dictionary created from `create_index`. - `keyword`: The keyword to search for. - **Returns:** A list of document IDs that contain the keyword. # Constraints - Document IDs are unique integers. - Content consists of lowercase alphabets and spaces only. - Assume no punctuation or special characters. - Keyword searches are case-sensitive. # Example ```python documents = [ (1, \\"the quick brown fox jumps over the lazy dog\\"), (2, \\"never jump over the lazy dog quickly\\"), (3, \\"the quick brown fox is quick and smart\\") ] index = create_index(documents) print(index) # Output could be: {\'the\': [1, 2, 3], \'quick\': [1, 3], \'brown\': [1, 3], \'fox\': [1, 3], \'jumps\': [1], \'over\': [1, 2], \'lazy\': [1, 2], \'dog\': [1, 2], \'never\': [2], \'jump\': [2], \'quickly\': [2], \'is\': [3], \'and\': [3], \'smart\': [3]} result = search(index, \'quick\') print(result) # Output: [1, 3] result = search(index, \'lazy\') print(result) # Output: [1, 2] ``` # Criteria - Correctness of the inverted index. - Efficiency of indexing and searching algorithms. - Accurate keyword search results based on the created index.","solution":"def create_index(documents): Creates an inverted index from a list of documents. Arguments: documents -- List of tuples (doc_id, content), where doc_id is a unique identifier for the document and content is a string of text. Returns: An inverted index as a dictionary where keys are words and values are lists of document IDs containing those words. index = {} for doc_id, content in documents: words = content.split() for word in words: if word in index: if doc_id not in index[word]: index[word].append(doc_id) else: index[word] = [doc_id] return index def search(index, keyword): Searches for a keyword in the inverted index and returns a list of document IDs that contain the keyword. Arguments: index -- The inverted index dictionary. keyword -- The keyword to search for. Returns: A list of document IDs that contain the keyword. return index.get(keyword, [])"},{"question":"# Coding Assessment Question Context In competitive programming, efficient sorting algorithms are paramount for optimizing performance, especially when dealing with large datasets. One such algorithm is the merge sort, a divide-and-conquer algorithm notable for its efficient handling of large arrays by breaking them down into smaller subarrays, sorting these, and then merging them back together. Problem Statement Your task is to implement the merge sort algorithm in Python. Given an unsorted array of integers, your function should return a sorted array. Ensure your implementation is efficient and adheres to the principles of the merge sort. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers that needs to be sorted. Output - A sorted list of integers (List[int]) in ascending order. Constraints - The input list can have up to (10^6) elements. - Each integer in the list is within the range (-10^9) to (10^9). Examples ```python >>> merge_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> merge_sort([3, 0, -1, 8, 7]) [-1, 0, 3, 7, 8] >>> merge_sort([1]) [1] >>> merge_sort([5, 5, 5, 5]) [5, 5, 5, 5] >>> merge_sort([]) [] ``` Additional Notes - Implement necessary error handling to ensure robustness. - Think of the merge sort implementation as recursive, where the array is continually divided until subarrays are reduced to single elements, which are naturally sorted. - Ensure your function efficiently handles large inputs and utilizes memory effectively. Good luck!","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] left_index = 0 right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array"},{"question":"# Modify an Immutable String **Problem Statement**: In many programming languages, strings are immutable, making certain operations like modification and inplace updates non-trivial. In this task, you will implement a custom string data structure that supports efficient modification operations. **Requirements**: Implement a class `ModifiableString` that should meet the following interface: 1. `__init__(self, initial_string: str) -> None`: Initializes the object with the given string. 2. `__len__(self) -> int`: Returns the current length of the string. 3. `__repr__(self) -> str`: Returns the string representation of the object in the format `ModifiableString(\\"string\\")`. 4. `modify(self, index: int, character: str) -> None`: Modifies the character at the specified index. Raises an `IndexError` if the index is out of bounds. 5. `substring(self, start: int, end: int) -> str`: Returns the substring from `start` to `end` (end exclusive) indices. Raises `IndexError` if the indices are out of bounds or invalid. **Input/Output Format**: - `modify(index, character)` will take an integer `index` and a string `character`. - `substring(start, end)` will take two integers, `start` and `end`, and return the resulting substring. **Constraints**: - The input string\'s length will be within a reasonable limit for Python\'s execution. - Substring indices are such that `0 <= start < end <= len(string)`. # Example Usage ```python mod_str = ModifiableString(\\"hello\\") print(mod_str) # Output: ModifiableString(\\"hello\\") mod_str.modify(1, \'a\') print(mod_str) # Output: ModifiableString(\\"hallo\\") print(mod_str.substring(1, 4)) # Output: \\"all\\" mod_str.modify(0, \'j\') print(mod_str) # Output: ModifiableString(\\"jallo\\") print(len(mod_str)) # Output: 5 ``` **Edge Cases to Consider**: - The string starts empty. - Modifying at boundaries (e.g., the first and last indexes). - Requests for substrings at the boundary edges. - Handling invalid or out-of-bounds indices for both `modify` and `substring`. **Solution Context**: This problem aims to test your understanding of string manipulation, error handling for out-of-bound indexes, and how to maintain state in an object-oriented manner effectively. Implementing this will reinforce knowledge of foundational data manipulation and encapsulation principles in Python.","solution":"class ModifiableString: def __init__(self, initial_string: str) -> None: self._string = list(initial_string) def __len__(self) -> int: return len(self._string) def __repr__(self) -> str: return f\'ModifiableString(\\"{\\"\\".join(self._string)}\\")\' def modify(self, index: int, character: str) -> None: if not (0 <= index < len(self._string)): raise IndexError(\\"Index out of bounds\\") if len(character) != 1: raise ValueError(\\"Character must be a single character string\\") self._string[index] = character def substring(self, start: int, end: int) -> str: if not (0 <= start < end <= len(self._string)): raise IndexError(\\"Invalid start or end index\\") return \'\'.join(self._string[start:end])"},{"question":"# Problem Statement You work as an engineer in a company that manufactures computer storage systems. Your team is tasked with implementing a file compression system that efficiently compresses a string representing a file\'s content. The compression algorithm should identify sequences of repeated characters in the string and represent them with a single character followed by the count of its repetitions. Your task is to implement a function `compress_string(data: str) -> str` that performs the string compression described above. # Input and Output Format Function: `compress_string(data: str) -> str` * **Input**: * `data` (str): The original string representing the file\'s content. * **Output**: * Returns a compressed string where sequences of repeated characters are represented with a single character followed by the count of repetitions. If the length of the compressed string is not smaller than the original string, return the original string. # Requirements 1. The function should compress only sequences of repeated characters. 2. If the length of the compressed string is not smaller than the original string, return the original string. 3. The function should handle both uppercase and lowercase characters. Compression should be case-sensitive. 4. The function should handle an empty string input and return an empty string as output. # Examples ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcd\\") == \\"abcd\\" assert compress_string(\\"abccCaaa\\") == \\"abccCaaa\\" assert compress_string(\\"\\") == \\"\\" assert compress_string(\\"a\\") == \\"a\\" ``` # Constraints * The input string can only contain printable ASCII characters [\' \', \'~\']. * The maximum length of the input string is 10000 characters. You are expected to implement this function in Python, ensuring correctness and efficiency.","solution":"def compress_string(data: str) -> str: if not data: return \\"\\" compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: compressed.append(data[i - 1]) compressed.append(str(count)) count = 1 compressed.append(data[-1]) compressed.append(str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(data) else data"},{"question":"# Coding Challenge: Given a list of strings representing file paths, create a function that organizes these paths into a hierarchical directory structure. Each path is made up of directory names separated by the \'/\' character. Your task is to construct a nested dictionary where each key is a directory name, and the value is another dictionary representing the contents of that directory. # Objective: Write a function `construct_directory_tree` that: 1. Takes a list of strings representing file paths. 2. Returns a nested dictionary where each directory name is a key, and its contents are values (either empty dictionaries or further nested dictionaries). Expected Input and Output: * **Input**: * A list of strings, each representing a file path. * **Output**: * A nested dictionary representing the directory structure. Performance Requirements: * The function should efficiently handle a large number of file paths. * The solution should not perform redundant operations and should optimize traversing and storing the file paths. Constraints and Considerations: * Consider edge cases such as an empty list of paths or paths with varying lengths. * Ensure paths with common directories are merged correctly in the hierarchy. * The list will only contain valid file paths with no empty segments between slashes. # Example: ```python def construct_directory_tree(paths: list) -> dict: pass print(construct_directory_tree([ \\"folder1/subfolder1/file1\\", \\"folder1/subfolder2/file2\\", \\"folder2/file3\\", \\"folder2/subfolder3/file4\\" ])) # Expected output: # { # \\"folder1\\": { # \\"subfolder1\\": { # \\"file1\\": {} # }, # \\"subfolder2\\": { # \\"file2\\": {} # } # }, # \\"folder2\\": { # \\"file3\\": {}, # \\"subfolder3\\": { # \\"file4\\": {} # } # } # } print(construct_directory_tree([])) # Expected output: {} print(construct_directory_tree([\\"singlelevel\\"])) # Expected output: {\\"singlelevel\\": {}} ``` # Note: * When printing the nested dictionary, the inner empty dictionaries (`{}`) represent files at the end of the paths. * You are required to provide a detailed explanation of your implementation choices and any assumptions made.","solution":"def construct_directory_tree(paths): Constructs a nested dictionary representing directory structure from a list of file paths. tree = {} for path in paths: parts = path.split(\'/\') current_level = tree # Traverse the path, creating nested dictionaries along the way for part in parts: if part not in current_level: current_level[part] = {} current_level = current_level[part] return tree"},{"question":"# Question: Scheduling Tasks with Dependencies **Scenario**: You\'re part of a team developing a task scheduling system for a project management application. You need to handle tasks that have dependencies, meaning some tasks need to be completed before others can start. **Your Task:** Implement a class with methods to handle the following operations: 1. **add_task(task_id)**: Add a new task with the given task_id (an integer). 2. **add_dependency(task_id, dependency_id)**: Specify that `dependency_id` must be completed before `task_id` can begin. 3. **can_schedule_all()**: Return a boolean indicating whether all tasks can be completed (i.e., there are no cyclic dependencies). 4. **task_order()**: Return a list of task_ids representing a valid order in which to complete all tasks. If no valid order exists, return an empty list. **Input and Output Format:** - Task IDs are integers. - `add_task(task_id)` has no return value. - `add_dependency(task_id, dependency_id)` has no return value. - `can_schedule_all()` returns a boolean. - `task_order()` returns a list of integers. **Constraints:** - Task IDs and dependency IDs are unique non-negative integers. - Assume no more than 10^5 tasks can be added. - Each task can have multiple dependencies. **Example:** ```python scheduler = TaskScheduler() scheduler.add_task(1) scheduler.add_task(2) scheduler.add_task(3) scheduler.add_dependency(2, 1) scheduler.add_dependency(3, 2) print(scheduler.can_schedule_all()) # Output: True print(scheduler.task_order()) # Output: [1, 2, 3] scheduler.add_dependency(1, 3) print(scheduler.can_schedule_all()) # Output: False print(scheduler.task_order()) # Output: [] ``` **Requirements:** - Implement the necessary class and methods to support the above functionality. - Ensure the methods are efficient and can handle large inputs and complex dependencies.","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): self.tasks = set() self.dependencies = defaultdict(list) self.indegree = defaultdict(int) def add_task(self, task_id): self.tasks.add(task_id) if task_id not in self.indegree: self.indegree[task_id] = 0 def add_dependency(self, task_id, dependency_id): self.add_task(task_id) self.add_task(dependency_id) self.dependencies[dependency_id].append(task_id) self.indegree[task_id] += 1 def can_schedule_all(self): order = self.task_order() return len(order) == len(self.tasks) def task_order(self): queue = deque() for task in self.tasks: if self.indegree[task] == 0: queue.append(task) order = [] while queue: task = queue.popleft() order.append(task) for dependent in self.dependencies[task]: self.indegree[dependent] -= 1 if self.indegree[dependent] == 0: queue.append(dependent) if len(order) == len(self.tasks): return order else: return []"},{"question":"# Problem Statement You are given a string containing digits from \'0\' to \'9\' and characters from \'a\' to \'z\'. Your task is to reorder the string in such a way that all the letters come before all the numbers while maintaining their relative order. Thus, the output string should have all characters sorted into alphabetical characters first and numerical digits last, but within their respective groups, the original order should remain intact. # Function Signature ```python def reorder_string(s: str) -> str: ``` # Input * `s` (string): The input string containing digits and lower-case letters only (1 â‰¤ len(s) â‰¤ 10^5). # Output * A string with letters first in original order followed by digits in original order. # Examples ```python print(reorder_string(\\"a1b2c3\\")) # Output: \\"abc123\\" print(reorder_string(\\"1a2b3c\\")) # Output: \\"abc123\\" print(reorder_string(\\"abc123\\")) # Output: \\"abc123\\" ``` # Explanation 1. For the first example, the function should return \\"abc123\\" as we collect all letters \\"abc\\" and then digits \\"123\\" maintaining the original order within groups. 2. For the second example, the function should return \\"abc123\\" as extracting the letters \\"abc\\" and digits \\"123\\" maintains order. 3. For the third example, the function already satisfies the requirement and thus remains unchanged. # Constraints * The input string will only contain digits and lower-case letters. * No characters outside \'0\'-\'9\' and \'a\'-\'z\' will be present in the string. # Example Code ```python def reorder_string(s: str) -> str: letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return \'\'.join(letters + digits) ```","solution":"def reorder_string(s: str) -> str: Reorders the input string such that all letters come before all numbers, maintaining their relative order. Parameters: s (str): Input string containing only digits and lower-case letters. Returns: str: Reordered string with all letters first and digits last, both in their original order. letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return \'\'.join(letters + digits)"},{"question":"# Problem Statement Create a function `evaluate_postfix` that evaluates a given postfix (Reverse Polish Notation) expression and returns its result. Ensure your implementation can handle basic arithmetic operations and takes into account the correct order of operations. # Requirements 1. **Function Signature**: ```python def evaluate_postfix(expression: str) -> float: ``` 2. **Inputs**: * `expression` (str): A string representing a postfix expression where operands are separated by spaces. 3. **Outputs**: * Returns a floating-point number which is the evaluated result of the postfix expression. 4. **Constraints**: * The input expression is guaranteed to be a valid postfix expression. * Operands will be non-negative floating-point numbers or integers. * Only the operators +, -, *, / are supported. # Example Usage ```python >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2.0 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> evaluate_postfix(\\"2.5 3.5 +\\") 6.0 ``` # Additional Notes - During evaluation, handle the operations with the appropriate order: operators are applied as they appear from left to right. - Pay special attention to division to ensure output correctness (e.g., dividing by zero should be handled gracefully). - Consider the performance and efficiency of your solution, especially with large expressions.","solution":"def evaluate_postfix(expression: str) -> float: Evaluates a postfix (Reverse Polish Notation) expression and returns the result. Parameters: expression (str): A string representing a postfix expression where operands are separated by spaces. Returns: float: The evaluated result of the postfix expression. stack = [] for token in expression.split(): if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) else: stack.append(float(token)) return stack[0]"},{"question":"# Problem Statement You are tasked with developing a method for identifying repeating patterns in a sequence of integers. Specifically, you need to determine if there is a contiguous subarray within a given integer array that, when repeated consecutively, forms the entire array. Implement a function `is_repeating_pattern` that checks whether the input list of integers can be constructed by repeating any of its contiguous subarrays. # Function Signature ```python def is_repeating_pattern(arr: list[int]) -> bool: pass ``` # Input - `arr`: a list of integers representing the sequence to be analyzed. The length of the list will be between 1 and (10^5). # Output - Returns a boolean value, `True` if the array can be constructed by repeating a contiguous subarray, otherwise `False`. # Constraints - The length of the array, `n`, will be between 1 and (10^5). - The integer values in the array will be between (-10^9) and (10^9). # Example ```python >>> is_repeating_pattern([1, 2, 1, 2, 1, 2]) True # The subarray [1, 2] is repeated to form the entire array >>> is_repeating_pattern([3, 4, 3, 4, 3]) False # No repeating subarray can form the entire array >>> is_repeating_pattern([5, 5, 5, 5]) True # The subarray [5] is repeated to form the entire array >>> is_repeating_pattern([1]) False # Single element array cannot form a repeated pattern ``` # Notes - The function should handle edge cases where parts of the sequence partially match a repeating pattern but do not fulfill the entire sequence. - Optimize for performance, ensuring the solution can handle the upper limits of the constraints efficiently.","solution":"def is_repeating_pattern(arr): Check if the array can be constructed by repeating a contiguous subarray. n = len(arr) if n == 1: return False # Create a string representation of the array. arr_str = \'\'.join(map(str, arr)) # Optionally, check substrings\' multiplicity up to half the length of the array for i in range(1, n // 2 + 1): if n % i == 0: # Get the subarray subarray = arr[:i] # Repeat the subarray to match the length of the original array if subarray * (n // i) == arr: return True return False"},{"question":"Scenario Due to the rapid growth of a communication network, you need to ensure that all connections are efficiently established without redundancy. You are tasked with determining the minimum cost required to connect all nodes in the network using a minimum spanning tree algorithm. # Problem Statement Write a function `minimum_spanning_tree_cost(n: int, edges: List[Tuple[int, int, int]]) -> int` that returns the minimum cost to connect all nodes in the network. Use Kruskal\'s algorithm to find the minimum spanning tree. # Function Signature ```python def minimum_spanning_tree_cost(n: int, edges: List[Tuple[int, int, int]]) -> int: ``` # Input * `n` (int): The number of nodes in the network, numbered from 0 to n-1. * `edges` (List[Tuple[int, int, int]]): A list of tuples where each tuple (u, v, w) represents an edge connecting nodes `u` and `v` with weight `w`. # Output * An integer representing the minimum cost to connect all nodes. If it\'s not possible to connect all nodes, return -1. # Constraints 1. `1 <= n <= 1000` 2. `0 <= len(edges) <= 10^4` 3. `0 <= u, v < n` 4. `1 <= w <= 10^6` # Examples ```python assert minimum_spanning_tree_cost(4, [(0, 1, 1), (1, 2, 2), (2, 3, 4), (0, 3, 3)]) == 6 assert minimum_spanning_tree_cost(3, [(0, 1, 1), (1, 2, 2), (2, 0, 3)]) == 3 assert minimum_spanning_tree_cost(4, [(0, 1, 1), (2, 3, 2)]) == -1 assert minimum_spanning_tree_cost(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (0, 4, 5)]) == 10 ``` # Note * Use Kruskal\'s algorithm to find the minimum spanning tree. * If there are fewer than `n-1` edges, it\'s impossible to connect all nodes, so the function should return -1. * The function should handle edge cases where the input graph is disconnected. # Performance Requirements * Your solution should complete within a reasonable time for the maximum input constraints.","solution":"from typing import List, Tuple def minimum_spanning_tree_cost(n: int, edges: List[Tuple[int, int, int]]) -> int: # A function to find the root of a node in the Union-Find structure def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # A function to unite two subsets in the Union-Find structure def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Kruskal\'s algorithm requires sorting the edges by their weights edges.sort(key=lambda x: x[2]) # Initialize Union-Find structure parent = [i for i in range(n)] rank = [0] * n mst_cost = 0 edges_used = 0 # Iterate through all sorted edges and apply union-find for u, v, w in edges: if find(parent, u) != find(parent, v): mst_cost += w union(parent, rank, u, v) edges_used += 1 # Early exit if we already have n-1 edges in the MST if edges_used == n - 1: break # If we didn\'t use n-1 edges, it means we can\'t connect all nodes if edges_used != n - 1: return -1 return mst_cost"},{"question":"# Scenario You are currently involved in developing a file management system. As part of the functionality, the system needs to be able to compress and decompress data efficiently using the Run-Length Encoding (RLE) algorithm. # Task Write a function to compress a string using Run-Length Encoding and another function to decompress it back to the original string. # Function 1: `compress_rle` Input - A string `data` consisting of only uppercase letters (A-Z). Output - A compressed string using Run-Length Encoding. # Function 2: `decompress_rle` Input - A string `compressed_data` that is the result of a Run-Length Encoding compression. Output - The original string before compression. # Examples ```python assert compress_rle(\\"AAAABBBCCDAA\\") == \\"4A3B2C1D2A\\" assert compress_rle(\\"ABCDEFG\\") == \\"1A1B1C1D1E1F1G\\" assert decompress_rle(\\"4A3B2C1D2A\\") == \\"AAAABBBCCDAA\\" assert decompress_rle(\\"1A1B1C1D1E1F1G\\") == \\"ABCDEFG\\" ``` # Constraints - The input strings for both functions will not exceed a length of 1000 characters. - Ensure the functions handle edge cases such as single character inputs, repeated sequences, and alternating characters efficiently. # Notes - Directly referencing existing code or solutions may lead to immediate disqualification. - Focus on clarity, correctness, and performance in your implementation.","solution":"def compress_rle(data): Compresses the given string using Run-Length Encoding. if not data: return \\"\\" compressed = [] current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{count}{current_char}\\") current_char = char count = 1 compressed.append(f\\"{count}{current_char}\\") return \'\'.join(compressed) def decompress_rle(compressed_data): Decompresses the given Run-Length Encoded string back to its original form. if not compressed_data: return \\"\\" decompressed = [] count = 0 for char in compressed_data: if char.isdigit(): count = count * 10 + int(char) else: decompressed.append(char * count) count = 0 return \'\'.join(decompressed)"},{"question":"# Coding Question **Context**: Your company is developing a library that handles various mathematical computations. Part of this library needs to provide a function that calculates the factorial of large numbers reliably and efficiently. Your current implementation uses a simple recursive method, which encounters limitations with large numbers due to stack overflow issues, making it unsuitable for practical usage. **Task**: Create an enhanced version of the factorial calculation that uses an iterative approach and handles very large numbers using Python\'s built-in arbitrary-precision integer type. **Function Specification**: ```python def large_factorial(n: int) -> int: Calculate the factorial of a given number using an iterative approach to handle large values. Parameters: - n (int): The number to compute the factorial for. Must be a non-negative integer. Returns: - int: The factorial of the number \'n\'. Raises: - ValueError: If \'n\' is not a non-negative integer. pass ``` **Constraints**: * Ensure that the function can handle very large numbers without running into recursion limits. * Validate the input to make sure it is a non-negative integer. * Optimize for performance, considering the use of efficient data structures if necessary. **Example Usage**: ```python print(large_factorial(5)) # Output: 120 print(large_factorial(20)) # Output: 2432902008176640000 ``` **Expected Output**: ```python # The function should return: # 120 for input 5 # 2432902008176640000 for input 20 ``` # Additional Details * You should focus on iterative implementation. * Handle invalid inputs gracefully and raise appropriate exceptions. * Consider edge cases like 0! which is 1.","solution":"def large_factorial(n: int) -> int: Calculate the factorial of a given number using an iterative approach to handle large values. Parameters: - n (int): The number to compute the factorial for. Must be a non-negative integer. Returns: - int: The factorial of the number \'n\'. Raises: - ValueError: If \'n\' is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"# Problem Description You are tasked with implementing a function to validate and potentially correct an input Sudoku puzzle. The goal is to identify any violations of the Sudoku rules and attempt to correct them by filling in the missing numbers (`0` in the grid) according to standard Sudoku rules. # Function Signature ```python def validate_and_solve_sudoku(grid: list[list[int]]) -> list[list[int]]: Validate the input Sudoku puzzle and attempt to correct it by solving any errors. Parameters: grid (list[list[int]]): 2D list representing a 9x9 Sudoku grid, where empty cells are represented by 0. Returns: list[list[int]]: Valid and completed Sudoku grid if solvable, otherwise raises ValueError. Raises: ValueError: If the Sudoku puzzle cannot be solved or if there are irreparable errors. ``` # Input * A `9 x 9` grid represented as a list of lists, where each sub-list is a row of the grid. * Each element in the grid is either an integer from `1` to `9` or `0` to represent an empty cell. # Output * A valid and completed `9 x 9` Sudoku grid. If the puzzle has unsolvable errors, raise a `ValueError`. # Constraints * The input is guaranteed to have the dimensions `9 x 9`. * There may be multiple or no solutions, handle accordingly by attempting the first solution found. # Requirements * Ensure the given grid adheres to Sudoku rules both initially and after attempting to solve: numbers `1-9` must appear exactly once in each row, column, and `3x3` sub-grid. * Proper error handling and validation are crucial before attempting to solve the puzzle. # Example ```python # Example 1 initial_grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] print(validate_and_solve_sudoku(initial_grid)) # Expected Output: # [ # [5, 3, 4, 6, 7, 8, 9, 1, 2], # [6, 7, 2, 1, 9, 5, 3, 4, 8], # [1, 9, 8, 3, 4, 2, 5, 6, 7], # [8, 5, 9, 7, 6, 1, 4, 2, 3], # [4, 2, 6, 8, 5, 3, 7, 9, 1], # [7, 1, 3, 9, 2, 4, 8, 5, 6], # [9, 6, 1, 5, 3, 7, 2, 8, 4], # [2, 8, 7, 4, 1, 9, 6, 3, 5], # [3, 4, 5, 2, 8, 6, 1, 7, 9] # ] # Example 2 invalid_grid = [ [5, 5, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] print(validate_and_solve_sudoku(invalid_grid)) # Expected Output: ValueError \'Sudoku puzzle cannot be solved or contains irreparable errors\' ``` # Instructions 1. Implement the function `validate_and_solve_sudoku` to properly validate and solve Sudoku puzzles. 2. Handle invalid puzzles by raising appropriate exceptions. 3. Ensure that the Sudoku puzzle is valid and correctly solved if possible.","solution":"def validate_and_solve_sudoku(grid): def is_valid(board, row, col, num): # Check the row for x in range(9): if board[row][x] == num: return False # Check the column for x in range(9): if board[x][col] == num: return False # Check the 3x3 sub-grid startRow = row - row % 3 startCol = col - col % 3 for i in range(3): for j in range(3): if board[i + startRow][j + startCol] == num: return False return True def solve_sudoku(board): l = [0, 0] if not find_empty_location(board, l): return True row, col = l for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False def find_empty_location(board, l): for row in range(9): for col in range(9): if board[row][col] == 0: l[0], l[1] = row, col return True return False def validate_initial_grid(board): for i in range(9): for j in range(9): num = board[i][j] if num != 0: board[i][j] = 0 if not is_valid(board, i, j, num): return False board[i][j] = num return True if not validate_initial_grid(grid): raise ValueError(\\"Sudoku puzzle contains irreparable errors\\") if solve_sudoku(grid): return grid else: raise ValueError(\\"Sudoku puzzle cannot be solved\\")"},{"question":"# Graph Traversal Exercise Understanding graph traversal algorithms is crucial for solving many problems in computer science, such as network routing, game AI, and social network analysis. Your task is to implement depth-first search (DFS) and breadth-first search (BFS) for a given undirected graph. # Problem Statement Create a class `GraphTraversal` that includes methods to perform DFS and BFS on a given undirected graph. # Class Definition ```python class GraphTraversal: def __init__(self, graph: Dict[int, List[int]]): self.graph = graph def dfs(self, start_node: int) -> List[int]: pass def bfs(self, start_node: int) -> List[int]: pass ``` # Detailed Requirements 1. **DFS Method**: * **Input**: An integer `start_node` representing the starting node for the traversal. * **Output**: Return a list of integers representing the nodes in the order they are visited. 2. **BFS Method**: * **Input**: An integer `start_node` representing the starting node for the traversal. * **Output**: Return a list of integers representing the nodes in the order they are visited. # Constraints - The graph is represented as an adjacency list, where the keys are node identifiers (integers) and the values are lists of adjacent nodes. - The graph may contain up to `10^5` nodes and `10^6` edges. - Nodes are numbered from `0` to `n-1`, where `n` is the total number of nodes. - The `start_node` is guaranteed to be a valid node in the graph. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2] } traversal = GraphTraversal(graph) dfs_order = traversal.dfs(0) # Expected Output: [0, 1, 3, 4, 2] print(dfs_order) bfs_order = traversal.bfs(0) # Expected Output: [0, 1, 2, 3, 4] print(bfs_order) ``` # Edge Cases 1. **Graph with Single Node**: Ensure the traversal methods can handle a graph with a single node correctly. 2. **Isolated Nodes**: Ensure the methods can handle isolated nodes, which have no edges. 3. **Graph with Up to Maximum Constraints**: Validate the performance and correctness for a graph at the maximum limit of nodes and edges. 4. **Disconnected Subgraphs**: Ensure methods properly handle when the graph has disconnected subgraphs. # Performance Requirements Your solution should be efficient with DFS and BFS implementations having a time complexity of O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph.","solution":"from collections import deque from typing import List, Dict class GraphTraversal: def __init__(self, graph: Dict[int, List[int]]): self.graph = graph def dfs(self, start_node: int) -> List[int]: visited = [] stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.append(node) # Add adjacent nodes to the stack in reverse order to maintain order stack.extend(reversed(self.graph[node])) return visited def bfs(self, start_node: int) -> List[int]: visited = [] queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.append(node) queue.extend(self.graph[node]) return visited"},{"question":"# Question: Implement Depth-First Search with Recursion You are tasked with implementing a recursive Depth-First Search (DFS) to traverse a given undirected graph and determine if there is a path between two vertices. Problem Statement Implement a function `dfs_recursive(graph: Dict[int, List[int]], start: int, target: int) -> bool` that returns `True` if there is a path from the `start` vertex to the `target` vertex, otherwise returns `False`. Input * `graph`: A dictionary where keys are vertex IDs (integers) and values are lists of neighboring vertex IDs. * `start`: An integer representing the starting vertex. * `target`: An integer representing the target vertex. Output A boolean value indicating whether there is a path from the `start` vertex to the `target` vertex. Constraints * The graph is undirected and connected. * The input vertices\' ids are 0-based integers. * The start and target vertices are guaranteed to be within the graph. Example ```python graph = { 0: [1, 3], 1: [0, 2, 3, 4], 2: [1, 4], 3: [0, 1, 4], 4: [1, 2, 3] } # Call DFS Recursive path_exists = dfs_recursive(graph, 0, 4) # Expected output # True: There is a path from vertex 0 to vertex 4 print(path_exists) ``` Notes 1. Utilize a helper function to facilitate the recursion, potentially tracking visited nodes. 2. Optimize to avoid revisiting nodes using a set to track visited vertices. 3. Ensure function efficiency with respect to graph traversal. Implement the `dfs_recursive` function and test it with different graph configurations to ensure correctness and efficiency. ```python def dfs_recursive(graph: Dict[int, List[int]], start: int, target: int) -> bool: def dfs(v: int, visited: Set[int]) -> bool: if v == target: return True visited.add(v) for neighbor in graph[v]: if neighbor not in visited and dfs(neighbor, visited): return True return False return dfs(start, set()) ``` Test the function with various input scenarios to validate its accuracy and performance.","solution":"from typing import Dict, List, Set def dfs_recursive(graph: Dict[int, List[int]], start: int, target: int) -> bool: def dfs(v: int, visited: Set[int]) -> bool: if v == target: return True visited.add(v) for neighbor in graph[v]: if neighbor not in visited and dfs(neighbor, visited): return True return False return dfs(start, set())"},{"question":"# Problem Statement In a multi-threaded environment, it is crucial for functions to operate without interrupting or conflicting with each other, especially when sharing resources. Implementing a thread-safe counter is a common challenge that can arise in such environments. In this problem, you are required to implement a thread-safe counter that can handle simultaneous increments by multiple threads. # Requirements 1. **Function Signature**: ```python import threading class ThreadSafeCounter: def __init__(self): self.counter = 0 self.lock = threading.Lock() def increment(self): with self.lock: self.counter += 1 def get_counter(self) -> int: with self.lock: return self.counter ``` - **Class `ThreadSafeCounter`**: - **Methods**: * `__init__`: Initializes the counter to 0 and sets up a threading lock. * `increment`: Safely increments the counter by 1, ensuring thread-safety. * `get_counter`: Returns the current value of the counter, ensuring thread-safety. # Details 1. **Thread Safety**: Ensure that the counter can be incremented by multiple threads concurrently without leading to race conditions. 2. **Locking Mechanism**: Use `threading.Lock` to manage access to the shared counter. # Example ```python from threading import Thread import time def test_thread_safe_counter(): counter = ThreadSafeCounter() def worker(): for _ in range(1000): counter.increment() threads = [Thread(target=worker) for _ in range(10)] for thread in threads: thread.start() for thread in threads: thread.join() assert counter.get_counter() == 10000 if __name__ == \\"__main__\\": test_thread_safe_counter() ``` # Constraints and Performance Requirements 1. Assume that the number of threads can be up to 100. 2. Assume each thread can perform up to 10000 increments. 3. Ensure that your implementation eliminates any potential race conditions. 4. Optimize the implementation for performance in a multi-threaded environment. Provide a solution that is efficient and ensures consistency and safety in the shared counter\'s value.","solution":"import threading class ThreadSafeCounter: def __init__(self): self.counter = 0 self.lock = threading.Lock() def increment(self): with self.lock: self.counter += 1 def get_counter(self) -> int: with self.lock: return self.counter"},{"question":"# Flight Itinerary Planner Problem Statement: You are required to implement a function that takes a list of direct flight legs between various destinations and returns a complete ordered itinerary starting from a given starting point. Each flight leg is a tuple containing the starting airport code and the destination airport code. Your task is to reconstruct the itinerary in the correct order. Function Signature: ```python def flight_itinerary(flights: list[tuple[str, str]], start: str) -> list[str]: pass ``` Input: - `flights` (list[tuple[str, str]]): A list of direct flight legs represented as tuples, where the first element is the starting airport and the second element is the destination airport. - `start` (str): The starting airport code. Output: - A list of airport codes representing the full itinerary in the correct order, starting from the given starting point. Constraints: - The provided flights form a valid and complete itinerary that ends where the next leg begins, without branching or disjoint segments. - If the flights list is empty, return a list containing only the starting airport. - All airport codes are unique and represented as 3-letter uppercase strings. Performance Requirements: - Optimize the function to ensure it constructs the itinerary in a linear time complexity. Examples: ```python assert flight_itinerary([(\\"JFK\\", \\"ATL\\"), (\\"ATL\\", \\"SFO\\"), (\\"SFO\\", \\"LAX\\")], \\"JFK\\") == [\\"JFK\\", \\"ATL\\", \\"SFO\\", \\"LAX\\"] assert flight_itinerary([(\\"ORD\\", \\"DFW\\"), (\\"DFW\\", \\"LAX\\"), (\\"LAX\\", \\"SFO\\")], \\"ORD\\") == [\\"ORD\\", \\"DFW\\", \\"LAX\\", \\"SFO\\"] assert flight_itinerary([(\\"BOS\\", \\"MIA\\")], \\"BOS\\") == [\\"BOS\\", \\"MIA\\"] assert flight_itinerary([], \\"SEA\\") == [\\"SEA\\"] ``` Edge Cases: - Handle cases where there is only one flight leg. - Handle the case where the flights list is empty. # Instructions: 1. Implement the function `flight_itinerary` following the given signature. 2. Ensure that all edge cases are handled appropriately. 3. Perform necessary validations as per the constraints. 4. Maintain the output format as specified.","solution":"def flight_itinerary(flights, start): Returns the complete ordered itinerary starting from the given start airport. Parameters: flights (list[tuple[str, str]]): A list of direct flight legs represented as tuples. start (str): The starting airport code. Returns: list[str]: The full itinerary in the correct order. if not flights: return [start] # Build adjacency list from flights flight_map = {start: None} for dep, arr in flights: flight_map[dep] = arr itinerary = [start] while True: next_destination = flight_map.get(start) if next_destination is None: break itinerary.append(next_destination) start = next_destination return itinerary"},{"question":"# Coding Assessment Question: Write a function to simulate the movement of a robotic vacuum cleaner in a room represented by a 2D grid. The vacuum starts at an initial position and follows a list of instructions to move in the cardinal directions (\\"N\\" for North, \\"S\\" for South, \\"E\\" for East, \\"W\\" for West). Ensure that the vacuum does not move out of the bounds of the grid. Function Signature ```python def simulate_vacuum(m: int, n: int, start: Tuple[int, int], instructions: List[str]) -> Tuple[int, int]: pass ``` Input and Output - **Input**: - `m`: The number of rows in the grid (1 â‰¤ m â‰¤ 10^5) - `n`: The number of columns in the grid (1 â‰¤ n â‰¤ 10^5) - `start`: A tuple representing the starting coordinates (row, column) of the vacuum cleaner (0 â‰¤ start[0] < m, 0 â‰¤ start[1] < n) - `instructions`: A list of instructions for the vacuum cleaner to follow (1 â‰¤ len(instructions) â‰¤ 10^5, each instruction being one of [\\"N\\", \\"S\\", \\"E\\", \\"W\\"]) - **Output**: - Returns a tuple representing the final position (row, column) of the vacuum cleaner after executing all instructions. Constraints - The vacuum cleaner must not move out of the boundaries of the grid. If an instruction causes the vacuum to move out of bounds, ignore that instruction and continue with the next one. - The function should operate efficiently within the given constraints. Example ```python >>> simulate_vacuum(5, 5, (0, 0), [\\"E\\", \\"E\\", \\"S\\", \\"S\\", \\"W\\", \\"N\\"]) (1, 1) ``` Here are the detailed steps: 1. Initialize the vacuum cleaner at the starting position. 2. Execute each instruction in order, ensuring the vacuum cleaner does not move out of the grid. 3. Return the final position of the vacuum cleaner.","solution":"from typing import List, Tuple def simulate_vacuum(m: int, n: int, start: Tuple[int, int], instructions: List[str]) -> Tuple[int, int]: Simulates the movement of a robotic vacuum cleaner in a room represented by a 2D grid. # Position of the vacuum cleaner row, col = start # Dictionary to define movement for each direction movement = { \\"N\\": (-1, 0), \\"S\\": (1, 0), \\"E\\": (0, 1), \\"W\\": (0, -1) } # Execute each instruction for instruction in instructions: if instruction in movement: delta_row, delta_col = movement[instruction] new_row = row + delta_row new_col = col + delta_col # Check if the new position is within bounds if 0 <= new_row < m and 0 <= new_col < n: row = new_row col = new_col return (row, col)"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing a function to generate all possible permutations of a given list of numbers. The function should ensure that the generated permutations are returned in sorted order. Task Implement a function `sorted_permutations` that generates all possible permutations of a given list of numbers and returns them sorted in lexicographical order. Function Signature ```python def sorted_permutations(arr: list) -> list: Generate all permutations of the input list in sorted order. :param arr: List of integers to generate permutations. :return: A list of permutations sorted in lexicographical order. ``` Input * `arr`: A list of integers. Length of the list is between 0 and 9. Output * A list of all permutations sorted in lexicographical order. Each permutation should be a list of integers. Constraints * The length of the input list can be up to 9. This means the total number of permutations can be factorial of 9 (362880). * The input list can contain duplicate elements. Duplicates should be taken into account while generating permutations. Examples ```python assert sorted_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert sorted_permutations([1, 1, 2]) == [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] assert sorted_permutations([3, 2, 1]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert sorted_permutations([1]) == [ [1] ] assert sorted_permutations([]) == [ [] ] ``` Notes * The order of permutations should be lexicographical, which means they are sorted as per dictionary order. * Utilize efficient algorithms or libraries to generate permutations, such as itertools.permutations. Ensure there are no duplicate permutations in the output list if the input list contains duplicates. * Ensure that your code handles edge cases, such as empty lists and single-element lists.","solution":"from itertools import permutations def sorted_permutations(arr: list) -> list: Generate all permutations of the input list in sorted order. :param arr: List of integers to generate permutations. :return: A list of permutations sorted in lexicographical order. # Generate all permutations using itertools.permutations perm_set = set(permutations(arr)) # Convert permutations to list of lists and sort them sorted_perm = sorted([list(p) for p in perm_set]) return sorted_perm"},{"question":"# Coding Assessment Question Scenario You are developing a file management system, and one of the features you need to implement is the ability to rename files by appending a numeric suffix to their names. If a file with the same name already exists, the suffix should increase incrementally until a unique name is found. The suffix should start at `1` and increment by `1` for each duplicate. Task Implement a function `rename_file` that renames a file by appending a suffix if a file with the same name exists in the provided list of filenames. The suffix should be in the format `_1`, `_2`, and so on. If the provided filename does not exist in the list, return it unchanged. Input - A list of strings `filenames` representing existing filenames. - A string `new_filename` representing the new filename to be added. Output - A string representing the unique filename by appending the necessary suffix. Constraints - `filenames` can have a length between `0` and `1000`. - Each filename and `new_filename` can have a length between `1` and `100`. - Filenames consist of printable ASCII characters except for whitespace characters. Examples ```python >>> rename_file([\\"file.txt\\", \\"file_1.txt\\"], \\"file.txt\\") \'file_2.txt\' >>> rename_file([\\"document.doc\\", \\"document_1.doc\\"], \\"document.doc\\") \'document_2.doc\' >>> rename_file([\\"image.png\\", \\"image_2.png\\"], \\"image.png\\") \'image_1.png\' >>> rename_file([], \\"new_file.txt\\") \'new_file.txt\' >>> rename_file([\\"data.csv\\"], \\"data.csv\\") \'data_1.csv\' ``` Implementation ```python def rename_file(filenames: list, new_filename: str) -> str: Appends a numeric suffix to the new_filename if it exists in filenames. base, ext = new_filename.rsplit(\'.\', 1) counter = 1 unique_filename = new_filename while unique_filename in filenames: unique_filename = f\\"{base}_{counter}.{ext}\\" counter += 1 return unique_filename # Sample test cases to validate your function assert rename_file([\\"file.txt\\", \\"file_1.txt\\"], \\"file.txt\\") == \\"file_2.txt\\" assert rename_file([\\"document.doc\\", \\"document_1.doc\\"], \\"document.doc\\") == \\"document_2.doc\\" assert rename_file([\\"image.png\\", \\"image_2.png\\"], \\"image.png\\") == \\"image_1.png\\" assert rename_file([], \\"new_file.txt\\") == \\"new_file.txt\\" assert rename_file([\\"data.csv\\"], \\"data.csv\\") == \\"data_1.csv\\" print(\\"All tests passed!\\") ```","solution":"def rename_file(filenames, new_filename): Appends a numeric suffix to the new_filename if it exists in filenames. if new_filename not in filenames: return new_filename base, ext = new_filename.rsplit(\'.\', 1) counter = 1 unique_filename = f\\"{base}_{counter}.{ext}\\" while unique_filename in filenames: counter += 1 unique_filename = f\\"{base}_{counter}.{ext}\\" return unique_filename"},{"question":"# Array Rotation You are given an array of integers `nums` and an integer `k`. Implement the missing method `rotate` that rotates the array to the right by `k` steps. # Explanation: To rotate the array to the right by `k` steps means to shift the elements such that the last `k` elements of the array appear at the beginning and the others follow after them. # Function Signature: ```python def rotate(nums: list[int], k: int) -> None: ... ``` # Expected Inputs and Outputs: * **Input**: * `nums`: A list of integers. * `k`: An integer representing the number of steps to rotate. * **Output**: * None (The list `nums` should be modified in-place). # Example: ```python # Initial Array nums = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate(nums, k) # After Rotation # nums should be [5, 6, 7, 1, 2, 3, 4] assert nums == [5, 6, 7, 1, 2, 3, 4] ``` # Constraints: 1. The length of the array `nums` will be between 1 and 100000. 2. `k` will be a non-negative integer and may be any integer value (handle cases where `k` is larger than the length of the array). # Testing: Your solution will be tested with the following scenarios: 1. Rotating an array where `k` is larger than the length of the array. 2. Rotating an array where `k` is zero. 3. Rotating an array with a length of one. 4. Rotating a large array. # Notes: Handle edge cases such as when `k` is zero or when `k` is greater than the length of the array by using the modulo operation to minimize unnecessary rotations. Ensure that your solution runs efficiently for large arrays.","solution":"def rotate(nums: list[int], k: int) -> None: Rotates the array to the right by k steps. Args: nums (list of int): The list of integers to rotate. k (int): The number of steps to rotate the array to the right. Returns: None n = len(nums) k = k % n # To handle cases where k is larger than the array length nums[:] = nums[-k:] + nums[:-k]"},{"question":"# Scenario: You are working on a feature for a social media platform that handles large volumes of user activity and engagement. To optimize user interactions, the platform collects and processes various types of user activities such as likes, comments, shares, and views. A common task is to analyze these activities to provide insights and recommendations. One key aspect is efficiently managing and querying this activity data. # Task: Given a dataset/array representing user activities with each element indicating the type of activity (like, comment, share, or view), implement a data structure (Segment Tree) that supports the following operations efficiently: 1. **Total Count Query**: Count the total number of any activity type in a given subarray segment. 2. **Update Activity**: Update the type of activity at a specific index in the array. 3. **Range Sum Query**: Compute the sum of activity indices in a given range of activity types within a specific subarray segment. # Implementation Requirements: 1. **Function Definitions**: - `build_segment_tree(arr: list[int]) -> Node`: Builds and returns the root of the Segment Tree. - `total_count(node: Node, activity_type: int, start: int, end: int) -> int`: Returns the total count of a specific activity type in the interval `[start, end]`. - `update_activity(node: Node, index: int, new_activity: int) -> None`: Updates the activity type at the specified `index` with `new_activity`. - `range_sum(node: Node, activity_types: list[int], start: int, end: int) -> int`: Returns the sum of indices of the specified `activity_types` within the interval `[start, end]`. 2. **Input**: - A static dataset (array) representing user activities. - Parameters for the functions include the array, segment indices, activity types, and necessary query parameters. 3. **Output**: - Return values based on specified function requirements, such as counts, sums, or confirmation of updates. 4. **Constraints**: - Activity types are represented by integers (e.g., 1 for likes, 2 for comments, 3 for shares, 4 for views). - The array contains activities represented by these integers. - Index ranges and values may be assumed valid and within the bounds of the array\'s constraints. # Example: ```python activities = [1, 2, 1, 3, 4, 2, 1, 3, 4, 1, 2, 3, 1, 2, 4, 1, 3, 4, 2, 1] root = build_segment_tree(activities) print(total_count(root, 1, 0, 19)) # Output: 7 print(total_count(root, 3, 5, 15)) # Output: 4 update_activity(root, 4, 1) print(total_count(root, 1, 0, 19)) # Output: 8 print(range_sum(root, [1, 2], 0, 5)) # Output: 8 (0+1+2+5) ``` Implement the above functions carefully considering edge cases and performance constraints.","solution":"class SegmentTreeNode: def __init__(self, start, end): self.start = start self.end = end self.count = {1: 0, 2: 0, 3: 0, 4: 0} self.total_sum = 0 self.left = None self.right = None def build_segment_tree(arr): def build(start, end): if start > end: return None node = SegmentTreeNode(start, end) if start == end: node.count[arr[start]] = 1 node.total_sum = start return node mid = (start + end) // 2 node.left = build(start, mid) node.right = build(mid + 1, end) node.count = {key: (node.left.count.get(key, 0) if node.left else 0) + (node.right.count.get(key, 0) if node.right else 0) for key in node.count} node.total_sum = (node.left.total_sum if node.left else 0) + (node.right.total_sum if node.right else 0) return node return build(0, len(arr) - 1) def total_count(node, activity_type, start, end): if not node or start > node.end or end < node.start: return 0 if start <= node.start and node.end <= end: return node.count.get(activity_type, 0) mid = (node.start + node.end) // 2 return total_count(node.left, activity_type, start, end) + total_count(node.right, activity_type, start, end) def update_activity(node, index, new_activity, original_activity): if not node or index < node.start or index > node.end: return if node.start == node.end: if original_activity != 0: node.count[original_activity] -= 1 node.count[new_activity] += 1 return if node.left and node.left.start <= index <= node.left.end: update_activity(node.left, index, new_activity, original_activity) if node.right and node.right.start <= index <= node.right.end: update_activity(node.right, index, new_activity, original_activity) node.count = {key: (node.left.count.get(key, 0) if node.left else 0) + (node.right.count.get(key, 0) if node.right else 0) for key in node.count} def range_sum(node, activity_types, start, end): if not node or start > node.end or end < node.start: return 0 if start <= node.start and node.end <= end: return sum(node.count.get(key, 0) for key in activity_types) return range_sum(node.left, activity_types, start, end) + range_sum(node.right, activity_types, start, end)"},{"question":"# Coding Question Context You are working on an e-commerce platform and need to implement a feature that manages the inventory of the products. The system should track the stock levels, allowing for addition and removal of products, and it should be able to handle concurrent updates efficiently. Task Write a class `InventoryManager` that provides functionality to manage the product inventory. The class should be designed to handle concurrent operations safely. Class Signature ```python class InventoryManager: def __init__(self) -> None: pass def add_product(self, product_id: int, quantity: int) -> None: pass def remove_product(self, product_id: int, quantity: int) -> None: pass def get_stock(self, product_id: int) -> int: pass ``` Requirements 1. **Inputs**: * For `add_product` and `remove_product` methods: * `product_id` (int): The ID of the product to be added or removed. * `quantity` (int): The number of units to add or remove. * For `get_stock` method: * `product_id` (int): The ID of the product whose stock level is being queried. 2. **Output**: * For `get_stock` method, returns the current stock level (int) of the given product. * For other methods, no output is required. 3. **Constraints**: * Initialize the stock level of a new product to 0. * Ensure thread-safe operations to handle concurrent updates. * Implement proper error handling (e.g., removing more products than are in stock). Example: ```python if __name__ == \\"__main__\\": inventory = InventoryManager() inventory.add_product(product_id=1, quantity=10) inventory.remove_product(product_id=1, quantity=2) stock_level = inventory.get_stock(product_id=1) print(stock_level) # Output: 8 ``` Notes: * Consider using threading or thread-safe data structures to handle concurrent updates. * Write clean and readable code with appropriate comments. * Employ suitable error handling and logging where necessary.","solution":"import threading class InventoryManager: def __init__(self) -> None: # Dictionary to store the stock levels of products with thread lock for concurrency management self.inventory = {} self.lock = threading.Lock() def add_product(self, product_id: int, quantity: int) -> None: with self.lock: if product_id in self.inventory: self.inventory[product_id] += quantity else: self.inventory[product_id] = quantity def remove_product(self, product_id: int, quantity: int) -> None: with self.lock: if product_id in self.inventory: if self.inventory[product_id] >= quantity: self.inventory[product_id] -= quantity else: raise ValueError(\\"Not enough stock to remove the requested quantity\\") else: raise ValueError(\\"Product does not exist in inventory\\") def get_stock(self, product_id: int) -> int: with self.lock: return self.inventory.get(product_id, 0)"},{"question":"# Problem Context In a matrix of size m x n, a cell (i, j) can be traversed if either of the following conditions are met: 1. It is the starting cell (0, 0). 2. There is an adjacent cell (i-1, j) with value 1. 3. There is an adjacent cell (i, j-1) with value 1. Given a matrix with 0s and 1s, you need to determine if it is possible to reach the bottom-right cell (m-1, n-1) starting from the top-left cell (0, 0). # Task Write a function `can_reach_end(matrix: List[List[int]]) -> bool` to determine if there is a path from the top-left cell to the bottom-right cell based on the given rules. # Function Signature ```python def can_reach_end(matrix: List[List[int]]) -> bool: ``` # Input - A 2D list `matrix` of size m x n composed of integers 0 and 1. # Output - A boolean value, `True` if a path exists from (0, 0) to (m-1, n-1); otherwise, `False`. # Constraints - The matrix will have at least one cell and a maximum of 1000 cells (i.e., 1 â‰¤ m*n â‰¤ 1000). - The values in the matrix will be either 0s or 1s. - You can only move to the right or down. # Example ```python matrix1 = [ [1, 0, 1], [1, 1, 0], [0, 1, 1] ] assert can_reach_end(matrix1) == True matrix2 = [ [1, 0], [0, 1] ] assert can_reach_end(matrix2) == False matrix3 = [ [1, 1, 0], [0, 1, 1], [1, 0, 1] ] assert can_reach_end(matrix3) == False ``` # Hints - Use Depth First Search (DFS) or Breadth First Search (BFS) to explore the traversable path. - Track visited cells to avoid redundant checks and infinite loops. - Make sure to handle edge cases where the start or end cell is not traversable.","solution":"from typing import List def can_reach_end(matrix: List[List[int]]) -> bool: if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) if matrix[0][0] == 0 or matrix[m-1][n-1] == 0: return False # BFS to find the path from collections import deque queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(1, 0), (0, 1)] # down, right while queue: i, j = queue.popleft() if i == m - 1 and j == n - 1: return True for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] == 1 and (ni, nj) not in visited: queue.append((ni, nj)) visited.add((ni, nj)) return False"},{"question":"# Scenario Design and implement a system for dynamically managing an event calendar. Each event has a unique identifier (title), a start time, and a duration. The system should allow adding events, removing events, and querying for the event happening at a given time. # Task Description Develop an `EventCalendar` class that supports the following functionalities: 1. Add a new event. 2. Remove an event. 3. Get the event occurring at a specific time. 4. Retrieve all events within a specified time range. # Input and Output Formats `EventCalendar` class should have the following methods: - `add_event(title: str, start_time: int, duration: int)`: Adds a new event with the given title, start time, and duration. - `remove_event(title: str)`: Removes the event with the specified title. - `get_event_at(time: int) -> str`: Returns the title of the event happening at the given time. If no event is happening at that time, return \\"No event\\". - `get_events_in_range(start_time: int, end_time: int) -> List[str]`: Returns a list of titles of all events that overlap with the specified time range [start_time, end_time). # Constraints - Event titles are unique. - Start time and duration are non-negative integers. - Time is represented as an integer (e.g., minute of the day). - The number of events (`n`) will not exceed (10^5). # Example ```python calendar = EventCalendar() calendar.add_event(\\"Meeting\\", 10, 30) calendar.add_event(\\"Lunch\\", 50, 60) calendar.add_event(\\"Workout\\", 120, 60) assert calendar.get_event_at(15) == \\"Meeting\\" assert calendar.get_event_at(100) == \\"No event\\" assert calendar.get_events_in_range(0, 60) == [\\"Meeting\\", \\"Lunch\\"] calendar.remove_event(\\"Meeting\\") assert calendar.get_event_at(15) == \\"No event\\" ``` # Requirements Ensure that your implementation efficiently handles adding, removing, and searching for events, even under the maximum input sizes. Handle any potential edge cases appropriately, such as overlapping event times.","solution":"from typing import List class EventCalendar: def __init__(self): self.events = {} def add_event(self, title: str, start_time: int, duration: int): if title in self.events: raise ValueError(\\"Event with the same title already exists.\\") self.events[title] = (start_time, start_time + duration) def remove_event(self, title: str): if title in self.events: del self.events[title] def get_event_at(self, time: int) -> str: for title, (start, end) in self.events.items(): if start <= time < end: return title return \\"No event\\" def get_events_in_range(self, start_time: int, end_time: int) -> List[str]: result = [] for title, (start, end) in self.events.items(): if start < end_time and end > start_time: result.append(title) return result"},{"question":"# Problem Statement You are developing a software that involves manipulating and managing lists of numbers. One of the required functionalities is to rotate these lists. More precisely, given a list of integers, you need to rotate the list elements to the right by a specified number of positions. # Function Specifications Function: `rotate_list(nums, k)` - **Input**: - A list of integers, `nums`. - An integer, `k`, representing the number of positions to rotate the list. - **Output**: A list of integers rotated to the right by `k` positions. - **Constraints**: - The input list can be empty. - The integer `k` can be zero or negative. - Rotating by a value greater than the length of the list should be handled gracefully. # Examples Example 1: ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], -3) [4, 5, 1, 2, 3] >>> rotate_list([], 3) [] >>> rotate_list([1, 2, 3], 0) [1, 2, 3] >>> rotate_list([1, 2, 3], 4) [3, 1, 2] ``` # Detailed Instructions 1. Implement the `rotate_list` function: - If the input list is empty, return an empty list. - Normalize the rotation steps `k` such that it falls within the length of the list, catering to both positive and negative values. - Modify the input list to rotate its elements to the right by the specified number of positions. - Return the rotated list. # Additional Notes - Ensure that your implementation is efficient and handles edge cases such as empty lists and rotation by zero. - Consider creating any helper functions if necessary to keep the main function clean and easy to understand. - Test your function thoroughly to ensure it works as expected for various inputs.","solution":"def rotate_list(nums, k): Rotates the list to the right by k steps. :param nums: List of integers. :param k: Number of positions to rotate the list. :return: Rotated list of integers. if not nums: return [] n = len(nums) k = k % n # Normalize k to ensure it falls within the bounds of the list length. return nums[-k:] + nums[:-k]"},{"question":"# Code Breaking Puzzle Context: You are working on a classic puzzle involving encoded messages. Your task is to decode a message that has been encoded using a Caesar Cipher. A Caesar Cipher shifts each letter in the message by a fixed number of positions (N) down the alphabet (wrap around the end of the alphabet if necessary). The challenge is to write an efficient function that takes an encoded message and the shift value, decodes it, and returns the original message. Task: Write a Python function named `decode_caesar_cipher` that decodes an encoded string using the given shift value. The function should handle both uppercase and lowercase letters while leaving non-alphabetic characters unchanged. * **Input**: - a string `encoded_message` containing the encoded message. - an integer `shift` representing the number of positions by which letters are shifted in the encoded message. * **Output**: A new string containing the decoded message. Constraints: 1. The input string length will not exceed (10^5) characters. 2. The shift value will be between 0 and 25. Example: ```python def decode_caesar_cipher(encoded_message: str, shift: int) -> str: # Your implementation goes here # Example usage: print(decode_caesar_cipher(\\"Khoor Zruog!\\", 3)) # Expected output: \'Hello World!\' print(decode_caesar_cipher(\\"Lipps Asvph!\\", 4)) # Expected output: \'Hello World!\' ``` Ensure your implementation is efficient and can handle the specified constraints. The function should decode the message correctly given different shift values.","solution":"def decode_caesar_cipher(encoded_message: str, shift: int) -> str: Decodes an encoded string using the given shift value. Handles both uppercase and lowercase letters while leaving non-alphabetic characters unchanged. decoded_message = [] for char in encoded_message: if \'a\' <= char <= \'z\': decoded_char = chr((ord(char) - ord(\'a\') - shift) % 26 + ord(\'a\')) elif \'A\' <= char <= \'Z\': decoded_char = chr((ord(char) - ord(\'A\') - shift) % 26 + ord(\'A\')) else: decoded_char = char decoded_message.append(decoded_char) return \'\'.join(decoded_message)"},{"question":"# Analyzing Stock Market Portfolio Scenario You are developing a tool for analyzing stock market portfolios. The tool needs to provide insights into the performance of a given portfolio over a specified period. You need to implement a series of functions to analyze and compute different aspects of the portfolio. The three main aspects are: 1. Total Portfolio Value 2. Percentage Change over Time 3. Annualized Return Each of these metrics needs to be calculated using specific stock market formulas. Input and Output Requirements You need to implement the following functions: 1. **`total_value(prices: list, shares: list) -> float`**: * **Input**: List of current prices per share (positive floats) for each stock and list of corresponding number of shares (positive integers). * **Output**: Rounded total portfolio value. 2. **`percentage_change(initial_value: float, final_value: float) -> float`**: * **Input**: Initial portfolio value (positive float) and final portfolio value (positive float). * **Output**: Rounded percentage change. 3. **`annualized_return(initial_value: float, final_value: float, years: float) -> float`**: * **Input**: Initial portfolio value (positive float), final portfolio value (positive float), and number of years (positive float). * **Output**: Rounded annualized return. Each function must validate that the inputs are positive numbers. If the arguments do not meet these criteria, appropriate exceptions should be thrown. Ensure the functions are optimized for readability and performance. Provide necessary test cases to validate your functions. Example Usage and Expected Results ```python assert total_value([150.0, 200.0], [5, 3]) == 1350.00 assert percentage_change(1000.0, 1500.0) == 50.00 assert annualized_return(1000.0, 1500.0, 3) == 14.47 assert total_value([120.0, 80.0, 95.0], [10, 15, 8]) == 3350.00 assert percentage_change(2000.0, 2500.0) == 25.00 assert annualized_return(2000.0, 2500.0, 5) == 4.56 ``` Constraints * All input numbers must be positive. * Floating-point inputs are allowable, ensure your validation handles them correctly. This assessment will test your ability to understand and implement financial models through programming, with an emphasis on validation and error handling.","solution":"def total_value(prices, shares): Calculate the total value of a stock portfolio. Args: prices (list of floats): Current prices per share for each stock. shares (list of ints): Corresponding number of shares for each stock. Returns: float: Total portfolio value. if not all(isinstance(price, (int, float)) and price > 0 for price in prices): raise ValueError(\\"All prices must be positive numbers.\\") if not all(isinstance(share, int) and share > 0 for share in shares): raise ValueError(\\"All shares must be positive integers.\\") if len(prices) != len(shares): raise ValueError(\\"Prices and shares lists must be of the same length.\\") total = sum(price * share for price, share in zip(prices, shares)) return round(total, 2) def percentage_change(initial_value, final_value): Calculate the percentage change of a portfolio value. Args: initial_value (float): Initial portfolio value. final_value (float): Final portfolio value. Returns: float: Percentage change in portfolio value. if initial_value <= 0 or final_value <= 0: raise ValueError(\\"Initial and final values must be positive numbers.\\") change = ((final_value - initial_value) / initial_value) * 100 return round(change, 2) def annualized_return(initial_value, final_value, years): Calculate the annualized return of a portfolio. Args: initial_value (float): Initial portfolio value. final_value (float): Final portfolio value. years (float): Number of years. Returns: float: Annualized return as a percentage. if initial_value <= 0 or final_value <= 0 or years <= 0: raise ValueError(\\"Initial value, final value, and years must be positive numbers.\\") annual_return = ((final_value / initial_value) ** (1 / years) - 1) * 100 return round(annual_return, 2)"},{"question":"# Coding Assessment Question You are given an integer `n` representing the length of an array of integers `arr`. The array is populated with consecutive integers starting from 1 up to `n`. However, one integer from this range is missing, and another integer (also from this range) is duplicated to maintain the length of the array at `n`. Your task is to write a function to identify the missing integer and the duplicated integer. # Function Signature ```python def find_missing_and_duplicate(arr: list) -> tuple: Identify the missing integer and the duplicated integer in an array. :param arr: A list of integers with length n, where numbers are in the range 1 to n but one number is missing and one number is duplicated. :return: A tuple with the duplicated integer and the missing integer. ``` # Example ```python >>> find_missing_and_duplicate([4, 3, 6, 2, 1, 1]) (1, 5) # Explanation: # Original list should be [1, 2, 3, 4, 5, 6] # Missing number is 5 # Number 1 is duplicated >>> find_missing_and_duplicate([1, 3, 3, 4, 5, 6]) (3, 2) # Explanation: # Original list should be [1, 2, 3, 4, 5, 6] # Missing number is 2 # Number 3 is duplicated >>> find_missing_and_duplicate([2, 2]) (2, 1) # Explanation: # Original list should be [1, 2] # Missing number is 1 # Number 2 is duplicated ``` # Input Constraints * The array `arr` will have length `n`. * The integers in the array `arr` range from 1 to `n`. * The array `arr` contains exactly one missing integer and one duplicate integer. # Requirements * Your solution should be efficient with a time complexity of O(n) and space complexity of O(1). # Edge Cases * Test with the smallest possible array length (n = 2).","solution":"def find_missing_and_duplicate(arr): Identify the missing integer and the duplicated integer in an array. :param arr: A list of integers with length n, where numbers are in the range 1 to n but one number is missing and one number is duplicated. :return: A tuple with the duplicated integer and the missing integer. n = len(arr) expected_sum = n * (n + 1) // 2 expected_sq_sum = n * (n + 1) * (2 * n + 1) // 6 actual_sum = sum(arr) actual_sq_sum = sum(x * x for x in arr) sum_diff = expected_sum - actual_sum sq_sum_diff = expected_sq_sum - actual_sq_sum missing = (sum_diff + sq_sum_diff // sum_diff) // 2 duplicate = missing - sum_diff return (duplicate, missing)"},{"question":"# Question: Implement an Auto-Complete System Using Trie Structure Scenario: A software company wants to implement an auto-complete feature for their text editor. This feature should suggest words based on the prefix entered by the user. To achieve efficient querying and updating, the company decided to use a Trie (Prefix Tree) data structure. Requirements: Implement an `AutocompleteSystem` class which supports the following operations: 1. **insert_word(word: str)**: Inserts the given word into the trie. 2. **search_word(word: str) -> bool**: Searches for the exact word in the trie and returns `True` if found, `False` otherwise. 3. **prefix_search(prefix: str) -> List[str]**: Returns a list of all words in the trie that start with the given prefix. The list should be sorted in lexicographical order. Constraints: 1. You may assume that all input will be lowercase letters. 2. The operations should be efficient. Aim for O(m) time complexity for insertion and search operations, where m is the length of the input word or prefix. 3. The input words will fit in memory (reasonable assumptions about data size). Input/Output Formats: * `insert_word(word: str)` - no output * `search_word(word: str) -> bool` - returns `True` if the word exists in the trie, `False` otherwise * `prefix_search(prefix: str) -> List[str]` - returns a list of words starting with the given prefix Example: ```python ac = AutocompleteSystem() ac.insert_word(\\"apple\\") ac.insert_word(\\"app\\") print(ac.search_word(\\"apple\\")) # Expected output: True print(ac.search_word(\\"app\\")) # Expected output: True print(ac.search_word(\\"apricot\\")) # Expected output: False print(ac.prefix_search(\\"ap\\")) # Expected output: [\\"app\\", \\"apple\\"] print(ac.prefix_search(\\"a\\")) # Expected output: [\\"app\\", \\"apple\\"] ac.insert_word(\\"apricot\\") print(ac.prefix_search(\\"ap\\")) # Expected output: [\\"app\\", \\"apple\\", \\"apricot\\"] ac.insert_word(\\"banana\\") print(ac.prefix_search(\\"b\\")) # Expected output: [\\"banana\\"] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert_word(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_word(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def prefix_search(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] words = [] self._find_words_from_node(node, prefix, words) return sorted(words) def _find_words_from_node(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): self._find_words_from_node(next_node, prefix + char, words)"},{"question":"**Problem Statement**: Write a function `merge_sort_linked_list` to sort a singly linked list using the merge sort algorithm. You also need to implement a basic `Node` class and a `LinkedList` class to handle the linked list operations. # Task Requirements: 1. Implement the class `Node`: - **Attributes**: - `data`: The value or data contained in the node. - `next`: A pointer/reference to the next node in the linked list. - **Initialization**: - Initialize a new node with a given data value and set `next` to `None`. 2. Implement the class `LinkedList`: - **Methods**: - `__init__`: Initialize an empty linked list. - `append`: Add a new node with the given data to the end of the linked list. - `to_list`: Convert the linked list to a regular Python list for output/display purposes. - `merge_sort`: Sort the linked list using the merge sort algorithm. - **Attributes**: - `head`: A pointer/reference to the first node in the linked list. 3. Implement the function `merge_sort_linked_list` to sort the linked list: - **Input**: A `LinkedList` object. - **Output**: Modify the linked list to be sorted in ascending order. # Constraints: 1. The merge sort algorithm should be implemented iteratively and/or recursively. 2. Handle edge cases such as an empty linked list or a single-element linked list appropriately. 3. Maintain efficient handling of linked list operations to ensure overall algorithm performance. # Function Signatures & Class Definitions: ```python class Node: def __init__(self, data: int): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data: int): pass def to_list(self) -> list: pass def merge_sort(self): pass def merge_sort_linked_list(linked_list: LinkedList): linked_list.merge_sort() ``` # Example: ```python # Sample LinkedList creation ll = LinkedList() ll.append(4) ll.append(2) ll.append(1) ll.append(3) # Perform merge sort on the linked list merge_sort_linked_list(ll) # Convert sorted linked list to a list for verification assert ll.to_list() == [1, 2, 3, 4] ```","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data: int): if self.head is None: self.head = Node(data) else: current = self.head while current.next: current = current.next current.next = Node(data) def to_list(self) -> list: result = [] current = self.head while current: result.append(current.data) current = current.next return result def _split(self, head): slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None return head, slow def _merge(self, left, right): dummy = Node(0) current = dummy while left and right: if left.data < right.data: current.next = left left = left.next else: current.next = right right = right.next current = current.next current.next = left or right return dummy.next def _merge_sort(self, head): if not head or not head.next: return head left, right = self._split(head) left = self._merge_sort(left) right = self._merge_sort(right) return self._merge(left, right) def merge_sort(self): self.head = self._merge_sort(self.head) def merge_sort_linked_list(linked_list: LinkedList): linked_list.merge_sort()"},{"question":"# Recursive Depth Calculation of Nested Dictionaries Your task is to write a function that calculates the maximum depth of a nested dictionary. The definition of depth for a dictionary is as follows: 1. A dictionary with no nested dictionaries has a depth of 1. 2. If a dictionary contains another dictionary, the depth is 1 plus the maximum depth of any of the nested dictionaries. # Function Description - **max_depth(d: dict) -> int** * This function takes a dictionary `d` as its parameter and returns an integer representing the maximum depth of the nested dictionaries. # Requirements * Implement the `max_depth` function as described. * The input dictionary `d` may contain nested dictionaries at arbitrary depths. * If the dictionary is empty, its depth is considered to be 1. # Constraints * Assume that the dictionary and its nested dictionaries only contain other dictionaries or dictionary-like (JSON-like) elements. * Ensure the function handles well at least moderately nested structures (depth up to 100). # Example ```python def max_depth(d: dict) -> int: if not isinstance(d, dict) or not d: return 1 return 1 + max(max_depth(v) for v in d.values() if isinstance(v, dict)) # Test cases d1 = {\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}} d2 = {\\"key1\\": {\\"key2\\": {\\"key3\\": \\"value\\"}}} d3 = {} print(max_depth(d1)) # Expected Output: 3 print(max_depth(d2)) # Expected Output: 3 print(max_depth(d3)) # Expected Output: 1 ``` Your solution should correctly calculate the depth for the provided test cases as well as other potential edge cases.","solution":"def max_depth(d: dict) -> int: Computes the maximum depth of a nested dictionary. Parameters: d (dict): The dictionary whose depth needs to be calculated. Returns: int: The maximum depth of the dictionary. if not isinstance(d, dict) or not d: return 1 return 1 + max((max_depth(v) for v in d.values() if isinstance(v, dict)), default=0)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with analyzing a set of strings to determine the most frequent substring of a given length. If there are multiple substrings with the same frequency, return the lexicographically smallest one. Detailed Description * **Function Name**: `most_frequent_substring` * **Inputs**: * `s` (str): The input string. * `length` (int): The length of the substrings to be analyzed. * **Output**: * Returns the substring of the specified length that appears most frequently in the string. * **Constraints**: * The length of `s` will be between 1 and 10^5. * `length` will be between 1 and the length of `s`. * If the `length` is greater than the length of `s`, return an empty string. Example ```python >>> most_frequent_substring(\\"banana\\", 2) \\"an\\" >>> most_frequent_substring(\\"abcabcabc\\", 3) \\"abc\\" >>> most_frequent_substring(\\"abcdefg\\", 4) \\"abcd\\" >>> most_frequent_substring(\\"\\", 1) \\"\\" >>> most_frequent_substring(\\"a\\", 2) \\"\\" ``` Implementation Implement the function in Python, structured as follows: ```python def most_frequent_substring(s: str, length: int) -> str: Takes an input string `s` and an integer `length`, and returns the most frequent substring of the specified length. In case of a tie, returns the lexicographically smallest substring. Examples: >>> most_frequent_substring(\\"banana\\", 2) \\"an\\" >>> most_frequent_substring(\\"abcabcabc\\", 3) \\"abc\\" >>> most_frequent_substring(\\"abcdefg\\", 4) \\"abcd\\" >>> most_frequent_substring(\\"\\", 1) \\"\\" >>> most_frequent_substring(\\"a\\", 2) \\"\\" if length > len(s): return \\"\\" from collections import defaultdict substring_count = defaultdict(int) for i in range(len(s) - length + 1): substring = s[i:i + length] substring_count[substring] += 1 max_count = 0 result = None for substring, count in substring_count.items(): if count > max_count or (count == max_count and substring < result): max_count = count result = substring return result if result is not None else \\"\\" ``` Complete the implementation and ensure the function works efficiently even for large inputs.","solution":"def most_frequent_substring(s: str, length: int) -> str: Takes an input string `s` and an integer `length`, and returns the most frequent substring of the specified length. In case of a tie, returns the lexicographically smallest substring. Examples: >>> most_frequent_substring(\\"banana\\", 2) \\"an\\" >>> most_frequent_substring(\\"abcabcabc\\", 3) \\"abc\\" >>> most_frequent_substring(\\"abcdefg\\", 4) \\"abcd\\" >>> most_frequent_substring(\\"\\", 1) \\"\\" >>> most_frequent_substring(\\"a\\", 2) \\"\\" if length > len(s): return \\"\\" from collections import defaultdict substring_count = defaultdict(int) for i in range(len(s) - length + 1): substring = s[i:i + length] substring_count[substring] += 1 max_count = 0 result = None for substring, count in substring_count.items(): if count > max_count or (count == max_count and (result is None or substring < result)): max_count = count result = substring return result if result is not None else \\"\\""},{"question":"# Coding Question: Counting Islands in a Binary Matrix Context: In various image processing, geographical mapping, and network connectivity problems, we often need to identify clusters or connected components in a grid. One typical problem is counting the number of islands in a binary matrix. An island is defined as a group of connected 1s (horizontally or vertically). Task: Write a function `count_islands` that takes a binary matrix and returns the number of islands (connected groups of 1s) in the matrix. Input: * `grid` (List[List[int]]): A binary matrix of size ( m times n ) where each element is either 0 or 1. Output: * int: The number of islands. Constraints: * ( 1 leq m, n leq 500 ) * Each element in the matrix is either 0 or 1. Requirements: * Time complexity should be ( O(m times n) ). * Space complexity should be ( O(m times n) ). Function Signature: ```python def count_islands(grid: List[List[int]]) -> int: pass ``` Example: Input: ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ] ``` Output: ```python 2 ``` Explanation: There are two islands in the provided matrix: 1. The island formed by the cells (0,0), (0,1), (1,0), and (1,1). 2. The island formed by the cells (1,3), (1,4), (2,3), (2,4), and (3,3). # Notes: 1. An island is surrounded by water (0s) and is formed by connecting adjacent lands (1s) horizontally or vertically. 2. You can use Depth First Search (DFS) or Breadth First Search (BFS) to explore the islands. 3. Consider marking visited cells during your traversal to avoid counting the same island multiple times. Use systematic exploration to identify and count all the islands in the matrix.","solution":"def count_islands(grid): Returns the number of islands (connected groups of 1s) in a binary matrix. Args: grid (List[List[int]]): A binary matrix of size m x n. Returns: int: The number of islands in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 0: return grid[x][y] = 0 # Mark as visited by setting to 0 # Traverse all four possible directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: island_count += 1 dfs(i, j) return island_count"},{"question":"# Problem Description Your task is to implement a class `CircularQueue` that simulates a circular queue with a fixed size. A circular queue is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure can handle the wraparound of elements when the first index of the queue connects to the last index to form a circle. # Class Definition Implement a class `CircularQueue` with the following methods: 1. **`__init__(self, k: int)`**: Initializes the queue with a capacity of `k`. 2. **`enqueue(self, value: int) -> bool`**: Adds an element to the circular queue. Returns `True` if the operation is successful, or `False` if the queue is full. 3. **`dequeue(self) -> int | None`**: Removes an element from the circular queue. Returns the removed element, or `None` if the queue is empty. 4. **`front(self) -> int | None`**: Gets the front item from the queue, or returns `None` if the queue is empty. 5. **`rear(self) -> int | None`**: Gets the last item from the queue, or returns `None` if the queue is empty. 6. **`is_empty(self) -> bool`**: Checks whether the circular queue is empty. 7. **`is_full(self) -> bool`**: Checks whether the circular queue is full. # Function Signature ```python class CircularQueue: def __init__(self, k: int): pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> int | None: pass def front(self) -> int | None: pass def rear(self) -> int | None: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass ``` # Constraints 1. The queue\'s capacity `k` will be between 1 and (10^3). 2. The values for the elements will be between (-10^6) and (10^6). # Examples ```python q = CircularQueue(3) assert q.enqueue(1) == True assert q.enqueue(2) == True assert q.enqueue(3) == True assert q.enqueue(4) == False # Queue is full assert q.rear() == 3 assert q.is_full() == True assert q.dequeue() == 1 assert q.enqueue(4) == True assert q.rear() == 4 assert q.front() == 2 assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.dequeue() == 4 assert q.dequeue() == None # Queue is empty assert q.front() == None assert q.rear() == None assert q.is_empty() == True ``` # Explanation - Initialize the queue with a capacity `k=3`. - Enqueue elements `1`, `2`, and `3` successfully. - Attempt to enqueue `4`, but the queue is full. - The rear of the queue is `3` and the queue is full. - Dequeue `1`, making space for one more element. - Enqueue `4` successfully. - After enqueuing `4`, the rear is now `4` and the front is `2`. - Continue to dequeue remaining elements `2`, `3`, and `4`. - Attempt to dequeue again, but the queue is empty. - Verify that both the front and rear return `None` and the queue is empty. # Notes - Pay attention to edge cases like attempting to dequeue from an empty queue or enqueue into a full queue. - Ensure the methods handle the circular nature of the queue efficiently.","solution":"class CircularQueue: def __init__(self, k: int): self.queue = [None] * k self.capacity = k self.size = 0 self.front_index = 0 self.rear_index = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.size == 0: self.queue[self.rear_index] = value else: self.rear_index = (self.rear_index + 1) % self.capacity self.queue[self.rear_index] = value self.size += 1 return True def dequeue(self) -> int | None: if self.is_empty(): return None removed_value = self.queue[self.front_index] self.queue[self.front_index] = None if self.size > 1: self.front_index = (self.front_index + 1) % self.capacity self.size -= 1 return removed_value def front(self) -> int | None: if self.is_empty(): return None return self.queue[self.front_index] def rear(self) -> int | None: if self.is_empty(): return None return self.queue[self.rear_index] def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Pascal\'s Triangle Row Calculator In this problem, you are required to write a function to calculate the nth row of Pascal\'s Triangle. A row in Pascal\'s Triangle is characterized by the binomial coefficients of a given number. Function Signature ```python def pascals_triangle_row(n: int) -> List[int]: ``` Parameters - `n` (int): The index of the row in Pascal\'s Triangle we want to calculate (0-based index). Returns - `List[int]`: The nth row of Pascal\'s Triangle. Constraints - `n` is an integer such that 0 <= n <= 20 (These constraints are given to avoid handling unreasonably large numbers and prevent performance issues). Example ```python assert pascals_triangle_row(0) == [1] assert pascals_triangle_row(1) == [1, 1] assert pascals_triangle_row(2) == [1, 2, 1] assert pascals_triangle_row(3) == [1, 3, 3, 1] assert pascals_triangle_row(4) == [1, 4, 6, 4, 1] ``` Edge Cases - Ensure your function handles small values such as `n=0` correctly. - Handle cases where `n` is not a non-negative integer by raising appropriate exceptions. **Your task** is to implement the `pascals_triangle_row` function while ensuring it is efficient and correctly handles all scenarios mentioned.","solution":"from typing import List def pascals_triangle_row(n: int) -> List[int]: Returns the nth row of Pascal\'s Triangle. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") row = [1] for k in range(1, n + 1): row.append(row[k - 1] * (n - k + 1) // k) return row"},{"question":"# Coding Assessment Question: Validate and Generate Parentheses Combinations As a developer, you are tasked with creating a Python module that involves two primary functions. One function will validate if a string of parentheses is well-formed, and the other function will generate all combinations of well-formed parentheses pairs for a given number of pairs. Function 1: `is_valid_parentheses(s: str) -> bool` - **Input**: - A string `s`, containing only the characters `(` and `)`. - **Output**: - A boolean value indicating whether the string `s` is a valid well-formed parentheses expression. - **Constraints**: - The input string will only contain `(` and `)`. - The length of the string will be between 0 and 100 inclusive. Function 2: `generate_parentheses(n: int) -> List[str]` - **Input**: - An integer `n`, representing the number of pairs of parentheses. - **Output**: - A list of strings, where each string represents a valid combination of `n` pairs of well-formed parentheses. - **Constraints**: - The input integer `n` will be between 0 and 10 inclusive. # Example: ```python >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(()\\") False >>> generate_parentheses(2) [\'(())\', \'()()\'] >>> generate_parentheses(3) [\'((()))\', \'(()())\', \'(())()\', \'()(())\', \'()()()\'] ``` # Requirements: 1. Implement the functions `is_valid_parentheses(s: str) -> bool` and `generate_parentheses(n: int) -> List[str]`. 2. Ensure the `is_valid_parentheses` function operates in O(n) time complexity, where n is the length of the input string. 3. Ensure the `generate_parentheses` function generates all combinations of valid parentheses in an efficient manner. 4. Include appropriate test cases to demonstrate the functionality of your functions. 5. Document your code properly with comments and explanations. Guidelines: * Avoid using any external libraries for validation or generation; implement all logic manually. * Write a main block that demonstrates the functionality using test cases. * Consider edge cases, such as empty strings and zero pairs of parentheses.","solution":"def is_valid_parentheses(s: str) -> bool: Determine if the input string of parentheses is well-formed. Parameters: s (str): The string containing only \'(\' and \')\'. Returns: bool: True if the string is a valid well-formed parentheses expression, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0 def generate_parentheses(n: int): Generate all combinations of well-formed parentheses pairs. Parameters: n (int): The number of pairs of parentheses. Returns: List[str]: A list of strings representing all valid combinations of well-formed parentheses pairs. result = [] def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"# Coding Assessment: Find Common Elements in Sorted Arrays Objective Write a Python function to find the common elements in two sorted arrays. Your task is to ensure that the function is efficient and handles edge cases gracefully. Requirements 1. **Function: `find_common_elements(arr1: List[int], arr2: List[int]) -> List[int]`** - Input: - Two lists of integers, `arr1` and `arr2`, which are both sorted in ascending order. - Output: - A list of integers that are present in both arrays. - Constraints: - The input arrays may have different lengths. - If there are no common elements, return an empty list. Performance Requirements - Your solution should be efficient in terms of time complexity. - Aim to solve it in O(n + m) time complexity, where n and m are the lengths of `arr1` and `arr2` respectively. - You should avoid using extra space and aim for an O(1) space complexity (excluding the space needed for the output list). Example ```python >>> arr1 = [1, 2, 4, 5, 7] >>> arr2 = [2, 3, 5, 6] >>> common_elements = find_common_elements(arr1, arr2) >>> print(common_elements) [2, 5] ``` ```python >>> arr1 = [1, 3, 4, 6] >>> arr2 = [2, 5, 8] >>> common_elements = find_common_elements(arr1, arr2) >>> print(common_elements) [] ``` Notes 1. Your function should handle cases where either or both arrays are empty. 2. The input arrays are guaranteed to be sorted in non-decreasing order. 3. The function should not modify the input arrays. Constraints - All integers in the input arrays are within the range [-10^9, 10^9]. - The length of each array is at most 10^5.","solution":"def find_common_elements(arr1, arr2): This function finds the common elements in two sorted arrays. It assumes that both input arrays are sorted in ascending order. i, j = 0, 0 common_elements = [] while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: i += 1 elif arr1[i] > arr2[j]: j += 1 else: common_elements.append(arr1[i]) i += 1 j += 1 return common_elements"},{"question":"Question: Implement a Custom Sorting Algorithm # Scenario As part of an application for organizing user data, you need to implement a custom sorting algorithm. This algorithm sorts an array of integers but prioritizes even numbers over odd numbers, maintaining their original relative order within their respective group of evens and odds. # Task Write a function `custom_sort` that sorts an array of integers such that all even numbers appear before all odd numbers, while preserving the relative order of both even and odd numbers as they appear in the original array. # Function Signature ```python def custom_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. # Output * Returns a list of integers sorted as per the requirements. # Constraints * The array can contain between 1 and 1000 integers. * Each integer in the array can range from -10000 to 10000. # Example ```python print(custom_sort([3, 1, 2, 4])) # Output: [2, 4, 3, 1] print(custom_sort([0, 1, 2, 3, 4])) # Output: [0, 2, 4, 1, 3] print(custom_sort([10, 21, 13, 16, 25])) # Output: [10, 16, 21, 13, 25] ``` # Notes * The function should maintain the relative order of the even and odd numbers in the input list. * Consider edge cases such as arrays with all even numbers, all odd numbers, or a mix of positive and negative integers.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sort the array such that all even numbers appear before all odd numbers, while preserving the relative order of both even and odd numbers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"# String Transformations You are tasked with implementing additional features for a `StringManipulator` class that processes a string in various ways. Specifically, you need to implement the following methods: 1. **Rotate String**: * Implement a method `rotate` that rotates the input string to the right by a specified number of positions. * **Input**: A string `s` and an integer `n`. * **Output**: A new string that is the original string rotated to the right by `n` positions. * **Constraints**: - If `n` is greater than the length of the string, rotate only by the remainder of `n` divided by the string length. 2. **Duplicate Removal**: * Implement a method `remove_duplicates` that removes all duplicate characters from the input string, preserving the order of their first occurrence. * **Input**: A string `s`. * **Output**: A new string with duplicate characters removed. **Function Signatures**: ```python def rotate(self, s: str, n: int) -> str: ... def remove_duplicates(self, s: str) -> str: ... ``` **Example Usage**: ```python sm = StringManipulator() # Rotate String result_rotate = sm.rotate(\\"abcdefg\\", 3) print(result_rotate) # Output: \\"efgabcd\\" # Remove Duplicates result_remove = sm.remove_duplicates(\\"abracadabra\\") print(result_remove) # Output: \\"abrcd\\" ``` **Explanation**: - For `rotate`, given the string \\"abcdefg\\" and `n = 3`, the last 3 characters \\"efg\\" are moved to the front, shifting the rest to the right. - For `remove_duplicates`, the first occurrence of each character is kept, resulting in \\"abracadabra\\" reducing to \\"abrcd\\".","solution":"class StringManipulator: def rotate(self, s: str, n: int) -> str: Rotates the string s to the right by n positions. if not s: return s n = n % len(s) # To handle if n is larger than the length of the string return s[-n:] + s[:-n] def remove_duplicates(self, s: str) -> str: Removes duplicate characters from the string s and preserves the order of first occurrence. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Roman Numerals to Integer Conversion Context: As a software developer, you are often required to interact with various numeral systems. One such system is the ancient Roman numeral system. Converting between numeral systems is a common task that tests your understanding of algorithms and string manipulation. Task: Write a function `roman_to_int(s: str) -> int` that converts a given Roman numeral string to an integer. The input is a string representing a Roman numeral, and the function should return the corresponding integer value. Input: * A string `s` representing a valid Roman numeral. Only the characters \\"I\\", \\"V\\", \\"X\\", \\"L\\", \\"C\\", \\"D\\", and \\"M\\" will be used, representing the values 1, 5, 10, 50, 100, 500, and 1000 respectively. Output: * An integer representing the converted Roman numeral. Example: ```python def roman_to_int(s: str) -> int: Example usage: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 ``` Constraints: * The input string `s` will be between 1 and 15 characters in length. * The input string will be a valid Roman numeral. **Edge Cases to consider**: * The numeral \\"I\\" only ever precedes the numerals \\"V\\" and \\"X\\". * The numeral \\"X\\" only ever precedes the numerals \\"L\\" and \\"C\\". * The numeral \\"C\\" only ever precedes the numerals \\"D\\" and \\"M\\". Requirements: * Make sure your function correctly handles all valid and edge case inputs. * Ensure the logic accounts for subtractive combinations (e.g., IV, IX, XL, XC, CD, and CM).","solution":"def roman_to_int(s: str) -> int: # Define values for Roman numerals roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Initialize integer result total = 0 prev_value = 0 # Process each character in the string, from left to right for char in s: # Get the value of the current Roman numeral character value = roman_values[char] # If the previous value is less than the current value, it means we should subtract twice the previous value # Because we have already added it once, we need to remove it by subtracting it twice if prev_value < value: total += value - 2 * prev_value else: total += value # Update the previous value prev_value = value return total"},{"question":"# Array Rotation Transformer Given a list and a positive integer `k`, your goal is to write a function that returns a new list with the elements rotated to the right by `k` positions. **Function Signature**: ```python def rotate_list(arr: list[int], k: int) -> list[int]: pass ``` # Input - `arr`: A list of integers where `0 <= len(arr) <= 10^5`. - `k`: A non-negative integer (`0 <= k <= 10^9`). # Output - Returns a new list of integers representing the rotated list. # Constraints - The function should raise a `TypeError` if the input `arr` is not a list or if `k` is not an integer. - If the length of `arr` is 0, the function should return an empty list. - The function should handle cases where `k` is larger than the length of `arr`. # Performance Requirements - The function should run efficiently for the upper limits of the input constraints. # Example ```python assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_list([], 3) == [] assert rotate_list(\'not a list\', 2) == TypeError(\\"Input must be a list of integers\\") assert rotate_list([1, 2, 3], \'string\') == TypeError(\\"Rotation count must be an integer\\") ``` # Explanation 1. For `arr = [1, 2, 3, 4, 5]` and `k = 2`, rotating the list to the right by 2 results in `[4, 5, 1, 2, 3]`. 2. For `arr = [1, 2, 3, 4, 5]` and `k = 5`, rotating by the length of the list should return the original list. 3. For `arr = [1, 2, 3, 4, 5]` and `k = 7`, which is equivalent to `k = 2` (`7 % 5 = 2`). 4. For `arr = []`, regardless of `k`, the result is an empty list. 5. The function raises a `TypeError` if `arr` is not a list or `k` is not an integer.","solution":"def rotate_list(arr: list[int], k: int) -> list[int]: Rotates the elements of the list to the right by k positions. Parameters: arr (list): List of integers to rotate. k (int): Number of positions to rotate the list by. Returns: list: The rotated list. if not isinstance(arr, list): raise TypeError(\\"Input must be a list of integers\\") if not isinstance(k, int): raise TypeError(\\"Rotation count must be an integer\\") n = len(arr) if n == 0: return [] k = k % n # handle cases where k is larger than the length of the list rotated_list = arr[-k:] + arr[:-k] return rotated_list"},{"question":"# Question: You are given a string containing space-separated words and a list of words to ignore. Your task is to write a function `filter_words(text: str, ignore_list: list[str]) -> str` that returns the text with the ignored words removed. The remaining words should be concatenated with a single space between them. # Detailed Requirements: 1. **Input Format**: * `text`: a non-empty string containing space-separated words ((1 leq text{length}(text) leq 1000)) * `ignore_list`: a list of strings containing words to be ignored (maximum size 100, each string length up to 20) 2. **Output Format**: * The function should return a string with the words from the ignore list removed and the remaining words concatenated with a single space. 3. **Constraints**: * All words in `text` and elements of `ignore_list` are non-empty and contain only lowercase alphabetical characters. 4. **Performance Requirements**: * Aim for a solution that runs in (O(n)) time complexity, where (n) is the length of the text. # Example: ```python def filter_words(text: str, ignore_list: list[str]) -> str: # Implementation here pass # Example usage print(filter_words(\\"the quick brown fox jumps over the lazy dog\\", [\\"the\\", \\"quick\\", \\"over\\"])) # Expected Output: \\"brown fox jumps the lazy dog\\" print(filter_words(\\"this is a sample text with repeated words this text\\", [\\"this\\", \\"text\\", \\"is\\"])) # Expected Output: \\"a sample with repeated words\\" ``` # Edge Cases to Consider: * `ignore_list` is empty. * Should return the original text unchanged. * All words in the `text` are present in the `ignore_list`. * Should return an empty string. * `text` contains multiple consecutive spaces or leading/trailing spaces. * The output should be properly trimmed and formatted with single spaces between words.","solution":"def filter_words(text: str, ignore_list: list[str]) -> str: Filters out words from the text that are present in the ignore_list. Args: text (str): The input string containing space-separated words. ignore_list (list): A list of words to be ignored. Returns: str: The filtered text with ignored words removed. words = text.split() filtered_words = [word for word in words if word not in ignore_list] return \' \'.join(filtered_words)"},{"question":"# Currency Exchange Calculator **Objective**: Implement a function to convert an amount from one currency to another using real-time exchange rates obtained through an external API, handling various edge cases and ensuring the accuracy of calculations. **Scenario**: In a financial application, users need to convert amounts from one currency to another based on the latest exchange rates. You are to integrate with a currency exchange rate API to fetch the conversion rate and perform the currency conversion accurately. **Requirements**: - Define a function `convert_currency(amount: float, from_currency: str, to_currency: str, api_key: str) -> dict` that: - Takes an amount (float), a source currency code (string), a destination currency code (string), and an API key (string). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"result\\"` (the converted amount on success or an error message on failure). - Validate that the amount is positive. - Ensure the currency codes provided are in the correct format (3-letter ISO currency codes). - Handle network errors or invalid API responses gracefully. - If an invalid currency code is provided, return an appropriate error message. **Function Signature**: ```python def convert_currency(amount: float, from_currency: str, to_currency: str, api_key: str) -> dict: pass ``` **Constraints**: - The API key provided is valid. - The input currency codes and amount are valid. **Examples**: 1. `convert_currency(100, \\"USD\\", \\"EUR\\", \\"YOUR API KEY\\")` - Might return: ```python { \\"success\\": True, \\"result\\": 84.50 # Assuming the conversion rate from USD to EUR is 0.845 } ``` 2. `convert_currency(0, \\"USD\\", \\"EUR\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"result\\": \\"Invalid amount. Amount must be greater than 0.\\" } ``` 3. `convert_currency(100, \\"INVALID\\", \\"EUR\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"result\\": \\"Invalid source currency code.\\" } ``` 4. On network failure: - Should return: ```python { \\"success\\": False, \\"result\\": \\"Network error occurred while fetching exchange rates.\\" } ```","solution":"import requests def convert_currency(amount: float, from_currency: str, to_currency: str, api_key: str) -> dict: Converts an amount from one currency to another using real-time exchange rates. Args: amount (float): The amount to convert. from_currency (str): The source currency code. to_currency (str): The destination currency code. api_key (str): The API key for accessing the exchange rate service. Returns: dict: A dictionary with keys \\"success\\" and \\"result\\", indicating whether the conversion was successful and the converted amount or error message. # Validate the amount if amount <= 0: return {\\"success\\": False, \\"result\\": \\"Invalid amount. Amount must be greater than 0.\\"} # Validate currency codes if len(from_currency) != 3 or not from_currency.isalpha(): return {\\"success\\": False, \\"result\\": \\"Invalid source currency code.\\"} if len(to_currency) != 3 or not to_currency.isalpha(): return {\\"success\\": False, \\"result\\": \\"Invalid destination currency code.\\"} # Construct API request url = f\\"https://api.exchangerate-api.com/v4/latest/{from_currency.upper()}\\" try: response = requests.get(url, headers={\\"apikey\\": api_key}) response.raise_for_status() except requests.RequestException: return {\\"success\\": False, \\"result\\": \\"Network error occurred while fetching exchange rates.\\"} data = response.json() # Check if the API response contains the required currency if to_currency.upper() not in data[\'rates\']: return {\\"success\\": False, \\"result\\": \\"Invalid destination currency code.\\"} # Perform the currency conversion rate = data[\'rates\'][to_currency.upper()] converted_amount = amount * rate return {\\"success\\": True, \\"result\\": converted_amount}"},{"question":"# Coding Assessment Question Context You are working on a calendar application that needs to calculate the number of days between two given dates. The application should handle different months and leap years correctly. Task Implement a function `days_between_dates(date1: str, date2: str) -> int` that calculates the number of days between the two given dates, including leap years. The dates will be provided in the format `\'YYYY-MM-DD\'`. Input - `date1`: A string representing the first date in the format `\'YYYY-MM-DD\'`. - `date2`: A string representing the second date in the format `\'YYYY-MM-DD\'`. Output - Return an integer representing the number of days between the two dates. - The result should be positive regardless of the order of the dates. Constraints - The dates are valid and within the range from `1900-01-01` to `2100-12-31`. - Both dates are given in the Gregorian calendar. Example ```python def days_between_dates(date1: str, date2: str) -> int: pass # Example Usage date1 = \\"2020-01-01\\" date2 = \\"2020-01-31\\" assert days_between_dates(date1, date2) == 30 date1 = \\"2021-02-01\\" date2 = \\"2020-02-01\\" assert days_between_dates(date1, date2) == 366 date1 = \\"2020-02-28\\" date2 = \\"2020-03-01\\" assert days_between_dates(date1, date2) == 2 ``` Requirements - Your implementation should accurately account for leap years and the varying number of days in each month. - Ensure your solution is efficient and handles edge cases correctly. - Do not use any external libraries for date manipulation; implement the logic from first principles.","solution":"def is_leap_year(year): Determine if the given year is a leap year. Args: year (int): The year to check. Returns: bool: True if the year is a leap year, False otherwise. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False def days_in_month(year, month): Determine the number of days in a given month of a given year. Args: year (int): The year. month (int): The month. Returns: int: The number of days in the month. days_of_month = [31, 29 if is_leap_year(year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] return days_of_month[month - 1] def date_to_ordinal(year, month, day): Convert a date to the number of days since 1900-01-01. Args: year (int), month (int), day (int): Components of the date. Returns: int: The number of days since 1900-01-01. total_days = 0 for y in range(1900, year): total_days += 366 if is_leap_year(y) else 365 for m in range(1, month): total_days += days_in_month(year, m) total_days += day - 1 return total_days def days_between_dates(date1, date2): Calculate the number of days between two dates. Args: date1 (str): The first date in \'YYYY-MM-DD\' format. date2 (str): The second date in \'YYYY-MM-DD\' format. Returns: int: The absolute number of days between the two dates. year1, month1, day1 = map(int, date1.split(\\"-\\")) year2, month2, day2 = map(int, date2.split(\\"-\\")) ordinal1 = date_to_ordinal(year1, month1, day1) ordinal2 = date_to_ordinal(year2, month2, day2) # Calculate absolute difference return abs(ordinal1 - ordinal2)"},{"question":"# Question: Given a string, write a Python function `anagram_groups` that returns a dictionary where the keys are sorted anagrams, and the values are lists of words from the input string that are anagrams of each other. Function Signature ```python def anagram_groups(words: list[str]) -> dict[str, list[str]]: ``` # Input - `words`: A list of strings where each string is a lowercase word. # Output - Returns a dictionary where each key is a sorted string of unique characters (representing the anagram pattern), and the corresponding value is a list of original words that match that anagram pattern. # Constraints - All elements in the list `words` are lowercase alphabetic strings. - The length of the list `words` does not exceed 10^4. - The length of each individual word does not exceed 100 characters. # Examples ```python assert anagram_groups([\\"ate\\", \\"eat\\", \\"tea\\", \\"nat\\", \\"tan\\", \\"bat\\"]) == { \'aet\': [\'ate\', \'eat\', \'tea\'], \'ant\': [\'nat\', \'tan\'], \'abt\': [\'bat\'] } assert anagram_groups([\\"\\"]) == { \'\': [\'\'] } assert anagram_groups([]) == {} ``` # Requirements 1. Ensure the function can handle cases with empty strings or an empty list gracefully. 2. Handle input validation to accept only lists of lowercase alphabetic strings. 3. Ensure the function performs efficiently even for larger lists of words. # Scenario You need to group words from a list by their anagrams. This can be useful in text analysis and natural language processing tasks where you want to identify clusters of words that are anagrams of each other. Use this function to simplify such grouping tasks.","solution":"def anagram_groups(words: list[str]) -> dict[str, list[str]]: Returns a dictionary where the keys are sorted anagrams, and the values are lists of words from the input list that are anagrams of each other. from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return dict(anagrams)"},{"question":"# Coding Assessment Question Scenario You are a developer working on a new graph-based social networking feature. Users can indicate their friendship connections, and the system must determine the shortest path of friend connections between any two users. If two users are not connected directly or indirectly, indicate that there is no possible connection. Task Write a function `shortest_friend_path(users: list[tuple[str, str]], user1: str, user2: str) -> int` that calculates the shortest path of friendships between `user1` and `user2`. Input * `users`: A list of tuples, each with two strings representing a friendship connection in the form `(user_a, user_b)`. * `user1`: A string representing the starting user. * `user2`: A string representing the target user. Output * The shortest number of hops between `user1` and `user2` as an integer. * Return `-1` if there is no possible connection between the two users. Constraints * Each user\'s name is a unique alphanumeric string. * `1 <= len(users) <= 1000` Example ```python def shortest_friend_path(users: list[tuple[str, str]], user1: str, user2: str) -> int: # function implementation # Example Calls users1 = [(\\"Alice\\", \\"Bob\\"), (\\"Bob\\", \\"Charlie\\"), (\\"Charlie\\", \\"David\\"), (\\"David\\", \\"Edward\\"), (\\"Edward\\", \\"Frank\\")] print(shortest_friend_path(users1, \\"Alice\\", \\"Frank\\")) # Output: 5 users2 = [(\\"Alice\\", \\"Bob\\"), (\\"Carol\\", \\"David\\"), (\\"Eve\\", \\"Frank\\")] print(shortest_friend_path(users2, \\"Alice\\", \\"Frank\\")) # Output: -1 users3 = [(\\"Alice\\", \\"Bob\\"), (\\"Bob\\", \\"Charlie\\"), (\\"Bob\\", \\"David\\"), (\\"David\\", \\"Edward\\")] print(shortest_friend_path(users3, \\"Alice\\", \\"Edward\\")) # Output: 3 ``` Additional Notes * Use a breadth-first search (BFS) approach to find the shortest path in an unweighted graph. * You may assume that each user mentioned will have at least one connection in the list if it appears at all. * Ensure the solution handles cases with no valid path efficiently.","solution":"from collections import deque, defaultdict def shortest_friend_path(users, user1, user2): Calculate the shortest path of friendships between user1 and user2. Args: users (list[tuple[str, str]]): List of friendship connections. user1 (str): Starting user. user2 (str): Target user. Returns: int: The shortest number of hops between user1 and user2, or -1 if they are not connected. if user1 == user2: return 0 graph = defaultdict(list) for u1, u2 in users: graph[u1].append(u2) graph[u2].append(u1) visited = set() queue = deque([(user1, 0)]) # (current_user, current_distance) visited.add(user1) while queue: current_user, current_distance = queue.popleft() for neighbor in graph[current_user]: if neighbor == user2: return current_distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) return -1"},{"question":"# Scenario You are tasked with developing a file renaming utility for a large batch of files. The utility should follow a specific naming pattern and ensure that no two files have the same name post-renaming. # Task Write a function `rename_files(pattern: str, files: List[str]) -> List[str]` that takes a list of file names and renames them according to the specified pattern. # Details 1. The pattern is a string that contains a placeholder `{n}` representing a unique incremental integer. 2. The function should replace `{n}` with integers starting from 1, ensuring all filenames are unique. # Input and Output * **Input Format**: * The input consists of a string `pattern` and a list of strings `files`. * `pattern` contains the placeholder `{n}` exactly once. * `files` is a list of strings containing the original file names. * **Output Format**: * The function should return a list of strings with the new file names following the pattern. # Constraints * There might be up to 1000 file names in the `files` list. * The `files` list will contain non-empty strings representing file names. # Examples * Example 1: ```python rename_files(\'file_{n}.txt\', [\'input.txt\', \'output.txt\', \'readme.txt\']) # [\'file_1.txt\', \'file_2.txt\', \'file_3.txt\'] ``` * Example 2: ```python rename_files(\'image_{n}.png\', [\'logo.png\', \'header.png\', \'footer.png\']) # [\'image_1.png\', \'image_2.png\', \'image_3.png\'] ``` # Additional Considerations 1. Ensure the function handles edge cases such as an empty list of files. 2. The function should maintain the order of files while renaming to ensure consistency. 3. If the pattern, files, or constraints change in the future, the function should be adaptable with minimal modifications. Implement the function to achieve the desired results and handle edge cases properly.","solution":"from typing import List def rename_files(pattern: str, files: List[str]) -> List[str]: Renames files according to a given pattern, ensuring unique names by incrementing an integer value within the pattern. :param pattern: A string containing a placeholder `{n}` for numeric indexing. :param files: A list of strings containing the original file names. :return: A list of renamed file names following the given pattern. if not files: return [] renamed_files = [] for i, _ in enumerate(files, start=1): new_file_name = pattern.replace(\\"{n}\\", str(i)) renamed_files.append(new_file_name) return renamed_files"},{"question":"Prefix Sum Array Utility Prefix sums are useful in many scenarios, such as calculating the sum of elements in a sub-array quickly. Given an integer array, your task is to implement a class `PrefixSumArray` with the following methods to manage prefix sums efficiently: 1. **__init__(self, arr: List[int])**: Initialize the class with an integer array `arr`. 2. **build_prefix_sum(self) -> None**: Build the prefix sum array from the input array. 3. **get_sum(self, left: int, right: int) -> int**: Return the sum of elements between indices `left` and `right` (inclusive). 4. **update(self, index: int, value: int) -> None**: Update the element at `index` with the new `value`, and update the prefix sum array accordingly. # Requirements: * The input array `arr` will contain integers. * The `left` and `right` indices in the `get_sum` method will always be valid and within the bounds of the array. * The `index` in the `update` method will always be valid and within the bounds of the array. * Your implementation should maintain efficient performance for both queries and updates. # Example: ```python from typing import List class PrefixSumArray: def __init__(self, arr: List[int]): self.arr = arr self.prefix_sum = [0] * len(arr) self.build_prefix_sum() def build_prefix_sum(self) -> None: self.prefix_sum[0] = self.arr[0] for i in range(1, len(self.arr)): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.arr[i] def get_sum(self, left: int, right: int) -> int: if left == 0: return self.prefix_sum[right] else: return self.prefix_sum[right] - self.prefix_sum[left - 1] def update(self, index: int, value: int) -> None: original_value = self.arr[index] difference = value - original_value self.arr[index] = value for i in range(index, len(self.arr)): self.prefix_sum[i] += difference # Example usage: psa = PrefixSumArray([1, 2, 3, 4, 5]) assert psa.get_sum(1, 3) == 9 # Sum of elements from index 1 to 3: 2 + 3 + 4 psa.update(2, 10) # Update index 2 with value 10 -> array becomes [1, 2, 10, 4, 5] assert psa.get_sum(1, 3) == 16 # Sum of elements from index 1 to 3: 2 + 10 + 4 ``` Implement the class `PrefixSumArray` with the specified methods using efficient techniques for maintaining and querying prefix sums.","solution":"from typing import List class PrefixSumArray: def __init__(self, arr: List[int]): self.arr = arr self.prefix_sum = [0] * len(arr) self.build_prefix_sum() def build_prefix_sum(self) -> None: self.prefix_sum[0] = self.arr[0] for i in range(1, len(self.arr)): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.arr[i] def get_sum(self, left: int, right: int) -> int: if left == 0: return self.prefix_sum[right] else: return self.prefix_sum[right] - self.prefix_sum[left - 1] def update(self, index: int, value: int) -> None: original_value = self.arr[index] difference = value - original_value self.arr[index] = value for i in range(index, len(self.arr)): self.prefix_sum[i] += difference"},{"question":"# Problem Statement: You are tasked with implementing a simplified simulator for a basic RPN (Reverse Polish Notation) calculator. An RPN calculator uses postfix notation wherein every operator follows all of its operands. # Detailed Requirements: 1. Create a class `RPNCalculator` with the following methods: * `evaluate(self, expression: str) -> float`: Accepts a space-separated `expression` in RPN and returns the calculated result as a float. 2. The calculator should support the following operators: * Addition: `+` * Subtraction: `-` * Multiplication: `*` * Division: `/` 3. Constraints: * Assume the `expression` contains only valid operators and operands. * All operands are valid numeric values. * The `expression` will be a valid RPN expression containing operators and operands separated by spaces. * The calculator should perform division as floating point division. 4. Input and Output formats: * The method will receive a string as input representing the RPN expression and will return a float as the computed result. * Sample input: `evaluate(\\"3 4 + 2 * 7 /\\")` * Sample output: `2.0` # Performance: * The `evaluate` method should execute with linear time complexity O(n), where n is the number of tokens (operators and operands) in the expression. * Memory usage should be minimal and proportional to the number of tokens in the expression. # Example: ```python # Sample usage of the RPNCalculator class calculator = RPNCalculator() # Evaluation result = calculator.evaluate(\\"3 4 + 2 * 7 /\\") print(result) # Output: 2.0 ``` Implement the `RPNCalculator` class to pass the test upon running the provided example.","solution":"class RPNCalculator: def evaluate(self, expression: str) -> float: stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) else: stack.append(float(token)) return stack[0]"},{"question":"# Scenario: You are working on a text-based application where efficient manipulation and searching of text is crucial. One key feature involves determining the frequency of specific words and identifying common prefixes. The goal is to design a data structure that can handle these operations effectively. # Task: Given a static list of strings representing a large document or dataset, implement a data structure (Trie) that supports the following operations efficiently: 1. **Word Frequency Query**: Return the number of occurrences of a particular word. 2. **Prefix Query**: Return all words with a given prefix. 3. **Word Insertion**: Add a new word to the dataset. # Implementation Requirements: 1. **Function Definitions**: - `insert_word(trie: Trie, word: str) -> None`: Inserts a word into the Trie. - `word_frequency(trie: Trie, word: str) -> int`: Returns the number of occurrences of a specified word. - `find_with_prefix(trie: Trie, prefix: str) -> list[str]`: Returns a list of words that start with the given prefix. 2. **Input**: - A list of strings representing the document or dataset. - Parameters for the functions include the word to be inserted or searched, and the prefix to find words with. 3. **Output**: - Return values based on specified function requirements, including counts or lists of words. 4. **Constraints**: - All words are comprised of lowercase alphabetic characters. - Words and prefixes provided in queries are valid and present in the dataset. - The dataset may be large, with up to 100,000 words. # Example: ```python document = [ \\"hello\\", \\"world\\", \\"helium\\", \\"hexagon\\", \\"hero\\", \\"helicopter\\", \\"hermit\\", \\"here\\", \\"hear\\", \\"heap\\", \\"herd\\", \\"herr\\", \\"helicopter\\" ] trie = Trie() for word in document: insert_word(trie, word) print(word_frequency(trie, \\"helicopter\\")) # Output: 2 print(find_with_prefix(trie, \\"hel\\")) # Output: [\\"hello\\", \\"helium\\", \\"helicopter\\", \\"helicopter\\"] print(find_with_prefix(trie, \\"her\\")) # Output: [\\"hero\\", \\"hermit\\", \\"here\\", \\"herd\\", \\"herr\\"] ``` Implement the above functions ensuring efficient Trie operations, and consider edge cases such as words with common prefixes.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.frequency = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True node.frequency += 1 def query_frequency(self, word): node = self.root for char in word: if char not in node.children: return 0 node = node.children[char] return node.frequency if node.is_end_of_word else 0 def search_prefix(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._collect_words_from_node(node, prefix) def _collect_words_from_node(self, node, prefix): words = [] if node.is_end_of_word: for _ in range(node.frequency): words.append(prefix) for char, next_node in node.children.items(): words.extend(self._collect_words_from_node(next_node, prefix + char)) return words def insert_word(trie, word): trie.insert(word) def word_frequency(trie, word): return trie.query_frequency(word) def find_with_prefix(trie, prefix): return trie.search_prefix(prefix)"},{"question":"# Array Sum With Divisors **Context**: As a data analyst, you often work with large datasets involving lists and arrays. One common task is to derive meaningful statistics based on specified criteria. In this particular task, you need to apply a specific mathematical operation to a list of numbers. **Problem Statement**: Write a function `array_sum_with_divisors` that calculates the sum of all elements within a given list that are divisible by a specified integer. If no elements are divisible by the specified integer, the function should return 0. # Function Signature ```python def array_sum_with_divisors(numbers: List[int], divisor: int) -> int: pass ``` # Input - **numbers (List[int])**: A list of integers. - **divisor (int)**: An integer divisor. # Output - **int**: The sum of the elements in the list that are divisible by the divisor. # Constraints 1. The list `numbers` can have up to 10^5 elements. 2. Each element in `numbers` will be an integer between -10^6 and 10^6. 3. The `divisor` is a non-zero integer between 1 and 10^6. # Examples ```python print(array_sum_with_divisors([1, 2, 3, 4, 5, 6], 2)) # Output: 12 print(array_sum_with_divisors([10, 15, 20, 25], 5)) # Output: 70 print(array_sum_with_divisors([1, 3, 5, 7], 10)) # Output: 0 ``` # Notes * The function should be efficient to handle lists with large numbers of elements. * Consider edge cases where all elements are negative or where no elements are divisible by the given divisor.","solution":"from typing import List def array_sum_with_divisors(numbers: List[int], divisor: int) -> int: Calculate the sum of all elements in the list that are divisible by `divisor`. :param numbers: List[int] - A list of integers. :param divisor: int - The integer divisor. :return: int - The sum of the elements in the list that are divisible by divisor. return sum(num for num in numbers if num % divisor == 0)"},{"question":"# Scenario: You are working on a software project that involves organizing a collection of documents based on their word usage. Each document is represented as a string, and you need to determine the frequency of each word for analytics purposes. Some words in this context are considered \\"stop words\\" and should be excluded from the frequency count. # Task: Write a function named `word_frequency` that calculates the frequency of each word in a given string, excluding a specified set of stop words. The function should return a dictionary where the keys are words (excluding stop words), and the values are the corresponding frequencies. - Words should be treated case-insensitively (\\"Word\\" and \\"word\\" should be counted as the same word). - The words in the resulting dictionary should be in lowercase. - Punctuation should be ignored (e.g., \\"word,\\" should be counted as \\"word\\"). - If a word appears in the stop words list, it should not be included in the frequency count. # Input: - A string representing the document text: `document` (string) - A list of stop words: `stop_words` (list of strings) # Output: - A dictionary with words as keys and their frequencies as values (dictionary of string: int) # Constraints: - The document may contain any ASCII characters and is guaranteed to have at most 100,000 characters. - The list of stop words may contain any ASCII characters and can have up to 10,000 words. - Ignore case differences and punctuation in the document. - Words are defined as sequences of characters separated by whitespace or punctuation. # Example: ```python >>> word_frequency(\\"Hello world! This is a test document. This document is just a test.\\", [\\"is\\", \\"a\\", \\"this\\"]) {\'hello\': 1, \'world\': 1, \'test\': 2, \'document\': 2, \'just\': 1} >>> word_frequency(\\"Python programming is great. Python is fun. Fun for everyone!\\", [\\"is\\", \\"for\\"]) {\'python\': 2, \'programming\': 1, \'great\': 1, \'fun\': 2, \'everyone\': 1} >>> word_frequency(\\"\\", [\\"a\\", \\"the\\", \\"is\\"]) {} ``` Ensure your solution handles the edge cases and constraints specified.","solution":"import re from collections import defaultdict def word_frequency(document, stop_words): Calculate the frequency of each word in the document, excluding stop words. Args: - document (str): The text of the document. - stop_words (list of str): The list of stop words to exclude from the count. Returns: - dict: A dictionary where keys are words and values are their frequencies. # Convert the document to lowercase document = document.lower() # Create a set of stop words for faster lookup stop_words_set = set(stop_words) # Use regex to find all words (sequences of alphabetic characters) words = re.findall(r\'bw+b\', document) # Initialize a default dictionary to count the words frequency = defaultdict(int) # Count the frequency of each word, excluding stop words for word in words: if word not in stop_words_set: frequency[word] += 1 return dict(frequency)"},{"question":"# Implement Custom LinkedList Class with Basic Operations Scenario: You have been hired to implement a custom LinkedList class, a fundamental data structure used in various applications. This LinkedList class must support basic operations like insertion, deletion, search, and displaying the linked list. Task: Implement a `LinkedList` class that provides the following functionalities: 1. `insert(value: int)` â€“ Insert a new node with the given value at the end of the list. 2. `delete(value: int)` â€“ Delete the node with the given value from the list. Raise a `ValueError` if the value is not found. 3. `search(value: int) -> bool` â€“ Search for the node with the given value in the list. Return `True` if found, `False` otherwise. 4. `display() -> str` â€“ Return a string representation of the list in the format \\"value1 -> value2 -> value3\\". Class Definition: ```python class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value: int) -> None: Insert a new node with the given value at the end of the list. :param int value: Value to insert new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete(self, value: int) -> None: Delete the node with the given value from the list. :param int value: Value to delete :raises ValueError: if value is not found in the list current = self.head if current is None: raise ValueError(f\\"{value} not found in the list.\\") if current.value == value: self.head = current.next return prev = None while current and current.value != value: prev = current current = current.next if current is None: raise ValueError(f\\"{value} not found in the list.\\") prev.next = current.next def search(self, value: int) -> bool: Search for the node with the given value in the list. :param int value: Value to search :return bool: True if found, False otherwise current = self.head while current: if current.value == value: return True current = current.next return False def display(self) -> str: Return a string representation of the list. :return str: String representation of the list values = [] current = self.head while current: values.append(str(current.value)) current = current.next return \\" -> \\".join(values) ``` Examples: ```python >>> # Initialize a LinkedList and perform operations >>> ll = LinkedList() >>> ll.insert(10) >>> ll.insert(20) >>> ll.insert(30) >>> ll.display() \'10 -> 20 -> 30\' >>> ll.search(20) True >>> ll.search(40) False >>> ll.delete(20) >>> ll.display() \'10 -> 30\' >>> ll.delete(40) Traceback (most recent call last): ... ValueError: 40 not found in the list. >>> ll.display() \'10 -> 30\' >>> ll.delete(10) >>> ll.display() \'30\' ``` Constraints: - The values to be inserted or deleted will always be integers. - Ensure that the `delete` method raises a `ValueError` with the message \\"value not found in the list\\" if the value is not found. - The `display` method should provide a clear string representation of the current state of the linked list. Performance Requirements: - Operations should be efficient and handle edge cases like empty lists appropriately. - Although searching in a linked list can have O(n) time complexity, ensure the implementation is clear and concise.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value: int) -> None: Insert a new node with the given value at the end of the list. :param int value: Value to insert new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete(self, value: int) -> None: Delete the node with the given value from the list. :param int value: Value to delete :raises ValueError: if value is not found in the list current = self.head if current is None: raise ValueError(f\\"{value} not found in the list.\\") if current.value == value: self.head = current.next return prev = None while current and current.value != value: prev = current current = current.next if current is None: raise ValueError(f\\"{value} not found in the list.\\") prev.next = current.next def search(self, value: int) -> bool: Search for the node with the given value in the list. :param int value: Value to search :return bool: True if found, False otherwise current = self.head while current: if current.value == value: return True current = current.next return False def display(self) -> str: Return a string representation of the list. :return str: String representation of the list values = [] current = self.head while current: values.append(str(current.value)) current = current.next return \\" -> \\".join(values)"},{"question":"# Problem Statement You are required to write a function that takes an encoded string as input and returns its decoded version. The encoding technique used is \'Run Length Encoding\' (RLE) where consecutive characters are stored as a single character and an integer representing the character\'s frequency. Function Signature ```python def decode_rle(encoded_string: str) -> str: ``` Input * **encoded_string (str)**: A string representing the Run Length Encoded data, e.g., \\"a2b1c5a3\\". Output * **(str)**: A string that represents the decoded version of the input string. Constraints * `encoded_string` must follow the RLE format, with characters followed by their frequencies. If the format is invalid, the function should raise a `ValueError`. * The frequency values will always be greater than 0 and less than 100. Performance Requirements * The function should be optimized to run in linear time relative to the length of the input string. Examples ```python >>> decode_rle(\\"a2b1c5a3\\") \'aabcccccaaa\' >>> decode_rle(\\"x5y3z2\\") \'xxxxxyyyzz\' >>> decode_rle(\\"a\\") Traceback (most recent call last): ... ValueError: Invalid RLE format >>> decode_rle(\\"b2a0\\") Traceback (most recent call last): ... ValueError: Invalid RLE format ``` Context This function will help in scenarios where compressed data using RLE needs to be expanded back to its original form. It can be useful in data storage and transmission where reducing data size is critical, but decompression is required for processing. Ensure your solution correctly implements the steps mentioned and passes all test cases, including handling invalid formats appropriately.","solution":"def decode_rle(encoded_string: str) -> str: Decodes a string encoded with Run Length Encoding (RLE). :param encoded_string: str - The RLE encoded string :return: str - The decoded string Raises ValueError if the encoded_string format is invalid. decoded_string = [] i = 0 n = len(encoded_string) while i < n: # The current char if not encoded_string[i].isalpha(): raise ValueError(\'Invalid RLE format\') char = encoded_string[i] i += 1 # Extract the consecutive number num = 0 if i < n and encoded_string[i].isdigit(): while i < n and encoded_string[i].isdigit(): num = num * 10 + int(encoded_string[i]) i += 1 else: raise ValueError(\'Invalid RLE format\') # Check if extracted number is valid if num <= 0: raise ValueError(\'Invalid RLE format\') # Append the decoded part decoded_string.append(char * num) return \'\'.join(decoded_string)"},{"question":"# File System Path Normalization You are tasked with implementing a function that normalizes a given file system path. The path may contain redundant elements such as `\\".\\"` (current directory), `\\"..\\"` (parent directory), and multiple consecutive slashes. Your function should convert the path into its simplest form. Input Format: - A single string representing the file system path. Output Format: - The output should be the normalized file system path as a string. Constraints: - The path will comply with UNIX-style file systems. - The input path is an absolute path that begins with a slash (`/`). - The path contains only ASCII characters. Example Assume the following file path is given: ``` \\"/a/./b/../../c/\\" ``` Your normalization function should produce: ``` \\"/c\\" ``` Another example: ``` \\"/home//foo/\\" ``` Your result should be: ``` \\"/home/foo\\" ``` Function Signature: ```python def normalize_path(path: str) -> str: pass ``` # Explanation: - `\\".\\"` refers to the current directory and can be removed. - `\\"..\\"` moves to the parent directory and should remove the previous directory from the path. - Consecutive slashes should be replaced by a single slash. The goal is to ensure the functionality works correctly and efficiently, conforming to the constraints and handling edge cases gracefully.","solution":"def normalize_path(path: str) -> str: Normalize the given file system path. parts = [] for part in path.split(\'/\'): if part == \'..\': if parts: parts.pop() elif part and part != \'.\': parts.append(part) return \'/\' + \'/\'.join(parts)"},{"question":"# Problem: Prime Factorization Counter You are tasked with writing a function that counts the total number of prime factors (including multiplicities) of a given positive integer ( n ). Given the following requirements: 1. Implement a function `count_prime_factors` that: - Accepts an integer ( n ) as input. - Returns the total number of prime factors of ( n ). # Input Format: - An integer ( n ) (1 â‰¤ ( n ) â‰¤ 10^9). # Output Format: - A single integer representing the total number of prime factors of ( n ). # Function Signature ```python def count_prime_factors(n: int) -> int: pass ``` # Example: ```python assert count_prime_factors(18) == 3 # 18 = 2 * 3 * 3 assert count_prime_factors(100) == 4 # 100 = 2 * 2 * 5 * 5 assert count_prime_factors(37) == 1 # 37 is a prime number assert count_prime_factors(60) == 4 # 60 = 2 * 2 * 3 * 5 ``` # Explanation: - For ( n = 18 ), the prime factorization is ( 2 times 3 times 3 ), so the count is 3. - For ( n = 100 ), the prime factorization is ( 2 times 2 times 5 times 5 ), so the count is 4. - For ( n = 37 ), since 37 is a prime number, the count is 1. - For ( n = 60 ), the prime factorization is ( 2 times 2 times 3 times 5 ), so the count is 4. # Constraints - Your solution should be efficient. - Pay attention to the time complexity, especially for larger values of ( n ).","solution":"def count_prime_factors(n: int) -> int: count = 0 # Check for number of 2s in the factorization and count them while n % 2 == 0: count += 1 n //= 2 # now check for odd factors from 3 onwards till sqrt(n) factor = 3 while factor * factor <= n: while n % factor == 0: count += 1 n //= factor factor += 2 # If n is still greater than 2, then it must be a prime number if n > 2: count += 1 return count"},{"question":"# Problem: You have been given a string that contains a sentence with some characters replaced by the character \'#\'. The task is to replace each \'#\' with a lowercase letter in such a way that no two identical letters are adjacent to each other. If there are multiple valid solutions, any one of them can be returned. # Objective: Implement the function `replace_hashes(sentence: str) -> str` that takes the input sentence and returns a string where all \'#\' characters are replaced to ensure no two identical letters are adjacent. # Function Signature: ```python def replace_hashes(sentence: str) -> str: ``` # Input: - `sentence`: A string containing the sentence with \'#\' characters. (1 <= len(sentence) <= 1000) # Output: - A modified string where all \'#\' characters have been replaced with lowercase letters such that no two identical letters are adjacent. If there are multiple valid solutions, any one of them can be returned. # Example: ```python input_sentence = \\"ab#c#ef#g#\\" output = replace_hashes(input_sentence) # Possible output: \\"abcddefgfh\\" (or any valid solution where no two adjacent letters are the same) ``` # Constraints: - The input sentence will only contain lowercase letters and \'#\' characters. - The returned string should have exactly the same non-# characters as the input. - You can assume that it is always possible to replace \'#\' characters to meet the criteria. # Guidance: In your function: 1. Identify positions of \'#\' characters in the string. 2. Determine possible replacements for each \'#\' considering surrounding characters. 3. Construct the final string ensuring that no two identical letters are adjacent. 4. Return the modified string.","solution":"def replace_hashes(sentence: str) -> str: import string import random letters = string.ascii_lowercase sentence = list(sentence) for i in range(len(sentence)): if sentence[i] == \'#\': candidates = set(letters) if i > 0 and sentence[i-1] != \'#\': candidates.discard(sentence[i-1]) if i < len(sentence) - 1 and sentence[i+1] != \'#\': candidates.discard(sentence[i+1]) sentence[i] = random.choice(list(candidates)) return \'\'.join(sentence)"},{"question":"# Coding Question: Consecutive Sum Check You are required to implement a function that determines whether a given integer `n` can be expressed as the sum of at least two consecutive positive integers. Consecutive Sum Definition A number `n` can be represented as the sum of two or more consecutive positive integers if and only if there exist integers `a` and `k` such that: [ n = a + (a+1) + (a+2) + ... + (a+k-1) ] Input and Output Format * **Input**: An integer `n`. * **Output**: A boolean value `True` if `n` can be expressed as the sum of at least two consecutive positive integers, otherwise `False`. Example ```python >>> consecutive_sum_check(15) True >>> consecutive_sum_check(10) True >>> consecutive_sum_check(6) True >>> consecutive_sum_check(8) False >>> consecutive_sum_check(1) False ``` Constraints - (1 leq n leq 10^9) Function Signature ```python def consecutive_sum_check(n: int) -> bool: pass ``` Implement the function `consecutive_sum_check(n: int) -> bool` to solve the problem as described.","solution":"def consecutive_sum_check(n: int) -> bool: Determine if the integer n can be expressed as the sum of at least two consecutive positive integers. # Check if n is greater than 1, as 1 cannot be expressed as the sum of consecutive positive integers. if n <= 1: return False # Check for all possible lengths of sequences (starting from 2) k = 2 while (k * (k + 1)) // 2 <= n: if (n - (k * (k + 1)) // 2) % k == 0: return True k += 1 return False"},{"question":"# Maximum Subarray Sum with Divide and Conquer **Problem Statement**: Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Implement this using the divide and conquer approach to achieve O(n log n) time complexity. Write a function `max_subarray_sum(nums: list[int]) -> int` that implements this logic. **Function Signature**: ```python from typing import List def max_subarray_sum(nums: List[int]) -> int: ``` **Input**: - `nums`: A list of integers, could contain positive and/or negative numbers (e.g., [-2,1,-3,4,-1,2,1,-5,4]). **Output**: - An integer representing the largest sum of the contiguous subarray. **Constraints**: - The length of `nums` is at least 1 and at most 10^6. - Each element in `nums` is an integer within the range [-10^6, 10^6]. **Examples**: ```python assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 assert max_subarray_sum([1]) == 1 assert max_subarray_sum([5,4,-1,7,8]) == 23 assert max_subarray_sum([-1,-2,-3,-4,-5]) == -1 assert max_subarray_sum([4,-1,2,1]) == 6 assert max_subarray_sum([1,2,3,4,5]) == 15 assert max_subarray_sum([-3,-2,-1]) == -1 assert max_subarray_sum([3,-1,2,-1,2,-1,2,1]) == 7 ``` **Explanation**: 1. `max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4])` returns `6` because `[4,-1,2,1]` is the subarray with the maximum sum. 2. `max_subarray_sum([1])` returns `1` because `[1]` is the only subarray. 3. `max_subarray_sum([5,4,-1,7,8])` returns `23` because subarray `[5,4,-1,7,8]` sums to `23`. 4. `max_subarray_sum([-1,-2,-3,-4,-5])` returns `-1` because the maximum sum, even though all negative, is the least negative single element. 5. `max_subarray_sum([4,-1,2,1])` returns `6` because `[4,-1,2,1]` sums to `6`. 6. `max_subarray_sum([1,2,3,4,5])` returns `15` because subarray `[1,2,3,4,5]` sums to `15`. 7. `max_subarray_sum([-3,-2,-1])` returns `-1` because the maximum sum, even though negative, is the least negative single element. 8. `max_subarray_sum([3,-1,2,-1,2,-1,2,1])` returns `7` because `[3,-1,2,-1,2,-1,2,1]` sums to `7`.","solution":"from typing import List def max_crossing_sum(nums: List[int], left: int, mid: int, right: int) -> int: left_sum = float(\'-inf\') total = 0 for i in range(mid, left - 1, -1): total += nums[i] if total > left_sum: left_sum = total right_sum = float(\'-inf\') total = 0 for i in range(mid + 1, right + 1): total += nums[i] if total > right_sum: right_sum = total return left_sum + right_sum def max_subarray_sum_util(nums: List[int], left: int, right: int) -> int: if left == right: return nums[left] mid = (left + right) // 2 left_sum = max_subarray_sum_util(nums, left, mid) right_sum = max_subarray_sum_util(nums, mid + 1, right) crossing_sum = max_crossing_sum(nums, left, mid, right) return max(left_sum, right_sum, crossing_sum) def max_subarray_sum(nums: List[int]) -> int: return max_subarray_sum_util(nums, 0, len(nums) - 1)"},{"question":"You are given a string containing an arithmetic expression with non-negative integers and the `+` and `*` operators. Your task is to evaluate this expression in the conventional way (i.e., with the correct operator precedence). # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input * A string `expression` consisting of non-negative integers and `+` and `*` operators. There will be no spaces within the string. # Output * An integer which is the result of evaluating the arithmetic expression. # Example ```python # Example 1 assert evaluate_expression(\\"3+5*2\\") == 13 # Example 2 assert evaluate_expression(\\"6+2*3+1\\") == 13 # Example 3 assert evaluate_expression(\\"4*3+2*1\\") == 14 # Example 4 assert evaluate_expression(\\"0*0+0\\") == 0 # Example 5 (Edge Case) assert evaluate_expression(\\"2+3+4\\") == 9 ``` # Constraints * The implementation should handle the order of operations correctly (`*` has higher precedence than `+`). * Assume the input expression will always be valid and properly formatted. * You should not use any built-in `eval` function or any other high-level library function to directly evaluate the expression. # Description The task aims to assess your ability to parse and evaluate a simple arithmetic expression while correctly applying operator precedence rules. This problem involves string parsing, following the precedence rules for arithmetic operators, and performing the necessary calculations. Parsing arithmetic expressions is a common task in various domains such as compilers (which parse and interpret code), spreadsheets (which calculate cell values based on expressions), and calculators. # Additional Notes * Implementing a simple algorithm to parse and evaluate the expression is expected. * Ensure clarity in code through appropriate variable names and comments, especially where handling operator precedence. * Consider leveraging data structures such as stacks if needed for managing intermediate results and operators.","solution":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression containing non-negative integers and \'+\' and \'*\' operators, respecting the conventional operator precedence. def compute(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'*\': values.append(left * right) operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): value = 0 while i < len(expression) and expression[i].isdigit(): value = value * 10 + int(expression[i]) i += 1 values.append(value) i -= 1 elif expression[i] == \'+\': while operators and operators[-1] in (\'+\', \'*\'): compute(operators, values) operators.append(\'+\') elif expression[i] == \'*\': while operators and operators[-1] == \'*\': compute(operators, values) operators.append(\'*\') i += 1 while operators: compute(operators, values) return values[0]"},{"question":"# Coding Question: Sentence Reversal and Word Count Analysis Objective: You are given a function that reverses words in a sentence and another function that counts the words. Your task is to enhance these functions and write a new function that works with both to solve a given problem. Problem Statement: Write a function `analyze_sentence(sentence: str) -> tuple` that takes as input a sentence (a string of words separated by spaces). This function should return a tuple containing: 1. A string with words in reversed order. 2. The count of words in the sentence. Function Signature: ```python def analyze_sentence(sentence: str) -> tuple: pass ``` Expected Input and Output: - **Input**: A string representing a sentence (e.g., \\"hello world\\") - **Output**: A tuple (`str`, `int`) where the first element is the reversed sentence and the second element is the word count. Constraints: - The input string will contain letters (both uppercase and lowercase) and spaces only. - The words in the input string are separated by a single space. - The sentence will contain at least one word. Performance Requirements: - Time complexity should be O(n) - Space complexity should be O(n) Example: ```python >>> analyze_sentence(\\"hello world\\") (\\"world hello\\", 2) >>> analyze_sentence(\\"The quick brown fox\\") (\\"fox brown quick The\\", 4) >>> analyze_sentence(\\"single\\") (\\"single\\", 1) ``` Additional Requirements: - Reuse and enhance the provided functions `reverse_words` and `count_words`. - Handle improper input by raising an appropriate ValueError with a descriptive message. # Provided Functions: ```python def reverse_words(sentence: str) -> str: return \' \'.join(sentence.split()[::-1]) def count_words(sentence: str) -> int: return len(sentence.split()) def analyze_sentence(sentence: str) -> tuple: if not isinstance(sentence, str): raise ValueError(\\"Input must be a string\\") reversed_sentence = reverse_words(sentence) word_count = count_words(sentence) return (reversed_sentence, word_count) ```","solution":"def reverse_words(sentence: str) -> str: Reverses the words in a sentence. return \' \'.join(sentence.split()[::-1]) def count_words(sentence: str) -> int: Counts the words in a sentence. return len(sentence.split()) def analyze_sentence(sentence: str) -> tuple: Analyzes a sentence to provide a reversed sentence and the word count. Parameters: sentence (str): The sentence to analyze. Returns: tuple: A tuple containing the reversed sentence and the word count. if not isinstance(sentence, str): raise ValueError(\\"Input must be a string\\") if not sentence.strip(): raise ValueError(\\"Input cannot be an empty string or just spaces\\") reversed_sentence = reverse_words(sentence) word_count = count_words(sentence) return (reversed_sentence, word_count)"},{"question":"Question Your task is to implement a function that generates the first `n` prime numbers in the Fibonacci sequence and calculates their sum. Specifically, you will: 1. Generate Fibonacci numbers until you have `n` prime numbers. 2. Return the sum of the first `n` prime Fibonacci numbers. # Function Signature ```python def sum_of_prime_fibonacci_numbers(n: int) -> int: Calculate the sum of the first n prime Fibonacci numbers. ``` # Input - `n` (int): The number of prime Fibonacci numbers to sum. # Output - Returns the sum of the first `n` prime Fibonacci numbers. # Example ```python sum_of_prime_fibonacci_numbers(3) # Expected Output: 19 (The first 3 prime Fibonacci numbers are 2, 3, 5 and their sum is 10) sum_of_prime_fibonacci_numbers(5) # Expected Output: 41 (The first 5 prime Fibonacci numbers are 2, 3, 5, 13, 89 and their sum is 112) ``` # Constraints * Ensure the implementation accurately identifies prime numbers. * Handle potential performance issues with generating large Fibonacci numbers. # Scenario Imagine you are writing a piece of code for a mathematical research project. You need to identify and sum the first `n` prime numbers within the Fibonacci sequence to analyze their distribution. This function is a critical piece of your analysis toolset.","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True # 2 is the only even prime number if num % 2 == 0: return False # other even numbers are not primes for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def generate_fibonacci(): Generate Fibonacci numbers indefinitely. a, b = 0, 1 while True: yield a a, b = b, a + b def sum_of_prime_fibonacci_numbers(n: int) -> int: Calculate the sum of the first n prime Fibonacci numbers. prime_fibs = [] fib_gen = generate_fibonacci() while len(prime_fibs) < n: fib = next(fib_gen) if is_prime(fib): prime_fibs.append(fib) return sum(prime_fibs)"},{"question":"# Coding Assessment Question Background: Given an array of integers, your task is to count the number of subarrays that have a sum equal to a given target value. Task: Write a function `countSubarraysWithSum(nums: List[int], target: int) -> int` that returns the number of contiguous subarrays that sum to the specified target value. Input: - A list of integers `nums` representing the array. - An integer `target` representing the target sum. Output: - An integer representing the number of subarrays with the sum equal to `target`. Constraints: - The length of the array is in the range `[1, 20000]`. - Each array element\'s value is in the range `[-1000, 1000]`. - The target value is an integer in the range `[-1000000, 1000000]`. Performance Requirements: - Your solution should aim for a time complexity of `O(N)`, where N is the length of the array. - Space complexity should be `O(N)`. Example: ```python # Example 1: nums = [1, 1, 1] target = 2 print(countSubarraysWithSum(nums, target)) # Output: 2 # Example 2: nums = [10, 2, -2, -20, 10] target = -10 print(countSubarraysWithSum(nums, target)) # Output: 3 # Example 3: nums = [1, 2, 3, 4, 5] target = 9 print(countSubarraysWithSum(nums, target)) # Output: 2 ``` Implementation: Based on the provided code snippet, implement the function following the structure and properties discussed.","solution":"from typing import List def countSubarraysWithSum(nums: List[int], target: int) -> int: Returns the number of contiguous subarrays that sum to the specified target value. count = 0 current_sum = 0 prefix_sums = {0: 1} # Initialize with 0 sum having one count for num in nums: current_sum += num if (current_sum - target) in prefix_sums: count += prefix_sums[current_sum - target] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"# Objective Simulate a basic scheduling algorithm to handle tasks based on their priority and arrival time. # Scenario In this problem, you need to implement a class `TaskScheduler` that manages tasks in a priority queue, allowing for efficient task execution based on their priority and arrival order. This will emphasize your understanding of data structures, particularly heaps/priority queues, and task management algorithms. # Task - Implement the `TaskScheduler` class with the following methods: 1. `__init__(self) -> None`: Initializes an empty task scheduler. 2. `add_task(self, task_id: int, priority: int, arrival_time: int) -> None`: Adds a new task to the scheduler. 3. `execute_next_task(self) -> int`: Executes and returns the `task_id` of the highest priority (and earliest arrival) task. 4. `peek_next_task(self) -> int`: Returns the `task_id` of the highest priority (and earliest arrival) task without removing it from the scheduler. # Implementation Details 1. **Characteristics**: - Use a priority queue (min-heap) to manage tasks, where tasks are ordered first by their priority and then by their arrival time for tasks with the same priority. - Each task will have a unique `task_id`, an integer `priority` (lower values indicating higher priority), and an `arrival_time` (an integer representing when the task was added). 2. **Input/Output**: - `__init__`: Initializes the scheduler. - Input: None - Output: None - `add_task`: Adds a task to the scheduler. - Input: task_id: int, priority: int, arrival_time: int - Output: None - `execute_next_task`: Removes and returns the `task_id` of the highest priority task. - Input: None - Output: task_id: int - `peek_next_task`: Returns the `task_id` of the highest priority task without removing it. - Input: None - Output: task_id: int 3. **Constraints**: - Assume a reasonable maximum number of tasks (e.g., 1000 tasks). - Task priorities will be non-negative integers. - Arrival times will be non-negative integers and will increase with each `add_task` call. # Example ```python scheduler = TaskScheduler() scheduler.add_task(1, 2, 0) scheduler.add_task(2, 1, 1) assert scheduler.peek_next_task() == 2 # Task 2 has higher priority assert scheduler.execute_next_task() == 2 # Execute task 2 assert scheduler.execute_next_task() == 1 # Execute task 1 ``` 4. **Performance Requirements**: - The solution should efficiently handle task additions and retrievals using the appropriate data structures (min-heap for priority queue). # Note Consider the prioritization logic carefully: tasks with lower priority values are processed before tasks with higher priority values. For tasks with the same priority, the task that arrived earlier should be processed first.","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] self.entry_count = 0 def add_task(self, task_id: int, priority: int, arrival_time: int) -> None: heapq.heappush(self.heap, (priority, arrival_time, task_id)) self.entry_count += 1 def execute_next_task(self) -> int: if not self.heap: raise IndexError(\\"No tasks to execute\\") priority, arrival_time, task_id = heapq.heappop(self.heap) return task_id def peek_next_task(self) -> int: if not self.heap: raise IndexError(\\"No tasks to peek\\") priority, arrival_time, task_id = self.heap[0] return task_id"},{"question":"# Problem Statement: Replace Elements with Greatest Element on Right Side Given an array `arr` of `n` integers, you need to replace every element in the array with the greatest element among the elements to its right, and replace the last element with -1. Write a function `replaceElements(arr: List[int]) -> List[int]` that performs this task. # Requirements 1. Implement a function `replaceElements(arr: List[int]) -> List[int]` that: - Accepts a list of integers `arr`. - Replaces every element in the array with the greatest element among the elements to its right, and replaces the last element with -1. - Returns the updated list. # Function Signature ```python def replaceElements(arr: List[int]) -> List[int]: pass ``` # Example - `replaceElements([17, 18, 5, 4, 6, 1])` should return `[18, 6, 6, 6, 1, -1]`. - `replaceElements([400])` should return `[-1]`. # Constraints: - The array `arr` will contain at least one element. - The number of elements in `arr` will be less than or equal to `10^4`. - Each element of `arr` will be an integer in the range `0 <= arr[i] <= 10^5`. # Testing & Evaluation Criteria: - Correctness: The solution should provide accurate results for provided test cases. - Efficiency: The function should be optimized to run in linear time. - Robustness: The solution should handle edge cases appropriately.","solution":"from typing import List def replaceElements(arr: List[int]) -> List[int]: n = len(arr) if n == 0: return [] # Initialize the greatest element from the right to -1 greatest = -1 # Traverse the list from right to left for i in range(n - 1, -1, -1): # Store the current element before replacing current = arr[i] # Replace current element with the greatest element so far arr[i] = greatest # Update the greatest element if current > greatest: greatest = current return arr"},{"question":"# Question You are required to implement a specific function related to the manipulation and analysis of a singly linked list. Problem Statement Given a singly linked list where each node contains an integer value, implement a function `remove_duplicates` that removes all duplicate values from the linked list. The function should modify the list in place and only retain distinct nodes. Function Signature ```python def remove_duplicates(head: ListNode | None) -> ListNode | None: ``` Input - `head` (ListNode | None): The head node of the singly linked list. It can be `None` if the list is empty. Output - `ListNode | None`: Return the head node of the modified linked list with all duplicates removed. Constraints 1. The number of nodes in the list is in the range [0, 10^5]. 2. Each node\'s value is in the range [-10^4, 10^4]. Example ```python # List structure: # 1 -> 1 -> 2 -> 3 -> 3 head = ListNode(1) head.next = ListNode(1) head.next.next = ListNode(2) head.next.next.next = ListNode(3) head.next.next.next.next = ListNode(3) modified_head = remove_duplicates(head) # Traversing the modified list print_list(modified_head) # Output: 1 -> 2 -> 3 ``` Requirements - Implement the `remove_duplicates` function ensuring that it properly removes all duplicate integers from the linked list and handles edge cases like an empty list, a list with a single unique value, and a list with all identical values. - Consider performance: the function should efficiently handle the upper limit of the constraints. Additional Note - The `ListNode` class is predefined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode | None) -> ListNode | None: if not head: return head current = head seen = set() seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"# Sum of Elements in a Spiral Order Context: You are tasked to develop a function that processes a 2D list of integers, representing a matrix, and returns the sum of its elements traversed in a spiral order. The traversal should start from the top-left corner and proceed inwards, following a clockwise direction. Problem Description: Write a function `spiral_matrix_sum` that takes a 2D list `matrix` and returns the sum of its elements when traversed in a spiral order. Function Signature: ```python def spiral_matrix_sum(matrix: list) -> int: ``` Input: - `matrix`: A 2D list of integers where `1 <= len(matrix), len(matrix[0]) <= 100`. - The matrix is guaranteed to be non-empty. Output: - An integer representing the sum of the matrix elements when traversed in a spiral order. Constraints: - The function must handle matrices with different shapes (e.g., square, rectangular). - No additional constraints on the values within the matrix elements. Examples: ```python >>> spiral_matrix_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 45 >>> spiral_matrix_sum([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) 136 >>> spiral_matrix_sum([ [7] ]) 7 >>> spiral_matrix_sum([ [1, 2], [3, 4], [5, 6], [7, 8] ]) 36 ``` Notes: - The traversal follows a spiral order: right, down, left, and up, repeating the process by extending inward. - Edge cases include matrices with only one row or one column. - Ensure the function efficiently processes the matrix and returns the correct sum.","solution":"def spiral_matrix_sum(matrix): Takes a 2D list (matrix) and returns the sum of its elements when traversed in a spiral order. if not matrix: return 0 top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 result = 0 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result += matrix[top][i] top += 1 # Traverse downwards for i in range(top, bottom + 1): result += matrix[i][right] right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result += matrix[bottom][i] bottom -= 1 if left <= right: # Traverse upwards for i in range(bottom, top - 1, -1): result += matrix[i][left] left += 1 return result"},{"question":"# Prime Factors Calculation **Problem Statement**: You are tasked with writing a function to compute all the prime factors of a given positive integer. Prime factors are the prime numbers that divide a given number exactly, without leaving a remainder. **Function Signature**: ```python def prime_factors(n: int) -> List[int]: Approach: - First, find the number of 2s that divide n. - Then, in a loop, try to divide n by all odd numbers starting from 3 up to the square root of n. - If n is still greater than 2 after the loop, then n itself is a prime factor. Params: - n (int): A positive integer whose prime factors are to be computed. Returns: - List[int]: A list of prime factors of n in ascending order. pass ``` **Input**: * `n` - A positive integer greater than 1. **Output**: * A list of integers representing the prime factors of `n`, in ascending order. **Constraints**: * `n > 1` * The function should handle large values of `n` efficiently. **Example**: ```python # Example use-case print(prime_factors(28)) # Output: [2, 2, 7] print(prime_factors(100)) # Output: [2, 2, 5, 5] print(prime_factors(37)) # Output: [37] print(prime_factors(315)) # Output: [3, 3, 5, 7] ``` **Note**: - Test your function with a variety of numbers to ensure correctness and efficiency. - Make sure to handle edge cases where `n` is a small prime number or a large composite number. - Consider using mathematical properties to optimize your solution, such as iterating only up to the square root of `n`.","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of prime factors of a given positive integer n in ascending order. factors = [] # First get the number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point, so we start from 3 and check till âˆšn for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n = n // i # If n is still a prime number and greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# File Organizer Script You are tasked with creating a file organizer script that sorts files in a given directory into subdirectories based on their file types. This script should take a directory path as input and then create subdirectories for each file type (e.g., `pdf`, `jpg`, `txt`, etc.), moving the files into their respective folder. Requirements: 1. **Function Definition**: ```python def organize_files(directory: str) -> dict: ``` 2. **Input**: * `directory` (str): A string representing the path to the directory that needs to be organized. 3. **Output**: * Returns a dictionary where each key is a file type and the value is the list of files moved to the subdirectory corresponding to the file type. 4. **Constraints**: * If a file does not have an extension, it should be moved to an \'unknown\' folder. * Handle any errors gracefully, ensure the script keeps running until all files are processed. * Maintain the original modified timestamps of the files. 5. **Performance Requirements**: * Ensure the function can efficiently handle directories with up to 1000 files. * Optimize file system I/O where necessary. Example: ```python directory_path = \\"C:/Users/Username/Documents/Downloads\\" result = organize_files(directory_path) # The \'result\' dictionary might look like: # { # \\"pdf\\": [\\"document1.pdf\\", \\"paper.pdf\\"], # \\"jpg\\": [\\"image1.jpg\\", \\"image2.jpg\\"], # \\"txt\\": [\\"notes.txt\\", \\"todo.txt\\"], # \\"unknown\\": [\\"README\\"], # } ``` Implementation Tips: * Use the `os` and `shutil` modules to manage file operations. * Ensure the directory paths are compatible across different operating systems. * Consider edge cases, such as files with no extension or files already existing in the target subdirectory. ----- This question maintains consistency in terms of style, length, difficulty, and scope with the sample question provided, focusing on another essential programming concept of file manipulation and organization.","solution":"import os import shutil from collections import defaultdict def organize_files(directory: str) -> dict: Organizes files in the specified directory into subdirectories based on their file types. Params: directory (str): The path to the directory to be organized. Returns: dict: A dictionary where the keys are file types and the values are lists of files moved to those subdirectories. # Ensure the directory exists if not os.path.isdir(directory): raise ValueError(f\\"The directory {directory} does not exist\\") # Dictionary to hold the result organized_files = defaultdict(list) # Iterate through the files in the directory for filename in os.listdir(directory): file_path = os.path.join(directory, filename) # Skip if it is a directory if os.path.isdir(file_path): continue # Get file extension file_extension = filename.split(\'.\')[-1] if \'.\' in filename else \'unknown\' subdirectory = os.path.join(directory, file_extension) # Create subdirectory if it does not exist if not os.path.exists(subdirectory): os.makedirs(subdirectory) # Move the file destination_path = os.path.join(subdirectory, filename) shutil.move(file_path, destination_path) organized_files[file_extension].append(filename) return organized_files"},{"question":"# Context You are working on a financial analysis tool that processes large sequences of stock prices to identify trends. One common operation is to identify the minimum and maximum prices within a range of days to make buy and sell recommendations. # Task Implement a function in Python to efficiently find the minimum and maximum stock prices within a given range of days. Your function should be optimized for multiple range queries using a preprocessing step. # Requirements - Function Name: `preprocess_and_query` - **Input**: - A list of integers `prices` where each integer represents the stock price on a particular day. - A list of tuples `queries` where each tuple contains two integers representing the start and end days (inclusive) of the range for which the minimum and maximum prices are to be found. - **Output**: A list of tuples, each containing two integers, where the first integer is the minimum price and the second integer is the maximum price for the corresponding query range. - **Constraints**: - The maximum length of the `prices` list will be 10^5. - The maximum number of queries will be 10^4. - Each price in the list will be a non-negative integer. - Indices in the query ranges are 0-based and inclusive. # Example ```python # Example usage prices = [100, 180, 260, 310, 40, 535, 695] queries = [(0, 2), (1, 5), (3, 6)] result = preprocess_and_query(prices, queries) print(result) # Output should be: [(100, 260), (40, 535), (40, 695)] prices = [10, 9, 8, 7, 6, 5, 4] queries = [(0, 3), (2, 6), (0, 6)] result = preprocess_and_query(prices, queries) print(result) # Output should be: [(7, 10), (4, 8), (4, 10)] ``` # Notes: - The function should preprocess the `prices` list to allow efficient querying. - Consider using Range Minimum Query (RMQ) and Range Maximum Query (RMQ) techniques for preprocessing. - The function should efficiently handle multiple queries to ensure the tool remains performant for large datasets and queries. **Implement the Function Below:** ```python def preprocess_and_query(prices, queries): # your code here ```","solution":"from typing import List, Tuple def preprocess_and_query(prices: List[int], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Preprocesses the prices list for efficient range minimum and maximum queries. :param prices: List of stock prices. :param queries: List of tuples representing the range queries. :return: List of tuples containing the minimum and maximum prices for each query. n = len(prices) if n == 0: return [(None, None)] * len(queries) LOG = n.bit_length() min_table = [[0] * LOG for _ in range(n)] max_table = [[0] * LOG for _ in range(n)] for i in range(n): min_table[i][0] = prices[i] max_table[i][0] = prices[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: min_table[i][j] = min(min_table[i][j - 1], min_table[i + (1 << (j - 1))][j - 1]) max_table[i][j] = max(max_table[i][j - 1], max_table[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 def query(l, r): j = (r - l + 1).bit_length() - 1 min_val = min(min_table[l][j], min_table[r - (1 << j) + 1][j]) max_val = max(max_table[l][j], max_table[r - (1 << j) + 1][j]) return min_val, max_val result = [] for l, r in queries: result.append(query(l, r)) return result"},{"question":"# Context You are developing a string manipulation utility that aims to format user input to comply with a specific coding style guide. One such guideline is ensuring that each identifier in a list follows the snake_case convention. In snake_case, all letters are in lowercase and words are separated by underscores (`_`). # Problem Statement Implement a function `convert_to_snake_case(identifiers: List[str]) -> List[str>` that takes a list of strings `identifiers` as its only parameter. This function should return a new list of strings where each identifier is converted to snake_case. # Requirements 1. Ensure that all characters in each identifier are converted to lowercase. 2. Replace any spaces or hyphens (`-`) in the identifiers with underscores (`_`). 3. Assume the input is a list of valid identifiers with no leading or trailing spaces. # Example ```python >>> convert_to_snake_case([\\"HelloWorld\\", \\"convert-To_Snake_Case\\", \\"example Identifier\\"]) [\'hello_world\', \'convert_to_snake_case\', \'example_identifier\'] >>> convert_to_snake_case([\\"testCase\\", \\"Snake-Case\\", \\"ANOTHER Example\\"]) [\'test_case\', \'snake_case\', \'another_example\'] >>> convert_to_snake_case([\\"simpletest\\"]) [\'simpletest\'] >>> convert_to_snake_case([]) [] ``` # Constraints * The number of identifiers will be between 0 and 10^4. * The length of each identifier will be between 1 and 100 characters. Write your implementation of `convert_to_snake_case(identifiers: List[str]) -> List[str]`.","solution":"from typing import List import re def convert_to_snake_case(identifiers: List[str]) -> List[str]: Converts a list of identifiers to snake_case. Args: identifiers (List[str]): A list of string identifiers to be converted. Returns: List[str]: A list of identifiers in snake_case. snake_case_identifiers = [] for identifier in identifiers: # Replace spaces or hyphens with underscores and convert to lowercase snake_case_identifier = re.sub(r\'[s-]\', \'_\', identifier).lower() snake_case_identifiers.append(snake_case_identifier) return snake_case_identifiers"},{"question":"# Coding Question Context In many programming scenarios, you are required to manipulate strings for various tasks, such as pattern matching, text editing, or data transformation. One commonly encountered problem is the need to compress and decompress strings efficiently, preserving all the information. In this question, you will implement a simple lossless text compression algorithm based on Run-Length Encoding (RLE), a form of lossless data compression where consecutive repetitions of the same character are replaced by a single character followed by the number of repetitions. Task You are required to implement two functions to handle compression and decompression using the RLE algorithm. 1. **compress_string(s: str) -> str**: * Compress the given string using the Run-Length Encoding algorithm. 2. **decompress_string(encoded: str) -> str**: * Decompress the given string encoded with the Run-Length Encoding algorithm. Input and Output Formats * `compress_string`: * Input: A `s` string consisting of uppercase alphabet letters. * Output: The compressed string. * `decompress_string`: * Input: The `encoded` string which is a valid Run-Length Encoded string. * Output: The original decompressed string. Performance Requirements Ensure that your solutions are efficient to handle strings with a length of up to 10^6 characters. Constraints * The input string `s` will consist of uppercase alphabet letters only. * The encoded string will follow the pattern where a character is followed by its count. Example ```python # Test cases assert compress_string(\\"AAAABBBCCDA\\") == \'A4B3C2D1A1\' assert decompress_string(\\"A4B3C2D1A1\\") == \'AAAABBBCCDA\' ```","solution":"def compress_string(s: str) -> str: Compress the given string using the Run-Length Encoding algorithm. if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 compressed.append(f\\"{prev_char}{count}\\") return \'\'.join(compressed) def decompress_string(encoded: str) -> str: Decompress the given string encoded with the Run-Length Encoding algorithm. decompressed = [] i = 0 n = len(encoded) while i < n: char = encoded[i] count = 0 i += 1 while i < n and encoded[i].isdigit(): count = count * 10 + int(encoded[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Scenario You are developing an application that processes geometric shapes and needs a utility to check if a provided point lies inside a given polygon. This functionality is crucial for operations like collision detection and geographical mapping. # Task Implement the function `is_point_inside_polygon(polygon: List[Tuple[int, int]], point: Tuple[int, int]) -> bool` in Python, which determines if a given point lies inside a polygon. # Requirements 1. **Input**: - `polygon`: A list of unique tuples representing the coordinates (x, y) of the vertices of the polygon in counter-clockwise order. The list will have at least 3 but no more than 10^3 vertices. - `point`: A tuple representing the coordinates (x, y) of the point to be checked. 2. **Output**: - A boolean value indicating whether the point is inside the polygon. # Input/Output Format - **Input**: `polygon = [(0, 0), (4, 0), (4, 4), (0, 4)]`, `point = (2, 2)` - **Output**: `True` - **Input**: `polygon = [(0, 0), (4, 0), (0, 4)]`, `point = (5, 5)` - **Output**: `False` # Constraints 1. The polygon vertices are provided in counter-clockwise order. 2. All points and polygon vertices are unique integers. 3. The polygon will have at least 3 vertices and at most 1,000 vertices. 4. The `point` coordinates are also integers. # Performance Requirements - Your solution should handle up to 1,000 vertices efficiently within a reasonable time frame. # Example ```python >>> is_point_inside_polygon([(0, 0), (4, 0), (4, 4), (0, 4)], (2, 2)) True >>> is_point_inside_polygon([(0, 0), (4, 0), (4, 4), (0, 4)], (5, 5)) False >>> is_point_inside_polygon([(0, 0), (4, 0), (2, 3)], (2, 2)) True ``` # Notes - Ensure that your implementation accounts for edge cases, such as points lying exactly on the polygon edges and vertices. - The function should use an efficient algorithm such as the Ray Casting method or the Winding Number algorithm. Implement your solution taking into account the potential complexities and ensuring correctness for all edge cases.","solution":"def is_point_inside_polygon(polygon, point): Determine if a point is inside a given polygon. Args: polygon (List[Tuple[int, int]]): List of tuples representing the vertices of the polygon. point (Tuple[int, int]): Tuple representing the point to check. Returns: bool: True if the point is inside the polygon, False otherwise. x, y = point n = len(polygon) inside = False p1x, p1y = polygon[0] for i in range(n + 1): p2x, p2y = polygon[i % n] if y > min(p1y, p2y): if y <= max(p1y, p2y): if x <= max(p1x, p2x): if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x if p1x == p2x or x <= xinters: inside = not inside p1x, p1y = p2x, p2y return inside"},{"question":"# Problem Statement You are tasked to implement a logging system that stores log entries. Each log entry consists of a timestamp, a log level, and a message. The system should support querying logs within a specific time range. Implement an efficient solution that can handle a large number of log entries and queries. # Requirements 1. Implement a class `LogSystem` with the following methods: - `add_log(timestamp: str, level: str, message: str) -> None`: Adds a new log entry with the given `timestamp`, `level`, and `message`. - `query(start: str, end: str) -> list[dict]`: Returns a list of log entries within the specified time range `[start, end]`. Each log entry should be represented as a dictionary with keys `timestamp`, `level`, and `message`. 2. The `timestamp` will be in the format `YYYY-MM-DD HH:MM:SS`. 3. The `level` will be one of the following strings: `[\\"INFO\\", \\"WARNING\\", \\"ERROR\\"]`. 4. Ensure efficient storage and retrieval of log entries. 5. Handle edge cases such as no log entries or no results within the specified time range effectively. # Class Definition Complete the class `LogSystem` with the necessary methods adhering to the following signature: ```python class LogSystem: def __init__(self): pass def add_log(self, timestamp: str, level: str, message: str) -> None: pass def query(self, start: str, end: str) -> list[dict]: pass ``` # Input and Output * **Input for `add_log`**: A `timestamp` as a string, a `level` as a string, and a `message` as a string. * `timestamp` format: `YYYY-MM-DD HH:MM:SS` * `level`: one of the following strings: `[\\"INFO\\", \\"WARNING\\", \\"ERROR\\"]` * `message`: any string * **Input for `query`**: `start` and `end` timestamps as strings. * `timestamp` format: `YYYY-MM-DD HH:MM:SS` * **Output for `query`**: A list of dictionaries, each representing a log entry with keys `timestamp`, `level`, and `message`. # Constraints * There will be at most `10^6` log entries. * The system should support up to `10^4` queries efficiently. # Example ```python logs = LogSystem() logs.add_log(\\"2023-09-01 14:20:30\\", \\"INFO\\", \\"System started.\\") logs.add_log(\\"2023-09-01 15:45:00\\", \\"ERROR\\", \\"An error occurred.\\") logs.add_log(\\"2023-09-02 09:15:10\\", \\"WARNING\\", \\"Low disk space.\\") print(logs.query(\\"2023-09-01 14:00:00\\", \\"2023-09-01 16:00:00\\")) # Outputs: [{\'timestamp\': \'2023-09-01 14:20:30\', \'level\': \'INFO\', \'message\': \'System started.\'}, # {\'timestamp\': \'2023-09-01 15:45:00\', \'level\': \'ERROR\', \'message\': \'An error occurred.\'}] print(logs.query(\\"2023-09-02 00:00:00\\", \\"2023-09-02 23:59:59\\")) # Outputs: [{\'timestamp\': \'2023-09-02 09:15:10\', \'level\': \'WARNING\', \'message\': \'Low disk space.\'}] ``` # Notes * Focus on the efficiency of both adding log entries and querying within a time range. * Log entries within the specified time range `[start, end]` are inclusive of `start` and `end`. * Return logs in chronological order according to their timestamps.","solution":"from bisect import bisect_left, bisect_right from datetime import datetime class LogSystem: def __init__(self): self.logs = [] self.timestamps = [] def add_log(self, timestamp: str, level: str, message: str) -> None: self.logs.append({\\"timestamp\\": timestamp, \\"level\\": level, \\"message\\": message}) self.timestamps.append(timestamp) def query(self, start: str, end: str) -> list[dict]: start_idx = bisect_left(self.timestamps, start) end_idx = bisect_right(self.timestamps, end) return [ self.logs[i] for i in range(start_idx, end_idx) if start <= self.logs[i][\\"timestamp\\"] <= end ]"},{"question":"# Coding Assessment Question: Build a Simple Calculator Scenario: You are tasked with creating a basic calculator that can perform addition, subtraction, multiplication, and division. The calculator will receive input as a string in the form of an expression and will output the result of the computation. Problem Statement: Write a function called `simple_calculator` that takes a string input representing a mathematical expression and returns the result as a float. The expression will contain two operands and one of the following operators: `+`, `-`, `*`, or `/`. Ensure the function handles basic edge cases such as division by zero and invalid input. Input: * A single string `expression` consisting of two operands (integers or floats) and one operator (+, -, *, or /). * The operands and the operator will be separated by a single space. Output: * A float representing the result of the calculation. Constraints: * The input will always contain exactly two operands and one operator, separated by spaces. * For division cases, if the divisor is zero, return the string \\"Error: Division by zero\\". * Do not use the `eval` function for this problem. Example: ```python print(simple_calculator(\\"3 + 5\\")) # Output: 8.0 print(simple_calculator(\\"10 - 4\\")) # Output: 6.0 print(simple_calculator(\\"7 * 8\\")) # Output: 56.0 print(simple_calculator(\\"9 / 3\\")) # Output: 3.0 print(simple_calculator(\\"5 / 0\\")) # Output: \\"Error: Division by zero\\" ``` Tips: 1. Parse the input string to extract operands and operator. 2. Implement separate handlers for each operator. 3. Validate the input to handle special cases such as division by zero. 4. Return the result as a float to handle decimal operations. **Good Luck!**","solution":"def simple_calculator(expression): Evaluates a simple mathematical expression with two operands and one operator. try: operand1, operator, operand2 = expression.split() operand1 = float(operand1) operand2 = float(operand2) if operator == \\"+\\": return operand1 + operand2 elif operator == \\"-\\": return operand1 - operand2 elif operator == \\"*\\": return operand1 * operand2 elif operator == \\"/\\": if operand2 == 0: return \\"Error: Division by zero\\" return operand1 / operand2 else: return \\"Error: Invalid operator\\" except ValueError: return \\"Error: Invalid input\\""},{"question":"# Coding Question: You are tasked with implementing a function that returns the depth of the deepest leaf node in a binary tree. The function should use a depth-first search (DFS) approach to traverse the tree and find the maximum depth. **Function Signature:** ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: pass ``` # Input: - `root` (TreeNode): The root node of a binary tree. A node in the tree is represented as an instance of `TreeNode` class. # Output: - Returns the maximum depth (int) of the deepest leaf node. # Constraints: 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. The value of each node is in the range `[0, 10^4]`. # Performance Requirements: - The function should run in (O(n)) time complexity, where (n) is the number of nodes in the tree. - The space complexity should be (O(h)), where (h) is the height of the tree, due to the recursion stack. # Test Cases: 1. For an empty tree `root = None`, `max_depth(root)` should return `0` 2. For a tree with a single node `root = TreeNode(1)`, `max_depth(root)` should return `1` 3. For a right-skewed tree `root = TreeNode(1, right=TreeNode(2, right=TreeNode(3)))`, `max_depth(root)` should return `3` 4. For a tree `root = TreeNode(1, left=TreeNode(2), right=TreeNode(3))`, `max_depth(root)` should return `2` 5. For a balanced tree `root = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3))`, `max_depth(root)` should return `3` # Scenario: This problem is typical in software development, specifically in the context of manipulation and analysis of hierarchical data structures like binary trees. Analyzing the depth of a tree is a fundamental problem, often required in scenarios such as computing the complexity of recursive algorithms, determining the balance of a search tree, or simply visualizing hierarchical data. Implement the function following these guidelines and ensure it handles various edge cases robustly.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Context You are developing a contact management system that allows users to store, search, and retrieve contact names efficiently. To achieve this, you need to implement a basic Trie (prefix tree) data structure to support insertion and search operations by name prefixes. # Task Implement the `ContactsTrie` class. Method Details 1. **`__init__(self)`**: - Initializes the Trie. 2. **`insert(self, contact: str) -> None`**: - Inserts a contact name into the Trie. 3. **`search_by_prefix(self, prefix: str) -> list[str]`**: - Searches for all contact names that start with the given prefix and returns them in lexicographical order. # Requirement Ensure your implementation of the `ContactsTrie` class: - **Handles edge cases**: such as inserting duplicate contact names and searching with non-existing prefixes. - **Is efficient**: both in terms of time and space complexity. - **Produces accurate results**: contact names retrieved in correct lexicographical order. # Input and Output * Input: * A string `contact` representing the contact name. * A string `prefix` representing the prefix to search for. * Output: * A list of contact names starting with the given prefix, sorted in lexicographical order. # Example ```python contacts = ContactsTrie() contacts.insert(\\"alice\\") contacts.insert(\\"bob\\") contacts.insert(\\"alex\\") contacts.insert(\\"albert\\") print(contacts.search_by_prefix(\\"al\\")) # Output: [\'alex\', \'alice\', \'albert\'] print(contacts.search_by_prefix(\\"b\\")) # Output: [\'bob\'] print(contacts.search_by_prefix(\\"z\\")) # Output: [] ``` # Constraints * Contact names and prefixes contain only lowercase English letters. * Length of each contact name: (1 leq text{length of contact} leq 100) * Number of contacts: (1 leq text{number of contacts} leq 10^4) * Length of prefix: (1 leq text{length of prefix} leq 100) **Note**: Make sure to handle edge cases and optimize for both time and space complexity.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class ContactsTrie: def __init__(self): self.root = TrieNode() def insert(self, contact: str) -> None: node = self.root for char in contact: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_by_prefix(self, prefix: str) -> list[str]: def dfs(node, prefix, result): if node.is_end_of_word: result.append(prefix) for char in sorted(node.children.keys()): dfs(node.children[char], prefix + char, result) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results"},{"question":"# Task Description You are given a list of student scores in various subjects. Your task is to implement a function to calculate the class topper in each subject and the overall class topper based on average scores across all subjects. Each student is represented as a dictionary with their name and scores in different subjects. # Function to Implement `calculate_toppers(students: List[Dict[str, Union[str, Dict[str, int]]]])` * **Input**: - `students` (List[Dict[str, Union[str, Dict[str, int]]]]): A list of dictionaries where each dictionary contains the name of a student and their scores in different subjects. For example, ```python [ {\\"name\\": \\"Alice\\", \\"scores\\": {\\"Math\\": 90, \\"Science\\": 80, \\"English\\": 85}}, {\\"name\\": \\"Bob\\", \\"scores\\": {\\"Math\\": 85, \\"Science\\": 88, \\"English\\": 90}} ] ``` * **Output**: - Returns a tuple containing: 1. A dictionary where each key is a subject and the value is a tuple with the name of the student who scored the highest in that subject and their score. 2. A string with the name of the student who has the highest average score across all subjects. # Constraints * Each student is guaranteed to have scores in the same set of subjects. * There will always be at least one student with scores. * Scores for each subject are between 0 and 100. # Requirements 1. Implement the `calculate_toppers` function that: - Identifies the topper in each subject. - Identifies the overall class topper based on average scores across all subjects. 2. Ensure the function handles ties by selecting the first student with the highest score in any subject or the highest average score overall. 3. Optimize the solution such that it has minimal performance overhead. # Example ```python # Example usage of the calculate_toppers function students = [ {\\"name\\": \\"Alice\\", \\"scores\\": {\\"Math\\": 90, \\"Science\\": 80, \\"English\\": 85}}, {\\"name\\": \\"Bob\\", \\"scores\\": {\\"Math\\": 85, \\"Science\\": 88, \\"English\\": 90}} ] subject_toppers, overall_topper = calculate_toppers(students) print(f\\"Subject toppers: {subject_toppers}\\") print(f\\"Overall class topper: {overall_topper}\\") ``` # Notes * You may assume that if two students have the same average score, the first student in the list is considered the topper. * Ensure the solution is efficient and readable.","solution":"from typing import List, Dict, Union def calculate_toppers(students: List[Dict[str, Union[str, Dict[str, int]]]]) -> Union[Dict[str, Dict[str, Union[str, int]]], str]: Calculates the toppers for each subject and the overall class topper. Args: students (list): List of dictionaries with student names and their scores in various subjects. Returns: tuple: (subject_toppers, overall_topper) - subject_toppers (dict): Dictionary where each key is a subject and the value is a tuple with the name of the student with the highest score in that subject and their score. - overall_topper (str): Name of the student with the highest average score across all subjects. if not students: return {}, \'\' subject_toppers = {} overall_topper = \'\' max_avg_score = -1 for student in students: name = student[\\"name\\"] scores = student[\\"scores\\"] # Calculate overall average total_score = sum(scores.values()) num_subjects = len(scores) avg_score = total_score / num_subjects # Check for overall topper if avg_score > max_avg_score: max_avg_score = avg_score overall_topper = name # Check for subject toppers for subject, score in scores.items(): if subject not in subject_toppers or score > subject_toppers[subject][1]: subject_toppers[subject] = (name, score) return subject_toppers, overall_topper"},{"question":"**Context**: Suppose there is a problem involving the computation of prime factors and determining the smallest integer greater than or equal to a given number that has exactly a specified number of distinct prime factors. This problem requires handling number theory and optimization techniques to efficiently find the solution. **Problem**: Write a Python function that, given an integer `n` and an integer `k`, finds the smallest integer greater than or equal to `n` which has exactly `k` distinct prime factors. **Task**: 1. Write a function `prime_factors_count(x)` that returns the count of distinct prime factors of `x`. 2. Write a function `find_number_with_k_prime_factors(n, k)` that finds and returns the smallest integer greater than or equal to `n` that has exactly `k` distinct prime factors. **Input**: - `n` (an integer) specifying the lower bound. - `k` (an integer) specifying the exact number of distinct prime factors required. **Output**: - An integer representing the smallest number greater than or equal to `n` with exactly `k` distinct prime factors. **Constraints**: - `2 <= n <= 10^6` - `1 <= k <= 10` **Function Signature**: ```python def prime_factors_count(x: int) -> int: pass def find_number_with_k_prime_factors(n: int, k: int) -> int: pass ``` **Example**: ```python >>> find_number_with_k_prime_factors(10, 2) 10 >>> find_number_with_k_prime_factors(30, 3) 30 ``` **Requirements**: - Optimize for performance, understanding large potential input values. - Consider edge cases and ensure the program can efficiently determine the result, even for the maximum constraints.","solution":"import math def prime_factors_count(x: int) -> int: Returns the count of distinct prime factors of x. count = 0 if x % 2 == 0: count += 1 while x % 2 == 0: x //= 2 for i in range(3, int(math.sqrt(x)) + 1, 2): if x % i == 0: count += 1 while x % i == 0: x //= i if x > 2: count += 1 return count def find_number_with_k_prime_factors(n: int, k: int) -> int: Finds the smallest integer greater than or equal to n that has exactly k distinct prime factors. num = n while True: if prime_factors_count(num) == k: return num num += 1"},{"question":"# Question: Most Frequent Substring Given the problem of identifying repeating patterns in a string, let\'s enhance the challenge by determining the most frequently occurring substring of a specific length. Problem Statement Write a function `most_frequent_substring` that takes a string `s` and an integer `k`, and returns the most frequently occurring substring of length `k` found in the string. If there are multiple substrings with the same highest frequency, return the lexicographically smallest one. Function Signature ```python def most_frequent_substring(s: str, k: int) -> str: ``` Input - `s` (str): The input string. - `k` (int): The length of substrings to consider. Output - `str`: The most frequently occurring substring of length `k`. Constraints - `1 <= len(s) <= 10^5 ` - `1 <= k <= 100` - The string `s` consists of lowercase English letters. Performance Requirements - The solution should run efficiently for strings of length up to 100,000. Example ```python >>> most_frequent_substring(\\"banana\\", 2) \\"an\\" >>> most_frequent_substring(\\"abababab\\", 2) \\"ab\\" >>> most_frequent_substring(\\"aabcabcab\\", 3) \\"abc\\" >>> most_frequent_substring(\\"abcd\\", 1) \\"a\\" ``` Notes - The solution should correctly identify the most frequently occurring substring of length `k`. - Handle ties by returning the lexicographically smallest substring. - Consider edge cases such as when `k` is larger than the length of `s`.","solution":"def most_frequent_substring(s: str, k: int) -> str: This function returns the most frequently occurring substring of length k in the given string s. In case of a tie, it returns the lexicographically smallest substring. from collections import defaultdict if k > len(s): return \\"\\" substring_counts = defaultdict(int) # Count occurrences of each substring of length k for i in range(len(s) - k + 1): substring = s[i:i+k] substring_counts[substring] += 1 # Find the most frequent substring and handle ties lexicographically most_frequent = \\"\\" max_frequency = 0 for substring, count in substring_counts.items(): if count > max_frequency or (count == max_frequency and substring < most_frequent): most_frequent = substring max_frequency = count return most_frequent"},{"question":"Matrix Spiral Traversal Given a class `SpiralMatrix` that is responsible for traversing a given 2D matrix in a spiral order, implement the method `spiral_order`. # Function Signature ```python def spiral_order(self) -> List[int]: pass ``` # Input - The class will have an `__init__` method that takes a 2D list representing a matrix of integers. - The function `spiral_order` should traverse the matrix in a spiral order starting from the top-left corner. # Output - The function `spiral_order` should return a list of integers representing the matrix elements in spiral order. # Example Scenario Consider the following input matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function call `spiral_order()` should return: ```python [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` # Constraints - You may assume that the matrix has at least one row and one column. - Try to optimize the traversal for a large matrix to ensure efficiency. # Sample Test Case ```python import unittest class TestSpiralMatrix(unittest.TestCase): def test_spiral_order(self): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] spiral_matrix = SpiralMatrix(matrix) result = spiral_matrix.spiral_order() self.assertEqual(result, [1, 2, 3, 6, 9, 8, 7, 4, 5]) matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] spiral_matrix = SpiralMatrix(matrix) result = spiral_matrix.spiral_order() self.assertEqual(result, [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]) matrix = [ [1, 2], [3, 4] ] spiral_matrix = SpiralMatrix(matrix) result = spiral_matrix.spiral_order() self.assertEqual(result, [1, 2, 4, 3]) if __name__ == \\"__main__\\": unittest.main() ``` # Tips - Think about how you can systematically remove layers of the matrix while continuing to traverse. - Watch out for edge cases involving single rows or single columns within the matrix. - Consider handling empty matrices appropriately.","solution":"from typing import List class SpiralMatrix: def __init__(self, matrix: List[List[int]]): self.matrix = matrix def spiral_order(self) -> List[int]: result = [] if not self.matrix or not self.matrix[0]: return result top, bottom = 0, len(self.matrix) - 1 left, right = 0, len(self.matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(self.matrix[top][i]) top += 1 # Traverse downwards for i in range(top, bottom + 1): result.append(self.matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(self.matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse upwards for i in range(bottom, top - 1, -1): result.append(self.matrix[i][left]) left += 1 return result"},{"question":"# Number Conversion and Formatting Write a function that takes an integer input and returns it formatted as a string with commas as a thousand separator. # Detailed Requirements 1. **Function Implementation**: * Implement a new function `format_number_with_commas(number: int) -> str`. * The function should convert the given integer to a string and insert commas to separate thousands, millions, billions, etc. 2. **Formatting Rules**: * Use commas as a thousand separator. * Ensure that the output does not include any leading zeros unless the number itself is zero. 3. **Edge Cases**: * Handle negative numbers and ensure the sign is preserved. * Verify the function handles large integers correctly. # Function Signature ```python def format_number_with_commas(number: int) -> str: pass ``` # Input * `number` (int): The integer to be formatted (e.g., 1234567). # Output A string representing the formatted number with commas as thousand separators (e.g., \\"1,234,567\\"). # Constraints * The input integer can range from `-2^31` to `2^31 - 1`. * The function should handle negative numbers and return the negative sign correctly. # Example ```python formatted_number = format_number_with_commas(1234567) print(formatted_number) # Output: \\"1,234,567\\" formatted_negative_number = format_number_with_commas(-987654) print(formatted_negative_number) # Output: \\"-987,654\\" ``` Demonstrating a few more cases: ```python print(format_number_with_commas(0)) # Output: \\"0\\" print(format_number_with_commas(1000)) # Output: \\"1,000\\" print(format_number_with_commas(-1000000)) # Output: \\"-1,000,000\\" print(format_number_with_commas(987654321))# Output: \\"987,654,321\\" ```","solution":"def format_number_with_commas(number: int) -> str: Formats the given integer with commas as thousand separators. Args: number (int): The integer to format. Returns: str: The formatted string with commas as thousand separators. return f\\"{number:,}\\""},{"question":"# Checking for Symmetry in a Binary Tree **Objective**: Write a Python function to check if a given binary tree is symmetric. **Function Signature**: ```python def is_symmetric(root: Node | None) -> bool: ``` Input: 1. **`root`** (Node | None): The root node of the binary tree. Output: A single boolean value: - **True** if the tree is symmetric. - **False** if the tree is not symmetric. Constraints: 1. The binary tree can contain any number of nodes, including zero (an empty tree). 2. Node values in the binary tree can be integers (both positive and negative). Example Scenarios: Here are some example scenarios to illustrate the expected outputs: 1. **Example 1:** * Input: `root = Node(1)` * Structure: ``` 1 / 2 2 / / 3 4 4 3 ``` * Output: `True` 2. **Example 2:** * Input: `root = Node(1)` * Structure: ``` 1 / 2 2 3 3 ``` * Output: `False` 3. **Example 3:** * Input: `root = None` * Structure: ``` Empty Tree ``` * Output: `True` 4. **Example 4:** * Input: `root = Node(1)` * Structure: ``` 1 / 2 2 / / 3 4 4 ``` * Output: `False` Additional Requirements: 1. Your implementation must be efficient with respect to both time and space. 2. Please include sufficient tests to validate your implementation, covering both typical and edge cases. Use the given structure for the TreeNode class: ```python @dataclass class Node: key: int left: Node | None = None right: Node | None = None ``` Note: You are required to ensure the helper functions or additional methods you use are well-optimized.","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: key: int left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def is_mirror(left: Optional[Node], right: Optional[Node]) -> bool: if left is None and right is None: return True if left is None or right is None: return False return (left.key == right.key and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)) def is_symmetric(root: Optional[Node]) -> bool: if root is None: return True return is_mirror(root.left, root.right)"},{"question":"# Sequence Arrangement Challenge You have been tasked with arranging a sequence of unique integers into a specific pattern known as the \\"Wave Array.\\" In a wave array, elements are arranged such that they form a sequence like this: `arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4]` and so on. Function Signature ```python def wave_array(arr: list) -> list: ``` # Input - `arr` (list): A list of unique integers. The list could be in any initial order. # Output - Returns the same list, but rearranged into a wave pattern. # Constraints 1. The input list should contain unique integers. 2. If the list has fewer than 2 elements, it should return the list as-is. 3. The function must rearrange elements in-place without creating additional arrays or using built-in sorting functions. # Example ```python print(wave_array([5, 3, 8, 6, 2])) # Output: [3, 2, 8, 5, 6] or any valid wave pattern print(wave_array([1])) # Output: [1] print(wave_array([10, 20, 30, 40])) # Output: [20, 10, 40, 30] or any valid wave pattern ``` # Detailed Requirements 1. Implement the main function `wave_array(arr)` that will rearrange the input list to meet the wave pattern criteria. 2. Iterate through the list and, at each step, compare adjacent elements to ensure they meet the required pattern (either `arr[i-1] >= arr[i]` or `arr[i] <= arr[i+1]`). 3. Make swaps between elements when necessary to achieve the wave pattern. 4. The resulting array should alternate between peaks and valleys, starting with a peak at the first element. # Edge Cases to Consider 1. Lists with a single element. 2. Lists already in a wave pattern. 3. The smallest and largest possible values in the list. 4. Very large lists to test performance. **Note**: You are not allowed to use built-in sorting functions. The goal is to demonstrate your ability to manipulate list elements to achieve a specific order.","solution":"def wave_array(arr: list) -> list: This function modifies the list in-place to form a wave pattern. n = len(arr) # Traverse all even positioned elements for i in range(0, n, 2): # If current even index element is smaller than previous if i > 0 and arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] # If current even index element is smaller than next if i < n - 1 and arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"# Problem Statement You are tasked with implementing a custom data structure `MovingAverage` that efficiently supports calculating the moving average of the last `k` elements in a sliding window from a stream of integers. Your implementation must ensure efficient operations to compute the moving average as new elements are added to the stream. # Function Signatures ```python class MovingAverage: def __init__(self, k: int) -> None: Initializes the data structure with the window size k. def next(self, val: int) -> float: Adds a new element to the stream and returns the moving average of the last k elements. ``` # Input Constraints - The window size `k` will be a positive integer up to `10^5`. - The values in the stream will be integers between `-10^5` and `10^5`. - Values are added to the stream one at a time, and the moving average is queried after each addition. # Example Usage ```python # Initialize the data structure with a window size of 3 ma = MovingAverage(3) # Add elements to the stream and get the moving average print(ma.next(1)) # Output: 1.0 print(ma.next(10)) # Output: 5.5 print(ma.next(3)) # Output: 4.66667 print(ma.next(5)) # Output: 6.0 ``` # Constraints - You must handle edge cases such as the number of elements being less than `k`. - Aim to optimize the performance of adding new elements and calculating the average to handle frequent operations efficiently.","solution":"from collections import deque class MovingAverage: def __init__(self, k: int) -> None: Initialize the data structure with the window size k. self.k = k self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: Adds a new element to the stream and returns the moving average of the last k elements. self.queue.append(val) self.current_sum += val # If the queue length exceeds k, pop the oldest element if len(self.queue) > self.k: removed = self.queue.popleft() self.current_sum -= removed return self.current_sum / len(self.queue)"},{"question":"# Problem Statement Write a Python function `unique_integers_sum_to_zero(n: int) -> list[int]` that takes an integer `n` and returns a list containing `n` unique integers that sum to zero. If `n` is not positive, the function should raise a `ValueError` with the message \\"n must be a positive integer.\\" # Function Signature ```python def unique_integers_sum_to_zero(n: int) -> list[int]: ``` # Input * `n` (int): The number of unique integers required. Must be a positive integer. # Output * list of ints: A list containing `n` unique integers that sum to zero. # Constraints * `n` must be a positive integer (â‰¥ 1). # Examples ```python >>> unique_integers_sum_to_zero(5) [-2, -1, 0, 1, 2] >>> unique_integers_sum_to_zero(3) [-1, 0, 1] >>> unique_integers_sum_to_zero(1) [0] >>> unique_integers_sum_to_zero(6) [-3, -2, -1, 1, 2, 3] >>> unique_integers_sum_to_zero(0) Traceback (most recent call last): ... ValueError: n must be a positive integer. >>> unique_integers_sum_to_zero(-2) Traceback (most recent call last): ... ValueError: n must be a positive integer. >>> unique_integers_sum_to_zero(3.5) Traceback (most recent call last): ... ValueError: n must be a positive integer. ``` # Notes * The function should ensure that all integers in the returned list are unique. * Make sure the function raises a `ValueError` with the message \\"n must be a positive integer.\\" if the input does not meet the required constraints.","solution":"def unique_integers_sum_to_zero(n: int) -> list[int]: if not isinstance(n, int) or n <= 0: raise ValueError(\\"n must be a positive integer.\\") result = list(range(1, n)) result.append(-sum(result)) return result"},{"question":"# Sum of Internal Nodes in BST You are assigned the task of developing a new module for a tree management system that performs various calculations on a Binary Search Tree (BST). One of the tasks is to compute the sum of all internal nodes within the tree. # Task: Write a function `sum_internal_nodes(root: TreeNode) -> int` that takes as input the root node of a BST and returns the sum of all internal nodes\' values. Internal nodes are those nodes that have at least one child. # Input: * `root` - A `TreeNode` object representing the root of the BST, where each node contains an integer value `val`, a left child `left`, and a right child `right`. # Output: * The sum of the values of all internal nodes in the BST. # Constraints: * Each node value will be a unique integer within the range `[-10^4, 10^4]`. * The number of nodes in the tree is between `1` and `1000`. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) output = sum_internal_nodes(root) # Expected output: 25 (sum of 10 and 15, as nodes with values 10 and 15 have children) # Example 2 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) output = sum_internal_nodes(root) # Expected output: 4 (only node with value 4 has children) # Example 3 root = TreeNode(8) root.left = TreeNode(3) root.right = TreeNode(10) root.left.left = TreeNode(1) root.left.right = TreeNode(6) root.left.right.left = TreeNode(4) root.left.right.right = TreeNode(7) root.right.right = TreeNode(14) root.right.right.left = TreeNode(13) output = sum_internal_nodes(root) # Expected output: 41 (sum of 8, 3, 10, 6, and 14) ``` # Instructions: 1. Create a helper function to determine if a node is an internal node. 2. Use a depth-first search (DFS) or breadth-first search (BFS) approach to traverse the tree and calculate the sum of internal nodes. 3. Ensure the function handles all edge cases, such as trees with a single node or unbalanced trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_internal_node(node): Check if a given node is an internal node. return node.left is not None or node.right is not None def sum_internal_nodes(root): Returns the sum of all internal nodes\' values in the BST. if root is None: return 0 internal_sum = 0 stack = [root] while stack: node = stack.pop() if is_internal_node(node): internal_sum += node.val if node.left: stack.append(node.left) if node.right: stack.append(node.right) return internal_sum"},{"question":"# Question: Implement a Function to Calculate the Prime Factorization of a Number Your task is to implement a function that computes the prime factors of a positive integer. The function should return a dictionary where each key is a prime factor, and the corresponding value is the count of that prime factor in the factorization. **Function Signature**: ```python def prime_factorization(n: int) -> dict: pass ``` **Input**: - `n`: A positive integer (`1 <= n <= 10^6`). **Output**: - A dictionary where keys are prime factors of `n` and values are the counts of those prime factors. **Constraints**: - Ensure the implementation is efficient and handles edge cases such as `n` being a prime number itself or `n` being 1. Example: ```python assert prime_factorization(20) == {2: 2, 5: 1} assert prime_factorization(32) == {2: 5} assert prime_factorization(97) == {97: 1} assert prime_factorization(1) == {} ``` Explanation: - For `n = 20`, the prime factorization is (2^2 times 5^1), so the output is `{2: 2, 5: 1}`. - For `n = 32`, the prime factorization is (2^5), so the output is `{2: 5}`. - For `n = 97`, since 97 is a prime number, the factorization is (97^1), so the output is `{97: 1}`. - For `n = 1`, since 1 has no prime factors, the output is `{}`.","solution":"def prime_factorization(n: int) -> dict: Returns the prime factorization of the given number `n` as a dictionary where keys are prime factors and values are their respective counts. factors = {} # Handle the smallest prime number 2 while n % 2 == 0: if 2 in factors: factors[2] += 1 else: factors[2] = 1 n //= 2 # Check for odd factors from 3 onwards factor = 3 while factor * factor <= n: while n % factor == 0: if factor in factors: factors[factor] += 1 else: factors[factor] = 1 n //= factor factor += 2 # If n is a prime number greater than 2 if n > 2: factors[n] = 1 return factors"},{"question":"# Question Title: Instagram Username Availability Checker with Optimized Handling # Scenario You have been hired to automate the process of checking username availability on Instagram. This will involve writing a script that queries Instagram to determine if a given username is available or taken. Due to rate limits imposed by Instagram, it is essential to implement an optimized and respectful way to handle multiple requests. # Requirements 1. **API Request and Parsing**: - Use the `requests` library to send a GET request to Instagram\'s username-check endpoint (`https://www.instagram.com/{username}/`). - Check the HTTP status code of the response to determine if the username is available or taken. - If the status code is `200`, the username is taken. - If the status code is `404`, the username is available. 2. **Optimized Handling**: - Implement rate limiting to prevent sending requests too frequently to Instagram (the script should wait at least 2 seconds between requests). - If Instagram temporarily blocks requests due to rate limits, handle this gracefully by pausing the program\'s execution for 15 minutes before retrying. 3. **Error Handling**: - Handle network-related errors (such as connection issues or timeouts) gracefully by implementing retries, with a maximum of 3 retries per username and 2 seconds delay between retries. - In case of unexpected status codes or other errors, log an appropriate error message. 4. **Edge Case Consideration**: - Handle the case where the username contains invalid characters or exceeds Instagram\'s acceptable username length (max 30 characters). # Function Signature Implement the following function: ```python def check_username_availability(username_list: list) -> dict: pass ``` # Input The function takes a list of usernames to be checked for availability. # Output The function returns a dictionary where keys are usernames from the input list and values are `True` if the username is available and `False` if it is taken. # Constraints - Use the `requests` library to send and manage API requests. - Implement rate limiting and retry logic as specified. - Ensure proper error handling and logging. - Username must be a valid Instagram username string (1-30 characters, alphanumeric with optional underscores and periods). # Example Usage ```python usernames_to_check = [\\"username1\\", \\"example_username\\", \\"unique.name\\"] results = check_username_availability(usernames_to_check) for username, is_available in results.items(): status = \\"available\\" if is_available else \\"taken\\" print(f\\"The username \'{username}\' is {status}.\\") ``` Expected output: ``` The username \'username1\' is taken. The username \'example_username\' is available. The username \'unique.name\' is available. ``` Write your implementation of `check_username_availability` ensuring it meets the specified requirements.","solution":"import requests import time import logging logging.basicConfig(level=logging.DEBUG) def check_username_availability(username_list): def is_valid_username(username): if 1 <= len(username) <= 30 and all(c.isalnum() or c in \'._\' for c in username): return True return False def check_single_username(username): url = f\'https://www.instagram.com/{username}/\' retries = 3 for attempt in range(retries): try: response = requests.get(url) if response.status_code == 200: return False # Username is taken elif response.status_code == 404: return True # Username is available else: logging.error(f\\"Unexpected status code for {username}: {response.status_code}\\") except requests.RequestException as e: logging.error(f\\"Request for {username} failed: {e}\\") time.sleep(2) # If all retries fail, consider username not available return False availability = {} last_request_time = 0 for username in username_list: if not is_valid_username(username): availability[username] = False logging.error(f\\"Invalid username: {username}\\") continue current_time = time.time() elapsed_time = current_time - last_request_time if elapsed_time < 2: time.sleep(2 - elapsed_time) availability[username] = check_single_username(username) last_request_time = time.time() if availability[username] == \'rate_limited\': logging.info(\\"Rate limited by Instagram. Sleeping for 15 minutes.\\") time.sleep(15 * 60) return availability"},{"question":"# Question: Longest Increasing Subsequence in a Permutation In combinatorial mathematics, finding subsequences in permutations often leads to interesting patterns and properties. A **permutation** is an ordered arrangement of elements from a set. Task Write a function `longest_increasing_subsequence(permutation)` that finds the length of the longest increasing subsequence (LIS) in a given permutation of distinct integers. An increasing subsequence is a sequence of elements that are in strict increasing order and appear in the same relative ordering as they do in the permutation. Function Signature ```python def longest_increasing_subsequence(permutation: List[int]) -> int: ``` Input - `permutation` (List[int]): A list of distinct integers representing the permutation. Output - An integer representing the length of the longest increasing subsequence. Constraints - The length of `permutation` will be at most `10^5`. - Elements in `permutation` are distinct and can be any integer within a reasonable range. Example ```python longest_increasing_subsequence([3, 10, 2, 1, 20]) # Output: 3 # Explanation: The LIS is [3, 10, 20] longest_increasing_subsequence([3, 2, 1]) # Output: 1 # Explanation: The LIS is [3] or [2] or [1] ``` Performance Requirements Your implementation should efficiently compute the LIS given the constraints to handle the upper limit of the input length within reasonable time and space complexity. Note - Use dynamic programming or any other efficient algorithm to ensure the solution\'s viability for large inputs.","solution":"from typing import List import bisect def longest_increasing_subsequence(permutation: List[int]) -> int: Finds the length of the longest increasing subsequence in the given permutation. if not permutation: return 0 lis = [] for num in permutation: pos = bisect.bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"# Array Rotation Challenge **Context**: You are a developer responsible for optimizing data access in an array storage system. To achieve this, you need to rotate the elements of an array by a given number of steps to the right. The rotation operation will shift elements to the end of the array while bringing the last elements to the front in a cyclic manner. **Task**: Write a function `rotate_array(nums: list[int], k: int) -> list[int]` that rotates the elements of the input array `nums` by `k` steps to the right and returns the modified array. **Function Signature**: ```python def rotate_array(nums: list[int], k: int) -> list[int]: ``` **Input**: - `nums`: A list of integers representing the array. - `k`: An integer representing the number of steps to rotate the array. **Output**: - A list of integers representing the rotated array. **Constraints**: 1. `1 <= len(nums) <= 1000` 2. `-1000 <= nums[i] <= 1000` 3. `0 <= k <= 1000` **Performance Requirements**: - The implementation should aim for O(n) time complexity and O(1) additional space complexity (excluding the space needed for the output array). **Example**: ```python nums = [1, 2, 3, 4, 5, 6, 7] k = 3 print(rotate_array(nums, k)) # Output: [5, 6, 7, 1, 2, 3, 4] ``` **Notes**: - You must handle cases where `k` is greater than the length of the list `nums`. Utilize the modulo operation to manage such scenarios. - The function should modify the input array such that it reflects the rotated order. - Focus on achieving an optimal solution in terms of both time and space complexity.","solution":"def rotate_array(nums, k): Rotates the elements of the array nums by k steps to the right. :param nums: List[int] - list of integers to be rotated :param k: int - number of steps to rotate the array :return: List[int] - rotated array n = len(nums) k = k % n # To handle cases where k is greater than the length of nums return nums[-k:] + nums[:-k]"},{"question":"# Question: Binary Search Tree (BST) from Preorder Traversal Background: A Binary Search Tree (BST) is a binary tree in which each node has at most two children, and each node follows the BST property: the left subtree of a node contains only nodes with keys less than the node\'s key, and the right subtree only nodes with keys greater than the node\'s key. Given a list representing the preorder traversal of a binary search tree, you need to construct the BST and return its inorder traversal. Problem Statement: Write a function `bst_from_preorder(preorder: List[int]) -> List[int]` that performs the following: 1. **Construction**: Construct the Binary Search Tree from the given preorder traversal list. 2. **Inorder Traversal**: Return the inorder traversal of the constructed BST. Input: * `preorder`: A list of integers representing the preorder traversal of a Binary Search Tree (1 â‰¤ len(preorder) â‰¤ 1000). Output: * Return a list representing the inorder traversal of the constructed BST. Example: ```python Input: preorder = [8, 5, 1, 7, 10, 12] Output: [1, 5, 7, 8, 10, 12] ``` Explanation: 1. The given preorder traversal list is `[8, 5, 1, 7, 10, 12]`. 2. Construct the BST: ``` 8 / 5 10 / 1 7 12 ``` 3. The inorder traversal of the BST is: ``` 1, 5, 7, 8, 10, 12 ``` Constraints: - Ensure the input is correctly validated as a list of integers. - Handle edge cases such as an empty list or a single-element list. --- Implement the function `bst_from_preorder(preorder: List[int]) -> List[int]` in Python and provide an analysis of its complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): if not preorder: return [] def build_bst(preorder, start, end): if start > end: return None node = TreeNode(preorder[start]) i = start + 1 while i <= end and preorder[i] < node.val: i += 1 node.left = build_bst(preorder, start + 1, i - 1) node.right = build_bst(preorder, i, end) return node def inorder_traversal(root): result = [] def inorder(node): if not node: return inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result root = build_bst(preorder, 0, len(preorder) - 1) return inorder_traversal(root)"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase English letters only. Your task is to determine the longest substring in which the characters occur in lexicographically increasing order. If there are multiple substrings with the same maximum length, return the one which appears first. # Function Signature ```python def longest_increasing_substring(s: str) -> str: pass ``` # Input - A string `s` (1 <= len(s) <= 10^4). # Output - A string representing the longest lexicographically increasing substring. # Example ```python assert longest_increasing_substring(\\"abcdxyzabxy\\") == \\"abcdxyz\\" assert longest_increasing_substring(\\"abcabcabc\\") == \\"abc\\" assert longest_increasing_substring(\\"zyxwvutsrq\\") == \\"z\\" ``` # Constraints - The input string `s` will contain only lowercase English letters. - The solution should ensure that it efficiently finds the required substring. # Performance - Aim for a time complexity of O(n) where `n` is the length of the input string. - Space complexity should be kept to O(1) if possible, storing only necessary variables. # Context Working with strings is a fundamental part of many programming scenarios, such as text processing, data parsing, and analysis. This problem tests your ability to navigate and manipulate strings efficiently while enforcing constraints on order and length, making it pertinent to tasks ranging from simple text management to complex pattern recognition and validation. # Example Execution ```python longest_increasing_substring(\\"abcdxyzabxy\\") # Output: \\"abcdxyz\\" longest_increasing_substring(\\"abcabcabc\\") # Output: \\"abc\\" ```","solution":"def longest_increasing_substring(s: str) -> str: n = len(s) if n == 0: return \\"\\" max_length = 1 start_idx = 0 current_length = 1 current_start = 0 for i in range(1, n): if s[i-1] < s[i]: current_length += 1 else: if current_length > max_length: max_length = current_length start_idx = current_start current_length = 1 current_start = i # Final check at the end of the loop if current_length > max_length: max_length = current_length start_idx = current_start return s[start_idx:start_idx + max_length]"},{"question":"# Problem: Letter Frequency Calculation Context In text analysis, determining the frequency of each letter in a string is a fundamental task. Such calculations are useful in various fields such as cryptography, linguistics, and text processing. Task Implement a Python function `letter_frequency(text: str) -> dict` that accomplishes the following: 1. Validates the input: * The input string should not be empty. If it is, raise a `ValueError` with the message `\\"Empty string was passed to the function\\"`. 2. Computes the frequency of each letter: * The function should ignore case, treating \'a\' and \'A\' as the same letter. * Only letters from the English alphabet (a-z, A-Z) should be considered; ignore digits, punctuation, and other characters. * The function should return a dictionary where the keys are the letters and the values are the corresponding frequencies in the text. Input * A single string `text` where: `1 <= len(text) <= 10000`. Output * A dictionary representing the frequency of each letter in the input string. Examples ```python >>> letter_frequency(\\"Hello, World!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> letter_frequency(\\"Python Programming 123!!!\\") {\'p\': 2, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 2, \'n\': 2, \'r\': 2, \'g\': 2, \'a\': 1, \'m\': 2, \'i\': 1} >>> letter_frequency(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function ``` Constraints * You can assume the input will always be a string type. * The function should have a time complexity of `O(n)`, where `n` is the length of the input string. Instructions * Write the solution in Python. * Test your implementation with various edge cases and large inputs to validate its correctness and efficiency.","solution":"def letter_frequency(text: str) -> dict: Returns the frequency of each letter in the provided text. Args: - text: str : The string to analyze Returns: - dict : A dictionary with letters as keys and their frequencies as values Raises: - ValueError: If the input string is empty if not text: raise ValueError(\\"Empty string was passed to the function\\") frequency = {} for char in text.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"Write a function `max_consecutive_sum` that calculates the maximum sum of consecutive elements in a given list of integers. The function needs to identify the segment of the list that yields the highest sum and return that value. The current naive implementation iterates through all possible subarrays, resulting in an inefficient time complexity for large lists. Optimize this solution to work effectively on large datasets. # Task: Create a function `max_consecutive_sum` which takes a list of integers `arr` and returns the maximum sum of any contiguous subarray. # Specifications: * **Input**: A list of integers `arr` where `1 â‰¤ len(arr) â‰¤ 10^5` and `-10^4 â‰¤ arr[i] â‰¤ 10^4`. * **Output**: An integer representing the maximum sum of any contiguous subarray within `arr`. # Requirements: * The function must operate with an improved time complexity compared to the naive approach. * Optimize your solution using efficient algorithms and avoid unnecessary nested iterations. # Constraints: * You may use built-in functions if they provide a clear efficiency benefit. * Consider handling large lists and optimizing for performance. # Example: ```python def max_consecutive_sum(arr: list) -> int: pass # Example Usage: # max_consecutive_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) should return 6 # max_consecutive_sum([1, 2, 3, 4, 5]) should return 15 # max_consecutive_sum([-1, -2, -3, -4]) should return -1 ```","solution":"def max_consecutive_sum(arr): Returns the maximum sum of any contiguous subarray. Implements Kadane\'s algorithm for an O(n) time complexity solution. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Coding Question: Implement a Dynamic Config Validator In modern software development, applications frequently rely on configuration files to manage their settings, support different environments, and enhance flexibility. As a developer, you need to implement a dynamic validation script to ensure that any new configuration file adheres to a predefined schema. Objective You are to write a Python function `validate_config_files` that: 1. Fetches the list of configuration files changed in the latest pull request using the GitHub API. 2. For each configuration file: - Loads the file content. - Validates its structure and required keys based on a predefined schema. 3. Returns a validation summary dictionary containing: - `file_path` (relative path of each file). - `validation_status` (boolean indicating if the file is valid). - `errors` (list of errors, if any, encountered during validation). # Input No direct input but relies on GitHub repository setup (referencing environment variables for GITHUB_TOKEN and GITHUB_REPOSITORY). # Output ```json [ { \\"file_path\\": \\"configs/config1.json\\", \\"validation_status\\": true, \\"errors\\": [] }, { \\"file_path\\": \\"configs/config2.json\\", \\"validation_status\\": false, \\"errors\\": [\\"Missing required key \'database\'.\\", \\"Invalid key \'unknown_key\'.\\"] }, ... ] ``` # Constraints - Only consider JSON configuration files with `.json` extension. - Assume there are always valid environment variables for GitHub. # Requirements - Use the `requests` library to fetch pull request file data. - Parse JSON files using the `json` module. - Validate JSON structure against a predefined schema. - Handle edge cases like invalid JSON format gracefully. # Predefined Schema Example The schema is a dictionary with required keys and expected types: ```python SCHEMA = { \\"database\\": {\\"required\\": True, \\"type\\": dict}, \\"logging\\": {\\"required\\": True, \\"type\\": dict}, \\"debug\\": {\\"required\\": False, \\"type\\": bool} } ``` # Performance - Script should execute under 5 seconds for up to 20 configuration file additions. Example ```python import requests import json import os # Predefined schema for validation SCHEMA = { \\"database\\": {\\"required\\": True, \\"type\\": dict}, \\"logging\\": {\\"required\\": True, \\"type\\": dict}, \\"debug\\": {\\"required\\": False, \\"type\\": bool} } def validate_config_files() -> list[dict]: # Your implementation here pass ``` This question is designed to align with the coding assessment\'s focus on interacting with external tools (e.g., GitHub APIs), dynamic content handling, and validation processes, matching the style, complexity, and scope of the existing questions.","solution":"import requests import json import os # Predefined schema for validation SCHEMA = { \\"database\\": {\\"required\\": True, \\"type\\": dict}, \\"logging\\": {\\"required\\": True, \\"type\\": dict}, \\"debug\\": {\\"required\\": False, \\"type\\": bool} } def fetch_changed_files(repo: str, pull_number: int, token: str) -> list: url = f\\"https://api.github.com/repos/{repo}/pulls/{pull_number}/files\\" headers = {\'Authorization\': f\'token {token}\'} response = requests.get(url, headers=headers) response.raise_for_status() return response.json() def load_file_content(repo: str, file_path: str, token: str) -> str: url = f\\"https://raw.githubusercontent.com/{repo}/main/{file_path}\\" headers = {\'Authorization\': f\'token {token}\'} response = requests.get(url, headers=headers) response.raise_for_status() return response.text def validate_json_schema(json_data: dict, schema: dict) -> tuple: errors = [] for key, rules in schema.items(): if rules[\\"required\\"] and key not in json_data: errors.append(f\\"Missing required key \'{key}\'.\\") elif key in json_data and not isinstance(json_data[key], rules[\\"type\\"]): errors.append(f\\"Wrong type for key \'{key}\'. Expected {rules[\'type\'].__name__}.\\") for key in json_data: if key not in schema: errors.append(f\\"Invalid key \'{key}\'.\\") return len(errors) == 0, errors def validate_config_files() -> list[dict]: repo = os.getenv(\\"GITHUB_REPOSITORY\\") pull_number = os.getenv(\\"GITHUB_PULL_NUMBER\\") token = os.getenv(\\"GITHUB_TOKEN\\") if not all([repo, pull_number, token]): raise ValueError(\\"One or more required environment variables are missing.\\") changed_files = fetch_changed_files(repo, pull_number, token) validation_results = [] for file in changed_files: if file[\'filename\'].endswith(\'.json\'): try: file_content = load_file_content(repo, file[\'filename\'], token) json_data = json.loads(file_content) is_valid, errors = validate_json_schema(json_data, SCHEMA) except json.JSONDecodeError: is_valid = False errors = [\\"Invalid JSON format.\\"] validation_results.append({ \\"file_path\\": file[\'filename\'], \\"validation_status\\": is_valid, \\"errors\\": errors }) return validation_results"},{"question":"Binary Tree Height Calculator **Objective**: Implement a function that calculates the height of a given binary tree. Context The height of a binary tree is defined as the length of the path from the root node to the deepest node in the tree. A tree with only a root node has a height of 1. Function Signature ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def height_of_binary_tree(root: TreeNode) -> int: Calculates the height of the binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The height of the binary tree. If the tree is empty, returns 0. pass ``` Expected Input and Output 1. **Input**: - A `TreeNode` instance representing the root of a binary tree. 2. **Output**: - An integer representing the height of the binary tree. Constraints - The number of nodes in the tree is between ( 0 ) and ( 10^4 ). - Node values are arbitrary integers. Performance Requirements - **Time Complexity**: O(n), where `n` is the number of nodes in the binary tree. - **Space Complexity**: O(h), where `h` is the height of the binary tree. Example * **Example 1**: ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> height_of_binary_tree(root) 3 ``` * **Example 2**: ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> height_of_binary_tree(root) 4 ``` * **Example 3**: ```python >>> root = TreeNode(1) >>> height_of_binary_tree(root) 1 ``` * **Edge Case**: ```python >>> height_of_binary_tree(None) 0 ``` **Note**: You can assume that the `TreeNode` class and constructor are correctly implemented for you to use in the function definition.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def height_of_binary_tree(root: TreeNode) -> int: Calculates the height of the binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The height of the binary tree. If the tree is empty, returns 0. if not root: return 0 left_height = height_of_binary_tree(root.left) right_height = height_of_binary_tree(root.right) return max(left_height, right_height) + 1"},{"question":"# **Coding Assessment Question** Context: As part of improving performance in a real-time messaging application, you need to implement a feature that ensures conversation messages are processed in the correct order. Each message has a unique timestamp, and you need to merge several pre-sorted lists of messages while maintaining the overall sorted order by timestamp. Task: Implement the **Merge k Sorted Lists** algorithm to efficiently merge multiple sorted lists of messages. Each list is sorted by the timestamp of the messages. Function Signature: - `def merge_k_sorted_lists(message_lists: list[list[dict]]) -> list[dict]:` # Input: - `message_lists`: A list containing k sublists, where each sublist contains dictionaries representing messages. Each dictionary has a `timestamp` key with an integer value. # Output: - Return a single list of dictionaries, with all messages sorted by the `timestamp`. # Constraints: - `1 <= k <= 10^3` (i.e., up to 1000 lists) - Each sublist will contain at most `10^4` messages - The `timestamp` value is an integer within the range [0, 10^9] - Assume that the messages within each sublist are already sorted by their `timestamp` # Examples: ```python messages_lists = [ [{\'timestamp\': 1, \'text\': \'Hi\'}, {\'timestamp\': 4, \'text\': \'Good morning\'}, {\'timestamp\': 10, \'text\': \'Bye\'}], [{\'timestamp\': 2, \'text\': \'Hello\'}, {\'timestamp\': 6, \'text\': \'How are you?\'}, {\'timestamp\': 9, \'text\': \'Good night\'}], [{\'timestamp\': 3, \'text\': \'Hey\'}, {\'timestamp\': 5, \'text\': \'I am fine\'}, {\'timestamp\': 8, \'text\': \'See you\'}] ] merged_messages = merge_k_sorted_lists(messages_lists) print(merged_messages) # Expected output: # [{\'timestamp\': 1, \'text\': \'Hi\'}, {\'timestamp\': 2, \'text\': \'Hello\'}, {\'timestamp\': 3, \'text\': \'Hey\'}, {\'timestamp\': 4, \'text\': \'Good morning\'}, {\'timestamp\': 5, \'text\': \'I am fine\'}, {\'timestamp\': 6, \'text\': \'How are you?\'}, {\'timestamp\': 8, \'text\': \'See you\'}, {\'timestamp\': 9, \'text\': \'Good night\'}, {\'timestamp\': 10, \'text\': \'Bye\'}] ``` Additional Requirements: - Ensure the code handles merging efficiently with minimal time complexity. - Write unit tests to ensure the correctness of the implementation. - Consider edge cases such as empty lists or lists with varying lengths.","solution":"from heapq import heappop, heappush, heapify def merge_k_sorted_lists(message_lists): Merges k sorted lists of messages while maintaining the overall sorted order by timestamp. :param message_lists: List of k sorted lists of messages. Each message is a dictionary with a \'timestamp\' key. :return: List of all messages sorted by \'timestamp\'. min_heap = [] # Initialize the heap for i, message_list in enumerate(message_lists): if message_list: heappush(min_heap, (message_list[0][\'timestamp\'], i, 0)) merged_messages = [] while min_heap: timestamp, list_idx, msg_idx = heappop(min_heap) merged_messages.append(message_lists[list_idx][msg_idx]) # If there are more messages in the same list, add the next one to the heap if msg_idx + 1 < len(message_lists[list_idx]): next_msg = message_lists[list_idx][msg_idx + 1] heappush(min_heap, (next_msg[\'timestamp\'], list_idx, msg_idx + 1)) return merged_messages"},{"question":"# Reverse a String Preserving Spaces # Objective Write a function that reverses the characters in a given string while preserving the original positions of the spaces. All other characters should be reversed in order, but spaces should remain in their original locations. # Input * A single string consisting of alphabetic characters and spaces. # Output * Return a new string where the characters are reversed, but the spaces are in their original positions. # Constraints * The function should handle strings up to 1000 characters in length. * Do not use any external libraries (standard library functions are allowed). * Function signature should be: `def reverse_string_preserving_spaces(input_string: str) -> str`. # Example ```python def reverse_string_preserving_spaces(input_string: str) -> str: # Implement the function here # Example Usage: print(reverse_string_preserving_spaces(\\"hello world\\")) # Output: \\"dlrow olleh\\" print(reverse_string_preserving_spaces(\\" example \\")) # Output: \\" elpmaxe \\" ``` # Notes 1. Only alphabetic characters should be reversed. 2. Spaces should remain in their original positions. 3. Multiple consecutive spaces should be handled correctly.","solution":"def reverse_string_preserving_spaces(input_string: str) -> str: chars = [c for c in input_string if c != \' \'] reversed_chars = chars[::-1] result = [] reversed_chars_iter = iter(reversed_chars) for char in input_string: if char == \' \': result.append(\' \') else: result.append(next(reversed_chars_iter)) return \'\'.join(result)"},{"question":"# Problem Description: A \\"Pandigital Multiple\\" is a number that contains every digit from 1 to n exactly once when concatenated with its multiples (where n is the number of digits). For instance, 192 is a Pandigital Multiple because 192, 384, and 576 concatenated result in 192384576, which is a 9-digit pandigital number containing each digit from 1 to 9 exactly once. Your task is to write a function to determine if a given number is a Pandigital Multiple. # Requirements: 1. Write a function `is_pandigital_multiple(num: int) -> bool` that checks whether a given number is a Pandigital Multiple. 2. The function should account for the total number of digits in the concatenated result and ensure it forms a valid pandigital number including each digit from 1 to the length of the result without missing any digits. # Input: - `num` (int): The number to verify. # Output: - Returns a boolean indicating whether the given number is a Pandigital Multiple. Constraints: - 1 â‰¤ num â‰¤ 10^6 - The input number should produce no more than a 9-digit pandigital concatenated result when multiplied. # Example: ```python def is_pandigital_multiple(num: int) -> bool: # Implementation here # Example print(is_pandigital_multiple(192)) # Output: True print(is_pandigital_multiple(123)) # Output: False ``` In this example, `is_pandigital_multiple(192)` should return True since the concatenated result of 192, 384, and 576 is 192384576, a 9-digit pandigital number. `is_pandigital_multiple(123)` should return False as it does not form a valid pandigital number with its multiples. # Scoring: - Correctness (50%): The function accurately determines if the number is a Pandigital Multiple. - Efficiency (30%): The implementation efficiently checks pandigital properties without unnecessary computations. - Edge Handling (20%): Properly handles edge cases and ensures valid pandigital checks.","solution":"def is_pandigital_multiple(num: int) -> bool: Checks whether the given number is a Pandigital Multiple. concatenated_result = \'\' n = 1 while len(concatenated_result) < 9: concatenated_result += str(num * n) n += 1 return len(concatenated_result) == 9 and set(concatenated_result) == set(\'123456789\')"},{"question":"# Frequency Counter and Maximum Occurrence Context: Analyzing the frequency of elements in a dataset is a common task in data analysis and programming, serving as the basis for various applications like mode finding, trend analysis, and more. Problem: 1. **Frequency Counter**: - Write a function `count_frequencies(data: list[int]) -> dict[int, int]` that counts the frequency of each element in a list and returns a dictionary with elements as keys and their frequencies as values. 2. **Maximum Occurrence**: - Using the `count_frequencies` function, write a function `find_max_occurrence(data: list[int]) -> int` to find the element with the highest frequency of occurrence. If there are ties in the highest frequency, return the smallest element among them. Requirements: 1. **`count_frequencies` Function**: - Input: A list of integers. - Output: A dictionary with the elements of the list as keys and their frequencies as values. - Example: ```python >>> count_frequencies([1, 2, 2, 3, 3, 3, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 2} >>> count_frequencies([10, 20, 10, 30, 20, 10]) {10: 3, 20: 2, 30: 1} ``` 2. **`find_max_occurrence` Function**: - Input: A list of integers. - Output: A single integer representing the element with the highest frequency of occurrence. - Example: ```python >>> find_max_occurrence([1, 2, 2, 3, 3, 3, 4, 4]) 3 >>> find_max_occurrence([10, 20, 10, 30, 20, 30]) 10 >>> find_max_occurrence([5, 7, 7, 9, 5]) 5 ``` Constraints: - The input list can have at most 10^5 elements. - Assume all elements in the input list are valid integers. - Consider both positive and negative integers as valid inputs. Good luck!","solution":"def count_frequencies(data): Given a list of integers, returns a dictionary with elements as keys and their frequencies as values. frequency_dict = {} for element in data: if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict def find_max_occurrence(data): Given a list of integers, returns the element with the highest frequency of occurrence. If there\'s a tie, returns the smallest element among them. frequency_dict = count_frequencies(data) max_freq = -1 max_elem = None for elem, freq in frequency_dict.items(): if (freq > max_freq) or (freq == max_freq and elem < max_elem): max_freq = freq max_elem = elem return max_elem"},{"question":"# Coding Assessment Question Problem Statement You are given a binary tree where each node contains an integer value. Implement a function to traverse the binary tree in a zigzag level order (also known as spiral order) and return the values of nodes in a list. In zigzag level order, the nodes at the first level are traversed from left to right, the nodes at the second level are traversed from right to left, and so on for subsequent levels. Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: Traverses a binary tree in zigzag level order. Parameters: root (TreeNode): the root of the binary tree. Returns: List[List[int]]: A list of lists where each inner list contains the values of nodes at that level in zigzag order. # your code here ``` Input Format - `root`: The root of a binary tree. Output Format - A list of lists, where each inner list contains the values of nodes at that level in zigzag order. Constraints - The number of nodes ( N ) ( (0 leq N leq 10^4) ). - Node values are integers within the range ([-10^4, 10^4]). Example Given the binary tree: ``` 3 / 9 20 / 15 7 ``` calling `zigzagLevelOrder(root)` should return: ``` [ [3], [20, 9], [15, 7] ] ``` # Requirements 1. Traverse the binary tree using a zigzag level order traversal. 2. Alternate the traversal direction at each level. 3. Return the values of nodes in a list of lists corresponding to each level\'s traversal order.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] current_level = deque([(root, 0)]) while current_level: node, level = current_level.popleft() if len(result) == level: result.append(deque([node.val])) else: if level % 2 == 0: result[level].append(node.val) else: result[level].appendleft(node.val) if node.left: current_level.append((node.left, level + 1)) if node.right: current_level.append((node.right, level + 1)) return [list(level) for level in result]"},{"question":"# Problem Statement You have been given a matrix that represents a grid of characters. Your goal is to determine if there is a path in the grid that forms a specific word. The path can start from any cell, and you can move horizontally or vertically to adjacent cells (no diagonal movements are allowed). Each cell can be used only once. Implement a function `exist` that takes a 2D list `board` representing the grid of characters and a string `word` to find. The function should return `True` if the `word` can be found in the grid and `False` otherwise. # Input: - A 2D list of characters `board`, where `1 <= len(board) <= 100` and `1 <= len(board[0]) <= 100`. - A string `word` with length between 1 and 100. # Output: - A boolean value `True` if the `word` can be formed in the grid, otherwise `False`. # Constraints: - All characters in `board` and `word` consist of only lowercase English letters. # Example: ```python # Example 1 board = [ [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ] word = \\"ABCCED\\" print(exist(board, word)) # Output: True # Example 2 board = [ [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ] word = \\"SEE\\" print(exist(board, word)) # Output: True # Example 3 board = [ [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ] word = \\"ABCB\\" print(exist(board, word)) # Output: False ``` # Requirements: - Implement an efficient search algorithm such as Depth-First Search (DFS). - Avoid using additional space beyond the input grid and path tracking. - Ensure that each cell is used no more than once per search. # Notes: - Carefully handle edge cases, such as single letter grids and words. - Consider the performance implications of the search strategy, given the constraints.","solution":"def exist(board, word): def dfs(board, word, i, j, k): if not (0 <= i < len(board)) or not (0 <= j < len(board[0])) or board[i][j] != word[k]: return False if k == len(word) - 1: # all characters matched return True tmp = board[i][j] # store the current cell board[i][j] = \'#\' # mark the cell as visited # explore all four directions (up, down, left, right) res = (dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1)) board[i][j] = tmp # unmark the cell return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"# Coding Challenge: Lattice Paths Counting Background: Lattice paths are paths on a grid that involve only moving right or up at each step. The number of distinct paths from the top-left corner to the bottom-right corner of an (n times m) grid is an interesting combinatorial problem. Task: Implement a function `count_lattice_paths` that computes the number of distinct paths from the top-left corner to the bottom-right corner of an (n times m) grid. Function Signature: ```python def count_lattice_paths(n: int, m: int) -> int: pass ``` Input: * An integer `n` (0 <= n <= 100) representing the number of rows. * An integer `m` (0 <= m <= 100) representing the number of columns. Output: * An integer representing the number of distinct lattice paths from the top-left corner (0,0) to the bottom-right corner (n,m). Constraints: * n and m will be non-negative integers. * In the case where either n or m is 0, there is only one path (straight line either right or up). Example: ```python assert count_lattice_paths(2, 2) == 6 # Paths: RRUU, RURU, RUUR, URRU, URUR, UURR assert count_lattice_paths(0, 0) == 1 # Only one path which is staying at the point assert count_lattice_paths(3, 2) == 10 # Paths: RRRUU, RURUU, RUURU, URRUU, ... and 6 more ``` **Note**: The expected number of paths should be computed using combinatorial methods (binomial coefficients) or dynamic programming to avoid deep recursion issues and excessive computation time for large grids.","solution":"def count_lattice_paths(n, m): Returns the number of distinct lattice paths from the top-left corner to the bottom-right corner of an n x m grid. # Create a (n+1) x (m+1) grid to store the number of paths to each point dp = [[0] * (m + 1) for _ in range(n + 1)] # There\'s only one way to reach any cell in the first row or first column for i in range(n + 1): dp[i][0] = 1 for j in range(m + 1): dp[0][j] = 1 # Fill the grid using dynamic programming for i in range(1, n + 1): for j in range(1, m + 1): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[n][m]"},{"question":"# Context You are developing a file management utility for a company which needs to track files\' access patterns. As part of this project, you need to implement a Least Recently Used (LRU) Cache system to optimize file access times. # Problem Statement Create a class `LRUCache` that supports the following methods: 1. `__init__(self, capacity: int)`: Initializes the cache with a given capacity. 2. `get(self, key: int) -> int`: Returns the value of the `key` if it exists in the cache, otherwise returns -1. 3. `put(self, key: int, value: int)`: Updates the value of the `key` if it exists in the cache. If the `key` does not exist, adds the `key-value` pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. # Input - The capacity of the cache is given as an integer `0 < capacity â‰¤ 1000`. - `get` and `put` operations will each have a key value of an integer, `0 â‰¤ key, value â‰¤ 1000`. - The number of operations performed on the cache will not exceed `10000`. # Output - For each `get` operation, return the value associated with the `key` or `-1` if the `key` is not in the cache. # Constraints - Your implementation must perform each `get` and `put` operation in O(1) time complexity. # Example ```python cache = LRUCache(2) cache.put(1, 1) # Cache is {1=1} cache.put(2, 2) # Cache is {1=1, 2=2} print(cache.get(1)) # returns 1, Cache is {2=2, 1=1} as 1 is now recently used cache.put(3, 3) # Evicts key 2, Cache is {1=1, 3=3} print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # Evicts key 1, Cache is {4=4, 3=3} print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3, Cache is {4=4, 3=3} print(cache.get(4)) # returns 4, Cache is {3=3, 4=4} ``` # Notes - Use Python\'s collections module (e.g., OrderedDict) or another efficient method to link elements by their usage order. - Ensure your class correctly tracks and updates the Most Recently Used (MRU) and Least Recently Used (LRU) elements to maintain constant time complexity for `get` and `put` operations.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key, last=True) return self.cache[key] def put(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key, last=True) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Coding Assessment Question You need to implement a function `find_critical_path` that calculates the critical path in a given Directed Acyclic Graph (DAG) using the longest path algorithm. # Function Signature ```python def find_critical_path(num_tasks: int, prerequisites: List[Tuple[int, int]]) -> List[int]: pass ``` # Input * `num_tasks` (int): Number of tasks (nodes) in the graph. * `prerequisites` (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) represents a directed edge from task `a` to task `b`. # Output * Returns a list of task indices representing the nodes in the critical path in order. # Constraints * `num_tasks` is a positive integer. * `prerequisites` list contains pairs of integers (a, b) where 0 <= a, b < num_tasks. * The graph is a valid DAG with no cycles. * Ensure algorithm efficiency to handle large graphs. # Performance Requirements * Solution should efficiently determine the critical path in large DAGs. * Handle edge cases where there may be multiple valid longest paths. # Example ```python num_tasks = 6 prerequisites = [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5)] result = find_critical_path(num_tasks, prerequisites) print(result) ``` Expected output: ```python [0, 1, 3, 4, 5] ``` # Note * Ensure to check that the input represents a valid DAG. * Implement error handling for invalid inputs such as cyclic graphs. * Consider the possibility of multiple longest paths and ensure at least one valid path is returned.","solution":"from typing import List, Tuple, Dict from collections import deque, defaultdict def find_critical_path(num_tasks: int, prerequisites: List[Tuple[int, int]]) -> List[int]: def topological_sort(): in_degree = {i: 0 for i in range(num_tasks)} for u, v in prerequisites: in_degree[v] += 1 zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) topo_order = [] while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() topo_order.append(vertex) for neighbor in graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topo_order) == num_tasks: return topo_order else: raise Exception(\\"Graph contains a cycle\\") graph = defaultdict(list) for u, v in prerequisites: graph[u].append(v) try: topo_order = topological_sort() except: raise ValueError(\\"Input graph is not a DAG\\") distances = [-float(\'inf\')] * num_tasks predecessors = [None] * num_tasks for node in topo_order: if distances[node] == -float(\'inf\'): distances[node] = 0 for neighbor in graph[node]: if distances[neighbor] < distances[node] + 1: distances[neighbor] = distances[node] + 1 predecessors[neighbor] = node end_node = distances.index(max(distances)) critical_path = [] while end_node is not None: critical_path.append(end_node) end_node = predecessors[end_node] critical_path.reverse() return critical_path"},{"question":"# Problem Statement Implement a Binary Search Tree (BST) with the following operations using the provided `BSTNode` class template: 1. **Insert**: The method, `insert`, should add a new key to the BST while maintaining the BST property. 2. **Delete**: The method, `delete`, should remove a key from the BST while maintaining the BST property. 3. **Find**: The method, `find`, should check if a given key exists in the BST and return a boolean value. 4. **Inorder Traversal**: The method, `inorder_traversal`, should return a list of elements in the BST in sorted order. Input Format - You will be provided an initial list of integers for building the BST. - A sequence of operations to perform on the BST (`insert`, `delete`, `find`, `inorder_traversal`), along with any necessary arguments. Output Format - For `find` operations, return `True` if the key exists in the BST, otherwise return `False`. - For `inorder_traversal` operations, return the list of elements in sorted order. Constraints - The initial list and operation queries will contain at most 10^5 integers. - Each integer will be in the range of -10^9 to 10^9. - The number of operations to follow would be at most 10^5. Functions to Implement ```python class BSTNode: def __init__(self, key:int): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def find(self, key: int) -> bool: pass def inorder_traversal(self) -> List[int]: pass ``` Example ```python # Initialize the BST bst = BST() # Build the BST with initial keys for key in [50, 30, 20, 40, 70, 60, 80]: bst.insert(key) # Inorder traversal operation print(bst.inorder_traversal()) # Output: [20, 30, 40, 50, 60, 70, 80] # Find operation print(bst.find(40)) # Output: True print(bst.find(90)) # Output: False # Insert operation bst.insert(25) print(bst.inorder_traversal()) # Output: [20, 25, 30, 40, 50, 60, 70, 80] # Delete operation bst.delete(20) print(bst.inorder_traversal()) # Output: [25, 30, 40, 50, 60, 70, 80] bst.delete(30) print(bst.inorder_traversal()) # Output: [25, 40, 50, 60, 70, 80] ``` Note: The exact output will depend on the intermediate steps during the insertion, deletion, and traversal methods due to the structure of the BST.","solution":"class BSTNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = BSTNode(key) else: self._insert(self.root, key) def _insert(self, node: BSTNode, key: int) -> None: if key < node.val: if node.left is None: node.left = BSTNode(key) else: self._insert(node.left, key) elif key > node.val: if node.right is None: node.right = BSTNode(key) else: self._insert(node.right, key) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node: BSTNode, key: int) -> BSTNode: if node is None: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node: BSTNode) -> BSTNode: current = node while current.left is not None: current = current.left return current def find(self, key: int) -> bool: return self._find(self.root, key) def _find(self, node: BSTNode, key: int) -> bool: if node is None: return False if key < node.val: return self._find(node.left, key) elif key > node.val: return self._find(node.right, key) else: return True def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node: BSTNode, result: list) -> None: if node is not None: self._inorder_traversal(node.left, result) result.append(node.val) self._inorder_traversal(node.right, result)"},{"question":"# Problem Description You are asked to develop an efficient algorithm to determine the number of distinct characters in the longest substring that contains only unique characters from a given string `s`. # Function Signature ```python def distinct_char_count_in_longest_unique_substring(s: str) -> int: Find the number of distinct characters in the longest substring with all unique characters. Args: s : A string consisting of English letters. Returns: An integer representing the count of distinct characters in the longest unique substring. Examples: >>> distinct_char_count_in_longest_unique_substring(\\"abcabcbb\\") 3 >>> distinct_char_count_in_longest_unique_substring(\\"bbbbb\\") 1 >>> distinct_char_count_in_longest_unique_substring(\\"pwwkew\\") 3 >>> distinct_char_count_in_longest_unique_substring(\\"\\") 0 ``` # Input * A string `s` (0 â‰¤ `len(s)` â‰¤ 10^5). The string contains only English letters (both uppercase and lowercase). # Output * Returns the count of distinct characters in the longest substring that contains only unique characters. # Constraints * The function should efficiently find the longest unique substring using an optimized method with a time complexity of (O(n)), where `n` is the length of the string. # Example ```python assert distinct_char_count_in_longest_unique_substring(\\"abcabcbb\\") == 3 assert distinct_char_count_in_longest_unique_substring(\\"bbbbb\\") == 1 assert distinct_char_count_in_longest_unique_substring(\\"pwwkew\\") == 3 assert distinct_char_count_in_longest_unique_substring(\\"\\") == 0 assert distinct_char_count_in_longest_unique_substring(\\"au\\") == 2 ``` # Performance Requirements * The algorithm must efficiently handle edge cases and long strings, utilizing techniques such as sliding window or hash map to maintain the time complexity at (O(n)). # Additional Information Ensure to write an optimal solution focusing on performance as well as correctness, making use of appropriate data structures to manage the range and uniqueness of characters in the substring.","solution":"def distinct_char_count_in_longest_unique_substring(s: str) -> int: Find the number of distinct characters in the longest substring with all unique characters. Args: s : A string consisting of English letters. Returns: An integer representing the count of distinct characters in the longest unique substring. if not s: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Question: Implement a Bounded Blocking Queue You need to create a `BoundedBlockingQueue` class that allows enqueuing elements until a fixed limit and dequeuing them in FIFO order. Additionally, implement methods to get the current size of the queue and the capacity of the queue. **Requirements**: - Implement a method `enqueue` to add an element to the queue. - Implement a method `dequeue` to remove and return the front element from the queue. - Implement a method `size` to return the current size of the queue, i.e., the number of elements in it. - Implement a method `capacity` to return the maximum capacity of the queue. # Function Signature ```python class BoundedBlockingQueue: def __init__(self, capacity: int): pass def enqueue(self, element: int) -> None: pass def dequeue(self) -> int | None: pass def size(self) -> int: pass def capacity(self) -> int: pass ``` # Input Format - No direct input. The sequence of operations is performed via the class methods. # Output Format - The method `enqueue` should return `None`. - The method `dequeue` should return an integer representing the front element of the queue or `None` if the queue is empty. - The method `size` should return an integer representing the current size of the queue. - The method `capacity` should return an integer representing the maximum capacity of the queue. # Constraints - Assume the queue only handles integer values. - Enqueuing to a full queue should wait until space is available. - Dequeuing from an empty queue should wait until an element is available. - Use threading constructs to handle synchronization between enqueue and dequeue operations. # Example ```python queue = BoundedBlockingQueue(2) queue.enqueue(1) queue.enqueue(2) print(queue.size()) # Output: 2 print(queue.capacity()) # Output: 2 print(queue.dequeue()) # Output: 1 print(queue.size()) # Output: 1 ``` **Hint**: Use threading constructs like `Condition` or `Semaphore` to handle synchronization in a thread-safe manner.","solution":"import threading class BoundedBlockingQueue: def __init__(self, capacity: int): self.capacity_value = capacity self.queue = [] self.lock = threading.Lock() self.not_empty = threading.Condition(self.lock) self.not_full = threading.Condition(self.lock) def enqueue(self, element: int) -> None: with self.not_full: while len(self.queue) >= self.capacity_value: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int | None: with self.not_empty: while not self.queue: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: with self.lock: return len(self.queue) def capacity(self) -> int: return self.capacity_value"},{"question":"Question: Find Missing Number You are asked to write a function that will find the missing number in an array containing unique integers from 1 to `n`. The array provided will be of length `n-1` and will have exactly one missing number from the sequence. # Function Signature ```python def find_missing_number(nums: List[int]) -> int: Find the missing number in an array of unique integers from 1 to n. Parameters: nums (List[int]): The list of integers with one number missing. Returns: int: The missing number. ``` # Constraints - The length of the input array will be `n-1`, where `1 <= n <= 10^5`. - The input array will only contain unique integers from 1 to `n` with exactly one number missing. # Input Example ```python nums = [3, 7, 1, 2, 8, 4, 5, 6, 9] ``` # Output Example ```python 10 ``` # Additional Examples Example 1 **Input**: ```python nums = [1, 2, 4, 5, 6] ``` **Output**: ```python 3 ``` Example 2 **Input**: ```python nums = [2, 3, 4, 5, 6, 7, 8, 9, 10] ``` **Output**: ```python 1 ``` # Scenario/Context This function is useful in data validation processes, where an array is meant to represent a complete sequence of numbers within a specific range, but one number is missing due to data entry errors or transmission issues. # Notes - Consider utilizing mathematical properties (such as the sum of the first `n` natural numbers) to achieve an efficient solution. - Handle edge cases where the missing number could be at the beginning, middle, or end of the sequence.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in an array of unique integers from 1 to n. Parameters: nums (List[int]): The list of integers with one number missing. Returns: int: The missing number. n = len(nums) + 1 expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"# Coding Assessment Question Objective Create a function to split a sequence into non-overlapping chunks of a specified size. If the last chunk is smaller than the specified size, it should still be included. Task Write a function `chunk_sequence(sequence: List[int], chunk_size: int) -> List[List[int]]` that takes a list of integers and splits it into non-overlapping chunks of the specified size. Input and Output Format **Input**: - `sequence`: A list of integers where `1 <= len(sequence) <= 10^6`. - `chunk_size`: An integer representing the size of each chunk where `1 <= chunk_size <= len(sequence)`. **Output**: - The function should return a list of lists, where each sublist represents a chunk of `chunk_size` elements from the original sequence. Constraints - The input list may contain up to 1,000,000 integers. - Ensure the function handles large inputs efficiently. - The last chunk may be smaller if there are fewer than `chunk_size` elements remaining. Performance Requirements - The function should have a time complexity of O(n), where n is the number of elements in the sequence. Example ```python from typing import List def chunk_sequence(sequence: List[int], chunk_size: int) -> List[List[int]]: Splits the given sequence into non-overlapping chunks of the specified size. return [sequence[i:i + chunk_size] for i in range(0, len(sequence), chunk_size)] # Example usage: sequence = [1, 2, 3, 4, 5, 6, 7, 8, 9] chunk_size = 3 result = chunk_sequence(sequence, chunk_size) print(result) # Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` Scenario You are developing a data processing application where large lists of integers are processed in smaller chunks. Implement the `chunk_sequence` function, which will divide the input list into non-overlapping chunks of a given size to facilitate the processing. Use the provided `chunk_sequence` function template to complete this task.","solution":"from typing import List def chunk_sequence(sequence: List[int], chunk_size: int) -> List[List[int]]: Splits the given sequence into non-overlapping chunks of the specified size. return [sequence[i:i + chunk_size] for i in range(0, len(sequence), chunk_size)]"},{"question":"# Task: Create a function named `date_calculator` that performs date arithmetic. The function should be able to add or subtract a specific number of days, weeks, months, or years to/from a given date. # Requirements: - The function should take three parameters: - `initial_date` (str): the starting date in the format \'YYYY-MM-DD\'. - `adjustment` (int): the number of days, weeks, months, or years to add (if positive) or to subtract (if negative). - `unit` (str): a string indicating the unit of time for the adjustment. It should be one of: \'days\', \'weeks\', \'months\', \'years\'. - The function should return the adjusted date as a string in the format \'YYYY-MM-DD\'. # Constraint: - The function should handle invalid date formats and unit types by raising a `ValueError` with a descriptive error message. # Examples: ```python >>> date_calculator(\'2023-01-01\', 10, \'days\') \'2023-01-11\' >>> date_calculator(\'2023-01-01\', -2, \'weeks\') \'2022-12-18\' >>> date_calculator(\'2023-01-01\', 1, \'months\') \'2023-02-01\' >>> date_calculator(\'2023-01-01\', 1, \'years\') \'2024-01-01\' >>> date_calculator(\'2023-01-01\', 10, \'centuries\') Traceback (most recent call last): ... ValueError: Invalid unit value: \'centuries\'. Adjustment units are: days, weeks, months, years. ```","solution":"from datetime import datetime, timedelta from dateutil.relativedelta import relativedelta def date_calculator(initial_date, adjustment, unit): Adjusts a date by adding or subtracting a given number of days, weeks, months, or years. Parameters: initial_date (str): The starting date in the format \'YYYY-MM-DD\'. adjustment (int): The number of days, weeks, months, or years to add (if positive) or to subtract (if negative). unit (str): The unit of time for the adjustment (\'days\', \'weeks\', \'months\', \'years\'). Returns: str: The adjusted date in the format \'YYYY-MM-DD\'. Raises: ValueError: If the date format is invalid or the unit type is not recognized. # Convert the initial date string to a datetime object try: date_obj = datetime.strptime(initial_date, \'%Y-%m-%d\') except ValueError: raise ValueError(\\"Invalid date format. Please use \'YYYY-MM-DD\'.\\") # Perform the date adjustment based on the unit if unit == \'days\': new_date = date_obj + timedelta(days=adjustment) elif unit == \'weeks\': new_date = date_obj + timedelta(weeks=adjustment) elif unit == \'months\': new_date = date_obj + relativedelta(months=adjustment) elif unit == \'years\': new_date = date_obj + relativedelta(years=adjustment) else: raise ValueError(\\"Invalid unit value: \'{}\'. Adjustment units are: days, weeks, months, years.\\".format(unit)) return new_date.strftime(\'%Y-%m-%d\')"},{"question":"# Home Automation Thermostat Settings You are tasked with creating a function that adjusts the settings of a smart thermostat based on the time of day and the presence of people in the house. The thermostat has different settings for morning, afternoon, evening, and night, and it can also be set to a \\"vacation\\" mode when no one is at home. Function Signature ```python def adjust_thermostat(time_of_day: str, is_home: bool) -> str: ``` Input: - `time_of_day` (str): A string indicating the current time of day, which can be one of \\"morning\\", \\"afternoon\\", \\"evening\\", or \\"night\\". - `is_home` (bool): A boolean indicating if there are people at home (`True`) or not (`False`). Output: - Returns a string representing the chosen thermostat setting. The settings are: \\"warm mode\\", \\"cool mode\\", \\"energy-saving mode\\", and \\"vacation mode\\". Constraints: - The thermostat setting for each time of day is typically: - \\"morning\\": \\"warm mode\\" - \\"afternoon\\": \\"cool mode\\" - \\"evening\\": \\"warm mode\\" - \\"night\\": \\"energy-saving mode\\" - If no one is home (`is_home` is `False`), regardless of the time of day, the thermostat should always be set to \\"vacation mode\\". Example: ```python adjust_thermostat(\\"morning\\", True) ``` This might return: ```python \\"warm mode\\" ``` Another Example: ```python adjust_thermostat(\\"afternoon\\", False) ``` This might return: ```python \\"vacation mode\\" ``` Notes: - Ensure to handle invalid time_of_day inputs by raising a `ValueError` with the message \\"Invalid time of day\\". - Optimize for readability and efficiency.","solution":"def adjust_thermostat(time_of_day: str, is_home: bool) -> str: Adjusts the thermostat settings based on the time of day and whether people are home. Parameters: time_of_day (str): The current time of day (\\"morning\\", \\"afternoon\\", \\"evening\\", or \\"night\\"). is_home (bool): Whether people are at home or not. Returns: str: The chosen thermostat setting (\\"warm mode\\", \\"cool mode\\", \\"energy-saving mode\\", or \\"vacation mode\\"). Raises: ValueError: If time_of_day is not one of the expected values. if not is_home: return \\"vacation mode\\" if time_of_day == \\"morning\\": return \\"warm mode\\" elif time_of_day == \\"afternoon\\": return \\"cool mode\\" elif time_of_day == \\"evening\\": return \\"warm mode\\" elif time_of_day == \\"night\\": return \\"energy-saving mode\\" else: raise ValueError(\\"Invalid time of day\\")"},{"question":"# Problem: Topological Sort of a Directed Acyclic Graph (DAG) You are required to implement an algorithm to find the topological ordering of a Directed Acyclic Graph (DAG). # Function Signature ```python def topological_sort(num_nodes: int, edges: list[tuple[int, int]]) -> list[int]: Parameters: - num_nodes : int : the number of nodes (vertices) in the graph - edges : list of tuples : each tuple is of the form (u, v) where `u` and `v` represent a directed edge from node `u` to node `v` Returns: - list of int : the topological ordering of the nodes ``` # Input Format - `num_nodes`: The number of nodes in the graph (0 < num_nodes <= 1000). - `edges`: A list of tuples, where each tuple (u, v) represents a directed edge from node `u` to node `v`. The number of edges can be up to 10000. # Output Format - A list of integers representing the topological ordering of the nodes. If there are multiple valid topological orders, any valid order will be accepted. # Constraints - The graph is a Directed Acyclic Graph (DAG). # Performance Requirements - The solution should efficiently handle up to 1000 nodes and 10000 edges. # Scenario Imagine you are a project manager tasked with scheduling a series of tasks where some tasks must be completed before others. Each task corresponds to a node in the graph, and each dependency between tasks is a directed edge indicating the order. Your objective is to determine a sequence in which to complete the tasks such that all dependencies are respected. This corresponds to finding a topological ordering of the DAG representing the tasks and their dependencies. # Example ```python num_nodes = 6 edges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] # Expected output (one of the possible correct outputs): # [5, 4, 2, 3, 1, 0] ``` Implement the function to solve the problem described.","solution":"def topological_sort(num_nodes, edges): from collections import defaultdict, deque # Create graph in adjacency list form and in-degrees count graph = defaultdict(list) in_degree = [0] * num_nodes # Construct the graph for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Prepare a queue with all nodes with no incoming edges (in-degree 0) queue = deque() for node in range(num_nodes): if in_degree[node] == 0: queue.append(node) topo_order = [] # Process nodes from queue while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the length of topo_order is not equal to num_nodes, it means there was a cycle (not expected in DAG) if len(topo_order) != num_nodes: raise ValueError(\\"Graph is not a DAG\\") return topo_order"},{"question":"# Word Frequency Analyzer Scenario: You need to analyze a given text to determine the frequency of each word. In this context, a word is defined as a sequence of alphanumeric characters, and the analysis should be case insensitive (e.g., \\"Hello\\" and \\"hello\\" are considered the same word). Task: Write a function `word_frequency_analyzer` that takes a string of text and returns a dictionary where the keys are the words and the values are their respective frequencies in the text. The function should handle input validation and normalize word cases correctly. Function Signature: ```python def word_frequency_analyzer(text: str) -> dict: pass ``` Input: - `text` (str): A single string of text, which may include punctuation, spaces, and newlines. Output: - Returns a dictionary where: - Keys are the words (in lowercase). - Values are the frequency of each word (int). Constraints: - The function should handle an empty string by returning an empty dictionary. Examples: ```python >>> word_frequency_analyzer(\\"Hello, world! Hello universe.\\") {\'hello\': 2, \'world\': 1, \'universe\': 1} >>> word_frequency_analyzer(\\"Go go GO stop stop!\\") {\'go\': 3, \'stop\': 2} >>> word_frequency_analyzer(\\"\\") {} >>> word_frequency_analyzer(\\"Python is amazing. Amazing, isn\'t it?\\") {\'python\': 1, \'is\': 1, \'amazing\': 2, \'isn\': 1, \'t\': 1, \'it\': 1} ``` Ensure your function handles errors appropriately and cleans the input text by removing punctuation and normalizing the case for accurate frequency count.","solution":"import re from collections import defaultdict def word_frequency_analyzer(text: str) -> dict: Analyzes the frequency of each word in the given text. Parameters: text (str): The input text to be analyzed. Returns: dict: A dictionary where keys are words in lowercase and values are their frequencies. if not text: return {} # Remove punctuation and normalize to lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() words = text.split() word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"Tower of Hanoi Problem # Context: Tower of Hanoi is a classic mathematical puzzle where you have three pegs and `n` disks of different sizes. Initially, all disks are stacked in ascending order of size on the first peg, with the largest disk at the bottom. The goal is to move the entire stack to the last peg following these simple rules: 1. Only one disk can be moved at a time. 2. A disk can only be placed on top of a larger disk or on an empty peg. # Problem: Implement a function `tower_of_hanoi(n, source, auxiliary, target)` where: - `n` is an integer representing the number of disks. - `source` is a string representing the name of the source peg. - `auxiliary` is a string representing the name of the auxiliary peg. - `target` is a string representing the name of the target peg. You must print the steps required to move the disks from the source peg to the target peg. # Function Signature: ```python def tower_of_hanoi(n: int, source: str, auxiliary: str, target: str) -> None: ``` # Constraints: - `1 <= n <= 15` # Example: ```python # Example 1: n = 3 source = \'A\' auxiliary = \'B\' target = \'C\' # Calling the function should output: # Move disk 1 from A to C # Move disk 2 from A to B # Move disk 1 from C to B # Move disk 3 from A to C # Move disk 1 from B to A # Move disk 2 from B to C # Move disk 1 from A to C # Example 2: n = 2 source = \'X\' auxiliary = \'Y\' target = \'Z\' # Calling the function should output: # Move disk 1 from X to Y # Move disk 2 from X to Z # Move disk 1 from Y to Z ``` # Additional Tests: You should consider writing additional tests to handle edge cases including but not limited to: - The minimum number of disks (n = 1) to validate the base case. - Larger values of n to test efficiency and recursion depth.","solution":"def tower_of_hanoi(n: int, source: str, auxiliary: str, target: str) -> None: Print the steps required to solve the Tower of Hanoi puzzle. Parameters: n (int): Number of disks source (str): Source peg auxiliary (str): Auxiliary peg target (str): Target peg if n == 1: print(f\\"Move disk 1 from {source} to {target}\\") return # Move n-1 disks from source to auxiliary, so they are out of the way tower_of_hanoi(n - 1, source, target, auxiliary) # Move the nth disk from source to target print(f\\"Move disk {n} from {source} to {target}\\") # Move the n-1 disks that we left on auxiliary to target tower_of_hanoi(n - 1, auxiliary, source, target)"},{"question":"# Alternating Character Removal **Scenario**: You are developing a feature for text analysis in a messaging app. One common issue is repeated characters that occur consecutively. To clean up the text, you need to write a function that removes adjacent duplicate characters and returns the clean version of the message. **Problem**: Given a string, write a function to remove adjacent duplicate characters. **Function Signature**: ```python def remove_adjacent_duplicates(message: str) -> str: Function to remove adjacent duplicate characters from a message. Args: message (str): The input string containing the message. Returns: str: A new string with all adjacent duplicate characters removed. ``` **Input**: - `message`: A string which may contain any printable ASCII characters. **Output**: - A string with all adjacent duplicate characters removed. **Constraints**: - The length of the message will not exceed 10^4. - The message may contain letters, numbers, punctuation, and whitespace. - The operation should be done in linear time complexity. **Examples**: ```python >>> remove_adjacent_duplicates(\\"aabbcc\\") \\"abc\\" >>> remove_adjacent_duplicates(\\"abbaca\\") \\"abaca\\" >>> remove_adjacent_duplicates(\\"mississippi\\") \\"misisipi\\" >>> remove_adjacent_duplicates(\\"bookkeeper\\") \\"bokeper\\" >>> remove_adjacent_duplicates(\\"\\") \\"\\" ``` **Note**: You should use an efficient approach to handle this operation in linear time complexity, considering the input string length constraint.","solution":"def remove_adjacent_duplicates(message: str) -> str: Function to remove adjacent duplicate characters from a message. Args: message (str): The input string containing the message. Returns: str: A new string with all adjacent duplicate characters removed. if not message: return \\"\\" result = [message[0]] for char in message[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"Coding Question: JSON Flattener and Expander # Objective Implement a JSON flattener and expander. Your task is to write two functions `json_flatten` and `json_expand` that convert a nested JSON object into a flattened dictionary and back. # Function Signatures ```python def json_flatten(data: dict) -> dict: pass def json_expand(data: dict) -> dict: pass ``` # Input and Output json_flatten * **Input**: - `data: dict`: The nested JSON object. * **Output**: - `dict`: The flattened dictionary with key paths as keys. json_expand * **Input**: - `data: dict`: The flattened dictionary with key paths as keys. * **Output**: - `dict`: The original nested JSON object. # Constraints - The input for both functions will be valid JSON objects. - Keys in the flattened dictionary for `json_expand` will use dot notation to denote hierarchy (e.g., \\"key1.key2.key3\\"). # Example ```python # Example flattening nested_json = { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": [1, 2, 3] } }, \\"e\\": 2 } flattened = json_flatten(nested_json) print(flattened) # Output: {\'a.b.c\': 1, \'a.b.d\': [1, 2, 3], \'e\': 2} # Example expanding flattened_json = { \'a.b.c\': 1, \'a.b.d\': [1, 2, 3], \'e\': 2 } expanded = json_expand(flattened_json) print(expanded) # Output: # { # \\"a\\": { # \\"b\\": { # \\"c\\": 1, # \\"d\\": [1, 2, 3] # } # }, # \\"e\\": 2 # } ``` # Explanation The `json_flatten` function should traverse the nested JSON object and create a flat dictionary where each key is a path to the original value, using dot notation. It should handle nested objects and lists correctly. The `json_expand` function should take a dictionary with dot notation keys and reconstruct the original nested JSON object, ensuring the hierarchical structure is restored. Consider common edge cases such as empty dictionaries, lists within dictionaries, and deeply nested structures when designing your solution to handle the general requirements efficiently.","solution":"def json_flatten(data: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: Flattens a nested JSON object. Args: - data: dict, the JSON object to flatten. - parent_key: str, the base key (used in recursion). - sep: str, the separator to use between keys. Returns: - dict: the flattened JSON object. items = [] for k, v in data.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(json_flatten(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items) def json_expand(data: dict, sep: str = \'.\') -> dict: Expands a flattened dictionary back into a nested JSON object. Args: - data: dict, the flattened JSON object. - sep: str, the separator used in keys to denote hierarchy. Returns: - dict: the expanded JSON object. result = {} for k, v in data.items(): keys = k.split(sep) d = result for key in keys[:-1]: if key not in d: d[key] = {} d = d[key] d[keys[-1]] = v return result"},{"question":"# Problem Statement You have been given the task to help a school automatically arrange students into groups for a field trip. The students should be grouped such that each group has the same number of students, except possibly the last group which may have fewer students. Develop a function that divides the list of students into groups. # Task Create a function `group_students(students, group_size)` that returns a list of groups where each group is a sublist containing the names of the students. # Input * `students` (List[str]): List of student names. * `group_size` (int): The maximum number of students per group. # Output * (List[List[str]]): A list of groups, each being a list of student names. # Constraints * 1 â‰¤ len(students) â‰¤ 1000. * 1 â‰¤ group_size â‰¤ len(students). # Example ```python assert group_students([\'Alice\', \'Bob\', \'Charlie\', \'David\', \'Eve\'], 2) == [[\'Alice\', \'Bob\'], [\'Charlie\', \'David\'], [\'Eve\']] assert group_students([\'Alice\', \'Bob\', \'Charlie\', \'David\', \'Eve\'], 3) == [[\'Alice\', \'Bob\', \'Charlie\'], [\'David\', \'Eve\']] ``` # Notes * Order of students in the groups should be as they appear in the input list. * Each group should have `group_size` students, except possibly the last group.","solution":"def group_students(students, group_size): Divides students into groups of given size. :param students: List of student names. :param group_size: Maximum number of students per group. :return: List of groups where each group is a list of student names. return [students[i:i + group_size] for i in range(0, len(students), group_size)]"},{"question":"# Binary Search Tree Iterator Problem Statement: You are required to implement an iterator for a binary search tree (BST). The iterator should allow in-order traversal of the BST. Your task is to design a data structure `BSTIterator` which supports efficiently accessing the next smallest element in the BST. Requirements: 1. **Function Signatures**: ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: Optional[TreeNode]): def next(self) -> int: def hasNext(self) -> bool: ``` 2. **Input and Output Format**: - `__init__(self, root: Optional[TreeNode])`: Initializes the iterator with the root node of the BST. - `next(self) -> int`: Returns the next smallest number in the BST. - `hasNext(self) -> bool`: Returns `True` if there is a next smallest number in the BST, otherwise returns `False`. 3. **Constraints**: - The number of nodes in the BST is between `1` and `10^5`. - `-10^6 <= Node.val <= 10^6` - The BST will be well-formed and adhere to BST properties. 4. **Performance Requirements**: - The `next()` and `hasNext()` methods should run in average O(1) time and use O(h) memory, where h is the height of the tree. - Your solution should not use a copy of the BST and should handle large input cases efficiently. Example Usage: ```python # Creating a BST root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initializing the iterator iterator = BSTIterator(root) # Iterating through the BST print(iterator.next()) # Output: 3 print(iterator.next()) # Output: 7 print(iterator.hasNext()) # Output: True print(iterator.next()) # Output: 9 print(iterator.hasNext()) # Output: True print(iterator.next()) # Output: 15 print(iterator.hasNext()) # Output: True print(iterator.next()) # Output: 20 print(iterator.hasNext()) # Output: False ``` Implement the `BSTIterator` class to fulfill the above specifications.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, node): Add all nodes along the path to the leftmost node of the given node. while node: self.stack.append(node) node = node.left def next(self) -> int: Returns the next smallest number in the BST. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: Returns True if there is a next smallest number in the BST, False otherwise. return len(self.stack) > 0"},{"question":"# Problem Statement You are given the task of arranging a set of domino tiles in such a way that all the tiles form a single, continuous chain. Each domino tile is represented as a tuple containing two integers. The goal is to find an arrangement of these domino tiles where the value of the second number of one domino matches the value of the first number of the next domino in the sequence. Function Signature ```python def arrange_dominos(dominos: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Input * `dominos` - A list of tuples, where each tuple contains two integers representing a domino tile. The length of the list is between 1 and 10 inclusive, and each integer in the tuple is between 0 and 6 inclusive. Output * Returns a list of tuples representing the arrangement of dominos in a valid sequence. If no such sequence is possible, return an empty list. Constraints * The solution must handle edge cases, such as when a sequence cannot be formed. # Examples * For `dominos = [(1, 2), (2, 3), (3, 4)]`, the function should return `[(1, 2), (2, 3), (3, 4)]`. * For `dominos = [(1, 2), (3, 4), (2, 4)]`, the function should return `[]` as no valid sequence can be formed. * For `dominos = [(0, 1), (1, 2), (2, 3), (3, 0)]`, the function should return `[(0, 1), (1, 2), (2, 3), (3, 0)]`. # Guidelines 1. **Graph Representation**: Consider representing the dominos as a graph where each node is a number, and each edge is a domino. 2. **Eulerian Path/Circuit**: Use concepts from Eulerian paths to find a valid arrangement. An Eulerian path exists if there are at most two vertices with odd degrees. 3. **Backtracking**: If a straightforward Eulerian path approach is complex, use a backtracking method to find a valid sequence. # Hints 1. Implement a helper function to check for the Eulerian path conditions. 2. Explore possible domino arrangements using backtracking to ensure a valid sequence. 3. Handle special cases where no valid sequence can be formed early to avoid unnecessary computations.","solution":"from typing import List, Tuple def arrange_dominos(dominos: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not dominos: return [] def can_form_sequence(sequence): for i in range(len(sequence) - 1): if sequence[i][1] != sequence[i + 1][0]: return False return True def backtrack(path): if len(path) == len(dominos): return path if can_form_sequence(path) else [] for i in range(len(dominos)): if visited[i]: continue visited[i] = True path.append(dominos[i]) result = backtrack(path) if result: return result path.pop() visited[i] = False return [] visited = [False] * len(dominos) for i in range(len(dominos)): visited[i] = True result = backtrack([dominos[i]]) if result: return result visited[i] = False return []"},{"question":"# Circular Queue Implementation In this task, you will be implementing a circular queue data structure, also known as a ring buffer, which operates on the FIFO (First In First Out) principle. You must implement this data structure from scratch using a fixed-size array (list) to simulate the circular nature of the queue. Class Specification 1. `CircularQueue` - This class should define a circular queue with the following methods: - `__init__(self, size: int) -> None`: Initialize a circular queue of the given size. - `enqueue(self, value: int) -> None`: Add a value to the end of the queue. If the queue is full, raise an `OverflowError` with the message \\"Queue is full\\". - `dequeue(self) -> int`: Remove and return the value at the front of the queue. If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". - `peek(self) -> int`: Return the value at the front of the queue without removing it. If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". - `is_empty(self) -> bool`: Return `True` if the queue is empty, else `False`. - `is_full(self) -> bool`: Return `True` if the queue is full, else `False`. 2. Your class must appropriately handle the circular nature using an internal list, and two pointers (one for the front and one for the rear). Example ```python >>> q = CircularQueue(3) >>> q.is_empty() True >>> q.enqueue(10) >>> q.enqueue(20) >>> q.enqueue(30) >>> q.is_full() True >>> q.dequeue() 10 >>> q.enqueue(40) >>> q.peek() 20 >>> q.dequeue() 20 >>> q.dequeue() 30 >>> q.dequeue() 40 >>> q.is_empty() True >>> q.dequeue() Traceback (most recent call last): ... IndexError: Queue is empty >>> q.enqueue(10) >>> q.enqueue(20) >>> q.enqueue(30) >>> q.enqueue(40) Traceback (most recent call last): ... OverflowError: Queue is full ``` Notes - Ensure the queue utilizes the circular property efficiently. - Handle edge cases such as trying to dequeue or peek from an empty queue, and attempting to enqueue into a full queue by raising appropriate exceptions. - The implementation should be efficient in both time and space complexity for typical queue operations. In this question, you will be tasked with implementing a basic yet foundational data structure, preparing you to handle more complex coding challenges where efficient data storage and retrieval are important.","solution":"class CircularQueue: def __init__(self, size: int) -> None: self.size = size self.queue = [None] * size self.front = -1 self.rear = -1 def enqueue(self, value: int) -> None: if self.is_full(): raise OverflowError(\\"Queue is full\\") if self.is_empty(): self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] if self.front == self.rear: # The queue becomes empty after dequeue self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.size return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self) -> bool: return self.front == -1 def is_full(self) -> bool: return (self.rear + 1) % self.size == self.front"},{"question":"# Coding Task: Sum of Leaf Nodes in a Binary Tree Objective: Write a function `sum_of_leaves` that takes the root of a binary tree and returns the sum of all the leaf node values. Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaves(root: TreeNode) -> int: ``` Input: * **root**: The root node of a binary tree. The binary tree nodes will have integer values. Output: * An integer which is the sum of all leaf node values in the binary tree. Constraints: * The number of nodes in the tree will not exceed (10^5). * The values of the nodes are integers in the range ([-10^4, 10^4]). Example: ```python # Example 1: # Input: # 1 # / # 2 3 # / # 4 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> sum_of_leaves(root) 9 # (4 + 5) - since 4 and 5 are leaf nodes # Example 2: # Input: # 1 # / # 2 # / # 4 5 # / # 6 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.left.right.left = TreeNode(6) >>> sum_of_leaves(root) 10 # (4 + 6) - since 4 and 6 are leaf nodes ``` Notes: * Leaf nodes are the nodes with no children. * Focus on writing an efficient solution that properly handles the constraints provided.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaves(root: TreeNode) -> int: if not root: return 0 if not root.left and not root.right: return root.val return sum_of_leaves(root.left) + sum_of_leaves(root.right)"},{"question":"# Given Context You are developing a simple task management system that allows users to view, add, complete, and delete tasks. Your current task is to implement the core functionalities for managing tasks, such as adding new tasks, marking tasks as complete, and deleting tasks. # Task 1. Implement a `TaskManager` class that manages a list of tasks. Each task is represented as a dictionary with a unique ID, a description, and a status indicating whether the task is completed or not. 2. Implement the following methods within the `TaskManager` class: - `add_task(description: str) -> None`: Adds a new task with the given description. The new task should have a unique ID and a status of \\"incomplete\\". - `complete_task(task_id: int) -> bool`: Marks the task with the given ID as complete. Returns `True` if the task was successfully marked as complete, or `False` if the task with the given ID does not exist. - `delete_task(task_id: int) -> bool`: Deletes the task with the given ID. Returns `True` if the task was successfully deleted, or `False` if the task with the given ID does not exist. - `get_tasks() -> list`: Returns the list of all tasks. # Example Scenario Assume you have a task manager and you want to add tasks, mark a task as complete, delete a task, and get the list of all tasks. # Starter Code ```python class TaskManager: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, description: str) -> None: Adds a new task with the given description. task = { \'id\': self.next_id, \'description\': description, \'status\': \'incomplete\' } self.tasks.append(task) self.next_id += 1 def complete_task(self, task_id: int) -> bool: Marks the task with the given ID as complete. for task in self.tasks: if task[\'id\'] == task_id: task[\'status\'] = \'complete\' return True return False def delete_task(self, task_id: int) -> bool: Deletes the task with the given ID. for task in self.tasks: if task[\'id\'] == task_id: self.tasks.remove(task) return True return False def get_tasks(self) -> list: Returns the list of all tasks. return self.tasks # Example usage manager = TaskManager() manager.add_task(\\"Do the laundry\\") manager.add_task(\\"Clean the house\\") print(manager.get_tasks()) # Should print the list of tasks print(manager.complete_task(1)) # Should return True print(manager.delete_task(2)) # Should return True print(manager.get_tasks()) # Should print the updated list of tasks ```","solution":"class TaskManager: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, description: str) -> None: Adds a new task with the given description. task = { \'id\': self.next_id, \'description\': description, \'status\': \'incomplete\' } self.tasks.append(task) self.next_id += 1 def complete_task(self, task_id: int) -> bool: Marks the task with the given ID as complete. for task in self.tasks: if task[\'id\'] == task_id: task[\'status\'] = \'complete\' return True return False def delete_task(self, task_id: int) -> bool: Deletes the task with the given ID. for task in self.tasks: if task[\'id\'] == task_id: self.tasks.remove(task) return True return False def get_tasks(self) -> list: Returns the list of all tasks. return self.tasks"},{"question":"# Longest Consecutive Sequence Objective Implement a function to find the length of the longest consecutive elements sequence in an unsorted integer array. The solution must demonstrate your ability to efficiently handle data structures and algorithms, particularly focusing on the use of sets to achieve the required results. Requirements 1. **Function Signature**: `longest_consecutive_sequence(numbers: list[int]) -> int` 2. **Input**: * `numbers`: A list of integers that may include both positive and negative values. * Length of `numbers` will be between 0 and 10^5. * Each integer in `numbers` will be between -10^6 and 10^6. 3. **Output**: * An integer representing the length of the longest consecutive elements sequence. Constraints * You must not use sorting as part of your solution. Instead, leverage a set to achieve O(n) time complexity. * Handle edge cases such as an empty list or lists with non-consecutive repeated elements. Performance Requirements * The solution should ideally run in O(n) time complexity, where n is the length of the input list. Scenario Imagine you are analyzing the trends in stock prices over a period. Given a set of recorded prices (which are integers), you need to determine the longest streak of consecutive day-to-day price changes to understand periods of consistent performance. Example ```python # Example usage: print(longest_consecutive_sequence([100, 4, 200, 1, 3, 2])) # Expected Output: 4 (The longest consecutive sequence is [1, 2, 3, 4]) print(longest_consecutive_sequence([0, -1, -2, -3, -4, 5, 6, 7, 8])) # Expected Output: 5 (The longest consecutive sequence is [-4, -3, -2, -1, 0]) print(longest_consecutive_sequence([])) # Expected Output: 0 print(longest_consecutive_sequence([1, 2, 0, 1])) # Expected Output: 3 (The longest consecutive sequence is [0, 1, 2]) ``` This question challenges the candidate\'s understanding of efficient algorithm design using sets and helps assess their skills in handling unsorted data and identifying patterns, which are crucial in various data analysis and processing scenarios.","solution":"def longest_consecutive_sequence(numbers): if not numbers: # Handle the edge case of an empty list return 0 number_set = set(numbers) # Use a set to achieve O(1) time complexity for lookups longest_streak = 0 for number in number_set: # Only start counting from the beginning of a sequence if number - 1 not in number_set: current_number = number current_streak = 1 while current_number + 1 in number_set: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Minimum Meeting Rooms Implement the `min_meeting_rooms` function that determines the minimum number of meeting rooms required to accommodate all the given meetings. The function takes one input: 1. **meetings**: A list of tuples where each tuple represents a meeting, containing two integers, the start time and end time of the meeting. The function should return an integer representing the minimum number of meeting rooms required. # Constraints: * Each meeting tuple contains two integers where `0 <= start < end <= 10^4`. * The number of meetings `n` where `1 <= n <= 10^4`. # Input Format: ```python def min_meeting_rooms(meetings: list) -> int: Args: meetings (list): List of tuples representing meetings with start and end times. Returns: int: Minimum number of meeting rooms required. pass ``` # Example: ```python meetings = [(0, 30), (5, 10), (15, 20)] # Expected output: 2 # Explanation: Two meeting rooms are required because: # - Meeting 1 (0-30) overlaps with Meeting 2 (5-10). # - Meeting 1 (0-30) overlaps with Meeting 3 (15-20). # Therefore, two rooms are required to accommodate all the meetings. print(min_meeting_rooms(meetings)) ``` # Performance Requirements: * The time complexity should be O(n log n). * The implemented function should handle edge cases such as overlapping meetings, back-to-back meetings, and varying lengths of meetings efficiently.","solution":"import heapq def min_meeting_rooms(meetings: list) -> int: Determines the minimum number of meeting rooms required to accommodate all the given meetings. Args: meetings (list): List of tuples representing meetings with start and end times. Returns: int: Minimum number of meeting rooms required. if not meetings: return 0 # Sort meetings by start times meetings.sort(key=lambda x: x[0]) # Initialize a heap to keep track of end times heap = [] for meeting in meetings: # If the earliest ending meeting is done before the current starts, room is available if heap and heap[0] <= meeting[0]: heapq.heappop(heap) # Add the current meeting\'s end time to the heap heapq.heappush(heap, meeting[1]) # The size of the heap is the number of meeting rooms required return len(heap)"},{"question":"**Question:** You are tasked with developing a system to manage book reservations in a library. The system should efficiently handle reservation requests, check if a book is reserved, and get the total number of reservations within a specific time frame. Given the nature of frequent reservations and queries, you decide to use the Segment Tree data structure for its efficient range query and update capabilities. **TASK**: Create a class called `ReservationManager` that includes the following methods: 1. `__init__(self, reservations: List[int])`: Initializes the class with a given list where each entry represents the number of reservations on each day. 2. `update_reservation(self, day: int, value: int)`: Updates the number of reservations on a particular day. 3. `check_reservation(self, day: int) -> int`: Retrieves the number of reservations on a specific day. 4. `get_reservation_count(self, start_day: int, end_day: int) -> int`: Returns the total number of reservations within the interval `[start_day, end_day)` (inclusive of start_day, exclusive of end_day). **Function Signature**: ```python class ReservationManager: def __init__(self, reservations: List[int]): pass def update_reservation(self, day: int, value: int): pass def check_reservation(self, day: int) -> int: pass def get_reservation_count(self, start_day: int, end_day: int) -> int: pass ``` **Constraints**: - 0 <= day < len(reservations) - start_day <= end_day <= len(reservations) **Performance Requirements**: - All operations should be efficient to handle high-frequency updates and queries (hint: aim for O(log N) complexity for update and query operations). **Example**: ```python reservations = [5, 3, 7, 9, 2, 4] rm = ReservationManager(reservations) # Update reservations rm.update_reservation(3, 10) # Check reservation print(rm.check_reservation(3)) # Output: 10 # Total reservations in interval [2, 5) print(rm.get_reservation_count(2, 5)) # Output: 19 (7 + 10 + 2) ``` Write your solution below:","solution":"class ReservationManager: def __init__(self, reservations): self.n = len(reservations) self.tree = [0] * (2 * self.n) # Segment tree size # Build the segment tree for i in range(self.n): self.tree[self.n + i] = reservations[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update_reservation(self, day, value): # Update the leaf node pos = self.n + day self.tree[pos] = value # Update the internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def check_reservation(self, day): # Return the value at the leaf node return self.tree[self.n + day] def get_reservation_count(self, start_day, end_day): res = 0 l = self.n + start_day r = self.n + end_day while l < r: if l % 2: res += self.tree[l] l += 1 if r % 2: r -= 1 res += self.tree[r] l //= 2 r //= 2 return res"},{"question":"# Knapsack Problem Solver Context The knapsack problem is a classic algorithmic problem in which you are given a set of items, each with a weight and a value. Your task is to determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. Task Write a function `knapsack(weights: List[int], values: List[int], capacity: int) -> int` that determines the maximum value that can be obtained by selecting items without exceeding the given capacity. The function should: 1. Use dynamic programming to solve the problem efficiently. 2. Create a 2D table where the entry at row `i` and column `w` represents the maximum value that can be obtained using the first `i` items with the total weight not exceeding `w`. 3. Populate the table based on the recurrence relation: - If the weight of the current item is less than or equal to the current capacity, consider the maximum of including the item or not. - Otherwise, consider the value without including the item. Inputs and Outputs * **Input**: * `weights` - A list of integers where each integer represents the weight of an item. * `values` - A list of integers where each integer represents the value of an item. * `capacity` - An integer representing the maximum weight capacity of the knapsack. * **Output**: * An integer representing the maximum value that can be obtained within the given capacity. Constraints * The number of items `n` will be between 1 and 100. * The weight of each item will be between 1 and 1000. * The value of each item will be between 1 and 1000. * The capacity of the knapsack will be between 1 and 10000. Performance Requirements * The solution should have a time complexity of O(n * capacity). * Ensure to handle edge cases such as empty lists or zero capacity appropriately. Example ```python from typing import List # Function definition def knapsack(weights: List[int], values: List[int], capacity: int) -> int: n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity] # Sample dataset weights = [2, 3, 4, 5] values = [3, 4, 5, 6] capacity = 5 print(\\"Maximum value:\\", knapsack(weights, values, capacity)) ``` Expected output: ``` Maximum value: 7 ``` The maximum value that can be obtained within the given capacity is 7.","solution":"from typing import List def knapsack(weights: List[int], values: List[int], capacity: int) -> int: n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Introduction Recursion is a powerful technique in programming where a function calls itself to solve smaller instances of the same problem. One common problem that can be solved using recursion is finding the nth Fibonacci number. The Fibonacci sequence is defined as follows: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n > 1 ) # Task Write a function `fibonacci` that calculates the nth Fibonacci number using recursion. # Function Signature ```python def fibonacci(n: int) -> int: ``` # Input * `n`: An integer representing the position in the Fibonacci sequence (0-indexed). # Output * Returns an integer representing the nth Fibonacci number. # Example ```python # Example 1 result = fibonacci(0) print(result) # Expected output: 0 # Example 2 result = fibonacci(1) print(result) # Expected output: 1 # Example 3 result = fibonacci(10) print(result) # Expected output: 55 ``` # Constraints * (0 leq n leq 30) # Notes * The function should use recursion to solve the problem. * Ensure that the base cases ( F(0) ) and ( F(1) ) are handled correctly. * Implement the function with efficiency in mind, though the input constraints (0 leq n leq 30) make the recursive approach feasible. # Testing Your Function Test your implementation with various values of ( n ) to ensure correctness. Here are a few additional test cases you can use: ```python if __name__ == \\"__main__\\": assert fibonacci(5) == 5, \\"Test Case 5 Failed\\" assert fibonacci(15) == 610, \\"Test Case 15 Failed\\" assert fibonacci(20) == 6765, \\"Test Case 20 Failed\\" print(\\"All test cases passed!\\") ```","solution":"def fibonacci(n: int) -> int: Return the nth Fibonacci number using recursion. if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2)"},{"question":"# Reverse Level Order Traversal of a Binary Tree Question: Given a binary tree, write a function `reverse_level_order_traversal(root: TreeNode | None) -> List[int]` that returns the reverse level order traversal of its nodes\' values. In a reverse level order traversal, you visit nodes from the bottom level to the top level, and within each level, you visit nodes from left to right. Implement the `reverse_level_order_traversal` function along with any helper functions you find necessary. Your solution should efficiently handle various tree structures and consider edge cases. Input: - `root`: The root node of the binary tree (or `None` if the tree is empty). Output: - A list of integers representing the node values in reverse level order traversal. Constraints: - The number of nodes in the binary tree is in the range [0, 1000]. - Each node\'s value is between [-1000, 1000]. Example: ```python class TreeNode: A binary tree node has a value variable and pointers to its left and right node. def __init__(self, val: int = 0) -> None: self.val = val self.left: TreeNode | None = None self.right: TreeNode | None = None from collections import deque def reverse_level_order_traversal(root: TreeNode | None) -> List[int]: if not root: return [] queue = deque([root]) result = deque() while queue: node = queue.popleft() result.appendleft(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return list(result) def build_tree_from_list(values: List[int]) -> TreeNode | None: if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while i < len(values): node = queue.popleft() if values[i] is not None: node.left = TreeNode(values[i]) queue.append(node.left) i += 1 if i < len(values) and values[i] is not None: node.right = TreeNode(values[i]) queue.append(node.right) i += 1 return root values = [1, 2, 3, 4, 5, None, 7] root = build_tree_from_list(values) print(reverse_level_order_traversal(root)) # Expected output: [4, 5, 7, 2, 3, 1] ``` Notes: - You should handle the case where the tree is empty. - Consider scenarios where all nodes have only one child or the tree is heavily unbalanced.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val: int = 0) -> None: self.val = val self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None def reverse_level_order_traversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) result = deque() while queue: node = queue.popleft() result.appendleft(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return list(result) def build_tree_from_list(values: List[Optional[int]]) -> Optional[TreeNode]: if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while i < len(values): node = queue.popleft() if values[i] is not None: node.left = TreeNode(values[i]) queue.append(node.left) i += 1 if i < len(values) and values[i] is not None: node.right = TreeNode(values[i]) queue.append(node.right) i += 1 return root"},{"question":"# Scenario You are tasked with designing a recommendation system for an online bookstore. Given a list of book purchases by users, you need to implement a function to find the top N recommended books based on the similarity of purchase patterns. # Requirements 1. Implement a function `recommend_books` that takes in three arguments: - `purchase_history` which is a list of lists where each inner list represents the books bought by a specific user. - `user_index` which is an integer representing the index of the user for whom the recommendations are to be made. - `top_n` which is an integer representing the number of top recommended books to return. 2. The function should identify books bought by the most similar users to the target user (specified by `user_index`), but not already bought by the target user, and return the top N recommended books. # Input - `purchase_history: List[List[int]]` - List of lists representing purchase history where each inner list contains the IDs of books bought by a user. - `user_index: int` - The index of the user in the `purchase_history` for whom recommendations are to be made. - `top_n: int` - The number of top recommended books to return. # Output - `List[int]` - List of book IDs recommended for the specified user. # Constraints - `0 <= len(purchase_history) <= 1000` - `0 <= len(purchase_history[user_index]) <= 100` - Book IDs are positive integers. - `1 <= top_n <= 20` - The number of distinct book IDs across all users does not exceed 5000. # Performance - The solution should efficiently find and rank the recommendations within the provided constraints. # Function Signature ```python def recommend_books(purchase_history: List[List[int]], user_index: int, top_n: int) -> List[int]: pass ``` # Example ```python purchase_history = [ [1, 2, 3, 4], [2, 3, 5, 7], [1, 6, 7, 8], [5, 6, 9] ] user_index = 0 top_n = 3 assert recommend_books(purchase_history, user_index, top_n) == [5, 7, 6] ``` The goal is to create an efficient recommendation system that leverages the purchase history to suggest books not yet bought by the target user, thereby enhancing their shopping experience.","solution":"from collections import Counter from typing import List def recommend_books(purchase_history: List[List[int]], user_index: int, top_n: int) -> List[int]: target_user_books = set(purchase_history[user_index]) similarity_scores = [] # Calculate similarity score for each user for index, books in enumerate(purchase_history): if index != user_index: common_books = target_user_books.intersection(books) similarity_scores.append((len(common_books), index)) # Sort users by similarity score in descending order similarity_scores.sort(reverse=True, key=lambda x: x[0]) # Collect books from similar users excluding the books already bought by the target user recommended_books_counter = Counter() for score, index in similarity_scores: for book in purchase_history[index]: if book not in target_user_books: recommended_books_counter[book] += 1 # Get the top_n most common books recommended_books = [book for book, _ in recommended_books_counter.most_common(top_n)] return recommended_books"},{"question":"# Problem Statement Design a function that evaluates the Newton-Raphson method for finding the root of a real-valued function. The Newton-Raphson method provides a powerful and efficient technique for root-finding which requires both the function and its derivative. # The Context A financial analytics firm needs your help to implement a robust method for evaluating the roots of non-linear equations. This feature will be a vital part of their algorithm suite, which their clients rely on for precise financial modeling and risk assessment. # Function Specification Implement the `newton_raphson` function that approximates the root of a given function using the Newton-Raphson method. Function Signature ```python def newton_raphson(function, derivative, initial_guess: float, tolerance: float = 1e-7, max_iterations: int = 1000) -> float: pass ``` Inputs * `function`: A callable (lambda or named function) that takes a single float argument and returns a float. * `derivative`: A callable (lambda or named function) that takes a single float argument and returns a float representing the derivative of the original function. * `initial_guess`: A float representing the starting point for the iteration. * `tolerance`: A float representing the tolerance for the method\'s stopping condition. Default is `1e-7`. * `max_iterations`: An integer representing the maximum number of iterations to perform. Default is `1000`. Outputs * A float representing the approximated root of `function`. Constraints * Ensure `function` and `derivative` are callables. * Ensure `initial_guess` is a float or integer. * Ensure `tolerance` is a positive float. * Ensure `max_iterations` is a positive integer. Assumptions * The provided `function` has a root within a reasonable range around the `initial_guess`. * While iterating, the `derivative` function does not return zero (to avoid division by zero). # Example ```python def func(x): return x**3 - x - 2 def deriv_func(x): return 3*x**2 - 1 result = newton_raphson(func, deriv_func, 1.5) print(result) # Expected output: Approximately 1.52138 ``` # Hints * Convergence can be sensitive to the choice of the initial guess. * If convergence is not reached within the maximum iterations, consider raising an appropriate exception or returning a specific value.","solution":"def newton_raphson(function, derivative, initial_guess: float, tolerance: float = 1e-7, max_iterations: int = 1000) -> float: Approximates the root of the given function using the Newton-Raphson method. Parameters: - function: a callable that takes a single float argument and returns a float. - derivative: a callable that takes a single float argument and returns a float representing the derivative. - initial_guess: a float representing the starting point for the iteration. - tolerance: a float representing the tolerance for the method\'s stopping condition. Default is 1e-7. - max_iterations: an int representing the maximum number of iterations to perform. Default is 1000. Returns: - A float representing the approximated root of the function. x = initial_guess for _ in range(max_iterations): fx = function(x) dfx = derivative(x) if dfx == 0: raise ZeroDivisionError(\\"Derivative is zero. Newton-Raphson method fails.\\") x_new = x - fx / dfx if abs(x_new - x) < tolerance: return x_new x = x_new raise ValueError(\\"Maximum iterations reached. No convergence.\\")"},{"question":"# Median of Two Sorted Arrays **Context**: In data analysis and statistics, finding the median of a dataset is a common task. When the data is split between two separate, sorted arrays, it adds complexity to the operation, requiring efficient methods to find the median without combining the arrays. **Objective**: Write a function that finds the median of two sorted arrays. The overall run-time complexity should be O(log(min(n, m))), where n and m are the lengths of the two arrays. **Function Signature**: ```python def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: ``` **Input**: - `nums1` (List[int]): The first sorted array. - `nums2` (List[int]): The second sorted array. **Output**: - Returns the median of the two sorted arrays as a float. **Examples**: ```python >>> find_median_sorted_arrays([1, 3], [2]) 2 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 ``` **Constraints**: - `nums1` and `nums2` are non-empty and sorted in non-decreasing order. - The total number of elements in both arrays combined will always be at least 1 and at most 2000. **Performance Requirements**: - The solution should leverage a binary search approach to achieve the required time complexity. **Notes**: - The median is the middle value in an ordered list if the total number of elements is odd, or the average of the two middle values if the total number of elements is even. - Consider edge cases where one array is significantly larger than the other. - Ensure your implementation handles cases where arrays have different lengths effectively. **Task**: Implement the `find_median_sorted_arrays` function to meet the above specifications.","solution":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float(\'-inf\') if partitionX == 0 else nums1[partitionX - 1] minX = float(\'inf\') if partitionX == x else nums1[partitionX] maxY = float(\'-inf\') if partitionY == 0 else nums2[partitionY - 1] minY = float(\'inf\') if partitionY == y else nums2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not sorted\\")"},{"question":"# Coding Assessment Question: Imagine you are provided with a list of integers representing the heights of trees planted along a straight road. Each tree needs enough sunlight to grow to its full potential, which it gets if it is not overshadowed by any taller tree to its right. Your task is to determine the total number of trees that will grow to their full potential based on the given heights. **Problem Statement:** You need to create a function that takes a list of integers where each integer represents the height of a tree. The function should return the count of trees that are not overshadowed by any taller tree to their right. **Requirements:** 1. **count_unobstructed_trees(heights: List[int]) -> int**: Given a list of tree heights, return the number of trees that will grow without being overshadowed. - Input: A list of integers, `heights`. - Output: An integer representing the count of trees that are not overshadowed by any taller or equal tree to their right. **Input/Output Format:** - The `count_unobstructed_trees` function should return an integer representing the count of unobstructed trees. - If all trees are overshadowed, the function should return `0`. **Example:** ```python def count_unobstructed_trees(heights): # Your implementation here # Example use case assert count_unobstructed_trees([3, 7, 4, 5, 2]) == 3 assert count_unobstructed_trees([10, 9, 8, 7]) == 4 assert count_unobstructed_trees([3, 3, 3, 3]) == 1 ``` **Constraints/Limitations:** - The input list `heights` will have a length of at least 1 and at most 10^6. - Each element in `heights` will be a positive integer not exceeding 10^9.","solution":"def count_unobstructed_trees(heights): Returns the number of trees that are not overshadowed by any taller or equal tree to their right. Args: heights: List[int] - list of integers representing the height of trees. Returns: int - count of trees that are not overshadowed. max_height_from_right = 0 unobstructed_count = 0 for height in reversed(heights): if height > max_height_from_right: unobstructed_count += 1 max_height_from_right = height return unobstructed_count"},{"question":"# Question: Average Rainfall Calculator Problem Statement: You are required to implement a Python function that calculates the average rainfall over a specified number of days. The rainfall data for each day will be provided in a list. Function Signature: ```python def average_rainfall(rainfall_data: list) -> float: ``` Input: - **rainfall_data** (list): A list of float values representing the amount of rainfall (in millimeters) recorded for each day. (0 â‰¤ rainfall for any day â‰¤ 500) (0 â‰¤ length of list â‰¤ 1000) Output: - Returns the average rainfall (float) rounded to 2 decimal places. Constraints: - If the `rainfall_data` list is empty, return `0.00`. Examples: ```python >>> average_rainfall([0.0, 10.2, 5.1, 3.0, 0.0]) 3.66 >>> average_rainfall([25.0]) 25.0 >>> average_rainfall([]) 0.00 >>> average_rainfall([20.0, 22.5, 25.5, 28.0]) 24.00 >>> average_rainfall([0, 0, 0, 0]) 0.00 >>> average_rainfall([1.2, 2.4, 3.6, 4.8, 6.0]) 3.60 ``` Implementation: Use plain Python to implement the function. Ensure your function properly computes the average even when the list is empty or contains only zeros. The result should be rounded to 2 decimal places.","solution":"def average_rainfall(rainfall_data: list) -> float: Returns the average rainfall rounded to 2 decimal places. If the list is empty, returns 0.00. if not rainfall_data: return 0.00 average = sum(rainfall_data) / len(rainfall_data) return round(average, 2)"},{"question":"# Question: Efficiently Implement the Anagram Detection Algorithm As a software engineer, you are required to write a function to determine if two given strings are anagrams of each other. With various data transformation operations in the company\'s product, ensuring the rearranged data matches the original with precision is crucial. Your task is to write an optimized version of the anagram detection function that minimizes both time and space complexities. Implement robust handling for various edge cases, such as empty strings and case-insensitive comparisons. **Function Signature:** ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` **Input:** - Two strings `s1` and `s2` each of length `1 <= len(s1), len(s2) <= 10^5`, containing lowercase and uppercase alphabets. **Output:** - Return a boolean value `True` if the input strings `s1` and `s2` are anagrams, otherwise return `False`. **Constraints:** 1. Consider that \'A\' and \'a\' are the same characters (i.e., the function should be case-insensitive). 2. Optimize for both time and space complexity. **Examples:** ```python assert are_anagrams(\\"Listen\\", \\"Silent\\") == True assert are_anagrams(\\"Triangle\\", \\"Integral\\") == True assert are_anagrams(\\"Apple\\", \\"Papel\\") == True assert are_anagrams(\\"Hello\\", \\"World\\") == False assert are_anagrams(\\"Santa\\", \\"Satan\\") == True ``` **Scenario:** The function needs to handle large strings efficiently, ensuring minimal time and space consumption. Design your function to manage edge cases with no excessive resource use and deliver correct results for all valid input pairs.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, ignoring case; otherwise, False # Convert both strings to lower case to make the comparison case insensitive s1 = s1.lower() s2 = s2.lower() # If the lengths of the two strings are not the same, they cannot be anagrams if len(s1) != len(s2): return False # Count the frequency of each character in s1 and s2 from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Problem Statement You are given a string containing a series of 0s and 1s, which represents a binary number. Your task is to count the number of contiguous substrings containing an equal number of 0s and 1s. Each such substring must consist of consecutive 0s followed by consecutive 1s or consecutive 1s followed by consecutive 0s. # Function Signature ```python def count_binary_substrings(s: str) -> int: ``` # Input - `s` (str): A string containing only characters \'0\' and \'1\'. # Output - Return an integer representing the count of contiguous substrings with an equal number of 0s and 1s. # Constraints - ( 1 leq text{length of } s leq 10^5 ) - The string contains only \'0\'s and \'1\'s. # Example ```python s = \\"00110011\\" print(count_binary_substrings(s)) # Expected output: 6 ``` # Explanation The substrings with equal number of consecutive 0s and consecutive 1s are: - \\"0011\\", \\"01\\", \\"1100\\", \\"10\\", \\"0011\\", and \\"01\\" in the string \\"00110011\\". # Requirements 1. Implement the function `count_binary_substrings(s: str) -> int` that counts the number of valid contiguous substrings as per the given description. 2. Ensure that your implementation can efficiently handle larger input sizes within the constraints. # Tips - Traverse the string and keep track of consecutive groups of 0s and 1s. - Count and compare the lengths of these groups to find valid substrings. - Consider edge cases where there may be only one type of character.","solution":"def count_binary_substrings(s: str) -> int: Counts the number of contiguous substrings containing an equal number of 0s and 1s. # This will store the lengths of consecutive groups of 0s or 1s groups = [] current_count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_count += 1 else: groups.append(current_count) current_count = 1 # Don\'t forget to append the last counted group groups.append(current_count) # Now count the number of valid substrings result = 0 for i in range(1, len(groups)): result += min(groups[i - 1], groups[i]) return result"},{"question":"# Problem Statement You are tasked to implement a task scheduler that can schedule tasks based on their priority and the time they were added. Higher priority tasks should always be executed before lower priority ones. If two tasks have the same priority, the one which was added earlier should be executed first. The task scheduler should support adding tasks, retrieving the next task to execute, and retrieving statistics about the tasks such as the total number of tasks, the number of tasks by priority, and the average waiting time of the tasks. # Method Signatures ```python class TaskScheduler: def __init__(self): Initialize the TaskScheduler. pass def add_task(self, task_id: int, priority: int) -> None: Add a task to the scheduler with the given task_id and priority. Args: - task_id (int): The unique identifier of the task. - priority (int): The priority of the task (higher value means higher priority). pass def get_next_task(self) -> int | None: Retrieve the task_id of the highest priority task that was added first. Returns: - int: The task_id of the next task to execute or None if there are no tasks. pass def stats(self) -> dict[str, float]: Retrieve statistics about the tasks. Returns a dictionary containing: - \'total_tasks\' (int): The total number of tasks. - \'tasks_by_priority\' (dict[int, int]): A dictionary mapping priority to the number of tasks with that priority. - \'average_waiting_time\' (float): The average waiting time of the tasks (time from being added to when this function is called). Returns: - dict[str, float]: A dictionary with statistics as described above. pass ``` # Constraints - Task priorities can range from 1 to 10 (inclusive), where 10 is the highest priority. - Task IDs are unique. - The stats method should provide accurate results based on the operations performed on the TaskScheduler. # Example Usage ```python # Initialize TaskScheduler scheduler = TaskScheduler() # Add tasks to the scheduler scheduler.add_task(1, 5) scheduler.add_task(2, 7) scheduler.add_task(3, 5) # Get next task to execute assert scheduler.get_next_task() == 2 # returns 2, as it has the highest priority # Get next task to execute assert scheduler.get_next_task() == 1 # returns 1, as it was added before task 3 with the same priority # Get statistics stats = scheduler.stats() print(stats) # Might print: {\'total_tasks\': 1, \'tasks_by_priority\': {5: 1, 7: 0}, \'average_waiting_time\': 3.5} # Add more tasks scheduler.add_task(4, 10) scheduler.add_task(5, 3) # Get next task to execute assert scheduler.get_next_task() == 4 # returns 4, as it has the highest priority # Get next task to execute assert scheduler.get_next_task() == 3 # returns 3, as it is the remaining task with the highest priority ``` **Your task is to complete the implementation of the `TaskScheduler` class as specified above, ensuring correct scheduling and accurate statistics.**","solution":"import heapq import time from collections import defaultdict from typing import List, Tuple, Union class TaskScheduler: def __init__(self): Initialize the TaskScheduler. self.tasks_heap: List[Tuple[int, int, int, float]] = [] # (priority, timestamp, task_id) self.tasks_count: int = 0 self.priority_count: dict = defaultdict(int) self.tasks_timestamps: dict = {} self.current_time: float = time.time() def add_task(self, task_id: int, priority: int) -> None: Add a task to the scheduler with the given task_id and priority. timestamp = time.time() - self.current_time heapq.heappush(self.tasks_heap, (-priority, timestamp, task_id)) self.tasks_count += 1 self.priority_count[priority] += 1 self.tasks_timestamps[task_id] = timestamp def get_next_task(self) -> Union[int, None]: Retrieve the task_id of the highest priority task that was added first. if self.tasks_count == 0: return None priority, timestamp, task_id = heapq.heappop(self.tasks_heap) self.tasks_count -= 1 self.priority_count[-priority] -= 1 return task_id def stats(self) -> dict: Retrieve statistics about the tasks. if self.tasks_count == 0: average_waiting_time = 0 else: current_time = time.time() total_waiting_time = sum(current_time - self.current_time - tstamp for tstamp in self.tasks_timestamps.values()) average_waiting_time = total_waiting_time / self.tasks_count return { \'total_tasks\': self.tasks_count, \'tasks_by_priority\': dict(self.priority_count), \'average_waiting_time\': average_waiting_time }"},{"question":"# Coding Question: Implementing a Custom Key-Value Store with Expiry Context You are designing a simple in-memory key-value store where keys are associated with values and expiry times. A value should be removed from the store once its expiry time is reached. If an expiry time is not specified, the value should remain in the store indefinitely. Additionally, the store should support basic operations like adding, retrieving, and removing values. Task Using Python, write a class `ExpiringKeyValueStore` that implements the following methods: `set`, `get`, and `remove`. The class should manage the expiry of keys accordingly. Class Definition ```python class ExpiringKeyValueStore: def __init__(self): Initializes the key-value store. pass def set(self, key: str, value: int, expiry: int = None): Sets the (key, value) pair in the store with an optional expiry time. Args: key: The key as a string. value: The associated value as an integer. expiry: The expiry time in seconds from now (optional). Example: store = ExpiringKeyValueStore() store.set(\\"key1\\", 100, 10) store.set(\\"key2\\", 200) pass def get(self, key: str) -> int: Gets the value associated with the key if it exists and is not expired. Args: key: The key as a string. Returns: The integer value associated with the key or -1 if the key does not exist or is expired. Example: store = ExpiringKeyValueStore() store.set(\\"key1\\", 100, 10) assert store.get(\\"key1\\") == 100 time.sleep(10) assert store.get(\\"key1\\") == -1 pass def remove(self, key: str): Removes the key and its associated value from the store if it exists. Args: key: The key as a string. Example: store = ExpiringKeyValueStore() store.set(\\"key1\\", 100) store.remove(\\"key1\\") assert store.get(\\"key1\\") == -1 pass ``` Requirements * The `ExpiringKeyValueStore` should handle setting, getting, and removing key-value pairs. * The `set` method should allow setting an optional expiry time for each key-value pair. If the expiry time is reached or exceeded, the key-value pair should automatically become inaccessible. * The `get` method should return the value associated with the key if it exists and is not expired; otherwise, return -1. * The `remove` method should remove the key-value pair from the store if the key exists. * Ensure correct handling of expiry by checking the current time against the expiry time. * You can use Pythonâ€™s `time` module to manage timings and expiry. Constraints - The `key` will be a non-empty string. - The `value` will be an integer. - The `expiry` parameter, if provided, will be a positive integer representing the number of seconds from the current time. # Example Usage ```python import time store = ExpiringKeyValueStore() # Setting values store.set(\\"key1\\", 100, 2) # key1 expires in 2 seconds store.set(\\"key2\\", 200) # key2 never expires # Getting values print(store.get(\\"key1\\")) # Output: 100 time.sleep(3) print(store.get(\\"key1\\")) # Output: -1 (since it expired) print(store.get(\\"key2\\")) # Output: 200 (still accessible) # Removing values store.remove(\\"key2\\") print(store.get(\\"key2\\")) # Output: -1 (since it was removed) ```","solution":"import time class ExpiringKeyValueStore: def __init__(self): Initializes the key-value store. self.store = {} self.expiry_times = {} def set(self, key: str, value: int, expiry: int = None): Sets the (key, value) pair in the store with an optional expiry time. Args: key: The key as a string. value: The associated value as an integer. expiry: The expiry time in seconds from now (optional). self.store[key] = value if expiry is not None: self.expiry_times[key] = time.time() + expiry elif key in self.expiry_times: del self.expiry_times[key] def get(self, key: str) -> int: Gets the value associated with the key if it exists and is not expired. Args: key: The key as a string. Returns: The integer value associated with the key or -1 if the key does not exist or is expired. if key not in self.store: return -1 if key in self.expiry_times and time.time() > self.expiry_times[key]: self.remove(key) return -1 return self.store.get(key, -1) def remove(self, key: str): Removes the key and its associated value from the store if it exists. Args: key: The key as a string. if key in self.store: del self.store[key] if key in self.expiry_times: del self.expiry_times[key]"},{"question":"# Coding Assessment Question # String Transformation and Analysis You are tasked with writing a function that performs several transformations on a given string and then analyzes the final result. The function operations will include reversing the string, converting it to uppercase, and then performing a frequency analysis of each character in the resulting string. Here are the steps you need to follow: 1. Write a function that takes a string and returns the string reversed. 2. Write a function that takes the reversed string and converts all characters to uppercase. 3. Write a function that takes the uppercase string and performs frequency analysis, returning a dictionary where keys are characters and values are their respective counts. 4. Handle exceptions for cases where the input is not a string by raising a relevant Python exception. Function Specifications 1. **transform_and_analyze** - **Input**: A string. - **Output**: A dictionary with character frequency counts of the transformed string. - **Constraints**: - The input must be a valid string. - Handle potential type errors gracefully. - **Performance Requirements**: - Implementations should have a time complexity of O(n). Example ```python def transform_and_analyze(s): # Your solution here # Example Usage s = \\"Hello, World!\\" print(transform_and_analyze(s)) # Output: {\'!\': 1, \'D\': 1, \'L\': 3, \'R\': 1, \'O\': 2, \'W\': 1, \' \': 1, \',\': 1, \'E\': 1, \'H\': 1} ```","solution":"def transform_and_analyze(s): Takes a string, reverses it, converts it to uppercase, and performs a frequency analysis. Args: s (str): The input string. Returns: dict: A dictionary with characters as keys and their frequency counts as values. Raises: TypeError: If the input is not a string. # Check if input is a string if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") # Step 1: Reverse the string reversed_string = s[::-1] # Step 2: Convert the reversed string to uppercase uppercased_string = reversed_string.upper() # Step 3: Perform frequency analysis frequency_dict = {} for char in uppercased_string: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Problem Description You are required to implement a `ParkingLot` class which will be initialized with a given capacity of parking spots. The parking lot should support the following operations: - `park(car_license: str)`: Parks a car with the given license number. If the parking lot is full, it will not park the car and return a message indicating the lot is full. - `leave(car_license: str)`: Removes the car with the given license number from the parking lot. If this car is not found, return a message indicating the car was not found. - `status() -> List[str]`: Returns a list of all cars currently parked in the parking lot, in the order they were parked. **Input Constraints** - `parking_lot_capacity: int` (1 â‰¤ parking_lot_capacity â‰¤ 10^4) - Car license numbers are strings which will be unique within the parking lot at any time. **Output Description** - Implement the specified functions. - Your parking lot must support efficient operations with correct time complexities: - `park`: O(1) for parking a new car. - `leave`: O(1) to remove a car. - `status`: O(n) to list all cars currently parked, where n is the number of cars in the parking lot. **Example Input** ```python parking_lot = ParkingLot(3) print(parking_lot.park(\\"ABC123\\")) # Output: None print(parking_lot.park(\\"XYZ789\\")) # Output: None print(parking_lot.park(\\"DEF456\\")) # Output: None print(parking_lot.status()) # Output: [\'ABC123\', \'XYZ789\', \'DEF456\'] print(parking_lot.park(\\"LMN321\\")) # Output: \\"Parking lot is full\\" print(parking_lot.leave(\\"XYZ789\\")) # Output: None print(parking_lot.status()) # Output: [\'ABC123\', \'DEF456\'] print(parking_lot.leave(\\"XYZ789\\")) # Output: \\"Car not found in the parking lot\\" print(parking_lot.status()) # Output: [\'ABC123\', \'DEF456\'] ``` **Detailed Instructions** 1. Implement the `ParkingLot` class with: - An `__init__` method to initialize the parking lot size. - A `park` method to add a car to the parking lot. - A `leave` method to remove a car from the parking lot. - A `status` method to view the current state of the parking lot.","solution":"class ParkingLot: def __init__(self, capacity): self.capacity = capacity self.cars = [] self.car_set = set() def park(self, car_license): if len(self.cars) >= self.capacity: return \\"Parking lot is full\\" if car_license in self.car_set: return \\"Car already parked\\" self.cars.append(car_license) self.car_set.add(car_license) def leave(self, car_license): if car_license not in self.car_set: return \\"Car not found in the parking lot\\" self.cars.remove(car_license) self.car_set.remove(car_license) def status(self): return self.cars"},{"question":"# Given Problem You are required to implement a function to convert a given number of seconds into a formatted string representing the equivalent duration in a combination of days, hours, minutes, and seconds. # Requirements 1. **Function Name**: `format_duration` 2. **Arguments**: - `seconds` (int): The total number of seconds representing the duration to be converted. 3. **Output**: Return a string in the format `\\"{d} days, {h} hours, {m} minutes, and {s} seconds\\"` where `d`, `h`, `m`, and `s` are the computed days, hours, minutes, and seconds respectively. 4. **Constraints**: - The input seconds must be non-negative, or raise a `ValueError` if it is negative. - Ensure that singular form (e.g., \\"1 day\\") and plural form (e.g., \\"2 days\\") are correctly used. # Examples ```python # Basic Examples format_duration(0) # Output: \\"0 seconds\\" format_duration(3661) # Output: \\"1 hour, 1 minute, and 1 second\\" format_duration(86400) # Output: \\"1 day\\" format_duration(90061) # Output: \\"1 day, 1 hour, 1 minute, and 1 second\\" format_duration(172800) # Output: \\"2 days\\" ``` # Implementation Write the function `format_duration` to meet the above requirements. **Function Signature**: ```python def format_duration(seconds: int) -> str: pass ``` **Notes**: - Handle formatting edge cases, such as zero values appropriately or when specific units should be singular or plural. - Include checks for invalid or out-of-bounds inputs. **Helper Code** (Optional): ```python def pluralize(value, unit): return f\\"{value} {unit}\\" if value == 1 else f\\"{value} {unit}s\\" ``` Implement the `format_duration` function considering different time units and the correct English grammar rules for singular and plural forms.","solution":"def pluralize(value, unit): return f\\"{value} {unit}\\" if value == 1 else f\\"{value} {unit}s\\" def format_duration(seconds: int) -> str: if seconds < 0: raise ValueError(\\"Seconds must be non-negative\\") if seconds == 0: return \\"0 seconds\\" days, seconds = divmod(seconds, 86400) hours, seconds = divmod(seconds, 3600) minutes, seconds = divmod(seconds, 60) parts = [] if days: parts.append(pluralize(days, \\"day\\")) if hours: parts.append(pluralize(hours, \\"hour\\")) if minutes: parts.append(pluralize(minutes, \\"minute\\")) if seconds: parts.append(pluralize(seconds, \\"second\\")) if len(parts) == 1: return parts[0] if len(parts) == 2: return f\\"{parts[0]} and {parts[1]}\\" return \\", \\".join(parts[:-1]) + f\\", and {parts[-1]}\\""},{"question":"# Coding Assessment Question: Highest Average Subarray Problem Statement: You are given an array of integers and a positive integer `k` (1 <= k <= length of array). Your task is to write a function that finds the k-length contiguous subarray with the highest average value and returns that average. Function Signature: ```python def find_highest_average(nums: list[int], k: int) -> float: pass ``` Inputs: - `nums` (list[int]): An array of integers (1 <= length <= 10^5, -10^4 <= nums[i] <= 10^4). - `k` (int): The length of the subarray (1 <= k <= length). Outputs: - Returns a float representing the highest average value of a contiguous subarray with length `k`. Constraints: 1. The function should be efficient to handle large inputs up to the maximum constraints. Example: ```python nums = [1, 12, -5, -6, 50, 3] k = 4 assert find_highest_average(nums, k) == 12.75 nums = [5, 5, 5, 5] k = 2 assert find_highest_average(nums, k) == 5.0 ``` The function should correctly handle various test cases, including negative values in the array and large input sizes efficiently. Hints: - Use a sliding window technique to maintain the sum of the k-length subarray. - Update the highest average value as you slide the window across the array.","solution":"def find_highest_average(nums: list[int], k: int) -> float: Finds the k-length contiguous subarray with the highest average value and returns that average. n = len(nums) if n == 0 or k <= 0 or k > n: return 0.0 # Calculate the initial sum of the first window of size k current_sum = sum(nums[:k]) max_sum = current_sum # Slide the window across the array for i in range(k, n): current_sum = current_sum - nums[i - k] + nums[i] if current_sum > max_sum: max_sum = current_sum # Return the highest average return max_sum / k"},{"question":"# Tree Diameter Calculation **Context**: You are working on a network analysis project where you need to understand the structure and size of various connected components. One such measure is the diameter of a tree, which is a connected graph without cycles. The diameter of a tree is the longest path between any two nodes. **Problem Statement**: Implement a function `tree_diameter` that calculates the diameter of a given tree. The tree is represented as an undirected, connected graph without cycles using an adjacency list, where nodes are labeled with consecutive integers starting from 0. # Function Signature ```python def tree_diameter(adjacency_list: List[List[int]]) -> int: pass ``` # Input - **adjacency_list (List[List[int]])**: A list of lists where `adjacency_list[i]` contains the list of nodes connected to node `i`. # Output - **int**: The diameter of the tree. # Constraints 1. The number of nodes in the tree will be between 2 and 10^4. 2. The adjacency list will represent a correctly formed tree (a connected acyclic graph). # Examples ```python # Example 1 adj_list = [ [1, 2], [0, 3, 4], [0], [1], [1] ] print(tree_diameter(adj_list)) # Output: 3 # Example 2 adj_list = [ [1], [0, 2], [1, 3], [2, 4], [3] ] print(tree_diameter(adj_list)) # Output: 4 ``` # Notes 1. Your function should be efficient to handle the upper constraint of the number of nodes. 2. You may assume the input is always a valid tree. 3. Consider using a breadth-first search (BFS) or depth-first search (DFS) to find the longest path by first finding the furthest node from any node, and then finding the maximum distance from this furthest node. **Testing**: Make sure to test edge cases where: 1. The tree has the minimum number of nodes (2). 2. The tree has nodes with varying degrees. 3. The tree is skewed or forms a straight line.","solution":"from collections import deque from typing import List def tree_diameter(adjacency_list: List[List[int]]) -> int: def bfs(farthest_node): q = deque([farthest_node]) distances = [-1] * len(adjacency_list) distances[farthest_node] = 0 max_distance = 0 farthest_node = farthest_node while q: current_node = q.popleft() current_distance = distances[current_node] for neighbor in adjacency_list[current_node]: if distances[neighbor] == -1: # not visited distances[neighbor] = current_distance + 1 q.append(neighbor) if distances[neighbor] > max_distance: max_distance = distances[neighbor] farthest_node = neighbor return farthest_node, max_distance # Step 1: Use BFS to find the farthest node from node 0 farthest_node, _ = bfs(0) # Step 2: Use BFS from the farthest node found to find the diameter _, diameter = bfs(farthest_node) return diameter"},{"question":"# Binary Tree Vertical Order Traversal Objective: You need to implement a method that performs a vertical order traversal of a binary tree. Vertical order traversal is the column-wise traversal of the tree nodes, where columns are defined based on their horizontal distance from the root. Function Signature: ```python def vertical_order_traversal(root: TreeNode) -> List[List[int]]: Returns the vertical order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: A list of lists, where each sublist contains the nodes on a specific vertical line, starting from left-most vertical to the right-most vertical. ``` Input: * `root`: An instance of `TreeNode`, representing the root of the binary tree. Output: * A list of lists. Each sublist contains the values of the nodes in a particular vertical column in top-to-bottom order. Constraints: * The tree might be empty. * Nodes in the same horizontal distance and level appear in the output in the order in which they appear while traversing from left to right. * Each node value is an integer. * You may assume the `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Example: ```python # Given binary tree: # 3 # / # 9 8 # / / # 4 0 1 7 # # 2 # # The vertical order traversal is: # [ # [4], # [9], # [3, 0, 1], # [8, 2], # [7] # ] root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(8) root.left.left = TreeNode(4) root.left.right = TreeNode(0) root.right.left = TreeNode(1) root.right.right = TreeNode(7) root.right.left.right = TreeNode(2) assert vertical_order_traversal(root) == [[4], [9], [3, 0, 1], [8, 2], [7]] ``` Notes: * Consider using a breadth-first search (BFS) approach to traverse the binary tree. * You might need a hash map to keep track of the nodes based on their horizontal distances. * Ensure that nodes appearing first come first in the result list for the same vertical line.","solution":"from collections import defaultdict, deque from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def vertical_order_traversal(root: TreeNode) -> List[List[int]]: if not root: return [] # Dictionary to store the vertical order traversal column_table = defaultdict(list) # Queue to perform BFS; stores pairs of node and its column index queue = deque([(root, 0)]) while queue: node, column = queue.popleft() if node is not None: column_table[column].append(node.val) if node.left: queue.append((node.left, column - 1)) if node.right: queue.append((node.right, column + 1)) # Sort the dictionary by column index and extract the values sorted_columns = sorted(column_table.keys()) return [column_table[col] for col in sorted_columns]"},{"question":"# String Compression Challenge The goal of this exercise is to implement a runtime string compression algorithm as might be used in a simple file compression application. Given a string, your task is to compress it using the counts of repeated characters. The compressed string should only be returned if it would save space, otherwise, return the original string. Implement the function `compress_string(s: str) -> str` where: * The input `s` is a string containing only uppercase and lowercase English letters. * The function should return a compressed version of the string or the original string if compression does not reduce its size. # Requirements: 1. **Character Counting**: Count the consecutive repeating characters in the string. 2. **Compression Format**: The format of the compression is the character followed by the number of times it repeats consecutively. For example, the string \\"aabcccccaaa\\" compresses to \\"a2b1c5a3\\". 3. **Space Efficiency**: If the compressed string is not shorter than the original string, return the original string. # Input * A string `s`. # Output * A string, being either the compressed version of `s` if it\'s shorter, or `s` itself if compression doesn\'t save space. # Examples ```python >>> compress_string(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> compress_string(\\"abcdef\\") \'abcdef\' >>> compress_string(\\"aabbcc\\") \'aabbcc\' >>> compress_string(\\"aabbaa\\") \'a2b2a2\' >>> compress_string(\\"aaabbbccc\\") \'a3b3c3\' ``` # Constraints * The function should handle edge cases where the string is empty or contains only one character. * The solution should be efficient in terms of both time and space complexity.","solution":"def compress_string(s: str) -> str: if not s: return s compressed_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_str.append(s[i - 1] + str(count)) count = 1 # Append the last character and its count compressed_str.append(s[-1] + str(count)) compressed_result = \'\'.join(compressed_str) return compressed_result if len(compressed_result) < len(s) else s"},{"question":"# Problem Statement You are tasked with writing a function that takes a list of integers and returns the length of the longest contiguous subarray with an equal number of 0s and 1s. This function will be essential in analyzing binary data structures. Function Signature ```python def find_max_length(nums: List[int]) -> int: ``` Input * **nums (List[int])**: A list of integers containing only 0s and 1s, e.g., [0, 1, 0, 1, 1, 0]. Output * **(int)**: The length of the longest contiguous subarray with an equal number of 0s and 1s. Constraints * The length of `nums` is between `1` and `10^5`. * Each element in the list `nums` is either `0` or `1`. Performance Requirements * The function should run in linear time relative to the length of the input list. Examples ```python >>> find_max_length([0, 1]) 2 >>> find_max_length([0, 1, 0]) 2 >>> find_max_length([0, 1, 0, 1, 1, 0, 1]) 6 >>> find_max_length([0, 0, 1, 1, 0, 1]) 6 ``` Context Analyzing binary data structures or binary communication streams often requires identifying patterns such as balancing sets of 0s and 1s. This function will help in such analyses by identifying the longest balanced subarray, which can be crucial in error detection and correction algorithms as well as data compression schemes. Ensure your solution correctly implements the steps mentioned in the analysis and passes all test cases including edge cases.","solution":"def find_max_length(nums): count_map = {0: -1} # Dictionary to store the count indices max_length = 0 count = 0 for i in range(len(nums)): if nums[i] == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"Problem: Rotate Matrix You are given an NxN matrix representing an image. Your task is to rotate the image by 90 degrees clockwise in-place. # Input 1. An integer **N** (1 <= N <= 20) denoting the order of the square matrix. 2. A square NxN matrix (provided as a list of lists) containing integers. # Output 1. The rotated matrix. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Example Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix)) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Example 2: ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] print(rotate_matrix(matrix)) # Output: [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` # Notes 1. The rotation should be done in-place, meaning you should not use any additional memory for another matrix to perform the operation. 2. Focus on identifying patterns in the indices transformations during the rotation to achieve the result without extra space. 3. Properly read the input format and ensure the output format matches the examples. # Hints - A good approach might involve first transposing the matrix and then reversing each row to achieve a clockwise rotation. - This problem can be simplified by visualizing the position changes step-by-step and implementing accordingly.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse() return matrix"},{"question":"# Question: You are given an integer array and a non-negative integer, `n`. Write a Python function `rotate_array` that rotates the array to the right by `n` positions. After rotating, the elements that fall off the end are wrapped around to the beginning of the array. Input Format: - An integer (1 â‰¤é•¿åº¦ â‰¤ 1000), representing the length of the array. - An array of integers. - An integer `n` (0 â‰¤é•¿åº¦ â‰¤ 1000), representing the number of positions to rotate the array. Output Format: - An array of integers, showing the rotated version of the input array. Constraints: - The function should handle both cases when `n` is smaller than and greater than the length of the array. - You should not use any built-in array rotation functions. - The function should work for empty arrays, returning an empty array if the input array is empty. Example: ```python def rotate_array(arr: list, n: int) -> list: pass assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3], 4) == [3, 1, 2] assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert rotate_array([], 1) == [] assert rotate_array([5], 3) == [5] ``` Provide your implementation of the `rotate_array` function below: ```python def rotate_array(arr: list, n: int) -> list: if not arr: return [] # Ensure n is within the length of the array n = n % len(arr) # Rotate the array rotated_array = arr[-n:] + arr[:-n] return rotated_array # Test cases for validation print(rotate_array([1, 2, 3, 4, 5], 2)) # Expected: [4, 5, 1, 2, 3] print(rotate_array([1, 2, 3], 4)) # Expected: [3, 1, 2] print(rotate_array([1, 2, 3, 4, 5], 0)) # Expected: [1, 2, 3, 4, 5] print(rotate_array([], 1)) # Expected: [] print(rotate_array([5], 3)) # Expected: [5] ``` Ensure your function covers all edge cases and is optimized for performance and memory utilization.","solution":"def rotate_array(arr: list, n: int) -> list: if not arr: return [] # Ensure n is within the length of the array n = n % len(arr) # Rotate the array rotated_array = arr[-n:] + arr[:-n] return rotated_array"},{"question":"# Coding Assessment Question As a software developer, you are assigned the task of extending an e-commerce platform\'s payment gateway integration to support multiple payment providers. Your goal is to create a more flexible and fault-tolerant system that can handle payment processing through different providers while maintaining a high success rate. Your tasks are: 1. **Implement a function to fetch and execute a payment request from a specified payment provider.** - The function should accept payment details and a provider name (e.g., \\"Stripe\\", \\"PayPal\\"). - It should handle the request based on the provider, constructing the appropriate API call for each. 2. **Enhance error handling:** - Implement a comprehensive error management system to deal with network issues, API errors, and invalid payment details. - Ensure the implementation logs relevant error messages and retries the payment request up to a defined number of times. 3. **Support multiple providers:** - Modify the system to switch between multiple providers seamlessly. Start with support for \\"Stripe\\" and \\"PayPal\\". - Create a configuration mechanism where adding new providers can be done with minimal code changes. 4. **Optimize payment validation:** - Improve the payment validation function to check for common issues such as expired cards, insufficient funds, and validation of CVV numbers. - Ensure the function efficiently handles these checks and provides clear feedback on validation failures. **Input:** - Payment details including card number, expiry date, CVV, amount, and currency. - A string representing the payment provider. - An integer representing the retry limit for failed payment requests. **Output:** - A confirmation message indicating the success or failure of the payment process, with appropriate error messages in case of failures. **Constraints:** - Ensure that invalid payment details are caught before making the API call. - Handle up to 3 retries for failed payment requests. - Providers must support a standardized API response format for success and failure. **Scenario Context:** Consider a growing e-commerce company that needs to diversify its payment options to provide a better user experience. They aim to integrate with multiple payment providers to ensure high availability and reliability in their payment processing system.","solution":"import requests class PaymentProvider: def __init__(self, name, api_url, api_key): self.name = name self.api_url = api_url self.api_key = api_key def execute_payment(self, payment_details): try: response = requests.post(self.api_url, json=payment_details, headers={\'Authorization\': f\'Bearer {self.api_key}\'}) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: return {\'status\': \'error\', \'message\': str(e)} # Dummy configurations for Stripe and PayPal providers_config = { \'Stripe\': PaymentProvider(\'Stripe\', \'https://api.stripe.com/v1/charges\', \'YOUR_STRIPE_API_KEY\'), \'PayPal\': PaymentProvider(\'PayPal\', \'https://api.paypal.com/v1/payments/payment\', \'YOUR_PAYPAL_API_KEY\') } def validate_payment_details(payment_details): required_fields = [\'card_number\', \'expiry_date\', \'cvv\', \'amount\', \'currency\'] for field in required_fields: if field not in payment_details or not payment_details[field]: return (False, f\\"Missing or empty field: {field}\\") # Placeholder for more advanced validation logic if len(str(payment_details[\'cvv\'])) != 3: return (False, \\"Invalid CVV length\\") return (True, \\"\\") def process_payment(payment_details, provider_name, retry_limit): is_valid, validation_message = validate_payment_details(payment_details) if not is_valid: return f\\"Validation Error: {validation_message}\\" provider = providers_config.get(provider_name) if not provider: return f\\"Error: Unsupported provider {provider_name}\\" for attempt in range(retry_limit): result = provider.execute_payment(payment_details) if result.get(\'status\') == \'success\': return f\\"Payment successful: {result.get(\'message\', \'\')}\\" else: error_message = result.get(\'message\', \'Unknown error\') continue return f\\"Payment failed after {retry_limit} attempts: {error_message}\\""},{"question":"# Coding Question: Custom Square Root Function Context Computing the square root of a number is a common task in various mathematical and computational problems. You are tasked with designing a custom implementation of the `sqrt()` function using a numerical method, such as the Babylonian (or Heron\'s) method. This will test your understanding of iterative numerical algorithms and precision handling. Problem Statement Write a function `custom_sqrt(x: float) -> float` that returns the square root of `x` calculated using the Babylonian method. Input - A single float value `x`. Output - A float representing the square root of `x`. Constraints - Your implementation must use the Babylonian method for calculating the square root. - You should handle edge cases such as positive values, zero, and small precision errors. - You must implement the logic directly without using any library functions like `math.sqrt`. Example ```python def custom_sqrt(x: float) -> float: if x < 0: raise ValueError(\\"Negative input\\") if x == 0: return 0.0 # Initial guess can be x / 2 or a better guess guess = x / 2.0 tolerance = 1e-7 # Define the precision tolerance while abs(guess * guess - x) > tolerance: guess = (guess + x / guess) / 2.0 return guess # Examples to test your solution print(custom_sqrt(4.0)) # Expected output: 2.0 print(custom_sqrt(0.0)) # Expected output: 0.0 print(custom_sqrt(1.0)) # Expected output: 1.0 print(custom_sqrt(2.0)) # Expected output: approximately 1.4142135 print(custom_sqrt(9.0)) # Expected output: 3.0 print(custom_sqrt(1_000_000.0)) # Expected output: approximately 1000.0 ``` Additional Requirements - Your solution must converge reasonably fast and handle precision efficiently. - Ensure that the function works for very large and very small floating-point numbers. - Include proper error handling for non-positive inputs.","solution":"def custom_sqrt(x: float) -> float: Returns the square root of x calculated using the Babylonian method. if x < 0: raise ValueError(\\"Negative input\\") if x == 0: return 0.0 guess = x / 2.0 tolerance = 1e-7 # Define the precision tolerance while abs(guess * guess - x) > tolerance: guess = (guess + x / guess) / 2.0 return guess"},{"question":"# Scenario You are building a utility that generates a summary of sales transactions for a particular product category. Each transaction includes the product name, quantity sold, and sale amount. You need to organize this data based on product names, summing up the quantities and total sales for each product. # Task Write a function: 1. `summarize_sales(transactions: list) -> dict` - This function should take a list of sales transactions and return a dictionary summarizing the total quantities and sales amounts for each unique product. # Constraints * Each transaction in the input list is represented as a tuple: `(product_name: str, quantity_sold: int, sale_amount: float)`. * The product names are case-sensitive and may contain spaces. * Quantities and sale amounts are guaranteed to be non-negative. # Input and Output Formats * **Function**: * Input: A list of tuples, where each tuple contains a product name, quantity sold, and the sale amount. * Output: A dictionary where keys are product names and values are another dictionary with keys `quantity` and `total_sales`. --- # Example ```python >>> transactions = [ (\\"Product A\\", 10, 100.0), (\\"Product B\\", 5, 50.0), (\\"Product A\\", 7, 70.0), (\\"Product A\\", 3, 30.0), (\\"Product B\\", 2, 20.0) ] >>> summarize_sales(transactions) { \\"Product A\\": {\\"quantity\\": 20, \\"total_sales\\": 200.0}, \\"Product B\\": {\\"quantity\\": 7, \\"total_sales\\": 70.0} } ``` # Edge Cases 1. No transactions: ```python >>> summarize_sales([]) {} ``` 2. Single transaction: ```python >>> summarize_sales([(\\"Product X\\", 1, 10.0)]) { \\"Product X\\": {\\"quantity\\": 1, \\"total_sales\\": 10.0} } ``` 3. Multiple transactions for the same product with zero quantity or sales amount: ```python >>> summarize_sales([(\\"Product Y\\", 0, 0.0), (\\"Product Y\\", 5, 0.0)]) { \\"Product Y\\": {\\"quantity\\": 5, \\"total_sales\\": 0.0} } ``` Ensure the function handles these scenarios correctly.","solution":"def summarize_sales(transactions): Summarize the total quantities and sales amounts for each unique product. Args: transactions (list): List of tuples where each tuple contains a product name (str), quantity sold (int), and sale amount (float). Returns: dict: Dictionary summarizing sales by product names with total quantities and sales amounts. summary = {} for product, quantity, amount in transactions: if product in summary: summary[product][\\"quantity\\"] += quantity summary[product][\\"total_sales\\"] += amount else: summary[product] = {\\"quantity\\": quantity, \\"total_sales\\": amount} return summary"},{"question":"# Extended Binary Search for Rotated Sorted Array **Scenario**: Imagine you are a backend developer at a logistics company. The company uses a large database to store information about delivery trucks scheduled on rotating shifts. The delivery schedules are stored in ascending order, but at any given time, the array may have been rotated at a pivot unknown to you. For instance, an array that was `[1, 2, 3, 4, 5, 6, 7]` might now be `[4, 5, 6, 7, 1, 2, 3]`. You need to implement an efficient search in this rotated array to find whether a given truck schedule (number) exists. # Problem Statement Write a function `search_in_rotated_array` which searches for a target number in a rotated sorted array. **Function Signature** ```python def search_in_rotated_array(nums: list[int], target: int) -> int: pass ``` **Input/Output Format** * **Input**: - `nums` - A list of integers sorted in ascending order but possibly rotated. - `target` - An integer representing the truck schedule number to search. * **Output**: - The index of the target number in the list if it is found, otherwise return -1. **Constraints** * `nums` may contain up to 10^5 elements. * Each element in `nums` will be within the range from -10^6 to 10^6. * Elements in `nums` are unique. # Constraints/Edge Cases to Consider 1. Empty array 2. Array without rotation 3. Array with only one element 4. Target not present in the array 5. All positive or all negative integers # Additional Requirements Besides implementing the `search_in_rotated_array` function, provide a brief discussion on the time complexity of the approach and why itâ€™s efficient for large input sizes. **Example** ```python nums = [4, 5, 6, 7, 0, 1, 2] target = 0 result = search_in_rotated_array(nums, target) print(result) # Output: 4 ```","solution":"def search_in_rotated_array(nums, target): Function to search for a target in a rotated sorted array. Returns the index of the target if found, otherwise returns -1. if not nums: return -1 low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] == target: return mid # Determine which part is sorted if nums[low] <= nums[mid]: if nums[low] <= target < nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] < target <= nums[high]: low = mid + 1 else: high = mid - 1 return -1 # Time Complexity Discussion: # The time complexity of this approach is O(log n) due to the binary search algorithm. # This is efficient for large input sizes up to 10^5 elements, # as the search space is halved in each iteration."},{"question":"# Scenario You are developing a software system for managing the inventory of a library. One of the core functionalities required is to manage the borrowing and returning of books. You need to ensure that the system keeps track of which books are currently borrowed and who has borrowed them. # Task Write a class `Library` that simulates the borrowing and returning process of books. Your task is to implement methods that allow borrowing and returning of books while maintaining the current status of each book. # Class Signature ```python class Library: def __init__(self, books: List[str]): pass def borrow_book(self, book: str, borrower: str) -> str: pass def return_book(self, book: str) -> str: pass def status(self) -> Dict[str, Optional[str]]: pass ``` # Input - `__init__(self, books: List[str])`: A list of book titles available in the library. - `borrow_book(self, book: str, borrower: str) -> str`: - `book` (str): The title of the book to borrow. - `borrower` (str): The name of the person borrowing the book. - `return_book(self, book: str) -> str`: - `book` (str): The title of the book being returned. # Output - `__init__`: Initializes the library with the provided books, setting them as available. - `borrow_book`: Returns a status message indicating the result of the borrowing action (`\\"Book borrowed\\"` or `\\"Book not available\\"`). - `return_book`: Returns a status message indicating the result of the return action (`\\"Book returned\\"` or `\\"Book was not borrowed\\"`). - `status`: Returns a dictionary where the keys are book titles and the values are either the borrower\'s name (if the book is borrowed) or `None` (if the book is available). # Constraints - A book can only be borrowed if it is available. - A book can only be returned if it was borrowed. # Examples ```python # Example 1 library = Library([\'The Great Gatsby\', \'1984\', \'To Kill a Mockingbird\']) print(library.borrow_book(\'1984\', \'Alice\')) # Output: \'Book borrowed\' print(library.borrow_book(\'1984\', \'Bob\')) # Output: \'Book not available\' print(library.return_book(\'1984\')) # Output: \'Book returned\' print(library.return_book(\'1984\')) # Output: \'Book was not borrowed\' print(library.status()) # Output: {\'The Great Gatsby\': None, \'1984\': None, \'To Kill a Mockingbird\': None} # Example 2 library = Library([\'Moby Dick\', \'War and Peace\']) print(library.borrow_book(\'War and Peace\', \'Charlie\')) # Output: \'Book borrowed\' print(library.status()) # Output: {\'Moby Dick\': None, \'War and Peace\': \'Charlie\'} ``` # Notes - Ensure proper handling of cases where a book is already borrowed or attempted to be returned without being borrowed. - Maintain clear and accurate status tracking for the books in the library.","solution":"from typing import List, Dict, Optional class Library: def __init__(self, books: List[str]): self.books = {book: None for book in books} def borrow_book(self, book: str, borrower: str) -> str: if book in self.books: if self.books[book] is None: self.books[book] = borrower return \'Book borrowed\' else: return \'Book not available\' else: return \'Book does not exist in the library\' def return_book(self, book: str) -> str: if book in self.books: if self.books[book] is not None: self.books[book] = None return \'Book returned\' else: return \'Book was not borrowed\' else: return \'Book does not exist in the library\' def status(self) -> Dict[str, Optional[str]]: return self.books"},{"question":"# Question: RLE Compression and Decompression You are tasked with implementing two functions: `compress` and `decompress`. These functions will implement Run-Length Encoding (RLE) for compressing a string and then decompress it back into its original form. Function Requirements: 1. **Function `compress`**: - **Input**: A string `s` containing only uppercase alphabetic characters (A-Z). - **Output**: A compressed string using run-length encoding where each group of the same character is represented by the character followed by the number of times it repeats consecutively. If a character appears only once, it should still be followed by the number 1. 2. **Function `decompress`**: - **Input**: A compressed string `cs` using the format created by the `compress` function. - **Output**: The original uncompressed string. Constraints: - The input to `compress` will be a non-empty string and only contain uppercase alphabetic characters. - The input to `decompress` will be a valid RLE compressed string. Examples: ```python def compress(s: str) -> str: # Your implementation here def decompress(cs: str) -> str: # Your implementation here # Example 1: # Input: \\"AAABBCCCCDDDDE\\" # Output (compress): \\"A3B2C4D4E1\\" # Explanation: # \'A\' -> 3 times, \'B\' -> 2 times, \'C\' -> 4 times, \'D\' -> 4 times, \'E\' -> 1 time # Example 2: # Input (compress): \\"A3B2C4D4E1\\" # Output: \\"AAABBCCCCDDDDE\\" # Explanation: # \'A3\' -> \'AAA\', \'B2\' -> \'BB\', \'C4\' -> \'CCCC\', \'D4\' -> \'DDDD\', \'E1\' -> \'E\' ``` Implement the `compress` and `decompress` functions to meet the specifications above. Ensure your implementation efficiently handles edge cases and adheres to the constraints. Testing: Make sure to test your functions with a variety of inputs, including edge cases such as: - Strings with only one character repeated. - Long strings with no repeated characters. - Strings with mixed patterns of character repetition.","solution":"def compress(s: str) -> str: Compresses a string using Run-Length Encoding. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return \\"\\".join(compressed) def decompress(cs: str) -> str: Decompresses a string using Run-Length Encoding. decompressed = [] i = 0 while i < len(cs): char = cs[i] i += 1 count_start = i while i < len(cs) and cs[i].isdigit(): i += 1 count = int(cs[count_start:i]) decompressed.append(char * count) return \\"\\".join(decompressed)"},{"question":"Problem Statement You are required to design an algorithm that identifies the number of unique ways a target sum can be achieved by adding up elements from an array of positive integers. Each element in the array can be used an unlimited number of times. # Goal Implement the function `number_of_ways_to_sum(target: int, numbers: List[int]) -> int` which takes an integer `target` and a list of integers `numbers` as inputs and returns the number of unique ways to achieve the `target` sum using the given numbers. # Input - `target` (1 â‰¤ target â‰¤ 1000): The sum to be achieved. - `numbers` (1 â‰¤ len(numbers) â‰¤ 100, 1 â‰¤ number_i â‰¤ 1000): The list of positive integers available for summation. # Output - Returns an integer count of the unique ways the target sum can be achieved using the given numbers. # Constraints 1. Implement the solution using dynamic programming to ensure efficiency. 2. Avoid redundant calculations by storing intermediate results. 3. Consider edge cases where the `target` cannot be achieved with the given numbers. # Example ```python def number_of_ways_to_sum(target: int, numbers: List[int]) -> int: # Your solution here pass # Test cases assert number_of_ways_to_sum(4, [1, 2, 3]) == 4 assert number_of_ways_to_sum(10, [2, 5, 3, 6]) == 5 assert number_of_ways_to_sum(7, [2, 4]) == 0 print(\\"All test cases passed!\\") ``` # Explanation For `number_of_ways_to_sum(4, [1, 2, 3])`, the expected output is `4` because there are four ways to achieve the sum of 4: - 1 + 1 + 1 + 1 - 1 + 1 + 2 - 1 + 3 - 2 + 2 # Additional Notes 1. Use a table to keep track of the number of ways to achieve each sum up to the target. 2. Initialize the table with base cases where achieving a sum of `0` can be done in one way: by taking no elements. 3. Iterate through the numbers and update the table by adding the number of ways to reach the current sum minus the current number. This approach ensures that you count every combination of sums without redundancy and within the constraints.","solution":"from typing import List def number_of_ways_to_sum(target: int, numbers: List[int]) -> int: Returns the number of unique ways to achieve the target sum using the given numbers. Each number can be used an unlimited number of times. # Create a list to store the number of ways to get each sum from 0 to target dp = [0] * (target + 1) # There is one way to achieve the sum 0: use no elements dp[0] = 1 # Process each number in the list for number in numbers: for current_sum in range(number, target + 1): dp[current_sum] += dp[current_sum - number] return dp[target]"},{"question":"# Question: Implementing a Custom Priority Queue You are tasked with implementing a custom Priority Queue called `CustomPriorityQueue`, which supports priority levels determining the order in which elements are removed. # Task: 1. **Implement the Custom Priority Queue**: - Create a class `CustomPriorityQueue` with methods to: - Insert an element with an associated priority. - Remove the element with the highest priority. - Peek at the element with the highest priority without removing it. - Check if the queue is empty. 2. **Analyze and Test**: - Analyze the efficiency of your algorithm in terms of time and space complexity. - Write appropriate unittests to ensure that the implementation handles edge cases and performs correctly. # Specifications: - **`CustomPriorityQueue` Class**: - `__init__(self)`: Initialize the empty priority queue. - `enqueue(self, element: Any, priority: int)`: Insert an element with the specified priority. - `dequeue(self) -> Any`: Remove and return the element with the highest priority. If multiple elements have the highest priority, return the one that was added earliest. - `peek(self) -> Any`: Return the element with the highest priority without removing it. If multiple elements have the highest priority, return the one that was added earliest. - `is_empty(self) -> bool`: Check if the queue is empty. # Input and Output: - **Input**: - `enqueue`: An element and its associated priority. - `dequeue` and `peek`: No input parameters. - `is_empty`: No input parameters. - **Output**: - `enqueue`: No output. - `dequeue`: The highest priority element. - `peek`: The highest priority element without removing it. - `is_empty`: A boolean indicating whether the queue is empty. # Constraints: - The elements can be of any type, but priorities are integers. - The queue should handle a mix of positive, negative, and zero priorities. - Handle scenarios where dequeue or peek is called on an empty queue gracefully (e.g., raise appropriate exceptions). # Example: ```python # Initialize the Custom Priority Queue pq = CustomPriorityQueue() # Enqueue elements with priorities pq.enqueue(\'apple\', 5) pq.enqueue(\'banana\', 1) pq.enqueue(\'cherry\', 3) pq.enqueue(\'date\', 5) # Peek at the element with the highest priority print(pq.peek()) # Output: \'apple\' # Dequeue the highest priority element print(pq.dequeue()) # Output: \'apple\' # Peek at the next highest priority element print(pq.peek()) # Output: \'date\' # Dequeue elements print(pq.dequeue()) # Output: \'date\' print(pq.dequeue()) # Output: \'cherry\' print(pq.dequeue()) # Output: \'banana\' # Check if the queue is empty print(pq.is_empty()) # Output: True ``` # Deliverables: - The complete implementation of `CustomPriorityQueue`. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate the correct operation of the queue for edge cases and general cases.","solution":"import heapq class CustomPriorityQueue: def __init__(self): self.heap = [] self.counter = 0 def enqueue(self, element, priority): heapq.heappush(self.heap, (-priority, self.counter, element)) self.counter += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2] def is_empty(self): return len(self.heap) == 0"},{"question":"# Question: Rearrange Array Alternately You are given a sorted array of distinct positive integers. Your task is to rearrange the array such that the maximum element is followed by the minimum, then the second maximum element is followed by the second minimum, and so on. **Function Signature**: ```python def rearrange_max_min(arr: list[int]) -> list[int]: pass ``` **Parameters**: - `arr` (list[int]): A list of distinct positive integers sorted in ascending order. **Returns**: - A list containing the rearranged elements as described. **Examples**: ```python >>> rearrange_max_min([1, 2, 3, 4, 5]) [5, 1, 4, 2, 3] >>> rearrange_max_min([10, 20, 30, 40, 50, 60, 70]) [70, 10, 60, 20, 50, 30, 40] >>> rearrange_max_min([1, 3, 5, 7, 9]) [9, 1, 7, 3, 5] ``` **Constraints**: - The input array is guaranteed to be non-empty and sorted in ascending order. - The array length (1 leq n leq 10^5). Your task is to implement this function in an efficient manner that rearranges the elements in (O(n)) time complexity and (O(1)) additional space complexity.","solution":"def rearrange_max_min(arr: list[int]) -> list[int]: Rearrange the given array of distinct positive integers such that the maximum element is followed by the minimum, then the second maximum element followed by the second minimum, and so on. Parameters: - arr (list[int]): A sorted list of distinct positive integers. Returns: - list[int]: The rearranged list as described. n = len(arr) result = [0] * n max_idx = n - 1 min_idx = 0 flag = True for i in range(n): if flag: result[i] = arr[max_idx] max_idx -= 1 else: result[i] = arr[min_idx] min_idx += 1 flag = not flag return result"},{"question":"**Context:** You are designing a simple content management system (CMS) where users can create and manage posts. A post is represented by its unique integer ID and the time it was created. # Task: Implement a class-based CMS that supports the following operations: - `create_post(post_id, timestamp)`: Adds a new post with the given `post_id` and `timestamp`. If a post with the same `post_id` already exists, raise a `ValueError`. - `delete_post(post_id)`: Deletes the post with the given `post_id`. If no such post exists, raise a `KeyError`. - `get_most_recent_post()`: Returns the `post_id` of the most recently created post. If no posts exist, return `None`. - `get_all_posts()`: Returns a list of all `post_id`s sorted by their timestamps in descending order (most recent first). # Specifications: 1. `create_post` should have O(1) time complexity for insertion. 2. `delete_post` should have O(1) time complexity for deletion. 3. `get_most_recent_post` should have O(1) time complexity. 4. `get_all_posts` should have O(n log n) time complexity where n is the number of posts. # Input and Output: Your methods must match the following signatures: - `create_post(post_id: int, timestamp: int) -> None` - `delete_post(post_id: int) -> None` - `get_most_recent_post() -> int` - `get_all_posts() -> list[int]` # Constraints: - `post_id` is a unique integer that identifies a post. - `timestamp` is an integer representing the creation time of the post. - Maximum number of posts managed: 10^5. - `timestamp` values will be unique. **Example:** ```python cms = CMS() cms.create_post(1, 100) cms.create_post(2, 200) assert cms.get_most_recent_post() == 2 cms.create_post(3, 150) assert cms.get_all_posts() == [2, 3, 1] cms.delete_post(2) assert cms.get_all_posts() == [3, 1] try: cms.create_post(1, 300) except ValueError: assert True # Expected behavior try: cms.delete_post(4) except KeyError: assert True # Expected behavior ``` ```python class CMS: def __init__(self): self.posts = {} # Dictionary to store posts with post_id as key and timestamp as value self.most_recent_post = None # Initialize the most recent post as None def create_post(self, post_id: int, timestamp: int) -> None: if post_id in self.posts: raise ValueError(\\"Post with this ID already exists\\") self.posts[post_id] = timestamp # Add the post to the dictionary if (self.most_recent_post is None) or (timestamp > self.posts[self.most_recent_post]): self.most_recent_post = post_id # Update the most recent post def delete_post(self, post_id: int) -> None: if post_id not in self.posts: raise KeyError(\\"Post not found\\") del self.posts[post_id] # Delete the post from the dictionary if post_id == self.most_recent_post: self.most_recent_post = max(self.posts, key=self.posts.get, default=None) # Update the most recent post def get_most_recent_post(self) -> int: return self.most_recent_post def get_all_posts(self) -> list[int]: return sorted(self.posts, key=lambda x: self.posts[x], reverse=True) # Return sorted list of post_ids based on timestamps ```","solution":"class CMS: def __init__(self): self.posts = {} # Dictionary to store posts with post_id as key and timestamp as value self.post_order = [] # List to keep track of post_ids based on insertion order for efficient timestamp comparison def create_post(self, post_id: int, timestamp: int) -> None: if post_id in self.posts: raise ValueError(\\"Post with this ID already exists\\") self.posts[post_id] = timestamp # Add the post to the dictionary self.post_order.append(post_id) # Add to order tracking list def delete_post(self, post_id: int) -> None: if post_id not in self.posts: raise KeyError(\\"Post not found\\") del self.posts[post_id] # Delete the post from the dictionary self.post_order.remove(post_id) # Remove from the order tracking list def get_most_recent_post(self) -> int: if not self.post_order: return None most_recent = max(self.post_order, key=lambda x: self.posts[x]) return most_recent def get_all_posts(self) -> list[int]: return sorted(self.posts, key=lambda x: self.posts[x], reverse=True) # Return sorted list of post_ids based on timestamps"},{"question":"# Question: Given a grid of size `m x n`, locate and mark the boundaries of all the islands present in the grid. An island is defined as a group of adjacent `1`s (horizontally or vertically). Each island boundary should be marked by changing the outermost `1`s of the island to `2`. # Task: Implement a function `mark_island_boundaries` that takes a grid of size `m x n` and modifies it in-place by transforming the boundaries of all islands in the grid. # Input: - **grid**: A 2D list of integers representing the grid, where `grid[i][j]` can be either 0 or 1. # Output: - The function should modify the input grid in-place and should not return any value. # Constraints and Notes: - `1 <= m, n <= 1000` - The input grid may be large; hence efficiency in both time and space is crucial. - Adjacent means connected horizontally or vertically, not diagonally. - Only the boundaries of the islands (the outermost cells that are `1`) should be changed to `2`. # Example: Input: ```python grid = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0] ] ``` Output: ```python grid = [ [2, 2, 0, 0, 0], [2, 0, 0, 2, 2], [0, 0, 0, 2, 0], [0, 2, 2, 0, 0] ] ``` # Explanation: In the input grid: - The first island consisting of cells (0,0), (0,1), (1,0) has its boundary marked as 2. - The second island consisting of cells (1, 3), (1, 4), (2, 3) has its boundary marked as 2. - The third island consisting of cells (3, 1), (3, 2) has its boundary marked as 2. # Implementation: ```python def mark_island_boundaries(grid): if not grid: return m, n = len(grid), len(grid[0]) def is_boundary(i, j): for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= x < m and 0 <= y < n and grid[x][y] == 0: return True return False def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1: return if is_boundary(i, j): grid[i][j] = 2 temp = grid[i][j] grid[i][j] = -1 # Temporarily mark as visited for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: dfs(x, y) grid[i][j] = temp for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j) if __name__ == \\"__main__\\": grid = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0] ] mark_island_boundaries(grid) for row in grid: print(row) ``` This function performs a depth-first search (DFS) to locate and mark the boundaries of islands in the grid. The `is_boundary` function checks if a cell is at the boundary of an island by looking at adjacent cells.","solution":"def mark_island_boundaries(grid): if not grid: return m, n = len(grid), len(grid[0]) # Perform DFS to find boundaries of each island def dfs(x, y, visited): stack = [(x, y)] while stack: i, j = stack.pop() if (i, j) in visited: continue visited.add((i, j)) at_boundary = False for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + dx, j + dy if 0 <= ni < m and 0 <= nj < n: if grid[ni][nj] == 0: at_boundary = True elif grid[ni][nj] == 1: stack.append((ni, nj)) else: at_boundary = True if at_boundary: grid[i][j] = 2 visited = set() for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: dfs(i, j, visited)"},{"question":"# Task You are provided with a basic implementation for a linked list. Your task is to extend the linked list class by implementing a new method to detect if the linked list contains a cycle (loop) and a method to remove the cycle if it exists. # Cycle Detection and Removal 1. **Cycle Detection**: Implement the \\"has_cycle\\" method using Floyd\'s cycle detection algorithm (also known as the tortoise and hare algorithm). 2. **Cycle Removal**: Implement the \\"remove_cycle\\" method that removes the cycle once detected. # Implementation: * Add these two methods to the existing `LinkedList` class: - `has_cycle(self) -> bool`: Returns `True` if a cycle is detected, otherwise returns `False`. - `remove_cycle(self) -> None`: Removes the cycle if it exists. * Ensure the `remove_cycle` method only modifies the linked list if a cycle is detected. Use Floyd\'s algorithm to locate and remove the cycle. # Input and Output: Use the following steps to implement and test your solution: * Create an instance of the `LinkedList` class and populate it with nodes. * Introduce a cycle in the linked list for testing purposes. * Use the `has_cycle` method to detect the cycle. * Use the `remove_cycle` method to remove the cycle. * Verify the linked list is cycle-free by using the `has_cycle` method again. # Constraints: - The linked list structure is implemented correctly with standard operations such as insertion and traversal. - Use efficient algorithms for cycle detection and removal to ensure optimal performance. # Example ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def has_cycle(self) -> bool: slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self) -> None: if not self.has_cycle(): return slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break slow = self.head if slow == fast: # Cycle starts from head while fast.next != slow: fast = fast.next else: while slow.next != fast.next: slow = slow.next fast = fast.next fast.next = None # Example usage ll = LinkedList() ll.insert(1) ll.insert(2) ll.insert(3) ll.insert(4) # Introducing a cycle for testing ll.head.next.next.next.next = ll.head.next print(\\"Cycle detected:\\", ll.has_cycle()) # Cycle detected: True ll.remove_cycle() print(\\"Cycle detected:\\", ll.has_cycle()) # Cycle detected: False ``` Reference the methods in the code snippet to ensure structure and consistency, and test thoroughly.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def has_cycle(self) -> bool: slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self) -> None: if not self.has_cycle(): return slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break slow = self.head if slow == fast: # Cycle starts from head while fast.next != slow: fast = fast.next else: while slow.next != fast.next: slow = slow.next fast = fast.next fast.next = None"},{"question":"# Problem Statement You are required to implement a function `list_unique_elements(arr)` that, given a list of integers `arr`, returns a sorted list of its unique elements. The function should manage both positive and negative integers and should aim for time and space efficiency. # Input - A list of integers `arr` (0 â‰¤ len(arr) â‰¤ 10^6) where each integer is in the range of -10^6 to 10^6. # Output - A sorted list of unique integers present in the input list. # Constraints - The function should remove any duplicate elements efficiently. - The solution must perform the task with optimized time and space complexity. # Performance Requirements - Your implementation should aim for an overall time complexity better than O(n^2). # Example ```python print(list_unique_elements([4, 3, 2, 1, 2, 3, 4])) # Expected output: [1, 2, 3, 4] print(list_unique_elements([-3, -1, -2, -3, -3, 1, 2, 3])) # Expected output: [-3, -2, -1, 1, 2, 3] ``` # Additional Context Consider implementing the function using data structures that support efficient element look-up, insertion, and deletion to achieve high performance. Utilizing built-in Python collections like sets and taking advantage of their properties could be beneficial. Furthermore, consider that maintaining order and uniqueness are key functional requirements.","solution":"def list_unique_elements(arr): Given a list of integers `arr`, returns a sorted list of unique elements. :param arr: List of integers. :return: Sorted list of unique integers. # Convert the list to a set to remove duplicates and then convert it back to a sorted list return sorted(set(arr))"},{"question":"# Advanced Coding Assessment Question 2 Context You are tasked with developing a part of a data analytics tool that processes and analyzes time-series data stored in a list of daily records. Each record contains multiple metrics, and the tool needs to dynamically compute aggregated statistics over given time ranges. Problem Statement Implement a class `TimeSeriesAnalyzer` that: - Accepts a time-series dataset (a list of dictionaries, where each dictionary represents daily data with multiple key-value pairs for different metrics) during initialization. - Provides methods to calculate the sum, mean, and maximum value of a specific metric over a given range of days. - Efficiently handles dynamic range queries, ensuring fast computation even for large datasets. 1. Implement the class `TimeSeriesAnalyzer` such that it: - Accepts the time-series dataset during initialization. - Has a method `sum_metric` to calculate the sum of a metric over a range of days. - Has a method `mean_metric` to calculate the mean of a metric over a range of days. - Has a method `max_metric` to find the maximum value of a metric over a range of days. 2. Ensure proper handling of edge cases: - Provide meaningful error messages for invalid metric names or out-of-bound ranges. - Handle edge cases such as empty datasets gracefully. Constraints - The dataset list will have up to 100,000 records. - Each record is a dictionary containing metrics with integer values. - The keys for metrics will be consistent across all records. - The methods should be optimized for efficiency given the possibility of multiple and large-range queries. Function Signatures * `class TimeSeriesAnalyzer` - `__init__(self, dataset: list[dict[str, int]]) -> None` - `sum_metric(self, metric: str, start_day: int, end_day: int) -> int` - `mean_metric(self, metric: str, start_day: int, end_day: int) -> float` - `max_metric(self, metric: str, start_day: int, end_day: int) -> int` Input and Output * `TimeSeriesAnalyzer.__init__(dataset: list[dict[str, int]])` - **Input**: A list of dictionaries with integer metrics. - **Initialization**: Stores the dataset and performs any necessary preprocessing. * `TimeSeriesAnalyzer.sum_metric(metric: str, start_day: int, end_day: int)` - **Input**: A string `metric`, and integers `start_day` and `end_day` (0-indexed inclusive). - **Output**: An integer representing the sum of the specified metric over the given range of days. - **Raises**: `ValueError` for invalid metric names or if the range is out of bounds. * `TimeSeriesAnalyzer.mean_metric(metric: str, start_day: int, end_day: int)` - **Input**: A string `metric`, and integers `start_day` and `end_day` (0-indexed inclusive). - **Output**: A float representing the mean of the specified metric over the given range of days. - **Raises**: `ValueError` for invalid metric names or if the range is out of bounds. * `TimeSeriesAnalyzer.max_metric(metric: str, start_day: int, end_day: int)` - **Input**: A string `metric`, and integers `start_day` and `end_day` (0-indexed inclusive). - **Output**: An integer representing the maximum value of the specified metric over the given range of days. - **Raises**: `ValueError` for invalid metric names or if the range is out of bounds. Example Usage ```python time_series_data = [ {\\"temperature\\": 20, \\"humidity\\": 50, \\"pressure\\": 1015}, {\\"temperature\\": 22, \\"humidity\\": 55, \\"pressure\\": 1013}, {\\"temperature\\": 19, \\"humidity\\": 45, \\"pressure\\": 1018}, {\\"temperature\\": 21, \\"humidity\\": 52, \\"pressure\\": 1016}, ] tsa = TimeSeriesAnalyzer(time_series_data) # Calculate sum of the \'temperature\' metric over days 0 to 2 inclusive print(tsa.sum_metric(\'temperature\', 0, 2)) # Outputs: 61 # Calculate mean of the \'humidity\' metric over days 1 to 3 inclusive print(tsa.mean_metric(\'humidity\', 1, 3)) # Outputs: 50.666... # Calculate maximum of the \'pressure\' metric over days 0 to 3 inclusive print(tsa.max_metric(\'pressure\', 0, 3)) # Outputs: 1018 # Handling edge cases try: print(tsa.sum_metric(\'temperature\', -1, 3)) except ValueError as e: print(e) # Outputs: range out of bounds try: print(tsa.mean_metric(\'wind_speed\', 0, 2)) except ValueError as e: print(e) # Outputs: invalid metric ```","solution":"class TimeSeriesAnalyzer: def __init__(self, dataset): self.dataset = dataset if not dataset: raise ValueError(\\"Dataset cannot be empty\\") def _validate_inputs(self, metric, start_day, end_day): if start_day < 0 or end_day >= len(self.dataset) or start_day > end_day: raise ValueError(\\"Range out of bounds\\") if metric not in self.dataset[0]: raise ValueError(\\"Invalid metric\\") def sum_metric(self, metric, start_day, end_day): self._validate_inputs(metric, start_day, end_day) return sum(record[metric] for record in self.dataset[start_day:end_day+1]) def mean_metric(self, metric, start_day, end_day): self._validate_inputs(metric, start_day, end_day) range_length = end_day - start_day + 1 return self.sum_metric(metric, start_day, end_day) / range_length def max_metric(self, metric, start_day, end_day): self._validate_inputs(metric, start_day, end_day) return max(record[metric] for record in self.dataset[start_day:end_day+1])"},{"question":"# Connect Four Winner Determination Implement a function to determine if there is a winner in a Connect Four game. The game board is a 2D grid of size 6x7 (6 rows and 7 columns) where the players drop their discs from the top into any of the columns. The game ends when a player manages to connect four of their discs either horizontally, vertically, or diagonally. Function Signature ```python def connect_four_winner(board: List[List[str]]) -> str: ``` Input * `board` (List[List[str]]): A 2D list representing the game board, where an empty cell is represented by \'.\', player one\'s disc is represented by \'X\', and player two\'s disc is represented by \'O\'. The dimensions of the board are always 6x7. Output * Returns \'X\' if player one wins, \'O\' if player two wins, and \'None\' if there is no winner. Constraints * The board will always be a valid 6x7 grid. * Discs may only be placed in accordance with the game\'s rules (i.e., they fall to the lowest unoccupied space within a column). Example ```python # Example 1: board = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'X\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'X\', \'.\', \'.\', \'.\'], [\'.\', \'O\', \'O\', \'O\', \'X\', \'.\', \'.\'], [\'O\', \'X\', \'X\', \'X\', \'X\', \'O\', \'O\'] ] print(connect_four_winner(board)) #=> \'X\' # Example 2: board = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'O\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'O\', \'.\', \'.\', \'.\'], [\'.\', \'X\', \'X\', \'O\', \'O\', \'O\', \'O\'] ] print(connect_four_winner(board)) #=> \'O\' # Example 3: board = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'X\', \'X\', \'O\', \'X\', \'O\', \'O\'] ] print(connect_four_winner(board)) #=> \'None\' ``` Explanation 1. In the first example, player one (\'X\') has four consecutive discs horizontally in the bottom row, thus they win. 2. In the second example, player two (\'O\') has four consecutive discs horizontally in the bottom row, so they win. 3. In the third example, neither player has four consecutive discs horizontally, vertically, or diagonally, so the result is \'None\'. Implement the function `connect_four_winner` to correctly determine the winner or report that there is no winner. Ensure the solution handles various board states efficiently and accurately.","solution":"def connect_four_winner(board): Check each cell to see if it starts a winning sequence of four horizontally, vertically, or diagonally. rows, cols = len(board), len(board[0]) def check_winner(r, c, dr, dc): Check for four in a row along (dr, dc) direction from (r, c). player = board[r][c] if player == \'.\': return None for i in range(1, 4): nr, nc = r + dr * i, c + dc * i if nr >= rows or nr < 0 or nc >= cols or nc < 0 or board[nr][nc] != player: return None return player # Check all cells for potential winners for r in range(rows): for c in range(cols): for dr, dc in [(0, 1), (1, 0), (1, 1), (1, -1)]: winner = check_winner(r, c, dr, dc) if winner: return winner return None"},{"question":"# Finding Common Ancestor in a Binary Search Tree You are tasked with finding the lowest common ancestor of two nodes in a binary search tree (BST). The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in the BST that has both `p` and `q` as descendants. Function Signature ```python def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: ``` # Input * `root` (TreeNode): The root node of the binary search tree. * `p` (TreeNode): A node in the binary search tree. * `q` (TreeNode): Another node in the binary search tree. # Output * Returns a `TreeNode` which is the lowest common ancestor of `p` and `q`. # Constraints * All the node values are unique. * `p` and `q` are guaranteed to be in the BST. * The number of nodes in the BST is in the range [2, 10000]. # Example Consider the following BST: ``` 6 / 2 8 / / 0 4 7 9 / 3 5 ``` Let `p = TreeNode(2)` and `q = TreeNode(8)`. The LCA of nodes `2` and `8` is `TreeNode(6)`. ```python assert lowest_common_ancestor(root, p, q).val == 6 ``` # Requirements * Implement the function `lowest_common_ancestor` utilizing the properties of the binary search tree. * Optimize the traversal to ensure efficient performance for large trees. * Handle different scenarios where `p` and `q` might be on different sides or the same side of the tree. # Notes * You can assume the input tree is always valid and contains both `p` and `q`. * Make use of the BST properties to reduce the search space and ensure efficient traversal.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two nodes in a binary search tree. Args: root (TreeNode): The root of the binary search tree. p (TreeNode): The first node. q (TreeNode): The second node. Returns: TreeNode: The lowest common ancestor of p and q. # Start at the root, traversing the tree current = root while current: if p.val < current.val and q.val < current.val: current = current.left elif p.val > current.val and q.val > current.val: current = current.right else: return current"},{"question":"# Question: Find Products of All Integers Except at Index Write a function `products_except_index(nums: List[int]) -> List[int]` that takes a list of integers and returns a new list such that at each index `i` of the new list, the value is the product of all the integers in the original list except the one at `i`. Input - `nums`: A list of integers. Output - A list of integers where each element is the product of all elements in the original list except the one at the corresponding index. Constraints - The length of `nums` will be between 1 and 1000. - All elements in `nums` will be integers between -10^4 and 10^4, inclusive. - The function must not use division. Example ```python >>> products_except_index([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> products_except_index([3, 2, 1]) [2, 3, 6] ``` Notes - Ensure the function handles edge cases, such as an empty list and a list with only one element. - Consider the efficiency of your solution, particularly with respect to time and space complexity. - Do not use the division operation to solve this problem; instead, implement an algorithm that multiplies elements directly to find the desired products.","solution":"from typing import List def products_except_index(nums: List[int]) -> List[int]: Returns a list where each element is the product of all elements in the input list except the one at the same index. length = len(nums) if length == 0: return [] # Initialize empty products list products = [1] * length # Calculate prefix product for each element prefix_product = 1 for i in range(length): products[i] = prefix_product prefix_product *= nums[i] # Calculate suffix product for each element suffix_product = 1 for i in range(length - 1, -1, -1): products[i] *= suffix_product suffix_product *= nums[i] return products"},{"question":"# Binary Tree Height Calculation You are tasked with writing a function that calculates the height of a binary tree. The height of a binary tree is the number of edges on the longest path from the root to any leaf node. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_height(root: TreeNode) -> int: pass ``` **Parameters**: - **root**: A `TreeNode` representing the root of the binary tree. **Returns**: - An integer representing the height of the given binary tree. # Example ```python # Example 1: root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.left.left = TreeNode(4) root1.left.right = TreeNode(5) height1 = calculate_height(root1) # Expected height1: 2 # Example 2: root2 = TreeNode(1) root2.left = TreeNode(2) root2.left.left = TreeNode(3) root2.left.left.left = TreeNode(4) height2 = calculate_height(root2) # Expected height2: 3 ``` # Constraints - The binary tree will contain at least one node (the root node). - The number of nodes in the binary tree will not exceed 10^4. # Notes: - The height of a tree with only one node (the root) is 0. - Ensure your implementation is efficient and handles large binary trees correctly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_height(root: TreeNode) -> int: if root is None: return -1 left_height = calculate_height(root.left) right_height = calculate_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Problem Statement You are a developer at a robotics company. Your task is to write a software module that controls the movement of a robot in a 2D grid-based environment. The robot can move in four possible directions: \'up\', \'down\', \'left\', and \'right\'. The initial position of the robot is at the origin point `(0,0)`. # Function Signature ```python def robot_position(movements: str) -> tuple[int, int]: pass ``` # Input - `movements`: A string consisting of the characters \'U\', \'D\', \'L\', and \'R\' which represent the robot\'s movements up, down, left, and right, respectively. # Output - Return a tuple containing two integers representing the final position of the robot in the 2D grid. # Constraints - `0 <= len(movements) <= 10^5` - The string `movements` consists only of the characters \'U\', \'D\', \'L\', \'R\'. # Example - Input: `\\"UUDDLRLR\\"` - Output: `(0, 0)` # Scenario Consider a scenario where the robot is navigating through a warehouse to pick and place items. Your solution will help in determining the robot\'s final position after executing a sequence of movements. # Performance Requirements - The solution should efficiently handle the input length up to the constraint limit. - Ensure that the function returns the correct final position based on the input string. # Requirements - Ensure the function is robust to handle an empty string of movements, which should return the initial position `(0, 0)`. - Invalid movement characters are out of the input constraints and hence need not be handled.","solution":"def robot_position(movements: str) -> tuple[int, int]: Given a string of movements, returns the final position of the robot in the 2D grid. :param movements: A string of movements (\'U\', \'D\', \'L\', \'R\') :return: A tuple containing the final coordinates (x, y) of the robot x, y = 0, 0 for move in movements: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return (x, y)"},{"question":"Coding Question - Implement a Min-Heap with Extract Min Feature Context You are tasked with implementing a min-heap data structure. A min-heap is a complete binary tree where the value of each node is less than or equal to the values of its children. This structure is particularly useful for efficiently retrieving the smallest element. Task Implement a `MinHeap` class in Python with the following methods: 1. **`__init__(self) -> None`**: Initializes an empty min-heap. 2. **`insert(self, item: int) -> None`**: Inserts an integer item into the heap. 3. **`extract_min(self) -> int`**: Removes and returns the smallest item from the heap. If the heap is empty, raise an `IndexError`. 4. **`get_min(self) -> int`**: Returns the smallest item from the heap without removing it. If the heap is empty, raise an `IndexError`. 5. **`__len__(self) -> int`**: Returns the number of elements in the heap. 6. **`__str__(self) -> str`**: Returns a string representation of the heap elements in level-order traversal format, separated by spaces. Input and Output Formats: - The `insert` method will have an integer parameter `item`. - The `extract_min` and `get_min` methods will return an integer. - `__len__` will return an integer. - `__str__` returns a string representation of the heap elements in level-order (top to bottom, left to right). Example: ```python heap = MinHeap() heap.insert(10) heap.insert(20) heap.insert(5) print(len(heap)) # 3 print(heap) # \\"5 20 10\\" print(heap.get_min()) # 5 print(heap.extract_min()) # 5 print(len(heap)) # 2 print(heap) # \\"10 20\\" heap.insert(2) heap.insert(8) print(heap) # \\"2 20 10 8\\" print(heap.extract_min()) # 2 print(heap) # \\"8 20 10\\" print(len(heap)) # 3 ``` Constraints: - All integers inserted into the heap will be in the range [-10^9, 10^9]. - The heap will handle up to 10^5 elements. Performance Requirements: - Insert, extract_min, and get_min operations should be performed in O(log n) time. - The `__str__` method should run in O(n) time.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, item: int) -> None: self.heap.append(item) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Extract from an empty heap\\") self._swap(0, len(self.heap) - 1) min_item = self.heap.pop() self._heapify_down(0) return min_item def get_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Get from an empty heap\\") return self.heap[0] def __len__(self) -> int: return len(self.heap) def __str__(self) -> str: return \' \'.join(map(str, self.heap)) def _heapify_up(self, index): parent = (index - 1) // 2 if parent >= 0 and self.heap[parent] > self.heap[index]: self._swap(parent, index) self._heapify_up(parent) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self._swap(index, smallest) self._heapify_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"**City Connection Planner** You are working for a company that needs to connect several cities with roads in the most cost-effective way. Each city can be represented as a node, and each potential road between two cities has a specified cost. The objective is to find the minimal total cost to connect all cities such that there is a path between any two cities. Your task is to implement a function that calculates the minimal total cost to connect all the cities and returns the total cost. # Function Signature ```python def minimal_connection_cost(n: int, edges: list) -> int: Determines the minimal total cost to connect all cities. Parameters: - n (int): Total number of cities, labeled from 0 to n-1. - edges (list): A list of tuples where each tuple (u, v, cost) represents a potential road between city u and city v with the given cost. All costs are positive integers. Returns: - minimal_cost (int): The minimal total cost to connect all cities. Returns -1 if it is impossible to connect all cities. # Constraints - 1 <= n <= 100 - 1 <= len(edges) <= 1000 - Each road\'s cost is a positive integer within the range 1 to 1000. # Example Consider the following examples: ```python # Example 1 n = 4 edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] assert minimal_connection_cost(n, edges) == 19 # Example 2 n = 3 edges = [(0, 1, 1), (1, 2, 1), (0, 2, 2)] assert minimal_connection_cost(n, edges) == 2 # Example 3 n = 4 edges = [(0, 1, 1), (1, 2, 1)] assert minimal_connection_cost(n, edges) == -1 ``` In the first example, the minimum costs to connect all cities are achieved with edges (0, 3), (2, 3), and (0, 1) with a total cost of 19. In the second example, connecting (0, 1) and (1, 2) achieves a minimum cost of 2. The third example returns -1 since it\'s impossible to connect all cities using the given edges.","solution":"def minimal_connection_cost(n, edges): Determines the minimal total cost to connect all cities. Parameters: - n (int): Total number of cities, labeled from 0 to n-1. - edges (list): A list of tuples where each tuple (u, v, cost) represents a potential road between city u and city v with the given cost. All costs are positive integers. Returns: - minimal_cost (int): The minimal total cost to connect all cities. Returns -1 if it is impossible to connect all cities. # Helper function to find the root of a node in the disjoint set def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to unify two subsets def union(parent, rank, xroot, yroot): if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Initialize the parent and rank arrays for the disjoint set union-find structure parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) # Sort all the edges in non-decreasing order of their cost edges = sorted(edges, key=lambda item: item[2]) result = [] # Store the resultant MST e = 0 # An index variable for edges i = 0 # An index variable for sorted edges while e < n - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle if x != y: e += 1 result.append((u, v, w)) union(parent, rank, x, y) # Check if all nodes are connected unique_roots = set() for i in range(n): unique_roots.add(find(parent, i)) if len(unique_roots) != 1: return -1 # Calculate the minimum cost minimal_cost = sum([weight for _, _, weight in result]) return minimal_cost"},{"question":"# Environmental Data Analyzer You are provided with a code snippet for retrieving and analyzing environmental data such as temperature, humidity, and air quality from a JSON API. The task is to enhance this code to handle potential issues and to extend its functionality to support retrieving data for a specific city. Requirements 1. **Function Implementation**: - Implement a function `city_environment_data(api_url: str, city: str) -> dict`, which takes an API endpoint URL and a city name as inputs and returns a dictionary of environmental data for that city. 2. **Input and Output Formats**: - **Input**: * `api_url` (string): The base API endpoint to retrieve data from (default: \\"https://api.open-meteo.com/v1/forecast\\"). * `city` (string): The name of the city to get data for. - **Output**: * A dictionary where keys are the names of the data types (e.g., Temperature, Humidity, Air Quality) and values are the corresponding data. 3. **Constraints**: - Ensure that your code handles: * Changes in the API response structure. * Non-200 HTTP responses. * Missing keys in the JSON response. * Network latency by setting an appropriate timeout. 4. **Performance Requirements**: - Handle HTTP request retries to mitigate transient network issues. - Ensure that the solution is efficient in terms of time and space complexity. Code Base to Extend ```python #!/usr/bin/env python3 import requests def world_environment_data(api_url: str = \\"https://api.open-meteo.com/v1/forecast\\", params: dict = { \\"latitude\\": 52.52, \\"longitude\\": 13.405, \\"current_weather\\": \\"true\\" }) -> dict: Return a dict of current worldwide environmental data response = requests.get(api_url, params=params, timeout=10) if response.status_code != 200: raise Exception(f\\"API request failed with status code {response.status_code}\\") data = response.json() if \'current_weather\' not in data: raise Exception(\\"Invalid data format\\") return { \\"Temperature\\": data[\'current_weather\'].get(\'temperature\', \\"N/A\\"), \\"Humidity\\": data[\'current_weather\'].get(\'humidity\', \\"N/A\\"), \\"Air Quality\\": data[\'current_weather\'].get(\'air_quality\', \\"N/A\\") if \\"air_quality\\" in data[\'current_weather\'] else \\"Not available\\" } # Add your implementation for city_environment_data here if __name__ == \\"__main__\\": print(\\"033[1m Current Environmental Data of the World 033[0mn\\") print(\\"n\\".join(f\\"{key}: {value}\\" for key, value in world_environment_data().items())) ``` # Implementation Note - The implementation should consider edge cases such as missing elements in the JSON response, handling timeouts, retrying requests, and formatting issues. --- *Ensure the new question integrates seamlessly with the existing ones in terms of style, complexity, and scope.*","solution":"import requests def get_location_coordinates(city: str) -> dict: Get the latitude and longitude for the given city using a geolocation API. Replace this with the actual implementation or mock it during tests. # Here, we use a placeholder implementation. # In a real scenario, we would call an actual geolocation API to fetch the coordinates. # For simplicity, let\'s define some mock coordinates for known cities: mock_coordinates = { \\"Berlin\\": {\\"latitude\\": 52.52, \\"longitude\\": 13.405}, \\"New York\\": {\\"latitude\\": 40.7128, \\"longitude\\": -74.0060}, \\"London\\": {\\"latitude\\": 51.5074, \\"longitude\\": -0.1278} } if city in mock_coordinates: return mock_coordinates[city] else: raise ValueError(f\\"Coordinates for the city \'{city}\' are not available in mock data.\\") def city_environment_data(api_url: str, city: str) -> dict: Return a dictionary of environmental data for a specific city. try: coordinates = get_location_coordinates(city) params = { \\"latitude\\": coordinates[\\"latitude\\"], \\"longitude\\": coordinates[\\"longitude\\"], \\"current_weather\\": \\"true\\" } response = requests.get(api_url, params=params, timeout=10) response.raise_for_status() # Raise an error for bad HTTP status codes data = response.json() if \'current_weather\' not in data: raise KeyError(\\"Invalid data format\\") return { \\"Temperature\\": data[\'current_weather\'].get(\'temperature\', \\"N/A\\"), \\"Humidity\\": data[\'current_weather\'].get(\'humidity\', \\"N/A\\"), \\"Air Quality\\": data[\'current_weather\'].get(\'air_quality\', \\"Not available\\") if \\"air_quality\\" in data[\'current_weather\'] else \\"Not available\\" } except (requests.RequestException, KeyError, ValueError) as e: print(f\\"Error occurred: {e}\\") return {}"},{"question":"# Question: You are tasked with implementing a function that sorts a list of tuples based on the sum of the elements of each tuple. The function should return a new list where tuples are sorted in ascending order of their summed values. In case of ties, maintain the original relative order of the tied tuples. Implement the following function: ```python def sort_tuples_by_sum(lst: list) -> list: Sorts a list of tuples based on the sum of their elements. :param lst: List of tuples to be sorted. :return: A new list of tuples sorted by the sum of their elements. >>> sort_tuples_by_sum([(1, 2), (3, 4), (1, 1)]) [(1, 1), (1, 2), (3, 4)] >>> sort_tuples_by_sum([(5, 5), (2, 1), (4, 4), (2, 3)]) [(2, 1), (2, 3), (4, 4), (5, 5)] >>> sort_tuples_by_sum([(1, 3, 2), (3, 2, 1), (1, 1, 1), (0, 1, 1)]) [(0, 1, 1), (1, 1, 1), (1, 3, 2), (3, 2, 1)] >>> sort_tuples_by_sum([(8,)]) [(8,)] pass ``` # Requirements: 1. **Function Signature**: - The function should take a list of tuples `lst` where each tuple contains at least one integer element. - The function will return a new list where tuples are sorted based on the sum of their elements. 2. **Input Constraints**: - `lst` will be a list consisting of tuples, each containing at least one integer. - The list can have any number of tuples, including zero. 3. **Output**: - The function should return a new list of tuples sorted by the sum of their elements. - Ties must maintain the relative order of the input list. 4. **Performance**: - The implementation should be efficient enough to handle lists with a large number of tuples. # Important Notes: - Tuples with the same summed value should retain their relative order from the original list. - The input list can be empty, in which case the function should return an empty list. - The function should work with tuples of different lengths and any integer values.","solution":"def sort_tuples_by_sum(lst): Sorts a list of tuples based on the sum of their elements. :param lst: List of tuples to be sorted. :return: A new list of tuples sorted by the sum of their elements. # Use sorted() with a custom key that sums the elements in each tuple return sorted(lst, key=lambda tup: sum(tup))"},{"question":"# Problem Statement You are managing a warehouse with several storage bins, and you need to keep track of inventory. Each bin can hold a certain number of items, and each item has a unique ID. Your task is to write a class `Warehouse` that supports the following operations: 1. **add_bin**: Add a new bin with a specified capacity. 2. **add_item**: Add an item to a bin. 3. **remove_item**: Remove an item from a bin. 4. **get_bin_status**: Get the current status of a bin, including its remaining capacity and the list of item IDs it contains. 5. **find_item**: Determine which bin a specified item is located in. Input: - Bin capacity and item IDs will be integers. - Bin IDs will be unique strings. Output: - For each operation, return the relevant output as described below. Operations 1. **add_bin(bin_id: str, capacity: int) -> None**: Adds a new bin with the specified capacity. 2. **add_item(bin_id: str, item_id: int) -> bool**: Adds an item to the specified bin. Returns `True` if the item was added successfully, `False` if the bin is full or does not exist. 3. **remove_item(bin_id: str, item_id: int) -> bool**: Removes an item from the specified bin. Returns `True` if the item was removed successfully, `False` if the bin or item does not exist. 4. **get_bin_status(bin_id: str) -> Tuple[int, List[int]]**: Returns a tuple with the remaining capacity of the bin and a list of item IDs in the bin. Returns `None` if the bin does not exist. 5. **find_item(item_id: int) -> Optional[str]**: Returns the bin ID where the item is located, or `None` if the item is not found in any bin. Function Signature ```python class Warehouse: def __init__(self): pass def add_bin(self, bin_id: str, capacity: int) -> None: pass def add_item(self, bin_id: str, item_id: int) -> bool: pass def remove_item(self, bin_id: str, item_id: int) -> bool: pass def get_bin_status(self, bin_id: str) -> Optional[Tuple[int, List[int]]]: pass def find_item(self, item_id: int) -> Optional[str]: pass ``` Example ```python # Initialize the warehouse warehouse = Warehouse() # Add bins warehouse.add_bin(\\"A1\\", 10) warehouse.add_bin(\\"B1\\", 5) # Add items to bins assert warehouse.add_item(\\"A1\\", 101) == True assert warehouse.add_item(\\"A1\\", 102) == True assert warehouse.add_item(\\"B1\\", 201) == True assert warehouse.add_item(\\"B1\\", 201) == False # Already exists in B1 # Get bin status assert warehouse.get_bin_status(\\"A1\\") == (8, [101, 102]) assert warehouse.get_bin_status(\\"B1\\") == (4, [201]) # Find item assert warehouse.find_item(101) == \\"A1\\" assert warehouse.find_item(105) == None # Not found # Remove item assert warehouse.remove_item(\\"A1\\", 101) == True assert warehouse.remove_item(\\"A1\\", 999) == False # Nonexistent item assert warehouse.get_bin_status(\\"A1\\") == (9, [102]) ``` Requirements - Implement the `Warehouse` class in Python. - Ensure that the class handles all specified operations correctly. - Handle edge cases such as attempting to add items to non-existent or full bins, and removing items that are not present. Your `Warehouse` class should allow efficient management and querying of items and bin statuses.","solution":"from typing import List, Tuple, Optional class Warehouse: def __init__(self): self.bins = {} def add_bin(self, bin_id: str, capacity: int) -> None: if bin_id not in self.bins: self.bins[bin_id] = {\\"capacity\\": capacity, \\"items\\": []} def add_item(self, bin_id: str, item_id: int) -> bool: if bin_id in self.bins: if len(self.bins[bin_id][\\"items\\"]) < self.bins[bin_id][\\"capacity\\"]: if item_id not in self.bins[bin_id][\\"items\\"]: self.bins[bin_id][\\"items\\"].append(item_id) return True return False def remove_item(self, bin_id: str, item_id: int) -> bool: if bin_id in self.bins: if item_id in self.bins[bin_id][\\"items\\"]: self.bins[bin_id][\\"items\\"].remove(item_id) return True return False def get_bin_status(self, bin_id: str) -> Optional[Tuple[int, List[int]]]: if bin_id in self.bins: bin_capacity = self.bins[bin_id][\\"capacity\\"] items = self.bins[bin_id][\\"items\\"] remaining_capacity = bin_capacity - len(items) return (remaining_capacity, items) return None def find_item(self, item_id: int) -> Optional[str]: for bin_id, bin_info in self.bins.items(): if item_id in bin_info[\\"items\\"]: return bin_id return None"},{"question":"**Scenario**: You are working on a text processing application, and one of the core requirements is to identify and highlight keywords in a large text document. The keywords to be highlighted are provided in a list. These keywords should be case-insensitive and the matches should be highlighted without affecting other parts of the text. **Problem Statement**: Write a function `highlight_keywords(text: str, keywords: list[str]) -> str` that highlights all occurrences of each keyword in the text. Each keyword match should be wrapped in `<highlight></highlight>` tags. The function should be case-insensitive but the original text\'s case should be preserved. # Input: 1. `text`: A string representing the text in which keywords need to be highlighted. 2. `keywords`: A list of strings where each string is a keyword to be highlighted. # Output: A string with all keyword occurrences highlighted. # Constraints: - The input text can be very large. - Keywords are non-empty strings and can contain multiple words. - The text and keywords may contain any printable characters. # Examples: ```python assert highlight_keywords(\\"This is a simple test.\\", [\\"simple\\"]) == \\"This is a <highlight>simple</highlight> test.\\" assert highlight_keywords(\\"Highlighting keywords in text.\\", [\\"highlighting\\", \\"text\\"]) == \\"<highlight>Highlighting</highlight> keywords in <highlight>text</highlight>.\\" assert highlight_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"quick\\", \\"fox\\", \\"lazy\\"]) == \\"The <highlight>quick</highlight> brown <highlight>fox</highlight> jumps over the <highlight>lazy</highlight> dog.\\" assert highlight_keywords(\\"Case sensitivity doesn\'t matter.\\", [\\"case\\", \\"sensitivity\\"]) == \\"<highlight>Case</highlight> <highlight>sensitivity</highlight> doesn\'t matter.\\" assert highlight_keywords(\\"\\", [\\"any\\"]) == \\"\\" assert highlight_keywords(\\"No keywords here.\\", []) == \\"No keywords here.\\" assert highlight_keywords(\\"Multiple occurrences of the word, multiple places.\\", [\\"multiple\\"]) == \\"<highlight>Multiple</highlight> occurrences of the word, <highlight>multiple</highlight> places.\\" ``` # Additional Notes: - Ensure efficiency since the text can be very large and the number of keywords can be substantial. - Handle cases where keywords may overlap or be a part of other words. - Consider edge cases such as empty text or empty keyword list gracefully.","solution":"import re def highlight_keywords(text: str, keywords: list[str]) -> str: Highlights all occurrences of each keyword in the text. Each keyword match is case-insensitive but preserves the original case. The matches are wrapped in <highlight></highlight> tags. def highlight_match(match): return f\\"<highlight>{match.group(0)}</highlight>\\" for keyword in keywords: # Use re.IGNORECASE for case-insensitive matching and re.escape to handle special characters in keywords pattern = re.compile(re.escape(keyword), re.IGNORECASE) text = pattern.sub(highlight_match, text) return text"},{"question":"Circular Array Rotation Objective Write a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates an array of integers `arr` by `k` steps to the right. Requirements & Constraints 1. The function should accept two parameters: * `arr`: A list of integers. * `k`: A non-negative integer representing the number of steps to rotate the array. 2. The function should return the rotated array. 3. The rotation is circular, meaning elements displaced from the end of the array come back around to the start. 4. Consider edge cases such as the array being empty, the rotation steps being greater than the array length, and single-element arrays. 5. Optimize for time complexity; aim for an O(n) solution where possible. Example ```python def rotate_array(arr: List[int], k: int) -> List[int]: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] # Your implementation here # Example Tests print(rotate_array([1, 2, 3, 4, 5], 2)) # [4, 5, 1, 2, 3] print(rotate_array([1, 2, 3, 4, 5], 5)) # [1, 2, 3, 4, 5] print(rotate_array([1, 2, 3, 4, 5], 7)) # [4, 5, 1, 2, 3] ``` Implementation Notes - You may use Python\'s list slicing for an efficient solution. - Pay attention to edge cases and handle them appropriately. - Ensure your function is optimized for large input sizes, reflecting the constraints and requirements.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array arr by k steps to the right. Args: arr (List[int]): The list of integers to rotate. k (int): The number of steps to rotate the array. Returns: List[int]: The rotated array. if not arr: # Edge case: empty array return arr n = len(arr) k = k % n # Handle cases where k is larger than array length return arr[-k:] + arr[:-k]"},{"question":"# Binary Tree Depth You are tasked with determining the depth of a given binary tree. The depth (or height) of a binary tree is the number of edges on the longest path from the root node to a leaf. This task will help you understand tree traversal algorithms and recursive programming techniques. **Objective**: Implement a function that calculates the depth of a given binary tree. Input: - `root`: A TreeNode object representing the root of a binary tree. Each TreeNode has the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Output: - An integer representing the depth of the binary tree. The depth of an empty tree is 0. # Function Definition: 1. Implement the function `tree_depth(root: TreeNode) -> int` that traverses the binary tree and computes its depth. # Example: ```python # Example tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> tree_depth(root) 3 # Example tree: # 1 # / # 2 2 # / # 3 3 # / # 4 4 root = TreeNode(1) root.left = TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)) root.right = TreeNode(2) >>> tree_depth(root) 4 ``` Constraints: 1. The number of nodes in the binary tree will be in the range `[0, 10^4]`. 2. Node values are expected to be integers. # Notes: - Utilize either depth-first search (DFS) or breadth-first search (BFS) approaches to solve the problem. - Ensure your solution handles edge cases such as an empty tree or a tree with only one node.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def tree_depth(root: TreeNode) -> int: Calculate the depth of a binary tree. :param root: TreeNode :return: integer depth of the tree if not root: return 0 left_depth = tree_depth(root.left) right_depth = tree_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Scenario You are assigned to develop a scheduling feature for a task management application. The objective is to determine the minimum number of meeting rooms required to accommodate a set of meetings, given their start and end times. Each meeting is represented by a start and end time, and you must ensure that no two meetings overlap in the same room. If meetings overlap, they must be held in different rooms. # Task Write a function `min_meeting_rooms` that accepts a list of tuples, where each tuple represents the start and end times of a meeting. The function should return an integer representing the minimum number of meeting rooms required to accommodate all meetings. # Function Signature ```python def min_meeting_rooms(meetings: list[tuple[int, int]]) -> int: ``` # Input * `meetings` - a list of tuples, where each tuple consists of two integers representing the start and end times of a meeting. * Constraints: * The length of the `meetings` list will be between 0 and 1000. * The start and end times will be non-negative integers less than or equal to 1000. * The start time will always be less than the end time for each meeting. # Output * An integer value representing the minimum number of meeting rooms required. # Example ```python assert min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) == 2 assert min_meeting_rooms([(7, 10), (2, 4)]) == 1 assert min_meeting_rooms([(6, 8), (2, 4), (8, 9)]) == 1 ```","solution":"def min_meeting_rooms(meetings): if not meetings: return 0 # Extract start and end times separately start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) start_pointer = 0 end_pointer = 0 max_rooms = 0 current_rooms = 0 while start_pointer < len(start_times): if start_times[start_pointer] < end_times[end_pointer]: current_rooms += 1 start_pointer += 1 else: current_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, current_rooms) return max_rooms"},{"question":"# Coding Question: Calculate Cylinder Volume or Surface Area **Objective:** Implement a function that calculates either the volume or the surface area of a cylinder based on the input parameters: radius, height, and a flag indicating whether to compute volume or surface area. Problem Statement: You need to write a function `cylinder_metrics(radius: float, height: float, calc_volume: bool) -> float` that calculates either the volume or the surface area of a cylinder. The third parameter, `calc_volume`, is a boolean flag that determines which calculation to perform: volume if `True`, surface area if `False`. Function Signature: ```python def cylinder_metrics(radius: float, height: float, calc_volume: bool) -> float: pass ``` Input: - `radius`: The radius of the base of the cylinder, given as a `float`. - `height`: The height of the cylinder, given as a `float`. - `calc_volume`: A boolean flag. If `True`, calculate the volume; if `False`, calculate the surface area. Output: - A `float` representing either the volume or the surface area of the cylinder, rounded to two decimal places. Formulas: - Volume of a cylinder: ( V = pi times text{radius}^2 times text{height} ) - Surface area of a cylinder: ( SA = 2 times pi times text{radius} times (text{radius} + text{height}) ) Constraints: - Radius and height must be positive numbers. - Use ( pi = 3.141592653589793 ). Error Handling: - Raise a `ValueError` if radius or height is non-positive. Example: ```python # Example usage: result = cylinder_metrics(radius=3, height=5, calc_volume=True) # Expected output: 141.37 print(result) result = cylinder_metrics(radius=3, height=5, calc_volume=False) # Expected output: 150.80 print(result) ``` Implement the `cylinder_metrics` function in Python, ensuring it handles edge cases and maintains efficient computation.","solution":"import math def cylinder_metrics(radius: float, height: float, calc_volume: bool) -> float: Calculate the cylinder volume or surface area based on the calc_volume flag. Parameters: - radius: The radius of the base of the cylinder, must be a positive float. - height: The height of the cylinder, must be a positive float. - calc_volume: A boolean flag. If True, calculate the volume, otherwise calculate the surface area. Returns: - A float representing either the volume or the surface area, rounded to two decimal places. Raises: - ValueError: If radius or height is non-positive. if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive numbers.\\") if calc_volume: # Volume of the cylinder volume = math.pi * radius**2 * height return round(volume, 2) else: # Surface area of the cylinder surface_area = 2 * math.pi * radius * (radius + height) return round(surface_area, 2)"},{"question":"# Coding Assessment Question Context You are given a large number of integer sequences, each sorted in non-decreasing order. Your goal is to merge all these sequences into a single sorted sequence efficiently. Traditional methods have been slow and memory-intensive. Task Write a function `merge_k_sorted_lists` that takes a list of k sorted lists of integers and merges them into a single sorted list. Your function should: 1. Handle cases where the input list is empty. 2. Efficiently merge even large lists with potentially large numbers of elements. 3. Return the merged sorted list. Constraints - The number of lists ( k ) will be between 0 and ( 10^5 ). - The total number of integers across all lists will be between 0 and ( 10^6 ). - The integers in the lists will range from (-10^9) to (10^9). Function Signature ```python def merge_k_sorted_lists(lists: list[list[int]]) -> list[int]: pass ``` Expected Input and Output ```python >>> merge_k_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_k_sorted_lists([[], [], []]) [] >>> merge_k_sorted_lists([[10, 20, 30], [], [5, 15, 25]]) [5, 10, 15, 20, 25, 30] >>> merge_k_sorted_lists([[1], [2], [3], [4], [5]]) [1, 2, 3, 4, 5] >>> merge_k_sorted_lists([[1, 2, 2], [2, 3, 3], [3, 4, 4]]) [1, 2, 2, 2, 3, 3, 3, 4, 4] ``` Performance Requirements - Your implementation should efficiently handle large input sizes. - Aim for O(n log k) time complexity where n is the total number of elements across all lists and k is the number of lists. - Ensure to handle edge cases mentioned above effectively.","solution":"import heapq def merge_k_sorted_lists(lists): Merges k sorted lists into a single sorted list. Args: lists (List[List[int]]): A list of k sorted integer lists. Returns: List[int]: A single sorted list that merges all the input lists. min_heap = [] for i, sorted_list in enumerate(lists): if sorted_list: heapq.heappush(min_heap, (sorted_list[0], i, 0)) merged_list = [] while min_heap: value, list_index, element_index = heapq.heappop(min_heap) merged_list.append(value) if element_index + 1 < len(lists[list_index]): next_value = lists[list_index][element_index + 1] heapq.heappush(min_heap, (next_value, list_index, element_index + 1)) return merged_list"},{"question":"# Interval Overlap Finder Problem Statement: You are required to implement a function that detects overlaps between a new interval and an existing list of intervals. An interval is defined as a list of two integers where the first integer represents the start and the second represents the end of the interval. An overlap occurs if the new interval shares any common points with any of the existing intervals. Function Signature: ```python def find_overlaps(existing_intervals: list[list[int]], new_interval: list[int]) -> list[list[int]]: pass ``` Input: - `existing_intervals` (list[list[int]]): A list of intervals, where each interval is represented by a list of two integers [start, end]. - `new_interval` (list[int]): The new interval represented by a list of two integers [start, end]. Output: - A list of intervals from `existing_intervals` that overlap with `new_interval`. Constraints: - Each start and end of an interval must be an integer where the start is less than or equal to the end. - All intervals are inclusive, i.e., an interval starting at 5 and ending at 10 includes both 5 and 10. - Consider the case where there might be no overlaps. - Ensure the new interval is also formatted correctly as described. Performance Requirements: - The implementation should be efficient in determining overlaps, ideally maintaining a time complexity of O(n), where n is the number of existing intervals. Examples: ```python assert find_overlaps([[1, 5], [10, 15], [20, 25]], [12, 18]) == [[10, 15]] assert find_overlaps([[1, 3], [4, 7], [8, 10]], [5, 9]) == [[4, 7], [8, 10]] assert find_overlaps([[1, 3], [5, 7]], [8, 10]) == [] ``` Edge Cases: - Handle cases where `existing_intervals` is an empty list. - Ensure that intervals with equal start and end points are processed correctly. - Validate that each interval list and the new interval adheres to the constraints. # Instructions: 1. Implement the function `find_overlaps` following the given signature. 2. Ensure that all edge cases are handled appropriately. 3. Perform necessary validations as per the constraints. 4. Maintain the output format as specified.","solution":"def find_overlaps(existing_intervals, new_interval): Given a list of existing intervals and a new interval, return a list of intervals from the existing intervals that overlap with the new interval. overlaps = [] new_start, new_end = new_interval for interval in existing_intervals: start, end = interval # Check if there is an overlap if not (new_end < start or new_start > end): overlaps.append(interval) return overlaps"},{"question":"# Unique Paths in Grid **Context**: You are a software developer tasked with implementing algorithms for pathfinding in a GPS application. One of the key features involves finding unique paths in a grid-based city map. Each grid cell represents an intersection and allows movement to adjacent cells in four possible directions (up, down, left, right), as long as you don\'t step out of the grid. **Task**: Implement a function `unique_paths(rows: int, cols: int) -> int` that calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with the given number of rows and columns. You are only allowed to move rightward or downward at any step. **Guidelines**: 1. **Input**: * Two integers `rows` and `cols`, where `rows >= 1` and `cols >= 1`. 2. **Output**: * The number of unique paths from the top-left corner to the bottom-right corner. 3. **Constraints**: * Handle non-integer inputs by raising a `ValueError`. * Ensure the implementation is efficient for larger grid sizes. * You must use either a dynamic programming approach or mathematical combinatorics. 4. **Edge Cases**: * Verify behavior with minimal grid sizes (e.g., 1x1 grid). * Consider performance implications on a large grid (e.g., 20x20 grid). **Performance Requirements**: * Time Complexity should be polynomial and feasible for `rows` and `cols` up to 100. * Maintain space complexity considering constraints on memory usage. **Example**: ```python >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(10, 10) 48620 >>> unique_paths(\'3\', \'2\') Traceback (most recent call last): ... ValueError: rows and cols must be integers >>> unique_paths(0, -4) Traceback (most recent call last): ... ValueError: rows and cols must be positive integers ``` Implement your solution in the function `unique_paths`.","solution":"def unique_paths(rows: int, cols: int) -> int: Calculates the number of unique paths from the top-left to the bottom-right of a grid with the given number of rows and columns. Parameters: rows (int): Number of rows in the grid cols (int): Number of columns in the grid Returns: int: Number of unique paths Raises: ValueError: If rows or cols are not positive integers. if not (isinstance(rows, int) and isinstance(cols, int)): raise ValueError(\\"rows and cols must be integers\\") if rows <= 0 or cols <= 0: raise ValueError(\\"rows and cols must be positive integers\\") dp = [[0] * cols for _ in range(rows)] for i in range(rows): dp[i][0] = 1 for j in range(cols): dp[0][j] = 1 for i in range(1, rows): for j in range(1, cols): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[rows-1][cols-1]"},{"question":"# Coding Assessment Question You are tasked with writing a Python function to process a given list of student scores, categorize the scores into specific grade buckets, and generate a formatted string report. **Function Description:** Write a function `generate_grade_report(scores: List[int], boundaries: Dict[str, Tuple[int, int]]) -> str` that categorizes student scores based on specified grade boundaries and returns a formatted string report. Input: * `scores` (List[int]): A list of student scores, where each score is an integer between 0 and 100. * `boundaries` (Dict[str, Tuple[int, int]]): A dictionary where each key is a grade (e.g., \\"A\\", \\"B\\", \\"C\\", etc.) and each value is a tuple representing the inclusive lower and upper boundaries for that grade. Output: * A formatted string report that lists the total number of students per grade and the percentage of the total student population that each grade represents. Formatting Rules: * Each grade should be listed in alphabetical order of the grade\'s label. * Display the grade, number of students, and percentage with 2 decimal points. * If there are no students for a particular grade, it should still be included in the report with a count of 0 and a percentage of 0.00%. * Separate each grade category by a newline in the final output. Example: For the input scores: ``` [85, 92, 76, 64, 89, 78, 90] ``` And the boundaries: ``` { \\"A\\": (85, 100), \\"B\\": (70, 84), \\"C\\": (50, 69), \\"D\\": (0, 49) } ``` The output should be: ``` A: 4 students, 57.14% B: 2 students, 28.57% C: 1 students, 14.29% D: 0 students, 0.00% ``` **Constraints:** * You must not import any additional modules except those provided. * The input list `scores` will have at least one score. * Each boundary tuple in the `boundaries` dictionary will have values between 0 and 100 inclusive, and the boundaries will not overlap. **Notes:** * Pay attention to edge cases such as the lowest and highest scores and ensure they are correctly categorized. * Assume that boundary keys are always provided in a sorted manner and cover the full range from 0 to 100 without gaps. Here is a function signature to help you get started: ```python from typing import List, Dict, Tuple def generate_grade_report(scores: List[int], boundaries: Dict[str, Tuple[int, int]]) -> str: # Your code here ```","solution":"from typing import List, Dict, Tuple def generate_grade_report(scores: List[int], boundaries: Dict[str, Tuple[int, int]]) -> str: # Initialize dictionaries to trace counts and percentages grade_counts = {grade: 0 for grade in boundaries.keys()} total_students = len(scores) # Categorize scores into corresponding grade buckets for score in scores: for grade, (low, high) in boundaries.items(): if low <= score <= high: grade_counts[grade] += 1 break # Generate the report report_lines = [] for grade in sorted(boundaries.keys()): count = grade_counts[grade] percentage = (count / total_students) * 100 report_lines.append(f\\"{grade}: {count} students, {percentage:.2f}%\\") return \\"n\\".join(report_lines)"},{"question":"# Question: Implement a Flexible Number Series Generator Context Generating sequences of numbers is a common task in computer science, particularly in areas like cryptography, algorithms, and numerical analysis. The provided task will test your ability to create a customizable number series based on given parameters. Task Implement a function `flexible_series(start: int, end: int, rule: str) -> List[int]` that generates a series of numbers between `start` and `end` (inclusive). The generation rule is string-based and the function must adapt based on the specified rule. The supported rules are: - \\"prime\\": Only include prime numbers. - \\"even\\": Only include even numbers. - \\"odd\\": Only include odd numbers. Requirements 1. **Function Signature**: ```python def flexible_series(start: int, end: int, rule: str) -> List[int]: ``` 2. **Inputs**: - `start`: An integer indicating the start of the range. - `end`: An integer indicating the end of the range. - `rule`: A string specifying the rule for the series generation. It can be \\"prime\\", \\"even\\", or \\"odd\\". 3. **Output**: - A list of integers forming the required series based on the rule. 4. **Constraints**: - `start` should be less than or equal to `end`. - The rule must be one of the specified strings; if not, raise a `ValueError` with the message \\"Invalid rule provided.\\" 5. **Error Handling**: - If `start` is greater than `end`, raise a `ValueError` with the message \\"Start must be less than or equal to End.\\" Examples ```python >>> flexible_series(1, 10, \\"prime\\") [2, 3, 5, 7] >>> flexible_series(1, 10, \\"even\\") [2, 4, 6, 8, 10] >>> flexible_series(1, 10, \\"odd\\") [1, 3, 5, 7, 9] >>> flexible_series(10, 5, \\"even\\") Traceback (most recent call last): ... ValueError: Start must be less than or equal to End. >>> flexible_series(1, 10, \\"fibonacci\\") Traceback (most recent call last): ... ValueError: Invalid rule provided. ``` Notes - Prime numbers are greater than 1 and have no positive divisors other than 1 and themselves. - You may assume the input numbers are non-negative integers. - Ensure your implementation is efficient within typical computational limits. This question requires understanding of: - Number theory for generating primes. - Control structures for filtering sequences. - Error handling to validate inputs.","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def flexible_series(start: int, end: int, rule: str) -> List[int]: if start > end: raise ValueError(\\"Start must be less than or equal to End.\\") if rule not in {\\"prime\\", \\"even\\", \\"odd\\"}: raise ValueError(\\"Invalid rule provided.\\") if rule == \\"prime\\": return [i for i in range(start, end + 1) if is_prime(i)] if rule == \\"even\\": return [i for i in range(start, end + 1) if i % 2 == 0] if rule == \\"odd\\": return [i for i in range(start, end + 1) if i % 2 != 0]"},{"question":"# Coding Question: Find the Missing Number in a Permutation You are required to write a function that finds the missing number from a permutation of integers ranging from 0 to n inclusive. The input list will contain exactly `n` distinct integers from the range 0 to `n` inclusive, but one number will be missing. For example: - In the list `[3, 0, 1]`, the missing number is `2`. - In the list `[0, 1]`, the missing number is `2`. - In the list `[9,6,4,2,3,5,7,0,1]`, the missing number is `8`. Function Specification You need to implement the function `find_missing_number(numbers: list[int]) -> int` which finds the single missing number in the given list of integers. Here is the function signature: ```python def find_missing_number(numbers: list[int]) -> int: pass ``` Parameters - `numbers (list[int])`: The input list containing `n` distinct integers from the range `0` to `n`. Output - Return an integer that is the missing number from the list. Constraints - The length of the list is `n`, containing integers in the range from `0` to `n`. - All integers within the range are distinct. Example ```python assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0, 1]) == 2 assert find_missing_number([9,6,4,2,3,5,7,0,1]) == 8 assert find_missing_number([0]) == 1 assert find_missing_number([1]) == 0 ``` Performance Requirements * Time Complexity: (O(n)) * Space Complexity: (O(1)) Edge Cases to Consider - Lists with the smallest size (1 element) should be properly handled. - Ensure the function works efficiently for large values of `n`. - Verify there are no duplicate numbers in the input list. # Additional Guidance You can use mathematical summation to find the missing number efficiently by computing the expected sum of numbers from `0` to `n` and subtracting the sum of elements in the list from it. Here is an example implementation: ```python def find_missing_number(numbers: list[int]) -> int: n = len(numbers) expected_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return expected_sum - actual_sum ``` This method ensures the time and space complexity requirements are met.","solution":"def find_missing_number(numbers: list[int]) -> int: Finds the missing number from the list of numbers ranging from 0 to n. Parameters: numbers (list[int]): A list containing n distinct integers in the range [0, n]. Returns: int: The missing integer from the list. n = len(numbers) expected_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return expected_sum - actual_sum"},{"question":"# Coding Assessment Question Context: You are required to implement a basic scheduling algorithm that assigns tasks to processors in such a way that the tasks are completed as quickly as possible. Each task has a certain duration, and there are a limited number of processors available to execute tasks simultaneously. Task: Write a Python function `schedule_tasks(durations: List[int], num_processors: int) -> int` that takes a list of task durations and the number of available processors, and returns the minimum amount of time required to complete all tasks when scheduled optimally. Implementation Steps: 1. Sort the list of task durations. 2. Use a priority queue (min-heap) to simulate processor availability. 3. Sequentially assign tasks to processors in a manner that minimizes total completion time. 4. Return the total time required to finish all tasks. Input Format: - `durations`: A list of integers where each integer represents the duration of a task. - `num_processors`: An integer representing the number of available processors. Output Format: - Return a single integer representing the total time required to complete all tasks. Constraints: - 1 â‰¤ len(durations) â‰¤ 10^5 - 1 â‰¤ durations[i] â‰¤ 10^4 for each valid `i` - 1 â‰¤ num_processors â‰¤ 100 Performance Requirements: - Aim for a solution with a time complexity of O(n log k) where n is the number of tasks and k is the number of processors, and a space complexity of O(k). Example: Suppose you have 4 tasks with the following durations: [5, 3, 8, 2], and there are 3 processors available. Calling `schedule_tasks([5, 3, 8, 2], 3)` should yield: ```python 8 ``` Explanation: - Processor 1 handles tasks of 5 and 3 units. - Processor 2 handles the task of 8 units. - Processor 3 handles the task of 2 units. - The total time is determined by the longest processing duration, which is 8 units in this case. Note: - Ensure tasks are optimally distributed to minimize the total completion time.","solution":"import heapq from typing import List def schedule_tasks(durations: List[int], num_processors: int) -> int: Schedules tasks on processors to minimize the total completion time. Parameters: durations (List[int]): A list of integers representing the task durations. num_processors (int): The number of available processors. Returns: int: The minimum amount of time required to complete all tasks. if len(durations) == 0: return 0 # Edge case where the number of processors is greater than or equal to the number of tasks if num_processors >= len(durations): return max(durations) # Initialize a priority queue with 0s to keep track of the time each processor will be finished processors = [0] * num_processors heapq.heapify(processors) for duration in durations: # Assign the task to the processor that becomes available the earliest earliest_available = heapq.heappop(processors) heapq.heappush(processors, earliest_available + duration) # The total time will be the maximum time among all processors return max(processors)"},{"question":"# Context In the field of data compression, Run-Length Encoding (RLE) is a simple form of lossless data compression. In RLE, consecutive occurrences of the same data value are replaced with a single data value and a count. For example, the string \\"AAAABBBCCDAA\\" would be compressed to \\"4A3B2C1D2A\\". Decompressing it would return the original string. # Problem Statement Write a function `rle_encode(data: str) -> str` that takes a string as input and returns the Run-Length Encoded (RLE) version of the string. Conversely, write a function `rle_decode(rle: str) -> str` that takes an RLE-encoded string and returns the original string. # Input - `data`: a string consisting of printable ASCII characters. - `rle`: a string representing a valid RLE-encoded sequence, consisting of digits followed by characters. # Output - `rle_encode(data)`: a Run-Length Encoded string. - `rle_decode(rle)`: the original string after decoding. # Constraints - The length of the input string `data` will not exceed 10^6. - The encoded string `rle` will be a valid RLE-encoded sequence. # Example ```python >>> rle_encode(\\"AAAABBBCCDAA\\") \'4A3B2C1D2A\' >>> rle_encode(\\"ABCD\\") \'1A1B1C1D\' >>> rle_decode(\\"4A3B2C1D2A\\") \'AAAABBBCCDAA\' >>> rle_decode(\\"1A1B1C1D\\") \'ABCD\' ``` # Notes - Ensure your implementation handles both encoding and decoding efficiently, considering both time and space complexities. - Pay attention to edge cases, such as an empty string or strings with no repeating characters.","solution":"def rle_encode(data: str) -> str: if not data: return \\"\\" encoded = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: encoded.append(f\\"{count}{data[i - 1]}\\") count = 1 encoded.append(f\\"{count}{data[-1]}\\") return \'\'.join(encoded) def rle_decode(rle: str) -> str: decoded = [] count = 0 for char in rle: if char.isdigit(): count = count * 10 + int(char) # handle multi-digit numbers else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"# Unique Triplet Sum Challenge **Scenario**: You are working on a system that identifies unique triplets in an array of integers. These triplets must have a sum that is equal to zero. This functionality is useful in various applications such as finding financial transactions that balance out, or in analysis problems where specific sum constraints are required. **Task**: Implement a function `find_triplets` that identifies all unique triplets in an array which sum up to zero. **Specifications**: * You will write a function `find_triplets(nums: List[int]) -> List[List[int]]`. * `nums`: The list of integers to search for triplets. * The triplets in the output list should be unique. * No triplet should be included more than once in the result. * The result list and each triplet should be sorted in ascending order. **Constraints**: * The length of `nums` will not exceed `1,000`. * Each element of `nums` will be between `-10,000` and `10,000`. **Expected Output**: * Return a list of lists, where each inner list contains three integers that sum up to zero. **Examples**: ```python # Example 1 triplets = find_triplets([-1, 0, 1, 2, -1, -4]) print(triplets) # Expected: [[-1, -1, 2], [-1, 0, 1]] # Example 2 triplets = find_triplets([0, 0, 0, 0]) print(triplets) # Expected: [[0, 0, 0]] # Example 3 triplets = find_triplets([1, -1, -1, 2, -4, 0]) print(triplets) # Expected: [[-1, -1, 2], [-1, 0, 1]] ``` Implement the `find_triplets` function to meet these requirements.","solution":"from typing import List def find_triplets(nums: List[int]) -> List[List[int]]: nums.sort() triplets = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return triplets"},{"question":"# Character Frequency Compression You are tasked with creating a function that performs a form of basic string compression using the counts of repeated characters. The function should compress strings by replacing sequences of the same character with a single character followed by the number of occurrences. Task Write a function `compress_string(s: str) -> str` that takes a string as input and returns a compressed version of the string using the above-mentioned technique. Input: - `s` (str): A non-empty string consisting of only lowercase alphabetical characters. Output: - A string: The compressed version of the input string. Constraints: - The input string contains only lowercase letters (\'a\'-\'z\'). Examples: 1. **Input**: `\\"aabbcc\\"` **Output**: `\\"a2b2c2\\"` 2. **Input**: `\\"abc\\"` **Output**: `\\"a1b1c1\\"` 3. **Input**: `\\"aaabbbcccaaa\\"` **Output**: `\\"a3b3c3a3\\"` 4. **Input**: `\\"z\\"` **Output**: `\\"z1\\"` 5. **Input**: `\\"xxxxx\\"` **Output**: `\\"x5\\"` Additional Requirements: - Ensure to handle edge cases such as strings with only one type of character and strings with no repeated characters.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # Append the last set of character and its count return \\"\\".join(compressed)"},{"question":"Coding Assessment Question # Objective Write a function that simulates an online store inventory system by managing product stock levels and handling customer orders effectively. Your implementation should ensure the integrity of stock levels and handle various edge cases. # Scenario You are building an inventory management system for an online bookstore. The system needs to accurately keep track of stock levels for multiple books and ensure that customer orders are processed correctly without overselling. Additionally, the system must handle cases where books go out of stock or when invalid order requests are made. # Task Implement the class `BookstoreInventory` with the following functionality: 1. **Initialization**: * Accepts a dictionary where keys are book titles (strings) and values are the stock levels (integers). 2. **Methods**: * `check_stock(book_title: str) -> int`: Returns the current stock level for the given book. If the book does not exist, return -1. * `add_stock(book_title: str, quantity: int) -> None`: Adds the given quantity to the stock level of the specified book. If the book does not exist, add it to the inventory with the initial stock level set to the given quantity. * `place_order(book_title: str, quantity: int) -> str`: Attempts to place an order for the specified book and quantity. Returns a success message if the order can be fulfilled or an appropriate error message (e.g., out of stock, invalid quantity). # Constraints: * Book titles are limited to 200 characters. * Quantities are non-negative integers. * Ensure thread-safety if multiple orders or stock updates are processed concurrently. # Performance Requirements: * The system should efficiently manage stock updates and order placements. * Handle edge cases such as placing an order for a non-existent book or adding negative stock amounts gracefully. # Function Signature ```python class BookstoreInventory: def __init__(self, initial_stock: dict): pass def check_stock(self, book_title: str) -> int: pass def add_stock(self, book_title: str, quantity: int) -> None: pass def place_order(self, book_title: str, quantity: int) -> str: pass ``` # Example ```python inventory = BookstoreInventory({\\"Harry Potter\\": 10, \\"Lord of the Rings\\": 5}) print(inventory.check_stock(\\"Harry Potter\\")) # Output: 10 inventory.add_stock(\\"Harry Potter\\", 5) print(inventory.check_stock(\\"Harry Potter\\")) # Output: 15 print(inventory.place_order(\\"Harry Potter\\", 8)) # Output: \\"Order placed for 8 copies of \'Harry Potter\'.\\" print(inventory.check_stock(\\"Harry Potter\\")) # Output: 7 print(inventory.place_order(\\"Harry Potter\\", 10)) # Output: \\"Insufficient stock for \'Harry Potter\'. Order cannot be processed.\\" print(inventory.check_stock(\\"Unknown Book\\")) # Output: -1 ``` # Additional Task * Write unit tests to ensure the correctness of your class implementation. The tests should cover scenarios such as adding stock, placing orders with sufficient and insufficient stock, and checking stock levels for non-existent books.","solution":"class BookstoreInventory: def __init__(self, initial_stock: dict): Initializes the inventory with the given initial stock. initial_stock: a dictionary where keys are book titles and values are the stock levels. self.inventory = initial_stock def check_stock(self, book_title: str) -> int: Returns the current stock level for the given book. If the book does not exist, return -1. return self.inventory.get(book_title, -1) def add_stock(self, book_title: str, quantity: int) -> None: Adds the given quantity to the stock level of the specified book. If the book does not exist, add it to the inventory with the initial stock level set to the given quantity. if quantity < 0: return # no negative stock addition logic if book_title in self.inventory: self.inventory[book_title] += quantity else: self.inventory[book_title] = quantity def place_order(self, book_title: str, quantity: int) -> str: Attempts to place an order for the specified book and quantity. Returns a success message if the order can be fulfilled or an appropriate error message. if quantity <= 0: return f\\"Invalid order quantity: {quantity}. Order cannot be processed.\\" if book_title not in self.inventory: return f\\"The book \'{book_title}\' does not exist in the inventory.\\" if self.inventory[book_title] < quantity: return f\\"Insufficient stock for \'{book_title}\'. Order cannot be processed.\\" self.inventory[book_title] -= quantity return f\\"Order placed for {quantity} copies of \'{book_title}\'.\\""},{"question":"# Coding Question You are required to write a function that determines the minimum number of operations needed to turn an integer `n` into 1. The allowed operations are: 1. Subtract 1 from `n`. 2. If `n` is divisible by 2, divide `n` by 2. 3. If `n` is divisible by 3, divide `n` by 3. # Task Implement the function `min_operations_to_one()` which calculates the minimum number of operations required to transform `n` into 1. # Function Signature ```python def min_operations_to_one(n: int) -> int: ``` # Input - `n`: An integer (`1 <= n <= 10^6`). # Output - The minimum number of operations required to reduce `n` to 1. # Constraints - The function should efficiently handle the upper constraint. # Example ```python >>> min_operations_to_one(10) 3 # Explanation: 10 -> 9 -> 3 -> 1 >>> min_operations_to_one(15) 4 # Explanation: 15 -> 5 -> 4 -> 2 -> 1 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(16) 4 # Explanation: 16 -> 8 -> 4 -> 2 -> 1 ``` # Performance Requirements - Ensure the solution is efficient and can handle large inputs up to `10^6` within a reasonable time frame.","solution":"def min_operations_to_one(n: int) -> int: # Using Dynamic Programming to avoid recomputation dp = [0] * (n + 1) for i in range(2, n + 1): # Start with the operation of subtracting 1 min_ops = dp[i - 1] + 1 # If divisible by 2, consider the division operation if i % 2 == 0: min_ops = min(min_ops, dp[i // 2] + 1) # If divisible by 3, consider the division operation if i % 3 == 0: min_ops = min(min_ops, dp[i // 3] + 1) dp[i] = min_ops return dp[n]"},{"question":"# Scenario: A company dealing with stock trading wants to predict stock prices based on simple moving averages. You have been asked to write a function that computes the simple moving average for a given list of stock prices over a specified window period. # Problem Statement: Write a function `simple_moving_average` that takes a list of stock prices (each a float) and a window size (an integer) as input and returns a list of simple moving averages. # Input: * `prices` (List[float]): A list of float values representing the stock prices. Each price should be a non-negative float value. * `window` (int): The size of the window over which the average is computed. The window should be a positive integer. # Output: * `averages` (List[float]): A list of float values representing the simple moving averages. # Constraints: * The length of the `prices` list will always be greater than or equal to the `window`. * The window size will always be a positive integer. * The function should return an empty list if the window size is larger than the length of `prices`. # Performance Requirements: * The function must perform this operation in O(n) time complexity, where n is the number of stock prices. * Ensure to handle any exceptions gracefully. # Function Signature: ```python def simple_moving_average(prices: List[float], window: int) -> List[float]: pass ``` # Examples: ```python simple_moving_average([1, 2, 3, 4, 5], 3) # Expected Output: [2.0, 3.0, 4.0] simple_moving_average([10, 20, 30, 40], 2) # Expected Output: [15.0, 25.0, 35.0] simple_moving_average([10, 20, 30], 5) # Expected Output: [] simple_moving_average([100, 200, 300], 1) # Expected Output: [100.0, 200.0, 300.0] ``` # Notes: * Consider edge cases such as an empty list for prices or incorrect window sizes. * Do not use any external libraries for the calculations. * Ensure accurate floating-point arithmetic. * The function should handle exceptions effectively and return meaningful results based on constraints.","solution":"def simple_moving_average(prices, window): if window > len(prices) or window <= 0: return [] moving_averages = [] window_sum = sum(prices[:window]) moving_averages.append(window_sum / window) for i in range(window, len(prices)): window_sum += prices[i] - prices[i - window] moving_averages.append(window_sum / window) return moving_averages"},{"question":"# Maze Path Finder Problem Statement Given a maze represented by a 2D list, write a function to find if there is a path from the start position to the end position. The start position is always at the top-left corner of the maze (i.e., at position (0, 0)), and the end position is always at the bottom-right corner of the maze (i.e., at position (n-1, m-1)). The maze only contains walls \'W\' and open paths \'O\'. You can move up, down, left, or right but not diagonally, and cannot move through walls. Task Write a function `find_path(maze: list[list[str]]) -> bool` that takes a 2D list (`maze`) representing the maze and returns `True` if there is a path from the start to the end, otherwise `False`. Input - `maze`: A 2D list where each element is either \'O\' (open path) or \'W\' (wall). Output - `True` if there is a path from the start to the end of the maze; otherwise, `False`. Examples ```python maze = [ [\'O\', \'O\', \'W\', \'O\'], [\'W\', \'O\', \'W\', \'O\'], [\'O\', \'O\', \'O\', \'O\'], [\'O\', \'W\', \'O\', \'O\'] ] find_path(maze) # True maze = [ [\'O\', \'W\', \'W\', \'O\'], [\'W\', \'W\', \'W\', \'O\'], [\'O\', \'O\', \'O\', \'W\'], [\'O\', \'W\', \'O\', \'O\'] ] find_path(maze) # False ``` Constraints 1. `maze` dimensions will be at most 100x100. 2. The start position (0, 0) and the end position (n-1, m-1) are always \'O\'. 3. There will not be any cycles in the maze; each path will be unique and distinct. 4. Valid moves are strictly limited to up, down, left, and right. Notes - Utilize efficient algorithms to handle potentially large inputs. - Make sure to handle edge cases where the maze might be entirely walls or all open paths. - Consider using breadth-first search (BFS) or depth-first search (DFS) to find the path efficiently.","solution":"def find_path(maze): rows, cols = len(maze), len(maze[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == \'O\' def dfs(x, y, visited): if (x, y) in visited: return False if (x, y) == (rows - 1, cols - 1): return True visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny, visited): return True return False return dfs(0, 0, set())"},{"question":"# Question Given an array of integers, you are required to write a function that finds the maximum sum of a contiguous subarray using the \\"Divide and Conquer\\" approach, also known as the modified Kadaneâ€™s algorithm. This method should break the problem down into smaller subproblems, solve each subproblem individually, and then combine the results to solve the original problem. Your function should adhere to the following specifications: **Function Signature:** ```python def max_subarray_sum_divide_and_conquer(nums: List[int]) -> int: ``` **Input:** - `nums` (List[int]): A list of integers. **Output:** - Return an integer that represents the maximum sum of a contiguous subarray within the given list. **Example:** ```python assert max_subarray_sum_divide_and_conquer([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # The subarray [4, -1, 2, 1] has the largest sum = 6 assert max_subarray_sum_divide_and_conquer([1, 2, 3, 4, -10]) == 10 # The subarray [1, 2, 3, 4] has the largest sum = 10 assert max_subarray_sum_divide_and_conquer([-1, -2, -3, -4]) == -1 # The subarray [-1] has the largest sum = -1 ``` **Constraints and Notes:** - The list can include positive and negative numbers. - The list will have at least one element. - The function should utilize the divide and conquer approach, not the iterative or dynamic programming approach. - Consider edge cases where the list contains a single element or all negative numbers. - Implement an efficient and clear divide and conquer algorithm. # Evaluation Criteria: - Correctness and robustness of the function under various edge cases. - Efficiency in dividing the problem and combining results. - Clarity and maintainability of the code.","solution":"from typing import List def max_subarray_sum_divide_and_conquer(nums: List[int]) -> int: def find_max_crossing_subarray(nums, left, mid, right): left_sum = float(\'-inf\') sum = 0 for i in range(mid, left - 1, -1): sum += nums[i] if sum > left_sum: left_sum = sum right_sum = float(\'-inf\') sum = 0 for i in range(mid + 1, right + 1): sum += nums[i] if sum > right_sum: right_sum = sum return left_sum + right_sum def find_maximum_subarray(nums, left, right): if left == right: return nums[left] mid = (left + right) // 2 left_max = find_maximum_subarray(nums, left, mid) right_max = find_maximum_subarray(nums, mid + 1, right) cross_max = find_max_crossing_subarray(nums, left, mid, right) return max(left_max, right_max, cross_max) return find_maximum_subarray(nums, 0, len(nums) - 1)"},{"question":"# Scenario You are working on processing and analyzing large sets of numerical data in your current project. One essential step is to standardize the data before feeding it into a machine learning model. Your task is to implement a function that normalizes a given input vector using the min-max scaling method. # Task Implement the function `min_max_scale(vector: np.ndarray) -> np.ndarray` which applies Min-Max scaling transformation to a given vector. The Min-Max scaling formula is: [ X\' = frac{X - X_{text{min}}}{X_{text{max}} - X_{text{min}}} ] # Function Signature ```python def min_max_scale(vector: np.ndarray) -> np.ndarray: pass ``` # Input: * `vector` (np.ndarray): An ndarray representing the input vector where each element will be scaled. # Output: * Returns an ndarray where each element of the initial vector is scaled to the range [0, 1]. # Constraints: * The input vector can have 0 or more elements. * The vector may contain negative values. * If the input vector has all identical elements, the function should return a vector of zeros, because there is no range to scale. # Examples: 1. Input: `vector = np.array([2, 3, 4, 5])` Output: `np.array([0.0, 0.3333, 0.6667, 1.0])` 2. Input: `vector = np.array([-3.0, 0.0, 3.0, 6.0])` Output: `np.array([0.0, 0.3333, 0.6667, 1.0])` 3. Input: `vector = np.array([5, 5, 5, 5])` Output: `np.array([0.0, 0.0, 0.0, 0.0])` # Note: The implementation should handle numerical precision and edge cases gracefully, ensuring the function can transform both small and large datasets efficiently.","solution":"import numpy as np def min_max_scale(vector: np.ndarray) -> np.ndarray: Applies Min-Max scaling to a given vector, scaling each element to the range [0, 1]. Parameters: vector (np.ndarray): Input vector to be scaled. Returns: np.ndarray: Scaled vector with elements ranging between [0, 1]. if vector.size == 0: return vector # Empty array, return as is min_val = np.min(vector) max_val = np.max(vector) if min_val == max_val: return np.zeros_like(vector) # All elements are identical return (vector - min_val) / (max_val - min_val)"},{"question":"# Question Context Searching within a sorted array is a common task in many applications. The Binary Search algorithm is efficient for this purpose with a time complexity of O(log n). In this problem, you will implement a variant of Binary Search that not only determines the presence of an element in the array but also finds the index of its first occurrence if it exists within the array. Problem Statement Implement the function `binary_search_first_occurrence` that takes a sorted list of integers and a target integer. The function should return the index of the first occurrence of the target in the list. If the target is not present in the list, the function should return `-1`. 1. **binary_search_first_occurrence(nums: list[int], target: int) -> int** - **Input**: - `nums`: A sorted list of integers. - `target`: An integer representing the target value to search for. - **Output**: - An integer representing the index of the first occurrence of `target` in `nums`, or `-1` if the target is not present. - **Example**: ```python >>> binary_search_first_occurrence([1, 2, 4, 4, 4, 5, 6], 4) 2 >>> binary_search_first_occurrence([1, 2, 3, 5, 6], 4) -1 ``` 2. **Constraints**: - `1 <= len(nums) <= 10^5` - `nums` is a list of distinct integers, sorted in non-decreasing order. - `-10^4 <= target <= 10^4` Additional Requirements - Your implementation should handle edge cases such as: - An empty list. - The target being at the beginning or end of the list. - The target not being present in the list. - Aim for a time-complexity-efficient solution to handle the upper input limits gracefully.","solution":"def binary_search_first_occurrence(nums, target): Perform a binary search to find the first occurrence of the target in a sorted list of numbers. :param nums: List of sorted integers. :param target: Integer target value to search for. :return: Index of the first occurrence of the target, or -1 if target is not present. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: result = mid # Found the target, but look left for the first occurrence right = mid - 1 # Narrow the search to the left subarray elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question You are given an array of integers where each integer appears an even number of times, except for one unique integer that appears an odd number of times. Write a function `find_unique_integer(arr: List[int]) -> int` that accepts: - `arr`: A list of integers. The function should return the unique integer that appears an odd number of times. Example ```python arr = [2, 3, 5, 4, 5, 3, 4, 2, 2] assert find_unique_integer(arr) == 2 ``` Constraints - The array will have at least 1 and at most 100,000 integers. - All integers in the array are between -10^9 and 10^9. Note - Consider using bitwise operations to find the unique integer efficiently.","solution":"def find_unique_integer(arr): Returns the unique integer that appears an odd number of times in the array. Args: arr (List[int]): List of integers where all integers appear an even number of times except for one. Returns: int: The unique integer that appears an odd number of times. unique_integer = 0 for num in arr: unique_integer ^= num return unique_integer"},{"question":"Problem Statement You are given a list of integers and your task is to remove the duplicates from the list without using any built-in libraries for handling duplicates. The output should preserve the original order of the first occurrences of the elements in the input list. # Function Signature ```python def remove_duplicates(nums: List[int]) -> List[int]: pass ``` # Input - A list of integers `nums` (0 â‰¤ len(nums) â‰¤ 10^5). # Output - Returns a list of integers with duplicates removed, maintaining the original order of first occurrences. # Constraints - The function should efficiently handle lists with up to 100,000 elements. - The input list will contain only integers. # Example ```python >>> remove_duplicates([1, 2, 2, 3, 4, 3, 5, 1]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 4, 4, 4, 4]) [4] >>> remove_duplicates([]) [] ``` # Notes - You need to implement the function without using any set or dictionary from built-in Python libraries that directly handle duplicates. - Aim for an optimal solution where possible; consider both time and space complexity. Your task is to implement the function `remove_duplicates` following the above specifications.","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes duplicates from the list while preserving the order of first occurrences. result = [] seen = set() for num in nums: if num not in seen: result.append(num) seen.add(num) return result"},{"question":"# Context To test your understanding of basic data structures and algorithm design, you need to implement a function for converting a given decimal number to its binary representation. This function should not use any in-built Python methods for direct conversion. # Question Implement a function `decimal_to_binary(n: int) -> str` in Python that takes a positive integer `n` and returns its binary representation as a string. Do not use Python\'s built-in functions like `bin()` for conversion. Ensure to handle edge cases and optimize for performance. Input Format - A positive integer `n`. Output Format - A string representing the binary representation of `n`. Example ```python >>> decimal_to_binary(5) \'101\' >>> decimal_to_binary(0) \'0\' >>> decimal_to_binary(32) \'100000\' ``` Constraints - `n` is a non-negative integer. - The function should handle edge cases, such as the smallest possible input value, and return appropriate results. # Performance Requirements - Your solution should ideally operate in O(log(n)) time complexity, as this matches the number of bits in the binary representation of `n`. - Aim for a space complexity of O(1) additional space apart from the string that is returned.","solution":"def decimal_to_binary(n: int) -> str: Converts a decimal number to its binary representation. :param n: integer, the decimal number to convert :return: string, the binary representation of the decimal number if n == 0: return \\"0\\" binary_representation = \\"\\" while n > 0: binary_representation = str(n % 2) + binary_representation n = n // 2 return binary_representation"},{"question":"# Problem Statement A warehouse keeps track of its stock in real-time using a simple inventory system represented as a list of integers. Each integer represents the quantity of a particular item. The system supports two main operations: restocking an item and fulfilling an order for an item. You are required to implement a system that can track these operations and keep the inventory updated accordingly. # Specific Requirements 1. **Input**: - A list of integers `inventory` where each integer represents the initial quantity of an item. - A list of operations to be performed on the inventory. Each operation is represented by a tuple: `(\\"restock\\" or \\"fulfill\\", index, quantity)`. 2. **Output**: - A list of integers representing the updated inventory after all operations are performed. # Example Consider the following inventory and operations: ```python inventory = [10, 5, 0, 20] operations = [(\\"restock\\", 2, 15), (\\"fulfill\\", 0, 5), (\\"fulfill\\", 1, 1)] ``` After performing the operations: - Restock index 2 with quantity 15: inventory becomes `[10, 5, 15, 20]` - Fulfill index 0 with quantity 5: inventory becomes `[5, 5, 15, 20]` - Fulfill index 1 with quantity 1: inventory becomes `[5, 4, 15, 20]` The final inventory would be `[5, 4, 15, 20]`. # Constraints - The `inventory` list will contain non-negative integers only. - The `operations` list can contain up to 10^5 operations. - Each index in the operations is valid for the given `inventory` list. - Fulfillment operations should never attempt to reduce the inventory below zero for any item. If such an attempt is made, raise a ValueError with an appropriate message. # Function Implementation You are required to implement the function `update_inventory(inventory: List[int], operations: List[Tuple[str, int, int]]) -> List[int]` that updates the inventory as per the operations provided and returns the updated inventory. # Additional Guidance Ensure to handle edge cases such as: - No operations to perform. - Restocking or fulfilling an item at the last index of the inventory. # Example Implementation ```python def update_inventory(inventory, operations): Updates the inventory based on the given operations. :param inventory: A list of integers representing the initial inventory. :param operations: A list of operations to be performed on the inventory. :return: A list of integers representing the updated inventory. for operation, index, quantity in operations: if operation == \\"restock\\": inventory[index] += quantity elif operation == \\"fulfill\\": if inventory[index] < quantity: raise ValueError(f\\"Insufficient stock for item at index {index}\\") inventory[index] -= quantity else: raise ValueError(\\"Invalid operation\\") return inventory if __name__ == \\"__main__\\": inventory = [10, 5, 0, 20] operations = [(\\"restock\\", 2, 15), (\\"fulfill\\", 0, 5), (\\"fulfill\\", 1, 1)] print(update_inventory(inventory, operations)) # Should print [5, 4, 15, 20] ``` This question is designed to test the student\'s ability to manipulate list data structures, handle operations, and implement error-checking mechanisms.","solution":"def update_inventory(inventory, operations): Updates the inventory based on the given operations. :param inventory: A list of integers representing the initial inventory. :param operations: A list of operations to be performed on the inventory. :return: A list of integers representing the updated inventory. for operation, index, quantity in operations: if operation == \\"restock\\": inventory[index] += quantity elif operation == \\"fulfill\\": if inventory[index] < quantity: raise ValueError(f\\"Insufficient stock for item at index {index}\\") inventory[index] -= quantity else: raise ValueError(\\"Invalid operation\\") return inventory"},{"question":"# Coding Question - Implement a Binary Search Tree with Basic Operations Context You are tasked with implementing a binary search tree (BST). A BST is a binary tree in which each node has a value such that all values in the left subtree are less than the node\'s value, and all values in the right subtree are greater than the node\'s value. This property allows efficient search, insertion, and deletion operations. Task Implement a `BinarySearchTree` class in Python with the following methods: 1. **`__init__(self) -> None`**: Initializes an empty binary search tree. 2. **`insert(self, value: int) -> None`**: Inserts a value into the BST. Duplicate values are not allowed. 3. **`find(self, value: int) -> bool`**: Returns `True` if the value exists in the BST, otherwise `False`. 4. **`delete(self, value: int) -> None`**: Deletes the node with the given value from the BST. If the value is not found, raise a `ValueError`. 5. **`inorder(self) -> List[int]`**: Returns a list of all values in the BST in ascending order. 6. **`preorder(self) -> List[int]`**: Returns a list of all values in the BST in a preorder traversal. 7. **`postorder(self) -> List[int]`**: Returns a list of all values in the BST in a postorder traversal. Input and Output Formats: - Methods `insert`, `find`, and `delete` will have an integer parameter `value`. - Method `find` will return a boolean. - Methods `inorder`, `preorder`, and `postorder` will return a list of integers. - Method `delete` will raise a `ValueError` if the value is not found. Example: ```python bst = BinarySearchTree() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) print(bst.find(40)) # True print(bst.find(25)) # False print(bst.inorder()) # [20, 30, 40, 50, 60, 70, 80] print(bst.preorder()) # [50, 30, 20, 40, 70, 60, 80] print(bst.postorder()) # [20, 40, 30, 60, 80, 70, 50] bst.delete(20) print(bst.inorder()) # [30, 40, 50, 60, 70, 80] bst.delete(30) print(bst.inorder()) # [40, 50, 60, 70, 80] bst.delete(50) print(bst.inorder()) # [40, 60, 70, 80] print(bst.find(50)) # False ``` Constraints: - Each method should be implemented according to the BST properties. - Values inserted into the BST must be unique. - The tree should maintain its properties after each insertion and deletion. Performance Requirements: - The average time complexity for insert, find, and delete operations should be O(log n). - The worst-case time complexity for insert, find, and delete operations should be O(n).","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) # Do nothing if the value is already present in the tree def find(self, value: int) -> bool: return self._find(self.root, value) def _find(self, node: TreeNode, value: int) -> bool: if node is None: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def _delete(self, node: TreeNode, value: int) -> TreeNode: if node is None: raise ValueError(\\"Value not found in the BST.\\") if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: # node.value == value if node.left is None: return node.right elif node.right is None: return node.left else: min_larger_node = self._find_min(node.right) node.value = min_larger_node.value node.right = self._delete(node.right, min_larger_node.value) return node def _find_min(self, node: TreeNode) -> TreeNode: while node.left is not None: node = node.left return node def inorder(self) -> list: result = [] self._inorder(self.root, result) return result def _inorder(self, node: TreeNode, result: list) -> None: if node: self._inorder(node.left, result) result.append(node.value) self._inorder(node.right, result) def preorder(self) -> list: result = [] self._preorder(self.root, result) return result def _preorder(self, node: TreeNode, result: list) -> None: if node: result.append(node.value) self._preorder(node.left, result) self._preorder(node.right, result) def postorder(self) -> list: result = [] self._postorder(self.root, result) return result def _postorder(self, node: TreeNode, result: list) -> None: if node: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.value)"},{"question":"# Context You are developing an application to manage a library\'s book inventory. The system requires a functionality to search for books based on multiple criteria including author name, publication year, and a keyword that may be present in the book\'s title. # Task Implement a function `search_books(books: List[dict], author: str, year: int, keyword: str) -> List[dict]` that filters a list of books according to the given criteria. Each book is represented as a dictionary with keys: \'title\', \'author\', and \'year\'. The function should return a list of books that match all the provided criteria. # Input Requirements 1. `books`: A list of dictionaries, where each dictionary represents a book and contains the following keys: - `\\"title\\"`: A string representing the book\'s title. - `\\"author\\"`: A string representing the author\'s name. - `\\"year\\"`: An integer representing the publication year. 2. `author`: A string representing the name of the author to search for. 3. `year`: An integer representing the publication year to search for. 4. `keyword`: A string to match against titles of the books. # Output Format A list of dictionaries, where each dictionary represents a book that matches all the criteria provided. # Constraints & Considerations - **Constraints**: - Raise a **TypeError** if any input is of the wrong type (e.g., `books` is not a list of dictionaries, `author` is not a string, `year` is not an integer, `keyword` is not a string). - The search should be case insensitive. - If no books match the criteria, return an empty list. # Function Signature Ensure to define the function signature as follows: ```python from typing import List, Dict def search_books(books: List[Dict[str, any]], author: str, year: int, keyword: str) -> List[Dict[str, any]]: pass ``` # Example ```python books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, {\\"title\\": \\"Animal Farm\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1945}, ] >>> search_books(books, \\"George Orwell\\", 1945, \\"farm\\") [ {\\"title\\": \\"Animal Farm\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1945} ] >>> search_books(books, \\"George Orwell\\", 1945, \\"unknown\\") [] >>> search_books(books, \\"Harper Lee\\", 1960, \\"mockingbird\\") [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960} ] ```","solution":"from typing import List, Dict, Any def search_books(books: List[Dict[str, Any]], author: str, year: int, keyword: str) -> List[Dict[str, Any]]: Search for books by author name, publication year, and a keyword in title. if not isinstance(books, list) or not all(isinstance(book, dict) for book in books): raise TypeError(\\"books must be a list of dictionaries\\") if not isinstance(author, str): raise TypeError(\\"author must be a string\\") if not isinstance(year, int): raise TypeError(\\"year must be an integer\\") if not isinstance(keyword, str): raise TypeError(\\"keyword must be a string\\") result = [] for book in books: if (author.lower() in book.get(\\"author\\", \\"\\").lower() and book.get(\\"year\\") == year and keyword.lower() in book.get(\\"title\\", \\"\\").lower()): result.append(book) return result"},{"question":"# Problem: Sum of Consecutive Powers of Digits You are tasked with finding all numbers that can be written as the sum of consecutive powers of their digits. More specifically, the problem is to find all numbers between 10,000 and 100,000 (inclusive) such that each digit (d) in the number raised to the power of its 1-based position (left to right) equals the number. Finally, calculate the total sum of such numbers. Input: No direct input is required; the ranges are predefined as between 10,000 and 100,000. Output: Your function should return a single integer representing the sum of all such numbers. Example: For a similar problem with squares, an example could be: ``` 89 = 8^1 + 9^2 ``` Write a function `sum_consecutive_powers` that solves the problem. ```python def sum_consecutive_powers() -> int: This function calculates the sum of all numbers that can be expressed as the sum of consecutive powers of their digits within the range [10000, 100000]. Returns: int: The sum of all such numbers. def sum_of_powers(number: int) -> int: digits = [int(digit) for digit in str(number)] return sum(digit ** (i + 1) for i, digit in enumerate(digits)) total_sum = sum( number for number in range(10000, 100001) if number == sum_of_powers(number) ) return total_sum # Example of usage if __name__ == \\"__main__\\": print(sum_consecutive_powers()) ``` # Constraints: - The numbers to be checked lie between 10,000 and 100,000. - Efficiently compute powers and their sums. - The solution should run within a reasonable time frame for the given range.","solution":"def sum_consecutive_powers() -> int: This function calculates the sum of all numbers that can be expressed as the sum of consecutive powers of their digits within the range [10000, 100000]. Returns: int: The sum of all such numbers. def sum_of_powers(number: int) -> int: digits = [int(digit) for digit in str(number)] return sum(digit ** (i + 1) for i, digit in enumerate(digits)) total_sum = sum( number for number in range(10000, 100001) if number == sum_of_powers(number) ) return total_sum # Example of usage if __name__ == \\"__main__\\": print(sum_consecutive_powers())"},{"question":"# Problem Statement You are assigned to create a function that generates all possible n-letter words from a given array of unique alphabets. The generated words must follow dictionary ordering. # Function Specification Implement the following function: ```python def generate_words(alphabets: List[str], n: int) -> List[str]: This function generates all possible n-letter words using the given array of unique alphabets in dictionary order. Args: alphabets (List[str]): List of unique alphabets. n (int): The length of each word to generate. Returns: List[str]: List of all possible n-letter words in dictionary order. ``` # Input - A list `alphabets` of unique alphabet characters (`1 <= len(alphabets) <= 10`), given in sorted order. - An integer `n` where `1 <= n <= 10`. # Output - The function should return a list of all possible n-letter words formed using the given alphabets, sorted in dictionary order. # Examples ```python >>> generate_words([\'a\', \'b\', \'c\'], 2) [\'aa\', \'ab\', \'ac\', \'ba\', \'bb\', \'bc\', \'ca\', \'cb\', \'cc\'] >>> generate_words([\'w\', \'x\', \'y\', \'z\'], 3) [\'www\', \'wwx\', \'wwy\', \'wwz\', \'wxw\', \'wxx\', \'wxy\', \'wxz\', \'wyw\', \'wyx\', \'wyy\', \'wyz\', \'wzw\', \'wzx\', \'wzy\', \'wzz\', \'xww\', \'xwx\', \'xwy\', \'xwz\', \'xxw\', \'xxx\', \'xxy\', \'xxz\', \'xyw\', \'xyx\', \'xyy\', \'xyz\', \'xzw\', \'xzx\', \'xzy\', \'xzz\', \'yww\', \'ywx\', \'ywy\', \'ywz\', \'yxw\', \'yxx\', \'yxy\', \'yxz\', \'yyw\', \'yyx\', \'yyy\', \'yyz\', \'yzw\', \'yzx\', \'yzy\', \'yzz\', \'zww\', \'zwx\', \'zwy\', \'zwz\', \'zxw\', \'zxx\', \'zxy\', \'zxz\', \'zyw\', \'zyx\', \'zyy\', \'zyz\', \'zzw\', \'zzx\', \'zzy\', \'zzz\'] >>> generate_words([\'d\', \'e\'], 1) [\'d\', \'e\'] ``` # Constraints - You can assume that `alphabets` only contains distinct characters. - Ensure the output list is sorted in dictionary order. - Consider edge cases where `n` is 1 or the length of `alphabets` is at its bounds. # Requirements - The function should handle the generation and sorting efficiently for the given constraints. - Ensure that the function properly forms and returns all possible combinations without missing any. - Edge cases should be properly managed, for instance when `n` is 1 or the alphabet list is small or large within the given constraints.","solution":"from typing import List from itertools import product def generate_words(alphabets: List[str], n: int) -> List[str]: This function generates all possible n-letter words using the given array of unique alphabets in dictionary order. Args: alphabets (List[str]): List of unique alphabets. n (int): The length of each word to generate. Returns: List[str]: List of all possible n-letter words in dictionary order. # Generate the Cartesian product of alphabets repeated n times words = [\'\'.join(word) for word in product(alphabets, repeat=n)] return words"},{"question":"# Finite State Machine Interpreter You are tasked with implementing a finite state machine (FSM) interpreter. The FSM has a specified number of states and transitions based on given rules. The interpreter should support the following functionalities: 1. `add_state(state)`: Add a new state to the FSM. 2. `add_transition(start_state, event, end_state)`: Define a transition from `start_state` to `end_state` triggered by the `event`. 3. `run(events)`: Start the FSM from an initial state (pre-defined) and process a list of events in sequence, returning the final state. # Input and Output Formats: - **add_state**: * Input: String state. * Output: None. - **add_transition**: * Input: String start_state, String event, String end_state. * Output: None. - **run**: * Input: List of String events. * Output: String final_state. # Constraints: - There will be no more than 50 states. - Transitions will be defined for events which are also strings. - Events will be processed in less than or equal to 1000 operations. - The FSM will always start in the \\"START\\" state. - Ensure transitions are deterministic (i.e., for a given state and event, there is only one resulting state). # Context Example: This type of FSM can be used to model workflows or protocols where an entity transitions through a series of defined states based on input events. For instance, a simple FSM could model a traffic light controller. ```python class FSM: def __init__(self): Initialize the FSM with an empty set of states and transitions. self.states = set() self.transitions = {} self.current_state = \\"START\\" def add_state(self, state: str) -> None: Add a new state to the FSM. self.states.add(state) if state not in self.transitions: self.transitions[state] = {} def add_transition(self, start_state: str, event: str, end_state: str) -> None: Define a transition in the FSM. if start_state in self.states and end_state in self.states: self.transitions[start_state][event] = end_state def run(self, events: list) -> str: Process a list of events and return the final state. for event in events: if event in self.transitions[self.current_state]: self.current_state = self.transitions[self.current_state][event] return self.current_state # Tests fsm = FSM() fsm.add_state(\\"START\\") fsm.add_state(\\"STATE1\\") fsm.add_state(\\"STATE2\\") fsm.add_transition(\\"START\\", \\"go\\", \\"STATE1\\") fsm.add_transition(\\"STATE1\\", \\"next\\", \\"STATE2\\") fsm.add_transition(\\"STATE2\\", \\"reset\\", \\"START\\") assert fsm.run([\\"go\\", \\"next\\"]) == \\"STATE2\\" # returns STATE2 assert fsm.run([\\"go\\", \\"next\\", \\"reset\\"]) == \\"START\\" # returns START ```","solution":"class FSM: def __init__(self): Initialize the FSM with an empty set of states and transitions. Also sets the initial state to \'START\'. self.states = set() self.transitions = {} self.current_state = \\"START\\" def add_state(self, state: str) -> None: Add a new state to the FSM. self.states.add(state) if state not in self.transitions: self.transitions[state] = {} def add_transition(self, start_state: str, event: str, end_state: str) -> None: Define a transition in the FSM. if start_state in self.states and end_state in self.states: self.transitions[start_state][event] = end_state def run(self, events: list) -> str: Process a list of events and return the final state. for event in events: if event in self.transitions[self.current_state]: self.current_state = self.transitions[self.current_state][event] return self.current_state"},{"question":"# AVL Tree Balancing Context An AVL tree is a self-balancing binary search tree where the difference in heights between the left and right subtrees of any node is at most 1. This difference is known as the balance factor. To keep the tree balanced during insertions or deletions, we perform tree rotations when necessary. Task You are to implement a class `AVLTree` that supports inserting nodes into the AVL tree while maintaining its balance. The class should provide methods to insert elements and to display the tree in a sorted order. Requirements: 1. The `AVLTree` class should have an `insert` method that takes an integer value and inserts it into the tree while maintaining the AVL tree properties. 2. The class should have a `display_in_order` method that returns a list of tree elements in ascending order. 3. Nodes should be balanced using left rotations, right rotations, left-right rotations, and right-left rotations as necessary. 4. Duplicates are not allowed in the tree. If an attempt is made to insert a duplicate value, it should be ignored. Input: * Integers to be inserted into the tree one by one via the `insert` method. Output: * A list of integers representing the in-order traversal of the tree when `display_in_order` is called. Constraints: * Ensure the efficiency of the insertion and balancing operations. * Use Python\'s built-in data structures and classes for the implementation. Examples: ```python avl = AVLTree() avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(4) avl.insert(15) >>> avl.display_in_order() [4, 5, 10, 15, 20] avl.insert(10) # Attempt to insert a duplicate value >>> avl.display_in_order() [4, 5, 10, 15, 20] avl.insert(12) avl.insert(11) >>> avl.display_in_order() [4, 5, 10, 11, 12, 15, 20] ``` Implementation Note: Handle the tree balancing operations (rotations) carefully to ensure the AVL properties are preserved after each insertion. You may define additional helper methods or classes as needed to manage the tree nodes and rotations.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if node is None: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node # Duplicate keys are not allowed node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) if balance_factor > 1: if key < node.left.key: return self._right_rotate(node) elif key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1: if key > node.right.key: return self._left_rotate(node) elif key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def display_in_order(self): result = [] self._in_order(self.root, result) return result def _in_order(self, node, result): if not node: return self._in_order(node.left, result) result.append(node.key) self._in_order(node.right, result)"},{"question":"# Question Design a function `list_xor_product` that takes a list of tuples as input, where each tuple consists of an even number of non-negative integers. The function should return a list containing the product of the XOR results of consecutive pairs within each tuple. Function Signature ```python def list_xor_product(input_tuples: List[Tuple[int, ...]]) -> List[int]: ``` Input * `input_tuples`: A list of tuples, where each tuple contains an even number of non-negative integers. Output * A list of integers, where each integer is the product of the XOR results of consecutive pairs within the corresponding tuple from the input list. Constraints * The input list will contain at least one tuple. * Each tuple will consist of an even number of non-negative integers. * Each integer in the tuple will be a non-negative integer (0 or greater). Example ```python >>> list_xor_product([(1, 2, 3, 4), (0, 0, 1, 1)]) [12, 0] >>> list_xor_product([(2, 3), (5, 6, 7, 8)]) [1, 45] >>> list_xor_product([(0, 1, 2, 3), (4, 5, 6, 7)]) [3, 21] ``` In the case of `list_xor_product([(1, 2, 3, 4), (0, 0, 1, 1)])`, the first tuple\'s XOR results are `(1 ^ 2) = 3` and `(3 ^ 4) = 7`, followed by their product `3 * 7 = 21`. For the second tuple, `(0 ^ 0) = 0` and `(1 ^ 1) = 0`, followed by `0 * 0 = 0`. Therefore, the final result is `[21, 0]`.","solution":"from typing import List, Tuple def list_xor_product(input_tuples: List[Tuple[int, ...]]) -> List[int]: def single_tuple_xor_product(t: Tuple[int, ...]) -> int: xor_results = [t[i] ^ t[i+1] for i in range(0, len(t), 2)] product = 1 for res in xor_results: product *= res return product results = [single_tuple_xor_product(t) for t in input_tuples] return results"},{"question":"# Find Unique Characters: Set Operations and Efficiency You are required to implement a function that processes an input string and returns a list of unique characters in the order of their first appearance. # Task Implement a function `find_unique_characters` that takes a single string `s` and returns a list of unique characters in the order they first appear in the string. # Specifications Method: `find_unique_characters` - **Input**: A string `s`. - **Output**: A list of characters, where each character is unique and appears in the order of their first occurrence in `s`. # Constraints 1. The input string `s` consists of only printable ASCII characters. 2. The length of `s` is not greater than 10,000. # Performance Requirements - The function should efficiently handle the order and uniqueness constraints without significant overhead. # Example ```python >>> find_unique_characters(\\"hello\\") [\'h\', \'e\', \'l\', \'o\'] >>> find_unique_characters(\\"character\\") [\'c\', \'h\', \'a\', \'r\', \'t\', \'e\'] >>> find_unique_characters(\\"aaabbbccc\\") [\'a\', \'b\', \'c\'] >>> find_unique_characters(\\"abcabcabcd\\") [\'a\', \'b\', \'c\', \'d\'] ``` # Implementation ```python def find_unique_characters(s: str) -> list: seen = set() unique_chars = [] for char in s: if char not in seen: seen.add(char) unique_chars.append(char) return unique_chars ``` # Example Explanation 1. In the string \\"hello\\": - The characters appear in the order `h`, `e`, `l`, `o`. - Output list is `[\'h\', \'e\', \'l\', \'o\']`. 2. In the string \\"character\\": - The characters appear in the order `c`, `h`, `a`, `r`, `t`, `e`. - Output list is `[\'c\', \'h\', \'a\', \'r\', \'t\', \'e\']`. 3. In the string \\"aaabbbccc\\": - The characters appear in the order `a`, `b`, `c`. - Output list is `[\'a\', \'b\', \'c\']`. 4. In the string \\"abcabcabcd\\": - The characters appear in the order `a`, `b`, `c`, `d`. - Output list is `[\'a\', \'b\', \'c\', \'d\']`. This question assesses the candidate\'s ability to handle set operations and maintain the order of elements efficiently. The use of sets ensures the uniqueness of characters, while appending to a list maintains the order of their first appearance.","solution":"def find_unique_characters(s: str) -> list: This function takes a string s and returns a list of unique characters in the order they first appear in the string. seen = set() unique_chars = [] for char in s: if char not in seen: seen.add(char) unique_chars.append(char) return unique_chars"},{"question":"# Implement a Custom Sorting Algorithm Using Heap You are required to write a function `custom_heapsort` that sorts an array of integers using the heap sort algorithm. Implement this algorithm from scratch without using any in-built sorting functions or libraries. Function Signature ```python def custom_heapsort(arr: List[int]) -> List[int]: Perform heapsort on a given list of integers. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: Sorted list of integers. pass ``` Requirements 1. **Input/Output**: - **Input**: - `arr` (List[int]): A list of integers that need to be sorted. - **Output**: - A sorted list of integers in ascending order. 2. **Implementation Details**: - Implement the helper function `heapify` to maintain the heap property. - Build a max-heap from the input list. - Extract the elements from the heap one by one, maintaining the max-heap property each time. - Ensure that the implementation handles edge cases such as an empty list or a list with repeated elements. - Optimize for efficient performance in terms of both time and space complexity. - Avoid using in-built sorting functions and libraries like `sort()` or `sorted()`. 3. **Performance**: - The algorithm should operate with a time complexity of O(N log N), where N is the number of elements in the list. Example ```python # Example usage arr = [4, 10, 3, 5, 1] sorted_arr = custom_heapsort(arr) print(\\"Sorted array:\\", sorted_arr) # Output: Sorted array: [1, 3, 4, 5, 10] ``` Your task is to implement the `custom_heapsort` function to achieve the expected functionality.","solution":"def custom_heapsort(arr): Perform heapsort on a given list of integers. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: Sorted list of integers. if not arr: return arr n = len(arr) # Function to heapify a subtree rooted with node i which is an index in arr[]. def heapify(arr, n, i): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"# Sum of Sliding Window You are given an array of integers and a window size. Your task is to write a function that calculates the sum of each sliding window (subarray of length `k`) and returns the result in an array. Ensure your implementation handles large inputs efficiently. Task 1. **Function Name**: `sliding_window_sum` 2. **Input**: - A list of integers. - An integer `k` representing the window size. 3. **Output**: A list of integers representing the sum of each sliding window. 4. **Constraints**: - The list length can be up to 10^5 elements. - The window size `k` will be a positive integer less than or equal to the length of the list. Requirements - Handle edge cases where the list is empty or `k` is 1. - Optimize for performance so that the function runs efficiently even for maximum input size. - Ensure your solution runs in linear time with respect to the number of elements in the list. Example ```python def sliding_window_sum(arr: list, k: int) -> list: # Your implementation here pass # Example cases print(sliding_window_sum([1, 2, 3, 4, 5], 3)) # Expected output: [6, 9, 12] print(sliding_window_sum([10, 20, 30], 2)) # Expected output: [30, 50] print(sliding_window_sum([3, 3, 3, 3], 1)) # Expected output: [3, 3, 3, 3] print(sliding_window_sum([], 1)) # Expected output: [] print(sliding_window_sum([15, 25, 35, 45, 55], 5)) # Expected output: [175] ``` Include unit tests to verify the correctness of your function and ensure it works efficiently with large input data.","solution":"def sliding_window_sum(arr: list, k: int) -> list: Calculate the sum of each sliding window (subarray of length k) in the given list. Parameters: arr (list): The list of integers. k (int): The window size. Returns: list: A list of integers representing the sum of each sliding window. if not arr or k <= 0 or k > len(arr): return [] n = len(arr) result = [] window_sum = sum(arr[:k]) result.append(window_sum) for i in range(k, n): window_sum += arr[i] - arr[i - k] result.append(window_sum) return result"},{"question":"# Problem Description You are tasked with creating a function that calculates the Body Mass Index (BMI) given a person\'s weight and height and classifies the result based on standard BMI categories. The function should validate the input parameters to ensure they are both positive. If any parameter is non-positive, the function should raise a `ValueError`. # Function Signature ```python def calculate_bmi(weight: float, height: float) -> str: pass ``` # Input * **weight** (float): A positive float number representing the person\'s weight in kilograms. * **height** (float): A positive float number representing the person\'s height in meters. # Output * **bmi_category** (str): A string representing the BMI category. The categories are as follows: - \\"Underweight\\" if BMI < 18.5 - \\"Normal weight\\" if 18.5 â‰¤ BMI < 24.9 - \\"Overweight\\" if 25 â‰¤ BMI < 29.9 - \\"Obesity\\" if BMI â‰¥ 30 # Constraints * Both input parameters must be positive float numbers. * If any parameter is non-positive, the function should raise a `ValueError`. # Examples ```python >>> calculate_bmi(68, 1.75) \'Normal weight\' >>> calculate_bmi(85, 1.75) \'Overweight\' >>> calculate_bmi(54, 1.70) \'Normal weight\' >>> calculate_bmi(0, 1.75) Traceback (most recent call last): ... ValueError: Both weight and height must be positive. >>> calculate_bmi(68, 0) Traceback (most recent call last): ... ValueError: Both weight and height must be positive. ``` # Note - The formula for calculating BMI is weight (kg) / (height (m))^2. - Ensure to handle and raise appropriate errors for non-positive inputs. - Ensure to run and pass the provided examples and edge cases.","solution":"def calculate_bmi(weight: float, height: float) -> str: Calculates Body Mass Index (BMI) and returns the BMI category. Categories: - \\"Underweight\\" if BMI < 18.5 - \\"Normal weight\\" if 18.5 â‰¤ BMI < 24.9 - \\"Overweight\\" if 25 â‰¤ BMI < 29.9 - \\"Obesity\\" if BMI â‰¥ 30 if weight <= 0 or height <= 0: raise ValueError(\\"Both weight and height must be positive.\\") bmi = weight / height ** 2 if bmi < 18.5: return \\"Underweight\\" elif 18.5 <= bmi < 24.9: return \\"Normal weight\\" elif 25 <= bmi < 29.9: return \\"Overweight\\" else: return \\"Obesity\\""},{"question":"# Problem Statement: You are given a binary tree, where each node contains an integer value, and you need to find the sum of all left leaves in the tree. A leaf is a node with no children. A left leaf is a leaf node that is the left child of its parent. # Specifications: **Function Name:** `sum_of_left_leaves` **Input:** - A reference to the root of a binary tree (`TreeNode`). **Output:** - An integer representing the sum of all left leaf nodes in the given binary tree. # Definitions: Define the `TreeNode` class to represent nodes in the binary tree: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example: Consider the following binary tree: ``` 3 / 9 20 / 15 7 ``` The left leaves are 9 and 15. Thus, the sum is 24. ```python >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> sum_of_left_leaves(root) 24 ``` # Constraints: - The number of nodes in the tree is in the range [1, 1000]. - -1000 â‰¤ Node.val â‰¤ 1000 # Hints: - Consider implementing a helper function to determine if a node is a left leaf. - Use a depth-first search (DFS) or breadth-first search (BFS) approach to traverse the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): def is_leaf(node): return node and not node.left and not node.right def dfs(node, is_left): if not node: return 0 if is_leaf(node) and is_left: return node.val return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"# Coding Assessment Question: Detecting Cycles with Depth-First Search (DFS) **Scenario**: In your role as a developer, you are responsible for ensuring that no cyclic dependencies exist within a set of interconnected components that form a dependency graph. Detecting cycles in directed graphs is critical to prevent infinite loops and other dependency-related issues in the system. **Problem Statement**: Write a function `detect_cycle(graph: dict[str, list[str]]) -> bool` that determines if a cycle exists in the given directed graph. You should implement a depth-first search (DFS) based algorithm to detect cycles. **Input**: - `graph`: A dictionary representing the adjacency list of a directed graph. Each key is a node (string), and its value is a list of neighboring nodes (strings) that the key node has directed edges to. **Output**: - A boolean value (`True` or `False`). Return `True` if there is at least one cycle in the graph, otherwise return `False`. **Constraints**: - `1 <= len(graph) <= 100` - `1 <= len(graph[u]) <= 200` for each node `u` - Nodes are assumed to be unique and represented as strings. **Example**: Given the following graph: ```python graph = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"E\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"D\\"] } ``` The function call `detect_cycle(graph)` should return `True`, as there are cycles: `A -> B -> C -> A` and `D -> E -> F -> D`. Given the following graph: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } ``` The function call `detect_cycle(graph)` should return `False`, as there are no cycles in this graph. **Additional Notes**: - You must use Depth-First Search (DFS) for cycle detection. - Consider edge cases such as graphs with a single node and graphs with multiple disconnected components. - Ensure the function is robust and efficiently handles a directed graph with up to 100 nodes and their respective edges.","solution":"def detect_cycle(graph): def dfs(node): if visited[node] == -1: return True if visited[node] == 1: return False visited[node] = -1 for neighbor in graph[node]: if dfs(neighbor): return True visited[node] = 1 return False visited = {node: 0 for node in graph} for node in graph: if dfs(node): return True return False"},{"question":"Data Stream Median You are tasked with processing a stream of integers and continuously finding the median of the numbers seen so far. Implement a class `MedianFinder` that will input numbers one by one and return the median after each insertion efficiently. # Class `MedianFinder`: Your task is to implement the following methods: 1. **`__init__(self)`:** Initializes the data structure. 2. **`addNum(self, num: int) -> None`:** Adds a number to the data structure. 3. **`findMedian(self) -> float`:** Returns the median of all numbers added so far. The runtime complexity should be `O(log n)` for `addNum` and `O(1)` for `findMedian`. # Input - `num (int)`: An integer number to be added to the stream. # Output - Returns the median of all numbers added so far. If the number of elements is odd, return the middle element. If it\'s even, return the average of the two middle elements. # Constraints - The number of elements added is `1 <= number of elements <= 10^6`. - The numbers added are in the range of `-10^5 <= num <= 10^5`. # Example Usage ```python finder = MedianFinder() finder.addNum(1) print(finder.findMedian()) # Output: 1.0 finder.addNum(2) print(finder.findMedian()) # Output: 1.5 finder.addNum(3) print(finder.findMedian()) # Output: 2.0 ``` # Note To implement an efficient solution, you may use two heaps: - A max-heap for the left half of the stream. - A min-heap for the right half of the stream. Make sure to balance both heaps such that their sizes do not differ by more than one element at any time. ```python import heapq class MedianFinder: def __init__(self): self.min_heap = [] # min-heap for the right half self.max_heap = [] # max-heap for the left half (simulated as a min-heap with negative values) def addNum(self, num: int) -> None: if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] elif len(self.min_heap) > len(self.max_heap): return self.min_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0 ``` # Extension Points - Add comments explaining the logic and choice of data structures. - Develop additional unit tests to cover edge cases such as large inputs, negative numbers, and repeated elements.","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] # min-heap for the right half self.max_heap = [] # max-heap for the left half (simulated as a min-heap with negative values) def addNum(self, num: int) -> None: if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) elif len(self.min_heap) > len(self.max_heap): return float(self.min_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Mini Markdown Compiler You are asked to implement a simplified Markdown to HTML converter for a limited set of Markdown features. Given a string containing Markdown text, your task is to convert it to its HTML equivalent. The Markdown text will include the following features: 1. **Headers**: - `#` for H1, `` for H2, and `#` for H3. Each `#` character at the beginning of a line should be converted to the corresponding `<h1>`, `<h2>`, or `<h3>` HTML tag. The line should end with the closing tag (`</h1>`, `</h2>`, or `</h3>`). 2. **Bold Text**: - Text wrapped with `**` should be converted to `<strong>`. For example, `**bold**` should be converted to `<strong>bold</strong>`. 3. **Italic Text**: - Text wrapped with `*` should be converted to `<em>`. For example, `*italic*` should be converted to `<em>italic</em>`. Problem Statement Implement the function `markdown_to_html(markdown: str) -> str` that takes a Markdown string and returns its HTML representation. - **Input**: - `markdown`: a string containing the Markdown text. It will contain a mix of headers, bold, and italic text. - **Output**: A string which is the HTML representation of the input Markdown text. # Example ```python markdown = \'\'\' # Header1 Header2 # Header3 This is a **bold** text and this is an *italic* text. \'\'\' print(markdown_to_html(markdown)) ``` **Expected Output**: ```html <h1>Header1</h1> <h2>Header2</h2> <h3>Header3</h3> <p>This is a <strong>bold</strong> text and this is an <em>italic</em> text.</p> ``` # Additional Details 1. Line breaks should be preserved in the HTML output, with each Markdown line converted properly. 2. Ensure nested Markdown features are correctly handled. For example, a line with `**This is *bold and italic***` should be converted to `<strong>This is <em>bold and italic</em></strong>`. 3. You can assume that there will be no Markdown syntax errors (e.g., correctly paired `**` or `*`, proper headers, etc.). Use the following helper functions (if needed): 1. **`convert_headers(line: str) -> str`**: - This function takes a single line of Markdown text and converts it to the corresponding HTML header tag. - **Input**: `line` containing Markdown text (e.g., ` Header2`). - **Output**: A string with the HTML equivalent of the header. 2. **`convert_bold_italic(text: str) -> str`**: - This function takes a text string and converts all instances of `**` to `<strong>` tags and `*` to `<em>` tags. - **Input**: `text` containing Markdown text with bold and italic syntax. - **Output**: A string with the text converted to HTML.","solution":"import re def convert_headers(line: str) -> str: Converts Markdown headers to HTML headers. if line.startswith(\'# \'): return f\'<h3>{line[4:].strip()}</h3>\' elif line.startswith(\' \'): return f\'<h2>{line[3:].strip()}</h2>\' elif line.startswith(\'# \'): return f\'<h1>{line[2:].strip()}</h1>\' return line def convert_bold_italic(text: str) -> str: Converts Markdown bold and italic text to HTML. # Convert bold first to avoid nested bold within italic or vice versa text = re.sub(r\'**(.*?)**\', r\'<strong>1</strong>\', text) # Convert italic text = re.sub(r\'*(.*?)*\', r\'<em>1</em>\', text) return text def markdown_to_html(markdown: str) -> str: Converts a Markdown string to its HTML equivalent. html_lines = [] lines = markdown.splitlines() for line in lines: if line.startswith(\'#\'): html_line = convert_headers(line) html_lines.append(html_line) else: html_line = convert_bold_italic(line) if html_line: html_lines.append(f\'<p>{html_line}</p>\') return \'n\'.join(html_lines)"},{"question":"# Flatten Nested Dictionary In this challenge, you are required to flatten a nested dictionary. A flat dictionary is one that does not contain other dictionaries or lists as its values. Each value in a flat dictionary should be a direct or recursive concatenation of all nested keys at that level, separated by dots (\'.\'). # Problem Statement Implement a function `flatten_dict(nested_dict: dict) -> dict` that takes in a nested dictionary and returns a flattened dictionary where: 1. Each key in the flattened dictionary is a dot-separated path representing the hierarchy of keys in the nested dictionary. 2. The keys are concatenated in the order they appear in the nested structure. 3. Leaf values (i.e., values that are not dictionaries) should remain unchanged. # Constraints - Keys are always strings. - Leaf values can be of any primitive data type (integers, strings, booleans, etc.). - Dictionaries can be nested to any level. - Maximum number of unique paths (keys) in the output will not exceed 1000. # Example ```python def flatten_dict(nested_dict: dict) -> dict: pass # Example run print(flatten_dict({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } }, \\"f\\": { \\"g\\": 4 } })) # Output: { # \\"a\\": 1, # \\"b.c\\": 2, # \\"b.d.e\\": 3, # \\"f.g\\": 4 # } ``` # Edge Cases to Consider 1. **Empty Dictionary**: Should return an empty dictionary. 2. **Deeply Nested Dictionary**: Ensure your implementation handles deep nesting efficiently. 3. **Mixed Types**: Ensure handling of dictionaries with mixed value types correctly. 4. **Single Level Dictionaries**: Function should correctly handle dictionaries that are already flat. # Guidelines - Employ a recursive approach to handle the nested nature of the dictionary. - Use helper functions if necessary to keep code modular and readable. - Ensure that dot notations build up correctly to reflect the path from the root to each leaf. Hint: You may find it useful to implement a helper function that keeps track of the current path as it traverses the nested dictionary.","solution":"def flatten_dict(nested_dict, parent_key=\'\', sep=\'.\'): Flatten a nested dictionary. Parameters: - nested_dict (dict): The nested dictionary to flatten. - parent_key (str): The base key used for recursive concatenation. - sep (str): The separator used between keys. Returns: - dict: A flattened dictionary. items = [] for k, v in nested_dict.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Coding Assessment Question Problem Statement: You are given the task of sorting an array of distinct integers such that the largest number comes first, the smallest number comes second, the second largest comes third, the second smallest comes fourth, and so on. Write a function `weave_sort(arr: List[int]) -> List[int]` that takes a list of distinct integers `arr` and returns a new list sorted in the \\"weave sort\\" order described above. Input: - `arr` (2 <= len(arr) <= 10^5): A list of distinct integers. Output: - A list of integers sorted in the specified \\"weave sort\\" order. Example: ```python assert weave_sort([4, 1, 3, 2]) == [4, 1, 3, 2] assert weave_sort([9, 1, 10, 5, 3]) == [10, 1, 9, 3, 5] assert weave_sort([15, 3, 7, 10, 5]) == [15, 3, 10, 5, 7] ``` Constraints: - The input list will contain distinct integers. - Your solution should aim for an efficient time complexity given the constraints. - The solution should handle edge cases gracefully, such as when the array length is minimal (2 integers). Performance: - Aim for an optimal solution that minimizes unnecessary computations and effectively balances the sorting operation and subsequent rearrangement. This question, like the previous one, requires an efficient algorithm to handle a large input size and demands careful consideration of the sorting and selection process to ensure the result meets the specified order.","solution":"from typing import List def weave_sort(arr: List[int]) -> List[int]: arr.sort() result = [] left, right = 0, len(arr) - 1 while left <= right: if right > left: result.append(arr[right]) result.append(arr[left]) else: result.append(arr[left]) # Only add one element if there\'s exactly one left left += 1 right -= 1 return result"},{"question":"# Binary Search Tree (BST) Construction and Range Sum Query You are given a list of integers representing node values. Your task is to construct a Binary Search Tree (BST) from this list and implement a function to find the sum of all node values within a given range [low, high]. Function Signature ```python def bst_range_sum(values: list[int], low: int, high: int) -> int: pass ``` Input - **values**: A list of integers representing the values to be inserted into the BST. The list will contain unique values with no duplicates. - **low**: An integer specifying the lower bound of the range. - **high**: An integer specifying the upper bound of the range. Output - **An integer**: The sum of all node values in the BST that fall within the range [low, high] inclusive. Constraints - The list `values` will have at least one and at most 1000 elements. - The values in the list are distinct integers. - -10^4 <= value <= 10^4 for any value in `values`. - -10^4 <= low <= high <= 10^4. Example ```python values = [10, 5, 15, 3, 7, 18] low = 7 high = 15 result = bst_range_sum(values, low, high) # Expected output: 32 (sum of values 7, 10, and 15) values = [10, 5, 15, 3, 7, 18] low = 6 high = 10 result = bst_range_sum(values, low, high) # Expected output: 17 (sum of values 7 and 10) ``` # Additional Notes * To solve this problem, first construct the BST by inserting the values in the given order. * Use an in-order traversal to check node values and compute the range sum efficiently. * Ensure your solution handles the construction and query efficiently within the given constraints.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def build_bst(values): root = None for value in values: root = insert_into_bst(root, value) return root def range_sum_bst(root, low, high): if root is None: return 0 if root.value < low: return range_sum_bst(root.right, low, high) if root.value > high: return range_sum_bst(root.left, low, high) return root.value + range_sum_bst(root.left, low, high) + range_sum_bst(root.right, low, high) def bst_range_sum(values, low, high): root = build_bst(values) return range_sum_bst(root, low, high)"},{"question":"# Question: Find the Largest Connected Component in an Undirected Graph You are tasked with finding the size of the largest connected component in an undirected graph. Implement a function `largest_connected_component(graph: dict) -> int` that takes a graph represented as a dictionary and returns the size of the largest connected component in the graph. # Function Signature ```python def largest_connected_component(graph: dict) -> int: ... ``` # Input - `graph`: A dictionary where the keys are nodes (integers) and the values are lists of nodes (integers) to which the key node is directly connected. # Output - Returns an integer representing the size of the largest connected component in the graph. # Constraints - Each node is represented by a unique integer. - The graph can be disconnected or connected. - The graph can have self-loops. - The number of nodes and edges in the graph can be at most (10^4) and (10^5) respectively. # Scenario Imagine you are a network analyst trying to understand the structure of a social network. One of the key insights you want to obtain is the size of the largest group of people who are all directly or indirectly connected to each other (a connected component). Your task is to implement a function to find this largest group. # Example ```python graph = { 0: [1, 2], 1: [0], 2: [0, 3], 3: [2, 4], 4: [3] } assert largest_connected_component(graph) == 5 graph = { 0: [1], 1: [0], 2: [3], 3: [2] } assert largest_connected_component(graph) == 2 graph = { 0: [1], 1: [] } assert largest_connected_component(graph) == 2 ``` # Performance Requirements - The function should run in (O(V + E)) time complexity. - The implementation should handle graphs with up to (10^4) nodes and (10^5) edges efficiently.","solution":"def largest_connected_component(graph: dict) -> int: def dfs(node, visited): stack = [node] size = 0 while stack: current = stack.pop() if current not in visited: visited.add(current) size += 1 stack.extend(graph.get(current, [])) return size visited = set() max_size = 0 for node in graph: if node not in visited: component_size = dfs(node, visited) max_size = max(max_size, component_size) return max_size"},{"question":"Problem Overview You are given two arrays representing the in-order and pre-order traversals of a binary tree. Your task is to reconstruct the binary tree from these traversal arrays and return its root. Constructing the tree from these traversal orders requires a solid understanding of how binary trees are structured given these traversal methods. Detailed Description # Function Specification You need to implement the following function: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder: list[int], inorder: list[int]) -> TreeNode: Reconstructs a binary tree from its preorder and inorder traversal arrays. Parameters: preorder (list[int]): A list of integers representing the preorder traversal. inorder (list[int]): A list of integers representing the inorder traversal. Returns: TreeNode: The root of the reconstructed binary tree. pass ``` # Input - Two lists of integers, `preorder` and `inorder`, which represent the preorder and inorder traversals of a binary tree respectively. Both lists have length `n`, where 0 â‰¤ `n` â‰¤ 10^4. The integers are unique and within the range -10^5 to 10^5. # Output - The root node of the binary tree reconstructed from the given traversals. # Constraints - The solution must reconstruct the exact tree represented by the provided traversals. - The function should handle edge cases such as empty traversal arrays efficiently. - Assume all tree nodes have unique values. # Example: ```python >>> class TreeNode: >>> def __init__(self, val=0, left=None, right=None): >>> self.val = val >>> self.left = left >>> self.right = right >>> def print_tree(root): >>> if not root: >>> return >>> print(root.val) >>> print_tree(root.left) >>> print_tree(root.right) >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> root = build_tree(preorder, inorder) >>> print_tree(root) 3 9 20 15 7 >>> preorder = [] >>> inorder = [] >>> root = build_tree(preorder, inorder) >>> print_tree(root) None >>> preorder = [1] >>> inorder = [1] >>> root = build_tree(preorder, inorder) >>> print_tree(root) 1 ``` # Implementation Notes - Utilize the fact that the first element in preorder list is the root of the tree or subtree. - Identify the root\'s position in the inorder list to determine the left and right subtrees. - Recursively reconstruct the subtrees and attach them to the root node. - The provided helper function `print_tree` is for demonstration purposes and not part of the solution requirements. - Ensure the solution is efficient and manages the traversal lists correctly especially for larger inputs.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder: list[int], inorder: list[int]) -> TreeNode: if not preorder or not inorder: return None # The first element in preorder is the root root_val = preorder[0] root = TreeNode(root_val) # Find the index of the root in inorder to divide left and right subtrees root_index_inorder = inorder.index(root_val) # Recursively build the left and right subtree left_inorder = inorder[:root_index_inorder] right_inorder = inorder[root_index_inorder+1:] left_preorder = preorder[1:1+len(left_inorder)] right_preorder = preorder[1+len(left_inorder):] root.left = build_tree(left_preorder, left_inorder) root.right = build_tree(right_preorder, right_inorder) return root"},{"question":"# Generate Next Permutation of a List You are tasked with writing a function that generates the next permutation of a given list of integers in lexicographical order. If no next permutation exists (i.e., the sequence is the highest possible permutation), the function should return the list in sorted order (also known as the first permutation in lexicographical order). # Function Signature ```python def next_permutation(nums: List[int]) -> List[int]: ``` # Parameters * `nums` (List[int]): A list of integers to compute the next permutation for. # Expected Output * (List[int]): The next permutation of the given list of integers. If the input is the highest permutation, the function returns the sorted list. # Constraints * The list `nums` has a length between 1 and 1000. * Each integer in `nums` is within the range -1000 to 1000. # Performance Requirements * The function should efficiently compute the next permutation in O(n) time complexity, where `n` is the length of the list. # Example ```python assert next_permutation([1, 2, 3]) == [1, 3, 2] assert next_permutation([3, 2, 1]) == [1, 2, 3] assert next_permutation([1, 1, 5]) == [1, 5, 1] assert next_permutation([2, 3, 1]) == [3, 1, 2] assert next_permutation([5, 3, 4, 9, 7, 6]) == [5, 3, 6, 4, 7, 9] ``` # Notes 1. The function should efficiently handle the given constraints and return the correct next permutation or the sorted list as required. 2. Consider edge cases such as lists with all identical elements and the smallest and largest possible lists. 3. Write a few additional test cases to demonstrate your function\'s correctness and performance. --- By matching the complexity, length, and tone of the existing set, the above question fits seamlessly into the overall collection of coding assessment questions. It tests the candidate\'s understanding of permutations and efficiency in handling moderately large inputs, similar to the technical rigor in the provided questions.","solution":"from typing import List def next_permutation(nums: List[int]) -> List[int]: # Find the first index \'i\' from the end such that nums[i] < nums[i + 1] i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # If such an index is found, find the next number which is larger than nums[i] from end if i >= 0: j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap numbers at index i and j nums[i], nums[j] = nums[j], nums[i] # Reverse the numbers from index i + 1 to the end of the list nums[i + 1:] = nums[i + 1:][::-1] return nums"},{"question":"# Coding Assessment Question: Matrix Diagonal Difference You are tasked with implementing two essential functions related to matrix operations: calculating the primary diagonal and secondary diagonal difference, and computing the trace of a matrix. - **Function 1: `diagonal_difference(matrix: list) -> int`** - **Description**: Calculate the absolute difference between the sums of the matrix\'s primary and secondary diagonals. - **Input**: A list of lists representing a square matrix of integers. - **Output**: An integer representing the absolute difference. - **Constraints**: - The input matrix must be square (same number of rows and columns). - The matrix will contain integers. - **Edge Cases**: - Raise a `ValueError` for invalid inputs, including non-square matrices or non-list inputs. - Handle single-element matrices by returning 0. - **Function 2: `matrix_trace(matrix: list) -> int`** - **Description**: Calculate the trace of the matrix (sum of primary diagonal elements). - **Input**: A list of lists representing a square matrix of integers. - **Output**: An integer representing the sum of the primary diagonal. - **Constraints**: - The input matrix must be square. - **Edge Cases**: - Raise a `ValueError` for invalid inputs, including non-square matrices or non-list inputs. Example: ```python # Example Function Call: print(diagonal_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: 0 print(matrix_trace([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: 15 # Example Invalid Call: print(diagonal_difference([[1, 2], [3, 4, 5]])) # Output: Raises ValueError # Single element example: print(matrix_trace([[5]])) # Output: 5 ``` Performance Requirement: - Both functions should operate in linear time concerning the number of elements in the matrix, O(n), where n is the number of elements in the matrix (or O(m^2) where m is the matrix dimension). **Notes**: - You can assume the matrix will have fewer than 10^6 elements. - Use proper exception handling to deal with invalid input scenarios. Implement the functions according to the given specifications.","solution":"def diagonal_difference(matrix): Calculate the absolute difference between the sums of the matrix\'s primary and secondary diagonals. # Validate that input is a list of lists and matrix is square if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be square\\") primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - i - 1] return abs(primary_diagonal_sum - secondary_diagonal_sum) def matrix_trace(matrix): Calculate the trace of the matrix (sum of primary diagonal elements). # Validate that input is a list of lists and matrix is square if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be square\\") primary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] return primary_diagonal_sum"},{"question":"# Question Context In many software applications, sorting data is a fundamental operation. However, sometimes sorting with a specific rule or criterion is required. One unique sorting criterion is to sort the strings by their length first, and then alphabetically within the same length. This kind of sorting can be useful when displaying data with hierarchical order or organizing content by its size followed by its natural alphabetical order. Task Write a function `custom_sort` that sorts a list of strings based on their length first and then by their lexicographical order within the same length. Function Signature ```python def custom_sort(strings: List[str]) -> List[str]: ``` Input * `strings` â€“ A list of strings. Output * A list of strings sorted first by length and then alphabetically within each length. Constraints * The number of strings in the list can range from `1` to `10^5`. * Each string can have a length from `1` to `10^3`. * All strings consist of lower-case English letters. Examples ```python assert custom_sort([\\"apple\\", \\"bat\\", \\"car\\", \\"batman\\", \\"ant\\", \\"adventure\\"]) == [\\"ant\\", \\"bat\\", \\"car\\", \\"apple\\", \\"batman\\", \\"adventure\\"] assert custom_sort([\\"zebra\\", \\"dog\\", \\"cat\\", \\"elephant\\", \\"mouse\\", \\"mice\\"]) == [\\"cat\\", \\"dog\\", \\"mice\\", \\"mouse\\", \\"zebra\\", \\"elephant\\"] assert custom_sort([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\"]) == [\\"one\\", \\"six\\", \\"two\\", \\"five\\", \\"four\\", \\"seven\\", \\"three\\"] assert custom_sort([\\"orange\\", \\"strawberry\\", \\"apple\\", \\"kiwi\\", \\"grape\\", \\"fig\\"]) == [\\"fig\\", \\"kiwi\\", \\"apple\\", \\"grape\\", \\"orange\\", \\"strawberry\\"] assert custom_sort([\\"b\\", \\"a\\", \\"c\\", \\"d\\"]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] ``` Explanation * First, the strings are sorted by length. * If there are multiple strings with the same length, they are sorted alphabetically. * For example, the list `[\\"apple\\", \\"bat\\", \\"car\\", \\"batman\\", \\"ant\\", \\"adventure\\"]` becomes `[\\"ant\\", \\"bat\\", \\"car\\", \\"apple\\", \\"batman\\", \\"adventure\\"]` after sorting, as each group of strings of the same length is in alphabetical order. Use the appropriate sorting mechanism to achieve this effectively based on the provided constraints.","solution":"from typing import List def custom_sort(strings: List[str]) -> List[str]: return sorted(strings, key=lambda x: (len(x), x))"},{"question":"# Question: Implement a Custom Hash Map You need to implement a custom hash map (a type of associative array or dictionary) from scratch. The hash map should support basic operations such as inserting a key-value pair, retrieving a value by key, and deleting a key-value pair. Objective Build a hash map with an initial fixed-size array for storing hash table entries. Implement collision resolution using chaining (i.e., using linked lists). Expected Input and Output * **Input**: - A series of operations to perform on the hash map. Each operation is in the form of a tuple, where the first element is the operation name (`\'insert\'`, `\'get\'`, or `\'delete\'`), followed by relevant parameters for the operation. ```python [(\'insert\', key, value), (\'get\', key), (\'delete\', key), ...] ``` * **Output**: - For `\'insert\'` and `\'delete\'` operations: No output is expected. - For `\'get\'` operations: Return the value associated with the key, or `None` if the key is not found. ```python [value, None, value, ...] ``` Constraints * Keys are integers in the range [0, 10^6]. * Values are strings with a maximum length of 100 characters. * There will be at most 10,000 operations. Performance Requirements * Average time complexity for each operation: O(1) * Handle up to 10,000 operations efficiently. Scenario Imagine you are developing the backend of a new web application that requires an efficient key-value store for session handling. Due to performance demands, you decide to implement a custom hash map. # Your Task: Write a Python class `CustomHashMap` that provides the required functionality. ```python class CustomHashMap: def __init__(self): Initialize your data structure here. # Implement initialization logic def insert(self, key, value): :param key: The key for the entry. :param value: The value associated with the key. :return: None. # Implement insertion logic def get(self, key): :param key: The key to find the corresponding value. :return: The value associated with the key, or None if the key does not exist. # Implement retrieval logic def delete(self, key): :param key: The key for the entry to be removed. :return: None. # Implement deletion logic ``` **Example**: ```python # Create a new instance of CustomHashMap hash_map = CustomHashMap() # Perform operations hash_map.insert(1, \\"x\\") hash_map.insert(2, \\"y\\") print(hash_map.get(1)) # Output: \\"x\\" hash_map.delete(2) print(hash_map.get(2)) # Output: None ``` **Note**: Do not use Python\'s built-in dictionary or any third-party libraries. Concentrate on implementing the core hash map functionality using arrays and linked lists.","solution":"class ListNode: def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class CustomHashMap: def __init__(self, size=1000): self.size = size self.table = [None] * self.size def _hash(self, key): return key % self.size def insert(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = ListNode(key, value) else: current = self.table[index] while current: if current.key == key: current.value = value return if current.next is None: current.next = ListNode(key, value) return current = current.next def get(self, key): index = self._hash(key) current = self.table[index] while current: if current.key == key: return current.value current = current.next return None def delete(self, key): index = self._hash(key) current = self.table[index] if not current: return if current.key == key: self.table[index] = current.next return prev = current while current: if current.key == key: prev.next = current.next return prev = current current = current.next"},{"question":"Depth-First Search (DFS) Implementation Challenge Scenario You are required to design and implement a graph class that allows you to perform depth-first search (DFS) traversal. The graph should support generic vertices and handle any typical DFS operations, such as visiting nodes and tracking visited states. Task Implement a class named `Graph` with the following requirements: Class: `Graph` 1. **Attributes**: * `adj_list` (dict): Dictionary representing the adjacency list of the graph. 2. **Methods**: * `__init__(self)`: Constructor to initialize an empty adjacency list. * `add_edge(self, u, v)`: Adds a directed edge from vertex `u` to vertex `v`. * `dfs(self, start)`: Performs DFS traversal starting from the given vertex `start` and returns a list of visited vertices in the order they were visited. * `dfs_recursive(self, start, visited=None)`: A helper method to perform DFS using recursion. Constraints and Limitations * Assume that the graph can have cycles and disconnected components. * Your solution must handle graphs with various sizes and structures. Input and Output Formats * Use the following methods for interaction with the graph: ```python class Graph: def __init__(self): # Initialize an empty adjacency list def add_edge(self, u, v): # Add a directed edge from vertex u to vertex v def dfs(self, start): # Perform DFS traversal from the start vertex and return visited vertices def dfs_recursive(self, start, visited=None): # Helper method to perform DFS using recursion # Used internally by the dfs method ``` Example ```python # Create a graph instance g = Graph() # Add edges to the graph g.add_edge(1, 2) g.add_edge(1, 3) g.add_edge(2, 4) g.add_edge(2, 5) g.add_edge(3, 6) g.add_edge(3, 7) # Perform DFS traversal vertices_visited = g.dfs(1) print(vertices_visited) # Output: [1, 2, 4, 5, 3, 6, 7] ``` Ensure your implementation correctly handles typical graph structures and accurately performs a depth-first search traversal from any starting node.","solution":"class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u, v): if u not in self.adj_list: self.adj_list[u] = [] self.adj_list[u].append(v) def dfs(self, start): visited = set() result = [] self.dfs_recursive(start, visited, result) return result def dfs_recursive(self, start, visited, result): if start not in visited: visited.add(start) result.append(start) if start in self.adj_list: for neighbor in self.adj_list[start]: self.dfs_recursive(neighbor, visited, result)"},{"question":"# File Content Sorter Scenario You are working on a data processing application that handles various text files with rows of data. Each row in the file represents an entry that needs to be sorted based on a specified column. The format of the data in the file is comma-separated values (CSV) where each row has the same number of columns. Task Write a function `sort_file_content(file_content: str, column_index: int) -> str` that takes two inputs: 1. A multi-line string `file_content` representing the content of the CSV file. 2. An integer `column_index` representing the zero-based index of the column to sort by. The function should return a new multi-line string with the rows sorted in ascending order based on the values in the specified column. Constraints 1. Each line in `file_content` will have the same number of columns. 2. Non-numeric columns should be sorted lexicographically. 3. Numeric columns should be sorted by their numeric values. 4. Consider the first line of the CSV as a header and it should remain at the top after sorting. 5. The input CSV will not be empty and will always have at least one row of data not including the header. Function Signature ```python def sort_file_content(file_content: str, column_index: int) -> str: pass ``` Example Test Cases ```python file_content = Name, Age, Country Alice, 30, USA Bob, 25, Canada Charlie, 35, UK David, 40, USA # Sorting by the \'Age\' column (column index 1) sorted_content = Name, Age, Country Bob, 25, Canada Alice, 30, USA Charlie, 35, UK David, 40, USA assert sort_file_content(file_content, 1) == sorted_content # Sorting by the \'Name\' column (column index 0) sorted_content = Name, Age, Country Alice, 30, USA Bob, 25, Canada Charlie, 35, UK David, 40, USA assert sort_file_content(file_content, 0) == sorted_content # Sorting by the \'Country\' column (column index 2) sorted_content = Name, Age, Country Bob, 25, Canada Charlie, 35, UK Alice, 30, USA David, 40, USA assert sort_file_content(file_content, 2) == sorted_content ``` Implement the function `sort_file_content` to adhere to the provided requirements and ensure it passes the given test cases.","solution":"def sort_file_content(file_content: str, column_index: int) -> str: lines = file_content.strip().split(\\"n\\") header = lines[0] rows = lines[1:] def convert(value): try: return int(value) except ValueError: return value rows.sort(key=lambda row: convert(row.split(\\",\\")[column_index].strip())) return \\"n\\".join([header] + rows)"},{"question":"# Coding Challenge: Consecutive Character Count Background: Analyzing and compressing strings can often result in optimized storage and faster processing times. One common approach is to count consecutive identical characters and store these counts instead of the original characters. Objective: Write a function that counts the maximum number of consecutive identical characters in a given string and returns this count. Task: Implement the function `max_consecutive_count(s: str) -> int` that: - Takes a single string `s` as an argument. - Returns an integer representing the maximum number of consecutive identical characters in the string. Input: - A string `s` consisting of lowercase and uppercase English letters, digits, and special characters (limited to space and punctuation). Output: - Returns an integer, which is the count of the largest group of consecutive identical characters. Constraints: - If the string `s` is empty, the function should return 0. - The function should handle strings of length up to (10^6) efficiently. Examples: ```python >>> max_consecutive_count(\\"aabbccdd\\") 2 >>> max_consecutive_count(\\"aaaabbccddddeeee\\") 4 >>> max_consecutive_count(\\"abcd\\") 1 >>> max_consecutive_count(\\"\\") 0 >>> max_consecutive_count(\\"aaAAAbbBBccCC\\") 3 ``` Requirements: 1. The function should be efficient to handle large strings up to the given constraint. 2. Thoroughly handle and test edge cases (e.g., empty string, single character string). 3. Ensure that the solution works with mixed types of characters (letters, digits, and punctuation).","solution":"def max_consecutive_count(s: str) -> int: Returns the maximum number of consecutive identical characters in the string s. :param s: Input string :return: Maximum consecutive identical character count if not s: return 0 max_count = 1 current_count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count"},{"question":"# Huffman Coding Tree Implementation Objective Implement the Huffman Coding algorithm by completing the provided functions. This task assesses your understanding of data compression techniques and tree-based algorithms. Scenario In a data compression application, you are required to compress a string using Huffman coding. Specifically, implement the key functions used in building the Huffman coding tree and encoding/decoding the string. Instructions 1. Implement the following functions in the provided `huffman()` method: * `build_frequency_dict(message)` * Input: * `message` (str): The input string to be compressed. * Output: * `freq_dict` (dict): A dictionary with characters as keys and their frequencies as values. * `build_min_heap(freq_dict)` * Input: * `freq_dict` (dict): Dictionary with characters as keys and frequencies as values. * Output: * `min_heap` (list): A list representing a priority queue (min-heap) of frequencies. * `build_huffman_tree(min_heap)` * Input: * `min_heap` (list): A list representing a priority queue (min-heap) of frequencies. * Output: * `root` (Node): The root node of the constructed Huffman tree. * `build_codes(root)` * Input: * `root` (Node): The root node of the Huffman tree. * Output: * `huffman_codes` (dict): A dictionary with characters as keys and their corresponding Huffman codes as values. * `encode_message(message, huffman_codes)` * Input: * `message` (str): The input string to be compressed. * `huffman_codes` (dict): Dictionary with characters as keys and their corresponding Huffman codes as values. * Output: * `encoded_message` (str): The encoded string produced from the input message. * `decode_message(encoded_message, root)` * Input: * `encoded_message` (str): The encoded string to be decompressed. * `root` (Node): The root node of the Huffman tree. * Output: * `decoded_message` (str): The original string after decoding the encoded message. Constraints * Assume the input message string contains only lowercase alphabetical characters. * The root node of the Huffman tree will always have more than one character. * The frequency dictionary and Huffman codes will be consistent and accurate based on the given message. * Use a min-heap for building the Huffman tree. Example ```python message = \\"huffman coding trees are interesting\\" freq_dict = build_frequency_dict(message) print(freq_dict) min_heap = build_min_heap(freq_dict) print(min_heap) root = build_huffman_tree(min_heap) print(root) huffman_codes = build_codes(root) print(huffman_codes) encoded_message = encode_message(message, huffman_codes) print(encoded_message) decoded_message = decode_message(encoded_message, root) print(decoded_message) ``` This task assesses your ability to understand tree structures, priority queues, and data compression techniques, as well as your programming skills in implementing these concepts.","solution":"import heapq from collections import defaultdict, namedtuple class Node(namedtuple(\\"Node\\", [\\"char\\", \\"freq\\", \\"left\\", \\"right\\"])): def __lt__(self, other): return self.freq < other.freq def build_frequency_dict(message): freq_dict = defaultdict(int) for char in message: freq_dict[char] += 1 return freq_dict def build_min_heap(freq_dict): min_heap = [Node(char, freq, None, None) for char, freq in freq_dict.items()] heapq.heapify(min_heap) return min_heap def build_huffman_tree(min_heap): while len(min_heap) > 1: left = heapq.heappop(min_heap) right = heapq.heappop(min_heap) merged = Node(None, left.freq + right.freq, left, right) heapq.heappush(min_heap, merged) return heapq.heappop(min_heap) def build_codes(root): huffman_codes = {} def _build_codes_helper(node, current_code): if node.char is not None: huffman_codes[node.char] = current_code return _build_codes_helper(node.left, current_code + \\"0\\") _build_codes_helper(node.right, current_code + \\"1\\") _build_codes_helper(root, \\"\\") return huffman_codes def encode_message(message, huffman_codes): return \'\'.join(huffman_codes[char] for char in message) def decode_message(encoded_message, root): decoded_message = [] current_node = root for bit in encoded_message: current_node = current_node.left if bit == \'0\' else current_node.right if current_node.char: decoded_message.append(current_node.char) current_node = root return \'\'.join(decoded_message) def huffman(message): freq_dict = build_frequency_dict(message) min_heap = build_min_heap(freq_dict) root = build_huffman_tree(min_heap) huffman_codes = build_codes(root) encoded_message = encode_message(message, huffman_codes) decoded_message = decode_message(encoded_message, root) return freq_dict, min_heap, root, huffman_codes, encoded_message, decoded_message"},{"question":"# Coding Assessment Question You are developing a text processing tool to summarize documents. Implement a `DocumentSummarizer` class that generates a summary by extracting sentences based on the frequency of key terms. **Requirements**: 1. Implement the `DocumentSummarizer` class constructor to initialize with the input document text. 2. Implement the `_term_frequency` method to compute the frequency of each word in the document. 3. Implement the `summarize` method: - Tokenize the document into sentences. - Score each sentence based on the sum of term frequencies of the words in the sentence. - Return the top `n` scoring sentences as the summary, maintaining their order of appearance in the original text. **Function Signatures**: ```python class DocumentSummarizer: def __init__(self, document: str) -> None: Init method to store the document. @staticmethod def _term_frequency(document: str) -> dict[str, int]: Compute the frequency of each word in the document. def summarize(self, top_n: int = 3) -> str: Generate a summary by extracting top_n sentences based on term frequency. ``` **Input**: * **document**: A string representing the full text of the document. * **top_n**: An integer representing the number of sentences to be included in the summary. **Output**: * **summarize**: A string representing the summarized text with the top `n` sentences. **Example**: ```python document = Machine learning is a field of artificial intelligence. It uses statistical techniques to give computer systems the ability to \'learn\' from data, without being explicitly programmed. The name \'machine learning\' was coined in 1959 by Arthur Samuel. Machine learning algorithms build a model based on sample data, known as \'training data\'. The study of machine learning has been closely linked to statistical inference and mathematical optimization. summarizer = DocumentSummarizer(document) print(summarizer.summarize(top_n=2)) # Output: # \\"Machine learning is a field of artificial intelligence. # Machine learning algorithms build a model based on sample data, known as \'training data\'.\\" ``` **Constraints**: * The input document will have at most (10^4) words. * Each sentence in the document will have at most (500) characters. * `top_n` is a positive integer within (1) to the number of sentences in the document. * Handle edge cases where the document is empty or contains less than `top_n` sentences.","solution":"import re from collections import Counter from typing import List class DocumentSummarizer: def __init__(self, document: str) -> None: Init method to store the document. self.document = document @staticmethod def _term_frequency(document: str) -> dict: Compute the frequency of each word in the document. words = re.findall(r\'bw+b\', document.lower()) freq = Counter(words) return freq def _score_sentences(self, sentences: List[str], term_freq: dict) -> List[tuple]: Score each sentence based on the sum of term frequencies of the words in the sentence. sentence_scores = [] for sentence in sentences: words = re.findall(r\'bw+b\', sentence.lower()) score = sum(term_freq[word] for word in words) sentence_scores.append((sentence, score)) return sentence_scores def summarize(self, top_n: int = 3) -> str: Generate a summary by extracting top_n sentences based on term frequency. if not self.document or top_n <= 0: return \\"\\" sentences = re.split(r\'(?<!w.w.)(?<![A-Z][a-z].)(?<=.|?)s\', self.document) term_freq = self._term_frequency(self.document) scored_sentences = self._score_sentences(sentences, term_freq) scored_sentences.sort(key=lambda x: x[1], reverse=True) top_sentences = sorted(scored_sentences[:top_n], key=lambda x: self.document.find(x[0])) summary = \\" \\".join(sentence for sentence, score in top_sentences) return summary"},{"question":"**[Question 2]: Recursive Sum of Digits** In this problem, you need to repeatedly sum the digits of an integer until you get a single-digit number. This process is sometimes referred to as finding the digital root of a number. For instance, the digital root of 9875 is calculated as follows: 9 + 8 + 7 + 5 = 29; 2 + 9 = 11; 1 + 1 = 2. So, the digital root of 9875 is 2. # Function Signature ```python def digital_root(n: int) -> int: ``` # Input * `n` (int): The input number (0 â‰¤ n â‰¤ 10^12). # Output * `int`: The single-digit result after summing the digits repeatedly. # Constraints * `n` is a non-negative integer. * If `n` is 0, the result should be 0. # Examples ```python digital_root(9875) # Expected output: 2 digital_root(12345) # Expected output: 6 digital_root(9) # Expected output: 9 digital_root(0) # Expected output: 0 digital_root(999999999) # Expected output: 9 ``` # Notes 1. Consider using properties of modular arithmetic for an optimized solution. 2. Make sure the function works efficiently even for the upper limits of the constraints. 3. Validate input to ensure it is a non-negative integer within the given range. # Test Case Note Your implementation should correctly compute the digital root for the provided examples and handle any possible edge cases, ensuring performance does not degrade with large input values.","solution":"def digital_root(n: int) -> int: Function to find the digital root of a number. Args: n (int): The input number (0 â‰¤ n â‰¤ 10^12). Returns: int: The single-digit result after summing the digits repeatedly. if n == 0: return 0 if n % 9 == 0: return 9 return n % 9"},{"question":"# Question: Implement an Image Augmentation Pipeline You are working on building an image classification deep learning model and wish to utilize image augmentation techniques to improve the model\'s performance and generalization. Implement a few basic augmentation techniques and integrate them into a function that applies these augmentations to a batch of images. Task Create the function `image_augmentation_pipeline(images, augmentations)` in Python. This function should receive a batch of images and a list of augmentations to apply to each image in the batch. The function will return the augmented images. Augmentation Details - **Flip horizontally (flip_horizontal)**: Flips the image along the vertical axis. - **Rotate (rotate)**: Rotates the image by a given angle (in degrees). For simplicity, assume the angle is provided as a parameter within the augmentation list (e.g., `{\\"type\\": \\"rotate\\", \\"angle\\": 90}`). - **Brightness Adjustment (adjust_brightness)**: Adjusts the brightness of the image. The factor to adjust brightness is given as a parameter within the augmentation list (e.g., `{\\"type\\": \\"adjust_brightness\\", \\"factor\\": 1.5}`). Function Details - **Input**: - `images` (np.ndarray): Batch of images of shape `(batch_size, height, width, channels)`. - `augmentations` (list of dict): List of augmentations to apply. Each dict contains the type of augmentation and associated parameters. - **Output**: - `(np.ndarray)`: Batch of augmented images with the same shape as the input. Constraints - Only apply valid augmentation types as specified. - Ensure the function handles multiple augmentations for a single batch. - Maintain the original image shape after applying augmentations. Example ```python import numpy as np from PIL import Image, ImageEnhance def image_augmentation_pipeline(images, augmentations): augmented_images = [] for img in images: img_pil = Image.fromarray(img) for aug in augmentations: if aug[\\"type\\"] == \\"flip_horizontal\\": img_pil = img_pil.transpose(Image.FLIP_LEFT_RIGHT) elif aug[\\"type\\"] == \\"rotate\\": img_pil = img_pil.rotate(aug[\\"angle\\"]) elif aug[\\"type\\"] == \\"adjust_brightness\\": enhancer = ImageEnhance.Brightness(img_pil) img_pil = enhancer.enhance(aug[\\"factor\\"]) augmented_images.append(np.array(img_pil)) return np.array(augmented_images) # Example usage images = np.random.randint(0, 256, (2, 64, 64, 3), dtype=np.uint8) augmentations = [{\\"type\\": \\"flip_horizontal\\"}, {\\"type\\": \\"rotate\\", \\"angle\\": 45}, {\\"type\\": \\"adjust_brightness\\", \\"factor\\": 1.2}] augmented_images = image_augmentation_pipeline(images, augmentations) print(augmented_images.shape) # Output: (2, 64, 64, 3) ``` In this example, the `image_augmentation_pipeline` integrates flipping, rotation, and brightness adjustments seamlessly, ensuring that the augmented images are correctly outputted with the same dimensions as the original batch.","solution":"import numpy as np from PIL import Image, ImageEnhance def image_augmentation_pipeline(images, augmentations): Apply a series of augmentations to a batch of images. :param images: np.ndarray, batch of images of shape (batch_size, height, width, channels) :param augmentations: list of dict, list of augmentations to apply. Each dict contains the type of augmentation and associated parameters. :return: np.ndarray, batch of augmented images with the same shape as the input augmented_images = [] for img in images: img_pil = Image.fromarray(img) for aug in augmentations: if aug[\\"type\\"] == \\"flip_horizontal\\": img_pil = img_pil.transpose(Image.FLIP_LEFT_RIGHT) elif aug[\\"type\\"] == \\"rotate\\": img_pil = img_pil.rotate(aug[\\"angle\\"]) elif aug[\\"type\\"] == \\"adjust_brightness\\": enhancer = ImageEnhance.Brightness(img_pil) img_pil = enhancer.enhance(aug[\\"factor\\"]) augmented_images.append(np.array(img_pil)) return np.array(augmented_images)"},{"question":"# Task Given a string representing a complex number in the form \\"a+bi\\" where a and b are integers, implement a function `complex_number_multiply(a: str, b: str) -> str` to perform multiplication between two complex numbers represented as strings. # Function Signature ```python def complex_number_multiply(a: str, b: str) -> str: pass ``` # Input - **a**: A string representing the first complex number in the form \\"a+bi\\", where \\"a\\" and \\"b\\" are integers (1 â‰¤ |a|, |b| â‰¤ 10^4). - **b**: A string representing the second complex number in the form \\"a+bi\\", where \\"a\\" and \\"b\\" are integers (1 â‰¤ |a|, |b| â‰¤ 10^4). # Output - Returns a string representing the product of the two complex numbers in the same form \\"c+di\\" where \\"c\\" and \\"d\\" are integers. # Constraints - The input integers a and b are guaranteed to be within the specified range. - Implement the multiplication using the standard rules for complex numbers: [ (a+bi) * (c+di) = (ac - bd) + (ad + bc)i ] # Example Consider `a = \\"1+1i\\"` and `b = \\"1+1i\\"`. The result of multiplying the two complex numbers is: 1. Real part = 1*1 - 1*1 = 0 2. Imaginary part = 1*1 + 1*1 = 2 Therefore, the function should return \\"0+2i\\". ```python >>> complex_number_multiply(\\"1+1i\\", \\"1+1i\\") \\"0+2i\\" ``` # Note Make sure the output format for the result is consistent with the input format, and handle positive and negative integers correctly.","solution":"def complex_number_multiply(a: str, b: str) -> str: # Extract real and imaginary parts from the first complex number a_real, a_imag = map(int, a[:-1].split(\'+\')) # Extract real and imaginary parts from the second complex number b_real, b_imag = map(int, b[:-1].split(\'+\')) # Compute the real part of the product real_part = a_real * b_real - a_imag * b_imag # Compute the imaginary part of the product imag_part = a_real * b_imag + a_imag * b_real # Format the result as a string result = f\\"{real_part}+{imag_part}i\\" return result"},{"question":"# Question: Matrix Row Sorting by Column Values Context: Youâ€™re designing an algorithm for efficiently processing large datasets represented by matrices. One common operation is to reorder the rows based on the values of a specific column. Problem Statement: Write a function `sort_matrix_by_column(matrix: List[List[int]], col_idx: int) -> List[List[int]]` that takes a matrix and an integer representing a column index, and returns the matrix with its rows sorted in ascending order based on the values of the specified column. Input: - A list of lists `matrix` where each inner list represents a row of the matrix. - An integer `col_idx` indicating the index of the column to sort by. - The matrix can have varying numbers of rows and columns. - Column index `col_idx` is guaranteed to be within the bounds of the columns of the matrix. Output: - A list of lists representing the sorted matrix. Constraints: - If the input matrix is empty or None, raise a `ValueError` with the message: \\"The matrix cannot be empty or None\\". - If any row in the matrix is not of the same length, raise a `ValueError` with the message: \\"All rows must have the same number of columns\\". Examples: ```python >>> sort_matrix_by_column([[3, 4, 2], [1, 2, 3], [5, 0, 9]], 1) [[5, 0, 9], [1, 2, 3], [3, 4, 2]] >>> sort_matrix_by_column([[10, -1], [-1, 2], [0, 0]], 0) [[-1, 2], [0, 0], [10, -1]] >>> sort_matrix_by_column([[5, 3, 7], [3, 2, 1], [4, 8, 6]], 2) [[3, 2, 1], [4, 8, 6], [5, 3, 7]] >>> sort_matrix_by_column([[1, 1], [2, 2], [3, 3]], 1) [[1, 1], [2, 2], [3, 3]] >>> sort_matrix_by_column([], 0) Traceback (most recent call last): ... ValueError: The matrix cannot be empty or None >>> sort_matrix_by_column([[1, 2, 3], [4, 5], [6, 7, 8]], 2) Traceback (most recent call last): ... ValueError: All rows must have the same number of columns ``` Notes: - Ensure that your function works efficiently even for large matrices. - Verify that the input matrix is valid and handle any edge cases appropriately.","solution":"from typing import List def sort_matrix_by_column(matrix: List[List[int]], col_idx: int) -> List[List[int]]: if matrix is None or not matrix: raise ValueError(\\"The matrix cannot be empty or None\\") # Check if all rows have the same number of columns num_cols = len(matrix[0]) for row in matrix: if len(row) != num_cols: raise ValueError(\\"All rows must have the same number of columns\\") # Sort the matrix by the specified column index sorted_matrix = sorted(matrix, key=lambda x: x[col_idx]) return sorted_matrix"},{"question":"# K-Means Clustering Implementation You are tasked with implementing the K-Means clustering algorithm to categorize `n` data points into `k` clusters. The objective is to iteratively adjust the cluster centroids to minimize the total distance between points and their assigned centroids. Task: Implement a function `k_means_clustering(points: List[Tuple[float, float]], k: int, max_iterations: int = 100) -> List[int]` that: 1. Randomly initializes `k` centroids from the given data points. 2. Assigns each point to the nearest centroid. 3. Recalculates the centroids as the average of points within each cluster. 4. Repeats steps 2 and 3 until the centroids no longer change or the maximum number of iterations is reached. Function Input: - `points`: A list of tuples, each tuple containing the x and y coordinates of a point (e.g., `[(x1, y1), (x2, y2), ...]`). - `k`: An integer representing the number of clusters. - `max_iterations`: An optional integer representing the maximum number of iterations to run the algorithm (default is 100). Function Output: - Returns a list of integers, where each integer is the index of the cluster to which the corresponding point has been assigned. Constraints: - `1 <= len(points) <= 10^5` - `1 <= k <= len(points)` - `1 <= max_iterations <= 1000` Example: ```python points = [(1.0, 2.0), (2.0, 1.0), (3.0, 4.0), (5.0, 7.0)] k = 2 result = k_means_clustering(points, k) print(result) # Expected output: [cluster_index1, cluster_index2, ...] ``` Note: - Implement the `k_means_clustering` function ensuring it effectively assigns clusters even for edge cases. - Consider using a seed for random initialization to ensure reproducibility of results. Implementation Tip: - Use Euclidean distance to measure the distance between points and centroids. - Ensure the implementation efficiently handles the constraints, particularly for large datasets.","solution":"import random from typing import List, Tuple def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5 def k_means_clustering(points: List[Tuple[float, float]], k: int, max_iterations: int = 100) -> List[int]: # Step 1: Initialize centroids randomly from the given data points random.seed(42) # For reproducibility centroids = random.sample(points, k) for _ in range(max_iterations): # Step 2: Assign each point to the nearest centroid clusters = [[] for _ in range(k)] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) clusters[closest_centroid_index].append(point) # Step 3: Recalculate the centroids as the average of points within each cluster new_centroids = [] for cluster in clusters: if cluster: # avoid division by zero for empty clusters avg_x = sum(point[0] for point in cluster) / len(cluster) avg_y = sum(point[1] for point in cluster) / len(cluster) new_centroids.append((avg_x, avg_y)) else: # Retry initializing an empty cluster new_centroids.append(random.choice(points)) # Step 4: Check for convergence (if centroids do not change) if new_centroids == centroids: break centroids = new_centroids # Create the final cluster assignment list final_assignments = [] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) final_assignments.append(closest_centroid_index) return final_assignments"},{"question":"# Coding Question: Statistical Mode Calculation Given a list of integers, write a function to compute the statistical mode. The mode is the value that appears most frequently in a set of data. If there is more than one mode (i.e., multiple values with the same highest frequency), the function should return all the modes in ascending order. Function Signature ```python def calculate_mode(numbers: list[int]) -> list[int]: pass ``` Input Parameters * `numbers` (list[int]): A list of integers representing the dataset. Output * A list of integer(s) which represent the mode(s) of the dataset, in ascending order. Constraints * The input list will contain at least one and at most 10,000 elements. * Each integer will be between -10^6 and 10^6 (inclusive). Doctests ```python >>> calculate_mode([1, 2, 3, 3, 2, 4, 5, 2]) [2] >>> calculate_mode([1, 1, 2, 2, 3]) [1, 2] >>> calculate_mode([10, 20, 10, 20, 30, 30]) [10, 20, 30] >>> calculate_mode([7]) [7] >>> calculate_mode([-1, -1, -2, -2, -3, -1]) [-1] >>> calculate_mode([]) Traceback (most recent call last): ... ValueError: Input list cannot be empty >>> calculate_mode([1, -1000000, 1000000, 1, 1000000, -1000000]) [-1000000, 1, 1000000] ``` The function should raise a `ValueError` for the following case: ```python >>> calculate_mode([]) Traceback (most recent call last): ... ValueError: Input list cannot be empty ``` Ensure your implementation effectively handles these cases and accurately computes the mode(s) for any valid input.","solution":"from collections import Counter def calculate_mode(numbers: list[int]) -> list[int]: if not numbers: raise ValueError(\\"Input list cannot be empty\\") counter = Counter(numbers) max_freq = max(counter.values()) modes = [num for num, freq in counter.items() if freq == max_freq] return sorted(modes)"},{"question":"Scenario: Given an array of integers, you are tasked with finding the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given integer, ( k ). This problem is crucial in scenarios where you need to evaluate the stability or variation within specific windows of data. Task: Implement the function `longest_stable_subarray` that analyzes an array to determine the length of the longest contiguous subarray where the difference between the maximum and minimum elements does not exceed ( k ). If no such subarray exists, the function should return 0. # Input Format: - `arr` (List[int]): A list of integers. - `k` (int): An integer representing the maximum allowed difference between the maximum and minimum elements in the subarray. # Output Format: - Return the length of the longest contiguous subarray where the difference between the maximum and minimum elements is at most ( k ). Example: ```python def longest_stable_subarray(arr: list[int], k: int) -> int: Find the length of the longest stable subarray where the difference between the max and min elements is <= k. >>> longest_stable_subarray([1, 3, 2, 4, 5], 3) 5 >>> longest_stable_subarray([10, 1, 2, 3, 2, 5, 6], 2) 4 >>> longest_stable_subarray([1, 5, 9, 1, 5, 9], 4) 1 >>> longest_stable_subarray([4, 3, 3, 2, 2, 2, 1, 3], 1) 4 >>> longest_stable_subarray([8], 5) 1 from collections import deque if not arr: return 0 max_dq = deque() # stores indices of potential max values in decreasing order min_dq = deque() # stores indices of potential min values in increasing order left = 0 max_length = 0 for right in range(len(arr)): while max_dq and arr[max_dq[-1]] <= arr[right]: max_dq.pop() while min_dq and arr[min_dq[-1]] >= arr[right]: min_dq.pop() max_dq.append(right) min_dq.append(right) while arr[max_dq[0]] - arr[min_dq[0]] > k: left += 1 if max_dq[0] < left: max_dq.popleft() if min_dq[0] < left: min_dq.popleft() max_length = max(max_length, right - left + 1) return max_length if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Constraints: - Each element in `arr` is an integer within the range ([-10^9, 10^9]). - The length of the array ( n ) is within the range ([1, 10^5]). - ( k ) is a non-negative integer within the range ([0, 10^9]). **Notes**: - Ensure to handle edge cases such as empty arrays and single-element arrays appropriately. - The function should consider the efficiency of checking subarray lengths and be optimized for large inputs.","solution":"def longest_stable_subarray(arr, k): Find the length of the longest stable subarray where the difference between the max and min elements is <= k. >>> longest_stable_subarray([1, 3, 2, 4, 5], 3) 5 >>> longest_stable_subarray([10, 1, 2, 3, 2, 5, 6], 2) 4 >>> longest_stable_subarray([1, 5, 9, 1, 5, 9], 4) 1 >>> longest_stable_subarray([4, 3, 3, 2, 2, 2, 1, 3], 1) 4 >>> longest_stable_subarray([8], 5) 1 from collections import deque if not arr: return 0 max_dq = deque() # stores indices of potential max values in decreasing order min_dq = deque() # stores indices of potential min values in increasing order left = 0 max_length = 0 for right in range(len(arr)): while max_dq and arr[max_dq[-1]] <= arr[right]: max_dq.pop() while min_dq and arr[min_dq[-1]] >= arr[right]: min_dq.pop() max_dq.append(right) min_dq.append(right) while arr[max_dq[0]] - arr[min_dq[0]] > k: left += 1 if max_dq[0] < left: max_dq.popleft() if min_dq[0] < left: min_dq.popleft() max_length = max(max_length, right - left + 1) return max_length if __name__ == \\"__main__\\": import doctest doctest.testmod()"},{"question":"# Problem Statement: Write a function that calculates the total weight of all unique characters in a string. Each character has a weight defined by its position in the English alphabet (1-based index), i.e., \'a\' has a weight of 1, \'b\' has a weight of 2, ..., and \'z\' has a weight of 26. Function Signature: ```python def unique_char_weight(s: str) -> int: # Your code here ``` Input: * A string `s` where ( 1 leq |s| leq 10^5 ). Output: * An integer - the total weight of all unique characters in the string. Constraints: * The input string `s` consists of lowercase English letters only. # Example: *Example 1*: ```python s = \\"abc\\" unique_char_weight(s) ``` *Output*: ``` 6 ``` *Example 2*: ```python s = \\"zzz\\" unique_char_weight(s) ``` *Output*: ``` 26 ``` *Example 3*: ```python s = \\"apple\\" unique_char_weight(s) ``` *Output*: ``` 36 ``` Explanation: In the first example, the string \\"abc\\" has unique characters \'a\', \'b\', and \'c\' which have weights 1, 2, and 3 respectively. Therefore, the total weight is 1 + 2 + 3 = 6. In the second example, \\"zzz\\" has only one unique character \'z\' with a weight of 26. In the third example, \\"apple\\" has unique characters \'a\', \'p\', \'l\', and \'e\' with weights 1, 16, 12, and 5 respectively. Therefore, the total weight is 1 + 16 + 12 + 5 = 34. Your task is to ensure the function efficiently handles strings of varying lengths and correctly calculates the sum of the weights of all unique characters.","solution":"def unique_char_weight(s: str) -> int: Calculate the total weight of all unique characters in a string. Each character\'s weight is determined by its position in the alphabet. # Create a set of unique characters in the input string unique_characters = set(s) # Calculate the total weight of all unique characters total_weight = sum(ord(char) - ord(\'a\') + 1 for char in unique_characters) return total_weight"},{"question":"# String Compression Coding Assessment You are tasked with creating a program that performs basic string compression using the counts of repeated characters. For example, the string `\\"aaabccddd\\"` would become `\\"a3b1c2d3\\"`. If the compressed string is not smaller than the original string, the program should return the original string. Additionally, implement a function to decompress the string back to its original form. 1. **`compress_string(s: str) -> str`**: This function should compress the input string `s` using the counts of repeated characters. It should return the compressed string if it is smaller in length than the original string; otherwise, it should return the original string. 2. **`decompress_string(s: str) -> str`**: This function should decompress a string that was compressed in the format produced by `compress_string` (e.g., `\\"a3b1c2d3\\"`) and return the original string (e.g., `\\"aaabccddd\\"`). # Requirements - **Input Format**: - `s`: A string containing the text to be compressed or decompressed. - **Output Format**: - For `compress_string`: A string that represents either the compressed version of the input or the original input. - For `decompress_string`: A string that represents the decompressed form of the input string. - **Constraints**: - The string `s` will only contain lowercase alphabetical characters and can have a length between 1 and 1000. - The compression function should only compress the string if the resulting compressed string is shorter in length than the original string. - The decompression function will always receive a valid compressed string in the format specified. # Example ```python # Given the string \\"aaabccddd\\" original_string = \\"aaabccddd\\" # Expected output for compress_string compressed_string = \\"a3b1c2d3\\" # Given the compressed string \\"a3b1c2d3\\" compressed_string = \\"a3b1c2d3\\" # Expected output for decompress_string original_string = \\"aaabccddd\\" ``` Implement the specified functions ensuring correctness and optimal performance.","solution":"def compress_string(s): Compress the input string using the counts of repeated characters. Returns the compressed string if it is shorter than the original string, otherwise returns the original string. if not s: return s compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char) compressed.append(str(count)) prev_char = char count = 1 compressed.append(prev_char) compressed.append(str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def decompress_string(s): Decompress the input string which is in the format produced by compress_string. Returns the original string. decompressed = [] i = 0 while i < len(s): char = s[i] i += 1 count = 0 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Problem: Efficient String Mutation and Search Utility **Context**: You are tasked with creating an efficient string management utility that can handle frequent updates and searches. This utility will facilitate setting characters at specific indices and finding patterns within the string. Your task is to implement a string manager class that supports the following operations: 1. **SetCharacter**: Set or update a character at a specific index in the string. 2. **FindPattern**: Return the starting index of the first occurrence of a given pattern in the string. # Task: Implement the class `EfficientStringManager` with the following methods: 1. **__init__()**: Initialize an empty string. 2. **set_character(index: int, char: str) -> None**: - Set the `index` in the string with `char`. Ensure that the index is within the current bounds of the string or extend the string if necessary. 3. **find_pattern(pattern: str) -> int**: - Return the starting index of the first occurrence of the `pattern` in the string. If the pattern is not found, return -1. # Constraints: - The system needs to operate within the following constraints: - `index` is a non-negative integer. - `char` is a single character string. - `pattern` is a non-empty string. - Assume no more than 10^5 operations will be made. - The methods `set_character` and `find_pattern` should be optimized for performance. # Example: ```python manager = EfficientStringManager() manager.set_character(0, \'a\') manager.set_character(1, \'b\') manager.set_character(2, \'c\') assert manager.find_pattern(\'abc\') == 0 manager.set_character(1, \'d\') assert manager.find_pattern(\'dbc\') == 0 assert manager.find_pattern(\'abc\') == -1 manager.set_character(3, \'e\') manager.set_character(4, \'f\') assert manager.find_pattern(\'dbcef\') == 0 assert manager.find_pattern(\'ef\') == 3 ``` *Implement `EfficientStringManager` below:* ```python class EfficientStringManager: def __init__(self): self.string = [] def set_character(self, index, char): # Extend the string if necessary and set the character at the specified index while len(self.string) <= index: self.string.append(\' \') self.string[index] = char def find_pattern(self, pattern): # Implement a method to find the pattern in the string str_repr = \'\'.join(self.string) return str_repr.find(pattern) # Example usage, such implementations must be tested thoroughly. ```","solution":"class EfficientStringManager: def __init__(self): self.string = [] def set_character(self, index, char): # Extend the string if necessary and set the character at the specified index while len(self.string) <= index: self.string.append(\' \') self.string[index] = char def find_pattern(self, pattern): # Implement a method to find the pattern in the string str_repr = \'\'.join(self.string) return str_repr.find(pattern)"},{"question":"# Problem Overview You are given a list of strings where each string represents a valid domain name. Your task is to write a function that calculates the number of occurrences of each top-level domain (TLD) in the list and returns a dictionary where the keys are the TLDs and the values are their respective counts. # Function Signature ```python def count_tlds(domains: list[str]) -> dict: pass ``` # Input * `domains`: A list of strings where each string is a valid domain name. # Output A dictionary where the keys are TLDs (including the dot, e.g., `.com`, `.org`) and the values are integers representing the count of each TLD in the input list. # Constraints 1. 1 <= len(domains) <= 1000 2. Each string in the list is a non-empty, valid domain name. 3. There will be no subdomains; all domain names are in the format `example.tld`. # Examples ```python domains = [ \\"example.com\\", \\"anotherexample.org\\", \\"yetanother.net\\", \\"example.com\\", \\"somedomain.co.uk\\", \\"anotherexample.org\\", \\"uniquedomain.xyz\\" ] # Example 1 print(count_tlds(domains)) # Expected Output: {\'.com\': 2, \'.org\': 2, \'.net\': 1, \'.co.uk\': 1, \'.xyz\': 1} # Example 2 print(count_tlds([\\"example.com\\"])) # Expected Output: {\'.com\': 1} # Example 3 print(count_tlds([\\"example.edu\\", \\"example.edu\\", \\"example.edu\\", \\"example.edu\\"])) # Expected Output: {\'.edu\': 4} # Example 4 print(count_tlds([])) # Expected Output: {} ``` # Notes When implementing this function, pay special attention to efficiently parsing the TLD from each domain name and accurately counting their occurrences. Consider edge cases such as an empty list or repetitive domain names.","solution":"def count_tlds(domains): This function counts the number of occurrences of each top-level domain in the list \'domains\'. Parameters: domains (list): A list of strings where each string is a valid domain name. Returns: dict: A dictionary with TLDs as keys and their respective counts as values. tld_count = {} for domain in domains: # Split the domain by \'.\' and get the TLD by joining the split parts from the end. parts = domain.split(\'.\') tld = \'.\' + \'.\'.join(parts[1:]) if tld in tld_count: tld_count[tld] += 1 else: tld_count[tld] = 1 return tld_count"},{"question":"# Question Write a Python program to implement a K-Means clustering algorithm for a given dataset. The goal is to cluster the instances in the dataset into k clusters and evaluate the clustering performance using a silhouette score. # Requirements: - Implement the K-Means clustering using `KMeans` from the scikit-learn library. - Load the dataset and preprocess it if necessary. - Determine the optimal number of clusters (k) using the Elbow method. - Fit the K-Means model to the dataset with the optimal k. - Evaluate the clustering performance using the silhouette score. - Visualize the clusters and the silhouette score for the optimal k. # Input: - `data`: a 2D array (or list of lists) where each inner list represents the feature vector of an instance. # Output: - A plot showing the Elbow method graph to determine the optimal k. - A silhouette score indicating the quality of the clustering. - A visualization of the clusters with different colors for each cluster. # Constraints: - The dataset should be normalized before applying the K-Means algorithm. - The program should handle datasets with at least 3 clusters. # Performance Requirements: - Aim for a silhouette score of at least 0.5 to ensure good clustering quality. # Scenario: You are given a synthetic dataset with three distinguishable clusters. Implement the `kmeans_clustering` function to perform K-Means clustering and evaluate the model. Use the helper functions provided to load and preprocess the dataset. ```python import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.datasets import make_blobs from sklearn.metrics import silhouette_score from sklearn.preprocessing import StandardScaler def load_dataset(samples: int = 300, centers: int = 3, cluster_std: float = 0.60) -> np.ndarray: Generate a synthetic dataset with the given parameters. data, _ = make_blobs(n_samples=samples, centers=centers, cluster_std=cluster_std, random_state=42) return data def preprocess_data(data: np.ndarray) -> np.ndarray: Normalize the provided dataset. scaler = StandardScaler() return scaler.fit_transform(data) def kmeans_clustering(data: np.ndarray) -> None: Apply K-Means clustering to the dataset and evaluate using silhouette score. # Preprocess the dataset data = preprocess_data(data) # Determine the optimal number of clusters using the Elbow method sse = [] for k in range(1, 11): kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(data) sse.append(kmeans.inertia_) plt.figure() plt.plot(range(1, 11), sse, marker=\'o\') plt.title(\'Elbow Method\') plt.xlabel(\'Number of clusters (k)\') plt.ylabel(\'Sum of squared errors (SSE)\') plt.show() # Choose the optimal k (e.g., from the Elbow Method plot) optimal_k = 3 # Apply K-Means with the optimal number of clusters kmeans = KMeans(n_clusters=optimal_k, random_state=42) labels = kmeans.fit_predict(data) # Evaluate the clustering performance using silhouette score silhouette_avg = silhouette_score(data, labels) print(f\'Silhouette Score for k={optimal_k}: {silhouette_avg:.2f}\') # Visualize the clusters plt.figure() plt.scatter(data[:, 0], data[:, 1], c=labels, s=50, cmap=\'viridis\') centers = kmeans.cluster_centers_ plt.scatter(centers[:, 0], centers[:, 1], c=\'red\', s=200, alpha=0.75) plt.title(\'K-Means Clustering\') plt.xlabel(\'Feature 1\') plt.ylabel(\'Feature 2\') plt.show() def main() -> None: # Load synthetic dataset data = load_dataset() # Perform K-Means clustering and evaluation kmeans_clustering(data) if __name__ == \\"__main__\\": main() ``` **Note**: Ensure to install the required libraries using `pip install numpy matplotlib scikit-learn` before running your script.","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.datasets import make_blobs from sklearn.metrics import silhouette_score from sklearn.preprocessing import StandardScaler def load_dataset(samples: int = 300, centers: int = 3, cluster_std: float = 0.60) -> np.ndarray: Generate a synthetic dataset with the given parameters. data, _ = make_blobs(n_samples=samples, centers=centers, cluster_std=cluster_std, random_state=42) return data def preprocess_data(data: np.ndarray) -> np.ndarray: Normalize the provided dataset. scaler = StandardScaler() return scaler.fit_transform(data) def kmeans_clustering(data: np.ndarray) -> tuple: Apply K-Means clustering to the dataset and evaluate using silhouette score. Returns: tuple: silhouette score, optimal number of clusters # Preprocess the dataset data = preprocess_data(data) # Determine the optimal number of clusters using the Elbow method sse = [] for k in range(1, 11): kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(data) sse.append(kmeans.inertia_) plt.figure() plt.plot(range(1, 11), sse, marker=\'o\') plt.title(\'Elbow Method\') plt.xlabel(\'Number of clusters (k)\') plt.ylabel(\'Sum of squared errors (SSE)\') plt.show() # Choose the optimal k based on the Elbow curve optimal_k = 3 # Apply K-Means with the optimal number of clusters kmeans = KMeans(n_clusters=optimal_k, random_state=42) labels = kmeans.fit_predict(data) # Evaluate the clustering performance using silhouette score silhouette_avg = silhouette_score(data, labels) print(f\'Silhouette Score for k={optimal_k}: {silhouette_avg:.2f}\') # Visualize the clusters plt.figure() plt.scatter(data[:, 0], data[:, 1], c=labels, s=50, cmap=\'viridis\') centers = kmeans.cluster_centers_ plt.scatter(centers[:, 0], centers[:, 1], c=\'red\', s=200, alpha=0.75) plt.title(\'K-Means Clustering\') plt.xlabel(\'Feature 1\') plt.ylabel(\'Feature 2\') plt.show() return silhouette_avg, optimal_k def main() -> None: # Load synthetic dataset data = load_dataset() # Perform K-Means clustering and evaluation kmeans_clustering(data) if __name__ == \\"__main__\\": main()"},{"question":"**Problem Statement**: You are given a list of integers which represent the scores of various players in a game. Your task is to implement the function `find_second_highest` that returns the second highest unique score from the list. If there is no second highest unique score, the function should return `None`. **Function Signature**: `def find_second_highest(scores: list[int]) -> int` **Input**: * A list of `n` integers where `1 â‰¤ n â‰¤ 10^5`. **Output**: * An integer representing the second highest unique score. * If there is no second highest unique score, return `None`. **Constraints**: * The list will always contain at least one integer. * All numbers in the list can be positive or negative. **Detailed Description**: * To find the second highest unique score, you need to first identify all unique scores in the list. * Then, sort these unique scores in descending order and return the second highest one. * If there are fewer than two unique scores, return `None`. **Edge Cases to Consider**: * List with all identical scores. * List with only one score. * List with negative scores. **Examples**: ```python >>> find_second_highest([4, 2, 10, 10, 6, 8]) 8 >>> find_second_highest([1, 2, 2, 2]) 1 >>> find_second_highest([5]) None >>> find_second_highest([3, 3, 3, 3]) None >>> find_second_highest([-5, -2, -8, -1]) -2 ``` Implement the function `find_second_highest` in Python to solve the problem as described.","solution":"def find_second_highest(scores: list[int]) -> int: Returns the second highest unique score from the list. If there is no second highest unique score, returns None. unique_scores = list(set(scores)) if len(unique_scores) < 2: return None unique_scores.sort(reverse=True) return unique_scores[1]"},{"question":"# Coding Assessment Question: Implementation of K-Means Clustering with SSE Calculation Objective Demonstrate an understanding of clustering algorithms by implementing the K-Means algorithm and calculating the Sum of Squared Errors (SSE) for the clusters formed. Task Description Given a list of data points and a number of clusters, implement a function using the K-Means clustering algorithm to cluster the data points. Additionally, your function should calculate the Sum of Squared Errors (SSE) for the clusters formed and return it along with the cluster centroids and the data point assignments. Function Signature ```python def k_means_clustering(data_points: list[list[float]], k: int, max_iterations: int = 300) -> tuple[list[list[float]], list[int], float]: Perform K-Means clustering on the given data points. Input ===== - data_points: A list of points, where each point is a list of floats representing a multi-dimensional coordinate. - k: The number of clusters to form. - max_iterations: Maximum number of iterations to perform. Output ====== - centroids: A list of centroids, where each centroid is a list of floats. - assignments: A list of integers representing the index of the cluster each data point is assigned to. - sse: Float, the Sum of Squared Errors for the clusters formed. ``` Input and Output - **Input**: - data_points: A list of lists of floats where each inner list represents a data point in multi-dimensional space. - k: An integer representing the number of clusters. - max_iterations: An integer representing the maximum number of iterations for the algorithm. - **Output**: - centroids: A list of lists of floats where each inner list is a centroid of a cluster. - assignments: A list of integers where each integer represents the index of the cluster the corresponding data point is assigned to. - sse: A float representing the Sum of Squared Errors for the clusters. Constraints - The number of data points will be between 1 and 1000. - Each data point will be in a space of up to 10 dimensions. - 1 â‰¤ k â‰¤ number of data points. - All elements in the data points will be real numbers. - The initial centroids should be chosen randomly from the data points. Performance Requirements - The algorithm should run within a reasonable time frame for data sets up to 1000 points. Example ```python data_points = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ] k = 2 max_iterations = 100 # Expected centroids and assignments may vary depending on the initial random selection of centroids. centroids, assignments, sse = k_means_clustering(data_points, k, max_iterations) print(f\\"Centroids: {centroids}\\") print(f\\"Assignments: {assignments}\\") print(f\\"SSE: {sse}\\") ``` This new question adheres to the style, complexity, and scope of the provided question by introducing a clustering algorithm and incorporating an additional requirement to calculate a performance metric (SSE) similar to how the variance is tracked in the Power Iteration example.","solution":"import random from typing import List, Tuple def euclidean_distance(point1: List[float], point2: List[float]) -> float: return sum((a - b) ** 2 for a, b in zip(point1, point2)) def calculate_sse(data_points: List[List[float]], centroids: List[List[float]], assignments: List[int]) -> float: sse = 0.0 for point, assignment in zip(data_points, assignments): sse += euclidean_distance(point, centroids[assignment]) return sse def k_means_clustering(data_points: List[List[float]], k: int, max_iterations: int = 300) -> Tuple[List[List[float]], List[int], float]: # Randomly initialize centroids centroids = random.sample(data_points, k) prev_centroids = [] assignments = [0] * len(data_points) for _ in range(max_iterations): # Assign points to the nearest centroid for i, point in enumerate(data_points): distances = [euclidean_distance(point, centroid) for centroid in centroids] assignments[i] = distances.index(min(distances)) # Update centroids new_centroids = [[0.0] * len(data_points[0]) for _ in range(k)] counts = [0] * k for assignment, point in zip(assignments, data_points): counts[assignment] += 1 for i in range(len(point)): new_centroids[assignment][i] += point[i] for i in range(k): if counts[i] != 0: new_centroids[i] = [x / counts[i] for x in new_centroids[i]] if new_centroids == centroids: break prev_centroids = centroids centroids = new_centroids sse = calculate_sse(data_points, centroids, assignments) return centroids, assignments, sse"},{"question":"You are required to implement a function that converts a given decimal number to its binary, hexadecimal, and octal representations. # Problem Statement 1. **Function to Implement**: Write a function `convert_number(number: int) -> dict` that takes one parameter: * `number` (integer): The decimal number to be converted. The function should return a dictionary with three key-value pairs, where: - The key `\\"binary\\"` holds the binary representation of the input number. - The key `\\"hexadecimal\\"` holds the hexadecimal representation of the input number. - The key `\\"octal\\"` holds the octal representation of the input number. 2. **Expected Output**: This function should return a dictionary with the specified conversions in string format. # Constraints * `0 <= number <= 10^6` # Example ```python >>> convert_number(255) { \'binary\': \'11111111\', \'hexadecimal\': \'ff\', \'octal\': \'377\' } ``` # Notes * The binary, hexadecimal, and octal representations should not contain any prefixes (like `0b`, `0x`, or `0o`). * Both upper and lower case letters for the hexadecimal output are acceptable, but be consistent. # Task Breakdown 1. Create a function that converts the integer to its binary, hexadecimal, and octal forms. 2. Ensure that the representations are correct and without prefixes. 3. Consider edge cases such as `number` being zero. 4. Validate the input to ensure it falls within the defined constraints.","solution":"def convert_number(number: int) -> dict: Converts a given integer to its binary, hexadecimal, and octal representations. Parameters: number (int): The decimal number to be converted. Returns: dict: A dictionary with binary, hexadecimal, and octal string representations. if not (0 <= number <= 10**6): raise ValueError(\\"Number is out of the valid range (0 <= number <= 10^6)\\") return { \'binary\': bin(number)[2:], \'hexadecimal\': hex(number)[2:], \'octal\': oct(number)[2:] }"},{"question":"# Coding Question: Advanced Overlapping Intervals As part of optimizing a scheduling system, you need to handle the detection of overlapping time intervals efficiently. The system receives a set of intervals and must determine the number of overlapping intervals at any given time. Efficient handling of this information is crucial for maintaining a responsive system, especially as the number of intervals grows. # Requirements: 1. Implement the `max_overlap(intervals: list[tuple[int, int]]) -> int` function. 2. The function must determine the maximum number of overlapping intervals present at any point in time. 3. Intervals are provided as a list of tuples, where each tuple (start, end) represents the start and end time of an interval. 4. Aim for an optimal solution in terms of time complexity. # Input: * `intervals`: A list of tuples, each containing two integers representing the start and end times of an interval. # Output: * An integer representing the maximum number of overlapping intervals. # Constraints: * The list of intervals is non-empty and contains tuples with integer values. * Start and end times are non-negative integers. * An interval is considered overlapping as long as there is at least one common point between intervals. # Performance Requirements: * Your solution must handle large lists of intervals efficiently, with time complexity better than O(N^2), aiming for O(N log N) approach if possible. # Function Signature: ```python def max_overlap(intervals: list[tuple[int, int]]) -> int: pass ``` # Example: ```python intervals = [ (1, 5), (2, 6), (3, 7), (10, 15), (5, 6) ] assert max_overlap(intervals) == 3 # Expected maximum overlap intervals = [ (1, 3), (2, 4), (5, 6), (7, 8) ] assert max_overlap(intervals) == 2 # Expected maximum overlap intervals = [ (1, 10), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11) ] assert max_overlap(intervals) == 2 # Expected maximum overlap ``` # Additional Notes: * Consider both start and end times separately for an effective solution. * Thoroughly test your function with various cases, including large sets of intervals and edge cases with minimal and maximal overlaps. * Efficient management of events will be crucial for grading.","solution":"def max_overlap(intervals): Determines the maximum number of overlapping intervals at any point in time. Parameters: intervals (list of tuple of int): List of tuples, where each tuple (start, end) represents the start and end time of an interval. Returns: int: Maximum number of overlapping intervals. events = [] # Convert intervals into events: +1 for start, -1 for end for start, end in intervals: events.append((start, 1)) events.append((end, -1)) # Sort events first by time; if same time, end (-1) should come before start (+1) events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 # Traverse events to calculate overlaps for event in events: current_overlap += event[1] if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"# Integer Matrix Operations You are tasked with extending a `Matrix` class to include additional matrix operations. Specifically, you need to implement the following methods: 1. **Matrix Multiplication**: * Implement a method `multiply` that performs the matrix multiplication of two matrices. * Matrix multiplication for matrices `A` (of dimensions m x n) and `B` (of dimensions n x p) is defined such that each element `C[i][j]` of the resulting matrix `C` (of dimensions m x p) is computed as: ``` C[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) ``` * **Input**: Two `Matrix` objects. * **Output**: A new `Matrix` object representing the product of the input matrices. 2. **Transpose of a Matrix**: * Implement a method `transpose` that computes the transpose of a matrix. * The transpose of a matrix `A` (of dimensions m x n) is defined as a new matrix `A^T` (of dimensions n x m) where: ``` A^T[i][j] = A[j][i] ``` * **Input**: None (as it works on the instance matrix). * **Output**: A new `Matrix` object representing the transpose of the matrix. **Function Signatures**: ```python def multiply(self, other: Matrix) -> Matrix: ... def transpose(self) -> Matrix: ... ``` **Constraints**: 1. For matrix multiplication: - The number of columns in the first matrix must equal the number of rows in the second matrix. - Both matrices must contain only integer values. - Raise an exception if the above conditions are not met. 2. For transpose: - The matrix must contain only integer values. - Handle empty matrices properly by returning an appropriate result or raising an exception. **Example Usage**: ```python m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) # Matrix Multiplication result_mult = m1.multiply(m2) print(result_mult) # Output: Matrix([[19, 22], [43, 50]]) # Matrix Transpose result_trans = m1.transpose() print(result_trans) # Output: Matrix([[1, 3], [2, 4]]) ``` # Additional Notes: - Ensure proper exception handling for the constraints. - Test your methods thoroughly to guarantee accuracy and efficiency.","solution":"class Matrix: def __init__(self, data): self.data = data def multiply(self, other): if not self.data or not other.data: raise ValueError(\\"Matrices should not be empty.\\") m, n = len(self.data), len(self.data[0]) n_other, p = len(other.data), len(other.data[0]) if n != n_other: raise ValueError(\\"Number of columns of the first matrix must equal number of rows of the second matrix.\\") result = [[0 for _ in range(p)] for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): result[i][j] += self.data[i][k] * other.data[k][j] return Matrix(result) def transpose(self): if not self.data: raise ValueError(\\"Matrix should not be empty.\\") m, n = len(self.data), len(self.data[0]) result = [[self.data[j][i] for j in range(m)] for i in range(n)] return Matrix(result) def __eq__(self, other): return self.data == other.data def __repr__(self): return f\\"Matrix({self.data})\\""},{"question":"Question: Fibonacci Sequence Write a function to generate the first `n` terms of the Fibonacci sequence using both an iterative approach and a recursive approach with memoization. # Function Signatures ```python def fibonacci_iterative(n: int) -> list: pass def fibonacci_recursive_memo(n: int, memo: dict = {}) -> list: pass ``` # Input - An integer `n` (0 â‰¤ n â‰¤ 40). # Output - A list of the first `n` terms of the Fibonacci sequence. # Constraints - The function should raise a `ValueError` if `n` is not within the given bounds. # Example ```python assert fibonacci_iterative(6) == [0, 1, 1, 2, 3, 5] assert fibonacci_iterative(0) == [] assert fibonacci_iterative(1) == [0] assert fibonacci_iterative(2) == [0, 1] try: fibonacci_iterative(41) except ValueError: print(\\"ValueError caught as expected\\") assert fibonacci_recursive_memo(6) == [0, 1, 1, 2, 3, 5] assert fibonacci_recursive_memo(0) == [] assert fibonacci_recursive_memo(1) == [0] assert fibonacci_recursive_memo(2) == [0, 1] try: fibonacci_recursive_memo(41) except ValueError: print(\\"ValueError caught as expected\\") ``` # Notes - Test and compare the performance of both implementations for various values of `n`. - Ensure that your code handles edge cases such as `n = 0`. - The iterative approach should have a time complexity of O(n). - The recursive approach with memoization should avoid redundant calculations and improve efficiency. Enhance your comprehension of these fundamental algorithms by observing their efficiency and performance across different scenarios of sequence generation.","solution":"def fibonacci_iterative(n: int) -> list: if not (0 <= n <= 40): raise ValueError(\\"n must be within the range 0 to 40.\\") if n == 0: return [] elif n == 1: return [0] fibs = [0, 1] for i in range(2, n): fibs.append(fibs[-1] + fibs[-2]) return fibs def fibonacci_recursive_memo(n: int, memo: dict = {}) -> list: if not (0 <= n <= 40): raise ValueError(\\"n must be within the range 0 to 40.\\") if n == 0: return [] elif n == 1: return [0] def fib_memoized(k, memo): if k in memo: return memo[k] if k <= 1: memo[k] = k else: memo[k] = fib_memoized(k - 1, memo) + fib_memoized(k - 2, memo) return memo[k] fibs = [] for i in range(n): fibs.append(fib_memoized(i, memo)) return fibs"},{"question":"**Question**: Implement a function that performs Depth-First Search (DFS) to check if there exists a path between two given vertices in an undirected graph. # Input - An integer `V` (1 â‰¤ `V` â‰¤ 1000) representing the number of vertices. - An integer `E` (0 â‰¤ `E` â‰¤ 10000) representing the number of edges. - A list of `E` edges, where each edge is represented by two integers: `u` and `v`, indicating an undirected edge between vertices `u` and `v`. - An integer `start` representing the starting vertex. - An integer `end` representing the ending vertex. # Output - A boolean value `True` if there exists a path from the start vertex to the end vertex, else `False`. # Function Signature ```python def dfs_path_exists(vertex_count: int, edges: list[tuple[int, int]], start: int, end: int) -> bool: pass ``` # Constraints - All vertices are numbered from 0 to V-1. - The graph may be disconnected. - It is guaranteed that `start` and `end` are valid vertices (0 â‰¤ `start`, `end` < `V`). # Example ```python vertex_count = 5 edges = [ (0, 1), (0, 2), (1, 2), (3, 4) ] start = 0 end = 3 result = dfs_path_exists(vertex_count, edges, start, end) print(result) # Output: False ``` In this example, the function should return `False` as there is no path between vertex 0 and vertex 3 in the given graph.","solution":"def dfs_path_exists(vertex_count: int, edges: list[tuple[int, int]], start: int, end: int) -> bool: from collections import defaultdict # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize visited set and stack visited = set() stack = [start] # Perform DFS while stack: vertex = stack.pop() if vertex == end: return True if vertex not in visited: visited.add(vertex) for neighbor in graph[vertex]: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"# Question: Rotating a 2D Matrix Implement a function `rotate_matrix` that rotates a given square 2D matrix by 90 degrees clockwise. The transformation should be done in-place, meaning you cannot use extra space for another matrix. Function Signature ```python def rotate_matrix(matrix: list) -> None: ``` Input - `matrix`: A list of lists representing a square 2D matrix of integers. The matrix will have dimensions `n x n`, where `n` is the number of rows (and columns) and can be up to 100. Output - The function does not return anything. Instead, it modifies the input matrix in place. Constraints - The input matrix will be non-empty and square (i.e., `n x n` where `1 â‰¤ n â‰¤ 100`). - Each element in the matrix can be any integer value (including negative integers). Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] matrix2 = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) print(matrix2) # Output: [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] ``` **Note**: Make sure your function handles the rotation in-place and efficiently, considering the constraints.","solution":"def rotate_matrix(matrix: list) -> None: Rotate the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # save top element top = matrix[first][i] # move left to top matrix[first][i] = matrix[last - offset][first] # move bottom to left matrix[last - offset][first] = matrix[last][last - offset] # move right to bottom matrix[last][last - offset] = matrix[i][last] # move top to right matrix[i][last] = top"},{"question":"# Coding Challenge: Implement Multiple Inheritance in a Python Class Hierarchy Context You have been provided with an incomplete hierarchy of classes representing animals in a zoo. Some animals share characteristics or behaviors, such as swimming or flying. Python supports multiple inheritance, which can be useful to implement these shared behaviors across different classes with ease. Task You need to complete the class hierarchy by implementing the required classes and using multiple inheritance where appropriate to share behaviors among different animal types. Specifications **Class Definitions** 1. **Swimmer**: This class should represent swimming behavior. - **Signature**: `class Swimmer:` - **Methods**: - `def swim(self):` - Prints `\\"I can swim!\\"`. 2. **Flyer**: This class should represent flying behavior. - **Signature**: `class Flyer:` - **Methods**: - `def fly(self):` - Prints `\\"I can fly!\\"`. 3. **Bird**: This class should inherit from `Flyer`. - **Signature**: `class Bird(Flyer):` - **Methods**: - `def speak(self):` - Prints `\\"Chirp\\"`. 4. **Fish**: This class should inherit from `Swimmer`. - **Signature**: `class Fish(Swimmer):` - **Methods**: - `def speak(self):` - Prints `\\"Blub\\"`. 5. **Duck**: This class should inherit from `Bird` and `Swimmer`. - **Signature**: `class Duck(Bird, Swimmer):` - **Methods**: - `def speak(self):` - Prints `\\"Quack\\"`. Additional Requirements - Ensure that the behaviors (`Swimmer` and `Flyer`) are only implemented once and reused across different classes. - Write code that effectively demonstrates the use of multiple inheritance achieving the desired behaviors. # Example Usage ```python # Initialize instances of various animals duck = Duck() fish = Fish() bird = Bird() # Demonstrate behaviors duck.fly() # Prints \\"I can fly!\\" duck.swim() # Prints \\"I can swim!\\" duck.speak() # Prints \\"Quack\\" fish.swim() # Prints \\"I can swim!\\" fish.speak() # Prints \\"Blub\\" bird.fly() # Prints \\"I can fly!\\" bird.speak() # Prints \\"Chirp\\" ``` # Constraints - Do not modify the method signatures provided. - Adhere to the principles of Object-Oriented Programming and use multiple inheritance correctly. - Handle potential conflicts in method resolution order gracefully. **Nota Bene**: Ensure that the `Duck` class calls the correct inherited behaviors and that each class maintains its integrity and expected outputs.","solution":"class Swimmer: def swim(self): print(\\"I can swim!\\") class Flyer: def fly(self): print(\\"I can fly!\\") class Bird(Flyer): def speak(self): print(\\"Chirp\\") class Fish(Swimmer): def speak(self): print(\\"Blub\\") class Duck(Bird, Swimmer): def speak(self): print(\\"Quack\\")"},{"question":"# Problem: Rotate Image You are given an n x n 2D matrix representing an image. Write a function `rotate_image(matrix: list[list[int]]) -> None` that rotates the image by 90 degrees (clockwise) in place. # Function Signature ```python def rotate_image(matrix: list[list[int]]) -> None: pass ``` # Input - `matrix`: A 2D list of integers representing the matrix. It is guaranteed to have n rows and n columns, where 1 â‰¤ n â‰¤ 20. # Output - The matrix will be modified in place to show the rotated image. The function should not return anything. # Example ```python assert rotate_image([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_image([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] assert rotate_image([[1]]) == [[1]] ``` # Constraints - Do not use any extra space for another matrix except for some variables to perform the rotation. - Aim for O(n^2) time complexity. # Notes - You might find it useful to handle the rotation layer by layer. - The function should modify the original matrix instead of returning a new one. - Consider edge cases like a matrix with a single element or the smallest possible n. # Implementation Idea 1. Transpose the matrix by swapping `matrix[i][j]` with `matrix[j][i]`. 2. Reverse each row of the transposed matrix.","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# K-means Clustering Implementation In this assessment, you are required to implement the K-means clustering algorithm along with an evaluation method to compute the Sum of Squared Errors (SSE). Ensure your implementation handles edge cases and includes suitable initialization and convergence criteria. Objectives: 1. Design the function for **K-means clustering**. 2. Design an evaluation function to compute **Sum of Squared Errors (SSE)**. 3. Implement error handling, including assertion errors for invalid inputs. Input * A feature matrix (numpy array) with dimensions m x n. * Number of desired clusters (k). Output * Cluster assignments for each data point (numpy array). * Cluster centroids (numpy array). * SSE value (float). Constraints * The feature matrix will have at least one row and column. * Number of clusters should be less than or equal to the number of rows in the feature matrix. * Use numpy for matrix operations. Function Signature ```python def k_means_clustering(features: np.ndarray, k: int) -> (np.ndarray, np.ndarray, float): K-means Clustering. Parameters: * features: The features extracted from the dataset * k: Number of desired clusters Returns: * Cluster assignments: Array indicating the cluster assignment for each data point * Centroids: Array containing the centroids of each cluster * SSE: Sum of Squared Errors for the clustering ``` Example Usage ```python import numpy as np # Sample dataset features = np.array([[1.0, 2.0], [1.5, 1.8], [3.0, 3.2], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0]]) # K-means implementation with 3 clusters cluster_assignments, centroids, sse = k_means_clustering(features, 3) print(\\"Cluster Assignments:n\\", cluster_assignments) print(\\"Centroids:n\\", centroids) print(\\"Sum of Squared Errors (SSE):n\\", sse) ``` Notes * Ensure that you include appropriate assertion checks within your function. * Use random initialization for the cluster centroids. * Implement convergence criteria based on centroid stability or a maximum number of iterations. * Aim for clean and readable code along with documentation where necessary. * Use the provided example for testing your function.","solution":"import numpy as np def k_means_clustering(features: np.ndarray, k: int) -> (np.ndarray, np.ndarray, float): K-means Clustering. Parameters: * features: The features extracted from the dataset * k: Number of desired clusters Returns: * Cluster assignments: Array indicating the cluster assignment for each data point * Centroids: Array containing the centroids of each cluster * SSE: Sum of Squared Errors for the clustering # Validate inputs assert isinstance(features, np.ndarray), \\"Features must be a numpy array\\" assert features.ndim == 2, \\"Features matrix must be two-dimensional\\" assert isinstance(k, int) and k > 0, \\"Number of clusters must be a positive integer\\" assert k <= features.shape[0], \\"Number of clusters cannot be greater than the number of data points\\" m, n = features.shape # Randomly initialize centroids centroids = features[np.random.choice(m, k, replace=False)] previous_assignments = np.zeros(m) def compute_sse(points, centroids, assignments): return np.sum([np.linalg.norm(points[assignments == i] - centroids[i])**2 for i in range(k)]) for _ in range(100): # Max iterations # Assign clusters distances = np.linalg.norm(features[:, np.newaxis] - centroids, axis=2) cluster_assignments = np.argmin(distances, axis=1) # Update centroids new_centroids = np.array([features[cluster_assignments == i].mean(axis=0) for i in range(k)]) # Check for convergence if np.all(cluster_assignments == previous_assignments): break centroids = new_centroids previous_assignments = cluster_assignments sse = compute_sse(features, centroids, cluster_assignments) return cluster_assignments, centroids, sse"},{"question":"# Coding Assessment Question Scenario You are developing a feature within a traffic monitoring system that requires frequent updates and queries on vehicle speed data over time. To maintain efficiency, you need to implement a data structure that supports dynamic addition of speeds and allows querying the minimum and maximum speeds within a specific time frame. Task Implement a class `SpeedTracker` that provides an efficient way to add speed data and query both minimum and maximum speeds over any given time interval. # Class Definition ```python class SpeedTracker: def __init__(self) -> None: # Initialize the class with necessary properties def record_speed(self, time: int, speed: int) -> None: # Record the speed at the specified time def query_min_speed(self, start_time: int, end_time: int) -> int: # Query the minimum speed within the time interval [start_time, end_time) def query_max_speed(self, start_time: int, end_time: int) -> int: # Query the maximum speed within the time interval [start_time, end_time) ``` # Method Details * **`__init__(self) -> None`**: * Initializes the SpeedTracker. * **`record_speed(self, time: int, speed: int) -> None`**: * Records the speed at the specified time. \'time\' is an integer representing the timestamp, and \'speed\' is an integer representing the vehicle speed. * **`query_min_speed(self, start_time: int, end_time: int) -> int`**: * Queries and returns the minimum speed within the time interval `[start_time, end_time)`. * **`query_max_speed(self, start_time: int, end_time: int) -> int`**: * Queries and returns the maximum speed within the time interval `[start_time, end_time)`. # Constraints * Recorded times and speeds are non-negative integers. * Queries are guaranteed to have valid intervals where `start_time < end_time`. * You can assume that `record_speed` will be called before any query. # Output Format * Method `query_min_speed` and `query_max_speed` return an integer. # Example ```python tracker = SpeedTracker() # Record speeds at different times tracker.record_speed(1, 60) tracker.record_speed(2, 55) tracker.record_speed(3, 70) tracker.record_speed(4, 50) tracker.record_speed(5, 65) # Query the minimum speed between time 2 and 5 assert tracker.query_min_speed(2, 5) == 50 # Minimum speed is 55 (at time 2) and 50 (at time 4) # Query the maximum speed between time 1 and 4 assert tracker.query_max_speed(1, 4) == 70 # Maximum speed is 70 (at time 3) ``` Solution Hereâ€™s an example implementation of `SpeedTracker`: ```python class SpeedTracker: def __init__(self) -> None: self.speeds = [] def record_speed(self, time: int, speed: int) -> None: self.speeds.append((time, speed)) self.speeds.sort() def query_min_speed(self, start_time: int, end_time: int) -> int: min_speed = float(\'inf\') for time, speed in self.speeds: if start_time <= time < end_time: min_speed = min(min_speed, speed) return min_speed def query_max_speed(self, start_time: int, end_time: int) -> int: max_speed = float(\'-inf\') for time, speed in self.speeds: if start_time <= time < end_time: max_speed = max(max_speed, speed) return max_speed ```","solution":"class SpeedTracker: def __init__(self) -> None: self.speeds = [] def record_speed(self, time: int, speed: int) -> None: self.speeds.append((time, speed)) self.speeds.sort() def query_min_speed(self, start_time: int, end_time: int) -> int: min_speed = float(\'inf\') for time, speed in self.speeds: if start_time <= time < end_time: min_speed = min(min_speed, speed) return min_speed def query_max_speed(self, start_time: int, end_time: int) -> int: max_speed = float(\'-inf\') for time, speed in self.speeds: if start_time <= time < end_time: max_speed = max(max_speed, speed) return max_speed"},{"question":"# Matrix Element Summation Challenge Given a matrix, write a Python function that calculates the sum of elements in each row and the sum of elements in each column. # Function Signature ```python def sum_matrix_elements(matrix: List[List[int]]) -> Tuple[List[int], List[int]]: Calculate the sum of elements in each row and the sum of elements in each column in a matrix. :param matrix: List[List[int]], input 2D matrix :return: Tuple containing two lists - List of row sums and List of column sums pass ``` # Input - `matrix`: A 2D list of integers representing the matrix. # Output - A tuple where the first element is a list of integers representing the sum of elements in each row, and the second element is a list of integers representing the sum of elements in each column. # Constraints 1. Each row in the matrix is the same length (i.e., the matrix is not jagged). 2. The matrix can be of size up to 100x100. 3. The elements of the matrix are integers in the range [-1000, 1000]. # Example Given the following input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Expected output: ```python row_sums, column_sums = sum_matrix_elements(matrix) print(\\"Row Sums:\\", row_sums) # Expected: [6, 15, 24] print(\\"Column Sums:\\", column_sums) # Expected: [12, 15, 18] ``` # Tips - Use basic loops to iterate through the rows and columns to calculate the sums. - Ensure that your function handles edge cases, such as an empty matrix or a matrix with one row/column correctly.","solution":"from typing import List, Tuple def sum_matrix_elements(matrix: List[List[int]]) -> Tuple[List[int], List[int]]: if not matrix or not matrix[0]: return ([], []) row_sums = [sum(row) for row in matrix] num_columns = len(matrix[0]) column_sums = [sum(matrix[row][col] for row in range(len(matrix))) for col in range(num_columns)] return (row_sums, column_sums)"},{"question":"# Coding Assessment Question Problem Statement: You are required to write a function that takes a list of integers and returns a list with the duplicates removed. The order of the elements in the returned list should match the order of their first occurrence in the input list. Input: - A list of integers `lst` (1 <= len(lst) <= 1000, -1000 <= lst[i] <= 1000). Output: - A list of integers where each value appears only once, in the order of their first appearance in the input list. Constraints: - The input list `lst` will contain valid integer values within the given range. - The solution must process the list efficiently and maintain the order of the first occurrences. Function Signature: ```python def remove_duplicates(lst: list) -> list: pass ``` Example: ```python print(remove_duplicates([1, 2, 3, 1, 2, 4])) # Output: [1, 2, 3, 4] print(remove_duplicates([4, 5, 4, 4, 7, 8])) # Output: [4, 5, 7, 8] ``` Context: In numerous data processing tasks, it\'s crucial to filter out duplicate records while maintaining the sequence of unique items. This functionality is often required in data cleaning and preprocessing steps in various applications. # Requirements: - Avoid using unnecessary nested loops which can compromise efficiency on larger lists. - Ensure that the order of first occurrences is preserved in the output list. Hint: Consider using data structures that help track the elements that have already been encountered.","solution":"def remove_duplicates(lst): Returns a list with duplicates removed, preserving the order of first occurrence. seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Problem Statement You are given a function `most_frequent_substring(s: str, length: int) -> str` which finds the most frequently occurring substring of a given length in a provided string. If there are multiple substrings with the same highest frequency, return the lexicographically smallest substring. # Objective Your task is to implement this function while adhering to the following constraints: 1. The function should be efficient and run in reasonable time for string lengths up to 10,000 characters. 2. Maintain the same input and output formats. 3. Handle edge cases such as empty strings or length greater than the input string. # Input and Output * **Input**: A string `s` of length `n` (0 â‰¤ `n` â‰¤ 10,000) and an integer `length` where 0 â‰¤ `length` â‰¤ `n`. * **Output**: A string representing the most frequently occurring substring of the given length. # Constraints - Use efficient algorithms to avoid excessive computations. - The function should run efficiently for large input sizes. - Ensure the function handles edge cases correctly. # Example ```python >>> most_frequent_substring(\\"ababc\\", 2) \'ab\' >>> most_frequent_substring(\\"aabbcc\\", 1) \'a\' >>> most_frequent_substring(\\"abcabcabc\\", 3) \'abc\' ``` # Notes - If the input string is empty or the length is zero, return an empty string. - If `length` is greater than `n`, return an empty string. - Consider utilizing hashing or sliding window techniques to optimize your solution. Good luck, and ensure your solution is efficient and robust!","solution":"def most_frequent_substring(s: str, length: int) -> str: if length == 0 or not s or length > len(s): return \\"\\" substring_count = {} # Slide over the string to count all substrings of the given length for i in range(len(s) - length + 1): substring = s[i:i+length] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 # Find the most frequent substring max_frequency = max(substring_count.values()) most_frequent = [substr for substr, count in substring_count.items() if count == max_frequency] # Return the lexicographically smallest substring if there\'s a tie return min(most_frequent)"},{"question":"# Problem Statement: You are tasked with building a simple text-based game that simulates a treasure hunt on an island grid. Write a function to determine the number of distinct paths from the starting point `(0, 0)` to a hidden treasure located at a specified point `(x, y)` on the grid. # Requirements 1. Implement a function `find_paths(x: int, y: int) -> int` to compute the number of distinct paths to the treasure. 2. The function should consider the following constraints: - You can only move right or down at any point in time. - The island is represented as a grid of size `x` by `y`, with `(0, 0)` being the top-left corner and `(x, y)` being the bottom-right corner where the treasure is located. 3. Use dynamic programming or combinatorial mathematics (Pascal\'s triangle or combinatorics) to solve the problem efficiently. # Steps to implement: 1. Define the base case where if `(x, y)` is `(0, 0)`, there\'s only one path (the starting point itself). 2. Use dynamic programming to populate the number of ways to reach each cell in the grid from the starting point. 3. Iterate through possible cells and calculate the number of paths to each cell by summing the number of paths from the cell directly above and the cell directly to the left. 4. Your function should return the number of distinct paths to reach `(x, y)` from `(0, 0)`. # Constraints: - The values of `x` and `y` are non-negative integers within the range `[0, 100]`. - Both `x` and `y` must be non-negative. # Input: Two integers, `x` and `y`. # Output: A single integer representing the number of distinct paths from the starting point to the treasure. # Example: ```python result = find_paths(2, 2) # Expected Output: 6 # Explanation: There are six paths to reach (2, 2) from (0, 0) on a 2x2 grid: # - Right, Right, Down, Down # - Right, Down, Right, Down # - Right, Down, Down, Right # - Down, Right, Right, Down # - Down, Right, Down, Right # - Down, Down, Right, Right ``` Evaluate your solution for edge cases including: - Small grids (e.g., 0x0, 1x1). - Larger grids to assess performance. - Only one possible path (e.g., 1-row or 1-column grids).","solution":"def find_paths(x, y): Returns the number of distinct paths from the top-left corner (0, 0) to the bottom-right corner (x, y). # Initialize a 2D DP array with dimensions (x+1) by (y+1) dp = [[0 for _ in range(y + 1)] for _ in range(x + 1)] # There\'s exactly one way to be at the start dp[0][0] = 1 # Fill the DP table for i in range(x + 1): for j in range(y + 1): if i > 0: dp[i][j] += dp[i - 1][j] # Paths from the cell above if j > 0: dp[i][j] += dp[i][j - 1] # Paths from the cell to the left # The number of paths to the bottom-right corner is stored in dp[x][y] return dp[x][y]"},{"question":"# Objective You are tasked with simulating a simplified version of a file sharing system. Implement a function that tracks file transfer requests between users and determines the total number of unique users each file has been shared with. # Function Implementation Function 1: Track File Sharing - **Function Name**: `track_sharing` - **Input**: - `file_id` (int): Identifier for the file being shared. - `sender` (int): The user ID of the sender. - `receiver` (int): The user ID of the receiver. - **Output**: None - **Constraints**: - All user IDs and file IDs are positive integers. - A user cannot share a file with themselves. Function 2: Get Unique Sharers - **Function Name**: `unique_sharers` - **Input**: - `file_id` (int): Identifier for the file. - **Output**: (int) Number of unique users that the file has been shared with, excluding the original sender. - **Constraints**: - File ID must be a positive integer. # Error Handling - Raise `ValueError` with appropriate messages in the following conditions: - Negative or zero values for `file_id`, `sender`, or `receiver` in `track_sharing`. - Sender sharing a file with themselves in `track_sharing`. - Negative or zero values for `file_id` in `unique_sharers`. # Example ```python class FileSharingSystem: def __init__(self): # Initialize the tracking mechanism self.sharing_log = {} def track_sharing(self, file_id: int, sender: int, receiver: int): if file_id <= 0 or sender <= 0 or receiver <= 0: raise ValueError(\\"File ID and user IDs must be positive integers.\\") if sender == receiver: raise ValueError(\\"Sender and receiver must be different users.\\") if file_id not in self.sharing_log: self.sharing_log[file_id] = set() self.sharing_log[file_id].add(receiver) def unique_sharers(self, file_id: int) -> int: if file_id <= 0: raise ValueError(\\"File ID must be a positive integer.\\") if file_id not in self.sharing_log: return 0 return len(self.sharing_log[file_id]) # Example usage: fs_system = FileSharingSystem() fs_system.track_sharing(1, 1001, 1002) fs_system.track_sharing(1, 1002, 1003) fs_system.track_sharing(1, 1003, 1004) print(fs_system.unique_sharers(1)) # Expected Output: 3 ``` # Notes - Ensure that your solution handles edge cases and constraints effectively. - Consider using data structures that efficiently track unique users.","solution":"class FileSharingSystem: def __init__(self): # Initialize the tracking mechanism self.sharing_log = {} def track_sharing(self, file_id: int, sender: int, receiver: int): if file_id <= 0 or sender <= 0 or receiver <= 0: raise ValueError(\\"File ID and user IDs must be positive integers.\\") if sender == receiver: raise ValueError(\\"Sender and receiver must be different users.\\") if file_id not in self.sharing_log: self.sharing_log[file_id] = set() self.sharing_log[file_id].add(receiver) def unique_sharers(self, file_id: int) -> int: if file_id <= 0: raise ValueError(\\"File ID must be a positive integer.\\") if file_id not in self.sharing_log: return 0 return len(self.sharing_log[file_id])"},{"question":"# Sorting and Searching Challenge Objective Implement a function `search_rotated_sorted_array` that searches for a target value in a rotated sorted array using binary search. # Requirements - The function should take in a rotated sorted array and a target value to search for. - If the target is found, return its index. Otherwise, return -1. - The solution should have O(log n) runtime complexity. Input Format: - **nums**: `list[int]` - A rotated sorted array of integers. - **target**: `int` - An integer value to be searched within the array. Output Format: - **int** - The index of the target in the array if it is found. Otherwise, return -1. Constraints: - 1 â‰¤ length of nums â‰¤ 5000 - -10^4 â‰¤ nums[i] â‰¤ 10^4 - nums contains unique elements and is sorted in ascending order initially, but then rotated at some pivot. Example: ```python nums = [4, 5, 6, 7, 0, 1, 2] target = 0 print(search_rotated_sorted_array(nums, target)) # Output: 4 ``` # Implementation Steps: 1. **Initialize Binary Search**: Set up pointers for the start and end of the array. 2. **Binary Search Logic**: - Find the middle element. - Check if the middle element is the target. - Determine whether the left or right half is sorted. - Adjust the pointers based on which half could contain the target. 3. **Return Result**: If the target is found, return its index. If the loop ends without finding the target, return -1. Edge Cases: - Single element arrays. - Target value not present in the array. - The array not being rotated. # Example Scenarios: 1. **Target in Left Half**: - Input: `nums = [6, 7, 8, 9, 1, 2, 3, 4, 5]`, `target = 7` - Output: `1` 2. **Target in Right Half**: - Input: `nums = [6, 7, 1, 2, 3, 4, 5]`, `target = 3` - Output: `4` 3. **Target as Pivot**: - Input: `nums = [8, 9, 1, 3, 5, 6, 7]`, `target = 1` - Output: `2` 4. **Target Not in Array**: - Input: `nums = [5, 6, 7, 8, 0, 1, 2]`, `target = 10` - Output: `-1` ```python def search_rotated_sorted_array(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1 ```","solution":"def search_rotated_sorted_array(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Perfect Power Determination **Context**: A perfect power is a positive integer that can be expressed as an integer power of another positive integer. In other words, a number ( n ) is a perfect power if there exist integers ( x ) and ( y ) such that ( n = x^y ) with ( x geq 1 ) and ( y geq 2 ). **Problem**: You need to write a function `is_perfect_power` that determines whether a given positive integer number is a perfect power. Your function should: - Raise a `TypeError` if the input is not an integer. - Return `False` if the input is not a positive integer. - Return `True` if the input number is a perfect power, `False` otherwise. **Function Signature**: `def is_perfect_power(number: int) -> bool` **Input**: - A positive integer `number` ( (1 leq text{number} leq 10^{12}) ). **Output**: - A boolean value: `True` if the number is a perfect power, `False` otherwise. **Examples**: - `is_perfect_power(1)` should return `True` - `is_perfect_power(4)` should return `True` (since ( 2^2 = 4 )) - `is_perfect_power(9)` should return `True` (since ( 3^2 = 9 )) - `is_perfect_power(11)` should return `False` - `is_perfect_power(27)` should return `True` (since ( 3^3 = 27 )) - `is_perfect_power(-4)` should return `False` - `is_perfect_power(8.0)` should raise a `TypeError` **Constraints**: 1. Your solution should handle edge cases such as very small positive integers and large positive integers efficiently. 2. It should raise appropriate errors for non-integer inputs. **Performance Requirements**: The solution should be efficient and potentially make use of mathematical properties or algorithms to determine if the number is a perfect power, ideally with a time complexity of (O(sqrt{n} log n)) or better. **Clarification**: - Pay attention to integer and non-integer inputs, ensuring type correctness. - Think about minimizing the computational complexity for large input values within the given range.","solution":"def is_perfect_power(number: int) -> bool: Determines if the given positive integer is a perfect power. if not isinstance(number, int): raise TypeError(\\"Input must be an integer.\\") if number <= 0: return False if number == 1: return True from math import isqrt, log # Check for x and y max_y = int(log(number, 2)) + 1 # since number <= 10^12, so log2(number) + 1 should be feasible for y in range(2, max_y + 1): x = int(round(number ** (1 / y))) if x ** y == number: return True return False"},{"question":"# Coding Assessment Question Scenario You are developing a simulation tool to analyze traffic flow in a city. An essential feature of this tool is to compute the minimum number of traffic lights a car would pass through when traveling from one intersection to another in a grid-based city layout. Task Implement a Python function that calculates the minimum number of traffic lights a car would encounter traveling between two intersections on a grid. Each intersection is represented by `(x, y)` coordinates, and cars can move in four directions: up, down, left, and right. Each intersection has a traffic light, but the start and end intersections do not count as passed lights. Function Signature ```python def traffic_lights(start: Tuple[int, int], end: Tuple[int, int]) -> int: ``` Input - `start`: A tuple of two integers representing the coordinates (x, y) of the starting intersection. - `end`: A tuple of two integers representing the coordinates (x, y) of the ending intersection. Output - An integer representing the number of traffic lights the car passes through on the shortest path. Constraints - All coordinates are integers. - Coordinates can range from -1000 to 1000. - Start and end points are distinct. Example ```python assert traffic_lights((0, 0), (2, 2)) == 3 assert traffic_lights((0, 0), (0, 0)) == 0 assert traffic_lights((-1, -1), (1, 1)) == 2 assert traffic_lights((0, 0), (0, 1)) == 0 ``` Note Ensure to correctly handle the calculation of the number of traffic lights in the grid layout and provide clear and concise documentation within your code.","solution":"from typing import Tuple def traffic_lights(start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the minimum number of traffic lights a car would encounter traveling from the start intersection to the end intersection on a grid. start_x, start_y = start end_x, end_y = end # Calculate the total number of intersections between both points. return abs(end_x - start_x) + abs(end_y - start_y)"},{"question":"# Coding Assessment Question You are working on developing an analytics application to monitor website traffic. The application needs to track the number of unique visitors on a given day. However, visitors could be using multiple devices, so each visitor\'s visit may be recorded more than once across different sessions. Your task is to: 1. Implement a function that processes data about website visits and returns the total number of unique visitors for a specified day. 2. Create a supporting function to parse raw visit data and ensure proper data formatting. Expected Input and Output **Function 1**: `def unique_visitors_per_day(visits: list[dict[str, str | int]], target_date: str) -> int`: Return the number of unique visitors for a specific date. - **Input**: - `visits` (list): A list of dictionaries, each containing visit details, where each dictionary has the keys `\'visitor_id\'` (int), `\'timestamp\'` (str, \\"YYYY-MM-DD HH:MM:SS\\"). - `target_date` (str): The date to count unique visitors for, formatted as \\"YYYY-MM-DD\\". - **Output**: An integer representing the number of unique visitors. **Function 2**: `def parse_visit_data(raw_data: list[str]) -> list[dict[str, str | int]]`: Parse raw visit data strings into a list of dictionaries. - **Input**: - `raw_data` (list): A list of strings, each formatted as \\"visitor_id, timestamp\\", where timestamp is \\"YYYY-MM-DD HH:MM:SS\\". - **Output**: A list of dictionaries, each with `visitor_id` (int) and `timestamp` (str, \\"YYYY-MM-DD HH:MM:SS\\"). # Constraints - Assume `visitor_id` values are unique positive integers for different visitors. - Handle cases where the same `visitor_id` may have multiple visits on the `target_date`, ensuring they are only counted once. - Ensure the time complexity of your solution is efficient even for large datasets. - Properly handle and parse all valid date-time strings; raise appropriate exceptions for invalid data. Example Input and Output: - **Example Input**: ```python visit_data = [ \\"123, 2023-10-15 14:23:11\\", \\"456, 2023-10-15 11:34:56\\", \\"123, 2023-10-15 16:45:12\\", \\"789, 2023-10-14 09:01:45\\" ] parsed_data = parse_visit_data(visit_data) unique_visitors = unique_visitors_per_day(parsed_data, \\"2023-10-15\\") print(unique_visitors) # Output: 2 ```","solution":"def unique_visitors_per_day(visits, target_date): Returns the number of unique visitors for a specified date. :param visits: A list of dictionaries each containing \'visitor_id\' (int) and \'timestamp\' (str). :param target_date: The target date as a string in \\"YYYY-MM-DD\\" format. :return: An integer representing the number of unique visitors. unique_visitors = set() for visit in visits: if visit[\'timestamp\'].startswith(target_date): unique_visitors.add(visit[\'visitor_id\']) return len(unique_visitors) def parse_visit_data(raw_data): Parses raw visit data strings into a list of dictionaries. :param raw_data: A list of strings, each formatted as \\"visitor_id, timestamp\\". :return: A list of dictionaries each with \'visitor_id\' (int) and \'timestamp\' (str). parsed_data = [] for entry in raw_data: try: visitor_id, timestamp = entry.split(\\", \\") parsed_data.append({ \'visitor_id\': int(visitor_id), \'timestamp\': timestamp }) except ValueError: raise ValueError(\\"Invalid data format\\") return parsed_data"},{"question":"# Problem Statement Design a function that takes two strings as input and determines if one string is a permutation of the other. A permutation is a rearrangement of characters. The function should return `True` if one string is a permutation of the other, and `False` otherwise. The solution must consider case sensitivity and special characters as valid. # Input Format 1. Two strings `s1` and `s2` with lengths ( text{0} leq text{len}(s1) leq 10^6 ) and ( text{0} leq text{len}(s2) leq 10^6 ). # Output Format - A boolean value `True` if `s1` is a permutation of `s2`. - `False` if `s1` is not a permutation of `s2`. # Constraints * Both uppercase and lowercase characters are considered distinct. * The strings can contain whitespace and special characters. * The function should be efficient in terms of both time and space complexity. # Performance Requirements * The function should run efficiently even for strings with lengths up to 1,000,000 characters. * Aim for a time complexity of (O(n log n)), where (n) is the length of the strings. # Examples 1. **Input**: ``` s1 = \\"listen\\" s2 = \\"silent\\" ``` **Output**: ``` True ``` 2. **Input**: ``` s1 = \\"hello\\" s2 = \\"bello\\" ``` **Output**: ``` False ``` 3. **Input**: ``` s1 = \\"A gentleman\\" s2 = \\"Elegant man\\" ``` **Output**: ``` False ``` 4. **Input**: ``` s1 = \\"123456\\" s2 = \\"654321\\" ``` **Output**: ``` True ``` # Function Signature ```python def is_permutation(s1: str, s2: str) -> bool: # Your code here ``` # Notes - Ensure your implementation is well-optimized and handles all edge cases. - Avoid using built-in functions that solve the problem directly such as `sorted(s1) == sorted(s2)`.","solution":"def is_permutation(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. :param s1: First string :param s2: Second string :return: True if s1 is a permutation of s2, False otherwise if len(s1) != len(s2): return False count = {} for char in s1: if char in count: count[char] += 1 else: count[char] = 1 for char in s2: if char in count: count[char] -= 1 else: return False return all(value == 0 for value in count.values())"},{"question":"# Problem Statement: Imagine you are developing a hospital management system. As a part of the system, you need to implement a scheduling algorithm for doctor\'s appointments. Each doctor has fixed time slots during which they can see patients, and each patient has a preferred time slot for the appointment. Write a function `schedule_appointments(doctors: dict, patients: dict) -> dict` that schedules appointments according to doctors\' availability and patients\' preferences. # Input: * `doctors`: A dictionary where keys are doctor IDs (integers) and values are lists of available time slots (strings in \\"HH:MM\\" 24-hour format) for that doctor. * `patients`: A dictionary where keys are patient IDs (integers) and values are preferred time slots (strings in \\"HH:MM\\" 24-hour format) for each patient. # Output: * Returns a dictionary where the keys are patient IDs, and the values are tuples containing the doctor ID and the confirmed time slot (tuple(int, str)). # Example: ```python >>> schedule_appointments( ... {1: [\\"09:00\\", \\"10:00\\", \\"11:00\\"], 2: [\\"10:00\\", \\"11:00\\", \\"12:00\\"]}, ... {101: \\"09:00\\", 102: \\"10:00\\", 103: \\"11:00\\"} ... ) {101: (1, \\"09:00\\"), 102: (1, \\"10:00\\"), 103: (1, \\"11:00\\")} >>> schedule_appointments( ... {1: [\\"09:00\\"], 2: [\\"09:00\\"]}, ... {101: \\"09:00\\", 102: \\"09:00\\"} ... ) {101: (1, \\"09:00\\"), 102: (2, \\"09:00\\")} ``` # Constraints: * There will be no more patients than the total number of available time slots across all doctors. * Each doctor can only see one patient per available time slot. * Patients prefer to get their appointment at their preferred time slot, but it may not always be possible. # Requirements: * Your function should prioritize assigning preferred time slots for patients. * If multiple doctors are available for the same preferred time slot, any available doctor can be chosen. * Your function should run in a time-efficient manner suitable for up to 10^3 doctors and 10^3 patients. # Points to Consider: * How would you match patients to doctors in cases where multiple slots are available? * Consider edge cases such as when all patients have the same preferred time slot or when doctors have overlapping time slots. * Extensibility for additional constraints such as doctors\' specific patient preferences could be a consideration for future development. # Note: You can define helper functions if needed, but the main function to be evaluated should be `schedule_appointments`.","solution":"def schedule_appointments(doctors, patients): Schedule appointments according to doctors\' availability and patients\' preferences. Parameters: doctors (dict): A dictionary with doctor IDs (int) as keys and lists of available time slots (str) as values. patients (dict): A dictionary with patient IDs (int) as keys and preferred time slots (str) as values. Returns: dict: A dictionary with patient IDs as keys and tuples of (doctor ID, confirmed time slot) as values. # Create a mapping of time slots to available doctors time_slot_to_doctors = {} for doctor_id, slots in doctors.items(): for slot in slots: if slot not in time_slot_to_doctors: time_slot_to_doctors[slot] = [] time_slot_to_doctors[slot].append(doctor_id) appointments = {} # Assign patients to doctors based on preferred time slot and availability for patient_id, preferred_slot in patients.items(): assigned = False if preferred_slot in time_slot_to_doctors and time_slot_to_doctors[preferred_slot]: # Assign the first available doctor for the preferred time slot doctor_id = time_slot_to_doctors[preferred_slot].pop(0) appointments[patient_id] = (doctor_id, preferred_slot) assigned = True # If the preferred slot is not available or not assigned, look for next available slot if not assigned: for slot, doctor_ids in time_slot_to_doctors.items(): if doctor_ids: doctor_id = doctor_ids.pop(0) appointments[patient_id] = (doctor_id, slot) break return appointments"},{"question":"# File Compression Utility You\'re asked to extend a utility function for compressing files in a specified directory. Currently, this function: 1. Collects all files from the given directory. 2. Compresses files into a ZIP archive. 3. Names the archive with the current timestamp. Your task is to enhance this utility with the following features: * **Selective Compression**: Allow the user to specify file extensions to include or exclude in the compression. * **Progress Reporting**: Provide real-time progress updates as files are being compressed. * **Error Handling**: Gracefully handle scenarios where files may be locked, missing, or unreadable. # Input - A string representing the directory path. - (Optional) A list of strings for specific file extensions to include or exclude. # Output - The function should create a ZIP archive in the specified directory with a timestamped name. - It should print real-time progress updates and error messages where applicable. # Constraints - The directory may contain a large number of files with total size up to several GBs. - Only the specified extensions should be included or excluded as per provided input. - Ensure that the utility handles both inclusion and exclusion lists, and default to including all files if no filters are provided. - Handle common file system errors and continue processing remaining files. # Example ```python # Example main invocation if __name__ == \\"__main__\\": directory = \\"/path/to/directory\\" extensions_inclusion = [\\".txt\\", \\".md\\"] try: compress_files(directory, extensions_inclusion) except Exception as e: print(f\\"Failed to compress files: {e}\\") ``` **Note**: Assume that the utility imports and additional required libraries are appropriately managed.","solution":"import os import zipfile import time from datetime import datetime def compress_files(directory, include_extensions=None, exclude_extensions=None): Compresses files in the specified directory into a ZIP archive with selective inclusion or exclusion of file extensions. Args: - directory (str): Path to the directory whose files are to be compressed. - include_extensions (list of str, optional): List of file extensions to include in the compression. - exclude_extensions (list of str, optional): List of file extensions to exclude from the compression. # Get the current timestamp for naming the zip file timestamp = datetime.now().strftime(\\"%Y%m%d%H%M%S\\") zip_filename = os.path.join(directory, f\\"compressed_{timestamp}.zip\\") with zipfile.ZipFile(zip_filename, \'w\') as zipf: for root, _, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) file_extension = os.path.splitext(file)[1] # Check inclusion/exclusion criteria if include_extensions and file_extension not in include_extensions: continue if exclude_extensions and file_extension in exclude_extensions: continue try: zipf.write(file_path, os.path.relpath(file_path, directory)) print(f\\"Compressed: {file_path}\\") except Exception as e: print(f\\"Error compressing {file_path}: {e}\\") print(f\\"Compression complete. Archive created at {zip_filename}\\")"},{"question":"# Problem Statement You are designing a digital vending machine. This machine should dispense items based on the user\'s input and money provided. The vending machine has a catalog of items, each with a unique code, price, and quantity available. Your task is to implement two classes: `Item` and `VendingMachine`. Class 1: `Item` * **Attributes**: * `code` (str): The unique code of the item. * `price` (float): The price of the item. * `quantity` (int): The quantity available of the item. Class 2: `VendingMachine` * **Methods**: * `__init__`: Initializes the vending machine with an empty catalog. * `add_item(item: Item) -> None`: * Adds an `Item` to the catalog. If the item code already exists, it should update the quantity of the item. * `purchase_item(code: str, money: float) -> str`: * Takes the `code` of the item to be purchased and the `money` provided by the user. * Returns a message indicating the success or failure of the purchase. Possible messages: - \\"Item dispensed. Change: X.XX\\" if the item is successfully dispensed and there is change. - \\"Item dispensed. No change.\\" if the item is successfully dispensed with no change. - \\"Insufficient money. Please insert X.XX more.\\" if the money provided is insufficient. - \\"Invalid code.\\" if the provided code does not exist in the catalog. - \\"Item out of stock.\\" if the item is out of stock. # Example ```python # Example usage of class Item and VendingMachine # Initialize items item1 = Item(\\"A1\\", 1.25, 10) item2 = Item(\\"B2\\", 2.0, 5) item3 = Item(\\"C3\\", 2.5, 2) # Initialize vending machine and add items vending_machine = VendingMachine() vending_machine.add_item(item1) vending_machine.add_item(item2) vending_machine.add_item(item3) # Purchase items print(vending_machine.purchase_item(\\"A1\\", 1.50)) # Output: \\"Item dispensed. Change: 0.25\\" print(vending_machine.purchase_item(\\"B2\\", 1.0)) # Output: \\"Insufficient money. Please insert 1.00 more.\\" print(vending_machine.purchase_item(\\"C3\\", 2.5)) # Output: \\"Item dispensed. No change.\\" print(vending_machine.purchase_item(\\"C3\\", 2.5)) # Output: \\"Item dispensed. No change.\\" print(vending_machine.purchase_item(\\"C3\\", 2.5)) # Output: \\"Item out of stock.\\" print(vending_machine.purchase_item(\\"D4\\", 1.0)) # Output: \\"Invalid code.\\" ``` # Constraints * The input price for items will be in the range of [0.0, 100.0]. * The input quantity will be in the range of [1, 100]. * The money provided for purchasing items will be in the range of [0.0, 1000.0]. * The item code will be a non-empty string. * Handling of fractional values for prices and change must be precise up to two decimal places. * All inputs will be valid per the given types; additional validations for non-type constraints must be implemented within the methods. Implement these classes in Python, ensuring correctness and proper object-oriented practices.","solution":"class Item: def __init__(self, code: str, price: float, quantity: int): self.code = code self.price = price self.quantity = quantity class VendingMachine: def __init__(self): self.catalog = {} def add_item(self, item: Item) -> None: if item.code in self.catalog: self.catalog[item.code].quantity += item.quantity else: self.catalog[item.code] = item def purchase_item(self, code: str, money: float) -> str: if code not in self.catalog: return \\"Invalid code.\\" item = self.catalog[code] if item.quantity <= 0: return \\"Item out of stock.\\" if money < item.price: return f\\"Insufficient money. Please insert {item.price - money:.2f} more.\\" change = money - item.price item.quantity -= 1 if change > 0: return f\\"Item dispensed. Change: {change:.2f}\\" else: return \\"Item dispensed. No change.\\""},{"question":"# Problem Statement: You are a software engineer at a company that specializes in cryptographic applications. One of your tasks involves creating secure communication channels. A common practice in cryptography is to use prime numbers. For this task, you need to generate prime numbers efficiently. Your task is to write a function `nth_prime(n: int) -> int` that returns the nth prime number. Function Signature: ```python def nth_prime(n: int) -> int: ``` Input: * An integer `n` where `1 <= n <= 1000`. Output: * Return an integer which is the nth prime number. Constraints: * The input `n` will always be an integer between 1 and 1000, inclusive. Example: ```python assert nth_prime(1) == 2 # The 1st prime number is 2 assert nth_prime(10) == 29 # The 10th prime number is 29 assert nth_prime(100) == 541 # The 100th prime number is 541 ``` Requirements: * **Edge Cases Handling**: Ensure to handle inputs such as 1 and very high `n` values efficiently. * **Performance**: The function should be able to efficiently calculate prime numbers up to the 1000th prime without excessive computational overhead. Additional Notes: * You may use the Sieve of Eratosthenes or any other efficient prime number generation algorithm. * Pythonâ€™s inherent capability to handle large integers should be utilized appropriately for computations involving large values.","solution":"def nth_prime(n: int) -> int: Returns the nth prime number. # To ensure optimal performance, we use the Sieve of Eratosthenes algorithm # First, we need an upper bound for the nth prime number. # For simplicity and to avoid repeatedly estimating the bound, we might overshoot and sieve more numbers. # The 1000th prime is less than 10000, we will use that as our bound. limit = 10000 # This is more than enough for our needs sieve = [True] * limit sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers p = 2 while (p * p < limit): if sieve[p] is True: for i in range(p * p, limit, p): sieve[i] = False p += 1 # Collecting primes up to the limit primes = [p for p in range(limit) if sieve[p] is True] return primes[n - 1]"},{"question":"# Coding Assessment Question: In a web application, managing user authentication and minimizing login attempts is crucial for security reasons. Your task is to enhance the login management system by implementing a `LoginManager` class. This class should handle user login attempts, store login timestamps, and enforce a login rate limit to prevent brute-force attacks. Objectives: 1. **Rate Limiting**: Implement a mechanism to restrict users to a maximum of 5 login attempts within a 5-minute window. 2. **Tracking Timestamps**: The `LoginManager` should track timestamps of each login attempt per user to assess the rate limit. 3. **Clearing Old Attempts**: Ensure the system only considers login attempts within the last 5 minutes for the rate limit, removing older attempts appropriately. 4. **User Lockout**: Add a method to check if a user is locked out due to exceeding the rate limit, and another method to attempt a login which updates the login attempts accordingly. Function Specification: * **Expected Input and Output Formats**: - **Input**: A username as a string for login-related methods. - **Output**: A boolean indicating success or failure of login attempts and rate limit status. * **Constraints and Limitations**: - Assume valid strings for usernames. - Handle cases where users may not exist in the login attempt records yet. * **Performance Requirements**: Efficiently handle multiple login attempts across various users, ensuring the rate limit logic is scalable. Implementation Requirements: 1. The `LoginManager` class should include: - A method `attempt_login(username: str) -> bool` which: - Returns `True` if the login attempt is allowed. - Returns `False` if the user is locked out due to exceeding the login attempt rate limit. - Updates the login attempt timestamp for the user. - A method `is_locked_out(username: str) -> bool` which: - Returns `True` if the user has exceeded the allowed login attempts within the last 5 minutes. - Returns `False` otherwise. 2. Ensure the class keeps the timestamps clean and only retains relevant timestamps within the 5-minute window. 3. Include appropriate error handling and logging for debugging purposes. Function Signature: ```python import time from collections import deque from typing import Dict, Deque class LoginManager: def __init__(self): self.login_attempts: Dict[str, Deque[float]] = {} def attempt_login(self, username: str) -> bool: Handle a login attempt for a given user. # Implementation goes here. def is_locked_out(self, username: str) -> bool: Check if a user is locked out based on rate limiting. # Implementation goes here. ``` # Example Usage: ```python # Initialize the class login_manager = LoginManager() # Simulate login attempts print(login_manager.attempt_login(\\"john_doe\\")) # True print(login_manager.attempt_login(\\"john_doe\\")) # True print(login_manager.attempt_login(\\"john_doe\\")) # True print(login_manager.attempt_login(\\"john_doe\\")) # True print(login_manager.attempt_login(\\"john_doe\\")) # True print(login_manager.is_locked_out(\\"john_doe\\")) # False or True depending on timing of attempts print(login_manager.attempt_login(\\"john_doe\\")) # False if attempts are within 5 mins ``` Ensure your implementation is robust, efficient, and handles various edge cases. Include appropriate documentation and comments for clarity.","solution":"import time from collections import deque from typing import Dict, Deque class LoginManager: def __init__(self): self.login_attempts: Dict[str, Deque[float]] = {} self.MAX_ATTEMPTS = 5 self.TIME_WINDOW = 300 # 5 minutes in seconds def attempt_login(self, username: str) -> bool: current_time = time.time() if username not in self.login_attempts: self.login_attempts[username] = deque() # Clean up old attempts self._cleanup_old_attempts(username, current_time) if len(self.login_attempts[username]) >= self.MAX_ATTEMPTS: return False self.login_attempts[username].append(current_time) return True def is_locked_out(self, username: str) -> bool: current_time = time.time() if username not in self.login_attempts: return False # Clean up old attempts self._cleanup_old_attempts(username, current_time) return len(self.login_attempts[username]) >= self.MAX_ATTEMPTS def _cleanup_old_attempts(self, username: str, current_time: float): window_start = current_time - self.TIME_WINDOW while self.login_attempts[username] and self.login_attempts[username][0] < window_start: self.login_attempts[username].popleft()"},{"question":"# Sales Data Analysis Task You are tasked with enhancing a basic sales data analysis script written in Python. The current implementation fetches sales data from a CSV file, processes it, and calculates total sales per product. Your goal is to improve the reliability and performance of the script by addressing its weaknesses and implementing additional features. # Requirements 1. **Function Implementation**: Create a function `get_sales_summary(file_path: str) -> dict` that: * Takes the path to a CSV file containing sales data as input. * Returns a dictionary with product names as keys and total sales as values. * Handles cases where the CSV file may be large, ensuring efficient memory usage. 2. **Error Handling**: * Gracefully handles file I/O errors, CSV parsing errors, and missing data. * Logs meaningful error messages to help debug issues. 3. **Performance Optimization**: Ensure the script can efficiently handle large CSV files by reading them in chunks. 4. **Testing and Validation**: * Provide a set of test cases to validate your function. * Ensure your function can handle edge cases such as missing columns, empty files, and large datasets. # Scenario Context A retail company wants to quickly summarize their sales data at the end of each day. They require a reliable and efficient script that can handle large amounts of data and provide a clear summary of total sales per product. # Input and Output * Input: Path to the CSV file containing sales data. * Output: Dictionary with product names as keys and total sales as values or an appropriate error message. # Constraints * The CSV file has the columns `product_name` and `sales`. * Ensure minimal memory usage for large file processing. ```python import csv import logging # Function to enhance def get_sales_summary(file_path: str) -> dict: Reads sales data from CSV and returns a summary of total sales per product. :param file_path: Path to the CSV file containing sales data :return: Dictionary with product names as keys and total sales as values sales_summary = {} try: with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) if \'product_name\' not in reader.fieldnames or \'sales\' not in reader.fieldnames: raise ValueError(\\"CSV file must contain \'product_name\' and \'sales\' columns.\\") for row in reader: try: product_name = row[\'product_name\'] sales = float(row[\'sales\']) if product_name in sales_summary: sales_summary[product_name] += sales else: sales_summary[product_name] = sales except ValueError: logging.error(f\\"Skipping invalid row: {row}\\") return sales_summary except FileNotFoundError: raise Exception(f\\"The file at {file_path} was not found.\\") except Exception as e: logging.error(f\\"Error processing file {file_path}: {e}\\") raise if __name__ == \\"__main__\\": file_path = input(\\"Enter the path to the sales CSV file: \\").strip() try: summary = get_sales_summary(file_path) for product, total_sales in summary.items(): print(f\\"Product: {product}, Total Sales: {total_sales}\\") print(\\"Sales summary completed.\\") except Exception as e: print(f\\"Failed to generate sales summary: {e}\\") ```","solution":"import csv import logging logging.basicConfig(level=logging.ERROR) def get_sales_summary(file_path: str) -> dict: Reads sales data from CSV and returns a summary of total sales per product. :param file_path: Path to the CSV file containing sales data :return: Dictionary with product names as keys and total sales as values sales_summary = {} try: with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) # Validate necessary columns if \'product_name\' not in reader.fieldnames or \'sales\' not in reader.fieldnames: raise ValueError(\\"CSV file must contain \'product_name\' and \'sales\' columns.\\") for row in reader: # Skip rows with missing data if not row[\'product_name\'] or not row[\'sales\']: logging.error(f\\"Skipping incomplete row: {row}\\") continue try: product_name = row[\'product_name\'] sales = float(row[\'sales\']) if product_name in sales_summary: sales_summary[product_name] += sales else: sales_summary[product_name] = sales except ValueError: logging.error(f\\"Skipping invalid row: {row}\\") return sales_summary except FileNotFoundError: logging.error(f\\"The file at {file_path} was not found.\\") return {\\"error\\": \\"File not found\\"} except Exception as e: logging.error(f\\"Error processing file {file_path}: {e}\\") return {\\"error\\": str(e)}"},{"question":"# Problem Statement You are to design and implement a CustomSet data structure that supports various set operations efficiently. The CustomSet should be able to handle integers and provide dynamic resizing capabilities. Implement the `CustomSet` class with the following methods: 1. **`__init__`**: - Initialize an empty CustomSet. 2. **`add`**: - Add an integer to the set. If the integer is already present, it should not be added again. 3. **`remove`**: - Remove an integer from the set if it exists. Raise an error if the integer is not found in the set. 4. **`contains`**: - Check if a specific integer is in the set. Return `True` if it exists, otherwise return `False`. 5. **`union`**: - Return a new CustomSet that is the union of the current set and another CustomSet. 6. **`intersection`**: - Return a new CustomSet that is the intersection of the current set and another CustomSet. 7. **`difference`**: - Return a new CustomSet that represents the difference between the current set and another CustomSet. # Requirements - For each method, provide thorough unit tests to confirm correctness, including edge cases. - Ensure to handle dynamic resizing when the set grows or shrinks during `add` and `remove` operations. - Implement the set operations (`union`, `intersection`, and `difference`) efficiently. - The `add`, `remove`, and `contains` operations should be O(1) on average. - Avoid using Python\'s built-in set type for the implementation. # Example Usage ```python my_set = CustomSet() my_set.add(1) my_set.add(2) my_set.add(3) assert my_set.contains(2) == True my_set.remove(2) assert my_set.contains(2) == False other_set = CustomSet() other_set.add(3) other_set.add(4) union_set = my_set.union(other_set) assert union_set.contains(1) == True assert union_set.contains(3) == True assert union_set.contains(4) == True intersection_set = my_set.intersection(other_set) assert intersection_set.contains(1) == False assert intersection_set.contains(3) == True assert intersection_set.contains(4) == False difference_set = my_set.difference(other_set) assert difference_set.contains(1) == True assert difference_set.contains(3) == False assert difference_set.contains(4) == False ```","solution":"class CustomSet: def __init__(self): self.data = {} def add(self, value): self.data[value] = True def remove(self, value): if value in self.data: del self.data[value] else: raise KeyError(\\"Value not found in set\\") def contains(self, value): return value in self.data def union(self, other_set): result = CustomSet() for value in self.data: result.add(value) for value in other_set.data: result.add(value) return result def intersection(self, other_set): result = CustomSet() for value in self.data: if value in other_set.data: result.add(value) return result def difference(self, other_set): result = CustomSet() for value in self.data: if value not in other_set.data: result.add(value) return result"},{"question":"Binary Search Tree - Inorder Predecessor Fix You are given the task of improving the given `bst_operations.py` code, which implements various operations on a Binary Search Tree (BST). Your focus is to optimize the process of finding the inorder predecessor of a node in the BST. Problem Statement Write a function that finds the inorder predecessor of a given node in a Binary Search Tree. The inorder predecessor of a node is the previous node in the inorder traversal of the BST. # Function Signature ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_inorder_predecessor(root, node): Find the inorder predecessor of a given node in the BST. :param root: The root of the BST. :param node: The node for which the predecessor is to be found. :return: The inorder predecessor node. pass ``` # Requirements 1. **Function Implementation**: Implement the `find_inorder_predecessor` function. It should take the root of the BST and the node for which the inorder predecessor is to be found. 2. **Correctness**: Ensure that the function correctly identifies and returns the inorder predecessor node in the BST. 3. **Efficiency**: Your solution should be efficient in terms of time complexity. # Input - `root`: Root node of the BST. - `node`: The target node for which the inorder predecessor is to be found. Example Input ```python # Construct the BST as shown in the example # 20 # / # 10 30 # / # 5 15 # # 17 root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) root.left.right.right = TreeNode(17) # Target node is 15 target = root.left.right ``` # Output - Return the node representing the inorder predecessor of the target node. Example Output ```python # The inorder predecessor of node 15 is node 10 predecessor_node = root.left ``` # Constraints - The number of nodes in the BST will be at most 10,000. - All node values are unique and will fit within the range of a 32-bit signed integer. - Node input to the function is guaranteed to be in the BST. # Note 1. If the node has a left child, its predecessor is the rightmost node of its left subtree. 2. If the node does not have a left child, its predecessor is one of its ancestors. 3. The function should return `None` if the target node does not have an inorder predecessor (e.g., the smallest node in the BST).","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_inorder_predecessor(root, node): Find the inorder predecessor of a given node in the BST. :param root: The root of the BST. :param node: The node for which the predecessor is to be found. :return: The inorder predecessor node. predecessor = None if node.left: # Find the rightmost node in the left subtree predecessor = node.left while predecessor.right: predecessor = predecessor.right return predecessor # Otherwise, traverse from the root, look for the deepest ancestor for which node is in right subtree current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: break return predecessor"},{"question":"# Coding Assessment Question Context You are working as a software engineer and have been tasked with enhancing a web application by implementing various utility functions. One particularly critical function you need to implement is to ensure the validity of user-entered dates within the application. Task Your task is to write a function called **validate_date** that validates a given date string. The function needs to check if the given date string adheres to the expected format and falls within an acceptable date range. # Input and Output Specifications * **Function Signature:** ```python def validate_date(date_str: str) -> bool: ``` * **Input:** - `date_str`: A string representing a date in the format \\"YYYY-MM-DD\\". * **Output:** - The function should return a boolean value: `True` if the date is valid, and `False` if the date is invalid. # Example *Given the following date strings:* ```python print(validate_date(\\"2023-10-25\\")) # True print(validate_date(\\"2023-02-29\\")) # False (2023 is not a leap year) print(validate_date(\\"2021-13-01\\")) # False (invalid month) print(validate_date(\\"not-a-date\\")) # False (invalid format) print(validate_date(\\"2000-02-29\\")) # True (2000 is a leap year) ``` *Expected Output:* ``` True False False False True ``` # Constraints 1. The date must follow the \\"YYYY-MM-DD\\" format strictly (4 digits for the year, 2 digits for the month, and 2 digits for the day). 2. The date must be a valid Gregorian calendar date. 3. Consider leap years in your validation: - A year is a leap year if it is divisible by 4 but not by 100, or it is divisible by 400. 4. Years within the range 1900-9999 are considered valid.","solution":"from datetime import datetime def validate_date(date_str: str) -> bool: Validates a given date string in the format \\"YYYY-MM-DD\\". Parameters: date_str (str): The date string to validate. Returns: bool: True if the date is valid, False otherwise. try: date = datetime.strptime(date_str, \'%Y-%m-%d\') if 1900 <= date.year <= 9999: return True else: return False except ValueError: return False"},{"question":"# Analyzing Web Server Logs Scenario: You are responsible for maintaining server health and performance. One of your tasks includes analyzing the server logs to determine the amount of traffic and to identify any potential issues. The server logs are in a standard format where each log entry contains a timestamp, HTTP method, resource requested, and a response code. Task: Write a Python function `analyze_server_logs(log_file_path: str) -> Dict[str, Union[int, Dict[str, int]]]` to analyze the log file and return a summary of the log data. The summary should include the total number of requests, a count of each type of HTTP method, and a count of each unique HTTP response code. Requirements: 1. Read the log file line by line. 2. Parse each log entry to extract the HTTP method and response code. 3. Maintain counts of each HTTP method and each response code. 4. Construct a summary of the total number of requests, counts of HTTP methods, and counts of response codes. 5. The summary should be returned as a dictionary. # Function Signature ```python def analyze_server_logs(log_file_path: str) -> Dict[str, Union[int, Dict[str, int]]]: pass ``` Input * `log_file_path`: A string representing the path to the log file (e.g., `/var/log/server.log`). Constraints * The log file size could be large, so the function should handle it efficiently without loading the entire file into memory. * The log format is assumed to be consistent and well-formed. Output * Returns a dictionary with the following structure: ```python { \\"total_requests\\": int, \\"methods\\": { \\"GET\\": int, \\"POST\\": int, \\"PUT\\": int, \\"DELETE\\": int, \\"other\\": int }, \\"response_codes\\": { \\"200\\": int, \\"404\\": int, ... } } ``` Example Assume the log file contains the following entries: ``` 2023-01-01T13:23:45 GET /index.html 200 2023-01-01T13:24:01 POST /form 404 2023-01-01T13:25:12 GET /images/logo.png 200 ``` The returned dictionary should be: ```python { \\"total_requests\\": 3, \\"methods\\": { \\"GET\\": 2, \\"POST\\": 1, \\"PUT\\": 0, \\"DELETE\\": 0, \\"other\\": 0 }, \\"response_codes\\": { \\"200\\": 2, \\"404\\": 1 } } ``` Notes * You may assume the log entries are well-formed and space-separated. * Efficient file processing techniques should be used to handle large log files. * Ensure proper error handling for file reading operations and invalid log entries.","solution":"from typing import Dict, Union import collections def analyze_server_logs(log_file_path: str) -> Dict[str, Union[int, Dict[str, int]]]: summary = { \\"total_requests\\": 0, \\"methods\\": { \\"GET\\": 0, \\"POST\\": 0, \\"PUT\\": 0, \\"DELETE\\": 0, \\"other\\": 0, }, \\"response_codes\\": collections.defaultdict(int) } with open(log_file_path, \'r\') as log_file: for line in log_file: parts = line.strip().split() if len(parts) != 4: continue _, method, _, response_code = parts summary[\\"total_requests\\"] += 1 if method in summary[\\"methods\\"]: summary[\\"methods\\"][method] += 1 else: summary[\\"methods\\"][\\"other\\"] += 1 summary[\\"response_codes\\"][response_code] += 1 # Convert defaultdict to a regular dict for the response codes summary[\\"response_codes\\"] = dict(summary[\\"response_codes\\"]) return summary"},{"question":"# Scenario: You are working on a filtering feature for an e-commerce application. The application presents users with a list of product names, and you need to implement a function that categorizes these products based on specific criteria. The function should be able to detect product names with numbers, special characters such as `!@#%^&*()-+=`, and names longer than a certain length. Additionally, it should flag names that do not start with an alphabetical character. # Task: Implement a Python function `categorize_product_names(product_names: List[str], max_length: int) -> Dict[str, List[str]]` that: 1. Accepts a list of product names and a maximum length integer. 2. Validates each product name according to the following rules: - **Numbers Check**: Names with numbers. - **Special Characters Check**: Names with special characters (`!@#%^&*()-+=`). - **Length Check**: Names longer than the specified maximum length. - **Non-Alphabet Start Check**: Names that do not start with an alphabetical character. 3. Returns a dictionary where the keys are the check names (`\\"numbers\\"`, `\\"special_characters\\"`, `\\"length\\"`, `\\"non_alphabet_start\\"`) and the values are lists of product names that fail the respective checks. # Input: - `product_names` (List[str]): A list of product name strings. - `max_length` (int): An integer specifying the maximum acceptable length for product names. # Output: - (Dict[str, List[str]]): A dictionary with lists of product names that fail each of the checks. # Constraints: - The product names will be non-empty strings. - Each product name may contain any printable character except the null character. - The maximum length will be a positive integer. # Example: ```python product_names = [ \\"Product1\\", \\"Pro@duct\\", \\"GoodProduct\\", \\"VeryVeryLongProductName\\", \\"2ndItem\\", \\"item#2\\", \\"item_Profile!\\" ] max_length = 15 result = categorize_product_names(product_names, max_length) # Expected result: # { # \\"numbers\\": [\\"Product1\\", \\"2ndItem\\", \\"item#2\\"], # \\"special_characters\\": [\\"Pro@duct\\", \\"item#2\\", \\"item_Profile!\\"], # \\"length\\": [\\"VeryVeryLongProductName\\"], # \\"non_alphabet_start\\": [\\"2ndItem\\"] # } ``` # Notes: - Ensure that your function handles edge cases gracefully. - Test your implementation with varying lengths of product names, different sets of characters, and different maximum length limits.","solution":"import re from typing import List, Dict def categorize_product_names(product_names: List[str], max_length: int) -> Dict[str, List[str]]: Categorizes product names based on the given criteria: - Contain numbers - Contain special characters - Exceed the given maximum length - Do not start with an alphabetical character Args: - product_names (List[str]): List of product name strings. - max_length (int): Maximum acceptable length for product names. Returns: - Dict[str, List[str]]: Dictionary with lists of product names that fail each of the checks. categories = { \\"numbers\\": [], \\"special_characters\\": [], \\"length\\": [], \\"non_alphabet_start\\": [] } for name in product_names: if re.search(r\'d\', name): categories[\\"numbers\\"].append(name) if re.search(r\'[!@#%^&*()-=+]\', name): categories[\\"special_characters\\"].append(name) if len(name) > max_length: categories[\\"length\\"].append(name) if not name[0].isalpha(): categories[\\"non_alphabet_start\\"].append(name) return categories"},{"question":"# Course Enrollment Management You are the administrator of a university\'s course management system. You need to develop a function that helps add students to courses while ensuring that the enrollment does not exceed the course capacity and preventing duplicate enrollments. **Objective:** Write a Python function that adds a student to a course if the course has not reached its full capacity and the student is not already enrolled in the course. # Function Signature Requirements: ```python def enroll_student( students: dict, student_name: str, course_name: str, max_capacity: int ) -> str: ``` # Parameters: 1. **students**: (dict) A dictionary where keys are student names and values are sets of courses they are enrolled in. 2. **student_name**: (str) The name of the student to be enrolled. 3. **course_name**: (str) The name of the course to enroll the student in. 4. **max_capacity**: (int) The maximum capacity of the course. # Returns: - A string message indicating whether the enrollment was successful or not. # Constraints: - All input strings (`student_name`, `course_name`) are non-empty. - The `max_capacity` is a positive integer. - Ensure to handle invalid inputs by raising a `ValueError` with a suitable error message. # Examples: ```python >>> students = {\\"John\\": {\\"Math\\", \\"Science\\"}, \\"Jane\\": {\\"English\\"}} >>> enroll_student(students, \\"John\\", \\"History\\", 3) \'John has been enrolled in History.\' >>> students {\'John\': {\'Math\', \'Science\', \'History\'}, \'Jane\': {\'English\'}} >>> enroll_student(students, \\"John\\", \\"History\\", 3) \'John is already enrolled in History.\' >>> enroll_student(students, \\"Mike\\", \\"Math\\", 1) \'Math has reached its capacity and cannot accept more students.\' >>> enroll_student(students, \\"Jane\\", \\"Science\\", 2) \'Jane has been enrolled in Science.\' >>> students {\'John\': {\'Math\', \'Science\', \'History\'}, \'Jane\': {\'English\', \'Science\'}} ``` **Hint:** Use dictionary and set operations to manage enrollments and check capacities. Iterate over the existing enrollments to ensure the course capacity is not exceeded. # Solution: 1. Verify the validity of the input parameters, raising a `ValueError` in case of any invalid input. 2. Check if the student is already enrolled in the course. 3. Ensure the course does not exceed its maximum capacity. 4. Update the students\' dictionary with the new enrollment if all checks pass. 5. Return appropriate success or error messages based on the operations performed. Implement and test your function to ensure that it handles various scenarios, including edge cases, efficiently and correctly.","solution":"def enroll_student(students, student_name, course_name, max_capacity): Enroll a student to a course if the course has not reached its full capacity and the student is not already enrolled in the course. Parameters: - students (dict): A dictionary where keys are student names and values are sets of courses they are enrolled in. - student_name (str): The name of the student to be enrolled. - course_name (str): The name of the course to enroll the student in. - max_capacity (int): The maximum capacity of the course. Returns: - str: A message indicating whether the enrollment was successful or not. Raises: - ValueError: If input parameters are invalid. # Validate input parameters if not isinstance(students, dict) or not all(isinstance(v, set) for v in students.values()): raise ValueError(\\"students must be a dictionary with sets as values\\") if not isinstance(student_name, str) or not student_name: raise ValueError(\\"student_name must be a non-empty string\\") if not isinstance(course_name, str) or not course_name: raise ValueError(\\"course_name must be a non-empty string\\") if not isinstance(max_capacity, int) or max_capacity <= 0: raise ValueError(\\"max_capacity must be a positive integer\\") # Check if student is already enrolled in the course if student_name in students and course_name in students[student_name]: return f\\"{student_name} is already enrolled in {course_name}.\\" # Check the course capacity across all students enrolled_count = sum(1 for courses in students.values() if course_name in courses) if enrolled_count >= max_capacity: return f\\"{course_name} has reached its capacity and cannot accept more students.\\" # Enroll student in the course if student_name not in students: students[student_name] = set() students[student_name].add(course_name) return f\\"{student_name} has been enrolled in {course_name}.\\""},{"question":"# Coding Assessment Question Scenario Your team is working on a network traffic analysis tool. One feature of this tool is to identify specific patterns in network packets. Each packet is represented as a string of characters, and certain characters are designated as \\"flag characters\\" used to identify special patterns or markers within the packet. You need to implement a function that checks for the presence of a sequence of flag characters within a given packet. The sequence must be contiguous within the packet, and the function should return the starting index of the first occurrence of the sequence if it is found. If the sequence is not found, the function should return -1. Function Definition Write a function `find_flag_sequence(packet: str, flags: str) -> int` that takes two strings: `packet` (the network packet) and `flags` (the sequence of flag characters). The function returns the starting index of the first occurrence of the flag sequence in the packet, or -1 if the sequence is not present. Input * `packet` (str): String representing the network packet (length <= 10000). * `flags` (str): String representing the sequence of flag characters (length <= 100). Output * (int): The starting index of the first occurrence of the flag sequence in the packet, or -1 if the sequence is not present. Example ```python >>> find_flag_sequence(\\"a1b2c3d4e5f6\\", \\"c3d\\") 4 >>> find_flag_sequence(\\"a1b2c3d4e5f6\\", \\"d5f\\") -1 ``` Constraints * Both `packet` and `flags` will only contain alphanumeric characters. * Case sensitivity is enforced (i.e., \'a\' is different from \'A\'). Performance Requirements Your solution should efficiently handle packets up to the maximum length constraint (up to 10000 characters). Edge Cases to Consider * If the `packet` is shorter than the `flags` sequence, the result should be -1. * Large input sizes should be processed efficiently within reasonable time and space complexity.","solution":"def find_flag_sequence(packet: str, flags: str) -> int: Returns the starting index of the first occurrence of the flag sequence in the packet. If the sequence is not found, returns -1. packet_len = len(packet) flags_len = len(flags) # If the packet is shorter than the flag sequence, return -1 if packet_len < flags_len: return -1 # Iterate through the packet to find the flag sequence for i in range(packet_len - flags_len + 1): if packet[i:i + flags_len] == flags: return i # If no match is found, return -1 return -1"},{"question":"# Repeated String Analysis You are given a file containing a single string of lowercase characters \'a\' and \'b\'. Your task is to determine the number of occurrences of the substring \\"ab\\" within a repeated version of the string such that the repeated string length is exactly `n`. # Task Write a function `count_ab_repeats(file_path: str, n: int)` that reads the initial string from a given file, constructs a new string by repeating it until its length is exactly `n`, and then returns the number of times the substring \\"ab\\" appears in this new string. # Input * `file_path`: A string representing the file path containing a single string. * `n`: An integer representing the length of the repeated string (1 â‰¤ n â‰¤ 10^6). # Output * The function should return an integer representing the number of times \\"ab\\" appears in the repeated string of length `n`. # Constraints 1. The file is properly formatted and contains only lowercase alphabetical characters \'a\' and \'b\'. 2. The initial string length will be at most 1000. # Example Assume the file input.txt contains: ```text abab ``` and `n = 10`. Explanation: After repeating the string to length 10, we get \\"ababababab\\". The substring \\"ab\\" appears 5 times. **Function signature:** ```python def count_ab_repeats(file_path: str, n: int) -> int: pass ```","solution":"def count_ab_repeats(file_path: str, n: int) -> int: Reads a string from the specified file, repeats it to length n, and counts occurrences of the substring \'ab\' in the repeated string. with open(file_path, \'r\') as file: initial_string = file.read().strip() repeat_len = len(initial_string) repeat_count = n // repeat_len remainder = n % repeat_len repeated_string = initial_string * repeat_count + initial_string[:remainder] count_ab = 0 for i in range(len(repeated_string) - 1): if repeated_string[i:i+2] == \\"ab\\": count_ab += 1 return count_ab"},{"question":"# Question: Detect and Remove Cycles in a Directed Graph You are given a directed graph with `n` nodes and `m` edges. Your task is to detect all the cycles in the graph and remove enough edges so that the graph becomes acyclic. Implement the function `remove_cycles(n: int, edges: list[tuple[int, int]]) -> list[tuple[int, int]]`, which takes the number of nodes `n` and a list of edges `edges`, where each edge is represented as a tuple `(u, v)`, indicating a directed edge from node `u` to node `v`. Input: - `n` (1 â‰¤ n â‰¤ 100000): The number of nodes. - `edges` (0 â‰¤ len(edges) â‰¤ 200000): A list of tuples representing directed edges in the graph. Output: - A list of tuples, where each tuple represents an edge that needs to be removed to transform the graph into an acyclic graph. If there are multiple solutions, any valid solution is acceptable. # Constraints: - Nodes are indexed from `0` to `n-1`. - All nodes and edges are valid and properly formatted. # Examples: Example 1: **Input**: ```python n = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] ``` **Output**: ```python [(2, 0)] ``` Example 2: **Input**: ```python n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] ``` **Output**: ```python [(3, 1)] ``` # Notes: - If there are no cycles in the graph, return an empty list. - The order of edges in the output does not matter. - Ensure your function handles all possible edge cases efficiently. # Function Signature: ```python def remove_cycles(n: int, edges: list[tuple[int, int]]) -> list[tuple[int, int]]: pass ```","solution":"def remove_cycles(n: int, edges: list[tuple[int, int]]) -> list[tuple[int, int]]: from collections import defaultdict def dfs(node, visited, stack, parent, removed_edges): visited[node] = 1 stack[node] = 1 for neighbor in adj_list[node]: if not visited[neighbor]: if dfs(neighbor, visited, stack, node, removed_edges): return True elif stack[neighbor]: removed_edges.append((node, neighbor)) return True stack[node] = 0 return False # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) visited = [0] * n stack = [0] * n removed_edges = [] for node in range(n): if not visited[node]: if dfs(node, visited, stack, -1, removed_edges): break return removed_edges"},{"question":"# Coding Assessment Question: Unique Email Address Checker You are given a list of email addresses stored in a file. Your task is to write a function that reads this file, processes each email such that it adheres to specific normalization rules, and determines the number of unique email addresses in the file after normalization. For the purposes of this task, an email address consists of two main parts separated by an \'@\' symbol: the local part and the domain part. The normalization rules to be applied are: 1. In the local part, any \'.\' (dot) characters should be removed. 2. In the local part, any characters after a \'+\' (plus) character should be ignored. The \'+\' and the characters following it should not appear in the normalized version. The domain part of the email should remain unchanged. Requirements: 1. **Function Name**: `unique_email_checker` 2. **Input**: - `filename`: The name of the file containing the email addresses (string). 3. **Output**: - An integer representing the number of unique email addresses after normalization. 4. **Performance**: Ensure the function is efficient in both time and space complexity. # Function Signature ```python def unique_email_checker(filename: str) -> int: pass ``` # Constraints: - Assume each line in the file contains a single valid email address. - The file is not empty and contains at least one email address. # Example Suppose the input file `emails.txt` contains the following email addresses: ``` test.email+alex@leetcode.com test.e.mail+bob.cathy@leetcode.com testemail+david@lee.tcode.com ``` Calling `unique_email_checker(\'emails.txt\')` should return `2`. After normalization, the unique email addresses are: - `testemail@leetcode.com` - `testemail@lee.tcode.com` **Steps to Achieve the Solution**: 1. Read the email addresses from the file. 2. Normalize each email according to the rules specified. 3. Use a data structure to keep track of unique normalized emails. 4. Implement the `unique_email_checker` function to count and return the number of unique emails.","solution":"def unique_email_checker(filename: str) -> int: unique_emails = set() with open(filename, \'r\') as file: for line in file: email = line.strip() local, domain = email.split(\'@\') local = local.split(\'+\')[0].replace(\'.\', \'\') normalized_email = local + \'@\' + domain unique_emails.add(normalized_email) return len(unique_emails)"},{"question":"# Coding Assessment Question **Problem Statement:** You need to implement a system to manage a parking lot using a least recently used (LRU) cache to track and optimize the allocation of parking spaces. The parking lot is represented by a list of spaces, each initialized to `None` when empty. Your tasks will include adding a vehicle, removing a vehicle, and finding a vehicle. Requirements: 1. **LRU Cache-Based Allocation**: Implement a parking lot system using an LRU cache mechanism for the allocation of parking spaces. Use the `collections.OrderedDict` data structure to maintain the LRU cache. 2. **Methods**: - `park(vehicle_id: int) -> int`: Parks a vehicle in the least recently used (LRU) available space and returns the index of the parking space. If parking lot is full, the least recently used parked vehicle is removed to make space. - `leave(vehicle_id: int) -> bool`: Removes the vehicle with the given `vehicle_id` from the parking lot and returns `True` if the vehicle was successfully removed, `False` otherwise. - `find(vehicle_id: int) -> int | None`: Returns the index of the parking space where the vehicle with the given `vehicle_id` is parked, or `None` if the vehicle is not found. Constraints: - The parking lot will have at most `N` spaces. - `vehicle_id` is guaranteed to be unique. Input: - A positive integer `N` representing the number of parking spaces. - Sequence of operations on the parking system. Output: - Indices of the parked vehicles where applicable. - Boolean indicating success for removal operation. - Indices of parking spaces for `find` operation or `None`. Function Signature: ```python from collections import OrderedDict class ParkingLot: def __init__(self, size: int): self.size = size self.parking_spaces = [None] * size self.lru_cache = OrderedDict() def park(self, vehicle_id: int) -> int: ... def leave(self, vehicle_id: int) -> bool: ... def find(self, vehicle_id: int) -> int | None: ... # Example Usage: # parking_lot = ParkingLot(3) # print(parking_lot.park(101)) # Should print the allocated parking index # print(parking_lot.park(102)) # Should print the allocated parking index # print(parking_lot.find(101)) # Should print the index where 101 is parked # print(parking_lot.leave(101)) # Should print True # print(parking_lot.park(103)) # Should print the allocated parking index # print(parking_lot.park(104)) # Should print the allocated parking index replacing the LRU if full ``` --- **Example:** ```python from collections import OrderedDict class ParkingLot: def __init__(self, size: int): self.size = size self.parking_spaces = [None] * size self.lru_cache = OrderedDict() def park(self, vehicle_id: int) -> int: if len(self.lru_cache) >= self.size: lru_vehicle = next(iter(self.lru_cache)) lru_index = self.lru_cache.pop(lru_vehicle) self.parking_spaces[lru_index] = None free_index = self.parking_spaces.index(None) self.parking_spaces[free_index] = vehicle_id self.lru_cache[vehicle_id] = free_index return free_index def leave(self, vehicle_id: int) -> bool: if vehicle_id in self.lru_cache: leave_index = self.lru_cache.pop(vehicle_id) self.parking_spaces[leave_index] = None return True return False def find(self, vehicle_id: int) -> int | None: if vehicle_id in self.lru_cache: return self.lru_cache[vehicle_id] return None # Test Case parking_lot = ParkingLot(3) assert parking_lot.park(101) == 0 assert parking_lot.park(102) == 1 assert parking_lot.find(101) == 0 assert parking_lot.leave(101) == True assert parking_lot.park(103) == 0 assert parking_lot.park(104) == 2 assert parking_lot.park(105) == 1 # This should remove vehicle 102 as it\'s the LRU assert parking_lot.find(102) == None ``` Create and manage a parking lot system effectively using the LRU cache mechanism to optimize space utilization, and ensure efficient vehicle parking management.","solution":"from collections import OrderedDict class ParkingLot: def __init__(self, size: int): self.size = size self.parking_spaces = [None] * size self.lru_cache = OrderedDict() def park(self, vehicle_id: int) -> int: if len(self.lru_cache) >= self.size: lru_vehicle = next(iter(self.lru_cache)) lru_index = self.lru_cache.pop(lru_vehicle) self.parking_spaces[lru_index] = None free_index = self.parking_spaces.index(None) self.parking_spaces[free_index] = vehicle_id self.lru_cache[vehicle_id] = free_index return free_index def leave(self, vehicle_id: int) -> bool: if vehicle_id in self.lru_cache: leave_index = self.lru_cache.pop(vehicle_id) self.parking_spaces[leave_index] = None return True return False def find(self, vehicle_id: int) -> int | None: if vehicle_id in self.lru_cache: return self.lru_cache[vehicle_id] return None"},{"question":"# Problem Statement **Scenario**: A hotel chain is looking to implement a booking system for their rooms. The hotel has a fixed number of rooms available, and each room can be booked for a specific date range. Each booking request contains a starting date and an ending date (both inclusive). You need to determine if a given booking request can be accommodated without any overlaps with the existing bookings. # Task Implement a function `can_book(room_bookings: List[Tuple[int, int]], new_booking: Tuple[int, int]) -> bool` that takes a list of existing bookings `room_bookings` and a new booking request `new_booking`. The function should return `True` if the new booking can be accommodated without overlapping any of the existing bookings, `False` otherwise. # Requirements * Validate the inputs to ensure they are in the correct format. * Efficiently determine if there is an overlap with existing bookings. # Function Signature ```python from typing import List, Tuple def can_book(room_bookings: List[Tuple[int, int]], new_booking: Tuple[int, int]) -> bool: Args: room_bookings (List[Tuple[int, int]]): List of existing bookings, each represented as a tuple (start_date, end_date). new_booking (Tuple[int, int]): New booking to be checked, represented as a tuple (start_date, end_date). Returns: bool: True if the new booking can be accommodated, False otherwise. Raises: ValueError: If inputs are in incorrect format or dates are invalid. ``` # Constraints * All dates are represented as integers denoting days (e.g., from day 1 to day 365). * Bookings are valid if start_date <= end_date. * The number of existing bookings will not exceed 10^4. # Example ```python # Example 1 assert can_book([(1, 3), (5, 8)], (2, 4)) == False # Example 2 assert can_book([(1, 3), (5, 8)], (3, 5)) == True # Example 3 assert can_book([(1, 3), (5, 8), (10, 15)], (6, 9)) == False ``` # Explanation In each example: - **Example 1**: The new booking (2, 4) overlaps with the existing booking (1, 3). - **Example 2**: The new booking (3, 5) does not overlap with the existing bookings as it starts exactly after one booking ends and ends exactly when another booking starts. - **Example 3**: The new booking (6, 9) overlaps with the existing booking (5, 8), thus it cannot be accommodated.","solution":"from typing import List, Tuple def can_book(room_bookings: List[Tuple[int, int]], new_booking: Tuple[int, int]) -> bool: Args: room_bookings (List[Tuple[int, int]]): List of existing bookings, each represented as a tuple (start_date, end_date). new_booking (Tuple[int, int]): New booking to be checked, represented as a tuple (start_date, end_date). Returns: bool: True if the new booking can be accommodated, False otherwise. Raises: ValueError: If inputs are in incorrect format or dates are invalid. # Validate input dates in room_bookings for start, end in room_bookings: if not isinstance(start, int) or not isinstance(end, int) or start > end: raise ValueError(\\"Invalid booking dates in room_bookings. Dates must be integers and start_date <= end_date.\\") # Validate input dates in new_booking new_start, new_end = new_booking if not isinstance(new_start, int) or not isinstance(new_end, int) or new_start > new_end: raise ValueError(\\"Invalid booking dates in new_booking. Dates must be integers and start_date <= end_date.\\") # Check if new booking overlaps with any existing booking for start, end in room_bookings: if max(new_start, start) <= min(new_end, end): return False return True"},{"question":"# Context You are developing an online search engine that needs to handle search queries in real time. One of the essential components is the autocomplete system, which should suggest possible completions based on current user input. This system must effectively manage and query a dynamic set of search terms as users frequently add new terms, and the data set can grow considerably large. # Task Using trie (prefix tree) data structure is ideal for this use case due to its efficient storage and lookup capabilities for strings. You need to implement a function that can: 1. Build a trie from an initial list of search terms. 2. Insert a new search term into the trie. 3. Retrieve all search terms with a given prefix from the trie. Implement the function with the following specifications: # Function Signature ```python def autocomplete_system(search_terms: list[str], new_term: str, prefix: str) -> list[str]: ``` # Input * `search_terms`: A list of strings representing the initial set of search terms. * `new_term`: A string representing the new search term to be added. * `prefix`: A string representing the prefix to search for possible completions. # Output * Returns a list of strings representing all possible search term completions for the given prefix from the updated set of search terms. # Constraints * The input list `search_terms` can have up to (10^5) elements. * Each string in the list and the new term will have up to (100) characters. * The prefix string will have up to (100) characters. * The characters in the strings are limited to lowercase English letters. # Example ```python search_terms = [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"] new_term = \\"heater\\" prefix = \\"he\\" print(autocomplete_system(search_terms, new_term, prefix)) # Output: [\'heaven\', \'heavy\', \'hell\', \'hello\', \'heater\'] search_terms = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"batch\\"] new_term = \\"batman\\" prefix = \\"ba\\" print(autocomplete_system(search_terms, new_term, prefix)) # Output: [\'banana\', \'bat\', \'batch\', \'batman\'] ``` # Note Ensure your function efficiently handles large input sizes and provides the correct output for various edge cases, such as when no terms match the prefix.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for ch in word: if ch not in node.children: node.children[ch] = TrieNode() node = node.children[ch] node.is_word = True def search(self, prefix): node = self.root for ch in prefix: if ch not in node.children: return [] node = node.children[ch] return self._collect_all_words_from(node, prefix) def _collect_all_words_from(self, node, prefix): words = [] if node.is_word: words.append(prefix) for ch, child in node.children.items(): words.extend(self._collect_all_words_from(child, prefix + ch)) return words def autocomplete_system(search_terms, new_term, prefix): trie = Trie() for term in search_terms: trie.insert(term) trie.insert(new_term) return trie.search(prefix)"},{"question":"# Binary Search Tree Operations Given a partially implemented binary search tree (BST) as demonstrated in the provided code snippet, complete the following tasks to showcase your comprehension of this data structure. Implement the requested methods and ensure they work as expected within the BST. Task 1: In-Order Traversal Implement a method `inorder_traversal()` in the `BST` class that prints the value of each node in in-order traversal (left, root, right). ```python def inorder_traversal(self) -> None: This function prints the data of the nodes in the BST in in-order traversal. >>> bst = BST() >>> for val in [4, 2, 6, 1, 3, 5, 7]: ... bst.insert(val) >>> bst.inorder_traversal() 1 2 3 4 5 6 7 ``` Task 2: Find Maximum Node Implement a method `find_max()` in the `BST` class that finds and returns the value of the maximum node in the BST. ```python def find_max(self) -> int: This function returns the value of the maximum node in the BST. >>> bst = BST() >>> for val in [4, 2, 6, 1, 3, 5, 7]: ... bst.insert(val) >>> bst.find_max() 7 ``` Task 3: Check if Balanced Implement a method `is_balanced()` in the `BST` class that checks if the BST is height-balanced. A binary tree is balanced if for every node, the height difference of its left and right subtrees is at most 1. ```python def is_balanced(self) -> bool: This function checks if the BST is balanced. Returns True if balanced, False otherwise. >>> bst = BST() >>> for val in [4, 2, 6, 1, 3, 5, 7]: ... bst.insert(val) >>> bst.is_balanced() True >>> bst.insert(8) >>> bst.insert(9) >>> bst.is_balanced() False ``` Input and Output * **Input**: * For inorder_traversal(): No input arguments. * For find_max(): No input arguments. * For is_balanced(): No input arguments. * **Output**: * For inorder_traversal(): Prints the values of the nodes in in-order traversal. * For find_max(): Returns an integer representing the maximum node\'s value. * For is_balanced(): Returns a boolean indicating if the BST is balanced or not. Ensure correctness and efficiency in your implementations. Consider edge cases like empty trees, trees with one element, etc.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def inorder_traversal(self): def _inorder_traversal(root): if root: _inorder_traversal(root.left) print(root.val, end=\' \') _inorder_traversal(root.right) _inorder_traversal(self.root) print() # for a newline at the end of the output def find_max(self): current = self.root while current.right: current = current.right return current.val def is_balanced(self): def _height(root): if root is None: return 0 left_height = _height(root.left) right_height = _height(root.right) return 1 + max(left_height, right_height) def _is_balanced(root): if root is None: return True left_height = _height(root.left) right_height = _height(root.right) if abs(left_height - right_height) > 1: return False return _is_balanced(root.left) and _is_balanced(root.right) return _is_balanced(self.root)"},{"question":"# Question: Parallel Processing of Large Datasets For a company dealing with large datasets, optimizing data processing time is crucial. One approach is to divide the workload among multiple processors executing in parallel. You are tasked with writing code to simulate such parallel processing and measure its effectiveness. Task 1: **Divide Data into Chunks** Write a function `chunk_data(data: List[int], num_chunks: int) -> List[List[int]]` that divides a list of integers (`data`) into `num_chunks` equal parts. If the data length is not perfectly divisible by the number of chunks, distribute the remainder items as evenly as possible among the chunks. Task 2: **Process Chunks in Parallel** Write a function `parallel_process(data: List[int], num_processors: int) -> List[int]` that simulates processing the data chunks in parallel. This function should: - Divide the data into `num_processors` chunks using the `chunk_data` function. - Process each chunk (e.g., sum up the integers in each chunk). - Return a list of results, where each result corresponds to the processing outcome of each chunk. # Input and Output Formats * **Task 1**: - **Input**: A list of integers and an integer representing the number of chunks (e.g., `chunk_data([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)`). - **Output**: A list of lists where each list represents a chunk. * **Task 2**: - **Input**: A list of integers and an integer representing the number of processors (e.g., `parallel_process([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)`). - **Output**: A list of integers where each integer represents the result of processing a chunk. # Constraints - The `data` list will have at least one element. - `num_chunks` and `num_processors` will always be greater than zero. - Ensure the implementation efficiently handles large datasets. - Assume that each data processing operation (e.g., summing a chunk) is independent and can be parallelized without any dependencies. # Example Scenarios * `chunk_data([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)` might return `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`. * `parallel_process([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)` might return `[6, 15, 24]`, which represents the sum of each chunk. Ensure your implementation handles cases where the data does not perfectly divide into equal chunks and balances the workload as evenly as possible.","solution":"from typing import List def chunk_data(data: List[int], num_chunks: int) -> List[List[int]]: Divide a list of integers into num_chunks equal parts. Distribute remainders as evenly as possible. :param data: List of integers to be divided :param num_chunks: Number of chunks to divide the data into :return: List of lists, where each list represents a chunk of the input data avg_size = len(data) // num_chunks remainder = len(data) % num_chunks chunks = [] start = 0 for i in range(num_chunks): end = start + avg_size + (1 if i < remainder else 0) chunks.append(data[start:end]) start = end return chunks def parallel_process(data: List[int], num_processors: int) -> List[int]: Simulate parallel processing of data by dividing it into num_processors chunks and summing each chunk. :param data: List of integers to be processed :param num_processors: Number of processors to simulate :return: List of integers, where each integer represents the sum of a chunk processed by a simulated processor chunks = chunk_data(data, num_processors) results = [sum(chunk) for chunk in chunks] return results"},{"question":"# Coding Challenge: Implement Operations on a Min-Heap with Array Representation Context You have been provided with a basic implementation of a Min-Heap, where the heap is represented as an array. The Min-Heap supports the standard operations such as insertion, deletion, and finding the minimum element. Task You need to extend the `MinHeap` class with two additional functions: 1. **Extract Min**: This operation removes and returns the minimum element from the heap. 2. **Heap Sort**: This operation returns a sorted array of the elements in the heap. Specifications **Operation 1: Extract Min** - **Function Signature**: `def extract_min(self):` - **Output**: It returns the minimum element from the heap and maintains the heap properties after removal. **Operation 2: Heap Sort** - **Function Signature**: `def heap_sort(self):` - **Output**: It returns a list of the elements sorted in ascending order. Additional Requirements - Ensure that the heap properties are intact after performing the `extract_min` operation. - Do not modify the original heap structure while implementing the `heap_sort` operation. - Implement appropriate checks and modifications to maintain the heap invariants. # Example Usage ```python # Initialize a min-heap heap = MinHeap() # Insert elements heap.insert(10) heap.insert(20) heap.insert(5) heap.insert(40) heap.insert(15) # Extract minimum element print(heap.extract_min()) # Should print 5 # Perform heap sort and display sorted elements print(heap.heap_sort()) # Should print [10, 15, 20, 40] ``` # Constraints - Handle edge cases such as extracting from an empty heap gracefully. - Performance constraints must adhere to the standard complexities of heap operations (e.g., O(log n) for extraction, O(n log n) for sorting). **Nota Bene**: Modify the `MinHeap` class as necessary to implement the new functionalities. Ensure to write modular and clean code that adheres to best practices.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val): Inserts a value into the heap. self.heap.append(val) self._heapify_up(len(self.heap) - 1) def _heapify_up(self, index): Maintains the heap property while bubbling up. parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): Maintains the heap property while bubbling down. left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def get_min(self): Returns the minimum element of the heap. if self.heap: return self.heap[0] return None def extract_min(self): Removes and returns the minimum element from the heap. if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def heap_sort(self): Returns a sorted list of the elements in the heap. sorted_list = [] temp_heap = MinHeap() temp_heap.heap = self.heap[:] while temp_heap.heap: sorted_list.append(temp_heap.extract_min()) return sorted_list"},{"question":"# Fibonacci Sequence Generator You have been asked to implement a class that generates the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. Your class will need to support generating the sequence up to a specified number of terms and provide functionality to retrieve specific values from the sequence. Requirements 1. Implement the `FibonacciGenerator` class with the following methods: * `__init__(self)`: Initializes the sequence with the first two numbers (0 and 1). * `generate_sequence(self, n: int) -> List[int]`: Generates and returns the first `n` numbers of the Fibonacci sequence. * `get_value_at(self, position: int) -> int`: Returns the Fibonacci number at the specified position (0-indexed). * `get_sequence(self) -> List[int]`: Returns the current state of the generated sequence. 2. Ensure that the input number `n` for `generate_sequence` is a non-negative integer. Raise a `ValueError` if invalid input is provided. 3. Optimize for both time and space complexities. Example Scenario ```python # Example usage of the FibonacciGenerator class. fib_gen = FibonacciGenerator() # Generate the first 10 numbers of the Fibonacci sequence sequence = fib_gen.generate_sequence(10) # Retrieve the Fibonacci number at position 5 value_at_5 = fib_gen.get_value_at(5) # Get the entire sequence generated so far current_sequence = fib_gen.get_sequence() print(sequence) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] print(value_at_5) # Output: 5 print(current_sequence) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` Testing Ensure your implementation passes the provided doctests to validate correctness. ```python # Doctests >>> fib_gen = FibonacciGenerator() >>> fib_gen.generate_sequence(5) [0, 1, 1, 2, 3] >>> fib_gen.get_value_at(3) 2 >>> fib_gen.get_sequence() [0, 1, 1, 2, 3] >>> fib_gen = FibonacciGenerator() >>> fib_gen.generate_sequence(0) [] >>> fib_gen.generate_sequence(1) [0] >>> fib_gen.generate_sequence(2) [0, 1] >>> fib_gen.get_sequence() [0, 1] >>> fib_gen = FibonacciGenerator() >>> fib_gen.generate_sequence(-1) Traceback (most recent call last): ... ValueError: Number of terms must be a non-negative integer. ``` Ensure your implementation passes these tests and any additional edge cases you consider necessary to validate the correctness and robustness of the class.","solution":"from typing import List class FibonacciGenerator: def __init__(self): self.sequence = [0, 1] def generate_sequence(self, n: int) -> List[int]: if not isinstance(n, int) or n < 0: raise ValueError(\\"Number of terms must be a non-negative integer.\\") if n <= len(self.sequence): return self.sequence[:n] for i in range(len(self.sequence), n): self.sequence.append(self.sequence[-1] + self.sequence[-2]) return self.sequence[:n] def get_value_at(self, position: int) -> int: if not isinstance(position, int) or position < 0: raise ValueError(\\"Position must be a non-negative integer.\\") if position < len(self.sequence): return self.sequence[position] self.generate_sequence(position + 1) return self.sequence[position] def get_sequence(self) -> List[int]: return self.sequence[:]"},{"question":"# Problem Statement Given a list of integers, find the maximum sum of a contiguous subarray using the Divide and Conquer approach. This approach should have a time complexity of (O(n log n)). # Requirements 1. Implement a function to divide the list and find the maximum sum of a subarray using the Divide and Conquer method. 2. Consider both the left subarray, the right subarray, and the cross subarray. # Input - A list of integers, `nums`, representing the array. # Output - An integer representing the maximum sum of a contiguous subarray. # Example ```python def max_subarray_sum(nums: list) -> int: Returns the maximum sum of a contiguous subarray using Divide and Conquer. # Example usage: print(max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4])) # Expected output: 6 (subarray [4,-1,2,1]) print(max_subarray_sum([1])) # Expected output: 1 print(max_subarray_sum([5,4,-1,7,8])) # Expected output: 23 (subarray [5,4,-1,7,8]) ``` # Constraints - ( 1 leq text{len(nums)} leq 10^5 ) - (-10^4 leq text{nums[i]} leq 10^4 ) # Hints - The Divide and Conquer approach divides the array into two halves, recurses on the two halves, and then finds the maximum subarray sum that crosses the midpoint. - The cross sum is calculated by finding the maximum subarray sum starting from the middle to the left and the middle to the right, then summing the two.","solution":"def max_crossing_sum(nums, left, mid, right): left_sum = float(\'-inf\') curr_sum = 0 for i in range(mid, left - 1, -1): curr_sum += nums[i] if curr_sum > left_sum: left_sum = curr_sum right_sum = float(\'-inf\') curr_sum = 0 for i in range(mid + 1, right + 1): curr_sum += nums[i] if curr_sum > right_sum: right_sum = curr_sum return left_sum + right_sum def max_subarray_sum_util(nums, left, right): if left == right: return nums[left] mid = (left + right) // 2 left_max = max_subarray_sum_util(nums, left, mid) right_max = max_subarray_sum_util(nums, mid + 1, right) cross_max = max_crossing_sum(nums, left, mid, right) return max(left_max, right_max, cross_max) def max_subarray_sum(nums): return max_subarray_sum_util(nums, 0, len(nums) - 1)"},{"question":"# Depth-First Search Paths In this task, you are required to implement a function to perform a Depth-First Search (DFS) and record all unique paths from the start vertex to a target vertex in the graph. Your Task Write a function `find_all_paths_dfs` to find all unique paths between two vertices in a directed graph using Depth-First Search. * **Input**: - `graph`: A dictionary where keys are vertex indices and values are lists of adjacent vertices. - `start`: Integer denoting the starting vertex. - `end`: Integer denoting the target vertex. * **Output**: - Return a list of lists, where each list represents a unique path from the start vertex to the end vertex. Constraints * (1 leq text{vertex count} leq 100) * Vertex indices range from (0) to (vertex_count - 1). Example ```python graph = { 0: [1, 2], 1: [2, 3], 2: [3], 3: [4], 4: [] } start = 0 end = 4 paths = find_all_paths_dfs(graph, start, end) print(\\"Unique paths from start to end:\\", paths) ``` Expected output: ``` Unique paths from start to end: [[0, 1, 2, 3, 4], [0, 1, 3, 4], [0, 2, 3, 4]] ``` Expectations: 1. **Correctness**: The function should correctly find and return all unique paths using DFS. 2. **Efficiency**: The solution should be efficient enough to handle the constraints. 3. **Robust Handling**: Ensure that edge cases (e.g., no path exists or start equals end) are appropriately handled.","solution":"def find_all_paths_dfs(graph, start, end): Perform DFS to find all unique paths from start to end. :param graph: Dictionary representing the graph adjacency list. :param start: Starting vertex. :param end: Ending vertex. :return: List of lists representing all unique paths. def dfs(current, target, path, paths): path.append(current) if current == target: paths.append(list(path)) else: for neighbor in graph.get(current, []): if neighbor not in path: dfs(neighbor, target, path, paths) path.pop() # Backtrack result_paths = [] dfs(start, end, [], result_paths) return result_paths"},{"question":"# Task: Implement a Matrix Transpose Function with Validation Your task is to implement a function that transposes a given matrix (list of lists) and includes input validation to handle potential errors. Specifically: 1. **Input Validation**: Ensure that the input is a matrix (list of lists) where all rows are lists of equal length. If the input is not a valid matrix, raise a `ValueError` with the message \\"Invalid input: Input must be a rectangular matrix of numbers\\". 2. **Matrix Transposition**: Implement the transposition logic to convert the rows of the matrix into columns and vice versa. # Function Signature ```python def transpose_matrix(matrix): Transpose the given matrix. :param matrix: List[List[<int or float>]]: A rectangular matrix :return: List[List[<int or float>]]: The transposed matrix >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[]]) [] >>> transpose_matrix([1, 2, 3]) Traceback (most recent call last): ... ValueError: Invalid input: Input must be a rectangular matrix of numbers >>> transpose_matrix([[1, 2], [3, \'4\']]) Traceback (most recent call last): ... ValueError: Invalid input: Input must be a rectangular matrix of numbers # Your implementation here ``` # Constraints 1. The `matrix` must be a list of lists, and all rows must be of the same length. 2. The elements of the matrix should be numbers (integers or floats). 3. The function should raise an appropriate `ValueError` for invalid inputs. # Example Usages - `transpose_matrix([[1, 2, 3], [4, 5, 6]])` should return `[[1, 4], [2, 5], [3, 6]]`. - `transpose_matrix([[1, 2], [3, 4], [5, 6]])` should return `[[1, 3, 5], [2, 4, 6]]`. - `transpose_matrix([[1]])` should return `[[1]]`. - `transpose_matrix([[]])` should return `[]`. - `transpose_matrix([1, 2, 3])` should raise `ValueError: Invalid input: Input must be a rectangular matrix of numbers`. - `transpose_matrix([[1, 2], [3, \'4\']])` should raise `ValueError: Invalid input: Input must be a rectangular matrix of numbers`.","solution":"def transpose_matrix(matrix): Transpose the given matrix. :param matrix: List[List[int or float]]: A rectangular matrix :return: List[List[int or float]]: The transposed matrix >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[]]) [] >>> transpose_matrix([1, 2, 3]) Traceback (most recent call last): ... ValueError: Invalid input: Input must be a rectangular matrix of numbers >>> transpose_matrix([[1, 2], [3, \'4\']]) Traceback (most recent call last): ... ValueError: Invalid input: Input must be a rectangular matrix of numbers # Input validation if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Invalid input: Input must be a rectangular matrix of numbers\\") row_length = None for row in matrix: if row_length is None: row_length = len(row) elif row_length != len(row): raise ValueError(\\"Invalid input: Input must be a rectangular matrix of numbers\\") if not all(isinstance(item, (int, float)) for item in row): raise ValueError(\\"Invalid input: Input must be a rectangular matrix of numbers\\") # Transposing the matrix if not matrix or matrix == [[]]: return [] return [[matrix[row][col] for row in range(len(matrix))] for col in range(len(matrix[0]))]"},{"question":"**Context**: You are a developer working on a library management system. Your responsibility is to manage the catalog of books, keeping track of all book information and performing search operations. **Task**: You need to write a class `LibraryCatalog` that supports adding books to the catalog and searching for books by their title. Each book is represented by its title and author. **Input**: - `add_book(title: str, author: str)`: Adds a book with the given title and author to the catalog. - `search_books(query: str) -> list[tuple[str, str]]`: Searches for books that contain the query string in their title (case-insensitive) and returns a list of tuples (title, author) of matching books. **Output**: - The `add_book` function does not return any value. - The `search_books` function returns a list of tuples with the title and author of each book that matches the search query. **Constraints**: - Title and author strings are non-empty and can contain any characters. - The search query is non-empty and case-insensitive. - The catalog can contain a large number of books, so both operations should be optimized for performance. **Example**: ```python # Example usage: catalog = LibraryCatalog() catalog.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") catalog.add_book(\\"Great Expectations\\", \\"Charles Dickens\\") catalog.add_book(\\"The Grapes of Wrath\\", \\"John Steinbeck\\") # Search for books with \\"Great\\" in the title: results = catalog.search_books(\\"Great\\") print(\\"Search Results:\\", results) # Output should be: # Search Results: [(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"Great Expectations\\", \\"Charles Dickens\\")] ``` ```python class LibraryCatalog: def __init__(self): self.books = [] def add_book(self, title: str, author: str) -> None: self.books.append((title, author)) def search_books(self, query: str) -> list[tuple[str, str]]: query_lower = query.lower() return [(title, author) for title, author in self.books if query_lower in title.lower()] ``` **Notes**: - You are expected to handle the case-insensitivity of the search query correctly. - The search should be efficient even as the number of books grows within realistic practical limits.","solution":"class LibraryCatalog: def __init__(self): self.books = [] def add_book(self, title: str, author: str) -> None: Adds a book with the given title and author to the catalog. self.books.append((title, author)) def search_books(self, query: str) -> list[tuple[str, str]]: Searches for books that contain the query string in their title (case-insensitive) and returns a list of tuples (title, author) of matching books. query_lower = query.lower() return [(title, author) for title, author in self.books if query_lower in title.lower()]"},{"question":"# Question: Calculate Area and Circumference of an Ellipse As a mathematician, you need to create a program that accurately computes the properties of an ellipse. The program should use the provided axes lengths to calculate the area and circumference of the ellipse. Your Task 1. Implement a function `ellipse_area` that computes the area of an ellipse given its semi-major and semi-minor axes lengths. 2. Implement a function `ellipse_circumference` to calculate the circumference of an ellipse given its semi-major and semi-minor axes lengths using the approximation by Ramanujan. Function Signatures ```python def ellipse_area(a: float, b: float) -> float | ValueError: pass def ellipse_circumference(a: float, b: float) -> float | ValueError: pass ``` # Parameters * **a (float)**: Semi-major axis length of the ellipse. * **b (float)**: Semi-minor axis length of the ellipse. # Returns For both functions: * The computed float value for the area or circumference, or a ValueError indicating invalid input. # Examples ```python # Example for ellipse_area ellipse_area(3, 2) # Expected: 18.84955592153876 # Example for ellipse_circumference ellipse_circumference(3, 2) # Expected: 15.865437575184454 ``` # Constraints * Both semi-major and semi-minor axes lengths should be greater than zero. * Use the approximation for circumference by Ramanujan, given by the formula: [ C approx pi left( 3(a + b) - sqrt{(3a + b)(a + 3b)} right) ] # Note Ensure to validate the inputs. All positive float values are considered valid. ```python import math def ellipse_area(a: float, b: float) -> float | ValueError: if a <= 0 or b <= 0: return ValueError(\'Axis lengths must be positive\') return math.pi * a * b def ellipse_circumference(a: float, b: float) -> float | ValueError: if a <= 0 or b <= 0: return ValueError(\'Axis lengths must be positive\') h = (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b))) return math.pi * h # Example usage print(ellipse_area(3, 2)) # Expected: 18.84955592153876 print(ellipse_circumference(3, 2)) # Expected: 15.865437575184454 ```","solution":"import math def ellipse_area(a: float, b: float) -> float: if a <= 0 or b <= 0: raise ValueError(\'Axis lengths must be positive\') return math.pi * a * b def ellipse_circumference(a: float, b: float) -> float: if a <= 0 or b <= 0: raise ValueError(\'Axis lengths must be positive\') h = (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b))) return math.pi * h"},{"question":"# Binary Search on Sorted Matrix **Context**: You are given a 2D matrix where each row and each column is sorted in ascending order. Your task is to implement an efficient search algorithm to find a target value in the matrix. Given the properties of the matrix, a binary search approach can be employed to locate the target value efficiently. **Task**: Implement the `search_matrix` function that takes a sorted 2D list and an integer target, and returns a boolean indicating whether the target value exists within the matrix. # Function Signature: ```python def search_matrix(matrix: List[List[int]], target: int) -> bool: matrix: a list of lists of integers representing a 2D sorted matrix target: an integer value to search for in the matrix returns: a boolean indicating whether the target value is found in the matrix ``` # Constraints: 1. The input matrix `matrix` is guaranteed to be non-empty and sorted in ascending order both row-wise and column-wise. 2. The function should be optimized to exploit the sorted properties of the matrix to minimize search time. 3. The matrix dimensions are within the constraints of 1 <= rows, columns <= 1000. # Expected Input/Output: - **Input**: A 2D list representing a sorted matrix, and an integer target value. - **Output**: A boolean value indicating whether the target value exists in the matrix. **Example**: ```python # Example 1: matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 print(search_matrix(matrix, 5)) # Output: True # Example 2: matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 20 print(search_matrix(matrix, 20)) # Output: False ``` # Additional Notes: - Ensure your function handles matrices of different dimensions, including edge cases where the target is smaller than all matrix elements or larger than all matrix elements. - Consider the efficient traversal of the matrix to find the target value, avoiding a brute force approach.","solution":"def search_matrix(matrix, target): matrix: a list of lists of integers representing a 2D sorted matrix target: an integer value to search for in the matrix returns: a boolean indicating whether the target value is found in the matrix if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Implement a function `find_majority_element(nums: List[int]) -> int` that finds the majority element in an array. A majority element is an element that appears more than `n/2` times in the array where `n` is the length of the array. # Detailed Function Description * **Input**: - `nums` (List[int]): A list of integers where the majority element is guaranteed to exist. The length of `nums` is between 1 and 10^5. * **Output**: - Returns an integer which is the majority element in the array `nums`. # Constraints - The input list is non-empty and contains only integer values. - The majority element is guaranteed to exist in the input list. - The function should operate with a time complexity of O(n) and a space complexity of O(1). # Example ```python >>> find_majority_element([3,2,3]) 3 >>> find_majority_element([2,2,1,1,1,2,2]) 2 ``` # Additional Requirements: * Handle edge cases effectively, such as lists with a single element. * Optimize the function to handle the upper limit of input size efficiently. Hints - Consider using an algorithm like the Boyer-Moore Voting Algorithm for optimal performance. - Make sure to return the correct majority element even if it appears close to exactly `n/2` times.","solution":"def find_majority_element(nums): Finds the majority element in the list, which appears more than n/2 times. Args: nums (List[int]): A list of integers where the majority element is guaranteed to exist. Returns: int: The majority element. # Boyer-Moore Voting Algorithm candidate = None count = 0 for num in nums: if count == 0: candidate = num count += 1 if num == candidate else -1 return candidate"},{"question":"# Context Given an inventory of a bookstore where each book is represented as an object with attributes such as title, author, genre, and price, you need to create a recommendation system based on book prices. The system will offer book recommendations to customers based on a given price range. The bookstore provides an implementation of the Book class. # Task You need to implement a function `recommend_books` that: 1. Takes a list of book objects and a price range (minimum and maximum price) as input. 2. Filters the books that fall within the specified price range. 3. Sorts the filtered books by price in ascending order and by title alphabetically if prices are the same. 4. Returns the sorted list of book titles. # Function Signature ```python def recommend_books(books: list[\'Book\'], min_price: float, max_price: float) -> list[str]: Recommends books within the given price range, sorted by price and title. Args: books (list[\'Book\']): The list of book objects. min_price (float): The minimum price. max_price (float): The maximum price. Returns: list[str]: A list of book titles within the given price range. ``` # Input - `books`: A list of book objects where each object has attributes like `title`, `author`, `genre`, and `price`. - `min_price`: A float representing the minimum price of a book. - `max_price`: A float representing the maximum price of a book. # Output - Returns a list of strings where each string is the title of a book within the specified price range, sorted by price in ascending order. If two books have the same price, they are sorted alphabetically by title. # Constraints - Assume the list of books is not empty. - No two books have the same title. - The price range is realistic and covers the prices in the list of books. # Example ```python class Book: def __init__(self, title: str, author: str, genre: str, price: float): self.title = title self.author = author self.genre = genre self.price = price books = [ Book(title=\\"Book A\\", author=\\"Author X\\", genre=\\"Fiction\\", price=19.99), Book(title=\\"Book B\\", author=\\"Author Y\\", genre=\\"Non-fiction\\", price=25.50), Book(title=\\"Book C\\", author=\\"Author X\\", genre=\\"Fiction\\", price=15.99), Book(title=\\"Book D\\", author=\\"Author Z\\", genre=\\"Historical\\", price=15.99), Book(title=\\"Book E\\", author=\\"Author W\\", genre=\\"Science\\", price=17.99), ] min_price = 15.00 max_price = 20.00 expected_output = [\\"Book C\\", \\"Book D\\", \\"Book A\\", \\"Book E\\"] output = recommend_books(books, min_price, max_price) assert output == expected_output ``` # Notes - Focus on implementing the filtering and sorting logic efficiently. - Do not use any libraries that directly solve the problem (e.g., `sorted` built-in function is allowed but no advanced ORM or database features).","solution":"def recommend_books(books, min_price, max_price): Recommends books within the given price range, sorted by price and title. Args: books (list[\'Book\']): The list of book objects. min_price (float): The minimum price. max_price (float): The maximum price. Returns: list[str]: A list of book titles within the given price range. # Filter books within the price range filtered_books = [book for book in books if min_price <= book.price <= max_price] # Sort the filtered books by price, then by title sorted_books = sorted(filtered_books, key=lambda x: (x.price, x.title)) # Extract titles book_titles = [book.title for book in sorted_books] return book_titles"},{"question":"# Matrix Transposition and Summation **Scenario**: You are tasked with implementing a function that transposes a given 2D matrix and then calculates the sum of all elements in the transposed matrix. Matrix transposition is a fundamental operation in linear algebra and is widely used in data processing and scientific computing. **Function Signature**: ```python def transpose_and_sum(matrix: List[List[int]]) -> int: pass ``` **Input**: - `matrix` (List[List[int]]): A 2D list of integers, representing the matrix to be transposed. **Output**: - Returns the sum of all elements in the transposed matrix as an integer. **Constraints**: - The input `matrix` contains only integers. - The `matrix` is non-empty, and all inner lists (rows) have equal length. - Your function should raise `ValueError` if the input matrix is not rectangular (i.e., all rows are not of the same length). **Example**: ```python >>> transpose_and_sum([[1, 2], [3, 4], [5, 6]]) 21 >>> transpose_and_sum([[1, 2, 3], [4, 5, 6]]) 21 >>> transpose_and_sum([[7]]) 7 >>> transpose_and_sum([[]]) Traceback (most recent call last): ... ValueError: matrix cannot be empty or contain empty rows >>> transpose_and_sum([[1, 2, 3], [4, 5]]) Traceback (most recent call last): ... ValueError: all rows must be of the same length ``` **Additional Notes**: - Implement the function ensuring it adheres strictly to the constraints, and handles edge cases such as non-rectangular matrices. - Consider using list comprehensions to efficiently transpose the matrix and calculate the sum.","solution":"from typing import List def transpose_and_sum(matrix: List[List[int]]) -> int: This function transposes a given 2D matrix and then calculates the sum of all elements in the transposed matrix. Parameters: matrix (List[List[int]]): A 2D list of integers, representing the matrix to be transposed. Returns: int: The sum of all elements in the transposed matrix. Raises: ValueError: If the input matrix is not rectangular (i.e., all rows are not of the same length). # Check for empty matrix or empty rows if not matrix or not all(matrix): raise ValueError(\\"matrix cannot be empty or contain empty rows\\") row_length = len(matrix[0]) # Validate that all rows are of the same length if not all(len(row) == row_length for row in matrix): raise ValueError(\\"all rows must be of the same length\\") # Perform the transpose operation using a list comprehension transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(row_length)] # Calculate the sum of all elements in the transposed matrix return sum(sum(row) for row in transposed)"},{"question":"# Longest Substring with At Most Two Distinct Characters Context In the domain of text processing and analysis, it is often necessary to identify patterns or trends within strings. One specific problem involves finding the longest substring that contains at most two distinct characters. This kind of problem is crucial in several applications ranging from data compression algorithms to error detection in communication systems. Task Write a function `longest_substring_two_distinct(s: str) -> int` that determines the length of the longest substring with at most two distinct characters in the given string `s`. Input - `s` (str): a string consisting of lowercase English letters. Output - Return an integer representing the length of the longest substring that contains at most two distinct characters. Constraints - The length of the string `s` is at least 1 and at most 10^4. Examples 1. `longest_substring_two_distinct(\\"eceba\\")` should return `3`. (The longest substring is \\"ece\\", which contains \'e\' and \'c\') 2. `longest_substring_two_distinct(\\"ccaabbb\\")` should return `5`. (The longest substring is \\"aabbb\\", which contains \'a\' and \'b\') Notes - Multiple substrings may qualify, but you only need to return the length of one longest substring. - Consider using efficient algorithms to minimize the time complexity, such as the sliding window technique.","solution":"def longest_substring_two_distinct(s: str) -> int: n = len(s) if n < 3: return n # Sliding window left and right pointers left = 0 right = 0 # Hashmap character -> its rightmost position in the sliding window hashmap = {} max_len = 2 while right < n: # When the sliding window contains less than 3 characters if len(hashmap) < 3: hashmap[s[right]] = right right += 1 # When the sliding window contains 3 characters if len(hashmap) == 3: # Delete the leftmost character del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"# Task: Reverse Words in a String Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Requirements * Implement the function `reverse_words(s: str) -> str` that takes a string `s` as input and returns a new string with the characters of each word reversed. * Ensure that the whitespace between words is preserved exactly as it is in the input string. Function Signature ```python def reverse_words(s: str) -> str: pass ``` # Input * `s`: A string containing words separated by spaces. The string may contain leading or trailing spaces and multiple spaces between words. (1 â‰¤ len(s) â‰¤ 10^4) # Output * Returns a string with the characters of each word reversed while maintaining the order of the words and the spaces. # Example ```python assert reverse_words(\\"Let\'s take LeetCode contest\\") == \\"s\'teL ekat edoCteeL tsetnoc\\" assert reverse_words(\\" hello world \\") == \\" olleh dlrow \\" assert reverse_words(\\"a b c d e\\") == \\"a b c d e\\" ``` # Constraints * Ensure the solution handles multiple spaces correctly. * Do not alter the order of the words, only reverse the individual words. # Notes * Focus on maintaining the exact structure of whitespace in the input string while reversing the character sequence of each word. * Consider edge cases like strings with only spaces, single-character words, and a mix of spaces and words of different lengths.","solution":"def reverse_words(s: str) -> str: Reverse the characters in each word of the string while preserving whitespace and initial word order. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The string with each word\'s characters reversed. # Split the string by whitespaces words = s.split(\' \') # Reverse each word reversed_words = [word[::-1] for word in words] # Join them back with a single space separator return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question Context: To assess your ability to handle data structures and recursion, you will be asked to implement a function that pre-processes input data for a specific task. The task requires building a nested dictionary structure from a list of paths. Each path is represented by a list of strings, where each string corresponds to a directory or a file. Task: Implement the function `build_path_tree` that takes a list of paths and constructs a nested dictionary representing the directory structure. Function Signature: ```python def build_path_tree(paths: List[List[str]]) -> Dict[str, Any]: pass ``` Input & Output: - **Input**: A list of lists, where each inner list contains strings representing paths `paths` (0 <= len(paths) <= 100). - **Output**: A nested dictionary representing the directory structure. Constraints: - A path will not be empty. - The strings are case-sensitive and can include any characters. - The list can contain duplicate paths, which should not affect the result. - Dictionaries should be used to represent directories, with the leaf nodes being empty dictionaries {}. Examples: ```python assert build_path_tree([ [\'home\', \'user\', \'documents\'], [\'home\', \'user\', \'pictures\'], [\'home\', \'user\', \'music\', \'rock\'], [\'home\', \'user\', \'music\', \'jazz\'] ]) == { \'home\': { \'user\': { \'documents\': {}, \'pictures\': {}, \'music\': { \'rock\': {}, \'jazz\': {} } } } } assert build_path_tree([ [\'project\', \'src\', \'main.py\'], [\'project\', \'README.md\'] ]) == { \'project\': { \'src\': { \'main.py\': {} }, \'README.md\': {} } } assert build_path_tree([]) == {} assert build_path_tree([[\'a\', \'b\'], [\'a\', \'b\', \'c\']]) == { \'a\': { \'b\': { \'c\': {} } } } ``` Explanation: - In the first example, the structure of nested directories and files is represented accurately in a nested dictionary format. - In the second example, the function handles both files and directories. - In the third and fourth examples, edge cases like an empty input list and deeply nested structures are considered and handled properly. Ensure your solution uses recursion or an iterative approach efficiently, keeping performance in mind for the allowed input size.","solution":"from typing import List, Dict, Any def build_path_tree(paths: List[List[str]]) -> Dict[str, Any]: def insert_path(tree: Dict[str, Any], path: List[str]): if not path: return node = path[0] if node not in tree: tree[node] = {} insert_path(tree[node], path[1:]) tree = {} for path in paths: insert_path(tree, path) return tree"},{"question":"# Problem You are given a list of email addresses. Your task is to write a function `extract_unique_domains` that extracts unique domain names from this list of email addresses. Domain names should be case insensitive, meaning \\"Example.com\\" and \\"example.com\\" should be considered the same domain. # Requirements 1. Extract the domain from the email addresses. 2. Ensure domain names are treated as case insensitive. 3. Return the list of unique domain names ordered alphabetically. # Constraints * The email addresses will be valid ASCII strings. * The list of email addresses can have a length between 1 and 10^5. * Email addresses have a maximum length of 100 characters. # Input and Output Format - `extract_unique_domains(emails: List[str]) -> List[str]` Here\'s an example of how this function should work: ```python emails = [ \\"user1@Example.com\\", \\"user2@example.com\\", \\"user3@domain.com\\", \\"user4@Domain.com\\", \\"user5@AnotherDomain.com\\", ] unique_domains = extract_unique_domains(emails) assert unique_domains == [\\"anotherdomain.com\\", \\"domain.com\\", \\"example.com\\"] ``` # Solution Template ```python from typing import List def extract_unique_domains(emails: List[str]) -> List[str]: Extract unique domain names from a list of emails, case insensitively. domains = set() for email in emails: domain = email.split(\'@\')[-1].lower() domains.add(domain) return sorted(domains) ```","solution":"from typing import List def extract_unique_domains(emails: List[str]) -> List[str]: Extract unique domain names from a list of emails, case insensitively. domains = set() for email in emails: domain = email.split(\'@\')[1].lower() domains.add(domain) return sorted(domains)"},{"question":"# Question You are given a string `s` representing a numeric expression containing digits and the operators `+` and `-`. Your task is to write a function `calculate_expression(s: str) -> int` that evaluates the expression and returns the result as an integer. Constraints: - The input string can contain spaces, which should be ignored. - The input string always represents a valid expression. - The input string will contain at least one digit. Example: ```python >>> calculate_expression(\\"3+5-2+8\\") 14 >>> calculate_expression(\\"10 + 22 - 5\\") 27 >>> calculate_expression(\\"10-2-3\\") 5 >>> calculate_expression(\\"0 - 1 + 1\\") 0 >>> calculate_expression(\\"54\\") 54 ``` Notes: - You should handle spaces between numbers and operators gracefully. - Ensure your solution can handle integer overflow and large inputs efficiently. Write the function `calculate_expression` to solve the above problem.","solution":"def calculate_expression(s: str) -> int: Evaluates a numeric expression containing digits and the operators + and -. s = s.replace(\' \', \'\') # remove all spaces total = 0 num = 0 sign = 1 # 1 means positive, -1 means negative for char in s: if char.isdigit(): num = num * 10 + int(char) # to handle multi-digit numbers else: total += sign * num num = 0 sign = 1 if char == \'+\' else -1 total += sign * num # adding the last number return total"},{"question":"# Problem Statement You are required to implement a function that simulates a simple cardiac rhythm over time using a sinusoidal model. The function will take four input parameters: 1. **duration**: An integer representing the duration of the signal in seconds. 2. **sampling_rate**: An integer representing the number of samples per second. 3. **heart_rate**: An integer representing the heart rate in beats per minute (bpm). 4. **amplitude**: A floating-point number representing the amplitude of the signal. # Input Format - `duration`: An integer (1 â‰¤ duration â‰¤ 3600) - `sampling_rate`: An integer (1 â‰¤ sampling_rate â‰¤ 10^3) - `heart_rate`: An integer (30 â‰¤ heart_rate â‰¤ 180) - `amplitude`: A floating-point number representing the amplitude (0.1 â‰¤ amplitude â‰¤ 100.0) # Output Format - Return a NumPy array representing the cardiac rhythm sampled at the specified rate over the given duration. # Constraints - Ensure efficient computation for signals lasting up to one hour. - The generated signal must accurately reflect the sinusoidal model over the specified period. # Function Signature ```python def simulate_cardiac_rhythm(duration: int, sampling_rate: int, heart_rate: int, amplitude: float) -> np.ndarray: pass ``` # Example Input ```python duration = 10 sampling_rate = 100 heart_rate = 60 amplitude = 1.0 ``` Output A NumPy array of length `1000`, for example: ```python array([0. , 0.0374641, 0.0749297, ..., -0.0749297, -0.0374641, 0. ]) ``` # Notes - The frequency of the sinusoidal signal can be calculated as `heart_rate / 60` Hz. - The number of total samples in the output array will be `duration * sampling_rate`. - Ensure that the function can handle edge cases, such as minimal durations or low heart rates. - Utilize efficient methods for generating the sinusoidal signal to meet performance constraints.","solution":"import numpy as np def simulate_cardiac_rhythm(duration: int, sampling_rate: int, heart_rate: int, amplitude: float) -> np.ndarray: Simulates a cardiac rhythm using a sinusoidal model. Parameters: duration (int): The signal\'s duration in seconds. sampling_rate (int): The number of samples per second. heart_rate (int): The heart rate in beats per minute. amplitude (float): The amplitude of the signal. Returns: np.ndarray: The simulated cardiac rhythm. # Calculate the number of samples num_samples = duration * sampling_rate # Calculate the frequency in Hz frequency = heart_rate / 60.0 # bpm to Hz # Create a time vector t = np.linspace(0, duration, num_samples, endpoint=False) # Generate the sinusoidal signal signal = amplitude * np.sin(2 * np.pi * frequency * t) return signal"},{"question":"Implementing a Stack with Minimum Element Retrieval You are required to build a custom stack data structure that supports the standard stack operations (push, pop) and an additional operation to retrieve the minimum element in the stack in constant time. # Requirements: Implement a class `MinStack` with the following methods: * `__init__(self)` - Initializes the stack. * `push(self, x: int)` - Pushes an integer `x` onto the stack. * `pop(self)` - Removes the element on the top of the stack. * `top(self)` - Gets the top element of the stack without removing it. * `getMin(self)` - Retrieves the minimum element in the stack. # Expected Behavior: * All operations (`push`, `pop`, `top`, `getMin`) should function in constant time. # Constraints: * The stack should handle a reasonable number of push and pop operations efficiently. * If `pop` or `top` is called on an empty stack, raise an appropriate exception. * Assume all input values for push are valid integers within the range of [-10^6, 10^6]. * Implement the stack such that `getMin` returns the smallest element in the stack at any given time. # Examples: ```python >>> min_stack = MinStack() >>> min_stack.push(-2) >>> min_stack.push(0) >>> min_stack.push(-3) >>> min_stack.getMin() -3 >>> min_stack.pop() >>> min_stack.top() 0 >>> min_stack.getMin() -2 ``` # Performance Considerations: Ensure the implementation can handle frequent and numerous stack operations while maintaining the minimal retrieval time for the `getMin` method.","solution":"class MinStack: def __init__(self): Initializes the data structure. self.stack = [] self.min_stack = [] def push(self, x: int): Pushes the element x onto the stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): Removes the top element of the stack. if not self.stack: raise IndexError(\\"pop from empty stack\\") top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Gets the top element of the stack. if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def getMin(self) -> int: Retrieves the minimum element in the stack. if not self.min_stack: raise IndexError(\\"getMin from empty stack\\") return self.min_stack[-1]"},{"question":"# Array Manipulation Script You have been tasked with writing a function to manipulate elements of an integer array according to a sequence of operations defined in a list. Each operation will either add a given value to all elements of a subarray or find the maximum value within a specified subarray. **Function Signature:** ```python def array_operations(n: int, operations: List[Tuple[str, int, int, int]]) -> List[int]: ``` # Requirements: 1. The function accepts two arguments: - An integer `n`, which denotes the size of the initial array filled with zeros. - A list of operations, where each operation is a tuple containing four elements: - A string `op` which can be either `\\"add\\"` or `\\"max\\"`. - Two integers `start` and `end`, defining the inclusive range of the subarray to be affected by the operation. - An integer `value`, representing the value to be added (applicable only for `\\"add\\"` operation; for `\\"max\\"` operation this will be ignored). 2. The function should return a list of maximum values obtained from all `\\"max\\"` operations in the sequence they were executed. # Input: - The first argument, `n` (1 â‰¤ `n` â‰¤ 10^5): The size of the array. - The second argument, `operations` (1 â‰¤ length of `operations` â‰¤ 10^4): A list of operations in the format (op, start, end, value). # Output: - A list of integers representing the results of all `\\"max\\"` operations, maintaining the order in which they were executed. # Constraints: - `start` and `end` are 0-indexed and always within the valid range (0 â‰¤ start â‰¤ end < n). - The value for `\\"add\\"` operations can be any integer. # Example: ```python n = 5 operations = [ (\\"add\\", 1, 3, 2), (\\"max\\", 0, 4, 0), // Value is ignored for \\"max\\" operations (\\"add\\", 0, 2, 1), (\\"max\\", 1, 3, 0) ] print(array_operations(n, operations)) # Expected output: [2, 3] ``` # Explanation: 1. Initialize the array: `[0, 0, 0, 0, 0]`. 2. Perform the first operation: Add 2 to elements from index 1 to 3. Array becomes `[0, 2, 2, 2, 0]`. 3. Perform the second operation: Find the max value from index 0 to 4, which is `2`. 4. Perform the third operation: Add 1 to elements from index 0 to 2. Array becomes `[1, 3, 3, 2, 0]`. 5. Perform the fourth operation: Find the max value from index 1 to 3, which is `3`. The function returns `[2, 3]` as the results of the `\\"max\\"` operations.","solution":"def array_operations(n, operations): Manipulates elements of an integer array according to a sequence of operations. Args: n: int - size of the initial array filled with zeros. operations: list of tuple - a list of operations where each operation is a tuple containing: - a string \\"add\\" or \\"max\\" - two integers start and end, defining the inclusive range of the subarray to be affected by the operation - an integer value, representing the value to be added (for \\"add\\" operation; ignored for \\"max\\" operation). Returns: list of int: a list of maximum values obtained from all \\"max\\" operations in the order they were executed. arr = [0] * n results = [] for op in operations: if op[0] == \\"add\\": for i in range(op[1], op[2] + 1): arr[i] += op[3] elif op[0] == \\"max\\": max_val = max(arr[op[1]:op[2] + 1]) results.append(max_val) return results"},{"question":"# Context: In computer science, hashing is a process to map data of arbitrary size to data of fixed size. Sometimes, hashing is used for quickly locating a data record given its search key. # Task: Write a function `find_missing_number_in_hashes(hashes, n)` that takes a list of length `n-1` containing unique integers from 1 to `n` (representing hashes of numbers from 1 to `n`) except one missing number, and returns the missing number. # Input: - `hashes`: a list of `n-1` integers, uniquely ranging from 1 to `n`. - `n`: an integer representing the number of unique integers that should be present. # Output: - An integer representing the missing number from 1 to `n`. # Constraints: - `1 <= n <= 10^6` - Elements in `hashes` are unique and in the range from 1 to `n`, inclusively, with exactly one number missing. # Example: ```python hashes = [1, 2, 3, 5] n = 5 assert find_missing_number_in_hashes(hashes, n) == 4 ``` # Performance Requirements: - The function should efficiently handle the input constraints, ensuring linear time complexity O(n) and constant space complexity O(1).","solution":"def find_missing_number_in_hashes(hashes, n): Returns the missing number from the list of hashes, ranging from 1 to n. Args: hashes (list): A list of n-1 integers uniquely ranging from 1 to n. n (int): The number of unique integers that should be present. Returns: int: The missing integer. # Calculate the expected sum of the first n natural numbers total_sum = n * (n + 1) // 2 # Calculate the sum of the elements provided in the list actual_sum = sum(hashes) # The missing number is the difference between the expected sum and the actual sum missing_number = total_sum - actual_sum return missing_number"},{"question":"# Warehouse Robot Path Optimization A warehouse has a grid layout with `n` rows and `m` columns. There is a robot located at the top-left corner of the grid at position `(0,0)`. The robot can move only to the right or down. The goal is for the robot to reach the bottom-right corner of the grid at position `(n-1, m-1)`. However, certain cells in the grid have obstacles, and the robot cannot pass through these cells. Given the grid configuration, implement a function to determine the number of unique paths the robot can take to reach the bottom-right corner. If no such path exists, the function should return 0. Function Signature `def unique_paths_with_obstacles(grid: List[List[int]]) -> int:` Input - `grid`: a 2D list representing the grid configuration, where `grid[i][j]` is `1` if there is an obstacle at cell `(i, j)` and `0` if it is free. Output - Returns an integer representing the number of unique paths from `(0,0)` to `(n-1, m-1)`. Constraints - 1 â‰¤ `n`, `m` â‰¤ 100 - `grid` will be a non-empty 2D list consisting of 0s and 1s. Performance Requirements - The solution should efficiently handle the maximum input size within reasonable time limits. # Example ```python >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 >>> unique_paths_with_obstacles([[1, 0], [0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0], [0, 1]]) 0 ``` # Hints 1. Think about dynamic programming to store and reuse subproblem solutions. 2. Start from the destination and work backwards, marking paths that are blocked by obstacles. 3. Consider edge cases where the start or end positions are blocked by obstacles. --- This question fits within the style and scope of the original set by requiring efficient algorithm design and implementation. It covers grid-based traversal, dynamic programming, and obstacle handling, which are complementary areas for assessing problem-solving skills in coding assessments.","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 n = len(grid) m = len(grid[0]) # Initialize a 2D DP array with zeros dp = [[0 for _ in range(m)] for _ in range(n)] # Fill the first cell dp[0][0] = 1 # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the rest of dp table for i in range(1, n): for j in range(1, m): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"# Problem Statement You are required to implement a `MaxStack` class from scratch in Python. A `MaxStack` is a data structure that supports stack operations such as pushing and popping elements, as well as retrieving the maximum element efficiently. The operations should be: 1. **Push** a value onto the stack. 2. **Pop** the top value from the stack. 3. **Max** to get the maximum value in the stack. 4. **Top** to get the top value without removing it. 5. **Size** to get the number of elements in the stack. 6. **Is Empty** to check if the stack is empty. # Input and Output - **push(value)**: Adds a value to the stack. - **Input**: Single value of a comparable type. - **Output**: None - **pop()**: Removes and returns the top value in the stack. - **Output**: The top value. - **Exceptions**: Raise `IndexError` if the stack is empty. - **max()**: Returns the maximum value in the stack without removing it. - **Output**: The maximum value. - **Exceptions**: Raise `IndexError` if the stack is empty. - **top()**: Returns the top value without removing it. - **Output**: The top value. - **Exceptions**: Raise `IndexError` if the stack is empty. - **size()**: Returns the number of elements in the stack. - **Output**: Integer representing the size of the stack. - **is_empty()**: Checks if the stack is empty. - **Output**: Boolean value, `True` if the stack is empty. # Constraints - `<value>` in operations can be of any type that supports comparison. - All operations except `push` and `pop` should adhere to O(1) complexity. - You must handle cases where operations are performed on an empty stack gracefully. # Example Usage ```python ms = MaxStack() ms.push(3) ms.push(1) ms.push(7) print(ms.max()) # Output: 7 print(ms.pop()) # Output: 7 print(ms.top()) # Output: 1 print(ms.size()) # Output: 2 print(ms.is_empty()) # Output: False ``` You must implement the entire MaxStack class with the specified methods and properties.","solution":"class MaxStack: def __init__(self): Initialize an empty stack with an auxiliary stack to keep track of the maximum values. self.stack = [] self.max_stack = [] def push(self, value): Push a value onto the stack and update the max_stack. self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self): Removes and returns the top value from the stack. Raise IndexError if the stack is empty. if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def max(self): Returns the maximum value in the stack without removing it. Raise IndexError if the stack is empty. if not self.max_stack: raise IndexError(\\"max from empty stack\\") return self.max_stack[-1] def top(self): Returns the top value without removing it. Raise IndexError if the stack is empty. if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def size(self): Returns the number of elements in the stack. return len(self.stack) def is_empty(self): Checks if the stack is empty. Returns True if the stack is empty, otherwise False. return len(self.stack) == 0"},{"question":"# Problem Description Develop a function that finds all prime numbers up to a given integer `N` using the Sieve of Eratosthenes algorithm. This will help you efficiently generate a list of prime numbers. # Task Implement a function using both iterative and recursive approaches to generate all prime numbers up to the given integer `N`. # Function Signature ```python def iterative_sieve(N: int) -> list[int]: pass def recursive_sieve(N: int, current: int = 2, primes: list[int] = None) -> list[int]: pass ``` # Input - `N` (int): The upper bound integer up to which to generate prime numbers (inclusive). - `current` (int): The current number being evaluated for primality in the recursive function. - `primes` (list[int]): The list of primes found so far in the recursive function. # Output - Return a list of all prime numbers up to `N` in ascending order. # Constraints - `N` is a non-negative integer. - Ensure good performance with time complexity of O(N log log N). # Examples ```python # Main function signature of iterative sieve def iterative_sieve(N): pass # Main function signature of recursive sieve def recursive_sieve(N, current=2, primes=None): pass # Iterative Sieve of Eratosthenes assert iterative_sieve(10) == [2, 3, 5, 7] assert iterative_sieve(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert iterative_sieve(2) == [2] assert iterative_sieve(1) == [] assert iterative_sieve(0) == [] assert iterative_sieve(25) == [2, 3, 5, 7, 11, 13, 17, 19, 23] # Recursive Sieve of Eratosthenes assert recursive_sieve(10) == [2, 3, 5, 7] assert recursive_sieve(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert recursive_sieve(2) == [2] assert recursive_sieve(1) == [] assert recursive_sieve(0) == [] assert recursive_sieve(25) == [2, 3, 5, 7, 11, 13, 17, 19, 23] ``` # Hints - Use a boolean array to mark non-prime numbers in the iterative approach. - For the recursive approach, consider a helper function to handle the recursion effectively. - Handle edge cases such as when `N` is less than 2.","solution":"def iterative_sieve(N: int) -> list[int]: This function returns a list of prime numbers less than or equal to N using the Sieve of Eratosthenes algorithm iteratively. if N < 2: return [] is_prime = [True] * (N + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers for i in range(2, int(N ** 0.5) + 1): if is_prime[i]: for j in range(i * i, N + 1, i): is_prime[j] = False return [i for i in range(2, N + 1) if is_prime[i]] def recursive_sieve(N: int, current: int = 2, primes: list[int] = None) -> list[int]: This function returns a list of prime numbers less than or equal to N using the Sieve of Eratosthenes algorithm recursively. if N < 2: return [] if primes is None: primes = list(range(2, N + 1)) if current * current > N: return primes primes = [x for x in primes if x == current or x % current != 0] return recursive_sieve(N, current + 1, primes)"},{"question":"# Customer Segmentation using K-Means Clustering You are tasked with segmenting customers based on their purchasing behavior using K-Means Clustering. This technique is suitable for grouping similar data points into clusters, making it easier to analyze and target different customer segments. # Problem Statement Given a dataset `customer_data.csv` that contains customer details and their purchasing behavior, write a Python function `segment_customers` that: 1. Loads and preprocesses the data. 2. Determines the optimal number of clusters using the Elbow method. 3. Applies K-Means Clustering to group the customers. 4. Outputs the cluster centers and assigns each customer to a cluster. The dataset is a CSV file with the following columns: - CustomerID (index 0) - Gender (index 1) - Age (index 2) - Annual Income (index 3) - Spending Score (index 4) You should: - Normalize the numerical features using StandardScaler. - Encode categorical variables such as gender. - Apply the Elbow method to find the optimal number of clusters. - Fit the K-Means model and output the cluster information. # Function Signature ```python def segment_customers(file_path: str, max_clusters: int) -> (np.ndarray, np.ndarray): Segments customers using K-Means Clustering. Args: - file_path (str): Path to the CSV file containing customer data. - max_clusters (int): Maximum number of clusters to consider for the Elbow method. Returns: - np.ndarray: Cluster centers. - np.ndarray: Cluster labels for each customer. pass ``` # Input - `file_path`: A string representing the path to the CSV file with customer data. - `max_clusters`: An integer representing the maximum number of clusters to consider for the Elbow method. # Output - `cluster_centers` : An array of cluster centers after fitting the K-Means model. - `cluster_labels` : An array indicating the cluster assigned to each customer. # Constraints - The CSV file has no missing values. - The dataset contains at least two rows. - The maximum number of clusters is a positive integer. # Example Usage ```python # Example usage: cluster_centers, cluster_labels = segment_customers(\\"customer_data.csv\\", 10) print(cluster_centers) print(cluster_labels) ``` Implement the function `segment_customers` to solve the given problem. Make sure to handle normalization, categorical encoding, and clustering appropriately within the function.","solution":"import numpy as np import pandas as pd from sklearn.preprocessing import StandardScaler, LabelEncoder from sklearn.cluster import KMeans import matplotlib.pyplot as plt def segment_customers(file_path: str, max_clusters: int) -> (np.ndarray, np.ndarray): # Load the data data = pd.read_csv(file_path) # Prepare the feature set X = data.iloc[:, 1:] # Encode categorical variables label_encoder = LabelEncoder() X[\'Gender\'] = label_encoder.fit_transform(X[\'Gender\']) # Normalize numerical features scaler = StandardScaler() X_scaled = scaler.fit_transform(X) # Determine the optimal number of clusters using the Elbow method wcss = [] for i in range(1, max_clusters + 1): kmeans = KMeans(n_clusters=i, random_state=0) kmeans.fit(X_scaled) wcss.append(kmeans.inertia_) # Plotting the elbow graph to visually find the optimal clusters # Generally, you would look at the plot to decide on the optimal number of clusters # This plot part would not be normally in the function, but included here for demonstration purposes plt.plot(range(1, max_clusters + 1), wcss) plt.title(\'Elbow Method For Optimal K\') plt.xlabel(\'Number of clusters\') plt.ylabel(\'WCSS\') plt.show() # Assuming the optimal clusters found from the Elbow method is (example: 5) # In practice, you would need to manually check the plot to decide this value k_optimal = 5 # This should be set by visualizing the elbow plot # Apply KMeans with the optimal number of clusters kmeans = KMeans(n_clusters=k_optimal, random_state=0) kmeans.fit(X_scaled) # Get the cluster centers and labels cluster_centers = kmeans.cluster_centers_ cluster_labels = kmeans.labels_ return cluster_centers, cluster_labels"},{"question":"# Problem Statement You need to develop a student grading system that computes the final grade of a student based on their scores in various categories: assignments, quizzes, midterms, and finals. Each category has a different weight towards the final grade, and you are required to implement a function that calculates the final weighted grade. # Task Implement a function `calculate_final_grade` that computes the final grade given the scores in each category, and the weight of each category. Function Signature ```python def calculate_final_grade( assignments: list, quizzes: list, midterms: list, finals: list, weights: dict ) -> float: ``` Input * `assignments` (list): A list of scores (float) for assignments. * `quizzes` (list): A list of scores (float) for quizzes. * `midterms` (list): A list of scores (float) for midterms. * `finals` (list): A list of scores (float) for finals. * `weights` (dict): A dictionary with keys \\"assignments\\", \\"quizzes\\", \\"midterms\\", \\"finals\\" and their respective weights as values (float). Output * (float): Final weighted grade of the student. Constraints * The values in `assignments`, `quizzes`, `midterms`, and `finals` should be between 0 and 100. * The sum of the weights must equal 1. # Example ```python final_grade = calculate_final_grade( [85, 90, 78], [88, 92], [84], [95], {\\"assignments\\": 0.4, \\"quizzes\\": 0.2, \\"midterms\\": 0.2, \\"finals\\": 0.2} ) print(final_grade) # Output should be the final weighted grade of the student ``` # Notes 1. Ensure to validate the input values. 2. You may assume there will be at least one score in each category. 3. Document any assumptions or additional considerations in your solution. The new question integrates well with the style, complexity, and scope of typical coding assessment questions, calling for practical implementation skills, mathematical reasoning, and input validation.","solution":"def calculate_final_grade(assignments, quizzes, midterms, finals, weights): Calculate the final weighted grade of a student based on their scores in various categories. :param assignments: List of scores for assignments :param quizzes: List of scores for quizzes :param midterms: List of scores for midterms :param finals: List of scores for finals :param weights: Dictionary with weights of each category :return: Final weighted grade # Check if the weights add up to 1 assert sum(weights.values()) == 1, \\"The weights must sum up to 1.\\" # Calculate the average score for each category assignments_avg = sum(assignments) / len(assignments) quizzes_avg = sum(quizzes) / len(quizzes) midterms_avg = sum(midterms) / len(midterms) finals_avg = sum(finals) / len(finals) # Handle the weighted grades final_grade = (assignments_avg * weights[\'assignments\'] + quizzes_avg * weights[\'quizzes\'] + midterms_avg * weights[\'midterms\'] + finals_avg * weights[\'finals\']) return final_grade"},{"question":"# Temperature Sensor Data Analysis You have been given a file containing temperature sensor data recorded over a period of time. The file is in CSV format, where the first column is the timestamp (in the format \\"YYYY-MM-DD HH:MM:SS\\") and the second column is the recorded temperature in Celsius. Your task is to write a function `temperature_statistics(filename: str) -> dict` that reads the file and calculates the following statistics: 1. The highest recorded temperature. 2. The lowest recorded temperature. 3. The average temperature. 4. The most frequent temperature (mode). 5. The median temperature. If there are multiple modes, select the smallest value. Assume the input file is well-formed and contains at least one record. **Problem Statement**: Write a function `temperature_statistics(filename: str) -> dict` that reads the temperature data from the given file and returns a dictionary containing the calculated statistics. **Input**: - The file `filename` will contain rows of temperature data in CSV format: \\"timestamp, temperature\\". **Output**: - A dictionary with the following keys and corresponding values: - `highest`: highest recorded temperature - `lowest`: lowest recorded temperature - `average`: average temperature - `mode`: most frequent temperature - `median`: median temperature **Constraints**: - Temperature values are in Celsius. - The file contains at least one record. ```python import csv from collections import Counter from statistics import mean, median from typing import List import pathlib def temperature_statistics(filename: str) -> dict: temperatures = [] # Read data from file with open(filename, newline=\'\') as csvfile: reader = csv.reader(csvfile) for row in reader: timestamp, temperature = row temperatures.append(float(temperature)) # Calculate statistics highest = max(temperatures) lowest = min(temperatures) average = mean(temperatures) mode = min(Counter(temperatures).most_common(), key=lambda x: (-x[1], x[0]))[0] median_temp = median(temperatures) return { \'highest\': highest, \'lowest\': lowest, \'average\': average, \'mode\': mode, \'median\': median_temp } if __name__ == \\"__main__\\": print(temperature_statistics(\\"temperature_data.csv\\")) ``` **Note**: Test your solution with appropriate data in the `temperature_data.csv` file. This new question aligns with the existing set by maintaining a similar style, length, and complexity. It challenges the programmer to read data from a file, process numerical data, and use statistical functions, all skills relevant in a coding assessment context.","solution":"import csv from collections import Counter from statistics import mean, median from typing import List, Dict def temperature_statistics(filename: str) -> Dict[str, float]: temperatures = [] # Read data from file with open(filename, newline=\'\') as csvfile: reader = csv.reader(csvfile) for row in reader: timestamp, temperature = row temperatures.append(float(temperature)) # Calculate statistics highest = max(temperatures) lowest = min(temperatures) average = mean(temperatures) mode = min(Counter(temperatures).most_common(), key=lambda x: (-x[1], x[0]))[0] median_temp = median(temperatures) return { \'highest\': highest, \'lowest\': lowest, \'average\': average, \'mode\': mode, \'median\': median_temp }"},{"question":"# Coding Challenge: Converting Time Differences You are given a list of timestamps in the format \\"YYYY-MM-DD HH:MM:SS\\" representing events. Your task is to calculate the differences between each consecutive event in seconds and return a list of these differences. Function Signature ```python from typing import List def calculate_time_differences(timestamps: List[str]) -> List[int]: pass ``` Parameters - `timestamps`: A list of strings representing the event timestamps in chronological order. Output - A list of integers where each integer is the difference in seconds between consecutive timestamps. Constraints - The list `timestamps` contains at least two timestamps and at most 100 timestamps. - All timestamps are in valid \\"YYYY-MM-DD HH:MM:SS\\" format. - The timestamps are in UTC and in chronological order. # Example ```python timestamps = [ \\"2023-01-01 00:00:00\\", \\"2023-01-01 01:00:00\\", \\"2023-01-01 01:30:00\\", \\"2023-01-01 03:00:00\\" ] differences = calculate_time_differences(timestamps) print(differences) ``` **Output:** ```python [3600, 1800, 5400] ``` Write the function `calculate_time_differences` to solve the problem.","solution":"from typing import List from datetime import datetime def calculate_time_differences(timestamps: List[str]) -> List[int]: Calculate the differences between each consecutive event timestamps in seconds. Parameters: timestamps (List[str]): A list of timestamps in the format \\"YYYY-MM-DD HH:MM:SS\\" Returns: List[int]: A list of differences in seconds between each consecutive timestamps differences = [] for i in range(1, len(timestamps)): first_timestamp = datetime.strptime(timestamps[i-1], \\"%Y-%m-%d %H:%M:%S\\") second_timestamp = datetime.strptime(timestamps[i], \\"%Y-%m-%d %H:%M:%S\\") difference = int((second_timestamp - first_timestamp).total_seconds()) differences.append(difference) return differences"},{"question":"# Problem Statement: Given a list of non-negative integers representing the heights of vertical lines on a horizontal axis, calculate the most water these lines can collectively trap. Imagine the lines form a container that captures water if there is a gap between any two lines. # Function Signature: ```python def max_trapped_water(heights: list) -> int: ``` # Input: * `heights` (a list of integers): A list of non-negative integers where each integer represents the height of a vertical line. # Output: * Returns an integer representing the maximum amount of water that can be trapped. # Constraints: * `heights` will have at least 2 elements and at most (10^5) elements. * Each element in `heights` will be in the range from 0 to (10^4). # Performance Requirements: * Your solution should efficiently handle the maximum input size within a reasonable time complexity, less than O(n^2). # Example: ```python assert max_trapped_water([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_trapped_water([1, 1]) == 1 assert max_trapped_water([4, 3, 2, 1, 4]) == 16 assert max_trapped_water([1, 2, 1]) == 2 ``` # Notes: 1. Utilize a two-pointer technique to achieve an optimal solution. 2. Start with pointers at both ends of the list, and adjust them based on comparing the heights of the lines they point to. 3. The maximum water is determined by the shorter line among the two pointers and the distance between them.","solution":"def max_trapped_water(heights): Calculate the maximum amount of water that can be trapped between vertical lines. :param heights: List[int] - A list of non-negative integers representing the heights :return: int - The maximum amount of water that can be trapped if not heights or len(heights) < 2: return 0 left, right = 0, len(heights) - 1 max_water = 0 while left < right: current_water = min(heights[left], heights[right]) * (right - left) max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Coding Assessment Question Context You are developing a library system where you need to frequently adjust the inventory of multiple branches. Your task is to implement a function that combines the inventories of two branches, updating the quantities of each book based on their ISBN numbers. Task Implement a function `combine_inventories` that takes the inventories of two branches and merges them. Each inventory is represented as a list of tuples, where each tuple contains an ISBN number and the quantity of books for that ISBN. If a book is present in both inventories, the final quantity should be the sum of both quantities. Function Signature ```python def combine_inventories(inventory_a: list, inventory_b: list) -> list: pass ``` Input * `inventory_a` and `inventory_b` are lists of tuples, where each tuple contains: * A string representing the ISBN number of the book. * An integer representing the quantity of books for that ISBN. Output * Returns a list of tuples representing the combined inventory, sorted by ISBN number. Constraints * Each ISBN number is unique within a single inventory. * ISBN numbers are strings. * Quantities are non-negative integers. * Raise `TypeError` if inputs are not lists of tuples. * Raise `ValueError` if ISBNs are non-strings or quantities are negative integers. * Handle invalid ISBN format by raising `ValueError`. Example ```python assert combine_inventories([(\\"12345\\", 5), (\\"67890\\", 2)], [(\\"12345\\", 3), (\\"11111\\", 4)]) == [(\\"11111\\", 4), (\\"12345\\", 8), (\\"67890\\", 2)] assert combine_inventories([], [(\\"22222\\", 7)]) == [(\\"22222\\", 7)] assert combine_inventories([(\\"99999\\", 10)], []) == [(\\"99999\\", 10)] ``` Edge Cases * Invalid input types: `combine_inventories([(\\"12345\\", 5)], \\"not_a_list\\")` should raise `TypeError`. * Invalid ISBN types: `combine_inventories([(\\"12345\\", 5)], [(12345, 3)])` should raise `ValueError`. * Negative quantities: `combine_inventories([(\\"12345\\", -5)], [(\\"67890\\", 2)])` should raise `ValueError`.","solution":"def combine_inventories(inventory_a: list, inventory_b: list) -> list: if not (isinstance(inventory_a, list) and isinstance(inventory_b, list)): raise TypeError(\\"Both inventories must be lists of tuples\\") combined_inventory = {} for inventory in [inventory_a, inventory_b]: for isbn, quantity in inventory: if not isinstance(isbn, str): raise ValueError(\\"ISBN must be a string\\") if not isinstance(quantity, int) or quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer\\") if isbn in combined_inventory: combined_inventory[isbn] += quantity else: combined_inventory[isbn] = quantity return sorted(combined_inventory.items())"},{"question":"# Context You are developing a text analysis module that includes a function to extract and process hashtags from a given string. Hashtags are words or phrases beginning with the \'#\' symbol, and they can include letters and numbers but no spaces or special characters. The goal is to retrieve all unique, case-insensitive hashtags and return them in alphabetical order. # Task Write a function `extract_hashtags` to identify and return a list of unique hashtags from a provided text string. Your function should: 1. Detect all hashtags, regardless of case. 2. Ensure the hashtags are unique and case-insensitive. 3. Return the hashtags in alphabetical order. # Function Signature ```python def extract_hashtags(text: str) -> list: Extract unique, alphabetically sorted hashtags from the given text. Args: text (str): The input string containing hashtags. Returns: list: A list of unique, sorted hashtags. pass ``` # Input and Output Formats * **Input**: A single string containing hashtags. * **Output**: A list of unique hashtags sorted in alphabetical order. # Constraints * The input string is non-empty. * Hashtags do not contain spaces or special characters beyond the initial \'#\'. * Hashtags are separated by spaces or punctuation. # Example Given the following text: ```python text = \\"Loving the #Sunshine, but the #sunshine and #Rain can be tricky. #rain\\" ``` A call to `extract_hashtags` should return: ```python [\'#rain\', \'#sunshine\'] ``` # Requirements 1. Implement the `extract_hashtags` function. 2. Ensure the function handles case insensitivity and returns sorted results. ```python def extract_hashtags(text: str) -> list: # Implement this function pass # Example usage: # text = \\"Loving the #Sunshine, but the #sunshine and #Rain can be tricky. #rain\\" # print(extract_hashtags(text)) # Output: [\'#rain\', \'#sunshine\'] ``` # Performance Requirements The function should efficiently handle large text inputs and process hashtags accurately within a fair time frame, ensuring robustness and scalability.","solution":"import re def extract_hashtags(text: str) -> list: Extract unique, alphabetically sorted hashtags from the given text. Args: text (str): The input string containing hashtags. Returns: list: A list of unique, sorted hashtags. # Using regex to find all hashtags and ensuring we only capture word characters after \'#\' hashtags = re.findall(r\'#[w]+\', text) # Convert to lowercase to ensure case-insensitivity and then use a set to get unique values unique_hashtags = {hashtag.lower() for hashtag in hashtags} # Return the sorted list of unique hashtags return sorted(unique_hashtags)"},{"question":"# Problem Statement As a developer working on a data analytics platform, you are required to implement a function that processes a stream of numerical data to detect trends. Specifically, you need to identify when the average of a sliding window of the last `k` elements surpasses a given threshold. Your task is to implement a function that takes an input list of integers, a window size `k`, and a threshold, and returns a list of booleans indicating whether the average of the elements within the sliding window at each position exceeds the threshold. # Function Signature ```python def detect_trend(data, k, threshold): Detects trends in the data stream using a sliding window average. Arguments: data -- list of integers representing the data stream k -- integer, the size of the sliding window threshold -- float, the threshold for the average Returns: A list of boolean values indicating if the average exceeds the threshold at each step. pass ``` # Input * `data` (list of int): A list of integers representing the data stream. * `k` (int): The size of the sliding window. * `threshold` (float): The threshold value for the average. # Output * List of boolean values indicating whether the sliding window average exceeds the threshold at each step. # Constraints * ( 1 leq len(data) leq 10^6 ) * ( 1 leq k leq len(data) ) * ( 0 leq |data[i]| leq 10^4 ) for each element in `data` * ( 0 leq threshold leq 10^4 ) # Performance Requirements * Your solution should efficiently process the data stream even for the maximum input size. # Example ```python # Define the parameters data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 3 threshold = 5 # Call the function results = detect_trend(data, k, threshold) # Expected output # [False, False, False, False, True, True, True, True, True, True] ``` # Explanation The function processes the data using a sliding window of size `k`. For each window position, it calculates the average and compares it to the threshold. The list of boolean values returned indicates whether the average exceeds the threshold at each position, starting from the first complete window. In the given example, the averages of the windows are: - [1, 2, 3] -> average = 2.0 (False) - [2, 3, 4] -> average = 3.0 (False) - [3, 4, 5] -> average = 4.0 (False) - [4, 5, 6] -> average = 5.0 (False) - [5, 6, 7] -> average = 6.0 (True) - [6, 7, 8] -> average = 7.0 (True) - [7, 8, 9] -> average = 8.0 (True) - [8, 9, 10] -> average = 9.0 (True) Thus, the result is `[False, False, False, False, True, True, True, True, True, True]`.","solution":"def detect_trend(data, k, threshold): Detects trends in the data stream using a sliding window average. Arguments: data -- list of integers representing the data stream k -- integer, the size of the sliding window threshold -- float, the threshold for the average Returns: A list of boolean values indicating if the average exceeds the threshold at each step. if k <= 0 or k > len(data): raise ValueError(\\"Window size k must be between 1 and length of data\\") result = [] window_sum = sum(data[:k]) for i in range(len(data) - k + 1): if i != 0: window_sum = window_sum - data[i - 1] + data[i + k - 1] window_avg = window_sum / k result.append(window_avg > threshold) return result"},{"question":"# AVL Tree Implementation and Rotations An **AVL tree** is a self-balancing binary search tree (BST) where the difference in heights between the left and right subtrees of any node is at most one. To maintain this balance, rotations are used during insertions and deletions. Task Your task is to implement an AVL tree with the basic operations like insertion and rotation (left and right). Specifically, write a Python function `insert_avl(root: Node | None, key: int) -> Node | None`, which inserts a key into the AVL tree and ensures the tree remains balanced. # Input 1. The **root** node of an AVL tree. 2. An integer **key** to insert into the tree. # Output * The **root** node of the AVL tree after insertion and rebalancing. # Constraints * The tree has nodes with integers as keys in the range [-10^4, 10^4]. * The tree size will not exceed 10^4 nodes. # Example ```python root = None root = insert_avl(root, 10) root = insert_avl(root, 20) root = insert_avl(root, 30) print(preorder_traversal(root)) # Output: [20, 10, 30] root = None root = insert_avl(root, 50) root = insert_avl(root, 20) root = insert_avl(root, 10) root = insert_avl(root, 5) root = insert_avl(root, 15) print(preorder_traversal(root)) # Output: [20, 10, 5, 15, 50] ``` # Function Signature ```python def insert_avl(root: Node | None, key: int) -> Node | None: # Your implementation here ``` # Notes * You should define the `Node` class and any helper functions required for insertion and rebalancing (rotations). * Ensure to handle edge cases such as inserting into an empty tree or inserting duplicate keys gracefully. * The function `preorder_traversal` is a helper function used only for validating the AVL tree structure in the examples and doesn\'t need to be implemented. # Solution Hint * Implement rotations (left and right) to maintain the AVL property. * Update the heights of nodes and balance the tree after each insertion. * Use the height difference between left and right subtrees to determine the need and type of rotation.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def get_height(node): if not node: return 0 return node.height def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def right_rotate(y): x = y.left T2 = x.right # Perform rotation x.right = y y.left = T2 # Update heights update_height(y) update_height(x) return x def left_rotate(x): y = x.right T2 = y.left # Perform rotation y.left = x x.right = T2 # Update heights update_height(x) update_height(y) return y def insert_avl(root, key): if not root: return Node(key) # Perform normal BST insertion if key < root.key: root.left = insert_avl(root.left, key) elif key > root.key: root.right = insert_avl(root.right, key) else: # Duplicate keys not allowed return root # Update height of the ancestor node update_height(root) # Get the balance factor balance = get_balance(root) # Balance the tree # Left Left Case if balance > 1 and key < root.left.key: return right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root def preorder_traversal(root): result = [] if root: result.append(root.key) result.extend(preorder_traversal(root.left)) result.extend(preorder_traversal(root.right)) return result"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},O={class:"card-container"},z={key:0,class:"empty-state"},R=["disabled"],L={key:0},P={key:1};function D(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"ðŸ¤”prompts chatðŸ§ ")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"ðŸ”",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," âœ• ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",L,"See more"))],8,R)):u("",!0)])}const Y=c(N,[["render",D],["__scopeId","data-v-395e25ec"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/13.md","filePath":"drive/13.md"}'),j={name:"drive/13.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,V as default};
