import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-3dd40fac"]]),A=JSON.parse('[{"question":"You are given a string `s` consisting of lowercase letters. The string can be split into substrings using one or more palindromic substrings. A palindrome is a string that reads the same backward as forward. Find and return the minimum number of cuts needed to split the string into palindromic substrings.","solution":"def min_cut_palindrome(s): Returns the minimum number of cuts needed to split the string into palindromic substrings. n = len(s) if n <= 1: return 0 # Create a DP table to check palindrome for substrings is_palindrome = [[False] * n for _ in range(n)] for i in range(n): is_palindrome[i][i] = True for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: is_palindrome[i][j] = (s[i] == s[j]) else: is_palindrome[i][j] = (s[i] == s[j] and is_palindrome[i + 1][j - 1]) # Create a DP array to find the minimum cuts cuts = [0] * n for i in range(n): if is_palindrome[0][i]: cuts[i] = 0 else: cuts[i] = float(\'inf\') for j in range(i): if is_palindrome[j + 1][i] and cuts[j] + 1 < cuts[i]: cuts[i] = cuts[j] + 1 return cuts[-1]"},{"question":"You are given two integer arrays `arr1` and `arr2` of equal length `n`. Construct a new array `result` of length `n` where `result[i]` is the **minimum** of the sum of any non-empty subarray from `arr1` that starts at `i` and the sum of the subarray from `arr2` that starts at `i`. Return the array `result`.","solution":"def min_subarray_sum(arr1, arr2): Returns an array where result[i] is the minimum of the sum of any non-empty subarray from arr1 that starts at i and the sum of the subarray from arr2 that starts at i. n = len(arr1) result = [0] * n for i in range(n): min_sum1 = float(\'inf\') current_sum1 = 0 for j in range(i, n): current_sum1 += arr1[j] min_sum1 = min(min_sum1, current_sum1) min_sum2 = float(\'inf\') current_sum2 = 0 for j in range(i, n): current_sum2 += arr2[j] min_sum2 = min(min_sum2, current_sum2) result[i] = min(min_sum1, min_sum2) return result"},{"question":"You are given an array `heights` representing the heights of students in a class. The array is **0-indexed** and its length is `n`. You are also given a positive integer `k`. You need to find the maximum number of students that can be grouped such that in each group, the difference between the tallest and the shortest student is no greater than `k`. Return _the maximum number of students that can be grouped according to the given condition_.","solution":"def max_students_grouped(heights, k): Returns the maximum number of students that can be grouped such that in each group, the difference between the tallest and the shortest student is no greater than k. heights (list[int]): List representing heights of students. k (int): Maximum allowed difference in heights within a group. Returns: int: Maximum number of students that can be grouped according to the given condition. if not heights or k < 0: return 0 heights.sort() max_group = 0 left = 0 for right in range(len(heights)): while heights[right] - heights[left] > k: left += 1 max_group = max(max_group, right - left + 1) return max_group"},{"question":"You are given two integers `sandwiches` and `students`, representing the number of sandwiches and the number of students in a queue, respectively. Each student can either **only eat** circular sandwiches or square sandwiches. Each time, the sandwich at the front of the queue is given to the student at the front of the queue if they want it. If they don\'t, they go to the end of the queue. This process continues until there are no sandwiches left or no student in the queue can eat the remaining sandwiches. Each sandwich has a type `0` for circular or `1` for square, while students are represented similarly, where each student is `0` if they only eat circular sandwiches and `1` if they only eat square sandwiches. **Return the number of students that remain in the queue.**","solution":"def count_students(sandwiches, students): This function returns the number of students that remain in the queue after the distribution of sandwiches is complete. Args: sandwiches (list): A list of integers representing the sandwiches. students (list): A list of integers representing the students. Returns: int: The number of students that remain in the queue. from collections import deque sandwich_queue = deque(sandwiches) student_queue = deque(students) while sandwich_queue and student_queue: attempts = 0 # To track if any student was able to get a sandwich in the last cycle while student_queue[0] != sandwich_queue[0]: student_queue.append(student_queue.popleft()) attempts += 1 if attempts == len(student_queue): return len(student_queue) sandwich_queue.popleft() student_queue.popleft() return len(student_queue)"},{"question":"You are given a grid represented as a list of lists where each element is a character that can be either `\'1\'` or `\'0\'`. A group of connected `\'1\'`s forms an island. Two `\'1\'`s are considered connected if they are adjacent horizontally or vertically, but not diagonally. The grid is completely surrounded by water, and there is at least one `\'1\'` if an island exists. Write a function that takes such a grid and returns the number of islands. Here\'s the function signature: ```python def numIslands(grid: List[List[str]]) -> int: pass ``` Return _the number of distinct islands in the grid_.","solution":"from typing import List def numIslands(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == \'1\': visited.add((nr, nc)) stack.append((nr, nc)) islands = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and (r, c) not in visited: visited.add((r, c)) dfs(r, c) islands += 1 return islands"},{"question":"Given a list of strings `words`, construct a new string by concatenating all the words together, but ensure that no two adjacent words in the resulting string share the same first character. If it is not possible to construct such a string, return an empty string. If multiple valid solutions exist, return any one of them. Return _the constructed string or an empty string if no valid construction is possible_.","solution":"from collections import Counter def concatenate_unique_first_chars(words): Concatenates words ensuring no two adjacent words share the same first character. Returns the final string or an empty string if such a concatenation is not possible. if not words: return \\"\\" # Helper function to check if the given words can be arranged def can_arrange(words): count = Counter(words) sorted_by_frequency = sorted(count.items(), key=lambda x: -x[1]) most_common_char, max_count = sorted_by_frequency[0] return max_count <= (len(words) + 1) // 2 # Check if it\'s possible to arrange if not can_arrange([word[0] for word in words]): return \\"\\" words.sort(key=lambda word: words.count(word), reverse=True) result = [] prev_word = None while words: for i, word in enumerate(words): if not result or result[-1][0] != word[0]: result.append(word) prev_word = words.pop(i) break else: return \\"\\" return \'\'.join(result)"},{"question":"You are given a binary tree where each node has a value of either `0` or `1`. Each path in the tree represents a binary number, with the highest bit at the root and the lowest bit at the leaf. Find the sum of all the numbers represented by all paths from the root to the leaves. A path \\"1 -> 0 -> 1\\" represents the number `101` which is `5` in decimal. Return the sum of all such numbers in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root): def dfs(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val if not node.left and not node.right: # if it\'s a leaf return current_number left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"Given a list of non-negative integers `arr` and an integer `k`, return _the **smallest non-negative integer** that is **not present** in the array and is **greater than or equal to** `k`_. If there are multiple valid integers, return **the smallest one**. For example, given `arr = [0, 1, 2, 4]` and `k = 3`, the function should return `3` because `3` is the smallest integer greater than or equal to `3` that is not present in the array.","solution":"def smallest_missing_greater_or_equal(arr, k): Returns the smallest non-negative integer that is not present in the array and is greater than or equal to k. :param arr: List of non-negative integers :param k: Integer value to compare against :return: Smallest non-negative integer not in arr and >= k # Convert the list to a set for O(1) lookup times num_set = set(arr) # Start from k and find the first integer not in set while k in num_set: k += 1 return k"},{"question":"You are given a 2D integer array `grid` representing a grid of digits. A path in the grid is a sequence of digits from the top-left cell to the bottom-right cell, moving only rightward or downward at each step. The **total** of a path is the sum of the digits along the path. Find a path such that the sum of its digits equals a given target `target`. Return _the total number of distinct paths_ that can achieve this total. If no such path exists, return `0`.","solution":"def count_paths_with_sum(grid, target): Returns the number of distinct paths in the grid that sum up to the target. Paths can only move rightward or downward from the top-left to the bottom-right. from collections import defaultdict rows = len(grid) cols = len(grid[0]) # DP table where dp[i][j][sum] stores the number of ways to reach position (i, j) with a specific sum dp = [[defaultdict(int) for _ in range(cols)] for _ in range(rows)] # Initialize the starting point dp[0][0][grid[0][0]] = 1 # Fill the DP table for i in range(rows): for j in range(cols): for s in dp[i][j]: if i + 1 < rows: # Step down dp[i+1][j][s+grid[i+1][j]] += dp[i][j][s] if j + 1 < cols: # Step right dp[i][j+1][s+grid[i][j+1]] += dp[i][j][s] # Retrieve the count of paths that achieve the target sum at the bottom-right cell return dp[rows-1][cols-1][target]"},{"question":"You are given a **square** matrix `grid` of size `n x n` containing integer values. A **zigzag** path in the matrix starts from the top-left corner `grid[0][0]` and moves to the bottom-right corner `grid[n-1][n-1]` by only moving down or right, but you cannot visit the same cell more than once. Return _the **minimum** sum of the values along any valid zigzag path_.","solution":"def min_zigzag_sum(grid): Returns the minimum sum of the values along any valid zigzag path in the grid. n = len(grid) dp = [[float(\'inf\')] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"You are given an array of `n` integers, `nums`. A **unique triplet** is a set of three numbers `(nums[i], nums[j], nums[k])` such that `i != j`, `i != k`, and `j != k`, and the sum of the triplet is zero. Return all unique triplets in the array that sum up to zero. Note that the solution set must not contain duplicate triplets.","solution":"def three_sum(nums): Returns all unique triplets in the array nums that sum up to zero. nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return res"},{"question":"Given two strings `s` and `t`, find the minimum window substring in `s` that contains all the characters in `t` (including duplicates). If there is no such window in `s` that covers all characters in `t`, return the empty string `\\"\\"`. If there are multiple such windows, return the one with the smallest length. Implement a function `minimumWindowSubstring(s: string, t: string) -> string` where: - `s` and `t` are non-empty strings containing only uppercase and lowercase English letters.","solution":"from collections import Counter def minimumWindowSubstring(s: str, t: str) -> str: if not s or not t or len(s) < len(t): return \\"\\" t_counter = Counter(t) window_counter = Counter() required = len(t_counter) formed = 0 l, r = 0, 0 min_length = float(\\"inf\\") min_window = (0, 0) while r < len(s): char = s[r] window_counter[char] += 1 if char in t_counter and window_counter[char] == t_counter[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < min_length: min_length = r - l + 1 min_window = (l, r) window_counter[char] -= 1 if char in t_counter and window_counter[char] < t_counter[char]: formed -= 1 l += 1 r += 1 l, r = min_window return s[l:r+1] if min_length != float(\\"inf\\") else \\"\\""},{"question":"You are given an array `arr` of integers, and you can perform the following operation on `arr` any number of times: choose any two adjacent elements and swap them. The cost of performing this operation is equal to the absolute difference between the two elements being swapped. Your task is to determine the minimum possible cost to sort the array in non-decreasing order. Return the minimum cost as an integer.","solution":"def min_cost_to_sort(arr): Returns the minimum cost to sort the array in non-decreasing order given the specified operation and cost. n = len(arr) if n <= 1: return 0 # Calculate the minimum cost using dynamic programming sorted_arr = sorted(arr) # Cost of converting arr[:i] to sorted_arr[:j] dp = [[float(\'inf\')] * n for _ in range(n)] # Base condition dp[0][0] = abs(arr[0] - sorted_arr[0]) for j in range(1, n): dp[0][j] = min(dp[0][j-1], abs(arr[0] - sorted_arr[j])) for i in range(1, n): min_so_far = dp[i-1][0] dp[i][0] = min_so_far + abs(arr[i] - sorted_arr[0]) for j in range(1, n): min_so_far = min(min_so_far, dp[i-1][j]) dp[i][j] = min_so_far + abs(arr[i] - sorted_arr[j]) return min(dp[-1])"},{"question":"Given an array of integers `nums`, return the smallest absolute difference between any two elements in the array. The difference between elements `a` and `b` is defined as `abs(a - b)`, where `abs` denotes the absolute value.","solution":"def smallest_absolute_difference(nums): Returns the smallest absolute difference between any two elements in the array. if len(nums) < 2: return 0 # Not enough elements to compare nums.sort() min_diff = float(\'inf\') for i in range(len(nums) - 1): diff = abs(nums[i+1] - nums[i]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"Create an online bookstore management system where users can add books to a catalog, purchase books, and check book availability. Implement the `Bookstore` class: * `Bookstore()` Initializes your bookstore object. * `void addBook(int bookId, int quantity)` Adds a specified quantity of the book with ID `bookId` to the bookstore\'s catalog. Each call to this function will be made with a unique `bookId`. * `bool purchaseBook(int bookId, int quantity)` Purchases a specified quantity of the book with ID `bookId` from the bookstore. If there are enough copies of the book available, decrease the book\'s quantity by the purchased amount and return `true`. Otherwise, return `false`. * `int checkAvailability(int bookId)` Checks the availability of the book with ID `bookId` and returns the quantity of the book currently in stock. If the book is not in the catalog, return `0`.","solution":"class Bookstore: def __init__(self): self.catalog = {} def addBook(self, bookId, quantity): Adds a specified quantity of the book with ID bookId to the bookstore\'s catalog. Each call to this function will be made with a unique bookId. self.catalog[bookId] = quantity def purchaseBook(self, bookId, quantity): Purchases a specified quantity of the book with ID bookId from the bookstore. If there are enough copies of the book available, decrease the book\'s quantity by the purchased amount and return true. Otherwise, return false. if bookId in self.catalog and self.catalog[bookId] >= quantity: self.catalog[bookId] -= quantity return True return False def checkAvailability(self, bookId): Checks the availability of the book with ID bookId and returns the quantity of the book currently in stock. If the book is not in the catalog, return 0. return self.catalog.get(bookId, 0)"},{"question":"You are given an array of integers `nums` and an integer `k`. Each element in the array represents the position of a car on a number line. You want to assign a parking space to each car such that the maximum distance any car has to walk after parking is minimized. Specifically, you can allocate each car to one of `k` parking lots. Each parking lot can hold any number of cars. Return the minimum possible value of the maximum walking distance any car has to walk to reach a parking lot. Consider that every parking lot is located at a position of one of the cars in the array.","solution":"def minimize_maximum_distance(nums, k): Minimizes the maximum walking distance any car has to walk to reach a parking lot. Args: nums: List[int] - positions of cars on a number line. k: int - number of parking lots. Returns: int - the minimum possible value of the maximum walking distance any car has to walk. nums.sort() def canAllocate(max_distance): parking_lots = 1 start_position = nums[0] for position in nums: if position - start_position > max_distance: parking_lots += 1 start_position = position if parking_lots > k: return False return True low, high = 0, nums[-1] - nums[0] while low < high: mid = (low + high) // 2 if canAllocate(mid): high = mid else: low = mid + 1 return low"},{"question":"Given a string `s` that consists of lowercase letters only, you are to perform queries of the following type: 1. **Update** the character at a specific index in the string. 2. **Count** the number of distinct characters in a specified substring of the string. Implement the following class: * `StringQuery(String s)` - Initializes the object with the string `s`. * `void update(int index, char newChar)` - Updates the character at `s[index]` to `newChar`. * `int countDistinctChars(int start, int end)` - Returns the number of distinct characters in the substring `s[start:end+1]`.","solution":"class StringQuery: def __init__(self, s): Initializes the object with the string `s`. self.s = list(s) # Store the string as a list of characters for easy updates def update(self, index, newChar): Updates the character at `s[index]` to `newChar`. if 0 <= index < len(self.s): self.s[index] = newChar def countDistinctChars(self, start, end): Returns the number of distinct characters in the substring `s[start:end+1]`. if 0 <= start <= end < len(self.s): substring = self.s[start:end+1] distinct_chars = set(substring) return len(distinct_chars) return 0"},{"question":"Given an integer `n`, write a function that returns a list of all self-dividing numbers between `1` and `n` (inclusive). A self-dividing number is a number that is divisible by every digit it contains. For example, `128` is a self-dividing number because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`. Note that if a number contains the digit zero, it is not considered a self-dividing number.","solution":"def is_self_dividing(number): Helper function that checks if a number is self-dividing. original_number = number while number > 0: digit = number % 10 if digit == 0 or original_number % digit != 0: return False number //= 10 return True def self_dividing_numbers(n): Returns a list of all self-dividing numbers between 1 and n (inclusive). return [i for i in range(1, n + 1) if is_self_dividing(i)]"},{"question":"You are tasked with designing a data structure that supports the following operations: 1. `insert(val)` - Insert a value into the data structure. 2. `delete(val)` - Remove a value from the data structure. 3. `get_random()` - Return a random element from the data structure. Each element must have an equal probability of being returned. Implement the `RandomizedSet` class that supports these operations efficiently.","solution":"import random class RandomizedSet: def __init__(self): Initialize the RandomizedSet object. self.data = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.data: return False self.data[val] = len(self.list) self.list.append(val) return True def delete(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.data: return False index = self.data[val] last_element = self.list[-1] self.list[index] = last_element self.data[last_element] = index self.list.pop() del self.data[val] return True def get_random(self) -> int: Get a random element from the set. return random.choice(self.list)"},{"question":"You\'re given a string `s` and a dictionary of words `dict`. Add bold tags `<b>` and `</b>` to the substrings in `s` that exist in `dict`. If two such substrings overlap, they should be enclosed with a single pair of bold tags. For example, if `s = \\"abcxyz123\\"` and `dict = [\\"abc\\", \\"123\\"]`, the resulting string should be `\\"<b>abc</b>xyz<b>123</b>\\"`. If `s = \\"aaabbcc\\"` and `dict = [\\"aaa\\", \\"aab\\", \\"bc\\"]`, the resulting string should be `\\"<b>aaabbc</b>c\\"`. Write a function `addBoldTag` that takes a string `s` and a list of words `dict`, and returns the string `s` with the appropriate bold tags added.","solution":"def addBoldTag(s, dict): Adds bold tags to substrings of s that exist in dict. Handles overlapping substrings by merging them. n = len(s) mask = [False] * n # Mark the substrings that need to be bolded for word in dict: start = s.find(word) while start != -1: for i in range(start, start + len(word)): mask[i] = True start = s.find(word, start + 1) # Build the resulting string with bold tags result = [] i = 0 while i < n: if mask[i]: result.append(\'<b>\') while i < n and mask[i]: result.append(s[i]) i += 1 result.append(\'</b>\') else: result.append(s[i]) i += 1 return \'\'.join(result)"},{"question":"You are given an integer array `arr` and an integer `x`. Your task is to determine if there exists a pair of elements in the array whose sum is equal to `x`. Return `true` if such a pair exists, otherwise return `false`. Note that each element in the array can only be used once in a pair.","solution":"def has_pair_with_sum(arr, x): Returns True if there exists a pair of elements in the array whose sum is equal to x. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"You are given a string `s` containing only three types of characters: `\'a\'`, `\'b\'`, and `\'c\'`. Return the minimum number of characters you need to delete from the string so that the string does not contain any consecutive repeating characters.","solution":"def min_deletions_to_avoid_consecutive_repeating(s): Returns the minimum number of characters to delete to ensure there are no consecutive repeating characters. Parameters: s (str): Input string containing only \'a\', \'b\', and \'c\' Returns: int: Minimum number of deletions required deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given two strings `s1` and `s2` which represent binary numbers (i.e., consist only of characters \'0\' and \'1\'). Your task is to add these two binary numbers and return the resulting binary number as a string. Make sure to handle cases where the result may have additional digits due to carry-over.","solution":"def add_binary(s1, s2): Returns the sum of two binary numbers represented as strings. # Convert binary strings to integers num1 = int(s1, 2) num2 = int(s2, 2) # Add binary numbers binary_sum = num1 + num2 # Convert the sum back to a binary string and remove the \'0b\' prefix return bin(binary_sum)[2:]"},{"question":"Given an integer array `arr`, your task is to prepare for a coding contest. You need to split the array into a minimum number of non-empty consecutive subarrays such that each subarray has its elements in strictly increasing order. Return the minimum number of subarrays required.","solution":"def min_subarrays(arr): Splits the array into the minimum number of non-empty consecutive subarrays such that each subarray has its elements in strictly increasing order. Args: arr (List[int]): The input array of integers. Returns: int: The minimum number of subarrays required. if not arr: return 0 subarray_count = 1 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: subarray_count += 1 return subarray_count"},{"question":"You are given a string `s` consisting of only lowercase English letters and initially empty string `t`. You can perform two types of operations on `s`: 1. Reverse any substring of `s` and append it to `t`. 2. Take any character from `s` (at any position) and append it to `t`. The goal is to transform `s` into `t` such that the final string `t` is lexicographically smallest. Return _the lexicographically smallest string `t` possible after performing the operations any number of times_.","solution":"def lexicographically_smallest(s): Transforms the string s into the lexicographically smallest string t possible by performing the allowed operations any number of times. Args: - s: a string consisting of only lowercase English letters. Returns: - a string t which is the lexicographically smallest possible string. t = [] while s: min_char = min(s) min_index = s.index(min_char) t.append(min_char) s = s[:min_index] + s[min_index+1:] return \'\'.join(t)"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, return _the maximum product of any two distinct elements of_ `nums`. A **product** of elements at indices `i` and `j` ((0 leq i, j leq n-1)) is defined as `nums[i] * nums[j]` where (i neq j).","solution":"def max_product(nums): Returns the maximum product of any two distinct elements in the nums array. if len(nums) < 2: return None # Edge case: there are not enough elements to form a product # Sort the array to find the two largest numbers nums.sort() # Maximum product could either be from the two largest positive numbers # or the two smallest negative numbers (if present and their product is larger). return max(nums[-1] * nums[-2], nums[0] * nums[1])"},{"question":"Given an integer array `nums`, you need to find an integer `k` such that: - The absolute difference between any two consecutive elements in the resulting array is exactly `k`. - The resulting array must have the same length as `nums` and the same elements as `nums` (possibly rearranged). If there are multiple solutions, return any of them. If no such array exists, return an empty array. For example: ``` nums = [2, 3, 4, 5] possible result arrays with k=1: [2, 3, 4, 5] or [5, 4, 3, 2] ``` Given an array `nums`, return _an array that satisfies the above conditions_ or an empty array if no such array exists.","solution":"from typing import List def array_with_k_difference(nums: List[int]) -> List[int]: Re-arranges the array such that the absolute difference between any two consecutive elements is exactly k. Args: nums (List[int]): The input list of integers. Returns: List[int]: The rearranged list or an empty list if no such array exists. N = len(nums) if N <= 1: return nums nums.sort() k = min(abs(nums[i] - nums[i - 1]) for i in range(1, N)) result = [nums[0]] used = {nums[0]} for num in nums[1:]: if abs(result[-1] - num) == k and num not in used: result.append(num) used.add(num) if len(result) == N: return result return [] nums = [2, 3, 4, 5] print(array_with_k_difference(nums)) # Example: [2, 3, 4, 5] or [5, 4, 3, 2]"},{"question":"Given a linked list, rotate the list to the right by k places, where k is a non-negative integer. For example, given the linked list `1->2->3->4->5` and `k = 2`, the list will become `4->5->1->2->3` after rotating it to the right by 2 places. You must optimize the algorithm to run in O(n) time complexity, where n is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Determine the length of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Create a circular list old_tail.next = head # Find the new tail and new head new_tail = head for _ in range(length - k % length - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"You are given an `n x n` binary grid `grid` where `0` represents an empty cell and `1` represents an obstacle. You can move up, down, left, or right, and your goal is to find the shortest path from the **top-left corner** (0, 0) to the **bottom-right corner** (n-1, n-1). However, you must break exactly one obstacle (if needed) to reach the destination. Return **the length of the shortest path**. If there is no path after breaking one obstacle, return `-1`.","solution":"from collections import deque def shortest_path_binary_matrix(grid): n = len(grid) if n == 0 or grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 def in_bounds(x, y): return 0 <= x < n and 0 <= y < n # Directions for movement directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS queue: (x, y, path_length, obstacle_broken) queue = deque([(0, 0, 1, False)]) visited = set([(0, 0, False)]) while queue: x, y, path_length, obstacle_broken = queue.popleft() if (x, y) == (n-1, n-1): return path_length for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny): if grid[nx][ny] == 0 and (nx, ny, obstacle_broken) not in visited: queue.append((nx, ny, path_length + 1, obstacle_broken)) visited.add((nx, ny, obstacle_broken)) elif grid[nx][ny] == 1 and not obstacle_broken and (nx, ny, True) not in visited: queue.append((nx, ny, path_length + 1, True)) visited.add((nx, ny, True)) return -1"},{"question":"You are given an **m x n** integer matrix `mat`. You can choose any element in the matrix and toggle all its neighbors that share an edge with it (up, down, left, right). Toggling a cell means changing it from 0 to 1 or from 1 to 0. You are allowed to perform this toggling operation **zero or more times**. Your goal is to make all elements in the matrix equal (all 0s or all 1s). Return _the minimum number of toggling operations required to achieve this goal_. If it is not possible, return `-1`.","solution":"def min_toggles_to_equal_matrix(matrix): Determine the minimum number of toggles required to make all elements in the matrix equal. def toggle(matrix, i, j): Toggle the element at (i, j) and its neighbors. rows, cols = len(matrix), len(matrix[0]) neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)] matrix[i][j] ^= 1 for di, dj in neighbors: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols: matrix[ni][nj] ^= 1 rows, cols = len(matrix), len(matrix[0]) original_matrix = [row[:] for row in matrix] operations_0 = operations_1 = 0 # Try to make all 0s for i in range(rows): for j in range(cols): if matrix[i][j] == 1: toggle(matrix, i, j) operations_0 += 1 # Reset matrix and try to make all 1s matrix = [row[:] for row in original_matrix] for i in range(rows): for j in range(cols): if matrix[i][j] == 0: toggle(matrix, i, j) operations_1 += 1 return min(operations_0, operations_1) # Example usage matrix = [ [0, 0, 0], [1, 0, 0], [0, 0, 0] ] print(min_toggles_to_equal_matrix(matrix)) # Output should be the minimum number of toggles required"},{"question":"Given an integer array `nums`, sort the array in such a way that all the even numbers are followed by all the odd numbers. Return _the sorted array maintaining the relative order of even and odd numbers as in the original array_. Implement the function `sortArrayByParity(int[] nums)` to achieve this.","solution":"def sortArrayByParity(nums): Sort the array in such a way that all the even numbers are followed by all the odd numbers while maintaining the relative order of even and odd numbers as in the original array. Args: nums: List[int] - The input list of integers. Returns: List[int] - The sorted list containing all even numbers followed by all odd numbers. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] return evens + odds"},{"question":"You are given an integer array `nums` consisting of `n` elements. You can perform a move in which you pick a non-empty subarray and increment each element in the subarray by `1`. To minimize the effort, you want to determine the minimum number of moves required to make all the elements in the array equal. Return _the minimum number of moves required to make all elements in the array equal_.","solution":"def min_moves_to_make_equal(nums): Returns the minimum number of moves to make all elements in the array equal. Each move increments each element in a chosen subarray by 1. :param nums: List[int] - The input list of integers. :return: int - Minimum number of moves to make all elements in the array equal. # To make all elements in the array equal, the optimal strategy is # to increment each element to match the largest element in the array. # Thus, the minimum number of moves is the difference between the sum of the array elements # and the product of the minimum element and the length of the array. total_sum = sum(nums) min_element = min(nums) num_elements = len(nums) return total_sum - min_element * num_elements"},{"question":"Given a list of integers `heights` representing the heights of students standing in a row, return the minimum number of students that must be moved such that the heights are in non-decreasing order. You can only move each student once from their current position to any other position.","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of students that must be moved such that the heights are in non-decreasing order. # Sort the list to get the target positions sorted_heights = sorted(heights) # Count the number of positions where the heights differ from the sorted sequence moves = sum(1 for i in range(len(heights)) if heights[i] != sorted_heights[i]) return moves"},{"question":"Given an array `nums` of integers, write a function to return _the length of the longest subarray with an equal number of 0\'s and 1\'s_. For example, given the array `[0, 1, 0]`, the longest subarray with an equal number of 0\'s and 1\'s is `[0, 1]` or `[1, 0]`, so the function should return `2`. The subarray contains an equal number of 0\'s and 1\'s.","solution":"def findMaxLength(nums): Returns the length of the longest subarray with an equal number of 0\'s and 1\'s. Args: nums -- List[int]: array of integers containing only 0\'s and 1\'s Returns: int: length of the longest subarray with equal number of 0\'s and 1\'s count = 0 count_map = {0: -1} max_length = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"Given a sequence of integers `nums` of length `n`, find the **maximum length** of a contiguous subsequence such that every element in the subsequence appears at least `k` times in the entire sequence. Return _the maximum length of such a contiguous subsequence_. If there is no subsequence that satisfies the condition, return `0`.","solution":"def max_length_subsequence(nums, k): Find the maximum length of a contiguous subsequence such that every element in the subsequence appears at least k times in the entire sequence. Args: nums (list of int): The sequence of integers. k (int): The minimum frequency for each element within the contiguous subsequence. Returns: int: The maximum length of such a contiguous subsequence. If no such subsequence exists, return 0. from collections import Counter n = len(nums) max_len = 0 for start in range(n): count = Counter() for end in range(start, n): count[nums[end]] += 1 if all(v >= k for v in count.values()): max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given a string `s`, return _the length of the **longest palindrome** that can be constructed with the letters of the string_. A **palindrome** is a word that reads the same backward as forward. You can use each character as many times as it appears in the string.","solution":"def longest_palindrome(s: str) -> int: Returns the length of the longest palindrome that can be constructed with the letters of the string s. from collections import Counter counts = Counter(s) length = 0 odd_found = False for count in counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"Given a string `s` consisting of only characters \'a\' and \'b\', you are allowed to swap any two characters in the string. Return the length of the longest substring with consecutive characters that can be achieved through these swaps. For example, given the string `s = \\"aabbab\\"`, one possible longest substring with consecutive characters is `\\"aaaa\\"` or `\\"bbbb\\"` after appropriate swaps. Return _the length of the longest substring_ with consecutive characters that can be made through swaps.","solution":"def longest_substring_after_swaps(s): Given a string `s` consisting of only characters \'a\' and \'b\', return the length of the longest substring with consecutive characters that can be achieved through swapping any two characters. Params: s (str): Input string consisting of characters \'a\' and \'b\' Returns: int: Length of the longest substring with consecutive characters # Count the number of \'a\'s and \'b\'s count_a = s.count(\'a\') count_b = s.count(\'b\') # The longest possible consecutive characters would be the max of count_a or count_b # Since we can swap any two characters, we can get a substring of all \'a\'s or all \'b\'s return max(count_a, count_b)"},{"question":"You are given an integer array `arr`, where the elements are sorted in strictly increasing order. Your task is to find the fixed point in the array, if it exists. A fixed point in an array is an element whose value is equal to its index. Return the index if there is a fixed point in the array; otherwise, return -1. If there are multiple fixed points, return the smallest index.","solution":"def find_fixed_point(arr): Finds the fixed point in the array, where element value is equal to its index. Returns the index if a fixed point exists, otherwise returns -1. for i in range(len(arr)): if arr[i] == i: return i return -1"},{"question":"You are given a matrix `grid` of size `m x n` consisting of digits `\'0\'` and `\'1\'`. A contiguous region of `\'1\'`s (horizontally or vertically, but not diagonally) forms an island in `grid`. A single `\'1\'` by itself is also considered an island. Return _the number of islands in the given `grid`_.","solution":"def numIslands(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': dfs(grid, i, j) count += 1 return count"},{"question":"You are given a **0-indexed** string `s` that contains only characters \'a\' and \'b\'. A substring is considered to be _special_ if it contains an equal number of \'a\'s and \'b\'s. Find the length of the longest special substring of `s`. If no such substring exists, return 0. The function should have a time complexity of O(n) and use constant additional space.","solution":"def longest_special_substring(s): Finds the length of the longest special substring containing equal number of \'a\'s and \'b\'s. max_length = 0 balance = 0 balance_map = {0: -1} for i, char in enumerate(s): if char == \'a\': balance += 1 else: balance -= 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"You are given an `n x n` binary grid `grid` representing a maze where `1` represents a wall and `0` represents a path you can walk on. You can start at any `0` in the grid and move in one of the four directions (up, down, left, right) to an adjacent cell. Your goal is to reach the bottom-right corner of the grid without crossing any walls. Return _the length of the shortest path to reach the bottom-right corner. If there is no path, return `-1`._ Note: It is not allowed to move outside the boundary of the grid.","solution":"from collections import deque def bfs_shortest_path(grid): Perform BFS to find the shortest path from top-left to bottom-right in a binary maze. Returns the length of the shortest path or -1 if there is no path. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"Given an array of integers `arr` representing the heights of buildings, the ocean view can be seen from a building if and only if every building to its right has a smaller height. Return an array containing the indices of buildings with an ocean view, sorted in increasing order.","solution":"def find_buildings_with_ocean_view(arr): Given an array of integers arr representing the heights of buildings, return an array containing the indices of buildings with an ocean view, sorted in increasing order. n = len(arr) if n == 0: return [] max_height = float(\'-inf\') result = [] for i in range(n - 1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return result[::-1]"},{"question":"You are given a list of numbers and a target number. You need to determine if there are two distinct numbers in the list that add up to the target number. Write a function that takes a list of integers `nums` and an integer `target` as input and returns a list of the indices of the two numbers that add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Return the indices in any order.","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: Indices of the two numbers. cache = {} for i, num in enumerate(nums): complement = target - num if complement in cache: return [cache[complement], i] cache[num] = i"},{"question":"Given an integer array `data` and an integer `k`, determine if it is possible to rearrange the elements of the array such that the array becomes a palindrome. An array is a palindrome if it reads the same backward as forward. If it is possible, return the rearranged array; otherwise, return an empty array. Note that you can only rearrange the elements without adding or removing any elements.","solution":"from collections import Counter def rearrange_to_palindrome(data, k): Determines if it\'s possible to rearrange the array such that it becomes a palindrome. If possible, returns the rearranged array, otherwise returns an empty array. if k <= 0 or len(data) != k: return [] count = Counter(data) odd_count = sum(1 for v in count.values() if v % 2 != 0) if odd_count > 1: return [] half = [] middle = [] for key, value in count.items(): if value % 2 != 0: middle = [key] * value else: half.extend([key] * (value // 2)) return half + middle + half[::-1]"},{"question":"Write a function `isValidSudoku` that takes a 9x9 2D array representing a Sudoku board and returns `true` if the board is valid, and `false` otherwise. A Sudoku board is valid if each row, column, and each of the nine 3x3 sub-boxes contains the digits 1-9 without repetition. The board can contain non-digit characters and empty cells, which should be ignored. A valid board does not necessarily need to be solvable.","solution":"def isValidSudoku(board): Check if a 9x9 Sudoku board is valid. # Initialize data structures to keep track of seen numbers rows = [set() for _ in range(9)] cols = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num == \'.\': continue # Calculate the index of the box box_index = (i // 3) * 3 + j // 3 if num in rows[i] or num in cols[j] or num in boxes[box_index]: return False rows[i].add(num) cols[j].add(num) boxes[box_index].add(num) return True"},{"question":"Given an array of positive integers representing the heights of vertically stacked boxes from left to right, determine the volume of water that can be trapped after raining. Suppose that each unit width can trap water if it is surrounded by taller boxes on both sides. The height of water trapped at each unit width can be determined by the minimum height of the taller boxes on its left and right minus its own height. Write a function to compute the total volume of trapped water.Given `heights`, an array of non-negative integers where each integer represents the height of a box at that index, return the total volume of water that can be trapped. The widths of each box are all 1 unit. **Example:** ```plaintext heights = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 ```","solution":"def trap(heights): Calculate the total volume of trapped water given the heights of the boxes. :param heights: List[int] - list of non-negative integers representing heights of boxes. :return: int - total volume of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += max(0, min(left_max[i], right_max[i]) - heights[i]) return trapped_water"},{"question":"Given a string `s` containing only lowercase letters, you need to evaluate its longest substring where the letters occur in alphabetical order (consecutive and non-repeating). Return the longest such substring. For example: - Given `s = \\"abacdfgdc\\"`, the longest substring in alphabetical order is `\\"acdfg\\"`. - Given `s = \\"xyzabc\\"`, the longest substring in alphabetical order is `\\"xyz\\"`. If there are multiple substrings of the same length, return the one that appears first.","solution":"def longest_alphabetical_substring(s): Finds the longest substring where the letters occur in alphabetical order. if not s: return \\"\\" longest = current = s[0] for i in range(1, len(s)): if s[i] >= s[i - 1]: current += s[i] else: if len(current) > len(longest): longest = current current = s[i] if len(current) > len(longest): # Check the last accumulated substring longest = current return longest"},{"question":"You are given a list of non-negative integers `nums` and a target number `target`. Your task is to implement a function that counts the number of unique pairs `(i, j)` where `i < j` and `nums[i] + nums[j] == target`. Return the count of unique pairs that satisfy this condition.","solution":"def count_unique_pairs(nums, target): Returns the count of unique pairs (i, j) where i < j and nums[i] + nums[j] == target. count = 0 seen = set() pairs = set() for i in range(len(nums)): complement = target - nums[i] if complement in seen: pairs.add((min(nums[i], complement), max(nums[i], complement))) seen.add(nums[i]) count = len(pairs) return count"},{"question":"Given an array of positive integers `chips` where `chips[i]` represents the position of the `i-th` chip on a number line, you can move a chip any number of times according to these rules: 1. Moving a chip by 2 units costs 0 energy. 2. Moving a chip by 1 unit costs 1 energy. Return the minimum amount of energy needed to move all the chips to the same position.","solution":"def minCostToMoveChips(chips): Returns the minimum amount of energy needed to move all the chips to the same position. :param chips: List[int], list of chip positions :return: int, minimum energy cost # Count the number of chips on even positions and odd positions even_count = sum(1 for chip in chips if chip % 2 == 0) odd_count = sum(1 for chip in chips if chip % 2 != 0) # The minimum energy to gather all chips to one position is to move the smaller group return min(even_count, odd_count)"},{"question":"Given an integer `n`, return _all structurally unique **BSTs** (binary search trees) that store values 1 to_ `n`. A **BST** is defined as a binary tree in which for every node, the left subtree\'s values are less than the node\'s value, and the right subtree\'s values are greater than the node\'s value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n): Generates all structurally unique BSTs (binary search trees) that store values 1 to n. if n == 0: return [] def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): # Generate all left and right subtrees left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return generate_trees(1, n)"},{"question":"You are given a 2D integer grid `grid` representing a rectangular map where `grid[i][j]` denotes the elevation at `(i, j)`. A person starts at the top-left corner of the map `(0, 0)` and wants to move to the bottom-right corner `(grid.length-1, grid[0].length-1)`. You can move up, down, left, or right, and the maximum elevation change you can handle on any move is `k`. Write a function that returns `true` if you can reach the bottom-right corner of the map within the allowed elevation change `k` for all moves, and `false` otherwise.","solution":"def can_reach_destination(grid, k): from collections import deque rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid_move(x, y, nx, ny): return 0 <= nx < rows and 0 <= ny < cols and abs(grid[nx][ny] - grid[x][y]) <= k queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(x, y, nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"You are given two arrays of integers `nums1` and `nums2`, where `nums2` is a shuffled version of `nums1` with one element missing. Write a function to return _the missing element_ that is present in `nums1` but not in `nums2`. Note: Each array could contain duplicates.","solution":"def find_missing_element(nums1, nums2): Returns the missing element that is present in nums1 but not in nums2. element_counts = {} # Count elements in nums2 for num in nums2: if num in element_counts: element_counts[num] += 1 else: element_counts[num] = 1 # Find the missing element in nums1 for num in nums1: if num not in element_counts or element_counts[num] == 0: return num else: element_counts[num] -= 1"},{"question":"You are given an integer array `arr` consisting of `n` elements, representing the heights of different buildings in a cityscape. The width of each building is `1` unit. Your task is to find the largest rectangular area that can be formed by choosing a contiguous subarray of buildings. The height of the rectangle is determined by the shortest building in the chosen subarray, and its width is the number of buildings in the subarray. Write a function to return the _maximum rectangular area_ that can be formed in the given cityscape.","solution":"def largest_rectangle_area(arr): Returns the largest rectangular area that can be formed by choosing a contiguous subarray of buildings. :param arr: List[int] representing the heights of the buildings :return: int, the largest rectangular area max_area = 0 stack = [] index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array `arr` of positive integers. Your task is to implement a function that maximizes the sum of the elements in the array while ensuring that no two selected elements are adjacent in the original array. Write a function `maxSumNonAdjacent` that takes an array of integers `arr` and returns the maximum possible sum of non-adjacent elements. For example, given the array `[3, 2, 5, 10, 7]`, the function should return `15` (by selecting elements `3, 10, and 2`). Example: - Input: `[3, 2, 5, 10, 7]` - Output: `15` Note: - You can assume that the input array has at least one element.","solution":"def maxSumNonAdjacent(arr): Given an array of positive integers, return the maximum sum of non-adjacent elements. if not arr: return 0 # Initialize the include and exclude sums include_sum = arr[0] # The maximum sum including the first element exclude_sum = 0 # The maximum sum excluding the first element for i in range(1, len(arr)): # Current max excluding i (No two adjacent sums) new_exclude_sum = max(include_sum, exclude_sum) # Current max including i include_sum = exclude_sum + arr[i] # Update exclude_sum to new_exclude_sum exclude_sum = new_exclude_sum return max(include_sum, exclude_sum)"},{"question":"Given a string `steps` consisting of the characters \'U\', \'D\', \'L\', and \'R\' representing up, down, left, and right movements respectively, determine if it is possible to return to the original position after performing all the movements in the string. Return `True` if it is possible to return to the original position, otherwise return `False`.","solution":"def is_original_position(steps): Determines if the movements in the string `steps` return to the original position. Args: steps (str): A string consisting of characters \'U\', \'D\', \'L\', and \'R\'. Returns: bool: True if it\'s possible to return to the original position, False otherwise. x, y = 0, 0 for step in steps: if step == \'U\': y += 1 elif step == \'D\': y -= 1 elif step == \'L\': x -= 1 elif step == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Design an algorithm that manages a collection of documents and allows for efficient keyword searching within the documents. Implement the `DocumentManager` class: * `void addDocument(int id, string content)`: Adds a new document with the given `id` and `content` to the collection. If a document with the same `id` already exists, it replaces the existing content. * `list<int> search(string keyword)`: Searches for documents containing the specified `keyword` and returns a list of their ids in ascending order. The keyword search should be case-insensitive. * `void removeDocument(int id)`: Removes the document with the given `id` from the collection, if it exists. Your implementation should support efficient insertion, deletion, and searching operations on the document collection.","solution":"class DocumentManager: def __init__(self): self.documents = {} def addDocument(self, id, content): Adds a new document with the given `id` and `content` to the collection. If a document with the same `id` already exists, it replaces the existing content. self.documents[id] = content def search(self, keyword): Searches for documents containing the specified `keyword` and returns a list of their ids in ascending order. The keyword search should be case-insensitive. keyword = keyword.lower() result = [doc_id for doc_id, content in self.documents.items() if keyword in content.lower()] return sorted(result) def removeDocument(self, id): Removes the document with the given `id` from the collection, if it exists. if id in self.documents: del self.documents[id]"},{"question":"Implement a caching system with a fixed capacity that supports the following operations: add an item to the cache, retrieve an item from the cache, and remove the least recently used (LRU) item if the cache reaches its capacity. Utilize appropriate data structures to ensure that both adding and retrieving items are performed in constant time. Implement the `LRUCache` class with the following methods: * `LRUCache(int capacity)` - Initializes the cache with a given capacity. * `int get(int key)` - Returns the value associated with the key if it exists in the cache, otherwise returns `-1`. * `void put(int key, int value)` - Inserts the key-value pair into the cache; if the cache reaches its capacity, remove the LRU item first. Ensure that all operations mentioned are executed as efficiently as possible.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: value = self.cache.pop(key) self.cache[key] = value return value def put(self, key: int, value: int): if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"You are given a list of strings `commands`, where each string represents a command to modify a string, initially empty. The commands can be of the following types: * `\'add_x\'`: Append the character `x` to the end of the string. * `\'remove\'`: Remove the last character from the string. * `\'undo\'`: Undo the last command applied to the string. Return the final state of the string after executing all the commands. If a \'remove\' command is executed when the string is empty, it should be ignored. If an \'undo\' command is executed with no previous command to undo, it should also be ignored.","solution":"def process_commands(commands): Processes a list of commands to modify a string, initially empty, and returns the final string after executing all the commands. Args: commands (list): List of strings representing commands. Returns: str: The resulting string after processing all commands. result = [] history = [] for command in commands: if command.startswith(\'add_\'): char = command[4:] if len(char) == 1: result.append(char) history.append((\'add\', char)) elif command == \'remove\': if result: last_char = result.pop() history.append((\'remove\', last_char)) elif command == \'undo\': if history: last_command = history.pop() action, char = last_command if action == \'add\': result.pop() elif action == \'remove\': result.append(char) return \'\'.join(result)"},{"question":"You are given a `2D` grid of dimensions `n x m`, where each cell contains either a `0` or a `1`. A position `(x, y)` in the grid is termed as **valid** if it contains a `1`. You need to determine the largest rectangle (axis-aligned) area composed entirely of `1\'s` in this grid. Return _an integer representing the area of the largest rectangle of `1\'s` found in the grid_. Here\'s the grid definition: * A grid is represented by a list of lists, where each sublist contains `n` integers (either `0` or `1`). * The grid dimensions are defined by the number of sublists (rows) and the length of each sublist (columns). Note: You may assume that the grid has at least one `row` and one `column`, and contains at least one `valid (1)` cell.","solution":"def maximalRectangle(matrix): Returns the area of the largest rectangle containing only 1\'s in a 2D binary grid. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for row in matrix: for i in range(m): heights[i] = heights[i] + 1 if row[i] == 1 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Helper function to find the largest rectangle area in a histogram. heights.append(0) stack = [-1] max_area = 0 for i in range(len(heights)): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"You are given a string `s` representing a sequence of lowercase English letters. You are also given an integer array `shifts` of the same length as `s`, where `shifts[i]` indicates by how many positions the `i-th` character of `s` is to be shifted. A shift operation changes a letter to the letter twenty-six positions for the alphabet modulo 26. Return the resulting string after all the shifts have been applied to `s`. Note that the shifts should be applied incrementally: apply shifts[0] to s[0], then shifts[1] to s[1], and so on.","solution":"def shifting_letters(s, shifts): Shifts each character in the string s according to the corresponding value in the shifts array. result = [] for i, char in enumerate(s): new_char = chr((ord(char) - ord(\'a\') + shifts[i]) % 26 + ord(\'a\')) result.append(new_char) return \'\'.join(result)"},{"question":"You are given a **0-indexed** integer array `weights` representing the weight of `n` different items. You are also given an integer `capacity` representing the maximum weight that a knapsack can carry. The array `weights` contains **approximately distinct** weights. You need to fit the maximum number of items into the knapsack without exceeding the `capacity`. Return _the **maximum** number of items that can be included in the knapsack._","solution":"def max_items_in_knapsack(weights, capacity): Returns the maximum number of items that can be included in the knapsack without exceeding the given capacity. weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= capacity: total_weight += weight count += 1 else: break return count"},{"question":"Given a string `s` consisting of lowercase English letters, you need to encode the string as follows: For each group of consecutive identical letters, replace them with a single instance of that letter followed by the number of occurrences of that letter in the group. For example, the string `aaabbc` would be encoded as `a3b2c1`. Return the encoded string. --- The provided question offers a clear, step-by-step problem that falls in line with the style and complexity of the original set. It requires understanding of string manipulation and basic encoding techniques, ensuring the challenge remains consistent with the cognitive and technical demands presented in the existing assessment.","solution":"def encode_string(s): Encodes a string by replacing groups of consecutive identical letters with a single instance of that letter followed by the number of occurrences. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The encoded string. if not s: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: encoded_str.append(s[i-1] + str(count)) count = 1 # Add the last group encoded_str.append(s[-1] + str(count)) return \'\'.join(encoded_str)"},{"question":"You are given two **0-indexed** arrays, `startTime` and `endTime`, each consisting of `n` integers. The `i-th` element in `startTime` represents the starting time of the `i-th` job, and the `i-th` element in `endTime` represents the ending time of the `i-th` job. Two jobs are considered **compatible** if one\'s ending time is less than or equal to the other one\'s starting time. You are tasked with finding the maximum number of compatible jobs. Return _an integer representing the maximum number of compatible jobs_ you can select from the given job schedules.","solution":"def max_compatible_jobs(startTime, endTime): Finds the maximum number of compatible jobs. Args: startTime (list): List of start times of jobs. endTime (list): List of end times of jobs. Returns: int: The maximum number of compatible jobs. # Combine the start and end times jobs = sorted(zip(endTime, startTime)) # Initialize variables to keep track of the job count and the end time of the last selected job max_jobs = 0 last_end_time = -1 for end, start in jobs: if start >= last_end_time: max_jobs += 1 last_end_time = end return max_jobs"},{"question":"You are given a list of strings representing log entries from various servers. Each log entry is formatted as \\"timestamp server_id log_level message\\". Your task is to implement a system to query these logs based on multiple criteria. Create a `LogSystem` class with the following functionalities: - `LogSystem()`: Initializes the log system. - `void put_log(String log)`: Adds a new log entry to the system. - `List<String> get_logs(int start_time, int end_time, List<String> server_ids, String log_level)`: Returns the list of log entries that match the specified criteria. The logs should be within the time range provided `[start_time, end_time]` (inclusive both ends), originate from one of the specified `server_ids`, and have the given `log_level`. The log entries in the returned list should be sorted by `timestamp` in ascending order.","solution":"from typing import List class LogSystem: def __init__(self): self.logs = [] def put_log(self, log: str): self.logs.append(log) def get_logs(self, start_time: int, end_time: int, server_ids: List[str], log_level: str) -> List[str]: result = [] for log in self.logs: parts = log.split() timestamp = int(parts[0]) server_id = parts[1] log_lvl = parts[2] if start_time <= timestamp <= end_time and server_id in server_ids and log_lvl == log_level: result.append(log) result.sort(key=lambda log: int(log.split()[0])) return result"},{"question":"Given a binary tree, determine if it is a complete binary tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. Design and implement a function `isCompleteTree` that takes the root of a binary tree and returns `true` if the tree is complete; otherwise, it returns `false`. Considerations should be made to ensure the solution handles large trees efficiently.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCompleteTree(root): if not root: return True queue = deque([root]) end = False # This flag indicates if we\'ve encountered a missing child. while queue: node = queue.popleft() if not node: end = True # If we encounter a null node, all subsequent nodes must also be null for a complete tree else: if end: return False # If we have previously encountered a null node, the tree can\'t be complete queue.append(node.left) queue.append(node.right) return True"},{"question":"You are given a list of `n` projects, each represented by a pair `[ai, bi]`, where `ai` is the profit you earn by completing the project, and `bi` is the number of hours required to complete it. You have `H` hours available and want to maximize your profit. You can only work on one project at a time, and you cannot partially complete a project. Write a function that returns the maximum profit you can achieve by selecting a subset of projects to work on, given the constraints on total working hours `H`.","solution":"def max_profit(projects, H): Returns the maximum profit given a list of projects and the total available hours. Parameters: projects (list): A list of pairs, each representing the profit and the hours required for a project. H (int): The total available hours. Returns: int: The maximum profit that can be achieved within the available hours. # dp[i] will store the maximum profit possible with i hours available dp = [0] * (H + 1) # Iterate through each project for profit, hours in projects: # Traverse dp array backwards to avoid recomputation with the same project for h in range(H, hours - 1, -1): dp[h] = max(dp[h], dp[h - hours] + profit) return dp[H]"},{"question":"You are given two **0-indexed** integer arrays, `profits` and `capital`, where `profits[i]` is the profit from the `i-th` project and `capital[i]` is the minimum capital required to start the corresponding project. You have an initial capital of `initialCapital` and you are allowed to invest in at most `k` different projects. Return _the maximum total profit you can achieve after at most `k` investments_.","solution":"import heapq def find_maximized_capital(k, initialCapital, profits, capital): Find the maximum total profit after at most k investments. Parameters: - k (int): the maximum number of projects you can invest in. - initialCapital (int): the initial capital available. - profits (List[int]): the profits from each project. - capital (List[int]): the minimum capital required for each project. Returns: - int: the maximum total profit achievable after at most k investments. projects = list(zip(capital, profits)) projects.sort() max_profit = 0 capital_available = initialCapital possible_projects = [] index = 0 for _ in range(k): while index < len(projects) and projects[index][0] <= capital_available: heapq.heappush(possible_projects, -projects[index][1]) index += 1 if possible_projects: capital_available += -heapq.heappop(possible_projects) else: break return capital_available"},{"question":"You are given two arrays, `piles` and `rocks`, where each element in `piles` represents the maximum capacity of each pile to hold rocks, and `rocks` represents the initial number of rocks in each pile. Additionally, you are given an integer `additionalRocks` which represents the extra rocks you have. Your task is to maximize the number of piles that can be filled to their capacity by strategically adding the `additionalRocks` to the piles. Return _the maximum number of piles that can be completely filled_.","solution":"def max_filled_piles(piles, rocks, additionalRocks): Return the maximum number of piles that can be completely filled. :param piles: List[int] - Maximum capacities of each pile :param rocks: List[int] - Initial number of rocks in each pile :param additionalRocks: int - Extra rocks available :return: int - Maximum number of completely filled piles needed_rocks = [piles[i] - rocks[i] for i in range(len(piles))] needed_rocks.sort() filled_piles = 0 for needed in needed_rocks: if additionalRocks >= needed: additionalRocks -= needed filled_piles += 1 else: break return filled_piles"},{"question":"You are given an array `heights` representing the heights of buildings in a line. You need to place a number of water tanks such that every building in the array has access to a water tank within a given distance `d`. Each water tank can only supply water to buildings within `d` distance from it. Determine the minimum number of water tanks required to ensure every building has access to water.","solution":"def min_water_tanks(heights, d): Determines the minimum number of water tanks required to ensure every building has access to water supply within a given distance `d`. Parameters: heights (list of int): The heights of the buildings. d (int): Maximum distance a water tank can supply water. Returns: int: Minimum number of water tanks required. n = len(heights) if n == 0: return 0 tanks = 0 i = 0 while i < n: tanks += 1 # Place a tank farthest_dist = i + d # Calculate the farthest distance for current tank # Find the best spot to place the tank (within the range which maximizes coverage) while i < n and i <= farthest_dist: i += 1 + d # Move to the next building outside the current tank\'s range if i >= n: # All buildings are covered break return tanks"},{"question":"You have a binary tree in which each node contains an integer value. Some of the nodes in the binary tree are \\"colored\\" using two colors: **red** and **blue**. A \\"color path\\" is defined as a path that starts from the root and ends at any leaf node, passing through at least one node of a particular color (either red or blue). Write a function to return the number of unique color paths for both colors separately. The function should return a tuple in the form `(red_paths, blue_paths)` where `red_paths` is the number of unique paths that include at least one red node, and `blue_paths` is the number of unique paths that include at least one blue node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, color=None): self.val = val self.left = left self.right = right # color can be \'red\', \'blue\', or None self.color = color def count_color_paths(root): def dfs(node, has_red, has_blue): if node is None: return 0, 0 new_has_red = has_red or node.color == \'red\' new_has_blue = has_blue or node.color == \'blue\' if node.left is None and node.right is None: return (1 if new_has_red else 0, 1 if new_has_blue else 0) left_red_paths, left_blue_paths = dfs(node.left, new_has_red, new_has_blue) right_red_paths, right_blue_paths = dfs(node.right, new_has_red, new_has_blue) return (left_red_paths + right_red_paths, left_blue_paths + right_blue_paths) return dfs(root, False, False)"},{"question":"Given an array of strings `words`, return _the longest string in `words` that can be constructed by concatenating other strings from `words`_. If there is no such string, return an empty string. Each string in `words` is unique.","solution":"def can_form_word(word, words_set, memo): Helper function to determine if a word can be formed by concatenating other words in the set. if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and (suffix in words_set or can_form_word(suffix, words_set, memo)): memo[word] = True return True memo[word] = False return False def longest_concatenated_word(words): Returns the longest string in words that can be constructed by concatenating other strings from words. If there is no such string, returns an empty string. words_set = set(words) memo = {} longest_word = \\"\\" for word in words: if can_form_word(word, words_set, memo): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"You are given an integer array `nums` where each element represents the cost of a movie ticket on a particular day. A movie enthusiast wants to watch one movie per day over a continuous period, starting from any day, and looks to minimize the total cost. Given an integer `d` representing the maximum number of days the enthusiast is willing to consider for watching movies, return the _minimum possible cost_ for watching exactly `d` consecutive days of movies. If it is not possible to watch movies for `d` consecutive days, return `-1`.","solution":"def min_cost_for_consecutive_days(nums, d): Returns the minimum possible cost for watching exactly d consecutive days of movies. If it is not possible to watch movies for d consecutive days, returns -1. if len(nums) < d: return -1 # Calculate the initial sum of the first `d` days. min_cost = sum(nums[:d]) current_cost = min_cost # Use a sliding window to calculate the sum of every possible `d` consecutive days. for i in range(d, len(nums)): current_cost += nums[i] - nums[i - d] # Adjust the window sum by adding the new element and removing the old one if current_cost < min_cost: min_cost = current_cost return min_cost"},{"question":"You are given a square grid of size `n` representing a city map where each cell is either land (`0`) or a building (`1`). You need to identify the shortest distance from each land cell to any building. The distance is defined as the number of steps in the four possible directions (up, down, left, right). If it is not possible for a land cell to reach any building, return `-1` for that cell. Return a 2D array where each cell contains the shortest distance to a building or `-1` if unreachable.","solution":"from collections import deque def shortest_distance_to_building(grid): n = len(grid) if n == 0: return [] def bfs(start_row, start_col): queue = deque([(start_row, start_col, 0)]) visited = set([(start_row, start_col)]) distances = [[-1] * n for _ in range(n)] while queue: row, col, dist = queue.popleft() distances[row][col] = dist for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < n and (r, c) not in visited and grid[r][c] == 0: visited.add((r, c)) queue.append((r, c, dist + 1)) return distances result = [[-1] * n for _ in range(n)] for row in range(n): for col in range(n): if grid[row][col] == 0: result[row][col] = float(\'inf\') for r in range(n): for c in range(n): if grid[r][c] == 1: building_distances = bfs(r, c) if building_distances[row][col] != -1: result[row][col] = min(result[row][col], building_distances[row][col]) if result[row][col] == float(\'inf\'): result[row][col] = -1 return result"},{"question":"Given a **sorted** array of distinct integers `arr`, write a function that finds a pair of elements that sum to a given target value `t`. Return _the pair of indices_ `[i, j]` _such that_ `arr[i] + arr[j] == t`, _where_ `i < j`. If no such pair exists, return `[-1, -1]`. Your solution should have a time complexity of O(n).","solution":"def find_pair_with_sum(arr, t): Returns the pair of indices [i, j] such that arr[i] + arr[j] == t, where i < j. If no such pair exists, returns [-1, -1]. :param arr: List[int], a sorted array of distinct integers :param t: int, the target sum :return: List[int], the pair of indices or [-1, -1] if no such pair exists left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == t: return [left, right] elif current_sum < t: left += 1 else: right -= 1 return [-1, -1]"},{"question":"You are given a **0-indexed** integer array `nums` with length `n` and an integer `k`. Your task is to partition the array into exactly `k` non-empty subsets such that the maximum sum of any subset is minimized. Return the minimized maximum sum.","solution":"def can_partition(nums, k, max_sum): Helper function to check if we can partition the array into k subsets with each subset having a sum less than or equal to max_sum. current_sum = 0 subsets = 1 for num in nums: if current_sum + num > max_sum: subsets += 1 current_sum = num if subsets > k: return False else: current_sum += num return True def minimized_maximum_sum(nums, k): Returns the minimized maximum sum of any subset when partitioning the array into exactly k non-empty subsets. left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_partition(nums, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a binary tree in which each node contains an integer value. Design a class `BinaryTree` that includes the following methods: * `BinaryTree(List<Integer> values)` - Initializes the tree with values from the given list, where `null` represents a missing node. * `int findDeepestNode()` - Returns the value of the deepest node in the binary tree. * `int getLeafCount()` - Returns the number of leaf nodes in the binary tree. * `boolean isBalanced()` - Returns `true` if the binary tree is height-balanced (a binary tree in which the left and right subtrees of every node differ in height by no more than 1), otherwise returns `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, values): self.root = self._build_tree(values) def _build_tree(self, values): if not values: return None nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def findDeepestNode(self): if not self.root: return None q = [self.root] node = None while q: node = q.pop(0) if node.left: q.append(node.left) if node.right: q.append(node.right) return node.val if node else None def getLeafCount(self): if not self.root: return 0 leaf_count = 0 q = [self.root] while q: node = q.pop(0) if not node.left and not node.right: leaf_count += 1 if node.left: q.append(node.left) if node.right: q.append(node.right) return leaf_count def isBalanced(self): def check(root): if not root: return 0, True left_height, left_balanced = check(root.left) right_height, right_balanced = check(root.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balanced = check(self.root) return balanced"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2` of equal length `n`. Analyze the values at each matching index of the two arrays and determine a new integer array `maxValues` of length `n` such that `maxValues[i] = max(nums1[i], nums2[i])` for every `i` from `0` to `n - 1`. Additionally, compute the **sum** of all the elements in `maxValues`. Implement the `MaxValuesSum` class: * `MaxValuesSum(int[] nums1, int[] nums2)` Initializes the object with the two integer arrays `nums1` and `nums2`. * `int[] calculateMaxValues()` Returns the resulting array `maxValues` that contains the maximum values at each index from the two input arrays. * `int sumMaxValues(int[] maxValues)` Returns the **sum** of all the elements in the `maxValues` array.","solution":"class MaxValuesSum: def __init__(self, nums1, nums2): self.nums1 = nums1 self.nums2 = nums2 def calculateMaxValues(self): return [max(a, b) for a, b in zip(self.nums1, self.nums2)] def sumMaxValues(self, maxValues): return sum(maxValues)"},{"question":"Given the `head` of a singly linked list, reverse the list, and return the reversed list. The linked list is defined as follows: ```cpp struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; ``` Design and implement a function that takes the `head` of the linked list and returns the new head after reversing the list. The function should have a linear time complexity of O(n) and use O(1) extra space.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head): Reverses a singly linked list. :param head: ListNode, the head of the linked list :return: ListNode, the new head of the reversed linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Given a list of `n` integers, return _the length of the longest subarray of consecutive numbers_ such that the absolute difference between the maximum and minimum number in this subarray does not exceed a given integer `k`.","solution":"def longest_subarray_with_diff(nums, k): Returns the length of the longest subarray where the absolute difference between the maximum and minimum number in the subarray does not exceed k. if not nums: return 0 left = 0 max_len = 0 current_min = nums[0] current_max = nums[0] for right in range(len(nums)): current_min = min(current_min, nums[right]) current_max = max(current_max, nums[right]) while current_max - current_min > k: left += 1 current_min = min(nums[left:right+1]) current_max = max(nums[left:right+1]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a binary tree where each node has a unique value. Each node has properties `val`, `left`, and `right`, which correspond to its value and its left and right children respectively. Implement a function to serialize and deserialize the binary tree. * Serialization is the process of converting a tree to a single string representation. * Deserialization is the process of converting the string representation back to the original tree structure. Implement the `Codec` class: * `String serialize(TreeNode root)` Serializes the binary tree rooted at `root` into a single string. * `TreeNode deserialize(String data)` Deserializes the string representation `data` back into the original binary tree structure. Your code will be tested with the following pseudocode: initialize codec with codec = Codec() serialize the binary tree with codec.serialize(root) deserialize the string back to binary tree with codec.deserialize(serializedString) compare the original tree and the deserialized tree for structural and value equality If the deserialized tree matches the original tree, then your code will be judged as correct.","solution":"import json class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Codec: def serialize(self, root): Encodes a tree to a single string. def rserialize(node): if node is None: return [\\"null\\"] return [str(node.val)] + rserialize(node.left) + rserialize(node.right) return json.dumps(rserialize(root)) def deserialize(self, data): Decodes your encoded data to tree. def rdeserialize(data_list): if data_list[0] == \\"null\\": data_list.pop(0) return None root = TreeNode(int(data_list.pop(0))) root.left = rdeserialize(data_list) root.right = rdeserialize(data_list) return root data_list = json.loads(data) return rdeserialize(data_list)"},{"question":"You are given an integer array `arr` of size `n` and an integer `k`. You want to find the minimum number of changes needed to make the array `_k-regular_`. An array is defined as `_k-regular_` if each element in the array has the same parity (i.e., even or odd), and the difference between maximum and minimum element is at most `k`. You are allowed to change any element in the array to any other integer. Return the minimum number of changes needed to make the array `_k-regular_`.","solution":"def min_changes_to_make_k_regular(arr, k): Returns the minimum number of changes needed to make the array k-regular. :param arr: List[int] - The input array of integers :param k: int - The regularity parameter :return: int - The minimum number of changes needed n = len(arr) evens = sum(1 for x in arr if x % 2 == 0) odds = n - evens changes_to_all_even = odds changes_to_all_odd = evens return min(changes_to_all_even, changes_to_all_odd)"},{"question":"You are given a 2D integer matrix `grid` representing a grid of dimensions `m x n`, where each cell in the grid contains an integer representing the elevation at that point. You are also given an integer `waterLevel` representing the height up to which water exists in the grid. A cell is flooded if its elevation is less than or equal to the `waterLevel`. You can move between any two adjacent cells horizontally or vertically. Return _the total number of distinct cells that can be reached starting from any non-flooded cell._","solution":"def countReachableCells(grid, waterLevel): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and not visited[x][y] and grid[x][y] > waterLevel def dfs(x, y): stack = [(x, y)] count = 0 while stack: cx, cy = stack.pop() if not is_valid(cx, cy): continue visited[cx][cy] = True count += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if is_valid(nx, ny): stack.append((nx, ny)) return count reachable_cells = 0 for i in range(m): for j in range(n): if grid[i][j] > waterLevel and not visited[i][j]: reachable_cells += dfs(i, j) return reachable_cells"},{"question":"Given an array of integers `arr` and an integer `target`, return the number of **unique pairs** of integers in `arr` whose sum is equal to `target`. A pair (arr[i], arr[j]) is considered unique if there are no other pairs (arr[k], arr[l]) where (arr[i] == arr[k] and arr[j] == arr[l]) or (arr[i] == arr[l] and arr[j] == arr[k]).","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs of integers in `arr` whose sum is equal to `target`. seen = set() unique_pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) unique_pairs.add(pair) seen.add(num) return len(unique_pairs)"},{"question":"You are given a linked list in which each node contains an integer value. You are also given an integer `k` such that 1 <= `k` <= the length of the linked list. Your task is to remove the k-th node from the end of the list and return the head of the modified linked list. Note that the k-th node from the end is the node that is `k` positions from the last node towards the head of the list. Make sure your algorithm handles edge cases such as removing the last node or the only node in the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head, k): Removes the k-th node from the end of the list and returns the head of the modified list. :param head: ListNode, the head of the linked list. :param k: int, the position from the end of the list to remove the node. :return: ListNode, the head of the modified linked list. # Create a dummy node to simplify edge cases dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first pointer k+1 steps ahead for _ in range(k + 1): first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Remove the k-th node from the end second.next = second.next.next return dummy.next"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters. You need to find the longest substring of `s` that contains no more than two distinct characters. Return the length of such a substring. If there are multiple such substrings with the maximum length, return the length of any one of them.","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 max_len = 2 char_map = {} while right < n: char_map[s[right]] = right right += 1 if len(char_map) == 3: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"Given a binary tree, return the **maximum depth** of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. The tree is represented using a TreeNode class where each node has an integer `val`, and two children left and right, which may be null.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Returns the maximum depth of the binary tree with root node as root. :param root: TreeNode, the root node of the binary tree :return: int, maximum depth of the binary tree if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are given a string `s` and an integer `k`. A **subsequence** of `s` is created by deleting some (or none) of the characters in `s` without changing the order of the remaining characters. A subsequence is considered **k-distinct** if it contains at most `k` distinct characters. Return _the length of the longest k-distinct subsequence_ of `s`.","solution":"def longest_k_distinct_subsequence(s, k): Returns the length of the longest k-distinct subsequence of s. Parameters: s (str): The string in which we are finding the subsequence. k (int): The maximum number of distinct characters allowed in the subsequence. Returns: int: The length of the longest k-distinct subsequence. if k == 0: return 0 from collections import defaultdict n = len(s) char_counts = defaultdict(int) distinct_count = 0 left = 0 max_length = 0 for right in range(n): if char_counts[s[right]] == 0: distinct_count += 1 char_counts[s[right]] += 1 while distinct_count > k: char_counts[s[left]] -= 1 if char_counts[s[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Suppose you are given a matrix of integers `matrix` with dimensions `m x n`. The values in each row and column are sorted in ascending order. Implement a function `searchMatrix` that takes the matrix and an integer `target`, and returns `true` if `target` is found in the matrix, and `false` otherwise. Your solution should have a time complexity better than O(m * n).","solution":"def searchMatrix(matrix, target): Search a target value in a matrix. The matrix is sorted in ascending order both row-wise and column-wise. :param matrix: List[List[int]], the 2D matrix to search. :param target: int, the target value to search for in the matrix. :return: bool, True if target is found in the matrix, otherwise False. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) # Start from top-right corner of the matrix row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"Given an array of `n` integers where each integer represents a type of plant. The `i-th` plant in the array is watered every `i-th` day. A plant type can only remain healthy if it is watered at least once every `unhealthy_days` consecutive days. Determine the maximum number of healthy plants after `k` days. Return the maximum number of healthy plants.","solution":"def max_healthy_plants(plants, unhealthy_days, k): Determines the maximum number of healthy plants after k days. Parameters: plants (list): A list of integers representing plant types. unhealthy_days (int): The number of days within which a plant must be watered to remain healthy. k (int): The number of days available to water the plants. Returns: int: The maximum number of healthy plants. total_plants = len(plants) if unhealthy_days > k: return 0 # Not enough days to keep any plant healthy plant_water_count = [0] * total_plants for day in range(k): plant_water_count[day % total_plants] += 1 # Water the plant as per its watering schedule healthy_plants = sum(1 for water_count in plant_water_count if water_count >= unhealthy_days) return healthy_plants"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return an array of the values of the nodes you can see ordered from top to bottom. Each node in the tree contains an integer value and you are specifically looking for the **right side view** of the tree. Consider that each node has only up to two children: a left child and a right child.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [(root, 0)] rightmost_value_at_depth = {} max_depth = -1 while queue: node, depth = queue.pop(0) if node is not None: max_depth = max(max_depth, depth) rightmost_value_at_depth[depth] = node.val queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]"},{"question":"You are given an array of integers `arr` and an integer `d`. In one step, you can move from index `i` to index `i + j` or `i - j` where `1 <= j <= d` and `arr[i] > arr[i + j]` or `arr[i] > arr[i - j]` respectively. You cannot move outside of the array boundaries. Determine the maximum number of indices you can visit starting from any index in the array. Note that you must move strictly to a smaller integer at each step. Return _the maximum number of indices you can visit_ from any starting index in the array.","solution":"def maxJumps(arr, d): Returns the maximum number of indices that can be visited starting from any index in the array. n = len(arr) # Memoization table. memo = [-1] * n def dfs(i): if memo[i] != -1: return memo[i] max_jump_count = 1 # Move to the right for j in range(i + 1, min(n, i + d + 1)): if arr[i] > arr[j]: max_jump_count = max(max_jump_count, 1 + dfs(j)) else: break # Move to the left for j in range(i - 1, max(-1, i - d - 1), -1): if arr[i] > arr[j]: max_jump_count = max(max_jump_count, 1 + dfs(j)) else: break memo[i] = max_jump_count return max_jump_count max_count = 0 for i in range(n): max_count = max(max_count, dfs(i)) return max_count"},{"question":"You are given a string `s` and an integer array `positions` of the same length, where each element in `positions` is unique and represents the initial index of each character in the string. * Perform a cyclic right shift on the string such that each character at `s[i]` moves to the index represented by `positions[i]`. * For example, if `s = \\"abcd\\"` and `positions = [3, 0, 1, 2]`, the character at `s[0]` (\'a\') moves to index `3`, `s[1]` (\'b\') moves to index `0`, and so on. Return _the resulting string after performing the shift_.","solution":"def cyclic_right_shift(s, positions): Perform a cyclic right shift on the string `s` using the `positions` array. Parameters: s (str): The input string. positions (List[int]): The list of positions to shift characters to. Returns: str: The resulting string after performing the shift. n = len(s) result = [\'\'] * n # Initialize a list to hold the resulting characters for i, pos in enumerate(positions): result[pos] = s[i] return \'\'.join(result)"},{"question":"You are given an integer array `arr` of length `n`, and an integer `d`. Your task is to return the **maximum length** of a subarray where the absolute difference between the maximum value and the minimum value in the subarray does not exceed `d`. A subarray is a contiguous subsequence of the array. For example, if `arr` is `[4, 7, 2, 9, 3]` and `d` is `3`, one of the possible valid subarrays is `[4, 7, 2]`, where the maximum value is `7`, the minimum value is `2`, and their absolute difference is `5`. Hence, the length of the subarray `[4, 7, 2]` is `3`. Return the maximum length out of all possible valid subarrays.","solution":"def max_length_subarray(arr, d): Returns the maximum length of a subarray where the absolute difference between the maximum value and the minimum value in the subarray does not exceed d. from collections import deque if not arr: return 0 max_len = 0 min_dq, max_dq = deque(), deque() left = 0 for right in range(len(arr)): while min_dq and arr[min_dq[-1]] >= arr[right]: min_dq.pop() while max_dq and arr[max_dq[-1]] <= arr[right]: max_dq.pop() min_dq.append(right) max_dq.append(right) while arr[max_dq[0]] - arr[min_dq[0]] > d: if min_dq[0] == left: min_dq.popleft() if max_dq[0] == left: max_dq.popleft() left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of integers `nums` representing the length of logs of wood. You must create beams of wood with a specific target length `k`. A beam can be made by taking any number of logs from the list and cutting them so that their lengths sum up to exactly `k`. You can assume that the leftover pieces from cutting the logs are discarded. Each log can be used only once. Write a function that determines the **minimum number of cuts** needed to form beams of length `k` using the provided logs. If it is not possible to form a beam of length `k` using the provided logs, return `-1`. For example: ```python nums = [5, 4, 3, 7] k = 10 ``` The output should be `2`, as we can cut two logs of length `3` and `7` to form a beam of length `10`.","solution":"from typing import List def min_cuts_to_form_beam(nums: List[int], k: int) -> int: Determines the minimum number of cuts needed to form beams of length `k` using the provided logs (nums). If it is not possible, returns -1. # Edge case: if k is zero, no cuts needed. if k == 0: return 0 # Sort the list of logs in descending order nums.sort(reverse=True) # Helper function to check if we can make the beam of length `k` with available logs def can_make_beam(nums, k): n = len(nums) dp = [float(\'inf\')] * (k + 1) dp[0] = 0 for num in nums: for i in range(k, num - 1, -1): dp[i] = min(dp[i], dp[i - num] + 1) return dp[k] if dp[k] != float(\'inf\') else -1 result = can_make_beam(nums, k) return result"},{"question":"You have a list of strings `words` and a list of phrases `phrases`. Each phrase is a string consisting of space-separated words. Return a list of integers where `result[i]` is the number of words from the list `words` that appear in the phrase `phrases[i]`. Each word and phrase is composed of lowercase English letters and the length of each word and phrase can vary.","solution":"def count_words_in_phrases(words, phrases): Given a list of words and a list of phrases, returns a list where each element is the count of words from the list that appear in the corresponding phrase. :param words: List of words. :param phrases: List of phrases. :return: List of integer counts. result = [] for phrase in phrases: phrase_words = set(phrase.split()) count = sum(1 for word in words if word in phrase_words) result.append(count) return result"},{"question":"You are given a 2D grid representing a map where `0` represents water and `1` represents land. The grid cells are connected horizontally or vertically (not diagonally). An island is a maximal group of land cells connected this way. Given a 2D grid, return _the number of distinct islands_ in the grid. Two islands are considered different if their shapes are different, even if they are positioned identically on the grid. The shape of an island is represented by the relative positions of the land cells to an arbitrary starting point.","solution":"def num_distinct_islands(grid): def dfs(x, y, direction, shape): if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: grid[x][y] = 0 shape.append(direction) dfs(x + 1, y, \'D\', shape) dfs(x - 1, y, \'U\', shape) dfs(x, y + 1, \'R\', shape) dfs(x, y - 1, \'L\', shape) shape.append(\'B\') unique_islands = set() for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == 1: shape = [] dfs(i, j, \'O\', shape) unique_islands.add(tuple(shape)) return len(unique_islands)"},{"question":"You are given a collection of `n` intervals, where each interval is represented as a pair of integers `[start, end]`. The intervals may overlap. A new interval `[new_start, new_end]` is to be added to this collection. Your task is to merge the new interval into the collection such that after the merge, there are no overlapping intervals. If intervals overlap, you should merge them into a single interval. Return _the updated list of intervals after merging the new interval_. Each interval is defined as starting before or at the same time as ending: `start <= end`. The intervals may not be sorted, and may contain equal intervals or intervals with the same start or end times.","solution":"def merge_intervals(intervals, new_interval): Merges a new interval into a collection of existing intervals such that there are no overlapping intervals. Args: intervals (List[List[int]]): a list of existing intervals represented as [start, end] new_interval (List[int]): the new interval to be added and merged Returns: List[List[int]]: The updated list of intervals after merging the new interval intervals.append(new_interval) # Sort intervals based on the starting times, if equal then based on ending times intervals.sort(key=lambda x: (x[0], x[1])) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval does not overlap with the previous if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # there is overlap, so we merge the current and previous intervals merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"A university is planning to conduct a coding competition and has a list of `n` students. The students are numbered from `0` to `n - 1`, and each student has provided a list of **preferred** coding partners. Each student can work with multiple students, and a student will only participate if at least one of their preferred partners is also participating. Given a `0-indexed` list of lists `preferences` where `preferences[i]` contains a list of indices representing the preferred partners of the `i`th student, return _the **maximum number of students** that can be paired up to participate in the competition_.","solution":"def max_participating_students(preferences): Returns the maximum number of students that can participate in the competition. :param preferences: List[List[int]] :return: int def dfs(student, visited, preferences): visited[student] = True count = 1 # including the current student for partner in preferences[student]: if not visited[partner]: count += dfs(partner, visited, preferences) return count n = len(preferences) if n == 0: return 0 max_students = 0 visited = [False] * n for student in range(n): if not visited[student] and preferences[student]: max_students = max(max_students, dfs(student, visited, preferences)) return max_students"},{"question":"Given an integer array `heights` representing the heights of buildings in a row, a building is considered a \\"sunset view\\" building if its height is greater than all the buildings to its right. Return _the indices of all \\"sunset view\\" buildings in ascending order of their indices_.","solution":"def sunsetViews(heights): Given an integer array heights representing the heights of buildings in a row, this function returns the indices of all \\"sunset view\\" buildings in ascending order of their indices. A building is considered a \\"sunset view\\" building if its height is greater than all the buildings to its right. sunset_buildings = [] max_height = -1 for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height: sunset_buildings.append(i) max_height = heights[i] return list(sorted(sunset_buildings))"},{"question":"You are given an array `arr` consisting of `n` integers. A subarray is called **special** if its length is at least `3` and all its elements are distinct. Your task is to determine the length of the longest **special** subarray in `arr`. If no such subarray exists, return `0`.","solution":"def length_of_longest_special_subarray(arr): Returns the length of the longest special subarray from the given array. A special subarray has at least 3 distinct elements. n = len(arr) if n < 3: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen and seen[arr[end]] >= start: start = seen[arr[end]] + 1 seen[arr[end]] = end current_subarray_length = end - start + 1 if current_subarray_length >= 3: max_len = max(max_len, current_subarray_length) return max_len"},{"question":"You are given an integer array `nums` and an integer `k`. Find the maximum sum of a non-empty subarray of length `k` in the array `nums`. The subarray should contain exactly `k` consecutive elements from `nums`. Return the maximum sum of such a subarray. If the array length is less than `k`, return 0.","solution":"def max_sum_subarray_k(nums, k): Returns the maximum sum of any non-empty subarray of length \'k\' in the array \'nums\'. If \'nums\' length is less than \'k\', return 0. n = len(nums) if n < k: return 0 # Compute the sum of the first subarray of length k max_sum = sum(nums[:k]) current_sum = max_sum # Use a sliding window to compute the sum of the remaining subarrays of length k for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Your task is to implement a function to find the smallest element in an unsorted array that is greater than a given target. If no such element exists, return `-1`. The function should have the signature: ```python def next_greater_element(arr: List[int], target: int) -> int: ``` **Example:** ``` Input: arr = [7, 1, 3, 4, 9, 2], target = 5 Output: 7 Explanation: The smallest element greater than 5 in the array is 7. Input: arr = [2, 3, 4], target = 4 Output: -1 Explanation: There is no element greater than 4 in the array. Input: arr = [5, 8, 9, 3], target = 6 Output: 8 Explanation: The smallest element greater than 6 in the array is 8. ``` Ensure your function runs efficiently and handles edge cases appropriately.","solution":"from typing import List def next_greater_element(arr: List[int], target: int) -> int: Finds the smallest element in an unsorted array that is greater than the given target. If no such element exists, return -1. min_greater = float(\'inf\') for num in arr: if num > target and num < min_greater: min_greater = num return min_greater if min_greater != float(\'inf\') else -1"},{"question":"A **square matrix** is given, where each cell contains an integer value. The matrix is said to have a **special diagonal** if the diagonal from the top left to the bottom right (main diagonal) or from the top right to the bottom left (anti-diagonal) contains all the same values. Write a function that checks if a given square matrix has a special diagonal. Given the input `matrix`, return _a boolean value_ indicating whether the matrix has any special diagonal.","solution":"def has_special_diagonal(matrix): Checks if the given square matrix has a special diagonal. A matrix has a special diagonal if either the main diagonal (top-left to bottom-right) or the anti-diagonal (top-right to bottom-left) contains all the same values. Args: matrix (list of list of int): The square matrix to check. Returns: bool: True if the matrix has a special diagonal, False otherwise. size = len(matrix) # Check main diagonal main_diag_value = matrix[0][0] main_diag_special = all(matrix[i][i] == main_diag_value for i in range(size)) # Check anti-diagonal anti_diag_value = matrix[0][size-1] anti_diag_special = all(matrix[i][size-1-i] == anti_diag_value for i in range(size)) return main_diag_special or anti_diag_special"},{"question":"You are given a string `s` consisting of lowercase English letters. Return the length of the longest substring with all characters the same. A substring is a contiguous sequence of characters within a string. For example, given `s = \\"aaabbccaa\\"`, return `3` since the longest substring with all characters the same is `\\"aaa\\"`.","solution":"def longest_substring_same_char(s): Given a string s consisting of lowercase English letters, return the length of the longest substring with all characters the same. if not s: return 0 max_length = current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"Given a list of integers, write a function that finds the maximum product of three integers within the list. The function should return the maximum product value. The list will contain at least three integers and could contain negative numbers. Consider different scenarios including large negative numbers and a combination of positive and negative values.","solution":"def maximum_product_of_three(nums): Returns the maximum product of three numbers in the list. nums.sort() return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])"},{"question":"You are given a binary search tree (BST) where each node contains an integer value. Design an algorithm to find the **k-th smallest** element in the BST (1-based index). Assume that `k` is always valid, i.e., `1  k  number of nodes in the BST`. The algorithm should have an average time complexity of `O(h + k)`, where `h` is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the k-th smallest element in the BST. def inorder(node): if not node: return [] return inorder(node.left) + [node.val] + inorder(node.right) return inorder(root)[k-1]"},{"question":"Given a binary tree, return the **list of all root-to-leaf paths** such that the **sum of the values** of the nodes in each path is **equal to a given number** `targetSum`. A leaf is a node with no children. Each path should be represented as a list of node values, and the result should be returned as a list of these lists. The binary tree is represented by its root node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): Returns all root-to-leaf paths in a binary tree where the sum of the node values in each path equals targetSum. def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == targetSum: result.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"You are given an integer `x`, find the minimum number of perfect square numbers (for example, `1`, `4`, `9`, `16`, ...) that sum to `x`. Return _the minimum number of perfect square numbers._","solution":"import math def min_perfect_squares(x): Returns the minimum number of perfect square numbers that sum up to x. if x <= 0: return 0 # Dynamic programming table to store the minimum numbers needed for each amount dp = [float(\'inf\')] * (x + 1) dp[0] = 0 # base case: 0 perfect squares sum up to 0 # Precompute the list of perfect squares less than or equal to x squares = [] i = 1 while i * i <= x: squares.append(i * i) i += 1 # Fill the dp array for i in range(1, x + 1): for square in squares: if i >= square: dp[i] = min(dp[i], dp[i - square] + 1) return dp[x]"},{"question":"You are given a list of integers `nums` representing a deck of cards, where the `i-th` card value is `nums[i]`. You are allowed to rearrange the deck to form groups of cards such that each group has the same integer value and each group can be rearranged into continuous values when sorted. **Note**: - For example, if nums = [1,2,3,6,2,3,4,7,8], one possible grouping is [[1,2,3,6], [2,3,4,7,8]]. After sorting, each group forms continuous values like `[1,2,3]` and `[6,7,8]`. - If it is not possible to form such groups, return `false`. Return `_true_` if you can rearrange the `nums` into such groups, otherwise return `_false_`.","solution":"from collections import Counter from heapq import heappop, heappush def can_rearrange_into_groups(nums): Check if we can rearrange nums into groups with the same integer values and that can be rearranged into continuous values when sorted. if len(nums) % 3 != 0: return False num_counts = Counter(nums) min_heap = [] for num in sorted(num_counts): while num_counts[num] > 0: current_group = [] for val in range(num, num + 3): if num_counts[val] <= 0: return False num_counts[val] -= 1 current_group.append(val) heappush(min_heap, current_group) return True"},{"question":"You are given a string `s` representing a series of operations where each character is either \'L\', \'R\', \'U\', or \'D\', indicating that a robot moves left, right, up, or down, respectively. The robot starts at the origin (0, 0) on a 2D plane. After performing all the operations in the string `s`, return the final coordinates of the robot as a tuple `(x, y)`. - \'L\' moves the robot one unit to the left (decreasing the x-coordinate), - \'R\' moves the robot one unit to the right (increasing the x-coordinate), - \'U\' moves the robot one unit up (increasing the y-coordinate), - \'D\' moves the robot one unit down (decreasing the y-coordinate).","solution":"def final_coordinates(s): Returns the final coordinates of the robot after performing a series of moves. Parameters: s (str): A string representing a series of operations (\'L\', \'R\', \'U\', \'D\'). Returns: tuple: Final coordinates (x, y) of the robot. x, y = 0, 0 for move in s: if move == \'L\': x -= 1 elif move == \'R\': x += 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return (x, y)"},{"question":"You are given an array of integers `arr`. A contiguous subarray of `arr` can be obtained by deleting some elements (possibly none) from the beginning and some elements (possibly none) from the end of the array. The **maximum subarray sum** is the largest sum among all possible contiguous subarrays of `arr`. However, a subarray sum can also be zero if the subarray is empty. Return the **maximum possible sum** of any non-empty contiguous subarray of `arr`. Note that the subarray must contain at least one element.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty contiguous subarray of arr. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"A `word square` is a n x n matrix of letters formed by `n` different words such that the kth row and kth column read the same string. You are given a list of words. Write a function to answer the following question: _Can the given list of words form a valid word square?_ A valid word square satisfies the following rules: - The number of rows must be equal to the number of columns. - The kth row and kth column must read the same string. Return `true` if the words can form a valid word square, and `false` otherwise.","solution":"def valid_word_square(words): Check if the given list of words forms a valid word square. :param words: List of strings, where each string represents a row. :return: True if the words form a valid word square, False otherwise. n = len(words) for i in range(n): for j in range(len(words[i])): if j >= n or i >= len(words[j]) or words[i][j] != words[j][i]: return False return True"},{"question":"Given a grid of size `m x n` consisting of `1\'s` (land) and `0\'s` (water), an **island** is a group of `1\'s` (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The **area** of an island is the number of cells with value `1` in the island. Write an algorithm to return the size of the largest island. If there is no island, return `0`.","solution":"def max_area_of_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark as visited return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a string `s` and an integer `n`. Find the lexicographically smallest string that can be obtained by rotating `s` exactly `n` times. Each rotation consists of moving the leftmost character of the string `s` to its rightmost position. If `n` is greater than the length of the string `s`, the rotations continue cyclically. Return the smallest rotated string.","solution":"def smallest_rotated_string(s, n): Returns the lexicographically smallest string that can be obtained by rotating \'s\' exactly \'n\' times. If \'n\' is greater than the length of \'s\', the rotations continue cyclically. length = len(s) n = n % length # To handle cases where n is greater than the length of the string rotations = [s[i:] + s[:i] for i in range(length)] return min(rotations) # Example use case # s = \\"abcde\\" # n = 2 # Possible rotations: \\"abcde\\", \\"bcdea\\", \\"cdeab\\", \\"deabc\\", \\"eabcd\\" # Lexicographically smallest rotation: \\"abcde\\""},{"question":"You are given a string `s` representing a sequence of parentheses. A parentheses sequence is balanced if every opening parenthesis \'(\' has a corresponding closing parenthesis \')\', and the pairs are properly nested. However, some characters in the string `s` might be \'*\', which can be treated as either an opening parenthesis \'(\', a closing parenthesis \')\', or an empty string \'\'. Return _a boolean value_ `true` _if the string `s` can be valid for some string made by replacing all the \'*\' characters, or_ `false` _otherwise_.","solution":"def is_valid_parentheses(s): Returns true if the string can be valid by replacing all \'*\' with \'(\', \')\' or \'\' left_balance = right_balance = 0 for char in s: if char in \'(*\': left_balance += 1 else: left_balance -= 1 if char != \'(\': right_balance -= 1 else: right_balance += 1 if left_balance < 0: return False right_balance = max(right_balance, 0) return right_balance == 0"},{"question":"Given a 2D matrix where each cell contains either a 0 or a 1, find the length of the longest line of consecutive 1s in the matrix. The line could be horizontal, vertical, diagonal, or anti-diagonal. Your task is to determine this length and return it. **Note**: A diagonal line is a line that goes from the top-left to the bottom-right, whereas an anti-diagonal line goes from the top-right to the bottom-left.","solution":"def longestLine(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_len = 0 # Create 3D dp array dp = [[[0]*4 for _ in range(cols)] for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1: # Horizontal dp[i][j][0] = dp[i][j-1][0] + 1 if j > 0 else 1 # Vertical dp[i][j][1] = dp[i-1][j][1] + 1 if i > 0 else 1 # Diagonal dp[i][j][2] = dp[i-1][j-1][2] + 1 if i > 0 and j > 0 else 1 # Anti-diagonal dp[i][j][3] = dp[i-1][j+1][3] + 1 if i > 0 and j < cols-1 else 1 # Updating max_len max_len = max(max_len, dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3]) return max_len"},{"question":"You are given a stream of integers and a window size `k`. Implement a data structure that calculates the moving average of the last `k` integers in the stream. The data structure should have the following methods: - `MovingAverage(k)`: Initializes the data structure with the integer `k`, the size of the moving window. - `next(val)`: Returns the moving average of the last `k` integers after inserting the value `val` into the stream. Return the moving averages as an array of floating-point numbers after processing each value from the stream. If there are fewer than `k` elements in the stream, calculate the average of all elements present.","solution":"from collections import deque class MovingAverage: def __init__(self, k): Initializes the data structure with the integer k, the size of the moving window. self.k = k self.window = deque() self.sum = 0 def next(self, val): Inserts the value val into the stream and returns the moving average of the last k integers. If there are fewer than k elements in the stream, calculate the average of all elements present. # Add new value to the window self.window.append(val) self.sum += val # If the window contains more than k elements, remove the oldest one if len(self.window) > self.k: removed_val = self.window.popleft() self.sum -= removed_val # Return the current moving average return self.sum / len(self.window)"},{"question":"You are given a **0-indexed** integer array `sprint` where `sprint[i]` represents the distance you can run in the `ith` minute. You are also given an integer `goal`, representing the distance you need to cover. You can start running from any minute `i` and run consecutively from that minute onward. Return _the **minimum number of minutes** you need to run to cover at least the `goal` distance_. If it is not possible to cover the `goal` distance, return `-1`.","solution":"def min_minutes_to_goal(sprint, goal): Returns the minimum number of minutes needed to cover the goal distance. If it is not possible to cover the goal distance, returns -1. running_sum = 0 # Initialize running sum to 0 min_minutes = float(\'inf\') # Initialize minimum minutes to infinity start_index = 0 # Starting index for end_index in range(len(sprint)): running_sum += sprint[end_index] while running_sum >= goal: min_minutes = min(min_minutes, end_index - start_index + 1) running_sum -= sprint[start_index] start_index += 1 return min_minutes if min_minutes != float(\'inf\') else -1"},{"question":"Given an array of integers `arr` and an integer `k`, return the maximum possible score you can achieve by applying the following operation exactly `k` times: Choose any element from `arr` and remove it; add the chosen element\'s value to your score. You are allowed to choose the same element multiple times. Your aim is to maximize your score after exactly `k` operations.","solution":"def max_score(arr, k): Returns the maximum score by choosing elements from `arr` exactly `k` times. Parameters: arr (list): List of integers. k (int): The number of times you are allowed to choose an element. Returns: int: Maximum score possible. max_value = max(arr) return max_value * k"},{"question":"Given an array of integers `nums` where each integer represents the cost of a step on a staircase, write a function to determine the minimum cost to reach the top of the staircase. You can either start from the step with index `0` or the step with index `1`. Once you pay the cost to get to a step, you can either climb one or two steps. Your function should return the minimum cost to reach the top of the staircase.","solution":"def min_cost_climbing_stairs(cost): Given an array of integers `cost` where cost[i] is the cost of the i-th step on a staircase, this function returns the minimum cost to reach the top of the staircase. You can either start from the step with index 0 or 1. n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] # Minimum cost to reach the top starts from the first two steps first = cost[0] second = cost[1] for i in range(2, n): current = cost[i] + min(first, second) first, second = second, current return min(first, second)"},{"question":"You are given a list of non-negative integers representing the amount of rainwater stored in each section of a histogram where the width of each bar is `1`. The objective is to calculate how much water is trapped between the bars after it rains. The histogram is represented by an integer array `heights` where `heights[i]` is the height of the `i-th` bar. Return the total amount of trapped rainwater.","solution":"def trap(height): Returns the total amount of trapped rainwater given the heights of the histogram bars. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"A company wants to hire new developers. They have `n` positions available and a list `candidates` where each candidate\'s skill level is denoted by an integer. To ensure a good fit, they want to hire only the top `k` candidates with the highest skill levels. However, they also want to ensure that among these top candidates, the difference in skill levels between the highest and lowest ranked candidate is within a specified range called `maxDifference`. Given the list `candidates`, an integer `k`, and an integer `maxDifference`, determine if it\'s possible to hire exactly `k` candidates such that the highest difference in their skill levels does not exceed `maxDifference`. Return `true` if it\'s possible to hire in such a manner, or `false` otherwise.","solution":"def can_hire(candidates, k, maxDifference): Determines if it\'s possible to hire k candidates such that the highest difference in their skill levels does not exceed maxDifference. :param candidates: List of integers representing skill levels of candidates. :param k: Integer representing the number of candidates to hire. :param maxDifference: Integer representing the maximum allowed difference in skill levels. :return: Boolean value indicating if it\'s possible to hire k candidates within the maxDifference. # Sort candidates by their skill levels in descending order candidates.sort(reverse=True) for i in range(len(candidates) - k + 1): # Check the difference between the highest and lowest in this window if candidates[i] - candidates[i + k - 1] <= maxDifference: return True return False"},{"question":"You are given an array of non-negative integers `nums` representing the amount of money of each house, arranged in a row. A thief needs to steal money from the houses, but he cannot steal from two adjacent houses, otherwise, an alarm will be triggered. Calculate the maximum amount of money the thief can steal without triggering the alarm.","solution":"def rob(nums): Calculates the maximum amount of money the thief can steal without triggering the alarm. if not nums: return 0 elif len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given two strings `s` and `t`, consisting only of lowercase English letters. You can insert any number of characters anywhere in `s` to make `s` equal to `t`. Find the minimum number of insertions required to transform `s` into `t`. If it\'s impossible to transform `s` into `t` by insertions alone, return `-1`.","solution":"def min_insertions_to_transform(s, t): Returns the minimum number of insertions required to transform `s` into `t`. If it\'s not possible, returns -1. si, ti = 0, 0 while si < len(s) and ti < len(t): if s[si] == t[ti]: si += 1 ti += 1 # If some characters in `s` have not been matched, it\'s impossible to transform `s` into `t` if si != len(s): return -1 # Number of insertions needed is the remaining unmatched characters in `t` return len(t) - len(s)"},{"question":"Given a set of `n` projects, each characterized by a start time, an end time, and a monetary profit associated with completing the project, find the maximum profit you can achieve by scheduling the projects such that no two projects overlap. Each project is described by three integers: `startTime`, `endTime`, and `profit`. You are given a list of `projects` where `projects[i] = [startTimei, endTimei, profiti]`. The goal is to return the maximum profit you can achieve by selecting a subset of non-overlapping projects.","solution":"from bisect import bisect_right def max_profit(projects): Returns the maximum profit by selecting a subset of non-overlapping projects. :param projects: List[List[int]] each element is a list of start time, end time and profit :return: int, maximum profit # Sort projects by end time projects.sort(key=lambda x: x[1]) n = len(projects) # DP array to store max profit up to each project endpoint dp = [0] * (n + 1) # times array to store end times for binary search times = [projects[i][1] for i in range(n)] for i in range(1, n + 1): start_time, end_time, profit = projects[i - 1] # Find the latest non-conflicting project using binary search index = bisect_right(times, start_time) - 1 # Max profit by including or excluding the current project dp[i] = max(dp[i - 1], profit + (dp[index + 1] if index != -1 else 0)) return dp[n]"},{"question":"Develop a `StringIterator` class that supports the following operations: 1. `StringIterator(String compressedString)` Initializes the `StringIterator` object with a compressed string. The string consists of a sequence of characters followed by their frequency in the string. For example, the string \\"a2b3\\" would be decompressed to \\"aabbb\\". 2. `char next()` Returns the next character if the original string still has characters to be extracted, otherwise returns \' \' (a single space). 3. `boolean hasNext()` Returns true if the original string still has characters to be extracted, otherwise returns false.","solution":"class StringIterator: def __init__(self, compressedString): self.chars = [] self.counts = [] i = 0 while i < len(compressedString): char = compressedString[i] i += 1 count = 0 while i < len(compressedString) and compressedString[i].isdigit(): count = count * 10 + int(compressedString[i]) i += 1 self.chars.append(char) self.counts.append(count) self.index = 0 self.char_count = 0 def next(self): if not self.hasNext(): return \' \' if self.char_count == 0: self.current_char = self.chars[self.index] self.char_count = self.counts[self.index] self.index += 1 self.char_count -= 1 return self.current_char def hasNext(self): return self.index < len(self.chars) or self.char_count > 0"},{"question":"Given a positive integer array `arr`, an operation consists of choosing any two indices `i` and `j` such that `i < j`, and `arr[i] <= arr[j]`, then increment `arr[i]` by 1. You need to make the given array `arr` non-decreasing using the minimum number of operations. Return _that minimum number of operations_. **Note** that: * An array is non-decreasing if `arr[k] <= arr[k + 1]` for every `0 <= k < arr.length - 1`.","solution":"def min_operations_to_non_decreasing(arr): Returns the minimum number of operations to make the array non-decreasing. n = len(arr) operations = 0 for i in range(1, n): if arr[i] < arr[i - 1]: operations += arr[i - 1] - arr[i] arr[i] = arr[i - 1] return operations"},{"question":"You are given a string `s` and a list of words `words`. A word is `good` if it appears in `s` as a contiguous substring. The task is to find the number of `good` words in `words` that can appear in `s` without overlapping. Return the maximum number of such `good` words. Note that each word must match exactly and cannot be rearranged or partially matched.","solution":"def max_good_words(s, words): Returns the maximum number of good words that can appear in s without overlapping. :param s: The main string :param words: List of words to be checked in the string :return: Maximum number of good words start = 0 count = 0 while start < len(s): found = False for word in words: if s.startswith(word, start): count += 1 start += len(word) found = True break if not found: start += 1 return count"},{"question":"Our new question integrates the themes of algorithm design, combinatorics, and efficiency concepts seen in the provided questions: --- [Question 4]: You are given an integer array `arr` and an integer `k`. Implement a function that returns the `kth` smallest element in the merged sorted array when `arr` is partitioned into exactly `k` non-overlapping, non-empty subarrays such that each subarray is individually sorted and then merged. Ensure that your algorithm is optimized for large values of `k` and the length of `arr`. Implement this function: * `int kthSmallestElement(int[] arr, int k)`: Returns the `kth` smallest element in the merged sorted array of `k` partitions from `arr`.","solution":"def kthSmallestElement(arr, k): if not arr or k == 0: return None n = len(arr) if k > n: return None # Step 1: Sort the array arr.sort() # Step 2: Determine the size of each partition partition_size = n // k extra_elements = n % k partitions = [] index = 0 # Step 3: Create partitions for i in range(k): if i < extra_elements: partitions.append(arr[index:index + partition_size + 1]) index += partition_size + 1 else: partitions.append(arr[index:index + partition_size]) index += partition_size # Step 4: Merge the partitions. We use a min-heap to efficiently find the kth element import heapq min_heap = [] for partition in partitions: for num in partition: heapq.heappush(min_heap, num) # Step 5: Extract the kth smallest element for _ in range(k - 1): heapq.heappop(min_heap) return heapq.heappop(min_heap)"},{"question":"Given an array of integers `arr`, return the length of the longest subarray, which contains at most `k` distinct elements. A subarray is a contiguous part of the array. For example, given the array `[1,2,1,2,3]` and `k = 2`, the longest subarray with at most `k` distinct elements is `[1, 2, 1, 2]`, and its length is 4. The function should be efficient, with an average time complexity better than O(n^2). Your function should return an integer representing the length of this subarray.","solution":"def longest_subarray_with_k_distinct(arr, k): from collections import defaultdict if k == 0: return 0 n = len(arr) left = 0 max_len = 0 freq_map = defaultdict(int) for right in range(n): freq_map[arr[right]] += 1 while len(freq_map) > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: del freq_map[arr[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an n x n integer matrix `grid` where each cell is either 0 (empty) or 1 (blocked). You need to find the length of the shortest clear path from the top-left corner to the bottom-right corner. A clear path in a matrix is a path that does not pass through any blocked cells (i.e., cells that contain a 1). The path can only move up, down, left, or right at each step. If there is no clear path, return -1.","solution":"from collections import deque def shortest_clear_path(grid): Returns the length of the shortest clear path from the top-left corner to the bottom-right corner in a given n x n grid. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given two **0-indexed** integer arrays `startTime` and `endTime`, each of length `n`, where `startTime[i]` and `endTime[i]` represent the start and end times of the `i-th` job, respectively. You are tasked with scheduling the maximum number of non-overlapping jobs. A job `i` is defined as non-overlapping with job `j` if `endTime[i] <= startTime[j]` or `endTime[j] <= startTime[i]`. Return the maximum number of non-overlapping jobs that can be scheduled.","solution":"def max_non_overlapping_jobs(startTime, endTime): Returns the maximum number of non-overlapping jobs that can be scheduled. Args: startTime (List[int]): A list of start times of jobs. endTime (List[int]): A list of end times of jobs. Returns: int: Maximum number of non-overlapping jobs. # Sorting jobs by their end time jobs = sorted(zip(startTime, endTime), key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in jobs: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given an integer array `arr` containing positive numbers. You need to find if there exists a subset of `arr` such that the sum of its elements is equal to a given positive integer `target`. Return `true` if such a subset exists, and `false` otherwise.","solution":"def subset_sum(arr, target): Determines if there\'s a subset of `arr` that sums up to `target`. n = len(arr) # DP table initialization dp = [[False] * (target + 1) for _ in range(n + 1)] # Base case: there\'s always a subset with sum 0 (empty subset) for i in range(n + 1): dp[i][0] = True # DP table computation for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][target]"},{"question":"Write a function that takes a list of integers `arr` and returns `true` if there are three consecutive odd numbers in the list. Otherwise, return `false`. For example, given the list `[2, 6, 4, 1, 3, 5, 7]`, the function should return `true` as `1, 3, 5` are three consecutive odd numbers.","solution":"def three_consecutive_odds(arr): Returns True if there are three consecutive odd numbers in the list `arr`. Otherwise, returns False. count = 0 for num in arr: if num % 2 != 0: # num is odd count += 1 if count == 3: return True else: count = 0 return False"},{"question":"Given a `string`, return `true` if the string is a **Palindrome Permutation**. Otherwise, return `false`. A string is a **Palindrome Permutation** if it can be rearranged to form a palindrome. In other words, determine if any permutation of the string could form a valid palindrome.","solution":"def is_palindrome_permutation(s): Determines if any permutation of the input string can form a palindrome. Args: s (str): Input string. Returns: bool: True if any permutation of the string can form a palindrome, False otherwise. # Removing spaces and converting to lowercase for uniformity s = s.replace(\\" \\", \\"\\").lower() # Count frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # A string can be permuted to form a palindrome if: # it has at most one character with an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"You are given an array of integers `arr`. A **Valley** is defined as a subarray that consists of three integers, where the first and third are larger than the second. For example, in the array [5, 3, 4], the subarray [5, 3, 4] forms a valley. Write a function that returns _the number of valleys in the given array_. A single element cannot be part of more than one valley.","solution":"def count_valleys(arr): Returns the number of valleys in the given array. A valley is defined as a subarray that consists of three integers, where the first and third are larger than the second. Parameters: arr (list): List of integers. Returns: int: Number of valleys in the array. valley_count = 0 for i in range(1, len(arr)-1): if arr[i-1] > arr[i] < arr[i+1]: valley_count += 1 return valley_count"},{"question":"You are given an integer array `nums` and a positive integer `k`. Your task is to identify the number of unique subarrays of length `k` where all the elements in the subarray are distinct. Return _an integer_ representing the count of such subarrays. For example, given `nums = [1, 2, 3, 1, 2, 3]` and `k = 3`, you should return 3, because the valid subarrays are `[1, 2, 3]`, `[2, 3, 1]`, and `[3, 1, 2]`. If there are no subarrays of length `k` with all distinct elements, return `0`.","solution":"def count_unique_subarrays(nums, k): Returns the count of unique subarrays of length k with all distinct elements. if len(nums) < k: return 0 unique_subarrays = set() for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if len(set(subarray)) == k: unique_subarrays.add(tuple(subarray)) return len(unique_subarrays)"},{"question":"Given a string `s` consisting of lowercase English letters, you need to perform the following operation until the string becomes empty: Choose the smallest lexicographical character and remove all its occurrences from the string. Return _the final string after performing the operation_.","solution":"def final_string_after_operations(s): result = [] chars = sorted(set(s)) for c in chars: result.append(c) return \'\'.join(result)"},{"question":"Design a class that emulates a bank\'s transaction process where each account has a unique identifier. Implement the `Bank` class: * `Bank(long[] balance)` initializes the `Bank` object with `balance`, an array representing the initial balances of each account. * `boolean transfer(int account1, int account2, long amount)` transfers `amount` from the account with ID `account1` to the account with ID `account2`. Returns `true` if the transaction was successful, otherwise `false`. * `boolean deposit(int account, long amount)` deposits `amount` into the account with ID `account`. Returns `true` if the deposit was successful. * `boolean withdraw(int account, long amount)` withdraws `amount` from the account with ID `account`. Returns `true` if the withdrawal was successful.","solution":"class Bank: def __init__(self, balance): self.balance = balance def transfer(self, account1, account2, amount): if (1 <= account1 <= len(self.balance)) and (1 <= account2 <= len(self.balance)) and (self.balance[account1 - 1] >= amount): self.balance[account1 - 1] -= amount self.balance[account2 - 1] += amount return True return False def deposit(self, account, amount): if 1 <= account <= len(self.balance): self.balance[account - 1] += amount return True return False def withdraw(self, account, amount): if (1 <= account <= len(self.balance)) and (self.balance[account - 1] >= amount): self.balance[account - 1] -= amount return True return False"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers. The cell at position (i, j) represents the height of a building at that position. The rainwater trapped at cell (i, j) is determined by the minimum height between the tallest building to the north, south, east, and west of that cell, minus the height of the building at (i, j). You need to calculate the total volume of rainwater that can be trapped in the grid after raining. Return _the total amount of trapped rainwater_.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False for _ in range(n)] for _ in range(m)] min_heap = [] for i in range(m): for j in range(n): if i == 0 or j == 0 or i == m - 1 or j == n - 1: heapq.heappush(min_heap, (heightMap[i][j], i, j)) visited[i][j] = True water_trapped = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"Given a **rectangular grid** of integers representing a map where each cell\'s value represents the elevation at that point, identify all **local peaks** in the grid. A **local peak** is a cell that is strictly greater than all of its adjacent cells. Adjacent cells are those directly above, below, to the left, and to the right of a cell (not diagonally). Return _a list of coordinates (i, j) of all local peaks_. You may return the coordinates in **any order**.","solution":"def find_local_peaks(grid): Return a list of coordinates (i, j) of all local peaks in the grid. A local peak is a cell that is strictly greater than all its adjacent cells. if not grid: return [] rows, cols = len(grid), len(grid[0]) peaks = [] def is_peak(r, c): # Check all four possible neighbors and compare current = grid[r][c] if r > 0 and grid[r-1][c] >= current: return False if r < rows-1 and grid[r+1][c] >= current: return False if c > 0 and grid[r][c-1] >= current: return False if c < cols-1 and grid[r][c+1] >= current: return False return True # Iterate through the grid for i in range(rows): for j in range(cols): if is_peak(i, j): peaks.append((i, j)) return peaks"},{"question":"Implement a `MinStack` class with the following methods: * `MinStack()` initializes the stack object. * `void push(int val)` pushes an integer value onto the stack. * `void pop()` removes the integer value on the top of the stack. * `int top()` retrieves the integer value on the top of the stack. * `int getMin()` retrieves the minimum integer value in the stack. You must implement a solution with `O(1)` time complexity for each of the methods.","solution":"class MinStack: def __init__(self): Initializes the stack object with the stack list and a min_stack to keep track of minimum values. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Pushes an integer value onto the stack. self.stack.append(val) # If min_stack is empty or the current val is less than or equal to the minimum value in min_stack if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the integer value on the top of the stack. if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Retrieves the integer value on the top of the stack. if self.stack: return self.stack[-1] return -1 def getMin(self) -> int: Retrieves the minimum integer value in the stack. if self.min_stack: return self.min_stack[-1] return -1"},{"question":"You are given an integer array `nums` sorted in ascending order, and an integer `target`. Write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return the index where it would be if it were inserted in order. Assume no duplicates in the array.","solution":"def search_insert(nums, target): Search for the target in the sorted array. If found, return its index, otherwise return the index where it should be inserted to maintain order. Parameters: nums (List[int]): A list of integers sorted in ascending order. target (int): The target integer to search for or insert. Returns: int: The index of the target if found, otherwise the index where the target should be inserted. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Given an integer matrix `grid`, count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Implement the following function: * `int numIslands(int[][] grid)` - returns the number of islands in the grid.","solution":"def numIslands(grid): Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. :param grid: List[List[int]], the grid representing islands and water :return: int, the number of islands if not grid: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the cell as visited dfs(grid, i + 1, j) # Down dfs(grid, i - 1, j) # Up dfs(grid, i, j + 1) # Right dfs(grid, i, j - 1) # Left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(grid, i, j) count += 1 return count"},{"question":"You are given a string `str` consisting of only lowercase English letters. You need to find the longest palindromic substring in `str`. Return _the longest palindromic substring_. If there are multiple such substrings with the same length, return the one which appears first in lexicographical order.","solution":"def longest_palindromic_substring(st): Returns the longest palindromic substring. If there are multiple such substrings with the same length, returns the one which appears first in lexicographical order. def is_palindrome(s): return s == s[::-1] n = len(st) longest = \\"\\" for i in range(n): for j in range(i, n): current_substring = st[i:j+1] if is_palindrome(current_substring): if len(current_substring) > len(longest) or (len(current_substring) == len(longest) and current_substring < longest): longest = current_substring return longest"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function that returns the **number of subarrays** whose sum equals `target`. A subarray is a contiguous non-empty sequence of elements within an array. Return _the count of such subarrays_.","solution":"def count_subarrays_with_sum(nums, target): Returns the count of subarrays within `nums` that sum up to `target`. count = 0 current_sum = 0 sum_counts = {0: 1} for num in nums: current_sum += num if current_sum - target in sum_counts: count += sum_counts[current_sum - target] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"You are given a directed graph with `n` vertices and `m` edges represented as an array `edges` of size `m`, where `edges[i] = [ui, vi]` indicates there is a directed edge from vertex `ui` to vertex `vi`. Each vertex `i` has an associated value given by the array `value[i]`. You need to determine the **longest path** in terms of the sum of the values of the vertices along the path in this directed graph. The path should start at **any vertex** and end at **any other vertex**, and each vertex can be visited at most once. Return the **maximum value sum** for the longest path possible in the graph. If there is no path, return `0`.","solution":"def longest_path_value_sum(n, edges, values): from collections import defaultdict, deque # Construct the graph graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Topological Sort using Kahn\'s algorithm topo_order = [] zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Early exit if there\'s a cycle and not all nodes are in topological order if len(topo_order) != n: return 0 # Initialize distance with negative infinity dist = [-float(\'inf\')] * n # Maximum path values starting from each vertex max_path_value = 0 # Process vertices in topological order for node in topo_order: if dist[node] == -float(\'inf\'): dist[node] = values[node] for neighbor in graph[node]: dist[neighbor] = max(dist[neighbor], dist[node] + values[neighbor]) return max(dist)"},{"question":"You are managing a library, and you need to keep track of book borrowing and returning. The library has a system where each book has a unique identifier represented by an integer. Whenever a student borrows a book, the book\'s identifier is recorded. If the same book is returned within a specified number of days `d`, then the borrowing is considered valid; otherwise, the book is considered overdue. Implement the `Library` class: * `Library(int d)` Initializes the object with the maximum number of days `d` for a valid return. * `void borrowBook(int bookId, int day)` Records the borrowing of the book with identifier `bookId` on the specified `day`. * `bool returnBook(int bookId, int day)` Returns `true` if the book `bookId` is returned on the specified `day` within the allowed `d` days, otherwise returns `false`. Example: Library lib = new Library(7); lib.borrowBook(101, 1); lib.borrowBook(202, 3); assert lib.returnBook(101, 5) == true; // Returns true, as the book 101 is returned within 7 days assert lib.returnBook(202, 10) == false; // Returns false, as the book 202 is returned after 7 days","solution":"class Library: def __init__(self, d): Initializes the Library object with the maximum number of days `d` for a valid return. self.d = d self.borrowed_books = {} def borrowBook(self, bookId, day): Records the borrowing of the book with identifier `bookId` on the specified `day`. self.borrowed_books[bookId] = day def returnBook(self, bookId, day): Returns `true` if the book `bookId` is returned on the specified `day` within the allowed `d` days, otherwise returns `false`. if bookId in self.borrowed_books: borrow_day = self.borrowed_books[bookId] if day - borrow_day <= self.d: del self.borrowed_books[bookId] # Remove the book from the borrowed list as it is returned return True return False"},{"question":"Given a string `s`, return _the length of the longest substring of `s` without repeating characters_. You may assume that all characters in the string are ASCII characters. Solve this problem using the sliding window technique, ensuring that your solution\'s time complexity is linear in respect to the input size.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} left = 0 max_len = 0 for right in range(n): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an integer `n`, return a list of all **unique combinations** of `n` pairs of well-formed parentheses. Each pair of parentheses is represented as `()` and combinations must be properly nested. For example, given `n = 3`, the list of combinations would be: ``` [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] ``` Return the list of combinations in **any order**.","solution":"def generate_parenthesis(n): Returns a list of unique combinations of n pairs of well-formed parentheses. result = [] def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"You are given a list of integers `nums` representing an amount of money for each house in a row. Each house is either owned by you or by a thief. If the house is owned by you, you can rob it, but you can\'t rob two consecutive houses, and if the house is owned by the thief, you can\'t rob it. You need to maximize the amount of money you can rob tonight. Return the maximum amount of money you can rob given the constraint.","solution":"def rob(nums, ownership): Given a list of integers nums representing amount of money for each house in a row and a list of booleans ownership representing whether you own the house (True) or the thief owns the house (False), this function returns the maximum amount of money you can rob given you can\'t rob two consecutive houses. if not nums: return 0 n = len(nums) # Initialize an array to store the maximum amounts dp = [0] * (n + 1) # Iterate through the houses for i in range(1, n + 1): if ownership[i - 1]: if i == 1: dp[i] = nums[i - 1] else: dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]) else: dp[i] = dp[i - 1] return dp[n]"},{"question":"You are given a list of integers `nums` and a target integer `sum`. Write a function to return all unique pairs of integers from the list that add up to the specified target sum. Each pair should be sorted in ascending order, and the list of pairs should be in ascending order based on the first value of each pair. If no pairs are found, return an empty list. Note that a pair `(a, b)` and `(b, a)` are considered the same and should only be counted once.","solution":"def find_pairs(nums, target_sum): Returns all unique pairs of integers from the list `nums` that add up to `target_sum`. Each pair is sorted in ascending order, and the list of pairs is sorted based on the first value of each pair. nums.sort() pairs = set() seen = {} for num in nums: complement = target_sum - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen[num] = True return sorted(pairs)"},{"question":"You are given a list of `n` non-negative integers representing the heights of columns where the width of each column is `1`. Find the maximum amount of water that can be trapped between the columns after a rainfall. The water accumulated between the columns is defined by the shorter column on either end and the columns between them that form a boundary to hold the water. Ensure your solution is efficient in terms of time complexity.","solution":"def trap(height): Calculate the maximum amount of water that can be trapped between columns after a rainfall. :param height: List of integers representing the height of the columns. :return: The maximum amount of water that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"A palindrome is a string that reads the same forwards and backwards. Given a string `s`, you are allowed to replace at most `k` characters of the string `s` with any lowercase English letter. Your task is to determine the minimum number of characters that need to be replaced in order for the string to become a palindrome. Return the minimum number of characters that need to be replaced to make the string `s` a palindrome.","solution":"def min_replacements_to_palindrome(s, k): Returns the minimum number of characters that need to be replaced in order for the string `s` to become a palindrome. n = len(s) replacements = 0 # Only need to check the first half, compare it with the second half left = 0 right = n - 1 while left < right: if s[left] != s[right]: replacements += 1 left += 1 right -= 1 return min(replacements, k)"},{"question":"You are given a list of `n` strings, `stringsList`. Each string `stringsList[i]` consists of lowercase letters. Your task is to find out how many strings in the list are **anagrams** of each other and group them together. Two strings are anagrams if and only if the characters in one string can be rearranged to form the other string. Return _a list of lists_, where each sub-list contains strings that are anagrams of each other. The order of the strings in the sub-lists and the order of the sub-lists themselves do not matter.","solution":"from collections import defaultdict def group_anagrams(stringsList): Groups anagrams from the provided list of strings. :param stringsList: List of strings :return: List of groups containing anagrams anagram_map = defaultdict(list) for string in stringsList: sorted_string = \'\'.join(sorted(string)) anagram_map[sorted_string].append(string) return list(anagram_map.values())"},{"question":"You are given a **0-indexed** integer array `weights` where `weights[i]` represents the weight of the `i-th` item. You need to distribute these items into two groups such that the **difference** between the total weights of the two groups is minimized. Return the minimum possible difference.","solution":"def minimum_difference(weights): Returns the minimum possible difference between two groups formed from weights. total_sum = sum(weights) n = len(weights) dp = [0] * (total_sum // 2 + 1) for weight in weights: for j in range(total_sum // 2, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return abs(total_sum - 2 * dp[total_sum // 2])"},{"question":"You are given a list of strings `words`. Arrange these strings in such a way that they form the largest possible concatenated string in lexicographical order. Each string must remain in its original order but the overall sequence can be reordered. Return _the largest concatenated string_. For example, if `words = [\\"cat\\", \\"bat\\", \\"apple\\"]`, the largest possible concatenated string is `\\"catbatapple\\"`.","solution":"def largest_concatenated_string(words): Returns the largest concatenated string in lexicographical order. Args: words (list of str): List of strings to concatenate. Returns: str: The largest concatenated string. # Sort the words in reverse lexicographical order and concatenate them words_sorted = sorted(words, reverse=True) return \'\'.join(words_sorted)"},{"question":"Given a binary string `s`, return the number of substrings with all characters `0`. A substring is defined as a contiguous sequence of characters within the string. You need to count all possible substrings within the given string that consist solely of the character `0`. For example, if `s = \\"0011000\\"`, the valid substrings are `\\"0\\"`, `\\"0\\"`, `\\"00\\"`, `\\"0\\"`, `\\"00\\"`, `\\"000\\"`. Therefore, the output should be `6`.","solution":"def count_zero_substrings(s): Counts the number of substrings consisting solely of the character \'0\' in the given binary string s. :param s: A string consisting of \'0\'s and \'1\'s. :return: The number of substrings with all characters \'0\'. count = 0 zero_count = 0 for char in s: if char == \'0\': zero_count += 1 count += zero_count else: zero_count = 0 return count"},{"question":"Given a binary tree, your task is to connect the nodes at each level from left to right using right pointers. Each node has an additional `next` pointer initially set to `NULL`. You need to populate this `next` pointer to point to its next right node at the same level. The last node at each level should have its `next` pointer set to `NULL`. Return the root of the modified tree. Example of input and output: ``` Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Where \'#\' signifies the end of each level.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. if not root: return None leftmost = root while leftmost: current = leftmost leftmost = None prev = None while current: if current.left: if not leftmost: leftmost = current.left if prev: prev.next = current.left prev = current.left if current.right: if not leftmost: leftmost = current.right if prev: prev.next = current.right prev = current.right current = current.next return root def level_order_traversal(root): Helper function to return level order traversal of the tree including next pointers. Each level ends with a \'#\'. result = [] while root: current = root while current: result.append(current.val) current = current.next result.append(\'#\') root = root.left if root.left else root.right return result"},{"question":"You are given a positive integer `n`. Your task is to find the **minimum number of steps** to reduce `n` to 1 under the following conditions: - If `n` is even, you may divide `n` by 2. - If `n` is divisible by 3, you may divide `n` by 3. - You may subtract 1 from `n`. Return the minimum number of steps required to reduce `n` to 1.","solution":"def min_steps_to_one(n): Return the minimum number of steps required to reduce n to 1. # Dictionary to store the minimum steps for each number dp = {1: 0} # Function to compute minimum steps using memoization def compute_steps(k): if k in dp: return dp[k] steps = compute_steps(k - 1) + 1 if k % 2 == 0: steps = min(steps, compute_steps(k // 2) + 1) if k % 3 == 0: steps = min(steps, compute_steps(k // 3) + 1) dp[k] = steps return steps return compute_steps(n)"},{"question":"Given a string `s` that consists of only lowercase letters, find the largest substring that is a palindrome. A palindrome is a string that reads the same forward and backward. Return _the longest palindromic substring_ in `s`.","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. :param s: A string consisting of only lowercase letters. :return: The longest palindromic substring in s. n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): # Check for even length palindromes low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindromes low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"A company has a list of employees, and each employee has a unique ID number. The company also has a list of pairs, where each pair represents a direct reporting relationship between a manager and an employee. Given an integer `n` representing the number of employees and an array `reportPairs` of size `m` where each `reportPairs[i] = [managerId, employeeId]` indicates that the employee with `employeeId` reports directly to the manager with `managerId`, return the ID of the employee who is the top-most manager (the one who does not report to anyone). If there are multiple top-most managers, return the smallest ID among them. If there is no such employee, return -1.","solution":"def find_top_manager(n, reportPairs): if n == 0: return -1 # a set of all employee IDs all_employees = set(range(1, n+1)) # a set of employees who report to someone has_manager = set(e for _, e in reportPairs) # find the set of employees who do not report to anyone top_managers = all_employees - has_manager if not top_managers: return -1 # return the smallest ID among the top managers return min(top_managers)"},{"question":"You are given a string `s` that represents a sequence of characters. Your task is to determine if there exists a non-empty substring that occurs at least twice in `s`, without overlapping. If such a substring exists, return `true`; otherwise, return `false`. Implement a function that receives a string `s` and returns a boolean indicating whether there is a repeated non-overlapping substring.","solution":"def has_repeated_non_overlapping_substring(s): Determines if there exists a non-empty substring that occurs at least twice in `s`, without overlapping. :param s: A string representing a sequence of characters. :return: True if there is a repeated non-overlapping substring, False otherwise. length = len(s) for sub_len in range(1, length // 2 + 1): for i in range(length - sub_len * 2 + 1): if s[i:i + sub_len] == s[i + sub_len:i + sub_len * 2]: return True return False"},{"question":"You are given an array of integers `nums` representing a permutation of integers from `1` to `n`. You need to split the array into a minimum number of partitions such that each partition is a continuous subsequence, and each subsequence is sorted in strictly increasing order. Return the minimum number of partitions required. A permutation is a sequence of numbers where every number from 1 to `n` appears exactly once.","solution":"def min_partitions(nums): Return the minimum number of partitions required such that each partition is a continuous subsequence and sorted in strictly increasing order. :param nums: List[int], a permutation of integers from 1 to n :return: int, minimum number of partitions required # Initialize the number of partitions partition_count = 0 # Initialize the end of the current partition current_end = 0 for i in range(len(nums)): # Update the end of the current partition current_end = max(current_end, nums[i]) # If current index reaches the end of the current partition, # increment the partition count if i + 1 == current_end: partition_count += 1 return partition_count"},{"question":"On an infinite plane, you are given an integer array `positions` where `positions[i]` represents the position of the `i`-th person on a number line. There is a player starting at position `0`. Each time, the player can move to any position on the number line; however, the total distance moved must be minimized. The player aims to visit every position in `positions` at least once. Return _the minimum distance the player must cover to visit all positions in `positions` starting and ending at position `0`.","solution":"def minimum_distance(positions): Returns the minimum distance the player must cover to visit all positions in `positions` starting and ending at position 0 if not positions: return 0 # Sort the positions positions.sort() # Total distance is twice the distance from the farthest point because the player must return to 0 max_distance = max(abs(position) for position in positions) return 2 * max_distance"},{"question":"Given a `m x n` matrix `mat` of integers, return the matrix obtained by flipping the matrix horizontally, then inverting it. To flip a matrix horizontally means that each row of the matrix is reversed. To invert a matrix means that each cell\'s value is replaced by its complement (i.e., 0 becomes 1 and 1 becomes 0). For instance, given the input matrix: ``` [[1,1,0], [1,0,1], [0,0,0]] ``` the output should be: ``` [[1,0,0], [0,1,0], [1,1,1]] ```","solution":"def flip_and_invert_image(mat): Flip the given matrix horizontally, then invert it. :param mat: List of List of integers (0 or 1). :return: Flipped and inverted matrix. def flip(row): return row[::-1] def invert(row): return [1 - x for x in row] flipped_and_inverted_mat = [invert(flip(row)) for row in mat] return flipped_and_inverted_mat"},{"question":"Given an array of integers `nums`, return _the **length** of the longest arithmetic subarray in `nums`_. An arithmetic subarray is a contiguous subarray that has the same difference between each pair of consecutive elements. For example, `[3, 6, 9, 12]`, `[9, 8, 7, 6]`, and `[20, 17, 14, 11]` are arithmetic subarrays, while `[1, 2, 4]`, `[5, 6, 8, 9]`, and `[7, 5, 3, 2]` are not. Note that the minimum length of an arithmetic subarray is 2.","solution":"def longest_arithmetic_subarray(nums): if len(nums) < 2: return 0 max_length = 2 current_length = 2 difference = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] == difference: current_length += 1 else: difference = nums[i] - nums[i - 1] current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"You are developing a social media application where users can form friend circles. Each user can send friend requests to other users to form a friendship. A friendship is defined as a bidirectional relationship between two users. Given an integer `n` representing the number of users and a list of friend requests represented as pairs of integers `[u, v]`, where `u` and `v` are user IDs, implement a method to determine if a friend request will form a cyclic relationship in any users friend circle. A cycle is formed if there is a series of friendships such that starting from one user you can come back to the same user by continuously following the friendships. Implement the `FriendCircle` class: * `FriendCircle(int n)` Initializes the data structure with `n` users. * `boolean request(int u, int v)` Returns `true` if the friend request between users `u` and `v` does not form a cycle in the friend circle, otherwise return `false` and do not add the friendship to the friend circle. Example: 1. User 1 sends a request to User 2: `(1, 2)` 2. User 2 sends a request to User 3: `(2, 3)` 3. User 3 sends a request to User 1: `(3, 1)` In this case, the third request forms a cycle because it creates a cycle 1 -> 2 -> 3 -> 1. Hence, the method should return `false`.","solution":"class FriendCircle: def __init__(self, n): self.parent = list(range(n)) def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: self.parent[root_u] = root_v def request(self, u, v): if self.find(u) == self.find(v): return False self.union(u, v) return True"},{"question":"Given a string `s`, you need to partition the string into the minimum number of substrings such that each substring contains characters that are all the same. Return the number of such substrings. For example, the string `\\"aaabbcc\\"` can be partitioned into `[\\"aaa\\", \\"bb\\", \\"cc\\"]`, resulting in 3 substrings.","solution":"def min_partitions(s): Returns the minimum number of substrings such that each substring contains characters that are all the same. if not s: return 0 partitions = 1 current_char = s[0] for char in s[1:]: if char != current_char: partitions += 1 current_char = char return partitions"},{"question":"Implement a class `MedianFinder` to continuously maintain the median of a sequence of integers being added. The class should be able to handle the following operations: * `MedianFinder()`: Initializes the `MedianFinder` object. * `addNum(int num)`: Adds the integer `num` to the data structure. * `findMedian()`: Returns the median of all elements so far. The median is the middle element in an ordered list if the list length is odd, or the average of the two middle elements if the list length is even. **Note**: - It is guaranteed that the inputs are valid and the `findMedian` method will be called only when there are at least one element in the data structure. - The addNum function must run in O(log n) time and the findMedian function must run in O(1) time.","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # max heap (inverted min heap) self.large = [] # min heap def addNum(self, num: int) -> None: heapq.heappush(self.small, -num) if (self.small and self.large and (-self.small[0] > self.large[0])): heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: if len(self.small) > len(self.large): return float(-self.small[0]) return (-self.small[0] + self.large[0]) / 2.0"},{"question":"You are given an integer array `arr` and an integer `k`. You need to form a string by concatenating all elements of `arr`, where each element of `arr` is converted to its corresponding string representation. Return the maximum number of contiguous substrings in this formed string such that each substring has a length of at least `k` characters. If no such substrings exist, return `0` instead.","solution":"def max_substrings(arr, k): Returns the maximum number of contiguous substrings in the concatenated string formed by arr such that each substring has at least length k. concatenated_str = \'\'.join(map(str, arr)) n = len(concatenated_str) if n < k: return 0 return n // k"},{"question":"Given a string `s` that is a representation of a Roman numeral, convert it to an integer. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M` with the following values: - `I` = 1 - `V` = 5 - `X` = 10 - `L` = 50 - `C` = 100 - `D` = 500 - `M` = 1000 There are some specific rules for these Roman numerals: 1. A numeral can be placed before a larger numeral to subtract. For example, \'IV\' represents 4. 2. A numeral can be placed after a larger or equal numeral to add. For example, \'VI\' represents 6. Return _the integer value of the given Roman numeral string_ `s`.","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to an integer. :param s: String representation of the Roman numeral :return: Integer representation of the Roman numeral roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"You are given a rectangular grid representing a map where each cell of the grid contains either a `0` (representing water) or a `1` (representing land). You must count the number of unique islands in the grid. An island is defined as a group of connected `1`s (land cells) surrounded by `0`s (water cells). Two cells are connected if they are adjacent horizontally or vertically. Diagonally adjacent cells are not connected. Return _the number of unique islands_.","solution":"def num_islands(grid): Returns the number of unique islands in the grid. :param grid: List[List[int]] - 2D list representing the grid. :return: int - number of unique islands. if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return grid[r][c] = 0 # Mark the land cell as visited (turn it into water) dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: island_count += 1 dfs(r, c) return island_count"},{"question":"Given a positive integer `n`, return _the length of the longest sequence of consecutive positive integers that sums up to `n`_. The sequence must contain at least two numbers. Return `-1` if no such sequence exists. **Example:** For `n = 9`, the possible sequence is `[2, 3, 4]`, as `2 + 3 + 4 = 9`. For `n = 8`, there is no sequence of at least two positive integers that sums up to `8`, so the answer is `-1`.","solution":"def longest_sequence_length(n): Returns the length of the longest sequence of consecutive positive integers that sums up to n. Returns -1 if no such sequence exists. max_length = -1 for start in range(1, n): current_sum = start length = 1 for next_num in range(start + 1, n+1): current_sum += next_num length += 1 if current_sum == n: max_length = max(max_length, length) if current_sum >= n: break return max_length if max_length >= 2 else -1"},{"question":"A bank maintains customer accounts, each with a unique account number and a balance. The bank needs a system to manage transfers between accounts. Implement the `Bank` class: * `Bank(vector<long long>& balance)` Initializes the `Bank` object with an array of account balances. * `bool transfer(int account1, int account2, long long amount)` Transfers `amount` of money from `account1` to `account2`. Returns `true` if the transfer is successful, or `false` if `account1` does not have enough balance. * `bool deposit(int account, long long amount)` Deposits `amount` of money into `account`. Returns `true` if the deposit is successful. * `bool withdraw(int account, long long amount)` Withdraws `amount` of money from `account`. Returns `true` if the withdrawal is successful, or `false` if `account` does not have enough balance. Your task is to ensure that all operations are done in constant time, and the system is ready to handle a large volume of transactions efficiently.","solution":"class Bank: def __init__(self, balance): self.balance = balance def transfer(self, account1, account2, amount): if account1 <= 0 or account1 > len(self.balance) or account2 <= 0 or account2 > len(self.balance): return False if self.balance[account1 - 1] < amount: return False self.balance[account1 - 1] -= amount self.balance[account2 - 1] += amount return True def deposit(self, account, amount): if account <= 0 or account > len(self.balance): return False self.balance[account - 1] += amount return True def withdraw(self, account, amount): if account <= 0 or account > len(self.balance): return False if self.balance[account - 1] < amount: return False self.balance[account - 1] -= amount return True"},{"question":"You are given a list of strings `words` and a string `target`. You can perform the following operation on any string in `words` any number of times: choose any character in the string and change it to any other lowercase English letter. Determine the **minimum number of operations** required to change one string in `words` to exactly match the `target` string. Return _the minimum number of operations._","solution":"def min_operations_to_match(words, target): Determine the minimum number of operations required to change one string in `words` to exactly match the `target` string. :param words: list of strings :param target: string to match :return: minimum number of operations required def operations_to_match(word, target): return sum(1 for w_char, t_char in zip(word, target) if w_char != t_char) return min(operations_to_match(word, target) for word in words if len(word) == len(target))"},{"question":"You are given two strings `s` and `t`, where `s` is a 1<=|s|<=1000 lowercase letters only string and `t` is a list of strings each containing lowercase letters only. Return `true` _if any string in `t` is a subsequence of `s`, otherwise return_ `false`_. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters._","solution":"def is_subsequence_of_any(s, t_list): Returns True if any string in t_list is a subsequence of s, otherwise returns False. def is_subsequence(s, t): t_len = len(t) s_index = 0 t_index = 0 while s_index < len(s) and t_index < t_len: if s[s_index] == t[t_index]: t_index += 1 s_index += 1 return t_index == t_len for t in t_list: if is_subsequence(s, t): return True return False"},{"question":"You are given a list of `n` strings `words`. Each string is a combination of lowercase English letters. You need to find the length of the longest string that can be formed using exactly one character from each string in the list. The new string must maintain the order of characters as they appear in the input list. Return _the length of the longest possible string that can be created_. If no such string can be formed, return `0`.","solution":"def longest_string_length(words): Finds the length of the longest string that can be formed using exactly one character from each string in the list while maintaining the order of characters as they appear in the input list. :param words: List of strings :return: Length of the longest possible string that can be created if not words: return 0 # The length of the longest string we can create is the number # of strings in the input list since we need to pick one character # from each string. for word in words: if len(word) == 0: return 0 return len(words)"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters. Your task is to find the longest subsequence `s\'` in `s` such that each character in `s\'` appears in non-decreasing order. Note that subsequences do not have to be contiguous. For example, if `s = \\"abppplee\\"`, one possible solution could be `s\' = \\"apple\\"`. Return the number of characters in such a longest subsequence.","solution":"def longest_non_decreasing_subsequence_length(s): Returns the length of the longest subsequence in string s such that each character appears in non-decreasing order. if not s: return 0 n = len(s) dp = [1] * n for i in range(1, n): for j in range(i): if s[i] >= s[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a matrix `grid` of `n x m` consisting of non-negative integers. You are also given an integer `k`. Your task is to shift all the elements of the `grid` to the right by `k` positions. This shift operation works in such a way that any element that goes beyond the last column of the grid appears at the beginning of the next row in the first column. Similarly, elements from the last row that go beyond the last column reappear at the beginning of the first row. Return the resulting matrix after the shift operation.","solution":"def shift_grid(grid, k): Shift the elements of the grid to the right by k positions. if not grid or not grid[0]: return grid n, m = len(grid), len(grid[0]) total_elements = n * m k = k % total_elements # normalize k to be within the range of total elements # Convert the 2D grid to a 1D list for easier manipulation flattened = [grid[i][j] for i in range(n) for j in range(m)] # Perform the right shift result_flattened = flattened[-k:] + flattened[:-k] # Convert the 1D list back to a 2D grid result_grid = [result_flattened[i * m:(i + 1) * m] for i in range(n)] return result_grid"},{"question":"You are given an integer array `nums` of length `n` and an integer `k`. The **k-radius subarray average** for a subarray of length `2k+1` centered at index `i` is the average of all elements in the subarray. If there is no such subarray, the k-radius subarray average is `-1`. Construct and return _an array of length `n` where the_ `i-th` _element is the k-radius subarray average for the subarray centered at `i`_.","solution":"def getAverages(nums, k): Returns an array of k-radius subarray averages for the array nums with radius k. If a k-radius subarray centered at index i does not exist, return -1 for that index. n = len(nums) result = [-1] * n if 2 * k + 1 > n: return result window_sum = sum(nums[:2 * k + 1]) result[k] = window_sum // (2 * k + 1) for i in range(k + 1, n - k): window_sum = window_sum - nums[i - k - 1] + nums[i + k] result[i] = window_sum // (2 * k + 1) return result"},{"question":"Given a string `s` and an integer `n`, return the **number of distinct substrings** of length `n` that exist in `s`. If `n` is greater than the length of `s`, return 0. For example, given `s = \\"abcabc\\"` and `n = 2`, the distinct substrings would be `\\"ab\\"`, `\\"bc\\"`, and `\\"ca\\"`. Thus, the output should be 3.","solution":"def distinct_substrings(s, n): Returns the number of distinct substrings of length n in the string s. If n is greater than the length of s, return 0. if n > len(s): return 0 substrings = set() for i in range(len(s) - n + 1): substr = s[i:i+n] substrings.add(substr) return len(substrings)"},{"question":"You are given an integer array `nums` and an integer `k`. You need to find out whether there is a **continuous subarray** of length at least 2 that sums up to a multiple of `k`, that is, sums up to `n*k` where `n` is an integer. If it does, return `True`; otherwise, return `False`. Be mindful of special cases where `k` is `0`.","solution":"def check_subarray_sum(nums, k): Check if there is a continuous subarray of length at least 2 that sums up to a multiple of k. :param nums: List of integers :param k: Integer :return: Boolean indicating if such a subarray exists if not nums: return False prefix_sum = 0 prefix_dict = {0: -1} # To handle the case when the subarray that starts from index 0 has the desired sum for i, num in enumerate(nums): prefix_sum += num if k != 0: prefix_sum %= k if prefix_sum in prefix_dict: if i - prefix_dict[prefix_sum] > 1: return True else: prefix_dict[prefix_sum] = i return False"},{"question":"You are given an array of integers `heights` representing the height of students standing in a line, in the order they appear. A student is considered \\"out of place\\" if their height is greater than the height of the student directly in front of them. Your task is to determine the minimum number of students who must be moved to fix the line, such that no student is out of place. Return _the **minimum number of movements** needed to achieve this_.","solution":"def height_check(heights): Returns the minimum number of movements needed to make sure no student is out of place in terms of height. Args: heights (List[int]): A list of integers representing heights of students. Returns: int: Minimum number of movements needed. sorted_heights = sorted(heights) return sum(1 for i in range(len(heights)) if heights[i] != sorted_heights[i])"},{"question":"You are given a **0-indexed** integer array `arr` where the length is `n`. Each element in the array represents the height of a building. A building can trap water if there are taller buildings on either side of it. Calculate the total amount of water that can be trapped after raining. Return _the total water trapped_ by the array.","solution":"def trap_water(arr): Given an integer array arr representing the height of buildings, return the total amount of water that can be trapped. Args: arr (List[int]): A 0-indexed integer array where the length is n. Returns: int: Total water trapped after raining. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"You are given a grid `board` of size `m x n`, where each cell contains a character from `\'a\'` to `\'z\'`. You want to find the longest path on the board such that no letter is repeated. The path can move in any of the four cardinal directions (up, down, left, right) from the current cell. Return the _length of the longest path_ with no repeated characters.","solution":"def longest_path(board): def dfs(x, y, visited): longest = 0 visited.add(board[x][y]) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and board[nx][ny] not in visited: longest = max(longest, dfs(nx, ny, visited)) visited.remove(board[x][y]) return longest + 1 max_path = 0 for i in range(len(board)): for j in range(len(board[0])): max_path = max(max_path, dfs(i, j, set())) return max_path"},{"question":"Given a string `s`, find the largest substring that contains only unique characters. Return the length of this substring. If there are multiple substrings of the same maximum length, return the length of any one of them. For example, for the string `s` `\\"abcabcbb\\"`, the answer would be `3` (the substrings \\"abc\\" and \\"bca\\" both have a length of `3`).","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_index_map: start = max(start, char_index_map[char] + 1) char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a list of integers `nums` where each integer represents a different task. Each task takes exactly one unit of time to complete. There is also an integer `cooldown` that represents the minimum number of units of time that must pass before the same task can be performed again. Return the minimum number of units of time required to complete all the tasks, executing them in such a way to honor the cooldown period between the same tasks.","solution":"def min_time_with_cooldown(nums, cooldown): Calculate the minimum time needed to complete all tasks with a given cooldown period. Args: nums (list of int): List of tasks. cooldown (int): Number of units of time that must pass before the same task can be performed again. Returns: int: Minimum time required to complete all tasks. task_map = {} time = 0 for task in nums: if task in task_map and (time - task_map[task] - 1) < cooldown: time_timeout = task_map[task] + cooldown + 1 time = max(time, time_timeout) task_map[task] = time time += 1 return time"},{"question":"You are given an `m x n` matrix of integers `matrix`. Each row and each column of the matrix is sorted in ascending order. Write a function to find if a given target value `target` exists in the matrix. The function should return `true` if the target value is found and `false` otherwise. Be sure to optimize your solution, taking advantage of the matrix\'s properties.","solution":"def search_matrix(matrix, target): Search for a target value in a m x n matrix. Each row and column is sorted in ascending order. :param matrix: List of List of integers representing the matrix. :param target: Integer representing the target value to find. :return: Boolean indicating if the target exists in the matrix. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given an array of integers `arr` representing the heights of consecutive buildings. An individual can jump from building `i` to building `j` if the height of building `j` is greater than or equal to the height of building `i` and `j` is exactly one index to the right of `i`. Design an algorithm to compute the maximum number of buildings one can consecutively jump to starting from any building. For example, given the array `[1, 2, 3, 2, 5, 6, 7]`, the output of your algorithm would be `4` as one can jump from the first building to the second, to the third, skip the fourth one, and then jump to the fifth, sixth, and seventh buildings.","solution":"def max_building_jumps(arr): Returns the maximum number of buildings one can consecutively jump to starting from any building. if not arr: return 0 n = len(arr) max_jump_sequence = 1 current_sequence = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: current_sequence += 1 else: max_jump_sequence = max(max_jump_sequence, current_sequence) current_sequence = 1 # Compare for the last sequence max_jump_sequence = max(max_jump_sequence, current_sequence) return max_jump_sequence"},{"question":"Given an array of integers `nums` representing the scores of `n` students, your task is to determine the resultant array after a series of operations. In each operation, you must: 1. Select an adjacent pair of elements, remove them from the array, and replace them with their sum. 2. Repeat the process until only one element remains in the array. You should return the final remaining element in the array after performing the above operations on `nums`.","solution":"def final_sum(nums): Determines the final remaining element after repeatedly summing adjacent pairs of elements. Args: nums : List[int] - List of integers representing the scores Returns: int - Final remaining element after all operations while len(nums) > 1: combined_nums = [] for i in range(0, len(nums) - 1, 2): combined_nums.append(nums[i] + nums[i + 1]) if len(nums) % 2 == 1: combined_nums.append(nums[-1]) nums = combined_nums return nums[0]"},{"question":"You are given a string `s` consist of lowercase alphabets and an integer `k`. A **subsequence** of `s` is considered beautiful if it has at least `k` unique characters. Note that a subsequence is a sequence that can be derived from `s` by deleting some or no characters without changing the order of the remaining characters. Return the maximum length of a beautiful subsequence of `s`. If there is no beautiful subsequence, return `-1`.","solution":"def max_beautiful_subsequence_length(s, k): Returns the maximum length of a beautiful subsequence with at least k unique characters. if s is None or k <= 0: return -1 unique_chars = set(s) if len(unique_chars) < k: return -1 # Since we need at least k unique characters # we just need the length of the given string return len(s)"},{"question":"Given a linked list, merge alternate nodes from the second half into the first half in reverse order. The linked list is guaranteed to have an even number of nodes. For example, for the linked list `1 -> 2 -> 3 -> 4 -> 5 -> 6`, the result will be `1 -> 6 -> 2 -> 5 -> 3 -> 4`. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_alternate_reverse(head): Merges alternate nodes from the second half into the first half in reverse order. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list. if not head or not head.next or not head.next.next: return head # Find the middle of the list slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Split the list into two halves second_half = slow.next slow.next = None # Reverse the second half prev = None current = second_half while current: next_node = current.next current.next = prev prev = current current = next_node second_half = prev # Merge the lists alternately first = head second = second_half while second: first_next = first.next second_next = second.next first.next = second second.next = first_next first = first_next second = second_next return head"},{"question":"You are given an array `instructions` where `instructions[i] = [\\"op\\", val1, val2]`, representing the operation `op` with arguments `val1` and `val2`. The operations can be one of the following: - `\\"add\\"`: Add `val2` to `val1`. - `\\"multiply\\"`: Multiply `val1` by `val2`. - `\\"subtract\\"`: Subtract `val2` from `val1`. - `\\"divide\\"`: Divide `val1` by `val2`. Perform all operations in the order they appear in the array and return the list of results after each operation. If an operation is invalid (e.g., division by zero), return \\"Invalid operation\\" for that specific operation.","solution":"def process_instructions(instructions): Processes a list of instructions where each instruction is a list of format [\\"op\\", val1, val2] and performs the respective operation. Args: instructions (list): A list of instructions. Returns: list: A list of results after each operation. results = [] for instr in instructions: op, val1, val2 = instr if op == \\"add\\": results.append(val1 + val2) elif op == \\"multiply\\": results.append(val1 * val2) elif op == \\"subtract\\": results.append(val1 - val2) elif op == \\"divide\\": if val2 == 0: results.append(\\"Invalid operation\\") else: results.append(val1 / val2) else: results.append(\\"Invalid operation\\") return results"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the longest substring of `s` such that every character in the substring appears at least `k` times. You must solve this problem without using extra space for hashmaps or arrays that track characters\' frequencies. Write a function `int longestSubstring(String s, int k)` that returns the length of the longest such substring.","solution":"def longestSubstring(s, k): Returns the length of the longest substring where every character appears at least `k` times. def longest_substring_helper(s, k, start, end): if end - start < k: return 0 count = [0] * 26 for i in range(start, end): count[ord(s[i]) - ord(\'a\')] += 1 for mid in range(start, end): if count[ord(s[mid]) - ord(\'a\')] >= k: continue next_mid = mid + 1 while next_mid < end and count[ord(s[next_mid]) - ord(\'a\')] < k: next_mid += 1 return max(longest_substring_helper(s, k, start, mid), longest_substring_helper(s, k, next_mid, end)) return end - start return longest_substring_helper(s, k, 0, len(s))"},{"question":"You are given an integer array `nums` that contains both positive and negative numbers of varying magnitudes. Your goal is to find the maximum sum of any _contiguous subarray_ within the array. This is a well-known problem often referred to as the \\"Maximum Subarray Problem\\" or \\"Kadane\'s Algorithm\\". The algorithm should run in O(n) time complexity. Return the maximum sum of the contiguous subarray. For example, given the input `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the subarray with the maximum sum is `[4, -1, 2, 1]`, and the corresponding sum is `6`.","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray within the given array `nums`. Args: nums (List[int]): The input list of integers containing both positive and negative numbers. Returns: int: The maximum sum of any contiguous subarray. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"A research lab has a collection of DNA sequences represented as strings. Each DNA string is composed of the characters \'A\', \'C\', \'G\', and \'T\'. A DNA sequence is considered to have a **repeated segment** if a substring of length 10 appears more than once in the DNA sequence. Given a string `s` representing a DNA sequence, return _all the 10-letter-long sequences (substrings) that occur more than once in the DNA sequence. You must write an algorithm that runs in `O(n)` time, where `n` is the length of `s`._","solution":"def findRepeatedDnaSequences(s): Finds all 10-letter-long sequences (substrings) that occur more than once in the DNA sequence. Args: s (str): DNA sequence composed of the characters \'A\', \'C\', \'G\', and \'T\'. Returns: List[str]: List of 10-letter-long sequences that appear more than once. seen, repeated = set(), set() for i in range(len(s) - 9): segment = s[i:i+10] if segment in seen: repeated.add(segment) else: seen.add(segment) return list(repeated)"},{"question":"Given an array of integers `arr`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.","solution":"def contains_duplicate(arr): Returns true if any value appears at least twice in the array, else false. return len(arr) != len(set(arr))"},{"question":"Given a string `s` and an integer `numRows`, convert the string into a zigzag pattern on a given number of rows and return the resulting string read line by line. For example, given the input string \\"PAYPALISHIRING\\" with `numRows = 3`, the zigzag pattern would be: ``` P A H N A P L S I I G Y I R ``` So, the output should be \\"PAHNAPLSIIGYIR\\".","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"You are given a list of integers `arr` and an integer `k`. Your task is to rearrange the list such that all even numbers precede all odd numbers while maintaining the relative order of even and odd numbers. You must achieve this with a single pass through the list and with O(1) extra space. Return the modified list. Example: Input: `arr = [3, 1, 2, 4, 7, 6]`, `k = 1` Output: `[2, 4, 6, 3, 1, 7]`","solution":"def rearrange_even_odd(arr): Rearrange the list `arr` such that all even numbers precede all odd numbers while maintaining the relative order of even and odd numbers. if not arr: # When the input list is empty return arr even_count = 0 for i in range(len(arr)): if arr[i] % 2 == 0: # Check if the current element is even arr.insert(even_count, arr.pop(i)) # Insert to the position of even_count and pop from i even_count += 1 # Increment the even count return arr"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `k`. Define the frequency of a substring as the number of times it appears in the string. Your task is to find the lexicographically smallest substring of length `k` that has the highest frequency in the string. Return this substring.","solution":"def find_lexicographically_smallest_substring(s, k): Finds the lexicographically smallest substring of length k with the highest frequency in the string. :param s: Input string consisting of only lowercase English letters. :param k: Length of the substring. :return: Lexicographically smallest substring of length k with the highest frequency. from collections import defaultdict # Create a dictionary to store the frequency of substrings of length k freq_dict = defaultdict(int) # Iterate through the string to count the frequency of each substring of length k for i in range(len(s) - k + 1): substring = s[i:i+k] freq_dict[substring] += 1 # Find the maximum frequency max_frequency = max(freq_dict.values()) # Filter out the substrings with the maximum frequency max_frequency_substrings = [substr for substr, freq in freq_dict.items() if freq == max_frequency] # Find and return the lexicographically smallest substring among those with the maximum frequency return min(max_frequency_substrings)"},{"question":"You are given a list of integers representing the amount of time each task takes and an integer `d` representing the number of available days. You need to schedule exactly one task per day. Each task can only be done once, and tasks must be completed consecutively. Return _the **minimum** number of days needed to complete all tasks if tasks completed on consecutive days form a valid schedule_. - A **valid schedule** is defined as arranging the tasks such that the sum of the task durations assigned each day does not exceed a certain `daily limit`, which will minimize the number of days required. - You may assume that `daily limit` to be any reasonable positive integer as part of the optimization process.","solution":"def min_days(tasks, d): Returns the minimum number of days needed to complete all tasks if tasks completed on consecutive days are a valid schedule. :param tasks: List of task durations :param d: Number of available days :return: Minimum number of days required def is_valid_schedule(daily_limit): days_needed = 1 current_sum = 0 for task in tasks: if current_sum + task > daily_limit: days_needed += 1 current_sum = task if days_needed > d: return False else: current_sum += task return True if not tasks: return 0 left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_valid_schedule(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a string `s`, you need to check if it can be transformed into a palindrome by removing at most one character. A palindrome is a string that reads the same backward as forward. Return `true` if the string can be transformed into a palindrome and `false` otherwise. For Example: - Input: \\"abca\\" - Output: true Explanation: You can remove the character \'c\' from \\"abca\\" to get \\"aba\\" which is a palindrome.","solution":"def valid_palindrome(s): Check if a string can be transformed into a palindrome by removing at most one character. Parameters: s (str): The input string. Returns: bool: True if the string can be transformed into a palindrome, False otherwise. def is_palindrome_range(i, j): Helper function to check if the substring s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, j)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # Check by removing one character either from left or right. return is_palindrome_range(l+1, r) or is_palindrome_range(l, r-1) l += 1 r -= 1 return True"},{"question":"You are given a list of positive integers representing the heights of a set of buildings in a skyline. The buildings are displayed in a specific order from left to right. A building\'s **visibility** is determined by the number of buildings to its right that are taller than itself. Write a function that returns the **visibility score** for each building in the order they appear in the list. Specifically, the visibility score for a building is the count of buildings that are taller than the given building to its right. For example, given the list `[3, 5, 3, 2, 4, 6]`, the visibility scores would be `[5, 6, 4, 4, 6, 0]`. Implement a function `buildingVisibility(List[int] heights) -> List[int]` to return the visibility scores for each building.","solution":"def building_visibility(heights): Returns the visibility score for each building in the order they appear in the list. The visibility score is determined by counting the number of buildings to its right that are taller than itself. n = len(heights) # Initialize the result list with zeros visibility_scores = [0] * n # Iterate over each building from left to right for i in range(n): for j in range(i + 1, n): if heights[j] > heights[i]: visibility_scores[i] = heights[j] break return visibility_scores"},{"question":"Given an integer array `arr`, return the maximum product obtained from the elements of any contiguous subarray of `arr`. If the array contains only one element, return that element. A contiguous subarray is a subarray composed of consecutive elements from the original array in the same order.","solution":"def max_product_subarray(arr): Returns the maximum product obtained from the elements of any contiguous subarray of arr. If the array contains only one element, returns that element. :param arr: List[int] - array of integers :return: int - maximum product of any contiguous subarray if len(arr) == 1: return arr[0] current_max = arr[0] current_min = arr[0] max_product = arr[0] for num in arr[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"You are given an unsorted array `arr` of unique integers. Your task is to determine if there exists a pair of elements in the array such that their sum is equal to a given target `x`. Return `true` if such a pair exists, otherwise return `false`. You should aim to find a solution with a time complexity better than O(n^2).","solution":"def has_pair_with_sum(arr, x): Determine if there exists a pair of elements in the array such that their sum is equal to x. :param arr: List[int] - A list of unique integers. :param x: int - The target sum. :return: bool - True if such a pair exists, otherwise False. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"You are given a string `s` and an array of integers `indices` of the same length. The string `s` contains only lowercase English letters, and each character in the string must be moved to the position indicated by the corresponding value in the `indices` array. Reconstruct the string and return it. For example, if `s` = `\\"abcde\\"` and `indices` = `[4,3,2,1,0]`, then the newly reconstructed string should be `\\"edcba\\"`.","solution":"def restore_string(s, indices): Reconstructs the string s based on the indices array which tells the position of each character in the final string. Args: s (str): a string of lowercase English letters. indices (list of int): an array of integers representing the positions. Returns: str: the newly reconstructed string. # Create an empty list to hold the characters at the correct positions result = [\'\'] * len(s) # Place each character at the corresponding position for i, char in enumerate(s): result[indices[i]] = char # Join the list into a string and return return \'\'.join(result)"},{"question":"You are given an array of integers `nums` where each integer `nums[i]` represents the position of a balloon. You are initially positioned at the starting index (0) and can move forward to any subsequent balloon, but you may not move backwards. For each index `i`, you can jump from the balloon at index `i` to the balloon at any index `i + nums[i]` if that index exists. Find the minimum number of jumps you need to reach the end of the array. If it is not possible to reach the end, return `-1`.","solution":"def min_jumps(nums): Returns the minimum number of jumps needed to reach the end of the array. If it is not possible to reach the end, returns -1. if len(nums) <= 1: return 0 jumps = 0 farthest = 0 current_end = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= len(nums) - 1: return jumps return -1 if current_end < len(nums) - 1 else jumps"},{"question":"You are given an `m x n` integers matrix `matrix`. You have to sort each row of the matrix independently in ascending order and return the resulting matrix. Write a function `sortMatrixRows` that takes a matrix as input and returns the sorted matrix. Function signature: ``` def sortMatrixRows(matrix: List[List[int]]) -> List[List[int]]: ```","solution":"from typing import List def sortMatrixRows(matrix: List[List[int]]) -> List[List[int]]: This function takes a 2D list (matrix) as input and returns the matrix with each row sorted in ascending order. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: List[List[int]]: The matrix with each row sorted in ascending order. return [sorted(row) for row in matrix]"},{"question":"Given two strings `s` and `t` consisting of only lowercase letters, you need to determine if you can convert `s` to `t` using the following operations exactly once: 1. Choose a non-empty substring of `s` and reverse it. Return `true` if it is possible to transform `s` into `t` using only the operations described above, otherwise return `false`.","solution":"def can_transform_by_reversing_substring(s, t): Determines if you can convert string s to string t by reversing exactly one substring. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if it is possible to transform s into t by reversing one substring, False otherwise. if len(s) != len(t): return False # Find the first and last positions where s and t differ start, end = None, None for i in range(len(s)): if s[i] != t[i]: if start is None: start = i end = i # If start is None, it means both strings are exactly same, no need for any operation. if start is None: return True # Reverse the substring s[start:end+1] and check if it equals to t[start:end+1] return s[:start] + s[start:end+1][::-1] + s[end+1:] == t"},{"question":"You are given a `0-indexed` integer matrix `grid` representing a rectangular cake, where each cell contains either an even or odd number. You can perform a series of operations where, in each operation, you select any row or column of the matrix and reverse the order of elements in that row or column. Your task is to determine the **minimum number of operations** required to make all rows in the `grid` identical. If it is impossible, return `-1`. Return _the **minimum number of operations** to make all rows of the grid identical_ or `-1` if it\'s not possible.","solution":"def min_operations_to_make_rows_identical(grid): Determine the minimum number of operations to make all rows identical in the matrix grid. Return -1 if it is impossible. # Get the number of rows and columns in the grid rows = len(grid) cols = len(grid[0]) # Function to reverse a list def reverse(lst): return lst[::-1] # Try to make all rows equal to the first row considering both original and reversed versions first_row = grid[0] reversed_first_row = reverse(first_row) # Function to determine the minimum operations needed to make a target row equal def min_operations_to_match(row, target_row, reversed_target_row): if row == target_row: return 0 elif row == reversed_target_row: return 1 else: return float(\'inf\') # Calculate total minimum operations total_operations = 0 for row in grid[1:]: operations = min_operations_to_match(row, first_row, reversed_first_row) if operations == float(\'inf\'): return -1 total_operations += operations return total_operations"},{"question":"You are given a list of positive integers representing the prices of `n` different candy bars. Each candy bar\'s price is distinct. You are tasked with distributing these candy bars between Alice and Bob under the following conditions: - Both Alice and Bob should receive an equal number of candy bars. - The total price of candy bars Alice receives should be as close as possible to the total price of candy bars Bob receives. Implement the `CandyDistribution` class: - `CandyDistribution(int[] prices)` Initialize the object with the array of `prices`. - `int[] distributeCandy()` Return an array of two integers: * The total price of candy bars Alice receives. * The total price of candy bars Bob receives, such that the absolute difference between the two totals is minimized. You must design an algorithm that aims to balance the total prices of the candy bars distributed to Alice and Bob as evenly as possible.","solution":"class CandyDistribution: def __init__(self, prices): self.prices = prices def distributeCandy(self): prices = sorted(self.prices, reverse=True) alice_total = 0 bob_total = 0 alice_candies = [] bob_candies = [] for price in prices: if alice_total <= bob_total: alice_candies.append(price) alice_total += price else: bob_candies.append(price) bob_total += price return [alice_total, bob_total]"},{"question":"Write a function that takes a singly linked list and returns the node where the cycle begins. If there is no cycle, return `null`. An input list can be represented as a list of `Node` objects where each `Node` has fields for `val` (which holds the value of the node) and `next` (which points to the next node in the list). Your solution must use `O(1)` (i.e., constant) memory.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): This function detects the node where a cycle begins in a singly linked list. If there is no cycle, it returns None. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, find the entry location slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"Given a string `s` composed of lowercase English letters and an integer `k`, you need to divide the string into `k` contiguous substrings such that the difference between the length of the longest substring and the length of the shortest substring is minimized. Return an array of strings, representing the `k` substrings. If it is not possible to divide the string in such a way, return an empty array. For example, given `s = \\"abcdefgh\\"` and `k = 3`, one possible valid output could be `[\\"abc\\", \\"def\\", \\"gh\\"]`, where the difference between the longest and shortest substrings\' lengths is minimized.","solution":"def divide_string(s, k): Divides string s into k contiguous substrings such that the difference between the length of the longest and the shortest substrings is minimized. if k == 0 or len(s) < k: return [] n = len(s) base_length = n // k longer_segments = n % k substrings = [] start = 0 for i in range(k): end = start + base_length + (1 if i < longer_segments else 0) substrings.append(s[start:end]) start = end return substrings"},{"question":"You are given a list of `n` points on a 2D plane, where each point is represented by its coordinates `(x, y)`. Your task is to determine the smallest possible perimeter of a rectangle that can be formed such that each side of the rectangle is parallel to either the x-axis or the y-axis and all given points lie on or inside this rectangle. Return the smallest perimeter as an integer. If no such rectangle can be formed, return -1.","solution":"def smallest_perimeter(points): if not points: # If there are no points, no rectangle can be formed return -1 min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) width = max_x - min_x height = max_y - min_y if width == 0 or height == 0: # if width or height is zero, it\'s a line, no rectangle can be formed. return -1 return 2 * (width + height)"},{"question":"Given an **n x n** 2D grid representing a chessboard where each cell is either empty or contains a knight, determine the minimum number of moves required for a knight to move from a given starting position `start` to a target position `end`. A knight moves in an L-shape: two cells in one direction and one cell in a perpendicular direction, or one cell in one direction and two cells in a perpendicular direction. Return _the minimum number of moves required for the knight to reach the target position from the starting position. If the target position is not reachable, return -1._","solution":"from collections import deque def min_knight_moves(n, start, end): Returns the minimum number of moves required for a knight to move from start to end in an n x n chessboard. If the target position is not reachable, return -1. if start == end: return 0 directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] def is_valid(x, y): return 0 <= x < n and 0 <= y < n queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1])) while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == end: return moves + 1 if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"You are given an integer array `nums` where the elements are sorted in **ascending order**. A **magic index** in `nums` is defined as an index `i` such that `nums[i] == i`. If there exists a magic index in the array, return _the index of the first magic index_. If no magic index exists, return `-1`. The algorithm should have a time complexity of O(log n).","solution":"def find_magic_index(nums): Finds the index of the first magic index in an array, if it exists. def binary_search(left, right): if left > right: return -1 mid = (left + right) // 2 if nums[mid] == mid: # Check if there is an earlier magic index on the left side left_magic = binary_search(left, mid - 1) return mid if left_magic == -1 else left_magic elif nums[mid] > mid: return binary_search(left, mid - 1) else: return binary_search(mid + 1, right) return binary_search(0, len(nums) - 1)"},{"question":"Consider a linked list of integers, where each node contains a unique value. Write a function that takes two inputs: the head of the linked list and an integer `k`, and returns the `k`-th to last element of the linked list. If `k` is larger than the length of the list, return `null`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def kth_to_last(head: ListNode, k: int) -> int: Returns the k-th to last element of the linked list. If k is larger than the length of the list, return None. first = head second = head # Move the `first` pointer k steps ahead for _ in range(k): if first is None: return None # k is larger than the length of the list first = first.next # Move both `first` and `second` pointers until `first` reaches the end while first is not None: first = first.next second = second.next return second.value"},{"question":"You are given an integer array `arr` and another integer `x`. The goal is to determine if there exist two distinct indices `i` and `j` in `arr` such that `arr[i] + arr[j] == x`. Write a function that takes these inputs and returns a boolean value indicating whether such a pair exists.","solution":"def has_pair_with_sum(arr, x): Determine if there exist two distinct indices i and j in arr such that arr[i] + arr[j] == x. Args: arr: List[int] - A list of integers. x: int - The target sum. Returns: bool - True if there is a pair with sum x, otherwise False. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"Given a binary search tree (BST), write a function that finds the **minimum difference** between the values of any two different nodes in the tree. The structure of the tree node is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` Implement the function: ``` public int minDiffInBST(TreeNode root) ``` that returns the minimum difference between the values of any two different nodes in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDiffInBST(root): Returns the minimum difference between the values of any two different nodes in the BST. def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) values = in_order_traversal(root) min_diff = float(\'inf\') for i in range(1, len(values)): min_diff = min(min_diff, values[i] - values[i-1]) return min_diff"},{"question":"You are given an array of integers `nums` where each element appears **twice**, except for one element which appears only **once**. Find and return the element that appears only once. Implement this in **O(n)** time complexity and **O(1)** space complexity.","solution":"def single_number(nums): Returns the element that appears only once in the array. # Initialize the variable to store the result result = 0 # Iterate through all elements in the array for num in nums: # Apply XOR operation between result and current number result ^= num return result"},{"question":"You are given an array of integers `arr` and an integer `k`. The array represents the heights of `n` towers. You need to determine the minimum possible difference between the height of the tallest modified tower and the height of the shortest modified tower after modifying the height of each tower by either increasing or decreasing it by `k` units. The answer should be the minimum difference between the maximum and minimum heights of the modified towers. Return the minimized difference.","solution":"def minimize_difference(arr, k): Determines the minimum possible difference between the height of the tallest modified tower and the height of the shortest modified tower after modifying each tower height by either increasing or decreasing it by `k` units. Args: arr (list of int): List of integers representing the heights of the towers. k (int): The amount by which the height of each tower can be modified. Returns: int: The minimum possible difference between the maximum and minimum heights of the modified towers. if not arr or len(arr) == 1: return 0 arr.sort() n = len(arr) # Initial difference before any modification initial_diff = arr[-1] - arr[0] # Minimum and maximum heights after modification min_height = arr[0] + k max_height = arr[-1] - k if min_height > max_height: min_height, max_height = max_height, min_height for i in range(1, n - 1): subtract_k = arr[i] - k add_k = arr[i] + k if subtract_k >= min_height or add_k <= max_height: continue if max_height - subtract_k <= add_k - min_height: min_height = subtract_k else: max_height = add_k return min(initial_diff, max_height - min_height)"},{"question":"You are given a 2D array `grid` of size `m x n`. Each cell contains a non-negative integer, representing the height of a cell in a 2D elevation map. The `water_pool` function determines the amount of water that can be trapped after raining across the entire grid. The function returns the total volume of water trapped. Water can only be trapped by the surrounding cells and cannot flow out of the grid.","solution":"import heapq def water_pool(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): for j in [0, n - 1]: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True for j in range(n): for i in [0, m - 1]: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return water_trapped"},{"question":"Given an array of integers `height` where `height[i]` represents the height of the `ith` building in a city skyline, and an integer `bricks`, return _the maximum number of consecutive buildings you can ascend starting from the first building, using the given number of bricks_. Each time you ascend from building `i` to building `i+1`, you use up `height[i+1] - height[i]` bricks (if `height[i+1] > height[i]`). If at any point you run out of bricks and cannot proceed, stop and return the count of the buildings you have ascended including the current one.","solution":"def max_buildings_ascend(height, bricks): Given an array of building heights and an integer representing bricks, return the maximum number of consecutive buildings that can be ascended starting from the first building. count = 1 # We start from the first building i = 0 while i < len(height) - 1: diff = height[i + 1] - height[i] if diff <= 0: # No bricks needed to move from building i to i+1 count += 1 elif bricks >= diff: # Enough bricks to move to the next building bricks -= diff count += 1 else: # Not enough bricks to move to the next building break i += 1 return count"},{"question":"You are given a linked list where the nodes contain integers. Write a function that reverses the linked list up to position `n`. The positions are 1-indexed, meaning the first node is position 1. Return the head of the modified linked list. If `n` is greater than the length of the linked list, reverse the entire list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_up_to_n(head, n): if not head or n == 1: return head # Initialize current, prev and next pointers current = head prev = None # Reverse the first `n` nodes of the linked list count = 0 while current and count < n: next_node = current.next current.next = prev prev = current current = next_node count += 1 # If there are more nodes left, link the (n+1)th node to the original head if head: head.next = current return prev"},{"question":"You are given an integer array `temperatures` representing the daily temperatures, and an integer `k`. The `k` is the threshold of days Senna can wait. For each day, you need to determine how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible within the next `k` days, write `-1` instead. Write a function that takes in `temperatures` and `k` and returns an array of integers representing the answer for each day.","solution":"def daily_temperatures_within_k(temperatures, k): result = [-1] * len(temperatures) stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: index = stack.pop() if i - index <= k: result[index] = i - index stack.append(i) return result"},{"question":"You are given an array of integers `nums` where the length of `nums` is `2n` and the elements in the array range from 1 to 2n inclusive. All elements in `nums` appear exactly twice. You need to form `n` pairs of integers where each pair consists of two equal elements. However, you want to minimize the maximum difference between the pairs\' sum. Return the minimized maximum pair sum of the array.","solution":"def minimize_max_pair_sum(nums): Minimizes the maximum pair sum of the array by properly pairing the elements. nums.sort() max_pair_sum = 0 n = len(nums) // 2 for i in range(n): pair_sum = nums[i] + nums[-i-1] if pair_sum > max_pair_sum: max_pair_sum = pair_sum return max_pair_sum"},{"question":"You are given a string `s` which contains only lowercase alphabets. You need to determine if it\'s possible to rearrange the characters of `s` to form a **palindrome**. A palindrome is a word that reads the same backward as forward. If it is possible to rearrange the characters to form at least one palindrome, return `true`. Otherwise, return `false`. A palindrome can have at most one character with an **odd** frequency, whereas all other characters must appear an **even** number of times. Implement the `Solution` class: * `Solution(String s)` Initializes the object with the string `s`. * `boolean canFormPalindrome()` Returns `true` if it is possible to rearrange the characters of `s` to form a palindrome, otherwise returns `false`.","solution":"class Solution: def __init__(self, s): self.s = s def canFormPalindrome(self): from collections import Counter count = Counter(self.s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1"},{"question":"Given an array of integers `nums` and an integer `k`, return the _k-th largest element_ in the array. Note that it is the k-th largest element in sorted order, not the k-th distinct element. Implement the `findKthLargest` function that takes the array and the value of `k` as arguments and returns the desired element.","solution":"def findKthLargest(nums, k): Finds the k-th largest element in the list nums. Args: nums (List[int]): List of integers. k (int): The k-th position (1-based index) to find the largest element. Returns: int: The k-th largest element in the list. nums.sort(reverse=True) return nums[k - 1]"},{"question":"You are given a binary tree where each node contains an integer value. The path sum of a path in the binary tree is the sum of the values of the nodes along the path. A **good path** is a path that starts at the root node and ends at any node, where no two consecutive nodes on the path have the same value. Given the root of the binary tree, return the length of the longest **good path**.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_good_path(root): def dfs(node, parent_value): if not node: return 0 left_length = dfs(node.left, node.value) right_length = dfs(node.right, node.value) return 1 + max(left_length, right_length) if node.value != parent_value else max(left_length, right_length) return dfs(root, None)"},{"question":"You are given a list of non-negative integers, `nums`, representing the amount of water in each section of a linear container. The container is visualized as a histogram, where each bar\'s height corresponds to an element in the list `nums`. The width of each bar is `1`. Each section of the container is connected, allowing water to flow to adjacent sections. Given this setup, determine the maximum amount of water that can be trapped between the bars after it rains. Return the maximum amount of trapped water as an integer.","solution":"def trap(height): Given a list of non-negative integers representing the height of bars in a histogram, returns the maximum amount of water that can be trapped between the bars after it rains. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 max_left, max_right = height[left], height[right] trapped_water = 0 while left < right: if max_left <= max_right: left += 1 max_left = max(max_left, height[left]) trapped_water += max_left - height[left] else: right -= 1 max_right = max(max_right, height[right]) trapped_water += max_right - height[right] return trapped_water"},{"question":"You are given a list of positive integers `arr` where each integer represents the maximum number of steps you can take forward from that position. Write a function to return the minimum number of jumps needed to reach the last index of the list, starting from the first index. If it is not possible to reach the last index, return `-1`. --- This question aligns with the given set as it addresses core programming concepts related to arrays and dynamic programming. It also relates to pathfinding and optimization problems similar to the provided questions.","solution":"def min_jumps(arr): Returns the minimum number of jumps needed to reach the last index of the list. If it is not possible to reach the last index, returns -1. n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 max_reach = arr[0] step = arr[0] jumps = 1 for i in range(1, n): if i == n-1: return jumps max_reach = max(max_reach, i + arr[i]) step -= 1 if step == 0: jumps += 1 if i >= max_reach: return -1 step = max_reach - i return -1"},{"question":"You are given two integers `n` and `m`, representing the number of rows and columns of a grid, respectively. Each cell in the grid can either be empty (represented by `0`) or have an obstacle (represented by `1`). You are initially positioned at the top-left corner of the grid and want to reach the bottom-right corner. You can only move either down or right at any point in time. Write a function to return the number of unique paths from the top-left corner to the bottom-right corner. If it\'s not possible to reach the bottom-right corner, return `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, considering obstacles. :param grid: List[List[int]], a 2D list representing the grid. 0 represents an empty cell. 1 represents an obstacle. :return: int, number of unique paths from the top-left to the bottom-right corner. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # Initialize the DP table dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 # Fill the first row for j in range(1, m): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the first column for i in range(1, n): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"You are given an array of integers `nums` and an integer `threshold`. You need to return the smallest possible integer `k` such that when each element in the array is divided by `k` and rounded up to the nearest integer, the sum of this new array is less than or equal to the given `threshold`.","solution":"import math def smallest_divisor(nums, threshold): Returns the smallest possible integer k such that when each element in the array nums is divided by k and rounded up to the nearest integer, the sum of this new array is less than or equal to the given threshold. def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) result = right while left <= right: mid = (left + right) // 2 if compute_sum(mid) <= threshold: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `k`. You need to find the maximum possible sum of a subarray of length `k`. A subarray is a contiguous part of an array. Return the sum of that subarray. The test cases are generated such that the sum of a subarray of length `k` always exists.","solution":"def max_subarray_sum(nums, k): Returns the maximum possible sum of a subarray of length k. n = len(nums) # Initial sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Slide the window across the array for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given an integer array `nums` and an integer `k`. We define a directed graph where each node represents an element in the array, and there is a directed edge from node `i` to node `j` if and only if `nums[i]` can be transformed into `nums[j]` by flipping exactly `k` bits in the binary representation of `nums[i]`. Return the number of connected components in this graph. **Note:** - Flipping exactly `k` bits means changing `k` bits from 0 to 1 or from 1 to 0.","solution":"def count_connected_components(nums, k): Returns the number of connected components in a directed graph based on the conditions. from collections import defaultdict def bit_count(x): return bin(x).count(\'1\') def can_transform(x, y, k): return bit_count(x ^ y) == k def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Initialization n = len(nums) adj_list = defaultdict(list) # Build the adjacency list for i in range(n): for j in range(i + 1, n): if can_transform(nums[i], nums[j], k): adj_list[i].append(j) adj_list[j].append(i) # Count connected components using DFS visited = set() component_count = 0 for i in range(n): if i not in visited: visited.add(i) dfs(i, visited, adj_list) component_count += 1 return component_count"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a row, and each building\'s width is 1. Write a function to find the maximum area of a rectangle formed by any set of consecutive buildings. The rectangle\'s height is determined by the shortest building in the selected range of buildings, and the width is determined by the number of consecutive buildings chosen. Return the maximum rectangle area that can be formed in the histogram of heights. Note: - The array will have at least one and at most 10^5 elements. - Each element of the array will be a non-negative integer not greater than 10^4.","solution":"def max_rectangle_area(heights): Finds the maximum rectangle area that can be formed by any set of consecutive buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Imagine you are given an integer `N`, representing the number of houses arranged in a straight line. Each house can be either painted red, green, or blue. The cost of painting each house with a certain color is given in a `cost` array, where `cost[i][0]` is the cost of painting the `i`th house red, `cost[i][1]` is the cost of painting the `i`th house green, and `cost[i][2]` is the cost of painting the `i`th house blue. You need to paint all the houses such that no two adjacent houses have the same color, and you want to minimize the total cost of painting. Return the minimum cost to paint all the houses. Note: The constraints for the array are as follows: - `1 <= N <= 100` - `1 <= cost[i][0], cost[i][1], cost[i][2] <= 1000` Let\'s test the function using the following array: ``` cost = [ [17, 2, 17], [16, 16, 5], [14, 3, 19] ] ``` The output for the above array should be `10`.","solution":"def minCost(cost): Returns the minimum cost to paint the houses such that no two adjacent houses have the same color. if not cost: return 0 n = len(cost) for i in range(1, n): # Cost of painting current house red cost[i][0] += min(cost[i-1][1], cost[i-1][2]) # Cost of painting current house green cost[i][1] += min(cost[i-1][0], cost[i-1][2]) # Cost of painting current house blue cost[i][2] += min(cost[i-1][0], cost[i-1][1]) return min(cost[-1])"},{"question":"Given an array of integers `nums`, you need to create a subset of the array such that the sum of the subset is maximum and no two elements in the subset are adjacent in the original array `nums`. Return the maximum sum you can obtain. For example, given the array `[3, 2, 7, 10]`, the subset `[3, 10]` yields the maximum sum of `13` since taking `3` and `10` avoids the adjacent `7` and `2`. another valid subset that yields sum `12` could be `[3, 2, 7]`, but it isnt the maximum amongst all possible sums.","solution":"def max_subset_sum_no_adjacent(nums): Returns the maximum sum of a subset of the given list of integers `nums` such that no two elements in the subset are adjacent in the original array. :param nums: List of integers. :return: Maximum sum obtained from selecting non-adjacent elements. if not nums: return 0 elif len(nums) == 1: return nums[0] include = nums[0] exclude = 0 for i in range(1, len(nums)): new_exclude = max(include, exclude) include = exclude + nums[i] exclude = new_exclude return max(include, exclude)"},{"question":"You are given a **0-indexed** `n x n` matrix `grid` consisting of `0`s (empty cell) and `1`s (obstacle). A line segment should be drawn from the top-left corner at `(0, 0)` to the bottom-right corner at `(n-1, n-1)` which only passes through `0`s. Moving only along horizontal or vertical lines is not allowed. The line segment may take any number of vertical and horizontal steps in any sequence but needs to consider obstacles and ensure continuous connectivity. Determine if there exists a connected line segment from `(0, 0)` to `(n-1, n-1)` that does not pass through any `1`s. If such a path exists, return `True`; otherwise, return `False`. **Note:** The path must be continuous and can be non-linear (e.g., zigzag shape).","solution":"def is_path_available(grid): Returns True if there is a connected path from top-left to bottom-right avoiding obstacles (1\'s), otherwise False. Uses Depth-First Search to determine the path connectivity. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return False directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 def dfs(x, y): if not is_valid(x, y): return False if (x, y) == (n-1, n-1): return True grid[x][y] = -1 # Mark as visited for dx, dy in directions: new_x, new_y = x + dx, y + dy if dfs(new_x, new_y): return True return False return dfs(0, 0)"},{"question":"Given a string `s` and a list of words `words`, return the length of the shortest substring of `s` that contains all the words in `words` as anagrams regardless of order. If there is no such substring, return -1.","solution":"from collections import Counter import sys def shortest_substring_containing_all_anagrams(s, words): Returns the length of the shortest substring of `s` that contains all the words in `words` as anagrams. If there is no such substring, returns -1. if not s or not words: return -1 word_counter = Counter(\'\'.join(words)) required_chars = len(word_counter) left = 0 min_length = sys.maxsize current_counter = Counter() formed = 0 for right in range(len(s)): char = s[right] current_counter[char] += 1 if char in word_counter and current_counter[char] == word_counter[char]: formed += 1 while left <= right and formed == required_chars: char = s[left] if right - left + 1 < min_length: min_length = right - left + 1 current_counter[char] -= 1 if char in word_counter and current_counter[char] < word_counter[char]: formed -= 1 left += 1 return min_length if min_length != sys.maxsize else -1"},{"question":"Given an array of integers `arr` and an integer `k`, return _the maximum sum of any continuous subarray of length `k`_. If the array length is less than `k`, return `0`. The subarray should consist of consecutive elements, where the sum of its elements is the highest among all possible subarrays of that length. Make sure your solution is efficient and handle edge cases appropriately.","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any continuous subarray of length `k`. If the array length is less than `k`, returns 0. n = len(arr) if n < k: return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an array `heights` representing the heights of consecutive fences in a row. You need to paint these fences such that no two adjacent fences have the same color. There are three colors available: Red, Green, and Blue. The cost of painting each fence with a specific color is represented by a 2D array `cost` where `cost[i][0]`, `cost[i][1]`, and `cost[i][2]` are the costs of painting the `ith` fence with Red, Green, and Blue respectively. Return the minimum cost to paint all the fences.","solution":"def minCostToPaintFences(cost): if not cost: return 0 n = len(cost) dp = [[0] * 3 for _ in range(n)] dp[0][0] = cost[0][0] dp[0][1] = cost[0][1] dp[0][2] = cost[0][2] for i in range(1, n): dp[i][0] = cost[i][0] + min(dp[i-1][1], dp[i-1][2]) dp[i][1] = cost[i][1] + min(dp[i-1][0], dp[i-1][2]) dp[i][2] = cost[i][2] + min(dp[i-1][0], dp[i-1][1]) return min(dp[-1])"},{"question":"You are given an array of integers `nums` and an integer `k`. Sort the array in such a way that the maximum difference between any two adjacent elements is minimized. Return _the minimized maximum difference_.","solution":"def minimized_max_diff(nums, k): Sort the array so that the maximum difference between any two adjacent elements is minimized and return the minimized maximum difference. if len(nums) < 2: return 0 # Sort the array nums.sort() # Compute the differences between adjacent elements diffs = [nums[i] - nums[i-1] for i in range(1, len(nums))] return min(diffs)"},{"question":"[Question] 4: Given a string `s` consisting of lowercase English letters, determine if you can make `s` a palindrome after deleting **at most one** character from it. A palindrome is a word that reads the same forward and backward. Return _true_ if it is possible to make `s` a palindrome by deleting at most one character, and _false_ otherwise.","solution":"def valid_palindrome(s: str) -> bool: Determine if you can make `s` a palindrome after deleting at most one character. Args: s (str): a string consisting of lowercase English letters. Returns: bool: True if it is possible to make `s` a palindrome by deleting at most one character, False otherwise. def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try skipping either the left character or the right character return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True"},{"question":"You are tasked with designing an authentication system for a secure vault. The vault can be accessed using a specific sequence of digits, but due to security purposes, it only opens if the request sequence does not contain any forbidden subsequence. Implement the `VaultSecurity` class: * `VaultSecurity(string[] forbidden_sequences)` initializes the data structure with the forbidden sequences. * `canAccess(string sequence)` returns `true` if the given sequence does not contain any of the forbidden subsequences, otherwise returns `false`.","solution":"class VaultSecurity: def __init__(self, forbidden_sequences): Initializes the data structure with the forbidden sequences. :param forbidden_sequences: List of forbidden subsequences. self.forbidden_sequences = forbidden_sequences def canAccess(self, sequence): Returns True if the given sequence does not contain any of the forbidden subsequences, otherwise returns False. :param sequence: The sequence to check. :return: Boolean value indicating whether access is granted. for forbidden in self.forbidden_sequences: if forbidden in sequence: return False return True"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `i-th` person in a queue. Your task is to find the minimum number of people that must be removed from the queue so that the remaining people are in non-decreasing order of their height. Return _the minimum number of removals required._","solution":"def min_removals_to_non_decreasing(heights): Returns the minimum number of removals required to make the heights list non-decreasing. n = len(heights) # Initialize the list to store the length of the longest increasing subsequence ending at each index LIS = [1] * n # Compute the length of the longest increasing subsequence using dynamic programming for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: LIS[i] = max(LIS[i], LIS[j] + 1) # The number of removals required is the size of the array minus the length of the longest increasing subsequence return n - max(LIS)"},{"question":"Given an integer array `arr` representing the amount of time a task takes and an integer `k` representing the number of workers, return the minimum possible time required to complete all tasks. Each worker can only work on one task at a time, and no two workers can work on the same task. All tasks must be completed.","solution":"def min_time_to_complete_tasks(arr, k): Calculate the minimum possible time required to complete all tasks with k workers available. :param arr: List[int] - List of times for each task :param k: int - Number of workers :return: int - Minimum possible time to complete all tasks left, right = max(arr), sum(arr) def can_complete_in_time(mid): Helper function to check if tasks can be done in `mid` time with `k` workers current_time = 0 workers_needed = 1 for time in arr: if current_time + time > mid: workers_needed += 1 current_time = time if workers_needed > k: return False else: current_time += time return True while left < right: mid = (left + right) // 2 if can_complete_in_time(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `rooms` in a hotel, each described by a triplet of integers `[length, width, height]` representing the dimensions of the room in meters. You need to design a booking system that helps customers find a room that meets their dimensional requirements. Each customer describes the size of the room they need with another triplet of integers `desired_length`, `desired_width`, and `desired_height`. Return _an array_ `answer`_, where_ `answer.length` == `number_of_queries` _and_ `answer[i]` _is a list of indices of rooms that meet the requirements of the_ `ith` _query_. A room meets a querys requirements if all the following conditions are satisfied: - The rooms length is greater than or equal to `desired_length` - The rooms width is greater than or equal to `desired_width` - The rooms height is greater than or equal to `desired_height` Given the list of `rooms` and an array of `queries`, return _the array of indices for each query_.","solution":"def find_rooms(rooms, queries): Finds rooms that meet the requirements of each query. Parameters: - rooms: List of list of integers, where each element is [length, width, height]. - queries: List of list of integers, where each element is [desired_length, desired_width, desired_height]. Returns: - List of lists of indices. Each sublist represents the indices of rooms that meet the requirements of the corresponding query. result = [] for q in queries: desired_length, desired_width, desired_height = q indices = [] for i, room in enumerate(rooms): if room[0] >= desired_length and room[1] >= desired_width and room[2] >= desired_height: indices.append(i) result.append(indices) return result"},{"question":"Given an array of integers `arr` and an integer `threshold`, return the maximum integer `k` such that every element in the array can be divided by `k` without leaving a remainder, and `k` is greater than or equal to `threshold`. If no such integer exists, return `-1`. For instance, with `arr = [4, 8, 12]` and `threshold = 2`, the result would be `4`, since `4`, `8`, and `12` are all divisible by `4` and it is greater than `2`.","solution":"from math import gcd from functools import reduce def max_integer_divisor(arr, threshold): Returns the maximum integer k such that every element in the array can be divided by k without leaving a remainder, and k is greater than or equal to threshold. if len(arr) == 0: return -1 def gcd_multiple(numbers): return reduce(gcd, numbers) # Find the GCD of all numbers overall_gcd = gcd_multiple(arr) # Starting from the GCD, find the largest k >= threshold for k in range(overall_gcd, threshold - 1, -1): if all(num % k == 0 for num in arr): return k return -1"},{"question":"You are given an array of strings `words` and a string `pattern`. Your task is to find all strings in `words` that match the given `pattern`. A word matches the pattern if there exists a permutation of letters such that the word can be transformed into the pattern. You should return a list of all matching words. The order of the output list should be the same as the order in `words`. For example, given `words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"]` and `pattern = \\"abb\\"`, the output should be `[\\"mee\\", \\"aqq\\"]`.","solution":"def find_and_replace_pattern(words, pattern): def match(word): if len(word) != len(pattern): return False m1, m2 = {}, {} for w, p in zip(word, pattern): if w not in m1: m1[w] = p if p not in m2: m2[p] = w if (m1[w], m2[p]) != (p, w): return False return True return [word for word in words if match(word)]"},{"question":"Given a function `isPalindrome` that checks if a given string `s` is a palindrome, implement another function `longestPalindromeSubstr` that finds the longest palindromic substring within `s`. The input string `s` contains only lowercase English letters and is non-empty. Return the longest palindromic substring. If there are multiple results with the same length, return the substring which appears first. ```python def longestPalindromeSubstr(s: str) -> str: # Your code here ``` - **Example 1:** - Input: `s = \\"babad\\"` - Output: `\\"bab\\"` (Note: `\\"aba\\"` is also a valid answer) - **Example 2:** - Input: `s = \\"cbbd\\"` - Output: `\\"bb\\"` - **Example 3:** - Input: `s = \\"a\\"` - Output: `\\"a\\"` - **Example 4:** - Input: `s = \\"ac\\"` - Output: `\\"a\\"`","solution":"def longestPalindromeSubstr(s: str) -> str: def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s or len(s) == 1: return s longest = \'\' for i in range(len(s)): # Odd length palindromes substr1 = expand_around_center(s, i, i) if len(substr1) > len(longest): longest = substr1 # Even length palindromes substr2 = expand_around_center(s, i, i + 1) if len(substr2) > len(longest): longest = substr2 return longest"},{"question":"You are given an `m x n` matrix of integers where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Write a function that finds an element `target` in the matrix. Return the _coordinates_ of `target` as a pair (row_index, column_index) if it is found, or `(-1, -1)` if it is not.","solution":"def search_matrix(matrix, target): Returns the coordinates (row_index, column_index) of target in the matrix. If target is not found, returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"You are given a list of `n` integers called `heights`, representing the heights of `n` buildings in a row. An integer `k` denotes the number of bricks available and an integer `m` denotes the number of ladders available to climb these heights. You want to reach the last building in the row (building `n-1`) starting from the first building (building `0`). You can climb from building `i` to building `i+1` with the following conditions: * If the height of the next building is greater than the current building, you can either use bricks or a ladder to climb up. The number of bricks used will be equal to the difference in height. * If the height of the next building is less than or equal to the current building, no bricks or ladders are necessary. Return _the index of the furthest building that can be reached using the given number of bricks and ladders_.","solution":"import heapq def furthest_building(heights, bricks, ladders): Returns the index of the furthest building that can be reached using the given number of bricks and ladders. # Min-heap to store used ladders or bricks heap = [] for i in range(len(heights) - 1): # Calculate difference in height between the current and next building diff = heights[i+1] - heights[i] # If there is an increase in height if diff > 0: heapq.heappush(heap, diff) # If there are more elements in heap than available ladders, use bricks if len(heap) > ladders: bricks -= heapq.heappop(heap) # If we run out of bricks, return the current index if bricks < 0: return i # If we can reach the last building return len(heights) - 1"},{"question":"You are given an array of integers representing the heights of buildings in a city. You need to determine the maximum number of buildings you can view from the top of an observation tower. The observation tower is situated at the first building (index 0), and you can only see a building if it is taller than all the buildings in between the tower and that building. Return _the maximum number of buildings_ you can see from the observation tower.","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings visible from the observation tower. :param heights: List[int] : A list of integers representing the heights of buildings :return: int : The number of buildings visible from the first building if not heights: return 0 max_height = heights[0] visible_count = 1 for i in range(1, len(heights)): if heights[i] > max_height: visible_count += 1 max_height = heights[i] return visible_count"},{"question":"You are given a list of non-negative integers `arr` that are arranged in a sequence, and a target non-negative integer `k`. Your task is to find the **number of subarrays** in `arr` whose elements have a sum exactly equal to `k`. Return _the number of such subarrays_. For example: - If `arr` = [1, 1, 1] and `k` = 2, return `2`. - If `arr` = [1, 2, 3] and `k` = 3, return `2`.","solution":"def count_subarrays_with_sum_k(arr, k): Returns the number of subarrays in arr whose elements have a sum exactly equal to k. count = 0 current_sum = 0 sum_dict = {0: 1} # Sum dictionary to store the frequency of prefix sums. for num in arr: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"You are given an integer array `nums` of length `n` representing the weight of `n` items. You are also given an integer `k` representing the number of components that you need to divide these items into. Each component should contain at least one item, and the total weight of items in each component is the sum of the weights of the items in that component. A **valid partition** divides the `n` items into `k` non-empty components such that for each component, the total weight is no more than a given maximum weight `W`. Return _the **minimum** possible value of `W` to achieve a valid partition_ of the `n` items into `k` components.","solution":"def is_valid_partition(nums, k, max_weight): Helper function to determine if we can partition nums into k components with max weight max_weight. current_sum = 0 count = 1 # We start with 1 component for weight in nums: if current_sum + weight <= max_weight: current_sum += weight else: count += 1 current_sum = weight if count > k: return False return True def min_max_weight_partition(nums, k): Returns the minimum possible value of max weight W for a valid partition into k components. left = max(nums) # Minimum of max_weight should be at least the maximum element in nums right = sum(nums) # Maximum of max_weight can be the sum of all elements while left < right: mid = (left + right) // 2 if is_valid_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a `m x n` grid `grid` representing a map where `1` represents land and `0` represents water. Only the vertical or horizontal edge of one land cell can connect to another land cell. The grid is said to be an island if all the land cells are connected directly or indirectly and there are no other land cells outside this connected component. A **bridge** is a straightforward path that connects a land cell `(i, j)` to another land cell `(k, l)` using horizontal and vertical steps only over water cells `0`, without crossing any other land cells `1`. The length of a bridge here is the number of water cells it crosses. You need to find the shortest possible bridge that can be built to connect any two disconnected islands in the grid. Return _the minimum length of the shortest bridge that can be built to connect any two islands_. It\'s guaranteed that there are exactly two islands on the grid.","solution":"from collections import deque def shortest_bridge(grid): def bfs_find_island(x, y): queue = deque([(x, y)]) island = set([(x, y)]) grid[x][y] = -1 while queue: cx, cy = queue.popleft() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: queue.append((nx, ny)) grid[nx][ny] = -1 island.add((nx, ny)) return island def bfs_expand_island(): steps = 0 while queue: for _ in range(len(queue)): cx, cy = queue.popleft() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): if grid[nx][ny] == 1: return steps if grid[nx][ny] == 0: grid[nx][ny] = -1 queue.append((nx, ny)) steps += 1 return -1 # Find the first island found_island = False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island1 = bfs_find_island(i, j) found_island = True break if found_island: break # Expand the first island to find the shortest bridge to the second island queue = deque(island1) return bfs_expand_island()"},{"question":"Given a string `s` containing only the characters `\'(\'` and `\')\'`, return the length of the longest balanced substring. A balanced substring is defined as one that has an equal number of opening and closing parentheses in proper order. Note that the parentheses must be correctly nested to be considered balanced.","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring containing properly nested parentheses. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"Given a list of strings `words`, determine if there exists a sequence of words such that each word is a prefix of the next word in the sequence. If such a sequence exists, return the longest possible sequence. If multiple longest sequences exist, return any one of them. If no such sequence exists, return an empty list. The returned sequence must maintain the order in which the words appear in the original list.","solution":"def longest_prefix_sequence(words): Returns the longest sequence of words such that each word is a prefix of the next word in the sequence. If no such sequence exists, returns an empty list. if not words: return [] longest_seq = [] current_seq = [] for i, word in enumerate(words): if not current_seq or word.startswith(current_seq[-1]): current_seq.append(word) else: if len(current_seq) > len(longest_seq): longest_seq = current_seq[:] current_seq = [word] if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"You are given an integer array `blocks` where the `i-th` element represents the height of the `i-th` block. You can stack blocks on top of each other to form towers, but you can only stack a block on top of another block if the height of the top block is less than or equal to the height of the bottom block. Return the number of distinct towers you can build using the given blocks. Note that blocks of the same height are considered identical.","solution":"def count_distinct_towers(blocks): Returns the number of distinct towers that can be built using the given blocks. # Convert the list to a set to eliminate duplicate heights unique_blocks = set(blocks) # The number of distinct towers will be the number of unique block heights return len(unique_blocks)"},{"question":"Given an array of integers, `arr`, of size `n`, you need to determine the **length** of the **longest contiguous subarray** that contains **at most two distinct numbers**. Return the length of this subarray.","solution":"def longest_subarray_with_two_distinct(arr): Returns the length of the longest contiguous subarray that contains at most two distinct numbers. if not arr: return 0 n = len(arr) max_len = 0 left = 0 num_count = {} for right in range(n): if arr[right] in num_count: num_count[arr[right]] += 1 else: num_count[arr[right]] = 1 while len(num_count) > 2: num_count[arr[left]] -= 1 if num_count[arr[left]] == 0: del num_count[arr[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an m x n integer matrix `mat` containing distinct numbers, where each row and each column is sorted in ascending order. Given an integer `target`, return _the position_ (i.e., `[row_index, col_index]`) of the `target` number in the matrix. If the target is not found, return `[-1, -1]`. Write an efficient algorithm to search for the `target` in the matrix.","solution":"def search_matrix(mat, target): Searches for the target in a sorted matrix and returns its position. Each row and column in the matrix is sorted in ascending order. Parameters: mat (list of list of int): The m x n matrix with distinct numbers sorted in ascending order. target (int): The target number to find in the matrix. Returns: list: The position [row_index, col_index] of the target if found, otherwise [-1, -1]. if not mat or not mat[0]: return [-1, -1] m, n = len(mat), len(mat[0]) row, col = 0, n - 1 while row < m and col >= 0: if mat[row][col] == target: return [row, col] elif mat[row][col] > target: col -= 1 else: row += 1 return [-1, -1]"},{"question":"You are given a string `s` representing a mathematical expression with only non-negative integers and the operators `\'+\'`, `\'-\'`, and `\'*\'`. Implement a function to evaluate the expression and return its result. The integer division should truncate toward zero. Note that the expressions are always valid, and there will be no division by zero operations. You may assume that the given expression contains no parentheses and that all operations have the same precedence. For example, given the input \\"3+2-5*6\\", the expected output is -25.","solution":"def evaluate_expression(s): Evaluates a mathematical expression with non-negative integers and operators \'+\' \'-\' \'*\'. tokens = [] num = 0 op = \'+\' for char in s + \'+\': if char.isdigit(): num = num * 10 + int(char) else: if op == \'+\': tokens.append(num) elif op == \'-\': tokens.append(-num) elif op == \'*\': tokens[-1] = tokens[-1] * num op = char num = 0 return sum(tokens)"},{"question":"You are given a string `time` in the format of `\\"HH:MM\\"`, which represents the time on a 24-hour clock. Your task is to find the next closest time that can be formed using the digits currently present in the given time string. This means that you can use the existing digits from `time`, and you must form a valid time that is as close as possible to the original time, but is strictly greater than the original time. If no such time exists on the same day, return the earliest possible time that can be formed. For example, if `time = \\"19:34\\"`, the next closest time using the digits `1`, `9`, `3`, and `4` is `19:39`. If `time = \\"23:59\\"`, the next closest time using the digits `2`, `3`, `5`, and `9` would be `22:22`.","solution":"def next_closest_time(time): Given a time in \\"HH:MM\\" format, find the next closest time using the same digits. # Extract digits from the input time digits = sorted(set(time.replace(\':\', \'\'))) # Convert the input time to minutes current_minutes = int(time[:2]) * 60 + int(time[3:]) while True: # Increment the time by one minute current_minutes = (current_minutes + 1) % (24 * 60) # Extract the new hour and minute in string format new_hour = current_minutes // 60 new_minute = current_minutes % 60 # Format the new time as \\"HH:MM\\" new_time = \\"{:02d}:{:02d}\\".format(new_hour, new_minute) # Check if all of the digits of the new time are present in the original digits if all(digit in digits for digit in new_time.replace(\':\', \'\')): return new_time"},{"question":"You are given an `n x n` 2D matrix, where every row and column is sorted in ascending order. Given a target `num`, write a function to search the target in the matrix. If the target exists, return its coordinates as an array `[row, col]`. If the target does not exist, return `[-1, -1]`. You may assume that the matrix has distinct numbers. Implement the function `int[] searchMatrix(int[][] matrix, int num)`. Remember, you need to ensure that your solution is efficient given the constraints of the sorted matrix.","solution":"def searchMatrix(matrix, num): Searches for the target number in the given sorted matrix. :param matrix: List[List[int]]: 2D list representing the sorted matrix :param num: int: target number to search for :return: List[int]: coordinates [row, col] if the target is found or [-1, -1] if not found if not matrix or not matrix[0]: return [-1, -1] rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == num: return [row, col] elif matrix[row][col] > num: col -= 1 else: row += 1 return [-1, -1]"},{"question":"You are given a string `s`, which contains a mixture of uppercase, lowercase, and digit characters. Implement a function to determine the length of the longest substring of `s` that contains at most two distinct characters. A substring is defined as a contiguous sequence of characters within the string. For example: * Given `s = \\"eceba\\"`, the function should return `3` because `\\"ece\\"` is the longest substring with at most 2 distinct characters. * Given `s = \\"abcbbbbcccbdddadacb\\"`, the function should return `10` because `\\"bcbbbbcccb\\"` is the longest substring with at most 2 distinct characters.","solution":"def longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given an array `stones` where `stones[i]` represents the weight of the `i`-th stone. We are playing a game with the following rules: 1. You pick two heaviest stones and smash them together. 2. If they are of different weight, the result is a new stone with weight equal to the difference between the weights of the two stones. 3. If they are of the same weight, both stones are destroyed. 4. The game ends when there is either one stone left or no stones left. Return _the weight of the last remaining stone_. If there are no stones left, return 0. For example, if the input is `[2,7,4,1,8,1]`, the output should be `1`.","solution":"import heapq def lastStoneWeight(stones): Returns the weight of the last remaining stone or 0 if there are no stones left. if not stones: return 0 # Convert stones to a max-heap by making elements negative stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: # Extract the two heaviest stones first = -heapq.heappop(stones) # Undo the negation to get the original value second = -heapq.heappop(stones) if first != second: # If they are not the same, push the difference back into the heap heapq.heappush(stones, -(first - second)) return -stones[0] if stones else 0"},{"question":"You are given a grid of size `n x m` representing a field where each cell can either be land (`1`) or water (`0`). You can only travel **up**, **down**, **left**, or **right** from a land cell to another land cell. A **group of connected land cells** is called an island. Write a function that returns _the size of the **largest** island in the given grid. If there is no island, return_ `0`_. The size of an island is the number of land cells in it._","solution":"def num_islands(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) largest_island = 0 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == \'0\': return 0 grid[x][y] = \'0\' size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size for i in range(n): for j in range(m): if grid[i][j] == \'1\': island_size = dfs(i, j) largest_island = max(largest_island, island_size) return largest_island"},{"question":"Given a list of integers `tasks`, where `tasks[i]` represents the duration of the `i-th` task, and an integer `breakTime`, representing the duration of a break that must be taken between consecutive tasks, calculate the minimum total time needed to complete all the tasks if you must take the break between each pair of tasks but not after the last task. Return _the minimum total time to finish all tasks, including the required breaks._","solution":"def minimum_total_time(tasks, breakTime): Calculates the minimum total time to finish all tasks, including the required breaks. Parameters: tasks (list): A list of integers where each integer represents the duration of a task. breakTime (int): The duration of a break that must be taken between consecutive tasks. Returns: int: The minimum total time to finish all tasks including breaks. if not tasks: return 0 total_task_time = sum(tasks) total_breaks_time = breakTime * (len(tasks) - 1) if len(tasks) > 1 else 0 return total_task_time + total_breaks_time"},{"question":"You are given a set of `n` tasks and an array `tasks` where `tasks[i]` represents the time required to complete the `i-th` task. You are also given an integer `k` representing the number of workers available to complete these tasks. Each worker can only work on one task at a time, but they can switch between tasks. The goal is to minimize the maximum amount of time any single worker spends on tasks. Return _the **minimum possible time** required to complete all tasks if the tasks are optimally distributed among the workers._ Example: - Input: `tasks = [3, 2, 3], k = 3` - Output: `3` Explanation: Assign each worker to a different task. Each worker will complete their task in the following time: [3, 2, 3]. The maximum time is 3. Note: Some workers might not be assigned any tasks if there are fewer tasks than the number of workers.","solution":"def min_time_required(tasks, k): Returns the minimum possible time required to complete all tasks if they are optimally distributed among the workers. def is_feasible(time_limit): current_time = 0 worker_count = 1 for task in tasks: if current_time + task <= time_limit: current_time += task else: worker_count += 1 current_time = task if worker_count > k: return False return True if not tasks: return 0 left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array of integers `nums` and an integer `k`. An interval [i, j] is called **nice** if there are at least `k` different integers in the subarray `nums[i...j]` (inclusive). Your task is to find the length of the shortest **nice** interval in `nums`. If no such interval exists, return `-1`. For example, given `nums = [1, 2, 1, 3, 4]` and `k = 3`, the shortest nice interval is `[1, 3, 4]` which has length `3`. Write a function to find the length of the shortest **nice** interval: ```python def shortestNiceInterval(nums: List[int], k: int) -> int: # Your implementation here ```","solution":"from typing import List def shortestNiceInterval(nums: List[int], k: int) -> int: Returns the length of the shortest nice interval in nums with at least k different integers. If no such interval exists, returns -1. n = len(nums) if k > n: return -1 shortest_length = float(\'inf\') freq_map = {} left = 0 for right in range(n): freq_map[nums[right]] = freq_map.get(nums[right], 0) + 1 while len(freq_map) >= k: shortest_length = min(shortest_length, right - left + 1) freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 return shortest_length if shortest_length != float(\'inf\') else -1"},{"question":"Given a string `s`, a character `c`, and an integer `x`, return the length of the longest substring of `s` where you are allowed to replace at most `x` characters with the character `c`.","solution":"def longest_substring_with_replacements(s, c, x): Returns the length of the longest substring of `s` where at most `x` characters are replaced by `c`. max_length = 0 window_start = 0 replacements = 0 for window_end in range(len(s)): if s[window_end] != c: replacements += 1 while replacements > x: if s[window_start] != c: replacements -= 1 window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"Given an integer array `arr`, return the **length of the shortest, non-empty, contiguous subarray** of `arr` with a sum greater than or equal to `target`. If there is no such subarray, return `-1`. Your solution should aim for an optimal approach in both time and space complexity.","solution":"def min_subarray_len(arr, target): Returns the length of the shortest, non-empty, contiguous subarray of arr with a sum greater than or equal to target. If there is no such subarray, returns -1. n = len(arr) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given an array of integers `arr`. A subarray is called **special** if it contains at least one even and one odd number. Return the length of the longest **special** subarray. If there are no such subarrays, return `-1`.","solution":"def longest_special_subarray(arr): Returns the length of the longest special subarray (containing at least one even and one odd number). If there are no such subarrays, returns -1. n = len(arr) max_length = -1 for i in range(n): has_even = has_odd = False for j in range(i, n): if arr[j] % 2 == 0: has_even = True else: has_odd = True if has_even and has_odd: max_length = max(max_length, j - i + 1) return max_length"},{"question":"Given an integer array `nums` and an integer `val`, you need to move all occurrences of `val` to the end of the array in-place. The relative order of the other elements may be changed. Return the new length of the array after performing the operation, which is the total number of elements that are not equal to `val`. Example: - Input: `nums = [0,1,2,2,3,0,4,2]`, `val=2` - Output: `5`","solution":"def move_val_to_end(nums, val): Moves all occurrences of val to the end of nums array in-place. Returns the number of elements that are not equal to val. n = len(nums) insert_pos = 0 for i in range(n): if nums[i] != val: nums[insert_pos] = nums[i] insert_pos += 1 for i in range(insert_pos, n): nums[i] = val return insert_pos"},{"question":"Write a function to find the **longest common subsequence** between two given strings `text1` and `text2`. A **subsequence** of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. Return _the length of the longest common subsequence between `text1` and `text2`_.","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of text1 and text2. m, n = len(text1), len(text2) # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given two integer arrays `arr1` and `arr2`. Your task is to merge these two arrays into one sorted array in non-decreasing order, and remove any duplicate elements so that every element in the resulting array is unique. Implement a function: - `List<Integer> mergeAndRemoveDuplicates(int[] arr1, int[] arr2)` that takes two integer arrays `arr1` and `arr2` as input and returns a list of integers containing the merged and sorted unique elements from both arrays. **Example:** - `arr1 = [1, 3, 4, 7]` - `arr2 = [2, 3, 5, 6, 7]` - `mergeAndRemoveDuplicates(arr1, arr2)` should return `[1, 2, 3, 4, 5, 6, 7]`.","solution":"def merge_and_remove_duplicates(arr1, arr2): Merges two arrays, removes duplicates, and returns a sorted list. Args: arr1 (list of int): First array. arr2 (list of int): Second array. Returns: list of int: Merged, sorted list with unique elements. merged_set = set(arr1) | set(arr2) return sorted(list(merged_set))"},{"question":"You are given a **0-indexed** integer array `weights` where `weights[i]` represents the weight of the `ith` item. You are also given an integer `capacity` which represents the maximum capacity of a container. You need to find the number of ways to select a non-empty subset of items such that the total weight of the subset does not exceed the `capacity`. Return _an integer array_ `answer`_, where each element represents the count of such valid subsets._ **Note:** Two subsets are considered different if there is at least one element that is present in one subset but not in the other.","solution":"def count_valid_subsets(weights, capacity): Returns the number of ways to select a non-empty subset of items such that the total weight of the subset does not exceed the capacity. from itertools import combinations n = len(weights) count = 0 # Check all subsets of weights for i in range(1, n+1): for subset in combinations(weights, i): if sum(subset) <= capacity: count += 1 return count"},{"question":"You are given an integer array `prices` where `prices[i]` represents the price of a given stock on the `i-th` day, and an integer `x` which represents your initial capital for trading. You can only perform at most one transaction (i.e., buy one and sell one share of the stock). However, you cannot buy stock if the price is greater than your current capital after any of your transactions. _Return the maximum profit_ you can achieve from this trade, given the constraint of your capital. If no such transaction is possible, return `0`.","solution":"def maxProfit(prices, x): Returns the maximum profit that can be achieved with the given prices and initial capital. :param prices: List of integers where each represents the stock price on a given day. :param x: Initial capital for trading. :return: Maximum profit possible, or 0 if no transaction can be made. n = len(prices) if n == 0: return 0 min_price = float(\'inf\') max_profit = 0 for i in range(n): if prices[i] <= x: # Buy only if price is within the capital. min_price = min(min_price, prices[i]) max_profit = max(max_profit, prices[i] - min_price) # Check if a valid transaction was possible with the given capital. if max_profit == 0: for price in prices: if price <= x: return 0 # No valid transaction found return max_profit"},{"question":"There are `n` cities connected by `m` roads. Each road is bidirectional and has a certain length. You are given an array `edges` where each `edges[i] = (u, v, w)` denotes a road between cities `u` and `v` with length `w`. Your task is to find the minimum number of roads that need to be removed so that there are no cycles in the remaining graph. If there are no cycles initially, return 0. Return the minimum number of roads to be removed.","solution":"def find_redundant_connections(n, edges): Finds the minimum number of roads that need to be removed to ensure no cycles in the remaining graph. Parameters: n (int): Number of cities (nodes) edges (list of tuples): Each tuple (u, v, w) represents a road between cities u and v with length w Returns: int: The minimum number of roads to be removed to make the graph acyclic parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False union_count = 0 for u, v, _ in edges: if not union(u, v): union_count += 1 return union_count"},{"question":"Given a list of strings, return the length of the **longest substring** that is a palindrome. A palindrome is a string that reads the same backward as forward.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in a given string. if not s: return 0 n = len(s) longest = 1 # Create a 2D array to keep track of palindromes dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for palindrome of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True longest = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True longest = length return longest def find_longest_palindromic_substring_length(strings): Given a list of strings, returns the length of the longest palindrome found as a substring in any of the strings in the list. max_length = 0 for s in strings: max_length = max(max_length, longest_palindromic_substring_length(s)) return max_length"},{"question":"You are given an integer array `nums` and an integer `k`. A subarray is defined as a contiguous portion of the array. Determine the number of subarrays whose sum is equal to `k`. Return the number of such subarrays. For example, given the array `nums = [1,1,1]` and `k = 2`, there are two subarrays `[1,1]` and `[1,1]` that sum to 2. Therefore, the answer would be 2.","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum is equal to k. Args: nums (list): List of integers. k (int): Target sum for subarrays. Returns: int: Number of subarrays whose sum equals k. count = 0 current_sum = 0 sum_counts = {0: 1} for num in nums: current_sum += num if (current_sum - k) in sum_counts: count += sum_counts[current_sum - k] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"Given a positive integer `n`, you need to construct a function that returns the number of unique paths from the top-left corner to the bottom-right corner of a grid. You are only allowed to move either down or right at any point in time. Additionally, certain cells in the grid can be marked as obstacles; if a cell is marked as an obstacle, you cannot pass through that cell. You are provided with a 2D array `obstacleGrid` where `obstacleGrid[i][j]` is `1` if the cell `(i, j)` is an obstacle, and `0` otherwise. Return the number of unique paths from the top-left corner to the bottom-right corner considering the obstacles. The value of `n` represents both the number of rows and columns of the grid.","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. You can only move either down or right at any point. The obstacleGrid is a 2D array where obstacleGrid[i][j] is 1 if the cell is an obstacle, and 0 otherwise. n = len(obstacleGrid) if n == 0 or obstacleGrid[0][0] == 1 or obstacleGrid[n-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = 1 for i in range(n): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"Given an array of integers `nums`, you are supposed to build a different array, `res`, where each element `res[i]` is the sum of every third element in the `nums` array starting from index `i`. Specifically: - `res[0]` is the sum of elements `nums[0]`, `nums[3]`, `nums[6]`, etc. - `res[1]` is the sum of elements `nums[1]`, `nums[4]`, `nums[7]`, etc. - `res[2]` is the sum of elements `nums[2]`, `nums[5]`, `nums[8]`, etc. If there aren\'t enough elements to continue adding, the sum should include as many as possible. Your task is to return this resulting array `res`.","solution":"def sum_every_third(nums): result = [0, 0, 0] # Initialize result array with zeros for i in range(len(nums)): result[i % 3] += nums[i] return result"},{"question":"Given an array of integers `arr`, return `true` if there are three consecutive common elements, otherwise return `false`. For example, in `arr = [1, 2, 2, 2, 3, 4]`, the element `2` appears consecutively three times.","solution":"def three_consecutive_common(arr): Returns True if there are three consecutive common elements in the array, otherwise returns False. for i in range(len(arr) - 2): if arr[i] == arr[i+1] == arr[i+2]: return True return False"},{"question":"Given an array of integers `arr`, and a positive integer `n`, find the **n-th smallest pair distance**. The **pair distance** of a pair `(arr[i], arr[j])` is defined as the absolute difference between `arr[i]` and `arr[j]`. The **n-th smallest pair distance** is the `n-th` smallest value out of all the possible pair distances. Return the `n-th` smallest pair distance in the array.","solution":"def nth_smallest_pair_distance(arr, n): Returns the n-th smallest pair distance in the array. def count_pairs_with_max_distance(max_dist): Counts the number of pairs with a distance less than or equal to max_dist. count = 0 left = 0 for right in range(len(arr)): while arr[right] - arr[left] > max_dist: left += 1 count += right - left return count arr.sort() lo, hi = 0, arr[-1] - arr[0] while lo < hi: mid = (lo + hi) // 2 if count_pairs_with_max_distance(mid) < n: lo = mid + 1 else: hi = mid return lo"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Your task is to determine if there are `k` distinct indices in the array such that the sum of the elements at those indices is `0`. Return `true` if such indices exist, and `false` otherwise.","solution":"def has_k_distinct_indices_sum_zero(arr, k): Determine if there are k distinct indices in the array such that the sum of the elements at those indices is 0. Args: arr (list): A list of integers. k (int): The number of distinct indices. Returns: bool: True if such indices exist, False otherwise. from itertools import combinations for indices in combinations(range(len(arr)), k): if sum(arr[i] for i in indices) == 0: return True return False"},{"question":"You are given a string `s` of length `n`, consisting only of the characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation any number of times: select two different characters in the string and swap their positions. Return the **minimum** number of swaps required to make the string **balanced**, which means the count of `\'a\'`, `\'b\'`, and `\'c\'` should be equal in all substrings of length `3` if possible. If it is not possible to make the string balanced, return `-1`. **Note**: Try to achieve the result without directly manipulating substrings of length 3.","solution":"def min_swaps_to_balance(s: str) -> int: Returns the minimum number of swaps required to make the string balanced. If it is not possible to make the string balanced, return -1. # Count the number of \'a\', \'b\', and \'c\' in the string count_a = s.count(\'a\') count_b = s.count(\'b\') count_c = s.count(\'c\') # Calculate the expected count for \'a\', \'b\', and \'c\' to be balanced n = len(s) if n % 3 != 0: return -1 # If length is not a multiple of 3, balancing is impossible target_count = n // 3 # Check if balancing is possible if count_a != target_count or count_b != target_count or count_c != target_count: return -1 # The string is already balanced if we reach here return 0 # No swaps needed if counts are already equal"},{"question":"Given a string `str`, determine if it can be rearranged to form a palindrome. Write a function `canFormPalindrome(s)` that returns `True` if it\'s possible to rearrange the characters of the string `s` to form a palindrome and `False` otherwise. A palindrome is a string that reads the same backward as forward.","solution":"def canFormPalindrome(s): Determines if the input string s can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency count (for odd-length strings) or all characters have even frequency counts (for even-length strings). Parameters: s (str): The input string to check. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) # For the string to be rearranged into a palindrome, at most one character can have an odd frequency return odd_count <= 1"},{"question":"You are given an array of integers `nums` and an integer `k`. The array is said to have an interesting subarray of length `k` if it contains exactly `k` elements and all elements are distinct. Write a function to determine the number of interesting subarrays of length `k` in the array `nums`. Return the count as an integer.","solution":"def count_interesting_subarrays(nums, k): Counts the number of interesting subarrays of length k in the given array. An interesting subarray contains exactly k elements and all elements are distinct. Parameters: nums (list): The input array of integers. k (int): The length of the subarray. Returns: int: The number of interesting subarrays of length k. if k > len(nums): return 0 count = 0 for i in range(len(nums) - k + 1): if len(set(nums[i:i+k])) == k: count += 1 return count"},{"question":"You are given an integer array `days` where `days[i]` represents the number of hours you study on the ith day. Given a positive integer `k`, find the maximum total number of hours you can study by selecting exactly `k` consecutive days from the array. Return _the maximum total hours you can achieve_.","solution":"def max_study_hours(days, k): n = len(days) if k > n: return 0 # Compute the initial sum of the first \'k\' days max_sum = current_sum = sum(days[:k]) # Use sliding window to find the maximum sum of \'k\' consecutive days for i in range(k, n): current_sum = current_sum - days[i - k] + days[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a string `s` containing only characters `\'0\'` and `\'1\'`. A substring is called \\"balanced\\" if its number of `0`s is equal to its number of `1`s. Return the maximum length of a balanced substring in `s`. If no balanced substring exists, return `0`. The substring must be contiguous within the given string.","solution":"def max_balanced_substring(s): Returns the maximum length of a balanced substring in the given string `s`. A balanced substring has an equal number of \'0\'s and \'1\'s. Parameters: s (str): The input string containing only \'0\' and \'1\' characters. Returns: int: The length of the maximum balanced substring. max_length = 0 balance = 0 balance_map = {0: -1} for i, char in enumerate(s): if char == \'0\': balance -= 1 else: balance += 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"You are given a string `s` and an integer `k`. The string `s` is initially encoded using the run-length encoding algorithm, where each group is shown as `cx` for a character `c` repeated `x` times consecutively. For example, the string `\\"aabbbbccc\\"` is represented as `\\"a2b4c3\\"`. Write a function to decode the encoded string and find the `k`-th character (1-indexed) in the decoded string. Implement the function `charAtK(s: str, k: int) -> str` that takes the encoded string `s` and the integer `k`, decodes `s`, and returns the `k`-th character in the decoded string.","solution":"def charAtK(s: str, k: int) -> str: Returns the k-th character in the decoded string of the run-length encoded string s. decoded_str = \\"\\" i = 0 while i < len(s): char = s[i] num = \\"\\" i += 1 while i < len(s) and s[i].isdigit(): num += s[i] i += 1 decoded_str += char * int(num) return decoded_str[k-1]"},{"question":"Given an array of integers `arr`, implement an algorithm to find the largest inverted subarray (contiguous subarray of `arr`) where the subarray is sorted in non-increasing order. The length of the inverted subarray should be maximized. If there are multiple subarrays with the same maximum length, return the subarray which starts with the smallest index. Return _the largest inverted subarray_.","solution":"def find_largest_inverted_subarray(arr): Finds the largest inverted subarray (contiguous subarray of `arr`) where the subarray is sorted in non-increasing order. The length of the inverted subarray should be maximized. If there are multiple subarrays with the same maximum length, return the subarray which starts with the smallest index. Parameters: arr (list): List of integers Returns: list: Largest inverted subarray n = len(arr) if n == 0: return [] max_len = 1 start_idx = 0 current_start = 0 current_len = 1 for i in range(1, n): if arr[i] <= arr[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len start_idx = current_start current_start = i current_len = 1 if current_len > max_len: max_len = current_len start_idx = current_start return arr[start_idx:start_idx + max_len]"},{"question":"You are given a list of strings `words` and a list of integers `queries`, where the `ith` query is the number of distinct words in the list that can be formed using exactly `queries[i]` characters from any of the words in the list. You can only form a word if the selected characters are in the same order as they originally appear in the word. For each query, return the number of distinct words that can be formed. Write a function `numWords(words, queries)` that takes a list of strings `words` and a list of integers `queries` as input and returns a list of integers where the `ith` element is the answer to the `ith` query.","solution":"def numWords(words, queries): Returns the number of distinct words that can be formed using exactly queries[i] characters from any of the words in the list `words`. word_lengths = sorted(set(len(word) for word in words)) def count_words_with_length(length): return len(set(word for word in words if len(word) == length)) return [count_words_with_length(query) for query in queries]"},{"question":"You are given a list of integers `arr` and two integers `k` and `x`. Find the `k` closest integers to `x` in the array. The result should also be sorted in ascending order. If there is a tie, prefer the smaller integers. Write a function `findClosestElements(arr, k, x)` that implements this functionality. Note: The list `arr` is sorted in ascending order.","solution":"def findClosestElements(arr, k, x): Find the k closest integers to x in the array. The result should be sorted in ascending order. # Binary search to find the right place to start left, right = 0, len(arr) - k while left < right: mid = (left + right) // 2 if x - arr[mid] > arr[mid + k] - x: left = mid + 1 else: right = mid return arr[left:left + k]"},{"question":"You are given a `0-indexed` array of integers `nums` of length `n` where each element ranges from `1` to `n`. Each integer in `nums` appears **exactly** once except for a single integer `x` which appears **twice**, and one integer in the range `[1, n]` is missing. You need to find the integer that is missing and the integer that appears twice. Return these two integers in a tuple of the form `(duplicate, missing)`.","solution":"def find_error_nums(nums): Returns a tuple (duplicate, missing) for the given list of integers where one integer appears exactly twice and one integer is missing. n = len(nums) sum_of_nums = sum(nums) sum_of_squares = sum(x * x for x in nums) expected_sum = n * (n + 1) // 2 expected_sum_of_squares = n * (n + 1) * (2 * n + 1) // 6 diff1 = sum_of_nums - expected_sum diff2 = (sum_of_squares - expected_sum_of_squares) // diff1 duplicate = (diff1 + diff2) // 2 missing = duplicate - diff1 return (duplicate, missing)"},{"question":"You are given a string `s` consisting of only lowercase characters. Your goal is to implement an algorithm that transforms `s` such that no two adjacent characters are the same. If it is impossible to achieve such a transformation, return an empty string. Otherwise, return the lexicographically smallest possible string after the transformation.","solution":"def transform_string(s): Transforms the string `s` such that no two adjacent characters are the same. Returns the lexicographically smallest possible string after transformation. If such a transformation is not possible, returns an empty string. from collections import Counter import heapq # Count the frequency of each character char_count = Counter(s) max_freq = max(char_count.values()) # If the most frequent character is more than half of the string length plus one, it\'s impossible if max_freq > (len(s) + 1) // 2: return \\"\\" # Max-heap (Python\'s heapq is a min-heap, so we negate the counts to simulate a max-heap) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # decrement the count return \'\'.join(result)"},{"question":"You are given a matrix of size `m x n` consisting of non-negative integers, where each cell represents the weight of the cell. Your goal is to find a path from the top-left corner to the bottom-right corner that minimizes the sum of the weights of the cells you visit. You can only move either down or right at any point in time. Return the minimum sum of weights you can achieve on such a path. ---","solution":"def minPathSum(grid): Returns the minimum sum of weights to reach the bottom-right corner of the grid from the top-left corner. if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill up the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Given a string `s` representing a sentence, return the number of words that have a length equal to the minimum word length in the sentence. A word is defined as a contiguous sequence of characters separated by spaces. For example, given the input `s = \\"The quick brown fox jumps over the lazy dog\\"`, the output should be `4`, as there are four words with the minimum length of 3 (\\"The\\", \\"fox\\", \\"the\\", \\"dog\\").","solution":"def count_min_length_words(s): Returns the number of words that have a length equal to the minimum word length in the sentence s. Parameters: s (str): Input string representing the sentence. Returns: int: The number of words with the minimum length. words = s.split() if not words: return 0 min_length = min(len(word) for word in words) return sum(1 for word in words if len(word) == min_length)"},{"question":"You are given a string `s` consisting of lowercase alphabets. You need to divide the string into as many parts as possible so that each letter appears in at most one part. Return the lengths of the parts in an array.","solution":"def partition_labels(s): Divides the string into as many parts as possible so that each letter appears in at most one part. Returns the lengths of the parts in an array. :param s: str :return: List[int] last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"You are given a list of `n` tasks and an array `dependencies` representing the dependencies between those tasks. Each task is represented by a unique integer in the range from `1` to `n`. `dependencies[i] = [a, b]` means that task `a` must be completed before task `b`. Determine if it is possible to complete all tasks. If it is possible, return the order of task completion as a list of integers. If it is not possible to complete all tasks due to a circular dependency, return an empty list.","solution":"from collections import deque, defaultdict def find_task_order(n, dependencies): Determine if it is possible to complete all tasks. If yes, return the order of task completion. If not, return an empty list. :param n: Number of tasks :param dependencies: A list of dependencies where dependencies[i] = [a, b] means task a must be completed before task b :return: A list of task completion order, or an empty list if not possible indegree = [0] * (n + 1) adj_list = defaultdict(list) # Build the graph and compute in-degrees of each node (task) for dep in dependencies: adj_list[dep[0]].append(dep[1]) indegree[dep[1]] += 1 # Initialize the queue with nodes having no incoming edges queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If the order contains all tasks, return it; otherwise, return an empty list return order if len(order) == n else []"},{"question":"Given a list of integers `arr` and a target integer `k`, return the number of subarrays that sum up to `k`. A subarray is a contiguous part of an array. This problem aims to identify all possible subarrays that, when summed, equal the provided target integer `k`. The solution should ultimately count these subarrays and return the total count.","solution":"def subarray_sum(arr, k): Returns the count of subarrays that sum up to k. Parameters: arr: List[int] - a list of integers k: int - the target sum Returns: int - count of subarrays count = 0 current_sum = 0 sum_dict = {0: 1} for num in arr: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"Given an integer `n`, return the number of unique binary search trees (BSTs) that can be constructed with `n` nodes where each node contains a unique value from `1` to `n`. A binary search tree is defined such that for every node, the nodes in the left subtree contain only values less than the node\'s value, and the nodes in the right subtree contain only values greater than the node\'s value.","solution":"def num_trees(n): Returns the number of unique BSTs that can be constructed with n nodes, where each node contains a unique value from 1 to n. if n == 0 or n == 1: return 1 count = [0] * (n + 1) count[0], count[1] = 1, 1 for i in range(2, n + 1): for j in range(1, i + 1): count[i] += count[j - 1] * count[i - j] return count[n]"},{"question":"You are given a list of `intervals`, where `intervals[i] = [starti, endi]` represents the start and end of the `i-th` interval. Implement a class `IntervalScheduler` that can add intervals and find the minimum number of conference rooms required to schedule all the intervals without conflicts. Implement the `IntervalScheduler` class: * `IntervalScheduler()` Initializes the scheduler object. * `void addInterval(int start, int end)` Adds the interval `[start, end]` to the scheduler. * `int minConferenceRooms()` Returns the minimum number of conference rooms required to schedule all the added intervals without conflicts. The solution should efficiently handle the addition of intervals and the calculation of the minimum number of conference rooms needed.","solution":"import heapq class IntervalScheduler: def __init__(self): self.intervals = [] def addInterval(self, start, end): self.intervals.append((start, end)) def minConferenceRooms(self): if not self.intervals: return 0 # Sort the intervals by start time self.intervals.sort(key=lambda x: x[0]) # Use a min-heap to track the end times of the meeting rooms min_heap = [] heapq.heappush(min_heap, self.intervals[0][1]) for interval in self.intervals[1:]: if interval[0] >= min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, interval[1]) return len(min_heap)"},{"question":"A vending machine contains `n` different types of snacks, each with a specific price and satisfaction value. You have a budget, `budget`, to spend on these snacks. Your goal is to maximize your total satisfaction without exceeding your budget. Given an array `prices` where `prices[i]` is the price of the `i-th` snack, and an array `satisfaction` where `satisfaction[i]` is the satisfaction value of the `i-th` snack, return the maximum total satisfaction you can obtain within the given budget. [Question 4]:","solution":"def max_satisfaction(prices, satisfaction, budget): n = len(prices) dp = [0] * (budget + 1) for i in range(n): for cost in range(budget, prices[i] - 1, -1): dp[cost] = max(dp[cost], dp[cost - prices[i]] + satisfaction[i]) return dp[budget]"},{"question":"You are given a list of **non-negative integers** representing the amount of money of each house arranged in a **circle**. A professional robber has to plan his robbery such that he maximizes his profit without robbing two consecutive houses, including the first and last houses in the circle. Return _the maximum amount of money you can rob tonight without alerting the police_.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. def rob_linear(houses): prev_max = 0 curr_max = 0 for amount in houses: temp = curr_max curr_max = max(prev_max + amount, curr_max) prev_max = temp return curr_max if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) # Solve the problem in two linear cases: # 1. Rob houses from the first to the second-to-last house. # 2. Rob houses from the second to the last house. return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given a 2D integer array `grid` representing a crossword puzzle, where `grid[i][j]` can be either `0` (an open cell) or `1` (a filled cell). Each `1` in the grid represents an obstacle that blocks the path. You need to find out the largest square area of connected open cells (`0`s) that can be formed in the grid. The square must be filled entirely with `0`s and should not be adjacent to any `1`s (except outside the grid). Return the side length of the largest square that can be formed.","solution":"def largest_square_area(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"Given a string `s` containing only the characters \'a\' and \'b\', you can swap any two characters exactly once. Determine the length of the longest subsequence consisting of the same character that can be obtained after the swap. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the length of the longest subsequence consisting of the same character after one swap.","solution":"def longest_subsequence_after_one_swap(s): Determines the length of the longest subsequence consisting of the same character that can be obtained after one swap. The sequence consists only of \'a\' and \'b\'. Args: s (str): The input string containing only \'a\' and \'b\'. Returns: int: The length of the longest subsequence after one swap. # Count the number of \'a\'s and \'b\'s count_a = s.count(\'a\') count_b = s.count(\'b\') # The maximum subsequence length is the length of the whole string minus one character max_subseq_length = max(count_a, count_b) # One swap can only increase the count by 1 only if `count_a` and `count_b` are not initially equal if max_subseq_length < len(s): return max_subseq_length + 1 else: # If max_subseq_length is already the length of the string return max_subseq_length"},{"question":"Given a `n x n` 2D matrix `mat`, rotate the matrix 90 degrees clockwise. The rotation should be performed in-place, which means you have to modify the input matrix directly without using any extra memory.","solution":"def rotate_matrix(mat): Rotates a n x n 2D matrix 90 degrees clockwise in place. :param mat: List[List[int]] - The 2D matrix to rotate. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"Given the `root` of a binary tree, imagine yourself standing on the **right** side of it, return the values of the nodes you can see ordered from top to bottom. Consider that the tree may have uneven depths and node values can be negative or positive.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom. :param root: TreeNode, the root of the binary tree. :return: List[int], the values of the nodes seen from the right side. if not root: return [] right_view = [] level_nodes = [root] while level_nodes: right_view.append(level_nodes[-1].val) next_level = [] for node in level_nodes: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) level_nodes = next_level return right_view"},{"question":"Write a function that takes an integer array `nums` and returns an array of the `k` most frequent elements in the array. Ensure the returned output is in decreasing order of their frequency. In case of a tie in frequency, sort by the numeric values in increasing order.","solution":"from collections import Counter def top_k_frequent(nums, k): Returns the k most frequent elements in the array nums. The returned output is in decreasing order of their frequency. In case of a tie in frequency, sort by the numeric values in increasing order. count = Counter(nums) result = sorted(count.keys(), key=lambda x: (-count[x], x)) return result[:k]"},{"question":"Given an array of integers `heights` representing the height of buildings, the span of each building is defined as the number of consecutive buildings (including itself) that are shorter than or equal to its height to the left. Write a function `int[] calculateSpan(int[] heights)` that takes the array `heights` and returns an array `span` where `span[i]` is the span of the `i-th` building. The calculation should be done in linear time complexity.","solution":"def calculateSpan(heights): Returns an array where each element represents the span of that building. The span is defined as the number of consecutive buildings to the left (including itself) with a height less than or equal to the height of the current building. n = len(heights) span = [0] * n # To store the span of each building stack = [] # Stack to store indices of buildings for i in range(n): # Calculate span for each building while stack and heights[stack[-1]] <= heights[i]: stack.pop() if not stack: span[i] = i + 1 else: span[i] = i - stack[-1] stack.append(i) return span"},{"question":"You are given an integer array `nums` and an integer `k`. In one operation, you can choose any element from `nums` and subtract 1 from it. Return the minimum number of operations required to make the sum of the array `nums` exactly `k`. If it\'s not possible to reach `k`, return -1.","solution":"def min_operations_to_reach_sum(nums, k): Returns the minimum number of operations required to make the sum of the array `nums` exactly `k`. If it\'s not possible to reach `k`, returns -1. current_sum = sum(nums) if current_sum < k: return -1 operations = 0 while current_sum > k: max_element = max(nums) reduction_amount = min(max_element, current_sum - k) index_max = nums.index(max_element) nums[index_max] -= reduction_amount current_sum -= reduction_amount operations += reduction_amount return operations"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. A singly linked list is a set of nodes where each node has a value and a pointer to the next node in the series, but the last node points to null. The reversal should be done in place, and you must return the new head of the reversed list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current: next_node = current.next # Temporarily save the next node current.next = prev # Reverse the current node\'s pointer prev = current # Move the prev pointer to the current node current = next_node # Move the current pointer to the next node return prev # Prev will be the new head of the reversed list"},{"question":"You are given a string `s` and an integer `k`. You need to extract the lexicographically smallest substring of length `k` from the string `s`. The lexicographical order for a string is defined as the order in which words are listed in a dictionary (i.e., sorted order for strings). Write a function that takes the string `s` and the integer `k`, and returns the lexicographically smallest substring of length `k`.","solution":"def smallest_lexicographical_substring(s, k): Returns the lexicographically smallest substring of length k from the given string s. Parameters: s (str): The input string. k (int): The length of the substring to be extracted. Returns: str: The lexicographically smallest substring of length k. smallest = s[:k] for i in range(1, len(s) - k + 1): current = s[i:i + k] if current < smallest: smallest = current return smallest"},{"question":"You are given a string `s` and another string `t`. You are allowed to remove some characters from `s` and rearrange the remaining characters to form `t`. Return _the minimum number of characters you need to remove from `s` to form `t`_, or -1 if it\'s not possible.","solution":"from collections import Counter def min_removals_to_form_t(s, t): Calculate the minimum number of characters to remove from s to form t. If it is not possible to form t from s, return -1. counter_s = Counter(s) counter_t = Counter(t) # Check if it\'s possible to form t from s for char, count in counter_t.items(): if counter_s[char] < count: return -1 # Calculate the number of removals needed removal_count = 0 for char in counter_s: if counter_s[char] > counter_t[char]: removal_count += counter_s[char] - counter_t[char] return removal_count"},{"question":"Given a `2D` grid of size `m x n` filled with non-negative integers, a rat needs to find a path from the top-left corner to the bottom-right corner of the grid. The rat can move either down or right at any point in time. Implement a function `minPathSum(grid)` that returns the minimum sum of all numbers along its path. Note: You can assume that `m` and `n` will be larger than 0.","solution":"def minPathSum(grid): Finds the minimum path sum in a 2D grid from top-left to bottom-right corner. The function can navigate only by moving right or down. :param grid: List[List[int]], the 2D grid :return: int, the minimum path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first cell for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] # Update the path sums for the rest of the cells for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"You are given the `root` of a binary search tree (BST) and an integer `target`. Implement a function `closestValue` that returns the value in the BST that is closest to the `target`. * The function signature should be: `def closestValue(root: TreeNode, target: float) -> int`. * Assume that `TreeNode` is a class representing a node in the tree, with `val`, `left`, and `right` as its properties. * The input tree is guaranteed to be non-empty and contain unique values. Your solution should aim for a time complexity of O(log n), where n is the number of nodes in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closestValue(root: TreeNode, target: float) -> int: closest = root.val while root: if abs(root.val - target) < abs(closest - target): closest = root.val if target < root.val: root = root.left else: root = root.right return closest"},{"question":"Given a string `s`, you need to find the length of the longest substring that contains at most two distinct characters. Implement a function that returns this length. For example, if `s = \\"eceba\\"`, the longest substring with at most two distinct characters is `\\"ece\\"` with a length of 3.","solution":"def lengthOfLongestSubstringTwoDistinct(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n # Sliding window left and right pointers left, right = 0, 0 # Hash map character -> its rightmost position in the sliding window hashmap = {} max_len = 2 while right < n: # When the slidewindow contains less than 3 characters hashmap[s[right]] = right right += 1 # Slidewindow contains 3 characters if len(hashmap) == 3: # Delete the leftmost character del_idx = min(hashmap.values()) del hashmap[s[del_idx]] # Move left pointer of the slidewindow left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given an array of integers `weights` representing weights of items and an integer `D` representing the number of days to ship all the items. Each day, you start at the beginning of the array and ship as many items as you can without exceeding a particular weight limit. Return the minimum weight capacity of the ship that will result in all the items being shipped within `D` days. For example, if you have weights `[1,2,3,4,5,6,7,8,9,10]` and `D = 5`, you might ship items in weights `[10]`, `[9]`, `[8,1]`, `[7,2,1]`, `[6,5,4,3]` on each of the five days, which would require a ship with a weight capacity of 10.","solution":"def shipWithinDays(weights, D): Determine the minimum weight capacity of the ship to ship all the items within D days. def canShipInDays(capacity): days = 1 current_weight = 0 for weight in weights: if current_weight + weight > capacity: days += 1 current_weight = 0 current_weight += weight return days <= D left, right = max(weights), sum(weights) while left < right: mid = (left + right) // 2 if canShipInDays(mid): right = mid else: left = mid + 1 return left"},{"question":"**[Question 4]:** You are provided with a matrix `grid` of integers where each element represents the cost associated with moving through that cell. You start from the top-left cell and need to reach the bottom-right cell by only moving either right or down at any given step. Your task is to find the **minimum path sum** from the top-left to the bottom-right corner. Return _this minimum path sum_. Write a function that takes a 2D list `grid` as input and returns the minimum cost to reach the bottom-right corner.","solution":"def min_path_sum(grid): Calculates the minimum path sum from the top-left to the bottom-right corner of a grid. :param grid: List[List[int]] - 2D list of integers where each element represents the cost associated with moving through that cell. :return: int - Minimum path sum to reach the bottom-right corner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize the top-left corner for i in range(1, rows): grid[i][0] += grid[i-1][0] # Initialize the left column for j in range(1, cols): grid[0][j] += grid[0][j-1] # Fill in the remainder of the grid for i in range(1, rows): for j in range(1, cols): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[rows-1][cols-1]"},{"question":"You are given an array of integers representing the daily temperatures for a given week. Your task is to return an array of integers `result` such that `result[i]` is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, put `0` instead. For example, given temperatures = `[73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`.","solution":"def daily_temperatures(temperatures): Given an array of daily temperatures, return an array where the value at each index i is the number of days until a warmer temperature. If no such day exists, put 0. result = [0] * len(temperatures) stack = [] for i, current_temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < current_temp: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"You are given a `matrix` of integers where each integer represents the height of a bar in a histogram. Each bar is of width 1. You need to find the area of the largest rectangle that can be formed using the bars in the histogram. The rectangle must be aligned between the bars, and the height of the rectangle is determined by the shortest bar in that range. Given the `matrix`, return _the area of the largest rectangle_ that can be formed within any one of the histograms represented by each row of the `matrix`.","solution":"def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) # Ensure the stack is emptied at the end for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() # Restore the heights array return max_area def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): # Update dp array representing the height of bars for the current row dp[i] = dp[i] + 1 if row[i] == 1 else 0 # Get the maximum area from the current histogram (row) max_area = max(max_area, largestRectangleArea(dp)) return max_area"},{"question":"You are given two binary trees, `root1` and `root2`. A node in the binary tree represents an integer value. Write an algorithm to return a binary tree that is the result of merging `root1` and `root2`. The merge operation is defined as follows: - If `root1` and `root2` overlap, then sum node values up as the new value of the merged node. - Otherwise, the non-null node will be used as the node of the new tree. Return the merged binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees. Args: root1 (TreeNode): The root of the first binary tree. root2 (TreeNode): The root of the second binary tree. Returns: TreeNode: The root of the merged binary tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged = TreeNode(root1.val + root2.val) merged.left = mergeTrees(root1.left, root2.left) merged.right = mergeTrees(root1.right, root2.right) return merged"},{"question":"**Question 4:** You are provided with an unsorted integer array `arr` and an integer `x`. Your task is to find the `x` smallest elements in the array and return them in sorted order. For example: - If `arr = [7, 10, 4, 3, 20, 15]` and `x = 3`, then the output should be `[3, 4, 7]`. - If `arr = [5, 15, 10, 20, 8]` and `x = 2`, then the output should be `[5, 8]`. Consider the following constraints: - You may assume that `1 <= x <= arr.length <= 10^4`. - The array `arr` contains distinct integers.","solution":"def find_x_smallest_elements(arr, x): Returns the x smallest elements from the array in sorted order. Parameters: arr (list of int): The input unsorted integer array. x (int): The number of smallest elements to find. Returns: list of int: The x smallest elements in sorted order. if not arr or x <= 0 or x > len(arr): raise ValueError(\\"Invalid input parameters\\") return sorted(arr)[:x]"},{"question":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. Given an array of distinct integers `nums`, generate all possible permutations of the array and return them. The permutations can be returned in any order. Write a function that returns _a list of all unique permutations_ of the array `nums`.","solution":"from itertools import permutations def generate_permutations(nums): Returns a list of all unique permutations of the array nums. :param nums: A list of distinct integers. :return: A list of lists, where each list is a unique permutation of nums. return list(permutations(nums))"},{"question":"You are given a **0-indexed** integer array `nums` representing the heights of buildings in a city. The city has decided to build ladders such that any two consecutive buildings can have a ladder connecting their roofs only if the ladder is not steeper than `maxSlope` (the absolute difference in their heights). Write an algorithm to determine if it is possible to place ladders between all consecutive buildings in `nums` given the `maxSlope`. Return a boolean value indicating the possibility.","solution":"def can_place_ladders(nums, maxSlope): Determines if ladders can be placed between all consecutive buildings without exceeding the maxSlope. Args: nums (list): Heights of the buildings. maxSlope (int): Maximum allowed slope between consecutive buildings. Returns: bool: True if ladders can be placed, False otherwise. for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) > maxSlope: return False return True"},{"question":"Write a function `findClosestElements(arr, k, x)` that takes a sorted integer array `arr`, two integers `k` and `x`, and returns the `k` closest integers to `x` from the array. The result should also be sorted in ascending order. An integer `a` is considered closer to `x` than an integer `b` if |a - x| < |b - x|, or |a - x| == |b - x| but `a` is smaller than `b`.","solution":"def findClosestElements(arr, k, x): Returns the k closest integers to x from the sorted array arr. # Sort the array with the custom comparator: first by absolute difference with x, then by natural order sorted_arr = sorted(arr, key=lambda num: (abs(num - x), num)) # Pick the first k elements and sort them before returning result = sorted(sorted_arr[:k]) return result"},{"question":"You are given an array `nums` of integers and a target integer `k`. You need to find the **minimum** number of operations required to reduce the array to a size of exactly `k`. An operation is defined as removing any one element from the array. Return _the minimum number of operations needed to achieve the target size_. For example, given `nums = [1, 2, 3, 4, 5]` and `k = 3`, the result would be `2` as removing two elements would leave exactly three elements in the array.","solution":"def min_operations_to_reduce_size(nums, k): Returns the minimum number of operations required to reduce the array to a size of exactly k by removing the minimum number of elements. :param nums: List of integers :param k: Target integer size of the array :return: Minimum number of operations needed to achieve the target size current_length = len(nums) if k >= current_length: return 0 else: return current_length - k"},{"question":"You are given a string `word` consisting of lowercase English letters. We define the **shifted string** by shifting each character of `word` by `k` positions in the alphabetical order, wrapping around if necessary. For example, shifting \'a\' by 2 positions results in \'c\', and shifting \'z\' by 1 position results in \'a\'. The alphabet is circular, and every character can be shifted. You are also given an integer array `shifts` of the same length as `word` where `shifts[i]` denotes the number of positions to shift the character at index `i` in `word`. Return the final shifted string after applying each shift accordingly. For example, given `word = \\"abc\\"` and `shifts = [1, 2, 3]`, the output should be `\\"bdf\\"`.","solution":"def shift_string(word, shifts): Shifts each character in the word by the corresponding value in shifts array. :param word: A string consisting of lowercase English letters. :param shifts: A list of integers where each integer indicates how many positions to shift the corresponding character in word. :return: The shifted string. shifted_word = [] for i, char in enumerate(word): new_char = chr(((ord(char) - ord(\'a\') + shifts[i]) % 26) + ord(\'a\')) shifted_word.append(new_char) return \'\'.join(shifted_word)"},{"question":"You are given a list of integers `arr` representing the heights of obstacles in a field and an integer `k` representing the maximum jump height of a rabbit. The rabbit starts at the beginning of the field and seeks to reach the end by jumping over the obstacles. Each obstacle in `arr` must be cleared by a jump of at least that height. Return _the minimum number of jumps the rabbit needs to reach the end of the field_, or `-1` if it\'s not possible. For example, given `arr = [3, 4, 3, 2, 5]` and `k = 3`, the rabbit can clear the field in 3 jumps: `(jump 3 over height 3) -> (jump 4 over height 4) -> (jump 5 over height 2)`. However, if `arr = [3, 4, 6, 2, 5]` and `k = 3`, it is not possible for the rabbit to clear the field, so the result should be `-1`.","solution":"def min_jumps(arr, k): Determines the minimum number of jumps needed for the rabbit to clear the field. Returns -1 if it\'s not possible within the given maximum jump height. Parameters: arr (List[int]): List of obstacle heights in the field. k (int): Maximum jump height of the rabbit. Returns: int: Minimum number of jumps or -1 if not possible. jumps = 0 for height in arr: if height > k: return -1 jumps += 1 return jumps"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to find two distinct indices `i` and `j` in the array such that the sum of `arr[i]` and `arr[j]` is equal to `target`. If there are multiple pairs, return any one of them. If no such pair exists, return `[-1, -1]`. The function should have a time complexity better than O(n).","solution":"def two_sum(arr, target): Find two distinct indices i and j such that arr[i] + arr[j] == target. Args: arr (list): List of integers. target (int): Target sum. Returns: list: A list containing the two indices i, j, or [-1, -1] if no such pair exists. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"Design a system that simulates an elevator, balancing efficiency and fairness. Implement a class `ElevatorSystem` with the following methods: - `request_elevator(floor: int)`: Represents a person on the given `floor` requesting the elevator. The system should determine the best elevator to service the request based on its current state and direction. - `step()`: Advances the simulation by one time unit. Each elevator should move one floor in its current direction or stop to pick up/drop off passengers if it has reached the requested floor. The class should handle multiple elevators, and the simulation should aim to optimize the overall waiting time for passengers while ensuring that all requests are eventually serviced.","solution":"class Elevator: def __init__(self, id): self.id = id self.current_floor = 0 self.target_floors = [] self.direction = 0 # -1 for down, 0 for idle, 1 for up def add_target_floor(self, floor): if floor not in self.target_floors: self.target_floors.append(floor) self.target_floors.sort() self.update_direction() def update_direction(self): if not self.target_floors: self.direction = 0 elif self.current_floor < self.target_floors[0]: self.direction = 1 elif self.current_floor > self.target_floors[0]: self.direction = -1 def step(self): if not self.target_floors: return if self.current_floor == self.target_floors[0]: self.target_floors.pop(0) if self.target_floors: if self.current_floor < self.target_floors[0]: self.current_floor += 1 elif self.current_floor > self.target_floors[0]: self.current_floor -= 1 self.update_direction() class ElevatorSystem: def __init__(self, num_elevators): self.elevators = [Elevator(i) for i in range(num_elevators)] def request_elevator(self, floor: int): best_elevator = min( self.elevators, key=lambda e: (abs(e.current_floor - floor), len(e.target_floors)) ) best_elevator.add_target_floor(floor) def step(self): for elevator in self.elevators: elevator.step()"},{"question":"Given an array of integers `nums` and a target integer `target`, return all unique pairs of integers in the array that sum up to the target. The pairs should be returned as a list of lists, where each list contains exactly two integers. The pairs should be in ascending order based on the first integer, and if two pairs have the same first integer, the pair with the smaller second integer should come first. Ensure that the solution has a time complexity of `O(n log n)` or better.","solution":"def two_sum_pairs(nums, target): Returns all unique pairs of integers in the array that sum up to the target. Each pair is represented as a list of two integers. The pairs are returned in ascending order based on the first integer. If two pairs have the same first integer, the pair with the smaller second integer comes first. nums.sort() pairs = set() left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 result = [list(pair) for pair in pairs] result.sort() return result"},{"question":"You are given a list of non-negative integers `nums` representing the number of tasks, where the `i-th` task has a time duration of `nums[i]`. Two workers are available to complete these tasks. A task can either be assigned to Worker 1 or Worker 2. Each worker works independently without any overlap in tasks. Return _the minimum possible difference in total time spent by the two workers_.","solution":"def min_difference(nums): Returns the minimum possible difference in total time spent by the two workers. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [0] * (target + 1) for num in nums: for j in range(target, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return abs(total_sum - 2 * dp[target])"},{"question":"Given an undirected graph represented as an adjacency list, write a function to find the number of connected components in the graph. The graph can have multiple disconnected subgraphs. Each node in the graph is labeled with a unique integer. Return the total count of connected components in the graph.","solution":"def count_connected_components(graph): This function returns the number of connected components in the graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are nodes and values are lists of adjacent nodes. Returns: int: The number of connected components in the graph. visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(graph.get(current, [])) components = 0 for node in graph: if node not in visited: dfs(node) components += 1 return components"},{"question":"You are given a 2D matrix `grid` of size `m x n` representing a map where `1` represents land and `0` represents water. An island is a maximal group of connected `1`s (horizontally, vertically, or diagonally). Given a `0-indexed` integer array `start` representing the starting cell of a map, return the number of islands that are connected to this starting cell. If the starting cell is water, return `0`. The function should traverse the grid and count all distinct islands connected to the starting cell, if the start cell is a piece of land.","solution":"def num_islands_connected_to_start(grid, start): Returns the number of islands connected to the given starting cell in the grid. If the starting cell is water (0), return 0. m, n = len(grid), len(grid[0]) start_row, start_col = start def is_valid(i, j, visited): return 0 <= i < m and 0 <= j < n and not visited[i][j] and grid[i][j] == 1 def dfs(i, j, visited): stack = [(i, j)] while stack: x, y = stack.pop() if not is_valid(x, y, visited): continue visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny, visited): stack.append((nx, ny)) if grid[start_row][start_col] == 0: return 0 visited = [[False for _ in range(n)] for _ in range(m)] num_islands = 0 if grid[start_row][start_col] == 1 and not visited[start_row][start_col]: dfs(start_row, start_col, visited) num_islands += 1 return num_islands"},{"question":"You are given an integer array `heights` representing the height of each cell in a grid. The grid is represented as an m x n matrix where `heights[i][j]` represents the height of cell (i, j). A cell is considered \\"reachable\\" if you can move directly uphill or downhill to it from an adjacent cell. Cells are adjacent if they share a common edge (top, bottom, left, or right). Your task is to calculate the highest peak in the grid such that every cell is reachable from at least one border cell (a cell on the edge of the grid). The peak is the maximum height in the resulting grid where each cell is reachable. Write a function that takes the 2D array `heights` as input and returns the height of the highest peak in the grid.","solution":"def highest_peak(heights): from collections import deque m, n = len(heights), len(heights[0]) queue = deque() visited = [[False] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with all border cells for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: queue.append((i, j)) visited[i][j] = True # Process the queue and perform BFS to find the highest peak while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: heights[nx][ny] = max(heights[nx][ny], heights[x][y]) visited[nx][ny] = True queue.append((nx, ny)) return max(max(row) for row in heights)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find all the distinct integers that occur exactly `k` times in the array and return _them in **ascending** order_.","solution":"def find_k_times_elements(arr, k): Returns distinct integers that occur exactly k times in the array in ascending order. from collections import Counter # Count occurrences of each element count = Counter(arr) # Filter elements that occur exactly k times k_times_elements = [element for element, freq in count.items() if freq == k] # Return elements in ascending order return sorted(k_times_elements)"},{"question":"Write a function `maxSumSubarrayElements` that takes an array of integers `arr` and an integer `k` as input. The function should return the maximum sum of `k` consecutive elements in the array. If the array contains fewer than `k` elements, the function should return `null`. For example, for `arr = [2, 1, 5, 1, 3, 2]` and `k = 3`, the function should return `9` (as the subarray `[5, 1, 3]` has the maximum sum of `9` among all possible subarrays of length `3`). **Function Signature:** `def maxSumSubarrayElements(arr: List[int], k: int) -> Optional[int]:` **Examples:** - `maxSumSubarrayElements([2, 1, 5, 1, 3, 2], 3)` returns `9` - `maxSumSubarrayElements([2, 3, 4, 1, 5], 2)` returns `7` - `maxSumSubarrayElements([2, 3], 3)` returns `None`","solution":"from typing import List, Optional def maxSumSubarrayElements(arr: List[int], k: int) -> Optional[int]: Returns the maximum sum of k consecutive elements in the array. If the array contains fewer than k elements, the function returns None. n = len(arr) if n < k: return None # Compute the sum of the first k elements max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array to find the maximum sum for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an unsorted integer array `nums`. Write a function that returns a list of all unique triplets `[nums[i], nums[j], nums[k]]` such that `i`, `j`, `k` are distinct indices and `nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets.","solution":"def three_sum(nums): Returns a list of all unique triplets [nums[i], nums[j], nums[k]] such that i, j, k are distinct indices and nums[i] + nums[j] + nums[k] == 0. The solution set must not contain duplicate triplets. nums.sort() res = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip same elements to avoid duplicates in `res` left, right = i + 1, length - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip same elements to avoid duplicates in `res` while left < right and nums[right] == nums[right - 1]: right -= 1 # skip same elements to avoid duplicates in `res` left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return res"},{"question":"You are given a string `s` which represents a binary number (a string consisting only of the characters \'0\' and \'1\'). Determine if the binary number is divisible by 3. Return `True` if it is divisible by 3, otherwise return `False`.","solution":"def is_divisible_by_3(s): Determines if the binary number represented by string `s` is divisible by 3. Args: s (str): String representation of a binary number. Returns: bool: True if the binary number is divisible by 3, False otherwise. # Convert binary string to decimal integer num = int(s, 2) # Check if number is divisible by 3 return num % 3 == 0"},{"question":"Write a function that takes a binary tree and returns a list of its node values in level-order traversal (breadth-first traversal). Each node in the binary tree has a value and two children, left and right. The return value should be a list of lists, where each list contains the values of nodes at the same level from left to right.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Returns the values of nodes in a binary tree using level-order traversal. :param root: TreeNode, the root of the binary tree :return: List[List[int]], list of lists where each list contains the values of nodes at the same level if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Given a binary tree, check whether it is a **mirror** of itself (i.e., symmetric around its center). To solve this problem, we define a function `isSymmetric(root)` that takes the root of a binary tree and returns `true` if the tree is symmetric, and `false` otherwise. A binary tree is symmetric if a left subtree is a mirror reflection of the right subtree. The function should consider the following: - A function `isMirror(t1, t2)` that checks whether two trees are mirror images. - Return `isMirror(root, root)` to check if the tree is a mirror of itself. The tree can be empty, have only one node, or have multiple nodes. The Nodes in the tree contain integer values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Check whether the binary tree is symmetric around its center. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left) return isMirror(root, root)"},{"question":"You have a sequence of integers given in the form of an array nums of length n. A subsequence of this array is considered to be a **good subsequence** if the sum of the numbers in the subsequence is divisible by a given integer k. Return _the maximum length of a good subsequence_ that can be constructed from nums. If no such subsequence exists, return 0.","solution":"def max_good_subsequence_length(nums, k): from itertools import combinations def is_good_subsequence(subsequence): return sum(subsequence) % k == 0 max_length = 0 n = len(nums) for length in range(1, n + 1): for subseq in combinations(nums, length): if is_good_subsequence(subseq): max_length = max(max_length, length) return max_length"},{"question":"Given a binary tree, return the **zigzag level order** traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). The tree is represented by a list of integer values in a breadth-first order where null values indicate missing nodes. For example, given the list `[3, 9, 20, null, null, 15, 7]`, your function should return `[[3], [20, 9], [15, 7]]`.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_len = len(current_level) level_vals = deque() for _ in range(level_len): node = current_level.popleft() if left_to_right: level_vals.append(node.val) else: level_vals.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.append(list(level_vals)) left_to_right = not left_to_right return result # Helper function to build a tree from a list of values def build_tree(values): if not values: return None root = TreeNode(values[0]) queue = deque([root]) index = 1 while index < len(values): current = queue.popleft() if values[index] is not None: current.left = TreeNode(values[index]) queue.append(current.left) index += 1 if index < len(values) and values[index] is not None: current.right = TreeNode(values[index]) queue.append(current.right) index += 1 return root"},{"question":"You are given a two-dimensional integer array `grid` of size `m x n`, representing a rectangular grid where each cell contains either a `0` (empty cell) or a `1` (obstacle). The grid is enclosed within a border of empty cells (i.e., all cells in the first and last rows, as well as the first and last columns, contain `0`). A robot starts at the top-left cell and its goal is to reach the bottom-right cell. The robot can only move in four directions: up, down, left, or right, and it cannot move through the obstacle cells. Return _the **length of the shortest path** from the top-left cell to the bottom-right cell, avoiding obstacles_. If there is no valid path, return `-1`.","solution":"from collections import deque def shortest_path(grid): Find the shortest path from the top-left to the bottom-right of the grid, avoiding obstacles. If no path exists, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # down, up, right, left queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dir in directions: nx, ny = x + dir[0], y + dir[1] if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given an array of integers `nums`, write a function to find the **maximum length** of a subarray with the sum equal to `k`. If no such subarray exists, return `0`. The sum of a subarray is defined as the sum of its elements between two indices, inclusive. ```python def max_length_subarray_with_sum_k(nums, k): # Write your code here ``` _**Input:**_ - An array of integers `nums` (1  nums.length  10^5, -10^4  nums[i]  10^4) - An integer `k` _**Output:**_ - An integer representing the maximum length of a subarray with sum equal to `k` **Example:** ``` Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and has a length of 4. Input: nums = [-2, -1, 2, 1], k = 1 Output: 2 Explanation: The subarray [-1, 2] sums to 1 and has a length of 2. ```","solution":"def max_length_subarray_with_sum_k(nums, k): Returns the maximum length of a subarray with sum equal to k. sum_dict = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_length = i + 1 if current_sum - k in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - k]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length"},{"question":"Given an array of distinct integers `arr` and a target integer value `target`, return _the smallest **positive** integer `k` such that after modifying `arr` by adding `k` to any subset of its elements (you can modify multiple elements with different k\'s), the array contains an element equal to `target`_. If no such `k` exists, return `-1`.","solution":"def find_smallest_k(arr, target): Finds the smallest positive integer k such that after modifying arr by adding k to any subset of its elements, the array contains an element equal to target. # First, check if the target is already in the array if target in arr: return 0 # The smallest positive integer cannot be less than 1 for k in range(1, target + 1): modified = {x + k for x in arr if x + k <= target} if target in modified: return k return -1"},{"question":"You are given two strings `s` and `goal` of the same length. Your task is to determine if you can obtain the string `goal` by rotating string `s` any number of times (including zero). A string rotation is defined as taking any number of characters from the start of the string `s` and moving them to the end in the same order. Return `true` if it is possible to obtain `goal` by rotating `s`, and `false` otherwise. For example, if `s = \\"abcde\\"` and `goal = \\"cdeab\\"`, then rotating `s` by 2 positions would yield `goal`, making the result `true`.","solution":"def can_obtain_goal_by_rotation(s, goal): Determines if the string goal can be obtained by rotating string s any number of times. Parameters: s (str): The original string. goal (str): The target string to check against. Returns: bool: True if goal can be obtained by rotating s any number of times, false otherwise. if len(s) != len(goal): return False return goal in (s + s)"},{"question":"A company has a collection of n projects, each associated with a certain revenue value. These projects can be performed in any order. However, some projects have dependencies, meaning one project must be completed before another can begin. You are given the list of projects `projects`, where each project is represented as an integer, and a list of dependencies `dependencies`, where each dependency is a pair of integers `[a, b]`, indicating that project `b` must be completed after project `a`. Your task is to find an order to complete all the projects such that all the dependencies are satisfied and the total revenue is maximized. If it\'s impossible to complete all the projects due to a cycle in the dependencies, return an empty list. If there are multiple valid orders with the same total revenue, you can return any of them. Return _an order of project completion to maximize revenue or an empty list if it\'s impossible_.","solution":"def max_revenue_order(projects, dependencies, revenues): from collections import defaultdict, deque # Create graph and calculate in-degrees graph = {project: [] for project in projects} in_degree = {project: 0 for project in projects} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Topological sort using Kahn\'s Algorithm queue = deque([project for project in projects if in_degree[project] == 0]) sorted_projects = [] while queue: project = queue.popleft() sorted_projects.append(project) for neighbor in graph[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all projects are not included in the topological sort, there\'s a cycle if len(sorted_projects) != len(projects): return [] # Calculating the total revenue in the order of sorted_projects total_revenue = sum(revenues[project] for project in sorted_projects) return sorted_projects"},{"question":"You are given an m x n matrix \\"grid\\" of integers where each integer represents the altitude of a cell. Water can flow from a cell to any of its directly adjacent cells with an equal or lower altitude. Two cells are considered directly adjacent if they share an edge (horizontally or vertically). Return _a list of all coordinates_ `(r, c)` _starting from which water can flow to the ocean in all four directions: left, right, top, and bottom boundary of the grid._ Cells should be represented as **tuples** in the format `(row, column)` and be sorted in **non-decreasing** order first by row and then by column.","solution":"def pacificAtlantic(matrix): if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable, prev_height): if (r, c) in reachable or r < 0 or c < 0 or r >= rows or c >= cols or matrix[r][c] < prev_height: return reachable.add((r, c)) for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)): dfs(r + dr, c + dc, reachable, matrix[r][c]) for i in range(rows): dfs(i, 0, pacific_reachable, matrix[i][0]) dfs(i, cols - 1, atlantic_reachable, matrix[i][cols - 1]) for j in range(cols): dfs(0, j, pacific_reachable, matrix[0][j]) dfs(rows - 1, j, atlantic_reachable, matrix[rows - 1][j]) result = list(pacific_reachable & atlantic_reachable) result.sort() # sort by row first, then by column return result"},{"question":"You are managing a tree farm and need to harvest the trees. Each tree grows at a different height, and you must select trees such that they form an **increasing sequence** of heights. Given an array of integers `heights` where `heights[i]` represents the height of the `i-th` tree, return _the length of the longest increasing subsequence of tree heights_. Note that the subsequence does not need to be contiguous, but the order must be maintained.","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest increasing subsequence of tree heights. :param heights: List[int] - List of tree heights. :return: int - Length of the longest increasing subsequence. if not heights: return 0 # Initialize an array to store the length of the LIS ending at each index lis = [1] * len(heights) # Compute the LIS values in a bottom up manner for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The longest increasing subsequence will be the maximum value in lis[] return max(lis)"},{"question":"You are given a grid of integers `grid` of size `m x n`, where each element in the grid represents the altitude at that position. You need to design an algorithm to find the minimum effort required to travel from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. While traveling, you can move in four possible directions: up, down, left, or right. The effort of a path is defined as the maximum absolute difference in altitudes between two consecutive cells in the path. Return the minimum effort required to travel from the top-left corner to the bottom-right corner. Implement the function `minimumEffortPath(grid: List[List[int]]) -> int`.","solution":"import heapq from typing import List def minimumEffortPath(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) def possible(mid): pq = [(0, 0, 0)] # (effort, x, y) visited = set() while pq: effort, x, y = heapq.heappop(pq) if (x, y) == (m-1, n-1): return True if (x, y) in visited: continue visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_effort = max(effort, abs(grid[nx][ny] - grid[x][y])) if new_effort <= mid: heapq.heappush(pq, (new_effort, nx, ny)) return False left, right = 0, max(max(row) for row in grid) while left < right: mid = (left + right) // 2 if possible(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a matrix of integers where each value represents the height of a cell, write a function to determine if there exists a path from the top-left corner to the bottom-right corner such that you can only move down or right at each step, and the height of the next cell must be greater than or equal to the current cell. Return a boolean indicating whether such a path exists.","solution":"def path_exists(matrix): Determines if there exists a path from the top-left corner to the bottom-right one that only moves either down or right and moves to cells with greater or equal height. if not matrix or not matrix[0]: return False def dfs(x, y): if x == len(matrix) - 1 and y == len(matrix[0]) - 1: return True if (x + 1 < len(matrix) and matrix[x + 1][y] >= matrix[x][y] and dfs(x + 1, y)): return True if (y + 1 < len(matrix[0]) and matrix[x][y + 1] >= matrix[x][y] and dfs(x, y + 1)): return True return False return dfs(0, 0)"},{"question":"Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in T that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). You may assume that both `p` and `q` exist in the BST. Write a function: ```python def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: ``` **Custom Testing:** - For the input, you should provide the entire BST traversed in level-order format (e.g., `[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]`) and the values of the two nodes `p` and `q`. - The output will be the value of the LCA node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two given nodes in a BST. current = root while current: if p.val < current.val and q.val < current.val: current = current.left elif p.val > current.val and q.val > current.val: current = current.right else: return current"},{"question":"You are given an **array** of integers `arr` and a positive integer `k`. You need to determine if you can rearrange the array such that the difference between the maximum and minimum element in every contiguous subarray of size `k` is the same. Return `true` if such a rearrangement is possible and `false` otherwise.","solution":"def can_rearrange_to_specify_diff(arr, k): Determines if the array can be rearranged such that the difference between the maximum and minimum element in every contiguous subarray of size `k` is the same. Args: arr (list of int): The input array of integers. k (int): The size of the subarray. Returns: bool: True if such a rearrangement is possible, False otherwise. if k > len(arr): return False sorted_arr = sorted(arr) diff_set = set() for i in range(len(sorted_arr) - k + 1): diff = sorted_arr[i + k - 1] - sorted_arr[i] diff_set.add(diff) if len(diff_set) > 1: return False return True"},{"question":"Given an array of non-negative integers `nums`, you are tasked with forming a non-decreasing array by modifying at most one element. In other words, you are allowed to change at most one element in the array such that the resulting array is non-decreasing. Return _true_ if it is possible to form a non-decreasing array with at most one modification, or _false_ otherwise.","solution":"def checkPossibility(nums): Returns True if it is possible to make the array non-decreasing with at most one modification, otherwise returns False. n = len(nums) count = 0 for i in range(1, n): if nums[i] < nums[i - 1]: if count == 1: return False count += 1 if i == 1 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"You are given a string `s` representing a sequence of lowercase letters. You need to determine if you can rearrange the letters of the string `s` such that no two adjacent letters are the same. If it is possible, return the rearranged string. If it is not possible, return an empty string. Make sure the returned string (if any) has the same length as the input string `s` and contains exactly the same characters, only rearranged to satisfy the non-adjacency condition.","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s): Rearranges the string \'s\' such that no two adjacent characters are the same. If such a rearrangement is not possible, returns an empty string. if not s: return \\"\\" # Frequency count of characters frequency = Counter(s) # Using max heap to sort characters by frequency max_heap = [] for char, freq in frequency.items(): heappush(max_heap, (-freq, char)) previous_char = None previous_freq = 0 result = [] while max_heap: freq, char = heappop(max_heap) # Add the previous character back if its frequency is not zero if previous_char and previous_freq < 0: heappush(max_heap, (previous_freq, previous_char)) # Append current character to result result.append(char) previous_char = char previous_freq = freq + 1 # Decrease the frequency if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"Given an integer `n`, generate all possible combinations of `n` pairs of balanced parentheses. Each combination should be well-formed and listed as a string. The result should be returned as a list of strings containing all valid combinations sorted in lexicographical order.","solution":"def generate_parentheses(n): Generate all combinations of n pairs of balanced parentheses. Parameters: n (int): The number of pairs of parentheses. Returns: List of strings: All valid combinations of parentheses sorted lexicographically. def backtrack(S = \'\', left = 0, right = 0): if len(S) == 2 * n: result.append(S) return if left < n: backtrack(S+\'(\', left+1, right) if right < left: backtrack(S+\')\', left, right+1) result = [] backtrack() result.sort() return result"},{"question":"Given a **0-indexed** integer array `arr`, you need to split the array into two contiguous subarrays `A` and `B` such that every element in `A` is less than or equal to every element in `B`. Return _the length of subarray `A`_. If multiple valid answers exist, return the smallest possible length of `A`. The test cases are generated such that it is always possible to split the array in this way.","solution":"def partition_disjoint(arr): Returns the length of subarray A such that every element in A is less than or equal to every element in B. left_max = arr[0] overall_max = arr[0] partition_idx = 0 for i in range(1, len(arr)): overall_max = max(overall_max, arr[i]) if arr[i] < left_max: left_max = overall_max partition_idx = i return partition_idx + 1"},{"question":"You are given a matrix `mat` of integers and an integer `k`. The matrix `mat` has `m` rows and `n` columns. A matrix block sum is the summation of all elements in a block centered at a given element `(r, c)` with a size of `(2k + 1) x (2k + 1)`. The block sum matrix is a matrix that satisfies the property that each element at position `(r, c)` is the sum of all elements from the original matrix within its `k` radius. Given the matrix `mat` and the integer `k`, return the block sum matrix. For example, given the input `mat = [[1,2,3],[4,5,6],[7,8,9]]` and `k = 1`, the output matrix should be `[[12,21,16],[27,45,33],[24,39,28]]`.","solution":"def matrixBlockSum(mat, k): m, n = len(mat), len(mat[0]) # Step 1: Create prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for r in range(m): for c in range(n): prefix_sum[r + 1][c + 1] = mat[r][c] + prefix_sum[r + 1][c] + prefix_sum[r][c + 1] - prefix_sum[r][c] result = [[0] * n for _ in range(m)] # Step 2: Calculate the block sum using the prefix sum matrix for r in range(m): for c in range(n): r1 = max(0, r - k) r2 = min(m - 1, r + k) c1 = max(0, c - k) c2 = min(n - 1, c + k) result[r][c] = prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r2 + 1][c1] - prefix_sum[r1][c2 + 1] + prefix_sum[r1][c1] return result"},{"question":"You are given an array of integers `nums`, where each element in the array can be either 0, 1, or 2. You need to sort this array in-place without using any built-in sorting algorithms such that all 0s come first, followed by all 1s, and all 2s come last. Return the sorted array.","solution":"def sort_colors(nums): Sorts an array of integers in-place where each element is either 0, 1, or 2 such that all 0s come first, followed by all 1s, and all 2s come last. Parameters: nums (list of int): The list of integers to sort Returns: list of int: The sorted list low = 0 mid = 0 high = len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1 return nums"},{"question":"You are given an integer array `nums` sorted in **non-decreasing order** and an integer `k`. Find the `k` strongest values in the array. The strength of a value is defined as the absolute difference between the value and the median of the array. If there is a tie between two values, the value with the greater number is considered stronger. Return the `k` strongest values in **any order**. Note that: - The median is the middle element in a sorted array. If the array length is odd, the median is the middle element; if it is even, the median is the average of the two middle elements. - Ensure the returned array is of size `k`.","solution":"def get_k_strongest_values(nums, k): Returns the k strongest values in the array nums. The strength of a value is defined as the absolute difference between the value and the median of the array. The values are returned in any order. :param nums: List[int] - A list of integers sorted in non-decreasing order. :param k: int - The number of strongest values to return. :return: List[int] - A list of the k strongest values. n = len(nums) # Find median if n % 2 == 0: median = (nums[n // 2 - 1] + nums[n // 2]) / 2 else: median = nums[n // 2] # Calculate strength for each number as a tuple (strength, value) strength_values = [(abs(num - median), num) for num in nums] # Sort primarily by strength in descending order, then by value in descending order strength_values.sort(key=lambda x: (x[0], x[1]), reverse=True) # Extract the values from the sorted list of tuples strongest_values = [value for strength, value in strength_values[:k]] return strongest_values"},{"question":"Given a binary tree, return the bottom-up level order traversal of its nodes\' values. (i.e., from left to right, level by level from leaf level to root level). Construct a function that takes the root of the binary tree as input and returns the bottom-up level order traversal as an array of arrays. Ensure the solution has a time complexity of O(n) and uses O(n) extra space where n is the number of nodes in the tree.","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root): Given the root of a binary tree, return the bottom-up level order traversal of its nodes\' values. if not root: return [] # Traverse the tree level by level and store the nodes in a dictionary level_map = defaultdict(list) queue = deque([(root, 0)]) # (node, level) max_level = 0 while queue: node, level = queue.popleft() level_map[level].append(node.val) max_level = max(max_level, level) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return [level_map[level] for level in range(max_level, -1, -1)]"},{"question":"Given a string that contains only lowercase letters, remove duplicate letters so that every letter appears only once. You must make sure your result is the smallest in lexicographical order among all possible results. Return the resulting string. For example: - Given \\"bcabc\\", the resulting string should be \\"abc\\". - Given \\"cbacdcbc\\", the resulting string should be \\"acdb\\".","solution":"def remove_duplicate_letters(s): Remove duplicate letters and return the smallest in lexicographical order among all possible results. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.discard(stack.pop()) seen.add(char) stack.append(char) return \'\'.join(stack)"},{"question":"Write a function that accepts a non-empty list of integers `nums` where every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Return the single element.","solution":"def single_number(nums): Given a non-empty list of integers `nums` where every element appears twice except for one, finds that single one. Args: nums (list of int): List of integers containing exactly one element that appears once and all others appear exactly twice. Returns: int: The single integer that appears only once in the list. unique = 0 for num in nums: unique ^= num return unique"},{"question":"You are given a 2D grid of size `m x n` representing a map with the following values: - `0` represents water. - `1` represents land. - `2` represents a treasure. You are currently positioned at the top-left corner of the grid (0, 0) and you want to find the minimum number of steps required to reach the treasure. You can only move up, down, left, or right on the map, and you cannot move on water (`0`). Return _the minimum number of steps required to reach the treasure_. If it is not possible to reach the treasure, return `-1`.","solution":"from collections import deque def min_steps_to_treasure(grid): Returns the minimum number of steps required to reach the treasure (2) from the top-left corner (0,0). If it is not possible to reach the treasure, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) if grid[0][0] == 0: return -1 while queue: x, y, steps = queue.popleft() if grid[x][y] == 2: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a 2D grid of size `m x n` representing a map of a city. Each cell in the grid can either be a building represented as `1` or an empty lot represented as `0`. You need to demolish certain buildings so that there exists exactly one connected group of buildings (connectivity can be established through adjacent cells - up, down, left, and right). Return the minimum number of buildings you need to demolish to achieve this. If it is not possible to have exactly one connected group of buildings, return `-1`.","solution":"def min_demolish_to_connect_buildings(grid): Returns the minimum number of buildings to demolish to create exactly one connected component of buildings. If it\'s not possible, return -1. from collections import deque def bfs(start, grid, visited): queue = deque([start]) visited.add(start) buildings = 0 cells = [] while queue: x, y = queue.popleft() buildings += 1 cells.append((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: if grid[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) return buildings, cells # Count number of initial building groups m, n = len(grid), len(grid[0]) visited = set() groups = 0 building_cells = [] for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: buildings, cells = bfs((i, j), grid, visited) groups += 1 building_cells.append((buildings, cells)) if groups == 0: return -1 # No building at all if groups == 1: return 0 # Already one connected component # Find the minimum number of demolish to connect all groups min_demolish = float(\'inf\') for _, cells1 in building_cells: for _, cells2 in building_cells: if cells1 != cells2: connected = False for x1, y1 in cells1: for x2, y2 in cells2: if abs(x1 - x2) + abs(y1 - y2) == 1: connected = True break if connected: break if connected: continue # Already adjacent, no need to demolish between these groups demolish_count = float(\'inf\') for x1, y1 in cells1: for x2, y2 in cells2: demolish_count = min(demolish_count, min(abs(x1 - x2), abs(y1 - y2))) min_demolish = min(min_demolish, demolish_count + 1) return min_demolish if min_demolish != float(\'inf\') else -1"},{"question":"**[Question 4]:** You are given two strings, `order` and `str`. `order` is a permutation of the 26 lowercase English letters which represents the custom order of the alphabet. `str` is a string consisting of lowercase English letters. Sort the characters of `str` such that they match the order defined by `order`. If `str` contains characters not present in `order`, those characters should appear at the end of `str` in their original order. Return _the sorted string._","solution":"def custom_sort_string(order, str): This function sorts the characters of `str` such that they match the order defined by `order`. Characters not in `order` appear at the end in their original order. # Create a dictionary to store the order of each character in `order` order_dict = {char: index for index, char in enumerate(order)} # Split the `str` into characters that are in `order` and those that are not in_order_chars = [] not_in_order_chars = [] for char in str: if char in order_dict: in_order_chars.append(char) else: not_in_order_chars.append(char) # Sort the characters that are in `order` according to the custom order in_order_chars.sort(key=lambda char: order_dict[char]) # Concatenate the characters in order followed by those not in order sorted_str = \'\'.join(in_order_chars) + \'\'.join(not_in_order_chars) return sorted_str"},{"question":"Implement a class, `WordDictionary`, that supports adding words and searching for words with wildcard characters. The class should have two functions: 1. `addWord(word)`: Adds a word into the data structure. 2. `search(word)`: Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. A word could contain the wildcard character `\'.\'` to represent any one letter. Example: ``` addWord(\\"bad\\") addWord(\\"dad\\") addWord(\\"mad\\") search(\\"pad\\") -> false search(\\"bad\\") -> true search(\\".ad\\") -> true search(\\"b..\\") -> true ```","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): Adds a word into the data structure. self.words.append(word) def search(self, word): Returns True if there is any string in the data structure that matches `word` or False otherwise. A word could contain the wildcard character `\'.\'` to represent any one letter. from re import match pattern = \\"^\\" + word + \\"\\" for w in self.words: if match(pattern, w): return True return False"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to perform a series of operations that transform the string into another string where no two adjacent characters are the same. In each operation, you can choose any character from the string and replace it with any lowercase letter. Determine the minimum number of operations required to achieve this transformation. If it is not possible to achieve this goal, return `-1`.","solution":"def min_operations_to_transform_string(s, k): Returns the minimum number of operations required to transform string s into a string where no two adjacent characters are the same. If not possible, returns -1. n = len(s) if n == 0: return 0 # Empty string requires zero operations. # Check the number of allowed differences k. if k < 2: return -1 # Impossible to transform with less than 2 different characters. # Transform string using a greedy approach count = 0 s = list(s) # Convert string to list for mutable operations. for i in range(1, n): if s[i] == s[i-1]: count += 1 for j in range(26): # Try replacing with different characters from \'a\' to \'z\' new_char = chr((ord(s[i-1]) - ord(\'a\') + j + 1) % 26 + ord(\'a\')) # Different char if (i == n-1 or new_char != s[i+1]) and new_char != s[i-1]: s[i] = new_char break return count"},{"question":"You are given two integers `a` and `b`. Your task is to find the minimum number of operations required to convert `a` into `b`. An operation consists of either incrementing or decrementing `a` by 1. Implement the following function: ```python def min_operations(a: int, b: int) -> int: ``` This function should return an integer representing the minimum number of operations required to transform `a` into `b`.","solution":"def min_operations(a: int, b: int) -> int: Returns the minimum number of operations required to convert a to b. An operation consists of either incrementing or decrementing a by 1. return abs(a - b)"},{"question":"Given an unsorted integer array `nums`, find the maximum difference between the successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear space.","solution":"def maximum_gap(nums): Finds the maximum difference between the successive elements in the sorted form of the array nums. :param nums: List of integers :return: Maximum difference between successive elements in sorted form if len(nums) < 2: return 0 min_val, max_val = min(nums), max(nums) if min_val == max_val: return 0 bucket_size = (max_val - min_val) // (len(nums) - 1) or 1 bucket_count = (max_val - min_val) // bucket_size + 1 buckets = [[None, None] for _ in range(bucket_count)] for num in nums: idx = (num - min_val) // bucket_size if buckets[idx][0] is None: buckets[idx][0] = buckets[idx][1] = num else: buckets[idx][0] = min(buckets[idx][0], num) buckets[idx][1] = max(buckets[idx][1], num) max_gap = 0 prev_max = min_val for bucket_min, bucket_max in buckets: if bucket_min is not None: max_gap = max(max_gap, bucket_min - prev_max) prev_max = bucket_max return max_gap"},{"question":"**Question 4**: You are given a list of integers representing the prices of a stock on different days. You are allowed to complete at most `k` transactions (buying and selling one share of the stock per transaction). Design an algorithm to find the maximum profit you can achieve. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).","solution":"def max_profit(prices, k): Returns the maximum profit that can be achieved with at most k transactions. Parameters: prices (list): list of integers representing the prices of the stock on different days. k (int): the maximum number of transactions allowed. Returns: int: the maximum profit that can be achieved. n = len(prices) if n == 0 or k == 0: return 0 if k >= n // 2: return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1)) profits = [[0] * n for _ in range(k+1)] for t in range(1, k+1): max_diff = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d-1], prices[d] + max_diff) max_diff = max(max_diff, profits[t-1][d] - prices[d]) return profits[k][n-1]"},{"question":"You are given an integer array `difficulty` and an integer array `profit`, where `difficulty[i]` and `profit[i]` are the difficulty and profit of the `i-th` job, respectively. You are also given an integer `worker`, which represents the maximum difficulty each worker can handle. Each worker can work on at most one job that does not exceed their ability. Return _the **maximum profit** you can achieve by assigning the optimal job to each worker._","solution":"def maxProfitAssignment(difficulty, profit, worker): jobs = sorted(zip(difficulty, profit)) worker.sort() max_profit = i = best = 0 for ability in worker: while i < len(jobs) and ability >= jobs[i][0]: best = max(best, jobs[i][1]) i += 1 max_profit += best return max_profit"},{"question":"You are given a 2D grid representing a maze, where \'0\' indicates an open cell and \'1\' indicates a blocked cell. You start at the top-left corner and need to reach the bottom-right corner, moving only up, down, left, or right through open cells. Determine the minimum number of steps required to reach the bottom-right corner. If it is not possible, return -1.","solution":"from collections import deque def min_steps(maze): Returns the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner. If reaching the destination is not possible, returns -1. if not maze or not maze[0] or maze[0][0] == \'1\' or maze[-1][-1] == \'1\': return -1 rows, cols = len(maze), len(maze[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Down, Up, Right, Left queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == rows - 1 and col == cols - 1: return steps for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and maze[r][c] == \'0\' and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, steps + 1)) return -1"},{"question":"You are given two integer arrays `nums1` and `nums2`, representing the two sets of integers. A **pair of sets** `{A, B}` is **good** if there are no integers in both `A` and `B`. Return the maximum possible sum of a **good** pair of subsets `{A, B}`, where subset `A` is a subset of `nums1`, and subset `B` is a subset of `nums2`. Note that the sum of a pair of subsets `{A, B}` is the sum of all elements in `A` plus the sum of all elements in `B`. If there are no good pairs of subsets, return `0`.","solution":"def max_sum_no_intersection(nums1, nums2): Returns the maximum possible sum of a good pair of subsets {A, B}, where subset A is a subset of nums1 and subset B is a subset of nums2 such that there are no integers in both A and B. nums1_set = set(nums1) nums2_set = set(nums2) # Determine if there is any intersection between the two sets if nums1_set & nums2_set: return 0 # Calculate the total sum of both arrays sum_nums1 = sum(nums1) sum_nums2 = sum(nums2) return sum_nums1 + sum_nums2"},{"question":"Given an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest sum and return its sum. Implement the solution using dynamic programming.","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. :param nums: List of integers :return: Integer, the largest sum of contiguous subarray # Handling edge case if the input list is empty if not nums: return 0 # Initialize current sum and max sum to the first element of the array current_sum = max_sum = nums[0] # Iterate through the list starting from the second element for num in nums[1:]: # Update current sum by including the current number or starting a new subarray current_sum = max(num, current_sum + num) # Update max sum if current sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a **0-indexed** array of integers `hours`, representing the number of hours you plan to work each day for the next `n` days. A day is considered a **successful** day if the number of hours worked is greater than or equal to `8`. Return the **maximum number** of consecutive successful days you can achieve by **optionally** increasing the hours worked on any day without any limit. However, you can only increase the hours on exactly `k` different days. If it\'s not possible to achieve any successful days, return `0`.","solution":"def max_consecutive_successful_days(hours, k): n = len(hours) left, right = 0, 0 max_length = 0 to_increase = 0 while right < n: if hours[right] < 8: to_increase += 1 while to_increase > k: if hours[left] < 8: to_increase -= 1 left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given an undirected graph represented as an adjacency list. Each node in the graph is an integer. Create a function that can detect if the graph contains a cycle. A cycle is defined as a path of edges and vertices wherein a vertex is reachable from itself. Implement the function `boolean hasCycle(Map<Integer, List<Integer>> graph)` which takes an adjacency list representation of the graph as input and returns `true` if the graph contains a cycle, or `false` otherwise. Use depth-first search (DFS) to solve this problem.","solution":"def has_cycle(graph): Detect if the graph contains a cycle. :param graph: dict, representing the adjacency list of the graph :return: bool, True if there is a cycle, False otherwise def dfs(node, parent, visited): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node, visited): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, None, visited): return True return False"},{"question":"Given a list of integers `nums`, write a function that returns the length of the longest subsequence that is a valid Fibonacci sequence. A sequence `x1, x2, x3, ..., xn` is a valid Fibonacci sequence if: - `n >= 3` - `xi + xi+1 = xi+2` for all `i + 2 <= n` If no such subsequence exists, return `0`. The elements in the subsequence do not need to be consecutive in the original list.","solution":"def len_longest_fib_subseq(nums): Returns the length of the longest subsequence that is a valid Fibonacci sequence. If no such subsequence exists, return 0. num_index = {num: i for i, num in enumerate(nums)} longest = {} max_len = 0 for k, z in enumerate(nums): for j in range(k): i = num_index.get(z - nums[j]) if i is not None and i < j: if (i, j) in longest: longest[(j, k)] = longest[(i, j)] + 1 else: longest[(j, k)] = 3 max_len = max(max_len, longest[(j, k)]) return max_len if max_len >= 3 else 0"},{"question":"You are given a linked list where each node contains an integer value. Write a function to return the node at which the cycle begins. If there is no cycle, return `null`. A linked list cycle means that some node in the list points to a previous node, thereby creating a loop. You are required to solve this problem in O(n) time and use only O(1) extra space.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. :param ListNode head: Head node of the linked list :return: The node where the cycle begins. If no cycle, return None if not head or not head.next: return None # Using Floyd\'s Tortoise and Hare algorithm to detect cycle slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # Find the starting node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a binary tree rooted at node `root` and an integer `targetSum`. Each node of the tree has an integer value. Return **all paths** from the root to the leaf nodes where the sum of the node values in the path equals `targetSum`. Each path should be represented as a list of node values in order from the root to the leaf. Return a list of all such paths. If there are no such paths, return an empty list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum_from_root_to_leaf(root, targetSum): Returns all paths from root to leaf whose sum of nodes equals targetSum. def helper(node, current_path, target, all_paths): if not node: return current_path.append(node.val) # Check if it\'s a leaf node and its path sum equals targetSum if not node.left and not node.right and sum(current_path) == target: all_paths.append(list(current_path)) # Traverse the left subtree if node.left: helper(node.left, current_path, target, all_paths) # Traverse the right subtree if node.right: helper(node.right, current_path, target, all_paths) # Backtrack current_path.pop() result = [] helper(root, [], targetSum, result) return result"},{"question":"You are given a 2D grid that represents a maze consisting of `n` rows and `m` columns. Each cell in the grid is either a wall (`1`) or a path (`0`). There is a rat located at the top-left corner of the grid (cell `(0, 0)`) and its goal is to reach the bottom-right corner (cell `(n-1, m-1)`). The rat can move up, down, left, or right at each step. However, it can only move to a path cell and not a wall cell. Determine if there is any possible path from the top-left corner to the bottom-right corner. Return `true` if such a path exists, otherwise return `false`.","solution":"from collections import deque def is_path_possible(grid): Determines if there is a path from the top-left corner to the bottom-right corner. Args: grid (List[List[int]]): A 2D list representing the maze. Returns: bool: True if there is a path, False otherwise. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: r, c = queue.popleft() if (r, c) == (rows - 1, cols - 1): return True for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and grid[new_r][new_c] == 0 and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append((new_r, new_c)) return False"},{"question":"Given an integer array `nums` and an integer `k`, return _`true` if all the numbers in the array within each sliding window of length `k` are unique_. A sliding window is a subarray that moves from the start of the array to the end, covering each continuous subarray of length `k` in the process. The array may contain negative numbers. The function should operate in linear time complexity with respect to the length of the array.","solution":"def all_unique_in_sliding_window(nums, k): Returns True if all numbers in each sliding window of length k are unique. if k > len(nums): return False # If k is larger than the length of the array, return false because we can\'t form a window. num_set = set() for i in range(len(nums)): if i >= k: num_set.remove(nums[i - k]) # Remove the element that is sliding out of the window. if nums[i] in num_set: return False # If we encounter a duplicate, return False. num_set.add(nums[i]) # Add the current number to the set. return True"},{"question":"You are given a string `s` comprised of lowercase alphabets. A substring of `s` is defined as any contiguous sequence of characters within `s`. A substring is considered **uniform** if all characters within the substring are the same. For example, in the string `\\"aaabbccc\\"`, the substrings `\\"aaa\\"`, `\\"bb\\"`, and `\\"ccc\\"` are uniform. Given an integer `k`, return the length of the **longest** uniform substring of `s` that can be obtained after performing **at most** `k` operations. In one operation, you can change any character of the string `s` to any other lowercase alphabet.","solution":"def longest_uniform_substring(s, k): def helper(ch): left, max_length, max_count = 0, 0, 0 for right in range(len(s)): if s[right] == ch: max_count += 1 while (right - left + 1) - max_count > k: if s[left] == ch: max_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length # considering each character as the one to be maximized in the uniform substring max_len = 0 for char in set(s): max_len = max(max_len, helper(char)) return max_len"},{"question":"You are given a `2D` grid `grid` of `m` rows and `n` columns, where each cell represents a plot of land that can be occupied or vacant. The cell is represented by the following: * `\'1\'` represents a plot of land that is **occupied**. * `\'0\'` represents a plot of land that is **vacant**. Your task is to determine the number of distinct contiguous blocks of occupied land (referred to as \\"islands\\"). An island is a group of connected cells that are occupied (`\'1\'`), connected by **horizontal or vertical** means. Return _the **number of islands**_ present in the grid.","solution":"def num_islands(grid): Returns the number of distinct islands in the grid. An island is a group of connected \'1\'s (occupied land) connected horizontally or vertically. if not grid: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == \'0\': return grid[x][y] = \'0\' # Mark the land as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) islands_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': islands_count += 1 dfs(i, j) return islands_count"},{"question":"You are given a 2D grid of size `m x n` representing a map of land (`1`) and water (`0`). An island is a maximal 4-directionally connected group of `1`s. Each land cell is initially its own island. An island can be merged with another island if you build a bridge on water (`0`) which changes it into land (`1`). You are given a list of positions where bridges can be built, incrementally. Return _the number of islands after each bridge is built._","solution":"def numIslands2(m, n, positions): def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootx = find(parent, x) rooty = find(parent, y) if rootx != rooty: if rank[rootx] > rank[rooty]: parent[rooty] = rootx elif rank[rootx] < rank[rooty]: parent[rootx] = rooty else: parent[rooty] = rootx rank[rootx] += 1 return True return False parent = [-1] * (m * n) rank = [0] * (m * n) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] counts = 0 result = [] for position in positions: r, c = position idx = r * n + c if parent[idx] != -1: result.append(counts) continue parent[idx] = idx counts += 1 for dr, dc in directions: nr, nc = r + dr, c + dc nidx = nr * n + nc if 0 <= nr < m and 0 <= nc < n and parent[nidx] != -1: if union(parent, rank, idx, nidx): counts -= 1 result.append(counts) return result"},{"question":"Given a matrix `n x m` where each element represents the cost to pass through that cell, and you can only move right or down from the top-left corner to the bottom-right corner, find the minimum cost path. Return the minimum cost to reach the bottom-right corner of the matrix from the top-left corner.","solution":"def min_cost_path(matrix): Returns the minimum cost to reach the bottom-right corner of the matrix from the top-left corner. Parameters: matrix (list of list of int): The cost matrix. Returns: int: The minimum cost. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) # Create a 2D list to store the cost of the minimum cost path to each cell dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = matrix[0][0] # Initialize the first column of the dp array for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Initialize the first row of the dp array for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"You are given a string containing just the characters \'(\' and \')\'. Your task is to determine the minimum number of parentheses to add to make the string valid. A string is considered valid if it is the empty string, or if it can be written as AB (A concatenated with B), where A and B are valid strings, or if it can be written as (A), where A is a valid string. Write a function: ``` def minAddToMakeValid(s: str) -> int: # Your code here ``` **Example:** ``` Input: s = \\"())\\" Output: 1 Input: s = \\"(((\\" Output: 3 ``` **Constraints:** * s consists of \'(\' and \')\' characters only.","solution":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses to add to make the string valid. left_balance = 0 right_balance = 0 for char in s: if char == \'(\': left_balance += 1 elif char == \')\': if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"Given an array `arr` of integers where every integer appears twice except for one, which appears only once, write a function to find the integer that appears only once. Consider the array might contain negative numbers as well.","solution":"def find_single_number(arr): Given an array of integers where every integer appears twice except for one, find the integer that appears only once. single_number = 0 for num in arr: single_number ^= num return single_number"},{"question":"You are given a `sentence` which consists of words separated by spaces. Each word consists of lowercase English letters only. Create a function that rearranges the words in a sentence such that all words are sorted in increasing order of their lengths. If two words have the same length, they should appear in the order they were found in the original `sentence`. Return _the newly-formatted sentence_.","solution":"def rearrange_sentence(sentence): Rearranges the words in the sentence such that all words are sorted in increasing order of their lengths. If two words have the same length, they appear in the order they were found in the original sentence. :param sentence: str, a sentence where words are separated by spaces :return: str, a sentence with words sorted by length # Split the sentence into words words = sentence.split() # Sort the words by length and maintain the original order sorted_words = sorted(words, key=len) # Join the sorted words back into a sentence return \' \'.join(sorted_words)"},{"question":"Given an integer array `arr`, you need to determine if the array is \\"mountain-shaped.\\" An array is considered mountain-shaped if it: 1. Contains at least 3 elements. 2. There exists some index `i` (0 < i < arr.length - 1) such that: - arr[0] < arr[1] < ... < arr[i] - arr[i] > arr[i + 1] > ... > arr[arr.length - 1] Return `true` if the array is mountain-shaped, otherwise return `false`.","solution":"def is_mountain(arr): Returns True if the array is mountain-shaped, otherwise returns False. n = len(arr) if n < 3: return False i = 0 # climb up while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # peak can\'t be first or last if i == 0 or i == n - 1: return False # climb down while i + 1 < n and arr[i] > arr[i + 1]: i += 1 return i == n - 1"},{"question":"You are given an array of integers `arr` and an integer `k`. You must divide the array into exactly `k` contiguous subarrays, and the score of this division is the sum of the maximum values of each subarray. Write a function to calculate the maximum possible score you can achieve from this division.","solution":"def max_subarray_score(arr, k): Calculate the maximum possible score by dividing the array into k contiguous subarrays. The score is the sum of the maximum values of each subarray. :param arr: List[int] - The array of integers :param k: int - The number of contiguous subarrays :return: int - The maximum possible score n = len(arr) if k > n: return -1 # Impossible to divide into more subarrays than elements # dp[i][j] will be the maximum score using the first i elements and j subarrays dp = [[float(\'-inf\')] * (k + 1) for _ in range(n + 1)] # Initialize dp for 0 subarrays for i in range(n + 1): dp[i][0] = 0 # Fill dp array for j in range(1, k + 1): for i in range(j, n + 1): local_max = float(\'-inf\') for l in range(i, j - 1, -1): local_max = max(local_max, arr[l - 1]) dp[i][j] = max(dp[i][j], dp[l - 1][j - 1] + local_max) return dp[n][k]"},{"question":"Given a string `s`, consisting of lowercase English letters with a maximum length of 10^5, and an integer `k`, return the length of the longest substring of `s` that contains at most `k` distinct characters. You should strive to achieve a time complexity better than O(n^2), where `n` is the length of the string `s`.","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring in `s` that contains at most `k` distinct characters. :param s: The input string consisting of lowercase English letters :param k: The maximum number of distinct characters allowed in the substring :return: The length of the longest substring with at most `k` distinct characters if k == 0 or not s: return 0 left = 0 max_length = 0 char_frequency = {} for right in range(len(s)): char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` consisting of characters \'0\' and \'1\' only. A binary substring is any substring that contains \'0\' and \'1\' with equal occurrences. Find the **maximum length** of the binary substring in `s` that meets this criterion. If there is no such substring, return 0.","solution":"def max_length_binary_substring(s): Returns the maximum length of the binary substring with equal occurrences of \'0\' and \'1\'. max_length = 0 count = 0 count_dict = {0: -1} for i, char in enumerate(s): if char == \'1\': count += 1 else: count -= 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"You are given a `tree` consisting of `n` nodes numbered from `0` to `n-1` and `n-1` edges. The root of the tree is node `0`, and each node has a label represented by a character string `labels` of length `n`. You need to implement a function `countSubTrees` that returns an array of size `n`, where `countSubTrees[i]` is the number of nodes in the subtree rooted at the `i-th` node which have the same label as node `i`. To implement this, you should: - Create a function `countSubTrees(int n, int[][] edges, String labels)`. - The `edges` parameter is a 2D array where each element represents an undirected edge between two nodes. - The `labels` parameter is a string where `labels[i]` is the label of the `i-th` node. Example: ``` Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \\"abaedcd\\" Output: [2,1,1,1,1,1,1] Explanation: - The subtree of node 0 contains nodes 0, 1, 2, 4, 5, 3, and 6 with labels \'a\', \'b\', \'a\', \'e\', \'d\', \'c\', \'d\'. - The subtree of node 1 contains nodes 1, 4, 5 with labels \'b\', \'e\', \'d\'. - The subtree of node 2 contains nodes 2, 3, 6 with labels \'a\', \'c\', \'d\' and so on. ``` Implement the `countSubTrees` function in such a way that it processes the tree efficiently and returns the correct count for each node.","solution":"from collections import defaultdict, Counter def countSubTrees(n, edges, labels): def dfs(node, parent): count = Counter() for child in graph[node]: if child == parent: continue count.update(dfs(child, node)) count[labels[node]] += 1 result[node] = count[labels[node]] return count graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) result = [0] * n dfs(0, -1) return result"},{"question":"Given an array of integers `arr` and an integer `k`, return _all the unique quadruples `[a, b, c, d]` such that `a + b + c + d = k`._ Each quadruple should be sorted in non-decreasing order and the result should be returned in sorted order based on the first element of each quadruple. If there are multiple quadruples with the same first element, sort them based on the second element, and so on. Ensure no duplicate quadruples are returned.","solution":"def four_sum(arr, k): arr.sort() n = len(arr) quadruples = set() for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == k: quadruples.add((arr[i], arr[j], arr[left], arr[right])) left += 1 right -= 1 elif total < k: left += 1 else: right -= 1 return sorted(quadruples)"},{"question":"You are given an array of strings `words` and an integer `k`. Each string consists of exactly `k` characters in the range `[\'a\', \'z\']`. A shift on a string means replacing each character by the next one in the alphabet (with \'z\' shifting to \'a\'). For example, a shift on `\\"abc\\"` results in `\\"bcd\\"`. Write a function that returns an array of strings where each string in the result represents the given string shifted by the corresponding number of times from `1` up to `k` times. For example, if the input array is `[\\"abc\\", \\"xyz\\"]` and `k=2`, the output should be `[\\"bca\\", \\"yzx\\", \\"cab\\", \\"zab\\"]`.","solution":"def shift_string(word, k): Shifts the characters in the word k times. shifted = [] for char in word: shifted.append(chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\'))) return \'\'.join(shifted) def shift_strings(words, k): Returns an array of strings where each string is shifted from 1 to k times. result = [] for word in words: for shift in range(1, k + 1): result.append(shift_string(word, shift)) return result"},{"question":"A company is organizing a team-building event where employees will form teams to solve a series of challenges. The event is structured such that employees are assigned to teams based on their skill levels. You are given an integer array `skills` where each element represents the skill level of an employee. Additionally, you are given an integer `t` which represents the required team size. A team is considered **balanced** if the difference between the highest and lowest skill levels in the team does not exceed a predefined threshold `d`. Your task is to determine the **maximum number of balanced teams** that can be formed from the employees. Return _the **maximum number of balanced teams** that can be formed. If no balanced teams can be formed, return `0`._","solution":"def max_balanced_teams(skills, t, d): Determines the maximum number of balanced teams that can be formed. A team is balanced if the difference between the highest and lowest skill levels in the team does not exceed `d`. Parameters: skills (list of int): Array of employee skill levels. t (int): Required team size. d (int): Skill threshold for team to be balanced. Returns: int: Maximum number of balanced teams. if not skills or t == 0: return 0 skills.sort() n = len(skills) teams = 0 i = 0 while i <= n - t: j = i + t - 1 if skills[j] - skills[i] <= d: teams += 1 i += t else: i += 1 return teams"},{"question":"You are given a list of integers `nums` and a list of integer pairs `operations` where each pair `[a, b]` indicates an operation of replacing the integer `a` in the list `nums` with the integer `b`. Perform all the given operations on the list sequentially. Return the modified list after performing all the operations. If an integer specified in an operation does not exist in the list, skip that operation. Example: ```plaintext Input: nums = [1, 2, 3, 4, 5], operations = [[1, 10], [2, 20], [6, 60], [3, 30]] Output: [10, 20, 30, 4, 5] ```","solution":"def modify_list(nums, operations): Modify the list `nums` by replacing integers based on the `operations` provided. Args: nums: List of integers to be modified. operations: List of pairs [a, b] where each pair indicates replacing integer `a` in `nums` with integer `b`. Returns: A list where all specified operations are performed sequentially. for a, b in operations: if a in nums: index = nums.index(a) nums[index] = b return nums"},{"question":"You are given a binary array `nums`, where a `1` represents a wall, and a `0` represents an open space. You are also given a start position `start` (a tuple of two integers representing the row and column, respectively) and an end position `end` (similarly a tuple). Write a function to determine the minimum number of moves required to travel from the start to the end. You can only move up, down, left, or right, and you cannot pass through walls (i.e., through `1`s). If there is no valid path from start to end, return `-1`.","solution":"from collections import deque def min_moves(nums, start, end): Returns the minimum number of moves required to travel from start to end. If no path, returns -1. rows, cols = len(nums), len(nums[0]) sr, sc = start er, ec = end if nums[sr][sc] == 1 or nums[er][ec] == 1: return -1 queue = deque([(sr, sc, 0)]) # (row, col, distance) visited = set((sr, sc)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and nums[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a street. The view of these buildings is from left to right. A building\'s view is **blocked** if there is at least one building taller or of the same height to its right. Return _an array containing the indices of the buildings that are not blocked_.","solution":"def buildings_with_view(heights): Returns the indices of the buildings that are not blocked. n = len(heights) if n == 0: return [] result = [] max_height_from_right = -1 for i in range(n-1, -1, -1): if heights[i] > max_height_from_right: result.append(i) max_height_from_right = heights[i] return result[::-1]"},{"question":"Given a matrix `mat` of integers with `m` rows and `n` columns, return an array containing the elements of the matrix in spiral order, starting from the top-left corner. The spiral order starts from the first element of the top row and proceeds clockwise, navigating through the outermost elements towards the center of the matrix. If there are multiple layers, each layer should be considered in turn. Write a function `spiralOrder` that takes a matrix `mat` as input and returns the resulting array in spiral order.","solution":"def spiralOrder(mat): if not mat or not mat[0]: return [] res = [] m, n = len(mat), len(mat[0]) top, left, bottom, right = 0, 0, m - 1, n - 1 while top <= bottom and left <= right: # Traverse from left to right for j in range(left, right + 1): res.append(mat[top][j]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): res.append(mat[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for j in range(right, left - 1, -1): res.append(mat[bottom][j]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): res.append(mat[i][left]) left += 1 return res"},{"question":"You are given a directed graph with `n` nodes labeled from `1` to `n`. Each node has an associated integer value. You are to find the **longest path** in the graph such that the sequence of values along this path is **strictly increasing**. The graph is represented as an array of edges, where each edge is a pair `[ui, vi]` indicating a directed edge from node `ui` to node `vi`. Additionally, you are given an array `values` where `values[i]` represents the integer value associated with node `i+1`. Return _the length of the longest path with strictly increasing values_. If there is no such path, return `0`.","solution":"from collections import defaultdict from functools import lru_cache def longest_increasing_path(n, edges, values): def dfs(node): if dp[node] != -1: # if already computed, no need to recompute return dp[node] max_length = 1 for neighbor in graph[node]: if values[neighbor] > values[node]: # strictly increasing condition max_length = max(max_length, 1 + dfs(neighbor)) dp[node] = max_length return dp[node] # Build the graph graph = defaultdict(list) for u, v in edges: graph[u - 1].append(v - 1) dp = [-1] * n # memoization for the longest path from each node max_path = 0 for node in range(n): max_path = max(max_path, dfs(node)) return max_path"},{"question":"Given a `string` containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. The digit to letter mapping can be found on a traditional phone keypad: 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" Consider the situation where a digit does not map to any letters (for example: \'1\' or \'0\'), the returned result should be an empty list. Provide a function that generates all possible letter combinations that the number could represent in lexicographical order.","solution":"def letter_combinations(digits): if not digits: return [] phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map.get(digits[index], \'\') for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"You are given two arrays of integers, `arr1` and `arr2`, of the same length `n`. You need to form a new array `result` of length `n` where each element in `result` is defined as follows: [ text{result}[i] = (text{arr1}[i] + text{arr2}[i]) , % , 10 ] Your task is to return the array `result`.","solution":"def sum_and_mod_arrays(arr1, arr2): Given two arrays of integers arr1 and arr2 of the same length, returns a new array where each element is (arr1[i] + arr2[i]) % 10. n = len(arr1) result = [(arr1[i] + arr2[i]) % 10 for i in range(n)] return result"},{"question":"Given a binary matrix `mat` of size `m x n`, where each element is either 0 or 1, find the largest square containing only 1\'s and return its area. The square must have its sides strictly aligned with the row and column axes of the matrix.","solution":"def maximalSquare(matrix): Given a binary matrix of size m x n, finds the largest square containing only 1\'s and returns its area. :param matrix: List[List[int]], 2D list representing binary matrix. :return: int, area of the largest square containing only 1\'s. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Using dp to store maximum side length of square ending at (i, j) dp = [[0] * n for _ in range(m)] max_side_length = 0 for i in range(m): for j in range(n): if matrix[i][j] == \'1\': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length * max_side_length"},{"question":"You are given a 2D grid of size `m x n`, where each cell represents a plot of land with a value of `0` (empty) or `1` (land) or `2` (obstacle). A river can start from any \\"1\\" cell and flows to its adjacent cells (horizontally or vertically) until it reaches an edge of the grid, another \\"1\\" cell, or a \\"2\\" cell. Determine the maximum area of such a river. A river\'s area is defined as the number of \\"1\\" cells it flows through. Note that rivers cannot flow diagonally. Return the maximum river area. If theres no river, return 0. **Example:** ``` Input: grid = [[1, 0, 0, 0, 1], [1, 1, 0, 2, 0], [0, 1, 0, 1, 1], [1, 0, 0, 0, 1]] Output: 4 ```","solution":"def max_river_area(grid): Determine the maximum area of such a river in the given grid. :param grid: List[List[int]] - 2D list where each element can be 0, 1, or 2. :return: int - Maximum area of the river. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 1: return 0 grid[x][y] = -1 # Mark as visited area = 1 # Current cell # Check all four possible directions area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given two strings `s1` and `s2` consisting only of lowercase English letters. Your task is to determine the minimum number of operations required to convert string `s1` into `s2`. The allowed operation is to remove any character from `s1`. The resulting string after all removals must be a subsequence of `s2`. Return the minimum number of operations required to achieve this or `-1` if it is impossible.","solution":"def min_operations_to_convert(s1, s2): Returns the minimum number of operations required to convert s1 into a subsequence of s2. Only removals are allowed to convert s1. Parameters: s1 (str): String to be converted. s2 (str): Target string. Returns: int: Minimum number of operations required or -1 if impossible. # Track the index of characters in s2 using a dictionary s2_char_indices = {} for i, char in enumerate(s2): if char not in s2_char_indices: s2_char_indices[char] = [] s2_char_indices[char].append(i) # Initialize current index in s2 current_index = -1 for char in s1: if char not in s2_char_indices: # s1 has a character not in s2, it\'s impossible return -1 # Try to find the next occurrence of char in s2 valid_indices = [index for index in s2_char_indices[char] if index > current_index] if not valid_indices: # No valid index found, conversion is not possible return -1 # Move the current_index to the found valid index current_index = valid_indices[0] # The remaining length to remove from s1 return len(s1)"},{"question":"Given an integer array `nums` and an integer `k`, return _the count of distinct elements in every subarray of length `k`_. If the length of `nums` is less than `k`, return an empty list.","solution":"def count_distinct_elements(nums, k): Returns a list of counts of distinct elements in every subarray of length k. If the length of nums is less than k, returns an empty list. if len(nums) < k: return [] result = [] current_window = {} distinct_count = 0 for i in range(len(nums)): if nums[i] in current_window: current_window[nums[i]] += 1 else: current_window[nums[i]] = 1 distinct_count += 1 if i >= k - 1: result.append(distinct_count) left_elem = nums[i - k + 1] if current_window[left_elem] == 1: del current_window[left_elem] distinct_count -= 1 else: current_window[left_elem] -= 1 return result"},{"question":"You are given a **0-indexed** integer array `tasks` where `tasks[i]` represents the time it takes to complete the `i-th` task. You have one worker who can only perform tasks sequentially. A worker can take a break of any length after completing a task, and it takes `rest` minutes of rest time before starting a new task. The worker must complete all tasks in the given order. Calculate and return _the minimum total time_ needed for the worker to finish all the tasks, considering the rest time between consecutive tasks.","solution":"def min_total_time(tasks, rest): Calculate the minimum total time required to complete all tasks sequentially with given rest time between each task. Parameters: tasks (list of int): List of times each task takes to complete. rest (int): Rest time between consecutive tasks. Returns: int: The minimum total time to complete all tasks. if not tasks: return 0 # Initial time is the time for the first task total_time = tasks[0] # Add the time for subsequent tasks including the rest times for i in range(1, len(tasks)): total_time += rest + tasks[i] return total_time"},{"question":"You are given a binary search tree (BST) with `n` nodes. Your task is to find the in-order predecessor of a given target node in this BST. An in-order predecessor of a node is the previous node in the inorder traversal of the BST. If the target node has no in-order predecessor, return `null`. You are given a function signature: ```python def inorder_predecessor(root: TreeNode, target: TreeNode) -> TreeNode: ``` Here, `TreeNode` class structure is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Return the in-order predecessor of the target node in the given BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_predecessor(root: TreeNode, target: TreeNode) -> TreeNode: predecessor = None current = root while current: if target.val > current.val: predecessor = current current = current.right else: current = current.left return predecessor"},{"question":"Given a string `s` consisting of only characters \'a\' and \'b\', write a function `removeAdjacentDuplicates(String s)` that returns the string after removing all possible adjacent duplicate characters in a single pass. For example, if `s = \\"abbaca\\"`, the function would return `ca` since: - The first pass removes the adjacent duplicates \'bb\', resulting in the string `aaca`. - The second pass removes the adjacent duplicates \'aa\', resulting in the string `ca`. Note that no character in the resulting string has any adjacent duplicates.","solution":"def removeAdjacentDuplicates(s): Removes all adjacent duplicates from the string s. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"Given an array `arr` of integers and an integer `m`, your task is to split the array into `m` contiguous subarrays, such that the largest sum among these subarrays is minimized. Return _this minimized largest sum_. **Notes:** * The given array will always have at least `m` elements. * Each element represents a non-negative integer. * Your goal is to determine the most balanced way to split the array, ensuring that the sum of elements in the subarrays is as even as possible.","solution":"def splitArray(arr, m): def canSplit(mid): current_sum = 0 number_of_subarrays = 1 for number in arr: if current_sum + number > mid: number_of_subarrays += 1 current_sum = number if number_of_subarrays > m: return False else: current_sum += number return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `arr` of length `n` where each element represents the amount of time it takes to complete a task. You are also given an integer `k` which represents the maximum number of tasks you can perform consecutively before needing a break. You need to determine the maximum number of tasks you can complete within a given total time `totalTime`. Each task must be completed in one go; you cannot split a task across multiple work sessions. Given `arr`, `k`, and `totalTime`, return the maximum number of tasks that can be completed. # Example: **Input:** `arr = [2, 1, 3, 2]`, `k = 2`, `totalTime = 5` **Output:** `2` **Explanation:** You can complete the tasks taking 2 and 1 time units consecutively in the first session, reaching a total time of 3. With the remaining time of 2, you can only complete one more task of 2 units. Thus, the maximum number of tasks completed is 2.","solution":"def max_tasks(arr, k, totalTime): Determines the maximum number of tasks that can be completed within given total time. Args: arr : List[int] - list of integers where each element represents the time of a task. k : int - maximum number of tasks that can be performed consecutively before needing a break. totalTime : int - the limit of total time in which tasks can be performed. Returns: int : maximum number of tasks that can be completed. arr.sort() # Sort the tasks based on time required tasks_completed = 0 current_time_used = 0 for i in range(len(arr)): if tasks_completed < k and current_time_used + arr[i] <= totalTime: current_time_used += arr[i] tasks_completed += 1 else: break return tasks_completed"},{"question":"You are given a list of `n` network events where each event is represented as a pair `(a, b)` indicating that node `a` initiated a connection to node `b`. Each node can only have one outgoing connection at any given time. If a node initiates a new connection while already having an active one, the previous connection is overridden. Write a function to return a list of isolated clusters in the network after processing all events. A cluster is defined as a set of nodes that are directly or indirectly connected to each other but not connected to any other nodes in the network. Each cluster should be returned as a sorted list of node identifiers. The list of clusters should be sorted in increasing order of the smallest node identifier in each cluster.","solution":"def find_clusters(events): from collections import defaultdict, deque # Build adjacency list adj = defaultdict(list) for a, b in events: adj[a].append(b) adj[b].append(a) # because connections are bidirectional def bfs(node): # Perform BFS to find all nodes in the same cluster visited = set([node]) queue = deque([node]) cluster = [] while queue: current = queue.popleft() cluster.append(current) for neighbor in adj[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited, sorted(cluster) visited_nodes = set() clusters = [] # Find all clusters for node in adj.keys(): if node not in visited_nodes: visited, cluster = bfs(node) visited_nodes.update(visited) clusters.append(cluster) # Sort clusters by the smallest node in each cluster clusters.sort(key=lambda x: x[0]) return clusters"},{"question":"Given a list of `n` integers `nums` representing the number of coins in `n` piles, where all `n` piles are initially unordered, return _the minimum number of moves required to make all piles equal by either taking one coin from a pile or adding one coin to a pile at each move._ You may assume that it is always possible to equalize the coin counts of all piles.","solution":"def min_moves_to_equalize_piles(nums): Returns the minimum number of moves required to make all piles equal by either taking one coin from a pile or adding one coin to a pile at each move. # Find the median value; this minimizes the total moves required nums.sort() median = nums[len(nums) // 2] # Sum the absolute differences between each pile and the median min_moves = sum(abs(num - median) for num in nums) return min_moves"},{"question":"Given the `root` of a binary tree, return _the **inorder traversal** of its nodes\'_ _values_. You may not use recursion in your solution. The logic should explicitly rely on an iterative approach that simulates the process using a stack._","solution":"def inorderTraversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values. Uses an iterative approach with a stack. :param root: TreeNode :return: List[int] res, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() res.append(current.val) current = current.right return res"},{"question":"You are given a list of `n` integers `heights` representing the heights of buildings arranged on a straight line. The goal is to **trap** as much rainwater between the buildings as possible. Write a function that calculates the maximum amount of rainwater that can be trapped after it rains. Your function should take a list of integers `heights` as input and return an integer representing the maximum amount of trapped rainwater.","solution":"def trap(heights): Calculate the maximum amount of rainwater that can be trapped :param heights: List[int], a list of non-negative integers representing the heights of buildings :return: int, the maximum amount of trapped rainwater n = len(heights) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given a list of `n` integers `nums`, where each element in the list represents a different length of rope. Your task is to determine the maximum number of ropes of length `k` that can be created out of the given ropes. You can cut any rope into smaller ropes, but you cannot combine ropes. Return _the maximum number of ropes of length `k` that can be created._","solution":"def max_ropes_of_length_k(nums, k): Calculate the maximum number of ropes of length k that can be created from the given list of ropes `nums`. Args: nums (list of int): List of ropes of different lengths. k (int): Desired length of each new rope. Returns: int: Maximum number of ropes of length k that can be created. if k <= 0: return 0 # If k is zero or negative, we cannot create any ropes. total_ropes = 0 for length in nums: total_ropes += length // k return total_ropes"},{"question":"You are given a circular array of integers `nums` where `nums[i]` is the height of the candle at index `i`. A circular array means the end of the array connects to the beginning of the array, forming a circle. You can rearrange the candles in a different order and start lighting them from any position you choose. Each time you light a candle, the candles next to it (both left and right) decreases in height by one unit due to the melting process. Determine the maximum number of candles you can light until at least one candle height in the array becomes zero.","solution":"def max_candles_to_light(candles): Determine the maximum number of candles you can light until at least one candle height in the array becomes zero. Args: candles (list): A list of integers representing candle heights. Returns: int: The maximum number of candles you can light. if not candles: return 0 min_height = min(candles) # The maximum number of candles that can be lit is the initial minimum height of any candle. return min_height"},{"question":"Given a string `s` consisting of uppercase letters and a target string `target`, find out the minimum number of times the target string must be repeated such that `target` becomes a substring of `s`. If it is impossible for `target` to become a substring of `s` in any number of repetitions, return -1.","solution":"def min_repeats_to_substring(s, target): Returns the minimum number of times the target string must be repeated such that target becomes a substring of s. If it is impossible, returns -1. repeated_s = s repeat_count = 1 while len(repeated_s) < 2 * len(target) + len(s) - 1: if target in repeated_s: return repeat_count repeated_s += s repeat_count += 1 return -1"},{"question":"Design and implement a data structure that allows for the following operations on a list of integers: 1. `addElement(x)`: Add an integer `x` to the list. 2. `findElement(x)`: Check if integer `x` is present in the list. Returns `true` if found, otherwise `false`. 3. `deleteElement(x)`: Remove integer `x` from the list if it is present. 4. `getRandom()`: Return a random element from the list (each element should have the same probability of being returned). Your implementation should ensure that all operations are performed in average O(1) time complexity.","solution":"import random class RandomizedSet: def __init__(self): self.data_list = [] self.data_dict = {} def addElement(self, x: int) -> bool: if x in self.data_dict: return False self.data_dict[x] = len(self.data_list) self.data_list.append(x) return True def findElement(self, x: int) -> bool: return x in self.data_dict def deleteElement(self, x: int) -> bool: if x in self.data_dict: last_element = self.data_list[-1] idx_to_replace = self.data_dict[x] self.data_list[idx_to_replace] = last_element self.data_dict[last_element] = idx_to_replace self.data_list.pop() del self.data_dict[x] return True return False def getRandom(self) -> int: return random.choice(self.data_list)"},{"question":"Given an integer array `nums`, return _the maximum sum of a **non-empty coast-hugging subarray** of_ `nums`. A coast-hugging subarray is defined as a contiguous subarray that touches either the first or the last element of the array. Note: A contiguous subarray is a subarray where the elements are next to each other, in their original order.","solution":"def max_coast_hugging_subarray(nums): n = len(nums) if n == 1: return nums[0] # Calculate maximum subarray sum touching the first element max_sum_from_start = float(\'-inf\') current_sum = 0 for i in range(n): current_sum += nums[i] max_sum_from_start = max(max_sum_from_start, current_sum) # Calculate maximum subarray sum touching the last element max_sum_from_end = float(\'-inf\') current_sum = 0 for i in range(n-1, -1, -1): current_sum += nums[i] max_sum_from_end = max(max_sum_from_end, current_sum) return max(max_sum_from_start, max_sum_from_end)"},{"question":"Given a binary matrix `grid` where `0` represents water and `1` represents land, an island is a maximal group of `1`s connected in 4-direction (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Return the **smallest island** in the grid. If there is no land, return `0`. The size of an island is the number of `1`s in the island.","solution":"def smallest_island(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1) min_island_size = float(\'inf\') found_island = False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: found_island = True island_size = dfs(i, j) if island_size < min_island_size: min_island_size = island_size return min_island_size if found_island else 0"},{"question":"Given a 2D grid of size `m x n` consisting of non-negative integers, write a function to find _the maximum sum of a submatrix which is no larger than a given integer_ `k`. The submatrix must be a rectangle consisting of rows and contiguous columns within the grid. Return the maximum sum of the submatrix, or 0 if no such submatrix exists.","solution":"import bisect def max_sum_submatrix(matrix, k): Finds the maximum sum of a submatrix which does not exceed k. if not matrix or not matrix[0]: return 0 def max_sum_subarray(arr, k): sorted_sum = [0] curr_sum = 0 max_sum = float(\'-inf\') for sum_end in arr: curr_sum += sum_end idx = bisect.bisect_left(sorted_sum, curr_sum - k) if idx < len(sorted_sum): max_sum = max(max_sum, curr_sum - sorted_sum[idx]) bisect.insort(sorted_sum, curr_sum) return max_sum m, n = len(matrix), len(matrix[0]) result = float(\'-inf\') for left in range(n): row_sum = [0] * m for right in range(left, n): for i in range(m): row_sum[i] += matrix[i][right] current_max = max_sum_subarray(row_sum, k) result = max(result, current_max) return result if result != float(\'-inf\') else 0"},{"question":"Given a string `s` representing a sentence, return the length of the shortest word in the sentence. A word is defined as a sequence of non-space characters. The input sentence will contain only lowercase and uppercase English letters and spaces. Ensure the function has a time complexity of `O(n)`, where `n` is the length of the input string.","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the given sentence. :param s: A string representing a sentence containing words separated by spaces. :return: An integer representing the length of the shortest word in the sentence. words = s.split() if not words: return 0 return min(len(word) for word in words)"},{"question":"You are given a list of `n` integers `nums` where each integer can be either positive, negative, or zero. Implement a function `int[] productExceptSelf(int[] nums)` that returns an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The function must be implemented without using division and should have a time complexity of O(n).","solution":"def product_except_self(nums): Returns an array such that answer[i] is equal to the product of all the elements of nums except nums[i]. length = len(nums) answer = [1] * length # Calculate left product for each element left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate right product for each element and multiply with the corresponding left product right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n-1`, and a list of `edges` where each `edge` is represented as a pair `[u, v]` indicating a directed edge from node `u` to node `v`, return the number of possible **topological sorts** of the DAG. A topological sort of a directed graph is a linear ordering of its nodes such that for every directed edge `u` to `v`, node `u` appears before node `v` in the ordering.","solution":"from itertools import permutations def num_topological_sorts(n, edges): Returns the number of possible topological sorts for a given DAG. Parameters: n (int): Number of nodes in the DAG. edges (list): List of directed edges represented as pairs [u, v]. Returns: int: Number of possible topological sorts. def is_topological(permutation, edges): index = {node: i for i, node in enumerate(permutation)} for u, v in edges: if index[u] > index[v]: return False return True nodes = [i for i in range(n)] count = 0 for perm in permutations(nodes): if is_topological(perm, edges): count += 1 return count"},{"question":"You are given a **0-indexed** array of integers `heights` representing the heights of buildings and an integer `bricks` representing the number of bricks you have. You need to jump from building to building in a linear order starting from the first building. You can jump to the next building if the height difference is less than or equal to the remaining bricks you have. If the required bricks are less than or equal to the bricks you have, you use the bricks to make the jump, otherwise, you cannot jump to that building. Return _the maximum number of buildings you can reach by jumping from one to the next using the bricks you have_.","solution":"def furthest_building(heights, bricks): Returns the maximum number of buildings that can be reached using the bricks. :param heights: List[int], the heights of the buildings :param bricks: int, the number of bricks available :return: int, the number of buildings that can be reached num_buildings = len(heights) for i in range(1, num_buildings): height_diff = heights[i] - heights[i - 1] if height_diff <= 0: continue if height_diff <= bricks: bricks -= height_diff else: return i - 1 return num_buildings - 1"},{"question":"Given an array of integers `arr` and an integer `t`, return the indices of the two numbers such that they add up to `t`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Your solution should have a linear runtime complexity.","solution":"def two_sum(arr, t): Returns the indices of the two numbers in the array `arr` such that they add up to `t`. Parameters: arr (list): A list of integers. t (int): The target sum. Returns: list: A list containing the indices of the two numbers. num_map = {} # To store number and its index for index, num in enumerate(arr): complement = t - num if complement in num_map: return [num_map[complement], index] num_map[num] = index # Raise an exception if there is no solution raise ValueError(\\"No two sum solution\\")"},{"question":"Given an integer `n`, representing the size of a cave system composed of n nodes, and a list of connections where each connection is a tuple `[a, b]` representing a tunnel that connects nodes `a` and `b`. The tunnels can be traversed in any direction. You need to implement a class called `CaveSystem` with the following methods: - `CaveSystem(int n, List<List<Integer>> connections)`: Initializes the cave system with `n` nodes and the specified list of connections. - `boolean hasPath(int start, int end)`: Checks if there is a path from node `start` to node `end`. Returns `true` if a path exists, otherwise returns `false`. - `List<Integer> shortestPath(int start, int end)`: Returns the shortest path from node `start` to node `end` as a list of node indices. If there is no path, returns an empty list. - `void addConnection(int a, int b)`: Adds a new tunnel connecting nodes `a` and `b`. Example: 1. `CaveSystem c = new CaveSystem(5, [[0, 1], [1, 2], [2, 3], [3, 4]])` 2. `c.hasPath(0, 4)` returns `true` 3. `c.shortestPath(0, 4)` returns `[0, 1, 2, 3, 4]` 4. `c.addConnection(4, 1)` 5. `c.hasPath(4, 0)` returns `true`","solution":"from collections import deque, defaultdict class CaveSystem: def __init__(self, n, connections): self.n = n self.graph = defaultdict(list) for a, b in connections: self.graph[a].append(b) self.graph[b].append(a) def hasPath(self, start, end): if start == end: return True visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == end: return True for neighbor in self.graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False def shortestPath(self, start, end): if start == end: return [start] visited = set() queue = deque([(start, [start])]) while queue: node, path = queue.popleft() for neighbor in self.graph[node]: if neighbor == end: return path + [end] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] def addConnection(self, a, b): self.graph[a].append(b) self.graph[b].append(a)"},{"question":"Given an unsorted integer array, determine the length of the longest consecutive elements sequence. A consecutive sequence is an unbroken sequence of integers, for instance, the array `[100, 4, 200, 1, 3, 2]` has a longest consecutive subsequence `[1, 2, 3, 4]`, which is of length 4. _Your task is to return the length of such longest consecutive subsequence._","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in an unsorted integer array. :param nums: List[int] - an unsorted list of integers :return: int - the length of the longest consecutive sequence if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_streak = 1 current_num = num while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"The International Space Station (ISS) is equipped with a powerful computer system that continuously records various measurements. One of the arrays onboard contains temperature readings taken every minute. Given an array `temps` of integers where `temps[i]` is the temperature reading at the `i-th` minute, your task is to determine the **longest contiguous subarray** where the temperature readings are non-decreasing. In other words, find the length of the longest subarray such that for every consecutive pair of indices `i` and `j` in the subarray, if `i < j` then `temps[i] <= temps[j]`. Return _the length of this longest subarray_.","solution":"def longest_non_decreasing_subarray(temps): Returns the length of the longest contiguous subarray where the temperature readings are non-decreasing. if not temps: return 0 max_length = 1 current_length = 1 for i in range(1, len(temps)): if temps[i] >= temps[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a `root` of a binary tree. A node X in the binary tree is named \'good\' if in the path from the `root` to X there are no nodes with a value greater than X\'s value. Return the number of \'good\' nodes in the binary tree. A binary tree node is defined as: ```py class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root: TreeNode) -> int: def dfs(node, max_val): if not node: return 0 good = 1 if node.val >= max_val else 0 max_val = max(max_val, node.val) good += dfs(node.left, max_val) good += dfs(node.right, max_val) return good return dfs(root, float(\'-inf\'))"},{"question":"You are given a **0-indexed** array `inbox` of `n` integers where `inbox[i]` represents the number of new emails received on day `i`. You can perform any of the following operations on the `inbox`: * Read all emails received on a particular day. If you choose to read emails on day `i`, you will read all `inbox[i]` emails and can then proceed to the next day. * Archive all emails received on a particular day. If you choose to archive emails on day `i`, they are moved to a separate folder and are not to be read in any future operation, and you can then proceed to the next day. * Skip a day without reading or archiving any emails. You can then proceed to the next day. The goal is to find the **minimum number of operations** needed to ensure there are no remaining unprocessed emails by the end of day `n-1`. Return _the minimum number of operations required to process all emails in the `inbox`_.","solution":"def min_operations(inbox): operations = 0 n = len(inbox) # Count non-zero days for i in range(n): if inbox[i] > 0: operations += 1 return operations"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function to perform this rotation without using extra space for another array. For example, if the array is `[1, 2, 3, 4, 5, 6, 7]` and `k` is `3`, the array should become `[5, 6, 7, 1, 2, 3, 4]` after rotating it 3 steps to the right.","solution":"def rotate(nums, k): Rotates the array `nums` to the right by `k` steps in-place. Parameters: nums (List[int]): The input array of integers. k (int): The number of steps to rotate the array. Returns: None n = len(nums) k %= n reverse(nums, 0, n - 1) reverse(nums, 0, k - 1) reverse(nums, k, n - 1) def reverse(nums, start, end): Reverses the elements of nums from index `start` to `end` in-place. Parameters: nums (List[int]): The input array of integers. start (int): The starting index for the reverse operation. end (int): The ending index for the reverse operation. Returns: None while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1"},{"question":"You are given an `m x n` matrix `grid` consisting of non-negative integers. You can move from any cell to any adjacent cell (up, down, left, right) if the height of the destination cell is less than or equal to the current cells height plus one. The height of a cell is given by the value at that cell in the matrix. Your task is to find the minimum number of moves required to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0). If it is not possible to reach the destination cell, return -1.","solution":"from collections import deque def minimum_moves(grid): Returns the minimum number of moves to reach the bottom-right cell from the top-left cell, or -1 if not possible. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() if x == m - 1 and y == n - 1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] <= grid[x][y] + 1: queue.append((nx, ny, moves + 1)) visited.add((nx, ny)) return -1"},{"question":"A robot is located at the top-left corner of a `m x n` grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (i.e., grid[m-1][n-1]). However, there are obstacles on the grid, represented by `1s` (indicating an obstacle) and `0s` (indicating a free space). Given the grid as a 2D array of integers, return the number of unique paths that the robot can take to reach the bottom-right corner. If it\'s impossible for the robot to reach the destination, return 0. Each step that the robot takes should only move it either down or right. The complexity of the solution should respect the constraints of the grid size and number of obstacles.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths for a robot to reach the bottom-right corner of a grid avoiding obstacles. The robot can only move either down or right. :param grid: List[List[int]] 2D array where 1 represents obstacles and 0 represents free space. :return: int Number of unique paths from top-left to bottom-right avoiding obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 # Fill the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j - 1] else: dp[0][j] = 0 # Fill the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i - 1][0] else: dp[i][0] = 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"You are given `n` islands numbered from `0` to `n-1`, some of which are connected by bidirectional bridges. You are also given an array `bridges`, where `bridges[i]` is a tuple `(u_i, v_i)` representing a bridge connecting islands `u_i` and `v_i`. An island is considered isolated if there are no other islands directly connected to it by a bridge. Find the number of isolated islands.","solution":"def count_isolated_islands(n, bridges): Returns the number of isolated islands. if n == 0: return 0 connected = [False] * n for u, v in bridges: connected[u] = True connected[v] = True isolated_count = 0 for i in range(n): if not connected[i]: isolated_count += 1 return isolated_count"},{"question":"You are given a binary tree where each node contains an integer value. Write a function that returns the maximum average value of any subtree in the given binary tree. A subtree of the tree is any node and all its descendants. The average value of a subtree is the sum of all its node values divided by the number of nodes in the subtree. Return the maximum average value as a floating-point number. Function signature: `def maximum_average_subtree(root: TreeNode) -> float` Consider defining the necessary data structures and functions required to solve the problem if they are not provided. For example, the `TreeNode` class if necessary.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maximum_average_subtree(root: TreeNode) -> float: max_avg = float(\'-inf\') def helper(node): nonlocal max_avg if not node: return (0, 0) # (sum, count) left_sum, left_count = helper(node.left) right_sum, right_count = helper(node.right) total_sum = left_sum + right_sum + node.val total_count = left_count + right_count + 1 current_avg = total_sum / total_count max_avg = max(max_avg, current_avg) return total_sum, total_count helper(root) return max_avg"},{"question":"Given an array of integers, determine whether it is possible to partition the array into two subsets such that the sum of the elements in both subsets is equal. Write an algorithm that will return `true` if such a partition is possible and `false` otherwise.","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets with equal sum. Parameters: nums (List[int]): The list of integers. Returns: bool: True if the array can be partitioned into two subsets with equal sum, otherwise False. total_sum = sum(nums) # If total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be made from the elements dp = [False] * (target + 1) dp[0] = True # Base case: zero sum can always be achieved with an empty subset for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"You are given a string `s` and an integer `k`. You need to partition the string into exactly `k` parts such that the maximum length among these parts is minimized. Return _the minimized maximum length_ of the `k` parts. The partitioning must be contiguous, meaning the parts obtained should be substrings of `s` in the given order. If it is not possible to split the string into `k` parts, return `-1`.","solution":"def minimized_max_length(s, k): Returns the minimized maximum length of the `k` parts that the string `s` can be partitioned into. If it\'s not possible to split the string into `k` parts, return `-1`. n = len(s) if k > n: return -1 def can_partition(max_len): partitions = 0 current_len = 0 for char in s: if current_len + 1 > max_len: partitions += 1 current_len = 1 if partitions >= k: return False else: current_len += 1 # If we haven\'t added the last partition return partitions + 1 <= k left, right = 1, n while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a `tree` with `n` nodes, where each node is numbered from `0` to `n-1`. The `tree` is represented by a 2D integer array `edges` where `edges[i] = [ui, vi]` indicates that there is an undirected edge between nodes `ui` and `vi`. Each node has a value associated with it given by an array `values`, where `values[i]` is the value of the `i-th` node. Your task is to find and return _the value of the maximum sum of values in the subtree of any node_. A subtree of a node is all nodes that are reachable from that node, including the node itself. (Note: The sum of values in the subtree of a node is the sum of the values of all nodes in the subtree.)","solution":"def max_subtree_sum(n, edges, values): from collections import defaultdict # Create adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): curr_sum = values[node] for neighbor in tree[node]: if neighbor != parent: curr_sum += dfs(neighbor, node) max_subtree_sum[0] = max(max_subtree_sum[0], curr_sum) return curr_sum max_subtree_sum = [float(\'-inf\')] dfs(0, -1) # Starting DFS from node 0, with no parent (-1) return max_subtree_sum[0]"},{"question":"Given a list of integers `prices` where `prices[i]` is the price of a given stock on the `i-th` day, write a function to find and return the **maximum profit** you can achieve from making at most two transactions. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).","solution":"def max_profit(prices): Returns the maximum profit from at most two transactions. if not prices: return 0 n = len(prices) profit_one = [0] * n profit_two = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit_one[i] = max(profit_one[i-1], prices[i] - min_price) max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) profit_two[i] = max(profit_two[i+1], max_price - prices[i]) max_profit_result = 0 for i in range(n): max_profit_result = max(max_profit_result, profit_one[i] + profit_two[i]) return max_profit_result"},{"question":"You are given an array of integers `nums` where each element appears exactly twice, except for one element which appears exactly once. Find the element that appears only once in linear time complexity and use only constant extra space. Return the single element that does not have a duplicate in the array.","solution":"def single_number(nums): Returns the single number that does not have a duplicate in the array. Uses XOR to ensure linear time complexity and constant space. :param nums: List[int] :return: int result = 0 for num in nums: result ^= num return result"},{"question":"You are given a matrix `grid` of size `n x m` filled with integers. Implement a class `MaxMatrix` that supports the following two operations: * `MaxMatrix(int[][] grid)`: Initializes the MaxMatrix object with the integer matrix `grid`. * `int maxRectangle(int[] topLeft, int[] bottomRight)`: Returns the maximum integer value within the rectangle defined by its top-left corner at `topLeft` and bottom-right corner at `bottomRight`, both inclusive. The topLeft and bottomRight are given as arrays `[row, col]`. Example: ``` MaxMatrix maxMatrix = new MaxMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); maxMatrix.maxRectangle([1, 1], [2, 2]); // Returns 9 maxMatrix.maxRectangle([0, 0], [1, 1]); // Returns 5 ```","solution":"class MaxMatrix: def __init__(self, grid): self.grid = grid def maxRectangle(self, topLeft, bottomRight): max_val = float(\'-inf\') for row in range(topLeft[0], bottomRight[0] + 1): for col in range(topLeft[1], bottomRight[1] + 1): max_val = max(max_val, self.grid[row][col]) return max_val"},{"question":"Develop a data structure `BTree` that represents a balanced binary search tree (BST). The `BTree` class should support the following operations: * `BTree(int[] nums)` Initializes the tree with elements from the array `nums`. The tree should remain balanced after the initialization. * `void insert(int val)` Inserts a new element `val` into the BST and keeps the tree balanced. * `boolean search(int val)` Searches for the element `val` in the BST. Returns `true` if the element is found, otherwise returns `false`. * `void delete(int val)` Deletes the element `val` from the BST. If the element does not exist, do nothing. The tree should remain balanced after the deletion. * `List<Integer> inorderTraversal()` Returns the elements of the BST in sorted order through an inorder traversal. **Note**: The tree should maintain its balance using appropriate rotations or rebalancing mechanisms upon insertion and deletion to ensure optimal search performance.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BTree: def __init__(self, nums): self.root = None self.sorted_nums = sorted(nums) self.root = self._sorted_array_to_bst(self.sorted_nums, 0, len(self.sorted_nums) - 1) def _sorted_array_to_bst(self, nums, start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(nums[mid]) node.left = self._sorted_array_to_bst(nums, start, mid-1) node.right = self._sorted_array_to_bst(nums, mid+1, end) return node def insert(self, val): self.sorted_nums.append(val) self.sorted_nums.sort() self.root = self._sorted_array_to_bst(self.sorted_nums, 0, len(self.sorted_nums) - 1) def search(self, val): def _search_recursive(node, val): if node is None: return False if val == node.val: return True elif val < node.val: return _search_recursive(node.left, val) else: return _search_recursive(node.right, val) return _search_recursive(self.root, val) def delete(self, val): if val not in self.sorted_nums: return self.sorted_nums.remove(val) self.root = self._sorted_array_to_bst(self.sorted_nums, 0, len(self.sorted_nums) - 1) def inorderTraversal(self): result = [] def _inorder_traversal(node): if node: _inorder_traversal(node.left) result.append(node.val) _inorder_traversal(node.right) _inorder_traversal(self.root) return result"},{"question":"Write a function `maxSlidingWindow` that takes an array of integers `nums` and an integer `k`, where `k` represents the size of a sliding window, and returns an array containing the maximum value of each window as it slides from the beginning of the array to the end. Implement the function as follows: * `maxSlidingWindow(nums: List[int], k: int) -> List[int]:` - `nums`: A list of integers representing the array. - `k`: An integer representing the size of the sliding window. The function should efficiently compute the maximum value for each sliding window in the array `nums`. Use a data structure that allows you to achieve this in O(n) time complexity where n is the length of nums. The function should return a list of integers representing the maximum values of each window. Example: ```python maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) # Output: [3,3,5,5,6,7] ```","solution":"from collections import deque from typing import List def maxSlidingWindow(nums: List[int], k: int) -> List[int]: Returns a list of the maximum values in each sliding window of size k. :param nums: List of integers representing the array :param k: Integer representing the size of the sliding window :return: List of integers representing the maximum values in each window if not nums or k == 0: return [] if k == 1: return nums deq = deque() result = [] for i in range(len(nums)): # Remove elements not within the current window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements not useful within the window (smaller than current element) while deq and nums[deq[-1]] <= nums[i]: deq.pop() deq.append(i) # When we reach the window size, record the max element (front of deque) if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"You are given an integer array `nums` with `n` elements. You can perform any number of operations on the array. In each operation, you can select any two adjacent elements and replace them with their sum. Your goal is to minimize the maximum value in the array after performing the operations any number of times. Return _the minimum possible maximum value_ of the array you can achieve.","solution":"def minimize_max_value(nums): Minimizes the maximum value of the array by replacing any two adjacent elements with their sum any number of times. Args: nums (List[int]): The input array of integers. Returns: int: The minimum possible maximum value of the array. # The minimum possible maximum value will be the average number of the array or just greater than it. n = len(nums) total_sum = sum(nums) return (total_sum + n - 1) // n # Ceiling division to get the smallest possible maximum value"},{"question":"Given a list of integers `nums`, you need to determine whether it is possible to reorder the list such that the sum of any two adjacent numbers is not divisible by a given integer `k`. If it is possible, return the reordered list. If it is not possible, return an empty list.","solution":"from itertools import permutations def can_reorder(nums, k): Check if it is possible to reorder the list such that the sum of any two adjacent numbers is not divisible by k. If possible, return the reordered list. If not possible, return an empty list. def is_valid(nums, k): for i in range(len(nums) - 1): if (nums[i] + nums[i + 1]) % k == 0: return False return True for perm in permutations(nums): if is_valid(perm, k): return list(perm) return [] # Example usage: # nums = [1, 2, 3, 4] # k = 5 # Output: [1, 2, 3, 4] or any valid permutation"},{"question":"You are given a **binary tree** with `n` nodes. Each node in the binary tree has a value of `0` or `1`. We define the **flipping cost** of a binary tree as the total number of edges that need to be toggled (flipped from parent-child direction to child-parent direction or vice versa) to make all nodes with value `1` reachable from the root. Write a function that returns the minimum flipping cost required. Note that flipping an edge restores its direction to the original state.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_flipping_cost(root): def dfs(node, parent): if not node: return 0, 0 left_cost, left_count = dfs(node.left, node) if node.left else (0, 0) right_cost, right_count = dfs(node.right, node) if node.right else (0, 0) current_cost = left_cost + right_cost if node.value == 1: total_count = left_count + right_count + 1 else: total_count = left_count + right_count if node.value == 0 and total_count > 0: current_cost += 1 return current_cost, total_count cost, _ = dfs(root, None) return cost"},{"question":"You are given a binary search tree (BST) with `n` nodes. Each node in the tree contains an integer value and has the following properties for a BST: * The left subtree of a node contains only nodes with values less than the node\'s value. * The right subtree of a node contains only nodes with values greater than the node\'s value. Given the `root` node of a BST, write a function to find the kth smallest element in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. :param root: TreeNode, the root of the BST :param k: int, the k-th smallest position :return: int, the value of the k-th smallest element def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k - 1]"},{"question":"You are given an integer array `moves` of non-negative integers where `moves[i]` represents the number of available moves for the `i`th robot. Each move can either be up (increasing the index by 1) or down (decreasing the index by 1) on a circular loop of length `n`. For example, if a robot is currently at index `0`, a move down would bring it to index `n-1`, and a move up at index `n-1` would bring it to index `0`. Your task is to determine if the robots can be arranged such that they form a circle with each robot returning to its initial position after making exactly the number of moves specified in the `moves` array. If it is possible to arrange them in this way, return `true`, otherwise return `false`.","solution":"def can_form_circle(moves): Returns True if robots can be arranged such that they form a circle with each robot returning to its initial position, otherwise returns False. n = len(moves) for i in range(n): position = i for j in range(moves[position]): position = (position + 1) % n if position != i: return False return True"},{"question":"Given a string `s`, return _the starting indices of all the palindromic substrings of_ `s`. A **palindromic substring** is a substring that reads the same forwards and backwards. You need to return the indices in a list in lexicographical order.","solution":"def palindromic_substring_indices(s): Returns the starting indices of all palindromic substrings of s. n = len(s) result = [] def is_palindrome(substr): return substr == substr[::-1] for i in range(n): for j in range(i+1, n+1): if is_palindrome(s[i:j]): result.append(i) return sorted(set(result))"},{"question":"Given a string `s`, you need to return _the longest palindromic substring of_ `s`. A palindrome is a string that reads the same backward as forward. The substring is a contiguous sequence of characters within the string.","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of the given string s. if s == \\"\\": return \\"\\" n = len(s) longest_palindrome_start = 0 longest_palindrome_length = 1 for i in range(1, n): # Check for even length palindromes l, r = i - 1, i while l >= 0 and r < n and s[l] == s[r]: if (r - l + 1) > longest_palindrome_length: longest_palindrome_start = l longest_palindrome_length = r - l + 1 l -= 1 r += 1 # Check for odd length palindromes l, r = i - 1, i + 1 while l >= 0 and r < n and s[l] == s[r]: if (r - l + 1) > longest_palindrome_length: longest_palindrome_start = l longest_palindrome_length = r - l + 1 l -= 1 r += 1 return s[longest_palindrome_start:longest_palindrome_start + longest_palindrome_length]"},{"question":"A company stores records in a hierarchical structure where each employee is linked to a manager, except for the CEO who has no manager. Each employee can have multiple managers and subordinates but only one direct manager. Your task is to design a class `CompanyStructure` that can efficiently perform the following operations: - `addEmployee(name: str, manager: str)` : Adds a new employee to the company with the given `name`, reporting to the given `manager`. Initially, each employee has an empty list of subordinates. - `removeEmployee(name: str)` : Removes an employee with the given `name` from the company. If the employee has subordinates, they will now report directly to their removed employee\'s manager. - `getSubordinates(name: str) -> List[str]` : Returns a list of direct subordinates of the given employee `name` in the company. - `isCycleExist() -> bool` : Returns `True` if there\'s any cyclic management loop in the company\'s hierarchical structure, `False` otherwise. Implement the `CompanyStructure` class such that it efficiently handles the above operations and maintains the hierarchical structure without any cycles.","solution":"class CompanyStructure: def __init__(self): self.employees = {} self.managers = {} def addEmployee(self, name: str, manager: str): if name in self.employees: raise ValueError(\\"Employee already exists\\") self.employees[name] = [] if manager: if manager not in self.employees: raise ValueError(\\"Manager does not exist\\") self.employees[manager].append(name) self.managers[name] = manager def removeEmployee(self, name: str): if name not in self.employees: raise ValueError(\\"Employee does not exist\\") # If the employee has subordinates, they will now report directly to the employee\'s manager manager = self.managers.get(name, None) subordinates = self.employees[name] if manager: self.employees[manager].remove(name) self.employees[manager].extend(subordinates) for subordinate in subordinates: self.managers[subordinate] = manager # Remove the employee from records del self.employees[name] if name in self.managers: del self.managers[name] def getSubordinates(self, name: str): if name not in self.employees: raise ValueError(\\"Employee does not exist\\") return self.employees[name] def isCycleExist(self): visited = set() def dfs(employee, ancestors): if employee in ancestors: return True if employee in visited: return False visited.add(employee) ancestors.add(employee) manager = self.managers.get(employee) if manager and dfs(manager, ancestors): return True ancestors.remove(employee) return False for employee in self.employees: if dfs(employee, set()): return True return False"},{"question":"Given a **binary tree**, perform an in-order traversal and return an array of the node values. An in-order traversal visits the nodes in the left subtree, the root node, and finally the nodes in the right subtree. Ensure that your solution handles trees with varying structures, including those with only left or right children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the in-order traversal of a binary tree. def inorder(node): return inorder(node.left) + [node.val] + inorder(node.right) if node else [] return inorder(root)"},{"question":"You are given a 2D grid of dimension `n x n` representing a map of an island where: - `1` represents land, and - `0` represents water. You must build a bridge to connect two separate islands by flipping exactly one `0` to `1`. The bridge can only be built in a place where two separate islands are closest to each other. Return the length of the shortest bridge that can be built to connect the two islands. If no such bridge exists, return `-1`. A bridge\'s length is defined as the number of `0`s between the two `1`s that connect the islands, including the one flipped. You may assume that the given grid always has exactly two separate islands.","solution":"def shortest_bridge(grid): from collections import deque def get_neighbors(x, y, n): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: yield nx, ny def bfs(queue, visited, mark_lookup): while queue: x, y = queue.popleft() for nx, ny in get_neighbors(x, y, n): if (nx, ny) not in visited and grid[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) mark_lookup.append((nx, ny)) # Find and mark all cells of the first island. n = len(grid) first_island = [] visited = set() for i in range(n): for j in range(n): if grid[i][j] == 1: first_island.append((i, j)) visited.add((i, j)) break if first_island: break queue = deque(first_island) bfs(queue, visited, first_island) # Use BFS to find the shortest path from the first island to the second island. queue = deque([(x, y, 0) for x, y in first_island]) visited = set(first_island) while queue: x, y, dist = queue.popleft() for nx, ny in get_neighbors(x, y, n): if (nx, ny) not in visited: if grid[nx][ny] == 1: return dist queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer array `charLimit` of length 26, where `charLimit[i]` represents the maximum allowable frequency for the letter corresponding to the i-th position in the alphabet (0 for \'a\', 1 for \'b\', and so on). Your task is to determine whether it is possible to rearrange the characters of the string `s` such that no letter exceeds its respective frequency limit as specified in `charLimit`. Return `true` if such a rearrangement is possible, `false` otherwise.","solution":"def can_rearrange_string(s, charLimit): Checks if characters of the string `s` can be rearranged such that the frequency of each character does not exceed its respective limit in `charLimit`. Parameters: s : str : a string consisting of lowercase English letters charLimit : list : an integer list of length 26 representing the maximum allowable frequency for each letter Returns: bool : True if such rearrangement is possible, False otherwise from collections import Counter # Count the frequency of each character in the string `s` char_count = Counter(s) for i in range(26): char = chr(i + ord(\'a\')) # get character corresponding to index i if char_count[char] > charLimit[i]: return False return True"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `n`. You need to find the **longest substring** of `s` that contains exactly `n` unique characters. If there are multiple such substrings, return the first one you encounter. If no such substring exists, return an empty string.","solution":"def longest_substring_with_n_unique_characters(s, n): Returns the longest substring of s that contains exactly n unique characters. Parameters: - s: a string of lowercase alphabets - n: an integer representing the number of unique characters Returns: - The longest substring with exactly n unique characters or an empty string if no such substring exists. if n == 0 or not s: return \\"\\" start = 0 max_len = 0 max_substr = \\"\\" char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > n: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 if len(char_count) == n and end - start + 1 > max_len: max_len = end - start + 1 max_substr = s[start:end+1] return max_substr"},{"question":"You are given a list of integers `nums` representing a sequence of stock prices, where `nums[i]` is the stock price on the `i`-th day. You are allowed to complete at most one transaction, which means you can buy one and sell one share of the stock. Return _the maximum profit_ you can achieve from this transaction. If you cannot achieve any profit, return `0`. Note that you must buy before you sell.","solution":"def max_profit(nums): Returns the maximum profit that can be achieved from a single buy and sell transaction. If no profit can be made, returns 0. :param nums: List of integers representing stock prices per day. :return: Integer maximum profit, or 0 if no profit is possible. if not nums: return 0 min_price = float(\'inf\') max_profit = 0 for price in nums: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given an integer array `nums` of length `n`. Your goal is to rearrange the elements in `nums` so that all zeros are moved to the end while maintaining the relative order of the non-zero elements. Return the modified array.","solution":"def move_zeros_to_end(nums): Rearranges the elements in nums so that all zeros are moved to the end while maintaining the relative order of the non-zero elements. :param nums: List[int] - An integer array :return: List[int] - The modified array with all zeros moved to the end non_zero_index = 0 # Move all non-zero elements to the front for i in range(len(nums)): if nums[i] != 0: nums[non_zero_index] = nums[i] non_zero_index += 1 # Fill remaining positions with zeros for i in range(non_zero_index, len(nums)): nums[i] = 0 return nums"},{"question":"Given an integer array `arr` and an integer `k`, return _the number of distinct subarrays where the sum of the elements in the subarray is equal to_ `k`. A subarray is a contiguous part of an array.","solution":"def count_distinct_subarrays_with_sum_k(arr, k): Returns the number of distinct subarrays where the sum of the elements in the subarray is equal to k. Parameters: arr (list of int): The input array of integers. k (int): The target sum. Returns: int: The number of distinct subarrays with sum equal to k. n = len(arr) count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += arr[end] if current_sum == k: count += 1 return count"},{"question":"Design a function that simulates a simple text editor. The editor starts with an empty string, and you can perform three types of operations on it: 1. `\\"INSERT <text>\\"`: Insert the given `<text>` at the end of the current string. 2. `\\"DELETE\\"`: Delete the last character of the current string, if the string is not empty. 3. `\\"UNDO\\"`: Undo the last operation performed (\\"UNDO\\" should not be undone). You need to implement the `TextEditor` class: - `TextEditor()`: Initializes the simple text editor. - `void insert(String text)`: Implements the \\"INSERT <text>\\" operation. - `void delete()`: Implements the \\"DELETE\\" operation. - `void undo()`: Implements the \\"UNDO\\" operation. - `String getText()`: Returns the current state of the text in the editor. The operations should be efficient, and the `getText` method should return the current text after performing several operations.","solution":"class TextEditor: def __init__(self): self.current_text = \\"\\" self.history = [] def insert(self, text): self.history.append(self.current_text) self.current_text += text def delete(self): if self.current_text: self.history.append(self.current_text) self.current_text = self.current_text[:-1] def undo(self): if self.history: self.current_text = self.history.pop() def get_text(self): return self.current_text"},{"question":"You are given a 2D matrix `grid` of size `m x n`, where each element is either `0` or `1`. The matrix represents a binary image where `1` denotes an object pixel and `0` denotes a background pixel. Objects are connected using 4-directional adjacency (left, right, up, down). Your task is to find and return _the number of distinct objects_ in the `grid`. Two objects are considered distinct if they are not connected.","solution":"def num_distinct_objects(grid): Returns the number of distinct objects in the grid. An object is a cluster of connected 1s (horizontally or vertically). if not grid: return 0 def dfs(i, j): Helper function to perform dfs and mark connected components if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark this cell as visited # Visit all 4 adjacent cells dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) m, n = len(grid), len(grid[0]) num_objects = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: # New object found num_objects += 1 dfs(i, j) return num_objects"},{"question":"You are given a list of daily temperatures `temperatures`, where `temperatures[i]` is the temperature in Celsius on the `ith` day. You need to return a list `answer` such that for each day `i`, `answer[i]` is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, keep `answer[i]` as `0` instead. For example, given the list `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. **Constraints**: - 1 <= `temperatures.length` <= 10^5 - 30 <= `temperatures[i]` <= 100","solution":"def daily_temperatures(temperatures): For each day in the input list \'temperatures\', return a list \'answer\' where answer[i] is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, answer[i] should be 0. n = len(temperatures) answer = [0] * n stack = [] # This will store the indices of the temperatures list for i in range(n): # If current temperature is higher than the temp at index stored in stack # pop from stack and calculate the difference while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"You are given a **binary tree** with nodes represented by integer values. Each node also has an extra boolean attribute `hasApple` that indicates whether the node contains an apple. Starting from the root node (node 0), you are to collect all the apples in the tree. Every time you visit a node, you either move to one of its children or back to its parent, and you incur a cost. Return the _minimum cost to collect all apples in the tree._ If there are no apples, the cost should be 0. Note: The structure of the tree is given as a list `edges` of size `n-1` where `edges[i] = [ui, vi]` denotes an edge between node `ui` and node `vi`, and a list `hasApple` of size `n` where `hasApple[i]` is `true` if node `i` has an apple, and `false` otherwise.","solution":"def minTime(n, edges, hasApple): from collections import defaultdict # Build an adjacency list from edges tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): time = 0 # Traverse all children for child in tree[node]: if child != parent: child_time = dfs(child, node) # If child or its subtree has an apple, we add the time to traverse to this child and back if child_time > 0 or hasApple[child]: time += child_time + 2 return time # Start DFS from the root node (0) return dfs(0, -1) # Example usage # n = 7 # edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]] # hasApple = [False,False,True,False,True,True,False] # Output: 8 # 1 <-- 0 --> 2 # | | # [4,5] [3,6]"},{"question":"A company has several projects, each requiring a certain number of workers to start. You\'re given a list `projects`, where each element is a tuple `(requiredWorkers, profit)` representing the number of workers required and the profit from the project, respectively. You are also given an integer `initialWorkers` representing the number of workers you initially have. You can start multiple projects, and for each project you start, the workers used are no longer available for other projects, but you gain the profit from that project. However, you can reinvest the gained profit to hire additional workers, with a cost of 1 worker per unit of profit. Implement a function `maxProfit(int initialWorkers, List<Pair<Integer, Integer>> projects)` that returns the maximum profit you can achieve given the constraints.","solution":"from typing import List, Tuple def max_profit(initial_workers: int, projects: List[Tuple[int, int]]) -> int: # Sort projects based on required workers in ascending order projects.sort() total_workers = initial_workers total_profit = 0 for required_workers, profit in projects: # If we have enough workers to start the project if total_workers >= required_workers: # Star the project total_workers -= required_workers # Deduct the required workers total_profit += profit # Gain the profit total_workers += profit # Reinvest profit into hiring new workers return total_profit"},{"question":"Given a string `licensePlate` and an array of strings `words`, return the shortest completing word in `words`. A **completing word** is a word that contains all the letters in the string `licensePlate` (ignoring case and non-letter characters), including duplicates. It is guaranteed that a completing word exists. If multiple words are of the same length, return the one that appears first in the array.","solution":"from collections import Counter def shortest_completing_word(licensePlate, words): def letter_count(word): return Counter([char.lower() for char in word if char.isalpha()]) plate_count = letter_count(licensePlate) shortest_word = None for word in words: word_count = letter_count(word) if all(word_count[char] >= plate_count[char] for char in plate_count): if shortest_word is None or len(word) < len(shortest_word): shortest_word = word return shortest_word"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find and return the length of the longest substring without repeating characters. Ensure your solution has a linear runtime complexity. Use a sliding window approach to keep track of the current substring without repeating characters and update the maximum length found as you iterate through the string.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"Write a function that, given a string `s`, counts and returns the number of anagrams of the string `s` that are palindromes. An anagram of a string is any rearrangement of its characters. A palindrome is a string that reads the same forwards and backwards. For example, the string \\"aabb\\" has an anagram \\"abba\\" which is a palindrome, but the string \\"abc\\" has no palindromic anagrams. If the input string `s` is empty, the function should return 0.","solution":"from collections import Counter def count_palindromic_anagrams(s): Returns the number of anagram of the string `s` that are palindromes. # Edge case for empty string if not s: return 0 # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome, # we can have at most one character with an odd count if odd_count > 1: return 0 return 1"},{"question":"You are given an integer array `arr` and a target value `target`. Find the number of distinct pairs `(i, j)` where `0 <= i < j < len(arr)` such that the absolute difference between `arr[i]` and `arr[j]` is equal to `target`. Return _the count of such pairs_. Note that pairs `(i, j)` and `(j, i)` are considered the same and should not be counted twice.","solution":"def count_pairs_with_diff(arr, target): Returns the number of distinct pairs (i, j) where 0 <= i < j < len(arr) such that the absolute difference between arr[i] and arr[j] is equal to target. count = 0 seen = set() n = len(arr) for i in range(n): if arr[i] + target in seen: count += 1 if arr[i] - target in seen: count += 1 seen.add(arr[i]) return count"},{"question":"Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `\'.\'` and `\'*\'`. The matching should cover the entire input string (not partial). - `\'.\'` Matches any single character. - `\'*\'` Matches zero or more of the preceding element. The function prototype is: `bool isMatch(string s, string p)`. You need to write an algorithm that returns true if the string `s` matches the pattern `p`, otherwise, return false. The input string `s` and pattern `p` consist of only lowercase English letters and characters `\'.\'` and `\'*\'`.","solution":"def isMatch(s: str, p: str) -> bool: Returns True if the input string `s` matches the pattern `p`. The pattern `p` can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. # Use dynamic programming to solve the problem m, n = len(s), len(p) # dp[i][j] means whether s[0:i] matches p[0:j] dp = [[False] * (n + 1) for _ in range(m + 1)] # Both s and p are empty dp[0][0] = True # Handle patterns with * for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Matches zero preceding element (e.g. x*) for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[m][n]"},{"question":"Given a binary tree, return the preorder traversal of its nodes\' values. A preorder traversal is defined as follows: visit the root, then recursively traverse the left subtree, and finally, recursively traverse the right subtree. Implement a function that takes the root of the binary tree as input and returns a list containing the preorder traversal of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root): Returns the preorder traversal of a binary tree\'s nodes\' values. def helper(node): if not node: return [] return [node.val] + helper(node.left) + helper(node.right) return helper(root)"},{"question":"Given a 2D grid of size `m x n` where each cell represents a particular amount of money, find the maximum amount of money you can collect if you start from the top-left corner and move to the bottom-right corner, only being able to move right or down. Return _the maximum amount of money that can be collected_.","solution":"def max_money_collected(grid): Returns the maximum amount of money that can be collected starting from the top-left corner to the bottom-right corner, only moving right or down. :param grid: List[List[int]] - a 2D grid of size m x n where each cell represents an amount of money :return: int - the maximum amount of money that can be collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array to store the max amount collected at each cell dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"Given an unsorted array of integers `nums`, find the length of the longest consecutively increasing sequence presented in the array. The sequence must be strictly increasing, and no elements should be skipped in the sequence. Your algorithm should run in `O(n)` time complexity. Return the length of this longest sequence.","solution":"def longest_consecutive(nums): Finds the length of the longest consecutively increasing sequence in the array `nums`. Parameters: nums (list of int): The input array of integers. Returns: int: The length of the longest consecutively increasing sequence. if not nums: return 0 nums_set = set(nums) longest_sequence = 0 for num in nums_set: if num - 1 not in nums_set: # Start of a new sequence current_num = num current_sequence = 1 while (current_num + 1) in nums_set: current_num += 1 current_sequence += 1 longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"Given a list of integers `arr`, you need to find contiguous subarray which has the largest sum and return its sum. The approach needs to be optimal with a time complexity of O(n). Write a function `int maxSubArraySum(int[] arr)` which takes an array as input and returns the maximum sum found among all possible contiguous subarrays.","solution":"def maxSubArraySum(arr): Returns the maximum sum of a contiguous subarray. :param arr: List[int] - Input array of integers :return: int - Maximum sum of a contiguous subarray if not arr: return 0 # Handle empty array edge case max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a grid representing a field of cells, where each cell has an associated height. The grid is given as a 2D list `grid` of size `n x m`. A cell `(i, j)` can only be accessed directly from its neighboring cells `(i-1, j)`, `(i+1, j)`, `(i, j-1)`, `(i, j+1)` if the height difference between the cells is no more than 1 unit. Determine the minimum effort needed such that you can travel from the top-left cell `(0, 0)` to the bottom-right cell `(n-1, m-1)`, where effort is defined as the maximum height difference encountered along the path. Return the minimum effort required as an integer.","solution":"import heapq def minimumEffortPath(grid): Determines the minimum effort required to travel from the top-left cell to the bottom-right cell in the grid. Parameters: grid (List[List[int]]): The grid representing the field of cells. Returns: int: The minimum effort required. n, m = len(grid), len(grid[0]) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] effort = [[float(\'inf\')] * m for _ in range(n)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == n-1 and y == m-1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny)) return effort[n-1][m-1]"},{"question":"A city is forming a new bus route system, and they want to ensure that each route passes through several key locations. Each key location is represented by a string in the list `keys`. You are given a list of routes where each route is represented by a list of strings denoting the stops that the bus makes in a cyclic manner. A route is considered to cover a key location if the route contains a stop that matches the key location. Determine the minimum number of routes required to cover all key locations. Return _an integer representing the minimum number of routes needed to cover all key locations_. If not all key locations can be covered, return `-1`.","solution":"from itertools import combinations def minimum_routes(routes, keys): n = len(routes) key_set = set(keys) def covers_all_keys(route_indices): covered = set() for i in route_indices: covered.update(routes[i]) return key_set.issubset(covered) for i in range(1, n + 1): for combo in combinations(range(n), i): if covers_all_keys(combo): return i return -1"},{"question":"You are given a string `s` representing a set of alphabets that only contains lowercase latters. You are allowed to insert exactly one character anywhere in the string to form a palindrome. Return whether you can form a palindrome by inserting exactly one character into `s`. A palindrome is a string that reads the same backward as forward.","solution":"def can_form_palindrome_by_inserting_one_char(s): Determine if we can form a palindrome by inserting exactly one character into the string s. def is_palindrome(subs): Helper function to check if a given string is a palindrome. return subs == subs[::-1] n = len(s) for i in range(n + 1): # Try inserting a character at every possible position if i == 0: new_str = \'_\' + s elif i == n: new_str = s + \'_\' else: new_str = s[:i] + \'_\' + s[i:] # Check if placing any character at this position can make it a palindrome for char in \'abcdefghijklmnopqrstuvwxyz\': candidate = new_str.replace(\'_\', char) if is_palindrome(candidate): return True return False"},{"question":"Given a string `s` and an integer `k`, you need to erase exactly `k` characters from `s` to form the lexicographically smallest string possible. Return the final string after removing `k` characters. The length of `s` will be at least `k`.","solution":"def removeKchars(s, k): Returns the lexicographically smallest string by removing exactly k characters from the input string \'s\'. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If k characters are not removed while k > 0: stack.pop() k -= 1 return \\"\\".join(stack)"},{"question":"You are managing a **warehouse** which contains stacks of different packages. Each stack is represented as a list of integers, where each integer denotes the **weight** of a package. You have a robot that can **transfer** the **topmost package** from one stack to another. Your goal is to ensure that the final weight distribution of all stacks is as **even** as possible. You are given a 2D list `stacks` where `stacks[i]` represents the `ith` stack of packages. Return _the minimum number of transfers needed to make the total weight of all stacks as even as possible_. If it is not possible to even out the stacks, return `-1`.","solution":"def min_transfers_to_even_stacks(stacks): Determine the minimum number of transfers needed to make the total weight of all stacks as even as possible. Args: stacks (list[list[int]]): 2D list where each sublist represents a stack of packages with their weights. Returns: int: Minimum number of transfers needed or -1 if not possible. total_weight = sum(sum(stack) for stack in stacks) num_stacks = len(stacks) if total_weight % num_stacks != 0: return -1 target_weight = total_weight // num_stacks def get_stack_weights(stacks): return [sum(stack) for stack in stacks] stack_weights = get_stack_weights(stacks) transfers = 0 for i in range(len(stacks)): while stack_weights[i] > target_weight: excess_weight = stack_weights[i] - target_weight for j in range(len(stacks)): if i != j and stack_weights[j] < target_weight: transfer_weight = min(excess_weight, target_weight - stack_weights[j]) stack_weights[i] -= transfer_weight stack_weights[j] += transfer_weight transfers += 1 if stack_weights[i] == target_weight: break return transfers"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to implement a function that returns the number of all unique pairs `(i, j)` (where `i != j`) such that `nums[i] + nums[j] == target`. You need to make sure that each pair is counted only once, regardless of their order in the array. For example, `[3, 5]` and `[5, 3]` should be considered the same pair and counted once. Note that `nums` may contain negative numbers and the solution should work efficiently even for large arrays.","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] == target and i != j. Each pair is counted only once, regardless of order. nums_sort = sorted(nums) left, right = 0, len(nums_sort) - 1 pairs = set() while left < right: current_sum = nums_sort[left] + nums_sort[right] if current_sum == target: pairs.add((nums_sort[left], nums_sort[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return len(pairs)"},{"question":"Write a function `findUniqueSubsets` that takes an array of integers `nums` and returns all possible unique subsets of `nums`. The solution set must not contain duplicate subsets and can be returned in any order. Each element in the array may appear multiple times but the subsets themselves must be unique (i.e., no repeating subset structures should be present in the result). The elements within each subset should also be in non-descending order. For example, given the input array `[1, 2, 2]`, the function should return the following unique subsets: `[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]`.","solution":"def findUniqueSubsets(nums): Returns all possible unique subsets of the input list of integers `nums`. nums.sort() res = [] subset = [] def backtrack(start): res.append(subset.copy()) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return res"},{"question":"Given a matrix `grid` of size `n x m`, where each cell contains an integer representing the height of that point above sea level, calculate the number of closed islands. A closed island is a group of connected `0`s completely surrounded by `1`s. Connected means 4-directionally (up, down, left, right). The boundary of the grid is surrounded by water (`1`s), and an island is considered closed if there are no 0s on its boundary. A cell is part of a closed island if and only if all the cells connected to it form a closed island. **Example:** ``` Input: grid = [ [1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1] ] Output: 1 ``` **Hint:** You may use Depth-First Search (DFS) traversal starting from each cell containing `0` to determine if it is part of a closed island, taking care to not count islands that touch the grid\'s boundary.","solution":"def closedIsland(grid): rows, cols = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols: return False if grid[x][y] == 1: return True grid[x][y] = 1 # mark as visited top = dfs(x-1, y) bottom = dfs(x+1, y) left = dfs(x, y-1) right = dfs(x, y+1) return top and bottom and left and right closed_islands = 0 for i in range(1, rows-1): for j in range(1, cols-1): if grid[i][j] == 0: if dfs(i, j): closed_islands += 1 return closed_islands"},{"question":"You are working with a simple text-based database management system, where you can store key-value pairs and perform various operations. Implement the `TextDB` class: * `TextDB()` - Initializes an empty database. * `void put(String key, String value)` - Inserts a key-value pair into the database. If the key already exists, its value will be updated. * `String get(String key)` - Returns the value associated with the key. If the key does not exist, return \\"Not found\\". * `void delete(String key)` - Deletes the key-value pair from the database. If the key does not exist, do nothing. * `String[] list()` - Returns an array of all keys in the database in lexicographical order. Example: ``` TextDB db = new TextDB(); db.put(\\"name\\", \\"Alice\\"); db.put(\\"age\\", \\"23\\"); System.out.println(db.get(\\"name\\")); // Outputs: Alice System.out.println(db.get(\\"gender\\")); // Outputs: Not found db.delete(\\"age\\"); String[] keys = db.list(); // Returns a sorted list of keys [\\"name\\"] ```","solution":"class TextDB: def __init__(self): self.database = {} def put(self, key, value): self.database[key] = value def get(self, key): return self.database.get(key, \\"Not found\\") def delete(self, key): if key in self.database: del self.database[key] def list(self): return sorted(self.database.keys())"},{"question":"You are given an array of `n` integers where each integer represents the height of a building in a straight line. The buildings form a skyline and the sun is rising from the left side (i.e., from the beginning of the array). A building can block the sunlight of any building to its right if it is equal to or taller than that building. Write a function to determine the number of buildings that will receive sunlight.","solution":"def count_buildings_with_sunlight(buildings): Returns the number of buildings that will receive sunlight. Parameters: buildings (list of int): List of building heights. Returns: int: Number of buildings that will receive sunlight. if not buildings: return 0 count = 1 # The first building always receives sunlight. max_height = buildings[0] for height in buildings[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given an integer array `arr` and a positive integer `k`. You are to create a new array that consists of the `k` largest **distinct** integers from `arr`. If the array has fewer than `k` distinct integers, fill the remaining positions with `-1`. The resulting array should be in descending order. Return _the new array of size `k` with the `k` largest distinct integers._","solution":"def k_largest_distinct(arr, k): Returns a new array that consists of the k largest distinct integers from arr. If there are fewer than k distinct integers, fills with -1. # Getting distinct elements and sorting them in descending order distinct_sorted = sorted(set(arr), reverse=True) # If there are fewer than k distinct integers, add necessary -1\'s to the result result = distinct_sorted[:k] + [-1] * (k - len(distinct_sorted)) return result"},{"question":"Given a string `s` and an integer `k`, result the number of distinct substrings of length `k`. If `k` is larger than the length of the string `s`, return `0`.","solution":"def count_distinct_substrings(s, k): Return the number of distinct substrings of length k in the string s. If k is larger than the length of s, return 0. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings)"},{"question":"Write a function that takes a list of non-negative integers `arr` and an integer `target`, and returns the closest sum of any three integers in `arr` to `target`. If there are multiple answers, return any of them.","solution":"def threeSumClosest(arr, target): Returns the sum of three integers in `arr` such that the sum is closest to `target`. arr.sort() n = len(arr) closest_sum = float(\'inf\') for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return current_sum if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 else: right -= 1 return closest_sum"},{"question":"Given a string `input` consisting of lowercase English letters, determine the length of the longest substring with all unique characters. Return the length of this longest substring.","solution":"def longest_unique_substring_length(input): Returns the length of the longest substring with all unique characters. char_index_map = {} max_length = 0 start = 0 for i, char in enumerate(input): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"You are given an array of integers `heights` representing the heights of students in a class. The teacher wants to reorder the array such that the heights are in non-decreasing order. However, instead of immediately sorting the array, the teacher wants to know how many students are initially standing in the same position as they would be in the sorted array. Write a function that returns the number of students standing in the same position before and after sorting the array.","solution":"def count_students_in_same_position(heights): Returns the number of students standing in the same position before and after sorting the array. Parameters: heights (list of int): List of heights of students. Returns: int: The number of students in the same position. sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] == sorted_heights[i]: count += 1 return count"},{"question":"You are given a string `s` containing digits from `2` to `9` inclusive. The string represents a sequence of digits on a telephone keypad. Return all possible letter combinations that the number could represent. You may return the answer in **any order**. Return an **empty list** if the input string is empty. The mapping of digits to letters is as follows (a typical telephone mapping): * `2` -> `\\"abc\\"` * `3` -> `\\"def\\"` * `4` -> `\\"ghi\\"` * `5` -> `\\"jkl\\"` * `6` -> `\\"mno\\"` * `7` -> `\\"pqrs\\"` * `8` -> `\\"tuv\\"` * `9` -> `\\"wxyz\\"`","solution":"def letter_combinations(digits): Returns all possible letter combinations that the input digit string could represent on a telephone keypad. :param digits: A string containing digits from \'2\' to \'9\' :return: A list of all possible letter combinations if not digits: return [] digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } results = [\'\'] for digit in digits: new_results = [] for combination in results: for letter in digit_to_letters[digit]: new_results.append(combination + letter) results = new_results return results"},{"question":"Given an array of integers `arr`, return the length of the longest subarray containing **only distinct** elements.","solution":"def longest_subarray_with_distinct_elements(arr): Returns the length of the longest subarray containing only distinct elements. seen = {} max_length = 0 start = 0 for end in range(len(arr)): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a `tree` represented as an adjacency list and a target integer `k`, find the number of paths in the tree that have exactly `k` edges. Each path should be counted based on its unique sequence of nodes, even if it traverses the same edges in a different order. Return the total number of such distinct paths.","solution":"from collections import defaultdict def count_k_edge_paths(tree, k): Returns the number of paths in the tree that have exactly k edges. if k == 0: return 0 # No such paths with 0 edges def dfs(node, parent, depth): # Base case: if path has exactly k edges, count it if depth == k: return 1 count = 0 # Traverse all adjacent nodes for neighbor in tree[node]: if neighbor != parent: # Don\'t revisit the parent node count += dfs(neighbor, node, depth+1) return count total_paths = 0 # Start DFS from each node (as each node might be a starting point) for start_node in tree: total_paths += dfs(start_node, None, 0) # Each path is counted twice (once in each direction), so divide by 2 return total_paths // 2 # Example Tree for testing tree = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2] }"},{"question":"Write a function that finds the **minimum** number of steps required to transform one given string into another string. You are allowed to perform the following operations on the string: - Insert a character - Delete a character - Replace a character Given two strings `word1` and `word2`, return the minimum number of steps required to convert `word1` to `word2`. The function signature should be `int minDistance(String word1, String word2)`.","solution":"def minDistance(word1, word2): Returns the minimum number of steps required to convert word1 to word2. Operations allowed: Insert a character, Delete a character, Replace a character. m, n = len(word1), len(word2) # create a DP table to memoize the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # initialize the table with base cases for i in range(m + 1): dp[i][0] = i # if word2 is empty, we need i deletions for j in range(n + 1): dp[0][j] = j # if word1 is empty, we need j insertions # fill the table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: # if characters match, no new operation needed dp[i][j] = dp[i - 1][j - 1] else: # otherwise, consider the minimum cost of the three operations dp[i][j] = min(dp[i - 1][j] + 1, # delete dp[i][j - 1] + 1, # insert dp[i - 1][j - 1] + 1) # replace return dp[m][n]"},{"question":"You are given a string `s` consisting of lowercase English letters. A **good subsequence** of `s` is a subsequence that contains every unique character of `s` at least once and no duplicate characters. Your task is to find the **lexicographically smallest** good subsequence of `s`. Write a function `smallestGoodSubsequence(s: str) -> str` that returns the lexicographically smallest good subsequence of the given string `s`. An example of a good subsequence for the string \\"abacb\\" would be \\"abc\\".","solution":"def smallestGoodSubsequence(s: str) -> str: Returns the lexicographically smallest good subsequence of the given string s. unique_chars = sorted(set(s)) return \'\'.join(unique_chars)"},{"question":"Given a string `s` and an integer `k`, return the length of the longest substring of `s` that can be transformed into a palindrome by inserting at most `k` characters.","solution":"def longest_palindrome_subseq(s: str) -> int: Helper function to find the length of the longest palindromic subsequence in s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] def longest_substring_transformed_palindrome(s: str, k: int) -> int: Returns the length of the longest substring of s that can be transformed into a palindrome by inserting at most k characters. n = len(s) if n == 0: return 0 # Find the length of the longest palindromic subsequence longest_palindromic_subseq_length = longest_palindrome_subseq(s) # Minimum insertions needed to transform the longest palindromic subsequence to a full palindrome min_insertions = n - longest_palindromic_subseq_length if min_insertions <= k: return n return -1 # It means it\'s not possible within k characters to make the entire string palindrome"},{"question":"In a university, students participate in various courses, and each course has a set of prerequisites. Given the number of courses `numCourses` and a list of prerequisites where `prerequisites[i] = [ai, bi]` indicates that to enroll in course `ai`, a student must have completed course `bi` first, return _the order in which students should take courses to finish  their courses_. If it is impossible to finish  courses, return an empty array. Each course may have zero or more prerequisites, and the prerequisites may have dependencies as well.","solution":"from collections import deque, defaultdict def findOrder(numCourses, prerequisites): Determines the order of courses to finish  courses given the prerequisites. :param numCourses: int, number of courses :param prerequisites: List[List[int]], list of prerequisite pairs :return: List[int], the order of courses to take or an empty list if impossible indegree = [0] * numCourses graph = defaultdict(list) for dest, src in prerequisites: graph[src].append(dest) indegree[dest] += 1 queue = deque([i for i in range(numCourses) if indegree[i] == 0]) order = [] while queue: course = queue.popleft() order.append(course) for neighbor in graph[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == numCourses: return order else: return []"},{"question":"You are given a binary tree in which each node contains a single digit value (0-9). Each root-to-leaf path in the tree represents a number formed by concatenating the values along the path. Return the sum of all the numbers represented by the root-to-leaf paths. Since the answer can be a large number, return this sum **modulo** 109 + 7.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): MOD = 10**9 + 7 def dfs(node, current_number): if not node: return 0 current_number = (current_number * 10 + node.val) % MOD if not node.left and not node.right: # if it\'s a leaf node return current_number left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return (left_sum + right_sum) % MOD return dfs(root, 0)"},{"question":"Given an integer array `nums` and an integer `k`, return _the k-th largest element in the array_. Note that it is the k-th largest element in sorted order, not the k-th distinct element. Implement the function `int findKthLargest(int[] nums, int k)` that achieves this in a time complexity better than O(n log n).","solution":"import heapq def findKthLargest(nums, k): Returns the k-th largest element in the array nums. # Using a min-heap to keep the k largest elements in the heap heap = nums[:k] heapq.heapify(heap) for num in nums[k:]: if num > heap[0]: heapq.heappop(heap) heapq.heappush(heap, num) # The root of the heap is the k-th largest element return heap[0]"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city, arranged in a row from left to right. The city layout guarantees that every building must have visual access to at least one other building in the opposite direction (i.e., if looking leftwards or rightwards from the building, it should see at least one building that is not shorter than itself). You need to determine the number of such buildings that can see each other directly without any taller buildings between them. For example, for buildings with heights `[4, 2, 3, 1]`, building `4` can see building `3`, and building `1` can see building `3`. However, building `2` cannot see any other buildings because building `3` is taller and blocks the view. Return the total count of buildings visible to each other.","solution":"def count_visible_buildings(heights): def visible_left(index, heights): curr_max = 0 for i in range(index-1, -1, -1): if heights[i] >= heights[index]: return True if heights[i] > curr_max: curr_max = heights[i] return curr_max >= heights[index] def visible_right(index, heights): curr_max = 0 for i in range(index+1, len(heights)): if heights[i] >= heights[index]: return True if heights[i] > curr_max: curr_max = heights[i] return curr_max >= heights[index] count = 0 for i in range(len(heights)): if visible_left(i, heights) or visible_right(i, heights): count += 1 return count"},{"question":"Given a string `s` and an array of string `words`, return _a list of all starting indices of `words`\' concatenations in `s`_. Each concatenation is formed by joining all the strings in `words` exactly once and without any intervening characters. The order of concatenation must match the order given in the array `words`. [Question] 4:","solution":"def find_substring_indices(s, words): if not s or not words: return [] word_length = len(words[0]) total_words_length = word_length * len(words) word_count = len(words) result = [] word_dict = {} for word in words: word_dict[word] = word_dict.get(word, 0) + 1 for i in range(len(s) - total_words_length + 1): seen_words = {} for j in range(word_count): word_index = i + j * word_length word = s[word_index:word_index + word_length] if word in word_dict: seen_words[word] = seen_words.get(word, 0) + 1 if seen_words[word] > word_dict[word]: break else: break else: result.append(i) return result"},{"question":"You are given a 2D grid of size `m x n` representing a maze where `0` represents an empty cell and `1` represents a barrier. You are also given two pairs of coordinates: `start` and `end`. Write an algorithm that determines if there exists a path from `start` to `end` such that you can move up, down, left, or right at each step, but you cannot move diagonally or traverse barriers. Return `true` if such a path exists and `false` otherwise.","solution":"def is_path_exist(maze, start, end): Determines if there exists a path from \'start\' to \'end\' in the maze using BFS. :param maze: List[List[int]] - 2D grid representing the maze, where 0 is an empty cell and 1 is a barrier. :param start: Tuple[int, int] - Coordinates of the starting cell. :param end: Tuple[int, int] - Coordinates of the ending cell. :return: bool - True if a path exists, False otherwise. from collections import deque m, n = len(maze), len(maze[0]) if start == end: return True if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return False # Directions for right, down, left, up movements directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == 0 and (nx, ny) not in visited: if (nx, ny) == end: return True queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Return the length of the modified array. You must do this by modifying the input array in-place with O(1) extra memory. Example: Given `nums = [0,0,1,1,1,2,2,3,3,4]`, Your function should return `length = 5`, and the modified `nums` array should be `[0, 1, 2, 3, 4]`. Note: It doesn\'t matter what values are set beyond the returned length.","solution":"def remove_duplicates(nums): Removes duplicates in a sorted list in-place and returns the length of the modified array with unique elements. Args: nums (List[int]): The input sorted list. Returns: int: The length of the modified list with unique elements. if not nums: return 0 write_index = 1 for i in range(1, len(nums)): if nums[i] != nums[write_index - 1]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"Design a data structure that supports the following operations efficiently on a list of unique numbers from 1 to n: * `pick()` - Randomly selects an integer from the list and returns it. * `remove(val)` - Removes the integer `val` from the list if it exists. Your implementation should aim to achieve both operations in constant time on average. You may assume that there will be no duplicate values and the removal function will only be called with integers that currently exist in the list. Implement the `RandomizedSet` class: * `RandomizedSet()` Initializes the data structure. * `bool pick()` Randomly returns an integer from the current list of numbers. * `bool remove(int val)` Removes the integer `val` from the list if it exists and returns `True` if the element was successfully removed or `False` otherwise.","solution":"import random class RandomizedSet: def __init__(self): Initialize the data structure which supports average O(1) operations. self.num_map = {} # Mapping from number to its index in the list self.nums_list = [] # List of numbers def pick(self): Randomly select an integer from the list and return it. if not self.nums_list: return None return random.choice(self.nums_list) def remove(self, val): Remove the integer val from the list if it exists. Returns True if the element was successfully removed, otherwise False. if val not in self.num_map: return False # Swap the element to remove with the last element index_to_remove = self.num_map[val] last_element = self.nums_list[-1] # Move the last element to the place of the element to remove self.nums_list[index_to_remove] = last_element self.num_map[last_element] = index_to_remove # Remove the last element from the list and map self.nums_list.pop() del self.num_map[val] return True def insert(self, val): Inserts a value to the set. Returns True if the set did not already contain the specified element. if val in self.num_map: return False self.num_map[val] = len(self.nums_list) self.nums_list.append(val) return True"},{"question":"You are given a 2D grid `board` of size `n x n` where each cell is either empty (represented by the character `\'.\'`) or is an obstacle (represented by the character `\'#\'`). You start from the top-left cell of the grid, and your goal is to move to the bottom-right cell. You can only move in four possible directions: up, down, left, and right. However, you cannot move into a cell that contains an obstacle `\'#\'`. Implement a function to determine the minimum number of moves required to reach the bottom-right cell from the top-left cell. If it is not possible to reach the target cell, return `-1`.","solution":"from collections import deque def min_moves(board): Find the minimum number of moves required to reach the bottom-right cell from the top-left cell in a grid with obstacles. Parameters: - board (List[List[str]]): 2D grid where \'.\' represents an empty cell and \'#\' represents an obstacle Returns: - int: Minimum number of moves to reach the bottom-right cell, or -1 if unreachable if not board or board[0][0] == \'#\' or board[-1][-1] == \'#\': return -1 n = len(board) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([((0, 0), 0)]) # ((current_position), current_steps) visited = set((0, 0)) while queue: (x, y), steps = queue.popleft() if (x, y) == (n-1, n-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and board[nx][ny] == \'.\': queue.append(((nx, ny), steps + 1)) visited.add((nx, ny)) return -1"},{"question":"A sequence of numbers is called **triangular** if it corresponds to the cumulative sums of the first `k` natural numbers, for some `k >= 1`. In other words, a sequence of numbers is triangular if there exists a `k` such that the sequence is the first `k` triangular numbers. Given a sequence of positive integers `nums` of length `n`, return _the length of the longest consecutive subsequence that forms a triangular sequence_. If no such subsequence exists, return `0`. For instance, in the sequence `[1, 3, 6, 2, 5, 10, 15]`, the longest triangular subsequence is `[1, 3, 6]` and has length `3`.","solution":"def longest_triangular_subsequence(nums): Returns the length of the longest consecutive subsequence that forms a triangular sequence. If no such subsequence exists, returns 0. def is_triangular(num): # Check if `num` is a triangular number # Using arithmetic series formula: n(n+1)//2 = num n = ((8 * num + 1) ** 0.5 - 1) / 2 return n == int(n) longest, current_length = 0, 0 for num in nums: if is_triangular(num): current_length += 1 else: longest = max(longest, current_length) current_length = 0 return max(longest, current_length)"},{"question":"Given an array of integers `height` where `height[i]` represents the height of a mountain, you are asked to find the **length of the longest mountain**. A mountain is defined as: - A sequence of at least three integers where: * height[i] < height[i+1] < ... < height[j] for some i < j and * height[j] > height[j+1] > ... > height[k] for some j < k (with a strictly increasing to strictly decreasing sequence). For example, `height` can be `[2, 1, 4, 7, 3, 2, 5]` with a mountain `[1, 4, 7, 3, 2]` of length 5. Given such an array `height`, return _the length of the longest mountain_. If there is no such mountain, return `0`.","solution":"def longest_mountain(height): if not height or len(height) < 3: return 0 n = len(height) longest = 0 for i in range(1, n - 1): if height[i - 1] < height[i] > height[i + 1]: # peak of mountain left = i - 1 while left > 0 and height[left - 1] < height[left]: left -= 1 right = i + 1 while right < n - 1 and height[right] > height[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"You are given a list of `n` tasks, where each task is represented as a tuple (id, duration, dependencies). The `id` is a unique identifier for the task, `duration` is the time it takes to complete the task, and `dependencies` is a list of task ids that must be completed before this task can start. Write a function that returns the minimum time required to complete all tasks. If it\'s impossible to complete all tasks due to a cyclic dependency, return -1.","solution":"from collections import defaultdict, deque def find_min_time(tasks): Returns the minimum time required to complete all tasks considering dependencies. If there\'s a cyclic dependency, returns -1. # Create adjacency list and indegree count adj_list = defaultdict(list) indegree = {task[0]: 0 for task in tasks} duration = {task[0]: task[1] for task in tasks} for task in tasks: for dep in task[2]: adj_list[dep].append(task[0]) indegree[task[0]] += 1 # Initialize queue with tasks having no dependencies queue = deque() for task in tasks: if indegree[task[0]] == 0: queue.append((task[0], task[1])) total_time = 0 completed = 0 task_count = len(tasks) time_taken = {task[0]: 0 for task in tasks} while queue: t, current_time = queue.popleft() total_time = max(total_time, current_time) completed += 1 for neighbor in adj_list[t]: indegree[neighbor] -= 1 time_taken[neighbor] = max(time_taken[neighbor], current_time + duration[neighbor]) if indegree[neighbor] == 0: queue.append((neighbor, time_taken[neighbor])) # Check if all tasks were completed if completed == task_count: return total_time else: return -1"},{"question":"Given a list of `n` integers and a target value `k`, write a function that determines if there are two distinct integers in the list whose sum is equal to `k`. The function should return `true` if such a pair exists, and `false` otherwise.","solution":"def has_pair_with_sum(nums, k): Determines if there are two distinct integers in the list whose sum is equal to k. Args: nums (list of int): List of integers. k (int): Target sum. Returns: bool: True if such a pair exists, false otherwise. seen = set() for num in nums: needed = k - num if needed in seen: return True seen.add(num) return False"},{"question":"You are given a list of `n` integers called `nums` and an integer `pivot`. Rearrange the list such that all elements less than `pivot` come before elements equal to `pivot`, which come before elements greater than `pivot`. Maintain the order of relative elements within each group (less than, equal to, greater than). Return the rearranged list.","solution":"def rearrange_list(nums, pivot): Rearrange the list such that all elements less than pivot come before elements equal to pivot, which come before elements greater than pivot. Maintains the relative order of elements within each group. Parameters: nums (list of int): The list of integers to be rearranged. pivot (int): The pivot element. Returns: list of int: The rearranged list. less_than = [num for num in nums if num < pivot] equal_to = [num for num in nums if num == pivot] greater_than = [num for num in nums if num > pivot] return less_than + equal_to + greater_than"},{"question":"A valid **palindrome** is a string that reads the same forward and backward, ignoring cases and removing all non-alphanumeric characters. For example, `\\"A man, a plan, a canal: Panama\\"` and `\\"race a car\\"` are valid palindromes after conversion. Given a string `s`, determine if it is a valid palindrome. Return `true` if it is a valid palindrome, otherwise return `false`.","solution":"import re def is_palindrome(s): Determines if a string is a valid palindrome. A valid palindrome is a string that reads the same forward and backward, ignoring cases and removing all non-alphanumeric characters. Args: s (str): The input string. Returns: bool: True if the string is a valid palindrome, False otherwise. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() # Check if the cleaned string is equal to its reversed version return cleaned_str == cleaned_str[::-1]"},{"question":"You are given an integer array `A` of length `n`. You are allowed to perform a series of operations on `A`, where in each operation, you can select any subarray of `A` and reverse it. A subarray is defined as a contiguous section of the array. Return the minimum number of operations required to make the entire array sorted in non-decreasing order.","solution":"def min_operations_to_sort(A): Returns the minimum number of operations needed to sort the array A in non-decreasing order. An operation consists of selecting a subarray and reversing it. if not A: return 0 n = len(A) lis = [1] * n # Compute the length of the Longest Increasing Subsequence (LIS) for i in range(1, n): for j in range(i): if A[i] >= A[j]: lis[i] = max(lis[i], lis[j] + 1) lis_length = max(lis) # The minimum operations required is the length of the array minus the length # of the LIS because it shows how many elements are already in order. return n - lis_length"},{"question":"You are given a string `s` of lowercase English letters and an integer `k`. You can insert any character at any position in the string `s` exactly `k` times. Return the lexicographically smallest string you can achieve after performing exactly `k` insertions.","solution":"def smallest_string_after_insertions(s, k): Return the lexicographically smallest string by inserting any character exactly k times. return \\"a\\" * k + s"},{"question":"Given an integer array `arr` that contains both negative and positive integers, return the sum of the maximum subarray. A subarray is a contiguous part of an array. For example, given the array `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the maximum subarray is `[4, -1, 2, 1]`, with a sum of `6`.","solution":"def max_subarray_sum(arr): Returns the sum of the maximum subarray. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a linked list, split the linked list into `k` consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null, meaning they are effectively empty. Return an array of the `k` parts. Example: ``` Input: head = [1, 2, 3], k = 5 Output: [[1], [2], [3], [], []] Explanation: The linked list should be split into 5 parts, resulting in the following format: [ [1], [2], [3], [], [] ] ``` Note: - Each element of the output array should be a ListNode object representing the start of the resulting linked list part. - If `head` is `null`, then output should be an array containing `k` `null` elements. - The given linked list might have less than `k` elements. In this scenario, the remaining parts should be empty lists.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_list_to_parts(head, k): def get_length(head): length = 0 while head: length += 1 head = head.next return length length = get_length(head) part_length = length // k extra = length % k parts = [] current = head for i in range(k): part_size = part_length + (1 if i < extra else 0) part_head, part_tail = None, None for j in range(part_size): if part_head is None: part_head = part_tail = ListNode(current.val) else: part_tail.next = ListNode(current.val) part_tail = part_tail.next if current: current = current.next parts.append(part_head) return parts"},{"question":"You are given an HTML-like string component consisting of opening tags \\"<tag>\\", closing tags \\"</tag>\\", and text in between. Tags can be nested within one another. Each tag can have multiple attributes represented in the format \\"<tag key1=\\"value1\\" key2=\\"value2\\">\\". Attributes are guaranteed not to have spaces within values and are enclosed in double quotes. Tags are case-sensitive. You are required to write a function that performs two operations: 1. Retrieve the value of a specific attribute from a given tag within the string. 2. Return the entire content found within a specific tag. Implement the `HTMLParser` class: - `HTMLParser(String html)` -- Initializes the parser with the given HTML string. - `String getAttribute(String tag, String attribute)` -- Returns the value of the `attribute` from the first occurrence of the `tag` in the HTML string. If the `attribute` or `tag` does not exist, return `null`. - `String getContent(String tag)` -- Returns the content inside the first occurrence of the `tag` in the HTML string. If the `tag` does not exist, return `null`. Note: It is guaranteed that the provided HTML string is well-formed.","solution":"import re class HTMLParser: def __init__(self, html): self.html = html def getAttribute(self, tag, attribute): pattern = f\\"<{tag}[^>]*b{attribute}=\\"([^\\"]*)\\"[^>]*>\\" match = re.search(pattern, self.html) if match: return match.group(1) return None def getContent(self, tag): pattern = f\\"<{tag}[^>]*>(.*?)</{tag}>\\" match = re.search(pattern, self.html, re.DOTALL) if match: return match.group(1) return None"},{"question":"You are given an integer array `height` of length `n` representing the heights of `n` buildings. Two buildings are considered adjacent if their indices are consecutive. You can collect water between two adjacent buildings if the height of both buildings is greater than zero and there is lower height building in between them. Return _the amount of water you can collect using these buildings_. The water collected between two buildings is determined by the shorter of the two heights.","solution":"def trap(height): Returns the amount of water that can be collected between buildings. if not height: return 0 n = len(height) left = 0 right = n - 1 left_max = height[left] right_max = height[right] water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water += max(0, right_max - height[right]) return water"},{"question":"Given a 2D matrix `mat` of size `m x n` where each cell contains an integer, write a function to determine the maximum sum of any rectangle from the matrix. A rectangle is defined by its top-left and bottom-right corners, and it should contain at least one element. The function should return the highest possible sum you can obtain from any such rectangle in the matrix. Note that the matrix can contain both positive and negative integers.","solution":"def max_sum_submatrix(mat): Returns the maximum sum of any rectangle in a 2D matrix. :param mat: List of List of integers representing the matrix :return: Integer representing the maximum rectangle sum if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) max_sum = float(\'-inf\') for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += mat[i][right] max_sum = max(max_sum, max_sum_subarray(temp)) return max_sum def max_sum_subarray(arr): Helper function to find the maximum sum of a subarray in a 1D array using Kadane\'s algorithm. current_max = global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"A **Cache** is a data structure that stores a subset of data, typically in a memory location faster to access than the primary data storage. Implement the `LRUCache` class: * `LRUCache(int capacity)` Initializes the cache with a **maximum** size `capacity`. * `int get(int key)` Returns the value associated with the key if it exists in the cache, otherwise returns `-1`. Marks the key as most recently used. * `void put(int key, int value)` Sets or inserts the value `value` for the key `key`. If the key already exists, update the value and mark the key as most recently used. If the cache is at capacity, evicts the least recently used key to make space. **Note**: The cache contains only `unique keys`.","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: lru = self.order.pop(0) del self.cache[lru] self.cache[key] = value self.order.append(key)"},{"question":"Given a string `s` containing digits from \'2\' to \'9\' inclusive, return all possible letter combinations that the number could represent. The mapping of digit to letters is as follows: ``` 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" ``` Note that 1 does not map to any letters. Write a function that takes in a string `s` and returns a list of all possible letter combinations that the number could represent in lexicographical order. The input string will have a length between 0 and 4.","solution":"from itertools import product def letter_combinations(s): Returns all possible letter combinations that the number could represent in lexicographical order. if not s: return [] phone_map = { \'2\': \\"abc\\", \'3\': \\"def\\", \'4\': \\"ghi\\", \'5\': \\"jkl\\", \'6\': \\"mno\\", \'7\': \\"pqrs\\", \'8\': \\"tuv\\", \'9\': \\"wxyz\\" } chars = [phone_map[digit] for digit in s] combinations = [\'\'.join(combo) for combo in product(*chars)] return sorted(combinations)"},{"question":"You are given a 2D grid of dimensions `m x n` filled with non-negative integers. A position `(i, j)` in the grid is called a \\"peak\\" if it\'s greater than or equal to its four possible neighbors: above, below, left, and right. Note that the edge positions on the grid have fewer than four neighbors. Write a function to find the coordinates of any one peak in the grid. If multiple peaks exist, return the coordinates of any one of them.","solution":"def find_peak(grid): This function finds any one peak in a 2D grid where a peak is defined as a position which has a value greater than or equal to its four neighbors (left, right, above, below). Args: grid (list of list of int): The 2D grid of non-negative integers. Returns: tuple: Coordinates (i, j) of any one peak in the grid. m, n = len(grid), len(grid[0]) def is_peak(i, j): Helper function to check if a position (i, j) is a peak Args: i (int): Row coordinate. j (int): Column coordinate. Returns: bool: True if the position is a peak, False otherwise. neighbors = [] if i > 0: neighbors.append(grid[i - 1][j]) # above if i < m - 1: neighbors.append(grid[i + 1][j]) # below if j > 0: neighbors.append(grid[i][j - 1]) # left if j < n - 1: neighbors.append(grid[i][j + 1]) # right for neighbor in neighbors: if grid[i][j] < neighbor: return False return True for i in range(m): for j in range(n): if is_peak(i, j): return (i, j) return (-1, -1) # Return (-1, -1) if no peak found, which should not happen in this problem as per definition."},{"question":"Write a function to find the **lowest common ancestor (LCA)** of two given nodes in a binary search tree (BST). According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). Given a BST with unique values, write a function to return the LCA of two given nodes `p` and `q`. Example: ```python # Given binary search tree: # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 # Example usage: # p = TreeNode(2) # q = TreeNode(8) # LCA of 2 and 8 is 6. # p = TreeNode(2) # q = TreeNode(4) # LCA of 2 and 4 is 2. ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\': Returns the lowest common ancestor (LCA) of two given nodes p and q in a BST. # Traverse the tree while root: # If both p and q are lesser than root, then LCA lies in left subtree if p.val < root.val and q.val < root.val: root = root.left # If both p and q are greater than root, then LCA lies in right subtree elif p.val > root.val and q.val > root.val: root = root.right else: # This is the split point: one is on one side and the other is on the other side return root return None # This should not be reached if p and q are in the tree"},{"question":"Given a list of integers `nums`, return the list with all duplicates removed. The order of the elements in the result should be the same as their first occurrence in the original list. For example, if `nums = [4, 3, 2, 4, 1, 3, 2]`, the return should be `[4, 3, 2, 1]`.","solution":"def remove_duplicates(nums): Removes duplicates from the list while maintaining the order of the first occurrence. Parameters: nums (list): The list of integers from which to remove duplicates. Returns: list: A list with duplicates removed. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"A company is designing a new program to help manage its network of servers. To do this, they need a function that can efficiently evaluate the shortest path for data to travel between different servers. The network is represented as a weighted, directed graph with `n` nodes (servers) numbered from `0` to `n - 1`. The edges are represented as a 2D integer array `edges` where `edges[i] = [ui, vi, weighti]` denotes a directed edge from server `ui` to server `vi` with an associated transmission time of `weighti`. Given a starting server `start` and a destination server `end`, write a function to compute the **shortest transmission time** from `start` to `end`. If there is no path from `start` to `end`, return `-1`.","solution":"import heapq def shortest_path(n, edges, start, end): Computes the shortest transmission time from start to end in a weighted, directed graph. :param n: Number of nodes (servers) :param edges: List of edges where each edge is represented as [ui, vi, weighti] :param start: Starting node :param end: Destination node :return: Shortest transmission time from start to end, or -1 if no such path exists graph = {i: [] for i in range(n)} for ui, vi, weight in edges: graph[ui].append((vi, weight)) pq = [(0, start)] # Priority queue to hold (current_time, current_node) dist = {i: float(\'inf\') for i in range(n)} dist[start] = 0 while pq: current_time, current_node = heapq.heappop(pq) if current_node == end: return current_time if current_time > dist[current_node]: continue for neighbor, weight in graph[current_node]: time = current_time + weight if time < dist[neighbor]: dist[neighbor] = time heapq.heappush(pq, (time, neighbor)) return -1"},{"question":"There are `n` buildings in a city, each with a certain height represented by an array `heights`, where `heights[i]` is the height of the `i-th` building. You are given an integer `k` representing the maximum number of adjacent buildings you can consider at once. You can paint exactly `k` consecutive buildings to cover them. Your objective is to paint those `k` buildings such that the maximum height among the painted buildings is minimized. Return _the minimum possible maximum height_ after painting any such `k` consecutive buildings.","solution":"def min_possible_max_height(heights, k): Returns the minimum possible maximum height after painting any k consecutive buildings. :param heights: List of integers representing the heights of buildings. :param k: Integer representing the number of consecutive buildings to consider. :return: Integer representing the minimum possible maximum height. n = len(heights) min_max_height = float(\'inf\') for i in range(n - k + 1): current_max_height = max(heights[i:i + k]) min_max_height = min(min_max_height, current_max_height) return min_max_height"},{"question":"Given an integer array `arr`, return _the **minimum sum** of a **non-empty** increasing subsequence_ of `arr`. An array `a` is a subsequence of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b` without changing the order of the remaining elements. An increasing subsequence is defined as a subsequence where each element is strictly greater than the one before it.","solution":"def min_increasing_subseq_sum(arr): Returns the minimum sum of a non-empty increasing subsequence of arr. if not arr: return 0 n = len(arr) min_sum = [float(\'inf\')] * n # Initialize min_sum array with values of arr for i in range(n): min_sum[i] = arr[i] # Find the minimum sum of an increasing subsequence for i in range(1, n): for j in range(i): if arr[i] > arr[j] and min_sum[i] > arr[i] + min_sum[j]: min_sum[i] = arr[i] + min_sum[j] # The result is the minimum value in the min_sum array return min(min_sum)"},{"question":"Implement the class `WordDictionary` which supports the following operations: 1. `addWord(String word)` - Adds a word into the data structure. 2. `search(String word)` - Searches for a word in the data structure. The word can contain the dot character `\'.\'` which can represent any one letter. # Example: ``` WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\\"bad\\"); wordDictionary.addWord(\\"dad\\"); wordDictionary.addWord(\\"mad\\"); wordDictionary.search(\\"pad\\"); // return False wordDictionary.search(\\"bad\\"); // return True wordDictionary.search(\\".ad\\"); // return True wordDictionary.search(\\"b..\\"); // return True ```","solution":"class WordDictionary: def __init__(self): self.dictionary = {} def addWord(self, word): node = self.dictionary for char in word: if char not in node: node[char] = {} node = node[char] node[\'\'] = True # End of word marker def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for x in node: if x != \'\' and search_in_node(word[i+1:], node[x]): return True return False else: if char not in node: return False node = node[char] return \'\' in node return search_in_node(word, self.dictionary)"},{"question":"Write a function `decodeString(s)` where `s` is an encoded string containing digits, alphabetic characters, and square brackets. The encoding rule is: `k[encoded_string]`, meaning that the `encoded_string` inside the square brackets is repeated exactly `k` times. You may assume that the input string is always valid. No extra white spaces, square brackets are well-formed. Return the decoded string. For example: - `decodeString(\\"3[a]2[bc]\\")` would return `\\"aaabcbc\\"`. - `decodeString(\\"3[a2[c]]\\")` would return `\\"accaccacc\\"`. - `decodeString(\\"2[abc]3[cd]ef\\")` would return `\\"abcabccdcdcdef\\"`.","solution":"def decodeString(s: str) -> str: Decodes the given encoded string s as per the encoding rules. stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': previous_string, repeat_count = stack.pop() current_string = previous_string + current_string * repeat_count else: current_string += char return current_string"},{"question":"Assume you have an array of `n` integers. You need to write a function that returns a subarray with the maximum possible sum. The subarray must have at least one element. A subarray is a contiguous portion of an array. For example, given the array `[2,1,3,4,1,2,1,5,4]`, the subarray `[4,1,2,1]` has the largest sum, which is `6`. Return the sum of the subarray with the maximum sum.","solution":"def max_subarray_sum(nums): Returns the sum of the subarray with the maximum sum. if not nums: raise ValueError(\\"The input array is empty\\") max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `arr` consisting of positive integers and an integer `k`. The task is to determine the minimum sum of any contiguous subarray of length `k` in the given array. A contiguous subarray is a range of elements from the array that are adjacent to each other. Return _the **minimum sum** of any contiguous subarray of length `k`_.","solution":"def min_sum_subarray(arr, k): Returns the minimum sum of any contiguous subarray of length k. Parameters: arr (list): List of positive integers. k (int): Length of the subarray. Returns: int: Minimum sum of any contiguous subarray of length k. # Initial sum of the first subarray of length k min_sum = sum(arr[:k]) current_sum = min_sum # Slide the window over the array for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"You are given two strings `s1` and `s2`. Your task is to determine if there exists a permutation of `s1` that is a substring of `s2`. In other words, check if a rearrangement of `s1` can appear in `s2` as a contiguous block of characters. Return `true` if such a permutation exists, and `false` otherwise.","solution":"from collections import Counter def check_permutation_in_string(s1, s2): Determines if any permutation of s1 is a substring of s2. Parameters: s1 (str): The string to form permutations from. s2 (str): The string to check for the presence of permutations of s1. Returns: bool: True if any permutation of s1 is a substring of s2, otherwise False. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) if s1_counter == window_counter: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] new_char = s2[i] window_counter[new_char] += 1 if window_counter[start_char] > 1: window_counter[start_char] -= 1 else: del window_counter[start_char] if s1_counter == window_counter: return True return False"},{"question":"Given an array of integers `nums` where each integer represents the position of a stone on a number line, determine if you can cross the river by jumping from stone to stone. You start at the first stone (position 0) and your goal is to reach the last stone. You can only jump to a stone that is in the `nums` array, and the jump must be the same distance as your previous jump, or one unit less, or one unit more. The first jump must be exactly one unit. Return `true` if you can cross the river, otherwise return `false`.","solution":"def canCross(nums): Determine if you can cross the river by jumping from stone to stone on the given array of positions. Parameters: nums (list): List of integers representing the positions of stones on a river. Returns: bool: True if you can cross the river, False otherwise. if not nums or nums[0] != 0: return False from collections import defaultdict positions = set(nums) jumps = {pos: set() for pos in nums} jumps[0].add(0) # starting position, previous jump was 0 for position in nums: for jump in jumps[position]: for new_jump in {jump - 1, jump, jump + 1}: if new_jump > 0 and (position + new_jump) in positions: jumps[position + new_jump].add(new_jump) return bool(jumps[nums[-1]])"},{"question":"You are given a string `expression` representing an expression containing digits and the characters `+`, `-`, `*`, and `/` (without parentheses). Implement a function that evaluates the expression and returns the result as an integer. The integer division should truncate towards zero. You can assume that the given expression is always valid. For example, given `expression = \\"3+2*2\\"`, the function should return `7`.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing +, -, *, and / (integer division). Parameters: expression (str): The expression string to be evaluated. Returns: int: The result of the evaluated expression. # Initialize the variables stack = [] current_number = 0 operation = \'+\' # Iterate through each character in the string for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if operation == \'+\': stack.append(current_number) elif operation == \'-\': stack.append(-current_number) elif operation == \'*\': stack.append(stack.pop() * current_number) elif operation == \'/\': stack.append(int(stack.pop() / current_number)) operation = char current_number = 0 # Sum up values in the stack return sum(stack)"},{"question":"Given an `m x n` grid that represents fields, each cell contains an integer that represents the height of the field at that position. Your objective is to find the longest increasing path in the field grid. The length of the path is defined by the number of cells it traverses. You can only move up, down, left, or right from a cell to an adjacent cell. The path cannot visit the same cell more than once. Return the length of the longest increasing path.","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) cache = [[-1]*n for _ in range(m)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_length = 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) cache[x][y] = max_length return max_length max_path_len = 0 for i in range(m): for j in range(n): max_path_len = max(max_path_len, dfs(i, j)) return max_path_len"},{"question":"You are given a **m x n** binary grid `grid` where `0` represents an empty cell and `1` represents a blocked cell. The grid represents a maze in which you can move up, down, left, or right from an empty cell to another empty cell. You are also given two pairs of coordinates `start` and `end` representing the starting and ending positions in the maze. Your task is to find the **shortest path** from the `start` cell to the `end` cell. Return the length of the shortest path in the maze. If there is no valid path from `start` to `end`, return `-1`. The test cases are generated in such a way that you are guaranteed to either find a valid path or determine that no path is possible.","solution":"from collections import deque def shortest_path_maze(grid, start, end): Returns the length of the shortest path from start to end in the grid. Returns -1 if no such path exists. # Check if the start or end points are blocked if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to find the **smallest subarray** (contiguous elements) of `arr` whose sum is **greater than** or **equal to** `target`. If no such subarray exists, return `0`. The subarray must be of size at least `1`.","solution":"def smallest_subarray_with_target_sum(arr, target): Returns the length of the smallest subarray with a sum greater than or equal to target. If no such subarray exists, return 0. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. The string can be rearranged such that every `k` consecutive characters are unique. Return `_true` if it is possible to rearrange the string in such a way, otherwise return `false.` For example, given the string `s = \\"aabbcc\\"` and `k = 3`, one possible rearrangement could be `\\"abcabc\\"` where every 3 consecutive characters are unique.","solution":"from collections import Counter from heapq import heapify, heappop, heappush def can_rearrange_string(s: str, k: int) -> bool: if k == 0: return True counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapify(max_heap) queue = [] result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) queue.append((freq + 1, char)) # decrement the frequency if len(queue) >= k: popped = queue.pop(0) if popped[0] < 0: heappush(max_heap, popped) return len(result) == len(s)"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. In one operation, select any index `i` and update `arr[i]` to be equal to `arr[i] + k` or `arr[i] - k`. Return _the **minimum number** of operations required to make all elements of_ `arr` _equal_. If it is impossible to make all elements equal, return `-1`.","solution":"def min_operations_to_equalize(arr, k): Given a 0-indexed integer array arr and an integer k, this function returns the minimum number of operations required to make all elements in arr equal by either adding or subtracting k to any element. If it is impossible, it returns -1. mod_set = set(element % k for element in arr) # All elements must have the same remainder when divided by k if len(mod_set) > 1: return -1 # All elements can be made equal, return 0 operations since they already contain the same residue mod k return 0"},{"question":"Implement a function `isSubsequence(s, t)` that takes in two strings `s` and `t`, and returns `true` if `s` is a subsequence of `t`, or `false` otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.","solution":"def isSubsequence(s, t): Returns True if \'s\' is a subsequence of \'t\', otherwise False. s_len = len(s) t_len = len(t) s_index = 0 t_index = 0 while s_index < s_len and t_index < t_len: if s[s_index] == t[t_index]: s_index += 1 t_index += 1 return s_index == s_len"},{"question":"You are given two integer arrays `arr1` and `arr2` of length `n`. A swap operation consists of picking any two indices `i` and `j` (0  i, j < n) and swapping `arr1[i]` with `arr2[j]`. Return _the minimum number of swap operations needed_ to make `arr1` and `arr2` identical. If it is not possible to make the arrays identical, return `-1`.","solution":"def min_swaps_to_identical(arr1, arr2): Returns the minimum number of swap operations needed to make arr1 and arr2 identical. If it is not possible to make the arrays identical, returns -1. if sorted(arr1) != sorted(arr2): return -1 n = len(arr1) count = 0 for i in range(n): if arr1[i] != arr2[i]: target_index = arr2.index(arr1[i], i) arr2[i], arr2[target_index] = arr2[target_index], arr2[i] count += 1 return count"},{"question":"You are given a string `s` and a list of words `wordDict` representing a dictionary of words. Add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. A valid sentence is defined as dividing the string `s` into one or more words such that each word is present in `wordDict`. You may assume that the dictionary does not contain duplicate words. For example, given `s = \\"catsanddog\\"` and `wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]`, the function should return: ```python [ \\"cats and dog\\", \\"cat sand dog\\" ] ```","solution":"def word_break(s, wordDict): def backtrack(index, path): if index == len(s): result.append(\\" \\".join(path)) return for end in range(index + 1, len(s) + 1): word = s[index:end] if word in wordDict: backtrack(end, path + [word]) wordSet = set(wordDict) result = [] backtrack(0, []) return result"},{"question":"Given a string `s1`, we may represent it as a binary tree by partitioning it into two non-empty substrings recursively. A binary tree string `s2` is a scramble of a binary tree string `s1` if we can obtain the binary tree string `s2` by recursively swapping the left and right children of some nodes of the binary tree representation of `s1`. You are given two strings `s1` and `s2` of the same length, and you need to determine if `s2` is a scrambled string of `s1`. Write a function that returns `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`. **Note** - `s1` and `s2` consist of lowercase English letters only. - The length of both strings is between 1 and 30.","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. Args: s1 (str): The original string s2 (str): The scrambled string to check Returns: bool: True if s2 is a scrambled string of s1, False otherwise # A base case if s1 == s2: return True # Pruning if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if there is a match by dividing and conquering if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"You are given a **0-indexed** array of integers `prices` where `prices[i]` is the price of a given stock on the `i-th` day. You are also given an integer `fee` representing the transaction fee for buying and selling the stock. Your goal is to maximize the profit by choosing a subset of days to buy and sell the stock such that after each buy transaction, there is exactly one sell transaction. Return _the maximum profit you can achieve_. **Note**: You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. However, you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you can buy again).","solution":"def max_profit(prices, fee): Returns the maximum profit which can be achieved. params: prices: List[int] - array of stock prices fee: int - transaction fee for each buy-sell returns: int - maximum profit achievable cash, hold = 0, -prices[0] for price in prices[1:]: cash = max(cash, hold + price - fee) hold = max(hold, cash - price) return cash"},{"question":"A text editor allows users to perform different operations on a string `s` which is initially empty. The operations supported by the editor are: 1. **Append**: Add a new character to the end of the string. 2. **Delete**: Remove the last character from the string. 3. **Replace**: Replace a character at a specified position with a new character. 4. **Undo**: Revert the last operation. The goal is to implement this text editor with the following methods: * `TextEditor()`: Initializes the text editor. * `void append(char c)`: Appends character `c` to the end of the string. * `void delete()`: Removes the last character from the string. * `void replace(int position, char c)`: Replaces the character at the given 1-indexed `position` with `c`. * `void undo()`: Reverts the last operation made on the string. * `string getContent()`: Returns the current content of the string. Implement the `TextEditor` class to support the described operations efficiently. Note that the number of operations may be large, and the solution should be optimized accordingly.","solution":"class TextEditor: def __init__(self): self.content = [] self.history = [] def append(self, c): self.history.append((\'delete\', len(self.content))) self.content.append(c) def delete(self): if self.content: last_char = self.content.pop() self.history.append((\'append\', last_char)) def replace(self, position, c): if 1 <= position <= len(self.content): old_char = self.content[position-1] self.content[position-1] = c self.history.append((\'replace\', position, old_char)) def undo(self): if self.history: last_operation = self.history.pop() if last_operation[0] == \'append\': self.content.append(last_operation[1]) elif last_operation[0] == \'delete\': del self.content[last_operation[1]:] elif last_operation[0] == \'replace\': self.content[last_operation[1]-1] = last_operation[2] def getContent(self): return \'\'.join(self.content)"},{"question":"You are given a list of `n` integers representing the heights of pillars arranged in a line. The width of each pillar is `1`. We want to place boards atop these pillars such that we maximize the total surface area covered by the boards. A board can only be placed on top of consecutive pillars that are of the same height. You need to find out the maximum surface area covered by the boards. Return the maximum surface area that can be covered by boards.","solution":"def max_board_surface_area(pillars): Returns the maximum surface area covered by boards placed on top of the pillars. A board can be placed on top of consecutive pillars that are of the same height. if not pillars: return 0 max_area = 0 current_height = pillars[0] current_length = 1 for i in range(1, len(pillars)): if pillars[i] == current_height: current_length += 1 else: max_area = max(max_area, current_height * current_length) current_height = pillars[i] current_length = 1 max_area = max(max_area, current_height * current_length) return max_area"},{"question":"You are given an array `events` where each `events[i]` is a pair of start and end times of the event `[startTimei, endTimei]`. All the events are closed intervals, meaning they include both their start and end times. Given a query time `q`, return the number of events that are ongoing at `q`. An event is considered ongoing at `q` if `startTimei <= q <= endTimei`.","solution":"def count_ongoing_events(events, q): Returns the number of events ongoing at time q. An event is considered ongoing if startTimei <= q <= endTimei. Parameters: events (list of lists): A list of events where each event is represented as [startTime, endTime] q (int): The query time to check the number of ongoing events. Returns: int: The number of ongoing events at time q. return sum(start <= q <= end for start, end in events)"},{"question":"Given an array of integers representing the heights of buildings on a street, where the width of each building is 1 unit. Compute the maximum area of water that can be trapped between two buildings after raining. The water cannot spill over the edges of the array, and each building must be able to support as much water as possible without collapsing. --- This question aligns with the original set in terms of style, complexity, and scope. It examines knowledge of algorithms and problem-solving skills regarding arrays and the two-pointer technique, which is consistent with the themes in the other questions.","solution":"def max_area_trapped_water(heights): Returns the maximum area of water that can be trapped between the buildings. :param heights: List[int] - A list of integers representing the heights of buildings. :return: int - The maximum area of water trapped. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"In an online store, the number of visitors can be tracked by a list where each element represents the number of visitors on a different day. During an observation period, the store wants to find out the longest stretch of consecutive days where the visitor count was consistently increasing. Write a function that takes an integer array `visitors` where `visitors[i]` represents the number of visitors on the `i-th` day and returns the length of the longest increasing subsequence of consecutive days. Note: An increasing subsequence of consecutive days is defined as a sequence where `visitors[i] < visitors[i+1]` for all `i` in the sequence.","solution":"def longest_increasing_streak(visitors): Returns the length of the longest increasing subsequence of consecutive days. :param visitors: List[int] - a list where each element represents the number of visitors on a different day. :return: int - the length of the longest increasing subsequence of consecutive days. if not visitors: return 0 longest_streak = 1 current_streak = 1 for i in range(1, len(visitors)): if visitors[i] > visitors[i - 1]: current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 1 return longest_streak"},{"question":"You are given a string `s` consisting of lowercase English letters. A **subsequence** of `s` is considered balanced if the number of occurrences of \'a\', \'b\', and \'c\' are all equal. Determine the length of the shortest balanced subsequence of `s`. If no such subsequence exists, return -1.","solution":"def shortest_balanced_subsequence(s): Returns the length of the shortest balanced subsequence of the given string. A subsequence is balanced if it contains an equal number of \'a\', \'b\', and \'c\'. count_a = count_b = count_c = 0 # Count the occurrences of \'a\', \'b\', and \'c\' in the string for char in s: if char == \'a\': count_a += 1 elif char == \'b\': count_b += 1 elif char == \'c\': count_c += 1 # The smallest count will determine the possible length of the balanced subsequence min_count = min(count_a, count_b, count_c) if min_count == 0: return -1 else: return min_count * 3"},{"question":"Consider a class `MovingAverage` that calculates the moving average of the last `k` values from a stream of integers. Implement the `MovingAverage` class: * `MovingAverage(int size)` Initializes the object with the size `k` of the moving window. * `double next(int val)` Adds the integer `val` to the stream and returns the current moving average of the last `k` integers. You can assume that the `next` method will only be called with at least `k` prior calls and that the moving average will always fit into a double without precision issues.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque() self.total = 0.0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.total -= self.queue.popleft() self.queue.append(val) self.total += val return self.total / len(self.queue)"},{"question":"Given an integer array `arr` and two integers `k` and `m`, find the **m** most frequent elements in `arr`. If there are multiple elements with the same frequency, select the smallest elements numerically. Return these elements in an array sorted in descending order of their frequency. If multiple elements have the same frequency, they should appear in ascending order within their frequency group. For example, given `arr = [4, 5, 1, 1, 2, 3, 5, 5, 4]`, `k = 2`, and `m = 3`, the most frequent elements would be `[5, 1, 4]`, as `5` appears `3` times, `1` appears `2` times, and `4` appears `2` times.","solution":"from collections import Counter def most_frequent_elements(arr, k, m): Finds the m most frequent elements in arr. :param arr: List of integers. :param k: Unused parameter. :param m: Number of most frequent elements to return. :return: List of m most frequent elements sorted by their frequency in descending order. if not arr: return [] # Count the frequency of each element freq_counter = Counter(arr) # Sort the items by frequency and then by the value (ascending order for ties) sorted_items = sorted(freq_counter.items(), key=lambda x: (-x[1], x[0])) # Extract the top m elements result = [item[0] for item in sorted_items[:m]] return result"},{"question":"Given a positive integer `x`, return the smallest number `y` such that the product of all digits of `y` equals `x`. If no such number exists, return `-1`. Note that `y` should not have leading zeroes except for the case when `x` is `0` (for which `y` should be `0`).","solution":"def smallest_number_with_digit_product(x): Returns the smallest number y such that the product of all digits of y equals x. If no such number exists, returns -1. if x == 0: return 10 if x == 1: return 1 factors = [] for i in range(9, 1, -1): while x % i == 0: factors.append(i) x //= i if x != 1: return -1 factors.sort() result = int(\'\'.join(map(str, factors))) return result"},{"question":"A **binary tree** contains nodes that each have a value and up to two child nodes. A node is considered a **leaf** if it does not have any children. Given the `root` of a binary tree, find all the **paths** from the `root` to a leaf. Each path should be represented as a list of node values, starting from the `root` and ending at a leaf. The output should be a list of these paths, where each path is represented as a list of integers. If the tree is empty, return an empty list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given the root of a binary tree, returns all root-to-leaf paths. def dfs(node, path, paths): if not node: return path.append(node.val) if not node.left and not node.right: # Current node is a leaf paths.append(list(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() # Backtrack paths = [] dfs(root, [], paths) return paths"},{"question":"You are given a list of strings `words` consisting of different words. Two words `a` and `b` are considered similar if they have the same set of characters (irrespective of order and frequency). Implement a function `findSimilarGroups(words)` that returns the number of groups of similar words in the list. Each word belongs to exactly one group, and each group comprises words that are all similar to each other.","solution":"def findSimilarGroups(words): Given a list of words, return the number of groups of similar words. Two words are considered similar if they have the same set of characters. def word_to_char_set(word): return frozenset(word) unique_groups = set() for word in words: char_set = word_to_char_set(word) unique_groups.add(char_set) return len(unique_groups)"},{"question":"Given a 2D integer matrix `matrix` of dimensions `m x n`, return _the maximum sum of any **submatrix**_. A **submatrix** is defined as a contiguous block of the original matrix. You need to ensure that the submatrix sum is the largest possible among all possible submatrices of the given matrix.","solution":"def max_sum_submatrix(matrix): def kadane(arr): Helper function to implement Kadane\'s algorithm. max_sum = cur_sum = arr[0] for num in arr[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') # Iterate over all possible left and right column bounds for left in range(n): temp = [0] * m for right in range(left, n): # Update the row sums for the current right column for i in range(m): temp[i] += matrix[i][right] # Use Kadane\'s algorithm to find the max sum of the current subarray max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to use the elements in the `nums` array to add up to the `target` value, but each element in the `nums` array can only be used once. Return _the list of indices_ of the elements in `nums` that add up to the `target`. If there are multiple solutions, you can return any one of them. Assume that there is exactly one solution.","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target. Args: nums : List[int] : List of integers target : int : Target sum Returns: List[int] : List of two indices of the numbers that add up to the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"Given an array of integers `arr` and an integer `k`, your task is to add the minimum number of elements to `arr` such that there are exactly `k` different integers present in the final array. If it is not possible to create an array with exactly `k` different integers, return -1. Example 1: - Input: `arr = [1, 2, 2]`, `k = 3` - Output: `1` - Explanation: We can add 3 to the array to make it `[1, 2, 2, 3]`. Example 2: - Input: `arr = [1, 1, 2, 2, 3, 3]`, `k = 2` - Output: `-1` - Explanation: Since there are already 3 different integers in the array (`1`, `2`, and `3`), it is impossible to have exactly 2 different integers. Example 3: - Input: `arr = [1, 1, 1, 1]`, `k = 2` - Output: `1` - Explanation: We can add 2 to the array to make it `[1, 1, 1, 1, 2]`. Ensure that your implementation handles the addition of elements in an optimal manner and correctly determines the impossibility cases.","solution":"def add_minimum_elements(arr, k): Adds the minimum number of elements to arr such that there are exactly k different integers in the final array. If it is not possible, returns -1. unique_elements = set(arr) num_unique_elements = len(unique_elements) if num_unique_elements == k: return 0 elif num_unique_elements > k: return -1 else: return k - num_unique_elements"},{"question":"Given a binary string `bits`, reverse all the bits of the string (i.e., 0 becomes 1 and 1 becomes 0). The input binary string will have a length of up to `10^5`. Return the reversed binary string.","solution":"def reverse_bits(bits): Reverses all the bits in a binary string. Parameters: bits (str): The input binary string. Returns: str: The reversed binary string. return \'\'.join(\'1\' if bit == \'0\' else \'0\' for bit in bits)"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find the **minimum** number of operations needed to make the sum of the array equal to `target`. In one operation, you can select any element from the array and modify it to any integer. If it is not possible to make the sum equal to `target`, return -1.","solution":"def min_operations_to_target(nums, target): Returns the minimum number of operations needed to make the sum of the array equal to target. If it is not possible, return -1. current_sum = sum(nums) difference = abs(current_sum - target) # One operation can modify any element to any integer, # so we need only one operation to change the entire sum by (target - current_sum) return 1 if difference != 0 else 0"},{"question":"In a social network, users are represented as nodes, and friendships are represented as undirected edges between nodes. You are given an integer `n` representing the number of users (nodes) and a list of pairs `edges` where each pair `[a, b]` represents a friendship between user `a` and user `b`. Write a function that returns the number of connected components in the network. A connected component is a subset of users such that there exists a path between any two users in this subset.","solution":"def count_connected_components(n, edges): def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adj_list = {i: [] for i in range(n)} for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) visited = set() components = 0 for node in range(n): if node not in visited: visited.add(node) dfs(node, visited, adj_list) components += 1 return components"},{"question":"Given an array of integers `nums`, find the most frequent element in the array. If there are multiple elements with the same highest frequency, return the smallest element among them. Return the _most frequent element_.","solution":"from collections import Counter def most_frequent_element(nums): Returns the most frequent element in the array. In case of a tie, returns the smallest element among the most frequent ones. if not nums: return None count = Counter(nums) max_frequency = max(count.values()) most_frequent_elements = [num for num, freq in count.items() if freq == max_frequency] return min(most_frequent_elements)"},{"question":"You are given a string `s` representing a sequence of characters, which includes lowercase alphabets and may contain duplicates. Implement a function that rearranges the characters in the string `s` such that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, return an empty string. Otherwise, return the rearranged string.","solution":"from collections import Counter from heapq import heappop, heappush def reorganize_string(s): Rearrange the string such that no two adjacent characters are the same. If it is not possible, return an empty string. :param s: A string with lowercase alphabets :return: Reorganized string or empty string if it\'s not possible counter = Counter(s) max_heap = [] # Build a max heap based on character frequencies for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) # If the previous character needs to be pushed back into the heap, do that if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char # decrement the frequency result_str = \'\'.join(result) # Check if the resulting string length matches the input string length if len(result_str) == len(s): return result_str else: return \'\'"},{"question":"A tree is an undirected graph in which any two nodes are connected by exactly one path. Given a tree with `n` nodes labeled from `0` to `n - 1`, you are also given an array `values` where `values[i]` represents the value associated with the node `i`. Your task is to find the maximum sum of values starting from node `0` and traversing to any leaf node. Implement the function `maxLeafPathSum(int n, List<List<Integer>> edges, int[] values)`: * `maxLeafPathSum(int n, List<List<Integer>> edges, int[] values)`: where `n` is the number of nodes, `edges` is a list of lists representing the edges of the tree, and `values` is an array of integers. The function should return an integer representing the maximum sum of values from the root node `0` to any leaf node.","solution":"def maxLeafPathSum(n, edges, values): from collections import defaultdict def dfs(node, parent): max_sum = values[node] leaf = True for neighbor in tree[node]: if neighbor != parent: leaf = False max_sum = max(max_sum, values[node] + dfs(neighbor, node)) return max_sum # Create the adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Start DFS from the root node 0 return dfs(0, -1)"},{"question":"You are given an undirected graph with `n` nodes labelled from `0` to `n - 1` and an integer `m`. The graph is represented by an array of edges, where `edges[i] = [u, v]` indicates that there is an edge between nodes `u` and `v`. You want to determine if there exists a path that visits exactly `m` different nodes. Return `true` if such a path exists, otherwise return `false`.","solution":"def can_visit_m_nodes(n, m, edges): from collections import defaultdict, deque if m > n: return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start_node): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) if len(visited) == m: return True return len(visited) == m for i in range(n): if bfs(i): return True return False"},{"question":"A **sad number** is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits in base-10, and repeat the process until the number either equals 4 (where it will stay as 4, forever) or it loops endlessly in a cycle that does not include 4. Those numbers for which this process finishes in 4 are sad numbers. Write an algorithm to determine if a number `n` is a sad number. Return `true` if `n` is a sad number, and `false` otherwise.","solution":"def is_sad_number(n): Determines if the number `n` is a sad number. A sad number will eventually transform to the value 4, and will then forever stay in a cycle involving 4. Parameters: n (int): The number to check. Returns: bool: True if `n` is a sad number, False otherwise. def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 4 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 4"},{"question":"You are given an integer array `nums` and an integer `window_size`. You must find the maximum sum of any subarray of size `window_size` in `nums`. Return the maximum sum found. If `window_size` is larger than the array size, return `-1`.","solution":"def max_subarray_sum(nums, window_size): Returns the maximum sum of any subarray of size window_size in nums. If window_size is larger than the array size, return -1. n = len(nums) if window_size > n: return -1 # Calculate the sum of the first window max_sum = sum(nums[:window_size]) current_sum = max_sum # Slide the window over the array for i in range(window_size, n): current_sum += nums[i] - nums[i - window_size] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `nums` representing the cost of items and an integer `coin_count` representing the total number of coins you have. Each item can be bought exactly once with the coins. Return _the maximum number of items you can buy with the available coins_. You must maximize the number of items purchased without exceeding the available coins.","solution":"def max_items(nums, coin_count): Returns the maximum number of items that can be bought with the given coin_count. Args: nums (List[int]): List of integers representing the cost of items. coin_count (int): Number of coins available. Returns: int: Maximum number of items that can be bought. nums.sort() total_cost = 0 count = 0 for cost in nums: if total_cost + cost <= coin_count: total_cost += cost count += 1 else: break return count"},{"question":"You are given an array `heights` consisting of integers where each element represents the height of a building. You need to find _the area of the largest rectangle that can be formed using these buildings as the histogram bars, without any gaps between them_. The width of each bar is 1. Create a function `largestRectangleArea(heights: List[int]) -> int` that returns the maximal rectangular area in the histogram represented by the heights array.","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Find the area of the largest rectangle that can be formed in a histogram. Parameters: heights (List[int]): List of non-negative integers representing building heights. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): # If the stack is empty or the current bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a linked list where each node contains an integer value. Implement a method to check if the linked list is a palindrome. _A palindrome is a sequence that reads the same backward as forward._ **Definition of ListNode:** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Method to implement:** ```python def isPalindrome(head: ListNode) -> bool: ``` Parameters: - `head` (ListNode): the head of the linked list. Returns: - `bool`: `True` if the linked list is a palindrome, `False` otherwise.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head: ListNode) -> bool: Checks if the linked list is a palindrome. vals = [] curr = head while curr is not None: vals.append(curr.val) curr = curr.next return vals == vals[::-1]"},{"question":"You are given a list of strings `words` and a target string `target`. Each word in `words` can be used multiple times to form the target string. However, you can only concatenate strings from `words` and cannot rearrange the characters of the target string. Return _the minimum number of concatenations needed to form the target string using the words from the list_. If it is not possible to form the target string, return `-1`.","solution":"from collections import defaultdict, deque def min_concatenations(words, target): Returns the minimum number of concatenations needed to form the target string using the words from the list. Returns -1 if it is not possible. word_set = set(words) memo = {} def solve(t): if t == \'\': return 0 if t in memo: return memo[t] min_concats = float(\'inf\') for word in word_set: if t.startswith(word): remaining = t[len(word):] result = solve(remaining) if result != -1: min_concats = min(min_concats, 1 + result) min_concats = min_concats if min_concats != float(\'inf\') else -1 memo[t] = min_concats return min_concats return solve(target)"},{"question":"Given a positive integer `n`, write a function to find the smallest integer `x` such that the sum of the digits in `x` equals `n`, and `x` is greater than or equal to `n`. Return `x` as a string. For instance, for `n = 5`, the result would be `\\"5\\"`, and for `n = 19`, the result would be `\\"199\\"`.","solution":"def smallest_integer_with_sum(n): Returns the smallest integer x as a string such that the sum of the digits in x equals n, and x is greater than or equal to n. if n <= 9: return str(n) # Start with the number itself x = n while sum(int(digit) for digit in str(x)) != n: x += 1 return str(x)"},{"question":"You are given an integer `n` and an integer array `nums` of length `m`. Your goal is to determine whether `m` is a subset of a sequence of consecutive integers starting from `0` to `n-1`. Return `true` if the array `nums` forms a subset of the set `{0, 1, 2, ..., n-1}`, otherwise return `false`.","solution":"def is_subset_of_range(n, nums): Determines whether an array nums is a subset of the sequence of consecutive integers from 0 to n-1. :param n: An integer representing the range upper limit (exclusive). :param nums: A list of integers. :return: True if nums is a subset of {0, 1, 2, ..., n-1}, otherwise False. return all(0 <= num < n for num in nums)"},{"question":"You are given a string `s` that consists solely of characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation on `s` any number of times: - Choose two **different** characters in `s` and replace all occurrences of the **first** character with the **second** character. Return the number of distinct strings you can obtain by applying the above operation any number of times on `s`. For example, given the string `s = \\"aabbcc\\"`, one possible operation is to replace all occurrences of `\'a\'` with `\'b\'`, resulting in the string `\\"bbbbcc\\"`.","solution":"def distinct_strings(s): Returns the number of distinct strings that can be obtained by performing the given operation any number of times on the input string s. distinct_chars = set(s) return len(distinct_chars)"},{"question":"Given a list of non-negative integers representing the amount of time taken by each task, and an integer `k` representing the number of workers available to complete these tasks, return the minimum possible maximum workload whenever the tasks are distributed optimally among the workers. Each worker must be assigned at least one task, and the goal is to minimize the maximum time any single worker has to spend.","solution":"def canDistribute(tasks, k, max_workload): current_workers = 1 current_load = 0 for task in tasks: if current_load + task <= max_workload: current_load += task else: current_workers += 1 current_load = task if current_workers > k: return False return True def minimizeMaxWorkload(tasks, k): low = max(tasks) high = sum(tasks) result = high while low <= high: mid = (low + high) // 2 if canDistribute(tasks, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"You are given a list of `n` unique integers and an integer `d`. You want to partition the list into as many sublists as possible such that for any sublist, the difference between the maximum value and the minimum value in that sublist is no greater than `d`. Return _the maximum number of sublists_ you can partition the list into.","solution":"def max_sublists(nums, d): Partitions a list of unique integers into the maximum number of sublists such that the difference between the maximum and minimum values in each sublist is <= d. :param nums: List of unique integers :param d: Integer maximum allowed difference between max and min in each sublist :return: Maximum number of sublists if not nums: return 0 nums.sort() sublists_count = 1 min_val = nums[0] for num in nums[1:]: if num - min_val > d: sublists_count += 1 min_val = num return sublists_count"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of each building in a street. You are also given an integer `steps` representing the number of steps you can move to another building. You start from the first building and can only move from one building to another if the height difference between the two buildings does not exceed `steps`. Return the total number of distinct buildings you can visit starting from the first building.","solution":"def can_visit_buildings(heights, steps): Returns the total number of distinct buildings you can visit starting from the first building. def dfs(index, visited): visited.add(index) for i in range(len(heights)): if i not in visited and abs(heights[i] - heights[index]) <= steps: dfs(i, visited) visited = set() dfs(0, visited) return len(visited)"},{"question":"You are given two sorted integer arrays `nums1` and `nums2`. Your task is to find and return the **median** of the two sorted arrays. The median is defined as the middle value if the combined number of elements is odd, and the average of the two middle values if the combined number of elements is even. Implement an efficient algorithm capable of finding the median without fully merging the two arrays. Return _the median of the two sorted arrays_ `nums1` _and_ `nums2`_.","solution":"def find_median_sorted_arrays(nums1, nums2): Returns the median of the two sorted arrays. A, B = nums1, nums2 total = len(A) + len(B) half = total // 2 if len(A) > len(B): A, B = B, A l, r = 0, len(A) - 1 while True: i = (l + r) // 2 # A\'s median j = half - i - 2 # B\'s median Aleft = A[i] if i >= 0 else float(\\"-infinity\\") Aright = A[i + 1] if (i + 1) < len(A) else float(\\"infinity\\") Bleft = B[j] if j >= 0 else float(\\"-infinity\\") Bright = B[j + 1] if (j + 1) < len(B) else float(\\"infinity\\") # partition is correct if Aleft <= Bright and Bleft <= Aright: # odd if total % 2: return min(Aright, Bright) # even return (max(Aleft, Bleft) + min(Aright, Bright)) / 2 elif Aleft > Bright: r = i - 1 else: l = i + 1"},{"question":"Given an array of integers `arr` where each element in the array represents a vote cast for a particular candidate, return _an integer array_ `result` _containing the counts of votes for each candidate from 1 to n_. The array `arr` can have votes for candidates numbered from 1 to `n`. The length of `arr` is `m` and elements are between 1 and `n`. You are guaranteed that votes are uniformly distributed, meaning each candidate receives at least one vote. The number of candidates `n` is not given explicitly but can be deduced from the range of the elements in the `arr`.","solution":"def count_votes(arr): Given an array of integers `arr` where each element in the array represents a vote cast for a particular candidate, return a list containing the counts of votes for each candidate from 1 to n. Parameters: arr (list): A list of integers representing votes for candidates. Returns: list: A list where the ith element is the number of votes for the (i+1)th candidate. # Find the number of candidates n = max(arr) # Initialize result array with zero votes for each candidate result = [0] * n # Count votes for each candidate for vote in arr: result[vote - 1] += 1 return result"},{"question":"Given a string `s`, find the length of the longest substring without repeating characters. Return an integer representing the length of this substring. (Note: The question challenges the algorithmic understanding of sliding window and hash map techniques, aligning with the complexity level and cognitive challenge of the provided questions.)","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two strings, `s` and `t`, consisting of lowercase English letters. You need to obtain `t` from `s` by deleting some (possibly zero) characters from `s` and rearranging the remaining characters without changing their relative order. Return _the minimum number of deletions required from `s` to obtain `t` as a subsequence_. For example, if `s = \\"abcde\\"` and `t = \\"ace\\"`, you can delete the characters `\\"b\\"` and `\\"d\\"` from `s` to get `\\"ace\\"`, which requires `2` deletions. If it is NOT possible to form `t` from `s`, return `-1`.","solution":"def minimum_deletions(s, t): Returns the minimum number of deletions required from `s` to obtain `t` as a subsequence. If it is not possible to form `t` from `s`, returns -1. :param s: String from which characters can be deleted. :param t: Target subsequence to achieve. :return: Minimum number of deletions required, or -1 if not possible. m, n = len(s), len(t) j = 0 for i in range(m): if j < n and s[i] == t[j]: j += 1 if j == n: return m - n return -1"},{"question":"You are given an array `heights` representing the heights of buildings where each height `heights[i]` is the height of a building at position `i`. You are tasked with finding the maximum area of a rectangular section that can be formed using adjacent buildings. Each building forms a width of 1 unit. Return _the maximum area of the rectangular section_ that can be formed.","solution":"def max_rect_area(heights): Returns the maximum area of a rectangular section that can be formed using adjacent buildings. :param heights: List of integers representing the heights of buildings. :return: Integer representing the maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `arr` of positive numbers and an integer `k`. You need to split the array into `k` non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum. The answer can be obtained by applying the binary search technique and a greedy approach to verify the feasibility.","solution":"def split_array_min_largest_sum(arr, k): Split the array `arr` into `k` non-empty subarrays such that the largest sum of any subarray is minimized. def can_split(nums, m, max_sum): count, current_sum = 1, 0 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Write a function that takes a string `s` containing only digits and returns all possible valid IP addresses that can be obtained by inserting three dots in `s`. Each segment of the IP address must be between 0 and 255 (inclusive) and should not contain leading zeros unless the segment is exactly \'0\'. Return the valid IP addresses as a list of strings in their original order found in the input string.","solution":"def restore_ip_addresses(s): def is_valid(segment): Check if a segment is a valid IP address segment. return int(segment) <= 255 and (segment == \\"0\\" or not segment.startswith(\\"0\\")) def backtrack(start, path): if len(path) == 4: if start == len(s): result.append(\\".\\".join(path)) return for length in range(1, 4): if start + length <= len(s): segment = s[start:start + length] if is_valid(segment): backtrack(start + length, path + [segment]) result = [] backtrack(0, []) return result"},{"question":"Given an integer array `arr` and an integer `m`, find the length of the shortest subarray with a sum of at least `m`. If there is no such subarray, return `0`. A subarray is a contiguous part of an array.","solution":"def shortest_subarray_with_sum_at_least_m(arr, m): Finds the length of the shortest subarray with a sum of at least `m`. :param arr: List of integers :param m: Target sum integer :return: Length of the shortest subarray with sum at least `m`, or 0 if none exists. from collections import deque n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] deq = deque() min_length = float(\'inf\') for i in range(n + 1): while deq and prefix_sums[i] - prefix_sums[deq[0]] >= m: min_length = min(min_length, i - deq.popleft()) while deq and prefix_sums[i] <= prefix_sums[deq[-1]]: deq.pop() deq.append(i) return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given an array of positive integers `nums`. A **subsequence** is a sequence derived from `nums` by deleting some or no elements without changing the order of the remaining elements. An alternating subsequence is a subsequence where the differences between consecutive elements strictly alternate between positive and negative. For example, `[1, 3, 2, 4]` is an alternating subsequence because `3 - 1 > 0`, `2 - 3 < 0`, and `4 - 2 > 0`. Return _the length of the longest alternating subsequence in_ `nums`.","solution":"def longest_alternating_subsequence(nums): if not nums: return 0 n = len(nums) inc = 1 dec = 1 for i in range(1, n): if nums[i] > nums[i - 1]: inc = dec + 1 elif nums[i] < nums[i - 1]: dec = inc + 1 return max(inc, dec)"},{"question":"You are given a 2D grid of size `m x n` representing an island. The grid contains only water `\'0\'` and land `\'1\'`. A **bridge** can be built between any two adjacent cells (horizontally or vertically) if at least one cell is land. You can change at most one cell from water to land or land to water. Determine the minimum number of bridges required to connect all land cells together. Return `-1` if it is not possible.","solution":"from collections import deque def min_bridges_required(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) # Function to check if a position is within the grid bounds. def in_bounds(x, y): return 0 <= x < m and 0 <= y < n # Function to find all initial islands and their coordinates. def get_islands(grid): islands = [] visited = [[False] * n for _ in range(m)] def bfs(start): queue = deque([start]) island = [] while queue: x, y = queue.popleft() if not visited[x][y]: visited[x][y] = True island.append((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and grid[nx][ny] == \'1\' and not visited[nx][ny]: queue.append((nx, ny)) return island for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: islands.append(bfs((i, j))) return islands # Get all islands and return -1 if there are fewer than 2 islands. islands = get_islands(grid) if len(islands) <= 1: return -1 if len(islands) == 0 else 0 # Function to find the minimum distance to connect two islands considering changing one cell. def min_distance_to_connect(island1, island2): min_distance = float(\'inf\') for x1, y1 in island1: for x2, y2 in island2: current_dist = abs(x1 - x2) + abs(y1 - y2) - 1 min_distance = min(min_distance, current_dist) return min_distance min_bridges = float(\'inf\') for i in range(len(islands)): for j in range(i + 1, len(islands)): min_bridges = min(min_bridges, min_distance_to_connect(islands[i], islands[j])) return min_bridges"},{"question":"Write a function that, given a string `s` consisting of letters and digits, returns a string where every letter in `s` is reversed and the position of the digits is preserved. For example, for the input `\\"a1b2cde3\\"`, the output should be `\\"e1d2cba3\\"`.","solution":"def reverse_letters(s): Returns a string where every letter in the input string `s` is reversed, but the position of the digits is preserved. # Extract only the letters from the string, reverse them letters = [char for char in s if char.isalpha()][::-1] # Use a list to store the result result = [] # Iterate through the original string letter_index = 0 for char in s: if char.isalpha(): # Append the letters from the reversed list result.append(letters[letter_index]) letter_index += 1 else: # Append the digits directly result.append(char) return \'\'.join(result)"},{"question":"You are given a binary tree where each node consists of a value and a pointer to the left and right child nodes. Define a function `longestConsecutivePath(root)` which returns the length of the longest sequence of nodes such that the values of successive nodes in the sequence increase by one. A sequence of nodes is referred to as a path, and the path does not need to start or end at the root of the binary tree. For example, given the binary tree: ``` 3 / 2 4 / 1 3 5 6 ``` The longest consecutive path would be 3-4-5-6, which has a length of 4. Use the same format for inputting and outputting the binary tree nodes as in question 1.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longestConsecutivePath(root): if not root: return 0 def dfs(node, parent, length): if not node: return length if parent and node.value == parent.value + 1: length += 1 else: length = 1 left_length = dfs(node.left, node, length) right_length = dfs(node.right, node, length) return max(length, left_length, right_length) return dfs(root, None, 0)"},{"question":"You are given a matrix of `n` rows and `m` columns where some cells are empty (represented by `0`) and some cells contain obstacles (represented by `1`). You need to find the length of the shortest path from the top-left corner `(0,0)` to the bottom-right corner `(n-1,m-1)` while avoiding obstacles. You can move up, down, left, or right from an empty cell during each step. If there is no possible path, return `-1`.","solution":"from collections import deque def shortest_path(matrix): Find the shortest path from top-left to bottom-right corner in a matrix avoiding obstacles. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0] or matrix[0][0] == 1 or matrix[-1][-1] == 1: return -1 n = len(matrix) m = len(matrix[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given a string `s`, determine the length of the longest substring that contains at most `k` distinct characters. If `k` is zero or the string is empty, return 0. Your algorithm should be efficient enough to handle large strings and values of `k`. Implement the following function signature: ```python def length_of_longest_substring_k_distinct(s: str, k: int) -> int: # Your code here ```","solution":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: if k == 0 or not s: return 0 from collections import defaultdict left = 0 right = 0 char_count = defaultdict(int) max_length = 0 while right < len(s): char_count[s[right]] += 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"You are given an integer array `stones` where `stones[i]` represents the weight of the `i`th stone. We are to combine these stones into one stone by performing the following operation until only one stone is left: 1. Choose two stones with the smallest weights (let\'s call them `a` and `b`). 2. Remove these two stones from the list. 3. Add a new stone with the weight `a + b`. Each time we perform this operation, the cost is `a + b`. Return _the minimum possible total cost of combining all the stones into one stone_.","solution":"import heapq def min_cost_to_combine_stones(stones): Calculates the minimum cost to combine all stones into one stone by repeatedly combining the two smallest stones. Args: stones (List[int]): A list of integers where each integer represents the weight of a stone. Returns: int: The minimum cost of combining all the stones into one stone. heapq.heapify(stones) total_cost = 0 while len(stones) > 1: a = heapq.heappop(stones) b = heapq.heappop(stones) cost = a + b total_cost += cost heapq.heappush(stones, cost) return total_cost"},{"question":"Given an array of integers `heights` representing the heights of different buildings, design a function that determines the highest building from which you can see the sunset. A building is considered to be facing the sunset if there are no taller buildings to its right. The function should return the indices of all such buildings in increasing order of their indices. For example, given the array `heights = [3, 7, 8, 3, 6, 1]`, the buildings at indices `[2, 4, 5]` can see the sunset because there are no taller buildings to their right.","solution":"def sunset_buildings(heights): Determines the indices of the buildings that can see the sunset. Args: heights (list of int): Heights of the buildings. Returns: list of int: Indices of the buildings that can see the sunset. n = len(heights) if n == 0: return [] highest_so_far = heights[-1] sunset_indices = [n - 1] for i in range(n - 2, -1, -1): if heights[i] > highest_so_far: sunset_indices.append(i) highest_so_far = heights[i] return sorted(sunset_indices)"},{"question":"You are given an integer array `nums` and a positive integer `k`. A **subarray** is a contiguous non-empty sequence of elements within an array. The **product of the subarray** is the product of all the elements in it. Return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.","solution":"def numSubarrayProductLessThanK(nums, k): Returns the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. if k <= 1: return 0 product = 1 left = 0 count = 0 for right in range(len(nums)): product *= nums[right] while product >= k and left <= right: product /= nums[left] left += 1 count += right - left + 1 return count"},{"question":"Given a 2-dimensional grid of integers `grid` with `m` rows and `n` columns, return _the maximum sum of elements of any subgrid of size `k x k`, where `1 <= k <= min(m, n)`_. A subgrid is defined as any contiguous `k x k` subarray of the grid.","solution":"def max_sum_subgrid(grid, k): Returns the maximum sum of elements of any subgrid of size k x k. m, n = len(grid), len(grid[0]) # Precompute the prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sum[i+1][j+1] = grid[i][j] + prefix_sum[i][j+1] + prefix_sum[i+1][j] - prefix_sum[i][j] max_sum = float(\'-inf\') # Iterate over all possible k x k subgrids for i in range(k, m + 1): for j in range(k, n + 1): current_sum = prefix_sum[i][j] - prefix_sum[i-k][j] - prefix_sum[i][j-k] + prefix_sum[i-k][j-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `nums` and an integer `k`, return _the maximum number of consecutive elements that sum to a number less than or equal to_ `k`. Your function should aim for an optimal solution in terms of time complexity.","solution":"def max_consecutive_sum(nums, k): Returns the maximum number of consecutive elements that sum to a number less than or equal to k. Parameters: nums (list of int): The list of integers. k (int): The maximum sum allowed. Returns: int: The maximum number of consecutive elements that sum to a number less than or equal to k. max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > k and start <= end: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Implement a function `replace_words(dictionary, sentence)` that replaces words in a sentence with their shortest root form from a given dictionary. The dictionary contains many roots, and the words in the sentence are separated by spaces. If a word has multiple root forms in the dictionary, replace it with the shortest one. If a word does not have a root form in the dictionary, it remains unchanged. Return the modified sentence as a string.","solution":"def replace_words(dictionary, sentence): Replaces words in a sentence with their shortest root form from a given dictionary. Parameters: dictionary (list of str): The list of root words. sentence (str): The input sentence where words need to be replaced. Returns: str: The modified sentence with words replaced by their shortest root form. root_set = set(dictionary) words = sentence.split() for i, word in enumerate(words): min_length = float(\'inf\') shortest_root = word for root in root_set: if word.startswith(root) and len(root) < min_length: min_length = len(root) shortest_root = root words[i] = shortest_root return \' \'.join(words)"},{"question":"You are given a non-negative integer `x` representing the amount of money you have and an array `prices` where `prices[i]` is the price of the `i-th` item in a store. Each item can only be purchased once. Return the **maximum** number of different items you can buy with the given amount of money `x`.","solution":"def max_items(x, prices): Returns the maximum number of different items that can be bought with the given amount of money x. :param x: non-negative integer representing the amount of money available. :param prices: list of integers where prices[i] is the price of the i-th item in the store. :return: the maximum number of different items that can be bought. prices.sort() items_bought = 0 for price in prices: if x >= price: x -= price items_bought += 1 else: break return items_bought"},{"question":"You are given a non-empty 2D array `grid` representing a maze with `m` rows and `n` columns. Each cell in the grid contains either 0 (an empty cell) or 1 (a blocked cell). You start at the top-left corner of the maze (0,0) and your goal is to reach the bottom-right corner (m-1, n-1). You can move one step at a time to an adjacent cell (up, down, left, or right), but you cannot move into a cell that contains 1. If there is no valid path, return -1. Otherwise, return the length of the shortest path from the starting cell to the goal cell. Remember, moving one step to an adjacent cell counts as one move.","solution":"from collections import deque def shortest_path_in_maze(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the given grid representing a maze. If no valid path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, distance = queue.popleft() if row == m - 1 and col == n - 1: return distance for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and grid[r][c] == 0 and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, distance + 1)) return -1"},{"question":"You are given a list of `n` integers `nums` and an integer `k`. Your task is to determine if the list can be partitioned into `k` non-empty subsets with equal sums. Each number in the list can be used in exactly one subset. If the list can be partitioned, return true; otherwise, return false. Implement the following function: * `boolean canPartitionKSubsets(int[] nums, int k)`: Given a list of integers `nums` and an integer `k`, this function returns `true` if the list can be partitioned into `k` subsets with equal sums, and `false` otherwise. Note that the function should consider the edge cases where the sum of `nums` is not divisible by `k` and cases where subsets can\'t be formed due to the constraints of individual numbers in `nums` exceeding the target partition sum.","solution":"def can_partition_k_subsets(nums, k): def backtrack(index, k, subset_sum, used, target): if k == 1: return True if subset_sum == target: return backtrack(0, k - 1, 0, used, target) for i in range(index, len(nums)): if not used[i] and subset_sum + nums[i] <= target: used[i] = True if backtrack(i + 1, k, subset_sum + nums[i], used, target): return True used[i] = False return False total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) return backtrack(0, k, 0, used, target)"},{"question":"You are given a string `s` which consists of lowercase and uppercase letters. You need to rearrange the letters in `s` such that all the uppercase letters come before all the lowercase letters, while maintaining their respective order among themselves. Return _the rearranged string_.","solution":"def rearrange_string(s): Rearranges the letters in the string s such that all uppercase letters come before all lowercase letters, while maintaining their respective order among themselves. :param s: input string consisting of lowercase and uppercase letters :return: rearranged string with all uppercase letters before all lowercase letters upper = [] lower = [] for char in s: if char.isupper(): upper.append(char) else: lower.append(char) return \'\'.join(upper) + \'\'.join(lower)"},{"question":"You are given an array of integers `arr`, and an integer `k`. Your task is to find the **minimum** possible value of the **maximum** difference between the `k` subarrays you can form by partitioning the original array. Each subarray should be contiguous. For each partition, the difference is defined as the difference between the maximum and minimum value in that subarray. Return _the **minimum** value of the **maximum** difference among all possible ways to partition the array into_ `k` _subarrays_.","solution":"def min_max_diff(arr, k): \'\'\' This function finds the minimum possible value of the maximum difference between k subarrays formed by partitioning the original array arr. \'\'\' def feasible(mid, k): current_min = current_max = arr[0] partitions = 1 for num in arr[1:]: current_min = min(current_min, num) current_max = max(current_max, num) if current_max - current_min > mid: partitions += 1 current_min = current_max = num return partitions <= k low, high = 0, max(arr) - min(arr) while low < high: mid = (low + high) // 2 if feasible(mid, k): high = mid else: low = mid + 1 return low"},{"question":"You are given an integer array `arr` and an integer `k`. A sliding window of size `k` moves from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return _the maximum sum of the sliding window._ If the array has fewer than `k` elements, return `-1`. For example, given `arr = [1, 3, 2, 5, 4]` and `k = 3`, the sliding windows are `[1, 3, 2]`, `[3, 2, 5]`, and `[2, 5, 4]` with corresponding sums `6`, `10`, and `11`, thus the maximum sum is `11`.","solution":"def max_sliding_window_sum(arr, k): Returns the maximum sum of a sliding window of size `k` in the array `arr`. :param arr: List[int] - The input array of integers. :param k: int - The size of the sliding window. :return: int - The maximum sum of the sliding window or -1 if array size is less than k. n = len(arr) if n < k: return -1 max_sum = current_sum = sum(arr[:k]) for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a non-negative integer `num` represented as a string. Return the largest number you can get by swapping at most two digits only once. If no swap is needed, return the original number as a string.","solution":"def largest_swap(num_str): Returns the largest number by swapping at most two digits only once. num_list = list(num_str) n = len(num_list) # Track the rightmost position of each digit last = {int(x): i for i, x in enumerate(num_list)} for i, x in enumerate(num_list): for d in range(9, int(x), -1): if last.get(d, -1) > i: num_list[i], num_list[last[d]] = num_list[last[d]], num_list[i] return \'\'.join(num_list) return num_str"},{"question":"An online retailer has a list of products represented by an array of integers `products`, where `products[i]` represents the price of the `i-th` product. They want to bundle products into groups such that each group has a total price less than or equal to a given integer `budget`. Every product can belong to at most one group. Write a function `minGroups` that determines the minimum number of groups needed to bundle all the products within the given budget. Your function should return an integer representing the minimum number of groups required.","solution":"def minGroups(products, budget): Determines the minimum number of groups needed to bundle all the products within the given budget. :param products: List of product prices. :param budget: Maximum budget for each group. :return: Minimum number of groups needed. # Sort products in descending order products.sort(reverse=True) # Initialize an empty list to hold the groups groups = [] for product in products: placed_in_group = False for group in groups: if sum(group) + product <= budget: group.append(product) placed_in_group = True break if not placed_in_group: groups.append([product]) return len(groups)"},{"question":"You are given a list of integers `nums`, where each integer represents the value of a building. A building `i` can see the sunset if there are no buildings to its right with height greater than or equal to the height of building `i`. Determine and return the number of buildings that can see the sunset if the buildings are aligned in a straight line from left to right. Note that buildings with equal height block each other unless they are the same building.","solution":"def count_buildings_with_sunset_view(nums): Returns the count of buildings that can see the sunset. A building can see the sunset if there are no buildings to its right with height greater than or equal to the height of the building. Args: nums (list of int): List of integers representing building heights. Returns: int: The count of buildings that can see the sunset. if not nums: return 0 count = 1 # The last building can always see the sunset max_height = nums[-1] # Start by considering the last building for i in range(len(nums) - 2, -1, -1): if nums[i] > max_height: count += 1 max_height = nums[i] return count"},{"question":"Given a collection of `n` ropes of different lengths, you need to connect these ropes into one rope. The cost to connect two ropes is equal to the sum of their lengths. Your task is to determine the minimum cost to connect all the ropes. Implement the function `int minCostToConnectRopes(vector<int>& ropes)` which takes a vector of integers representing the lengths of the ropes and returns the minimum cost of connecting all the ropes into one rope.","solution":"import heapq def minCostToConnectRopes(ropes): Returns the minimum cost to connect all the ropes into one rope. Parameters: ropes (List[int]): A list of integers representing the lengths of the ropes. Returns: int: The minimum cost to connect all the ropes. if not ropes: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"You are given an integer array `nums` of size `n` where each element is between `1` and `n` inclusive. Return the number of distinct triplets `(i, j, k)` such that `1 <= i < j < k <= n` and `nums[i]`, `nums[j]`, and `nums[k]` follow a specific order listed below: 1. `nums[i] < nums[j] < nums[k]` 2. `nums[i] > nums[j] > nums[k]` Additionally, each distinct triplet should be counted only once.","solution":"def count_distinct_triplets(nums): Returns the number of distinct triplets (i, j, k) such that 1 <= i < j < k <= n and nums[i], nums[j], nums[k] follow the orders: 1. nums[i] < nums[j] < nums[k] 2. nums[i] > nums[j] > nums[k] Args: nums (list of int): The input array. Returns: int: The number of distinct triplets following the rules. n = len(nums) count = 0 for i in range(n-2): for j in range(i+1, n-1): for k in range(j+1, n): if nums[i] < nums[j] < nums[k] or nums[i] > nums[j] > nums[k]: count += 1 return count"},{"question":"Given a non-empty string `s`, you may delete at most one character. Judge whether you can make it a palindrome. A string is a palindrome when it reads the same backward as forward. Ensure your solution handles edge cases like empty strings and single-character strings gracefully. Your algorithm should operate in `O(n)` time complexity, where `n` is the length of the string. Return `true` if the string can be made a palindrome by deleting at most one character, otherwise return `false`.","solution":"def valid_palindrome(s): def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"Given a **0-indexed** array `nums` of length `n`, where `nums[i]` represents the value at the `i-th` position, **remove** the minimum number of elements from `nums` such that the remaining array is **non-decreasing** (each element is no less than the previous one). Return the length of the final array after removals. Construct an integer `result` such that `result` equals the length of the longest non-decreasing subsequence that can be obtained by removing some elements from `nums`. Return _the constructed integer_ `result`.","solution":"def length_of_LNDS(nums): Given a 0-indexed array nums, return the length of the longest non-decreasing subsequence that can be obtained by removing some elements from nums. if not nums: return 0 # Initialize list to hold longest subsequence lengths n = len(nums) dp = [1] * n # Iterate through the list, applying dynamic programming technique for i in range(1, n): for j in range(i): if nums[i] >= nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given two strings `s` and `t` of lengths `n` and `m` respectively, consisting of lowercase English letters. Your task is to determine whether `t` is a subsequence of `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return `true` if `t` is a subsequence of `s`, and `false` otherwise.","solution":"def is_subsequence(s, t): Determines whether t is a subsequence of s. Args: s (str): The main string. t (str): The sequence to check as a subsequence. Returns: bool: True if t is a subsequence of s, False otherwise. m, n = len(s), len(t) if n == 0: return True t_index = 0 for char in s: if char == t[t_index]: t_index += 1 if t_index == n: return True return False"},{"question":"A social networking website has a feature that allows users to form groups. A group is defined as a collection of users where each user is directly or indirectly connected to every other user in that group. Two users are directly connected if they are friends. You are given a list of friendships where each friendship is represented as a pair of user IDs, `[u, v]`, indicating that user `u` and user `v` are friends. Compute the number of groups formed. Write a function `int countGroups(List<int[]> friendships)` that takes a list of integer arrays, `friendships`, and returns the number of groups. Each friendship is bidirectional, meaning if user `u` is friends with user `v`, then user `v` is also friends with user `u`. You can assume that each user appears in at least one friendship.","solution":"def countGroups(friendships): from collections import defaultdict def dfs(user, adj_list, visited): stack = [user] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adj_list = defaultdict(list) for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) visited = set() groups = 0 for user in adj_list.keys(): if user not in visited: visited.add(user) dfs(user, adj_list, visited) groups += 1 return groups"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to find the `k` most frequent elements in the array. The output should be an array of these `k` most frequent elements sorted in decreasing order of their frequency. If two elements have the same frequency, the element with the larger value should come first. You should implement the following function: * `List findKFrequentElements(int[] nums, int k)`, which returns a list of the `k` most frequent elements sorted as described above. Note: You can assume that `k` is always valid and `1 <= k <= nums.length`.","solution":"from collections import Counter import heapq def findKFrequentElements(nums, k): Returns the k most frequent elements in the array sorted in decreasing order of their frequency. If two elements have the same frequency, the element with the larger value should come first. # Count frequencies of each element frequency = Counter(nums) # Create a heap of frequency and elements pairs heap = [(-freq, num) for num, freq in frequency.items()] # Convert list into a heap heapq.heapify(heap) # Extract the k most frequent elements from the heap result = [] for _ in range(k): freq, num = heapq.heappop(heap) result.append(num) return result"},{"question":"Design a function that takes in two strings `a` and `b`, and returns the length of the longest uncommon subsequence between them. An uncommon subsequence is defined as a subsequence that is unique to each string (i.e., it doesn\'t appear in both strings). If no such subsequence exists, return `-1`. A subsequence of a string is a sequence that can be derived from the string by deleting some or no characters without changing the order of the remaining characters.","solution":"def findLUSlength(a, b): Returns the length of the longest uncommon subsequence between a and b. If no such subsequence exists, return -1. if a == b: return -1 return max(len(a), len(b))"},{"question":"You are given a binary tree where each node has a value of `0` or `1`. Each path from the root to a leaf represents a binary number starting from the root. Your task is to calculate the sum of these binary numbers represented by all root-to-leaf paths. Each binary number should be computed from the highest bit (root) to the lowest bit (leaf) in the path. Return this sum in decimal (base 10) representation. Example: ``` Input: root = [1,0,1,0,1,0,1] Output: 22 Explanation: The binary numbers from root to leaves are 100, 101, 110, and 111. Their decimal sums are 4 + 5 + 6 + 7 = 22. ```","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root): Compute the sum of all binary numbers represented by root-to-leaf paths in the binary tree. def dfs(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val # if it\'s a leaf, return the current number if not node.left and not node.right: return current_number # otherwise, return the sum of both subtrees left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"You are given two integers `n` and `k`. Your task is to remove exactly `k` digits from the integer `n` to form the smallest possible new integer. Return the smallest possible new integer as a string after `k` digits have been removed. Note: The resulting integer should not contain any leading zeros unless it is zero itself.","solution":"def remove_k_digits(n, k): Removes exactly k digits from the integer n to form the smallest possible new integer. Returns the smallest possible new integer as a string after k digits have been removed. number_str = str(n) stack = [] for digit in number_str: while k and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still elements to remove, remove them from the end. final_stack = stack[:-k] if k else stack # Join the stack to form the resultant number and strip leading zeros. result = \'\'.join(final_stack).lstrip(\'0\') return result if result else \'0\'"},{"question":"Given a string `s` representing a sequence of lowercase English letters, return a new string where all the duplicate letters are removed and only the last occurrence of each letter is kept. The resulting string should preserve the order of their last occurrences in `s`. *For example, given `s = \\"abacbad\\"`, the result should be \\"cbad\\".*","solution":"def remove_duplicates(s): Removes all duplicate letters from the string s keeping only the last occurrence of each letter. The order of the resulting string should preserve the order of their last occurrences in s. :param s: str - A string of lowercase English letters. :return: str - A new string where all the duplicate letters are removed. last_occurrence = {char: idx for idx, char in enumerate(s)} result = [] seen = set() for idx, char in enumerate(s): if char not in seen and idx == last_occurrence[char]: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"You are given a linked list that might contain a loop. Implement a function `ListNode* detectCycle(ListNode* head)` that returns the node where the cycle begins. If there is no cycle, return `null`. To represent a cycle in the given linked list, we use an integer `pos` which is the position (0-indexed) in the linked list where the tail connects. Note that `pos` is not passed as a parameter. Do not modify the linked list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): This function detects the cycle in a linked list and returns the node where the cycle begins. if head is None or head.next is None: return None slow = head fast = head # Detect if there is a cycle in the linked list while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # No cycle found if not (fast and fast.next): return None # Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a **0-indexed** array `arr` of integers representing the heights of trees in a forest. You can cut down the trees, but you must follow these rules: 1. You can cut down only one tree at a time. 2. After cutting down a tree, all shorter or equal height trees to the left and right of it will also fall down. Your goal is to determine the **minimum number** of cuts needed to bring down all the trees. Return the minimum number of cuts needed.","solution":"def min_cuts(arr): Returns the minimum number of cuts needed to bring down all the trees. Parameters: arr (list): A list of integers representing the heights of trees. Returns: int: Minimum number of cuts needed. # Consider the unique values in the heights unique_heights = set(arr) # The number of unique heights determines the minimum cuts needed return len(unique_heights)"},{"question":"You are given a binary tree represented by the root node `root`. Each node in the tree contains an integer value and two children pointers (left and right). Your task is to find the diameter of the binary tree, where the diameter is defined as the length of the longest path between any two nodes in the tree. This path may or may not pass through the root node. The length of a path is measured by the number of edges between the nodes on the path. Implement the function `int diameterOfBinaryTree(TreeNode* root)` that takes the root node of the binary tree and returns the diameter of the tree. In your implementation, you can assume that the tree will have at least one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Calculate the diameter of the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The diameter of the binary tree. def height(node): nonlocal diameter if not node: return 0 left_height = height(node.left) right_height = height(node.right) diameter = max(diameter, left_height + right_height) return 1 + max(left_height, right_height) diameter = 0 height(root) return diameter"},{"question":"Write a function to transform a given string `s` to its zigzag conversion with a given number of rows `numRows`. The function should return the string that reads line by line. For example, the string \\"PAYPALISHIRING\\" with 3 rows would be transformed to: ``` P A H N A P L S I I G Y I R ``` So the output for the above example would be \\"PAHNAPLSIIGYIR\\". Implement the function: ```python def convert(s: str, numRows: int) -> str: # Your code here ``` The function should handle edge cases like `numRows = 1` or `numRows >= len(s)` appropriately.","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s # Initialize a list of strings for each row rows = [\'\'] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 # Concatenate all rows and return return \'\'.join(rows)"},{"question":"Given a 2D integer array `mat` representing a matrix of dimensions `m x n` and an integer `k`, return _the maximum sum of any non-empty submatrix of `mat` such that the sum of the elements of the submatrix is less than or equal to `k`_. A submatrix is a rectangular region of the matrix formed by selecting some of its rows and columns.","solution":"def maxSumSubmatrix(matrix, k): import bisect def maxSumSubarray(arr, k): max_sum = -float(\'inf\') curr_sum = 0 cum_set = [0] for num in arr: curr_sum += num # We need cum_sum[j] such that cum_sum[j] >= cum_sum[i] - k where j < i idx = bisect.bisect_left(cum_set, curr_sum - k) if idx < len(cum_set): max_sum = max(max_sum, curr_sum - cum_set[idx]) bisect.insort(cum_set, curr_sum) return max_sum m, n = len(matrix), len(matrix[0]) max_sum = -float(\'inf\') # left and right define the bounds of the columns of the submatrix for left in range(n): row_sums = [0] * m for right in range(left, n): for i in range(m): row_sums[i] += matrix[i][right] max_sum = max(max_sum, maxSumSubarray(row_sums, k)) return max_sum"},{"question":"You are given a string `s` and an integer `k`. You need to determine if the string `s` can be rearranged to form a palindrome such that the maximum number of adjacent character swaps needed to achieve this rearrangement is less than or equal to `k`. A palindrome is a string that reads the same backward as forward. Return `true` if it\'s possible to rearrange `s` into a palindrome with the given constraints, otherwise return `false`.","solution":"def can_form_palindrome_with_swaps(s, k): from collections import Counter # Count frequency of each character char_count = Counter(s) # Check how many characters have odd counts odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome: # - If the length of the string is even, there should be no characters with odd counts. # - If the length is odd, there should be at most one character with an odd count. if odd_counts > 1: return False # The minimum number of swaps needed to make a string into a palindrome is # n//2 - number of positions where characters don\'t match from start to end # For the optimal number of swaps computation, it\'s a complex graph problem, # but for simplicity let\'s consider the condition checks. # Placeholder for actual swaps logic since exact optimal swap distance is complex # We use simple check only for constraint satisfaction: n = len(s) swap_needed = 0 for i in range(n // 2): if s[i] != s[n-i-1]: swap_needed += 1 # Since k is supposed to be the maximum allowed swaps, we directly check return swap_needed <= k"},{"question":"You have a task to develop a system to manage and query data for a warehouse. The warehouse system should be able to perform operations related to storing and searching products. Each product is represented by a `productCode` which is a string consisting of alphanumeric characters. Implement the `WarehouseManager` class: * `WarehouseManager()` constructs the `WarehouseManager`. * `addProduct(string productCode, int quantity)` adds a certain `quantity` of the given `productCode` to the warehouse. * `removeProduct(string productCode, int quantity)` removes a certain `quantity` of the given `productCode` from the warehouse. If the `quantity` to be removed exceeds the current stock of the product, remove only the available quantity. * `checkStock(string productCode)` returns the current stock of the given `productCode` in the warehouse. Note that a product\'s quantity should only be added or removed based on its current stock, and new product codes can be added dynamically during the operations. The `productCode`s are case-insensitive, meaning \'abc123\' and \'ABC123\' should be considered the same product.","solution":"class WarehouseManager: def __init__(self): self.inventory = {} def addProduct(self, productCode: str, quantity: int): productCode = productCode.lower() if productCode in self.inventory: self.inventory[productCode] += quantity else: self.inventory[productCode] = quantity def removeProduct(self, productCode: str, quantity: int): productCode = productCode.lower() if productCode in self.inventory: self.inventory[productCode] = max(0, self.inventory[productCode] - quantity) def checkStock(self, productCode: str): productCode = productCode.lower() return self.inventory.get(productCode, 0)"},{"question":"Given a string `s`, determine if it can be converted into a palindrome by removing **at most** one character. Return `true` if it can be converted into a palindrome, otherwise, return `false`.","solution":"def valid_palindrome(s: str) -> bool: Determines if the string can be converted into a palindrome by removing at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) i, j = i + 1, j - 1 return True"},{"question":"Given a string `s` consisting of lowercase alphabetic characters and parentheses `(` and `)`, remove the minimum number of parentheses (in any positions) so that the resulting parentheses string is valid. A parentheses string is valid if and only if it is the empty string, contains multiple pairs of opened and closed parentheses correctly, or contains nested valid parentheses. Return the resulting string.","solution":"def minRemoveToMakeValid(s): This function removes the minimum number of parentheses to make the input string valid. stack = [] s = list(s) for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: s[i] = \\"\\" while stack: s[stack.pop()] = \\"\\" return \\"\\".join(s)"},{"question":"You are given a string `expr` representing an arithmetic expression that consists of non-negative integers and the operators `+` and `*`. The expression does not contain any parentheses and each operator + or * will have exactly two operands. Your task is to write a function to calculate the result of the arithmetic expression following the standard operator precedence: `*` has higher precedence than `+`. Return an integer that represents the result of `expr`.","solution":"def evaluate_expression(expr): Evaluates a given arithmetic expression with + and * following the standard operator precedence. Args: expr (str): The arithmetic expression as a string. Returns: int: The result of the expression. # Split expression by \'+\' terms = expr.split(\'+\') # Process each term (which can contain only multiplication) evaluated_terms = [] for term in terms: factors = map(int, term.split(\'*\')) product = 1 for factor in factors: product *= factor evaluated_terms.append(product) # Sum of all evaluated terms result = sum(evaluated_terms) return result"},{"question":"You are given a 2D grid of integers where each integer represents the height of a building. A building can be represented as a rectangle in the grid and its height is the minimum height among all integers in that rectangle. Find the largest rectangle possible that can be formed in the grid such that the minimum height of the rectangle is greater than or equal to a given threshold `h`. Return the area of this rectangle.","solution":"def largest_rectangle_area_with_threshold(grid, h): Returns the largest rectangle area in the grid such that the minimum height of the rectangle is greater than or equal to threshold h. :param grid: List[List[int]] The 2D grid of integers representing building heights. :param h: int The height threshold. :return: int The area of the largest possible rectangle. # Helper function to calculate maximum histogram area def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize heights array with zeros heights = [0] * cols max_area = 0 for i in range(rows): for j in range(cols): if grid[i][j] >= h: heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"You are given a list of integers representing the stock prices of a company in chronological order. Implement a function to determine the maximum profit you can achieve by making at most two transactions. A transaction is defined as buying and then selling one share of the stock. *Note:* You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you can buy again). * Function Signature: `int maxProfit(int[] prices)` **Example:** `Input: prices = [3,3,5,0,0,3,1,4]` `Output: 6` `Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.`","solution":"def maxProfit(prices): Calculates the maximum profit from at most two transactions. :param prices: List[int] - List of stock prices :return: int - Maximum profit that can be achieved with at most two transactions if not prices: return 0 n = len(prices) first_buy = second_buy = float(\'-inf\') first_sell = second_sell = 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"Write a function that takes as input a 2D array `grid` representing a maze, where `1` represents a wall and `0` represents a path. Your function should find the shortest path from the top-left corner to the bottom-right corner. You can only move up, down, left, or right. Return the minimum number of steps required to reach the bottom-right corner, or -1 if no such path exists.","solution":"from collections import deque def shortest_path_maze(grid): Finds the shortest path from the top-left corner to the bottom-right corner in a maze represented as a 2D grid. Parameters: grid (List[List[int]]): 2D list representing the maze where 1 is a wall and 0 is a path. Returns: int: The minimum number of steps required to reach the bottom-right corner, or -1 if no path exists. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 # Directions for moving up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS, starting at (0, 0) with a step count of 1 queue = deque([(0, 0, 1)]) grid[0][0] = 1 # Mark as visited while queue: x, y, step = queue.popleft() # Check if we reached the bottom-right corner if x == rows - 1 and y == cols - 1: return step for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0: grid[new_x][new_y] = 1 # Mark as visited queue.append((new_x, new_y, step + 1)) return -1"},{"question":"You are given a list of `projects` where each project is represented by a pair of integers `[start, end]` denoting the start and end times of the project. Two projects are considered conflicting if they overlap in time. Your goal is to select the maximum number of non-conflicting projects. Return _the maximum number of non-conflicting projects you can select from the given list_.","solution":"def max_non_conflicting_projects(projects): Returns the maximum number of non-conflicting projects. Projects are represented by pairs of integers [start, end] denoting the start and end times. if not projects: return 0 # Sort projects based on their end times projects.sort(key=lambda x: x[1]) # Use a greedy approach to select the maximum number of non-conflicting projects count = 1 last_end_time = projects[0][1] for i in range(1, len(projects)): if projects[i][0] >= last_end_time: count += 1 last_end_time = projects[i][1] return count"},{"question":"You are given an unsorted integer array `nums` and an integer `k`. Write an algorithm that finds the `k`-th largest element in the array. Note that it is the `k`-th largest element in the sorted order, not the `k`-th distinct element. Implement the `Solution` class: * `Solution(int[] nums, int k)` Initializes the object with the integer array `nums` and the integer `k`. * `int findKthLargest()` Returns the `k`-th largest element in the array. Your algorithm should have a time complexity better than `O(n log n)`, where `n` is the number of elements in the array.","solution":"import heapq class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def findKthLargest(self): # use a min-heap with size k to store the k largest elements min_heap = self.nums[:self.k] heapq.heapify(min_heap) for num in self.nums[self.k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"You are given a binary tree with `n` nodes. Each node has an integer value. You need to find the length of the longest path in the tree such that the nodes on the path form a sequence where each node\'s value is exactly one more than the value of its parent node. Return the length of this path. Note that the path can start from any node and you cannot change the direction (left or right) once started on the path.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_consecutive(root): Returns the length of the longest path in the binary tree such that the node values form a sequence where each node\'s value is exactly one more than its parent. def helper(node, parent_val, length): if not node: return length if node.val == parent_val + 1: length += 1 else: length = 1 left_length = helper(node.left, node.val, length) right_length = helper(node.right, node.val, length) return max(length, left_length, right_length) if not root: return 0 return max(helper(root, root.val - 1, 0), helper(root.left, root.val, 0), helper(root.right, root.val, 0))"},{"question":"Write a function `minReorder(n, connections)` that determines the minimum number of edges you need to reverse to make all the nodes in an undirected graph reachable from node `0`. The function is given an integer `n` representing the number of nodes (labeled from `0` to `n-1`) and a list `connections` where each element is a list `[a, b]` representing a directed edge from node `a` to node `b`. The connections list is guaranteed to form a tree. Return the minimum number of edges that need to be reversed to make the entire tree connected, such that there is a path from node `0` to every other node in the tree.","solution":"def minReorder(n, connections): from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) # Build the graph and reverse graph for a, b in connections: graph[a].append(b) reverse_graph[b].append(a) visited = [False] * n queue = deque([0]) visited[0] = True reversals = 0 while queue: current = queue.popleft() # Explore all nodes connected to current in the original graph for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) reversals += 1 # Explore all nodes connected to current in the reversed graph for neighbor in reverse_graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return reversals"},{"question":"You are given a list of tuples `connections`, where each tuple `[a, b]` represents a direct connection between computer `a` and computer `b` in a network. Two computers are considered to be in the same network if there is a path of direct or indirect connections linking them. Write a function to determine if all given computers are part of a single network or if there are isolated segments. Return `true` if all computers are connected in a single network, otherwise return `false`.","solution":"def is_single_network(connections): from collections import defaultdict, deque if not connections: return True adjacency_list = defaultdict(list) nodes = set() for a, b in connections: nodes.add(a) nodes.add(b) adjacency_list[a].append(b) adjacency_list[b].append(a) visited = set() def bfs(start_node): queue = deque([start_node]) visited.add(start_node) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Start BFS from the first node first_node = next(iter(nodes)) bfs(first_node) # After BFS, if visited contains all nodes, it means all nodes are connected return len(visited) == len(nodes)"},{"question":"You are given an integer array `arr` of length `n` and an integer `m` such that `1 <= m <= n`. Your task is to rearrange the elements of `arr` such that the sum of every `m` consecutive elements is maximized. Return _the rearranged array_.","solution":"def maximize_consecutive_sum(arr, m): Rearrange the elements of `arr` such that the sum of every `m` consecutive elements is maximized. :param arr: List[int] -- input array :param m: int -- number of consecutive elements to maximize the sum for :return: List[int] -- rearranged array # Sort the array in decreasing order arr.sort(reverse=True) # Create the rearranged array to store result rearranged = [] n = len(arr) # Logic: We take the first m elements from the sorted array directly # because they are the largest numbers and will definitely maximize the first segment. # We then repeat this until we have covered the entire array. for i in range(n // m): rearranged.extend(arr[i*m:i*m + m]) # If there are any remaining elements that don\'t make up a full segment of size m, # append them at the end. remaining_elements = n % m if remaining_elements > 0: rearranged.extend(arr[-remaining_elements:]) return rearranged"},{"question":"You are given an integer array `arr` of size `n` representing the heights of `n` buildings, where `arr[i]` is the height of the `i-th` building. You are also given an integer `k`, denoting the maximum number of consecutive buildings you can paint. Your task is to find the maximum height difference between the highest and the lowest painted building if you paint exactly `k` consecutive buildings. Return the maximum height difference in the optimal painting scenario.","solution":"def max_height_difference(arr, k): Returns the maximum height difference between the highest and the lowest painted building if you paint exactly k consecutive buildings. :param arr: List[int] - heights of the buildings :param k: int - number of consecutive buildings to paint :return: int - maximum height difference n = len(arr) max_diff = 0 for i in range(n - k + 1): segment = arr[i:i+k] max_diff = max(max_diff, max(segment) - min(segment)) return max_diff"},{"question":"You are given an integer array `arr` and an integer `target`. Your task is to return an integer array of length 2, where the elements are the indices of the two numbers in `arr` whose sum is equal to `target`. If such a pair does not exist, return an empty array. Assume there is exactly one solution when a pair is found, and you may not use the same element twice. You can return the indices in any order.","solution":"def two_sum(arr, target): Returns the indices of the two numbers that add up to the target. Parameters: arr (list of int): The input array target (int): The target sum Returns: list of int: A list of two indices, or an empty list if no such pair exists num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can perform operations where you can choose any three consecutive characters in `s` and arbitrarily rearrange them. Return _the minimum number of such operations required to transform `s` so that no instances of three consecutive characters are the same_.","solution":"def min_operations_to_avoid_triplets(s): Return the minimum number of operations required to ensure that no three consecutive characters in s are the same. n = len(s) operations = 0 i = 0 while i < n - 2: # Check for triplets if s[i] == s[i + 1] == s[i + 2]: # If all three are the same, that means we need one operation to break this triplet operations += 1 # Skip the next character to ensure we\'re not including the just fixed triplet in the next one i += 3 else: i += 1 return operations"},{"question":"Given a 2D binary matrix `grid` of `0`s and `1`s, an island is a group of `1`s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Write a function that returns the minimum number of steps to convert all the land (`1`s) into water (`0`s). You can only perform one conversion (from `1` to `0`) at a time and all `1` adjacent to the converted `0` will be converted in the next step. Return the minimum number of steps required to convert all the land into water.","solution":"from collections import deque def min_steps_to_convert_land_to_water(grid): Returns the minimum number of steps to convert all lands (1s) in the grid to waters (0s). if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) queue = deque() steps = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c)) if not queue: return 0 # No land to convert # Directions for moving in 4 directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: steps += 1 for _ in range(len(queue)): row, col = queue.popleft() for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 0 queue.append((nr, nc)) return steps - 1 # Subtract 1 because the last increment happens when no more lands are left # Example usage # grid = [ # [0, 1, 0], # [1, 1, 1], # [0, 1, 0] # ] # print(min_steps_to_convert_land_to_water(grid)) # Output: 2"},{"question":"You are given a string `s` containing only characters `\'a\'` and `\'b\'`. You can swap out any `\'a\'` in the string for a `\'b\'` and any `\'b\'` for an `\'a\'`. Your goal is to form a string that has all `\'a\'` characters followed by all `\'b\'` characters (i.e., all `\'a\'`s come before any `\'b\'`s in the string). Return the minimum number of swaps required to achieve this.","solution":"def min_swaps_to_order(s): Returns the minimum number of swaps required to rearrange the string such that all \'a\'s come before all \'b\'s. # Count the total number of \'a\'s and \'b\'s in the string total_a = s.count(\'a\') total_b = len(s) - total_a # Any \'b\' found before having counted all \'a\'s is a misposition needed_swaps = 0 a_seen = 0 for char in s: if char == \'a\': a_seen += 1 elif char == \'b\' and a_seen < total_a: needed_swaps += 1 return needed_swaps"},{"question":"You are given an array of integers `nums` representing a list of numbers. Your task is to rearrange the numbers such that every `nums[i]` is equal to the product of the largest elements in all even indexed positions and all odd indexed positions up to `i-1`. More formally, assign the value of `nums[i]` such that: - If `i` is even, `nums[i]` should be equal to the product of the maximum elements at even indices among all preceding elements (including `i` itself). - If `i` is odd, `nums[i]` should be equal to the product of the maximum elements at odd indices among all preceding elements (including `i` itself). Return the rearranged array `nums`.","solution":"def rearrange(nums): if len(nums) == 0: return nums max_even = float(\'-inf\') max_odd = float(\'-inf\') new_nums = [] for i, num in enumerate(nums): if i % 2 == 0: # even index max_even = max(max_even, num) new_nums.append(max_even) else: # odd index max_odd = max(max_odd, num) new_nums.append(max_odd) return new_nums"},{"question":"Given a `m x n` integer grid `cost` where `cost[i][j]` represents the cost of stepping on the cell `(i, j)` from either the left or from above, return _the minimum cost to reach the bottom-right cell_ `(m-1, n-1)` from the top-left cell `(0, 0)`. You can only move either down or right at any point in time.","solution":"def min_path_cost(cost): Returns the minimum cost to reach the bottom-right cell from the top-left cell. :param cost: A list of lists of integers where cost[i][j] represents the cost of stepping on the cell (i, j) :return: Minimum cost to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0) if not cost or not cost[0]: return 0 m, n = len(cost), len(cost[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = cost[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + cost[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + cost[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[m-1][n-1]"},{"question":"You are given an integer array `arr` and an integer `n`. You can perform the following operation multiple times: choose any pair of adjacent elements in the array and swap them. However, you can only make up to `n` swaps in total. Your task is to find the lexicographically smallest array that can be obtained by performing up to `n` swaps. Return the lexicographically smallest array possible.","solution":"def get_lexicographically_smallest_array(arr, n): Returns the lexicographically smallest array possible by performing up to n swaps on adjacent elements. Parameters: arr (list of int): The original array. n (int): The maximum number of allowed swaps. Returns: list of int: The lexicographically smallest array. length = len(arr) for i in range(length): # To find the minimum element in the subarray arr[i:i+n+1] min_index = i for j in range(i + 1, min(length, i + n + 1)): if arr[j] < arr[min_index]: min_index = j # Calculate how many swaps needed to put arr[min_index] to arr[i] if min_index != i: n -= (min_index - i) value = arr.pop(min_index) arr.insert(i, value) if n <= 0: break return arr"},{"question":"Given an integer array `arr` and an integer `target`, return _the indices of two distinct numbers in the array that add up to_ `target`. You may assume that exactly one solution exists, and each input array will have at most one valid answer. You can return the answer in any order. Note that the array is **not** sorted.","solution":"def two_sum(arr, target): Given an array of integers, return indices of the two numbers such that they add up to a specific target. Assumes that there is exactly one solution, and array contains distinct elements. Parameters: arr (list): List of integers target (int): Target sum for two numbers in the array Returns: list: List containing indices of the two numbers num_map = {} # dictionary to store numbers and their indices for i, num in enumerate(arr): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i return [] # return an empty list if no solution is found (though the problem guarantees one solution)"},{"question":"Given an integer array `arr` and an integer `d`, you can jump from index `i` to index `j` in the array `arr` if `i < j` and `arr[i] < arr[j]` and `j` is at most `d` indices away from `i`. You have to find out the maximum number of indices you can visit in the array starting from any index. You can start jumping from any index in the array. Write a function `maxJumps(arr, d)` that returns the maximum number of indices you can visit.","solution":"def maxJumps(arr, d): def dfs(i): if dp[i] != -1: return dp[i] max_reach = 1 for direction in (-1, 1): for j in range(1, d+1): ni = i + direction * j if 0 <= ni < n and arr[ni] < arr[i]: max_reach = max(max_reach, 1 + dfs(ni)) else: break dp[i] = max_reach return max_reach n = len(arr) dp = [-1] * n return max(dfs(i) for i in range(n))"},{"question":"You are given a string `s` and two integers `x` and `y`. The string consists of characters \'A\', \'B\', and \'C\'. You need to transform the string by performing the following operations any number of times and in any order: 1. Remove a substring \\"AB\\" for a cost of `x`. 2. Remove a substring \\"BC\\" for a cost of `y`. Return the minimum cost to transform the string into a string that contains no substrings \\"AB\\" or \\"BC\\".","solution":"def min_cost_to_transform(s, x, y): Returns the minimum cost to remove all substrings \\"AB\\" and \\"BC\\" from the given string. total_cost = 0 # Initially, prioritize the cheaper operation if x < y: target1, cost1 = \\"AB\\", x target2, cost2 = \\"BC\\", y else: target1, cost1 = \\"BC\\", y target2, cost2 = \\"AB\\", x # Continuously remove the cheaper substring until none exists while target1 in s or target2 in s: while target1 in s: s = s.replace(target1, \'\', 1) total_cost += cost1 while target2 in s: s = s.replace(target2, \'\', 1) total_cost += cost2 return total_cost"},{"question":"You are given a list of integers `arr` consisting of `n` elements, and an integer `k`. An operation involves selecting any subarray of length `m` (where `m` is a positive integer) and reversing the order of its elements. Your task is to determine the **minimum** number of such operations needed to make the array strictly increasing. If it is not possible to make the array strictly increasing using any number of operations, return `-1`.","solution":"def min_operations_to_increase(arr, k): Determine the minimum number of operations needed to make the array strictly increasing by reversing subarrays of length k. If it is not possible to make the array strictly increasing, return -1. def is_strictly_increasing(lst): return all(x < y for x, y in zip(lst, lst[1:])) n = len(arr) if is_strictly_increasing(arr): return 0 for i in range(1, k + 1): new_arr = arr[:] for j in range(0, n, i): new_arr[j:j+i] = reversed(new_arr[j:j+i]) if is_strictly_increasing(new_arr): return 1 return -1"},{"question":"Given a `string` `s`, you need to decode it. The encoding rule is: `k[encoded_string]`, where the encoded_string inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer. You may assume that the input string is always valid, no extra white spaces, square brackets are well-formed, etc. Return _the decoded string_. **Example:** ```plaintext Input: s = \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" ```","solution":"def decodeString(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \\"[\\": stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \\"]\\": last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"You are given an integer array `nums` and an integer `target`. You need to place the operators `\'+\'` or `\'-\'` between the numbers in `nums` to get the target value. Return the number of possible ways to achieve the `target` by placing the operators. Each number in the array can only be used once with exactly one operator. The order in which numbers are given must be maintained. Two distinct sequences that result in the same sum are considered different ways.","solution":"def find_target_sum_ways(nums, target): Returns the number of ways to place the \'+\' or \'-\' operators between numbers in nums to get the target value. def backtrack(index, total): if index == len(nums): return 1 if total == target else 0 add = backtrack(index + 1, total + nums[index]) subtract = backtrack(index + 1, total - nums[index]) return add + subtract return backtrack(0, 0)"},{"question":"You are given a string `s` representing a sentence with words separated by spaces. Each word in the sentence consists of only uppercase and lowercase English letters, and the sentence does not contain any leading or trailing spaces. You need to return the last word of the sentence. If the string is empty or does not contain any words, return an empty string. Write a function that receives the input string `s` and returns the last word of the sentence. Your function should handle cases where there are multiple spaces between words and should trim any unnecessary spaces.","solution":"def get_last_word(s): Returns the last word of the sentence. Parameters: s (str): The input string representing the sentence. Returns: str: The last word of the sentence. If the string is empty or does not contain any word, returns an empty string. # Split the string by spaces words = s.split() # Return the last word if exists, else return empty string return words[-1] if words else \\"\\""},{"question":"You are given a list of strings `words` where each string consists of only lowercase English letters. Imagine you have an operation called \\"swap identical\\" where you can select two identical characters within a word and swap their positions. The aim is to make all words in the list anagrams of each other by performing this operation any number of times. Return the minimum number of swap operations needed to make all the words in the list anagrams of each other or `-1` if it\'s not possible to achieve this. For example, given `words = [\\"aabb\\", \\"ab\\", \\"bbaa\\"]`, the output should be `1` since swapping the two \'a\'s in the first word puts \'a\' at the same positions as in the other words.","solution":"from collections import Counter def min_swaps_to_make_anagrams(words): Returns the minimum number of swap operations needed to make all words in the list anagrams of each other, or -1 if it\'s not possible to achieve this. if not words: return 0 # Get the character frequency of the first word char_freq = Counter(words[0]) # Check all words have the same character count for word in words: if Counter(word) != char_freq: return -1 return 0 # Since all words are already anagrams of each other"},{"question":"Given a list of `n` integers representing the **weights** of `n` packages, you need to load these packages into two trucks such that the difference between the sum of the weights in the first truck and the sum of the weights in the second truck is minimized. Each truck can hold any number of packages from the list. Return _the **minimum difference** possible between the total weights of the two trucks._","solution":"from itertools import combinations def minimum_weight_difference(weights): Returns the minimum difference possible between the total weights of two trucks given a list of weights. total_weight = sum(weights) n = len(weights) # We need to find subsets which sum up closest to total_weight // 2 min_diff = float(\'inf\') for i in range(n//2 + 1): for subset in combinations(weights, i): subset_weight = sum(subset) diff = abs((total_weight - subset_weight) - subset_weight) min_diff = min(min_diff, diff) return min_diff"},{"question":"[Question] 4: You are given an array of integers `arr` and an integer `k`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that `arr[i] == arr[j]` and the absolute difference between `i` and `j` is at most `k`. Return `true` if such indices exist, otherwise return `false`. **Example 1:** **Input:** arr = [1, 2, 3, 1], k = 3 **Output:** true **Explanation:** There are two 1s in the array, and their indices (0, 3) are at most 3 units apart. **Example 2:** **Input:** arr = [1, 0, 1, 1], k = 1 **Output:** true **Explanation:** There are two 1s in the array, and their indices (2, 3) are at most 1 unit apart. **Example 3:** **Input:** arr = [1, 2, 3, 1, 2, 3], k = 2 **Output:** false **Explanation:** Although there are duplicate elements, none are at most 2 units apart in their indices. **Constraints:** - 1 <= arr.length <= 10^5 - -10^9 <= arr[i] <= 10^9 - 0 <= k <= 10^9","solution":"def contains_nearby_duplicate(arr, k): Returns true if there are two distinct indices `i` and `j` in the array such that arr[i] == arr[j] and the absolute difference between `i` and `j` is at most `k`. index_map = {} for i, num in enumerate(arr): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"You are given a string `s` representing a list of words separated by spaces. Each word consists of lowercase letters only. We define a \\"clique\\" as a group of words where each word shares at least one common letter with every other word in the group. Your task is to find the size of the largest \\"clique\\" in the string. Return the size of the largest \\"clique\\".","solution":"def share_common_letter(word1, word2): Check if two words share at least one common letter. return bool(set(word1) & set(word2)) def largest_clique_size(s): Find the size of the largest clique where each word shares at least one common letter with every other word in the group. words = s.split() n = len(words) def dfs(node, visited, graph): visited.add(node) size = 1 for neighbor in graph[node]: if neighbor not in visited: size += dfs(neighbor, visited, graph) return size # Build the graph graph = {i: [] for i in range(n)} for i in range(n): for j in range(i + 1, n): if share_common_letter(words[i], words[j]): graph[i].append(j) graph[j].append(i) # Perform DFS to find the largest connected component visited = set() largest_clique = 0 for node in range(n): if node not in visited: largest_clique = max(largest_clique, dfs(node, visited, graph)) return largest_clique"},{"question":"You are given a grid of size `m x n` consisting of `0`s (land) and `1`s (water). An island is a maximal 4-directionally (horizontal or vertical) connected group of `0`s. Your task is to find and return the largest island (largest number of `0`s connected). If there is no island, return `0`.","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. An island is a maximal 4-directionally (horizontal or vertical) connected group of `0`s. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return 0 # Mark as visited grid[x][y] = -1 return 1 + dfs(x+1, y) + dfs(x-1, y) + dfs(x, y+1) + dfs(x, y-1) max_island_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 0: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"Given a string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. 3. Each close bracket has a corresponding open bracket before it. Implement a function: ```python def isValid(s: str) -> bool: # your code here ``` Return `true` if the string is valid, `false` otherwise. Example: ```python isValid(\\"()\\") => true isValid(\\"()[]{}\\") => true isValid(\\"(]\\") => false isValid(\\"([)]\\") => false isValid(\\"{[]}\\") => true ```","solution":"def isValid(s: str) -> bool: Determine if the input string of brackets is valid. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given an array `nums` of integers. The task is to determine whether there exists a ***132*** pattern in the array. A ***132*** pattern is a subsequence of three integers `nums[i]`, `nums[j]`, `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`. * Note that the numbers in the **pattern** do not need to be consecutively located in the array. Return `true` if there is a 132 pattern in `nums` otherwise return `false`. ***Example:*** ``` Input: nums = [3, 1, 4, 2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. ``` ``` Input: nums = [1, 2, 3, 4] Output: false Explanation: There is no 132 pattern in the sequence. ```","solution":"def find132pattern(nums): if len(nums) < 3: return False # Using a stack to maintain the candidate\'s third element(k) stack = [] third = float(\'-inf\') # Traversing elements from right to left for num in reversed(nums): if num < third: return True while stack and num > stack[-1]: third = stack.pop() stack.append(num) return False"},{"question":"Given an integer array `nums` and an integer `k`, where `k` is guaranteed to be less than the length of the array, your task is to return the maximum sum of any contiguous subarray of length `k`. For example, if the input is `nums = [1, 4, 2, 10, 23, 3, 1, 0, 20]` and `k = 4`, the maximum sum subarray of length `k` is `[4, 2, 10, 23]`, with a sum of `39`. Write a function to achieve this result, ensuring your approach runs in linear time, O(n).","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any contiguous subarray of length k. :param nums: List[int] - List of integers. :param k: int - Length of the subarray. :return: int - Maximum sum of the contiguous subarray of length k. # Initialize the maximum sum to be the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Slide the window over the rest of the array for i in range(k, len(nums)): # Move the window to the right: add the next element and remove the first element of the previous window current_sum += nums[i] - nums[i - k] # Update the maximum sum if the current window\'s sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of `n` integers, `arr`, where `arr[i]` represents the rating of the ith student. Your task is to distribute candies to the students such that: * Each student must receive at least one candy. * Students with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to distribute. You may assume that the length of the list `n` is always at least 1.","solution":"def min_candies(arr): Returns the minimum number of candies required to distribute among students with the given ratings, ensuring each student receives at least one candy and students with higher ratings get more candies than their neighbors. n = len(arr) if n == 0: return 0 candies = [1] * n # First pass: from left to right, ensure each student has more candies than # the left neighbor if the rating is higher for i in range(1, n): if arr[i] > arr[i-1]: candies[i] = candies[i-1] + 1 # Second pass: from right to left, ensure each student has more candies than # the right neighbor if the rating is higher for i in range(n-2, -1, -1): if arr[i] > arr[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) # Return the sum of all candies return sum(candies)"},{"question":"You are given a `root` node of a binary tree. Each node\'s value is either 0 or 1. The tree traversal rule is defined as: * If you are at a node with value 1, you can move only to the nodes at even levels from this node. * If you are at a node with value 0, you can move only to the nodes at odd levels from this node. A **valid path** is any path that starts at the root node and ends at any leaf node, following the traversal rule. Return `true` if there exists **at least one valid path** from the root to a leaf, otherwise return `false`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_valid_path(root): Determines if there is at least one valid path from the root to a leaf node, following the traversal rule. :param TreeNode root: The root node of the tree. :return: True if there is a valid path, else False. :rtype: bool def dfs(node, level): if not node: return False if not node.left and not node.right: return True if node.value == 1: # Can move to nodes at even levels next_level = level + 1 if next_level % 2 == 0: return (node.left and dfs(node.left, next_level)) or (node.right and dfs(node.right, next_level)) else: # Can move to nodes at odd levels next_level = level + 1 if next_level % 2 != 0: return (node.left and dfs(node.left, next_level)) or (node.right and dfs(node.right, next_level)) return False return dfs(root, 0)"},{"question":"You are given a list of `n` integers representing the height of buildings on a street. The city plans to enhance the view by allowing travelers to see the maximum height of buildings to their left as they walk along the street. This is represented by a new list, `leftMaxView`, where `leftMaxView[i]` is the maximum height of buildings from the beginning of the list up to the `i-th` building (inclusive). Implement the function `leftMaxView` that takes an integer list `heights` as input and returns the list `leftMaxView`. For example, given the input `heights = [3, 7, 8, 3, 6, 1, 4]`, the expected output is `[3, 7, 8, 8, 8, 8, 8]`.","solution":"def leftMaxView(heights): Returns the list of maximum height from the beginning of the list up to each building. :param heights: A list of integers representing building heights. :return: A list of integers where each element is the maximum height of buildings from the start up to that index in the input list. if not heights: return [] max_view = [heights[0]] for i in range(1, len(heights)): max_view.append(max(max_view[-1], heights[i])) return max_view"},{"question":"[Question] 4: You are given an array of integers `arr` representing the choices available. Your task is to determine whether it\'s possible to partition the array into two subsets such that the sum of elements in both subsets is equal. If it is possible, return `true`; otherwise, return `false`. Example: - Input: arr = [1, 5, 11, 5] - Output: true - Explanation: The array can be partitioned as [1, 5, 5] and [11]. Note: The sum of the elements in both subsets must be exactly equal, considering all elements of the array and no element should be excluded from the subsets.","solution":"def can_partition(arr): total_sum = sum(arr) # If total sum is odd, it\'s not possible to partition into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(arr) # Creating a dp array of (target_sum+1) elements, initialized with False dp = [False] * (target_sum + 1) dp[0] = True for num in arr: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target_sum]"},{"question":"You are given a binary tree with `n` nodes, where each node is labeled from `0` to `n-1`. The task is to implement a function that calculates the sum of the values of nodes at each level of the tree. Given the root node of the tree, return an array where each element represents the sum of the nodes\' values at that level, starting from the root level. Implement the function `levelOrderSum(root)`, where `root` is the root node of the tree, and it returns an array of integers representing the sum of values at each level. **Example:** Input: ``` 1 / 2 3 / / 4 5 6 7 ``` Output: [1, 5, 22]","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderSum(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_sum = 0 for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"You are given a **binary string** `s` (a string consisting only of \'0\'s and \'1\'s). You can change **exactly one** \'0\' to \'1\' to create a new binary string. Determine the **length** of the longest contiguous sequence of \'1\'s that can be obtained. Return _the maximum length of the contiguous sequence of \'1\'s after making the modification._","solution":"def longest_contiguous_ones(s): Given a binary string `s`, determines the length of the longest contiguous sequence of \'1\'s that can be obtained by changing exactly one \'0\' to \'1\'. max_len = 0 n = len(s) zeros_positions = [i for i, char in enumerate(s) if char == \'0\'] if not zeros_positions: # No \'0\' in the string return n for pos in zeros_positions: left = right = pos # Expand left while left > 0 and s[left - 1] == \'1\': left -= 1 # Expand right while right < n - 1 and s[right + 1] == \'1\': right += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a non-negative integer `num`, repeatedly add all its digits until the result has only one digit, and return that result.","solution":"def add_digits(num): Repeatedly add all digits of a non-negative integer num until the result has only one digit. :param num: Non-negative integer :return: Single digit integer while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern string `p` consisting of lowercase English letters. Your task is to check if the pattern `p` can be found in the string `s` as a contiguous substring. Return a boolean indicating whether `p` is a substring of `s`. For example, if `s` is `\\"abcdefgh\\"` and `p` is `\\"cde\\"`, the output should be `True` as `\\"cde\\"` is a substring of `\\"abcdefgh\\"`.","solution":"def is_substring(s, p): Returns True if p is a substring of s, else returns False. return p in s"},{"question":"You are given an array of integers `arr` and an integer `threshold`. You can perform the following operation any number of times: - Choose an element from the array and decrement it by `1`. Your task is to find the minimum number of operations required so that the sum of all elements in the array is less than or equal to the `threshold`.","solution":"def min_operations_to_threshold(arr, threshold): Returns the minimum number of operations required to make the sum of all elements in `arr` less than or equal to `threshold`. An operation consists of choosing an element and decrementing it by 1. operations = 0 current_sum = sum(arr) while current_sum > threshold: current_sum -= 1 operations += 1 return operations"},{"question":"You are given an integer array `nums` of length `n`. A subarray is a contiguous part of an array. A subarray sum is simply the sum of all elements in the subarray. Return the maximum possible subarray sum of any length.","solution":"def max_subarray_sum(nums): Returns the maximum possible subarray sum of any length. Uses Kadane\'s Algorithm which runs in O(n) time. :param nums: List[int] - A list of integers representing the array. :return: int - The maximum subarray sum. max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given an array of integers `arr` representing the height of each tree in a forest. Your task is to cut the trees such that you are left with only the `k` tallest trees. If there are less than `k` trees in the array, return an empty array indicating no trees are left. The heights of the remaining trees should be preserved in their original order. Write a function to implement this task.","solution":"def tallest_trees(arr, k): Returns the heights of the k tallest trees, preserving their original order. If there are less than k trees, return an empty array. if len(arr) < k: return [] sorted_arr = sorted(arr, reverse=True) kth_tallest_height = sorted_arr[k - 1] # Collect heights that are greater than or equal to the kth tallest remaining_trees = [height for height in arr if height >= kth_tallest_height] return remaining_trees[:k]"},{"question":"You are given an initial array `tasks` where the ith element represents the time required to complete the ith task. You need to organize these tasks in such a way that you maximize the number of tasks completed within a given time limit `T`. Return _the **maximum number** of tasks that can be completed within the given time limit._","solution":"def max_tasks_completed(tasks, T): Returns the maximum number of tasks that can be completed within the given time limit T. Params: tasks (list of int): Time required to complete each task. T (int): The time limit. Returns: int: The maximum number of tasks that can be completed within the given time limit. tasks.sort() total_time = 0 task_count = 0 for task in tasks: if total_time + task <= T: total_time += task task_count += 1 else: break return task_count"},{"question":"Given a string `pattern` and a string `str`, implement a function to find if `str` follows the same pattern. Here, following the pattern means there is a bijection between a letter in `pattern` and a non-empty word in `str`. Ensure that no two characters map to the same word and vice versa. If the string adheres to the pattern, return `true`; otherwise, return `false`.","solution":"def follows_pattern(pattern, str): Returns true if the string follows the same pattern. words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are given a string `s` that consists of lowercase English letters and `#` characters. You can remove a `#` and the character that immediately precedes it, stepping towards an empty string. Find the resulting string after all possible removals have been made. Consider all `#` characters in the original string and apply the removals in a single pass, from left to right. Return the resulting string after all `#` removals.","solution":"def remove_backspaces(s): Process a string `s` containing \'#\' characters that act as backspaces, removing each \'#\' and the character preceding it. Args: s (str): Input string containing lowercase letters and \'#\' characters. Returns: str: The resulting string after processing all backspaces. stack = [] for char in s: if char == \'#\': if stack: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an array of integers `nums` and an integer `k`. Rearrange the array such that the element at index `i` in the original array is moved to index `(i + k) % n` in the rearranged array, where `n` is the length of the array. Implement a function `rotateArray(nums, k)` that returns the rearranged array. **Note:** - The input array will have at least one element. - `k` can be any integer.","solution":"def rotateArray(nums, k): Rotates the array such that the element at index i in the original array is moved to index (i + k) % n in the rearranged array. Args: nums: List[int] - The original array of integers. k: int - The number of positions to rotate the array. Returns: List[int] - The rearranged array. n = len(nums) k = k % n # Normalize k to be within the bounds of the array length return nums[-k:] + nums[:-k]"},{"question":"Megan is working on an algorithm to optimize network routing. She has a `n x n` matrix `graph` representing the distances between `n` nodes. Each `graph[i][j]` denotes the distance from node `i` to node `j`. If `graph[i][j]` is `-1`, it means there is no direct connection between node `i` and node `j`. Megan needs to compute the shortest path between each pair of nodes and update the matrix so that `graph[i][j]` contains the shortest distance from node `i` to node `j`. If a pair of nodes is not connected by any path, the distance should remain `-1`. Return the updated `graph` matrix with the shortest paths between all nodes.","solution":"def floyd_warshall(graph): Performs Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes. :param graph: List[List[int]], 2D matrix representing the weights of the edges. If graph[i][j] is -1, it means there is no direct connection. :return: List[List[int]], updated graph with shortest paths between all pairs of nodes. n = len(graph) # Initialize the matrix: replace -1 with inf, except on the diagonal (identity paths with zero cost) for i in range(n): for j in range(n): if graph[i][j] == -1 and i != j: graph[i][j] = float(\'inf\') # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if graph[i][j] > graph[i][k] + graph[k][j]: graph[i][j] = graph[i][k] + graph[k][j] # Convert inf back to -1 for no connections for i in range(n): for j in range(n): if graph[i][j] == float(\'inf\'): graph[i][j] = -1 return graph"},{"question":"Given an m x n matrix of integers, write a function to return all the elements of the matrix in diagonal order. The diagonal order starts from the top-left corner and moves in a zigzag pattern (i.e., starting upwards for the first diagonal, downwards for the second, and so on). For example, given the following matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The returned array should be `[1, 2, 4, 7, 5, 3, 6, 8, 9]`. Ensure your function handles matrices of different dimensions and values.","solution":"def find_diagonal_order(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] diagonals = {} for i in range(m): for j in range(n): if i + j not in diagonals: diagonals[i + j] = [] diagonals[i + j].append(matrix[i][j]) for k in range(m + n - 1): if k % 2 == 0: result.extend(reversed(diagonals[k])) else: result.extend(diagonals[k]) return result"},{"question":"You are given a string `s` consisting of lowercase English letters and an array `letters` consisting of distinct characters representing a set of allowed letters. Your task is to find the longest substring of `s` that contains only characters from `letters`. Return the length of this longest substring.","solution":"def longest_allowed_substring(s, letters): Returns the length of the longest substring of \'s\' that contains only characters from \'letters\'. :param s: str, the input string consisting of lowercase English letters :param letters: list of str, the allowed characters :return: int, the length of the longest allowed substring allowed_set = set(letters) max_length = 0 current_length = 0 for char in s: if char in allowed_set: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"Given a list of integers `arr` and an integer `k`, return the **maximum sum** of a subsequence of `arr` such that the subsequence\'s length is `k` and its elements are in **increasing order**. If no such subsequence exists, return 0. Note that the subsequence does not necessarily have to be contiguous within `arr`.","solution":"def max_sum_increasing_subseq_of_length_k(arr, k): Returns the maximum sum of a subsequence of arr such that the subsequence\'s length is k and its elements are in increasing order. If no such subsequence exists, return 0. n = len(arr) if n < k: return 0 # Initialize dp array where dp[i][j] is the maximum sum of increasing subsequence of length j ending with arr[i] dp = [[0] * (k + 1) for _ in range(n)] for i in range(n): # initialize subsequences of length 1 dp[i][1] = arr[i] for length in range(2, k + 1): # build up the subsequences for lengths from 2 to k for i in range(n): dp[i][length] = float(\'-inf\') for j in range(i): if arr[j] < arr[i] and dp[j][length - 1] != float(\'-inf\'): dp[i][length] = max(dp[i][length], dp[j][length - 1] + arr[i]) max_sum = float(\'-inf\') for i in range(n): if dp[i][k] != float(\'-inf\'): max_sum = max(max_sum, dp[i][k]) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"You are given an array of `n` integers `arr` and two integers `x` and `y`. Write a function to determine whether there exists a pair of indices `(i, j)` such that `arr[i] + arr[j]` equals `x` *and* `abs(i - j) <= y`. Return `true` if such a pair exists, and `false` otherwise.","solution":"def has_pair_with_sum(arr, x, y): Determines if there exists a pair of indices (i, j) such that: - arr[i] + arr[j] equals x - abs(i - j) <= y Parameters: arr (list): List of integers. x (int): Target sum. y (int): Maximum index difference. Returns: bool: True if such a pair exists, False otherwise. for i in range(len(arr)): for j in range(max(0, i - y), min(len(arr), i + y + 1)): if i != j and arr[i] + arr[j] == x: return True return False"},{"question":"Given an integer array `arr`, move all zeroes to the end of the array while maintaining the relative order of the non-zero elements. Note that you must accomplish this without making a copy of the array and with a time complexity of O(n). Return _the modified array after moving the zeroes_.","solution":"def move_zeroes(arr): Moves all zeroes in the array to the end while maintaining the order of non-zero elements. Parameters: arr (list): List of integers. Returns: list: The modified list with all zeroes at the end. non_zero_index = 0 # Pointer to place non-zero elements for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 for j in range(non_zero_index, len(arr)): arr[j] = 0 return arr"},{"question":"You are given a non-empty array of integers `arr` and an integer `target`. Find a subarray whose sum is closest to the given target and return _the sum of that subarray_. If there are multiple answers, choose the subarray with the smallest length. If there is still a tie, choose the one with the smallest starting index.","solution":"def closest_subarray_sum(arr, target): Finds a subarray whose sum is closest to the given target. If there are multiple answers, choose the subarray with the smallest length. If there is still a tie, choose the one with the smallest starting index. Parameters: arr (list): a list of integers target (int): the target sum Returns: int: the sum of the subarray closest to the target n = len(arr) closest_sum = float(\'inf\') best_len = float(\'inf\') best_start_index = float(\'inf\') for start in range(n): current_sum = 0 for end in range(start, n): current_sum += arr[end] current_length = end - start + 1 if (abs(current_sum - target) < abs(closest_sum - target) or (abs(current_sum - target) == abs(closest_sum - target) and current_length < best_len) or (abs(current_sum - target) == abs(closest_sum - target) and current_length == best_len and start < best_start_index)): closest_sum = current_sum best_len = current_length best_start_index = start return closest_sum"},{"question":"You are given a **1-indexed** integer array `position`, where `position[i]` represents the position of a ball on a linear track. Two players take turns to move the balls. On each turn, a player must move a single ball to any unoccupied position on the track. The player who cannot make a move loses the game. Return a list of integers representing the positions of the balls in `position` just before the last move. If the game cannot be started, return an empty list `[]`.","solution":"def positions_before_last_move(position): Returns the positions of the balls just before the last move is made. If the game cannot be started, return an empty list. position.sort() n = len(position) if n == 0 or n == 1: return [] for i in range(1, n): if position[i] - position[i-1] > 1: return position return []"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). Return the result as a list of lists, where each inner list contains the nodes at that level. [Question 4]: Given a string s containing only three types of characters: \'(\', \')\' and \'*\', write a function to check whether s is valid. The string is valid if: - Any left parenthesis \'(\' must have a corresponding right parenthesis \')\'. - Any right parenthesis \')\' must have a corresponding left parenthesis \'(\'. - Left parenthesis \'(\' must go before the corresponding right parenthesis \')\'. - \'*\' could be treated as a single right parenthesis \')\' or a single left parenthesis \'(\' or an empty string. Return `True` if the string is valid, and `False` otherwise.","solution":"def checkValidString(s: str) -> bool: Check if the input string s is valid according to the given rules. left_balance = 0 for char in s: if char == \'(\' or char == \'*\': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False right_balance = 0 for char in reversed(s): if char == \')\' or char == \'*\': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"You are given an array that represents the number of citations that researchers have. Each element of the array `citations` corresponds to a researcher\'s total number of citations. Your goal is to determine the researcher\'s h-index. The h-index is defined as follows: A researcher has an index h if `h` of their `n` papers have at least `h` citations each, and the other `n - h` papers have no more than `h` citations each. Given the array `citations`, return the researcher\'s h-index. # Example: Input: `citations = [3, 0, 6, 1, 5]` Output: `3` Explanation: The researcher has 3 papers with at least 3 citations each (i.e., [3, 6, 5]) and the remaining 2 papers have no more than 3 citations (i.e., [0, 1]). Thus, the h-index is 3.","solution":"def h_index(citations): Calculate the h-index given an array of citations. citations.sort(reverse=True) h = 0 for i, c in enumerate(citations): if c >= i + 1: h = i + 1 else: break return h"},{"question":"You are given an array of tasks `tasks` where each task is represented by a unique integer, and an integer `k` representing the cooldown period between two same tasks. Your goal is to find the minimum time required to finish all tasks. At each unit of time, you can either execute a task or be idle. If a task is executed at time `t`, the same task cannot be executed again until time `t + k + 1`. Return the minimum time needed to complete all tasks.","solution":"from collections import Counter def least_interval(tasks, k): Returns the minimum time required to complete all tasks with a given cooldown period. if not tasks: return 0 # Count frequencies of the tasks task_counts = Counter(tasks) max_task_count = max(task_counts.values()) max_task_count_frequency = list(task_counts.values()).count(max_task_count) # Calculate the minimum intervals needed intervals_needed = (max_task_count - 1) * (k + 1) + max_task_count_frequency return max(intervals_needed, len(tasks))"},{"question":"You are given two strings `s1` and `s2` of the same length containing only the characters \'0\', \'1\', and \'2\'. You want to make both strings equal by applying the following operation any number of times: **choose a character in `s1` and a character in `s2` at the same position, and swap them if the characters are different**. Return `true` if it is possible to make the strings equal using any number of operations, and `false` otherwise.","solution":"def can_make_equal(s1, s2): Returns True if it is possible to make strings s1 and s2 equal by applying swaps of characters at the same positions any number of times. Otherwise, returns False. # Count the frequency of each character in s1 and s2 from collections import Counter count_s1 = Counter(s1) count_s2 = Counter(s2) # Both strings can be made equal if and only if they have the same character counts return count_s1 == count_s2"},{"question":"Given a list of `N` integers, write a function that returns a list of integers containing only the elements that appear more than once in the input list. Ensure the output list contains elements in the order they first appear as repeated elements in the input list. For example, given the list: `[4, 5, 6, 7, 5, 6, 8, 4, 9, 5]` The output should be: `[5, 6, 4]`","solution":"def get_repeated_elements(lst): Returns a list of elements that appear more than once in the input list in the order they first appear as repeated elements. seen = set() repeated = set() result = [] for num in lst: if num in seen: if num not in repeated: result.append(num) repeated.add(num) else: seen.add(num) return result"},{"question":"You are given a string `s` and an integer `k`. The string consists of lowercase English letters. You can choose any one of the first `k` characters of `s` and append it to the end of the string. You can perform this operation any number of times. Return the lexicographically smallest string you can obtain after applying the above operation any number of times. Note that a string `a` is lexicographically smaller than a string `b` if in the first position where `a` and `b` differ, `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. For example, `\\"abc\\"` is lexicographically smaller than `\\"abd\\"` because the first position they differ is at the third letter, and `\'c\'` comes before `\'d\'`.","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by choosing from the first k characters and appending them to the end. if k == 1: smallest_string = s for i in range(1, len(s)): rotated = s[i:] + s[:i] if rotated < smallest_string: smallest_string = rotated return smallest_string else: return \'\'.join(sorted(s))"},{"question":"Given an array of distinct integers `nums`, and an integer `k`, return the k-th smallest element in the array if the array is sorted in ascending order. Implement a function `findKthSmallest(nums, k)` that returns this value using an algorithm that ensures a time complexity better than O(n log n).","solution":"def findKthSmallest(nums, k): Returns the k-th smallest element in the list nums. def quickselect(l, r, k): Helper function to perform the quickselect algorithm. if l == r: return nums[l] pivot_index = partition(l, r) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(l, pivot_index - 1, k) else: return quickselect(pivot_index + 1, r, k) def partition(l, r): Helper function to partition the array into elements less than and greater than the pivot. pivot = nums[r] i = l for j in range(l, r): if nums[j] < pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[r] = nums[r], nums[i] return i return quickselect(0, len(nums) - 1, k - 1)"},{"question":"Given a **0-indexed** string `s`, and a list of queries where each query is of the form `[start, end, character]`, determine for each query whether the substring of `s` from `start` to `end` (inclusive) contains all occurrences of the character `character`. Return _a list of boolean values where each boolean value corresponds to a query, being `True` if the substring contains all occurrences of the character, and `False` otherwise_. Ensure your solution handles overlapping and non-overlapping substrings efficiently.","solution":"def check_occurrences(s, queries): For each query, check if the substring of s from start to end contains all occurrences of character. Parameters: s (str): The input string. queries (List[List[int]]): List of queries where each query is of the form [start, end, character]. Returns: List[bool]: List of boolean values corresponding to each query. results = [] for start, end, char in queries: substring = s[start:end+1] # Check if all occurrences of char in the full string are within the substring results.append(s.count(char) == substring.count(char)) return results"},{"question":"You are given a binary search tree with integer values. Write a function that returns the sum of all nodes with values within a given range [low, high] (inclusive). The function should have the signature: ```python def rangeSumBST(root: TreeNode, low: int, high: int) -> int: ``` where `root` represents the root node of the binary search tree, and `low` and `high` specify the range. The binary search tree is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root: TreeNode, low: int, high: int) -> int: def dfs(node: TreeNode) -> int: if not node: return 0 if node.val < low: return dfs(node.right) if node.val > high: return dfs(node.left) return node.val + dfs(node.left) + dfs(node.right) return dfs(root)"},{"question":"Write a function to reverse a linked list. The input to the function should be the head of a singly linked list, and the function should return the head of the new reversed list. Define the `ListNode` class as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Function signature:** ```python def reverseList(head: ListNode) -> ListNode: # Your code here ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the new reversed list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given an m x n grid where each cell is either a dry land `0` or water `1`. You can perform the following operation: Choose any water cell and transform it into a dry land cell. At most one operation is allowed. Your task is to identify the largest possible size of an island that can be formed, after performing at most one operation. An island is a group of `1`s (water cells) connected 4-directionally (horizontal or vertical). Determine the maximum size of the island possible after at most one operation. Return that maximum island size.","solution":"def max_island(grid): Given a grid of dry land (0) and water (1), find the largest possible size of an island after changing at most one water cell to dry land. rows, cols = len(grid), len(grid[0]) def dfs(x, y, index): if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != 1: return 0 grid[x][y] = index return 1 + dfs(x-1, y, index) + dfs(x+1, y, index) + dfs(x, y-1, index) + dfs(x, y+1, index) island_sizes = {} island_index = 2 # Find all original islands and their sizes. for i in range(rows): for j in range(cols): if grid[i][j] == 1: island_sizes[island_index] = dfs(i, j, island_index) island_index += 1 max_island_size = max(island_sizes.values(), default=0) # Try to change each 0 to 1 and calculate potential max island size. for i in range(rows): for j in range(cols): if grid[i][j] == 0: seen = set() current_size = 1 # Changing this 0 to 1 for nx, ny in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] > 1: index = grid[nx][ny] if index not in seen: current_size += island_sizes[index] seen.add(index) max_island_size = max(max_island_size, current_size) return max_island_size"},{"question":"You are given an array of integers `arr` representing the heights of students standing in a line in any order. Your task is to arrange the students into the line such that each student is either taller than the student immediately before them or shorter than the student immediately after them, creating as many peaks and valleys as possible. Return the rearranged array where this condition is met. If there are multiple correct answers, return **any** of them.","solution":"def rearrange_heights(arr): Rearranges the array such that the heights form peaks and valleys. Args: arr (list): List of integers representing heights. Returns: list: Rearranged list with peaks and valleys. arr.sort() # Create the peaks and valleys for i in range(1, len(arr) - 1, 2): arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"Given an integer `m` and a list of integers `arrivalTimes` representing the arrival times of guests at an event, each guest stays for `k` minutes. Determine the maximum number of guests present at the event at any given time. _Return this maximum number as an integer value_.","solution":"def max_guests(arrivalTimes, k): Determines the maximum number of guests present at any given time. Parameters: arrivalTimes (list of int): List of guests\' arrival times. k (int): Duration of stay for each guest in minutes. Returns: int: Maximum number of guests present at the event simultaneously. events = [] for arrival in arrivalTimes: events.append((arrival, \'arrive\')) events.append((arrival + k, \'depart\')) # Sort events by time with \'arrive\' events taking priority if they have the same time events.sort(key=lambda x: (x[0], x[1] == \'depart\')) max_guests = 0 current_guests = 0 for event in events: if event[1] == \'arrive\': current_guests += 1 max_guests = max(max_guests, current_guests) else: current_guests -= 1 return max_guests"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in **non-decreasing order**. Return an array of the **first K smallest** sums formed by adding an element from `nums1` and an element from `nums2`. The input arrays `nums1` and `nums2` will contain **unique** integers. The value of `K` will be less than or equal to the length of the total number of possible sums.","solution":"import heapq def k_smallest_pairs(nums1, nums2, k): Returns an array of the first K smallest sums formed by adding an element from nums1 and an element from nums2. if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(k, len(nums1))): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while k > 0 and min_heap: current_sum, i, j = heapq.heappop(min_heap) result.append(current_sum) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) k -= 1 return result"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Modify the list in such a way that each element of the list is incremented by `k` non-negative integer multiples (including zero). The goal is to maximize the sum of the list after the modification while keeping the list elements in non-decreasing order. Return the maximum possible sum of the modified list.","solution":"def maximize_sum(nums, k): Modify the list so that each element is incremented by `k` non-negative integer multiples. Return the maximum possible sum of the modified list + while keeping the elements in non-decreasing order. Args: nums: list of non-negative integers k: non-negative integer Returns: int: maximum possible sum of the modified list nums.sort() max_sum = 0 for i in range(len(nums)): nums[i] += k * i max_sum += nums[i] return max_sum"},{"question":"Given a binary tree, imagine you\'re standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. The binary tree is represented by TreeNode objects with the following property: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` For example, given the following tree: ``` 1 / 2 3 5 4 ``` You should return `[1, 3, 4]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes you can see ordered from top to bottom. if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given an **m x n** integer grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal group of connected `1`\'s, where a **group** is connected if any `1` in the group is connected to other `1`\'s horizontally or vertically. Each **island** has a **perimeter** which is the number of edges surrounding that island. Calculate the perimeter of the island starting from the top-left corner and return it. If there are multiple islands, return the perimeter of the island that contains point `[0, 0]`. If there is no island at `[0, 0]`, return `0`.","solution":"def islandPerimeter(grid): Calculate the perimeter of the island that contains the top-left cell (0, 0). If there is no island at (0, 0), return 0. if not grid or grid[0][0] == 0: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): if (r, c) in visited: return 0 if not (0 <= r < rows) or not (0 <= c < cols) or grid[r][c] == 0: return 1 visited.add((r, c)) perimeter = dfs(r - 1, c) perimeter += dfs(r + 1, c) perimeter += dfs(r, c - 1) perimeter += dfs(r, c + 1) return perimeter return dfs(0, 0)"},{"question":"You are given an integer `n` representing the number of cities and a 2D integer array `roads` where `roads[i] = [city1, city2, distance_i]` represents a bidirectional road between `city1` and `city2` with a travel distance of `distance_i`. Each city is labeled from `0` to `n-1`. You are tasked with finding the city with the smallest number of neighbors at a distance less than or equal to a given threshold `distance`. If there are multiple cities with the same smallest number of neighbors, return the city with the greatest number. Return _an integer representing the city with the desired properties_.","solution":"from collections import defaultdict, deque def find_the_city(n, roads, distance): def dijkstra(src): import heapq distances = {i: float(\'inf\') for i in range(n)} distances[src] = 0 min_heap = [(0, src)] while min_heap: curr_dist, u = heapq.heappop(min_heap) if curr_dist > distances[u]: continue for v, w in neighbors[u]: if curr_dist + w < distances[v]: distances[v] = curr_dist + w heapq.heappush(min_heap, (distances[v], v)) return distances neighbors = defaultdict(list) for u, v, w in roads: neighbors[u].append((v, w)) neighbors[v].append((u, w)) min_neighbor_count = float(\'inf\') best_city = -1 for city in range(n): distances = dijkstra(city) neighbor_count = sum(1 for d in distances.values() if d <= distance) if neighbor_count < min_neighbor_count or (neighbor_count == min_neighbor_count and city > best_city): min_neighbor_count = neighbor_count best_city = city return best_city"},{"question":"You are given a list of unique integers `arr` and an integer `k`. Write a function that returns the `k`th largest element in `arr`. The list `arr` is not sorted, and the elements might be positive, negative, or zero. You must solve this problem with a time complexity of O(n log k).","solution":"import heapq def kth_largest_element(arr, k): Returns the kth largest element in the array `arr`. Uses a min heap to maintain the k largest elements. if k > len(arr) or k <= 0: raise ValueError(\\"k should be between 1 and the length of the array inclusive\\") min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"You are given an integer array `A` of length `N` and an integer `K`. Write a function to determine if there exists a continuous subarray of length `K` that contains every integer from `1` to `K` (inclusive). If such a subarray exists, return `true`; otherwise, return `false`.","solution":"def contains_all_integers_subarray(A, K): Determine if there exists a continuous subarray of length K that contains every integer from 1 to K (inclusive). Arguments: A -- List of integers. K -- Length of the subarray and the range of integers to check (from 1 to K). Returns: boolean -- True if such a subarray exists, otherwise False. # Check for early exit if K > len(A) if K > len(A): return False # Required set of integers from 1 to K required_set = set(range(1, K + 1)) # Slide over the array with a window of size K for i in range(len(A) - K + 1): if set(A[i:i+K]) == required_set: return True return False"},{"question":"You are given a string `s` consisting of lowercase Latin letters and a matrix of integers `matrix` where `matrix[i][j]` represents the cost of replacing character `i` with character `j`. The cost of a string transformation is the sum of the costs of each character change needed to transform the string into a palindrome. Return the minimum cost to transform the given string `s` into a palindrome.","solution":"def min_cost_to_palindrome(s, matrix): n = len(s) cost = 0 for i in range(n // 2): left_char = s[i] right_char = s[n - i - 1] if left_char != right_char: left_idx = ord(left_char) - ord(\'a\') right_idx = ord(right_char) - ord(\'a\') cost += min(matrix[left_idx][right_idx], matrix[right_idx][left_idx]) return cost"},{"question":"Given a singly linked list, write a function to rearrange it in such a way that the nodes are in non-decreasing order based on their values. You should modify the linked list in-place without using any extra space for another data structure. Implement the function: * `void sortLinkedList(Node head)` where `Node` is a predefined class with `int val` (the value of the node) and `Node next` (the reference to the next node in the list).","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def sortLinkedList(head): Rearrange the linked list in non-decreasing order based on node values. if not head or not head.next: return head # Convert linked list to array current = head values = [] while current: values.append(current.val) current = current.next # Sort the array values.sort() # Convert array back to linked list current = head for value in values: current.val = value current = current.next return head"},{"question":"You are given two arrays `arr1` and `arr2` containing non-negative integers. A **common subarray** is a subarray that appears in both `arr1` and `arr2`. Find the length of the longest common subarray. Return _the **length** of the longest common subarray_.","solution":"def findLength(arr1, arr2): Finds the length of the longest common subarray between arr1 and arr2. m, n = len(arr1), len(arr2) dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"Given a string `s`, find _the shortest palindrome you can form by adding characters in front of `s`_. Return _the final palindrome string_. For example, if the input is \\"aacecaaa\\", the output should be \\"aaacecaaa\\". If the input is \\"abcd\\", the output should be \\"dcbabcd\\".","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be formed by adding characters in front of the string s. if not s: return s rev_s = s[::-1] l = s + \'#\' + rev_s p = [0] * len(l) for i in range(1, len(l)): j = p[i - 1] while j > 0 and l[i] != l[j]: j = p[j - 1] if l[i] == l[j]: j += 1 p[i] = j return rev_s[:len(s) - p[-1]] + s"},{"question":"You are given an array of positive integers `arr`, where each integer represents the height of a tree in a forest. You want to cut exactly one tree such that the resulting sequence of tree heights is strictly increasing from left to right. If it is possible to make such a cut, return the index of the tree to be cut. If there are multiple answers, return any one of them. If it is not possible to make the sequence strictly increasing with one cut, return -1. Ensure your solution has a linear time complexity.","solution":"def find_cut_index(arr): def is_valid(arr): for i in range(1, len(arr)): if arr[i] <= arr[i-1]: return False return True n = len(arr) if is_valid(arr): return -1 for i in range(n): if is_valid(arr[:i] + arr[i+1:]): return i return -1"},{"question":"Given an array of integers `arr` representing the heights of buildings in a line, and an integer `maxWidth`, you need to determine the maximum number of buildings that can be aligned in a visually appealing way. A visually appealing sequence of buildings means that after choosing these buildings, the sequence must be strictly increasing in height from left to right, and the difference in width between any two consecutive buildings in your chosen sequence cannot exceed `maxWidth`. Return _the maximum number of such buildings you can choose from the array_.","solution":"def max_buildings_count(arr, maxWidth): n = len(arr) if n == 0: return 0 dp = [1] * n # Initialize dp array with 1 # Iterate over the array for i in range(n): for j in range(i): if arr[i] > arr[j] and (i - j) <= maxWidth: dp[i] = max(dp[i], dp[j] + 1) # Return the maximum value in dp array return max(dp)"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge these two strings into a single string by choosing characters alternately from each string starting with `word1`. If one of the strings runs out of characters, append the remaining characters from the other string. Return the merged string.","solution":"def merge_alternately(word1, word2): Merges two strings by choosing characters alternately from each string starting with word1. If one string runs out of characters, append the remaining characters from the other string. Args: word1 (str): The first input string. word2 (str): The second input string. Returns: str: The merged string. merged_string = \\"\\" len1, len2 = len(word1), len(word2) i = 0 # Iterate over both strings and add characters alternately while i < len1 and i < len2: merged_string += word1[i] + word2[i] i += 1 # Append the remaining characters of the longer string, if any if i < len1: merged_string += word1[i:] elif i < len2: merged_string += word2[i:] return merged_string"},{"question":"Given a list of integers `nums`, sort the list in ascending order but prioritize even numbers over odd numbers. The even numbers should be sorted in ascending order at the beginning of the list, followed by the odd numbers sorted in ascending order. Return the modified list.","solution":"def prioritize_sort(nums): Sorts the list in ascending order with even numbers before odd numbers. even_numbers = sorted([num for num in nums if num % 2 == 0]) odd_numbers = sorted([num for num in nums if num % 2 != 0]) return even_numbers + odd_numbers"},{"question":"You are given a **0-indexed** integer array `nums`. An element `nums[i]` is considered **unstable** if there is at least one neighboring element that differs from it by more than `k`. Formally, `nums[i]` is unstable if for any `i` (0 <= i < nums.length), any neighbor `nums[j]` (where `j == i - 1` or `j == i + 1`), `|nums[i] - nums[j]| > k`. If there are no unstable elements, return an empty array. Otherwise, return the list of degraded positions (indexes) of all unstable elements sorted in ascending order.","solution":"def find_unstable_elements(nums, k): Returns the list of indexes of unstable elements in the array nums. An element nums[i] is considered unstable if there is at least one neighboring element that differs from it by more than k. n = len(nums) unstable_indexes = [] for i in range(n): if (i > 0 and abs(nums[i] - nums[i - 1]) > k) or (i < n - 1 and abs(nums[i] - nums[i + 1]) > k): unstable_indexes.append(i) return unstable_indexes"},{"question":"You are given a string `s` that consists of lower case English letters and a list of strings `forbidden` where each string in the list is also a lower case English letter word. Return the length of the longest substring of `s` that does not contain any string from `forbidden` as a substring. If there are multiple such substrings with the same maximum length, return any one of them.","solution":"def longest_valid_substring(s, forbidden): Returns the length of the longest substring of `s` that does not contain any string from `forbidden` as a substring. n = len(s) forbidden_set = set(forbidden) max_len = 0 for i in range(n): for j in range(i, n): current_substring = s[i:j+1] if any(forb in current_substring for forb in forbidden_set): break max_len = max(max_len, j - i + 1) return max_len"},{"question":"You are given an integer array `arr` representing the values of different houses along a street. You are a thief who wants to steal from these houses but cannot steal from two adjacent houses due to security alarms. Write a function to determine the maximum amount of money you can steal without triggering the alarms. Return the maximum amount that can be stolen.","solution":"def rob(arr): Determines the maximum amount of money that can be stolen without triggering the alarms. Parameters: arr (list of int): List of integers representing money in houses. Returns: int: Maximum amount of money that can be stolen. if not arr: return 0 if len(arr) == 1: return arr[0] prev2, prev1 = 0, arr[0] for i in range(1, len(arr)): current = max(prev1, prev2 + arr[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"You are given a string `s` and an array of strings `patterns`. Your task is to determine for each pattern in `patterns`, whether it is a subsequence of the string `s`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Return an array of boolean values where each element indicates whether the corresponding pattern is a subsequence of `s` or not. The order of the boolean values in the output array should match the order of the patterns in `patterns`.","solution":"def is_subsequence(s, pattern): Helper function to determine if a pattern is a subsequence of s. it = iter(s) return all(char in it for char in pattern) def check_patterns(s, patterns): Determines for each pattern in patterns whether it is a subsequence of the string s. Parameters: s (str): The source string. patterns (list of str): The list of patterns to check. Returns: list of bool: List of boolean values indicating whether each pattern is a subsequence of s. return [is_subsequence(s, pattern) for pattern in patterns]"},{"question":"You are given a list of integers `nums` and an integer `k`. Rotate the list to the right by `k` steps, where `k` is non-negative. For example, if `nums` is `[1,2,3,4,5,6,7]` and `k` is `3`, the list should be rotated to `[5,6,7,1,2,3,4]`. Return the updated list.","solution":"def rotate(nums, k): Rotates the list to the right by k steps. Args: nums: List of integers k: Number of steps to rotate the list Returns: List of integers rotated to the right by k steps n = len(nums) k = k % n # In case k is greater than the length of the list return nums[-k:] + nums[:-k]"},{"question":"You are given an integer array `arr` consisting of `n` distinct elements. You need to perform a series of operations to make all the elements in `arr` equal. In each operation, you can select any two elements from the array and replace the larger element with the value of the smaller one. Return _the minimum number of operations required_ to make all the elements in `arr` equal. **Constraints**: * The length of `arr` will be at most 10^5. * Each element in `arr` will be a positive integer and will not exceed 10^9.","solution":"def min_operations_to_equal_array(arr): Returns the minimum number of operations required to make all elements in the array equal. Each operation replaces the larger of two selected elements with the value of the smaller one. # The optimal strategy is to make all elements equal to the smallest element in the array, # since that reduces the number of necessary operations to the minimum. min_element = min(arr) operations = 0 for num in arr: if num != min_element: operations += 1 return operations"},{"question":"You are given an array of integers `arr` and an integer `k`. A **subarray** is called a **k-even subarray** if it contains exactly `k` even numbers. Your task is to find the number of all possible **k-even subarrays** within the given array. A subarray is a contiguous part of the array. Return the count of such subarrays.","solution":"def count_k_even_subarrays(arr, k): Returns the number of subarrays that contain exactly `k` even numbers. Parameters: arr (list): A list of integers. k (int): The number of even numbers a subarray must contain. Returns: int: The count of subarrays containing exactly `k` even numbers. n = len(arr) even_count = [0] * (n + 1) for i in range(n): even_count[i + 1] = even_count[i] + (1 if arr[i] % 2 == 0 else 0) count = 0 prefix_count = {} for i in range(n + 1): prefix = even_count[i] - k if prefix in prefix_count: count += prefix_count[prefix] if even_count[i] in prefix_count: prefix_count[even_count[i]] += 1 else: prefix_count[even_count[i]] = 1 return count"},{"question":"You are given a binary tree with `n` nodes, where each node is uniquely labeled from `1` to `n`. The tree is represented as an array `parent`, where `parent[i]` is the parent of the `(i + 1)`-th node (for each `i` in the range `0` to `n-1`). The root node has `parent[root-1] = -1`. Each node in the tree also has a value associated with it given by an integer array `value` of length `n`. Your task is to implement the `Tree` class which supports the following operations: * `Tree(int n, int[] parent, int[] value)`: Initializes the `Tree` class with `n`, the parent array `parent`, and the values array `value`. * `void updateValue(int node, int newValue)`: Updates the value of the specified `node` to `newValue`. * `int querySum(int node)`: Returns the sum of the values of the subtree rooted at the specified `node`. Implement the `Tree` class with efficient time complexity for the update and query operations.","solution":"class Tree: def __init__(self, n, parent, value): self.n = n self.parent = parent self.value = value self.children = [[] for _ in range(n)] for i in range(n): if parent[i] != -1: self.children[parent[i]].append(i) def updateValue(self, node, newValue): self.value[node] = newValue def querySum(self, node): def dfs(node): total = self.value[node] for child in self.children[node]: total += dfs(child) return total return dfs(node)"},{"question":"You are given a list of integers `prices` where `prices[i]` is the price of a given item on the `i`-th day. You want to determine the maximum profit you can achieve by performing at most two transactions. A transaction consists of buying and then selling one share of the item. Note that you cannot engage in multiple transactions at the same time (you must sell the previous item before you buy again). Write a function that takes the list `prices` and returns the maximum profit you can achieve from at most two transactions. If you cannot achieve any profit, return 0.","solution":"def maxProfit(prices): Function to calculate the maximum profit from at most two transactions. if not prices: return 0 n = len(prices) dp = [[0] * n for _ in range(3)] for k in range(1, 3): max_diff = -prices[0] for i in range(1, n): dp[k][i] = max(dp[k][i - 1], prices[i] + max_diff) max_diff = max(max_diff, dp[k - 1][i] - prices[i]) return dp[2][n - 1] if n > 1 else 0"},{"question":"Given a string `s`, return the number of contiguous substrings that have an equal number of `0` and `1`, and all the `0`s and all the `1`s in these substrings are grouped consecutively. Substrings that occur multiple times and in different positions in `s` should each be counted separately. For example: - `Input`: \\"00110011\\" - `Output`: 6","solution":"def countBinarySubstrings(s): Returns the number of contiguous substrings that have an equal number of `0` and `1`, and all the `0`s and all the `1`s in these substrings are grouped consecutively. # Lengths of consecutive groups of \'0\'s or \'1\'s groups = [] continuous_length = 1 # Create the groups array for i in range(1, len(s)): if s[i] == s[i - 1]: continuous_length += 1 else: groups.append(continuous_length) continuous_length = 1 groups.append(continuous_length) # Count the valid substrings count = 0 for i in range(1, len(groups)): count += min(groups[i], groups[i - 1]) return count"},{"question":"You are given a list of strings `words` and a string `target`. A concatenated string is formed by concatenating two different strings from the list `words` in any order. Return `true` if there exist two different strings in `words` that form the `target` string when concatenated. Otherwise, return `false`.","solution":"def can_form_target(words, target): Returns True if there exist two different strings in \'words\' that form the \'target\' string when concatenated. Otherwise, returns False. :param words: List of strings :param target: Target string to form :return: Boolean value indicating if target can be formed words_set = set(words) for word in words: complement = target[len(word):] if word != complement and complement in words_set: return True return False"},{"question":"Given an array of integers `heights` representing the height of individuals standing in a queue, return the minimum number of people that must be removed so that the remaining queue is a non-decreasing sequence by height. A **non-decreasing sequence** is defined as a sequence where each subsequent element is not smaller than the previous one.","solution":"def min_removals_to_non_decreasing(heights): Returns the minimum number of people that must be removed to make the remaining queue a non-decreasing sequence by height. # Calculate the Longest Increasing Subsequence (LIS) length n = len(heights) if n == 0: return 0 lis = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) max_lis_length = max(lis) # The minimum number of removals is the total length minus the LIS length return n - max_lis_length"},{"question":"You are given a binary tree where each node represents a city and has a numerical value that indicates the population of that city. Write a function that computes the **maximum population sum** of any **bst subtree** in the given binary tree. A **bst subtree** is defined as a subtree which satisfies the properties of a Binary Search Tree (BST), which means: * The left subtree of a node contains only nodes with values less than the node\'s value. * The right subtree of a node contains only nodes with values greater than the node\'s value. * Both the left and right subtrees must also be binary search trees. Return the maximum population sum among all subtrees in the given binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_bst_subtree_sum(root): def postorder_traversal(node): if not node: return (True, 0, float(\'inf\'), float(\'-inf\')) l_is_bst, l_sum, l_min, l_max = postorder_traversal(node.left) r_is_bst, r_sum, r_min, r_max = postorder_traversal(node.right) if l_is_bst and r_is_bst and l_max < node.val < r_min: current_sum = node.val + l_sum + r_sum max_sum[0] = max(max_sum[0], current_sum) return (True, current_sum, min(l_min, node.val), max(r_max, node.val)) else: return (False, 0, 0, 0) max_sum = [0] postorder_traversal(root) return max_sum[0]"},{"question":"You are given `n` pairs of integers representing the nodes and edges of an undirected graph, where `edges[i] = [u, v]` indicates there is an edge between nodes `u` and `v`. Determine if the graph contains a cycle. Return `true` if there is a cycle, or `false` otherwise. The graph does not contain multiple edges between any pair of nodes.","solution":"def has_cycle(n, edges): Determines if the graph contains a cycle. Parameters: n (int): The number of nodes in the graph. edges (List[List[int]]): The edges of the graph. Returns: bool: True if there is a cycle, False otherwise. parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return False return True for i in range(n): parent[i] = i for u, v in edges: if union(u, v): return True return False"},{"question":"Given an array of `n` integers `arr`, you are allowed to perform the following operation any number of times: Choose any two different indices `i` and `j` such that `arr[i]` is even and `arr[j]` is odd. Swap the values of `arr[i]` and `arr[j]`. Return the _lexicographically smallest_ permutation of the array that can be obtained. A permutation of an array is lexicographically smaller than another permutation if in the first position where they differ, the first permutation has a smaller number. For example, `[1, 3, 4]` is lexicographically smaller than `[1, 4, 3]` because at the second position, `3` is smaller than `4`.","solution":"def lexicographically_smallest_permutation(arr): Given an array of integers, return the lexicographically smallest permutation that can be obtained by swapping even and odd elements any number of times. # Separate even and odd numbers evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0]) # Initialize result array result = [] # Pointers for evens and odds lists even_idx = 0 odd_idx = 0 # Iterate over the input array for num in arr: # Append the sorted even or odd number while preserving the original parity positions if num % 2 == 0: result.append(evens[even_idx]) even_idx += 1 else: result.append(odds[odd_idx]) odd_idx += 1 return result"},{"question":"You are given a log file that contains the timestamps (in seconds) of `n` user actions. Each log entry is represented as a tuple with user ID and timestamp, `log = [(userID1, timestamp1), (userID2, timestamp2), ...]`. Your task is to identify the maximum number of users that were active simultaneously. Two users are considered active at the same time if their action timestamps are within `t` seconds of each other. Implement a function `max_simultaneous_users(log: List[Tuple[int, int]], t: int) -> int` that returns this maximum number.","solution":"from typing import List, Tuple def max_simultaneous_users(log: List[Tuple[int, int]], t: int) -> int: if not log: return 0 # Sort the log entries by timestamp log.sort(key=lambda x: x[1]) max_users = 0 window = [] for user_id, timestamp in log: # Remove users from the window that are outside the t-second window window = [time for time in window if time >= timestamp - t] # Add the current timestamp to the window window.append(timestamp) # Update the maximum number of users if current window is larger max_users = max(max_users, len(window)) return max_users"},{"question":"Write a program that simulates a simple text editor. The editor supports the following operations: - `void append(String word)`: appends the given word to the end of the current text. - `void delete(int k)`: deletes the last `k` characters from the current text. If `k` is greater than the length of the text, delete all characters. - `String getText()`: returns the current text. - `void undo()`: undoes the last operation performed (either append or delete). Implement the `SimpleTextEditor` class to handle these operations, ensuring that operations are performed efficiently.","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, word): self.history.append(self.text) self.text += word def delete(self, k): self.history.append(self.text) self.text = self.text[:-k] def getText(self): return self.text def undo(self): if self.history: self.text = self.history.pop() # Example usage: # editor = SimpleTextEditor() # editor.append(\\"hello\\") # editor.append(\\" world\\") # editor.delete(6) # editor.undo() # print(editor.getText()) # should print \\"hello world\\""},{"question":"You are given a list of non-negative integers `heights` representing the height of students. During a group photo, the students need to form a line such that each student\'s height is greater than or equal to the height of the previous student. However, there is a constraint that swaps are allowed only between adjacent students. Return the **minimum number of adjacent swaps** required to arrange the students in non-decreasing order of their heights. For example, if the list `heights` is [3, 2, 1], the minimum number of swaps needed is 3.","solution":"def min_swaps_to_sort(heights): Returns the minimum number of adjacent swaps required to arrange students in non-decreasing order of their heights. def merge_sort_and_count(arr, temp, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, temp, left, mid) count += merge_sort_and_count(arr, temp, mid + 1, right) count += merge_and_count(arr, temp, left, mid, right) return count def merge_and_count(arr, temp, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted swaps = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp[k] = arr[i] i += 1 else: temp[k] = arr[j] swaps += (mid-i + 1) j += 1 k += 1 while i <= mid: temp[k] = arr[i] i += 1 k += 1 while j <= right: temp[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp[i] return swaps n = len(heights) temp = [0] * n return merge_sort_and_count(heights, temp, 0, n - 1)"},{"question":"Given an array of `n` integers, return the length of the longest consecutive elements sequence in the array. The consecutive elements sequence must be an unbroken series of numbers, not necessarily sorted. For example, if the input array is `[100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`, and its length is 4.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in the array. :param nums: List[int], the array of integers :return: int, the length of the longest consecutive elements sequence if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: # Only start counting if `num` is the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an array of integers `nums` that represents a permutation of numbers from `1` to `n`, where `n` is the length of the array. However, one number from this permutation is missing, and another number is duplicated to take its place. Your task is to identify both the missing and the duplicated number. Return _an array containing the duplicated number and the missing number in that order._ **Example:** Given `nums = [3, 1, 2, 2]`, you should return `[2, 4]`. **Note:** * The input array will have at least two elements. * The result will always be unique.","solution":"def find_error_nums(nums): This function finds the duplicated and missing number in the given permutation of numbers. Args: nums (list of int): A list of integers representing a permutation with one duplicate and one missing. Returns: list of int: A list containing the duplicated number and the missing number. n = len(nums) actual_sum = sum(nums) expected_sum = n * (n + 1) // 2 expected_square_sum = sum([i ** 2 for i in range(1, n + 1)]) actual_square_sum = sum([x ** 2 for x in nums]) diff = expected_sum - actual_sum square_diff = expected_square_sum - actual_square_sum missing_plus_dup = square_diff // diff missing = (diff + missing_plus_dup) // 2 dup = missing_plus_dup - missing return [dup, missing]"},{"question":"Consider a grid of size `n x n` where each cell contains a non-negative integer. A robot starting at the top-left corner of the grid (0, 0) needs to reach the bottom-right corner (n-1, n-1). The robot can only move to the right or down one cell at a time. Your task is to determine the number of unique paths the robot can take to reach the destination such that the sum of the numbers in the cells along the path is even. Return the number of such paths.","solution":"def number_of_even_sum_paths(grid): n = len(grid) if n == 0: return 0 # dp[row][col][even] will store the number of ways to reach (row, col) with sum mod 2 == even dp = [[[0, 0] for _ in range(n)] for _ in range(n)] # initialize dp[0][0][grid[0][0] % 2] = 1 # fill the dp table for i in range(n): for j in range(n): if i > 0: dp[i][j][0] += dp[i-1][j][grid[i][j] % 2] dp[i][j][1] += dp[i-1][j][(grid[i][j] % 2) ^ 1] if j > 0: dp[i][j][0] += dp[i][j-1][grid[i][j] % 2] dp[i][j][1] += dp[i][j-1][(grid[i][j] % 2) ^ 1] return dp[n-1][n-1][0]"},{"question":"You are given a list of `words` and a set of characters `allowed`. Your task is to find the number of words that can be constructed using only the characters in `allowed`. Note that each character in `allowed` can be used multiple times in constructing a word. Return the count of valid words that can be constructed using only the characters from `allowed`.","solution":"def count_valid_words(words, allowed): Counts how many words can be constructed using only allowed characters. Parameters: - words (list of str): The list of words to check. - allowed (set of str): The set of allowed characters. Returns: - int: The number of valid words. valid_count = 0 for word in words: if all(char in allowed for char in word): valid_count += 1 return valid_count"},{"question":"You are given a circular array `nums` of positive and negative integers. Each integer represents the gain or loss of points. The circular array is defined such that the next element of `nums[nums.length - 1]` is `nums[0]`, and the previous element of `nums[0]` is `nums[nums.length - 1]`. Calculate the maximum sum of a contiguous subarray, which may wrap around to the beginning of the array. Implement the function `maxCircularSubarraySum(nums: List[int]) -> int` that takes in - `nums`: an array of integers representing the circular array. Overall, your function should perform in `O(n)` time where `n` is the number of elements in `nums`.","solution":"def maxCircularSubarraySum(nums): Returns the maximum sum of a contiguous subarray in a circular array. def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(nums) max_kadane = kadane(nums) max_wrap = sum(nums) # Invert sign of all elements to find the minimum subarray sum using kadane\'s algorithm for i in range(n): nums[i] = -nums[i] max_wrap = max_wrap + kadane(nums) # max_wrap would be zero if all numbers are negative, so return max_kadane in that case if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"Given an array of non-negative integers `heights` representing the heights of a series of buildings, where each building is separated by an identical gap, return the maximum area of water that can be trapped between two buildings after a rainstorm. Constraints: You must use a linear time complexity algorithm.","solution":"def max_area(heights): Returns the maximum area of water that can be trapped between two buildings. :param heights: List[int] :return: int left, right = 0, len(heights) - 1 max_water = 0 while left < right: # Calculate the width and the constrained height width = right - left height = min(heights[left], heights[right]) # Calculate the current area current_area = width * height max_water = max(max_water, current_area) # Move the pointer of the shorter building inward if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform a series of operations on this string, where in each operation, you can select a character and remove all its consecutive duplicates (including the selected character itself) in one go. Your task is to determine the minimum number of operations required to completely remove all characters from the string `s`. Return the minimum number of operations needed to make the string empty.","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations required to make the string empty. operations = 0 i = 0 while i < len(s): operations += 1 char = s[i] while i < len(s) and s[i] == char: i += 1 return operations"},{"question":"Given an integer `n`, return a string array `ans` (1-indexed) with `n` strings such that: - `ans[i]` (1  `i`  `n`) is consistent with: - The length of the string is `i`. - The characters of the string are in lexicographically increasing order starting from \'a\'. - The characters are contiguous, i.e., letters having consecutive alphabetic order. Example: Input: `n = 3` Output: `[\\"a\\", \\"ab\\", \\"abc\\"]` Clarifications: - When `n = 1`, the result should be `[\\"a\\"]`. - For `n = 2`, the result should include the first two strings `[\\"a\\", \\"ab\\"]`. Write code that generates the described string array for any provided `n`.","solution":"def generate_string_array(n): Generate a string array of length `n` with given constraints. Each string has a length of i (1  i  n) and contains alphabetically increasing characters starting from \'a\'. Parameters: n (int): The length of the string array to generate. Returns: list[str]: A list of strings meeting the criteria. ans = [] for i in range(1, n + 1): # Generate string of length i ans.append(\\"\\".join(chr(97 + j) for j in range(i))) return ans"},{"question":"Design an algorithm to clone a graph. The given graph is represented as an adjacency list; each node in the graph contains a unique integer value and a list of its neighbors. The cloned graph must maintain the same structure as the original graph, ensuring each node and its connections are accurately replicated. Implement the cloning process in such a manner that it effectively handles any graph structure, including disconnected graphs.","solution":"class Node: def __init__(self, val=0, neighbors=None): self.val = val self.neighbors = neighbors if neighbors is not None else [] def clone_graph(node): Clones a graph given an adjacency list representation. if not node: return node # Dictionary to save the cloned node of each original node. clone_dict = {} def dfs(original_node): if original_node in clone_dict: return clone_dict[original_node] # Clone the node. clone_node = Node(original_node.val) clone_dict[original_node] = clone_node for neighbor in original_node.neighbors: clone_node.neighbors.append(dfs(neighbor)) return clone_node return dfs(node)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of blocks. You need to find the **longest sequence** of consecutive blocks such that the height of each block in the sequence is greater than or equal to the height of its predecessor and does not exceed the height of the next block. Return _the length of the longest such sequence in `heights`_.","solution":"def longest_non_decreasing_sequence(heights): Returns the length of the longest non-decreasing sequence of heights. :param heights: List[int] - A list of integers representing the heights of blocks. :return: int - The length of the longest non-decreasing sequence. if not heights: return 0 longest_seq = 1 current_seq = 1 for i in range(1, len(heights)): if heights[i] >= heights[i - 1]: current_seq += 1 longest_seq = max(longest_seq, current_seq) else: current_seq = 1 return longest_seq"},{"question":"You are given a **0-indexed** integer array `flips` representing a series of coin flips, where `1` indicates a flip to heads and `0` indicates a flip to tails. Counting from the start of the array, you flip all coins including and before index `i` whenever you encounter a `1` at index `i`. Your goal is to determine the amount of time these operations occur until all the coins are heads. Return _the **minimum** number of flips needed to make all the coins show heads_.","solution":"def min_flips(flips): Returns the minimum number of flips needed to make all coins heads. :param flips: List[int] - A list of integers where 1 indicates a flip to heads and 0 to tails. :return: int - The minimum number of flips to make all coins heads. flip_count = 0 current_state = 0 # 0 means tails, 1 means heads for flip in flips: if flip != current_state: flip_count += 1 current_state = 1 - current_state # Toggle current state return flip_count"},{"question":"You are given a list `s` of `n` strings, where each string `s[i]` consists of lowercase English letters. Your task is to find all the pairs of strings `(s[i], s[j])` such that `i < j` and the concatenation of the two strings, i.e., \'s[i] + s[j]\', is a palindrome. A palindrome is a string that reads the same forward and backward. Return a list of all such pairs `(i, j)` where `0 <= i < j < n`. The list can be in any order.","solution":"def is_palindrome(s): Check if the input string s is a palindrome. return s == s[::-1] def palindrome_pairs(s): Return list of pairs (i, j) where i < j and s[i] + s[j] is a palindrome. :param s: List of strings :return: List of tuples (i, j) n = len(s) pairs = [] for i in range(n): for j in range(i + 1, n): if is_palindrome(s[i] + s[j]): pairs.append((i, j)) return pairs"},{"question":"Given a string `str`, find the length of the longest substring where every character appears at most `k` times. A substring is a contiguous sequence of characters within a string. Return the length of this longest substring.","solution":"def longest_substring_k_distinct(s, k): Returns the length of the longest substring where every character appears at most `k` times. from collections import defaultdict if k == 0 or not s: return 0 char_frequency = defaultdict(int) max_length = 0 window_start = 0 for window_end in range(len(s)): right_char = s[window_end] char_frequency[right_char] += 1 # Shrink the window until we are left with `k` distinct characters in the char_frequency dictionary while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"You are given a string containing only characters `(` and `)`. A valid string is a string that is constructed by the following rules: 1. An empty string `\\"\\"` is valid. 2. If `s` is a valid string, then `\\"(\\" + s + \\")\\"` is also a valid string. 3. If `a` and `b` are valid strings, then `a + b` is also a valid string. Given a string `s`, remove the minimum number of parentheses (either \'(\' or \')\') so that the resulting string is valid and return _any_ valid string.","solution":"def min_remove_to_make_valid(s): Remove the minimum number of parentheses to make the string valid. stack = [] to_remove = set() # First pass: Identify positions of invalid parentheses for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if not stack: to_remove.add(i) else: stack.pop() # Add remaining unmatched \'(\' to the set to be removed to_remove = to_remove.union(set(stack)) # Build the result string excluding characters marked for removal result = \'\'.join([char for i, char in enumerate(s) if i not in to_remove]) return result"},{"question":"Given an integer array `scores`, where each element represents the score of a particular student, you need to form two separate arrays from this input array. Each element of the first array should be less than or equal to the corresponding element in the second array at any position. Your task is to maximize the sum of all the elements in the first array while ensuring it adheres to the following constraints: - Each element in the first array should be a subsequence of the input array `scores`. - Each element in the second array should be formed by removing elements from the input array `scores` without changing the order of remaining elements. Return the maximum possible sum of the elements in the first array. The output should be an integer representing this maximum sum.","solution":"def max_sum_subsequence(scores): Returns the maximum possible sum of all elements in the first array such that each element in the first array is less than or equal to the corresponding element in the second array. :param scores: List[int] :return: int n = len(scores) # dp[i] will store the max sum of increasing subsequence ending at index i dp = scores.copy() for i in range(1, n): for j in range(i): if scores[j] <= scores[i]: dp[i] = max(dp[i], dp[j] + scores[i]) return max(dp)"},{"question":"You are given a binary tree where each node contains an integer value. Determine the sum of all values in the tree that are greater than a given integer `x`. The tree is represented in a list format where the elements are given in level-order, with `None` indicating missing nodes. Return _the total sum of node values that are greater than_ `x`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def create_tree(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while i < len(level_order): current = queue.pop(0) if i < len(level_order) and level_order[i] is not None: current.left = TreeNode(level_order[i]) queue.append(current.left) i += 1 if i < len(level_order) and level_order[i] is not None: current.right = TreeNode(level_order[i]) queue.append(current.right) i += 1 return root def sum_greater_than_x(root, x): if not root: return 0 def dfs(node): if not node: return 0 left_sum = dfs(node.left) right_sum = dfs(node.right) return (node.val if node.val > x else 0) + left_sum + right_sum return dfs(root)"},{"question":"You are given two strings `s1` and `s2` of the same length consisting of lowercase letters. You are allowed to rearrange the characters of `s1` in any order to make it a **subsequence** of `s2`. A subsequence is defined as a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. Determine if it is possible to rearrange `s1` such that it becomes a subsequence of `s2`. Return `true` if it is possible, otherwise return `false`.","solution":"def can_rearrange_to_subsequence(s1, s2): Check if it\'s possible to rearrange s1 to become a subsequence of s2. :param s1: First string :param s2: Second string (must be of the same length as s1) :return: True if possible, False otherwise from collections import Counter # Create counter for both strings counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Check if s1 can be rearranged to be part of s2 by comparing character counts for char, count in counter_s1.items(): if count > counter_s2[char]: return False return True"},{"question":"You are given two strings `s` and `t`, where `t` is a subsequence of `s`. Write a function to determine the minimum window in `s` which will contain all the characters in `t` in their order of appearance. The window should be the smallest in length among all the possible windows in `s` that contain `t`. Return the minimum window in `s` that contains `t` in order. If there is no such window, return the empty string `\\"\\"`. For example, given `s = \\"abcdebdde\\"` and `t = \\"bde\\"`, the minimum window in `s` that contains the characters of `t` in order is `\\"bcde\\"`.","solution":"def min_window(s, t): def find_sub_sequence(s, t): i, j = 0, 0 while i < len(s) and j < len(t): if s[i] == t[j]: j += 1 i += 1 return j == len(t) if not t: return \\"\\" min_len = float(\\"inf\\") result = \\"\\" for i in range(len(s)): if s[i] == t[0]: for j in range(i, len(s)): if find_sub_sequence(s[i:j+1], t): if j - i + 1 < min_len: min_len = j - i + 1 result = s[i:j+1] break return result"},{"question":"Given an array of integers `nums` and a target value `target`, return _the length of the shortest, non-empty subarray_ of `nums` whose sum is greater than or equal to `target`. If no such subarray exists, return `-1`. Example: ```plaintext Input: nums = [2, 3, 1, 2, 4, 3], target = 7 Output: 2 Explanation: The subarray [4, 3] has the minimal length under the problem constraints. ``` Note: You may assume that the input values will always be non-negative integers.","solution":"def min_subarray_len(nums, target): n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a maze represented by an `n x n` 2D grid of characters, where each character can be either \'P\', \'W\', or \'O\'. \'P\' indicates the starting position of a person, \'W\' indicates a wall that cannot be passed through, and \'O\' indicates an open space that can be traversed. The person can move up, down, left, or right to an adjacent cell. They cannot move diagonally or pass through walls. Your goal is to find the shortest path for the person to reach the bottom-right corner of the maze, `grid[n-1][n-1]`. * Implement the `MazeSolver` class: * `MazeSolver(char[][] grid)` - Initializes the object with the maze grid. * `int findShortestPath()` - Returns the length of the shortest path from the starting position \'P\' to the bottom-right corner, \'grid[n-1][n-1]\'. If no such path exists, return `-1`.","solution":"from collections import deque class MazeSolver: def __init__(self, grid): self.grid = grid self.n = len(grid) def findShortestPath(self): if not self.grid or self.grid[0][0] != \'P\': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (self.n-1, self.n-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < self.n and 0 <= nc < self.n and self.grid[nr][nc] != \'W\' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given a string `s` consisting only of lowercase alphabets. You have to perform `n` operations on this string. In each operation, you can choose any character from the string and shift it to the start of the string. You need to determine the lexicographically smallest string that can be obtained after performing exactly `n` such operations. Given a non-empty string `s` and an integer `n`, return _the lexicographically smallest string that can be obtained after performing exactly `n` operations_.","solution":"def lexicographically_smallest_string(s, n): Returns the lexicographically smallest string that can be obtained after performing exactly n operations, where each operation consists of shifting any character to the start of the string. Parameters: s (str): the input string consisting of lowercase alphabets. n (int): the number of operations to perform. Returns: str: The lexicographically smallest string possible after n operations. if n == 0: return s char_list = list(s) char_list.sort() return \\"\\".join(char_list)"},{"question":"You are given a binary tree where each node contains an integer value. Implement the `BinaryTree` class with the following methods: * `BinaryTree(TreeNode root)` - Initializes the object with the given root of the binary tree. * `int getMaxDepth()` - Returns the maximum depth of the binary tree. The depth of a binary tree is the length of the longest path from the root to any leaf. * `boolean isBalanced()` - Returns `true` if the binary tree is balanced, and `false` otherwise. A balanced binary tree is one in which the heights of the two subtrees of any node never differ by more than one. A `TreeNode` class is provided with the following definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root): self.root = root def getMaxDepth(self): def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root) def isBalanced(self): def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) balanced = ( left_balanced and right_balanced and abs(left_depth - right_depth) <= 1 ) return (max(left_depth, right_depth) + 1, balanced) return check_balance(self.root)[1]"},{"question":"You are given an `m x n` matrix where elements are non-negative integers. You are also given an integer `target`. Determine if there is a path from the top-left to bottom-right of the matrix such that the sum of the values along the path is exactly `target`. You can only move either down or right at any point in time. Return _`true` if such a path exists, otherwise return `false`_.","solution":"def has_path_with_target_sum(matrix, target): Determines if there is a path from the top-left to bottom-right of the matrix such that the sum of the values along the path is exactly target. The path can only move either down or right at any point in time. :param matrix: List[List[int]], the m x n matrix with non-negative integers. :param target: int, the target sum to find. :return: bool, True if such a path exists, otherwise False. if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) memo = {} def dfs(x, y, current_sum): if (x, y, current_sum) in memo: return memo[(x, y, current_sum)] if x >= m or y >= n: return False current_sum += matrix[x][y] if current_sum > target: return False if x == m - 1 and y == n - 1: return current_sum == target down = dfs(x + 1, y, current_sum) right = dfs(x, y + 1, current_sum) memo[(x, y, current_sum)] = down or right return memo[(x, y, current_sum)] return dfs(0, 0, 0)"},{"question":"You are given a 2D matrix of characters `grid` representing a word search puzzle and a string `word` to search for in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Implement a function `bool exist(char[][] grid, String word)` that returns `true` if the word exists in the grid and `false` otherwise. Note: - The input grid consists of lowercase and uppercase English letters. - The word consists of lowercase or uppercase English letters.","solution":"def exist(grid, word): def dfs(i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[word_index] or (i, j) in visited: return False visited.add((i, j)) result = (dfs(i+1, j, word_index+1) or dfs(i-1, j, word_index+1) or dfs(i, j+1, word_index+1) or dfs(i, j-1, word_index+1)) visited.remove((i, j)) return result for i in range(len(grid)): for j in range(len(grid[0])): visited = set() if dfs(i, j, 0): return True return False"},{"question":"Given a binary tree, each node has an integer value. Return _the maximum sum of the values along any path starting from the root and ending at a leaf_. A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_root_to_leaf_sum(root): Returns the maximum sum of the values along any path from root to a leaf. This function assumes the binary tree is non-empty. if root is None: return float(\'-inf\') # No leaf should return negative infinity for comparison if root.left is None and root.right is None: return root.value # It\'s a leaf node # Recursively find the maximum sum in the left and right subtrees left_max_sum = max_root_to_leaf_sum(root.left) right_max_sum = max_root_to_leaf_sum(root.right) return root.value + max(left_max_sum, right_max_sum)"},{"question":"You are given a set of instructions represented as a string `s`. Each character in the string corresponds to a movement direction: `\'L\'` for left, `\'R\'` for right, `\'U\'` for up, and `\'D\'` for down. Assume the initial position is at the origin `(0, 0)` on a 2D plane. Write a function that returns the final coordinates after executing all the movements in the string `s`. For example, given `s = \\"LLRRUUDD\\"`, the output should be `(0, 0)` since all movements cancel each other out.","solution":"def final_position(s): Returns the final coordinates after executing the movements in the string s. x, y = 0, 0 for move in s: if move == \'L\': x -= 1 elif move == \'R\': x += 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return (x, y)"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be split into several substrings. Your task is to determine if `s` can be split into exactly `k` substrings, where each substring is a palindrome. Return `true` if it is possible to split the string in such a way; otherwise, return `false`. A palindrome is a string that reads the same forward and backward.","solution":"def can_split_into_k_palindromes(s, k): def is_palindrome(sub): return sub == sub[::-1] n = len(s) # If k is greater than the length of s, we cannot split it into k non-empty substrings if k > n: return False dp = [[False] * n for _ in range(n)] # Fill dp array: dp[i][j] will be True if s[i:j+1] is a palindrome for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 1: dp[i][j] = True elif length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] def can_partition(start, k): if k == 0: return start == n if k < 0: return False for end in range(start, n): if dp[start][end]: if can_partition(end + 1, k - 1): return True return False return can_partition(0, k)"},{"question":"There is a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n - 1`, and you are given an integer array `values` where `values[i]` represents the value of the `i`-th node. You are also given a 2D integer array `edges` of length `m` where `edges[i] = [ui, vi]` indicates a directed edge from node `ui` to node `vi`. Define the score of a path as the sum of the values of the nodes in the path. Return _the **maximum score** of any path from node_ `0` _to node_ `n - 1` _in the DAG. If there is no path from `0` to `n - 1`, return `-1`._","solution":"from collections import defaultdict, deque def max_path_score(n, values, edges): Find the maximum score of any path from node 0 to node n-1. Args: n (int): Number of nodes. values (list): List of values for each node. edges (list): List of edges in the graph. Returns: int: Maximum score of any path from node 0 to node n-1, or -1 if no path exists. # Create a graph representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Initialize DP array to keep track of maximum scores dp = [-1] * n dp[0] = values[0] # Topological sorting using Kahn\'s algorithm indegree = [0] * n for u, v in edges: indegree[v] += 1 queue = deque([i for i in range(n) if indegree[i] == 0]) top_order = [] while queue: node = queue.popleft() top_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Update dp for each node in topological order for node in top_order: if dp[node] == -1: continue for neighbor in graph[node]: if dp[neighbor] < dp[node] + values[neighbor]: dp[neighbor] = dp[node] + values[neighbor] return dp[n - 1]"},{"question":"You are given an integer array `arr` of size `n`, where each element in the array represents the height of a building. A building\'s view is considered unobstructed if there are no taller buildings to its left. Return _the **number** of buildings with an unobstructed view_ from the leftmost side of the array.","solution":"def unobstructed_views(arr): Returns the number of buildings with an unobstructed view from the leftmost side of the array. Parameters: arr (List[int]): A list of integers representing the heights of buildings. Returns: int: The number of buildings with an unobstructed view. n = len(arr) if n == 0: return 0 count = 1 # The first building always has an unobstructed view. max_height = arr[0] for i in range(1, n): if arr[i] > max_height: count += 1 max_height = arr[i] return count"},{"question":"You are given an array of integers `numbers` where each element represents a different drug\'s effectiveness rate in a clinical trial. Determine the maximum possible difference between any two elements in the array, such that the higher element appears after the lower element in the array. Return this maximum difference. If no such pair exists, return `0`.","solution":"def max_effectiveness_difference(numbers): Returns the maximum possible difference between any two elements in the array such that the higher element appears after the lower element. if not numbers or len(numbers) < 2: return 0 min_value = numbers[0] max_diff = 0 for number in numbers[1:]: if number > min_value: max_diff = max(max_diff, number - min_value) min_value = min(min_value, number) return max_diff"},{"question":"You are given a **0-indexed** array `nums` of **distinct** integers and an integer `target`. A **sum pair** is a pair of integers `(i, j)` such that: - `0 <= i, j < nums.length` - `i != j` - `nums[i] + nums[j] == target` Return _an array of all the **sum pairs** of `nums`_. Each pair should be represented as `(i, j)` where `i < j`.","solution":"def find_sum_pairs(nums, target): Returns all pairs of indices whose elements sum up to the target. :param nums: List[int], list of distinct integers :param target: int, target sum :return: List[Tuple[int, int]], list of pairs of indices pairs = [] num_indices = {num: idx for idx, num in enumerate(nums)} for i, num in enumerate(nums): complement = target - num if complement in num_indices and num_indices[complement] != i: j = num_indices[complement] if i < j: pairs.append((i, j)) return pairs"},{"question":"Given a `m x n` grid consisting of cells with integer values, find the **maximum sum path** from the top-left cell to the bottom-right cell, where each cell value can be either positive or negative. The path can only move right or down at any point in time. Return the value of the maximum sum path. If the grid is empty, return `0`. Your code will be given `grid`, a 2D list of integers representing the values of the cells.","solution":"def max_sum_path(grid): Returns the maximum sum path from the top-left corner to the bottom-right corner. The path can only move right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given an array of integers `arr` and an integer `target`. Determine if there exist two integers in the array whose sum is equal to `target`. Return `true` if such a pair exists, and `false` otherwise. The array may contain both positive and negative integers, and each integer in the array can be part of the pair only once. For example, given `arr = [4, -1, 9, 7, 5, 2]` and `target = 6`, return `true` because `(-1 + 7 = 6)`. If `arr = [3, 1, 4, 2, 5]` and `target = 10`, return `false` as there are no two integers in the array that sum to `10`.","solution":"def two_sum(arr, target): Determines if there are two integers in the array whose sum is equal to the target. Args: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if there are two integers in the array whose sum is equal to the target, False otherwise. seen = set() for number in arr: if target - number in seen: return True seen.add(number) return False"},{"question":"Given a binary tree, you need to return the values of its nodes as they appear in level-order traversal (also known as breadth-first traversal). Collect the nodes\' values for each level into separate subarrays and return them as a nested list, where each subarray corresponds to one level of the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): Returns the values of the nodes in level-order traversal as a nested list. :param root: TreeNode, the root of the binary tree :return: List of lists, each containing values of the nodes at each level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Given a string `s` which represents a scrambled sentence, return the sentence corrected by rearranging the words. Each word is appended with a single-digit number which indicates its position in the sentence (1-indexed). Remove the numbers and return the sentence in its correct order.","solution":"def unscramble_sentence(s): Given a scrambled sentence where each word has a number indicating its correct position, return the sentence with words in the right order and numbers removed. Example: s = \\"sentence4 is2 a3 This1\\" return: \\"This is a sentence\\" words = s.split() sorted_words = sorted(words, key=lambda word: word[-1]) result = \' \'.join(word[:-1] for word in sorted_words) return result"},{"question":"**Question 4**: You are given an array of unique strings `words` where each string is composed of lowercase English letters. A string `words[i]` is a predecessor of `words[j]` if and only if we can add exactly one letter anywhere in `words[i]` to make it equal to `words[j]`. For example, \\"abc\\" is a predecessor of \\"abac\\", while \\"abc\\" is not a predecessor of \\"abcd\\". A **word chain** is a sequence of words `[word_1, word_2, ..., word_k]` with `k >= 1`, where `word_1` is a predecessor of `word_2`, `word_2` is a predecessor of `word_3`, and so on. Return the length of the longest possible word chain with words chosen from the given list of `words`. Implement the function `int longestStrChain(vector<string>& words)` that returns the length of the longest word chain. **Example:** ```python Input: words = [\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"] Output: 4 Explanation: One of the longest word chains is [\\"a\\",\\"ba\\",\\"bda\\",\\"bdca\\"]. ```","solution":"def longestStrChain(words): Returns the length of the longest possible word chain with words chosen from the given list of words. # Sort words by their lengths words.sort(key=len) # Dictionary to keep the longest chain ending with the word longest_chain = {} max_length = 1 for word in words: longest_chain[word] = 1 # Every word at least has a chain length of 1 (itself) # Try to generate predecessors by removing one character at a time for i in range(len(word)): predecessor = word[:i] + word[i + 1:] if predecessor in longest_chain: longest_chain[word] = max(longest_chain[word], longest_chain[predecessor] + 1) # Update max_length for the longest chain found so far max_length = max(max_length, longest_chain[word]) return max_length"},{"question":"You are given a **0-indexed** array `coins` where `coins[i]` represents the number of coins in the `i-th` pile. You can perform the following operation any number of times: - Choose any pile and take one coin from it, or do nothing. The goal is to minimize the number of piles that have an odd number of coins left. Return _the **minimum** number of piles with an **odd** number of coins after any number of operations_.","solution":"def min_piles_with_odd_coins(coins): Return the minimum number of piles with an odd number of coins after any number of operations. odd_piles = sum(coin % 2 != 0 for coin in coins) # We can make any coin even by subtracting one coin from a pile if it is odd. # Thus, minimum number of piles with odd number of coins would be: return odd_piles"},{"question":"Given a list of `n` integers representing the heights of vertical lines on a histogram, where the width of each bar is 1, return _the area of the largest rectangle that can be formed within the histogram._ The rectangle must be formed using consecutive bars in the histogram.","solution":"def largest_rectangle_area(heights): Given a list of integers representing the heights of vertical lines on a histogram, return the area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` and an array of queries `queries`. Each query `queries[i] = [lefti, righti]` asks you to determine if the substring `s[lefti...righti]` is a palindrome. A string is a palindrome if it reads the same forwards and backwards. Implement a class `PalindromeSubstrings` to execute these queries efficiently. * `PalindromeSubstrings(String s)` initializes the class with the string `s`. * `boolean isPalindrome(int left, int right)` checks if the substring `s[left...right]` is a palindrome and returns `true` if it is, `false` otherwise. Example: ``` PalindromeSubstrings palindromeChecker = new PalindromeSubstrings(\\"racecar\\"); palindromeChecker.isPalindrome(0, 6); // returns true palindromeChecker.isPalindrome(1, 4); // returns false palindromeChecker.isPalindrome(2, 5); // returns true ```","solution":"class PalindromeSubstrings: def __init__(self, s): self.s = s def isPalindrome(self, left, right): Checks if the substring s[left...right] is a palindrome. substring = self.s[left:right+1] return substring == substring[::-1]"},{"question":"You are given a **0-indexed** integer array `nums` representing the strengths of soldiers in an army. You are also given an integer `k` representing the number of divisions you\'d like to split this army into. Each division must have at least one soldier. You aim to minimize the strength of the division with the highest total strength while keeping all divisions as balanced as possible. Return _the minimum possible value of the maximum strength of any division after splitting the array `nums` into `k` divisions_. **Note**: - A division\'s strength is the sum of the strengths of the soldiers within that division. - The division should be contiguous, meaning you can only split `nums` at specific indices to form each division.","solution":"def min_max_division_strength(nums, k): Given an array of integers `nums` and an integer `k`, this function computes the minimum possible value of the maximum sum of any subarray after splitting `nums` into `k` contiguous subarrays. :param nums: List[int], array of integers :param k: int, number of divisions :return: int, minimized maximum strength of any division def can_divide(max_sum): current_sum = 0 required_divisions = 1 for num in nums: if current_sum + num > max_sum: required_divisions += 1 current_sum = num if required_divisions > k: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_divide(mid): high = mid else: low = mid + 1 return low"},{"question":"Given a matrix of integers `grid` representing a city\'s layout where `1` represents land and `0` represents water, return the size of the largest island. An island is formed by connecting adjacent lands horizontally or vertically (not diagonally). Write a function that finds and returns the size of the largest island in the grid. If there are no islands, return `0`.","solution":"def largest_island(grid): Returns the size of the largest island in the grid. :param grid: List[List[int]] - 2D list representing the city\'s layout. :return: int - the size of the largest island. def dfs(i, j): if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1: grid[i][j] = 0 # Mark as visited size = 1 size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size return 0 max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"You are given an integer array `nums` and an integer `target`. You can perform only one type of operation on the array: pick any two adjacent elements and replace them with their sum. For example, given the array `[1, 3, 5]`, if you pick `1` and `3`, the array becomes `[4, 5]`. Your task is to determine whether it is possible to reduce the array to a single element that is equal to the `target`. If it is possible, return `true`. Otherwise, return `false`.","solution":"def can_sum_to_target(nums, target): Determines if it is possible to reduce the array to a single element equal to the target by summing adjacent elements. Args: nums: List[int] : List of integers. target: int : The target sum to achieve. Returns: bool : True if the target sum can be achieved, otherwise False. return sum(nums) == target"},{"question":"Given a list of `n` integers, write a function to find the length of the longest subsequence such that all elements of the subsequence are consecutive integers. A consecutive sequence is defined as a sequence where the difference between the maximum and minimum element is equal to the number of elements in the sequence minus one. Implement the function `longestConsecutiveSubsequence(int[] nums)` that returns the length of the longest subsequence of consecutive integers in the list. The input array can contain duplicates and negative numbers.","solution":"def longestConsecutiveSubsequence(nums): Returns the length of the longest subsequence of consecutive integers in the list nums. if not nums: return 0 num_set = set(nums) longest_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"You are given a **binary tree** with `n` nodes. Each node in the tree has a unique value from `1` to `n`. The tree is represented as a set of `n-1` edges where each edge is a pair of nodes `[u, v]` denoting a connection between nodes `u` and `v`. Given the binary tree, your task is to find the **diameter** of the tree. The diameter of a binary tree is defined as the **longest path** between any two nodes in the tree. The path can go through the root or any other node in the tree. Write a function: ```python def tree_diameter(edges: List[List[int]], n: int) -> int: pass ``` **Input:** - `edges`: A list of `n-1` lists of two integers, each representing an edge in the binary tree. - `n`: An integer representing the number of nodes in the tree. **Output:** - An integer representing the diameter of the binary tree.","solution":"from collections import defaultdict, deque from typing import List def tree_diameter(edges: List[List[int]], n: int) -> int: def bfs(start_node): # Helper function for BFS that returns the farthest node and its distance from start_node queue = deque([start_node]) visited = [-1] * (n + 1) visited[start_node] = 0 farthest_node = start_node max_distance = 0 while queue: node = queue.popleft() current_distance = visited[node] for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Build the graph from the edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Start BFS from an arbitrary node (node 1) farthest_node_1, _ = bfs(1) # Use the farthest node from first BFS to start a second BFS _, diameter = bfs(farthest_node_1) return diameter"},{"question":"Given an integer array `nums`, your task is to determine if there exists a way to split the array into three parts such that the sum of the elements in each part is equal. Specifically, you need to find indices `i` and `j` (where `0 <= i < j <= nums.length - 1`) such that the sum of the elements from the start to `i`, the sum of the elements from `i+1` to `j-1`, and the sum of the elements from `j` to the end of the array are all the same. Return `true` if such a split is possible, otherwise, return `false`.","solution":"def can_split_array_into_three_parts(nums): total_sum = sum(nums) # If the total_sum is not divisible by 3, it is impossible to split the array into three parts with equal sum if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 parts_found = 0 for num in nums: current_sum += num if current_sum == target_sum: parts_found += 1 current_sum = 0 if parts_found == 2 and current_sum == 0: return True return False"},{"question":"Given an **n-ary tree**, return the level order traversal of its nodes\' values. An **n-ary tree** is a tree in which a node can have at most `n` children. The level order traversal is a breadth-first traversal of the tree, where for each level, we visit all nodes at that level from left to right. The moment you see a node, you should append its value to the list of that particular level. The tree is represented as a dictionary with keys being the node values and values being a list of the node\'s children. Each node is identified uniquely by its value. Return the nodes\' values in level order as a list of lists, where each inner list represents the node values at that level. For custom testing purposes, the input will be the root node of the n-ary tree, presented as a dictionary.","solution":"from collections import deque def level_order(n_ary_tree, root): Returns the level order traversal of an n-ary tree. n_ary_tree: dict, The representation of the n-ary tree where keys are node values and values are lists of children. root: The root node of the n-ary tree. return: List[List[Node values at each level]] if not n_ary_tree or root not in n_ary_tree: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node) for child in n_ary_tree.get(node, []): queue.append(child) result.append(level) return result"},{"question":"You are given a 2D integer array `grid` of size `m x n` representing a matrix. Your task is to return the sum of the values in all cells that are part of any diagonal in the matrix. Note that diagonals can go from top-left to bottom-right or top-right to bottom-left. For example, if `grid` is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The diagonals are: [1, 5, 9], [3, 5, 7], [4], [2, 4], [2, 6], [8]. Return the sum of all these diagonal values.","solution":"def sum_of_diagonals(grid): m, n = len(grid), len(grid[0]) diag_sums = 0 seen = set() # Sum top-left to bottom-right diagonals for d in range(-(m - 1), n): for i in range(max(0, -d), min(m, n - d)): if (i, i + d) not in seen: diag_sums += grid[i][i + d] seen.add((i, i + d)) # Sum top-right to bottom-left diagonals for d in range(m + n - 1): for i in range(max(0, d - n + 1), min(m, d + 1)): if (i, d - i) not in seen: diag_sums += grid[i][d - i] seen.add((i, d - i)) return diag_sums"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _the total number of **subsequences** of `nums` whose sum is equal to `target`_. Be mindful of potential overflow issues in your calculations.","solution":"def count_subsequences(nums, target): Returns the total number of subsequences of nums whose sum is equal to target. # Using dynamic programming to keep track of the counts of sums from collections import defaultdict dp = defaultdict(int) dp[0] = 1 # Base case: there\'s one way to sum to 0 (using no elements) for num in nums: # Traverse the dictionary in reverse order to avoid overwriting entries during update for current_sum in list(dp.keys())[::-1]: dp[current_sum + num] += dp[current_sum] return dp[target]"},{"question":"You are given an array of integers `arr` and an integer `k`. Determine if there exists a contiguous subarray whose length is greater than or equal to `k` and the average of its elements is greater than or equal to `k`. Return `true` if such a subarray exists, otherwise return `false`. An **average** of a subarray is the sum of its elements divided by the number of elements in the subarray, and a **subarray** is a contiguous portion of an array.","solution":"def has_subarray_with_average(arr, k): Determines if there exists a contiguous subarray whose length is greater than or equal to k and the average of its elements is greater than or equal to k. :param arr: List of integers :param k: Integer threshold for both the length and the average :return: Boolean value whether such a subarray exists n = len(arr) if n < k: return False # Calculate the prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Iterate over all possible subarrays of length at least k for i in range(n - k + 1): for j in range(i + k, n + 1): subarray_sum = prefix_sum[j] - prefix_sum[i] subarray_length = j - i if subarray_length >= k and (subarray_sum / subarray_length) >= k: return True return False"},{"question":"Given an array of integers `arr`, you are allowed to select a subarray (contiguous part of the array) and perform one operation: reverse the order of elements in that subarray. Only one such operation is allowed. Determine if the entire array can be sorted in non-decreasing order by using exactly one reverse operation on a subarray. Return `true` if it is possible to sort the array with one reverse operation, otherwise return `false`.","solution":"def can_be_sorted_by_reversing_subarray(arr): Determines if the array can be sorted in non-decreasing order by reversing one subarray. n = len(arr) if n <= 1: return True # Find the first decreasing element i = 0 while i < n - 1 and arr[i] <= arr[i + 1]: i += 1 if i == n - 1: # Already sorted return True # Find the last element that is out of order from the end j = n - 1 while j > 0 and arr[j - 1] <= arr[j]: j -= 1 # Reverse the subarray from i to j arr[i:j+1] = arr[i:j+1][::-1] # Check if the array is now sorted for k in range(n - 1): if arr[k] > arr[k + 1]: return False return True"},{"question":"**[Question 4]**: Given a 2D grid `grid` of size `m x n` consisting of some obstacles (represented by `1`) and empty spaces (represented by `0`), find the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). You can move up, down, left, or right. If it\'s not possible to reach the bottom-right corner, return -1. Note that you cannot move onto or over obstacles. Implement a function that performs this task and returns the length of the shortest path.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left corner to the bottom-right corner in a 2D grid. The grid contains 0s (empty spaces) and 1s (obstacles). Allowed movements are up, down, left, or right. Parameters: grid (List[List[int]]): A 2D grid representing the map with obstacles and empty spaces. Returns: int: Length of the shortest path or -1 if it\'s not possible to reach the bottom-right corner. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == m - 1 and col == n - 1: return dist for d_row, d_col in directions: n_row, n_col = row + d_row, col + d_col if 0 <= n_row < m and 0 <= n_col < n and grid[n_row][n_col] == 0 and (n_row, n_col) not in visited: visited.add((n_row, n_col)) queue.append((n_row, n_col, dist + 1)) return -1"},{"question":"Given a string `text` consisting of lowercase English letters, you need to compress it using the following method: repeatedly pick the first character of the string and add it to a new string `result`, then remove all the consecutive occurrences of that character from `text`. Return the compressed string `result`.","solution":"def compress_string(text): Compresses the input text by repeatedly picking the first character of the text and adding it to a new string result, then removing all consecutive occurrences of that character from text. Args: text (str): The input string consisting of lowercase English letters. Returns: str: The compressed string after removing consecutive occurrences. result = \\"\\" while text: char = text[0] result += char text = text.lstrip(char) return result"},{"question":"Given a binary tree, represented as a list of lists where each list contains three elements `[parent, child, is_left]`, write a function to determine if it is height-balanced. A binary tree is height-balanced if for each node in the tree, the absolute difference in height between its left and right subtrees is at most 1. Return `True` if the binary tree is height-balanced, otherwise return `False`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(relations): if not relations: return None nodes = {} for parent, child, is_left in relations: if parent not in nodes: nodes[parent] = TreeNode(parent) if child not in nodes: nodes[child] = TreeNode(child) if is_left: nodes[parent].left = nodes[child] else: nodes[parent].right = nodes[child] # The root is the only node without a parent child_nodes = {child for _, child, _ in relations} all_nodes = set(nodes.keys()) root_val = (all_nodes - child_nodes).pop() return nodes[root_val] def is_balanced_binary_tree(relations): def check_balance(node): if not node: return 0, True left_height, is_left_balanced = check_balance(node.left) right_height, is_right_balanced = check_balance(node.right) height = max(left_height, right_height) + 1 is_balanced = is_left_balanced and is_right_balanced and abs(left_height - right_height) <= 1 return height, is_balanced root = build_tree(relations) _, is_balanced = check_balance(root) return is_balanced"},{"question":"Given two integers `n` and `m`, where `1 <= m <= n`, return an integer array where the `k`-th element is the number of distinct subsequences of length `k` that can be formed from the set `{1, 2, . . . , n}`. Since the result can be very large, return each element in the array **modulo** `10^9 + 7`.","solution":"def distinct_subsequences(n, m): MOD = 10**9 + 7 # Calculate the binomial coefficient C(n,k) which is n!/(k!(n-k)!) def binomial_coeff(n, k): if k > n: return 0 if k == 0 or k == n: return 1 # Calculate n! / (n-k)! first num = 1 for i in range(k): num = num * (n - i) % MOD # Calculate k! denom = 1 for i in range(1, k + 1): denom = denom * i % MOD # Use Fermat\'s Little Theorem to find modular inverse denom_inverse = pow(denom, MOD - 2, MOD) return num * denom_inverse % MOD result = [] for k in range(1, m + 1): result.append(binomial_coeff(n, k)) return result"},{"question":"You are given a 2D integer array `matrix` of size `m x n`, where each element `matrix[i][j]` represents the value at the `i-th` row and `j-th` column of the matrix. Write a function to return a list of the elements of the matrix in spiral order, starting from the top-left corner and moving clockwise. For example, given the matrix: ``` [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` The function should return `[1, 2, 3, 6, 9, 8, 7, 4, 5]`.","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. Args: matrix: List[List[int]] - 2D list of integers representing the matrix. Returns: List[int] - List of integers in spiral order. result = [] if not matrix: return result top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right. for j in range(left, right + 1): result.append(matrix[top][j]) top += 1 # Traverse from top to bottom. for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left. for j in range(right, left - 1, -1): result.append(matrix[bottom][j]) bottom -= 1 if left <= right: # Traverse from bottom to top. for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"You are given a 2D integer array `rooms` representing a building where `rooms[i] = [ki, k1, k2, ..., kj]` indicates room `i` has keys to rooms `k1, k2, ..., kj`. Initially, you are in room `0`, and all other rooms are locked. Each room may have zero or more keys. Your task is to determine whether you can visit all the rooms. Write a function that returns `true` if you can visit all the rooms, or `false` otherwise.","solution":"def can_visit_all_rooms(rooms): Determines if you can visit all the rooms starting from room 0. Args: rooms (List[List[int]]): A list of lists, where each list represents keys in a room. Returns: bool: True if you can visit all the rooms, False otherwise. n = len(rooms) visited = [False] * n stack = [0] while stack: current_room = stack.pop() if not visited[current_room]: visited[current_room] = True stack.extend(rooms[current_room]) return all(visited)"},{"question":"Given two strings `word1` and `word2`, return the length of their shortest common supersequence. A shortest common supersequence is a string that has both `word1` and `word2` as subsequences and is of the minimal possible length.","solution":"def shortest_common_supersequence_length(word1, word2): Returns the length of the shortest common supersequence for the given strings word1 and word2. m, n = len(word1), len(word2) # Create a DP table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array using bottom-up approach for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of the shortest common supersequence lcs_length = dp[m][n] scs_length = m + n - lcs_length return scs_length"},{"question":"Write a function that takes a string `s` and an integer `d` as input. The function should return the length of the **longest substring** in `s` where each character appears at least `d` times. If no such substring exists, return 0.","solution":"def longest_substring(s, d): Returns the length of the longest substring in s where each character appears at least d times. if not s or d <= 0: return 0 def longest_substring_helper(start, end, d): if end - start < d: return 0 char_freq = {} for i in range(start, end): char_freq[s[i]] = char_freq.get(s[i], 0) + 1 for i in range(start, end): if char_freq[s[i]] < d: left_part = longest_substring_helper(start, i, d) right_part = longest_substring_helper(i + 1, end, d) return max(left_part, right_part) return end - start return longest_substring_helper(0, len(s), d)"},{"question":"A **social network** graph is represented as an undirected graph where each node represents a user, and each edge represents a friendship between two users. You are given an integer `n` denoting the number of users in the network and a 2D integer array `connections` where each `connections[i] = [ui, vi]` depicts that user `ui` is friends with user `vi`. The network might be disconnected, meaning there might be users who are not friends with each other either directly or through mutual friends. Your task is to determine the number of **connected components** in this social network graph. A **connected component** is a subset of users such that any two users in this subset can be connected, directly or indirectly, through friendships, and which is not connected to any additional user outside this subset. Return _the number of connected components in the social network graph_.","solution":"def count_connected_components(n, connections): Returns the number of connected components in an undirected graph represented by n nodes and a list of edges. from collections import defaultdict, deque if n == 0: return 0 # Build the adjacency list representation of the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = set() count = 0 def bfs(node): queue = deque([node]) while queue: curr = queue.popleft() for neighbor in graph[curr]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Iterate through all nodes and perform BFS for each unvisited node for i in range(n): if i not in visited: visited.add(i) bfs(i) count += 1 return count"},{"question":"You are given an integer array `arr` of length `n` containing the prices of different items. You want to apply discounts to these items and you are allowed to apply one of the following two operations any number of times: 1. Select any item and apply a flat discount of a given integer `d` on its price. The price of the item cannot go below zero after this operation. 2. Select any two items and swap their positions in the array. Your goal is to minimize the sum of the prices of all items in the array by applying a series of these operations. Return the minimum possible sum of the prices after performing the operations optimally.","solution":"def minimize_prices(arr, d): Minimizes the sum of an array by applying a flat discount `d` on any item any number of times ensuring no prices go below zero. # Apply the discount to each item ensuring the price does not go below zero minimized_prices = [max(0, price - d) for price in arr] # The array can be rearranged in any order without affecting the final result. # Hence, just summing up the minimized prices will provide the required answer. return sum(minimized_prices)"},{"question":"You are given an array of integers `arr` representing the heights of trees. You need to chop down trees such that exactly `k` trees remain standing. A tree is \\"visible\\" if it is not blocked by a taller tree to its left. A tree of height `arr[i]` will block another tree at `arr[j]` if `i < j` and `arr[i] >= arr[j]`. Return the number of ways to chop down the trees so that exactly `k` trees remain visible. Since the answer may be large, return it **modulo** `10^9 + 7`.","solution":"MOD = 10**9 + 7 def count_ways(arr, k): def count_subsequences(i, count, prev_height): if count == k: return 1 if i == len(arr): return 0 # Include the current tree if it is taller than the last included tree include = exclude = 0 if arr[i] > prev_height: include = count_subsequences(i + 1, count + 1, arr[i]) # Exclude the current tree exclude = count_subsequences(i + 1, count, prev_height) return (include + exclude) % MOD return count_subsequences(0, 0, -1)"},{"question":"You are given a directed graph represented by a list of edges, where each edge is a pair `[u, v]` indicating a directed connection from node `u` to node `v`. The graph may contain cycles. You are required to perform a **topological sorting** on the nodes of the graph. If multiple valid topological orders exist, return any of them. If it is impossible to perform a topological sort (i.e., the graph has a cycle), return an empty list. Write a function `topologicalSort(edges, numNodes)` that accepts a list of edges and the total number of nodes in the graph, and returns a list of nodes in a valid topological order, or an empty list if no such order exists.","solution":"from collections import defaultdict, deque def topologicalSort(edges, numNodes): # Create a graph from the edges graph = defaultdict(list) in_degree = [0] * numNodes for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Find all nodes with no incoming edge queue = deque([i for i in range(numNodes) if in_degree[i] == 0]) topological_order = [] while queue: current = queue.popleft() topological_order.append(current) # Decrease the in-degree of connected nodes for neigh in graph[current]: in_degree[neigh] -= 1 if in_degree[neigh] == 0: queue.append(neigh) # Check if topological sorting is possible if len(topological_order) == numNodes: return topological_order else: return []"},{"question":"Given a string `s` consisting only of the characters \'a\', \'b\', and \'c\', you are allowed to replace any character with another character to form a palindrome. Return _the **minimum** number of replacements needed_ to make the string a palindrome. **Note** that a palindrome is a string that reads the same backward as forward.","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of replacements needed to make the string s a palindrome. s is a string consisting only of the characters \'a\', \'b\', and \'c\'. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"**Question 4**: You are given an array of integers `arr` and a number `x`. You need to find the length of the smallest contiguous subarray of which the sum is greater than or equal to `x`. If no such subarray exists, return `0`.","solution":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest contiguous subarray of which the sum is greater than or equal to x. If no such subarray exists, returns 0. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given two strings `str1` and `str2`. Your task is to determine the minimum number of operations required to convert `str1` into `str2`. You are allowed to perform three types of operations on `str1`: 1. **Insert** a character. 2. **Delete** a character. 3. **Replace** a character. Return the minimum number of operations needed to transform `str1` into `str2`. This problem is a variation of the classic _edit distance_ problem where you need to find the minimum number of operations required to make the two strings identical.","solution":"def min_edit_distance(str1, str2): Returns the minimum number of operations required to convert str1 into str2. Allowed operations are insert, delete, and replace. m = len(str1) k = len(str2) # Create a DP array to memoize result of previous computations. dp = [[0 for _ in range(k + 1)] for _ in range(m + 1)] # Initialize DP array for i in range(m + 1): for j in range(k + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining string elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # If last character are different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][k]"},{"question":"Given a binary tree, find the length of the shortest path between two nodes. The length is defined as the number of edges between the two nodes. You may assume that both nodes exist within the tree. Return the length of the shortest path between the two specified nodes.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, node1, node2): if root is None: return None if root == node1 or root == node2: return root left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def find_distance_from_ancestor(root, node, distance): if root is None: return -1 if root == node: return distance left_distance = find_distance_from_ancestor(root.left, node, distance + 1) if left_distance != -1: return left_distance right_distance = find_distance_from_ancestor(root.right, node, distance + 1) return right_distance def shortest_path_length(root, node1, node2): lca = find_lca(root, node1, node2) distance1 = find_distance_from_ancestor(lca, node1, 0) distance2 = find_distance_from_ancestor(lca, node2, 0) return distance1 + distance2"},{"question":"Given a directed graph represented by an adjacency list, determine if there is a cycle in the graph. Return _true_ if there is a cycle, otherwise _false_. The graph is represented as an array of lists `graph` where `graph[i]` contains the list of nodes to which the node `i` is connected. Use depth-first search (DFS) to detect any cycles.","solution":"def has_cycle(graph): Determines if there is a cycle in a directed graph. Parameters: graph (list): A list of lists where graph[i] contains the list of nodes to which node i is connected. Returns: bool: True if there is a cycle, False otherwise. def dfs(node, visited, recursion_stack): visited[node] = True recursion_stack[node] = True for neighbour in graph[node]: if not visited[neighbour]: if dfs(neighbour, visited, recursion_stack): return True elif recursion_stack[neighbour]: return True recursion_stack[node] = False return False visited = [False] * len(graph) recursion_stack = [False] * len(graph) for node in range(len(graph)): if not visited[node]: if dfs(node, visited, recursion_stack): return True return False"},{"question":"You are given a binary matrix `grid` where `0` represents water and `1` represents land. An island is a maximal group of connected `1`s, where a cell is considered connected if it is horizontally or vertically adjacent to another land cell in the group. The task is to find the size of the largest island in the matrix. If there is no land, return `0`. The `largestIsland` method should be implemented as follows: - `int largestIsland(int[][] grid)`: Returns the size of the largest island in the given grid.","solution":"def largestIsland(grid): Returns the size of the largest island of 1s in the grid. def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the cell as visited size = 1 size += dfs(i+1, j) size += dfs(i-1, j) size += dfs(i, j+1) size += dfs(i, j-1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given an array of integers `nums` representing a set of points on a number line. A subset of these integers is called a harmonic subset if every pair of integers `(a, b)` in the subset satisfies the equation `|a - b|` (leq) `1`. Return the size of the largest harmonic subset of `nums`. ----","solution":"def largest_harmonic_subset(nums): Returns the size of the largest harmonic subset in the given list of integers. A harmonic subset is a subset where the absolute difference between any two elements is at most 1. from collections import Counter count = Counter(nums) max_size = 0 for num in count: # Size of subset including \'num\' and \'num + 1\' current_size = count[num] + count[num + 1] max_size = max(max_size, current_size) return max_size"},{"question":"Given a list of integers `arr`, return _the minimum number of operations required to make all the elements of the array equal_, where an operation is defined as incrementing or decrementing a selected element by `1`.","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations required to make all elements of the array equal. if not arr: return 0 median = sorted(arr)[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"You have been given an integer `target` and an array `coins` of distinct integers representing coin denominations. Your task is to find and return _all unique combinations_ of the coin denominations that sum up to `target`. Each denomination can be used _any number of times_. The combinations can be returned in **any order**. Implement the function `List<List<Integer>> findChangeCombinations(int target, int[] coins)` that returns all the possible combinations of coin denominations that sum up to the given `target`. The solution should ensure that combinations are unique and not repeated. For example, with `target = 5` and `coins = [1, 2, 5]`, possible combinations could be `[[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [5]]`.","solution":"def findChangeCombinations(target, coins): def backtrack(remainder, combination, start): if remainder == 0: result.append(list(combination)) return elif remainder < 0: return for i in range(start, len(coins)): combination.append(coins[i]) backtrack(remainder - coins[i], combination, i) combination.pop() result = [] backtrack(target, [], 0) return result"},{"question":"There are `n` people standing in a circle, labeled from `1` to `n` in a clockwise direction. Each person holds a ball with a unique number from `1` to `n` written on it. At the beginning, each person has a ball whose number matches their label. The game consists of each person passing their ball to the person standing immediately to their left (counter-clockwise direction). After exactly one move, determine the final arrangement of the balls. Your task is to write a function that takes an integer `n` as input and returns a list representing the new arrangement of ball numbers after one move. The list should be of size `n`, where each element represents the number on the ball held by the corresponding person in the circle (1-indexed: the person labeled `1` holds the first element, person labeled `2` holds the second element, and so on). Return _an array of integers representing the new arrangement of the ball numbers after one move_.","solution":"def ball_arrangement(n): Returns the arrangement of ball numbers after one move in a counter-clockwise direction. Parameters: n (int): Number of people in the circle Returns: List[int]: The new arrangement of ball numbers if n == 0: return [] # The person labeled `i` will receive the ball from person labeled `i+1`, # and the person labeled `1` receives the ball from person labeled `n`. # Therefore, the result will be a list from 2 to n, followed by 1. return [i for i in range(2, n+1)] + [1]"},{"question":"You are given an array of integers `nums`. Write a function to determine if it is possible to partition the array into three non-empty parts with equal sums. Formally, you need to find indexes `i, j` with `0 < i < j < nums.length - 1` such that the sum of the elements in `nums[0, i-1]` is equal to the sum of the elements in `nums[i, j-1]`, and the sum of the elements in `nums[j, nums.length - 1]` is equal to the sum of the elements in `nums[0, i-1]`. If such a partitioning is possible, return true; otherwise, return false.","solution":"def can_partition_into_three_equal_parts(nums): total_sum = sum(nums) if total_sum % 3 != 0: return False target = total_sum // 3 current_sum, parts_found = 0, 0 for num in nums: current_sum += num if current_sum == target: parts_found += 1 current_sum = 0 if parts_found == 2: return True return False"},{"question":"You are given an `n` x `n` matrix `grid` representing an image, where each value in the matrix represents the pixel value at that location. The task is to perform a **rotational transformation** on the image. The rotational transformation consists of rotating the image 90 degrees clockwise. Return the `n` x `n` matrix after performing the rotation. For example, an input matrix `[[1,2,3],[4,5,6],[7,8,9]]` after a 90-degree clockwise rotation should return `[[7,4,1],[8,5,2],[9,6,3]]`.","solution":"def rotate_image_90_degrees_clockwise(grid): Rotates the given n x n matrix 90 degrees clockwise. Args: grid (List[List[int]]): An n x n matrix representing an image. Returns: List[List[int]]: The n x n matrix after being rotated 90 degrees clockwise. n = len(grid) rotated_grid = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_grid[j][n-1-i] = grid[i][j] return rotated_grid"},{"question":"Given an array of integers `arr` and an integer `x`, find a **subarray** whose sum is exactly `x` and has the smallest possible length. Return the **length** of that subarray. If no such subarray exists, return `-1`. A subarray is a contiguous part of an array.","solution":"def smallest_subarray_with_sum_x(arr, x): Finds the length of the smallest subarray with sum exactly x. Parameters: arr (List[int]): List of integers x (int): Target sum Returns: int: Length of the smallest subarray with sum x, or -1 if no such subarray exists. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: if current_sum == x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an array of integers `nums` where each `nums[i]` represents the number of balloons at the i-th position. Each balloon can either be a red balloon if `nums[i]` is positive or a blue balloon if `nums[i]` is negative. Your task is to find the **largest contiguous subarray** containing **equal numbers** of red and blue balloons. Return the _length_ of the largest such subarray.","solution":"def find_max_length(nums): Given an array of integers nums, find the length of the largest contiguous subarray containing an equal number of positive and negative integers. Args: nums (list of int): List of integers, representing the balloons. Returns: int: Length of the longest balanced subarray containing equal numbers of positive and negative integers. count_map = {0: -1} # Initialize the counter map with {0: -1} to handle cases starting from index 0 max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num > 0 else -1 # Increment count for positive, decrement for negative if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"Given a binary tree, implement a function to determine whether the binary tree is balanced. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. You should return a boolean indicating whether the binary tree is balanced or not. Write a function: ```python def isBalanced(root: TreeNode) -> bool: ``` Where: - `root`: the root node of the binary tree, which could be `None`. Note: The tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your function should return `True` if the tree is balanced, `False` otherwise. The function should be efficient, ideally with a time complexity of O(n), where n is the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root: TreeNode) -> bool: Determines whether the binary tree is balanced. A binary tree is balanced if for every node, the height difference between its left and right subtree is no more than 1. def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house in a street. The houses are arranged in a circular pattern, meaning the first house is adjacent to the last house. You cannot rob two adjacent houses, as it will alert the police. Write a function that returns the maximum amount of money you can rob without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money you can rob without alerting the police. def rob_linear(houses): prev_max, curr_max = 0, 0 for amount in houses: prev_max, curr_max = curr_max, max(curr_max, prev_max + amount) return curr_max if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements, where `n` is even. You need to partition the array into two subsets such that the **sum** of the elements in both subsets is as **equal** as possible. Return _the minimum **absolute difference** between the sum of the elements in the two subsets_.","solution":"from itertools import combinations from typing import List def minimumDifference(nums: List[int]) -> int: n = len(nums) total_sum = sum(nums) half_n = n // 2 def get_subset_sums(nums: List[int]) -> List[List[int]]: n = len(nums) subsets = [] for i in range(n+1): subsets.append([sum(combination) for combination in combinations(nums, i)]) return subsets left_sums = get_subset_sums(nums[:half_n]) right_sums = get_subset_sums(nums[half_n:]) right_all_sums = set() for sums in right_sums: right_all_sums.update(sums) min_diff = float(\'inf\') for i, left_subset_sums in enumerate(left_sums): for left_sum in left_subset_sums: target = (total_sum // 2) - left_sum possible_sums = sorted(right_all_sums) for sum_candidate in possible_sums: current_diff = abs(total_sum - 2 * (left_sum + sum_candidate)) min_diff = min(min_diff, current_diff) # Since the candidate sums are sorted, break early to optimize if sum_candidate >= target: break return min_diff"},{"question":"Given a string `s` containing only characters \'a\' and \'b\', you can delete any single character in `s`. Return the length of the longest substring containing \'a\' only or \'b\' only after deleting exactly one character from `s`.","solution":"def longest_substring_with_deletion(s): def max_substring_char(s, char): max_length = 0 current_length = 0 for c in s: if c == char: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length max_length = 0 for i in range(len(s)): new_str = s[:i] + s[i+1:] max_length = max(max_length, max_substring_char(new_str, \'a\'), max_substring_char(new_str, \'b\')) return max_length"},{"question":"You are given a `root` node of a binary tree. The binary tree is **height-balanced** and **binary search tree** compliant. Each node in the tree contains an integer value. Write a function that returns the **inorder traversal** of the given tree as a list of integers. In an inorder traversal, for each node, the left subtree is visited first, then the node itself, and finally, the right subtree. Return a list that represents the inorder traversal of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree as a list of integers. :param root: TreeNode, the root node of the binary tree :return: List[int], the inorder traversal of the tree result = [] def traverse(node): if node is not None: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. A binary tree node is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ```","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def rightSideView(root): Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # if it\'s the last node in the current level, add it to the right view if i == level_length - 1: right_view.append(node.val) # add child nodes to the queue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"Given a string `s`, you need to perform a series of moves to modify the string to match a target string `t`. Each move allows you to choose any character in `s` and replace it with any character. You are required to find the minimum number of moves needed to convert `s` to `t`. Return the minimum number of moves.","solution":"def min_moves(s, t): Calculates the minimum number of moves needed to convert string s to string t. Each move allows replacing any character in s with any character. Parameters: s (str): The original string. t (str): The target string. Returns: int: The minimum number of moves required. if len(s) != len(t): raise ValueError(\\"Strings s and t must have the same length\\") # Count the number of positions where the characters differ moves = sum(1 for a, b in zip(s, t) if a != b) return moves"},{"question":"You are given a string `str` containing only lowercase alphabets. Your task is to find the length of the longest substring that contains at most two distinct characters. Return _the length of the longest substring_. Example: ```plaintext Input: str = \\"abcba\\" Output: 3 Explanation: The longest substring that contains at most two distinct characters is \\"bcb\\" with length 3. ```","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring which contains at most two distinct characters. if len(s) < 3: return len(s) left, right = 0, 0 max_len = 2 hashmap = {} while right < len(s): if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given two **non-empty** strings, `s1` and `s2`. Your task is to write a function that **determines the minimum number of operations** needed to make `s1` and `s2` anagrams of each other. In one operation, you can **delete** any character from either string. Return the minimum number of deletions required to make the two strings anagrams. ```python def minDeletionsToMakeAnagrams(s1: str, s2: str) -> int: # Your code here ```","solution":"def minDeletionsToMakeAnagrams(s1: str, s2: str) -> int: from collections import Counter # Count the frequency of each character in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Calculate the number of deletions required deletions = 0 # For characters in s1 for char in counter1: if char in counter2: # The difference in counts of the same character in both strings deletions += abs(counter1[char] - counter2[char]) else: # All characters should be deleted if not present in s2 deletions += counter1[char] # For characters in s2 that are not in s1 for char in counter2: if char not in counter1: deletions += counter2[char] return deletions"},{"question":"You are given an array `intervals` where `intervals[i] = [start_i, end_i]` represents the start and end of the `i-th` interval. The intervals are disjoint and in sorted order. Insert a new interval `newInterval = [start, end]` into `intervals`, merging overlapping intervals if necessary. Return _the updated array of disjoint intervals after insertion_. Note: - The intervals in the output array should also be in sorted order. - The input intervals can be an empty array at first, and the provided new interval should still be placed correctly. For example: - Given intervals `[[1,3],[6,9]]` and newInterval `[2,5]`, your function should return `[[1,5],[6,9]]`. - Given intervals `[[1,2],[3,5],[6,7],[8,10],[12,16]]` and newInterval `[4,8]`, your function should return `[[1,2],[3,10],[12,16]]`.","solution":"def insert_interval(intervals, new_interval): Inserts a new interval into a list of disjoint intervals, merging overlapping intervals if necessary. merged_intervals = [] i = 0 n = len(intervals) # Add all intervals starting before new_interval while i < n and intervals[i][1] < new_interval[0]: merged_intervals.append(intervals[i]) i += 1 # Merge all overlapping intervals with new_interval while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 merged_intervals.append(new_interval) # Add the remaining intervals while i < n: merged_intervals.append(intervals[i]) i += 1 return merged_intervals"},{"question":"You are given a list of `n` integers and an integer `target`. Your task is to determine whether there are three distinct elements in the list that add up to `target`. Return _a boolean value_ indicating whether such a combination exists or not. Ensure your solution has a time complexity of at most O(n^2).","solution":"def three_sum(nums, target): Determines if there are three distinct elements in nums that add up to target. Args: nums : List[int] - List of integers target : int - Target sum Returns: bool - True if there exist three elements in nums that sum up to target, otherwise False nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` containing only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You are also given an integer `k`. A substring of `s` is considered beautiful if it contains at most `k` distinct characters. Return _the length of the longest beautiful substring_ of `s`.","solution":"def longest_beautiful_substring(s, k): Returns the length of the longest beautiful substring with at most k distinct characters. n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"Given the root of a binary tree, return the largest subtree (including itself) of the tree which is a valid Binary Search Tree (BST). A subtree must include all of its descendants. The largest subtree is defined by the number of nodes. A valid BST is defined by the following properties: - The left subtree of a node contains only nodes with keys less than the node\'s key. - The right subtree of a node contains only nodes with keys greater than the node\'s key. - Both the left and right subtrees must also be binary search trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root): def postorder(node): if not node: return (0, float(\'inf\'), float(\'-inf\'), 0) left_size, left_min, left_max, left_largest = postorder(node.left) right_size, right_min, right_max, right_largest = postorder(node.right) if left_max < node.val < right_min: size = left_size + right_size + 1 return (size, min(left_min, node.val), max(right_max, node.val), max(size, left_largest, right_largest)) else: return (0, float(\'-inf\'), float(\'inf\'), max(left_largest, right_largest)) return postorder(root)[3]"},{"question":"Implement a function that takes in a list of integers `arr` and returns the length of the longest subsequence such that all elements of the subsequence are consecutive integers. The consecutive numbers can be in any order. For example, for the input list `[4, 2, 1, 6, 5]`, the longest subsequence of consecutive integers is `[4, 5, 6]`, so the function should return `3`.","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive integers in the array. if not arr: return 0 arr = set(arr) longest_streak = 0 for number in arr: if number - 1 not in arr: current_number = number current_streak = 1 while current_number + 1 in arr: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a list of integers `arr` representing the heights of buildings in a line. The rainwater that can be trapped between the buildings is determined by the relative height differences among the buildings. Write a function to find the total amount of rainwater that can be trapped after it rains. You are also given an integer `threshold`. You need to return the total amount of rainwater if it is less than or equal to `threshold`. If the total rainwater is greater than `threshold`, return `-1`. Return an integer representing the total collected rainwater within the threshold limit.","solution":"def trap_rain_water(arr, threshold): Calculate the total amount of trapped rainwater within the threshold limit. Parameters: arr (list of int): List of heights of buildings threshold (int): Maximum allowable collected rainwater Returns: int: Total collected rainwater if it\'s <= threshold, else -1 if not arr: return 0 if threshold >= 0 else -1 n = len(arr) left, right = 0, n - 1 left_max, right_max = arr[left], arr[right] total_water = 0 while left < right: if arr[left] < arr[right]: left += 1 left_max = max(left_max, arr[left]) total_water += left_max - arr[left] else: right -= 1 right_max = max(right_max, arr[right]) total_water += right_max - arr[right] if total_water > threshold: return -1 return total_water if total_water <= threshold else -1"},{"question":"Given a string `s`, you can perform the following operation any number of times: Choose a non-empty prefix of the string `s` and add its reverse to the end of `s`. Your goal is to determine if it is possible to transform `s` into a palindrome by performing the above operation any number of times. Return `true` if you can transform `s` into a palindrome, otherwise return `false`.","solution":"def can_transform_to_palindrome(s): Determine if it is possible to transform the string `s` into a palindrome by appending the reverse of its prefixes any number of times. :param s: input string :return: True if it\'s possible to transform to palindrome, otherwise False # A helper function to check if a string is palindrome def is_palindrome(subs): return subs == subs[::-1] # Checking whether it is possible with the given conditions if is_palindrome(s): return True return False"},{"question":"Given an integer array `data` representing packets of information, where each packet is characterized by its size, you need to transmit these packets over a network with a limited bandwidth. The network has a maximum bandwidth of `max_bandwidth`. You can choose a continuous sequence of packets to transmit such that the total size of the packets does not exceed `max_bandwidth`. Return _the maximum number of packets_ that can be transmitted in one go. Example: If `data` = `[1, 2, 3, 4, 5]` and `max_bandwidth` = `10`, the function should return `4`, since the packets can be `[1, 2, 3, 4]` which total `10`, and this is the largest number of packets within the given bandwidth.","solution":"def max_packets(data, max_bandwidth): Returns the maximum number of continuous packets that can be transmitted without exceeding the given max_bandwidth. n = len(data) max_count = 0 current_sum = 0 start = 0 for end in range(n): current_sum += data[end] while current_sum > max_bandwidth: current_sum -= data[start] start += 1 max_count = max(max_count, end - start + 1) return max_count"},{"question":"Given an array of integers `nums`, you need to perform a specific transformation on the array exactly `k` times. In one transformation, you can select any subarray of `nums` and add 1 to each element in the subarray. After performing exactly `k` transformations, return the lexicographically smallest array that you can obtain. An array `a` is considered lexicographically smaller than array `b` if at the first index `i` where `a` and `b` differ, `a[i] < b[i]`. For example, `[1,2,3]` is lexicographically smaller than `[1,2,4]`.","solution":"def transform_array(nums, k): Perform exactly k transformations to get lexicographically smallest array. Args: nums: List[int] - The input array of integers. k: int - Number of transformations. Returns: List[int] - The lexicographically smallest array after k transformations. n = len(nums) for _ in range(k): min_index = 0 # Find the first occurrence of the minimum element for i in range(1, n): if nums[i] < nums[min_index]: min_index = i # Add 1 to all elements in the subarray starting at min_index for i in range(min_index, n): nums[i] += 1 return nums"},{"question":"You are given a string `s` and an array of strings `words`. Each string in `words` has the same length and is an anagram of `s`. Return the count of all distinct permutations of `s` that appear as a substring in any of the strings in `words`. A substring is a contiguous sequence of characters within a string. Each permutation of `s` is considered distinct only if it appears in a different position or a different string within the `words` array.","solution":"from collections import Counter def count_distinct_permutations(s, words): Returns the count of all distinct permutations of `s` that appear as a substring in any of the strings in `words`. s_len = len(s) s_counter = Counter(s) permutations = set() for word in words: word_len = len(word) for i in range(word_len - s_len + 1): substring = word[i:i+s_len] if Counter(substring) == s_counter: permutations.add((word, i)) return len(permutations)"},{"question":"Given a string `s` containing only lowercase letters, you need to find the length of the longest substring that contains exactly `k` distinct characters. If there is no such substring, return `-1`.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring that contains exactly k distinct characters. If no such substring exists, returns -1. if k == 0 or not s: return -1 n = len(s) max_length = -1 start = 0 char_count = {} for end in range(n): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 if len(char_count) == k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are developing an inventory management system for a warehouse. The warehouse contains multiple bulk storage areas, each identified by a unique string `storageId`. The system needs to track the quantity of different items stored in each area. An initial inventory state is provided as a list of lists, where each sublist contains three elements: `storageId`, `itemId`, and `quantity`, representing the quantity of the `itemId` present in the `storageId` storage area. Implement the `InventoryManager` class with the following methods: * `InventoryManager(List<List<String>> initialInventory)` - Initializes the inventory with the provided initial state. * `boolean addStock(String storageId, String itemId, int quantity)` - Adds `quantity` units of `itemId` to the specified `storageId`. Return `true` if the operation is successful, or `false` if the `storageId` does not exist. * `boolean removeStock(String storageId, String itemId, int quantity)` - Removes `quantity` units of `itemId` from the specified `storageId`. Return `true` if the operation is successful and there is enough stock, or `false` otherwise. * `Map<String, Integer> getStock(String storageId)` - Returns a dictionary representing the inventory of the specified `storageId`, where the keys are `itemId`s and the values are their quantities. If the `storageId` does not exist, return an empty dictionary.","solution":"from collections import defaultdict class InventoryManager: def __init__(self, initialInventory): self.inventory = defaultdict(lambda: defaultdict(int)) for storageId, itemId, quantity in initialInventory: self.inventory[storageId][itemId] += quantity def addStock(self, storageId, itemId, quantity): if storageId not in self.inventory: return False self.inventory[storageId][itemId] += quantity return True def removeStock(self, storageId, itemId, quantity): if storageId not in self.inventory: return False if self.inventory[storageId][itemId] < quantity: return False self.inventory[storageId][itemId] -= quantity if self.inventory[storageId][itemId] == 0: del self.inventory[storageId][itemId] return True def getStock(self, storageId): if storageId not in self.inventory: return {} return dict(self.inventory[storageId])"},{"question":"Given an integer array `nums`, return an array of the same length where each element at index `i` is the count of numbers in `nums` that are smaller than `nums[i]`. For example, let `nums = [8, 1, 2, 2, 3]`. The output should be `[4, 0, 1, 1, 3]`, where each element represents the count of integers smaller than the corresponding element in the original array.","solution":"def smallerNumbersThanCurrent(nums): Given an integer array nums, return an array of the same length where each element at index i is the count of numbers in nums that are smaller than nums[i]. :param nums: List[int] - The input list of integers :return: List[int] - The resulting list where each index indicates the count of numbers smaller than the number at that index in the input list result = [] for i in nums: count = 0 for j in nums: if j < i: count += 1 result.append(count) return result"},{"question":"You are given an array of strings `words` where each string consists of lowercase letters only. A word is considered \\"unique\\" if it appears exactly once in the array. Your task is to find the longest \\"unique\\" word in the array. If there are multiple longest \\"unique\\" words, return the one that appears first in the array. If there are no \\"unique\\" words, return an empty string. Write a function `longest_unique_word(words)` that returns the longest \\"unique\\" word, or an empty string if there are no unique words in the array.","solution":"def longest_unique_word(words): Returns the longest unique word in the list of words. A word is considered unique if it appears exactly once in the list. If there are multiple longest unique words, the one that appears first is returned. If there are no unique words, an empty string is returned. from collections import Counter word_counts = Counter(words) unique_words = [word for word in words if word_counts[word] == 1] if not unique_words: return \\"\\" longest_word = max(unique_words, key=len) return longest_word"},{"question":"You are given an array of integers `arr` and an integer `m`. Your task is to rearrange the elements of `arr` such that the **maximum sum** of any **m consecutive** elements is **minimized**. Return the minimum possible value of the maximum sum of any m consecutive elements after rearranging the array.","solution":"def minimize_max_sum(arr, m): def is_valid_mid(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > m: return False else: current_sum += num return True arr.sort() left, right = max(arr), sum(arr) while left < right: mid = left + (right - left) // 2 if is_valid_mid(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a 2D integer array `matrix` where each row represents a different item\'s features and columns represent different feature values. Your task is to find and return the row indices of all rows that match all feature criteria specified in the list `criteria`. Each element in `criteria` is a tuple `(column, min_value, max_value)` indicating that the corresponding column of the matrix should have values between `min_value` and `max_value` (inclusive) to be considered a match. Return the row indices in ascending order. ```python def matching_rows(matrix, criteria): pass ```","solution":"def matching_rows(matrix, criteria): Returns the row indices of all rows that match all feature criteria. :param matrix: List of lists where each list represents an item\'s features. :param criteria: List of tuples where each tuple is (column, min_value, max_value). :return: List of row indices that match all criteria. matching_indices = [] for row_index, row in enumerate(matrix): match = True for column, min_value, max_value in criteria: if not (min_value <= row[column] <= max_value): match = False break if match: matching_indices.append(row_index) return sorted(matching_indices)"},{"question":"You are given a string `s` and a list of strings `words`. Each string in `words` can be used any number of times, and you are allowed to concatenate them in any order. Determine if `s` can be formed exactly by concatenating strings from `words`. Return `true` if it is possible to form `s` using the strings in `words`, otherwise return `false`.","solution":"def can_form_string(s, words): from collections import Counter def can_form(s, word_counter): if not s: return True for word in word_counter: if s.startswith(word) and word_counter[word] > 0: word_counter[word] -= 1 if can_form(s[len(word):], word_counter): return True word_counter[word] += 1 return False word_counter = Counter(words) return can_form(s, word_counter)"},{"question":"You are given an integer array `nums` and an integer `target`. Design an algorithm to find all unique quadruplets in the array which gives the sum of the `target`. Implement the `findQuadruplets` function: * `List<List<Integer>> findQuadruplets(int[] nums, int target)` Returns a list of all unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that `a`, `b`, `c`, and `d` are distinct indices and `nums[a] + nums[b] + nums[c] + nums[d] == target`.","solution":"def findQuadruplets(nums, target): Returns a list of all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that a, b, c, and d are distinct indices and nums[a] + nums[b] + nums[c] + nums[d] == target. nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j-1]: continue left, right = j + 1, length - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a city skyline where the width of each building is `1`. You are working on designing a billboard that spans multiple buildings and want to find the largest possible area of the billboard that can be installed on top of the buildings. The billboard must be a rectangular area between the buildings (without rotating) and its base must sit at the same level as or below the shorter building in case of two adjacent buildings with different heights, for stability. Return _the largest possible area_ of the billboard.","solution":"def largestRectangleArea(heights): Returns the largest possible rectangular area of the billboard that can be installed on top of the buildings. stack = [] max_area = 0 for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"Given a list of integers `nums`, implement a function that returns _a list of length `k`, where each element is the average of the contiguous subarray of length `k` in `nums`_. If the list `nums` has less than `k` elements, return an _empty list_. The average should be a floating-point number and rounded to 2 decimal places.","solution":"def average_of_subarrays(nums, k): Returns a list of length k, where each element is the average of the contiguous subarray of length \'k\' in \'nums\'. If \'nums\' has less than \'k\' elements, return an empty list. Params: nums (list): List of integers. k (int): Length of the subarray. Returns: list: List of averages of each subarray. if len(nums) < k: return [] result = [] window_sum = sum(nums[:k]) for i in range(len(nums) - k + 1): if i > 0: window_sum = window_sum - nums[i - 1] + nums[i + k - 1] average = round(window_sum / k, 2) result.append(average) return result"},{"question":"Write a function that takes an integer array and returns the largest integer that only occurs once in the array. If no integer occurs exactly once, return -1. The function should handle both positive and negative integers.","solution":"def largest_unique_number(nums): Returns the largest integer that occurs exactly once in the array. If no integer occurs exactly once, return -1. from collections import Counter count = Counter(nums) unique_numbers = [num for num, cnt in count.items() if cnt == 1] return max(unique_numbers) if unique_numbers else -1"},{"question":"Given a 2D binary matrix of 0s and 1s, find the largest square containing only 1s and return its area. Each cell in the matrix contains a value of either 0 or 1. To solve the problem, implement the function `maximalSquare()` which takes the matrix as input and returns an integer representing the area of the largest square containing only 1s. For example: - If the input matrix is: ``` [ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ] ``` The output should be `4` because the largest square has a side length of 2 and thus an area of 4. Your algorithm should run in `O(m*n)` time complexity, where `m` is the number of rows and `n` is the number of columns in the matrix.","solution":"def maximalSquare(matrix): if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side_length = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i-1][j-1] == \'1\': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length * max_side_length"},{"question":"You are given a matrix where each row is sorted in ascending order and each column is sorted in ascending order. Write a function to find the k-th smallest element in the matrix. It is guaranteed that k is between 1 and the total number of elements in the matrix. **Example:** Given the following matrix and k = 8, matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] The 8th smallest element is 13.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted matrix. Args: matrix: List[List[int]] - a n x n matrix where rows and columns are sorted in ascending order k: int - an integer between 1 and the total number of elements in the matrix Returns: int - the k-th smallest element in the matrix n = len(matrix) min_heap = [(matrix[0][0], 0, 0)] # (value, row, col) visited = set((0, 0)) for _ in range(k): val, r, c = heapq.heappop(min_heap) if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (matrix[r + 1][c], r + 1, c)) visited.add((r + 1, c)) if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) visited.add((r, c + 1)) return val"},{"question":"Given a singly linked list where each node contains a number, write a function `partition` that partitions the list based on a value `x`, such that all nodes less than `x` come before nodes greater than or equal to `x`. The original relative order of the nodes in each of the two partitions should be preserved. The function should take the head of the linked list and the value `x` as input, and return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): less_head = ListNode(0) less = less_head greater_head = ListNode(0) greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next greater.next = None less.next = greater_head.next return less_head.next"},{"question":"You are given an integer array `arr` consisting of `n` positive integers. We define the badness of a subarray as the absolute difference between the maximum and minimum element in that subarray. Write a function that, given the array `arr` and an integer `k`, returns the maximum possible badness of any subarray of length `k`. If no such subarray exists, return `-1`. Implement the function `int maxSubarrayBadness(int[] arr, int k)`.","solution":"def maxSubarrayBadness(arr, k): if k > len(arr): return -1 max_badness = -1 for i in range(len(arr) - k + 1): subarray = arr[i:i + k] badness = max(subarray) - min(subarray) if badness > max_badness: max_badness = badness return max_badness"},{"question":"Implement a function `wordPattern` that takes a pattern and a string `s` and determines if `s` follows the same pattern. Here, following a pattern means there is a bijective mapping between a letter in the pattern and a non-empty word in `s`. Examples of valid and invalid mappings: - `pattern = \\"abba\\", s = \\"dog cat cat dog\\"` -> true - `pattern = \\"abba\\", s = \\"dog cat cat fish\\"` -> false - `pattern = \\"aaaa\\", s = \\"dog cat cat dog\\"` -> false Implement the function `boolean wordPattern(String pattern, String s)` that returns `true` if `s` follows the pattern and `false` otherwise. **Notes:** * Both `pattern` and `s` consist of lower-case English letters. * `s` contains words separated by a single space.","solution":"def wordPattern(pattern, s): Determine if the string s follows the pattern. Args: pattern (str): a string pattern. s (str): a string consisting of words separated by spaces. Returns: bool: True if s follows the pattern, False otherwise. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of a sequence of buildings. In one operation, you can: * Choose an index `i` in the range `0 <= i < heights.length` * Increase or decrease `heights[i]` by 1 unit Your goal is to ensure that each building is either the same height as or shorter than the building to its right (i.e., `heights` should be non-decreasing). Return _the **minimum** number of operations required to achieve this._","solution":"def min_operations_to_non_decreasing(heights): Returns the minimum number of operations required to make the array of heights non-decreasing. operations = 0 for i in range(1, len(heights)): if heights[i] < heights[i - 1]: operations += heights[i - 1] - heights[i] heights[i] = heights[i - 1] # Adjust height to make non-decreasing return operations"},{"question":"You are given a binary tree in which each node contains an integer value and a character. Define a **path** as a sequence of nodes where each node is the child of the previous node in the sequence. A path is **valid** if and only if all the characters on the path appear in non-decreasing alphabetical order. Return _the length of the longest **valid** path_ in the tree. If there are multiple paths with the same length, return any one of them. A **binary tree** is a tree data structure in which each node has at most two children, referred to as the `left` child and the `right` child.","solution":"class TreeNode: def __init__(self, value=0, char=\'\', left=None, right=None): self.value = value self.char = char self.left = left self.right = right def longest_valid_path(root): def dfs(node, prev_char, curr_length): if not node: return curr_length if node.char >= prev_char: left_length = dfs(node.left, node.char, curr_length + 1) right_length = dfs(node.right, node.char, curr_length + 1) return max(left_length, right_length) else: return curr_length return dfs(root, \'\', 0) # Example usage: # Constructing a binary tree # 1(\'a\') # / # 2(\'b\') 3(\'c\') # / # 4(\'d\') 5(\'b\') root = TreeNode(1, \'a\') root.left = TreeNode(2, \'b\') root.right = TreeNode(3, \'c\', TreeNode(4, \'d\'), TreeNode(5, \'b\')) print(longest_valid_path(root)) # Expected Output: 3 (\'a\' -> \'b\' -> \'c\')"},{"question":"You are given two strings `str1` and `str2` consisting of lowercase letters. Your task is to determine if you can transform `str1` into `str2` using the following operation any number of times: choose one character in `str1` and change it to any character. Return _`true` if you can transform `str1` into `str2` and `false` otherwise_.","solution":"def can_transform(str1, str2): Returns True if str1 can be transformed into str2 using any number of character changes. Returns False otherwise. # Ensure both strings are of the same length if len(str1) != len(str2): return False # If both strings have the same length, they can always transform into each other return True"},{"question":"You are given a stream of integers where each integer represents the temperature for a day. Design a system that can report the temperatures for the past `k` days whenever a new temperature is recorded. The system should be able to handle a large number of updates and queries efficiently. Implement the `TemperatureRecorder` class: * `TemperatureRecorder(int k)` Initializes the recorder with the required number of past days to report. * `void record(int temperature)` Records the temperature for a day. * `List<Integer> getLastKDays()` Returns the temperatures for the past `k` days, in the order they were recorded. If there are fewer than `k` recorded temperatures so far, return all available temperatures. (Note: The test data will ensure `k` is always a positive integer.)","solution":"from collections import deque class TemperatureRecorder: def __init__(self, k): Initializes the recorder with the required number of past days to report. :param k: int - the number of past days to keep track of. self.k = k self.temperatures = deque(maxlen=k) def record(self, temperature): Records the temperature for a day. :param temperature: int - the temperature value to record. self.temperatures.append(temperature) def getLastKDays(self): Returns the temperatures for the past k days. If there are fewer than k recorded temperatures so far, returns all available temperatures. :return: List[int] - list of temperatures for the past k days. return list(self.temperatures)"},{"question":"Given a string `s` consisting of uppercase English letters, you can perform at most one move where you pick any character from `s` and move it to any position in the string (including moving it to the same position). Return the length of the longest palindrome that can be achieved by performing at most one move.","solution":"def longest_palindrome_with_one_move(s): Returns the length of the longest palindrome that can be achieved by performing at most one move in the string s. from collections import Counter count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) if odd_count == 0: # If there are no odd counts, the whole string can form a palindrome return len(s) elif odd_count == 1: return len(s) # One odd, at most one move needed to make it a palindrome else: return len(s) - odd_count + 1 # Move one char to balance"},{"question":"You are given a string `s` consisting of only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You can replace any substring of `s` of length `k` with any one of the characters `\'a\'`, `\'b\'`, or `\'c\'`. What is the minimum number of replacements needed to ensure that no three consecutive characters are the same in the final string? Return an integer representing the minimum number of replacements needed.","solution":"def min_replacements(s, k): Returns the minimum number of replacements needed to ensure that no three consecutive characters are the same in the final string after replacing any substring of length k. n = len(s) replacements = 0 i = 0 while i < n - 2: if s[i] == s[i + 1] == s[i + 2]: # We need to change s[i + 2] at a minimum replacements += 1 i += 2 else: i += 1 return replacements"},{"question":"You are given a string `s` representing a sentence, where each word is separated by a single space. Each word in the sentence has either all lowercase letters or all uppercase letters. Modify the string such that every word that starts with a lowercase letter is reversed, and every word that starts with an uppercase letter remains as is. Return the modified string as your result.","solution":"def modify_sentence(s): Modifies the sentence `s` such that each word that starts with a lowercase letter is reversed, and each word that starts with an uppercase letter remains as is. :param s: A string representing a sentence. :return: A modified string. words = s.split() modified_words = [ word[::-1] if word[0].islower() else word for word in words ] return \' \'.join(modified_words)"},{"question":"You are developing an application to track locations of various delivery trucks. Each truck has a unique ID and can only be at one location at any time. Implement the `DeliveryTracker` class: * `void startDelivery(int truckId, string location, int startTime)` * A truck with ID `truckId` starts a delivery at location `location` at time `startTime`. * `void endDelivery(int truckId, string location, int endTime)` * The truck with ID `truckId` completes its delivery at location `location` at time `endTime`. * `double getAverageDeliveryTime(string startLocation, string endLocation)` * Returns the average time it takes to complete deliveries from `startLocation` to `endLocation`. * The average time is computed using all the previous deliveries that started at `startLocation` and ended at `endLocation`. * Deliveries directly from `startLocation` to `endLocation` should be considered for this average. * The time it takes to deliver from `startLocation` to `endLocation` may differ from the time it takes to deliver from `endLocation` to `startLocation`. * There will be at least one delivery that has been completed from `startLocation` to `endLocation` before `getAverageDeliveryTime` is called. You may assume all calls to the `startDelivery` and `endDelivery` methods are consistent in terms of chronology.","solution":"class DeliveryTracker: def __init__(self): self.deliveries = {} self.times = {} def startDelivery(self, truckId, location, startTime): self.deliveries[truckId] = (location, startTime) def endDelivery(self, truckId, location, endTime): if truckId in self.deliveries: start_location, start_time = self.deliveries.pop(truckId) if start_location == location: return route = (start_location, location) time_taken = endTime - start_time if route not in self.times: self.times[route] = [] self.times[route].append(time_taken) def getAverageDeliveryTime(self, startLocation, endLocation): route = (startLocation, endLocation) if route not in self.times or not self.times[route]: return 0.0 return sum(self.times[route]) / len(self.times[route])"},{"question":"You are given a list of `words`, where each word consists of lowercase English letters. Two words are said to be **connected** if they differ by exactly one letter. For example, the words \\"cat\\" and \\"bat\\" are connected, but \\"cat\\" and \\"cats\\" are not. You need to determine the minimum number of steps required to transform a given `beginWord` into an `endWord`. Each step must transform the current word into a connected word in the list. If it is not possible to transform the `beginWord` into the `endWord`, return -1. Note that all words, including the `beginWord` and `endWord` are of the same length.","solution":"from collections import deque def word_ladder(beginWord, endWord, words): Returns the minimum number of steps required to transform `beginWord` into `endWord`, transforming one letter at a time using words from the list. Returns -1 if not possible. if endWord not in words: return -1 word_set = set(words) queue = deque([(beginWord, 1)]) # initialize queue with (word, step count) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"You are given two strings `s` and `t` consisting of lowercase alphabetical characters. Return _the minimum number of operations required to convert_ `s` _into_ `t`. In one operation, you can insert a character, delete a character, or replace a character in `s`.","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s into string t. Operations allowed are insert, delete, replace a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, inserting all characters from t elif j == 0: dp[i][j] = i # If t is empty, delete all characters in s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete character from s dp[i][j - 1], # Insert character into s dp[i - 1][j - 1] # Replace character in s ) return dp[m][n]"},{"question":"You are given a collection of `n` stones, each with a positive integer weight. Write a function that determines the maximum weight you can achieve by removing stones according to the following rule: - In each turn, you must remove **exactly** two stones from the collection. - Their weights are added together, and a new stone with this combined weight is added back to the collection. Continue this process until you cannot remove two stones. Return the weight of the last remaining stone. If no stones are left, return 0.","solution":"import heapq def lastStoneWeight(stones): Determines the last stone weight after continuously combining the heaviest two stones until one or zero stones remain. Args: stones (list): List of integers representing the weights of the stones. Returns: int: Weight of the last remaining stone, or 0 if no stones remain. # Using a max-heap. Python\'s heapq is a min-heap, so we invert the values for max-heap behavior. stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: first = -heapq.heappop(stones) # Get heaviest stone second = -heapq.heappop(stones) # Get second heaviest stone if first != second: heapq.heappush(stones, -(first - second)) return -stones[0] if stones else 0"},{"question":"Given a list of strings `words`, return _the string that can be obtained by concatenating all the strings in a way that forms the lexicographically smallest possible result_. If there are multiple such results, return the one that appears first in the dictionary order. It is guaranteed that the length of all combined strings will not exceed 10^6.","solution":"def lexicographically_smallest_concatenation(words): Returns the lexicographically smallest concatenation of the given list of strings. # Sort the words with a custom key that compares concatenated results sorted_words = sorted(words, key=lambda x: x*len(words)) # Concatenate the sorted words return \'\'.join(sorted_words)"},{"question":"Given a string `s` containing only digits and lowercase English letters, return the number of unique characters in the longest contiguous substring of `s` that contains at most `k` different characters. If there are multiple such substrings of the same length, return the longest one that appears first. If `k` is 0, return 0.","solution":"def longest_substring_with_k_unique_characters(s, k): Returns the length of the longest contiguous substring with at most k unique characters. if k == 0: return 0 n = len(s) left = 0 right = 0 max_len = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a binary tree root with `n` nodes, where each node has a `value`. Each node will have either 0 or 2 children. Your task is to determine whether the binary tree is a full binary tree (i.e., each node has either 0 or 2 children, and no node has only one child). Return `true` if the tree is a full binary tree, and `false` otherwise.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_full_binary_tree(root): Determines if a binary tree is a full binary tree. A full binary tree is defined as a tree in which every node has either 0 or 2 children. :param TreeNode root: The root node of the binary tree. :return: True if the tree is a full binary tree, False otherwise. :rtype: bool if root is None: return True if (root.left is None and root.right is not None) or (root.left is not None and root.right is None): return False return is_full_binary_tree(root.left) and is_full_binary_tree(root.right)"},{"question":"Given an integer array `arr`, return the length of the longest subarray that contains at most two distinct integers. The solution should have a time complexity of (O(n)). *Example:* If `arr` is `[1, 2, 1, 2, 3, 2, 1]`, the longest subarray with at most two distinct integers is `[1, 2, 1, 2]`, so the output should be `4`. If `arr` is `[1, 2, 3, 4, 5]`, the longest subarray with at most two distinct integers is `[1, 2]`, so the output should be `2`.","solution":"def longest_subarray_with_two_distinct(arr): from collections import defaultdict start = 0 max_len = 0 freq_map = defaultdict(int) for end in range(len(arr)): freq_map[arr[end]] += 1 while len(freq_map) > 2: freq_map[arr[start]] -= 1 if freq_map[arr[start]] == 0: del freq_map[arr[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"A palindrome is a sequence that reads the same backward as forward. Given a string `s`, find the length of the longest palindromic subsequence in `s`. Implement the following function: ```python def longestPalindromeSubseq(s: str) -> int: ``` **Example:** ```python Input: s = \\"bbbab\\" Output: 4 Explanation: One possible longest palindromic subsequence is \\"bbbb\\". ``` ```python Input: s = \\"cbbd\\" Output: 2 Explanation: One possible longest palindromic subsequence is \\"bb\\". ``` Constraints: - The input string\'s length `s` is guaranteed to be between 1 and 1000.","solution":"def longestPalindromeSubseq(s: str) -> int: n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"You are given an array of distinct integers `arr` sorted in **increasing** order and an integer `target`. Your task is to return _the index of the first integer in the array that is **greater than or equal to**_ `target`. If no such integer exists, return `-1`.","solution":"def find_first_greater_or_equal(arr, target): Returns the index of the first integer in the array that is greater than or equal to the target. If no such integer exists, returns -1. :param arr: list of distinct integers sorted in increasing order :param target: integer target :return: index of the first integer >= target or -1 if none exists low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 else: high = mid - 1 if low < len(arr): return low else: return -1"},{"question":"You are given an `m x n` binary matrix `grid`, where `0` represents empty land and `1` represents a building. We want to build a post office on an empty land such that the **sum of Manhattan distances** from the post office to all the buildings is minimized. The Manhattan distance between two points `(x1, y1)` and `(x2, y2)` is `abs(x1 - x2) + abs(y1 - y2)`. Return the minimum sum of Manhattan distances of such a placement. If it is impossible to build such a post office, return `-1`.","solution":"from collections import deque def minimum_distance_sum(grid): Calculates the minimum sum of Manhattan distances from an empty land to all buildings (1\'s in the grid). if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) total_buildings = sum(cell == 1 for row in grid for cell in row) if total_buildings == 0: return -1 def bfs(start_i, start_j): visited = [[False] * n for _ in range(m)] queue = deque([(start_i, start_j, 0)]) distances = [[0] * n for _ in range(m)] while queue: x, y, dist = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 0: distances[nx][ny] += dist + 1 queue.append((nx, ny, dist + 1)) return distances building_distances = [[0] * n for _ in range(m)] buildings_visited = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if grid[i][j] == 1: distances = bfs(i, j) for x in range(m): for y in range(n): if grid[x][y] == 0 and distances[x][y]: building_distances[x][y] += distances[x][y] buildings_visited[x][y] += 1 result = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 0 and buildings_visited[i][j] == total_buildings: result = min(result, building_distances[i][j]) return result if result != float(\'inf\') else -1"},{"question":"Write a function `int longestConsecutive(vector<int>& nums)` that takes a vector of integers `nums` and returns the length of the longest consecutive elements sequence. Your algorithm should run in `O(n)` time complexity. A **consecutive sequence** is a sequence of numbers where each number is exactly one more than the previous number.","solution":"def longestConsecutive(nums): Returns the length of the longest consecutive elements sequence in an array/list of integers. Args: nums (List[int]): A list of integers Returns: int: The length of the longest consecutive sequence num_set = set(nums) longest_streak = 0 for num in num_set: # Only check for the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given two strings `word1` and `word2`. A **merge** operation between two words alternates the characters from `word1` and `word2`, beginning with the first character of `word1`. If a string is longer than the other, append the additional characters onto the end of the merged string. Return the merged string formed from `word1` and `word2`.","solution":"def merge_strings(word1, word2): Merge two strings by alternating their characters, starting with the first character of word1. If one string is longer, append the additional characters to the end of the merged string. :param word1: First input string :param word2: Second input string :return: Merged string merged_string = [] len1, len2 = len(word1), len(word2) max_len = max(len1, len2) for i in range(max_len): if i < len1: merged_string.append(word1[i]) if i < len2: merged_string.append(word2[i]) return \\"\\".join(merged_string)"},{"question":"Given a string `s` consisting of digits between \'0\' and \'9\', you can perform the following operation any number of times: choose a non-empty substring of `s` and replace it with its numerical sum (e.g., replacing \\"123\\" with \\"6\\"). The operation should be valid, meaning the resulting value should be within the range of a single digit. You need to return the minimum final number of digits possible after performing the operation.","solution":"def min_final_digits(s): Reduce the number string `s` by replacing non-empty substrings with their digit sum until the sum is a single digit. Returns the minimum number of digits remaining. # Calculate the sum of all digits in the original string total_sum = sum(int(c) for c in s) # Return the sum of digits repeated until a single digit result is obtained def digit_root(n): while n > 9: n = sum(int(c) for c in str(n)) return n return 1 if digit_root(total_sum) < 10 else len(str(digit_root(total_sum)))"},{"question":"You are given an integer array `nums` of size `n`, where `n` is even. You need to split this array into two subsets `A` and `B` such that the absolute difference between the sums of `A` and `B` is minimized. Return the minimum possible absolute difference. * For example, if `nums = [1, 6, 11, 5]`, splitting it into `A = [1, 6, 5]` and `B = [11]` minimizes the difference, resulting in ( | 1 + 6 + 5 - 11 | = 1 ). Thus, the return value would be `1`.","solution":"def minimumDifference(nums): Given an integer array \'nums\' of size \'n\' (where \'n\' is even), split it into two subsets such that the absolute difference between the sums is minimized. Return the minimum possible absolute difference. from itertools import combinations n = len(nums) total_sum = sum(nums) half = n // 2 # Generate all possible subset sums for the first half left_all_sums = [] for i in range(half + 1): for comb in combinations(nums[:half], i): left_all_sums.append(sum(comb)) # Generate all possible subset sums for the second half right_all_sums = [] for i in range(half + 1): for comb in combinations(nums[half:], i): right_all_sums.append(sum(comb)) left_all_sums = set(left_all_sums) right_all_sums.sort() min_diff = float(\'inf\') for left_sum in left_all_sums: target = (total_sum - 2 * left_sum) / 2 # Binary search in sorted right_all_sums lo, hi = 0, len(right_all_sums) - 1 while lo <= hi: mid = (lo + hi) // 2 if right_all_sums[mid] <= target: lo = mid + 1 else: hi = mid - 1 if lo < len(right_all_sums): min_diff = min(min_diff, abs(total_sum - 2 * (left_sum + right_all_sums[lo]))) if hi >= 0: min_diff = min(min_diff, abs(total_sum - 2 * (left_sum + right_all_sums[hi]))) return min_diff"},{"question":"Given a string `s` consisting of lowercase alphabets, return the length of the longest palindrome that can be formed by rearranging the characters in the string. A palindrome is a word that reads the same backward as forward. **Example:** If the input string is \\"abccccdd\\", the output should be 7, since one possible palindrome formation is \\"dccaccd\\". You may assume that the input string will not be empty and its length will not exceed 2000 characters.","solution":"def longest_palindrome(s): Returns the length of the longest palindrome that can be formed by rearranging the characters in the string. from collections import Counter count = Counter(s) length = 0 odd_found = False for char_count in count.values(): if char_count % 2 == 0: length += char_count else: length += char_count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"You are given an array of integers `nums` and an integer `pivot`. Your task is to rearrange the elements in the array such that all elements less than the pivot appear before all elements equal to the pivot, and those appear before all elements greater than the pivot. The relative order of the elements less than pivot, equal to pivot, and greater than pivot should be preserved. Return the rearranged array. For example, given `nums = [9,12,5,10,14,3,10]` and `pivot = 10`, the output should be `[9,5,3,10,10,12,14]`.","solution":"def rearrange_array(nums, pivot): Rearrange elements in nums such that all elements less than pivot appear before all elements equal to pivot, and those appear before all elements greater than pivot. Parameters: nums (list of int): The list of integers to rearrange. pivot (int): The pivot integer for the rearrangement. Returns: list of int: The rearranged list. less_than_pivot = [x for x in nums if x < pivot] equal_to_pivot = [x for x in nums if x == pivot] greater_than_pivot = [x for x in nums if x > pivot] return less_than_pivot + equal_to_pivot + greater_than_pivot"},{"question":"Given a binary tree and a target value, determine if there exist two different nodes in the binary tree such that their values sum up to the target value. Return `true` if such a pair exists, otherwise return `false`. Each node in the binary tree contains an integer value. Here is the definition of the binary tree node: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function: ```python def find_target(root: TreeNode, k: int) -> bool: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root: TreeNode, k: int) -> bool: def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) values = inorder_traversal(root) value_set = set() for value in values: if k - value in value_set: return True value_set.add(value) return False"},{"question":"Given a matrix of integers `matrix` where each row is sorted in ascending order, return the k-th smallest element in the matrix. You must find a solution with better time complexity than O(n*m), where n is the number of rows and m is the number of columns.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted matrix. Args: matrix (List[List[int]]): 2D list of integers where each row is sorted in ascending order. k (int): The order of the element to find (1-based indexing). Returns: int: The k-th smallest element in the matrix. n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) while k: element, r, c = heapq.heappop(min_heap) if c < n - 1: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"You are given a list of strings `words` where each word consists of lowercase English letters. Your task is to determine which words can be typed using letters of only one row on a QWERTY keyboard. The QWERTY keyboard rows are: - Row 1: \\"qwertyuiop\\" - Row 2: \\"asdfghjkl\\" - Row 3: \\"zxcvbnm\\" Return _a list of the words that can be typed using letters of only one row_.","solution":"def find_words(words): Returns a list of words that can be typed using letters of only one row on a QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") valid_words = [] for word in words: lower_word = word.lower() if set(lower_word).issubset(row1) or set(lower_word).issubset(row2) or set(lower_word).issubset(row3): valid_words.append(word) return valid_words"},{"question":"You are given a string `s` consisting of small English letters. A substring is considered \\"valid\\" if no two adjacent characters are the same. You can delete any number of characters from the string to make it valid. Return _the length of the longest valid substring that can be obtained by deleting some characters (possibly none) from_ `s`.","solution":"def longest_valid_substring(s): Returns the length of the longest valid substring where no two adjacent characters are the same. if not s: # handle empty string return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] != s[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given the head of a singly linked list, remove all the nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_unsorted(head: ListNode) -> ListNode: if not head: return None # Step 1: Collect all the values and their counts in a dictionary counts = {} current = head while current: counts[current.val] = counts.get(current.val, 0) + 1 current = current.next # Step 2: Remove nodes with values that have counts greater than 1 dummy = ListNode(0, head) prev, current = dummy, head while current: if counts[current.val] > 1: prev.next = current.next else: prev = current current = current.next # Step 3: Return the filtered list return dummy.next"},{"question":"Given an integer array `nums`, return the next permutation of the list in lexicographical order. If such an arrangement is not possible, it must rearrange it to the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples: if the input is `[1,2,3]`, the output should be `[1,3,2]`; if the input is `[3,2,1]`, the output should be `[1,2,3]`.","solution":"def next_permutation(nums): Modifies the list `nums` to its next permutation in lexicographical order. If such permutation is not possible, rearranges it to the lowest possible order. n = len(nums) if n <= 1: return nums # Step 1: Find the first decreasing element from the end i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Step 2: Find the element just larger than nums[i] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap elements nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the elements from i+1 to the end nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"You are given a list of points in a 2D plane represented by their coordinates (x, y) and an integer `k`. You need to find the `k` closest points to the origin (0, 0). The distance between two points (x1, y1) and (x2, y2) is calculated as the Euclidean distance: ((x2 - x1) + (y2 - y1)). Implement the function `kClosestPoints(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]`. * The function should return a list of `k` points that are closest to the origin in the 2D plane. * If there are multiple points with the same distance, you can return any of them. * You may assume `k` is always valid, i.e., `k` is less than or equal to the number of points.","solution":"import heapq from typing import List, Tuple def kClosestPoints(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: Returns the k closest points to the origin (0, 0). # Calculate the distance from origin for each point def distance(point): return point[0]**2 + point[1]**2 # Use a heap to keep track of the k smallest distances heap = [] for point in points: dist = distance(point) heapq.heappush(heap, (dist, point)) # Extract the k smallest distances result = [] for _ in range(k): result.append(heapq.heappop(heap)[1]) return result"},{"question":": You are given a sequence of `n` positive integers representing the heights of pillars. You can perform one or more \\"legal\\" actions on this sequence. A legal action is defined as choosing any two adjacent pillars and reducing their height by `1` simultaneously, as long as both heights are greater than or equal to `1`. Return the maximum number of legal actions you can perform on the sequence before it becomes impossible to perform any more actions.","solution":"def max_legal_actions(heights): Returns the maximum number of legal actions you can perform on the sequence. max_actions = 0 for i in range(len(heights) - 1): max_actions += min(heights[i], heights[i + 1]) return max_actions"},{"question":"You are given a `root` of a binary tree where each node contains an integer value. A node\'s value is considered \\"good\\" if it is greater than or equal to the maximum value encountered along the path from the root to that node. Write a function that returns the number of \\"good\\" nodes in the binary tree. The path refers to the sequence of nodes from the root to the current node, following parent-child connections.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: def dfs(node, max_value): if not node: return 0 total_good = 0 if node.val >= max_value: total_good += 1 max_value = node.val total_good += dfs(node.left, max_value) total_good += dfs(node.right, max_value) return total_good return dfs(root, float(\'-inf\'))"},{"question":"Given an array of integers `arr` of length `n`, you need to perform two types of queries on it: 1. **Increment**: Increment all elements of the subarray `arr[l:r+1]` inclusive by a given value `val`. 2. **Maximum**: Return the maximum value in the subarray `arr[l:r+1]` inclusive. Implement the `SubarrayOperations` class: * `SubarrayOperations(int[] arr)` Initializes the `SubarrayOperations` object with the integer array `arr`. * `void increment(int l, int r, int val)` Increments all elements of the subarray `arr[l:r+1]` by `val`. * `int maximum(int l, int r)` Returns the maximum value in the subarray `arr[l:r+1]`.","solution":"class SubarrayOperations: def __init__(self, arr): self.arr = arr def increment(self, l, r, val): for i in range(l, r + 1): self.arr[i] += val def maximum(self, l, r): return max(self.arr[l:r + 1])"},{"question":"You are given two strings, `s1` and `s2`, each of length `n`. Your task is to check if it is possible to transform `s1` into `s2` using zero or more operations. In one operation, you can insert any character anywhere in `s1`. The transformation must maintain the order of characters as in `s2` but can have additional characters in between. For example, if `s1 = \\"abc\\"` and `s2 = \\"aebc\\"`, you can transform `s1` into `s2` by inserting the character \'e\' at the second position. Implement a function `bool canTransform(string s1, string s2)` that returns `true` if it is possible to achieve this transformation, and `false` otherwise.","solution":"def can_transform(s1, s2): Checks if it is possible to transform s1 into s2 by inserting characters. Parameters: s1 (str): The source string. s2 (str): The target string to be formed. Returns: bool: True if transformation is possible, otherwise False. # Start pointers for both strings i = 0 j = 0 while i < len(s1) and j < len(s2): if s1[i] == s2[j]: i += 1 j += 1 return i == len(s1)"},{"question":"You are given an `n x n` 2D matrix where each integer represents the weight of the element at that position. Write a function to find the minimum path sum from the top-left corner to the bottom-right corner, where each move you can either go right or down. The path sum is the sum of the elements along that path. Return _the minimum path sum_.","solution":"def min_path_sum(grid): Given a grid of integers, returns the minimum path sum from the top-left corner to the bottom-right corner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"You are given two strings `s` and `t`. String `t` is generated by randomly shuffling string `s` and then adding an extra character at a random position. Return the extra character that was added to `t`. Both strings `s` and `t` will only consist of lowercase letters, and `t` will only contain lowercase letters. For example: - If `s = \\"abcd\\"` and `t = \\"abcde\\"`, the extra character is `\\"e\\"`. - If `s = \\"xyz\\"` and `t = \\"xyaz\\"`, the extra character is `\\"a\\"`.","solution":"def find_the_difference(s, t): Find the extra character in t that was not in s. :param s: String of lowercase letters :param t: String of lowercase letters with one extra character :return: The extra character in t # Using XOR bitwise operation to find the extra character result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"You are given an array of integers and an integer `k`. The array represents a circular list, meaning the next element of the last element is the first element of the array. Your task is to rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function `rotateArray(nums, k)` that takes in the array `nums` and the integer `k`, and modifies the array in-place to achieve the required rotation. The function should handle cases where `k` is larger than the length of the array by using the modulo operation.","solution":"def rotateArray(nums, k): Rotates the array to the right by k steps. Modifies the array in-place. n = len(nums) k %= n # Handle the case where k is larger than the length of the array nums[:] = nums[-k:] + nums[:-k] # Rotate the array"},{"question":"You are given a linked list, where the `head` node is at index 0 and each node contains an integer value and a reference to the next node. You are also given a list `queries` where each query contains two integers: the start index `start` and the end index `end`. For each query, you need to compute the sum of the values of the nodes from index `start` to `end` (inclusive). Return an array that contains the result of each query. Ensure your solution efficiently computes the sums without recalculating the sums for overlapping sublists.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def compute_prefix_sums(head): prefix_sums = [] current = head index = 0 current_sum = 0 while current is not None: current_sum += current.val prefix_sums.append(current_sum) current = current.next index += 1 return prefix_sums def sum_queries(head, queries): if not head: return [0] * len(queries) prefix_sums = compute_prefix_sums(head) results = [] for start, end in queries: if start == 0: results.append(prefix_sums[end]) else: results.append(prefix_sums[end] - prefix_sums[start - 1]) return results"},{"question":"Given an integer array `arr` where each element is at most 10^6, return the length of the longest consecutive sequence of elements. A **consecutive sequence** is a subset of elements from the array such that the elements can be arranged into a sequence where each number is exactly 1 more than the previous number. The sequence does not need to be present in the array in a continuous manner. Additionally, your solution should run in `O(n)` time complexity, where `n` is the length of the array.","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive sequence of elements. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # Only check for the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a directed graph representing the prerequisites of tasks, determine a possible order in which the tasks can be completed. Each task is represented by a unique integer in the range `[0, n - 1]`. The prerequisites are represented as a list of pairs `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that task `a_i` must be completed before task `b_i`. Return an array of integers representing one of the possible orders to complete all tasks or an empty array if it is not possible to complete all tasks. Note: 1. The prerequisites graph could have multiple valid task orders. 2. If no valid order exists (i.e., there is a cycle in the prerequisites), return an empty array. Example: ``` Input: n = 4, prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]] Output: [0, 1, 2, 3] or [0, 2, 1, 3] Input: n = 2, prerequisites = [[1, 0], [0, 1]] Output: [] ```","solution":"from collections import defaultdict, deque def findOrder(n, prerequisites): Determines a possible order to complete the tasks given their prerequisites. Parameters: n (int): The number of tasks. prerequisites (List[List[int]]): List of prerequisite pairs. Returns: List[int]: One possible order of task completion or an empty list if not possible. # Create a graph and calculate in-degrees of nodes graph = defaultdict(list) in_degree = [0] * n for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Queue for nodes with zero in-degree zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() order.append(node) # Decrement the in-degree of neighboring nodes for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If order contains all nodes, return the order; otherwise, return an empty list return order if len(order) == n else []"},{"question":"You are given a list of strings `words` and a dictionary string `dictionary` which contains words separated by spaces. Your task is to identify all the words from the input `words` list that are subsequences of any word in the `dictionary`. A string `A` is a subsequence of string `B` if `A` can be derived from `B` by deleting some or no characters while keeping the order of the remaining characters. Return a list of all the words from the input `words` list that are valid subsequences of any word in the `dictionary`. The output should be in the same order as the input `words` list. **Note:** You need to efficiently manage the case where the `dictionary` is very large.","solution":"def is_subsequence(word, dict_word): Check if `word` is a subsequence of `dict_word`. it = iter(dict_word) return all(char in it for char in word) def find_subsequences(words, dictionary): Given a list of strings `words` and a dictionary string `dictionary`, returns all the words from `words` that are subsequences of any word in the `dictionary`. dict_words = dictionary.split() result = [] for word in words: if any(is_subsequence(word, dict_word) for dict_word in dict_words): result.append(word) return result"},{"question":"Given a binary tree with `n` nodes, each node has a unique value from `1` to `n`, and each value represents the value of that particular node. The tree structure is given by a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates that there is an edge between nodes `ui` and `vi`. You are to write a function to return the sum of the values of the nodes at the maximum depth level of the binary tree. The maximum depth level is the level of the deepest nodes in the binary tree. If there are multiple nodes at the maximum depth level, return the sum of their values.","solution":"from collections import defaultdict, deque def sum_at_max_depth(n, edges): if not edges: return n # Only one node in the tree # Building graph using adjacency list representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Breadth-First Search (BFS) to find nodes at the maximum depth visited = set() queue = deque([(1, 0)]) # Starting BFS from node 1 at depth 0 max_depth = 0 max_depth_nodes = [] while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth max_depth_nodes = [node] elif depth == max_depth: max_depth_nodes.append(node) visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, depth + 1)) return sum(max_depth_nodes)"},{"question":"You are managing a library system that tracks books and their status. Each book can either be available for borrowing, currently borrowed, or reserved. Implement the `LibrarySystem` class: * `LibrarySystem(List<String> books)` Initializes the library system with a list of books. * `bool borrow(String book)` Sets the book status to borrowed if it is available and returns `true`. If the book is already borrowed or reserved, returns `false`. * `bool reserve(String book)` Sets the book status to reserved if it is available and returns `true`. If the book is already borrowed or reserved, returns `false`. * `void returnBook(String book)` Changes the status of the book back to available if it was borrowed or reserved. The system should ensure that the status of any book is accurately tracked and updated based on the actions performed.","solution":"class LibrarySystem: def __init__(self, books): Initializes the library system with a list of books. All books are available by default. self.books = {book: \'available\' for book in books} def borrow(self, book): Sets the book status to \'borrowed\' if it is available and returns True. If the book is already borrowed or reserved, returns False. if book in self.books and self.books[book] == \'available\': self.books[book] = \'borrowed\' return True return False def reserve(self, book): Sets the book status to \'reserved\' if it is available and returns True. If the book is already borrowed or reserved, returns False. if book in self.books and self.books[book] == \'available\': self.books[book] = \'reserved\' return True return False def returnBook(self, book): Changes the status of the book back to \'available\' if it was borrowed or reserved. if book in self.books and self.books[book] in [\'borrowed\', \'reserved\']: self.books[book] = \'available\'"},{"question":"Given an array of integers `arr` and an integer `k`, implement an algorithm to check whether there exists a pair of distinct indices `i` and `j` such that `arr[i] + arr[j] == k`. Return `true` if such a pair exists, and `false` otherwise. Your solution should aim for an optimal runtime performance.","solution":"def has_pair_with_sum(arr, k): Checks if there exists a pair of distinct indices i and j such that arr[i] + arr[j] == k. :param arr: List[int] - list of integers :param k: int - target sum :return: bool - True if such a pair exists, otherwise False seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"Given a binary matrix `mat` with `m` rows and `n` columns, return the number of 1\'s in the largest square sub-matrix that contains only 1\'s. If the matrix does not contain any 1\'s, return `0`.","solution":"def maximalSquare(matrix): Returns the number of 1\'s in the largest square sub-matrix that contains only 1\'s. Args: matrix: List[List[int]] - binary matrix with m rows and n columns Returns: int - number of 1\'s in the largest square sub-matrix that contains only 1\'s if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given an array of strings called `words`. Your task is to find the length of the longest substring such that the substring is a concatenation of some or all of the strings from `words` (each string can be used at most once) and all the strings used in the concatenation must be distinct. Return the length of this longest substring.","solution":"from itertools import permutations def longest_concatenated_substring_length(words): Returns the length of the longest concatenated substring such that the substring is formed by using each string from `words` at most once. max_length = 0 # Generate all permutations of the given words for i in range(1, len(words) + 1): for perm in permutations(words, i): concatenated_string = \'\'.join(perm) max_length = max(max_length, len(concatenated_string)) return max_length # Example usage: # words = [\\"a\\", \\"b\\", \\"c\\"] # print(longest_concatenated_substring_length(words)) # Should output 3 (\\"abc\\")"},{"question":"You are given two strings `word1` and `word2`. A **substring swap** involves picking a substring from `word1` and swapping it with a substring of the same length from `word2`. The goal is to determine whether it\'s possible to make `word1` and `word2` equal using exactly one substring swap. Return `true` if it is possible, otherwise return `false`.","solution":"def canMakeEqualWithOneSwap(word1, word2): Checks if it\'s possible to make word1 and word2 equal by swapping exactly one substring. if len(word1) != len(word2): return False # Early exit if words are already equal if word1 == word2: return False # Find the positions where the words differ diffs = [i for i in range(len(word1)) if word1[i] != word2[i]] # If there are not exactly 2 places where they differ, return False if len(diffs) != 2: return False # Check if swapping these two characters makes the strings equal i, j = diffs new_word1 = list(word1) new_word1[i], new_word1[j] = word1[j], word1[i] return \'\'.join(new_word1) == word2"},{"question":"You are given an array of positive integers `heights` representing the heights of buildings in a row, where each building is of width 1. The rainwater that falls on top of the buildings will accumulate between them, forming \\"pools\\" of water. Create a function to calculate the maximum volume of rainwater that can be trapped between the buildings. Return the total amount of trapped rainwater.","solution":"def trap(heights): Calculate the maximum volume of rainwater that can be trapped between the buildings. :param heights: List[int] A list of integers representing the heights of buildings. :return: int Total amount of trapped rainwater. if not heights: return 0 left_max = [0] * len(heights) right_max = [0] * len(heights) water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[len(heights)-1] = heights[len(heights)-1] for i in range(len(heights)-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate total water trapped for i in range(len(heights)): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given an array of integers `nums` sorted in ascending order, return _the lowest index_ at which a given `target` appears. If `target` is not found in the array, return `-1`. The array may contain duplicate elements. Implement the solution with a time complexity of `O(log n)`. ``` python def find_lowest_index(nums: List[int], target: int) -> int: # Your code here # Example print(find_lowest_index([1, 2, 2, 4, 5], 2)) # Should return 1 print(find_lowest_index([1, 3, 4, 6, 7], 5)) # Should return -1 ```","solution":"from typing import List def find_lowest_index(nums: List[int], target: int) -> int: Returns the lowest index of the target in the sorted list of integers nums. If the target is not found, return -1. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: result = mid right = mid - 1 # Look further on the left side for the lowest index elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"Given a list of `n` integers, design an algorithm to find the maximum contiguous subarray sum. The subarray must contain at least one number. A subarray is a contiguous part of an array. For example, with the input list `[-2,1,-3,4,-1,2,1,-5,4]`, the output should be `6` because the maximum sum can be obtained from the subarray `[4,-1,2,1]`. Write a function `maxSubArray` that returns the maximum sum of any contiguous subarray within the given list.","solution":"def maxSubArray(nums): Returns the maximum sum of any contiguous subarray within the given list. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a grid consisting of \'0\'s (water) and \'1\'s (land). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Now, you need to write a function that calculates the perimeter of the island represented in this grid. Implement the function `int islandPerimeter(vector<vector<int>>& grid)`, where `grid` is a 2D vector representing the map. Your function should return the overall perimeter of the island present in the grid. Note that there is exactly one island in the grid.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 # start with a contribution of 4 for each land cell if r > 0 and grid[r-1][c] == 1: # check above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # check left perimeter -= 2 return perimeter"},{"question":"You are given an array `nums` containing `n` distinct numbers in the range `[1, n+1]`. Each number appears exactly once except for one missing number. Write a function to return _the missing number_.","solution":"def find_missing_number(nums): Returns the missing number from the array of n distinct numbers in the range [1, n+1]. Args: nums: List[int] - List of unique integers in the range [1, n+1] with one missing number. Returns: int - The missing number. n = len(nums) + 1 total_sum = n * (n + 1) // 2 return total_sum - sum(nums)"},{"question":"Given a 2D grid `matrix` consisting of `0`\'s (representing water) and `1`\'s (representing land), determine the size of the largest island. An island is a group of connected 1\'s (connected horizontally or vertically). You may assume all four edges of the grid are surrounded by water. The function should return _the area (number of cells) of the largest island_. If there is no island, return _0_.","solution":"from typing import List def dfs(matrix: List[List[int]], i: int, j: int, visited: List[List[bool]]) -> int: if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or visited[i][j] or matrix[i][j] == 0: return 0 visited[i][j] = True area = 1 # include current cell # check all four possible directions area += dfs(matrix, i + 1, j, visited) area += dfs(matrix, i - 1, j, visited) area += dfs(matrix, i, j + 1, visited) area += dfs(matrix, i, j - 1, visited) return area def largest_island(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 visited = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))] max_area = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and not visited[i][j]: max_area = max(max_area, dfs(matrix, i, j, visited)) return max_area"},{"question":"Given a string `s`, find the length of the longest subsequence that can be derived from `s` that contains no two consecutive identical characters. Return _the length_ of this subsequence.","solution":"def longest_subsequence_length(s): Return the length of the longest subsequence with no two consecutive identical characters. if not s: return 0 n = len(s) count = 1 # First character is always included for i in range(1, n): if s[i] != s[i-1]: count += 1 return count"},{"question":"You are given an array of non-negative integers `nums`. Consider the leading non-zero segment of the array as the longest segment starting from the beginning of `nums` where all elements are non-zero. Your task is to move all the zero elements to the end of the array while maintaining the relative order of the non-zero elements. You should perform this operation in-place without making a copy of the array. Return _the modified array_.","solution":"def move_zeroes(nums): Moves all zero elements to the end of the array while maintaining the relative order of the non-zero elements. This operation is performed in-place. Args: nums (List[int]): The list of non-negative integers. Returns: List[int]: The modified list with all zero elements moved to the end. last_non_zero_found_at = 0 # If the current element is not 0, then we need to append it # in \'last_non_zero_found_at\' index position and increment the position. for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # After we have finished the task to move all the nonzero elements, # we just need to fill remaining array with 0\'s. for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0 return nums"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The input will be the root of the binary tree, and you should return a list of integers representing the right side view of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given a binary tree, returns the values of the nodes you can see ordered from top to bottom. :param root: The root node of the binary tree. :return: A list of integers representing the right side view of the tree. if not root: return [] right_view = [] queue = [(root, 0)] # (node, level) while queue: node, level = queue.pop(0) if level == len(right_view): right_view.append(node.val) else: right_view[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_view"},{"question":"Given a string `s` and an array of pairs of indices `pairs` where each pair `(i, j)` represents a swap operation where substrings of length 1 at indices `i` and `j` can be swapped, return the lexicographically smallest string that `s` can be transformed into after any number of swap operations. Note: * You can perform the swap operation on any pair in `pairs` any number of times. * You can assume that the array `pairs` does not contain duplicate pairs. Example: ```plaintext Input: s = \\"dcab\\", pairs = [[0,3],[1,2]] Output: \\"bacd\\" ```","solution":"def smallest_string_with_swaps(s, pairs): from collections import defaultdict import heapq def dfs(i, indices, characters): visited[i] = True indices.append(i) characters.append(s[i]) for neighbor in graph[i]: if not visited[neighbor]: dfs(neighbor, indices, characters) n = len(s) graph = defaultdict(list) for i, j in pairs: graph[i].append(j) graph[j].append(i) visited = [False] * n result = list(s) for i in range(n): if not visited[i]: indices = [] characters = [] dfs(i, indices, characters) indices.sort() characters.sort() for idx, char in zip(indices, characters): result[idx] = char return \'\'.join(result)"},{"question":"Given an integer array `nums`, return _the **starting index** of the longest **subarray** that contains **only** the value `0`. If there are multiple such subarrays of equal length, return the starting index of the **first** one._ If no such subarray exists, return `-1`. A **subarray** is a **contiguous** part of an array.","solution":"def longest_zero_subarray_start_index(nums): Given an integer array nums, return the starting index of the longest subarray that contains only the value 0. If there are multiple such subarrays of equal length, return the starting index of the first one. If no such subarray exists, return -1. max_length = 0 start_index = -1 current_length = 0 current_start = 0 for i, num in enumerate(nums): if num == 0: if current_length == 0: current_start = i current_length += 1 else: if current_length > max_length: max_length = current_length start_index = current_start current_length = 0 if current_length > max_length: start_index = current_start return start_index"},{"question":"You are given a 2D grid `board` containing only the characters `\'X\'` and `\'O\'`. A region is captured by flipping all `\'O\'`s into `\'X\'`s in that surrounded region where a surrounded region is formed by `\'O\'`s that are surrounded by `\'X\'`s on all four sides (up, down, left, and right boundaries). The task is to return the 2D grid after capturing all regions. Note that `\'O\'`s on the border cannot be flipped as they are not surrounded on all four sides.","solution":"def solve(board): Modifies the board in-place to capture all \'O\' regions surrounded by \'X\'. Args: board: List[List[str]]: The 2D grid containing \'X\' and \'O\'. if not board: return rows, cols = len(board), len(board[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != \'O\': return board[r][c] = \'E\' dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) # Mark \'O\'s on the border and their connected \'O\'s for r in range(rows): dfs(r, 0) dfs(r, cols - 1) for c in range(cols): dfs(0, c) dfs(rows - 1, c) # Capture all \'O\'s that are not marked for r in range(rows): for c in range(cols): if board[r][c] == \'O\': board[r][c] = \'X\' elif board[r][c] == \'E\': board[r][c] = \'O\'"},{"question":"You are given an `n x n` board representing a game of Tic-Tac-Toe. The board consists of characters `\'X\'`, `\'O\'`, and `\'.\'`. The character `\'.\'` indicates an empty spot on the board. Write a function to check if a player has won the game. A player wins if they have three of their marks (`\'X\'` or `\'O\'`) in a row horizontally, vertically, or diagonally. Return `\'X\'` if player X has won, `\'O\'` if player O has won, or `\'None\'` if there is no winner yet. ```python def check_tic_tac_toe(board): # Your implementation here ```","solution":"def check_tic_tac_toe(board): Checks if a player has won the game of Tic-Tac-Toe. Params: board: List[List[str]], a 2D list representing the Tic-Tac-Toe board Returns: str: \'X\' if player X has won, \'O\' if player O has won, \'None\' if there is no winner n = len(board) def check_winner(mark): # Check rows and columns for i in range(n): if all(board[i][j] == mark for j in range(n)) or all(board[j][i] == mark for j in range(n)): return True # Check main diagonal if all(board[i][i] == mark for i in range(n)): return True # Check anti-diagonal if all(board[i][n - 1 - i] == mark for i in range(n)): return True return False if check_winner(\'X\'): return \'X\' if check_winner(\'O\'): return \'O\' return \'None\'"},{"question":"Given a binary tree, you need to calculate the sum of values of its deepest leaves. The depth of the tree is the number of levels in the tree. Return the sum of values of the leaves at the deepest level. Consider nodes with the same depth on different branches as leaves at the same level.","solution":"from collections import deque from typing import Optional, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: Optional[TreeNode]) -> int: if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) # level_sum now holds the sum of the current level return level_sum"},{"question":"You are given an integer array `nums` of length `n` where each element represents the number of coins in a particular pile. You can perform the following operation any number of times: choose any pile with at least `3` coins and remove `2` coins from it while simultaneously adding `1` coin to another pile that is not empty. Return _the **maximum** number of piles that can all have an **even** number of coins after performing any number of operations._ If it is not possible to make all piles have an even number of coins, return `-1`.","solution":"def max_even_piles(nums): Returns the maximum number of piles that can all have an even number of coins after performing the operations any number of times or returns `-1` if it is not possible. even_count = sum(1 for num in nums if num % 2 == 0) odd_count = len(nums) - even_count if odd_count % 2 == 0: return len(nums) else: if any(num >= 3 for num in nums): return len(nums) else: return -1"},{"question":"You are given a list of strings `words` representing an English dictionary, where `words[i]` is a word in the dictionary. You are also given another string `s` which represents a sequence of characters. The task is to determine the longest word in `words` that can be formed by deleting some characters of the string `s` without reordering the remaining characters. If there are multiple longest words with the same length, return the word that appears first in the dictionary. Return the longest word that can be formed from `s`. If no word can be formed, return an empty string.","solution":"def find_longest_word(s, words): def can_form_by_deleting(word, s): it = iter(s) return all(char in it for char in word) longest_word = \\"\\" for word in words: if can_form_by_deleting(word, s): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"Given an array of integers `nums`, you are tasked with finding the length of the longest subarray that contains at most two distinct values. Each subarray must consist of values that appear consecutively in the original array. Return the maximum length of such a subarray. # Example: - Input: `nums = [1, 2, 1, 2, 3, 1]` - Output: `4` - Explanation: The longest subarray with at most two distinct values is `[1, 2, 1, 2]`, which has length 4.","solution":"def longest_subarray_with_two_distinct(nums): Finds the length of the longest subarray that contains at most two distinct values. if not nums: return 0 window_start = 0 max_length = 0 freq_map = {} for window_end in range(len(nums)): right_char = nums[window_end] if right_char not in freq_map: freq_map[right_char] = 0 freq_map[right_char] += 1 while len(freq_map) > 2: left_char = nums[window_start] freq_map[left_char] -= 1 if freq_map[left_char] == 0: del freq_map[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine if there are two distinct elements in the `nums` list whose sum is equal to `target`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def has_pair_with_sum(nums, target): Determines if there are two distinct elements in the list nums whose sum equals target. Parameters: nums (list of int): The list of integers to check. target (int): The target sum value. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a string `s` which contains only lowercase alphabets. You need to find the **minimum window** in `s` which will contain all the unique characters present in `s`. If there is a tie, return the window which occurs first. The function should return the substring representing the minimum window. Note: The question is about finding the smallest contiguous substring that contains all characters of the input string at least once.","solution":"def min_window_with_all_unique_chars(s): from collections import defaultdict # Get the set of all unique characters in the string unique_chars = set(s) required_len = len(unique_chars) # Dictionary to count character frequencies in the current window char_count = defaultdict(int) left = 0 unique_count = 0 min_len = float(\'inf\') min_window = \\"\\" for right, char in enumerate(s): # Increase the character count for the character at the right pointer char_count[char] += 1 # If this character\'s count is exactly 1 in the window, increase the unique count if char_count[char] == 1: unique_count += 1 # When the window contains all unique characters, try to minimize it while unique_count == required_len: # Update the minimum window if the current window is smaller window_length = right - left + 1 if window_length < min_len: min_len = window_length min_window = s[left:right+1] # Try to reduce the window size from the left char_count[s[left]] -= 1 if char_count[s[left]] == 0: unique_count -= 1 left += 1 return min_window"},{"question":"A **password strength** checker is a tool that evaluates the security level of a password based on certain criteria. The criteria for a strong password are as follows: * It has at least 8 characters. * It contains at least one lowercase letter. * It contains at least one uppercase letter. * It contains at least one digit. * It contains at least one special character from the set `{\\"!@#%^&*()-+\\"}`. Given a string `password`, return _`True` if the password meets all the criteria for a strong password, and `False` otherwise._","solution":"import re def is_strong_password(password): Returns True if the password meets all the criteria for a strong password, False otherwise. if len(password) < 8: return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'d\', password): return False if not re.search(r\'[!@#%^&*()-+]\', password): return False return True"},{"question":"Given a string `s` consisting of lowercase English letters, you need to reorder the string so that no two adjacent characters are the same. If it is possible to rearrange the string in such a way, return the new rearranged string. If it is not possible, return an empty string. The new arrangement must use all the characters from the input string and must maintain the original letter count of each character. **Example:** - Input: `s = \\"aab\\"` - Output: `\\"aba\\"` - Input: `s = \\"aaab\\"` - Output: `\\"\\"`","solution":"from collections import Counter import heapq def reorganize_string(s): Rearrange the string `s` so that no two adjacent characters are the same. If possible, returns the new rearranged string. Otherwise, return an empty string. count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_char, prev_count = \'\', 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 result_str = \'\'.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"Given an integer `N`, your task is to find all unique combinations of natural numbers (positive integers) that sum up to `N`. Return these combinations in a list, where each combination is a list of integers. The combinations should be sorted in lexicographical order, and within each combination, the numbers should be sorted in non-descending order. The list of combinations should not contain duplicate combinations.","solution":"def unique_combinations(N): def backtrack(start, target, path): if target == 0: result.append(path[:]) return for i in range(start, N+1): if i > target: break path.append(i) backtrack(i, target - i, path) path.pop() result = [] backtrack(1, N, []) return sorted(result)"},{"question":"Given a binary matrix `mat` of size `m x n`, you want to find the longest sequence of consecutive ones in the matrix. A sequence of consecutive ones can be formed horizontally, vertically, or diagonally. Return _the **length** of the longest sequence of consecutive ones_ in the matrix.","solution":"def longest_consecutive_ones(mat): if not mat or not mat[0]: return 0 m = len(mat) n = len(mat[0]) max_len = 0 def check_direction(x, y, dx, dy): length = 0 while 0 <= x < m and 0 <= y < n and mat[x][y] == 1: length += 1 x += dx y += dy return length for i in range(m): for j in range(n): if mat[i][j] == 1: max_len = max(max_len, check_direction(i, j, 0, 1)) # Horizontal max_len = max(max_len, check_direction(i, j, 1, 0)) # Vertical max_len = max(max_len, check_direction(i, j, 1, 1)) # Diagonal down-right max_len = max(max_len, check_direction(i, j, -1, 1)) # Diagonal up-right return max_len"},{"question":"You are given an integer array `nums` and an integer `k`. The array `nums` is rotated `k` times to the right. Your task is to return the original array before it was rotated. Assume that all elements in `nums` are unique. For example, if `nums = [4, 5, 6, 7, 0, 1, 2]` and `k = 3`, the array before rotation would be `[0, 1, 2, 4, 5, 6, 7]`. Create a function that efficiently finds and returns the original array.","solution":"def rotate_back(nums, k): Returns the original array before it was rotated k times to the right. Parameters: nums (list): Rotated array of integers. k (int): Number of rotations to the right. Returns: list: Original array before it was rotated. n = len(nums) k = k % n # In case k is larger than the array length return nums[-k:] + nums[:-k]"},{"question":"Given an array of integers `nums`, find the **shortest subarray** with a sum of at least `k`. If there is no such subarray, return `-1`. Construct a function `findShortestSubarray(nums: List[int], k: int) -> int` that implements this functionality efficiently. The function should strive to achieve better than O(n^2) time complexity.","solution":"from collections import deque from typing import List def findShortestSubarray(nums: List[int], k: int) -> int: Function to find the shortest subarray with a sum of at least k. If no such subarray exists, returns -1. n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = n + 1 deque_index = deque() for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result <= n else -1"},{"question":"Given an integer `m` and an array of strings `nums` representing large integers, return the largest integer (as a string) that is divisible by `m` from the array `nums`. If no such number exists, return an empty string.","solution":"def largest_divisible_by_m(m, nums): Returns the largest integer (as a string) that is divisible by m from the array nums. If no such number exists, returns an empty string. Args: m (int): The divisor. nums (list of str): The list of string representations of large integers. Returns: str: The largest integer divisible by m or an empty string. max_num = \\"\\" for num in nums: if int(num) % m == 0: if max_num == \\"\\" or int(num) > int(max_num): max_num = num return max_num"},{"question":"You are given a list of words and a target word. Your task is to determine if you can rearrange the letters of the target word to form one or more of the words in the given list. Write a function called `canFormByRearranging` that takes two parameters: - `words`: a list of strings where each string represents a word. - `targetWord`: a string representing the target word. The function should return `true` if you can rearrange the letters of the `targetWord` to form any word in the `words` list, and `false` otherwise. # Example: ```python canFormByRearranging([\\"listen\\", \\"silent\\", \\"enlist\\"], \\"tinsel\\") # Output: true (since \\"tinsel\\" can be rearranged to \\"silent\\") canFormByRearranging([\\"hello\\", \\"world\\"], \\"house\\") # Output: false (since \\"house\\" cannot be rearranged to form any word in the list) ``` # Constraints: - The length of `words` will be between 1 and 1000. - Each word in `words` will have a length between 1 and 100. - The `targetWord` will have a length between 1 and 100.","solution":"def canFormByRearranging(words, targetWord): Determines if the targetWord can be rearranged to form one of the words in the list. :param words: List of strings where each string represents a word. :param targetWord: A string representing the target word. :return: True if targetWord can be rearranged to form any word in the words list, False otherwise. from collections import Counter targetWordCount = Counter(targetWord) for word in words: if Counter(word) == targetWordCount: return True return False"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. The level order traversal is also known as a breadth-first search (BFS). Your implementation should handle a binary tree of size up to 1000 nodes efficiently.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of nodes\' values in a binary tree. if not root: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given an integer array `height` that represents the height of buildings in a cityscape. Each building `height[i]` can trap water if it is between two taller buildings. Write a function to return the amount of water that can be trapped after raining. The array `height` is given in such a way that calculating the total amount of trapped water is challenging due to its varying height patterns. Ensure your function handles edge cases and returns `0` if no water can be trapped.","solution":"def trap(height): Compute how much water it is able to trap after raining. :param height: List[int] representing the height of buildings :return: int representing the total amount of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given an array of integers `heights` representing the heights of a number of buildings in a row. A stack is used to identify and remove buildings with heights less than or equal to a specified limit. Your task is to compute the remaining buildings\' heights in the order they appear after applying the following operations: 1. Iterate through the array from left to right. 2. For each building, push its height into the stack if it is strictly greater than the specified limit. 3. If the building\'s height is less than or equal to the limit, continue to the next building without pushing its height onto the stack. Return an array of the remaining buildings\' heights after processing all the buildings. Note: The operation should preserve the original order of the heights of the buildings that are not removed.","solution":"def remaining_buildings(heights, limit): Returns an array of buildings\' heights that are strictly greater than the specified limit. stack = [] for height in heights: if height > limit: stack.append(height) return stack"},{"question":"You are given two integer arrays `arrival` and `departure` representing the arrival and departure times of `n` guests at a party. The `i-th` guest arrives at `arrival[i]` and leaves at `departure[i]`. A guest can only attend the party if there is room for them when they arrive. The venue has a limited capacity of `k`. Return _the maximum number of guests that can attend the party at the same time without exceeding the capacity_.","solution":"def max_guests(arrival, departure, k): Returns the maximum number of guests that can attend the party at the same time without exceeding the venue capacity. :param arrival: List of integers representing arrival times. :param departure: List of integers representing departure times. :param k: Integer representing the venue capacity. :return: Integer representing the maximum number of guests at the same time. events = [] for i in range(len(arrival)): events.append((arrival[i], \'arrive\')) events.append((departure[i], \'depart\')) events.sort(key=lambda x: (x[0], x[1] == \'depart\')) curr_guests = 0 max_guests = 0 for event in events: if event[1] == \'arrive\': curr_guests += 1 max_guests = max(max_guests, curr_guests) else: curr_guests -= 1 return min(max_guests, k)"},{"question":"Design a data structure to efficiently calculate the **product** of all elements in a given subarray. Implement the `RangeProductQuery` class: - `RangeProductQuery(int[] arr)` Constructs an instance of the class with the given **0-indexed** integer array `arr`. - `long query(int left, int right)` Returns the **product** of all elements in the subarray `arr[left...right]`. A **subarray** is a contiguous sequence of elements within an array. `arr[left...right]` denotes the subarray that contains the elements of `arr` between indices `left` and `right` (**inclusive**). Note that the product can be large, so the result should be returned as a `long`.","solution":"class RangeProductQuery: def __init__(self, arr): self.arr = arr self.prefix_products = self._compute_prefix_products() def _compute_prefix_products(self): prefix_products = [1] * len(self.arr) prefix_products[0] = self.arr[0] for i in range(1, len(self.arr)): prefix_products[i] = prefix_products[i - 1] * self.arr[i] return prefix_products def query(self, left, right): if left > 0: return self.prefix_products[right] // self.prefix_products[left - 1] else: return self.prefix_products[right]"},{"question":"You are given a list of flights represented as `flight[i] = [src, dest, time]`, where `src` is the source city, `dest` is the destination city, and `time` is the travel time between the cities. Additionally, you are provided with two integers, `start` and `end`, which represent your departure and arrival cities respectively. Your goal is to find the shortest travel time from `start` to `end` using the provided flights. Implement a function `findShortestTime(flights, start, end)` that returns _the shortest travel time, or `-1` if there is no possible route from `start` to `end`._","solution":"import heapq def findShortestTime(flights, start, end): Find the shortest travel time from start to end using the provided flights. Parameters: flights (List[List[int]]): List of flight routes represented as [src, dest, time]. start (int): The departure city. end (int): The arrival city. Returns: int: The shortest travel time, or -1 if there is no possible route from start to end. # Create a graph from the flights data graph = {} for src, dest, time in flights: if src not in graph: graph[src] = [] graph[src].append((dest, time)) # Priority queue to keep track of the shortest travel time to each city pq = [(0, start)] visited = set() while pq: curr_time, curr_city = heapq.heappop(pq) # If the current city is the destination, return the travel time if curr_city == end: return curr_time # If we have already visited this city, skip it if curr_city in visited: continue visited.add(curr_city) # Explore neighbors of the current city for neighbor, travel_time in graph.get(curr_city, []): if neighbor not in visited: heapq.heappush(pq, (curr_time + travel_time, neighbor)) # If no route from start to end, return -1 return -1"},{"question":"Implement a data structure that simulates a basic bank account system. The system should support opening new accounts, performing deposits or withdrawals, and checking the balance of any account. Implement the `Bank` class: * `Bank()` Initializes the bank with an empty list of accounts. * `int openAccount(int initialDeposit)` Opens a new account with an initial deposit and returns the account number. Account numbers should start at `1` and be sequentially increasing. * `void deposit(int accountNumber, int amount)` Deposits the specified amount to the account with the given account number. * `void withdraw(int accountNumber, int amount)` Withdraws the specified amount from the account with the given account number. Ensure that the account has sufficient funds before allowing the withdrawal. * `int checkBalance(int accountNumber)` Returns the current balance of the account with the given account number.","solution":"class Bank: def __init__(self): self.accounts = {} self.next_account_number = 1 def openAccount(self, initialDeposit): account_number = self.next_account_number self.accounts[account_number] = initialDeposit self.next_account_number += 1 return account_number def deposit(self, accountNumber, amount): if accountNumber in self.accounts: self.accounts[accountNumber] += amount def withdraw(self, accountNumber, amount): if accountNumber in self.accounts and self.accounts[accountNumber] >= amount: self.accounts[accountNumber] -= amount def checkBalance(self, accountNumber): if accountNumber in self.accounts: return self.accounts[accountNumber] return 0 # Assuming zero balance for non-existing accounts"},{"question":"You are given an integer `n` representing the number of courses, and a 2D integer array `prerequisites`, where `prerequisites[i] = [ai, bi]` means you must complete course `bi` before taking course `ai`. Each course can have multiple prerequisites but is guaranteed to form a Directed Acyclic Graph (DAG). Your task is to find one possible order to complete all the courses. Return _an integer array `order`_ of size `n`, where each element represents a course number, or return _an empty array_ if it is impossible to complete all courses.","solution":"from collections import deque, defaultdict def find_order(n, prerequisites): Returns one possible order to complete all the courses, or an empty array if it is impossible to complete all courses. # Create the adjacency list for the graph adj_list = defaultdict(list) in_degrees = [0] * n for dest, src in prerequisites: adj_list[src].append(dest) in_degrees[dest] += 1 # Initialize the queue with courses that have no prerequisites queue = deque([i for i in range(n) if in_degrees[i] == 0]) order = [] while queue: course = queue.popleft() order.append(course) for neighbor in adj_list[course]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return []"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `k`. You can perform the following operation exactly once: Choose any non-empty substring of `s` and rearrange its characters in any order. Return _the length of the longest palindromic subsequence_ that can be obtained from `s` after performing the operation. Note that a subsequence is derived from another string by deleting some or no characters without changing the order of the remaining characters.","solution":"def longest_palindromic_subsequence(s, k): Returns the length of the longest palindromic subsequence that can be obtained from string s after performing the operation. from collections import Counter # Count the frequency of each character freq = Counter(s) # Count pairs and single characters pairs = 0 single = 0 for count in freq.values(): pairs += count // 2 single += count % 2 # The length of longest palindromic subsequence # It includes all pairs (counted as twice) and at most one single character longest_length = pairs * 2 + (1 if single > 0 else 0) return longest_length"},{"question":"Given an array of integers `nums` representing n unique elements, where `nums` is sorted in ascending order, write a function to determine if a target value exists within `nums`. If the target exists, return its index. Otherwise, return `-1`. You must provide an algorithm that runs in O(log n) time complexity.","solution":"def binary_search(nums, target): Performs a binary search to find the target value within nums. Parameters: nums (List[int]): A list of integers sorted in ascending order. target (int): The value to search for. Returns: int: The index of target if it exists in nums, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given a `2D` grid of `m x n` size representing a maze where some cells are empty (`0`) and some cells have obstacles (`1`), and a starting point `(startRow, startCol)` and a destination `(destRow, destCol)`, return `true` if there is a path from the start to the destination without moving diagonally, otherwise return `false`. The path must exclusively move to adjacent cells in the grid (up, down, left, right) and cannot pass through obstacles.","solution":"from collections import deque def is_valid_move(grid, visited, row, col): Check if the move to (row, col) is valid. if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]) and not visited[row][col] and grid[row][col] == 0: return True return False def has_path(grid, startRow, startCol, destRow, destCol): Determines if there is a path from start to destination in the given maze grid. # Base case: return False if start or destination is an obstacle if grid[startRow][startCol] == 1 or grid[destRow][destCol] == 1: return False # Initialize the directions array for up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize visited matrix m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] # Use a deque for BFS queue = deque([(startRow, startCol)]) visited[startRow][startCol] = True while queue: row, col = queue.popleft() # Check if we have reached the destination if row == destRow and col == destCol: return True # Explore all four possible directions for dr, dc in directions: newRow, newCol = row + dr, col + dc if is_valid_move(grid, visited, newRow, newCol): visited[newRow][newCol] = True queue.append((newRow, newCol)) return False"},{"question":"You are given a list of `logs` where each log is represented as a string with the format `\\"id1_id2 action timestamp\\"`. Here, `id1` and `id2` are user identifiers (strings), `action` is a string that can be either `\\"follows\\"` or `\\"unfollows\\"`, and `timestamp` is an integer denoting the time of the action. Write a function that generates the final list of followers for each user at the end of all the actions in the logs. The output should be a dictionary where the keys are user IDs and the values are lists of user IDs that are following them, sorted in ascending order.","solution":"def generate_followers(logs): from collections import defaultdict followers = defaultdict(set) for log in logs: parts = log.split() ids = parts[0].split(\'_\') id1, id2 = ids[0], ids[1] action = parts[1] if action == \\"follows\\": followers[id2].add(id1) elif action == \\"unfollows\\": followers[id2].discard(id1) # convert sets to sorted lists result = {user: sorted(list(follower_set)) for user, follower_set in followers.items()} return result"},{"question":"A **magical string** S consists of only \'1\' and \'2\' and obeys the following rules: 1. The string S is initially \\"1221121221221121122\\". 2. The number at the sequence S[i] represents the frequency of \'1\' to be added after S[i] in the sequence. For example, S[6] = \'1\', so 1 \'1\' will be added after S[6], making the sequence S = \\"12211212211212...\\". Construct the sequence based on these rules and determine how many \'1\'s are in the first N numbers of the sequence S. Write a function `int magicalString(int N)` that returns the count of \'1\'s in the first N numbers of the magical string S. Note: - The value N will always be a positive integer. - Your implementation should consider efficient generation of the magical string, especially for larger values of N.","solution":"def magicalString(N): if N == 0: return 0 if N <= 3: return 1 s = [1, 2, 2] head = 2 tail = 3 num = 1 while tail < N: for _ in range(s[head]): s.append(num) tail += 1 if tail >= N: break num ^= 3 # switch between 1 and 2. 1^3=2, 2^3=1 head += 1 return s[:N].count(1)"},{"question":"Given a list of daily `temperatures`, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead. For example, given the list `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. Implement an algorithm with a time complexity of `O(n)`.","solution":"def daily_temperatures(temperatures): Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. result = [0] * len(temperatures) stack = [] for i, temp in enumerate(temperatures): while stack and temp > temperatures[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"You are given a binary tree where each node contains a value representing the quantity of gold in that bank. Thieves have decided to rob gold from the tree in such a way that they cannot rob two directly connected banks. Implement a function to compute the maximum amount of gold that can be robbed without alerting security. Given the root of the binary tree, return the maximum gold that can be robbed.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rob_gold(root): def rob_subtree(node): if not node: return (0, 0) left = rob_subtree(node.left) right = rob_subtree(node.right) # If we rob this node, we cannot rob its children rob_this = node.val + left[1] + right[1] # If we do not rob this node, we take the max value from robbing or not robbing the children not_rob_this = max(left) + max(right) return (rob_this, not_rob_this) result = rob_subtree(root) return max(result)"},{"question":"You are given an integer array `nums` that represents the position of stones along a river. Initially, a frog is at the first stone (position 0) and can jump to the next stone with a step size of 1. The frog can make jumps of size k-1, k, or k+1 from a stone at position `nums[i]`, where `k` is the jump size used to reach that stone. Determine if the frog can reach the last stone. Return _true if the frog can reach the last stone, otherwise return false._","solution":"def can_cross(nums): Determines if the frog can reach the last stone in the river. Parameters: nums (List[int]): List representing the positions of stones along a river. Returns: bool: True if frog can reach last stone, False otherwise. if not nums: return False stone_positions = {x: set() for x in nums} stone_positions[0].add(0) for stone in nums: for jump in stone_positions[stone]: for step in range(jump - 1, jump + 2): if step > 0 and (stone + step) in stone_positions: stone_positions[stone + step].add(step) return len(stone_positions[nums[-1]]) > 0"},{"question":"You are given a large integer `n`, and you are required to break it down into the sum of two or more positive integers such that their product is maximized. For example, if `n = 8`, you can break it down into `3 + 3 + 2`, and their product is `3 * 3 * 2 = 18`, which is the maximum possible for `n = 8`. Write a function that returns the maximum product possible for a given `n`.","solution":"def integer_break(n): Break the integer n into the sum of at least two positive integers such that their product is maximized. Returns the maximum product possible. if n <= 3: return n - 1 product = 1 while n > 4: product *= 3 n -= 3 product *= n return product"},{"question":"You are given a **sorted** array of **unique** integers `nums` and an integer `target`. Write a function that returns the index of `target` if it exists in `nums`, otherwise return the index where `target` should be inserted to maintain the sorted order. You must implement an algorithm with `O(log n)` runtime complexity.","solution":"def search_insert(nums, target): Returns the index if target is found in nums, otherwise returns the index where it should be inserted. low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] == target: return mid elif nums[mid] < target: low = mid + 1 else: high = mid - 1 return low"},{"question":"You are given a string `s` containing only lowercase letters. Implement a function to determine the **length of the longest substring** of `s` where every character appears at least `k` times. If no such substring exists, return `0`. The substring must be contiguous and non-empty. Example: ```python Input: s = \\"aaabb\\", k = 3 Output: 3 Explanation: The longest substring is \\"aaa\\", where each \'a\' appears at least 3 times. ```","solution":"def longest_substring_with_at_least_k_repeats(s, k): def helper(s, k, start, end): if end - start < k: return 0 count = [0] * 26 for i in range(start, end): count[ord(s[i]) - ord(\'a\')] += 1 for mid in range(start, end): if count[ord(s[mid]) - ord(\'a\')] >= k: continue mid_next = mid + 1 while mid_next < end and count[ord(s[mid_next]) - ord(\'a\')] < k: mid_next += 1 return max(helper(s, k, start, mid), helper(s, k, mid_next, end)) return end - start return helper(s, k, 0, len(s))"},{"question":"An array of integers `arr` is given, where each element represents the number of units of a type of item. Every minute, the most frequently occurring item is processed (unit count decreases by one). If there are ties for the most frequent item, any of the most frequent items can be chosen. Return the minimum number of minutes needed to process all the items in the array.","solution":"from collections import Counter def min_minutes_to_process_all_items(arr): Returns the minimum number of minutes needed to process all the items in the array. if not arr: return 0 counter = Counter(arr) total_minutes = 0 while counter: most_frequent = counter.most_common(1)[0] item, count = most_frequent[0], most_frequent[1] # Process one unit of the most frequent item total_minutes += 1 if count > 1: counter[item] -= 1 else: del counter[item] return total_minutes"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return _all possible sentences_ you can form by concatenating words from the dictionary _such that each character in the input string is used exactly once_. Each word in the dictionary may be used multiple times in the segmentation. You may return the answer in **any order**.","solution":"def wordBreak(s, wordDict): Given a string s and a dictionary of strings wordDict, return all possible sentences by concatenating words from the dictionary such that each character in the input string is used exactly once. Each word in the dictionary can be used multiple times. def backtrack(start): if start == len(s): return [\\"\\"] if start in memo: return memo[start] results = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in wordDict: sub_sentences = backtrack(end) for sentence in sub_sentences: results.append(word + (\\"\\" if sentence == \\"\\" else \\" \\" + sentence)) memo[start] = results return results memo = {} return backtrack(0)"},{"question":"You are given a list of non-negative integers `arr` and an integer `target`. Your task is to determine if there are three distinct elements in `arr` that add up to exactly `target`. Return _`true` if such a triplet exists and `false` otherwise_.","solution":"def find_triplet(arr, target): Determines if there are three distinct elements in `arr` that add up to exactly `target`. :param arr: List of non-negative integers. :param target: Target sum as an integer. :return: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given an array of integers `arr` and an integer `x`. You need to find the smallest subarray length for which the sum of the elements is greater than or equal to `x`. If there is no subarray that meets this criterion, return -1. For example, given `arr = [1, 2, 3, 4, 5]` and `x = 11`, the smallest subarray that meets the requirement is `[4, 5]`, so the answer would be 2.","solution":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest subarray with sum greater than or equal to x. If no such subarray exists, returns -1. n = len(arr) min_length = float(\'inf\') start = 0 curr_sum = 0 for end in range(n): curr_sum += arr[end] while curr_sum >= x: min_length = min(min_length, end - start + 1) curr_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a list of integers `nums` and an integer `target`. Your goal is to determine whether there exist four integers `a`, `b`, `c`, and `d` such that `a + b + c + d = target`. Return _a boolean indicating whether such a combination exists_. Note: - The same element may be used multiple times. - Duplicates in `nums` are allowed and should be considered as individual elements. For example, if `nums = [1, 2, 3, 4, 5]` and `target = 10`, one possible combination is `1 + 2 + 3 + 4 = 10`, so the function should return `true`. If `nums = [1, 1, 1, 1]` and `target = 6`, there is no combination of four numbers that adds up to 6, so the function should return `false`.","solution":"def four_sum(nums, target): Returns True if there exist four integers in `nums` whose sum equals `target`, False otherwise. nums_sorted = sorted(nums) n = len(nums_sorted) for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: total = nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given an array of integers `arr` and an integer `k`. The task is to find the `k`th smallest element in the array after sorting it. Implement a function to achieve this in O(n) expected time complexity. If `k` is greater than the length of the array, return -1. Note that the same number can appear multiple times in the array.","solution":"import random def kth_smallest_element(arr, k): Returns the k-th smallest element in the array after sorting it. If k is greater than len(arr), returns -1. def quickselect(arr, left, right, k): if left == right: return arr[left] pivot_index = random.randint(left, right) pivot_index = partition(arr, left, right, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[right] = arr[right], arr[store_index] return store_index if k > len(arr) or k <= 0: return -1 return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"You are given a string `s` consisting of only characters \'a\' and \'b\'. You can perform the following operation as many times as you want (including zero): select any two adjacent characters and replace them with another character (\'a\' can be replaced with \'b\' or \'b\' can be replaced with \'a\'). Your goal is to make the string such that no two adjacent characters are the same. Return the minimum number of operations needed to achieve this.","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations needed to make the string s such that no two adjacent characters are the same. # Initialize counters for both alternating patterns operations_1 = 0 # For pattern starting with \'a\' operations_2 = 0 # For pattern starting with \'b\' for i, char in enumerate(s): if i % 2 == 0: if char != \'a\': operations_1 += 1 if char != \'b\': operations_2 += 1 else: if char != \'b\': operations_1 += 1 if char != \'a\': operations_2 += 1 # Minimum of the operations needed for both patterns return min(operations_1, operations_2)"},{"question":"You are given a **2D** array `obstacles` where `obstacles[i] = [xi, yi]` represents obstacles on a `m x n` grid. You are to find a path from the top-left corner of the grid `(0, 0)` to the bottom-right corner `(m-1, n-1)` while avoiding obstacles. You can only move **up**, **down**, **left**, or **right**, and you cannot pass through cells containing obstacles. Return _the length of the shortest path from the start to the goal, or -1 if no such path exists_. **Note**: The start and goal cells will not be obstacles.","solution":"from collections import deque def shortest_path(m, n, obstacles): Returns the length of the shortest path from (0,0) to (m-1,n-1) in a grid with obstacles represented as (xi, yi). If there is no such path, returns -1. directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] obstacle_set = set(map(tuple, obstacles)) if (0, 0) in obstacle_set or (m-1, n-1) in obstacle_set: return -1 queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (m-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and (nx, ny) not in obstacle_set: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Write a function that takes an array of integers and an integer `k`, and returns all unique pairs of integers in the array that sum to `k`. The pairs should be in ascending order based on the first element of the pair. Each pair should be sorted in ascending order.","solution":"def find_pairs_with_sum(arr, k): Returns all unique pairs of integers in the array that sum to k. Each pair and pairs themselves are sorted in ascending order. Params: arr (list of int): The list of integers. k (int): The target sum. Returns: list of tuples: A list of unique pairs that sum to k. # Use a set to keep track of pairs to avoid duplicates seen = set() output = set() for num in arr: target = k - num if target in seen: # Add the pair in sorted order output.add(tuple(sorted((num, target)))) seen.add(num) # Convert the output set to a sorted list return sorted(output)"},{"question":"You are given an `m x n` grid of characters and a list of strings `words`. Your task is to find all the words that are present in the grid. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once for constructing a word. Return all words found in the grid, without duplicates. The words can appear in any order.","solution":"def findWords(board, words): def backtrack(r, c, parent): letter = board[r][c] curr_node = parent[letter] word_match = curr_node.pop(\'#\', False) if word_match: result.add(word_match) # Mark the cell as visited board[r][c] = \'#\' for (dr, dc) in ((0, 1), (1, 0), (0, -1), (-1, 0)): nr, nc = r + dr, c + dc if 0 <= nr < len(board) and 0 <= nc < len(board[0]): if board[nr][nc] in curr_node: backtrack(nr, nc, curr_node) board[r][c] = letter if not curr_node: parent.pop(letter) def addWord(word): node = trie for letter in word: node = node.setdefault(letter, {}) node[\'#\'] = word trie = {} for word in words: addWord(word) result = set() for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in trie: backtrack(row, col, trie) return list(result)"},{"question":"Given an array of integers `arr`, find and return the length of the longest contiguous subarray where the absolute difference between any two elements of the subarray is less than or equal to `1`. Use a sliding window technique to optimize the search for the longest subarray satisfying the condition.","solution":"def longest_contiguous_subarray(arr): Returns the length of the longest contiguous subarray where the absolute difference between any two elements of the subarray is less than or equal to 1. if not arr: return 0 n = len(arr) max_len = 1 start = 0 for end in range(1, n): while start <= end and (max(arr[start:end+1]) - min(arr[start:end+1]) > 1): start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an integer array `nums`. Two integers `nums[i]` and `nums[j]` form an **important pair** if `i < j` and `nums[i] > 2 * nums[j]`. Return _the number of important pairs in the array_.","solution":"def count_important_pairs(nums): Returns the number of important pairs in the array nums where i < j and nums[i] > 2 * nums[j]. def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, temp_arr, left, mid) count += merge_sort_and_count(arr, temp_arr, mid + 1, right) count += merge_and_count(arr, temp_arr, left, mid, right) return count def merge_and_count(arr, temp_arr, left, mid, right): i = left # Initial index for left subarray j = mid + 1 # Initial index for right subarray k = left # Initial index to be sorted count = 0 # Count important pairs while i <= mid and j <= right: if arr[i] > 2 * arr[j]: count += (mid - i + 1) j += 1 else: i += 1 i = left j = mid + 1 # Merge the two subarrays into temp_arr while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return count n = len(nums) temp_arr = [0] * n return merge_sort_and_count(nums, temp_arr, 0, n - 1)"},{"question":"Given an array of integers `profits` where `profits[i]` represents the profit from the i-th project, and an integer `k` which represents the maximum number of projects you can select, return the maximum total profit you can achieve by selecting at most `k` projects. You must choose a set of projects such that their indices are non-overlapping and miminize the total number of selected projects in each case of the same total profit.","solution":"def max_total_profit(profits, k): Returns the maximum total profit by selecting at most k projects with non-overlapping indices. profits.sort(reverse=True) if k >= len(profits): return sum(profits) return sum(profits[:k])"},{"question":"You are given a list of integers `prices` representing the prices of a collection of products on different days. You can only purchase one product per day, and you can buy the products on any days you choose. Additionally, you can apply a special discount once, which will reduce any one price to zero. Return the minimum total cost required to purchase all the products. Note that you can apply the discount to any product price in the list.","solution":"def minimum_total_cost(prices): Returns the minimum total cost required to purchase all products in the list, given that one product\'s price can be reduced to zero using a special discount. if not prices: return 0 return sum(prices) - max(prices)"},{"question":"A binary string is a string that consists only of the characters `0` and `1`. Given a binary string `s`, you need to find the length of the longest contiguous segment of `1`s. Write a function `longestContiguousOnes` that takes a binary string `s` as its input and returns an integer that represents the length of the longest continuous segment of `1`s in the string.","solution":"def longestContiguousOnes(s): Returns the length of the longest contiguous segment of 1\'s in the binary string s. max_length = current_length = 0 for char in s: if char == \'1\': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"You are given a 2D grid of size `m x n` consisting of non-negative integers representing the elevation at each point `(i, j)`. You are initially positioned at the top-left corner `(0, 0)` and want to reach the bottom-right corner `(m-1, n-1)`. During each step, you can move to any neighboring point (left, right, up, down) with at most a difference of `d` in elevation between the current cell and the destination cell. Return the minimum `d` such that it is possible to travel from `(0, 0)` to `(m-1, n-1)` without exceeding an elevation difference of `d`.","solution":"from collections import deque def min_elevation_difference(grid): Given a 2D grid representing elevations, finds the minimum value `d` such that one can travel from the top-left corner to the bottom-right corner without exceeding an elevation difference of `d`. Uses binary search and BFS to determine the minimum `d`. def can_pass(grid, m, n, mid): # BFS to check if we can travel from (0, 0) to (m-1, n-1) with the given elevation difference `mid` directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m-1 and y == n-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and abs(grid[nx][ny] - grid[x][y]) <= mid: visited[nx][ny] = True queue.append((nx, ny)) return False if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) low, high = 0, max(max(row) for row in grid) while low < high: mid = (low + high) // 2 if can_pass(grid, m, n, mid): high = mid else: low = mid + 1 return low"},{"question":"Given a list of `n` events where each event is represented as a tuple `(start, end)` corresponding to its starting and ending time, find a way to schedule the maximum number of non-overlapping events. Assume that if one event ends at time `t`, another event can start at the same time `t`. Implement the function `findMaxEvents(events)` that returns the maximum number of non-overlapping events that can be attended. ```python # Function signature def findMaxEvents(events: List[Tuple[int, int]]) -> int: pass ```","solution":"from typing import List, Tuple def findMaxEvents(events: List[Tuple[int, int]]) -> int: Schedule the maximum number of non-overlapping events. Parameters: events (List[Tuple[int, int]]): List of events where each event is represented by a tuple (start, end). Returns: int: Maximum number of non-overlapping events. # Sort the events based on the ending time events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = float(\'-inf\') for start, end in events: # If the event starts after or when the last event ends, we can attend it if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"You are given a **2D binary matrix** where `0` represents land and `1` represents water. An island is a maximal group of `1`s connected **horizontally**, **vertically**, or **diagonally**, and surrounded by `0`s or the matrix boundary. Given the matrix, return _the size of the largest island_. The size of an island is the number of `1`s in the island. Implement the `LargestIslandFinder` class: * `LargestIslandFinder(int[][] matrix)` Initializes the object with the provided matrix. * `int findLargestIsland()` Returns the size of the largest island in the matrix.","solution":"class LargestIslandFinder: def __init__(self, matrix): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows else 0 def findLargestIsland(self): def dfs(x, y): if x < 0 or y < 0 or x >= self.rows or y >= self.cols or self.matrix[x][y] == 0: return 0 count = 1 self.matrix[x][y] = 0 # mark as visited for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: count += dfs(x + dx, y + dy) return count max_size = 0 for i in range(self.rows): for j in range(self.cols): if self.matrix[i][j] == 1: island_size = dfs(i, j) max_size = max(max_size, island_size) return max_size"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can delete any substring \\"ab\\" or \\"ba\\" from the string in one operation. After performing any number of such operations, determine the minimum possible length of the resulting string. Output the minimum possible length of the string after all possible deletions.","solution":"def minimum_possible_length(s): Determines the minimum possible length of the resulting string after performing all possible deletions of substrings \\"ab\\" and \\"ba\\". a_count = s.count(\'a\') b_count = s.count(\'b\') # The remaining length is the difference in the count of \'a\' and \'b\' # if the counts are not equal, or 0 if they are equal return abs(a_count - b_count)"},{"question":"You are given a binary tree represented by `root`, where each node contains an integer value. Return the number of **univalue subtrees** in the tree. A **univalue subtree** is a subtree where all nodes have the same value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def countUnivalSubtrees(root): Counts the number of univalue subtrees in a binary tree. def is_unival(node, parent_val): if not node: return True left_is_unival = is_unival(node.left, node.val) right_is_unival = is_unival(node.right, node.val) if left_is_unival and right_is_unival: nonlocal count count += 1 return node.val == parent_val return False count = 0 is_unival(root, None) return count"},{"question":"You are given a **0-indexed** array of integers `nums`. Each integer in `nums` represents the height of a building. An ocean is to the right of the array (beyond the last element). A building has an \\"ocean view\\" if all buildings to its right have a smaller height. Return _an integer array_ `answer` _, where each element is the index of a building that has an \\"ocean view\\"_. For example, consider the array `[4, 2, 3, 1]`. The buildings at indices `0`, `2`, and `3` have an ocean view, so the answer would be `[0, 2, 3]`. Ensure that the buildings appear in the answer array in the same order as they do in `nums`.","solution":"def findBuildingsWithOceanView(nums): Returns the indices of buildings that have an ocean view. A building has an ocean view if all buildings to its right have a smaller height. :param nums: List[int] - heights of the buildings :return: List[int] - indices of buildings that have ocean view if not nums: return [] n = len(nums) result = [] max_height_so_far = float(\'-inf\') # Traverse from right to left to find ocean view buildings for i in range(n - 1, -1, -1): if nums[i] > max_height_so_far: result.append(i) max_height_so_far = nums[i] # The results need to be in ascending order of indices, so reverse the result return result[::-1]"},{"question":"Given a binary tree, implement a function that returns the **right view** of the tree. The right view of a binary tree is the set of nodes visible when the tree is viewed from the right side. A binary tree node is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } ``` Write a function: ```python def rightSideView(root: TreeNode) -> List[int]: ``` The function should take the root node of a binary tree and return a list of integers representing the right view of the tree.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] level = [root] while level: current_level_values = [node.val for node in level] result.append(current_level_values[-1]) next_level = [] for node in level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) level = next_level return result"},{"question":"You are given an array of integers `nums`. You can rotate the array by moving the last element of the array to the first position. You can perform this operation any number of times. Your task is to find the minimum possible value of the array that can be obtained after some number of rotations. The array is said to be in a valid state when the first element of the array is the smallest element of the array. Return _the minimum possible value of the first element of the array in a valid state_.","solution":"def find_min_possible_value(nums): Returns the minimum possible value for the first element after rotations. return min(nums)"},{"question":"Design a system that manages a team\'s work schedule. The system should allocate tasks to team members based on their availability and skill level. You are given a list of `n` tasks, where each task has a duration and a required skill level. You are also given a list of `m` team members, where each member has a unique ID, availability, and skill level. The goal is to assign each task to a team member such that: 1. Each team member can only handle one task at a time. 2. The team member\'s skill level must be equal to or higher than the required skill level of the task. 3. A team member can only be assigned a task if they are available during the task\'s duration. Return a list of `n` tuples, where each tuple contains the task ID and the assigned team member\'s ID. If a task cannot be assigned to any team member, return `-1` for that task\'s assignment. ___ Note: - The input will include the task list which contains task IDs, durations, and required skill levels. - The team member list will include member IDs, availability ranges, and skill levels. - Ensure the function is efficient and can handle large inputs within a reasonable time frame.","solution":"def assign_tasks_to_team(tasks, team_members): Assign tasks to team members based on their availability and skill level. Parameters: tasks (list of tuples): A list of tasks where each task is represented as (task_id, duration, required_skill). team_members (list of tuples): A list of team members where each member is represented as (member_id, availability_start, availability_end, skill_level). Returns: list of tuples: A list of assignments where each assignment is represented as (task_id, assigned_member_id). If no team member can be assigned to a task, the assigned_member_id is -1. assignments = [] for task_id, duration, required_skill in tasks: task_assigned = False for member_id, availability_start, availability_end, skill_level in team_members: if skill_level >= required_skill and availability_end - availability_start >= duration: assignments.append((task_id, member_id)) team_members = [(m_id, av_start, av_end, sk_lvl) for m_id, av_start, av_end, sk_lvl in team_members if m_id != member_id] task_assigned = True break if not task_assigned: assignments.append((task_id, -1)) return assignments"},{"question":"You are given a binary tree with `n` nodes where each node is labeled from `0` to `n-1`. Each node has a value associated with it, given in the array `values` where `values[i]` represents the value of the `ith` node. Each node can have either 0, 1, or 2 children. Your task is to find the longest path in the tree such that the sum of the node values along the path is the highest. return _the length of this path_. The tree is represented using an array `children`, where `children[i]` is a list containing the children of the `ith` node.","solution":"def longest_path_with_max_sum(values, children): def dfs(node): if not node in children or not children[node]: return (values[node], 1) max_sum = -float(\'inf\') max_path_length = 0 for child in children[node]: child_sum, child_len = dfs(child) if child_sum > max_sum: max_sum = child_sum max_path_length = child_len return (values[node] + max_sum, max_path_length + 1) overall_max_length = 0 for node in range(len(values)): node_sum, node_len = dfs(node) overall_max_length = max(overall_max_length, node_len) return overall_max_length"},{"question":"A tree is an undirected graph in which any two vertices are connected by exactly one path. Moreover, any connected graph with `n` nodes and `n-1` edges is a tree. You are given a tree represented by a `0-indexed` integer array `parents`, where `parents[i]` is the parent of the `i-th` node. The root of the tree is at node `0`, so `parents[0]` is `-1` since it has no parent. Your task is to calculate the maximum distance between any two nodes in the tree. The distance between any two nodes is the number of edges on the path between them. Given the array `parents`, return the maximum distance in the tree.","solution":"def tree_diameter(parents): from collections import defaultdict, deque def bfs(start): Helper function to perform BFS and return the farthest node and its distance queue = deque([start]) visited = set([start]) distance = {start: 0} farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) distance[neighbor] = distance[node] + 1 if distance[neighbor] > distance[farthest_node]: farthest_node = neighbor return farthest_node, distance[farthest_node] # Build the adjacency list for the tree n = len(parents) graph = defaultdict(list) for child, parent in enumerate(parents): if parent != -1: graph[parent].append(child) graph[child].append(parent) # Perform BFS from the root (node 0) to find the farthest node from it farthest_node, _ = bfs(0) # Perform BFS from the farthest node found in the previous step to find the maximum distance farthest_node, max_distance = bfs(farthest_node) return max_distance"},{"question":"You are given a list of airline routes represented by a list of tuples where each tuple `(source, destination)` indicates there is an available flight route from `source` to `destination`. Write a function that determines whether you can travel from the starting city `start` to the destination city `end` using the available routes. Return `True` if a valid path exists, otherwise return `False`. **Example:** Input: - routes = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\")] - start = \\"A\\" - end = \\"E\\" Output: - True Input: - routes = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\")] - start = \\"A\\" - end = \\"E\\" Output: - False","solution":"def can_travel(routes, start, end): Determines if you can travel from start city to end city using the available routes. :param routes: List[Tuple[str, str]] - List of available routes as (source, destination) pairs. :param start: str - The starting city. :param end: str - The destination city. :return: bool - True if there is a valid path from start to end, otherwise False. from collections import defaultdict, deque # Create a graph from the routes graph = defaultdict(list) for source, destination in routes: graph[source].append(destination) # Perform a BFS to find if there is a path from start to end queue = deque([start]) visited = set() while queue: current = queue.popleft() if current == end: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"You are given an array of integers `nums` and an integer `target`. Find all unique pairs of integers in the array that sum up to `target`. Each pair must be sorted i.e., the smaller number must appear first. The solution set must not contain duplicate pairs. Implement a function `List<List<Integer>> findPairs(int[] nums, int target)` that returns a list of lists of integers representing all the unique pairs that sum up to `target`. The pairs inside the lists should also be sorted in ascending order based on the first element of the pair and then the second element.","solution":"def find_pairs(nums, target): Returns a list of unique pairs of integers from nums that sum up to target. Each pair is sorted, and the output list is sorted in ascending order based on the first element of the pair and then the second element. nums.sort() # sort nums to handle pairs and avoid duplicates easily pairs = [] seen = set() lookup = {} for num in nums: difference = target - num if difference in lookup: pair = (min(num, difference), max(num, difference)) if pair not in seen: seen.add(pair) pairs.append(pair) lookup[num] = True pairs.sort() # sort pairs for the output return pairs"},{"question":"Given a 2D grid of integers `grid` representing the layout of a city, where `1` represents a building and `0` represents an empty space, find the distance of the shortest path from an empty space to any building. You can move in four possible directions (up, down, left, right), and you must not move diagonally. If it is impossible to reach any building from an empty space, return `-1`. Implement the class `CityGrid` with the following method: * `int shortestPathToBuilding(int[][] grid)` which returns the shortest distance from any empty space to a building, or `-1` if no such path exists.","solution":"from collections import deque class CityGrid: def shortestPathToBuilding(self, grid): def bfs(start): q = deque([start]) visited = set([start]) dist = 0 while q: size = len(q) for _ in range(size): x, y = q.popleft() if grid[x][y] == 1: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: visited.add((nx, ny)) q.append((nx, ny)) dist += 1 return float(\'inf\') min_dist = float(\'inf\') for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: min_dist = min(min_dist, bfs((i, j))) return min_dist if min_dist != float(\'inf\') else -1"},{"question":"Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. You may assume that it is a perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). The binary tree is provided in the form of the `TreeNode` class where `TreeNode` has attributes `val` (representing its value), `left` (representing the left child), `right` (representing the right child), and `next` (representing the next right node pointer). Return the modified tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Populates each next pointer to point to its next right node. If there is no next right node, the next pointer is set to None. Assumes root is the root of a perfect binary tree. if not root: return root # Start with the root node level_start = root while level_start: current = level_start while current: if current.left: # Connect left child to right child current.left.next = current.right # Connect right child to the next node\'s left child if next exists if current.next: current.right.next = current.next.left current = current.next # Move to the next level level_start = level_start.left return root"},{"question":"You are given an array `sticks` of length `n`, each representing the length of a stick. Your goal is to determine if you can form a square using all the given sticks. Each stick must be used exactly once, and each side of the square must have the same length. Return a boolean indicating whether it is possible to form such a square.","solution":"def makesquare(sticks): Determines whether we can form a square using all the given sticks. Parameters: sticks (List[int]): List of lengths of the sticks. Returns: bool: True if a square can be formed, False otherwise. if not sticks: return False total_length = sum(sticks) if total_length % 4 != 0: return False side_length = total_length // 4 sticks.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(sticks): return sides[0] == sides[1] == sides[2] == sides[3] == side_length for i in range(4): if sides[i] + sticks[index] <= side_length: sides[i] += sticks[index] if dfs(index + 1): return True sides[i] -= sticks[index] return False return dfs(0)"},{"question":"Given a list of integers `nums`, return _a list of all 0-indexed quadruplets `[a, b, c, d]` such that `nums[a] + nums[b] + nums[c] + nums[d] == target`_. You may return the answer in **any order**. The solution should not contain duplicate quadruplets.","solution":"def four_sum(nums, target): Given a list of integers `nums`, return a list of all 0-indexed quadruplets [a, b, c, d] such that nums[a] + nums[b] + nums[c] + nums[d] == target. The solution should not contain duplicate quadruplets. nums.sort() quadruplets = set() n = len(nums) for i in range(n): for j in range(i + 1, n): left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return [list(quad) for quad in quadruplets]"},{"question":"Given a list of strings `words`, you need to find the longest string `s` such that `s` is a concatenation of distinct words from `words` list and each word can be used at most once. If there are multiple results, return the lexicographically smallest one. Return an empty string if there is no valid string that meets the conditions. **Note:** You can assume all words in `words` are lowercase and do not contain spaces.","solution":"def longest_concatenation(words): Returns the longest concatenation of distinct words from words list where each word can be used at most once. If there are multiple results, returns the lexicographically smallest one. from itertools import permutations longest_word = \\"\\" words_sorted = sorted(words) for i in range(1, len(words)+1): for perm in permutations(words_sorted, i): candidate = \'\'.join(perm) if len(candidate) > len(longest_word) or (len(candidate) == len(longest_word) and candidate < longest_word): longest_word = candidate return longest_word"},{"question":"Given a string `s` which consists of lowercase letters and one integer `k`, determine whether it is possible to rearrange the characters in the string such that every character appears at least once every `k` positions. Return `true` if such an arrangement is possible, otherwise return `false`.","solution":"from collections import Counter from heapq import heappush, heappop def can_rearrange(s, k): if k == 0: return True # With k = 0, we do not need any specific arrangement counter = Counter(s) max_heap = [] for char, freq in counter.items(): if freq > (len(s) + 1) // k: return False # If the frequency of a character is too high to be spaced by k positions heappush(max_heap, (-freq, char)) queue = [] while max_heap: freq, char = heappop(max_heap) freq = -freq s = s.replace(char, \'\', freq) if len(queue) == k: freq, char = queue.pop(0) if freq > 0: heappush(max_heap, (-freq, char)) freq -= 1 if freq > 0: queue.append((freq, char)) return not max_heap"},{"question":"Given an array of integers `nums` and an integer `k`, find the **k-th smallest pair distance** between any two elements in the array. The pair distance between `nums[i]` and `nums[j]` is defined as `|nums[i] - nums[j]|` (the absolute difference between the two elements). Return the `k`-th smallest pair distance in the array.","solution":"def smallest_distance_pair(nums, k): Returns the k-th smallest pair distance between any two elements in the array. nums.sort() def count_pairs(mid): count = 0 left = 0 for right in range(len(nums)): while nums[right] - nums[left] > mid: left += 1 count += right - left return count low, high = 0, nums[-1] - nums[0] while low < high: mid = (low + high) // 2 if count_pairs(mid) < k: low = mid + 1 else: high = mid return low"},{"question":"You are given a list of integers `nums` and an integer `k`. You need to determine if there exists a **subarray** of size at least `k` such that the sum of its elements is greater than or equal to 0. Return `true` if such a subarray exists, otherwise return `false`. A **subarray** is a contiguous portion of an array. For example, given `nums = [1, -1, 2, -3, 4]` and `k = 2`, the subarray `[2, -3, 4]` is of size 3 and has a sum of 3, so the function should return `true`.","solution":"def subarray_with_non_negative_sum(nums, k): Determines if there exists a subarray of length at least k with a sum >= 0. :param nums: List[int] - The list of integers. :param k: int - The minimum length of the subarray. :return: bool - True if such a subarray exists, False otherwise. n = len(nums) if n == 0 or k > n: return False # Compute the prefix sums prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1] # Find subarray of at least length k with non-negative sum for i in range(k, n + 1): for j in range(i - k, -1, -1): if prefix_sum[i] - prefix_sum[j] >= 0: return True return False"},{"question":"Implement an iterator class named `ConsonantIterator` that iterates over only the consonants in a given string. The class should support the following methods: 1. **Constructor(string s)**: Accepts a string `s` and initializes the iterator. 2. **hasNext()**: Returns `true` if there is another consonant in the string; otherwise, returns `false`. 3. **next()**: Returns the next consonant in the string. If there are no more consonants, this method should throw a `StopIteration` exception. A consonant is defined as any alphabetical character that is not a vowel (`a, e, i, o, u`). The iterator should be case-insensitive, meaning it treats uppercase and lowercase letters as the same. Example: ``` ConsonantIterator iterator = new ConsonantIterator(\\"hello\\"); iterator.hasNext(); // true iterator.next(); // \'h\' iterator.hasNext(); // true iterator.next(); // \'l\' iterator.hasNext(); // true iterator.next(); // \'l\' iterator.hasNext(); // false iterator.next(); // throws StopIteration exception ```","solution":"class ConsonantIterator: def __init__(self, s): self.string = s self.current_index = 0 self.consonants = [] for char in self.string: if char.isalpha() and char.lower() not in \'aeiou\': self.consonants.append(char) def hasNext(self): return self.current_index < len(self.consonants) def next(self): if not self.hasNext(): raise StopIteration(\\"No more consonants in the string.\\") next_consonant = self.consonants[self.current_index] self.current_index += 1 return next_consonant"},{"question":"Given an array of integers `arr`, find and return the length of the **shortest subarray** that, if sorted, results in the entire array being sorted in non-decreasing order. If the array is already sorted, return `0`. For example: - If the input is `arr = [2, 6, 4, 8, 10, 9, 15]`, then the shortest subarray that can be sorted to achieve a fully sorted array is `[6, 4, 8, 10, 9]`, and since its length is 5, the function should return `5`. - If the input is `arr = [1, 2, 3, 4, 5]`, the array is already sorted, so the function should return `0`.","solution":"def find_unsorted_subarray_length(arr): Returns the length of the shortest subarray that if sorted makes the entire array sorted. If the array is already sorted, returns 0. :param arr: List[int] - The input array :return: int - The length of the shortest subarray n = len(arr) if n <= 1: return 0 start, end = -1, -1 # Find the first element out of order from the start for i in range(1, n): if arr[i] < arr[i - 1]: start = i - 1 break if start == -1: # Array is already sorted return 0 # Find the first element out of order from the end for j in range(n - 2, -1, -1): if arr[j] > arr[j + 1]: end = j + 1 break # Find the minimum and maximum elements in the subarray arr[start:end+1] subarray_min = min(arr[start:end+1]) subarray_max = max(arr[start:end+1]) # Extend start to the left while arr[start] > subarray_min while start > 0 and arr[start - 1] > subarray_min: start -= 1 # Extend end to the right while arr[end] < subarray_max while end < n - 1 and arr[end + 1] < subarray_max: end += 1 return end - start + 1"},{"question":"You are given an unsorted array of integers `nums` where the integers are in the range `1` to `n` and some elements appear twice while others appear once. Find all the elements that appear twice in the array. Return the duplicated integers in any order. Write a function that implements this. Try to do it in `O(n)` time and without using extra space.","solution":"def find_duplicates(nums): Finds all the elements that appear twice in the list nums. :param nums: List[int] - List of integers where 1 <= nums[i] <= n (n = len(nums)) :return: List[int] - List of duplicated integers duplicates = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: duplicates.append(abs(nums[i])) else: nums[index] = -nums[index] return duplicates"},{"question":"You are given a string `s` containing only lowercase English letters. You can apply the following operation any number of times: choose a non-empty substring of `s` and delete it if the substring appears at least twice in `s`. Your goal is to determine if you can make the entire string empty after performing the operation any number of times. Return `True` if you can achieve this, otherwise return `False`.","solution":"def can_empty_string(s: str) -> bool: Determines if the entire string can be made empty by deleting substrings appearing at least twice in the string. n = len(s) if n == 0: return True # Using dynamic programming to check if we can empty the string dp = [False] * (n + 1) dp[0] = True # Base case: an empty string is considered empty for i in range(1, n + 1): for length in range(1, i + 1): substring = s[i-length:i] if s.count(substring) > 1 and dp[i-length]: dp[i] = True break return dp[n]"},{"question":"You are given a 2D grid of size `m x n` representing a map of land and water cells. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write a function that returns the number of islands. An island is defined as a group of connected `1`s (representing land) surrounded by `0`s (representing water). The function signature is `int numIslands(vector<vector<char>>& grid)`, where `grid` is a 2D vector containing \'1\'s and \'0\'s.","solution":"def numIslands(grid): Returns the number of islands in the given grid. An island is defined as a group of connected \'1\'s (land) surrounded by \'0\'s (water). Parameters: grid (List[List[str]]): 2D grid of \'1\'s and \'0\'s Returns: int: Number of islands if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark the land as visited by sinking it dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) number_of_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': number_of_islands += 1 dfs(grid, i, j) return number_of_islands"},{"question":"Given two strings `s` and `t`, return the length of the shortest in-between substring of `s` that contains all the characters of `t`. If there is no such substring, return `-1`.","solution":"def min_window(s, t): Returns the length of the shortest substring of `s` that contains all the characters of `t`. If no such substring exists, returns `-1`. from collections import Counter if not s or not t: return -1 t_counter = Counter(t) current_counter = {} required_chars = len(t_counter) formed_chars = 0 left = 0 min_length = float(\\"inf\\") min_length_result = -1 for right, char in enumerate(s): current_counter[char] = current_counter.get(char, 0) + 1 if char in t_counter and current_counter[char] == t_counter[char]: formed_chars += 1 while left <= right and formed_chars == required_chars: if (right - left + 1) < min_length: min_length = right - left + 1 min_length_result = min_length current_counter[s[left]] -= 1 if s[left] in t_counter and current_counter[s[left]] < t_counter[s[left]]: formed_chars -= 1 left += 1 return min_length_result if min_length != float(\\"inf\\") else -1"},{"question":"You are given an integer array `nums` and an integer `k`. The array contains positive numbers only. Your task is to find the number of contiguous subarrays where the product of all the elements in the subarray is less than `k`. Return _this number as an integer_. Ensure your solution runs in `O(n)` time using a sliding window approach.","solution":"def num_subarray_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all the elements in the subarray is less than k. :param nums: List[int] - list of positive integers :param k: int - the threshold product value :return: int - count of such subarrays if k <= 1: return 0 left = 0 product = 1 count = 0 for right in range(len(nums)): product *= nums[right] while product >= k: product //= nums[left] left += 1 count += (right - left + 1) return count"},{"question":"Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations_ in **any order**. Each permutation should be a list of numbers, and no duplicate permutations are allowed in the final output.","solution":"from typing import List from itertools import permutations def unique_permutations(nums: List[int]) -> List[List[int]]: Return all unique permutations of the input list nums. # Get all permutations of the list nums all_perms = permutations(nums) # Use a set to avoid duplicates unique_perms = set(all_perms) # Convert each tuple in the set to a list return [list(perm) for perm in unique_perms]"},{"question":"You are given two strings `order` and `strs`. `order` is a permutation of the lowercase English letters indicating the desired order of characters. `strs` is a string that needs to be custom sorted according to the `order`. Sort `strs` such that the characters appear in the order defined by `order`. If a character is not present in `order`, it should appear at the end of `strs` in its original relative order. Return the sorted string.","solution":"def custom_sort_string(order, strs): Custom sorts the string `strs` according to the order defined in `order`. Characters not present in `order` appear at the end of `strs` in original relative order. Parameters: order (str): The string representing the desired order of characters. strs (str): The string to be sorted. Returns: str: The custom sorted string. order_map = {char: i for i, char in enumerate(order)} order_value = len(order_map) sorted_chars = sorted(strs, key=lambda x: (order_map.get(x, order_value), strs.index(x))) return \'\'.join(sorted_chars)"},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. You need to determine if you can convert `s` into `t` using the following operation any number of times: choose any character from `s` and change it to any other lowercase English letter. Return `true` if you can convert `s` to `t`, otherwise return `false`.","solution":"def can_convert(s, t): Determines if string `s` can be converted to string `t` using the given operations. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if `s` can be converted to `t`, False otherwise. if len(s) != len(t): return False if s == t: return True # Track character mappings from s to t s_to_t = {} t_mapped = set() for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False else: if char_t in t_mapped: return False s_to_t[char_s] = char_t t_mapped.add(char_t) return True"},{"question":"**[Question 4]:** You are given an array of integers `nums` and an integer `target`. Your task is to determine if there exist three integers in `nums` whose sum is equal to `target`. Return a tuple containing these three integers if such a triplet exists. If no such triplet exists, return an empty list. Ensure that the solution you provide considers any possibilities, including the case of duplicate numbers and multiple potential triplets.","solution":"def find_three_sum(nums, target): Determine if there exist three integers in nums whose sum is equal to target. Return a tuple containing these three integers if such a triplet exists. If no such triplet exists, return an empty list. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return (nums[i], nums[left], nums[right]) elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given a list of `n` integers, `nums`, and an integer `target`. Your task is to determine if there are any three integers in `nums` whose sum is exactly equal to `target`. Return a boolean value of `true` if such a combination exists and `false` if it does not. You may assume that all integers in `nums` are distinct.","solution":"def three_sum(nums, target): Determine if there are any three integers in nums whose sum is exactly equal to target. :param nums: List[int] - List of distinct integers :param target: int - Target sum :return: bool - True if such a combination exists, False otherwise nums.sort() n = len(nums) for i in range(n): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` containing only the characters `a` and `b`. You are allowed to perform two operations on the string any number of times: 1) remove one occurrence of `ab` from the string, or 2) remove one occurrence of `ba` from the string. Return _the **minimum length** of the string that can be obtained after performing the above operations any number of times._","solution":"def min_length_after_removals(s): Given a string containing only the characters \'a\' and \'b\', return the minimum length of the string that can be obtained after performing any number of removals of the pairs \'ab\' or \'ba\'. # Count the number of \'a\'s and \'b\'s in the string count_a = s.count(\'a\') count_b = s.count(\'b\') # The minimum length is the absolute difference between the counts of \'a\' and \'b\' min_length = abs(count_a - count_b) return min_length"},{"question":"Write a function that takes a string `s` consisting of only uppercase English letters and returns the same string in a zigzag pattern where characters are placed diagonally on successive lines in a specified number of rows `numRows`. Your function should reconstruct the string following a zigzag path starting from the top down to the bottom and then diagonally back up with the specified number of rows. If `numRows` is 1, the string should remain in its original order. Your solution should focus on efficiency in terms of time and space complexity.","solution":"def convert(s, numRows): Reconstruct the string to follow a zigzag pattern given the number of rows. :param s: String consisting of only uppercase English letters. :param numRows: Number of rows for the zigzag pattern. :return: String formatted in the zigzag pattern. if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * numRows curRow = 0 goingDown = False for char in s: rows[curRow] += char if curRow == 0 or curRow == numRows - 1: goingDown = not goingDown curRow += 1 if goingDown else -1 return \'\'.join(rows)"},{"question":"You are given an array of integers `heights` representing the heights of a group of students standing in a line. Each student `i` wants to see the board at the front of the class, but they can only see the board if there is no student taller than them standing in front. Return an array of integers where each element represents the number of students up to and including the ith student that can see the board.","solution":"def can_see_board(heights): Given heights of students in a line, returns an array representing the number of students up to and including the ith student that can see the board. Args: heights (List[int]): An array of integers representing the heights of students. Returns: List[int]: An array where each element i represents the number of students up to and including the ith student that can see the board. result = [] max_height_so_far = 0 for height in heights: if height > max_height_so_far: max_height_so_far = height result.append(max_height_so_far) return [result.index(h) + 1 for h in result] # Example usage: # heights = [1, 2, 3, 2, 1] # output: [1, 2, 3, 3, 3]"},{"question":"You are given a list of strings `words` and a list of characters `chips`. Each character in `chips` can be used once to form a subsequence of any word in `words`. Return _the length of the longest word_ that can be formed using characters from `chips`. If no words can be formed, return `0`. **Note:** A subsequence of a string is a new string generated by deleting some (or none) of the characters without disturbing the relative positions of the remaining characters.","solution":"def can_form_word(word, chips_count): word_count = {} for char in word: if char not in chips_count: return False word_count[char] = word_count.get(char, 0) + 1 if word_count[char] > chips_count[char]: return False return True def longest_word(words, chips): chips_count = {} for char in chips: chips_count[char] = chips_count.get(char, 0) + 1 max_length = 0 for word in words: if can_form_word(word, chips_count): max_length = max(max_length, len(word)) return max_length"},{"question":"You are given a matrix `grid` of `m` x `n` integers where each integer represents the height of a pillar. You can perform the following operation as many times as you want: - Pick any two adjacent pillars (sharing an edge) and adjust their heights so that the difference between their heights is at most 1 by either increasing the height of the lower pillar or decreasing the height of the higher pillar. Return _true if you can make all pillars in the matrix `grid` have the **same** height using the above operation and false otherwise._","solution":"def can_make_all_heights_equal(grid): Returns True if all the pillars in grid can be made the same height, otherwise False min_height = min(map(min, grid)) max_height = max(map(max, grid)) # The condition is that all pillars must be within a difference of 1 in any given operation. return max_height - min_height <= 1"},{"question":"Given an unsorted array of integers, return _a list of all possible quadruplets_ ([nums[i], nums[j], nums[k], nums[l]]) such that: 1. (i, j, k,) and (l) are four distinct indices. 2. (nums[i] + nums[j] + nums[k] + nums[l] = target). You may return the result in **any order**.","solution":"def four_sum(nums, target): Returns a list of all possible quadruplets [nums[i], nums[j], nums[k], nums[l]] such that: 1. i, j, k, and l are four distinct indices. 2. nums[i] + nums[j] + nums[k] + nums[l] = target. Args: nums: List of integers (unsorted). target: Target sum for the quadruplets. Returns: List of lists containing quadruplets. nums.sort() quadruplets = [] length = len(nums) for i in range(length-3): # Avoid duplicate if i > 0 and nums[i] == nums[i-1]: continue for j in range(i+1, length-2): # Avoid duplicate if j > i+1 and nums[j] == nums[j-1]: continue left, right = j+1, length-1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) # Avoid duplicate while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given a **0-indexed** integer array `tasks` of size `n`, where `tasks[i]` represents the time in minutes required to complete the `ith` task. Additionally, you are given an integer `sessionTime` representing the maximum duration of a work session in minutes. You need to organize the tasks into multiple work sessions such that the total duration of tasks in each session does not exceed `sessionTime`. Return the **minimum** number of work sessions required to complete all the tasks.","solution":"def min_sessions(tasks, sessionTime): def backtrack(i, current_sessions): if i == len(tasks): return len(current_sessions) min_sessions_needed = float(\'inf\') for j in range(len(current_sessions)): if current_sessions[j] + tasks[i] <= sessionTime: current_sessions[j] += tasks[i] min_sessions_needed = min(min_sessions_needed, backtrack(i + 1, current_sessions)) current_sessions[j] -= tasks[i] current_sessions.append(tasks[i]) min_sessions_needed = min(min_sessions_needed, backtrack(i + 1, current_sessions)) current_sessions.pop() return min_sessions_needed tasks.sort(reverse=True) return backtrack(0, [])"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the number of distinct integers in all the subarrays of `arr` of length `k`. Two subarrays are considered distinct if they contain at least one different integer, regardless of the order of integers within the subarrays. Return an array where the value at index `i` is the count of distinct integers in the subarray starting from index `i` to index `i+k-1` in `arr`. If the subarray starting at index `i` has a length less than `k`, the corresponding value should not be included in the output.","solution":"def count_distinct_in_subarrays(arr, k): Returns the number of distinct integers in all the subarrays of length k of `arr`. if k == 0 or k > len(arr): return [] result = [] window = {} distinct_count = 0 for i in range(len(arr)): if arr[i] in window: window[arr[i]] += 1 else: window[arr[i]] = 1 distinct_count += 1 if i >= k: if window[arr[i - k]] == 1: del window[arr[i - k]] distinct_count -= 1 else: window[arr[i - k]] -= 1 if i >= k - 1: result.append(distinct_count) return result"},{"question":"You are given a string `sentence` that consists of lowercase and uppercase alphabetic characters and empty spaces `\' \'`. A **word** is defined as any sequence of non-space characters. You need to **reverse the order** of the words in the sentence while preserving the spaces between them and ensuring the case of the individual characters stays unchanged. For example, the sentence \\"`Hello World`\\" should become \\"`World Hello`\\". Implement a function to return the resultant string with words in reversed order.","solution":"def reverse_words(sentence): Reverses the order of words in the given sentence while preserving spaces. :param sentence: str : The input sentence with words separated by spaces. :return: str : The sentence with words in reversed order. # Split the sentence into words and filter out any empty strings resulting from multiple spaces words = [word for word in sentence.split(\' \') if word] # Reverse the list of words reversed_words = words[::-1] # Join the reversed words with a single space to form the result result = \' \'.join(reversed_words) return result"},{"question":"Given a list of integers `nums`, return a list containing all the integers that appear more than once in `nums`. Each integer in the result should appear only once. You must achieve this in (O(n)) time complexity, where (n) is the length of the input list.","solution":"def find_duplicates(nums): Given a list of integers, return a list containing all the integers that appear more than once in the list. Each integer in the result should appear only once. Args: nums (List[int]): The input list of integers. Returns: List[int]: The list containing duplicates. count = {} result = [] for num in nums: if num in count: count[num] += 1 else: count[num] = 1 for num, cnt in count.items(): if cnt > 1: result.append(num) return result"},{"question":"You are given a matrix `grid` of size `m x n` consisting of only `0`s and `1`s. A group of `1`s is a connected component if it contains only adjacent `1`s connected either vertically or horizontally. The `perimeter` of a component is the number of `0`s either inside the grid or forming the boundary that surrounds it. Return _the **maximum perimeter** of any connected component in the grid_.","solution":"def max_perimeter_of_island(grid): Returns the maximum perimeter of any connected component in the grid. if not grid: return 0 def dfs(grid, x, y, visited): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 1 if (x, y) in visited: return 0 visited.add((x, y)) perimeter = 0 perimeter += dfs(grid, x - 1, y, visited) perimeter += dfs(grid, x + 1, y, visited) perimeter += dfs(grid, x, y - 1, visited) perimeter += dfs(grid, x, y + 1, visited) return perimeter max_perimeter = 0 visited = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: max_perimeter = max(max_perimeter, dfs(grid, i, j, visited)) return max_perimeter"},{"question":"Given an array of integers `arr` representing the lengths of various pieces of wood, and an integer `k` representing the number of friends you need to share the wood with, you need to determine the maximum length of wood that can be evenly cut and distributed to all friends. Each friend should receive the same length of wood and all pieces of wood must be fully utilized. If it is not possible to distribute the wood in such a manner, return 0.","solution":"def max_length_to_share_wood(arr, k): Determines the maximum length of wood that can be evenly cut and distributed to all friends. :param arr: List of integers representing lengths of various pieces of wood. :param k: Integer representing the number of friends to share the wood with. :return: Maximum length of wood that can be evenly distributed. Returns 0 if not possible. def can_cut(length): Helper function to check if wood can be cut into pieces of \'length\'. return sum(piece // length for piece in arr) >= k left, right = 1, max(arr) result = 0 while left <= right: mid = (left + right) // 2 if can_cut(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"A **mirror sequence** in an array is a subarray that reads the same forward and backward. Given an integer array `nums`, return the length of the longest mirror sequence within the array. A **subarray** is a contiguous portion of an array.","solution":"def longest_mirror_sequence(nums): Given an integer array nums, return the length of the longest mirror sequence within the array. n = len(nums) if n == 0: return 0 # Creating a table to store results of subproblems dp = [[0] * n for _ in range(n)] max_len = 1 # Every single element is a mirror sequence of length 1 for i in range(n): dp[i][i] = 1 # Build the table. Note that the lower diagonal values of the table are useless, # and not filled in the process. for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if nums[i] == nums[j] and cl == 2: dp[i][j] = 2 elif nums[i] == nums[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) max_len = max(max_len, dp[i][j]) return max_len"},{"question":"You are given a **directed graph** with `n` nodes and `m` edges, where each edge has a **weight**. The nodes are numbered from `1` to `n`. You need to find the length of the **shortest path** from a given source node `s` to a target node `t`. If there is no path from `s` to `t`, return `-1`. Note that the graph can contain negative weight edges, but will **not** contain negative weight cycles. The input is provided as three arrays: `edges`, `weights`, and `queries`. Each `query` in `queries` contains a source node and a target node where you should determine the shortest path length. Return an array `answer` where `answer[i]` is the length of the shortest path from the source to the target node for the `i-th` query.","solution":"import heapq def dijkstra(graph, start): # Implementation of Dijkstra\'s algorithm to find shortest paths from a single source n = len(graph) dist = [float(\'inf\')] * n dist[start] = 0 pq = [(0, start)] while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > dist[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist def shortest_path(n, edges, weights, queries): # Create adjacency list for the graph graph = [[] for _ in range(n)] for (u, v), w in zip(edges, weights): graph[u-1].append((v-1, w)) answers = [] for s, t in queries: # Compute shortest paths from source s using Dijkstra\'s algorithm dist = dijkstra(graph, s-1) shortest_dist = dist[t-1] answers.append(shortest_dist if shortest_dist != float(\'inf\') else -1) return answers"},{"question":"Given an array of integers `arr` and an integer `k`, find the number of contiguous subarrays where the product of all the elements in the subarray is less than `k`. **Note** that: * A subarray is a contiguous part of an array. **Example**: Input: `arr = [10, 5, 2, 6]`, `k = 100` Output: `8` Explanation: The subarrays that have products less than `100` are: `[10]`, `[5]`, `[2]`, `[6]`, `[10, 5]`, `[5, 2]`, `[2, 6]`, `[5, 2, 6]`.","solution":"def num_subarrays_with_product_less_than_k(arr, k): Given an array of integers arr and an integer k, finds the number of contiguous subarrays where the product of all elements in the subarray is less than k. if k <= 1: return 0 product = 1 left = 0 count = 0 for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product //= arr[left] left += 1 count += (right - left + 1) return count"},{"question":"You are given a **0-indexed** array `arr` of `n` integers. The **range sum query** on the array is defined as the sum of all integers between two given indices `left` and `right`, inclusive (i.e., `arr[left] + arr[left + 1] + ... + arr[right]`). You need to process multiple queries of this type efficiently. Each query is represented as a pair of integers `(left, right)`. Return _an array_ `results` _where_ `results[i]` _is the sum of the elements for the_ i-th query. To speed up the process, first preprocess the input array to create an auxiliary array that can be used to get the sum of elements in constant time. Example: - Input: `arr = [1, 2, 3, 4, 5]`, `queries = [(0, 2), (1, 3), (2, 4)]` - Output: `[6, 9, 12]`","solution":"def preprocess_array(arr): Preprocess the input array to create a prefix sum array. n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] return prefix_sum def range_sum_queries(arr, queries): Process the range sum queries using the prefix sum array. Parameters: arr (list of int): The input array. queries (list of tuples): List of queries where each query is a tuple (left, right). Returns: list of int: The result for each query. prefix_sum = preprocess_array(arr) results = [] for left, right in queries: sum_range = prefix_sum[right + 1] - prefix_sum[left] results.append(sum_range) return results"},{"question":"You are given a grid of size `m x n` filled with non-negative numbers representing the height of a terrain at each cell. You need to implement a class `WaterVolumeCalculator` that supports the following methods: 1. **Trap water** over the terrain grid. This method should calculate and return the total amount of water that can be trapped after raining, considering the heights of the surrounding cells. 2. **Update height** of a specific cell in the terrain grid. This method should update the height of the cell at the given row and column to a new height. Implement the `WaterVolumeCalculator` class: - `WaterVolumeCalculator(int[][] heightMap)` Initializes the object with a grid of terrain heights `heightMap`. - `int trapWater()` Returns the total amount of water that can be trapped over the terrain grid. - `void updateHeight(int row, int col, int newHeight)` Updates the height of the terrain at the given cell `heightMap[row][col]` to `newHeight`.","solution":"import heapq class WaterVolumeCalculator: def __init__(self, heightMap): self.heightMap = heightMap self.m = len(heightMap) self.n = len(heightMap[0]) if self.m > 0 else 0 def trapWater(self): if not self.heightMap or not self.m or not self.n: return 0 visited = [[False for _ in range(self.n)] for _ in range(self.m)] minHeap = [] waterTrapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Add all the boundary cells to the heap and mark them as visited for i in range(self.m): for j in range(self.n): if i == 0 or i == self.m - 1 or j == 0 or j == self.n - 1: heapq.heappush(minHeap, (self.heightMap[i][j], i, j)) visited[i][j] = True while minHeap: height, x, y = heapq.heappop(minHeap) for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < self.m and 0 <= ny < self.n and not visited[nx][ny]: visited[nx][ny] = True waterTrapped += max(0, height - self.heightMap[nx][ny]) heapq.heappush(minHeap, (max(height, self.heightMap[nx][ny]), nx, ny)) return waterTrapped def updateHeight(self, row, col, newHeight): self.heightMap[row][col] = newHeight"},{"question":"You are given an array of `n` integers, `arr`, and an integer `k`. A **subarray** is any contiguous part of the original array. Return _the minimum number of subarrays with a sum of at least_ `k`. If it is not possible to find such subarrays, return `-1`. **Note**: A subarray should contain at least one element.","solution":"def min_subarrays_with_sum_at_least_k(arr, k): Returns the minimum number of subarrays with sum at least k. If it is not possible to find such subarrays, return -1. n = len(arr) min_count = float(\'inf\') def find_min_count(start_index): current_sum = 0 for end_index in range(start_index, n): current_sum += arr[end_index] if current_sum >= k: return end_index - start_index + 1 return float(\'inf\') for i in range(n): min_count = min(min_count, find_min_count(i)) return -1 if min_count == float(\'inf\') else min_count"},{"question":"You are given a string `s` containing only lowercase letters, and you need to partition `s` into as few substrings as possible such that each substring contains unique characters only (i.e., no characters repeat within a substring). Return the minimum number of substrings in which you can split `s` and an array of the split substrings. The split should be done such that the order of characters remains the same as in the original string `s`. * Example: `s = \\"abac\\"`: `result = 2, substrings = [\\"ab\\",\\"ac\\"]` * Example: `s = \\"aabc\\"`: `result = 2, substrings = [\\"a\\",\\"abc\\"]` * Example: `s = \\"abcd\\"`: `result = 1, substrings = [\\"abcd\\"]`","solution":"def partition_unique_substrings(s): Partition the string `s` into as few substrings as possible such that each substring contains unique characters only. Returns the number of substrings and the list of substrings. substrings = [] current_sub = \\"\\" seen_chars = set() for char in s: if char in seen_chars: substrings.append(current_sub) current_sub = char seen_chars = {char} else: current_sub += char seen_chars.add(char) if current_sub: substrings.append(current_sub) return len(substrings), substrings"},{"question":"You are given a string `s` representing an alphanumeric sequence consisting of digits and lowercase English letters. Split the string into chunks of consecutive digits and chunks of consecutive letters. Then, reverse the order of the digits and letters respectively to form a new string. For example, if `s = \\"abc123def456\\"`, the new string would be `\\"cba321fed654\\"`. Return _the resulting string_ after performing the described operation.","solution":"import re def reverse_chunks(s): Returns a string where chunks of consecutive letters and digits are reversed. # Use regular expression to split the string into chunks of digits and letters chunks = re.findall(r\'d+|D+\', s) # Reverse each chunk reversed_chunks = [chunk[::-1] for chunk in chunks] # Join the reversed chunks to get the final string result = \'\'.join(reversed_chunks) return result"},{"question":"You are given an integer array `nums` consisting of `n` integers where `n` is even. The array is sorted in non-decreasing order. Your task is to partition the array into two subsets `A` and `B` such that: - The size of subset `A` is `k` (where `k = n / 2`) and the size of subset `B` is also `k`. - Both subsets should have the minimum possible absolute difference between their sums. Return the minimum possible absolute difference between the sums of the two subsets. **Note:** The sum of a subset is the sum of elements contained in the subset.","solution":"from itertools import combinations def min_difference(nums): Returns the minimum possible absolute difference between the sums of two subsets A and B. n = len(nums) k = n // 2 total_sum = sum(nums) min_diff = float(\'inf\') # Checking all combinations of k elements for comb in combinations(nums, k): subset_sum = sum(comb) current_diff = abs(total_sum - 2 * subset_sum) min_diff = min(min_diff, current_diff) return min_diff"},{"question":"Given a string `s` containing only lowercase English letters, return the length of the longest palindromic subsequence in `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no characters without changing the order of the remaining characters. For example, the longest palindromic subsequence of \\"bbbab\\" is \\"bbbb\\", with a length of 4. You must write an algorithm that runs in `O(n^2)` time where `n` is the length of the string.","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = 2 + dp[i + 1][j - 1] if i + 1 <= j - 1 else 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n-1]"},{"question":"You are given a 2D grid of size `m x n` representing a **maze** with `m` rows and `n` columns. Each cell of the maze is either an empty cell (\'.\') or a wall (\'#\'). You are also given a starting position `[startRow, startCol]` and a destination position `[endRow, endCol]`. You can move left, right, up, or down but cannot pass through walls. Write an algorithm to determine the **minimum number of steps** required to reach the destination from the start position. If it is not possible to reach the destination, return -1. **Note**: You can move only in the four cardinal directions (left, right, up, down).","solution":"from collections import deque def min_steps_to_reach_dest(maze, start, end): Returns the minimum number of steps required to reach the destination from the start position in a given maze. If the destination is not reachable, returns -1. m, n = len(maze), len(maze[0]) startRow, startCol = start endRow, endCol = end if maze[startRow][startCol] == \'#\' or maze[endRow][endCol] == \'#\': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startRow, startCol, 0)]) visited = set((startRow, startCol)) while queue: row, col, steps = queue.popleft() if (row, col) == (endRow, endCol): return steps for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < m and 0 <= newCol < n and maze[newRow][newCol] == \'.\' and (newRow, newCol) not in visited: visited.add((newRow, newCol)) queue.append((newRow, newCol, steps + 1)) return -1"},{"question":"You are given a **0-indexed** integer array `height` representing the heights of buildings in a city. The city has `n` buildings and it rains, creating water pools between the buildings. The goal is to calculate the total volume of water that can be trapped between the buildings after it rains. The amount of water trapped between two buildings can be determined by the shorter of the two building heights, minus the height of the terrain between them. Return _the total water volume trapped_ when it rains across all buildings. For example, if `height = [0,1,0,2,1,0,1,3,2,1,2,1]`, the total volume of water trapped is `6`.","solution":"def trap(height): Calculate the total volume of water that can be trapped between buildings. Args: height (List[int]): A list of integers representing the height of the buildings. Returns: int: Total volume of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Write a function `mostCommonElement(arr)` that takes a list of integers `arr` as input and returns the most common element in the list. If there are multiple elements with the same highest frequency, return the smallest one among them. For instance, given the list `[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]`, the function should return `4` since it appears most frequently in the list. However, for the list `[1, 2, 2, 3, 3, 4, 4]`, the function should return `2` because `2` and `4` have the highest frequency but `2` is the smaller of the two.","solution":"def mostCommonElement(arr): Returns the most common element in the list. If there are multiple elements with the same highest frequency, returns the smallest one among them. from collections import Counter if not arr: return None count = Counter(arr) max_frequency = max(count.values()) most_common_elements = [key for key, value in count.items() if value == max_frequency] return min(most_common_elements)"},{"question":"You are given an array of strings `words` and an integer `k`. A string is considered valid if it can be obtained by concatenating exactly `k` distinct words from the array in any order. Return the length of the longest valid string. If no valid string can be formed return 0.","solution":"from itertools import permutations def longest_valid_string(words, k): Returns the length of the longest valid string that can be formed by concatenating exactly k distinct words from the array. if k > len(words): return 0 max_length = 0 for combination in permutations(words, k): concatenated_str = \'\'.join(combination) max_length = max(max_length, len(concatenated_str)) return max_length"},{"question":"Given an integer array `nums` and an integer `target`, return _the **number of pairs** of indices `(i, j)` such that `i < j` and `nums[i] + nums[j]` is equal to `target`_. If there are no such pairs, return _0_. Aim to find an efficient solution with a time complexity better than O(n^2).","solution":"def count_pairs(nums, target): Returns the number of pairs of indices (i, j) such that i < j and nums[i] + nums[j] equals target. count = 0 complements = {} for i, num in enumerate(nums): complement = target - num if complement in complements: count += complements[complement] if num in complements: complements[num] += 1 else: complements[num] = 1 return count"},{"question":"You are given an **m x n** 2D grid initialized with multiple `0`s and exactly one `1`. You need to turn all the `0`s into `1`s by flipping a \'1\' over the grid, following these rules: - During one turn, you can move the `1` to any neighboring cell (top, bottom, left, or right) that contains a `0`. - You can only move the `1` to a `0` cell, and the cell you move to will become a `1`. Return the minimum number of turns needed to convert all `0`s in the grid to `1`s. If it is impossible to complete the task, return `-1`.","solution":"from collections import deque def min_turns_to_fill(grid): Returns the minimum number of turns needed to convert all `0`s to `1`s in the grid. Returns -1 if it is impossible. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) queue = deque() total_zeros = 0 # Scan the grid to find the initial position of the \'1\' and count total zeros for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) elif grid[i][j] == 0: total_zeros += 1 if total_zeros == 0: return 0 # No zeros to convert directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] turns = 0 # Perform BFS to spread \'1\'s across the grid while queue: turns += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: grid[nx][ny] = 1 queue.append((nx, ny)) total_zeros -= 1 if total_zeros == 0: return turns return -1 if total_zeros > 0 else turns"},{"question":"You are given an array of `n` integers `arr` and an integer `x`. Your task is to determine if there exist three distinct indices `i`, `j`, and `k` in the array such that `arr[i] + arr[j] + arr[k] = x`. Return `true` if such indices exist, otherwise, return `false`. Your solution should have a time complexity of `O(n^2)`.","solution":"def find_indices_with_sum(arr, x): Returns True if there exist three distinct indices i, j, k in the array such that arr[i] + arr[j] + arr[k] = x. Otherwise, returns False. n = len(arr) if n < 3: return False arr.sort() for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return True elif current_sum < x: left += 1 else: right -= 1 return False"},{"question":"Given an integer array `arr` consisting of distinct numbers, write a function to find all unique pairs of numbers in the array such that their sum is equal to a given target value `k`. Return an array of pairs sorted in ascending order by the first element of the pair, and if two pairs have the same first element, by the second element. Each pair should be represented as an array of two elements. For example, if `arr = [1, 2, 3, 4, 5, 6]` and `k = 7`, the unique pairs are `[[1, 6], [2, 5], [3, 4]]`. Return _the array of unique pairs_ sorted in the described order.","solution":"def find_pairs_with_sum(arr, k): Returns all unique pairs of numbers in the array whose sum is equal to k. arr.sort() left, right = 0, len(arr) - 1 pairs = [] while left < right: current_sum = arr[left] + arr[right] if current_sum == k: pairs.append([arr[left], arr[right]]) left += 1 right -= 1 elif current_sum < k: left += 1 else: right -= 1 return pairs"},{"question":"You are given a binary search tree (BST) with `n` nodes. Design an algorithm to convert the BST into a balanced binary search tree (a tree where the depth of the two subtrees of every node never differs by more than 1). Return _the root of the balanced binary search tree._","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root): Converts a given binary search tree into a balanced binary search tree. Returns the root of the balanced binary search tree. # Helper function to perform an in-order traversal # and collect nodes in sorted order def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Helper function to build a balanced BST from sorted nodes def build_balanced_bst(sorted_vals): if not sorted_vals: return None mid_idx = len(sorted_vals) // 2 root = TreeNode(sorted_vals[mid_idx]) root.left = build_balanced_bst(sorted_vals[:mid_idx]) root.right = build_balanced_bst(sorted_vals[mid_idx + 1:]) return root # Get the sorted values from the original BST sorted_vals = inorder_traversal(root) # Build and return a balanced BST return build_balanced_bst(sorted_vals)"},{"question":"You are given a string `s` that consists of lowercase letters and a non-negative integer `k`. You need to select a substring of `s` such that the length of the substring is `k` and the number of unique characters in that substring is maximized. Return the starting index of such a substring. If there are multiple possible answers, return the smallest starting index.","solution":"def max_unique_substring(s, k): Returns the starting index of the k-length substring in s with the maximum number of unique characters. If multiple such substrings exist, returns the smallest starting index. if k == 0 or k > len(s): return -1 max_unique_count = 0 max_unique_index = 0 current_unique_count = 0 count = {} for i in range(k): if s[i] not in count: count[s[i]] = 0 count[s[i]] += 1 if count[s[i]] == 1: current_unique_count += 1 max_unique_count = current_unique_count for i in range(k, len(s)): left_char = s[i - k] right_char = s[i] count[left_char] -= 1 if count[left_char] == 0: current_unique_count -= 1 if right_char not in count: count[right_char] = 0 count[right_char] += 1 if count[right_char] == 1: current_unique_count += 1 if current_unique_count > max_unique_count: max_unique_count = current_unique_count max_unique_index = i - k + 1 return max_unique_index"},{"question":"You are given an integer array `height` representing the heights of students in a class standing in a straight line. The students need to be re-arranged such that the heights are non-decreasing from the front to the back of the line. However, instead of performing the sorting directly, you are given a list of pairs `(i, j)` representing indices of students that you can swap. Your task is to determine if it is possible to sort the array by only swapping the heights at the given pairs. Return `true` if it is possible to sort the array using the allowed swaps, otherwise return `false`.","solution":"def can_sort_by_swaps(height, swaps): Determines if the array can be sorted using the allowed swaps. :param height: List[int] - list of heights :param swaps: List[Tuple[int, int]] - list of index pairs that can be swapped :return: bool - True if the array can be sorted using allowed swaps, otherwise False n = len(height) # Create an adjacency list for the swaps to represent the graph graph = {i: [] for i in range(n)} for i, j in swaps: graph[i].append(j) graph[j].append(i) def dfs(node, visited, group): stack = [node] while stack: cur = stack.pop() if cur not in visited: visited.add(cur) group.append(cur) for neighbor in graph[cur]: if neighbor not in visited: stack.append(neighbor) visited = set() for i in range(n): if i not in visited: group = [] dfs(i, visited, group) group_heights = sorted(height[j] for j in group) group_indices = sorted(group) for idx, value in zip(group_indices, group_heights): height[idx] = value return height == sorted(height)"},{"question":"You are given a linked list where each node contains a unique integer value, and the list is sorted in ascending order. Implement a function that removes all elements with a given value `val` from this list and returns the modified list. The function should maintain the original order of the remaining elements. If the element with the given value does not exist in the list, the function should return the list unchanged.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_elements(head: ListNode, val: int) -> ListNode: dummy = ListNode(0) dummy.next = head current = dummy while current.next: if current.next.val == val: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"You are given an array `s` of strings representing a collection of words in a dictionary. Each element in `s` consists of lowercase English letters. You need to find out if one word can be converted into another word by changing exactly one character. Return a boolean matrix where `matrix[i][j]` is `true` if the `i-th` word can be converted to the `j-th` word by changing exactly one character, and `false` otherwise. For example, given `s = [\\"abc\\", \\"abd\\", \\"aac\\", \\"bcd\\"]`: - `matrix[0][1]` (comparison between \\"abc\\" and \\"abd\\") would be `true`. - `matrix[0][2]` (comparison between \\"abc\\" and \\"aac\\") would be `true`. - `matrix[0][3]` (comparison between \\"abc\\" and \\"bcd\\") would be `false`. Return the boolean matrix representing all such comparisons in the array `s`.","solution":"def can_convert_by_one_char(word1, word2): Returns True if word1 can be converted to word2 by changing exactly one character, otherwise False. if len(word1) != len(word2): return False diff_count = 0 for char1, char2 in zip(word1, word2): if char1 != char2: diff_count += 1 if diff_count > 1: return False return diff_count == 1 def conversion_matrix(s): Returns a boolean matrix where matrix[i][j] is True if the i-th word can be converted to the j-th word by changing exactly one character, and False otherwise. n = len(s) matrix = [[False] * n for _ in range(n)] for i in range(n): for j in range(n): if i != j: matrix[i][j] = can_convert_by_one_char(s[i], s[j]) return matrix"},{"question":"You are given an `n x m` grid representing a farm where each cell can either be barren (represented by `0`) or fertile (represented by `1`). You need to determine the total number of distinct rectangles that can be formed by only using the fertile cells. A rectangle is defined by its top-left and bottom-right corners and includes all cells in between these corners. Return the _number of distinct rectangles that can be formed using only the fertile cells._","solution":"def count_rectangles(grid): Function to count the number of distinct rectangles that can be formed using only fertile cells. Parameters: grid - list of list of int: The n x m grid representing the farm Returns: int - Number of distinct rectangles that can be formed using only fertile cells if not grid: return 0 n, m = len(grid), len(grid[0]) count = 0 for top in range(n): for bottom in range(top, n): consecutive_ones = 0 for col in range(m): if all(grid[row][col] == 1 for row in range(top, bottom + 1)): consecutive_ones += 1 count += consecutive_ones else: consecutive_ones = 0 return count"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. Write a function that takes the `root` of the binary tree as input and returns a list of integers representing the visible nodes from the right side view.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side. if not root: return [] view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: # last node in the current level view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return view"},{"question":"You are given a list of `n` words. Each word consists of lower case English letters only. There are two specific words: `start` and `end`. Your task is to transform the `start` word into the `end` word by changing exactly one character at a time. Each intermediate word must exist in the list of words. Return _the minimum number of transformations needed to convert `start` to `end`, or return `-1` if it is not possible_.","solution":"from collections import deque def word_transformation_length(start, end, word_list): Returns the minimum number of transformations needed to convert start to end, where each transformation changes exactly one character at a time and each intermediate word must exist in word_list. if end not in word_list: return -1 word_list = set(word_list) queue = deque([(start, 1)]) while queue: current_word, level = queue.popleft() if current_word == end: return level for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': intermediate_word = current_word[:i] + c + current_word[i+1:] if intermediate_word in word_list: queue.append((intermediate_word, level + 1)) word_list.remove(intermediate_word) # mark as visited return -1"},{"question":"You are given a list of strings `words` and a string `target`. You need to find and return the index of the string in `words` which can be formed by removing the fewest number of characters from `target`. If there is a tie, return the smallest index. If no such string exists, return -1. You may assume all characters in `words` and `target` are lowercase English letters.","solution":"def min_characters_to_form(words, target): def can_form_with_fewest_removals(word, target): it = iter(target) return all(char in it for char in word) best_index = -1 min_removals = float(\'inf\') for i, word in enumerate(words): if can_form_with_fewest_removals(word, target): current_removals = len(target) - len(word) if current_removals < min_removals: min_removals = current_removals best_index = i return best_index"},{"question":"You are given two arrays `nums1` and `nums2` of equal length `n` where each element is a unique integer. Your task is to find an index `i` such that the sum of the prefix sums of `nums1` and `nums2` from 0 to `i` (inclusive) is minimized. If there are multiple such indices, return the smallest one. Implement the function: ```python def min_prefix_sum_index(nums1: List[int], nums2: List[int]) -> int: ``` # Example: ```python nums1 = [1, 2, 3, 4] nums2 = [4, 3, 2, 1] min_prefix_sum_index(nums1, nums2) # Output: 0 ```","solution":"from typing import List def min_prefix_sum_index(nums1: List[int], nums2: List[int]) -> int: n = len(nums1) prefix_sum_1 = [0] * n prefix_sum_2 = [0] * n prefix_sum_1[0] = nums1[0] prefix_sum_2[0] = nums2[0] for i in range(1, n): prefix_sum_1[i] = prefix_sum_1[i - 1] + nums1[i] prefix_sum_2[i] = prefix_sum_2[i - 1] + nums2[i] min_sum = float(\'inf\') min_index = -1 for i in range(n): current_sum = prefix_sum_1[i] + prefix_sum_2[i] if current_sum < min_sum: min_sum = current_sum min_index = i return min_index"},{"question":"Given a **0-indexed** integer array `arr` of length `n`, return _the **length of the longest** subsequence that can be removed such that the remaining array has at least one increasing or one decreasing sequence of length at least `3`._ A subsequence is a sequence derived from the original array by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_subsequence_length(arr): Returns the length of the longest subsequence that can be removed such that the remaining array has at least one increasing or one decreasing sequence of length at least 3. :param arr: List[int] - the input array of integers. :return: int - the length of the longest subsequence that can be removed. n = len(arr) if n < 3: return 0 def longest_increasing_subseq_length(arr): if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_decreasing_subseq_length(arr): if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] < arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) longest_inc = longest_increasing_subseq_length(arr) longest_dec = longest_decreasing_subseq_length(arr) if longest_inc < 3 and longest_dec < 3: return 0 return n - 3"},{"question":"Given a **0-indexed** integer array `nums`, return an array of the same length where each element at index `i` represents the number of elements in the array that are greater than `nums[i]`.","solution":"def count_greater_elements(nums): Returns an array where each element at index i represents the number of elements in the array that are greater than nums[i]. result = [] for i in range(len(nums)): count = sum(1 for j in range(len(nums)) if nums[j] > nums[i]) result.append(count) return result"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `distance`. The `distance` indicates that for each pair of equal letters in the string, there must be exactly `distance` other characters in between them. Determine if the given string satisfies this condition. If it does, return `true`; otherwise, return `false`.","solution":"def check_distance(s, distance): Returns True if for each pair of equal letters in the string s, there are exactly \'distance\' characters between them. char_position = {} for i, c in enumerate(s): if c in char_position: if i - char_position[c] - 1 != distance: return False char_position[c] = i return True"},{"question":"You are given a list of integers `nums` and an integer `k`. Return _the maximum sum of a subarray of length_ `k` _in_ `nums`. A subarray is a contiguous part of an array. ```python def max_sum_subarray(nums, k): # Your implementation here ```","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k in the list nums. :param nums: List[int] - The list of integers :param k: int - The length of the subarray :return: int - The maximum sum of a subarray of length k if not nums or k <= 0 or k > len(nums): return 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are managing an online video streaming service that requires segmenting videos for optimized buffering and playback. Each video is divided into several segments of equal length. Given a list of integers `segments`, where `segments[i]` represents the length of the `i-th` segment of the video in seconds, and an integer `k` representing the maximum number of segments you can merge to form a continuous buffer block, return _the maximum duration of a buffer block that can be created by merging at most `k` consecutive segments_. If no segments can be merged to form a valid buffer block, return `0`.","solution":"def max_buffer_block_duration(segments, k): Returns the maximum duration of a buffer block that can be created by merging at most `k` consecutive segments. Parameters: segments (List[int]): A list of integers where each element represents the length of a segment in seconds. k (int): The maximum number of segments that can be merged. Returns: int: The maximum duration of a buffer block that can be created. if not segments or k <= 0: return 0 max_duration = 0 current_duration = 0 for i in range(len(segments)): current_duration = 0 for j in range(i, min(i + k, len(segments))): current_duration += segments[j] max_duration = max(max_duration, current_duration) return max_duration"},{"question":"Given an array of integers `nums` and an integer `target`, find the two integers in `nums` such that their sum equals `target`. Return the indices of the two integers in the form of a list. You may assume that each input would have exactly one solution, and you may not use the same element twice. The solution should have a time complexity of O(n).","solution":"def two_sum(nums, target): Returns the indices of the two numbers in `nums` that add up to `target`. :param nums: List of integers. :param target: Integer target sum. :return: List containing two indices. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"Given a binary tree, the task is to find and return the level of a given node `x`. The level of a node in a binary tree is defined as the distance from the root node to that node. The root node is at level 1, its children are at level 2, and so on. You are given the root of the binary tree and an integer `x` representing the value of the target node. The tree nodes have the following structure: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` Write a function that returns the level of the node with value `x`. If the node is not found, return `-1`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def get_level(root, x): Returns the level of the node with value x. If the node is not found, return -1. The root node is at level 1. def find_level(node, depth): if not node: return -1 if node.val == x: return depth left_level = find_level(node.left, depth + 1) if left_level != -1: return left_level return find_level(node.right, depth + 1) return find_level(root, 1)"},{"question":"You are given a 0-indexed integer array `nums` that may contain duplicates. Your task is to determine if there exists a contiguous subarray of `nums` that can be sorted in non-decreasing order to make the entire array `nums` sorted in non-decreasing order. If such a subarray exists, return the start and end indices of the shortest such subarray. If there are multiple possible answers, return the one with the smallest start index. If no such subarray exists, return `[-1, -1]`.","solution":"def find_unsorted_subarray(nums): Returns the start and end indices of the shortest contiguous subarray that, if sorted, makes the entire array sorted in non-decreasing order. n = len(nums) start, end = -1, -1 sorted_nums = sorted(nums) for i in range(n): if nums[i] != sorted_nums[i]: if start == -1: start = i end = i return [start, end]"},{"question":"Given a binary string `s`, return the minimum number of substrings in `s` such that each substring is either \\"0\\" or \\"1\\". You are allowed to reorder the substrings in any way, but each substring must consist of the same character and must begin and end with a different character as the next substring.","solution":"def minSubstrings(s): Returns the minimum number of substrings in s such that each substring is either \\"0\\" or \\"1\\". if not s: return 0 count = 1 for i in range(1, len(s)): if s[i] != s[i-1]: count += 1 return count"},{"question":"You are given a `root` of a binary tree where each node contains an integer value. The tree is guaranteed to be a **full binary tree** (each node has either 0 or 2 children). Your task is to determine the depth of the shallowest leaf node. For example, in the following tree: ``` 1 / 2 3 / 4 5 ``` The shallowest leaf node is either node 3 or node 4, both at depth 2. Return the depth as an integer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): Determines the depth of the shallowest leaf node in a full binary tree. :param root: TreeNode, the root of a binary tree :return: int, the depth of the shallowest leaf node if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() # Check if it is a leaf node if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return 0"},{"question":"You are given an array of integers `arr` and an integer `k`. A subset of the array is called a k-subset if it contains exactly `k` elements. Find the k-subset with the maximum sum and return the sum of that k-subset. If there are multiple k-subsets with the same maximum sum, return the sum of any of them.","solution":"def max_k_subset_sum(arr, k): Find the k-subset with the maximum sum and return the sum of that k-subset. if k > len(arr): raise ValueError(\\"k cannot be greater than the length of the array\\") # Sort the array in descending order sorted_arr = sorted(arr, reverse=True) # Take the first k elements to form the k-subset with maximum sum max_k_subset = sorted_arr[:k] # Return the sum of the k-subset return sum(max_k_subset)"},{"question":"You are given an integer array `grades` representing the grades of students in a class. Each student\'s grade is an integer value where a higher grade means better performance. The teacher wants to form study groups such that the difference between the highest and lowest grade in each group does not exceed a given threshold `maxDifference`. A group can be of any size, including a single student. Write a function that returns the **minimum number of groups** needed to accommodate all students under the given constraints.","solution":"def min_groups(grades, maxDifference): Returns the minimum number of groups needed to accommodate all students where the difference between the highest and lowest grade in each group does not exceed maxDifference. if not grades: return 0 grades.sort() groups = 0 start = 0 while start < len(grades): end = start while end < len(grades) and grades[end] - grades[start] <= maxDifference: end += 1 groups += 1 start = end return groups"},{"question":"You are given a string `s` and an integer `k`. You need to partition the string into as few parts as possible so that each part is a substring with a length equal to `k`. If the length of the string is not a multiple of `k`, the last part can contain the remaining characters, even if it is shorter than `k`. Return _the **minimum** number of parts needed to partition the string_. For example, if `s = \\"abcdefgh\\"` and `k = 3`, the partition can be `[\\"abc\\", \\"def\\", \\"gh\\"]`, requiring 3 parts in total.","solution":"def partition_string(s, k): Partitions the string into parts with length k. Parameters: s (str): The string to be partitioned. k (int): The length of each part. Returns: int: The minimum number of parts needed to partition the string. n = len(s) if n % k == 0: return n // k else: return n // k + 1"},{"question":"Given an integer array `nums` and an integer `k`, your task is to construct the lexicographically smallest subsequence of length `k` from the given array. A subsequence is derived by deleting some or none of the elements from the array without changing the order of the remaining elements. The lexicographical comparison of two sequences is similar to comparing two words in a dictionary; for example, sequence `a` is smaller than sequence `b` if at the first position where `a` and `b` differ, the sequence `a` has a smaller element than the corresponding element in sequence `b`. Return _the lexicographically smallest subsequence of length `k`_.","solution":"def lexicographically_smallest_subsequence(nums, k): Returns the lexicographically smallest subsequence of length k from the given array nums. stack = [] to_remove = len(nums) - k for num in nums: while stack and stack[-1] > num and to_remove > 0: stack.pop() to_remove -= 1 stack.append(num) # We need a subsequence of length k return stack[:k]"},{"question":"Given a string `s` and an integer `k`, you need to rearrange the string such that the same characters are at least `k` distance apart. If it is not possible to rearrange the string, return an empty string `\\"\\"`. Otherwise, return the rearranged string. Example 1: Input: `s = \\"aabbcc\\", k = 3` Output: `\\"abcabc\\"` Example 2: Input: `s = \\"aaabc\\", k = 3` Output: `\\"\\"` **Note**: - `s.length` and `k` will be in the range `[1, 10000]`. - The string `s` will contain only lowercase English letters.","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k == 0: return s # Count the frequency of each character in the string char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((char, count + 1)) # We increase the count because we store negative counts if len(queue) >= k: char, count = queue.pop(0) if -count > 0: heapq.heappush(max_heap, (count, char)) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"Given a linked list, reverse the nodes in groups of `k` and return the _modified list_. If the number of nodes is not a multiple of `k`, leave the last remaining nodes as they are.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): if head is None or k == 1: return head # Function to reverse the linked list def reverse_linked_list(start, end): prev, curr = None, start while curr != end: nex = curr.next curr.next = prev prev = curr curr = nex return prev # Placeholder for the new head of the reversed linked list dummy = ListNode(0) dummy.next = head prev = dummy end = head i = 0 while end: i += 1 if i % k == 0: start = prev.next next = end.next end.next = None prev.next = reverse_linked_list(start, end.next) start.next = next prev = start end = prev end = end.next return dummy.next"},{"question":"You are given an array of integers `arr` and an integer `target`. Find the number of combinations that add up to the `target` using elements from the array. You may use elements multiple times and in any order. The order of elements in the combination does not matter. Return _the number of possible combinations that add up to the target sum_. Implement a function `countCombinations(int[] arr, int target)` that returns the total number of combinations.","solution":"def countCombinations(arr, target): Returns the number of combinations that add up to the target using elements from arr. dp = [0] * (target + 1) dp[0] = 1 # There\'s one way to make the target 0, by using no elements for i in range(1, target + 1): for num in arr: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"You are given a **unique** string `s` consisting of lowercase letters and a non-negative integer `k`. You need to determine if it\'s possible to form a palindrome by reordering at most `k` characters in the string. A **palindrome** is a string that reads the same forward and backward. Return `true` _if it is possible to form a palindrome with at most `k` reorders, or_ `false` _otherwise_.","solution":"def can_form_palindrome(s, k): Determines if it is possible to form a palindrome by reordering at most k characters in the string s. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # To form a palindrome, we need at most one odd frequency character in the string # Every odd frequency character can be paired with some character by reordering return odd_count - 1 <= k"},{"question":"Design a class to implement a stack that supports retrieving the minimum element in constant time. Implement the `MinStack` class: - `MinStack()` initializes the stack object. - `void push(int val)` pushes the element `val` onto the stack. - `void pop()` removes the element on the top of the stack. - `int top()` gets the top element of the stack. - `int getMin()` retrieves the minimum element in the stack. Each function must be implemented to run in O(1) time complexity.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"Given a string `s`, partition the string into as many parts as possible such that each letter appears in at most one part. Return a list of integers representing the size of these parts. Each part should be as large as possible. To achieve this, you need to recompute the last occurrence of each letter of the string while partitioning. Note that each letter should only appear in one partition despite the fact that the partitions must be the largest feasible. --- This new question is designed to align with the style, complexity, length, and domain of the provided sample questions.","solution":"def partition_labels(s: str): last_occurrence = {ch: i for i, ch in enumerate(s)} partitions = [] start = end = 0 for i, ch in enumerate(s): end = max(end, last_occurrence[ch]) if i == end: partitions.append(i - start + 1) start = i + 1 return partitions"},{"question":"Given a string `s` consisting of lowercase and uppercase letters, sort the string such that all uppercase letters come before all lowercase letters, but the relative order among uppercase letters and among lowercase letters should remain unchanged. Return the sorted string.","solution":"def sort_string(s): Sort the string such that all uppercase letters come before all lowercase letters, but the relative order among uppercase and among lowercase letters remains unchanged. uppercase_chars = [char for char in s if char.isupper()] lowercase_chars = [char for char in s if char.islower()] return \'\'.join(uppercase_chars + lowercase_chars)"},{"question":"You are given an unsorted integer array `arr` which may contain duplicates. You need to remove the duplicates from it and return a new array that is sorted and has all duplicates removed. Do not use any built-in methods for removing duplicates. Return the sorted array of unique elements.","solution":"def remove_duplicates_and_sort(arr): Removes duplicates from the input array and returns a sorted array of unique elements. # Using a set to track unique elements unique_elements = {} for num in arr: unique_elements[num] = True # Convert the keys of the dictionary to a list and sort it result = [] for key in unique_elements: result.append(key) # Sorting the list of unique elements for i in range(len(result)): for j in range(i + 1, len(result)): if result[i] > result[j]: result[i], result[j] = result[j], result[i] return result"},{"question":"Write a function that receives an array of integers and returns a boolean indicating whether it contains any duplicate elements within `k` distance of each other. In other words, check if there are two distinct indices `i` and `j` in the array such that `arr[i] == arr[j]` and the absolute difference between `i` and `j` is at most `k`.","solution":"def contains_nearby_duplicate(arr, k): Returns True if there are duplicate elements within k distance of each other. Params: arr - List of integers k - Integer representing the maximum distance between duplicate elements Returns: Boolean indicating whether there are duplicate elements within k distance of each other seen = {} for i, num in enumerate(arr): if num in seen and i - seen[num] <= k: return True seen[num] = i return False"},{"question":"You are given a **0-indexed** integer array `tasks` where `tasks[i]` represents the duration of the `i-th` task in minutes. You need to distribute these tasks among two workers such that the maximum time any worker spends on tasks is minimized. Return the minimum possible value of the maximum task duration assigned to a single worker. For example, if `tasks = [3, 2, 3]`, one optimal way is to assign the first and second tasks to the first worker (total duration = 5) and the third task to the second worker (total duration = 3). Hence, the minimum possible value of the maximum task duration is 5.","solution":"def min_max_task_duration(tasks): Returns the minimum possible value of the maximum task duration assigned to a single worker. def can_distribute(mid): total = 0 workers = 1 for task in tasks: total += task if total > mid: workers += 1 total = task return workers <= 2 left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_distribute(mid): right = mid else: left = mid + 1 return left"},{"question":"You own a flower shop and need to keep track of daily sales. You are given an integer array `dailySales` where `dailySales[i]` denotes the number of flowers sold on the `i`-th day. Additionally, you are provided with an integer `m` which indicates the number of consecutive days that determine a streak. Write a function that returns `true` if there exists any consecutive streak of `m` days where the number of flowers sold each day is greater than or equal to a specified threshold `threshold`, otherwise return `false`. The consecutive streak must consist of exactly `m` days.","solution":"def has_sales_streak(dailySales, m, threshold): Returns True if there exists any consecutive streak of m days where the number of flowers sold each day is greater than or equal to threshold, otherwise returns False. :param dailySales: List of integers representing the number of flowers sold each day. :param m: Integer representing the number of consecutive days that determine a streak. :param threshold: Integer representing the flower sales threshold. :return: Boolean indicating whether there is a streak of m days with sales >= threshold each day. for i in range(len(dailySales) - m + 1): if all(dailySales[j] >= threshold for j in range(i, i + m)): return True return False"},{"question":"You are given a lowercase alphabet string `s` and a character `c`. Return _the length of the shortest substring of_ `s` _that starts and ends with_ `c`. If there is no such substring, return _0_. Consider all occurrences of `c` in `s`.","solution":"def shortest_substring_length(s: str, c: str) -> int: Returns the length of the shortest substring starting and ending with character c. If there is no such substring, returns 0. positions = [i for i, char in enumerate(s) if char == c] if len(positions) < 2: return 0 min_length = float(\'inf\') for i in range(len(positions) - 1): min_length = min(min_length, positions[i+1] - positions[i] + 1) return min_length"},{"question":"You are given a string `sequence` consisting of lowercase English letters. You need to find the length of the longest substring of `sequence` where each unique letter appears at least `k` times. Write a function that returns the length of such a substring. Note that if no such substring exists, the function should return 0.","solution":"def longest_substring(sequence, k): Returns the length of the longest substring where each unique letter appears at least k times. def helper(s, k): if len(s) < k: return 0 freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 for char in freq: if freq[char] < k: return max(helper(substring, k) for substring in s.split(char)) return len(s) return helper(sequence, k)"},{"question":"You are given two non-empty binary trees `root1` and `root2` where each node contains a single digit (0-9). Imagine these trees are numbers stored in a reversed level-order format (similar to how numbers are stored in a reversed format in a linked list where each node represents a single digit). You need to return the sum of these two numbers represented as a new binary tree, also in reversed level-order format. Write a function to achieve this. The binary tree is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def add_trees_in_reverse_level_order(root1, root2): Returns the sum of two binary trees represented as numbers in reversed level-order format. def add_lists_as_numbers(l1, l2): carry, head = 0, None current = None while l1 or l2 or carry: val1 = l1.pop(0) if l1 else 0 val2 = l2.pop(0) if l2 else 0 total = val1 + val2 + carry carry = total // 10 new_node = TreeNode(total % 10) if not head: head = new_node current = head else: current.left = new_node current = current.left return head def tree_to_list(tree): q, result = [tree], [] while q: node = q.pop(0) if node: result.append(node.val) q.append(node.left) q.append(node.right) return result list1 = tree_to_list(root1) list2 = tree_to_list(root2) return add_lists_as_numbers(list1, list2)"},{"question":"You are given two integer arrays `target` and `position`. The `target` array represents the desired target values, and the `position` array holds the initial positions of the elements. Your task is to rearrange the elements in `position` such that the values match the order given in `target`. However, you can only swap neighboring elements (adjacent in the array) to achieve this. Determine the minimum number of swaps required to transform the `position` array into the `target` array. If it is not possible to achieve the target arrangement, return `-1`.","solution":"def min_swaps_to_target(target, position): Returns the minimum number of adjacent swaps required to transform the position array into the target array. If it is not possible to achieve the target arrangement, return -1. from collections import defaultdict, deque if sorted(target) != sorted(position): return -1 target_position = {value: i for i, value in enumerate(target)} position_indices = [target_position[value] for value in position] def count_inversions(arr): inversions = 0 temp_arr = arr.copy() def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = (merge_sort_and_count(arr, temp_arr, left, mid) + merge_sort_and_count(arr, temp_arr, mid + 1, right) + merge_and_count(arr, temp_arr, left, mid, right)) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1) inversions = count_inversions(position_indices) return inversions"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find a contiguous subarray whose sum is exactly equal to the `target`. If there are multiple solutions, return the subarray that starts with the smallest index. If there is no such subarray, return an empty array. * Example: `nums = [1, 2, 3, 4, 5]`, `target = 9`: the subarray `[2, 3, 4]` has the sum 9 and starts with the smallest index 1. * Example: `nums = [1, -1, 5, -2, 3]`, `target = 3`: the subarray `[1, -1, 5, -2]` has the sum 3 and starts with the smallest index 0. * Example: `nums = [1, 2, 3, 4, 5]`, `target = 15`: the subarray `[1, 2, 3, 4, 5]` has the sum 15 and starts with the smallest index 0. * Example: `nums = [1, 2, 3, 4, 5]`, `target = 8`: there is no subarray with the sum of 8, so the result should be an empty array. Return the contiguous subarray or an empty array if no such subarray exists.","solution":"def find_subarray_with_target_sum(nums, target): Find a contiguous subarray whose sum is exactly equal to the target. # Dictionary to store cumulative sum and corresponding index cum_sum_map = {} current_sum = 0 for i, num in enumerate(nums): # Add the current number to the running sum current_sum += num # Check if the current running sum is equal to the target if current_sum == target: return nums[:i+1] # Check if any subarray sums up to the target by checking if # (current_sum - target) is present in the cumulative sum map if (current_sum - target) in cum_sum_map: return nums[cum_sum_map[current_sum - target] + 1:i + 1] # Store the current running sum with its index in the map cum_sum_map[current_sum] = i return []"},{"question":"Given a binary matrix `mat` of size `m x n`, return _the number of islands_. An island is a group of connected `1`s (representing land) surrounded by `0`s (representing water). You may assume all four edges of the grid are surrounded by water. Two cells are connected if they are adjacent in one of the four directions (horizontal or vertical). ```python def numIslands(mat: List[List[int]]) -> int: # Your code here ```","solution":"from typing import List def numIslands(mat: List[List[int]]) -> int: Returns the number of islands in the given binary matrix. An island is a group of connected 1\'s surrounded by 0\'s. if not mat: return 0 m, n = len(mat), len(mat[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or mat[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i+1, j) # down dfs(i-1, j) # up dfs(i, j+1) # right dfs(i, j-1) # left count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"A valid parentheses string (VPS) is defined as follows: - An empty string is a VPS. - If `S` and `T` are VPS, then `S + T` is a VPS. - If `S` is a VPS, then `(S)` is a VPS. Given a parentheses string `s`, determine the length of the longest valid parentheses substring. Return _the length of the longest valid parentheses substring in `s`._","solution":"def longest_valid_parentheses(s): Finds the length of the longest valid parentheses substring. Parameters: s (str): A string consisting of \'(\' and \')\'. Returns: int: The length of the longest valid parentheses substring. max_len = 0 stack = [] start = -1 for i, char in enumerate(s): if char == \'(\': stack.append(i) else: if stack: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - start) else: start = i return max_len"},{"question":"Write a function that takes a string `s` and a list of queries, where each query is a pair of integers representing the start and end indices of a substring within `s`. For each query, determine if the substring is a palindrome. Return a list of booleans corresponding to each query, where `True` means the substring is a palindrome and `False` means it is not.","solution":"def is_palindrome_substring(s, queries): Determines if the substrings specified by each pair of start and end indices in queries are palindromes. Args: s (str): The input string. queries (list): A list of (start, end) index pairs representing the substring. Returns: list: A list of booleans corresponding to each query, where True means the substring is a palindrome and False means it is not. result = [] for start, end in queries: substring = s[start:end+1] result.append(substring == substring[::-1]) return result"},{"question":"You are given an array of integers `heights` representing the heights of different buildings with the condition that a person standing on the i-th building can see the building ahead if their height is greater than or equal to the height of that building. Return the number of buildings that have at least one building in front of them that they cannot see due to the presence of a taller building blocking the view.","solution":"def count_blocked_buildings(heights): Returns the count of buildings that have at least one building ahead of them that they cannot see due to the presence of a taller building blocking the view. blocked_count = 0 max_height_so_far = 0 for height in heights: if height >= max_height_so_far: max_height_so_far = height else: blocked_count += 1 return blocked_count"},{"question":"You are given a linked list where each node contains an integer value. Write a function that takes the head of the linked list as input and returns the head of the list after rearranging it so that all nodes with even values appear before all nodes with odd values while maintaining their relative order in the list. For example, given the linked list `1 -> 4 -> 3 -> 2 -> 5 -> 8`, the expected output is `4 -> 2 -> 8 -> 1 -> 3 -> 5`. The function should have a time complexity of O(n) and space complexity of O(1), where n is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_even_odd(head): Rearranges the linked list such that all even numbers appear before all odd numbers. if not head: return head even_dummy = ListNode(0) odd_dummy = ListNode(0) even_tail, odd_tail = even_dummy, odd_dummy current = head while current: if current.val % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = odd_dummy.next odd_tail.next = None return even_dummy.next"},{"question":"You are given a list of non-negative integers representing the amount of rainfall recorded at regular intervals. Write a function to determine the maximum amount of water that can be trapped between these intervals after it rains. The array represents the elevation map where the width of each bar is 1. Return the total amount of trapped water. For example, given `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the function should return `6`.","solution":"def trap(height): Calculate the maximum amount of water that can be trapped after raining given a list of non-negative integers representing an elevation map. :param height: List[int] - List of non-negative integers representing the amounts of rainfall at regular intervals :return: int - The total amount of trapped water if not height or len(height) < 3: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) trapped_water += right_max - height[right] return trapped_water"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a box. Each box is either empty (`0`) or contains a fresh orange (`1`) or a rotten orange (`2`). Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. How many minutes will it take for all fresh oranges to become rotten? If this is impossible, return `-1`.","solution":"from collections import deque def oranges_rotting(grid): Computes the minimum time required for all fresh oranges to become rotten. If impossible, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Populate initial state of the grid for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) # store the coordinate and the minute elif grid[r][c] == 1: fresh_oranges += 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] time = 0 # Perform BFS to rot adjacent fresh oranges while queue: x, y, minute = queue.popleft() time = max(time, minute) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny, minute + 1)) return -1 if fresh_oranges > 0 else time"},{"question":"Given an integer array `arr` and an integer `k`, rearrange the array such that the element at the k-th position becomes the maximum element in the array, and all the other elements maintain their original relative order. For example, given `arr = [1, 3, 5, 2, 4]` and `k = 2`, the resulting array should be `[1, 3, 5, 2, 4]`, where the element at index `2` is `5`, which is already the maximum element. If the k-th position does not have the maximum element initially, swap with the maximum element located in the array. Return the modified array.","solution":"def rearrange_array(arr, k): Rearrange the array such that the element at position k becomes the maximum element, and all other elements maintain their original relative order. if not arr: return arr max_element_index = 0 max_element = arr[0] # Find the index of the maximum element for i in range(len(arr)): if arr[i] > max_element: max_element = arr[i] max_element_index = i # If max element is already at the k-th position, return the array if max_element_index == k: return arr # Otherwise, swap the k-th element with the maximum element arr[max_element_index], arr[k] = arr[k], arr[max_element_index] return arr"},{"question":"You are given an integer array `nums`. You need to find the last occurrence of the smallest element in `nums`, and return its index. If the smallest element appears only once, return its index directly. If the list is empty, return -1.","solution":"def last_index_of_smallest(nums): Finds the last occurrence of the smallest element in nums and returns its index. If the smallest element appears only once, returns its index directly. If the list is empty, returns -1. if not nums: return -1 min_value = min(nums) last_index = len(nums) - 1 - nums[::-1].index(min_value) return last_index"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to partition the string into as many parts as possible such that each letter appears in at most one part, and the length of the longest part is minimized. Return _the **minimum** possible length of the longest part after partitioning_.","solution":"def min_max_partition(s, k): Returns the minimum possible length of the longest part after partitioning the string `s`. last_occurrence = {} for i, char in enumerate(s): last_occurrence[char] = i partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(end - start + 1) start = i + 1 return max(partitions)"},{"question":"Given an array of integers `heights` representing the heights of students standing in a line, return the minimum number of students that need to be removed so that the remaining students are standing in non-decreasing order of height. Note that you only need to identify the minimum number of students to be removed, and not the resulting array. ```python def minimum_removals(heights): # Your implementation here ```","solution":"def minimum_removals(heights): Returns the minimum number of students that need to be removed so that the remaining students are standing in non-decreasing order of height. def longest_increasing_subsequence(arr): if not arr: return 0 lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] >= arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) n = len(heights) length_of_lis = longest_increasing_subsequence(heights) return n - length_of_lis"},{"question":"You are building a robot that can move in a grid. The robot starts at position (1,1) in an `m x n` grid. Each cell in the grid is either empty or contains an obstacle. The robot can only move **down** or **right** at each step. Design an algorithm to determine the number of unique paths that the robot can take to reach the bottom-right corner (m, n) of the grid while avoiding obstacles. The grid is represented by a 2D array `grid`, where `grid[i][j]` is `0` if the cell is empty and `1` if it contains an obstacle. Return the number of unique paths from the top-left to the bottom-right corner of the grid.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in a grid that contains obstacles. Parameters: grid (List[List[int]]): 2D list representing the grid. 0 indicates empty cell, 1 indicates obstacle. Returns: int: Number of unique paths from the top-left to the bottom-right corner of the grid. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Create a 2D array to store the number of unique paths to each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', you are allowed to delete any number of characters from the string. Define the operation \\"make beautiful\\" as the process of turning the string into a sequence in which no two adjacent characters are the same. For example, \\"abab\\" is beautiful, and \\"aaabbb\\" is not. Write a function `minDeletionsToMakeBeautiful(s)` that returns the minimum number of deletions required to make the string beautiful.","solution":"def minDeletionsToMakeBeautiful(s): Returns the minimum number of deletions required to make the string \'s\' beautiful. A beautiful string is defined as a string where no two adjacent characters are the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"Write a function to determine whether a given sequence of brackets is balanced. A sequence of brackets is considered balanced if every opening bracket has a corresponding and correctly oriented closing bracket. The bracket types include `()`, `{}`, and `[]`. The input will be a string containing only these bracket characters. Return `true` if the sequence is balanced, otherwise return `false`. For example: ``` \\"()[]{}\\" -> true \\"([{}])\\" -> true \\"[(])\\" -> false \\"[({})](]\\" -> false ```","solution":"def is_balanced(s): Determines whether a given sequence of brackets is balanced. Parameters: s (str): The input string containing only bracket characters. Returns: bool: True if the sequence is balanced, otherwise False. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"We use numbers to represent our position in a maze, which consists of multiple rooms connected by corridors. Each room is represented by a unique positive integer, and corridors are represented by an array of tuples where each tuple (a, b) indicates a bidirectional corridor between rooms a and b. You are given an array of corridors and two integers, start and end, representing the room where you start and the room where you want to reach. Write a function `bool canReach(int[][] corridors, int start, int end)` that returns true if it\'s possible to travel from the start room to the end room using the corridors, and false otherwise.","solution":"def canReach(corridors, start, end): from collections import defaultdict, deque # Create a graph from corridors graph = defaultdict(list) for a, b in corridors: graph[a].append(b) graph[b].append(a) # Use BFS to find if there is a path from start to end queue = deque([start]) visited = set() while queue: current = queue.popleft() if current == end: return True visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"You are given an array of integers `arr` which contains both positive and negative numbers. You need to find the **largest** sum of any **contiguous subarray** within the array and return the sum. If the array contains only negative numbers, return the *maximum* single element (the least negative number). Write a function `maxSubArraySum(arr)` that takes in the array and returns the largest sum of the contiguous subarray.","solution":"def maxSubArraySum(arr): Returns the largest sum of any contiguous subarray within the array. If the array contains only negative numbers, returns the maximum single element. if len(arr) == 0: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Write a function that takes a string containing digits from \'2\' to \'9\' inclusive, and returns all possible letter combinations that the number could represent using the mapping of digits to letters on a phone keypad. Return the answer in any order. Note that 1 does not map to any letters. Example input: \\"23\\" Example output: [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] The mapping is as follows: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\"","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent using the mapping of digits to letters on a phone keypad. if not digits: return [] digit_to_char = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_char[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"Given a directed graph represented as an adjacency list, determine if there is a cycle present in the graph. The graph is given as a dictionary where keys are node identifiers and values are lists of nodes to which the key node has directed edges. Implement a function `hasCycle(graph: dict) -> bool` that returns `True` if there is a cycle in the graph and `False` otherwise.","solution":"def hasCycle(graph): Returns True if there is a cycle in the directed graph, False otherwise. The graph is represented as an adjacency list in a dictionary. def visit(node): if node in temp: return True if node in perm: return False temp.add(node) for neighbour in graph.get(node, []): if visit(neighbour): return True temp.remove(node) perm.add(node) return False temp = set() perm = set() for node in graph: if visit(node): return True return False"},{"question":"You are given two arrays of integers `nums1` and `nums2`, where `nums1` contains integers from 1 to `n` and `nums2` contains only distinct integers. Your task is to determine if `nums2` is a subsequence of any permutation of `nums1`. Return `true` if `nums2` is a subsequence of any permutation of `nums1`, otherwise return `false`.","solution":"def is_subsequence_of_permutation(nums1, nums2): Returns True if nums2 is a subsequence of any permutation of nums1, otherwise False. nums1_set = set(nums1) for num in nums2: if num not in nums1_set: return False return True"},{"question":"Given an **undirected** graph with `n` nodes labeled from `0` to `n - 1`, and a `0-indexed` `n x n` adjacency matrix `isConnected`, where `isConnected[i][j] = 1` indicates that node `i` is directly connected to node `j`, and `isConnected[i][j] = 0` means they are not directly connected. Determine the size of the largest **connected component** in the graph. A **connected component** is a subset of nodes such that there exists a path between any two nodes in the subset, and it is maximal, meaning no additional nodes in the graph are connected to any nodes in the subset. Return the **size** of this largest connected component.","solution":"def largest_connected_component(isConnected): Determine the size of the largest connected component in an undirected graph given its adjacency matrix. :param isConnected: List[List[int]], 2D adjacency matrix of the graph :return: int, size of the largest connected component def dfs(node, visited): stack = [node] component_size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True component_size += 1 for neighbor in range(len(isConnected)): if isConnected[current][neighbor] == 1 and not visited[neighbor]: stack.append(neighbor) return component_size n = len(isConnected) visited = [False] * n largest_size = 0 for i in range(n): if not visited[i]: size_of_component = dfs(i, visited) largest_size = max(largest_size, size_of_component) return largest_size"},{"question":"You are given a sorted array of distinct integers `arr` and an integer `k`. Return _the `kth` positive integer that is missing from this array_.","solution":"def findKthPositive(arr, k): Finds the kth positive integer that is missing from the array. Parameters: arr (list): A sorted list of distinct integers. k (int): The position of the missing integer to find. Returns: int: The kth positive integer that is missing from the array. missing_count = 0 current = 1 index = 0 while missing_count < k: if index < len(arr) and arr[index] == current: index += 1 else: missing_count += 1 if missing_count == k: return current current += 1"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to count the number of pairs `(i, j)` where `1 <= i < j <= n` (n is the length of the list), such that `nums[i] + nums[j]` equals the target `target`. Do this without using nested loops to directly match the pairs. Return _the **count** of such pairs._","solution":"from collections import defaultdict def count_pairs(nums, target): Returns the count of pairs (i, j) where 1 <= i < j <= n such that nums[i] + nums[j] equals target. pair_count = 0 value_count = defaultdict(int) for num in nums: if target - num in value_count: pair_count += value_count[target - num] value_count[num] += 1 return pair_count"},{"question":"Given an integer `x`, return the square root of `x`. If `x` is not a perfect square, return the floor value of the square root. The expected time complexity is `O(log x)`.","solution":"def sqrt(x): Returns the square root of x. If x is not a perfect square, returns the floor value of the square root. :param x: int :return: int if x < 0: raise ValueError(\\"Input should be a non-negative integer\\") if x == 0 or x == 1: return x low, high = 0, x result = 0 while low <= high: mid = (low + high) // 2 mid_squared = mid * mid if mid_squared == x: return mid elif mid_squared < x: low = mid + 1 result = mid else: high = mid - 1 return result"},{"question":"Design a class that sorts a stream of integers. The stream of integers is provided in arbitrary order, and you need to return them sorted in ascending order. Implement the `StreamSorter` class with the following methods: - `void addNum(int num)`: Adds the integer `num` to the stream. - `List<Integer> getSortedStream()`: Returns a sorted list of all the integers added to the stream so far. Each method should maintain efficiency suitable for large streams of data.","solution":"class StreamSorter: def __init__(self): self.nums = [] def addNum(self, num): Adds the integer `num` to the stream. self.nums.append(num) self.nums.sort() def getSortedStream(self): Returns a sorted list of all the integers added to the stream so far. return self.nums[:]"},{"question":"Given the `root` of a binary tree, determine whether it is a **balanced** binary tree. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. Return `true` if the tree is balanced, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine whether the binary tree is balanced. def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) current_balanced = left_balanced and right_balanced and abs(left_depth - right_depth <= 1) current_depth = max(left_depth, right_depth) + 1 return current_depth, current_balanced return check_balance(root)[1]"},{"question":"Given an integer array `nums` of length `n`, return `true` if there exists a **duplicate element** in the array within a distance of `k` indices of each other, otherwise return `false`. The array contains only non-negative integers. For example, given `nums = [1, 2, 3, 1]` and `k = 3`, you should return `true` because `nums[0] == nums[3]` and the distance between these indices is `3`, which is equal to `k`.","solution":"def contains_nearby_duplicate(nums, k): Returns true if there exists a duplicate element in the array within a distance of k indices of each other. num_map = {} for i, num in enumerate(nums): if num in num_map and i - num_map[num] <= k: return True num_map[num] = i return False"},{"question":"You are given a two-dimensional integer array `logs` where each `logs[i] = [ID, time]` indicates that the user with `ID` has logged in at `time`. The user logs are not ordered in any particular way. A user is considered to be active if there\'s another log for the same user within `5` units of time radius. If the difference between the login times of the two logs is less than or equal to `5`, the user is active during that period. Return _the number of unique active users_.","solution":"def count_active_users(logs): Returns the number of unique active users based on the provided login logs. from collections import defaultdict # Dictionary to map user IDs to their respective login times user_logs = defaultdict(list) # Populate the dictionary with the logs for log in logs: user_logs[log[0]].append(log[1]) # Function to check if a user is active def is_active(times): times.sort() for i in range(len(times) - 1): if times[i+1] - times[i] <= 5: return True return False # Checking each user for activity active_users = set() for user, times in user_logs.items(): if is_active(times): active_users.add(user) return len(active_users)"},{"question":"You are given a 2D matrix `grid` of size `n x n` where each cell is initially either \'S\' (safe) or \'T\' (trapped). You are also given a list `operations` where each operation is represented as `[type, x, y]`. The type can either be `1` (set cell (x, y) to \'S\') or `2` (set cell (x, y) to \'T\'). After applying all operations, determine if there exists a path from the top-left cell (0, 0) to the bottom-right cell (n-1, n-1) only through \'S\' cells. Assume valid `x` and `y` that are within grid boundaries. Implement the `PathFinder` class: * `PathFinder(char[][] grid)`: Initializes the object with a 2D grid representing the initial state. * `void applyOperations(int[][] operations)`: Applies a list of operations to the grid in the given order. * `boolean hasSafePath()`: Returns `true` if there exists a path from the top-left to the bottom-right cell consisting entirely of \'S\' cells, otherwise `false`.","solution":"class PathFinder: def __init__(self, grid): self.grid = grid self.n = len(grid) def applyOperations(self, operations): for operation in operations: op_type, x, y = operation if op_type == 1: self.grid[x][y] = \'S\' elif op_type == 2: self.grid[x][y] = \'T\' def hasSafePath(self): if self.grid[0][0] == \'T\' or self.grid[self.n - 1][self.n - 1] == \'T\': return False visited = [[False] * self.n for _ in range(self.n)] return self.dfs(0, 0, visited) def dfs(self, x, y, visited): if x < 0 or y < 0 or x >= self.n or y >= self.n or self.grid[x][y] == \'T\' or visited[x][y]: return False if x == self.n - 1 and y == self.n - 1: return True visited[x][y] = True # Explore all four possible directions if (self.dfs(x + 1, y, visited) or self.dfs(x - 1, y, visited) or self.dfs(x, y + 1, visited) or self.dfs(x, y - 1, visited)): return True return False"},{"question":"A certain complex network can be represented as a **directed graph** where each node indicates a server and each directed edge implies a direct one-way connection from one server to another. You are given a positive integer `n` representing the number of servers and an array of directed connections `connections` where each connection is in the format `[a, b]` indicating a one-way connection from server `a` to server `b`. Your task is to find the minimum number of connections that need to be added to the network to ensure that there is a path from every server to every other server within the network. Return _the minimum number of connections required to make the network fully connected._ Note that the network should be connected both forwards (from any server to any other server) and backwards (from any other server to the original server). The solution should give the correct results even if the network is already fully connected or if it\'s disconnected initially.","solution":"from collections import defaultdict, deque def min_additional_connections(n, connections): def bfs(start_node, graph): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: queue.append(neighbor) return visited # Create the graph and the reverse graph graph = defaultdict(list) reverse_graph = defaultdict(list) for a, b in connections: graph[a].append(b) reverse_graph[b].append(a) # Check if the graph is strongly connected initial_reach = bfs(0, graph) if len(initial_reach) < n: return -1 reverse_reach = bfs(0, reverse_graph) if len(reverse_reach) < n: return -1 return 0"},{"question":"A road network can be represented as a graph where intersections are nodes and roads between them are edges. You are given an undirected graph represented by an integer `n`, the number of intersections (nodes), and a list `roads`, where each `roads[i] = [ui, vi]` represents a bidirectional road between intersections `ui` and `vi`. Your task is to determine the number of complete connected components in this road network. A complete connected component is defined as a subgraph where each pair of nodes is connected directly by an edge. Return _the number of complete connected components in the given graph_.","solution":"def count_complete_components(n, roads): from collections import defaultdict def is_complete_graph(component): num_nodes = len(component) num_edges = sum(len(adj[node]) for node in component) // 2 # because each edge is counted twice return num_edges == num_nodes * (num_nodes - 1) // 2 def dfs(node, visited, component): visited.add(node) component.add(node) for neighbor in adj[node]: if neighbor not in visited: dfs(neighbor, visited, component) # Create adjacency list for the graph adj = defaultdict(list) for u, v in roads: adj[u].append(v) adj[v].append(u) visited = set() complete_components_count = 0 # Traverse all nodes to find all connected components for node in range(n): if node not in visited: component = set() dfs(node, visited, component) if is_complete_graph(component): complete_components_count += 1 return complete_components_count"},{"question":"Given an integer array `arr`, you need to find the length of the longest contiguous subarray such that if you take all the elements of the subarray and rearrange them in any order, it forms a sequence of consecutive integers. A sequence of consecutive integers is an ordered list of integers where each number has exactly one less or one more than the number immediately before or after it. Return the length of that longest contiguous subarray.","solution":"def longest_consecutive_subarray(arr): Returns the length of the longest contiguous subarray that can be rearranged to form a sequence of consecutive integers. if not arr: return 0 max_len = 1 for i in range(len(arr)): min_val = max_val = arr[i] unique_elements = {arr[i]} for j in range(i + 1, len(arr)): if arr[j] in unique_elements: break unique_elements.add(arr[j]) min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if max_val - min_val == j - i: max_len = max(max_len, j - i + 1) return max_len"},{"question":"You are given a binary tree with each node having an integer value. Design an algorithm to find the greatest common ancestor of two given nodes in the binary tree. The binary tree is not necessarily a binary search tree. Implement a function `findGCA(root, p, q)` which takes the root of the binary tree, and the two nodes `p` and `q` of which you need to find the greatest common ancestor, and returns the value of their greatest common ancestor. Note that all values in the binary tree are unique.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findGCA(root, p, q): if not root or root == p or root == q: return root left = findGCA(root.left, p, q) right = findGCA(root.right, p, q) if left and right: return root return left if left else right"},{"question":"You are given an integer array `nums` and an integer `target`. You need to find two distinct indices `i` and `j` in the array such that `nums[i] + nums[j]` equals `target`. Return the indices `[i, j]` in ascending order. If no such indices exist, return an empty list. * Implement the `Solution` class: * `Solution()` Initializes the object of the system. * `List<Integer> findTwoSum(int[] nums, int target)` Returns the indices `[i, j]` such that `nums[i] + nums[j]` equals `target`, or an empty list if no such pair exists. Examples: Input: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] Input: nums = [3, 2, 4], target = 6 Output: [1, 2] Input: nums = [3, 3], target = 6 Output: [0, 1]","solution":"from typing import List class Solution: def findTwoSum(self, nums: List[int], target: int) -> List[int]: Returns the indices [i, j] such that nums[i] + nums[j] equals target, or an empty list if no such pair exists. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"Given a string `s`, find the length of the smallest subsequence of `s` that contains all distinct characters of `s`. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, if `s = \\"abcabc\\"`, then the smallest subsequence that contains all distinct characters is `\\"abc\\"` with length 3. Return the length of such a subsequence.","solution":"def length_of_smallest_subsequence_with_all_distinct_chars(s): Returns the length of the smallest subsequence that contains all distinct characters of the string s. # Use a set to determine unique characters in the string unique_chars = set(s) # The length of the desired subsequence is just the number of unique characters return len(unique_chars)"},{"question":"Given an **m x n** matrix `grid` and an integer `k`, you need to shift the `grid` `k` times. Each shift operation moves the last element of each row to the front of the next row. For the last row, the last element moves to the front of the first row. Return the `grid` after performing `k` shifts. Example: ``` Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] ``` If the shift count `k` is greater than the total number of elements in the grid, consider only the remainder of `k` divided by the number of elements.","solution":"def shift_grid(grid, k): Shifts the grid k times. Each shift operation moves the last element of each row to the front of the next row. For the last row, the last element moves to the front of the first row. Parameters: grid (list of list of ints): The m x n grid. k (int): The number of shifts to be performed. Returns: list of list of ints: The grid after performing k shifts. m, n = len(grid), len(grid[0]) total_elements = m * n k %= total_elements # Reduce the number of shifts if k is greater than total_elements if k == 0: return grid # Flatten the grid into a single list flat_grid = [grid[i][j] for i in range(m) for j in range(n)] # Perform the shift by slicing flat_shifted = flat_grid[-k:] + flat_grid[:-k] # Convert the flat list back into a grid shifted_grid = [[flat_shifted[i * n + j] for j in range(n)] for i in range(m)] return shifted_grid"},{"question":"You are given a **0-indexed** array `nums` of integers representing the initial state of a range `[0, n-1]` where `n` is the length of the array. You are also given a series of update operations where each operation is represented by a triplet `(start, end, delta)` that increments each element of the subarray `nums[start...end]` (both inclusive) by `delta`. Return the array after all the operations have been performed.","solution":"def update_array(nums, operations): Apply a series of operations to the nums array. Each operation is a triplet (start, end, delta) that increments each element of the subarray nums[start...end] (both inclusive) by delta. Args: nums (list of int): The initial state of the array. operations (list of tuple): A list of operations where each operation is (start, end, delta). Returns: list of int: The updated array after all operations have been applied. for (start, end, delta) in operations: for i in range(start, end + 1): nums[i] += delta return nums"},{"question":"You are given a rectangular grid consisting of rows and columns, where each cell contains either a `1` representing a wall or a `0` representing an open space. You are currently at the top-left corner of the grid (i.e., `grid[0][0]`) and want to reach the bottom-right corner (i.e., `grid[m-1][n-1]`). You can only move up, down, left, or right, and you cannot move through walls. Write a function to determine if there exists a path from the top-left corner to the bottom-right corner. Return `true` if such a path exists, otherwise return `false`.","solution":"def is_path_exists(grid): Determines if there exists a path from the top-left corner to the bottom-right corner. Parameters: grid (List[List[int]]): The grid represented as a list of lists, where 1 represents a wall and 0 represents an open space. Returns: bool: True if a path exists, False otherwise. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 1 or visited[x][y]: return False if x == m - 1 and y == n - 1: return True visited[x][y] = True return dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1) return dfs(0, 0)"},{"question":"Given an array of integers `nums` and an integer `k`, find the `k`th largest element in the array. Note that it is the `k`th largest element in **sorted order**, not the `k`th distinct element. You may assume `k` is always valid, `1 <= k <= nums.length`.","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. Parameters: nums (list): List of integers k (int): The order of the largest element to find (1-based index) Returns: int: The k-th largest element min_heap = [] for num in nums: heapq.heappush(min_heap, num) if len(min_heap) > k: heapq.heappop(min_heap) return min_heap[0]"},{"question":"You are given a string `s` that is formatted as multiple words separated by single spaces with no leading or trailing spaces. Reverse the order of the words in the string. Each word must be reversed as well. For example, given `s = \\"hello world\\"`, the result should be `\\"olleh dlrow\\"`. Return the resultant string.","solution":"def reverse_words_and_string(s): Given a string s, reverse the order of the words in the string and reverse each word as well. Parameters: s (str): A string formatted as multiple words separated by single spaces with no leading or trailing spaces. Returns: str: The resultant string with reversed words and their order reversed. words = s.split() reversed_words = [word[::-1] for word in words] reversed_sentence = \' \'.join(reversed_words[::-1]) return reversed_sentence"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to determine if there are three distinct integers in `arr` that add up to the given `target`. Return `true` if there exist such integers, otherwise, return `false`. The function should handle an array of length up to 10^3.","solution":"def three_sum(arr, target): Returns true if there are three integers in the array `arr` that add up to `target`, otherwise returns false. arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: curr_sum = arr[i] + arr[left] + arr[right] if curr_sum == target: return True elif curr_sum < target: left += 1 else: right -= 1 return False"},{"question":"Ana is organizing a string-based puzzle competition and she wants to track participants\' performance over time. She has a **0-indexed** string `s` consisting of lowercase English letters and a **0-indexed** 2D integer array `actions` where `actions[i] = [type, left, right / char]`. Each `actions[i]` can be of two types: - If `type` is `1`, find the number of unique characters in the substring `s[left...right]`. - If `type` is `2`, replace the character at index `left` in string `s` with character `char`. Return an array `results` where `results[i]` is the result of the `i-th` action if `type` is `1`. Example: Given `s = \\"abcdabc\\"` and `actions = [[1, 0, 3], [2, 2, \'z\'], [1, 1, 4]]`, after performing the actions, the results array should be `[4, 4]`. Note: 1. For `type 2` actions, you will only need to perform the replacement operation and there won\'t be any additional output for them. 2. The `results` array should only include results from the `type 1` actions in sequence of their occurrences.","solution":"def perform_actions(s, actions): results = [] s = list(s) # Convert string to list for easy manipulation for action in actions: if action[0] == 1: left, right = action[1], action[2] substring = s[left:right + 1] unique_chars = len(set(substring)) results.append(unique_chars) elif action[0] == 2: index, char = action[1], action[2] s[index] = char return results"},{"question":"Given an array of strings `words`, find and return all strings that are anagrams of another string in the array. An anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once. Strings should be returned in the order they appear in the input array. If no strings are anagrams of another string, return an empty list.","solution":"def find_anagrams(words): Returns a list of strings that are anagrams of another string in the array. Parameters: words (list): List of strings. Returns: list: List of anagram strings. from collections import defaultdict anagrams_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams_dict[sorted_word].append(word) result = [] for word_list in anagrams_dict.values(): if len(word_list) > 1: result.extend(word_list) return result"},{"question":"You are given a linked list `head` where each node contains a positive integer. Every `k` nodes in the linked list will be reversed in the group. Return _the modified linked list after reversing every `k` nodes_. You may not alter the values within the nodes, only the nodes themselves may be changed. If the number of nodes is not a multiple of `k` then all remaining nodes should remain as they are.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): def reverse_linked_list(start, end): prev, curr = end, start while curr != end: curr.next, prev, curr = prev, curr, curr.next return prev dummy = ListNode(0) dummy.next = head group_prev = dummy while True: kth = group_prev for _ in range(k): kth = kth.next if not kth: return dummy.next group_next = kth.next reverse_linked_list(group_prev.next, group_next) new_group_prev = group_prev.next group_prev.next.next = group_next group_prev.next = kth group_prev = new_group_prev return dummy.next"},{"question":"Given a binary tree, where each node contains an integer value, return _a 2D array where each element is a list of integers representing the node values at each depth level from top to bottom_. The root node is at depth level 0, its children are at depth level 1, their children are at depth level 2, and so on. If the tree is empty, return an empty list. For example: ``` 1 / 2 3 / / 4 5 6 ``` Return `[[1], [2, 3], [4, 5, 6]]`.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"You are given a **0-indexed** 1D integer array `houses`, where `houses[i]` represents the position of the ith house along a street. You are also given an integer `k`, the number of heaters you can place. You can place heaters at any integer position along the street. Each heater covers all houses within a distance of `d`, meaning if you place a heater at position `p`, it will cover all houses from position `p - d` to `p + d`. Return _the **minimum** `d` such that all houses can be covered by the `k` heaters_.","solution":"def can_cover_with_d(houses, k, d): Helper function to check if all houses can be covered by k heaters with a given radius d. heaters_count = 0 i = 0 while i < len(houses): heaters_count += 1 if heaters_count > k: return False # Place the heater to cover as many houses as possible cover_position = houses[i] + d # Move i to the next house which is not covered by this heater while i < len(houses) and houses[i] <= cover_position + d: i += 1 return True def minimum_heater_radius(houses, k): Returns the minimum heater radius `d` such that all houses are covered by `k` heaters. houses.sort() left = 0 right = houses[-1] - houses[0] while left < right: mid = (left + right) // 2 if can_cover_with_d(houses, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a positive integer `n`. Write a function to determine the number of valid parentheses strings of length `2n`. A valid parentheses string is dened as a string of length `2n` that consists only of characters \'(\' and \')\', and is balanced such that every open parenthesis \'(\' has a matching close parenthesis \')\' and the pairs of parentheses are properly nested.","solution":"def catalan_number(n): Returns the nth Catalan number. if n == 0: return 1 catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n] def num_valid_parentheses(n): Returns the number of valid parentheses strings of length 2n. return catalan_number(n)"},{"question":"You are given an array of integers `arr` and an integer `sum`. The array `arr` is sorted in non-decreasing order, and you are tasked to find all unique quadruplets `(a, b, c, d)` where `a`, `b`, `c`, and `d` are elements of `arr` such that `a + b + c + d = sum`. Each quadruplet must be returned as a list of integers `[a, b, c, d]` and the quadruplets should be returned in the form of a list of lists. The order of the quadruplets and the integers within each quadruplet does not matter. Return _a list of all unique quadruplets that sum up to_ `sum`_. If no such quadruplets exist, return an empty list_.","solution":"def four_sum(arr, target): Returns a list of all unique quadruplets [a, b, c, d] such that a + b + c + d = target. arr.sort() result = [] length = len(arr) for i in range(length - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, length - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: result.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return result"},{"question":"Given a string `s` representing a sentence containing words separated by spaces, reverse the order of words in the sentence while preserving the spacing and punctuation. The input sentence can contain multiple spaces between words, punctuation marks, and varying cases. Return the modified sentence.","solution":"def reverse_words(s): Function to reverse the order of words in a sentence while preserving the spacing and punctuation. Arguments: s -- string representing the input sentence Returns: A string with the words in reversed order. # Split the sentence by spaces to get the words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space reversed_sentence = \' \'.join(reversed_words) # Return the reversed sentence return reversed_sentence"},{"question":"You are given a `digits` array where each element is a digit from 0 to 9, forming a large integer. Implement a function `subtractOne(digits)` that subtracts one from the number represented by the array. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. Assume the number does not contain any leading zeros, except for the number 0 itself. Return the resulting array of digits after subtracting one.","solution":"def subtractOne(digits): Subtracts one from the number represented by the digits array. n = len(digits) # Start from the end of the array for i in range(n-1, -1, -1): if digits[i] > 0: digits[i] -= 1 break else: digits[i] = 9 # If the first element is zero and the array length is greater than 1, remove it if digits[0] == 0 and len(digits) > 1: digits.pop(0) return digits"},{"question":"You are given a list of integers `nums`, where `nums[i]` is the number of books on the `i-th` shelf. You need to redistributes these books among the shelves in such a way that the difference between the shelf with the maximum number of books and the shelf with the minimum number of books is minimized. You are allowed to move books between any two shelves an arbitrary number of times. Return the minimum possible difference between the maximum number of books on any shelf and the minimum number of books on any shelf.","solution":"def min_books_difference(nums): Returns the minimum difference between the maximum and minimum number of books on any shelf after redistributing. # The minimum possible difference is zero if all shelves can have the same number of books return 0 if nums else None"},{"question":"Given an integer array `arr` of length `n`, where each element represents the cost of a task, you are required to complete exactly two distinct tasks and maximize the sum of their costs such that their indices satisfy the condition that the absolute difference between the indices of the chosen tasks is at least `d` (i.e., if `i` and `j` are the indices of the chosen tasks, then |i - j| >= d). Return the maximum sum of the costs of two such tasks, or `-1` if it\'s not possible to fulfill the condition.","solution":"def max_sum_of_tasks(arr, d): Returns the maximum sum of costs of two distinct tasks such that their indices have an absolute difference >= d. n = len(arr) if n < 2 or d >= n: return -1 max_task_cost = -1 for i in range(n): for j in range(i + d, n): max_task_cost = max(max_task_cost, arr[i] + arr[j]) return max_task_cost if max_task_cost != -1 else -1"},{"question":"Given an integer array `nums` representing the amount of weight you can lift for each day and an integer `k` representing the number of consecutive days you must perform the exercise, find the maximum sum of the weight you can lift in any consecutive `k` days. If you cannot lift weights for `k` consecutive days due to the length of the array being smaller than `k`, return `0`.","solution":"def max_weight_lift(nums, k): Finds the maximum sum of weights lifted in any consecutive k days. :param nums: List of integers representing the amount of weight lifted each day. :param k: Integer representing the number of consecutive days. :return: Maximum sum of weights lifted in any consecutive k days, or 0 if it is not possible. if len(nums) < k: return 0 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum += nums[i] - nums[i-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an unsorted array of integers `nums`, and an integer `k`, find the `k`th largest element in the array. Implement an efficient solution that scales well with input size by using a priority queue (min-heap) for instances where `k` is significantly smaller than the length of the array. Return the `k`th largest element in the array.","solution":"import heapq def find_kth_largest(nums, k): Find the k-th largest element in an unsorted array using a min-heap. Args: nums: List[int] The list of integers. k: int The k-th largest index (1-based). Returns: int The k-th largest element in the array. min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"Write a function `findMinPathSum(grid)` that takes a 2D list `grid` representing a matrix filled with non-negative integers. Your task is to find the minimum sum of elements along any path from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. Return the minimum path sum.","solution":"def findMinPathSum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid moving only right or down. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a dp grid to store the minimum path sum up to each cell dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the values for the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the values for the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Compute minimum path sums for the rest of the cells for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[rows-1][cols-1]"},{"question":"You are given a **0-indexed** array of integers `arr`. A **subarray** is defined as a contiguous subsequence of `arr`. We say that a subarray is **monotonic** if it is either strictly increasing or strictly decreasing. Your task is to determine the number of monotonic subarrays in `arr`. Return _the total number of monotonic subarrays_.","solution":"def count_monotonic_subarrays(arr): Returns the number of monotonic subarrays in the given array `arr`. A subarray is monotonic if it is either strictly increasing or strictly decreasing. def is_increasing(a, b): return a < b def is_decreasing(a, b): return a > b n = len(arr) count = 0 i = 0 while i < n: length = 1 # Check for increasing subarrays while i + 1 < n and is_increasing(arr[i], arr[i+1]): i += 1 length += 1 count += (length * (length - 1)) // 2 length = 1 start = i # Check for decreasing subarrays while i + 1 < n and is_decreasing(arr[i], arr[i+1]): i += 1 length += 1 count += (length * (length - 1)) // 2 if i == start: i += 1 return count"},{"question":"Given an integer array `nums` and an integer `k`, please calculate the minimum value of `x` such that there are at least `k` elements in the array greater than or equal to `x`. If no such `x` exists, return `-1`. Note that the elements of the array and `k` are indexed from `1`.","solution":"def min_value_for_k_elements(nums, k): # Sort the array in descending order nums.sort(reverse=True) # Check if there are at least k elements in the array if k <= len(nums): # Return the k-th element (1-indexed, so we use k-1) return nums[k - 1] else: return -1"},{"question":"You are given an array of `n` integers `arr`. Your task is to form the smallest possible contiguous subarray where the sum of its elements is greater than or equal to a given integer `x`. If no such subarray exists, return `-1`. The subarray should be chosen such that its length is minimized. Return the length of this subarray.","solution":"def min_subarray_len(arr, x): Returns the length of the smallest contiguous subarray where the sum is greater than or equal to x. If no such subarray exists, return -1. n = len(arr) min_len = float(\'inf\') left = 0 curr_sum = 0 for right in range(n): curr_sum += arr[right] while curr_sum >= x: min_len = min(min_len, right - left + 1) curr_sum -= arr[left] left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to determine whether the array can be partitioned into exactly `k` subarrays, such that the sum of elements in each subarray is equal. Return `true` if such a partition is possible, otherwise return `false`. Implement the function `canPartitionKSubarrays(arr, k)` which respects these conditions.","solution":"def canPartitionKSubarrays(arr, k): total_sum = sum(arr) # If total sum is not divisible by k, then we cannot partition it into k subarrays with equal sum if total_sum % k != 0: return False subarray_sum = total_sum // k used = [False] * len(arr) def can_partition(start_index, k_remaining, current_sum): # If only one subarray is remaining, it must be the valid subarray with the required sum if k_remaining == 1: return True if current_sum == subarray_sum: # A subarray with the required sum is found, try to find the next one return can_partition(0, k_remaining - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= subarray_sum: # Select this element and mark as used used[i] = True if can_partition(i + 1, k_remaining, current_sum + arr[i]): return True used[i] = False return False return can_partition(0, k, 0)"},{"question":"You are given an integer array `arr` where each element represents the consumption rate of water per hour for different plants placed in a line. You need to water the plants using buckets of limited capacity. Each bucket has a capacity `k` and the watering process starts from the first plant. If you run out of water in the bucket before watering a plant, you need to refill the bucket to full before continuing. You may refill the bucket an unlimited number of times. Return the minimum number of refills you will need to water all the plants. # Example: - Input: `arr = [2, 4, 3, 5]`, `k = 6` - Output: `3` # Explanation: - You start with a bucket of 6 units. - Water plant 0 with 2 units, 4 units left. - Water plant 1 with 4 units, 0 units left (refill: 1). - Refill the bucket to 6 units, water plant 2 with 3 units, 3 units left. - Water plant 3 with 5 units, 0 units left (refill: 2). - Refill the bucket (finally), no units remain unused (total: 3 refills).","solution":"def min_refills(arr, k): Returns the minimum number of refills needed to water all the plants. Parameters: arr (list): A list of integers representing the consumption rate of water per hour for different plants. k (int): the capacity of the bucket. Returns: int: The minimum number of refills needed. refills = 0 current_capacity = k for consumption in arr: if current_capacity >= consumption: current_capacity -= consumption else: refills += 1 current_capacity = k - consumption return refills"},{"question":"You are given a string `s` and a list of words `words`. Determine the **number of words** in `words` that are **subsequences** of `s`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \\"ace\\" is a subsequence of \\"abcde\\", but \\"aec\\" is not. Return _the total number of words in `words` that are subsequences of `s`_. The test cases are generated so that the total length of input string `s` and all the strings in `words` combined does not exceed 10^5.","solution":"def is_subsequence(s, word): Helper function to check if word is a subsequence of s it = iter(s) return all(char in it for char in word) def num_matching_subseq(s, words): Returns the number of words that are subsequences of s count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"You are given an array of integers `nums`. In one operation, you can choose two indices `i` and `j` (where `i != j`) and replace `nums[i]` and `nums[j]` with their sum and their absolute difference. Your task is to determine the minimum possible value of the largest element in the array after performing any number of operations. Return _the minimum possible value of the largest element in the array_.","solution":"from functools import reduce from math import gcd def min_largest_element(nums): Determines the minimum possible value of the largest element in the array after any number of operations. :param nums: List[int] - an array of integers :return: int - the minimum possible value of the largest element in the array # The number can be reduced to the gcd of all numbers in the array array_gcd = reduce(gcd, nums) return array_gcd"},{"question":"You are given a grid consisting of `m` rows and `n` columns. Each cell in the grid contains a non-negative integer which represents the time taken to pass through that cell. You are tasked with finding the minimum time required to travel from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of the grid. You can only move right or down at each step. Implement a function that returns the minimum time. (Note: This problem requires the understanding of dynamic programming or pathfinding algorithms such as Dijkstra\'s or the A* search algorithm.)","solution":"def min_travel_time(grid): Finds the minimum time required to travel from top-left to bottom-right of the grid. :param grid: List[List[int]] :return: int if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp array where dp[i][j] represents the minimum time to reach cell (i, j) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given an array of integers `heights` representing the heights of columns where the width of each column is 1. Compute how much water can be trapped after raining if the columns form a histogram. The function should return an integer representing the total units of trapped water. Write an algorithm with `O(n)` time complexity and use only `O(1)` additional space.","solution":"def trap(height): Given a list of non-negative integers representing elevation heights, determines the amount of water that can be trapped after raining. Args: height: List[int] - Non-negative integers representing column heights. Returns: int - Total units of trapped water. if not height: return 0 left = 0 right = len(height) - 1 left_max = height[left] right_max = height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"Given two integers `n` and `x`, return the number of ways you can write `n` as the sum of exactly `x` positive integers. Each combination should be considered unique based on the order of the numbers, not the set of numbers. For example, for `n = 5` and `x = 2`, the valid combinations are (1, 4), (2, 3), (3, 2), and (4, 1).","solution":"def ways_to_write_sum(n, x): Returns the number of ways to write n as the sum of exactly x positive integers. Each unique permutation is considered. # Use dynamic programming to solve this problem if x == 0 and n > 0: return 0 if x == 0 and n == 0: return 1 if n == 0 and x > 0: return 0 dp = [[0 for _ in range(n + 1)] for _ in range(x + 1)] dp[0][0] = 1 # There\'s exactly one way to sum to 0 using 0 elements. for i in range(1, x + 1): for j in range(1, n + 1): for k in range(1, j + 1): dp[i][j] += dp[i - 1][j - k] return dp[x][n]"},{"question":"You are given two positive integers `a` and `b`. Implement a function to find their greatest common divisor (GCD) using the Euclidean algorithm. The Euclidean algorithm is a well-known method to compute the GCD of two numbers based on the principle that the GCD of two numbers also divides their difference. Return the greatest common divisor of `a` and `b`. For example, the greatest common divisor of 48 and 18 is 6.","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of two positive integers a and b using the Euclidean algorithm. while b: a, b = b, a % b return a"},{"question":"You are given a 2D grid `grid` of size `rows x cols` where each cell is either `0` (empty) or `1` (blocked). You are also given an integer `k`. A valid path starts from the top-left corner `(0,0)` and ends at the bottom-right corner `(rows-1, cols-1)`, and you can move up, down, left, or right at each step. However, you can eliminate up to `k` blocked cells along the way during the traversal. Return the minimum number of steps required to walk from the top-left corner to the bottom-right corner, or return `-1` if there is no valid path.","solution":"from collections import deque def shortest_path(grid, k): rows, cols = len(grid), len(grid[0]) if rows == 1 and cols == 1: # Starting and ending on the same cell return 0 # Initialize the queue with the starting point, 0 steps, and `k` eliminations left queue = deque([(0, 0, 0, k)]) visited = set((0, 0, k)) while queue: x, y, steps, remaining_k = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right movements nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: # Check boundaries new_eliminations = remaining_k - grid[nx][ny] if new_eliminations >= 0: # If we can still eliminate cells if (nx, ny) == (rows - 1, cols - 1): # Reached the bottom-right corner return steps + 1 if (nx, ny, new_eliminations) not in visited: visited.add((nx, ny, new_eliminations)) queue.append((nx, ny, steps + 1, new_eliminations)) return -1"},{"question":"You are given a `m x n` integer grid `heights` representing the height of each unit cell in a continent. The ocean water can flow either from the Pacific or the Atlantic, and from one cell water can flow to another if and only if the height of the next cell is less than or equal to its own height. The Pacific ocean touches the left and top edges of the grid, and the Atlantic ocean touches the right and bottom edges. Write an algorithm to return a list of all grid coordinates `result` where water can flow to both the Pacific and Atlantic oceans. Example: ``` Input: heights = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] ``` Explanation: - From point `[0,4]`, water can flow to both the Pacific and Atlantic oceans. - From point `[1,3]`, water can flow to both the Pacific and Atlantic oceans. And so on for each coordinate in the result list. Note: - The order of the output list does not matter.","solution":"def pacific_atlantic(heights): if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable_set, prev_height): if ((r, c) in reachable_set or r < 0 or c < 0 or r >= m or c >= n or heights[r][c] < prev_height): return reachable_set.add((r, c)) for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(r + dr, c + dc, reachable_set, heights[r][c]) for i in range(m): dfs(i, 0, pacific_reachable, heights[i][0]) dfs(i, n - 1, atlantic_reachable, heights[i][n - 1]) for j in range(n): dfs(0, j, pacific_reachable, heights[0][j]) dfs(m - 1, j, atlantic_reachable, heights[m - 1][j]) results = [] for i in range(m): for j in range(n): if (i, j) in pacific_reachable and (i, j) in atlantic_reachable: results.append([i, j]) return results"},{"question":"Given a binary string `s` that contains only characters \'0\' and \'1\'. You can change at most one \'0\' to \'1\' to form a contiguous substring of \'1\'s. Return the length of the longest contiguous substring of \'1\'s you can achieve.","solution":"def longest_contiguous_ones(s): Returns the length of the longest contiguous substring of \'1\'s one can achieve by changing at most one \'0\' to \'1\'. max_len = 0 zero_count = 0 left = 0 for right in range(len(s)): if s[right] == \'0\': zero_count += 1 while zero_count > 1: if s[left] == \'0\': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of student scores on a recent exam, represented as an array of integers. Additionally, you are given a list of queries where each query asks for the number of students who scored within a specific range. The range will be given as a pair of integers `[low, high]` inclusive. Implement a function that processes all the queries and returns the results in an array. Each element in the result array should correspond to the number of students who scored within the range for that particular query. For example, given the scores `[85, 78, 90, 95, 67, 88]` and the queries `[[70, 80], [85, 95], [60, 70]]` the function should return `[1, 4, 1]` since one student scored between 70 and 80, four students scored between 85 and 95, and one student scored between 60 and 70.","solution":"def count_scores_within_range(scores, queries): Returns a list of count of students who scored within given ranges for each query. Parameters: scores (list of int): List of student scores. queries (list of list of int): List of queries where each query is a list with two integers [low, high]. Returns: list of int: List of counts for each query. results = [] for low, high in queries: count = sum(1 for score in scores if low <= score <= high) results.append(count) return results"},{"question":"You are given a string `s` containing only digits `0-9` and a target value `target`. Return all possibilities to add binary operators (`+`, `-`, or `*`) between the digits of `s` so that the resultant expression evaluates to the `target` value. Note that operands in the returned expressions should not contain leading zeros (e.g., \\"05\\" is not valid). You may return the answers in any order.","solution":"def addOperators(num, target): def backtrack(index, prev_operand, current_operand, value, expression): if index == len(num): if value == target and current_operand == 0: results.append(\\"\\".join(expression[1:])) return current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) if current_operand > 0: backtrack(index + 1, prev_operand, current_operand, value, expression) expression.append(\'+\') expression.append(str_op) backtrack(index + 1, current_operand, 0, value + current_operand, expression) expression.pop() expression.pop() if expression: expression.append(\'-\') expression.append(str_op) backtrack(index + 1, -current_operand, 0, value - current_operand, expression) expression.pop() expression.pop() expression.append(\'*\') expression.append(str_op) backtrack(index + 1, prev_operand * current_operand, 0, value - prev_operand + (prev_operand * current_operand), expression) expression.pop() expression.pop() results = [] if num: backtrack(0, 0, 0, 0, []) return results"},{"question":"You are given an integer array `heights` representing the height of buildings in a city skyline. Each building is represented by an index in the array, and the value at that index is the building\'s height. You are also given an integer `vantagePoint` which represents the index position in the `heights` array from where you are viewing the skyline. Return the visibility count of buildings from this vantage point to the end of the array. A building at index `i` is visible if there is no taller building between index `i` and the `vantagePoint`. In other words, a building `i` is visible if all buildings between `i` and `vantagePoint` inclusive are not taller than the building at index `i`.","solution":"def visible_buildings(heights, vantagePoint): Returns the count of visible buildings from the vantagePoint to the end of the array. Parameters: heights (list of int): Array representing heights of buildings. vantagePoint (int): Index representing the vantage point from where to start viewing. Returns: int: Count of visible buildings. n = len(heights) visible_count = 0 current_max_height = 0 for i in range(vantagePoint, n): if heights[i] > current_max_height: visible_count += 1 current_max_height = heights[i] return visible_count"},{"question":"Given a list of non-negative integers, each representing the amount of some resource from a list `resources` and an integer `k`, determine the maximum value of the minimum amount of resource each person can get if you distribute the resources among `k` people. Each person should get at least one unit of resource. Return the maximum value of the minimum amount of resource that can be distributed. For example, if the input `resources` is `[5, 9, 7]` and `k` is `3`, the maximum value of the minimum amount each person can get is `5`.","solution":"def can_distribute(resources, k, minimum_amount): Helper function to check if it\'s possible to distribute resources such that each person gets at least `minimum_amount` resources. count = 0 for resource in resources: count += resource // minimum_amount return count >= k def maximum_minimum_distribution(resources, k): Determine the maximum value of the minimum amount of resources each person can get. low, high = 1, sum(resources) // k while low <= high: mid = (low + high) // 2 if can_distribute(resources, k, mid): low = mid + 1 else: high = mid - 1 return high"},{"question":"You are given a string `expression` containing digits, `+`, `-`, `*`, `(`, `)`, and spaces. Evaluate the arithmetic expression and return the result as an integer. The integer division should truncate toward zero and the result is guaranteed to be within the range of a 32-bit signed integer. You may assume the given `expression` is always valid. Note: You are not allowed to use the built-in `eval` function or any similar built-in functions/libraries for the evaluation.","solution":"def evaluate(expression: str) -> int: def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return int(a / b) # use int() for truncating division towards zero def evaluate_tokens(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(val1, val2, op)) return values[-1] tokens = list(expression) return evaluate_tokens(tokens)"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Find the `k`th smallest element in the array. The `k`th smallest element is the element that would be in the `k`th position of the sorted array (1-indexed). You must solve it with a time complexity better than `O(n log n)`. Return the `k`th smallest element.","solution":"import heapq def kth_smallest(arr, k): Finds the k-th smallest element in the array. :param arr: List[int] - The list of integers. :param k: int - The k-th position in the sorted array (1-indexed). :return: int - The k-th smallest element in the array. # Convert k to 0-indexed k -= 1 return heapq.nsmallest(k + 1, arr)[-1]"},{"question":"Given a sorted array of `n` unique integers where each integer is in the range from `0` to `n - 1`, and each index in the array represents a node in a binary search tree (BST). Suppose the BST is constructed by inserting the elements in the sorted order. Your task is to return the height of this tree. The height of a binary search tree is defined as the number of edges on the longest path from the root to a leaf.","solution":"def find_height_of_bst(sorted_array): Returns the height of the binary search tree formed by inserting elements in sorted order. The height of a binary search tree with elements inserted in sorted order will be n - 1 where n is the number of elements in the array. n = len(sorted_array) if n == 0: return -1 # no nodes return n - 1 # height of BST with sorted insertion"},{"question":"Given an array of integers `heights`, where `heights[i]` represents the height of the `i-th` building, return _the maximum area of a rectangle made by any two buildings such that the smaller building is the limiting height and the width is the distance between them_. Remember, the rectangles are constrained to lie on the x-axis (i.e., the buildings must be aligned horizontally).","solution":"def max_area(heights): Returns the maximum area of a rectangle formed by any two buildings. Arguments: heights -- a list of integers representing the heights of buildings. Returns: int -- the maximum area of the rectangle. max_area = 0 left, right = 0, len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given an integer array `nums` of size `n`, where `n` is an even number, you need to partition the array into two subsets with equal sum. Determine _if it is possible_ to partition the array into two subsets such that the sum of both subsets is equal. Return _true_ if you can partition the array this way, and _false_ otherwise. Your solution should have a time complexity of _O(n * sum(nums))_, where `sum(nums)` is the sum of all elements in the array.","solution":"def canPartition(nums): Determine if the array can be partitioned into two subsets with equal sum. :param nums: List of integers :return: Boolean indicating if the partition is possible total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"[Question]: Given an integer array `elements` of length `n`, you need to perform the following operations in order to make all the elements of the array the same. You can do the following operations any number of times on `elements`: - Choose any element in the array and add or subtract `1` from it. The cost of one operation is equal to the absolute difference between the current value of the element and the target value. Return the minimum total cost to make all the elements of the array the same. If there are multiple possible target values that yield the same minimum cost, choose the smallest target value.","solution":"def min_cost_to_make_elements_equal(elements): Computes the minimum cost to make all elements of the array the same. if not elements: return 0 elements.sort() median = elements[len(elements) // 2] total_cost = sum(abs(element - median) for element in elements) return total_cost"},{"question":"You are given two integers `m` and `n`, representing a grid with `m` rows and `n` columns. You are also given an array `positions` where `positions[i] = [ri, ci]` represents adding a new building at the position `(ri, ci)` on the grid. A building occupies one cell and no two buildings will be in the same cell. The grid has `0`-indexed coordinates. Initially, the grid is empty and every cell contains `water`. Every time a building is added, it connects its neighboring cells vertically and horizontally that have buildings, forming a cluster of buildings. Return an array of integers `result` where `result[i]` is the number of clusters of buildings after adding the building at `positions[i]`.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.count -= 1 return True return False def increment_count(self): self.count += 1 def get_count(self): return self.count def num_islands2(m, n, positions): def get_index(x, y): return x * n + y uf = UnionFind(m * n) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] occupied = set() result = [] for x, y in positions: if (x, y) in occupied: result.append(uf.get_count()) continue index = get_index(x, y) uf.increment_count() occupied.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) in occupied: uf.union(index, get_index(nx, ny)) result.append(uf.get_count()) return result"},{"question":"Given an integer array `arr` and an integer `target`, return _the closest possible sum of any three distinct elements in `arr` that is closest to the `target`_. If there are multiple such sums, return the smallest sum. The array may contain both positive and negative integers.","solution":"def closest_three_sum(arr, target): Finds the closest possible sum of any three distinct elements in `arr` to the `target`. arr.sort() closest_sum = float(\'inf\') for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return current_sum # If the exact sum is found, return it if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum elif abs(target - current_sum) == abs(target - closest_sum): closest_sum = min(closest_sum, current_sum) if current_sum < target: left += 1 else: right -= 1 return closest_sum"},{"question":"You are given two integers `a` and `b` representing the dimensions of a chocolate bar that is divided into `a * b` square pieces. At each move, you can split any chocolate piece into two smaller rectangular pieces by making one horizontal or vertical cut in one of the current pieces. Return the minimum number of moves required to split the entire chocolate bar into individual `1x1` pieces.","solution":"def min_moves(a, b): Returns the minimum number of moves required to split an a*b chocolate bar into 1x1 pieces. # To split an a*b chocolate bar into 1x1 pieces, we need to make (a*b - 1) cuts. return a * b - 1"},{"question":"You are given a string `s` consisting of only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You can delete any number of characters from `s` to make it a subsequence of the string `\\"abc\\"` or `\\"acb\\"`. Return _the minimum number of deletions needed to achieve this_.","solution":"def min_deletions_to_subsequence(s): Returns the minimum number of deletions needed to make the input string s a subsequence of \\"abc\\" or \\"acb\\". def count_deletions(target): j = 0 for i in range(len(s)): if j < len(target) and s[i] == target[j]: j += 1 return len(s) - j return min(count_deletions(\\"abc\\"), count_deletions(\\"acb\\"))"},{"question":"You are given an array of integers `heights` representing the heights of structures such that `heights[i]` is the height of the structure at index `i`. A **skyline** is generated by these structures when viewed from the right side such that only the tallest structures are visible in the view. A structure `i` is considered visible if there is no structure `j` (where `i < j`) with a height greater than or equal to `heights[i]`. Return an array representing the indices of the structures that are visible in the skyline when viewed from the right side. The skyline should be listed in the order of visibility from right to left.","solution":"def visible_structures(heights): Returns the indices of the structures that are visible in the skyline when viewed from the right side, in the order of visibility from right to left. n = len(heights) if n == 0: return [] visible_indices = [] max_height = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height: visible_indices.append(i) max_height = heights[i] return visible_indices[::-1]"},{"question":"Given a list of integers `nums`, return a list of integers where each element at index `i` of the output list is equal to the product of all the elements of `nums` except `nums[i]`. You must solve this problem without using division.","solution":"def product_except_self(nums): Given a list of integers nums, return a list of integers where each element at index i of the output list is equal to the product of all the elements of nums except nums[i]. n = len(nums) if n == 0: return [] # Create two arrays for left and right products left_products = [1] * n right_products = [1] * n # Fill left_products list such that left_products[i] contains product of all elements to the left of nums[i] for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products list such that right_products[i] contains product of all elements to the right of nums[i] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Create the result array where each element is the product of the corresponding left and right products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"You are given an integer array `arr` and an integer `k`. A partition of the array into contiguous subarrays is considered valid if the maximum element in each subarray is at most `k` greater than the minimum element in that subarray. Return _the maximum number of valid partitions you can achieve from the array_.","solution":"def max_valid_partitions(arr, k): Returns the maximum number of valid partitions for the provided array. Partitions are valid if the max element in each subarray is at most k greater than the min element. if not arr: return 0 partitions = 1 min_elem = max_elem = arr[0] for num in arr[1:]: min_elem = min(min_elem, num) max_elem = max(max_elem, num) # Check if the current number can be part of the current partition if max_elem - min_elem > k: partitions += 1 min_elem = max_elem = num return partitions"},{"question":"Given an array of integers `arr`, find the minimum number of moves required to make the array sorted in non-decreasing order. In one move, you are allowed to select any subarray from the array and reverse it. Return _the minimum number of moves required to sort the array in non-decreasing order._ A subarray is a contiguous part of an array.","solution":"def minMovesToSortArray(arr): Returns the minimum number of moves required to sort the array in non-decreasing order by reversing subarrays. n = len(arr) sorted_arr = sorted(arr) # Two pointers technique to find the minimum subarray that needs to be reversed left, right = 0, n - 1 while left < n and arr[left] == sorted_arr[left]: left += 1 while right >= 0 and arr[right] == sorted_arr[right]: right -= 1 # If array is already sorted if left >= right: return 0 # Check if reversing the subarray from left to right makes the array sorted subarray = arr[left:right + 1] if subarray == subarray[::-1] or arr[:left] + subarray[::-1] + arr[right + 1:] == sorted_arr: return 1 return 2 # If more than one move is needed, at most it will be 2 moves"},{"question":"You are given a list of non-negative integers representing the daily amount of rainfall in a city over a period. Implement the `RainfallTracker` class that has the following methods: * `RainfallTracker()` Initializes an empty `RainfallTracker` object. * `void addRainfall(int day, int amount)` Adds the specified amount of rainfall to the given day. If rainfall data for the day already exists, it increments the existing amount by the new amount. * `int totalRainfall()` Returns the total amount of rainfall recorded up to the current day. * `double averageRainfall()` Returns the average daily rainfall up to the current day. If no rainfall data is available, return `0.0`. * `List<Integer> maxRainfallDays()` Returns a list of days with the highest recorded rainfall. If there are multiple days with the same highest amount, include all such days. Ensure the output of each method matches its expected result as described above.","solution":"class RainfallTracker: def __init__(self): self.rainfall_data = {} def addRainfall(self, day, amount): if day in self.rainfall_data: self.rainfall_data[day] += amount else: self.rainfall_data[day] = amount def totalRainfall(self): return sum(self.rainfall_data.values()) def averageRainfall(self): total_days = len(self.rainfall_data) if total_days == 0: return 0.0 return self.totalRainfall() / total_days def maxRainfallDays(self): if not self.rainfall_data: return [] max_rainfall = max(self.rainfall_data.values()) return [day for day, amount in self.rainfall_data.items() if amount == max_rainfall]"},{"question":"You are given a **0-indexed** integer array `tasks` of length `n`, where `tasks[i]` represents the duration of the `i-th` task. You are also given an integer `k`, which represents the maximum time that a single worker can continue working without taking a break. Each worker must take a break of duration `k` after working consecutively for `k` time units. You need to assign tasks to workers such that each task is assigned to a single worker and all tasks are completed in sequence. Return _the **minimum** number of workers needed_ to complete all the tasks. For example, if `tasks = [2, 3, 4]` and `k = 5`, one way to assign tasks is by letting worker `1` complete tasks `0` and `1` and worker `2` complete task `2`, which requires a minimum of `2` workers.","solution":"def min_workers(tasks, k): Returns the minimum number of workers needed to complete all the tasks. workers_needed = 0 current_time = 0 for task in tasks: if current_time + task <= k: current_time += task else: workers_needed += 1 current_time = task if current_time > 0: workers_needed += 1 return workers_needed"},{"question":"Given an integer matrix `mat`, where `mat[i][j]` represents the cost of moving through cell `(i, j)`, find the minimum path sum from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Return the minimum path sum.","solution":"def min_path_sum(mat): Returns the minimum path sum from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param mat: A list of list of integers representing the matrix :return: Integer representing the minimum path sum if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) # Create a DP table to store the minimum path sum for each cell dp = [[0] * cols for _ in range(rows)] # Initialize the DP table with the starting point dp[0][0] = mat[0][0] # Fill in the first row (only move right possible) for j in range(1, cols): dp[0][j] = dp[0][j-1] + mat[0][j] # Fill in the first column (only move down possible) for i in range(1, rows): dp[i][0] = dp[i-1][0] + mat[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[rows-1][cols-1]"},{"question":"A warehouse has multiple packages with different weights and values. You are tasked to select some of these packages to maximize the total value while keeping the total weight below or equal to a given maximum weight limit. You are given an array `weights` where `weights[i]` is the weight of the `ith` package, an array `values` where `values[i]` is the value of the `ith` package, and an integer `maxWeight` representing the maximum weight capacity of the warehouse. Return the maximum total value of the packages that can be selected without exceeding the maximum weight capacity.","solution":"def knapsack(weights, values, maxWeight): Returns the maximum value of the packages that can be selected without exceeding maxWeight. :param weights: List of weights of the packages :param values: List of values of the packages :param maxWeight: Maximum weight capacity :return: Maximum total value n = len(weights) dp = [[0] * (maxWeight + 1) for _ in range(n + 1)] # Build dp table for i in range(1, n + 1): for w in range(maxWeight + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][maxWeight]"},{"question":"You are given two strings `s` and `t` of the same length that consist of only lowercase letters. Your task is to determine if you can transform string `s` into string `t` by permuting (rearranging) the characters of `s`. Return `true` if it is possible, or `false` otherwise.","solution":"def can_transform(s, t): Determine if string s can be transformed into string t by permuting the characters of s. Parameters: s (str): The original string. t (str): The target string to be checked for permutability. Returns: bool: True if s can be permuted to form t, otherwise False. from collections import Counter return Counter(s) == Counter(t)"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is called a **palindrome** if it reads the same backward as forward. The palindromic length of a substring is defined as the count of characters in it. Given an integer `k`, return the length of the **longest palindromic substring** of `s` that is at least of length `k`. If there is no such substring, return `0`.","solution":"def longest_palindromic_substring(s, k): Returns the length of the longest palindromic substring of `s` that is at least of length `k`. If there is no such substring, returns `0`. def is_palindrome(subs): return subs == subs[::-1] max_len = 0 n = len(s) for length in range(k, n + 1): for i in range(n - length + 1): substring = s[i:i + length] if is_palindrome(substring): max_len = length break # We are looking for the longest so we can break early return max_len"},{"question":"You have a `binary search tree` (BST) with `n` nodes. Each node in the BST contains a unique integer value. We define the `distance` between two nodes as the number of edges in the shortest path connecting them. You are given references to two nodes, `node1` and `node2` in the BST. Write a function to find the distance between `node1` and `node2`. Return _the distance between the two nodes in the BST_.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root, node1, node2): if not root: return None # If either node1 or node2 is equal to root, then root is LCA if root == node1 or root == node2: return root # Recur for left and right subtrees left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) # If nodes are found in left and right subtrees, return root as LCA if left_lca and right_lca: return root # Otherwise, return the non-null subtree result return left_lca if left_lca else right_lca def find_distance_from_lca(lca, node, distance): if not lca: return -1 if lca == node: return distance left_distance = find_distance_from_lca(lca.left, node, distance + 1) if left_distance != -1: return left_distance return find_distance_from_lca(lca.right, node, distance + 1) def find_distance_between_nodes(root, node1, node2): lca = find_lca(root, node1, node2) if not lca: return -1 distance1 = find_distance_from_lca(lca, node1, 0) distance2 = find_distance_from_lca(lca, node2, 0) return distance1 + distance2"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == target`. Implement the `Solution` class with a method `public boolean twoSum(int[] nums, int target)` that returns `true` if such indices exist, and `false` otherwise.","solution":"def two_sum(nums, target): Given an array of integers `nums` and an integer `target`, determine if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Args: nums (list of int): List of integers. target (int): Target integer. Returns: bool: True if such indices exist, False otherwise. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"Given a list of words, implement a function that returns all the words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard. The QWERTY keyboard rows are: - First row: \\"QWERTYUIOP\\" - Second row: \\"ASDFGHJKL\\" - Third row: \\"ZXCVBNM\\" You may assume that the input list will consist of words containing only letters of the English alphabet. **Example:** Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"]","solution":"def find_words_that_can_be_typed(words): Returns a list of words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard. Parameters: words (list): List of words to be checked Returns: list: List of words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard first_row = set(\\"QWERTYUIOP\\") second_row = set(\\"ASDFGHJKL\\") third_row = set(\\"ZXCVBNM\\") def can_be_typed(word, row): for char in word.upper(): if char not in row: return False return True result = [] for word in words: if can_be_typed(word, first_row) or can_be_typed(word, second_row) or can_be_typed(word, third_row): result.append(word) return result"},{"question":"You are given a directed acyclic graph (DAG) represented by a list of edges `edges`, where `edges[i] = [u, v]` indicates a directed edge from node `u` to node `v`. Your task is to return a topologically sorted order of the nodes in the graph. If there are multiple valid topological orders, return any one of them. Use the adjacency list representation for the graph and ensure that your solution efficiently handles graphs with at least one node up to graphs with several nodes and edges.","solution":"def topological_sort(edges): from collections import defaultdict, deque # Step 1: Build Graph as adjacency list and in-degrees count graph = defaultdict(list) in_degrees = defaultdict(int) nodes = set() for u, v in edges: graph[u].append(v) in_degrees[v] += 1 nodes.add(u) nodes.add(v) # Step 2: Find all nodes with 0 in-degree zero_in_degree_queue = deque([node for node in nodes if in_degrees[node] == 0]) topological_order = [] # Step 3: Perform Kahn\'s Algorithm while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topological_order.append(node) # Decrease in-degrees of neighbours for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological_order contains all nodes, return it if len(topological_order) == len(nodes): return topological_order else: return [] # Return empty list if there is a cycle (though DAG assumption ensures no cycle)"},{"question":"Given an integer array `arr`, you need to implement a class `FindAverage` that supports the following operations: 1. Add a new number to the array. 2. Get the average of all numbers currently in the array. Implement the `FindAverage` class: * `FindAverage()` Initializes the object with an empty array. * `void addNumber(int num)` Adds the integer `num` to the array. * `double getAverage()` Returns the average of all integers in the array. The average should be calculated as a floating-point number.","solution":"class FindAverage: def __init__(self): self.numbers = [] def addNumber(self, num): self.numbers.append(num) def getAverage(self): if len(self.numbers) == 0: return 0.0 return sum(self.numbers) / len(self.numbers)"},{"question":"Given an array of integers `nums` and an integer `target`, return _all unique combinations_ of `nums` elements that sum up to `target`. The same number may be chosen from `nums` an unlimited number of times. Two combinations are considered unique if they have different numbers or the numbers are in different orders. Implement a function that meets the following signature: * `List<List<Integer>> combinationSum(int[] nums, int target)` # Example ```plaintext Input: nums = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Input: nums = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] ``` # Constraints * `1 <= nums.length <= 20` * `1 <= nums[i] <= 50` * `1 <= target <= 500`","solution":"def combinationSum(nums, target): Returns all unique combinations of nums elements that sum up to target. Args: nums (list of int): The list of candidate numbers. target (int): The target sum. Returns: list of list of int: A list containing all unique combinations. def backtrack(start, target, path, results): if target == 0: results.append(list(path)) return elif target < 0: return for i in range(start, len(nums)): path.append(nums[i]) backtrack(i, target - nums[i], path, results) path.pop() results = [] nums.sort() # Optional, to possibly speed up the process backtrack(0, target, [], results) return results"},{"question":"You are given a string `s` consisting of lowercase letters and an integer array `indices` of the same length. The string `s` has its characters shuffled based on the integer array `indices`. Return the original string by rearranging the characters of `s` to their original positions given by `indices`.","solution":"def restore_string(s, indices): Returns the original string by rearranging the characters of s based on the indices provided in the array. restored = [\'\'] * len(s) for char, index in zip(s, indices): restored[index] = char return \'\'.join(restored)"},{"question":"You are given a **0-indexed** integer array `nums` of **even** length `n`. Divide the array into two equal parts: the first `n / 2` elements representing one part and the last `n / 2` elements representing the other part. Return the **minimum possible absolute difference** between the sums of these two parts after performing the following operation exactly once: - Select any integer from either part and move it to the other part. Return _the minimum possible absolute difference between the sums of the two parts after performing the operation_.","solution":"def min_diff_after_moving_one(nums): n = len(nums) part1, part2 = nums[:n//2], nums[n//2:] sum1, sum2 = sum(part1), sum(part2) min_diff = abs(sum1 - sum2) for i in range(n//2): new_sum1, new_sum2 = sum1 - part1[i], sum2 + part1[i] min_diff = min(min_diff, abs(new_sum1 - new_sum2)) new_sum1, new_sum2 = sum1 + part2[i], sum2 - part2[i] min_diff = min(min_diff, abs(new_sum1 - new_sum2)) return min_diff"},{"question":"Given an array of integers `nums`, you need to create a 2D array `result` where each element `result[i]` is a list of integers consisting of elements from `nums` that are divisible by `nums[i]`. The list `result[i]` should be sorted in non-decreasing order. Return the `result` array in the same order as the input array `nums`. For an empty list, return an empty sublist.","solution":"def divisible_pairs(nums): result = [] for i in range(len(nums)): divisible_list = [num for num in nums if num % nums[i] == 0] result.append(sorted(divisible_list)) return result"},{"question":"Given a string `s`, you need to split `s` into a number of substrings, each of which is a palindrome. Return the minimum number of cuts needed to achieve this.","solution":"def min_cut_palindrome_partition(s): Given a string s, returns the minimum number of cuts needed to partition s into palindromic substrings. n = len(s) if n == 0: return 0 dp = [0] * n is_palindrome = [[False] * n for _ in range(n)] for i in range(n): min_cuts = i # maximum cuts so far for j in range(i + 1): if s[j] == s[i] and (i - j <= 2 or is_palindrome[j + 1][i - 1]): is_palindrome[j][i] = True min_cuts = 0 if j == 0 else min(min_cuts, dp[j - 1] + 1) dp[i] = min_cuts return dp[-1]"},{"question":"In a social network represented as an undirected graph, each node represents a user, and each edge represents a friendship between two users. Given an array `edges` where each edge is represented as a pair `[u, v]`, find the number of connected components in the graph. A connected component is a subset of nodes such that there is a path between any two nodes in that subset, and no node in the subset is connected to any node outside it. Return _the number of connected components in the graph_.","solution":"def count_connected_components(n, edges): Returns the number of connected components in an undirected graph represented by n nodes and edges. :param n: Number of nodes in the graph :param edges: List of edges where each edge is represented as a pair [u, v] :return: Number of connected components in the graph def dfs(node): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True stack.extend(graph[current]) # Initialize graph representation graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n num_components = 0 for node in range(n): if not visited[node]: num_components += 1 dfs(node) return num_components"},{"question":"Given an integer array `arr` of length `n`, return an array `answer` such that for each `i` (0 <= i < n), `answer[i]` is equal to the product of all the elements of `arr` except `arr[i]`. You must solve it in `O(n)` time and without using division.","solution":"def product_except_self(arr): Returns an array such that for each element in the input array, the corresponding output element is the product of all other elements in the input array. Solves it in O(n) time complexity and without division. length = len(arr) answer = [1] * length # Traverse the input array from left to right left_product = 1 for i in range(length): answer[i] = left_product left_product *= arr[i] # Traverse the input array from right to left right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= arr[i] return answer"},{"question":"You are given two matrices `A` and `B`, each of size `m x n`. Both matrices are filled with integers. You need to transform matrix `A` into matrix `B` by following these rules: 1. You can choose any element in matrix `A` and increment it by one. 2. The cost to increment any element by one is given as a constant `c`. Calculate the minimum total cost required to transform matrix `A` into matrix `B`. If it is not possible to transform matrix `A` into matrix `B`, return `-1`. Return the minimum cost or `-1` if the transformation is not possible.","solution":"def min_cost_transform(A, B, c): Calculates the minimum cost required to transform matrix A into matrix B. If not possible, returns -1. Parameters: A (list of list of int): The initial matrix. B (list of list of int): The target matrix. c (int): The cost to increment any element in A by one. Returns: int: The minimum total cost required or -1 if transformation is not possible. m = len(A) n = len(A[0]) total_cost = 0 for i in range(m): for j in range(n): if A[i][j] > B[i][j]: return -1 else: total_cost += (B[i][j] - A[i][j]) * c return total_cost"},{"question":"You are given a string `s` consisting of lowercase English letters representing a 24-hour time in \\"HH:mm\\" format. An anagram of `s` is any string that can be formed by rearranging its characters. Return the **earliest** possible valid time that can be formed by an anagram of `s` in \\"HH:mm\\" format. **Note**: For the time to be valid, `00 <= HH < 24` and `00 <= mm < 60`.","solution":"from itertools import permutations def earliest_time(s): Returns the earliest possible valid time from an anagram of the given string s in \\"HH:mm\\" format. for perm in sorted(set(permutations(s))): hh = int(\'\'.join(perm[0:2])) mm = int(\'\'.join(perm[2:4])) if 0 <= hh < 24 and 0 <= mm < 60: return f\\"{perm[0]}{perm[1]}:{perm[2]}{perm[3]}\\" return \\"\\""},{"question":"An e-commerce website keeps track of user purchases and wants to reward users who make frequent purchases. Each user is identified by a unique user ID. You are given two integer arrays, `userID` and `purchase`. The array `userID` contains user IDs, where the `i-th` user ID corresponds to the `i-th` purchase in the `purchase` array. Write a function that returns the user ID of the user who made the most frequent purchases. If there are multiple users with the same highest frequency of purchases, return the user ID with the lowest numerical value.","solution":"from collections import defaultdict def most_frequent_user(userID, purchase): Returns the user ID of the user who made the most frequent purchases. If multiple users have the same highest frequency, return the user with the lowest numerical value. purchase_count = defaultdict(int) # Count the purchases per user for user in userID: purchase_count[user] += 1 # Determine the user with the most frequent purchases max_purchases = 0 frequent_user = float(\'inf\') for user, count in purchase_count.items(): if count > max_purchases or (count == max_purchases and user < frequent_user): max_purchases = count frequent_user = user return frequent_user"},{"question":"Given an array of integers `nums` and an integer `k`, return _the number of distinct subsequences of_ `nums` _that sum up to_ `k`_. A subsequence is derived from the original array by deleting some or no elements without changing the order of the remaining elements._","solution":"def numDistinctSubseqSum(nums, k): Returns the number of distinct subsequences of nums that sum up to k. from collections import defaultdict # Using dynamic programming with a dictionary to count subsequences sums dp = defaultdict(int) dp[0] = 1 for num in nums: # To prevent modifying dp in the middle of the iteration, use a temporary dict tmp = dp.copy() for sum_so_far in dp: new_sum = sum_so_far + num tmp[new_sum] += dp[sum_so_far] dp = tmp return dp[k]"},{"question":"Given a string `s` consisting of lowercase English letters and a word `word`, remove the first and last occurrence of `word` in `s`. If the word does not appear in the string, return the string unchanged. If the word appears only once, remove that one occurrence. Return the resulting string after applying the removals.","solution":"def remove_first_last_occurrence(s, word): Removes the first and last occurrence of \'word\' in the string \'s\'. first_occurrence_index = s.find(word) last_occurrence_index = s.rfind(word) if first_occurrence_index == -1: # If the word does not appear in the string return s elif first_occurrence_index == last_occurrence_index: # If the word appears only once s = s[:first_occurrence_index] + s[first_occurrence_index + len(word):] else: # Remove the first occurrence s = s[:first_occurrence_index] + s[first_occurrence_index + len(word):] # Update the last_occurrence_index since the first occurrence was removed last_occurrence_index = s.rfind(word) # Remove the last occurrence s = s[:last_occurrence_index] + s[last_occurrence_index + len(word):] return s"},{"question":"You are given an **m x n** binary matrix `grid` where each cell contains either a `0` (representing water) or a `1` (representing land). An island is a cluster of `1`s connected vertically or horizontally. Consider `P` different positions, each given by a pair `(x, y)` which you need to convert from `0` to `1` to potentially create new islands or expand existing ones. Return the number of islands after all `P` conversions are done.","solution":"def num_islands_after_conversions(grid, positions): rows, cols = len(grid), len(grid[0]) # Function to perform DFS to mark visited islands def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != 1: return grid[r][c] = \'#\' dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) # Convert given positions from 0 to 1 for x, y in positions: grid[x][y] = 1 num_islands = 0 # Count the number of islands for r in range(rows): for c in range(cols): if grid[r][c] == 1: dfs(r, c) num_islands += 1 return num_islands"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on a 2D plane. A point `[xi, yi]` is said to be **dominated** by another point `[xj, yj]` if `xi < xj` and `yi < yj`. Return _an array_ `result` _where_ `result[i]` _represents the number of points that dominate the point_ `points[i]`.","solution":"from typing import List def count_dominated_points(points: List[List[int]]) -> List[int]: Returns an array where result[i] represents the number of points that dominate the point points[i]. A point [xi, yi] is said to be dominated by another point [xj, yj] if xi < xj and yi < yj. result = [0] * len(points) for i in range(len(points)): for j in range(len(points)): if points[j][0] > points[i][0] and points[j][1] > points[i][1]: result[i] += 1 return result"},{"question":"A network of `n` computers is represented as a graph where each node is a computer, and each edge is a direct communication link between two computers. You are given an integer `n` representing the number of computers and a list of `edges`, where `edges[i] = [u, v]` indicates a direct link between computer `u` and computer `v`. Assume there are no duplicate edges and no self-loops. A computer is considered to be **isolated** if it has no direct links to other computers. Your task is to write a function that returns a list of all the isolated computers in ascending order. If no isolated computers exist, return an empty list.","solution":"def find_isolated_computers(n, edges): Returns a list of isolated computers in ascending order. Parameters: n (int): Number of computers. edges (List[List[int]]): List of edges representing direct communication links. Returns: List[int]: A list of isolated computers in ascending order. # Create a set for all computers all_computers = set(range(n)) # Create a set for computers with edges connected_computers = set() for u, v in edges: connected_computers.add(u) connected_computers.add(v) # Isolated computers are those which are in all_computers but not in connected_computers isolated_computers = list(all_computers - connected_computers) isolated_computers.sort() return isolated_computers"},{"question":"You are given an **N-ary Tree** where each node contains a single character. Implement a function to find all **root-to-leaf** paths in the tree such that the characters along the path form a valid English word from a given dictionary. The tree is represented as a nested array, and the dictionary is provided as a set of strings. Return _a list of all valid words found from root-to-leaf paths in **lexicographical order**_.","solution":"from typing import List, Set class Node: def __init__(self, value: str, children: List[\'Node\'] = None): self.value = value self.children = children if children is not None else [] def find_words_from_tree(root: Node, dictionary: Set[str]) -> List[str]: def dfs(node: Node, path: str, results: List[str]): new_path = path + node.value if not node.children: if new_path in dictionary: results.append(new_path) else: for child in node.children: dfs(child, new_path, results) results = [] if root: dfs(root, \'\', results) return sorted(results)"},{"question":"You are given a string `s` consisting of lowercase alphabets. A substring of `s` is defined as a contiguous sequence of characters within `s`. A substring is considered \\"nice\\" if there are no duplicate characters in it. Write a function to return the length of the longest \\"nice\\" substring from the given string `s`. If no \\"nice\\" substring exists, return `0`.","solution":"def length_of_longest_nice_substring(s): Returns the length of the longest nice substring of s. A nice substring is one that contains no duplicate characters. max_length = 0 for i in range(len(s)): seen = set() current_length = 0 for j in range(i, len(s)): if s[j] in seen: break seen.add(s[j]) current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"Implement a function `int longestConsecutiveSequence(vector<int>& nums)` that takes a list of integers `nums` and returns the length of the longest consecutive elements sequence. The consecutive elements sequence means elements in the sequence follow each other numerically without any gaps. The algorithm should have a time complexity better than O(n^2). - For example, given the input `nums = [100, 4, 200, 1, 3, 2]`, the output should be `4` because the longest consecutive sequence (1, 2, 3, 4) has 4 elements.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a string `s` containing lowercase English letters and an integer `k`. You need to find the lexicographically smallest string that can be obtained by rotating the string `s` (choose a point in the string and rotate the parts before and after it) any number of times and removing exactly `k` characters from it. Return _the lexicographically smallest string after performing these operations_.","solution":"from itertools import combinations def smallestStringAfterRemovalsAndRotation(s: str, k: int) -> str: Returns the lexicographically smallest string after rotating and removing exactly k characters from string s. n = len(s) smallest = s # Generate all rotations of the string for i in range(n): rotated_string = s[i:] + s[:i] # Generate all combinations of the rotated string after removing k characters for combo in combinations(range(n), n - k): candidate = \'\'.join(rotated_string[j] for j in combo) if candidate < smallest: smallest = candidate return smallest"},{"question":"You are given a list of schedules, where each schedule is a list of time intervals during which a person is busy. Each interval is represented as a pair of integers `[start, end]` indicating the start and end times (inclusive), in a 24-hour format. Return a list of intervals representing the common free time slots among all schedules. The free time intervals should be presented in the ascending order of their start times. Note: An interval `[a, b]` is considered free if it does not overlap with any busy intervals of any person and is at least 1 hour long.","solution":"def common_free_time(schedules): Returns a list of intervals representing the common free time slots among all schedules. Parameters: schedules (list of list of lists): a list of schedules, where each schedule is a list of busy time intervals [start, end]. Returns: list of lists: A list of intervals representing the common free time slots among all schedules. # Flatten and sort all busy intervals all_intervals = [interval for schedule in schedules for interval in schedule] all_intervals.sort() # Merge overlapping intervals merged_busy_intervals = [] for interval in all_intervals: if merged_busy_intervals and interval[0] <= merged_busy_intervals[-1][1]: merged_busy_intervals[-1][1] = max(merged_busy_intervals[-1][1], interval[1]) else: merged_busy_intervals.append(interval) # Find common free intervals free_intervals = [] end_of_last_busy = 0 for interval in merged_busy_intervals: if interval[0] > end_of_last_busy: # Check if the free interval is at least 1 hour long if interval[0] - end_of_last_busy >= 1: free_intervals.append([end_of_last_busy, interval[0]]) end_of_last_busy = interval[1] # Add the possible last free interval from the end of the last busy interval to 24 if valid. if end_of_last_busy < 24: free_intervals.append([end_of_last_busy, 24]) return free_intervals"},{"question":"A delivery service needs to deliver parcels to multiple destinations. Each destination has a specific time window `[start, end]` during which the delivery can be made. The service can only deliver to one destination at any time. Given a list of time windows for all the destinations, find the maximum number of parcels that can be delivered on time. Each time window is represented as a pair of integers `[start, end]`, where `start` is less than `end`. Return the maximum number of deliveries that can be made without any overlap in the time windows.","solution":"def max_deliveries(time_windows): Finds the maximum number of non-overlapping deliveries that can be made on time. Parameters: time_windows: List[Tuple[int, int]] - A list of tuples where each tuple represents the start and end time window for a delivery. Returns: int - Maximum number of deliveries that can be made without any overlap. # Sort the time windows based on their end times to apply the interval scheduling maximization time_windows.sort(key=lambda x: x[1]) count = 0 current_end_time = 0 for start, end in time_windows: if start >= current_end_time: count += 1 current_end_time = end return count"},{"question":"You are given an array of integers `nums` where each element appears exactly twice, except for one element which appears only once. Write a function `int findUnique(int[] nums)` that finds and returns the element that appears only once. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def findUnique(nums): Finds the element that appears only once in an array where all other elements appear exactly twice. Args: nums (List[int]): The list of integers where one integer appears only once and all others appear exactly twice. Returns: int: The integer that appears only once. unique_element = 0 for num in nums: unique_element ^= num # XOR all elements. The result is the unique element. return unique_element"},{"question":"There is a string `s` of length `n` consisting of only the characters \'a\' and \'b\'. You are allowed to perform at most one operation: choose any position and change the character at that position to either \'a\' or \'b\'. Your task is to determine if it is possible for the string to become a palindrome by performing at most one such operation. Return `true` if it is possible to make the string a palindrome, and `false` otherwise.","solution":"def can_be_palindrome(s): Determines if it is possible to make the given string a palindrome by performing at most one change in a character. Parameters: s (str): The input string consisting of characters \'a\' and \'b\'. Returns: bool: True if it is possible to make `s` a palindrome with one or zero changes, False otherwise. left, right = 0, len(s) - 1 diff_count = 0 while left < right: if s[left] != s[right]: diff_count += 1 if diff_count > 1: return False left += 1 right -= 1 return True"},{"question":"You are given a list of `courses` where each `course[i] = [course_i_duration, prerequisites]` indicates that you need to complete the `prerequisites` before taking course `i`, and the `course_i_duration` is the time it takes to complete the course. The `prerequisites` list contains other course indices that need to be completed before starting the given course. You aim to find the minimum time to complete all the courses. Implement the `CourseScheduler` class: * `CourseScheduler(int[][] courses)`: Initializes the `CourseScheduler` object with a list of courses. * `int minimumCompletionTime()`: Returns the minimum time needed to complete all the courses. You may assume: - There are no cyclic dependencies in the prerequisite structure. - Each course duration is a positive integer. - The list may contain up to `1000` courses. # Example: ```python courses = [[3, []], [2, [0]], [1, [1]]] scheduler = CourseScheduler(courses) print(scheduler.minimumCompletionTime()) # Output: 6 ```","solution":"class CourseScheduler: def __init__(self, courses): self.courses = courses self.time_cache = {} def _calculate_completion_time(self, course_index): if course_index in self.time_cache: return self.time_cache[course_index] course_duration, prerequisites = self.courses[course_index] if not prerequisites: self.time_cache[course_index] = course_duration return course_duration max_prerequisite_time = max(self._calculate_completion_time(prereq) for prereq in prerequisites) total_time = course_duration + max_prerequisite_time self.time_cache[course_index] = total_time return total_time def minimumCompletionTime(self): total_time = 0 for course_index in range(len(self.courses)): total_time = max(total_time, self._calculate_completion_time(course_index)) return total_time"},{"question":"You are given a collection of `n` strings, each string consisting of lowercase letters. Your task is to group the strings that are anagrams of each other and return the result as a list of lists, where each list contains strings that are anagrams of each other. The order of the elements within the groups does not matter. An anagram is a word or phrase formed by rearranging the letters of another, such as \\"cinema\\" formed from \\"iceman\\". Given an array of strings `strs`, return _a list of lists containing the grouped anagrams_.","solution":"from collections import defaultdict def group_anagrams(strs): Groups the strings that are anagrams of each other. Args: strs: List of strings Returns: A list of lists, where each list contains strings that are anagrams of each other. anagram_map = defaultdict(list) for s in strs: sorted_s = \'\'.join(sorted(s)) anagram_map[sorted_s].append(s) return list(anagram_map.values())"},{"question":"You are given a 2D integer array `grid` where each cell represents a positive integer. You can move from a cell to any adjacent cell in the grid (up, down, left, or right) as long as the target cell contains a number greater than the current cell. For each cell, find the length of the longest path you can take starting from that cell. Return the length of the longest path in the entire grid.","solution":"def longestIncreasingPath(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) cache = [[-1] * cols for _ in range(rows)] def dfs(r, c, prev_value): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] <= prev_value: return 0 if cache[r][c] != -1: return cache[r][c] current_val = grid[r][c] left = dfs(r, c - 1, current_val) right = dfs(r, c + 1, current_val) up = dfs(r - 1, c, current_val) down = dfs(r + 1, c, current_val) cache[r][c] = 1 + max(left, right, up, down) return cache[r][c] longest_path = 0 for r in range(rows): for c in range(cols): longest_path = max(longest_path, dfs(r, c, float(\'-inf\'))) return longest_path"},{"question":"You are given a list of integers `arr` representing the heights of people standing in a queue. Each person has a unique height. However, some persons have swapped their positions in the queue. Your task is to determine the minimum number of adjacent swaps required to sort the queue in non-decreasing order based on their heights. Return this minimum number. Note that: - You can only swap adjacent elements in the list.","solution":"def min_adjacent_swaps(arr): Calculate the minimum number of adjacent swaps required to sort the queue in non-decreasing order. Parameters: arr (list of int): List of unique integers representing heights. Returns: int: Minimum number of adjacent swaps required. count = 0 n = len(arr) # Perform a modified bubble sort and count the swaps for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] count += 1 return count"},{"question":"You are given a **0-indexed** integer array `arr`. The **distance** of a subarray `[arr[i], arr[i+1], ..., arr[j]]` is defined as the difference between the maximum and minimum elements in that subarray. Find the **maximum distance** among all possible subarrays of the given array. Return _an integer representing the maximum distance_.","solution":"def maximum_distance(arr): Returns the maximum distance among all possible subarrays of the given array. The distance is defined as the difference between the maximum and minimum elements in a subarray. max_distance = float(\'-inf\') for i in range(len(arr)): curr_min, curr_max = arr[i], arr[i] for j in range(i, len(arr)): curr_min = min(curr_min, arr[j]) curr_max = max(curr_max, arr[j]) max_distance = max(max_distance, curr_max - curr_min) return max_distance"},{"question":"Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return the binary tree. Implement the `TreeNode` class with necessary methods to support the operations needed for this construction. Example: ``` Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: The constructed binary tree is: 3 / 9 20 / 15 7 ``` Assume the TreeNode class has the prototype: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your implementation should include a function: ```python def buildTree(inorder: List[int], postorder: List[int]) -> TreeNode ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(inorder, postorder): if not inorder or not postorder: return None # the last element in postorder is the root of the current tree root_val = postorder.pop() root = TreeNode(root_val) # find the index of the root in inorder inorder_index = inorder.index(root_val) # build right and left subtrees recursively root.right = buildTree(inorder[inorder_index + 1:], postorder) root.left = buildTree(inorder[:inorder_index], postorder) return root"},{"question":"You are provided a list of words, `words`, and a string `s`. Write a function that returns the largest word in `words` that can be formed by deleting some characters of `s` without reordering the characters in `s`. If there is more than one possible result, return the word that appears first in `words`. If no words in `words` can be formed from `s`, return an empty string.","solution":"def is_subsequence(word, s): Helper function to check if `word` is a subsequence of `s`. it = iter(s) return all(char in it for char in word) def find_longest_word(words, s): Returns the largest word in \'words\' that can be formed by deleting some characters of \'s\' without reordering the characters of \'s\'. If there is more than one possible result, returns the word that appears first in \'words\'. If no words in \'words\' can be formed from \'s\', returns an empty string. longest_word = \\"\\" for word in words: if is_subsequence(word, s): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"You are given an `n x n` binary matrix `grid` where `0` represents an empty cell and `1` represents a wall. You are also given two integers `r1` and `c1` representing your starting position on the grid `(r1, c1)` and two integers `r2` and `c2` representing your target position `(r2, c2)`. You can move up, down, left, or right, but you cannot move into a cell with a wall. Return _the length of the shortest path from your starting position to the target position, or `-1` if there is no such path_.","solution":"from collections import deque def shortest_path(grid, r1, c1, r2, c2): Returns the length of the shortest path from (r1, c1) to (r2, c2) in a binary matrix grid. Returns -1 if no such path exists. if grid[r1][c1] == 1 or grid[r2][c2] == 1: return -1 # Either start or end is blocked if (r1, c1) == (r2, c2): return 0 # Start and end are the same n = len(grid) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(r1, c1, 0)]) # (row, col, distance) visited = set() visited.add((r1, c1)) while queue: cr, cc, dist = queue.popleft() for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited: if grid[nr][nc] == 0: if (nr, nc) == (r2, c2): return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"You are given an array of integers `arr` and an integer `d`. Each element in the array represents the maximum length of jump you can make from that position. Write a function `maxJumps(int[] arr, int d)` which determines the maximum number of indices you can visit starting from any index. You can only jump to an index `i` if `i + d <= arr[i]` in the direction (either left or right) from the current index, and you cannot land on a smaller value. Once you jump out of the array bounds, you stop. The function should return the maximum number of indices that can be visited from any starting index in the array.","solution":"def max_jumps(arr, d): Determines the maximum number of indices you can visit starting from any index. You can jump to an index i if i + d <= arr[i] in either direction (left or right). You cannot land on a smaller value. def dfs(i, memo): if memo[i] != -1: return memo[i] max_reach = 1 # Jump to the right for j in range(i + 1, min(i + d + 1, len(arr))): if arr[j] < arr[i]: max_reach = max(max_reach, 1 + dfs(j, memo)) else: break # Jump to the left for j in range(i - 1, max(i - d - 1, -1), -1): if arr[j] < arr[i]: max_reach = max(max_reach, 1 + dfs(j, memo)) else: break memo[i] = max_reach return max_reach memo = [-1] * len(arr) return max(dfs(i, memo) for i in range(len(arr)))"},{"question":"You are given a **0-indexed** array `height` representing the heights of `n` buildings. The **sunlight** can only come from the right side. A building will be considered to be **in shadow** if there is a taller building to its right. Return an array of `n` where the ith element denotes whether the building `height[i]` is in shadow (`1`) or not (`0`). A building is not in shadow if there is no taller building to its right.","solution":"def find_shadows(height): Given an array of heights representing the heights of buildings, returns an array of 0s and 1s where 1 indicates that the building is in shadow and 0 indicates that it is not in shadow. n = len(height) result = [0] * n max_height = 0 for i in range(n - 1, -1, -1): if height[i] > max_height: max_height = height[i] result[i] = 0 else: result[i] = 1 return result"},{"question":"Given a **0-indexed** integer array `nums`, find the length of the longest subarray that contains at most two distinct integers. Return _the length of this subarray_.","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray that contains at most two distinct integers. if not nums: return 0 left = 0 freq = {} max_len = 0 for right in range(len(nums)): if nums[right] in freq: freq[nums[right]] += 1 else: freq[nums[right]] = 1 while len(freq) > 2: freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Write a function `calculatePaths` that takes an integer `n` representing the size of an `n x n` grid. You can only move right or down from the top-left corner to the bottom-right corner of the grid. Return the number of unique paths you can take to reach the bottom-right corner from the top-left corner. The answer should be given modulo `10**9 + 7`.","solution":"def calculatePaths(n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid, moving only right or down, modulo 10**9 + 7. MOD = 10**9 + 7 # Create a 2D list to store results of subproblems dp = [[0] * n for _ in range(n)] # Initialize the first row and first column for i in range(n): dp[0][i] = 1 dp[i][0] = 1 # Fill the dp table bottom-up for i in range(1, n): for j in range(1, n): dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD return dp[n-1][n-1]"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, arranged linearly. You are supposed to rob houses along this street in such a way that you maximize the total amount of money robbed, but you cannot rob two directly adjacent houses because the police will be alerted to your presence. Given that you can start robbing from any house, return the maximum amount of money you can rob without triggering the alarm.","solution":"def rob(nums): Calculate the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): List of non-negative integers representing the amount of money in each house. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"You are given a 2D matrix `mat` where each element is either `0` or `1`. A cluster is defined as a group of `1`s connected vertically or horizontally (not diagonally). Write a function that returns the number of distinct clusters in the matrix.","solution":"def num_clusters(mat): Returns the number of distinct clusters of 1s in the given 2D matrix. def dfs(x, y): if x < 0 or y < 0 or x >= len(mat) or y >= len(mat[0]) or mat[x][y] != 1: return mat[x][y] = -1 # Mark the cell as visited # Visit all adjacent cells dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) if not mat or not mat[0]: return 0 num_clusters = 0 for i in range(len(mat)): for j in range(len(mat[0])): if mat[i][j] == 1: dfs(i, j) num_clusters += 1 return num_clusters"},{"question":"You are given an array `books` where each element represents the number of pages in a particular book. A group of friends wants to divide these books among themselves such that each friend gets a contiguous segment of books. However, they want to minimize the maximum number of pages any friend has to read. You need to find the minimum possible value of the maximum number of pages read by any friend after optimally dividing the books. Write a function that returns this minimum value given the array `books` and the integer `k` representing the number of friends. For example, given `books = [10, 20, 30, 40, 50]` and `k = 2`, the optimal way to divide the books is to give the first friend the first two books (10 + 20 + 30 = 60 pages) and the second friend the remaining three books (40 + 50 = 90 pages). The function should return `60`, which is the minimized maximum number of pages.","solution":"def is_valid(books, n, k, curr_min): current_sum = 0 required_students = 1 for i in range(n): if (books[i] > curr_min): return False if (current_sum + books[i] > curr_min): required_students += 1 current_sum = books[i] if required_students > k: return False else: current_sum += books[i] return True def max_pages(books, k): n = len(books) if k > n: return -1 start = max(books) end = sum(books) result = float(\'inf\') while(start <= end): mid = (start + end) // 2 if (is_valid(books, n, k, mid)): result = min(result, mid) end = mid - 1 else: start = mid + 1 return result"},{"question":"Given an `n x m` 2D grid of integers, where each element in the grid represents a certain height above sea level, implement an algorithm to find the size of the largest region of connected cells with the same value. Cells are considered connected if they are adjacent horizontally, vertically, or diagonally. Return _the size of the largest region of connected cells with the same value_.","solution":"def largest_region(grid): Finds the size of the largest connected region of same values in a given 2D grid. :param grid: List of List of integers, representing the grid. :return: Integer, size of the largest connected region. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False for _ in range(m)] for _ in range(n)] directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def dfs(x, y, value): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < m and not visited[cx][cy] and grid[cx][cy] == value: visited[cx][cy] = True size += 1 for dx, dy in directions: stack.append((cx + dx, cy + dy)) return size largest_size = 0 for i in range(n): for j in range(m): if not visited[i][j]: region_size = dfs(i, j, grid[i][j]) largest_size = max(largest_size, region_size) return largest_size"},{"question":"Given an integer array `heights` representing the height of buildings without any gap between them, a building\'s shadow extends to its right neighbor till the first shorter building. Determine the total number of buildings that can directly see the sunset if the sun sets to the left of the buildings. The buildings are in a straight line and are indexed from left to right starting with index 0. Implement a function `int countBuildingsWithSunsetView(int[] heights)` that returns the total number of buildings which can see the sunset without having their view blocked by a taller building to their left.","solution":"def countBuildingsWithSunsetView(heights): Returns the total number of buildings that can see the sunset. The sun sets to the left, so a building can see the sunset if there is no taller building to its left. if not heights: return 0 max_height = 0 count = 0 for height in heights: if height > max_height: max_height = height count += 1 return count"},{"question":"A company is selecting participants for a new project based on their scores. You are given two arrays: `scores` and `team`. The array `scores[i]` contains the scores for the participant with `id = i`. The array `team` represents sets of participants that form a team, where `team[i]` contains the list of participants that form the team with `id = i`. You need to select the team with the highest average score. If there are multiple teams with the same highest average score, select the team with the smallest `id`. Return the `id` of the selected team.","solution":"def select_highest_avg_score_team(scores, team): Selects the team with the highest average score. In case of a tie, the team with the smallest id is selected. Args: scores (list): A list of integers representing the scores of participants. team (list): A list of lists with each inner list representing a team of participant ids. Returns: int: The id of the team with the highest average score. highest_avg = -1 selected_team_id = -1 for i, members in enumerate(team): if not members: continue team_score = sum(scores[m] for m in members) team_size = len(members) team_avg = team_score / team_size if team_avg > highest_avg or (team_avg == highest_avg and i < selected_team_id): highest_avg = team_avg selected_team_id = i return selected_team_id"},{"question":"Given the `head` of a singly linked list, write a function to _swap every two adjacent nodes_ and return its head. You must solve the problem without modifying the values in the list\'s nodes (i.e., only nodes themselves may be changed.)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swapPairs(head): Given the head of a singly linked list, swaps every two adjacent nodes and returns its head. if not head or not head.next: return head new_head = head.next prev = None current = head while current and current.next: next_pair = current.next.next second = current.next # Swap the pair second.next = current current.next = next_pair if prev: prev.next = second # Update pointers prev = current current = next_pair return new_head"},{"question":"You are given an array of integers `nums`. You need to design an algorithm that finds the maximum sum of a non-empty subarray of `nums` such that at least one element of the subarray is the first or last element of the array. Return the maximum sum obtained under this condition. Note that the subarray must be contiguous.","solution":"def max_sum_subarray_include_edges(nums): Finds the maximum sum of a non-empty subarray such that at least one element of the subarray is the first or last element of the array. def kadane(arr): max_current = max_global = arr[0] for x in arr[1:]: max_current = max(x, max_current + x) if max_current > max_global: max_global = max_current return max_global n = len(nums) if n == 1: return nums[0] max_sum_start = kadane(nums) max_sum_end = kadane(nums[::-1]) return max(max_sum_start, max_sum_end)"},{"question":"Given a string `s` consisting of lowercase alphabets, return _the length of the longest substring that can be rearranged to form a palindrome_. A substring is defined as a contiguous sequence of characters within the string.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest substring that can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Initialize the length of the longest palindromic substring length = 0 odd_count = 0 # Iterate through the character frequencies for count in char_count.values(): # Add the even part of each character frequency length += (count // 2) * 2 # Check if there is any odd frequency character if count % 2 == 1: odd_count = 1 # Add an odd character to the length if it exists return length + odd_count"},{"question":"You are given a string `s` containing only the characters `\'a\'`, `\'b\'`, and `\'c\'`. Each operation consists of picking any two distinct adjacent characters and deleting them, causing the rest of the string to concatenate around them. Return the length of the shortest string that can be obtained by performing the above-described operation as many times as possible.","solution":"def shortest_string_length(s): Returns the length of the shortest string by performing operations described in the prompt: pick any two distinct adjacent characters and delete them. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"Given two integers `low` and `high`, return the count of even numbers between `low` and `high` (both inclusive). If there are no even numbers between `low` and `high`, return `0`.","solution":"def count_even_numbers(low, high): Returns the count of even numbers between low and high (both inclusive). If there are no even numbers between low and high, returns 0. if low > high: return 0 # Make sure low and high are the first even numbers >= low and <= high respectively if low % 2 != 0: low += 1 if high % 2 != 0: high -= 1 if low > high: return 0 return ((high - low) // 2) + 1"},{"question":"You are given a list of integers representing the duration of tasks `tasks[i]` and an integer `d` representing the maximum number of days you can allocate to complete these tasks. Each day, you can complete at most two tasks and the sum of their durations must not exceed a given limit `dayLimit`. Return `true` if it\'s possible to finish all the tasks within `d` days, otherwise return `false`.","solution":"def can_complete_tasks(tasks, d, dayLimit): Determines if it\'s possible to complete all tasks within d days with the given day limit on task durations. Args: tasks (list of int): List of task durations. d (int): Maximum number of days available. dayLimit (int): Maximum duration of tasks that can be completed in a single day. Returns: bool: True if it\'s possible to complete all tasks within d days, False otherwise. # Sort tasks to try pairing the shortest tasks together tasks.sort() left, right = 0, len(tasks) - 1 days_needed = 0 while left <= right: if tasks[left] + tasks[right] <= dayLimit: left += 1 right -= 1 days_needed += 1 if days_needed > d: return False return days_needed <= d"},{"question":"You are given an integer array `nums` where each element appears exactly three times except for one element which appears exactly once. Write a function to find and return this single element. Your algorithm should have a linear runtime complexity and use only constant extra space. Do not use any built-in hash table libraries.","solution":"def singleNumber(nums): Function to find the element that appears only once in an array where all other elements appear exactly three times. The algorithm should run in linear time complexity and use constant extra space. Args: nums: List[int] - A list of integers where each element except one appears exactly three times. Returns: int - The element that appears exactly once. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given an array of integers `nums` representing the cost of performing a series of operations, where `nums[i]` is the cost of the `i-th` operation. You need to perform a total of `k` operations. However, you can only perform at most one operation per index and you cannot perform consecutive operations on adjacent indexes. Return the minimum cost needed to perform exactly `k` operations from this array, or `-1` if it\'s not possible to do so.","solution":"def min_cost_to_perform_k_operations(nums, k): Returns the minimum cost needed to perform exactly k operations from the given list nums, without performing consecutive operations on adjacent indexes. If it\'s not possible, returns -1. n = len(nums) if k > (n + 1) // 2: return -1 # Initialize a DP array where dp[j] will store the minimal cost to # select j non-adjacent elements from the first i elements of nums. dp = [-1] * (k + 1) dp[0] = 0 for i in range(n): new_dp = dp[:] for j in range(1, k + 1): if dp[j - 1] != -1: new_cost = dp[j - 1] + nums[i] if new_dp[j] == -1 or new_dp[j] > new_cost: new_dp[j] = new_cost dp = new_dp[:] return dp[k]"},{"question":"You are given a list of `strings` where each string represents a file path, and each file path may contain directory names and the special references `\\".\\"` for the current directory or `\\"..\\"` for the parent directory. Implement a function `simplifyPath(list<string> paths)` that normalizes each file path by resolving the special references and reducing any redundant slashes. The function should return a list of simplified file paths.","solution":"def simplifyPath(paths): Simplifies each file path in the list by resolving special references and reducing redundant slashes. paths: list of strings, each representing a file path return: list of simplified file paths def simplify_single_path(path): parts = path.split(\'/\') stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) return \\"/\\" + \\"/\\".join(stack) return [simplify_single_path(path) for path in paths]"},{"question":"Write a function that takes a string `s` as input, and returns the longest substring without repeating characters. Your implementation should use a sliding window approach to achieve O(n) time complexity where `n` is the length of the string. For example, given the input string `\\"abcabcbb\\"`, your function should return `\\"abc\\"`, which has a length of 3.","solution":"def longest_substring_without_repeating(s): Returns the longest substring without repeating characters. :param s: Input string :type s: str :return: Longest substring without repeating characters :rtype: str char_map = {} start = 0 max_len = 0 longest_subst = \\"\\" for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end if end - start + 1 > max_len: max_len = end - start + 1 longest_subst = s[start:end + 1] return longest_subst"},{"question":"You are given a **directed acyclic graph (DAG)**, with nodes labeled from `0` to `n-1`. Each node has a list of neighboring nodes representing directed edges. Your task is to determine if there exists a **unique topological ordering** of the given graph. If such an ordering exists, return `true`; otherwise, return `false`. The graph can be represented as follows: - An integer `n` representing the number of nodes. - A list of pairs of integers, where each pair `[u, v]` represents a directed edge from node `u` to node `v`. Note: A **topological ordering** of a DAG is a linear ordering of its vertices such that for every directed edge `uv`, vertex `u` comes before `v` in the ordering. To solve this problem, you are not required to generate the actual topological order, but merely to determine if the graph has one unique topological ordering.","solution":"from collections import deque def has_unique_topological_ordering(n, edges): Determine if a directed acyclic graph has a unique topological ordering. :param n: Number of nodes in the graph. :param edges: List of pairs representing directed edges [u, v]. :return: True if there is a unique topological ordering, otherwise False. # Initialize the graph graph = [[] for _ in range(n)] in_degree = [0] * n # Build the graph and compute in-degrees of each node for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Queue for nodes with in-degree 0 zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) unique_topological_order = [] while zero_in_degree_queue: # If there is more than one choice at any point, the ordering is not unique if len(zero_in_degree_queue) > 1: return False # Get one of the nodes with in-degree 0 current_node = zero_in_degree_queue.popleft() unique_topological_order.append(current_node) # Decrease the in-degree of neighboring nodes for neighbor in graph[current_node]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the topological sort includes all nodes, it\'s unique return len(unique_topological_order) == n"},{"question":"Given a list of `N` integers representing the height of `N` buildings arranged in a line, an integer `W` representing the maximum width of the window, and an integer `L` representing the minimum width of the window, you need to calculate the maximum sum of heights within any valid window between width `L` and `W` (inclusive). A valid window is defined as a contiguous subarray of buildings. Return the maximum sum of heights possible within any valid window.","solution":"def max_sum_within_window(heights, W, L): Calculate the maximum sum of heights within any valid window of width between L and W (inclusive). Parameters: heights (list of int): List of heights of N buildings. W (int): Maximum width of the window. L (int): Minimum width of the window. Returns: int: The maximum sum of heights within any valid window. N = len(heights) max_sum = float(\'-inf\') for window_size in range(L, W + 1): current_sum = sum(heights[:window_size]) max_sum = max(max_sum, current_sum) for i in range(window_size, N): current_sum = current_sum + heights[i] - heights[i - window_size] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `nums` representing different lengths of sticks, you are tasked with forming a square. Each side of the square must have the same length, and you must use all the sticks. You cannot break any stick, but you can use each stick only once. Return `true` if you can form a square using all the sticks, and `false` otherwise. **Note:** - The length of each stick is guaranteed to be positive. - The number of sticks `n` will be between 1 and 15, inclusive.","solution":"def makesquare(nums): Returns True if you can form a square using all the sticks, else False. if not nums: return False total_length = sum(nums) if total_length % 4 != 0: return False side_length = total_length // 4 nums.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(nums): return sides[0] == sides[1] == sides[2] == sides[3] == side_length for i in range(4): if sides[i] + nums[index] <= side_length: sides[i] += nums[index] if dfs(index + 1): return True sides[i] -= nums[index] return False return dfs(0)"},{"question":"You are given a **0-indexed** integer array `segments` where `segments[i]` represents the length of the `i-th` cable segment. You also have a task to connect these cable segments to form a single continuous cable. To connect two cable segments of lengths `a` and `b`, the cost incurred is `a + b`. Return _the **minimum total cost** to connect all segments into one cable._ Note: You can connect segments in any order and the final cost should be minimized.","solution":"import heapq def min_cost_to_connect_segments(segments): Returns the minimum total cost to connect all segments into one cable. Parameters: segments (list): A list of integers where each integer represents the length of a cable segment. Returns: int: The minimum total cost to connect all segments into one cable. if not segments: return 0 min_heap = segments[:] heapq.heapify(min_heap) total_cost = 0 while len(min_heap) > 1: first = heapq.heappop(min_heap) second = heapq.heappop(min_heap) cost = first + second total_cost += cost heapq.heappush(min_heap, cost) return total_cost"},{"question":"You are given a 2D grid representing a maze. Each cell in the grid can be \'S\' (start), \'E\' (end), \'0\' (walkable path), or \'1\' (wall). The maze has exactly one \'S\' and one \'E\'. You need to find out if there is a path from \'S\' to \'E\' without moving diagonally. You can only move up, down, left, or right. Return `true` if there is a path from \'S\' to \'E\', otherwise return `false`. Write a function `boolean canReachEnd(char[][] maze)` to determine if there is a path from \'S\' to \'E\' in the maze.","solution":"def can_reach_end(maze): rows = len(maze) cols = len(maze[0]) # Directions for moving in the maze (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Find the start (\'S\') and end (\'E\') positions start = end = None for i in range(rows): for j in range(cols): if maze[i][j] == \'S\': start = (i, j) elif maze[i][j] == \'E\': end = (i, j) if not start or not end: return False # BFS initialization queue = [start] visited = set() visited.add(start) while queue: current = queue.pop(0) if current == end: return True for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols: if maze[neighbor[0]][neighbor[1]] != \'1\' and neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False"},{"question":"Given an `n x n` matrix `grid` containing only integers `0` and `1`, where `0` represents an empty cell and `1` represents a cell filled with land, find _the largest **island** in the grid_. An island is defined as a group of `1`\'s connected 4-directionally (horizontal or vertical). You may transform up to `one` `0` into a `1` in order to form a larger island. Return _the size of the largest possible island in the grid after performing at most one transformation_.","solution":"def largest_island(grid): def dfs(x, y, index): stack = [(x, y)] area = 0 while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < n and grid[cx][cy] == 1: grid[cx][cy] = index area += 1 for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: stack.append((nx, ny)) return area n = len(grid) if not n: return 0 island_area = {} index = 2 # Start index from 2 because 0 and 1 are already in use # Step 1: Use DFS to paint each island and record their area for i in range(n): for j in range(n): if grid[i][j] == 1: island_area[index] = dfs(i, j, index) index += 1 if not island_area: return 1 # The grid only contains one cell as 0 max_area = max(island_area.values(), default=0) # Step 2: Check each 0 cell to see if it can connect two or more islands for i in range(n): for j in range(n): if grid[i][j] == 0: seen = set() new_area = 1 # Start with this cell being an island for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1: index = grid[ni][nj] if index not in seen: new_area += island_area[index] seen.add(index) max_area = max(max_area, new_area) return max_area"},{"question":"You are given a string containing only lowercase letters. Rearrange the characters of the string such that no two adjacent characters are the same. If it is not possible to do so, return an empty string. If there are multiple valid rearrangements, return any of them.","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Rearrange the characters of the string such that no two adjacent characters are the same. If it is not possible to do so, return an empty string. # Count frequency of each character counter = Counter(s) # Max heap to store characters based on frequency max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # update previous char and frequency prev_char = char prev_freq = freq + 1 # since freq is negative, we increment towards zero rearranged_string = \\"\\".join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"You are given an array of `n` integers, `arr`, where each integer represents the height of a building. The array is such that `arr[i]` denotes the height of the building at position `i`. You need to determine the maximum area of a rectangle that can be formed between the buildings where the width of the rectangle is determined by the distance between the buildings (i.e., the number of buildings between two selected buildings including the selected buildings) and the height of the rectangle is determined by the shorter building between the two selected buildings. Return the maximum rectangular area possible.","solution":"def max_rectangle_area(arr): Returns the maximum rectangular area that can be formed between the buildings. Parameters: arr (list): A list of integers where each integer represents the height of a building. Returns: int: The maximum rectangular area possible. max_area = 0 n = len(arr) for left in range(n): min_height = arr[left] for right in range(left, n): min_height = min(min_height, arr[right]) width = right - left + 1 area = min_height * width max_area = max(max_area, area) return max_area"},{"question":"You are given a 2D matrix `mat` of size `m x n` consisting of non-negative integers. You are also given an integer `k`. A **sub-matrix** is a rectangular area within the matrix, defined by its top-left corner `(r1, c1)` and bottom-right corner `(r2, c2)` where `0 <= r1 <= r2 < m` and `0 <= c1 <= c2 < n`. The **sum** of a sub-matrix is the sum of all the elements in that sub-matrix. Return the **maximum sum** of any sub-matrix of `mat` that does not exceed `k`. If no such sub-matrix exists, return **0**.","solution":"def max_sum_submatrix(mat, k): import bisect def max_sum_subarray(arr, k): max_sum = float(\'-inf\') curr_sum = 0 sums = [0] for num in arr: curr_sum += num idx = bisect.bisect_left(sums, curr_sum - k) if idx < len(sums): max_sum = max(max_sum, curr_sum - sums[idx]) bisect.insort(sums, curr_sum) return max_sum if not mat: return 0 m, n = len(mat), len(mat[0]) max_sum = float(\'-inf\') for left in range(n): row_sum = [0] * m for right in range(left, n): for i in range(m): row_sum[i] += mat[i][right] max_sum = max(max_sum, max_sum_subarray(row_sum, k)) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"You are given a string `s` containing lowercase English letters that represent the moves a robot makes. The robot starts at the origin point `(0, 0)` on a 2D plane. Each character in the string represents a move: - \'L\' for a move to the left (-1, 0) - \'R\' for a move to the right (1, 0) - \'U\' for a move up (0, 1) - \'D\' for a move down (0, -1) Return `true` _if the robot returns to the origin after completing all of its moves, or_ `false` _otherwise_.","solution":"def judgeCircle(moves: str) -> bool: Determines if the robot returns to the origin after completing all of its moves. :param moves: A string containing characters \'L\', \'R\', \'U\', and \'D\' representing moves. :return: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'L\': x -= 1 elif move == \'R\': x += 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Given a non-negative integer `n`, compute and return the largest number that can be formed by rearranging the digits of `n`. If the input is `0`, return `0`.","solution":"def largest_number(n): Given a non-negative integer n, returns the largest number that can be formed by rearranging the digits of n. if n == 0: return 0 digits = list(str(n)) digits.sort(reverse=True) return int(\'\'.join(digits))"},{"question":"You are given a set of **tasks** represented as `n` intervals `[start_i, end_i]` where `0 <= start_i < end_i <= 1e9`. Each task requires a worker to start and finish the task within this interval. Only one worker can work on one task at any time. A worker can work on multiple tasks, but only one at a time. Find the **minimum number of workers** required to finish all the tasks. Given an integer `intervals` array where `intervals[i] = [start_i, end_i]`, return _the minimum number of workers required_.","solution":"def min_number_of_workers(intervals): Given a list of intervals, returns the minimum number of workers required to complete all the tasks without overlap. if not intervals: return 0 # Separate start and end times starts = sorted(interval[0] for interval in intervals) ends = sorted(interval[1] for interval in intervals) workers = 0 end_idx = 0 for start in starts: if start < ends[end_idx]: workers += 1 else: end_idx += 1 return workers"},{"question":"You are given a list `points` where `points[i] = [xi, yi]` represents a point with coordinates `(xi, yi)` on a 2D plane. The points are all distinct. Your task is to find the minimum time required to visit all points in the sequence provided. You can move horizontally, vertically, or diagonally to a neighboring point, each movement costs 1 unit of time. Compute the minimum time required to visit all points in the given order.","solution":"def min_time_to_visit_all_points(points): Calculate the minimum time required to visit all points in the sequence. :param points: List of points with coordinates [x, y] :return: Minimum time to visit all points def distance(p1, p2): Calculate the Chebyshev distance between two points. return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) total_time = 0 for i in range(len(points) - 1): total_time += distance(points[i], points[i + 1]) return total_time"},{"question":"You are tasked with designing a system for managing a university course enrollment. Each course and student has a unique identifier. The system should support enrolling students into courses, dropping them from courses, and querying the currently enrolled students for each course. Students are identified by `studentId` and courses are identified by `courseId`. The system should support the following functions: * **Enroll**: Enrolls a student with a given `studentId` into a course with a given `courseId`. If the student is already enrolled in the course, no action should be taken. * **Drop**: Drops a student with a given `studentId` from a course with a given `courseId`. If the student is not enrolled in the course, no action should be taken. * **GetEnrolledStudents**: Returns a list of students currently enrolled in a given course identified by `courseId`. The students should be listed by their `studentId` in ascending order. Implement the `CourseEnrollmentSystem` class: * `CourseEnrollmentSystem()` Initializes the `CourseEnrollmentSystem` object. * `void enroll(int studentId, int courseId)` Enrolls the given `studentId` in the given `courseId`. * `void drop(int studentId, int courseId)` Drops the given `studentId` from the given `courseId`. * `List<Integer> getEnrolledStudents(int courseId)` Returns a list of `studentId`s of students currently enrolled in the course with `courseId` as described above.","solution":"class CourseEnrollmentSystem: def __init__(self): # Initializes the CourseEnrollmentSystem with a dictionary to hold course enrollments. self.enrollments = {} def enroll(self, studentId, courseId): # Enrolls the given student in the given course. if courseId not in self.enrollments: self.enrollments[courseId] = set() self.enrollments[courseId].add(studentId) def drop(self, studentId, courseId): # Drops the given student from the given course. if courseId in self.enrollments: self.enrollments[courseId].discard(studentId) def getEnrolledStudents(self, courseId): # Returns the list of students currently enrolled in the given course, sorted by studentId. if courseId in self.enrollments: return sorted(self.enrollments[courseId]) else: return []"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. A subarray of `nums` is called **good** if the product of its elements is **less than or equal** to `k`. Return _the **number** of good subarrays in the array_ `nums`.","solution":"def count_good_subarrays(nums, k): Returns the number of good subarrays in the array nums where the product of elements in the subarray is less than or equal to k. n = len(nums) count = 0 # Function to compute the product of subarray elements def product(subarray): result = 1 for num in subarray: result *= num return result for left in range(n): for right in range(left, n): if product(nums[left:right+1]) <= k: count += 1 return count"},{"question":"A company has decided to adopt a new work-from-home policy and conducted a survey to determine employees\' preferences. Each employee\'s preference can be represented as a list of string values indicating their preferred working days, such as `[\\"Monday\\", \\"Wednesday\\", \\"Friday\\"]`. The company wants to understand how many days of the week are unanimously preferred by all employees. You are given a list of lists, `preferences`, where `preferences[i]` is the list of preferred days for the `i-th` employee. Your task is to write a function that finds and returns a list of days that are preferred by every employee. For example, if `preferences` is: ``` [ [\\"Monday\\", \\"Wednesday\\", \\"Friday\\"], [\\"Wednesday\\", \\"Friday\\"], [\\"Friday\\"] ] ``` The output should be: ``` [\\"Friday\\"] ```","solution":"def unanimous_preferences(preferences): Returns a list of days preferred unanimously by all employees. :param preferences: List of lists where each inner list is the preferred days of an employee :return: List of days preferred by all employees if not preferences: return [] # Start with the first employee\'s preferences as the initial set of unanimous days unanimous_days = set(preferences[0]) # Intersect this set with the preferences of each subsequent employee for preference in preferences[1:]: unanimous_days.intersection_update(preference) return sorted(list(unanimous_days))"},{"question":"Write a function that takes a non-negative integer `num` as input and returns a string representing its hexadecimal representation. For negative inputs, return an empty string. Note that all the letters in the hexadecimal representation should be in lowercase. The function should be able to handle input up to `2^32 - 1`. Avoid using the built-in conversion functions.","solution":"def to_hex(num): Converts a non-negative integer to its hexadecimal representation as a string. If the input is negative, returns an empty string. if num < 0: return \\"\\" if num == 0: return \\"0\\" hex_chars = \\"0123456789abcdef\\" hex_str = \\"\\" while num > 0: hex_str = hex_chars[num % 16] + hex_str num = num // 16 return hex_str"},{"question":"You are given an array of positive integers `arr` representing the sizes of balloons. You can perform the following operation any number of times: choose a balloon, reduce its size by 1 and apply this reduction to exactly one other balloon (increasing its size by 1). The goal is to make all balloons have the same size using this operation. Return _the **minimum** number of operations required to make all balloons have the same size._","solution":"def min_operations_to_equalize(arr): Returns the minimum number of operations required to make all balloons have the same size. if not arr: return 0 max_element = max(arr) operations = 0 for size in arr: operations += max_element - size return operations"},{"question":"A company is organizing a team-building event and wants to fill various teams with employees. You are given an array `skills` where `skills[i]` is a list of skills that employee `i` possesses, and an integer `k` representing the minimum number of distinct skills required for any team to be considered effective. You are also given an integer `t` representing the total number of teams to be formed. Each employee can be a part of at most one team. Return the maximum number of effective teams that can be formed from the given employees. If it is not possible to form even one effective team, return 0.","solution":"from collections import defaultdict def max_effective_teams(skills, k, t): Calculate the maximum number of effective teams. :param skills: List[List[int]], a list where each element is a list of skills of a specific employee :param k: int, minimum number of distinct skills required for a team to be considered effective :param t: int, number of teams to be formed :return: int, maximum number of effective teams if not skills or k <= 0 or t <= 0: return 0 # Calculate the number of distinct skills each employee has employee_skills_count = [len(set(employee_skills)) for employee_skills in skills] # Filter out employees who do not have at least k distinct skills eligible_employees = [count for count in employee_skills_count if count >= k] # The number of effective teams we can form is the minimum of: # 1. Number of eligible employees (as each team needs at least one employee) # 2. The total number of teams we are asked to form # 3. Number of k-compatible groups we can form return min(len(eligible_employees), t)"},{"question":"You are given a string `s` consisting of letters \'x\' and \'y\'. A balanced string is defined as a string where the number of \'x\' characters is equal to the number of \'y\' characters. Your task is to split the string `s` into the maximum number of balanced strings. Return _the maximum number of balanced strings you can obtain_. The input string may be empty, in which case you should return 0.","solution":"def max_balanced_strings(s): Returns the maximum number of balanced strings that can be obtained from the input string s. A balanced string has an equal number of \'x\' and \'y\' characters. balance = 0 count = 0 for char in s: if char == \'x\': balance += 1 elif char == \'y\': balance -= 1 if balance == 0: count += 1 return count"},{"question":"You are given a list of `n` integers `arr`, where `arr[i]` represents the number of coins you have of the `i-th` denomination. You are also given a target integer `amount`. Implement a function that returns `true` if it is possible to make up that amount using any combination of the given coins, and `false` otherwise. You may assume that each coin denomination has an infinite supply.","solution":"def can_make_amount(denominations, amount): Determines if it\'s possible to make up the given amount using the given denominations. :param denominations: List of integers representing coin denominations. :param amount: The target amount to make. :return: Boolean value, True if possible to make the amount, False otherwise. dp = [False] * (amount + 1) dp[0] = True # Base case: zero amount can always be made with zero coins for coin in denominations: for x in range(coin, amount + 1): if dp[x - coin]: dp[x] = True return dp[amount]"},{"question":"You are given a 2D grid of characters `grid` where each cell contains either `\'W\'` (water), `\'L\'` (land), or `\'S\'` (start). The grid represents a map of islands. You start on the cell marked with `\'S\'` and can move up, down, left, or right to adjacent cells on land. Determine the minimum number of moves required to reach a cell containing water. If there is no such path, return `-1`.","solution":"from collections import deque def min_moves_to_water(grid): Returns the minimum number of moves required to reach a cell containing water (\'W\') starting from the cell marked with \'S\'. If there is no path, returns -1. rows = len(grid) cols = len(grid[0]) # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find starting point \'S\' start = None for r in range(rows): for c in range(cols): if grid[r][c] == \'S\': start = (r, c) break if start: break if not start: # No starting point found return -1 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: if grid[nr][nc] == \'W\': return dist + 1 if grid[nr][nc] == \'L\' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # No path to water found return -1"},{"question":"You are given a 2D grid of size `m x n` as a list of lists with each element representing a cell. Each cell contains one of three possible values: - `0` for an empty cell, - `1` for a cell containing a fresh apple, or - `2` for a cell containing a rotten apple. Each minute, any fresh apple that is adjacent (up, down, left, right) to a rotten apple becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh apple. If this is impossible, return `-1`.","solution":"from collections import deque def min_minutes_to_rot_all_apples(grid): Returns the minimum number of minutes that must elapse until no cell has a fresh apple. If this is impossible, returns -1. m, n = len(grid), len(grid[0]) queue = deque() fresh_count = 0 # Initialize the queue with all rotten apple positions and count fresh apples for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) # (row, col, time) elif grid[i][j] == 1: fresh_count += 1 # If there are no fresh apples, no time is needed if fresh_count == 0: return 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] minutes = 0 while queue: x, y, min_elapsed = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = 2 queue.append((nx, ny, min_elapsed + 1)) fresh_count -= 1 minutes = max(minutes, min_elapsed + 1) return minutes if fresh_count == 0 else -1"},{"question":"Write a function to find the longest common subsequence between two given strings `text1` and `text2`. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. Your function should return the length of this longest common subsequence.","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a 2D grid of integers where each cell represents the height of that point in the grid. You can move up, down, left, or right from a point, but you can only move to another point if its height is strictly greater than the current point. Your goal is to determine the longest increasing path in the grid. Return the length of the longest increasing path. **Example:** Input: `grid = [[9,9,4],[6,6,8],[2,1,1]]` Output: `4` Explanation: The longest increasing path is `[1, 2, 6, 9]`. **Constraints:** * `m == grid.length` * `n == grid[0].length` * `1 <= m, n <= 200` * `0 <= grid[i][j] <= 10^4`","solution":"def longest_increasing_path(grid): if not grid or not grid[0]: return 0 def dfs(x, y): if memo[x][y]: return memo[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) memo[x][y] = max_path return max_path m, n = len(grid), len(grid[0]) memo = [[0] * n for _ in range(m)] res = 0 for i in range(m): for j in range(n): res = max(res, dfs(i, j)) return res"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find two distinct indices `i` and `j` in the list such that `nums[i] * nums[j]` is equal to `target`, and the difference between the indices `|i - j|` is minimized. If multiple pairs exist, return the pair with the smallest indices. If no such pair exists, return `[-1, -1]`. Note that the indices in the list start from 1.","solution":"def find_min_diff_indices(nums, target): Returns two distinct indices i and j (1-based) such that nums[i-1] * nums[j-1] equals target and the difference |i - j| is minimized. If no such pair exists, returns [-1, -1]. min_diff = float(\'inf\') result = [-1, -1] n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] * nums[j] == target: diff = abs(i - j) if diff < min_diff: min_diff = diff result = [i + 1, j + 1] elif diff == min_diff and i + 1 < result[0]: result = [i + 1, j + 1] return result"},{"question":"You are given an integer array `nums` of length `n`. You can perform multiple operations where in each operation you select a **non-empty** subarray and **rotate** it to the right by one position. Return _the **minimum number of operations** required to sort the array_ `nums` _in non-decreasing order_.","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations required to sort the array in non-decreasing order by rotating any non-empty subarray to the right by one position. n = len(nums) count = 0 # Traverse from the end of the list to the beginning for i in range(n-1, 0, -1): if nums[i] < nums[i-1]: count += 1 return count"},{"question":"Implement the `Trie` class. A `Trie` (pronounced as \\"try\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, including autocomplete and spell-checking. The `Trie` class should support the following operations: * `Trie()`: Initializes the Trie object. * `void insert(String word)`: Inserts the string `word` into the trie. * `boolean search(String word)`: Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise. * `boolean startsWith(String prefix)`: Returns `true` if there is a previously inserted string in the trie that has the prefix `prefix`, and `false` otherwise.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie object. self.root = TrieNode() def insert(self, word): Inserts the string word into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Returns True if the string word is in the trie, and False otherwise. node = self.__find_node(word) return node is not None and node.is_end_of_word def startsWith(self, prefix): Returns True if there is any string in the trie that starts with the prefix, and False otherwise. return self.__find_node(prefix) is not None def __find_node(self, prefix): Helper function to find the node corresponding to a prefix. node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node"},{"question":"You are given an array of integers `nums` and an integer target `k`. Your task is to determine whether there exist two distinct indices i and j in the array such that `nums[i]` + `nums[j]` is equal to `k`. If such indices exist, return true. Otherwise, return false. Be sure that your solution is both efficient and understandable.","solution":"def has_pair_with_sum(nums, target): Check if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. :param nums: List of integers. :param target: Integer target sum. :return: True if such a pair exists, False otherwise. num_set = set() for num in nums: if target - num in num_set: return True num_set.add(num) return False"},{"question":"Given a `LinkedList` where each node contains an integer value, determine the size of the largest contiguous sublist such that the sum of its elements is equal to zero. Return the size of this sublist. If no such sublist exists, return 0.","solution":"class Node: def __init__(self, data): self.data = data self.next = None def largest_zero_sum_sublist(head): Returns the size of the largest contiguous sublist such that the sum of its elements is equal to zero in the given linked list. prefix_sum = 0 max_len = 0 prefix_sum_map = {} current = head index = 0 while current is not None: prefix_sum += current.data if prefix_sum == 0: max_len = index + 1 if prefix_sum in prefix_sum_map: max_len = max(max_len, index - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = index current = current.next index += 1 return max_len"},{"question":"Given an array of integers `arr`, where each integer represents the height of a person. Write a function that returns the **maximum number of people** that can form a single **non-decreasing** line from left to right. You are allowed to remove some people from the line to achieve this. Note: The height order must be maintained, i.e., you can only remove people to form the longest non-decreasing subsequence.","solution":"def max_non_decreasing_line(arr): Returns the maximum number of people that can form a single non-decreasing line from left to right by removing some people. :param arr: List[int] - A list of integers representing heights. :return: int - Maximum number of people that can form the non-decreasing line. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will store the length of the longest non-decreasing subsequence ending with arr[i] for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a binary tree where each node has either 0 or 2 children. Each child of a node represents a digit (0-9). Starting from the root to each leaf, the sequence of digits formed represents a number. Write a function to calculate the sum of all the numbers formed by the paths from the root to the leaves. Return the cumulative sum of all these numbers.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_root_to_leaf_numbers(root): Calculates the sum of all the numbers formed by paths from the root to the leaves. :param root: TreeNode :return: int def helper(node, current_sum): if not node: return 0 current_sum = current_sum * 10 + node.value if not node.left and not node.right: return current_sum left_sum = helper(node.left, current_sum) right_sum = helper(node.right, current_sum) return left_sum + right_sum return helper(root, 0)"},{"question":"You are given an integer array `nums`. We define a running difference `rd` as an array where `rd[i] = nums[i] - nums[i-1]` for all valid `i > 0`, and `rd[0] = nums[0]`. Write a function to modify the array `nums` such that the number of elements with a value of `0` in `rd` is maximized. Return the modified array `nums`. Note that you may modify the elements of the input array `nums` in order to achieve the desired result.","solution":"def maximize_zero_run_diff(nums): Modify the array nums such that the number of elements with a value of 0 in the running difference is maximized. Returns the modified array nums. if not nums: return nums for i in range(1, len(nums)): nums[i] = nums[i-1] return nums"},{"question":"You are given an array of `words` and a string `letters`. Each word consists of lowercase English letters and the string `letters` contains distinct lowercase English letters. Return _the longest word from the array that can be constructed using letters from_ `letters` without repeating any letter. If there is a tie, return the word that appears first in the array. If no word can be constructed, return an empty string.","solution":"def can_construct(word, letters): Helper function to determine if a word can be constructed from given letters. # Create a set of available letters available_letters = set(letters) # Try to construct the word for letter in word: if letter not in available_letters: return False return True def longest_word(words, letters): Returns the longest word that can be constructed from the given letters. longest = \\"\\" for word in words: if can_construct(word, letters) and len(word) > len(longest): longest = word return longest"},{"question":"You are given a list of `n` words. Two words are said to be \\"similar\\" if their character sets are identical (i.e., if they contain the same characters, ignoring the order and duplicates). Write a function to group the words that are similar and return the number of such groups. Each word belongs to exactly one group. For example, given the words `[\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"evil\\", \\"vile\\", \\"live\\"]`, the groups would be `[\\"listen\\", \\"silent\\", \\"enlist\\"]`, `[\\"rat\\", \\"tar\\", \\"art\\"]`, and `[\\"evil\\", \\"vile\\", \\"live\\"]`, resulting in 3 groups in total.","solution":"def count_similar_groups(words): Groups words with identical character sets and returns the number of such groups. :param words: List of words to be grouped. :returns: Number of groups of identical character sets. unique_char_set_groups = set() for word in words: sorted_characters = \\"\\".join(sorted(set(word))) unique_char_set_groups.add(sorted_characters) return len(unique_char_set_groups)"},{"question":": Write a function `reverseSubarrays(arr, k)` that takes an integer array `arr` and an integer `k`, and reverses every subarray of `k` consecutive elements. If the number of elements left in the array is less than `k`, reverse them as well. The function should modify the original array and return it. For example: - Given `arr = [1, 2, 3, 4, 5]` and `k = 2`, the function should return `[2, 1, 4, 3, 5]`. - Given `arr = [1, 2, 3, 4, 5, 6, 7, 8]` and `k = 3`, the function should return `[3, 2, 1, 6, 5, 4, 8, 7]`.","solution":"def reverseSubarrays(arr, k): Reverses every subarray of k consecutive elements in the array. If the number of elements left in the array is less than k, reverse them as well. Parameters: arr (list): A list of integers. k (int): The size of the subarrays to reverse. Returns: list: The modified list with reversed subarrays. n = len(arr) for i in range(0, n, k): arr[i:i+k] = arr[i:i+k][::-1] return arr"},{"question":"You are given a string `s` consisting of only lowercase letters. You need to find a new string that follows two rules: 1. Every character in the new string must appear in the same relative order as it appears in `s`. 2. Each character can only be included in the new string once. For example, if the given string is \\"abacb\\", the new string can be \\"abc\\". Write a function `removeDuplicates` that, given the string `s`, returns the lexicographically smallest string that is possible by removing the duplicate characters and following the above rules. Example: * Given `s = \\"cbacdcbc\\"`, the function should return \\"acdb\\". * Given `s = \\"bcabc\\"`, the function should return \\"abc\\".","solution":"def removeDuplicates(s: str) -> str: Function to remove duplicate characters and return the lexicographically smallest string following the rules. last_occurrence = {c: i for i, c in enumerate(s)} stack = [] seen = set() for i, char in enumerate(s): if char in seen: continue while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return \'\'.join(stack)"},{"question":"You are given a string `s` representing a sequence of characters, which can include multiple types of brackets: `()`, `[]`, `{}`. A valid sequence is defined as one where each type of bracket opens and closes properly and in the correct order. Your task is to determine whether the given string forms a valid sequence of brackets. Return a boolean value `True` if the sequence is valid, and `False` otherwise. Make use of a stack data structure to solve this problem.","solution":"def is_valid_sequence(s): Determines if a given string of brackets is valid. A string is considered valid if: - Every opening bracket has a corresponding closing bracket. - Brackets are closed in the correct order. Args: s (str): The input string containing brackets. Returns: bool: True if the string is valid, False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given two strings, `s1` and `s2`, and you need to determine if `s2` is a permutation of `s1`. In other words, return `true` if `s2` contains the exact same characters as `s1` in any order, and `false` otherwise. The solution should be case-sensitive and should not use any built-in sorting functions. Implement a function that takes `s1` and `s2` as input and returns the appropriate boolean result.","solution":"def are_permutations(s1, s2): Returns True if s2 is a permutation of s1, False otherwise. if len(s1) != len(s2): return False char_count = {} # Count characters in s1 for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Subtract character count using s2 for char in s2: if char not in char_count: return False char_count[char] -= 1 if char_count[char] < 0: return False return True"},{"question":"Given a string `s`, split it into as few strings as possible such that each string is a palindrome. Return _the minimum number of splits needed to split the string such that every substring is a palindrome_. For example, given the string \\"aab\\", one way to split it is [\\"aa\\", \\"b\\"], so the return value should be 1.","solution":"def minCut(s: str) -> int: n = len(s) dp = [0] * n # dp[i] will be the min cut for s[:i+1] palindrome = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # max cuts from s[:i+1] for j in range(i + 1): if s[i] == s[j] and (i - j < 2 or palindrome[j + 1][i - 1]): palindrome[j][i] = True # if s[j:i+1] is palindrome # then we check if no cuts needed or 1+ cut needed from s[:j] min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1]"},{"question":"Given a 2D matrix `grid` of size `m x n` where each cell represents either land (`1`) or water (`0`), an island is a group of `1s` (land) connected 4-directionally (horizontal or vertical). Assume all four edges of the grid are surrounded by water. Count the number of distinct islands that can be formed. Two islands are considered distinct if and only if one island cannot be translated (move in any direction) to equal the other. Return _the number of distinct islands_.","solution":"def countDistinctIslands(grid): def dfs(x, y, baseX, baseY): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return grid[x][y] = 0 shape.append((x - baseX, y - baseY)) for dx, dy in directions: dfs(x + dx, y + dy, baseX, baseY) if not grid: return 0 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] shapes = set() for i in range(m): for j in range(n): if grid[i][j] == 1: shape = [] dfs(i, j, i, j) shapes.add(tuple(shape)) return len(shapes)"},{"question":"You are given a **0-indexed** array of integers `arr` and an integer `k`. A **move** consists of selecting two indices `i` and `j` (where `0 <= i, j < arr.length` and `i != j`), and swapping `arr[i]` with `arr[j]`. Return _the minimum number of moves required to make the array balanced_, where an array is considered balanced if the absolute difference between any two adjacent elements is at most `k`. If it is not possible to make the array balanced, return `-1`.","solution":"def minMovesToBalanceArray(arr, k): Returns the minimum number of moves required to make the array balanced or -1 if it is not possible. n = len(arr) if n < 2: return 0 for i in range(n - 1): if abs(arr[i] - arr[i + 1]) > k: return -1 return 0"},{"question":"Given a binary tree, write a function to check whether it is a **complete binary tree** or not. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes are as far left as possible. The tree is defined using a `TreeNode` class where each node has an integer value and two children (`left` and `right`). Return `true` if the binary tree is complete, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCompleteBinaryTree(root): if not root: return True queue = [root] foundNull = False while queue: current = queue.pop(0) if current: if foundNull: return False queue.append(current.left) queue.append(current.right) else: foundNull = True return True"},{"question":"You are given an array `height` representing the heights of buildings, where the width of each building is 1. The rain starts pouring over the buildings. Construct a container-like structure between the buildings such that the container captures the maximum amount of rainwater. Return _the maximum amount of water that can be trapped_ after raining. (Note: You must solve it by scanning the array from both ends towards the center, in one pass, using a greedy approach.)","solution":"def trap(height): if not height: return 0 left, right = 0, len(height) - 1 max_left, max_right = height[left], height[right] water_trapped = 0 while left < right: if max_left < max_right: left += 1 max_left = max(max_left, height[left]) water_trapped += max_left - height[left] else: right -= 1 max_right = max(max_right, height[right]) water_trapped += max_right - height[right] return water_trapped"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to count the number of pairs `(i, j)` where `i < j` and `nums[i] + nums[j]` is equal to `target`. Return _the total count of such pairs_.","solution":"def count_pairs(nums, target): Returns the number of pairs (i, j) where i < j and nums[i] + nums[j] equals target. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"Given a string `s`, you are required to determine if it is possible to rearrange the characters of `s` to form a palindrome. A palindrome reads the same forward and backward. The string can contain only lowercase alphabets. Return `true` if a palindrome can be formed, otherwise return `false`. * For example, given the input string `\\"civic\\"`, it is already a palindrome, so the answer would be `true`. For the input string `\\"ivicc\\"`, we can rearrange it to form `\\"civic\\"`, so the answer would be `true`. Conversely, for the input string `\\"hello\\"`, there is no way to rearrange the characters to form a palindrome, so the answer would be `false`.","solution":"def can_form_palindrome(s): Determines if the characters of the given string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase alphabets. Returns: bool: True if a palindrome can be formed, otherwise False. from collections import Counter # Count the occurrence of each character in the string count = Counter(s) # A palindrome can have at most one character with an odd occurrence odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) # For the string to be rearranged into a palindrome, at most one character should have an odd count return odd_count <= 1"},{"question":"You are given an integer array `heights` representing the heights of students in a classroom in the order they appear. The teacher wants to rearrange the students in a non-decreasing order of their heights, but with the minimum number of students being moved to accomplish this. Return the minimum number of students that need to be moved to achieve the sorted order. Note: A move is defined as taking a student out of the current lineup and then inserting them back into any position of the lineup.","solution":"def min_students_to_rearrange(heights): Returns the minimum number of students that need to be moved to achieve the sorted order. if not heights: return 0 sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: count += 1 return count"},{"question":"You are given an integer array `arr` and an integer `m`. A **straight subarray** is defined as a subarray that consists of consecutive increasing integers. Find the **length** of the longest straight subarray in `arr` such that the length of the subarray does not exceed `m`. Return _the length of the longest straight subarray_ that satisfies the above conditions.","solution":"def longest_straight_subarray(arr, m): Returns the length of the longest straight subarray with consecutive increasing integers such that the subarray length does not exceed m. n = len(arr) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i - 1] + 1: current_length += 1 else: current_length = 1 if current_length > m: current_length = m max_length = max(max_length, current_length) return max_length"},{"question":"Given a binary tree, collect a list of all nodes at each depth (i.e., nodes with the same distance from the root). Return a list of lists where each sublist contains nodes at the corresponding level. For example, for a tree with root `1`, left child `2`, and right child `3`, the output should be `[[1], [2, 3]]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns a list of lists with nodes at each depth of the binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: List[List[int]]: A list of lists where each sublist contains nodes at a corresponding level. if not root: return [] from collections import deque result = [] queue = deque([(root, 0)]) while queue: current, level = queue.popleft() if level == len(result): result.append([]) result[level].append(current.val) if current.left: queue.append((current.left, level+1)) if current.right: queue.append((current.right, level+1)) return result"},{"question":"You are given a list of `n` transactions where each transaction is represented as a tuple `(name, time, amount, city)`. The name is a string representing the person who did the transaction, time is an integer representing the time in minutes at which the transaction occurred, amount is an integer representing the transaction amount, and city is a string indicating the city in which the transaction occurred. A transaction is considered **invalid** if: * The amount exceeds 1000, or * There exists another transaction with the same name within a 60-minute interval (including both transactions) and in a different city. Your task is to return a list of strings representing all the invalid transactions. The transactions should be returned in the order they appear in the input list.","solution":"def invalid_transactions(transactions): invalid = set() for i in range(len(transactions)): name1, time1, amount1, city1 = transactions[i] if int(amount1) > 1000: invalid.add(i) for j in range(len(transactions)): if i != j: name2, time2, amount2, city2 = transactions[j] if name1 == name2 and abs(int(time1) - int(time2)) <= 60 and city1 != city2: invalid.add(i) invalid.add(j) return [\\",\\".join(transactions[i]) for i in invalid]"},{"question":"Given an array `nums` consisting of distinct integers, return _an array of all permutations of `nums`_. The solution must not contain any duplicate permutations and should return the permutations in any order. For example, given `nums = [1,2,3]`, the output should be `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`.","solution":"from itertools import permutations def permute(nums): Returns all permutations of nums. return [list(p) for p in permutations(nums)]"},{"question":"You are given an array of integers `arr` where each element in the array is unique. Consider an operation where you can swap any two elements in the array. You need to find the minimum number of swaps required to sort the array in non-decreasing order. Return the minimum number of swaps needed to sort the array.","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. # Getting the array length n = len(arr) # Creating a list of tuples where each tuple is the element and its index arrpos = list(enumerate(arr)) # Sorting the array by its value arrpos.sort(key=lambda it: it[1]) # Visited array to keep track of already visited elements visited = [False] * n # Initialize result swaps = 0 # Loop through each element for i in range(n): # Skip already visited or already correctly placed elements if visited[i] or arrpos[i][0] == i: continue # initiate cycle variables cycle_size = 0 j = i # traverse the cycle while not visited[j]: # mark node as visited visited[j] = True # move to next node j = arrpos[j][0] cycle_size += 1 # Update swaps if there is more than one element in the cycle if cycle_size > 1: swaps += cycle_size - 1 return swaps"}]'),z={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},F={class:"card-container"},L={key:0,class:"empty-state"},C=["disabled"],S={key:0},D={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")},"  ")):l("",!0)]),t("div",F,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",L,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",D,"Loading...")):(n(),r("span",S,"See more"))],8,C)):l("",!0)])}const G=m(z,[["render",E],["__scopeId","data-v-8b1d27fb"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/1.md","filePath":"guide/1.md"}'),P={name:"guide/1.md"},O=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{M as __pageData,O as default};
