import{_,o as s,c as r,a as t,m as c,t as d,C as p,M as g,U as b,f as l,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,u,m,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const N=_(q,[["render",A],["__scopeId","data-v-ed78363f"]]),F=JSON.parse(`[{"question":"from typing import List, Tuple def findKthMostFrequent(string: str, k: int) -> str: Write a function that accepts two parameters, i) a string (containing a list of words) and ii) an integer (k). The function should return the k-th most frequent word from the list. If there is a tie (two words with the same frequency), return the one that appeared first in the original list. The words should be compared case-insensitive, but the returned word should maintain its original case. Assume the list will contain at least k unique words. The format of the input string will be 'word word word'. >>> findKthMostFrequent('dog cat dog bird cat dog bird bird', 2) 'bird' >>> findKthMostFrequent('apple orange banana apple orange apple', 2) 'orange' >>> findKthMostFrequent('one two two three three three four four four four', 2) 'three' >>> findKthMostFrequent('cat bat cat bat', 1) 'cat' >>> findKthMostFrequent('apple Apple apple orange ORANGE orange', 1) 'apple' >>> findKthMostFrequent('alpha beta gamma delta', 3) 'gamma' >>> findKthMostFrequent('single', 1) 'single'","solution":"def findKthMostFrequent(string, k): from collections import Counter # Split the string into words words = string.split() # Use a Counter to count the frequencies of the words count = Counter(word.lower() for word in words) # Get a list of unique words in the original order unique_words_ordered = [] seen_words = set() for word in words: word_lower = word.lower() if word_lower not in seen_words: seen_words.add(word_lower) unique_words_ordered.append(word) # Sort the unique words first by frequency (descending), then by their first occurrence sorted_words = sorted(unique_words_ordered, key=lambda word: (-count[word.lower()], words.index(word))) # Return the k-th most frequent word maintaining its original case return sorted_words[k-1]"},{"question":"def max_deliveries(grid): Given a grid representing delivery destinations, find the maximum deliveries possible in any valid circular route. >>> max_deliveries([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 40 >>> max_deliveries([[1, 2], [3, 4]]) 10 def process_input(input_data): result = [] lines = input_data.strip().split('n') T = int(lines[0]) index = 1 for _ in range(T): N, M = map(int, lines[index].split()) index += 1 grid = [] for i in range(N): row = list(map(int, lines[index].split())) index += 1 grid.append(row) result.append(max_deliveries(grid)) for res in result: print(res)","solution":"def max_deliveries(grid): N = len(grid) M = len(grid[0]) # DP table for down-right path down_right = [[0] * M for _ in range(N)] down_right[0][0] = grid[0][0] for i in range(N): for j in range(M): if i == 0 and j == 0: continue if i == 0: down_right[i][j] = down_right[i][j-1] + grid[i][j] elif j == 0: down_right[i][j] = down_right[i-1][j] + grid[i][j] else: down_right[i][j] = max(down_right[i-1][j], down_right[i][j-1]) + grid[i][j] # Total point when going through bottom-right corner total_deliveries = down_right[-1][-1] * 2 - grid[0][0] - grid[-1][-1] return total_deliveries def process_input(input_data): result = [] lines = input_data.strip().split('n') T = int(lines[0]) index = 1 for _ in range(T): N, M = map(int, lines[index].split()) index += 1 grid = [] for i in range(N): row = list(map(int, lines[index].split())) index += 1 grid.append(row) result.append(max_deliveries(grid)) for res in result: print(res)"},{"question":"from typing import List def wave_array(arr: List[int]) -> List[int]: Transforms the array into a \\"wave\\" array. An array is defined as being in a \\"wave\\" form if each even-indexed element is greater than or equal to its adjacent odd-indexed elements. >>> wave_array([3, 6, 5, 10, 7, 20]) [6, 3, 10, 5, 20, 7] >>> wave_array([1, 2, 3, 4, 5, 6]) [2, 1, 4, 3, 6, 5]","solution":"from typing import List def wave_array(arr: List[int]) -> List[int]: Transforms the array into a \\"wave\\" array. n = len(arr) for i in range(0, n, 2): # If the current even-indexed element is less than the previous odd-indexed element if i > 0 and arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] # If the current even-indexed element is less than the next odd-indexed element if i < n - 1 and arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. A leap year is exactly divisible by 4, except for years which are exactly divisible by 100, but these centurial years are leap years if they are exactly divisible by 400. Args: year (int): the year to check Returns: bool: True if the year is a leap year, False otherwise Examples: >>> is_leap_year(2000) True >>> is_leap_year(1996) True >>> is_leap_year(1900) False >>> is_leap_year(2021) False","solution":"def is_leap_year(year): Determine if a given year is a leap year. Args: year (int): the year to check Returns: bool: True if the year is a leap year, False otherwise if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return True else: return False"},{"question":"def filter_three_divisors(nums: List[int]) -> List[int]: Returns a list of numbers from the input list that have exactly three divisors. >>> filter_three_divisors([2, 3, 4, 7, 9, 10, 16, 25, 36]) == [4, 9, 25] >>> filter_three_divisors([1, 5, 8, 11, 12, 13]) == [] from solution import filter_three_divisors def test_has_three_divisors(): assert filter_three_divisors([2, 3, 4, 7, 9, 10, 16, 25, 36]) == [4, 9, 25] assert filter_three_divisors([1, 5, 8, 11, 12, 13]) == [] assert filter_three_divisors([4, 9, 25, 49]) == [4, 9, 25, 49] assert filter_three_divisors([3, 5, 6, 12, 15]) == [] assert filter_three_divisors([10, 26, 36, 49, 56, 81]) == [49] def test_empty_list(): assert filter_three_divisors([]) == [] def test_single_element_list(): assert filter_three_divisors([4]) == [4] assert filter_three_divisors([5]) == [] assert filter_three_divisors([9]) == [9] assert filter_three_divisors([14]) == [] assert filter_three_divisors([25]) == [25]","solution":"def has_exactly_three_divisors(n): Helper function to check if a number has exactly three divisors. if n < 2: return False root = int(n**0.5) return root * root == n and all(n % i != 0 for i in range(2, root)) def filter_three_divisors(nums): Returns a list of numbers from the input list that have exactly three divisors. return [num for num in nums if has_exactly_three_divisors(num)] # Example usage nums = [2, 3, 4, 7, 9, 10, 16, 25, 36] print(filter_three_divisors(nums)) # Output should be [4, 9, 25]"},{"question":"from typing import List def max_sum_submatrix(matrix: List[List[int]]) -> int: Given a matrix with N rows and M columns, finds the maximum sum of elements from any submatrix within the matrix. >>> max_sum_submatrix([ ... [1, 2, -1], ... [-3, 4, 2], ... [1, -1, 3]]) 9 >>> max_sum_submatrix([[5]]) 5 pass def test_example_case(): matrix = [ [1, 2, -1], [-3, 4, 2], [1, -1, 3] ] assert max_sum_submatrix(matrix) == 9 def test_single_element(): matrix = [ [5] ] assert max_sum_submatrix(matrix) == 5 def test_single_row(): matrix = [ [1, -2, 3, 4] ] assert max_sum_submatrix(matrix) == 7 def test_single_column(): matrix = [ [1], [-2], [3], [4] ] assert max_sum_submatrix(matrix) == 7 def test_all_negative(): matrix = [ [-1, -2], [-3, -4] ] assert max_sum_submatrix(matrix) == -1 def test_large_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert max_sum_submatrix(matrix) == sum(range(1, 17)) def test_mixed_sign(): matrix = [ [1, 2, -1], [-3, 4, -2], [1, -1, 3], [2, -5, 7] ] assert max_sum_submatrix(matrix) == 10 def test_edge_case(): matrix = [ [-1, -1], [-1, -1] ] assert max_sum_submatrix(matrix) == -1","solution":"def max_sum_submatrix(matrix): Returns the maximum sum of elements from any submatrix within the given matrix. # Get the number of rows and columns N = len(matrix) M = len(matrix[0]) # Step 1: Calculate cumulative sum for each row cumulative_sum = [[0] * (M + 1) for _ in range(N)] for i in range(N): for j in range(M): cumulative_sum[i][j + 1] = cumulative_sum[i][j] + matrix[i][j] # Step 2: Use the cumulative sum to find the max sum submatrix max_sum = float('-inf') for start_col in range(M): for end_col in range(start_col, M): subarray_sum = [0] * N for row in range(N): subarray_sum[row] = cumulative_sum[row][end_col + 1] - cumulative_sum[row][start_col] # Apply Kadane's algorithm to find the max subarray sum for this subarray_sum current_max = subarray_sum[0] overall_max = subarray_sum[0] for i in range(1, N): current_max = max(subarray_sum[i], current_max + subarray_sum[i]) overall_max = max(overall_max, current_max) max_sum = max(max_sum, overall_max) return max_sum # Input and output for verification purpose if __name__ == \\"__main__\\": N, M = 3, 3 matrix = [ [1, 2, -1], [-3, 4, 2], [1, -1, 3] ] print(max_sum_submatrix(matrix)) # Expected output: 9"},{"question":"def distribute_chocolates(chocolates: List[int], m: int) -> int: Returns the minimum difference between the maximum and minimum chocolates distributed to the students. >>> distribute_chocolates([12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 44, 48, 43, 50], 7) 10 >>> distribute_chocolates([1, 3, 4, 7, 9, 9], 2) 0 >>> distribute_chocolates([5, 8, 6, 2], 4) 6 >>> distribute_chocolates([1, 2, 3, 4], 0) 0 >>> distribute_chocolates([], 5) 0 >>> distribute_chocolates([10], 1) 0 >>> distribute_chocolates([7, 3, 2, 4, 9, 12, 56], 3) 2","solution":"def distribute_chocolates(chocolates, m): Returns the minimum difference between the maximum and minimum chocolates distributed to the students. if m == 0 or len(chocolates) == 0: return 0 # Sort the array of chocolates chocolates.sort() # Number of packets of chocolates n = len(chocolates) # Initialize the minimum difference as a large number min_diff = float('inf') # Traverse through the sorted list to find the minimum difference in a subset of size m for i in range(n - m + 1): diff = chocolates[i + m - 1] - chocolates[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the characters of the string s such that no two adjacent characters are the same. If not possible, returns \\"IMPOSSIBLE\\". >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaa\\") 'IMPOSSIBLE' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"ab\\") 'ab' >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaabbc\\") 'ababac' >>> rearrange_string(\\"aaaaabc\\") 'IMPOSSIBLE' >>> rearrange_string(\\"aaabbbccc\\") 'abcabcabc' >>> rearrange_string(\\"abcdefghijklmnopqrstuvwxyz\\") 'abcdefghijklmnopqrstuvwxyz'","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s): Rearranges the characters of the string s such that no two adjacent characters are the same. If not possible, returns \\"IMPOSSIBLE\\". # Count frequency of each character freq = Counter(s) max_heap = [] # Create a max-heap based on character frequency for char, count in freq.items(): heappush(max_heap, (-count, char)) previous_char = None previous_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # Push the previous character back if its count is more than 0 if previous_char and previous_count < 0: heappush(max_heap, (previous_count, previous_char)) # Update previous_char and previous_count for the next iteration previous_char = char previous_count = count + 1 # As decrementing the count of used character rearranged_string = ''.join(result) if len(rearranged_string) == len(s): return rearranged_string else: return \\"IMPOSSIBLE\\""},{"question":"def minimum_time_to_connect_tracks(n: int, lengths: List[int]) -> int: Returns the minimum time required to form one long track by connecting n tracks. Args: n (int): The number of tracks. lengths (List[int]): The lengths of the tracks. Returns: int: The minimum number of seconds required to form one long track. >>> minimum_time_to_connect_tracks(3, [3, 2, 1]) 2 >>> minimum_time_to_connect_tracks(4, [1, 1, 1, 1]) 3","solution":"def minimum_time_to_connect_tracks(n, lengths): Returns the minimum time required to form one long track by connecting n tracks. # Base case: If there's only one track, no connection is needed. if n == 1: return 0 # Sorting the track lengths helps in efficiently connecting them. lengths.sort() # Total time required is the number of connections i.e., number of tracks - 1 return n - 1"},{"question":"def three_sum(nums: List[int], T: int) -> bool: Returns True if there are three distinct elements in the list that sum up to T, False otherwise. >>> three_sum([12, 3, 6, 1, 6, 9], 24) True >>> three_sum([1, 2, 3, 4, 5], 50) False","solution":"def three_sum(nums, T): Returns True if there are three distinct elements in the list that sum up to T, False otherwise. # Ensure the elements are distinct nums = list(set(nums)) # Sort the numbers to make the two-pointer technique easier nums.sort() n = len(nums) # Loop through the list, fixing one element at a time and searching for the other two for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == T: return True elif current_sum < T: left += 1 else: right -= 1 return False"},{"question":"def repeated_characters(s: str) -> dict: Returns a dictionary with characters that appear more than once as keys and their counts as values. :param s: Input string containing only lowercase alphabetical characters :return: Dictionary with repeated characters and their counts >>> repeated_characters(\\"programming\\") {'r': 2, 'g': 2, 'm': 2} >>> repeated_characters(\\"abcdef\\") {} >>> repeated_characters(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> repeated_characters(\\"abracadabra\\") {'a': 5, 'b': 2, 'r': 2} >>> repeated_characters(\\"a\\") {} >>> repeated_characters(\\"\\") {}","solution":"def repeated_characters(s): Returns a dictionary with characters that appear more than once as keys and their counts as values. :param s: Input string containing only lowercase alphabetical characters :return: Dictionary with repeated characters and their counts char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 repeated_chars = {char: count for char, count in char_count.items() if count > 1} return repeated_chars"},{"question":"def sum_of_even_elements(n: int, arr: List[int]) -> int: Returns the sum of even elements in the given array. Parameters: n (int): The size of the array. arr (list of int): The array of integers. Returns: int: The sum of the even elements in arr. def test_sum_of_even_elements(): assert sum_of_even_elements(5, [1, 2, 3, 4, 5]) == 6 assert sum_of_even_elements(6, [0, 1, 2, 3, 4, 5]) == 6 assert sum_of_even_elements(4, [2, 4, 6, 8]) == 20 assert sum_of_even_elements(3, [-2, -4, -6]) == -12 assert sum_of_even_elements(5, [1, 3, 5, 7, 9]) == 0 assert sum_of_even_elements(4, [-1, -3, -5, -7]) == 0 assert sum_of_even_elements(1, [2]) == 2 assert sum_of_even_elements(1, [3]) == 0 assert sum_of_even_elements(0, []) == 0","solution":"def sum_of_even_elements(n, arr): Returns the sum of even elements in the given array. Parameters: n (int): The size of the array. arr (list of int): The array of integers. Returns: int: The sum of the even elements in arr. return sum(x for x in arr if x % 2 == 0)"},{"question":"def is_correctly_nested(s: str) -> bool: Evaluates if a string of braces is correctly nested. Args: - s (str): The input string containing braces Returns: - bool: True if the string is correctly nested, False otherwise Examples: >>> is_correctly_nested(\\"()\\") True >>> is_correctly_nested(\\"({[]})\\") True >>> is_correctly_nested(\\"({[}])\\") False >>> is_correctly_nested(\\"[({})]\\") True >>> is_correctly_nested(\\"[\\") False >>> is_correctly_nested(\\"][\\") False >>> is_correctly_nested(\\"{[()]}\\") True","solution":"def is_correctly_nested(s): Evaluates if a string of braces is correctly nested. Args: - s (str): The input string containing braces Returns: - bool: True if the string is correctly nested, False otherwise stack = [] matching_brace = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_brace: # It's a closing brace if stack and stack[-1] == matching_brace[char]: stack.pop() # Pop the matching opening brace else: return False else: stack.append(char) # It's an opening brace, push onto the stack return not stack # If stack is empty, all braces were matched"},{"question":"def prime_sieve_interval(low: int, high: int) -> list: Create a function that returns a list of all prime numbers within the given interval [low, high] (inclusive) using the Sieve of Eratosthenes algorithm. >>> prime_sieve_interval(10, 30) [11, 13, 17, 19, 23, 29] >>> prime_sieve_interval(50, 60) [53, 59] >>> prime_sieve_interval(100, 110) [101, 103, 107, 109] >>> prime_sieve_interval(1, 1) [] >>> prime_sieve_interval(20, 10) []","solution":"def prime_sieve_interval(low: int, high: int) -> list: if low > high: return [] if low < 2: low = 2 # Create a boolean array \`is_prime[0..high]\` and initialize is_prime = [True] * (high + 1) p = 2 while (p * p <= high): if is_prime[p]: for i in range(p * p, high + 1, p): is_prime[i] = False p += 1 # Collect prime numbers within the interval [low, high] primes = [num for num in range(low, high + 1) if is_prime[num]] return primes"},{"question":"def compress_string(s: str) -> str: Compress a string using the count of repeated characters. >>> compress_string('aabcccccaaa') 'a2b1c5a3' >>> compress_string('abcdef') 'abcdef' >>> compress_string('aabbcc') 'aabbcc' >>> compress_string('aaaabbbbccdde') 'a4b4c2d2e1' >>> compress_string('a') 'a' >>> compress_string('') '' >>> compress_string('aaa') 'a3'","solution":"def compress_string(s): if not s: return s compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(current_char + str(count)) current_char = char count = 1 compressed.append(current_char + str(count)) # Append the last group compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def transform_list(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list where all even numbers are incremented by 1 and all odd numbers are decremented by 1. >>> transform_list([1, 2, 3, 4, 5]) [0, 3, 2, 5, 4] >>> transform_list([10, 15, 20, 25]) [11, 14, 21, 24] from solution import transform_list def test_single_element(): assert transform_list([1]) == [0] assert transform_list([2]) == [3] def test_all_odd_numbers(): assert transform_list([1, 3, 5, 7]) == [0, 2, 4, 6] def test_all_even_numbers(): assert transform_list([2, 4, 6, 8]) == [3, 5, 7, 9] def test_mixed_numbers(): assert transform_list([1, 2, 3, 4, 5]) == [0, 3, 2, 5, 4] assert transform_list([10, 15, 20, 25]) == [11, 14, 21, 24] def test_negative_numbers(): assert transform_list([-1, -2, -3, -4]) == [-2, -1, -4, -3]","solution":"def transform_list(lst): Takes a list of integers and returns a new list where: - All even numbers are incremented by 1. - All odd numbers are decremented by 1. Parameters: - lst: List of integers. Returns: - A new list with transformed integers. return [x + 1 if x % 2 == 0 else x - 1 for x in lst]"},{"question":"def min_possible_median(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the minimum possible median replication rate of the final colony after mixing bacteria colonies. Each test case contains an integer N (number of colonies) and a list of N integers (replication rates). Args: T: Number of test cases. test_cases: A list of tuples. Each tuple contains an integer N and a list of N replication rates. Returns: A list of strings where each string is the minimum possible median replication rate rounded to six decimal places. >>> min_possible_median(2, [(2, [3, 9]), (4, [1, 2, 3, 4])]) [\\"6.000000\\", \\"2.500000\\"] >>> min_possible_median(1, [(3, [1000000000, 1000000001, 1000000002])]) [\\"1000000001.000000\\"] >>> min_possible_median(1, [(2, [5, 5])]) [\\"5.000000\\"] >>> min_possible_median(1, [(5, [1, 2, 3, 4, 5])]) [\\"3.000000\\"]","solution":"def min_possible_median(T, test_cases): results = [] for case in test_cases: N, rates = case rates.sort() if N % 2 == 0: median = (rates[N // 2 - 1] + rates[N // 2]) / 2 else: median = rates[N // 2] results.append(f\\"{median:.6f}\\") return results"},{"question":"def find_longest_word(words: List[str]) -> str: Returns the longest word from a list of words. If there are multiple words with the same maximum length, returns the first one that appears in the list. If the list is empty, returns an empty string. >>> find_longest_word(['hello', 'world', 'python', 'great']) 'python' >>> find_longest_word([]) ''","solution":"def find_longest_word(words): Returns the longest word from a list of words. If there are multiple words with the same maximum length, returns the first one that appears in the list. If the list is empty, returns an empty string. if not words: return '' longest_word = words[0] for word in words[1:]: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def vending_machine_subset_sum(input_str): Determines whether there is a subset of the weights that sum to exactly W. The input is given in the following format: N W w1 w2 ... wN Example: >>> vending_machine_subset_sum(\\"5 9n3 34 4 12 5\\") \\"YES\\" >>> vending_machine_subset_sum(\\"5 30n3 34 4 12 5\\") \\"NO\\"","solution":"def can_sum_to_weight(N, W, weights): Determines whether there is a subset of the weights that sum to exactly W. dp = [False] * (W + 1) dp[0] = True for weight in weights: for j in range(W, weight - 1, -1): if dp[j - weight]: dp[j] = True return \\"YES\\" if dp[W] else \\"NO\\" def vending_machine_subset_sum(input_str): input_lines = input_str.strip().split() N = int(input_lines[0]) W = int(input_lines[1]) weights = list(map(int, input_lines[2:])) return can_sum_to_weight(N, W, weights)"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the amount of water that can be trapped after raining. Args: heights (list of int): List of non-negative integers representing heights of pillars. Returns: int: The total amount of trapped water. Examples: >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([4,2,0,3,2,5]) 9 from solution import trap_rain_water def test_example_1(): heights = [0,1,0,2,1,0,1,3,2,1,2,1] assert trap_rain_water(heights) == 6 def test_example_2(): heights = [4,2,0,3,2,5] assert trap_rain_water(heights) == 9 def test_no_trapping(): heights = [1,2,3,4,5] assert trap_rain_water(heights) == 0 def test_flat_surface(): heights = [3,3,3,3,3] assert trap_rain_water(heights) == 0 def test_single_trap(): heights = [3,0,3] assert trap_rain_water(heights) == 3 def test_all_zeros(): heights = [0,0,0,0,0] assert trap_rain_water(heights) == 0 def test_empty_list(): heights = [] assert trap_rain_water(heights) == 0 def test_small_tower(): heights = [2,1,2] assert trap_rain_water(heights) == 1","solution":"def trap_rain_water(heights): Calculate the amount of water that can be trapped after raining. Args: heights (list of int): List of non-negative integers representing heights of pillars. Returns: int: The total amount of trapped water. if not heights or len(heights) < 2: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): water_level = min(left_max[i], right_max[i]) trapped_water += max(0, water_level - heights[i]) return trapped_water"},{"question":"def productExceptSelf(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each element at index \`i\` is the product of all the numbers in the original list except the one at \`i\`. Args: nums (List[int]): List of integers. Returns: List[int]: New list where each element is the product of all other elements except the one at its index. Note: You should not use division in your solution. Examples: >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def productExceptSelf(nums): Returns a list where each element at index \`i\` is the product of all the numbers in the input list except the one at \`i\`. n = len(nums) left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the result by multiplying left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def max_profit(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the maximum profit that can be achieved by making at most two transactions from the given stock prices on consecutive days for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list where each element is a tuple containing the number of days and the stock prices for each day. Returns: List[int]: A list of integers where each integer represents the maximum profit that can be achieved with at most two transactions for the corresponding test case. If no profit can be achieved, return 0. >>> max_profit([(6, [3, 3, 5, 0, 0, 3, 1, 4])]) [6] >>> max_profit([(7, [1, 2, 3, 4, 5, 6, 7])]) [6] >>> max_profit([(5, [7, 6, 4, 3, 1])]) [0] >>> max_profit([(4, [1, 2, 3, 100])]) [99] >>> max_profit([(0, [])]) [0]","solution":"def max_profit_with_two_transactions(prices): if not prices or len(prices) <= 1: return 0 n = len(prices) # Initialize profit arrays profit_before = [0] * n profit_after = [0] * n min_price_so_far = prices[0] for i in range(1, n): min_price_so_far = min(min_price_so_far, prices[i]) profit_before[i] = max(profit_before[i-1], prices[i] - min_price_so_far) max_price_so_far = prices[-1] for i in range(n-2, -1, -1): max_price_so_far = max(max_price_so_far, prices[i]) profit_after[i] = max(profit_after[i+1], max_price_so_far - prices[i]) max_profit = 0 for i in range(n): max_profit = max(max_profit, profit_before[i] + profit_after[i]) return max_profit def max_profit(test_cases): results = [] for test_case in test_cases: n, prices = test_case results.append(max_profit_with_two_transactions(prices)) return results"},{"question":"def count_even_sum_pairs(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Returns the count of unique pairs whose sum is even for given list of test cases. >>> count_even_sum_pairs([(4, [1, 2, 3, 4])]) [\\"Case 1:n2\\"] >>> count_even_sum_pairs([(3, [2, 2, 2])]) [\\"Case 1:n3\\"] >>> count_even_sum_pairs([(4, [1, 2, 3, 4]), (3, [2, 2, 2])]) [\\"Case 1:n2\\", \\"Case 2:n3\\"]","solution":"def count_even_sum_pairs(test_cases): Returns the count of unique pairs whose sum is even for given list of test cases. results = [] for index, case in enumerate(test_cases): n = case[0] nums = case[1] even_count = sum(1 for x in nums if x % 2 == 0) odd_count = n - even_count # Pairing even numbers among themselves even_pairs = even_count * (even_count - 1) // 2 # Pairing odd numbers among themselves odd_pairs = odd_count * (odd_count - 1) // 2 result = even_pairs + odd_pairs results.append(f\\"Case {index + 1}:n{result}\\") return results # Example of how the function would be used T = 2 test_cases = [ (4, [1, 2, 3, 4]), (3, [2, 2, 2]) ] for result in count_even_sum_pairs(test_cases): print(result)"},{"question":"def findTriangular(n: int) -> int: Given a positive integer n, compute the nth triangular number. The nth triangular number is defined as the sum of the first n natural numbers and can be represented by the formula: T(n) = n * (n + 1) / 2 >>> findTriangular(1) 1 >>> findTriangular(3) 6 >>> findTriangular(7) 28","solution":"def findTriangular(n): Returns the nth triangular number. return n * (n + 1) // 2"},{"question":"def count_boats(total_boats: int, total_oars: int, total_pedals: int) -> dict: Returns the count of pedal boats, rowing boats, and motorboats. Parameters: total_boats (int): The total number of boats. total_oars (int): The total number of oars. total_pedals (int): The total number of pedals. Returns: dict: A dictionary with counts of pedal boats, rowing boats, and motorboats. Example: >>> count_boats(14, 12, 4) {\\"pedal_boats\\": 2, \\"rowing_boats\\": 6, \\"motorboats\\": 6} >>> count_boats(10, 6, 2) {\\"pedal_boats\\": 1, \\"rowing_boats\\": 3, \\"motorboats\\": 6}","solution":"def count_boats(total_boats, total_oars, total_pedals): Returns the count of pedal boats, rowing boats, and motorboats. pedal_boats_count = total_pedals // 2 rowing_boats_count = total_oars // 2 motorboats_count = total_boats - (pedal_boats_count + rowing_boats_count) return { \\"pedal_boats\\": pedal_boats_count, \\"rowing_boats\\": rowing_boats_count, \\"motorboats\\": motorboats_count }"},{"question":"from typing import List, Tuple def balance_weights(weights: List[int]) -> Tuple[List[int], List[int]]: Redistributes the weights in a balanced way across two bags trying to minimize the maximum weight in any bag. The algorithm should split the input list of weights into two bags, so that the absolute difference between the sums of the weights in each bag is minimized. >>> balance_weights([3, 1, 4, 1, 5]) ([4, 5], [3, 1, 1]) >>> balance_weights([1, 1, 1, 1, 1, 1]) ([1, 1, 1], [1, 1, 1]) >>> balance_weights([3, 1, 4, 1, 2, 7]) ([1, 2, 7], [3, 4, 1]) >>> balance_weights([5]) ([5], []) >>> balance_weights([]) ([], []) pass # Implement the function here","solution":"from typing import List, Tuple def balance_weights(weights: List[int]) -> Tuple[List[int], List[int]]: def backtrack(index, bag1, bag2): if index == len(weights): diff = abs(sum(bag1) - sum(bag2)) if diff < self.min_diff: self.min_diff = diff self.result = (bag1[:], bag2[:]) return backtrack(index + 1, bag1 + [weights[index]], bag2) backtrack(index + 1, bag1, bag2 + [weights[index]]) self = lambda: None self.min_diff = float('inf') self.result = ([], []) backtrack(0, [], []) return self.result"},{"question":"def longest_substring_with_k_replacements(s: str, k: int) -> int: Determine the length of the longest substring that consists of the same character after performing at most k replace operations. Args: s (str): The input string. k (int): The maximum number of replacement operations. Returns: int: The length of the longest substring with the same character after at most k replacements. >>> longest_substring_with_k_replacements(\\"aabcc\\", 2) 4 >>> longest_substring_with_k_replacements(\\"abcde\\", 1) 2","solution":"def longest_substring_with_k_replacements(s, k): from collections import defaultdict # This dictionary will count frequencies of characters in the current window char_count = defaultdict(int) left = 0 # Start of the sliding window max_len = 0 # Length of the longest valid window max_count = 0 # Count of the most frequent character in the current window # Expand the window with right pointer for right in range(len(s)): # Add the current character to the count char_count[s[right]] += 1 # Update max_count with the count of the most frequent character max_count = max(max_count, char_count[s[right]]) # If the current window size minus the most frequent character count # is greater than k, then it means we need more than k replacements if (right - left + 1 - max_count) > k: # Shrink the window from the left char_count[s[left]] -= 1 left += 1 # Update the max length of the window max_len = max(max_len, right - left + 1) return max_len"},{"question":"def is_valid_password(password): Returns \\"VALID\\" if the password meets the given criteria, otherwise \\"INVALID\\". The criteria for a valid password are: - It must contain at least one uppercase letter (A to Z). - It must contain at least one lowercase letter (a to z). - It must contain at least one digit (0 to 9). - It must contain at least one special character from the set {'', '!', '#', '%', '&', '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '{', '}', '|', '~'}. - Its length must be at least 8 characters. >>> is_valid_password(\\"StrongPass1!\\") == \\"VALID\\" True >>> is_valid_password(\\"weakpass\\") == \\"INVALID\\" True >>> is_valid_password(\\"12345678!\\") == \\"INVALID\\" True >>> is_valid_password(\\"Valid_One1\\") == \\"VALID\\" True >>> is_valid_password(\\"MissingNumber!\\") == \\"INVALID\\" True def validate_passwords(passwords): Given a list of passwords, return a list containing \\"VALID\\" or \\"INVALID\\" for each password based on the validation rules. >>> validate_passwords([\\"StrongPass1!\\", \\"weakpass\\", \\"12345678!\\", \\"Valid_One1\\", \\"MissingNumber!\\"]) ['VALID', 'INVALID', 'INVALID', 'VALID', 'INVALID'] >>> validate_passwords([\\"Short1!\\", \\"NoSpecialCharacter1\\", \\"NOSPECIALCHARACTER1\\", \\"lowercase1!\\"]) ['INVALID', 'INVALID', 'INVALID', 'INVALID']","solution":"def is_valid_password(password): Returns \\"VALID\\" if the password meets the given criteria, otherwise \\"INVALID\\". if len(password) < 8: return \\"INVALID\\" has_upper = False has_lower = False has_digit = False has_special = False special_characters = {'', '!', '#', '%', '&', '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '{', '}', '|', '~'} for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True if has_upper and has_lower and has_digit and has_special: return \\"VALID\\" return \\"INVALID\\" def validate_passwords(passwords): results = [] for password in passwords: results.append(is_valid_password(password)) return results"},{"question":"def reverse_words(s: str) -> str: Takes a string consisting of words separated by spaces and returns a string where each word is reversed, but the words are in the original order. >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"Coding is fun\\") \\"gnidoC si nuf\\" from solution import reverse_words def test_reverse_single_word(): assert reverse_words(\\"hello\\") == \\"olleh\\" def test_reverse_two_words(): assert reverse_words(\\"hello world\\") == \\"olleh dlrow\\" def test_reverse_multiple_words(): assert reverse_words(\\"Coding is fun\\") == \\"gnidoC si nuf\\" def test_reverse_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_reverse_mixed_case(): assert reverse_words(\\"Hello World\\") == \\"olleH dlroW\\" def test_reverse_string_with_punctuation(): assert reverse_words(\\"hello, world!\\") == \\",olleh !dlrow\\"","solution":"def reverse_words(s): Takes a string consisting of words separated by spaces and returns a string where each word is reversed, but the words are in the original order. return ' '.join(word[::-1] for word in s.split())"},{"question":"def productExceptSelf(nums: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list where each integer is replaced by the product of all the integers in the original list except for the one at the current index, without using division. >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([2, 3, 4, 5]) [60, 40, 30, 24] >>> productExceptSelf([1, 1, 1, 1]) [1, 1, 1, 1] >>> productExceptSelf([10]) [1] >>> productExceptSelf([3, 4]) [4, 3] >>> productExceptSelf([4, 0, 5]) [0, 20, 0] >>> productExceptSelf([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def productExceptSelf(nums): Returns a list such that each element at index i is the product of all the elements in the original array except nums[i], without using division. length = len(nums) # Initialize the two lists left_products = [1] * length right_products = [1] * length result = [1] * length # Fill the left_products array for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill the right_products array for j in range(length - 2, -1, -1): right_products[j] = right_products[j + 1] * nums[j + 1] # Construct the result array for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List def can_concatenate_unique(strings: List[str]) -> bool: Determines if there is a way to concatenate all strings together such that each letter appears at most once in the concatenated result. Args: strings (list of str): List of strings with distinct lowercase letters. Returns: bool: True if there is a way to concatenate without repeat letters, otherwise False. >>> can_concatenate_unique([\\"ab\\", \\"cd\\", \\"ef\\"]) True >>> can_concatenate_unique([\\"ab\\", \\"bc\\", \\"cd\\"]) False >>> can_concatenate_unique([\\"a\\", \\"bc\\", \\"def\\"]) True >>> can_concatenate_unique([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\", \\"h\\", \\"i\\", \\"j\\"]) True","solution":"def can_concatenate_unique(strings): Determines if there is a way to concatenate all strings together such that each letter appears at most once in the concatenated result. Args: strings (list of str): List of strings with distinct lowercase letters. Returns: bool: True if there is a way to concatenate without repeat letters, otherwise False. seen_chars = set() for s in strings: for char in s: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"def reverse_words(s: str) -> str: Given a string of words separated by spaces, return the string with the order of words reversed. Do not reverse the individual words themselves. Args: s (str): A string of words separated by spaces. Returns: str: A string with the order of words reversed. Examples: >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"The quick brown fox\\") 'fox brown quick The'","solution":"def reverse_words(s): Reverses the order of words in a given string. Args: s (str): A string of words separated by spaces. Returns: str: A string with the order of words reversed. return ' '.join(s.split()[::-1])"},{"question":"def digit_to_word(digit_str: str) -> str: Takes a string of numerical digits and returns a string where each digit is replaced by the corresponding word. Args: digit_str (str): A string of numerical digits. Returns: str: A string with each digit replaced by its word representation. >>> digit_to_word(\\"123\\") 'onetwothree' >>> digit_to_word(\\"504\\") 'fivezerofour' >>> digit_to_word(\\"0\\") 'zero' >>> digit_to_word(\\"9\\") 'nine' >>> digit_to_word(\\"0123456789\\") 'zeroonetwothreefourfivesixseveneightnine' >>> digit_to_word(\\"1234567890\\" * 10) 'onetwothreefourfivesixseveneightninezero' * 10","solution":"def digit_to_word(digit_str): Takes a string of numerical digits and returns a string where each digit is replaced by the corresponding word. Args: digit_str (str): A string of numerical digits. Returns: str: A string with each digit replaced by its word representation. digit_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } return ''.join(digit_map[digit] for digit in digit_str)"},{"question":"def count_unique_substrings(s: str, k: int) -> int: Returns the number of unique substrings of length k in s. >>> count_unique_substrings(\\"abcabc\\", 3) 3 >>> count_unique_substrings(\\"aaaaa\\", 2) 1 >>> count_unique_substrings(\\"abacab\\", 2) 4","solution":"def count_unique_substrings(s, k): Returns the number of unique substrings of length k in s. if k > len(s): return 0 # Using a set to store unique substrings of length k substrings = set() for i in range(len(s) - k + 1): substr = s[i:i+k] substrings.add(substr) return len(substrings)"},{"question":"def segregate_even_odd(numbers: List[int]) -> List[int]: Segregate even and odd numbers in a list such that all even numbers come before all odd numbers while preserving their relative order. :param numbers: List of integers. :return: List of integers with all even numbers preceding the odd numbers. >>> segregate_even_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> segregate_even_odd([5, 3, 1, 2, 4, 6]) [2, 4, 6, 5, 3, 1] >>> segregate_even_odd([]) [] >>> segregate_even_odd([5, 3, 1]) [5, 3, 1] >>> segregate_even_odd([2, 4, 6]) [2, 4, 6] >>> segregate_even_odd([7]) [7] >>> segregate_even_odd([8]) [8]","solution":"def segregate_even_odd(numbers): Segregate even and odd numbers in a list such that all even numbers come before all odd numbers while preserving their relative order. :param numbers: List of integers. :return: List of integers with all even numbers preceding the odd numbers. if not numbers: return [] evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] return evens + odds"},{"question":"class MovieRatingSystem: Design a class MovieRatingSystem which can be used to track and query the ratings of movies. Methods: - addRating(movieId, rating): Adds a rating for the given movieId. Ratings are integers between 1 and 5. - getAverageRating(movieId): Returns the average rating of the specified movieId. If there are no ratings, returns -1. - getTopRatedMovies(n): Returns a list of the top n movies with the highest average rating. def __init__(self): pass def addRating(self, movieId, rating): pass def getAverageRating(self, movieId): pass def getTopRatedMovies(self, n): pass def test_add_rating(): movie_rating_system = MovieRatingSystem() movie_rating_system.addRating(1, 5) assert movie_rating_system.ratings[1] == [5] def test_get_average_rating_no_ratings(): movie_rating_system = MovieRatingSystem() assert movie_rating_system.getAverageRating(1) == -1 def test_get_average_rating_with_ratings(): movie_rating_system = MovieRatingSystem() movie_rating_system.addRating(1, 4) movie_rating_system.addRating(1, 5) assert movie_rating_system.getAverageRating(1) == 4.5 def test_get_top_rated_movies(): movie_rating_system = MovieRatingSystem() movie_rating_system.addRating(1, 4) movie_rating_system.addRating(1, 5) movie_rating_system.addRating(2, 3) movie_rating_system.addRating(2, 4) assert movie_rating_system.getTopRatedMovies(1) == [1] assert movie_rating_system.getTopRatedMovies(2) == [1, 2] def test_tied_average_ratings(): movie_rating_system = MovieRatingSystem() movie_rating_system.addRating(1, 4) movie_rating_system.addRating(2, 4) assert movie_rating_system.getTopRatedMovies(2) == [1, 2]","solution":"class MovieRatingSystem: def __init__(self): self.ratings = {} def addRating(self, movieId, rating): if movieId not in self.ratings: self.ratings[movieId] = [] self.ratings[movieId].append(rating) def getAverageRating(self, movieId): if movieId not in self.ratings or len(self.ratings[movieId]) == 0: return -1 sum_ratings = sum(self.ratings[movieId]) count_ratings = len(self.ratings[movieId]) return round(sum_ratings / count_ratings, 2) def getTopRatedMovies(self, n): avg_ratings = [(movieId, sum(ratings) / len(ratings)) for movieId, ratings in self.ratings.items()] avg_ratings.sort(key=lambda x: (-x[1], x[0])) return [movieId for movieId, _ in avg_ratings[:n]]"},{"question":"def categorize_files_by_size(files): Categorize files by their size into Small, Medium, and Large. :param files: List of tuples where each tuple contains a string (file name) and an integer (file size in bytes). :return: Dictionary with keys \\"Small\\", \\"Medium\\", and \\"Large\\" mapping to lists of file names. from solution import categorize_files_by_size def test_categorize_files_mixed(): files = [ (\\"file1.txt\\", 1024), # 1 KB (\\"file2.zip\\", 1048576), # 1 MB (\\"file3.mp3\\", 52428800), # 50 MB (\\"file4.pdf\\", 50000) # 48.83 KB ] expected = { \\"Small\\": [\\"file1.txt\\", \\"file4.pdf\\"], \\"Medium\\": [\\"file2.zip\\"], \\"Large\\": [\\"file3.mp3\\"] } assert categorize_files_by_size(files) == expected def test_categorize_files_all_small(): files = [ (\\"file1.txt\\", 1024), # 1 KB (\\"file2.txt\\", 51200), # 50 KB (\\"file3.txt\\", 98560) # 96.25 KB ] expected = { \\"Small\\": [\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"], \\"Medium\\": [], \\"Large\\": [] } assert categorize_files_by_size(files) == expected def test_categorize_files_all_medium(): files = [ (\\"file1.zip\\", 1048576), # 1 MB (\\"file2.zip\\", 150000), # 146.48 KB (\\"file3.zip\\", 500000) # 488.28 KB ] expected = { \\"Small\\": [], \\"Medium\\": [\\"file1.zip\\", \\"file2.zip\\", \\"file3.zip\\"], \\"Large\\": [] } assert categorize_files_by_size(files) == expected def test_categorize_files_all_large(): files = [ (\\"file1.mp3\\", 2000000), # 1.91 MB (\\"file2.mp3\\", 3000000), # 2.86 MB (\\"file3.mp3\\", 52428800) # 50 MB ] expected = { \\"Small\\": [], \\"Medium\\": [], \\"Large\\": [\\"file1.mp3\\", \\"file2.mp3\\", \\"file3.mp3\\"] } assert categorize_files_by_size(files) == expected def test_categorize_files_empty(): files = [] expected = { \\"Small\\": [], \\"Medium\\": [], \\"Large\\": [] } assert categorize_files_by_size(files) == expected","solution":"def categorize_files_by_size(files): Categorize files by their size into Small, Medium, and Large. :param files: List of tuples where each tuple contains a string (file name) and an integer (file size in bytes). :return: Dictionary with keys \\"Small\\", \\"Medium\\", and \\"Large\\" mapping to lists of file names. categorized_files = { \\"Small\\": [], \\"Medium\\": [], \\"Large\\": [] } for file_name, file_size in files: if file_size < 100 * 1024: categorized_files[\\"Small\\"].append(file_name) elif 100 * 1024 <= file_size <= 1048576: categorized_files[\\"Medium\\"].append(file_name) else: categorized_files[\\"Large\\"].append(file_name) return categorized_files"},{"question":"from typing import List def find_permutations(s: str) -> List[str]: Return a list of all unique permutations of a string sorted in lexicographical order. >>> find_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> find_permutations(\\"aab\\") ['aab', 'aba', 'baa'] >>> find_permutations(\\"a\\") ['a'] >>> find_permutations(\\"\\") [''] >>> find_permutations(\\"aaa\\") ['aaa'] >>> find_permutations(\\"ab\\") ['ab', 'ba'] >>> find_permutations(\\"abcd\\") ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba']","solution":"from itertools import permutations def find_permutations(s: str) -> list: Return all unique permutations of the string s sorted in lexicographical order. unique_permutations = sorted(set(permutations(s))) return [''.join(p) for p in unique_permutations]"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Find the maximum rectangle area that can be formed within the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([2, 4]) == 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([1, 2, 1]) == 3","solution":"def largest_rectangle_area(heights): Find the largest rectangle area in the histogram represented by heights. stack = [] max_area = 0 index = 0 # Iterate through all bars of the histogram while index < len(heights): # If this bar is higher than the bar at stack top, push it to stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now pop the remaining bars from the stack and calculate area with each popped bar's height as the smallest height while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def numIslands(grid: List[List[str]]) -> int: Returns the number of islands in a given grid. An island is a group of '1's (representing land) connected 4-directionally (horizontal or vertical). Args: grid (List[List[str]]): 2D grid representing the map where '1' represents land and '0' represents water. Returns: int: Number of islands in the grid. >>> numIslands([ ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ]) 1 >>> numIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3","solution":"def numIslands(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark the land as visited dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) if not grid: return 0 num_islands = 0 for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == '1': dfs(i, j) num_islands += 1 return num_islands"},{"question":"def merge_strings(s1: str, s2: str) -> str: Merge two strings into a single string where words from the second string are inserted after every word from the first string, maintaining their respective order. Ensure that there's exactly one space between each word in the resulting string, and trim any leading or trailing whitespace. If one string is longer than the other, append the remaining words from the longer string to the end of the merged string. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The merged string with words from \`s1\` and \`s2\`. >>> merge_strings(\\"a b c\\", \\"x y z\\") 'a x b y c z' >>> merge_strings(\\"a b c\\", \\"x y\\") 'a x b y c' >>> merge_strings(\\"a b\\", \\"x y z\\") 'a x b y z' >>> merge_strings(\\"\\", \\"x y z\\") 'x y z' >>> merge_strings(\\"a b c\\", \\"\\") 'a b c' >>> merge_strings(\\"\\", \\"\\") '' >>> merge_strings(\\"hello world!\\", \\"how are you?\\") 'hello how world! are you?' >>> merge_strings(\\"a b\\", \\" x y \\") 'a x b y' >>> merge_strings(\\"hello\\", \\"world\\") 'hello world' >>> merge_strings(\\"hello\\", \\"\\") 'hello' >>> merge_strings(\\"\\", \\"world\\") 'world'","solution":"def merge_strings(s1, s2): Merges two strings, inserting words from \`s2\` after every word from \`s1\`, maintaining their respective order. If one string is longer than the other, appends the remaining words from the longer string to the end of the merged string. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The merged string with words from \`s1\` and \`s2\`. words1 = s1.split() words2 = s2.split() merged_words = [] len1, len2 = len(words1), len(words2) max_len = max(len1, len2) for i in range(max_len): if i < len1: merged_words.append(words1[i]) if i < len2: merged_words.append(words2[i]) return ' '.join(merged_words)"},{"question":"def is_palindromic_number(num: int) -> bool: Determines whether a given integer is a palindrome. >>> is_palindromic_number(121) True >>> is_palindromic_number(123) False >>> is_palindromic_number(-121) False >>> is_palindromic_number(7) True >>> is_palindromic_number(1223221) True >>> is_palindromic_number(1234567) False >>> is_palindromic_number(0) True","solution":"def is_palindromic_number(num): Determines whether a given integer is a palindrome. Args: - num (int): The integer to check. Returns: - bool: True if the integer is a palindrome, False otherwise. # Negative numbers are not palindromic by definition if num < 0: return False # Convert the number to string to easily check if it reads the same backward and forward num_str = str(num) return num_str == num_str[::-1]"},{"question":"from typing import List import re def extract_alphanumeric_words(s: str) -> List[str]: Extracts and returns a list of words that contain both alphabetic characters and digits. Parameters: s (str): A string comprising words separated by spaces. Returns: List[str]: A list of words containing both alphabetic characters and digits. >>> extract_alphanumeric_words(\\"hello a1b2c3 world d4e5 fgh 123\\") [\\"a1b2c3\\", \\"d4e5\\"] >>> extract_alphanumeric_words(\\"hello world fgh\\") [] >>> extract_alphanumeric_words(\\"a1b b2c3 c4d5\\") [\\"a1b\\", \\"b2c3\\", \\"c4d5\\"] >>> extract_alphanumeric_words(\\"A1b2 hello W4rld\\") [\\"A1b2\\", \\"W4rld\\"] >>> extract_alphanumeric_words(\\"123 456 789\\") [] >>> extract_alphanumeric_words(\\"\\") [] >>> extract_alphanumeric_words(\\"123a\\") [\\"123a\\"] >>> extract_alphanumeric_words(\\"a123 a1b1c1 a b c\\") [\\"a123\\", \\"a1b1c1\\"]","solution":"from typing import List import re def extract_alphanumeric_words(s: str) -> List[str]: Extracts and returns a list of words that contain both alphabetic characters and digits. Parameters: s (str): A string comprising words separated by spaces. Returns: List[str]: A list of words containing both alphabetic characters and digits. words = s.split() alphanumeric_words = [] for word in words: if re.search(\\"[a-zA-Z]\\", word) and re.search(\\"[0-9]\\", word): alphanumeric_words.append(word) return alphanumeric_words"},{"question":"def char_frequency(s: str) -> dict: Returns a dictionary with the frequency count of each character (case-sensitive) in the string s. >>> char_frequency(\\"\\") == {} >>> char_frequency(\\"a\\") == {'a': 1} >>> char_frequency(\\"aa\\") == {'a': 2} >>> char_frequency(\\"Aaa\\") == {'a': 2, 'A': 1} >>> char_frequency(\\"HeLLo\\") == {'H': 1, 'e': 1, 'L': 2, 'o': 1} >>> char_frequency(\\"123 123\\") == {'1': 2, '2': 2, '3': 2, ' ': 1}","solution":"def char_frequency(s): Returns a dictionary with the frequency count of each character (case-sensitive) in the string s. frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def final_position(instructions: str) -> tuple: Given a string of instructions, calculate the final coordinates of the robot. Args: instructions (str): A string containing the instructions, where 'U' means up, 'D' means down, 'L' means left, and 'R' means right. Returns: tuple: The final coordinates (x, y) of the robot. >>> final_position(\\"UUDDLRLR\\") (0, 0) >>> final_position(\\"UUU\\") (0, 3) >>> final_position(\\"LLRRDD\\") (0, -2) >>> final_position(\\"ULDR\\") (0, 0)","solution":"def final_position(instructions): Given a string of instructions, calculate the final coordinates of the robot. Args: instructions (str): A string containing the instructions, where 'U' means up, 'D' means down, 'L' means left, and 'R' means right. Returns: tuple: The final coordinates (x, y) of the robot. x, y = 0, 0 for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 return (x, y)"},{"question":"from typing import List def longestStrChain(words: List[str]) -> int: Returns the length of the longest possible word chain such that each word in the chain is a predecessor of the next word. >>> longestStrChain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) == 4 >>> longestStrChain([\\"xbc\\", \\"pcxbcf\\", \\"xb\\", \\"cxbc\\", \\"pcxbc\\"]) == 5 >>> longestStrChain([\\"abcd\\", \\"dbqca\\"]) == 1","solution":"def longestStrChain(words): Returns the length of the longest possible word chain such that each word in the chain is a predecessor of the next word. words.sort(key=len) dp = {} max_len = 1 for word in words: dp[word] = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: dp[word] = max(dp[word], dp[predecessor] + 1) max_len = max(max_len, dp[word]) return max_len"},{"question":"def find_maximum_subarray(arr): Find the subarray with the maximum sum using the divide and conquer approach. Inputs: arr (list): A list of integers which could contain both positive and negative numbers. Outputs: tuple: - An integer representing the maximum sum of the subarray. - A list of integers which represents the subarray with the maximum sum. Examples: >>> find_maximum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [4, -1, 2, 1]) >>> find_maximum_subarray([1, 2, 3, 4, 5]) (15, [1, 2, 3, 4, 5]) >>> find_maximum_subarray([-1, -2, -3, -4, -5]) (-1, [-1]) >>> find_maximum_subarray([2, 3, -2, -1, 10, -5, 1]) (12, [2, 3, -2, -1, 10]) >>> find_maximum_subarray([5]) (5, [5]) >>> find_maximum_subarray([-5]) (-5, [-5]) >>> find_maximum_subarray([]) (0, [])","solution":"def max_crossing_sum(arr, left, mid, right): Helper function to find the maximum sum of the subarray crossing the midpoint. # Initialize variables to store the maximum sums on the left and right of the midpoint left_sum = float('-inf') right_sum = float('-inf') # Calculate the maximum sum in the left half sum_left = 0 max_left_idx = mid for i in range(mid, left - 1, -1): sum_left += arr[i] if sum_left > left_sum: left_sum = sum_left max_left_idx = i # Calculate the maximum sum in the right half sum_right = 0 max_right_idx = mid + 1 for i in range(mid + 1, right + 1): sum_right += arr[i] if sum_right > right_sum: right_sum = sum_right max_right_idx = i return (left_sum + right_sum, arr[max_left_idx:max_right_idx + 1]) def max_subarray_sum(arr, left, right): Helper function to find the maximum sum subarray using the divide and conquer approach. if left == right: return (arr[left], [arr[left]]) mid = (left + right) // 2 # Recursively get the maximum sum in the left, right, and crossing subarrays left_sum, left_subarray = max_subarray_sum(arr, left, mid) right_sum, right_subarray = max_subarray_sum(arr, mid + 1, right) crossing_sum, crossing_subarray = max_crossing_sum(arr, left, mid, right) # Return the maximum of the three if left_sum >= right_sum and left_sum >= crossing_sum: return (left_sum, left_subarray) elif right_sum >= left_sum and right_sum >= crossing_sum: return (right_sum, right_subarray) else: return (crossing_sum, crossing_subarray) def find_maximum_subarray(arr): Find the subarray with the maximum sum using the divide and conquer approach. if not arr: return (0, []) return max_subarray_sum(arr, 0, len(arr) - 1)"},{"question":"def trap(height: List[int]) -> int: Computes how much water it is able to trap after raining. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([1, 1, 1, 1, 1]) 0 pass","solution":"def trap(height): Computes how much water it is able to trap after raining. :param height: List of non-negative integers representing the amount of rainwater each bar can trap. :return: Total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def convert_temperatures(temperatures, current_scale, target_scale): Convert a list of temperatures from one scale to another (Celsius to Fahrenheit or vice versa). Parameters: temperatures (list of floats): List of temperatures to be converted. current_scale (str): 'C' for Celsius, 'F' for Fahrenheit. target_scale (str): 'C' for Celsius, 'F' for Fahrenheit. Returns: list of floats: List of converted temperatures rounded to two decimal places. >>> convert_temperatures([0, 100, -40, 37.78], 'C', 'F') [32.0, 212.0, -40.0, 100.0] >>> convert_temperatures([32, 212, -40, 100], 'F', 'C') [0.0, 100.0, -40.0, 37.78] >>> convert_temperatures([0, 100, -40, 37.78], 'C', 'C') [0.0, 100.0, -40.0, 37.78] >>> convert_temperatures([-273.15, 1000], 'C', 'F') [-459.67, 1832.0]","solution":"def convert_temperatures(temperatures, current_scale, target_scale): Convert a list of temperatures from one scale to another (Celsius to Fahrenheit or vice versa). Parameters: temperatures (list of floats): List of temperatures to be converted. current_scale (str): 'C' for Celsius, 'F' for Fahrenheit. target_scale (str): 'C' for Celsius, 'F' for Fahrenheit. Returns: list of floats: List of converted temperatures rounded to two decimal places. if current_scale == target_scale: return [round(temp, 2) for temp in temperatures] if current_scale == 'C' and target_scale == 'F': return [round((temp * 9/5) + 32, 2) for temp in temperatures] if current_scale == 'F' and target_scale == 'C': return [round((temp - 32) * 5/9, 2) for temp in temperatures] raise ValueError(\\"Invalid scale conversion\\")"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring of given string s. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" # or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"abcde\\") \\"a\\" >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\" >>> longest_palindromic_substring(\\"Aba\\") \\"A\\" >>> longest_palindromic_substring(\\"abc\\") \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"a\\" * 1000) \\"a\\" * 1000","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of given string s. if len(s) == 0: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindrome odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindrome even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def in_stock(item: str, inventory: dict) -> str: Determines if an item is in stock at the store. Args: item (str): The name of the item. inventory (dict): A dictionary where keys are item names and values are quantities available. Returns: str: \\"In stock\\" if the item is in stock (quantity > 0), otherwise \\"Out of stock\\". Examples: >>> inventory = {\\"apple\\": 4, \\"banana\\": 0, \\"orange\\": 10} >>> in_stock(\\"apple\\", inventory) \\"In stock\\" >>> in_stock(\\"banana\\", inventory) \\"Out of stock\\" >>> in_stock(\\"grape\\", inventory) \\"Out of stock\\"","solution":"def in_stock(item, inventory): Determines if an item is in stock at the store. Args: item (str): The name of the item. inventory (dict): A dictionary where keys are item names and values are quantities available. Returns: str: \\"In stock\\" if the item is in stock (quantity > 0), otherwise \\"Out of stock\\". if inventory.get(item, 0) > 0: return \\"In stock\\" else: return \\"Out of stock\\""},{"question":"def min_orbs_to_influence_segment(N, M, L, R, orbs): Determine the minimum number of Orbs required to influence every position in a given segment [L, R]. Args: N (int): Number of Orbs. M (int): Length of the segment to be influenced. L (int): Starting point of the segment. R (int): Ending point of the segment. orbs (List[Tuple[int, int]]): List of tuples where each tuple contains the position and power of an Orb. Returns: int: The minimum number of Orbs required to influence the entire segment. Example: >>> min_orbs_to_influence_segment(3, 8, 2, 9, [(1, 1), (5, 3), (10, 1)]) 2 >>> min_orbs_to_influence_segment(0, 5, 1, 5, []) -1 >>> min_orbs_to_influence_segment(1, 10, 1, 10, [(5, 10)]) 1 >>> min_orbs_to_influence_segment(3, 5, 1, 5, [(1, 1), (3, 1), (5, 1)]) 3 >>> min_orbs_to_influence_segment(4, 10, 1, 10, [(1, 2), (4, 2), (6, 2), (9, 2)]) 3","solution":"def min_orbs_to_influence_segment(N, M, L, R, orbs): # First we sort the orbs based on their effective start position orbs.sort(key=lambda orb: orb[0] - orb[1]) min_orbs = 0 current_end = L - 1 i = 0 # Iterate until we have covered the entire segment [L, R] while current_end < R: best_orb_end = current_end while (i < N and orbs[i][0] - orbs[i][1] <= current_end + 1): best_orb_end = max(best_orb_end, orbs[i][0] + orbs[i][1]) i += 1 if best_orb_end == current_end: return -1 # Segment cannot be fully covered current_end = best_orb_end min_orbs += 1 return min_orbs # Example usage: # N = 3 # M = 8 # L = 2 # R = 9 # orbs = [(1, 1), (5, 3), (10, 1)] # print(min_orbs_to_influence_segment(N, M, L, R, orbs)) # Output should be 2"},{"question":"def can_make_recipe(available_ingredients: dict, recipe: dict) -> bool: Determines if a recipe can be made with available ingredients. Parameters: - available_ingredients (dict): A dictionary with ingredient names as keys and quantities as values. - recipe (dict): A dictionary with ingredient names as keys and quantities needed as values. Returns: - bool: True if the recipe can be made with the available ingredients, otherwise False. Examples: >>> available_ingredients = {'flour': 10, 'sugar': 5, 'eggs': 6, 'milk': 3, 'butter': 2} >>> recipe = {'flour': 5, 'sugar': 2, 'eggs': 4} >>> can_make_recipe(available_ingredients, recipe) True >>> available_ingredients = {'flour': 10, 'sugar': 5, 'eggs': 6, 'milk': 3, 'butter': 2} >>> recipe = {'flour': 8, 'sugar': 5, 'eggs': 4, 'milk': 4} >>> can_make_recipe(available_ingredients, recipe) False from solution import can_make_recipe def test_can_make_recipe_all_ingredients_available(): available_ingredients = { 'flour': 10, 'sugar': 5, 'eggs': 6, 'milk': 3, 'butter': 2 } recipe = { 'flour': 5, 'sugar': 2, 'eggs': 4 } assert can_make_recipe(available_ingredients, recipe) == True def test_can_make_recipe_not_enough_flour(): available_ingredients = { 'flour': 10, 'sugar': 5, 'eggs': 6, 'milk': 3, 'butter': 2 } recipe = { 'flour': 11, 'sugar': 2, 'eggs': 4 } assert can_make_recipe(available_ingredients, recipe) == False def test_can_make_recipe_missing_ingredient(): available_ingredients = { 'flour': 10, 'sugar': 5, 'eggs': 6, 'milk': 3, 'butter': 2 } recipe = { 'flour': 5, 'sugar': 2, 'eggs': 4, 'vanilla': 1 } assert can_make_recipe(available_ingredients, recipe) == False def test_can_make_recipe_exact_ingredients(): available_ingredients = { 'flour': 5, 'sugar': 2, 'eggs': 4 } recipe = { 'flour': 5, 'sugar': 2, 'eggs': 4 } assert can_make_recipe(available_ingredients, recipe) == True def test_can_make_recipe_with_excess_ingredients(): available_ingredients = { 'flour': 25, 'sugar': 15, 'eggs': 20, 'milk': 10, 'butter': 8 } recipe = { 'flour': 5, 'sugar': 2, 'eggs': 4, 'milk': 2 } assert can_make_recipe(available_ingredients, recipe) == True def test_can_make_recipe_empty_ingredients(): available_ingredients = {} recipe = { 'flour': 5, 'sugar': 2, 'eggs': 4 } assert can_make_recipe(available_ingredients, recipe) == False def test_can_make_recipe_empty_recipe(): available_ingredients = { 'flour': 10, 'sugar': 5, 'eggs': 6 } recipe = {} assert can_make_recipe(available_ingredients, recipe) == True","solution":"def can_make_recipe(available_ingredients, recipe): Determines if a recipe can be made with available ingredients. Parameters: - available_ingredients (dict): A dictionary with ingredient names as keys and quantities as values. - recipe (dict): A dictionary with ingredient names as keys and quantities needed as values. Returns: - bool: True if the recipe can be made with the available ingredients, otherwise False. for ingredient, required_qty in recipe.items(): if ingredient not in available_ingredients or available_ingredients[ingredient] < required_qty: return False return True"},{"question":"from typing import List, Tuple def max_coins_in_grid(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Given a number of test cases with rectangular grids of size R x C containing hidden treasures, find the maximum amount of coins that can be collected by starting at the top-left corner and moving to the bottom-right corner, with movements only allowed to the right or down at each step. Args: test_cases: A list of tuples where each tuple contains: - R: int, number of rows in the grid - C: int, number of columns in the grid - grid: List of lists of integers, representing the grid Returns: A list of integers representing the maximum coins that can be collected for each test case. >>> test_cases = [(2, 3, [[0, 3, 1], [2, 0, 4]]), (3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]])] >>> max_coins_in_grid(test_cases) [8, 12] pass def test_sample_cases(): test_cases = [ (2, 3, [[0, 3, 1], [2, 0, 4]]), (3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) ] expected_results = [8, 12] assert max_coins_in_grid(test_cases) == expected_results def test_single_cell(): test_cases = [ (1, 1, [[0]]), (1, 1, [[10]]) ] expected_results = [0, 10] assert max_coins_in_grid(test_cases) == expected_results def test_row_grid(): test_cases = [ (1, 5, [[1, 2, 3, 4, 5]]) ] expected_results = [15] assert max_coins_in_grid(test_cases) == expected_results def test_column_grid(): test_cases = [ (5, 1, [[1], [2], [3], [4], [5]]) ] expected_results = [15] assert max_coins_in_grid(test_cases) == expected_results def test_large_grid(): test_cases = [ (3, 3, [[1000, 0, 0], [0, 1000, 0], [0, 0, 1000]]) ] expected_results = [3000] assert max_coins_in_grid(test_cases) == expected_results def test_multiple_paths(): test_cases = [ (2, 2, [[1, 2], [3, 4]]) ] expected_results = [8] assert max_coins_in_grid(test_cases) == expected_results","solution":"def max_coins_in_grid(test_cases): results = [] for test_case in test_cases: R, C, grid = test_case dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] results.append(dp[R-1][C-1]) return results"},{"question":"def factorial(n: int) -> int: Calculates the factorial of a given number using an iterative approach. Parameters: n (int): A non-negative integer (0 <= n <= 12) Returns: int: The factorial of the given number. pass # Test Cases if __name__ == \\"__main__\\": assert factorial(5) == 120 assert factorial(0) == 1 assert factorial(10) == 3628800 assert factorial(0) == 1 assert factorial(12) == 479001600 assert factorial(1) == 1 try: factorial(-1) except ValueError: pass else: raise AssertionError(\\"Expected ValueError for input -1\\") try: factorial(13) except ValueError: pass else: raise AssertionError(\\"Expected ValueError for input 13\\")","solution":"def factorial(n): Calculates the factorial of a given number using an iterative approach. Parameters: n (int): A non-negative integer (0 <= n <= 12) Returns: int: The factorial of the given number. if n < 0 or n > 12: raise ValueError(\\"Input number must be in the range 0 <= n <= 12\\") result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def is_valid_password(password: str) -> bool: Checks if the input string is a valid password based on the specified criteria: 1. At least 8 characters long. 2. Contains at least one uppercase letter. 3. Contains at least one lowercase letter. 4. Contains at least one digit. 5. Contains at least one special character from the set: ~!@#%^&*()-_+=. Returns True if all criteria are met, otherwise False. >>> is_valid_password(\\"Password123!\\") # Expected output: True True >>> is_valid_password(\\"password123!\\") # Expected output: False False >>> is_valid_password(\\"PASSWORD123!\\") # Expected output: False False >>> is_valid_password(\\"Password!\\") # Expected output: False False >>> is_valid_password(\\"Password12\\") # Expected output: False False >>> is_valid_password(\\"Short1!\\") # Expected output: False False >>> is_valid_password(\\"Passw0rd!\\") # Expected output: True True >>> is_valid_password(\\"P@ssw0rd2022\\") # Expected output: True True >>> is_valid_password(\\"P@ssw0rd\\") # Expected output: True True >>> is_valid_password(\\"short!\\") # Expected output: False False >>> is_valid_password(\\"Short12\\") # Expected output: False False >>> is_valid_password(\\"SHORT!12\\") # Expected output: False False >>> is_valid_password(\\"short123\\") # Expected output: False False","solution":"def is_valid_password(password): Checks if the input string is a valid password based on the specified criteria: 1. At least 8 characters long. 2. Contains at least one uppercase letter. 3. Contains at least one lowercase letter. 4. Contains at least one digit. 5. Contains at least one special character from the set: ~!@#%^&*()-_+=. Returns True if all criteria are met, otherwise False. if len(password) < 8: return False has_uppercase = any(char.isupper() for char in password) has_lowercase = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) has_special = any(char in \\"~!@#%^&*()-_+=\\" for char in password) return has_uppercase and has_lowercase and has_digit and has_special"},{"question":"def transform_list(lst): Transforms a list of integers according to the rules: - Replace with \\"Fizz\\" if divisible by 3 - Replace with \\"Buzz\\" if divisible by 5 - Replace with \\"FizzBuzz\\" if divisible by both 3 and 5 - Otherwise, keep the integer as is Parameters: lst (list): A list of integers Returns: list: A new list with integers and/or strings according to the rules Examples: >>> transform_list([1, 3, 5, 15, 22]) [1, 'Fizz', 'Buzz', 'FizzBuzz', 22] >>> transform_list([3, 6, 9, 12]) ['Fizz', 'Fizz', 'Fizz', 'Fizz'] >>> transform_list([5, 10, 20, 25]) ['Buzz', 'Buzz', 'Buzz', 'Buzz']","solution":"def transform_list(lst): Transforms a list of integers according to the rules: - Replace with \\"Fizz\\" if divisible by 3 - Replace with \\"Buzz\\" if divisible by 5 - Replace with \\"FizzBuzz\\" if divisible by both 3 and 5 - Otherwise, keep the integer as is Parameters: lst (list): A list of integers Returns: list: A new list with integers and/or strings according to the rules result = [] for num in lst: if num % 15 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(num) return result"},{"question":"def insert_log(logs, new_log): Inserts a new log entry into a sorted list of logs while maintaining the sorted order. Parameters: logs (list of tuples): A sorted list of log entries. new_log (tuple): The new log entry to be inserted. Returns: list of tuples: A new list with the new log entry inserted in the correct position. Examples: >>> insert_log([(1, 'food_pack'), (3, 'water_bottle'), (5, 'space_suit')], (4, 'oxygen_tank')) [(1, 'food_pack'), (3, 'water_bottle'), (4, 'oxygen_tank'), (5, 'space_suit')] >>> insert_log([(1, 'tool_kit'), (4, 'navigation_system')], (2, 'med_kit')) [(1, 'tool_kit'), (2, 'med_kit'), (4, 'navigation_system')] def test_insert_log_middle(): logs = [(1, 'food_pack'), (3, 'water_bottle'), (5, 'space_suit')] new_log = (4, 'oxygen_tank') result = insert_log(logs, new_log) expected = [(1, 'food_pack'), (3, 'water_bottle'), (4, 'oxygen_tank'), (5, 'space_suit')] assert result == expected def test_insert_log_start(): logs = [(2, 'tool_kit'), (4, 'navigation_system')] new_log = (1, 'med_kit') result = insert_log(logs, new_log) expected = [(1, 'med_kit'), (2, 'tool_kit'), (4, 'navigation_system')] assert result == expected def test_insert_log_end(): logs = [(1, 'food_pack'), (3, 'water_bottle'), (4, 'oxygen_tank')] new_log = (5, 'space_suit') result = insert_log(logs, new_log) expected = [(1, 'food_pack'), (3, 'water_bottle'), (4, 'oxygen_tank'), (5, 'space_suit')] assert result == expected def test_insert_log_between(): logs = [(1, 'tool_kit'), (4, 'navigation_system')] new_log = (2, 'med_kit') result = insert_log(logs, new_log) expected = [(1, 'tool_kit'), (2, 'med_kit'), (4, 'navigation_system')] assert result == expected def test_insert_single_log(): logs = [(3, 'space_suit')] new_log = (2, 'med_kit') result = insert_log(logs, new_log) expected = [(2, 'med_kit'), (3, 'space_suit')] assert result == expected","solution":"def insert_log(logs, new_log): Inserts a new log entry into a sorted list of logs while maintaining the sorted order. Parameters: logs (list of tuples): A sorted list of log entries. new_log (tuple): The new log entry to be inserted. Returns: list of tuples: A new list with the new log entry inserted in the correct position. new_timestamp, _ = new_log for i in range(len(logs)): if new_timestamp < logs[i][0]: return logs[:i] + [new_log] + logs[i:] return logs + [new_log]"},{"question":"class Entry: Base class for representing an entry in the file hierarchy. Should be inherited by specific types of entries like File and Directory. def __init__(self, name): self.name = name def get_name(self): Return the name of the entry. return self.name def get_size(self): Return the size of the entry. Should be implemented by subclasses. raise NotImplementedError(\\"Subclasses should implement this method\\") def __str__(self): Return the string representation of the entry (its name). return self.name class File(Entry): Class representing a File in the file hierarchy. Inherits from Entry. A File has a size. >>> file = File(\\"file1.txt\\", 100) >>> file.get_size() == 100 True >>> file.get_name() == \\"file1.txt\\" True def __init__(self, name, size): super().__init__(name) self.size = size def get_size(self): Return the size of the file. return self.size class Directory(Entry): Class representing a Directory in the file hierarchy. Inherits from Entry. A Directory can contain multiple entries like Files and other Directories. >>> dir = Directory(\\"dir_with_files\\") >>> file1 = File(\\"file1.txt\\", 100) >>> file2 = File(\\"file2.txt\\", 200) >>> dir.add_entry(file1) >>> dir.add_entry(file2) >>> dir.get_size() == 300 True >>> set(dir.get_entry_names()) == {\\"file1.txt\\", \\"file2.txt\\"} True def __init__(self, name): super().__init__(name) self.entries = [] def add_entry(self, entry): Add an entry to the directory. Entry can be a File or another Directory. self.entries.append(entry) def get_size(self): Return the total size of all entries within the directory. return sum(entry.get_size() for entry in self.entries) def get_entry_names(self): Return the names of all direct children entries in the directory. return [entry.get_name() for entry in self.entries] def test_file_size(): file = File(\\"file1.txt\\", 100) assert file.get_size() == 100 assert file.get_name() == \\"file1.txt\\" def test_empty_directory_size(): directory = Directory(\\"empty_dir\\") assert directory.get_size() == 0 assert directory.get_name() == \\"empty_dir\\" assert directory.get_entry_names() == [] def test_directory_with_files_size(): dir = Directory(\\"dir_with_files\\") file1 = File(\\"file1.txt\\", 100) file2 = File(\\"file2.txt\\", 200) dir.add_entry(file1) dir.add_entry(file2) assert dir.get_size() == 300 assert set(dir.get_entry_names()) == {\\"file1.txt\\", \\"file2.txt\\"} def test_nested_directories_size(): root = Directory(\\"root\\") file1 = File(\\"file1.txt\\", 100) file2 = File(\\"file2.txt\\", 200) subdir = Directory(\\"subdir\\") subdir_file = File(\\"file3.txt\\", 300) subdir.add_entry(subdir_file) root.add_entry(file1) root.add_entry(file2) root.add_entry(subdir) assert root.get_size() == 600 assert set(root.get_entry_names()) == {\\"file1.txt\\", \\"file2.txt\\", \\"subdir\\"} assert subdir.get_size() == 300 assert set(subdir.get_entry_names()) == {\\"file3.txt\\"} def test_string_representation(): file = File(\\"file1.txt\\", 100) directory = Directory(\\"dir\\") assert str(file) == \\"file1.txt\\" assert str(directory) == \\"dir\\"","solution":"class Entry: def __init__(self, name): self.name = name def get_name(self): return self.name def get_size(self): raise NotImplementedError(\\"Subclasses should implement this method\\") def __str__(self): return self.name class File(Entry): def __init__(self, name, size): super().__init__(name) self.size = size def get_size(self): return self.size class Directory(Entry): def __init__(self, name): super().__init__(name) self.entries = [] def add_entry(self, entry): self.entries.append(entry) def get_size(self): return sum(entry.get_size() for entry in self.entries) def get_entry_names(self): return [entry.get_name() for entry in self.entries]"},{"question":"def is_symmetric_matrix(matrix): Determines if a given N x N matrix is symmetric along its main diagonal. Args: matrix (List[List[int]]): The N x N matrix of integers. Returns: bool: True if the matrix is symmetric along its main diagonal, otherwise False. def solve_symmetry(matrix_data): Solves the problem of checking symmetries for multiple test cases. Args: matrix_data (List[List[List[int]]]): List of matrices to be checked. Returns: List[str]: List of results (\\"YES\\" or \\"NO\\") for each matrix. # Unit Test import pytest from solution import is_symmetric_matrix, solve_symmetry def test_is_symmetric_matrix(): assert is_symmetric_matrix([ [1, 2, 3], [2, 4, 5], [3, 5, 6] ]) == True assert is_symmetric_matrix([ [1, 2], [3, 1] ]) == False assert is_symmetric_matrix([ [1] ]) == True assert is_symmetric_matrix([ [1, -2], [-2, 1] ]) == True assert is_symmetric_matrix([ [1, 2, 3], [2, 3, 4], [3, 4, 5] ]) == True def test_solve_symmetry(): assert solve_symmetry([ [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ], [ [1, 2], [2, 1] ] ]) == [\\"YES\\", \\"YES\\"] assert solve_symmetry([ [ [1, 2], [3, 4] ] ]) == [\\"NO\\"] assert solve_symmetry([ [ [5] ] ]) == [\\"YES\\"] assert solve_symmetry([ [ [1, 7, 3], [7, 4, 6], [3, 6, 9] ] ]) == [\\"YES\\"] assert solve_symmetry([ [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ]) == [\\"NO\\"]","solution":"def is_symmetric_matrix(matrix): Determines if a given N x N matrix is symmetric along its main diagonal. Args: matrix (List[List[int]]): The N x N matrix of integers. Returns: bool: True if the matrix is symmetric along its main diagonal, otherwise False. N = len(matrix) for i in range(N): for j in range(i + 1, N): if matrix[i][j] != matrix[j][i]: return False return True def solve_symmetry(matrix_data): Solves the problem of checking symmetries for multiple test cases. Args: matrix_data (List[List[List[int]]]): List of matrices to be checked. Returns: List[str]: List of results (\\"YES\\" or \\"NO\\") for each matrix. results = [] for matrix in matrix_data: if is_symmetric_matrix(matrix): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sum_of_unique_numbers(arr): Returns the sum of all unique numbers in the array. The array can contain both positive and negative numbers as well as duplicates. Your solution should identify and sum only the unique numbers, ignoring any that appear more than once. If there are no unique numbers in the array, then return \`0\`. Parameters: - arr: list of integers, can be positive, negative or zero. Returns: - int: sum of unique numbers. Examples: >>> sum_of_unique_numbers([]) 0 >>> sum_of_unique_numbers([1, 1, 2, 2, 3, 3]) 0 >>> sum_of_unique_numbers([1, 2, 3, 4, 5]) 15 >>> sum_of_unique_numbers([1, 2, 2, 3, 4, 4, 4, -1]) 3 >>> sum_of_unique_numbers([-1, -1, -2, -3, -3]) -2 >>> sum_of_unique_numbers([7]) 7 >>> sum_of_unique_numbers([0, 0, 1, 1, 2]) 2","solution":"def sum_of_unique_numbers(arr): Returns the sum of all unique numbers in the array. Parameters: - arr: list of integers, can be positive, negative or zero. Returns: - int: sum of unique numbers. from collections import Counter # Count the frequency of each number in the array frequency = Counter(arr) # Sum only the numbers that appear exactly once in the array unique_sum = sum([num for num, count in frequency.items() if count == 1]) return unique_sum"},{"question":"def calculate_final_balance(transactions: List[str]) -> int: Calculates the final balance after applying a list of transactions. >>> calculate_final_balance([\\"deposit 1000\\", \\"withdrawal 200\\", \\"transfer 300 to 12345\\"]) 500 >>> calculate_final_balance([\\"deposit 500\\", \\"withdrawal 300\\", \\"transfer 100 to 67890\\", \\"deposit 200\\"]) 300 >>> calculate_final_balance([\\"deposit 1000\\", \\"deposit 2000\\", \\"deposit 3000\\"]) 6000 >>> calculate_final_balance([\\"deposit 5000\\", \\"withdrawal 1000\\", \\"withdrawal 2000\\", \\"withdrawal 1000\\"]) 1000 >>> calculate_final_balance([\\"deposit 5000\\", \\"transfer 1000 to 123\\", \\"transfer 2000 to 456\\", \\"transfer 500 to 789\\"]) 1500 >>> calculate_final_balance([\\"deposit 1000\\", \\"withdrawal 500\\", \\"transfer 200 to 123\\", \\"deposit 300\\", \\"withdrawal 100\\"]) 500","solution":"def calculate_final_balance(transactions): Calculates the final balance after applying a list of transactions. Args: transactions (list of str): List of transactions strings. Returns: int: The final balance. balance = 0 for transaction in transactions: parts = transaction.split() if parts[0] == \\"deposit\\": amount = int(parts[1]) balance += amount elif parts[0] == \\"withdrawal\\": amount = int(parts[1]) balance -= amount elif parts[0] == \\"transfer\\": amount = int(parts[1]) balance -= amount return balance"},{"question":"def max_subarray_sum_less_than_S(arr, S): Given an integer array, find the maximum sum of a contiguous subarray where the sum is less than a given integer S. >>> max_subarray_sum_less_than_S([2, 1, 3, 6, 2], 10) 9 >>> max_subarray_sum_less_than_S([4, 3, 5, 1], 5) 4 pass def max_sums_for_cases(cases): For multiple test cases, return a list of maximum sums for each case. >>> cases = [(5, 10, [2, 1, 3, 6, 2]), (4, 5, [4, 3, 5, 1]), (3, 7, [2, 3, 4])] >>> max_sums_for_cases(cases) [9, 4, 5] pass","solution":"def max_subarray_sum_less_than_S(arr, S): max_sum = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum >= S and start <= end: current_sum -= arr[start] start += 1 if current_sum < S: max_sum = max(max_sum, current_sum) return max_sum def max_sums_for_cases(cases): results = [] for N, S, array in cases: result = max_subarray_sum_less_than_S(array, S) results.append(result) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determines if a binary tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.left.right.right = TreeNode(6) >>> is_balanced(root) False >>> is_balanced(None) True >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> is_balanced(root) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.right = TreeNode(4) >>> is_balanced(root) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is height-balanced. def height(node): if not node: return 0 left_height = height(node.left) if left_height == -1: return -1 right_height = height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return height(root) != -1"},{"question":"from typing import List, Tuple, Dict def get_most_recent_messages(messages: List[Tuple[int, str, str, str, str]], start_date: str, end_date: str) -> Dict[str, Tuple[int, str, str, str, str]]: Retrieves the most recent message for each unique sender within a given date range. Args: - messages (List[Tuple[int, str, str, str, str]]): List of message tuples, where each tuple contains information about a message. - start_date (str): Start date in the format \\"yyyy-mm-dd\\". - end_date (str): End date in the format \\"yyyy-mm-dd\\". Returns: - Dict[str, Tuple[int, str, str, str, str]]: Dictionary of most recent messages per sender within the date range. >>> messages = [ ... (1, \\"Alice\\", \\"Bob\\", \\"2023-01-15\\", \\"Hello!\\"), ... (2, \\"Alice\\", \\"David\\", \\"2023-01-16\\", \\"Hi there!\\"), ... (3, \\"Eve\\", \\"Bob\\", \\"2023-01-17\\", \\"Greetings!\\"), ... (4, \\"Alice\\", \\"Bob\\", \\"2023-01-20\\", \\"Goodbye!\\"), ... (5, \\"Eve\\", \\"Alice\\", \\"2023-01-22\\", \\"See you!\\") ... ] >>> start_date = \\"2023-01-15\\" >>> end_date = \\"2023-01-20\\" >>> get_most_recent_messages(messages, start_date, end_date) { \\"Alice\\": (4, \\"Alice\\", \\"Bob\\", \\"2023-01-20\\", \\"Goodbye!\\"), \\"Eve\\": (3, \\"Eve\\", \\"Bob\\", \\"2023-01-17\\", \\"Greetings!\\") }","solution":"from typing import List, Tuple, Dict from datetime import datetime def get_most_recent_messages(messages: List[Tuple[int, str, str, str, str]], start_date: str, end_date: str) -> Dict[str, Tuple[int, str, str, str, str]]: Retrieves the most recent message for each unique sender within a given date range. Args: - messages (List[Tuple[int, str, str, str, str]]): List of message tuples. - start_date (str): Start date in the format \\"yyyy-mm-dd\\". - end_date (str): End date in the format \\"yyyy-mm-dd\\". Returns: - Dict[str, Tuple[int, str, str, str, str]]: Dictionary of most recent messages per sender within the date range. # Parse the start and end dates start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") # Initialize a dictionary to store the most recent message for each sender most_recent_messages_by_sender = {} for message in messages: message_date = datetime.strptime(message[3], \\"%Y-%m-%d\\") if start_date <= message_date <= end_date: sender = message[1] if sender not in most_recent_messages_by_sender: most_recent_messages_by_sender[sender] = message else: current_most_recent_message = most_recent_messages_by_sender[sender] current_most_recent_message_date = datetime.strptime(current_most_recent_message[3], \\"%Y-%m-%d\\") if message_date > current_most_recent_message_date: most_recent_messages_by_sender[sender] = message return most_recent_messages_by_sender"},{"question":"def sum_of_positives(nums: List[int]) -> int: Returns the sum of all positive integers in the list. If there are no positive integers, it returns 0. >>> sum_of_positives([1, -4, 7, 12]) 20 >>> sum_of_positives([-1, -4, -7, 0]) 0 from solution import sum_of_positives def test_sum_of_positives_with_mixed_numbers(): assert sum_of_positives([1, -4, 7, 12]) == 20 def test_sum_of_positives_with_all_negatives(): assert sum_of_positives([-1, -4, -7, 0]) == 0 def test_sum_of_positives_with_all_positives(): assert sum_of_positives([3, 4, 5, 6]) == 18 def test_sum_of_positives_with_no_numbers(): assert sum_of_positives([]) == 0 def test_sum_of_positives_with_single_positive(): assert sum_of_positives([10]) == 10 def test_sum_of_positives_with_single_negative(): assert sum_of_positives([-10]) == 0 def test_sum_of_positives_with_zero(): assert sum_of_positives([0, 2, 4]) == 6","solution":"def sum_of_positives(nums): Returns the sum of all positive integers in the list. If there are no positive integers, it returns 0. return sum(num for num in nums if num > 0)"},{"question":"from typing import List, Union NestedList = List[Union[int, 'NestedList']] def unique_flatten(nested_list: NestedList) -> List[int]: Flattens a nested list of integers and returns a list of unique integers preserving the order of the first appearance. >>> unique_flatten([1, [2, 3], [4, [5, 6], 3], 2]) [1, 2, 3, 4, 5, 6] >>> unique_flatten([1, [2, [2, 3, 4], 5, [6, 7]], 8, 7]) [1, 2, 3, 4, 5, 6, 7, 8] >>> unique_flatten([[[1, 2], 3], 4, 5, [1, 2, [3, 4]], 6, [5, [7, 8]]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> unique_flatten([1, [2, 2, [2]], [1, 3, [4]], 5]) [1, 2, 3, 4, 5] >>> unique_flatten([]) [] pass def test_unique_flatten_basic(): assert unique_flatten([1, [2, 3], [4, [5, 6], 3], 2]) == [1, 2, 3, 4, 5, 6] assert unique_flatten([1, [2, [2, 3, 4], 5, [6, 7]], 8, 7]) == [1, 2, 3, 4, 5, 6, 7, 8] assert unique_flatten([[[1, 2], 3], 4, 5, [1, 2, [3, 4]], 6, [5, [7, 8]]]) == [1, 2, 3, 4, 5, 6, 7, 8] assert unique_flatten([1, [2, 2, [2]], [1, 3, [4]], 5]) == [1, 2, 3, 4, 5] assert unique_flatten([]) == [] def test_unique_flatten_nested_duplicates(): assert unique_flatten([[1, 1], [2, [2, 3]], 4, [5, [5, [6, 6]]]]) == [1, 2, 3, 4, 5, 6] assert unique_flatten([1, [1, [1, [1]]], [2, [2, [2], 2], 2]]) == [1, 2] def test_unique_flatten_mixed(): assert unique_flatten([1, [1, [2, [3, [4, [5, [6]]]]]]]) == [1, 2, 3, 4, 5, 6] assert unique_flatten([1, 2, [3, 4], [5, 6], 7, 8, [9, 0, [1, 2, [3, 4, [5, 6]]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] def test_unique_flatten_deeply_nested(): assert unique_flatten([[[[[1]]], [[[[2]]]], [[[[3]]]]]]) == [1, 2, 3] assert unique_flatten([[[[[1, 2, 1], [3, 4, 3]], 1], 0], 5, [0]]) == [1, 2, 3, 4, 0, 5] def test_unique_flatten_single_element(): assert unique_flatten([1]) == [1] assert unique_flatten([[1]]) == [1] assert unique_flatten([[[[1]]]]) == [1] def test_unique_flatten_large_range(): input_list = [[i for i in range(1000)], [i for i in range(1000, 2000)]] assert unique_flatten(input_list) == list(range(2000)) input_list.append([i for i in range(2000, 3000)]) assert unique_flatten(input_list) == list(range(3000)) def test_unique_flatten_large_duplicates(): input_list = [[i for i in range(1000)]*10] assert unique_flatten(input_list) == list(range(1000))","solution":"def unique_flatten(nested_list): Flattens a nested list of integers and returns a list of unique integers preserving the order of the first appearance. def _flatten(lst): for item in lst: if isinstance(item, list): yield from _flatten(item) else: yield item seen = set() result = [] for number in _flatten(nested_list): if number not in seen: seen.add(number) result.append(number) return result"},{"question":"def min_steps_to_palindrome(s: str) -> int: Calculate the minimum number of steps required to convert the given string to a palindrome. :param s: Input string consisting of lowercase Latin letters :return: An integer representing the minimum number of steps to make S a palindrome >>> min_steps_to_palindrome(\\"abca\\") 1 >>> min_steps_to_palindrome(\\"race\\") 2 >>> min_steps_to_palindrome(\\"a\\") 0 >>> min_steps_to_palindrome(\\"madam\\") 0 >>> min_steps_to_palindrome(\\"aaa\\") 0 >>> min_steps_to_palindrome(\\"abcd\\") 2 >>> min_steps_to_palindrome(\\"a\\"*10000 + \\"b\\" + \\"a\\"*10000) 0 >>> min_steps_to_palindrome(\\"a\\"*10000 + \\"bc\\" + \\"a\\"*10000) 1","solution":"def min_steps_to_palindrome(s): Calculate the minimum number of steps required to convert the given string to a palindrome. :param s: Input string consisting of lowercase Latin letters :return: An integer representing the minimum number of steps to make S a palindrome n = len(s) steps = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: steps += 1 return steps"},{"question":"def find_sunset_buildings(heights: List[int]) -> List[int]: Returns the indices of buildings that can see the sunset. Parameters: - heights: List of integers representing the heights of the buildings. Returns: - List of indices of buildings that can see the sunset. >>> find_sunset_buildings([3, 7, 8, 3, 6, 1]) [2, 4, 5] >>> find_sunset_buildings([5]) [0] >>> find_sunset_buildings([4, 4, 4, 4]) [3] >>> find_sunset_buildings([5, 4, 3, 2, 1]) [0, 1, 2, 3, 4] >>> find_sunset_buildings([1, 2, 3, 4, 5]) [4] >>> find_sunset_buildings([3, 5, 4, 6, 2, 7, 1]) [5, 6] >>> find_sunset_buildings([]) [] >>> find_sunset_buildings([2, 3]) [1] >>> find_sunset_buildings([3, 3]) [1]","solution":"def find_sunset_buildings(heights): Returns the indices of buildings that can see the sunset. Parameters: - heights: List of integers representing the heights of the buildings. Returns: - List of indices of buildings that can see the sunset. n = len(heights) if n == 0: return [] visible_buildings = [] max_height = 0 for i in range(n-1, -1, -1): if heights[i] > max_height: visible_buildings.append(i) max_height = heights[i] visible_buildings.reverse() return visible_buildings"},{"question":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Given an array of integers nums and an integer k, return the number of contiguous subarrays that sum to k. >>> subarray_sum([1,1,1], 2) == 2 >>> subarray_sum([1,2,3], 3) == 2 def test_subarray_sum_example1(): assert subarray_sum([1, 1, 1], 2) == 2 def test_subarray_sum_example2(): assert subarray_sum([1, 2, 3], 3) == 2 def test_subarray_sum_single_element(): assert subarray_sum([1], 0) == 0 assert subarray_sum([1], 1) == 1 assert subarray_sum([-1], -1) == 1 def test_subarray_sum_large_k(): assert subarray_sum([1,2,3,4,5,6], 21) == 1 def test_subarray_sum_negative_numbers(): assert subarray_sum([-1,-1,1], -2) == 1 assert subarray_sum([1, -1, 1, -1], 0) == 4 def test_subarray_sum_zero_k(): assert subarray_sum([0,0,0,0], 0) == 10 assert subarray_sum([1, -1, 1, -1], 0) == 4","solution":"def subarray_sum(nums, k): Given an array of integers nums and an integer k, return the number of contiguous subarrays that sum to k. count = 0 curr_sum = 0 sum_dict = {0: 1} for num in nums: curr_sum += num if (curr_sum - k) in sum_dict: count += sum_dict[curr_sum - k] if curr_sum in sum_dict: sum_dict[curr_sum] += 1 else: sum_dict[curr_sum] = 1 return count"},{"question":"def max_trapped_water(heights): Calculate the maximum amount of trapped water between the buildings after rainfall. Example 1: >>> max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 Example 2: >>> max_trapped_water([4, 2, 0, 3, 2, 5]) 9 Example 3: >>> max_trapped_water([1, 0, 2]) 1 Example 4: >>> max_trapped_water([0, 0, 0, 0, 0]) 0 Example 5: >>> max_trapped_water([]) 0 Example 6: >>> max_trapped_water([1]) 0 Example 7: >>> max_trapped_water([1, 2]) 0 Example 8: >>> max_trapped_water([1] * 100000) 0 Example 9: >>> max_trapped_water([2, 1, 2]) 1 Example 10: >>> max_trapped_water([3, 0, 0, 2, 0, 4]) 10 pass","solution":"def max_trapped_water(heights): Calculate the maximum amount of trapped water between the buildings after rainfall. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - heights[i]) return water_trapped"},{"question":"def water_stations(participants, threshold): Determines the number of water stations required at each checkpoint. Args: participants (list of int): Number of participants at each checkpoint. threshold (int): Maximum number of participants a single water station can handle. Returns: list of int: Number of water stations required at each checkpoint. Examples: >>> water_stations([130, 200, 50], 100) [2, 2, 1] >>> water_stations([50, 150, 250], 100) [1, 2, 3] >>> water_stations([99, 101, 100], 100) [1, 2, 1] pass # Your solution goes here","solution":"def water_stations(participants, threshold): Determines the number of water stations required at each checkpoint. Args: participants (list of int): Number of participants at each checkpoint. threshold (int): Maximum number of participants a single water station can handle. Returns: list of int: Number of water stations required at each checkpoint. return [(p // threshold) + (1 if p % threshold != 0 else 0) for p in participants]"},{"question":"def isPalindrome(s: str) -> bool: Write a function that accepts a string as its parameter and returns a boolean value indicating whether the given string is a palindrome, considering only alphanumeric characters and ignoring case sensitivity. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"Hello, World!\\") False","solution":"def isPalindrome(s: str) -> bool: Returns True if the input string is a palindrome, ignoring non-alphanumeric characters and case sensitivity. # Filter only alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare filtered list to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def special_sort(arr): Given an array of integers, sort the array such that all even numbers come first (in ascending order), followed by all odd numbers (in descending order). >>> special_sort([3, 1, 2, 4, 6, 5, 9, 10]) [2, 4, 6, 10, 9, 5, 3, 1] >>> special_sort([8, 4, 2, 6]) [2, 4, 6, 8] >>> special_sort([7, 1, 9, 3]) [9, 7, 3, 1] >>> special_sort([]) [] >>> special_sort([2]) [2] >>> special_sort([3]) [3] >>> special_sort([5, 3, 3, 2, 2, 4, 8, 7]) [2, 2, 4, 8, 7, 5, 3, 3] >>> special_sort([-1, -2, -3, -4, -5, -6, -7, -8]) [-8, -6, -4, -2, -1, -3, -5, -7]","solution":"def special_sort(arr): Sort the array such that all even numbers come first (in ascending order), followed by all odd numbers (in descending order). evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) return evens + odds"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s2 is an anagram of s1. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. Examples: >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"oellh\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False","solution":"def is_anagram(s1, s2): Determines if s2 is an anagram of s1. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"def to_roman(n): Convert an integer to a Roman numeral. :param n: Integer to convert (must be between 1 and 3999 inclusive). :return: A string representing the Roman numeral. >>> to_roman(1) == \\"I\\" >>> to_roman(4) == \\"IV\\" >>> to_roman(3999) == \\"MMMCMXCIX\\" >>> to_roman(2023) == \\"MMXXIII\\" pass import pytest def test_to_roman_min_value(): assert to_roman(1) == \\"I\\" def test_to_roman_small_numbers(): assert to_roman(4) == \\"IV\\" assert to_roman(9) == \\"IX\\" assert to_roman(23) == \\"XXIII\\" def test_to_roman_large_numbers(): assert to_roman(3999) == \\"MMMCMXCIX\\" assert to_roman(2023) == \\"MMXXIII\\" def test_to_roman_midrange(): assert to_roman(1000) == \\"M\\" assert to_roman(1987) == \\"MCMLXXXVII\\" assert to_roman(444) == \\"CDXLIV\\" def test_to_roman_edge_cases(): assert to_roman(40) == \\"XL\\" assert to_roman(90) == \\"XC\\" assert to_roman(400) == \\"CD\\" assert to_roman(900) == \\"CM\\" def test_invalid_input_type(): with pytest.raises(ValueError): to_roman(0) with pytest.raises(ValueError): to_roman(4000) with pytest.raises(ValueError): to_roman(-1) with pytest.raises(ValueError): to_roman(\\"ten\\") with pytest.raises(ValueError): to_roman(3.14)","solution":"def to_roman(n): Convert an integer to a Roman numeral. :param n: Integer to convert (must be between 1 and 3999 inclusive). :return: A string representing the Roman numeral. if not isinstance(n, int): raise ValueError(\\"Input must be an integer.\\") if not (1 <= n <= 3999): raise ValueError(\\"Input must be between 1 and 3999 inclusive.\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syb[i] n -= val[i] i += 1 return roman_num"},{"question":"import re from typing import List def find_valid_codes(clues: List[str]) -> List[str]: This function takes an array of strings with clues containing numerical codes and returns a sorted list of valid 4-digit codes as strings. def test_no_valid_codes(): clues = [\\"There are no codes here\\", \\"Not a single one\\", \\"Absolutely none\\"] assert find_valid_codes(clues) == [] def test_single_valid_code(): clues = [\\"The code is hidden as 1-2-3-4\\"] assert find_valid_codes(clues) == [\\"1234\\"] def test_multiple_valid_codes(): clues = [\\"First code: 5a1b2c3d\\", \\"Second one: 7-8-9-0\\", \\"Finally: 2e0f1g3\\"] assert find_valid_codes(clues) == [\\"2013\\", \\"5123\\", \\"7890\\"] def test_invalid_codes(): clues = [\\"The string 12-34-56 isn't valid\\", \\"This 123-4567 will not work either\\"] assert find_valid_codes(clues) == [] def test_mixed_valid_and_invalid_codes(): clues = [\\"Good code here: 1|2|3|4\\", \\"Bad code here: 1234\\", \\"Another valid: 5-6-7-8\\"] assert find_valid_codes(clues) == [\\"1234\\", \\"5678\\"] def test_edge_cases(): clues = [\\"Edge case: 9!8@7#6 should be valid\\", \\"123/4 should be ignored\\"] assert find_valid_codes(clues) == [\\"9876\\"]","solution":"import re def find_valid_codes(clues): This function takes an array of strings with clues containing numerical codes and returns a sorted list of valid 4-digit codes as strings. valid_codes = [] # Regex to find groups of exactly 4 digits, separated by non-digit characters pattern = re.compile(r'dDdDdDd') for clue in clues: matches = pattern.findall(clue) for match in matches: # Remove the non-digit characters to get the 4-digit code code = re.sub(r'D', '', match) if len(code) == 4: valid_codes.append(code) return sorted(valid_codes)"},{"question":"def rotate(nums: List[int], k: int) -> List[int]: Rotate the array to the right by k steps. >>> rotate([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate([1, 2, 3, 4], 6) [3, 4, 1, 2] >>> rotate([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> rotate([1], 1) [1] >>> rotate([1], 100) [1] >>> rotate([7, 7, 7, 7], 3) [7, 7, 7, 7] >>> rotate([1, 2, 3, 4, 5, 6], 15) [4, 5, 6, 1, 2, 3]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. n = len(nums) k = k % n # In case k is greater than the length of nums nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"def min_length(s: str, k: int) -> int: Determine the minimum length of the resulting string after performing at most k removal operations to avoid adjacent duplicates. >>> min_length(\\"aaabbb\\", 2) 4 >>> min_length(\\"aabbcc\\", 3) 3 >>> min_length(\\"abc\\", 1) 2 >>> min_length(\\"abc\\", 0) 3 >>> min_length(\\"abac\\", 1) 3 >>> min_length(\\"aaaa\\", 2) 2 >>> min_length(\\"aaaa\\", 4) 0 >>> min_length(\\"abcde\\", 100) 0 >>> min_length(\\"aabbcc\\", 5) 1 >>> min_length(\\"abcdef\\", 2) 4 >>> min_length(\\"aaaaaa\\", 3) 3 >>> min_length(\\"aaaaaa\\", 0) 6 >>> min_length(\\"aaaaaa\\", 6) 0","solution":"def min_length(s, k): Returns the minimum length of the resulting string after performing at most k removal operations. if k == 0: return len(s) # First we will count the frequency of each character in the string from collections import Counter freq = Counter(s) # Sort characters by frequency in descending order sorted_chars = sorted(freq.items(), key=lambda item: item[1], reverse=True) # Track removals and minimal length removals_left = k length = len(s) for char, count in sorted_chars: if removals_left == 0: break if count <= removals_left: length -= count removals_left -= count else: length -= removals_left removals_left = 0 return length"},{"question":"def calculate_salaries(worker_info): Calculate the total salary of each worker based on their daily rate and the number of days worked. Parameters: worker_info (list of tuples): Each tuple contains the worker's ID (int), daily rate (float), and the number of days worked (int). Returns: dict: A dictionary with worker's ID as keys and their total salary as values. Examples: >>> calculate_salaries([(1, 100.0, 20), (2, 200.0, 15), (3, 150.0, 10)]) {1: 2000.0, 2: 3000.0, 3: 1500.0} >>> calculate_salaries([(4, 80.5, 25), (5, 110.0, 22)]) {4: 2012.5, 5: 2420.0} def test_calculate_salaries_sample(): assert calculate_salaries([(1, 100.0, 20), (2, 200.0, 15), (3, 150.0, 10)]) == {1: 2000.0, 2: 3000.0, 3: 1500.0} def test_calculate_salaries_additional(): assert calculate_salaries([(4, 80.5, 25), (5, 110.0, 22)]) == {4: 2012.5, 5: 2420.0} def test_calculate_salaries_zero_days(): assert calculate_salaries([(1, 100.0, 0), (2, 200.0, 0)]) == {1: 0.0, 2: 0.0} def test_calculate_salaries_zero_rate(): assert calculate_salaries([(1, 0.0, 10), (2, 0.0, 20)]) == {1: 0.0, 2: 0.0} def test_calculate_salaries_empty_list(): assert calculate_salaries([]) == {} def test_calculate_salaries_large_numbers(): assert calculate_salaries([(1, 10000.0, 365), (2, 20000.0, 365)]) == {1: 3650000.0, 2: 7300000.0}","solution":"def calculate_salaries(worker_info): Calculate the total salary of each worker based on their daily rate and the number of days worked. Parameters: worker_info (list of tuples): Each tuple contains the worker's ID (int), daily rate (float), and the number of days worked (int). Returns: dict: A dictionary with worker's ID as keys and their total salary as values. salaries = {} for worker_id, daily_rate, days_worked in worker_info: total_salary = daily_rate * days_worked salaries[worker_id] = total_salary return salaries"},{"question":"def is_valid_code(grid, n): Check if a given code grid is valid based on given conditions. >>> is_valid_code([\\"XOX\\", \\".O.\\", \\"XOX\\"], 3) \\"VALID\\" >>> is_valid_code([\\"XXOX\\", \\"X..O\\", \\"O..X\\", \\"XOXX\\"], 4) \\"INVALID\\" >>> is_valid_code([\\"XO\\", \\"OX\\"], 2) \\"VALID\\" pass def validate_citizen_codes(test_cases): Validate multiple citizen codes and return their status. >>> validate_citizen_codes([ (3, [\\"XOX\\", \\".O.\\", \\"XOX\\"]), (4, [\\"XXOX\\", \\"X..O\\", \\"O..X\\", \\"XOXX\\"]), (2, [\\"XO\\", \\"OX\\"]) ]) [\\"VALID\\", \\"INVALID\\", \\"VALID\\"] >>> validate_citizen_codes([ (1, [\\"X\\"]) ]) [\\"INVALID\\"] >>> validate_citizen_codes([ (3, [\\"...\\", \\"...\\", \\"...\\"]) ]) [\\"VALID\\"] pass","solution":"def is_valid_code(grid, n): for i in range(n): for j in range(n): if grid[i][j] == 'X': has_adjacent_o = False # Check above if i > 0 and grid[i-1][j] == 'O': has_adjacent_o = True # Check below if i < n-1 and grid[i+1][j] == 'O': has_adjacent_o = True # Check left if j > 0 and grid[i][j-1] == 'O': has_adjacent_o = True # Check right if j < n-1 and grid[i][j+1] == 'O': has_adjacent_o = True if not has_adjacent_o: return \\"INVALID\\" return \\"VALID\\" def validate_citizen_codes(test_cases): results = [] for n, grid in test_cases: results.append(is_valid_code(grid, n)) return results"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def level_order_traversal(num_cases: int, cases: List[List[Tuple[int, int]]]) -> List[List[List[int]]]: Given a binary tree, perform level order traversal and return the list of node values for each level. >>> level_order_traversal(2, [[(1, -1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 3)], [(10, -1), (20, 10), (30, 20), (40, 10)]]) [[[1], [2, 3], [4, 5, 6]], [[10], [20, 40], [30]]] def process_input_output(input_data: str) -> List[List[List[int]]]: Process the input string and output the level order traversal results. >>> process_input_output(\\"1n6n1 -1n2 1n3 1n4 2n5 2n6 3\\") [[[1], [2, 3], [4, 5, 6]]] def format_output(results: List[List[List[int]]]) -> str: Format the output for the level order traversal result. >>> format_output([[[1], [2, 3], [4, 5, 6]]]) '1n2 3n4 5 6'","solution":"from collections import defaultdict, deque def level_order_traversal(num_cases, cases): def build_tree(nodes): tree = defaultdict(list) root = None for value, parent in nodes: if parent == -1: root = value else: tree[parent].append(value) return root, tree def bfs_level_order(root, tree): if not root: return [] queue = deque([root]) result = [] while queue: level_nodes = [] for _ in range(len(queue)): node = queue.popleft() level_nodes.append(node) for child in tree[node]: queue.append(child) result.append(level_nodes) return result all_results = [] for nodes in cases: root, tree = build_tree(nodes) levels = bfs_level_order(root, tree) all_results.append(levels) return all_results def process_input_output(input_data): data = input_data.strip().split(\\"n\\") num_cases = int(data.pop(0)) index = 0 cases = [] for _ in range(num_cases): num_nodes = int(data[index]) nodes = [] for i in range(index + 1, index + num_nodes + 1): node_val, parent_val = map(int, data[i].split()) nodes.append((node_val, parent_val)) cases.append(nodes) index += num_nodes + 1 results = level_order_traversal(num_cases, cases) return results def format_output(results): output = [] for levels in results: for level in levels: output.append(\\" \\".join(map(str, level))) return \\"n\\".join(output) input_data = 2 6 1 -1 2 1 3 1 4 2 5 2 6 3 4 10 -1 20 10 30 20 40 10 result = process_input_output(input_data) print(format_output(result))"},{"question":"from typing import List def map_letters_to_primes(text: str) -> List[int]: Maps each letter in the input text to a unique prime number and computes the product for each word. Parameters: text (str): A string consisting of words separated by spaces. Returns: List[int]: A list of products for each word in the input string. >>> map_letters_to_primes(\\"bat cat dog\\") [426, 710, 5593] >>> map_letters_to_primes(\\"cat\\") [710] >>> map_letters_to_primes(\\"aaa bbb\\") [8, 27] >>> map_letters_to_primes(\\"abcdefghijklmnopqrstuvwxyz\\") [232862364358497360900063316880507363070] >>> map_letters_to_primes(\\"\\") [] >>> map_letters_to_primes(\\"a b c\\") [2, 3, 5]","solution":"def map_letters_to_primes(text): Maps each letter in the input text to a unique prime number and computes the product for each word. Parameters: text (str): A string consisting of words separated by spaces. Returns: List[int]: A list of products for each word in the input string. # List of the first 26 prime numbers primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101] # Create a dictionary to map each letter to its corresponding prime number letter_to_prime = {chr(i + ord('a')): prime for i, prime in enumerate(primes)} # Split the input text into words words = text.split() # Calculate the product of prime numbers for each word products = [ product([letter_to_prime[letter] for letter in word]) for word in words ] return products def product(numbers): Computes the product of a list of numbers. Parameters: numbers (List[int]): A list of integers. Returns: int: The product of the numbers. result = 1 for number in numbers: result *= number return result"},{"question":"def find_target_in_matrix(matrix: List[List[int]], target: int) -> bool: Function to find a target value in a n x n matrix where each row and column is sorted. Args: matrix (list of list of int): A 2D list representing the sorted matrix. target (int): The target value to find in the matrix. Returns: bool: True if target is found, False otherwise. def test_find_target_in_matrix(): matrix1 = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert find_target_in_matrix(matrix1, 5) == True assert find_target_in_matrix(matrix1, 1) == True assert find_target_in_matrix(matrix1, 9) == True assert find_target_in_matrix(matrix1, 0) == False assert find_target_in_matrix(matrix1, 10) == False matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert find_target_in_matrix(matrix2, 5) == True assert find_target_in_matrix(matrix2, 1) == True assert find_target_in_matrix(matrix2, 9) == True assert find_target_in_matrix(matrix2, 11) == False assert find_target_in_matrix(matrix2, -1) == False matrix3 = [ [-5, -3, 0], [-2, 2, 4], [1, 3, 10] ] assert find_target_in_matrix(matrix3, 2) == True assert find_target_in_matrix(matrix3, -5) == True assert find_target_in_matrix(matrix3, 10) == True assert find_target_in_matrix(matrix3, -6) == False assert find_target_in_matrix(matrix3, 11) == False","solution":"def find_target_in_matrix(matrix, target): Function to find a target value in a n x n matrix where each row and column is sorted. Args: matrix (list of list of int): A 2D list representing the sorted matrix. target (int): The target value to find in the matrix. Returns: bool: True if target is found, False otherwise. n = len(matrix) row, col = 0, n - 1 while row < n and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def final_amount(spendings: float, status: str) -> float: Calculate the final amount after applying discount based on the customer's loyalty status and spending. Parameters: spendings (float): The total amount spent by the customer. status (str): The loyalty status of the customer (\\"regular\\", \\"silver\\", \\"gold\\"). Returns: float: The final amount to be paid by the customer after applying the discount. # Example test cases # final_amount(150.0, \\"regular\\") # should return 142.5 # final_amount(90.0, \\"silver\\") # should return 80.0 # final_amount(50.0, \\"gold\\") # should return 30.0 # final_amount(15.0, \\"regular\\") # should return 10.0","solution":"def final_amount(spendings, status): Calculate the final amount after applying discount based on the customer's loyalty status and spending. Parameters: spendings (float): The total amount spent by the customer. status (str): The loyalty status of the customer (\\"regular\\", \\"silver\\", \\"gold\\"). Returns: float: The final amount to be paid by the customer after applying the discount. discount_amount = 0 if spendings >= 100: if status == \\"regular\\": discount_amount = spendings * 0.05 elif status == \\"silver\\": discount_amount = spendings * 0.10 elif status == \\"gold\\": discount_amount = spendings * 0.15 else: if status == \\"regular\\": discount_amount = 5 elif status == \\"silver\\": discount_amount = 10 elif status == \\"gold\\": discount_amount = 20 final_cost = spendings - discount_amount # Final cost should not be less than 0 if final_cost < 0: final_cost = 0 return final_cost"},{"question":"def remove_duplicates(email_alerts: List[str]) -> List[str]: Removes duplicate email alerts, keeping only the first occurrence of each string. >>> remove_duplicates([\\"Alert 1\\", \\"Alert 2\\", \\"Alert 1\\", \\"Alert 3\\"]) [\\"Alert 1\\", \\"Alert 2\\", \\"Alert 3\\"] >>> remove_duplicates([\\"Fire\\", \\"Intruder\\", \\"Fire\\", \\"Flood\\", \\"Flood\\"]) [\\"Fire\\", \\"Intruder\\", \\"Flood\\"] >>> remove_duplicates([\\"System Update\\", \\"System Update\\", \\"Meeting Reminder\\"]) [\\"System Update\\", \\"Meeting Reminder\\"] def test_remove_duplicates_with_duplicates(): assert remove_duplicates([\\"Alert 1\\", \\"Alert 2\\", \\"Alert 1\\", \\"Alert 3\\"]) == [\\"Alert 1\\", \\"Alert 2\\", \\"Alert 3\\"] assert remove_duplicates([\\"Fire\\", \\"Intruder\\", \\"Fire\\", \\"Flood\\", \\"Flood\\"]) == [\\"Fire\\", \\"Intruder\\", \\"Flood\\"] assert remove_duplicates([\\"System Update\\", \\"System Update\\", \\"Meeting Reminder\\"]) == [\\"System Update\\", \\"Meeting Reminder\\"] def test_remove_duplicates_without_duplicates(): assert remove_duplicates([\\"Alert 1\\", \\"Alert 2\\", \\"Alert 3\\"]) == [\\"Alert 1\\", \\"Alert 2\\", \\"Alert 3\\"] assert remove_duplicates([\\"Update\\", \\"Meeting\\", \\"Fire\\"]) == [\\"Update\\", \\"Meeting\\", \\"Fire\\"] def test_remove_duplicates_empty(): assert remove_duplicates([]) == [] def test_remove_duplicates_all_same(): assert remove_duplicates([\\"Alert\\", \\"Alert\\", \\"Alert\\", \\"Alert\\"]) == [\\"Alert\\"] def test_remove_duplicates_mixed_case(): assert remove_duplicates([\\"Alert\\", \\"alert\\", \\"ALERT\\", \\"Alert\\"]) == [\\"Alert\\", \\"alert\\", \\"ALERT\\"]","solution":"def remove_duplicates(email_alerts): Removes duplicate email alerts, keeping only the first occurrence of each string. :param email_alerts: List of email alert strings. :return: A list of email alert strings with duplicates removed. seen = set() unique_alerts = [] for alert in email_alerts: if alert not in seen: seen.add(alert) unique_alerts.append(alert) return unique_alerts"},{"question":"def reverse_string(s: str) -> str: Returns the reverse of the input string. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"hello world\\") \\"dlrow olleh\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"madam\\") \\"madam\\" >>> reverse_string(\\"a\\") \\"a\\"","solution":"def reverse_string(s): Returns the reverse of the input string. return s[::-1]"},{"question":"def second_largest(numbers: List[int]) -> int: Returns the second largest integer in the list. >>> second_largest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) 6 >>> second_largest([-1, -2, -3, -4, -5, -6, 0]) -1 >>> second_largest([100, -100, 99, -99, 98, -98]) 99 >>> second_largest([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) 3 def parse_input(input_string: str) -> List[int]: Parses a space-separated string of integers into a list. >>> parse_input(\\"3 1 4 1 5 9 2 6 5 3 5\\") [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] >>> parse_input(\\"-1 -2 -3 -4 -5 -6 0\\") [-1, -2, -3, -4, -5, -6, 0]","solution":"def second_largest(numbers): Returns the second largest integer in the list. unique_numbers = list(set(numbers)) # Remove duplicates unique_numbers.sort(reverse=True) # Sort in descending order return unique_numbers[1] # Return the second largest def parse_input(input_string): Parses a space-separated string of integers into a list. return list(map(int, input_string.split()))"},{"question":"from typing import List, Tuple, Dict def select_warriors(T: int, test_cases: List[Dict[str, List[int]]]) -> List[str]: Select warriors based on the given criteria. >>> input_str = '''2 ... 5 3 10 ... 1 2 3 4 5 ... 4 2 6 ... 5 7 9 11''' >>> T, test_cases = parse_input(input_str) >>> select_warriors(T, test_cases) [\\"1 4 5\\", \\"5 7\\"] >>> input_str = '''1 ... 5 2 10 ... 1 2 3 4 5''' >>> T, test_cases = parse_input(input_str) >>> select_warriors(T, test_cases) [\\"-1\\"] pass def parse_input(input_str: str) -> Tuple[int, List[Dict[str, List[int]]]]: Parse the input string into the required format. >>> input_str = '''2 ... 5 3 10 ... 1 2 3 4 5 ... 4 2 6 ... 5 7 9 11''' >>> parse_input(input_str) (2, [{'N': 5, 'K': 3, 'D': 10, 'strengths': [1, 2, 3, 4, 5]}, {'N': 4, 'K': 2, 'D': 6, 'strengths': [5, 7, 9, 11]}]) pass def test_select_warriors_example(): input_str = '''2 5 3 10 1 2 3 4 5 4 2 6 5 7 9 11''' T, test_cases = parse_input(input_str) output = select_warriors(T, test_cases) assert len(output) == 2 assert output[0] == \\"1 4 5\\" or output[0] == \\"2 3 5\\" # multiple correct outputs are possible assert output[1] == \\"5 7\\" def test_select_warriors_no_solution(): input_str = '''1 5 2 10 1 2 3 4 5''' T, test_cases = parse_input(input_str) output = select_warriors(T, test_cases) assert len(output) == 1 assert output[0] == \\"-1\\" def test_select_warriors_single_case(): input_str = '''1 3 2 5 5 10 15''' T, test_cases = parse_input(input_str) output = select_warriors(T, test_cases) assert len(output) == 1 assert output[0] == \\"5 10\\" or output[0] == \\"10 15\\" def test_select_warriors_all_solutions(): input_str = '''1 5 2 3 3 6 9 12 15''' T, test_cases = parse_input(input_str) output = select_warriors(T, test_cases) assert len(output) == 1 assert output[0] in (\\"3 6\\", \\"3 9\\", \\"3 12\\", \\"3 15\\", \\"6 9\\", \\"6 12\\", \\"6 15\\", \\"9 12\\", \\"9 15\\", \\"12 15\\")","solution":"def select_warriors(T, test_cases): results = [] from itertools import combinations for case in test_cases: N, K, D = case['N'], case['K'], case['D'] strengths = case['strengths'] valid_selection = False for combo in combinations(strengths, K): if sum(combo) % D == 0: results.append(\\" \\".join(map(str, combo))) valid_selection = True break if not valid_selection: results.append(\\"-1\\") return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] line_index = 1 for _ in range(T): N, K, D = map(int, lines[line_index].split()) strengths = list(map(int, lines[line_index + 1].split())) test_cases.append({'N': N, 'K': K, 'D': D, 'strengths': strengths}) line_index += 2 return T, test_cases"},{"question":"def generate_unique_permutations(nums: List[int]) -> List[List[int]]: Generate all unique permutations of a list of integers. >>> generate_unique_permutations([1, 1, 2]) [[1, 1, 2], [1, 2, 1], [2, 1, 1]] >>> generate_unique_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_unique_permutations([]) [] >>> generate_unique_permutations([1]) [[1]] >>> generate_unique_permutations([2, 2, 2]) [[2, 2, 2]]","solution":"def generate_unique_permutations(nums): def backtrack(start=0): if start == len(nums) - 1: permutations.add(tuple(nums[:])) return for i in range(start, len(nums)): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] permutations = set() backtrack() return [list(p) for p in permutations]"},{"question":"def max_skill_utilization(N: int, skills: List[int]) -> int: Returns the maximum total skill utilization for given students' skill levels and problem difficulties. Args: - N (int): Number of students/problems - skills (list of int): Skill levels of the students Returns: - int: Maximum total skill utilization pass # Unit tests def test_sample_input(): assert max_skill_utilization(4, [1, 2, 3, 4]) == 30 def test_reverse_order(): assert max_skill_utilization(4, [4, 3, 2, 1]) == 30 def test_random_order(): assert max_skill_utilization(4, [3, 1, 4, 2]) == 30 def test_all_same_skills(): assert max_skill_utilization(4, [2, 2, 2, 2]) == 20 def test_large_skills(): assert max_skill_utilization(3, [100, 200, 300]) == 1400","solution":"def max_skill_utilization(N, skills): Returns the maximum total skill utilization for given students' skill levels and problem difficulties. Args: - N (int): Number of students/problems - skills (list of int): Skill levels of the students Returns: - int: Maximum total skill utilization # Sort the list of skills skills.sort() # Calculate the maximum skill utilization total_utilization = sum(skill * (i + 1) for i, skill in enumerate(skills)) return total_utilization"},{"question":"def check_string(S: str) -> str: Check if the string S is all alphabetic, all numeric or a mix of both. Parameters: S (str): The input string. Returns: str: \\"Alphabetic\\" if all characters in the string are alphabetic, \\"Numeric\\" if all characters are numeric, \\"Mixed\\" otherwise. Example: >>> check_string('abc') 'Alphabetic' >>> check_string('1234') 'Numeric' >>> check_string('abc123') 'Mixed'","solution":"def check_string(S): Check if the string S is all alphabetic, all numeric or a mix of both. Parameters: S (str): The input string. Returns: str: \\"Alphabetic\\" if all characters in the string are alphabetic, \\"Numeric\\" if all characters are numeric, \\"Mixed\\" otherwise. if S.isalpha(): return \\"Alphabetic\\" elif S.isdigit(): return \\"Numeric\\" else: return \\"Mixed\\""},{"question":"def is_factorial_number(n: int) -> int: Determine if a given number n is a factorial number. If it is, return the integer for which n is the factorial; otherwise, return False. >>> is_factorial_number(6) == 3 >>> is_factorial_number(10) == False >>> is_factorial_number(120) == 5 >>> is_factorial_number(24) == 4","solution":"def is_factorial_number(n): Determines if a given number n is a factorial number. If it is, return the integer for which n is the factorial; otherwise, return False. if n == 1: return 0 # 0! = 1 and 1! = 1 factorial = 1 i = 1 while factorial < n: i += 1 factorial *= i if factorial == n: return i return False"},{"question":"def rotate_matrix(m: List[List[int]], k: int) -> List[List[int]]: Rotates the given matrix \`m\` clockwise by 90 degrees \`k\` times. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4], [5, 6]], 2) [[6, 5], [4, 3], [2, 1]] pass def test_single_rotation_3x3(): m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert rotate_matrix(m, 1) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def test_double_rotation_3x3(): m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert rotate_matrix(m, 2) == [[9, 8, 7], [6, 5, 4], [3, 2, 1]] def test_triple_rotation_3x3(): m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert rotate_matrix(m, 3) == [[3, 6, 9], [2, 5, 8], [1, 4, 7]] def test_quadruple_rotation_3x3(): m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert rotate_matrix(m, 4) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]] def test_rotation_2x3(): m = [[1, 2], [3, 4], [5, 6]] assert rotate_matrix(m, 1) == [[5, 3, 1], [6, 4, 2]] def test_double_rotation_2x3(): m = [[1, 2], [3, 4], [5, 6]] assert rotate_matrix(m, 2) == [[6, 5], [4, 3], [2, 1]] def test_zero_rotation(): m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert rotate_matrix(m, 0) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]] def test_large_k(): m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # k % 4 == 2 implies rotating 2 times effectively assert rotate_matrix(m, 10) == [[9, 8, 7], [6, 5, 4], [3, 2, 1]]","solution":"def rotate_matrix(m, k): Rotates the given matrix \`m\` clockwise by 90 degrees \`k\` times. def rotate_90_deg(mat): Helper function to rotate the matrix mat 90 degrees clockwise. return [list(row) for row in zip(*mat[::-1])] k = k % 4 # Each 4 rotations result back to the original position for _ in range(k): m = rotate_90_deg(m) return m"},{"question":"from typing import List, Tuple def can_make_unique(N: int, M: int, K: int, grid: List[List[int]]) -> str: Determine if it is possible to make the values in all rows and columns unique with at most K operations. Args: N: Number of rows M: Number of columns K: Maximum number of operations grid: 2D list representing the grid Returns: A string \\"YES\\" if it is possible to make all values unique, otherwise \\"NO\\" >>> can_make_unique(2, 2, 1, [[1, 2], [2, 1]]) 'YES' >>> can_make_unique(3, 3, 4, [[3, 3, 3], [3, 3, 3], [2, 2, 2]]) 'NO' >>> can_make_unique(2, 2, 2, [[1, 2], [1, 2]]) 'YES' def solve_test_cases(T: int, test_cases: List[Tuple[Tuple[int, int, int], List[List[int]]]]) -> List[str]: Process multiple test cases to determine if each grid can be made unique. Args: T: Number of test cases test_cases: A list containing tuples where each tuple contains the grid dimensions, maximum operations and the grid itself Returns: A list of strings where each string is \\"YES\\" or \\"NO\\" based on whether the grid can be made unique >>> T = 3 >>> test_cases = [ ... ((2, 2, 1), [[1, 2], [2, 1]]), ... ((3, 3, 4), [[3, 3, 3], [3, 3, 3], [2, 2, 2]]), ... ((2, 2, 2), [[1, 2], [1, 2]]) ... ] >>> solve_test_cases(T, test_cases) ['YES', 'NO', 'YES'] from typing import List, Tuple def test_can_make_unique_small_grid_positive(): N, M, K = 2, 2, 1 grid = [ [1, 2], [2, 1] ] assert can_make_unique(N, M, K, grid) == \\"YES\\" def test_can_make_unique_small_grid_negative(): N, M, K = 3, 3, 4 grid = [ [3, 3, 3], [3, 3, 3], [2, 2, 2] ] assert can_make_unique(N, M, K, grid) == \\"NO\\" def test_can_make_unique_example_case_3(): N, M, K = 2, 2, 2 grid = [ [1, 2], [1, 2] ] assert can_make_unique(N, M, K, grid) == \\"YES\\" def test_solve_test_cases_example_input(): T = 3 test_cases = [ [(2, 2, 1), [ [1, 2], [2, 1] ]], [(3, 3, 4), [ [3, 3, 3], [3, 3, 3], [2, 2, 2] ]], [(2, 2, 2), [ [1, 2], [1, 2] ]] ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert solve_test_cases(T, test_cases) == expected def test_can_make_unique_large_grid(): N, M, K = 2, 2, 3 grid = [ [10**9, 10**9], [10**9, 10**9] ] assert can_make_unique(N, M, K, grid) == \\"NO\\"","solution":"def can_make_unique(N, M, K, grid): row_freqs = [] col_freqs = [dict() for _ in range(M)] # Count frequencies of numbers in each row and column for r in range(N): row_freq = {} for c in range(M): value = grid[r][c] if value in row_freq: row_freq[value] += 1 else: row_freq[value] = 1 if value in col_freqs[c]: col_freqs[c][value] += 1 else: col_freqs[c][value] = 1 row_freqs.append(row_freq) # Count the total number of duplicates duplicates = 0 for row_freq in row_freqs: for count in row_freq.values(): if count > 1: duplicates += count - 1 for col_freq in col_freqs: for count in col_freq.values(): if count > 1: duplicates += count - 1 # Check if the number of steps is within the limit return \\"YES\\" if duplicates <= K else \\"NO\\" def solve_test_cases(T, test_cases): results = [] for i in range(T): N, M, K = test_cases[i][0] grid = test_cases[i][1] results.append(can_make_unique(N, M, K, grid)) return results"},{"question":"def find_busiest_minute(log_entries: List[str]) -> Tuple[str, int]: Identify the busiest minute (most number of events) within a given minute from the log file. If there are multiple minutes with the same number of events, report the earliest one. Args: log_entries: List of strings, each representing a log entry with a timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\" Returns: A tuple with the busiest minute in the format \\"YYYY-MM-DD HH:MM\\" and the number of events during that minute. >>> find_busiest_minute([\\"2023-03-15 10:01:22\\", \\"2023-03-15 10:01:45\\", \\"2023-03-15 10:02:30\\", \\"2023-03-15 10:01:55\\", \\"2023-03-15 10:02:00\\", \\"2023-03-15 10:01:10\\"]) (\\"2023-03-15 10:01\\", 4) >>> find_busiest_minute([\\"2023-03-15 10:01:22\\"]) (\\"2023-03-15 10:01\\", 1) >>> find_busiest_minute([\\"2023-03-15 10:01:22\\", \\"2023-03-15 10:01:45\\", \\"2023-03-15 10:01:10\\"]) (\\"2023-03-15 10:01\\", 3)","solution":"def find_busiest_minute(log_entries): from collections import defaultdict minute_count = defaultdict(int) for entry in log_entries: if entry.strip(): # Check if the entry is not empty # Extract the minute part (YYYY-MM-DD HH:MM) minute = entry[:16] minute_count[minute] += 1 # Find the busiest minute busiest_minute, max_events = max(minute_count.items(), key=lambda x: x[1]) return busiest_minute, max_events"},{"question":"from typing import List def find_repeated_substrings(s: str, k: int) -> List[str]: Given a string s consisting of only lowercase letters, find all possible substrings of length k that occur more than once in the string. Return the substrings as a list of strings in alphabetical order. Examples: >>> find_repeated_substrings(\\"banana\\", 2) [\\"an\\", \\"na\\"] >>> find_repeated_substrings(\\"abcdefg\\", 3) [] >>> find_repeated_substrings(\\"ababababa\\", 2) [\\"ab\\", \\"ba\\"]","solution":"def find_repeated_substrings(s, k): Returns all possible substrings of length k that occur more than once in the string s. The substrings are returned in alphabetical order. from collections import defaultdict substring_count = defaultdict(int) for i in range(len(s) - k + 1): substring = s[i:i+k] substring_count[substring] += 1 result = [sub for sub, count in substring_count.items() if count > 1] result.sort() return result"},{"question":"def is_permutation_of_N(N, arr): Returns \\"YES\\" if arr is a permutation of the first N natural numbers, otherwise \\"NO\\". def check_permutations(test_cases): Processes multiple test cases to find if each array is a permutation of the first N natural numbers. >>> check_permutations([(3, [1, 3, 2]), (4, [2, 1, 3, 5]), (5, [1, 2, 3, 4, 5])]) ['YES', 'NO', 'YES'] # Unit Tests def test_is_permutation_of_N(): assert is_permutation_of_N(3, [1, 3, 2]) == \\"YES\\" assert is_permutation_of_N(4, [2, 1, 3, 5]) == \\"NO\\" assert is_permutation_of_N(5, [1, 2, 3, 4, 5]) == \\"YES\\" assert is_permutation_of_N(1, [1]) == \\"YES\\" assert is_permutation_of_N(2, [1, 3]) == \\"NO\\" assert is_permutation_of_N(3, [3, 2, 1]) == \\"YES\\" assert is_permutation_of_N(4, [4, 3, 1, 2]) == \\"YES\\" assert is_permutation_of_N(4, [4, 3, 2, 2]) == \\"NO\\" def test_check_permutations(): test_cases = [ (3, [1, 3, 2]), (4, [2, 1, 3, 5]), (5, [1, 2, 3, 4, 5]), (1, [1]), (2, [1, 3]), ] assert check_permutations(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] more_tests = [ (3, [3, 2, 1]), (4, [4, 3, 1, 2]), (4, [4, 3, 2, 2]), ] assert check_permutations(more_tests) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_permutation_of_N(N, arr): Returns \\"YES\\" if arr is a permutation of the first N natural numbers, otherwise \\"NO\\". return \\"YES\\" if sorted(arr) == list(range(1, N + 1)) else \\"NO\\" def check_permutations(test_cases): results = [] for N, arr in test_cases: results.append(is_permutation_of_N(N, arr)) return results"},{"question":"import heapq class MedianFinder: A class that supports adding numbers and finding the median in a data stream. Methods: addNum(int num): Adds a number to the data structure. findMedian() -> float: Finds the median of the numbers added so far. Examples: >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2.0 def __init__(self): self.small = [] # max-heap self.large = [] # min-heap def addNum(self, num: int): pass # To Do: Implement this method def findMedian(self) -> float: pass # To Do: Implement this method from solution import MedianFinder def test_median_finder_example_1(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2.0 def test_median_finder_example_2(): mf = MedianFinder() mf.addNum(2) assert mf.findMedian() == 2 mf.addNum(3) assert mf.findMedian() == 2.5 def test_median_finder_single_element(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1 def test_median_finder_even_number_of_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(3) mf.addNum(2) mf.addNum(4) assert mf.findMedian() == 2.5 def test_median_finder_large_numbers(): mf = MedianFinder() mf.addNum(100000) mf.addNum(-100000) assert mf.findMedian() == 0 mf.addNum(0) assert mf.findMedian() == 0 def test_median_finder_mixed_sign_numbers(): mf = MedianFinder() mf.addNum(-1) mf.addNum(1) mf.addNum(-2) mf.addNum(2) assert mf.findMedian() == 0","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # max-heap self.large = [] # min-heap def addNum(self, num: int): heapq.heappush(self.small, -num) if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: if len(self.small) > len(self.large): return float(-self.small[0]) return (-self.small[0] + self.large[0]) / 2.0"},{"question":"def generate_sequence(n): Generates a sequence where each number i (1 <= i <= n) is repeated i times, and groups are separated by commas. Parameters: n (int): the maximum number in the sequence. Returns: str: the generated sequence as a string. >>> generate_sequence(3) \\"1,22,333\\" >>> generate_sequence(5) \\"1,22,333,4444,55555\\"","solution":"def generate_sequence(n): Generates a sequence where each number i (1 <= i <= n) is repeated i times, and groups are separated by commas. Parameters: n (int): the maximum number in the sequence. Returns: str: the generated sequence as a string. return ','.join(str(i) * i for i in range(1, n + 1))"},{"question":"import heapq from collections import defaultdict def find_shortest_path(edges, start, destination): Given a list of tuples edges where each tuple (a, b, d) represents a tunnel from cave a to cave b with a distance of d, find the shortest path distance from the start cave to the destination cave. Each tunnel can only be used at most once. Return an integer representing the shortest path distance. If no such path exists, return -1. >>> find_shortest_path([(1, 2, 2), (2, 3, 3), (1, 4, 1), (4, 3, 2)], 1, 3) 3 >>> find_shortest_path([(1, 2, 1), (2, 3, 4), (2, 4, 2), (4, 3, 1)], 1, 3) 4 >>> find_shortest_path([(1, 2, 3), (2, 1, 1)], 1, 2) 3 >>> find_shortest_path([(1, 2, 2), (2, 3, 3)], 3, 1) -1 >>> find_shortest_path([(1, 2, 5)], 1, 2) 5","solution":"import heapq from collections import defaultdict import sys def find_shortest_path(edges, start, destination): # Create adjacency list adj = defaultdict(list) for a, b, d in edges: adj[a].append((b, d)) # Use Dijkstra's Algorithm with a priority queue pq = [(0, start)] # (distance, node) distances = {start: 0} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == destination: return current_distance for neighbor, weight in adj[current_node]: distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): tree_nodes = [None] + [TreeNode(val=x[0]) for x in nodes] # create a list of nodes for i, (v, l, r) in enumerate(nodes, start=1): if l != -1: tree_nodes[i].left = tree_nodes[l] if r != -1: tree_nodes[i].right = tree_nodes[r] return tree_nodes[1] def max_sum_leaf_to_root(root): if not root: return 0 # If the node is a leaf node, return its value if not root.left and not root.right: return root.val # Recursively find the max sum from both subtrees left_sum = float('-inf') if not root.left else max_sum_leaf_to_root(root.left) right_sum = float('-inf') if not root.right else max_sum_leaf_to_root(root.right) # Return the max sum path till the current node return max(left_sum, right_sum) + root.val def max_sum_path(nodes): Given a list of nodes as tuples (val, left_index, right_index), find the maximum sum from any leaf node to the root node in the binary tree. >>> nodes = [(1, 2, 3), (2, -1, -1), (3, 4, -1), (4, 5, -1), (5, -1, -1)] >>> max_sum_path(nodes) 13 >>> nodes = [(5, -1, -1)] >>> max_sum_path(nodes) 5 >>> nodes = [(1, 2, -1), (2, 3, -1), (3, 4, -1), (4, 5, -1), (5, -1, -1)] >>> max_sum_path(nodes) 15 >>> nodes = [(1, -1, 2), (2, -1, 3), (3, -1, 4), (4, -1, 5), (5, -1, -1)] >>> max_sum_path(nodes) 15 >>> nodes = [(1, 2, 3), (2, 4, 5), (3, 6, 7), (4, -1, -1), (5, -1, -1), (6, -1, -1), (7, -1, -1)] >>> max_sum_path(nodes) 11","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): tree_nodes = [None] + [TreeNode(val=x[0]) for x in nodes] # create a list of nodes for i, (v, l, r) in enumerate(nodes, start=1): if l != -1: tree_nodes[i].left = tree_nodes[l] if r != -1: tree_nodes[i].right = tree_nodes[r] return tree_nodes[1] def max_sum_leaf_to_root(root): if not root: return 0 # If the node is a leaf node, return its value if not root.left and not root.right: return root.val # Recursively find the max sum from both subtrees left_sum = float('-inf') if not root.left else max_sum_leaf_to_root(root.left) right_sum = float('-inf') if not root.right else max_sum_leaf_to_root(root.right) # Return the max sum path till the current node return max(left_sum, right_sum) + root.val def max_sum_path(nodes): root = build_tree(nodes) return max_sum_leaf_to_root(root)"},{"question":"class TextEditor: def __init__(self): Initializes the text editor object. pass def type(self, c: str) -> None: Types the character \`c\` at the end of the text. pass def undo(self) -> None: Undoes the last type operation. pass def redo(self) -> None: Redoes the last undone type operation. pass def getText(self) -> str: Returns the current text. pass def test_type_and_getText(): editor = TextEditor() editor.type('a') assert editor.getText() == \\"a\\" editor.type('b') assert editor.getText() == \\"ab\\" editor.type('c') assert editor.getText() == \\"abc\\" def test_undo(): editor = TextEditor() editor.type('a') editor.type('b') editor.type('c') editor.undo() assert editor.getText() == \\"ab\\" editor.undo() assert editor.getText() == \\"a\\" editor.undo() assert editor.getText() == \\"\\" editor.undo() # Undo when no operations should have no effect assert editor.getText() == \\"\\" def test_redo(): editor = TextEditor() editor.type('a') editor.type('b') editor.type('c') editor.undo() editor.undo() editor.redo() assert editor.getText() == \\"ab\\" editor.redo() assert editor.getText() == \\"abc\\" editor.redo() # Redo when no operations should have no effect assert editor.getText() == \\"abc\\" def test_combined_operations(): editor = TextEditor() editor.type('a') editor.type('b') editor.undo() editor.type('c') assert editor.getText() == \\"ac\\" editor.undo() assert editor.getText() == \\"a\\" editor.undo() assert editor.getText() == \\"\\" editor.redo() assert editor.getText() == \\"a\\" editor.redo() assert editor.getText() == \\"ac\\"","solution":"class TextEditor: def __init__(self): self.text = [] self.undo_stack = [] self.redo_stack = [] def type(self, c: str) -> None: Types the character \`c\` at the end of the text. self.text.append(c) self.undo_stack.append(('type', c)) self.redo_stack.clear() # Clear redo stack whenever a new type operation is performed def undo(self) -> None: Undoes the last type operation. if self.undo_stack: operation = self.undo_stack.pop() if operation[0] == 'type': self.text.pop() self.redo_stack.append(operation) def redo(self) -> None: Redoes the last undone type operation. if self.redo_stack: operation = self.redo_stack.pop() if operation[0] == 'type': self.text.append(operation[1]) self.undo_stack.append(operation) def getText(self) -> str: Returns the current text. return ''.join(self.text)"},{"question":"def can_chef_finish_book(T: int, test_cases: List[Tuple[int, int, List[int], int]]) -> List[str]: Determines if Chef can finish reading the book on time without exceeding the daily page limit. >>> can_chef_finish_book(2, [(5, 3, [100, 200, 300, 400, 500], 300), (4, 4, [100, 200, 300, 100], 300)]) [\\"NO\\", \\"YES\\"] >>> can_chef_finish_book(1, [(1, 1, [1000000], 1000000)]) [\\"YES\\"] >>> can_chef_finish_book(1, [(1, 10, [100], 100)]) [\\"YES\\"] >>> can_chef_finish_book(1, [(3, 2, [250, 250, 250], 250)]) [\\"NO\\"] >>> can_chef_finish_book(1, [(5, 10, [10, 20, 30, 40, 50], 50)]) [\\"YES\\"] >>> can_chef_finish_book(1, [(1000, 1, [1000000] * 1000, 1000000)]) [\\"NO\\"]","solution":"def can_chef_finish_book(T, test_cases): results = [] for i in range(T): N, D, pages, K = test_cases[i] page_segments = pages days_required = 0 possible = True for pages in page_segments: if pages > K: possible = False break if days_required + (pages // K) + (1 if pages % K != 0 else 0) > D: possible = False break else: days_required += (pages // K) + (1 if pages % K != 0 else 0) results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, only considering alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"1\\") True >>> is_palindrome(\\"AbBa\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False","solution":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, only considering alphanumeric characters and ignoring cases. :param s: The input string. :return: True if the string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def smallest_missing_positive(nums: List[int]) -> int: Determine the lowest positive integer that is missing from the list. >>> smallest_missing_positive([3, 4, -1, 1]) == 2 >>> smallest_missing_positive([1, 2, 0]) == 3 >>> smallest_missing_positive([1, 1, 2, 2]) == 3 >>> smallest_missing_positive([1000000, 5, 3, 2, 1]) == 4 >>> smallest_missing_positive([-10, -20, -30]) == 1","solution":"def smallest_missing_positive(nums): Find the lowest positive integer that is missing from the list. nums = [num for num in nums if num > 0] num_set = set(nums) smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def next_greater(n: int) -> int: Returns the next greater positive integer that uses the same number of 1 bits in its binary representation. Returns -1 if no such number exists within the range of 32-bit signed integers. >>> next_greater(5) 6 >>> next_greater(6) 9 >>> next_greater(7) 11 >>> next_greater(2147483647) -1 >>> next_greater(3) 5 >>> next_greater(9) 10 >>> next_greater(2) 4 >>> next_greater(1) 2 >>> next_greater(4) 8 >>> next_greater(2147483646) -1 >>> next_greater(0) -1 >>> next_greater(-1) -1","solution":"def next_greater(n): Returns the next greater positive integer that uses the same number of 1 bits in its binary representation. Returns -1 if no such number exists within the range of 32-bit signed integers. if n <= 0: return -1 # Calculate the binary length and the number of ones ones = bin(n).count('1') candidate = n + 1 # Iterate until we find the next number with the same number of '1' bits while candidate <= 0x7FFFFFFF: # 0x7FFFFFFF is the largest 32-bit signed integer if bin(candidate).count('1') == ones: return candidate candidate += 1 return -1"},{"question":"import random def improved_shuffle(N: int, songs: List[int]) -> List[int]: Simulates the improved shuffle feature, ensuring that no song is played more than once until all other songs have been played. Parameters: - N: number of songs - songs: list of song IDs Returns: - Shuffled list of song IDs >>> improved_shuffle(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> improved_shuffle(3, [1, 2, 1]) [1, 2, 1] from solution import improved_shuffle def test_single_song(): assert improved_shuffle(1, [1]) == [1] def test_no_repeats_simple_case(): result = improved_shuffle(5, [1, 2, 3, 4, 5]) assert sorted(result) == [1, 2, 3, 4, 5] assert all(result[i] != result[i+1] for i in range(len(result)-1)) def test_repeated_songs(): result = improved_shuffle(3, [1, 2, 1]) assert result == [1, 2, 1] or result == [2, 1, 1] def test_more_complex_case(): result = improved_shuffle(6, [1, 2, 1, 3, 4, 2]) assert sorted(result) == [1, 1, 2, 2, 3, 4] assert all(result[i] != result[i+1] for i in range(len(result)-1)) def test_larger_case_with_repeats(): result = improved_shuffle(10, [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]) assert sorted(result) == [1, 1, 1, 2, 2, 2, 3, 3, 3, 4] assert all(result[i] != result[i+1] for i in range(len(result)-1))","solution":"import random def improved_shuffle(N, songs): Simulates the improved shuffle feature, ensuring that no song is played more than once until all other songs have been played. Parameters: - N: number of songs - songs: list of song IDs Returns: - Shuffled list of song IDs if N == 1: return songs song_counts = {song: songs.count(song) for song in set(songs)} shuffled_playlist = [] while len(shuffled_playlist) < N: candidate_songs = list(song_counts.keys()) random.shuffle(candidate_songs) for song in candidate_songs: if song_counts[song] > 0: if len(shuffled_playlist) == 0 or shuffled_playlist[-1] != song: shuffled_playlist.append(song) song_counts[song] -= 1 break return shuffled_playlist"},{"question":"class StoreInventory: You are designing an inventory management system for a small store. Each product has a unique identifier (ID), a name, a quantity, and a price. Implement a \`StoreInventory\` class that allows you to manage the inventory by adding new products, updating the quantity of existing products, and calculating the total value of all products in the store. Example: # Creating an instance of StoreInventory store = StoreInventory() # Adding products to the inventory store.add_product(1, \\"Apple\\", 50, 0.50) store.add_product(2, \\"Banana\\", 100, 0.30) # Updating product quantity store.update_quantity(1, 75) # Updating quantity of \\"Apple\\" to 75 # Calculating total value of inventory total_value = store.calculate_total_value() print(total_value) # Output: 52.5 def __init__(self): Initializes the inventory as an empty dictionary. pass def add_product(self, product_id: int, name: str, quantity: int, price: float): Adds a new product to the inventory. If the product ID already exists in the inventory, it should raise a ValueError with the message \\"Product ID already exists\\". pass def update_quantity(self, product_id: int, quantity: int): Updates the quantity of an existing product. If the product ID does not exist in the inventory, it should raise a ValueError with the message \\"Product ID not found\\". pass def calculate_total_value(self) -> float: Calculates and returns the total value of all products in the inventory. The value of a product is its quantity multiplied by its price. pass","solution":"class StoreInventory: def __init__(self): self.inventory = {} def add_product(self, product_id: int, name: str, quantity: int, price: float): if product_id in self.inventory: raise ValueError(\\"Product ID already exists\\") self.inventory[product_id] = {\\"name\\": name, \\"quantity\\": quantity, \\"price\\": price} def update_quantity(self, product_id: int, quantity: int): if product_id not in self.inventory: raise ValueError(\\"Product ID not found\\") self.inventory[product_id]['quantity'] = quantity def calculate_total_value(self) -> float: total_value = sum(item['quantity'] * item['price'] for item in self.inventory.values()) return round(total_value, 2)"},{"question":"def canAttendAllMeetings(meetings: List[List[int]]) -> bool: Determines if a person can attend all given meetings without conflicts. :param meetings: List of lists, where each list represents a meeting interval [start, end] :return: Boolean, True if the person can attend all meetings, False otherwise >>> canAttendAllMeetings([[0, 30], [5, 10], [15, 20]]) False >>> canAttendAllMeetings([[7, 10], [2, 4]]) True >>> canAttendAllMeetings([[1, 5], [6, 10], [11, 15]]) True","solution":"def canAttendAllMeetings(meetings): Determines if a person can attend all given meetings without conflicts. :param meetings: List of lists, where each list represents a meeting interval [start, end] :return: Boolean, True if the person can attend all meetings, False otherwise # Sort meetings based on start time sorted_meetings = sorted(meetings, key=lambda x: x[0]) for i in range(1, len(sorted_meetings)): # Check if there is an overlap between the current and the previous meeting if sorted_meetings[i][0] < sorted_meetings[i-1][1]: return False return True"},{"question":"from typing import List def array_sum(numbers: List[int]) -> int: Calculates the sum of all elements in the array. Parameters: numbers (List[int]): A list of integers Returns: int: The total sum of the elements in the array pass def test_array_sum_positive_numbers(): assert array_sum([1, 2, 3, 4]) == 10 def test_array_sum_negative_numbers(): assert array_sum([-1, -2, -3, -4]) == -10 def test_array_sum_mixed_sign_numbers(): assert array_sum([1, -2, 3, -4]) == -2 def test_array_sum_empty_list(): assert array_sum([]) == 0 def test_array_sum_single_element(): assert array_sum([5]) == 5 assert array_sum([-5]) == -5 def test_array_sum_large_numbers(): assert array_sum([1000000, 2000000, 3000000]) == 6000000 def test_array_sum_zeros(): assert array_sum([0, 0, 0, 0]) == 0","solution":"from typing import List def array_sum(numbers: List[int]) -> int: Calculates the sum of all elements in the array. Parameters: numbers (List[int]): A list of integers Returns: int: The total sum of the elements in the array return sum(numbers)"},{"question":"def analyzeSocks(sock_colors: List[int]) -> int: Create a function named analyzeSocks which takes an array of integers as input. Each integer in the array represents the color code of a sock. The function should count the number of matching pairs of socks and return the total number of pairs. >>> analyzeSocks([10, 20, 20, 10, 10, 30, 50, 10, 20]) 3 >>> analyzeSocks([10, 20, 30, 40, 50]) 0 >>> analyzeSocks([10, 10, 20, 20, 30, 30]) 3 >>> analyzeSocks([10, 10, 20, 30, 30, 30]) 2 >>> analyzeSocks([]) 0 >>> analyzeSocks([10]) 0","solution":"from typing import List def analyzeSocks(sock_colors: List[int]) -> int: Given an array of integers where each integer represents the color code of a sock, this function counts and returns the number of matching pairs of socks. from collections import Counter color_count = Counter(sock_colors) pairs = 0 for count in color_count.values(): pairs += count // 2 # Each pair of socks return pairs"},{"question":"def h_index(citations: List[int]) -> int: Calculates the H-Index for a researcher given their citations list. :param citations: List[int], number of citations for each paper. :return: int, the H-Index value. >>> h_index([3, 0, 6, 1, 5]) 3 >>> h_index([10, 8, 5, 4, 3]) 4 >>> h_index([0, 0, 0, 0, 0]) 0 >>> h_index([]) 0 >>> h_index([10]) 1 >>> h_index([4, 4, 4, 4, 4]) 4 >>> h_index([1, 3, 1, 6, 7, 10, 2]) 3","solution":"def h_index(citations): Calculates the H-Index for a researcher given their citations list. :param citations: List[int], number of citations for each paper. :return: int, the H-Index value. citations.sort(reverse=True) h = 0 for i, citation in enumerate(citations): if citation >= i + 1: h = i + 1 else: break return h"},{"question":"from typing import List from collections import Counter def find_modes(nums: List[int]) -> List[int]: Returns the mode(s) of the list of integers. If multiple modes, returns them in ascending order. If the list is empty, returns an empty list. >>> find_modes([]) == [] >>> find_modes([7]) == [7] >>> find_modes([1, 1, 2, 3, 4, 5, 6]) == [1] >>> find_modes([20, 30, 20, 30, 20, 30]) == [20, 30] >>> find_modes([4, 4, 1, 2, 2, 3, 3]) == [2, 3, 4] >>> find_modes([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> find_modes([1000000000, 1000000000, -1000000000, -1000000000]) == [-1000000000, 1000000000] >>> find_modes([-1, -2, -1, -2, -3, -3, -3]) == [-3]","solution":"from collections import Counter def find_modes(nums): Returns the mode(s) of the list of integers. If multiple modes, returns them in ascending order. If the list is empty, returns an empty list. if not nums: return [] frequency = Counter(nums) max_frequency = max(frequency.values()) modes = [key for key, value in frequency.items() if value == max_frequency] return sorted(modes)"},{"question":"import heapq from typing import List def kth_largest(arr: List[int], k: int) -> int: Returns the k-th largest element in the given array. >>> kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 def test_kth_largest_example1(): assert kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 def test_kth_largest_example2(): assert kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 def test_kth_largest_single_element(): assert kth_largest([1], 1) == 1 def test_kth_largest_all_same_elements(): assert kth_largest([2, 2, 2, 2, 2], 3) == 2 def test_kth_largest_large_k(): assert kth_largest([1, 2, 3, 4, 5], 5) == 1 def test_kth_largest_negative_elements(): assert kth_largest([-1, -2, -3, -4, -5], 1) == -1 assert kth_largest([-1, -2, -3, -4, -5], 3) == -3 def test_kth_largest_mixed_elements(): assert kth_largest([3, -2, -1, 5, 6, 4], 2) == 5 assert kth_largest([3, -2, -1, 5, 6, 4], 3) == 4","solution":"import heapq def kth_largest(arr, k): Returns the k-th largest element in the given array. return heapq.nlargest(k, arr)[-1]"},{"question":"def min_replacements_to_palindrome(n: int, s: str) -> int: Returns the minimal number of character replacements required to transform the string into a palindrome. Parameters: n (int): Length of the string. s (str): Input string composed of lowercase English letters. Returns: int: Minimal number of replacements. Examples: --------- >>> min_replacements_to_palindrome(5, \\"abcca\\") 1 >>> min_replacements_to_palindrome(6, \\"abccba\\") 0 >>> min_replacements_to_palindrome(7, \\"racecar\\") 0 >>> min_replacements_to_palindrome(8, \\"abcdefgh\\") 4 # Unit Tests def test_min_replacements_to_palindrome_example1(): assert min_replacements_to_palindrome(5, \\"abcca\\") == 1 def test_min_replacements_to_palindrome_example2(): assert min_replacements_to_palindrome(6, \\"abccba\\") == 0 def test_min_replacements_to_palindrome_example3(): assert min_replacements_to_palindrome(7, \\"racecar\\") == 0 def test_min_replacements_to_palindrome_example4(): assert min_replacements_to_palindrome(8, \\"abcdefgh\\") == 4 def test_min_replacements_to_palindrome_single_char(): assert min_replacements_to_palindrome(1, \\"a\\") == 0 def test_min_replacements_to_palindrome_empty_string(): assert min_replacements_to_palindrome(0, \\"\\") == 0 def test_min_replacements_to_palindrome_odd_length(): assert min_replacements_to_palindrome(5, \\"abcba\\") == 0 def test_min_replacements_to_palindrome_all_same_char(): assert min_replacements_to_palindrome(3, \\"aaa\\") == 0 def test_min_replacements_to_palindrome_no_palindrome_substring(): assert min_replacements_to_palindrome(3, \\"abc\\") == 1","solution":"def min_replacements_to_palindrome(n, s): Returns the minimal number of character replacements required to transform the string into a palindrome. Parameters: n (int): Length of the string. s (str): Input string composed of lowercase English letters. Returns: int: Minimal number of replacements. replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"def find_indices(nums, target): Finds two indices such that their corresponding elements in the list \`nums\` add up to \`target\`. The function returns these indices in ascending order. :param nums: List of integers :param target: Integer target sum :return: List of two indices in ascending order >>> find_indices([2, 7, 11, 15], 9) [0, 1] >>> find_indices([3, 2, 4], 6) [1, 2] >>> find_indices([3, 3], 6) [0, 1] >>> find_indices([1, 2, 3], 4) [0, 2] >>> find_indices([1, 2, 3], 7) [] >>> find_indices([-3, 4, 3, 90], 0) [0, 2] >>> find_indices([2], 4) []","solution":"def find_indices(nums, target): Finds two indices such that their corresponding elements in the list \`nums\` add up to \`target\`. The function returns these indices in ascending order. :param nums: List of integers :param target: Integer target sum :return: List of two indices in ascending order lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i return [] # If no solution is found"},{"question":"def find_top_k_toys(scores: List[int], k: int) -> List[int]: Returns the top k unique scores in descending order from the given list. >>> find_top_k_toys([50, 20, 20, 30, 40, 10, 50], 3) == [50, 40, 30] >>> find_top_k_toys([100, 90, 90, 80, 70, 60, 100], 4) == [100, 90, 80, 70] >>> find_top_k_toys([10, 20, 30, 40, 50], 2) == [50, 40] >>> find_top_k_toys([5, 15, 25], 3) == [25, 15, 5] >>> find_top_k_toys([99], 1) == [99] >>> find_top_k_toys([1, 3, 5], 5) == [5, 3, 1] >>> find_top_k_toys([1000000000, 999999999, 500000000], 2) == [1000000000, 999999999] >>> find_top_k_toys([1, 2, 2, 3, 3, 3, 4, 5], 1) == [5]","solution":"def find_top_k_toys(scores, k): Returns the top k unique scores in descending order from the given list. :param scores: List of integers representing the scores of toys :param k: Integer representing the number of top scores to return :return: List of integers with the top k scores in descending order # Remove duplicates and sort the scores in descending order unique_scores = sorted(set(scores), reverse=True) # Return the top k scores, or all scores if there are fewer than k return unique_scores[:k]"},{"question":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: Returns the length of the longest substring where no more than k distinct characters are used. Args: s (str): The input string. k (int): The number of distinct characters allowed in the substring. Returns: int: The length of the longest substring with at most k distinct characters. >>> longest_substring_with_k_distinct_chars(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"a\\", 1) 1 >>> longest_substring_with_k_distinct_chars(\\"a\\", 0) 0 >>> longest_substring_with_k_distinct_chars(\\"\\", 3) 0 >>> longest_substring_with_k_distinct_chars(\\"aba\\", 1) 1 >>> longest_substring_with_k_distinct_chars(\\"aabacbebebe\\", 3) 7","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring where no more than k distinct characters are used. if k == 0 or not s: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def get_sorted_schedules(schedules: List[Dict[str, Union[int, str]]], platform_number: int) -> List[Dict[str, Union[int, str]]]: Returns the list of schedules filtered by platform_number and sorted by arrival_time (and departure_time if necessary). Args: schedules (list of dicts): List of train schedules. platform_number (int): The platform number to filter by. Returns: list of dicts: Sorted and filtered list of schedules for the given platform. >>> schedules = [ ... {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, ... {\\"platform\\": 2, \\"arrival_time\\": \\"08:50\\", \\"departure_time\\": \\"09:10\\"}, ... {\\"platform\\": 1, \\"arrival_time\\": \\"09:05\\", \\"departure_time\\": \\"09:20\\"}, ... {\\"platform\\": 1, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"08:40\\"} ... ] >>> platform_number = 1 >>> get_sorted_schedules(schedules, platform_number) [{\\"platform\\": 1, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"08:40\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"09:05\\", \\"departure_time\\": \\"09:20\\"}] def test_get_sorted_schedules_normal_case(): schedules = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 2, \\"arrival_time\\": \\"08:50\\", \\"departure_time\\": \\"09:10\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"09:05\\", \\"departure_time\\": \\"09:20\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"08:40\\"} ] platform_number = 1 expected_output = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"08:40\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"09:05\\", \\"departure_time\\": \\"09:20\\"} ] assert get_sorted_schedules(schedules, platform_number) == expected_output def test_get_sorted_schedules_no_schedules_on_platform(): schedules = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 2, \\"arrival_time\\": \\"08:50\\", \\"departure_time\\": \\"09:10\\"}, ] platform_number = 3 expected_output = [] assert get_sorted_schedules(schedules, platform_number) == expected_output def test_get_sorted_schedules_empty_input(): schedules = [] platform_number = 1 expected_output = [] assert get_sorted_schedules(schedules, platform_number) == expected_output def test_get_sorted_schedules_same_arrival_times(): schedules = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:05\\"}, {\\"platform\\": 2, \\"arrival_time\\": \\"08:50\\", \\"departure_time\\": \\"09:10\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"08:55\\"} ] platform_number = 1 expected_output = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"08:55\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:05\\"} ] assert get_sorted_schedules(schedules, platform_number) == expected_output def test_get_sorted_schedules_different_platforms_same_times(): schedules = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:20\\"}, {\\"platform\\": 2, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 2, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:20\\"} ] platform_number = 1 expected_output = [ {\\"platform\\": 1, \\"arrival_time\\": \\"08:30\\", \\"departure_time\\": \\"09:00\\"}, {\\"platform\\": 1, \\"arrival_time\\": \\"08:45\\", \\"departure_time\\": \\"09:20\\"} ] assert get_sorted_schedules(schedules, platform_number) == expected_output","solution":"def get_sorted_schedules(schedules, platform_number): Returns the list of schedules filtered by platform_number and sorted by arrival_time (and departure_time if necessary). Args: schedules (list of dicts): List of train schedules. platform_number (int): The platform number to filter by. Returns: list of dicts: Sorted and filtered list of schedules for the given platform. # Filter schedules by the given platform number filtered_schedules = [schedule for schedule in schedules if schedule['platform'] == platform_number] # Sort the filtered schedules by arrival_time (and by departure_time if arrival_times are equal) sorted_schedules = sorted(filtered_schedules, key=lambda x: (x['arrival_time'], x['departure_time'])) return sorted_schedules"},{"question":"def ship_within_days(weights: List[int], D: int) -> int: Given an array of positive integers \`weights\` representing weights of different items, and an integer \`D\` representing the number of days. You need to transport all items within \`D\` days by dividing them into different days' loads. Each day, you can carry a load that can be represented as the sum of elements from a contiguous subarray of \`weights\`. The load for each day cannot exceed a capacity \`C\` which needs to be decided. Your task is to find the smallest capacity \`C\` such that the items can be distributed within \`D\` days. >>> ship_within_days([1,2,3,4,5,6,7,8,9,10], 5) == 15 >>> ship_within_days([3,2,2,4,1,4], 3) == 6 >>> ship_within_days([1,2,3,1,1], 4) == 3 >>> ship_within_days([10], 1) == 10 >>> ship_within_days([3,8,5,6], 2) == 11 >>> ship_within_days([5,5,5,5], 4) == 5 >>> ship_within_days([5,5,5,5], 1) == 20 >>> ship_within_days([1]*50000, 50000) == 1 >>> ship_within_days([500], 1) == 500","solution":"def ship_within_days(weights, D): def can_ship_with_capacity(capacity): days_needed = 1 current_load = 0 for weight in weights: if current_load + weight > capacity: days_needed += 1 current_load = 0 current_load += weight if days_needed > D: return False return True left, right = max(weights), sum(weights) while left < right: mid = (left + right) // 2 if can_ship_with_capacity(mid): right = mid else: left = mid + 1 return left"},{"question":"def smallest_missing_positive_integer(test_cases): Find the smallest missing positive integer for each test case. Args: test_cases: List of tuples where each tuple is (n, list of n integers) Returns: List of smallest missing positive integers for each test case. >>> smallest_missing_positive_integer([(5, [2, 3, 7, 6, 8])]) [1] >>> smallest_missing_positive_integer([(3, [1, 2, 3])]) [4] >>> smallest_missing_positive_integer([(6, [1, 2, 3, 5, 6, 7])]) [4] from solution import smallest_missing_positive_integer def test_small_list(): assert smallest_missing_positive_integer([(5, [2, 3, 7, 6, 8])]) == [1] def test_consecutive_numbers(): assert smallest_missing_positive_integer([(3, [1, 2, 3])]) == [4] def test_large_gap(): assert smallest_missing_positive_integer([(6, [1, 2, 3, 5, 6, 7])]) == [4] def test_with_duplicates(): assert smallest_missing_positive_integer([(5, [1, 3, 3, 0, 2])]) == [4] def test_only_large_numbers(): assert smallest_missing_positive_integer([(4, [100, 101, 102, 200])]) == [1] def test_gaps_in_sequence(): assert smallest_missing_positive_integer([(7, [1, 3, 5, 7, 9, 11, 13])]) == [2] def test_large_n(): assert smallest_missing_positive_integer([(1000, list(range(1, 1001)))]) == [1001] def test_all_zeros(): assert smallest_missing_positive_integer([(5, [0, 0, 0, 0, 0])]) == [1] def test_zeros_and_negatives(): assert smallest_missing_positive_integer([(6, [-1, -2, 0, 2, 3, 4])]) == [1]","solution":"def smallest_missing_positive_integer(test_cases): Find the smallest missing positive integer for each test case. Args: test_cases: List of tuples where each tuple is (n, list of n integers) Returns: List of smallest missing positive integers for each test case. results = [] for n, arr in test_cases: positive_set = set(x for x in arr if x > 0) smallest_missing = 1 while smallest_missing in positive_set: smallest_missing += 1 results.append(smallest_missing) return results"},{"question":"def categorize_numbers(numbers): Categorizes numbers into prime, composite, or neither. Parameters: numbers (list of int): List of positive integers to categorize. Returns: dict: A dictionary with keys 'prime', 'composite', and 'neither'. Each key maps to a list of numbers in the respective category. Examples: >>> categorize_numbers([2, 3, 4, 5, 1, 0, 15, 23, 25]) {'prime': [2, 3, 5, 23], 'composite': [4, 15, 25], 'neither': [1, 0]} >>> categorize_numbers([10, 20, 30, 40]) {'prime': [], 'composite': [10, 20, 30, 40], 'neither': []} >>> categorize_numbers([7, 11, 13, 17]) {'prime': [7, 11, 13, 17], 'composite': [], 'neither': []} # Your code here def test_numbers_mixed_categories(): result = categorize_numbers([2, 3, 4, 5, 1, 0, 15, 23, 25]) assert result == { 'prime': [2, 3, 5, 23], 'composite': [4, 15, 25], 'neither': [1, 0] } def test_composite_only(): result = categorize_numbers([10, 20, 30, 40]) assert result == { 'prime': [], 'composite': [10, 20, 30, 40], 'neither': [] } def test_prime_only(): result = categorize_numbers([7, 11, 13, 17]) assert result == { 'prime': [7, 11, 13, 17], 'composite': [], 'neither': [] } def test_neither_only(): result = categorize_numbers([0, 1]) assert result == { 'prime': [], 'composite': [], 'neither': [0, 1] } def test_empty_input(): result = categorize_numbers([]) assert result == { 'prime': [], 'composite': [], 'neither': [] } def test_large_prime(): result = categorize_numbers([2, 3, 17, 19, 23, 29, 31]) assert result == { 'prime': [2, 3, 17, 19, 23, 29, 31], 'composite': [], 'neither': [] } def test_large_composite(): result = categorize_numbers([4, 6, 8, 9, 10, 12, 14]) assert result == { 'prime': [], 'composite': [4, 6, 8, 9, 10, 12, 14], 'neither': [] }","solution":"from math import isqrt def is_prime(n): Helper function to determine if a number is prime. Returns True if the number is prime, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def categorize_numbers(numbers): Categorizes numbers into prime, composite, or neither. Parameters: numbers (list of int): List of positive integers to categorize. Returns: dict: A dictionary with keys 'prime', 'composite', and 'neither'. Each key maps to a list of numbers in the respective category. categorized = {'prime': [], 'composite': [], 'neither': []} for number in numbers: if number < 2: categorized['neither'].append(number) elif is_prime(number): categorized['prime'].append(number) else: categorized['composite'].append(number) return categorized"},{"question":"from typing import List def longest_city_names(cities: List[str]) -> List[str]: You are given a list of city names which contain only lowercase alphabetical characters. Write a function that returns the longest city name(s) from the given list. If multiple cities have the same maximum length, return all of them in a list sorted in alphabetical order. For example: >>> longest_city_names([\\"paris\\", \\"amsterdam\\", \\"newyork\\", \\"losangeles\\"]) ['losangeles'] >>> longest_city_names([\\"paris\\", \\"london\\", \\"newyork\\", \\"tokyo\\"]) ['newyork'] >>> longest_city_names([\\"delhi\\", \\"chicago\\", \\"boston\\", \\"lisbon\\"]) ['chicago'] >>> longest_city_names([\\"athens\\", \\"madrid\\", \\"oslo\\", \\"berlin\\"]) ['athens', 'berlin', 'madrid'] pass # Unit Tests def test_single_longest_city(): assert longest_city_names([\\"paris\\", \\"amsterdam\\", \\"newyork\\", \\"losangeles\\"]) == ['losangeles'] assert longest_city_names([\\"paris\\", \\"london\\", \\"newyork\\", \\"tokyo\\"]) == ['newyork'] def test_multiple_longest_cities(): assert longest_city_names([\\"athens\\", \\"madrid\\", \\"oslo\\", \\"berlin\\"]) == ['athens', 'berlin', 'madrid'] assert longest_city_names([\\"delhi\\", \\"chicago\\", \\"boston\\", \\"lisbon\\", \\"jacksonville\\"]) == ['jacksonville'] def test_all_same_length(): assert longest_city_names([\\"oslo\\", \\"rome\\", \\"lima\\", \\"baku\\"]) == ['baku', 'lima', 'oslo', 'rome'] def test_empty_input(): assert longest_city_names([]) == [] def test_mixed_case_sensitive(): assert longest_city_names([\\"Paris\\", \\"paris\\", \\"LosAngeles\\", \\"losangeles\\"]) == ['LosAngeles', 'losangeles']","solution":"from typing import List def longest_city_names(cities: List[str]) -> List[str]: if not cities: return [] max_length = max(len(city) for city in cities) longest_cities = [city for city in cities if len(city) == max_length] return sorted(longest_cities)"},{"question":"def can_form_by_rearranging(str1: str, str2: str) -> str: Determines if str2 can be formed by rearranging the characters of str1 and possibly using each character in str1 more than once. >>> can_form_by_rearranging(\\"ab\\", \\"a\\") == \\"YES\\" >>> can_form_by_rearranging(\\"ab\\", \\"abc\\") == \\"NO\\" >>> can_form_by_rearranging(\\"abcd\\", \\"abc\\") == \\"YES\\" pass def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases and returns the results. >>> T = 3 >>> test_cases = [(\\"ab\\", \\"a\\"), (\\"ab\\", \\"abc\\"), (\\"abcd\\", \\"abc\\")] >>> process_test_cases(T, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> T = 2 >>> test_cases = [(\\"aaa\\", \\"aaa\\"), (\\"abc\\", \\"aaa\\")] >>> process_test_cases(T, test_cases) == [\\"YES\\", \\"NO\\"] pass from solution import can_form_by_rearranging, process_test_cases def test_can_form_by_rearranging(): assert can_form_by_rearranging(\\"ab\\", \\"a\\") == \\"YES\\" assert can_form_by_rearranging(\\"ab\\", \\"abc\\") == \\"NO\\" assert can_form_by_rearranging(\\"abcd\\", \\"abc\\") == \\"YES\\" assert can_form_by_rearranging(\\"abc\\", \\"aaa\\") == \\"NO\\" assert can_form_by_rearranging(\\"aaa\\", \\"aaa\\") == \\"YES\\" assert can_form_by_rearranging(\\"xyz\\", \\"xyz\\") == \\"YES\\" assert can_form_by_rearranging(\\"xyz\\", \\"xxyyzz\\") == \\"NO\\" def test_process_test_cases(): T = 3 test_cases = [ (\\"ab\\", \\"a\\"), (\\"ab\\", \\"abc\\"), (\\"abcd\\", \\"abc\\") ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(T, test_cases) == expected_output T = 2 test_cases = [ (\\"aaa\\", \\"aaa\\"), (\\"abc\\", \\"aaa\\") ] expected_output = [\\"YES\\", \\"NO\\"] assert process_test_cases(T, test_cases) == expected_output def test_process_test_cases_large(): T = 1 test_cases = [ (\\"a\\" * 100, \\"a\\" * 100) # Edge case with maximum size strings ] expected_output = [\\"YES\\"] assert process_test_cases(T, test_cases) == expected_output","solution":"def can_form_by_rearranging(str1, str2): Determines if str2 can be formed by rearranging the characters of str1 and possibly using each character in str1 more than once. from collections import Counter count1 = Counter(str1) count2 = Counter(str2) # Check if count2 can be fully covered by count1 for char in count2: if count2[char] > count1.get(char, 0): return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): results = [] for i in range(T): str1, str2 = test_cases[i] results.append(can_form_by_rearranging(str1, str2)) return results"},{"question":"from typing import List def maxSumPath(grid: List[List[int]]) -> int: Given a grid of size n x m filled with non-negative integers, find the maximum sum of the numbers you can collect starting from any cell in the first row and ending in any cell in the last row. You can move straight downwards, diagonally down-left, or diagonally down-right at each step. >>> grid = [ ... [3, 1, 7, 4, 2], ... [2, 8, 1, 9, 7], ... [5, 3, 2, 4, 8], ... [1, 6, 7, 8, 3] ... ] >>> maxSumPath(grid) 32 >>> grid = [ ... [3, 1, 7, 4, 2] ... ] >>> maxSumPath(grid) 7 >>> grid = [ ... [3], ... [8], ... [2], ... [6] ... ] >>> maxSumPath(grid) 19 >>> grid = [ ... [3, 1], ... [2, 2] ... ] >>> maxSumPath(grid) 5 >>> grid = [ ... [1, 1], ... [1, 1], ... [1, 1] ... ] >>> maxSumPath(grid) 3","solution":"from typing import List def maxSumPath(grid: List[List[int]]) -> int: n = len(grid) m = len(grid[0]) # Create a DP table to store the maximum sum up to each cell dp = [[0] * m for _ in range(n)] # Initialize the first row of DP table for j in range(m): dp[0][j] = grid[0][j] # Fill the DP table for i in range(1, n): for j in range(m): down = dp[i - 1][j] down_left = dp[i - 1][j - 1] if j > 0 else 0 down_right = dp[i - 1][j + 1] if j < m - 1 else 0 dp[i][j] = grid[i][j] + max(down, down_left, down_right) # The maximum sum will be the maximum value in the last row of the DP table return max(dp[-1])"},{"question":"def minimize_max_partition_sum(arr: List[int], k: int) -> int: Returns the minimized maximum subset sum when partitioning the array into k subsets. >>> minimize_max_partition_sum([1, 2, 3, 4, 5], 2) == 9 >>> minimize_max_partition_sum([7, 2, 5, 10, 8], 2) == 18 >>> minimize_max_partition_sum([1, 2, 3, 4], 3) == 4 >>> minimize_max_partition_sum([10], 1) == 10 >>> minimize_max_partition_sum([1, 2], 2) == 2 >>> minimize_max_partition_sum([5, 5, 5, 5], 2) == 10 >>> minimize_max_partition_sum([1, 2, 3, 4, 5, 6], 6) == 6 >>> minimize_max_partition_sum([1, 2, 3, 7, 9], 3) == 9","solution":"def can_partition(arr, k, max_sum): Helper function to check whether we can partition the array into k subsets with each subset's sum not exceeding max_sum. current_sum = 0 count = 1 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True def minimize_max_partition_sum(arr, k): Returns the minimized maximum subset sum when partitioning the array into k subsets. left, right = max(arr), sum(arr) answer = right while left <= right: middle = (left + right) // 2 if can_partition(arr, k, middle): answer = middle right = middle - 1 else: left = middle + 1 return answer"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> bool: Determines if the string s can be segmented into one or more words from wordDict. >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"applepie\\", [\\"apple\\", \\"pie\\"]) True >>> wordBreak(\\"applepie\\", [\\"app\\", \\"pie\\"]) False >>> wordBreak(\\"\\", [\\"apple\\", \\"pie\\"]) True >>> wordBreak(\\"apple\\", []) False pass # Unit Test: def test_wordBreak_example_case(): assert wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True def test_wordBreak_single_segment(): assert wordBreak(\\"apple\\", [\\"apple\\", \\"pie\\"]) == True def test_wordBreak_multiple_segments(): assert wordBreak(\\"applepie\\", [\\"apple\\", \\"pie\\"]) == True def test_wordBreak_no_matching_word(): assert wordBreak(\\"applepie\\", [\\"app\\", \\"pie\\"]) == False def test_wordBreak_empty_string(): assert wordBreak(\\"\\", [\\"apple\\", \\"pie\\"]) == True def test_wordBreak_no_words_dict(): assert wordBreak(\\"apple\\", []) == False def test_wordBreak_single_character_match(): assert wordBreak(\\"a\\", [\\"a\\"]) == True def test_wordBreak_repeated_word(): assert wordBreak(\\"aaaa\\", [\\"a\\", \\"aa\\"]) == True def test_wordBreak_complex_case(): assert wordBreak(\\"catsanddog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == True","solution":"def wordBreak(s, wordDict): Determines if the string s can be segmented into one or more words from wordDict. Parameters: s (str): Input string wordDict (List[str]): List of words Returns: bool: True if s can be segmented, else False word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. Args: s (str): The input string consisting only of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" pass def solve_palindrome_problem(test_cases: List[str]) -> List[str]: Solves the problem for multiple test cases. Args: test_cases (list of str): A list of strings for each test case. Returns: list of str: A list containing the results for each test case (\\"YES\\" or \\"NO\\"). >>> solve_palindrome_problem([\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve_palindrome_problem([\\"aabb\\", \\"abcde\\", \\"aabbccdd\\", \\"aabbccdde\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass def test_can_form_palindrome(): assert can_form_palindrome(\\"civic\\") == \\"YES\\" assert can_form_palindrome(\\"ivicc\\") == \\"YES\\" assert can_form_palindrome(\\"hello\\") == \\"NO\\" assert can_form_palindrome(\\"aabb\\") == \\"YES\\" assert can_form_palindrome(\\"abcde\\") == \\"NO\\" assert can_form_palindrome(\\"aabbccdd\\") == \\"YES\\" assert can_form_palindrome(\\"aabbccdde\\") == \\"YES\\" assert can_form_palindrome(\\"a\\") == \\"YES\\" assert can_form_palindrome(\\"aa\\") == \\"YES\\" assert can_form_palindrome(\\"ab\\") == \\"NO\\" def test_solve_palindrome_problem(): test_cases = [\\"civic\\", \\"ivicc\\", \\"hello\\"] assert solve_palindrome_problem(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [\\"aabb\\", \\"abcde\\", \\"aabbccdd\\", \\"aabbccdde\\"] assert solve_palindrome_problem(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): The input string consisting only of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) # For the string to be a palindrome, it can have at most one character with an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\" def solve_palindrome_problem(test_cases): Solves the problem for multiple test cases. Args: test_cases (list of str): A list of strings for each test case. Returns: list of str: A list containing the results for each test case (\\"YES\\" or \\"NO\\"). results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results # Input processing (can be adjusted according to framework or specific needs) def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:T+1] results = solve_palindrome_problem(test_cases) for result in results: print(result)"},{"question":"from typing import List def can_obtain_sum_by_consecutive_elements(N: int, K: int, T: int, array: List[int]) -> str: Determine if the target T can be obtained by adding exactly K consecutive elements of the array. :param N: int - Number of integers in the array :param K: int - Number of consecutive elements to sum :param T: int - Target sum :param array: list - List of integers :return: str - \\"Yes\\" if the sum can be obtained, otherwise \\"No\\" >>> can_obtain_sum_by_consecutive_elements(5, 3, 9, [1, 2, 3, 4, 5]) \\"Yes\\" >>> can_obtain_sum_by_consecutive_elements(6, 2, 4, [1, -1, 2, -2, 3, -3]) \\"No\\" def test_example_1(): N = 5 K = 3 T = 9 array = [1, 2, 3, 4, 5] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"Yes\\" def test_example_2(): N = 6 K = 2 T = 4 array = [1, -1, 2, -2, 3, -3] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"No\\" def test_target_at_start(): N = 4 K = 2 T = 3 array = [1, 2, 3, 4] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"Yes\\" def test_target_at_end(): N = 4 K = 3 T = 9 array = [2, 1, 2, 6] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"Yes\\" def test_no_possible_sum(): N = 5 K = 4 T = 11 array = [1, 5, 9, 0, -2] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"No\\" def test_single_element_array(): N = 1 K = 1 T = 5 array = [5] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"Yes\\" def test_large_numbers(): N = 3 K = 2 T = 1000000000 array = [500000000, 500000000, 1] assert can_obtain_sum_by_consecutive_elements(N, K, T, array) == \\"Yes\\"","solution":"def can_obtain_sum_by_consecutive_elements(N, K, T, array): Determine if the target T can be obtained by adding exactly K consecutive elements of the array. :param N: int - Number of integers in the array :param K: int - Number of consecutive elements to sum :param T: int - Target sum :param array: list - List of integers :return: str - \\"Yes\\" if the sum can be obtained, otherwise \\"No\\" # Calculate the sum of the first K elements current_sum = sum(array[:K]) # Check if the initial sum equals the target if current_sum == T: return \\"Yes\\" # Use a sliding window approach to calculate the sum of each K consecutive elements for i in range(K, N): # Update the sum to include the next element and exclude the previous element current_sum += array[i] - array[i - K] if current_sum == T: return \\"Yes\\" return \\"No\\" # Demonstration of the function with the given examples N = 5 K = 3 T = 9 array = [1, 2, 3, 4, 5] print(can_obtain_sum_by_consecutive_elements(N, K, T, array)) # Output: \\"Yes\\" N = 6 K = 2 T = 4 array = [1, -1, 2, -2, 3, -3] print(can_obtain_sum_by_consecutive_elements(N, K, T, array)) # Output: \\"No\\""},{"question":"def longest_consecutive_sequence(grid: List[List[str]], character: str) -> int: Returns the length of the longest consecutive sequence of the given character in the grid. The sequence can be horizontal, vertical, or diagonal. >>> longest_consecutive_sequence([['a', 'b', 'a', 'a'], ['b', 'a', 'a', 'b'], ['a', 'a', 'b', 'a'], ['b', 'b', 'a', 'a']], 'a') == 4 >>> longest_consecutive_sequence([['a', 'b'], ['c', 'd']], 'e') == 0 >>> longest_consecutive_sequence([['a', 'a', 'a', 'a'], ['b', 'a', 'a', 'b'], ['a', 'a', 'b', 'a'], ['b', 'b', 'a', 'a']], 'a') == 4 >>> longest_consecutive_sequence([['a', 'b', 'a'], ['a', 'b', 'a'], ['a', 'b', 'a'], ['a', 'b', 'b']], 'a') == 4 >>> longest_consecutive_sequence([['a', 'b', 'c'], ['b', 'a', 'c'], ['a', 'c', 'a']], 'a') == 3 >>> longest_consecutive_sequence([['a', 'b', 'a', 'a'], ['b', 'a', 'a', 'a'], ['a', 'a', 'b', 'a'], ['b', 'b', 'a', 'a']], 'a') == 4","solution":"def longest_consecutive_sequence(grid, character): Returns the length of the longest consecutive sequence of the given character in the grid. The sequence can be horizontal, vertical, or diagonal. if not grid or not character: return 0 rows = len(grid) cols = len(grid[0]) max_length = 0 # Directions: right, down-right, down, down-left directions = [(0, 1), (1, 1), (1, 0), (1, -1)] def count_in_direction(r, c, dr, dc): count = 0 while 0 <= r < rows and 0 <= c < cols and grid[r][c] == character: count += 1 r += dr c += dc return count for r in range(rows): for c in range(cols): if grid[r][c] == character: for dr, dc in directions: max_length = max(max_length, count_in_direction(r, c, dr, dc)) return max_length"},{"question":"def sort_book_ids(n: int, book_ids: List[str]) -> List[str]: Sorts book IDs according to the custom sorting rule. Parameters: n (int) : Number of book IDs book_ids (list): List of book IDs Returns: list: Sorted list of book IDs pass # Example usage # book_ids = [\\"123\\", \\"abc\\", \\"A12\\", \\"56\\", \\"bA3\\"] # sorted_ids = sort_book_ids(5, book_ids) # print(\\"n\\".join(sorted_ids)) # This would print the sorted IDs as per given custom rule. # Unit tests def test_sort_with_all_numeric_ids(): assert sort_book_ids(3, [\\"123\\", \\"56\\", \\"7\\"]) == [\\"7\\", \\"56\\", \\"123\\"] def test_sort_with_mixed_ids(): assert sort_book_ids(5, [\\"123\\", \\"abc\\", \\"A12\\", \\"56\\", \\"bA3\\"]) == [\\"56\\", \\"123\\", \\"A12\\", \\"abc\\", \\"bA3\\"] def test_sort_with_all_uppercase_ids(): assert sort_book_ids(3, [\\"A12\\", \\"B34\\", \\"C56\\"]) == [\\"A12\\", \\"B34\\", \\"C56\\"] def test_sort_with_all_lowercase_ids(): assert sort_book_ids(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) == [\\"abc\\", \\"def\\", \\"ghi\\"] def test_sort_with_single_id(): assert sort_book_ids(1, [\\"123\\"]) == [\\"123\\"] assert sort_book_ids(1, [\\"A12\\"]) == [\\"A12\\"] assert sort_book_ids(1, [\\"abc\\"]) == [\\"abc\\"]","solution":"def sort_book_ids(n, book_ids): Sorts book IDs according to the custom sorting rule. Parameters: n (int) : Number of book IDs book_ids (list): List of book IDs Returns: list: Sorted list of book IDs numeric_ids = [] uppercase_ids = [] lowercase_ids = [] for book_id in book_ids: if book_id.isdigit(): numeric_ids.append(book_id) elif book_id[0].isupper(): uppercase_ids.append(book_id) else: lowercase_ids.append(book_id) numeric_ids.sort(key=int) uppercase_ids.sort() lowercase_ids.sort() return numeric_ids + uppercase_ids + lowercase_ids # Example usage #book_ids = [\\"123\\", \\"abc\\", \\"A12\\", \\"56\\", \\"bA3\\"] #sorted_ids = sort_book_ids(5, book_ids) #print(\\"n\\".join(sorted_ids)) # This would print the sorted IDs as per given custom rule."},{"question":"def minimum_removals_to_make_distinct(test_cases): Function to determine the number of removals required to make all elements in each array distinct. :param test_cases: List of dicts. Each dict contains a key 'n' (length of array) and 'a' (the array itself). :returns: List of integers, each representing the number of removals required for the corresponding test case. >>> minimum_removals_to_make_distinct([{'n': 5, 'a': [4, 7, 2, 3, 9]}]) [0] >>> minimum_removals_to_make_distinct([{'n': 6, 'a': [1, 3, 3, 7, 8, 7]}]) [2] >>> minimum_removals_to_make_distinct([{'n': 5, 'a': [5, 5, 5, 5, 5]}]) [4] >>> minimum_removals_to_make_distinct([{'n': 4, 'a': [1, 2, 3, 4]}]) [0] >>> minimum_removals_to_make_distinct([ ... {'n': 5, 'a': [4, 7, 2, 3, 9]}, ... {'n': 6, 'a': [1, 3, 3, 7, 8, 7]}, ... {'n': 5, 'a': [5, 5, 5, 5, 5]}, ... {'n': 4, 'a': [1, 2, 3, 4]} ...]) [0, 2, 4, 0] # Your code here","solution":"def minimum_removals_to_make_distinct(test_cases): Function to determine the number of removals required to make all elements in each array distinct. :param test_cases: List of dicts. Each dict contains a key 'n' (length of array) and 'a' (the array itself). :returns: List of integers, each representing the number of removals required for the corresponding test case. results = [] for case in test_cases: n, a = case['n'], case['a'] element_count = {} # Count occurrences of each element for num in a: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 # Calculate minimum number of removals removals = 0 for count in element_count.values(): if count > 1: removals += (count - 1) results.append(removals) return results"},{"question":"def autocomplete(words, prefix): Returns a sorted list of words that start with the given prefix. Parameters: words (list of str): The list of words available for autocompletion. prefix (str): The prefix to search for in the words list. Returns: list of str: List of words from the input list that start with the given prefix, sorted lexicographically. Examples: >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"], \\"ap\\") ['app', 'apple', 'apricot'] >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"], \\"ca\\") [] def test_autocomplete_with_valid_prefix(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"] prefix = \\"ap\\" assert autocomplete(words, prefix) == [\\"app\\", \\"apple\\", \\"apricot\\"] def test_autocomplete_no_matching_prefix(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"] prefix = \\"ca\\" assert autocomplete(words, prefix) == [] def test_autocomplete_with_empty_prefix(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"] prefix = \\"\\" assert autocomplete(words, prefix) == sorted(words) def test_autocomplete_with_exact_match(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"] prefix = \\"berry\\" assert autocomplete(words, prefix) == [\\"berry\\"] def test_autocomplete_with_no_words(): words = [] prefix = \\"ap\\" assert autocomplete(words, prefix) == [] def test_autocomplete_with_one_word_matching(): words = [\\"apple\\"] prefix = \\"app\\" assert autocomplete(words, prefix) == [\\"apple\\"] def test_autocomplete_with_case_insensitive_prefix(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\"] prefix = \\"Ap\\" assert autocomplete(words, prefix) == []","solution":"def autocomplete(words, prefix): Returns a sorted list of words that start with the given prefix. Parameters: words (list of str): The list of words available for autocompletion. prefix (str): The prefix to search for in the words list. Returns: list of str: List of words from the input list that start with the given prefix, sorted lexicographically. # Filter words that start with the given prefix result = [word for word in words if word.startswith(prefix)] # Sort the result list lexicographically result.sort() return result"},{"question":"from datetime import datetime from typing import List, Tuple def is_reservation_possible(existing_reservations: List[Tuple[str, str, str]], new_reservation: Tuple[str, str]) -> bool: Check if the new reservation can be accommodated without overlapping existing reservations. Args: existing_reservations (list of tuples): Each tuple contains two strings (check-in date, check-out date) and a guest name. new_reservation (tuple): Tuple containing two strings (check-in date, check-out date). Returns: bool: True if new reservation does not overlap with any existing reservations, otherwise False. >>> is_reservation_possible([ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), (\\"2023-05-10\\", \\"2023-05-20\\", \\"Bob\\") ], (\\"2023-05-05\\", \\"2023-05-10\\")) True >>> is_reservation_possible([ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), (\\"2023-05-10\\", \\"2023-05-20\\", \\"Bob\\") ], (\\"2023-05-04\\", \\"2023-05-11\\")) False pass def test_no_overlap(): existing_reservations = [ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), (\\"2023-05-10\\", \\"2023-05-20\\", \\"Bob\\") ] new_reservation = (\\"2023-05-05\\", \\"2023-05-10\\") assert is_reservation_possible(existing_reservations, new_reservation) == True def test_overlap(): existing_reservations = [ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), (\\"2023-05-10\\", \\"2023-05-20\\", \\"Bob\\") ] new_reservation = (\\"2023-05-04\\", \\"2023-05-11\\") assert is_reservation_possible(existing_reservations, new_reservation) == False def test_overlap_with_single_existing_reservation(): existing_reservations = [ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), ] new_reservation = (\\"2023-05-03\\", \\"2023-05-06\\") assert is_reservation_possible(existing_reservations, new_reservation) == False def test_no_overlap_with_single_existing_reservation(): existing_reservations = [ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), ] new_reservation = (\\"2023-05-06\\", \\"2023-05-10\\") assert is_reservation_possible(existing_reservations, new_reservation) == True def test_overlap_on_same_day(): existing_reservations = [ (\\"2023-05-01\\", \\"2023-05-05\\", \\"Alice\\"), ] new_reservation = (\\"2023-05-05\\", \\"2023-05-07\\") assert is_reservation_possible(existing_reservations, new_reservation) == True def test_no_existing_reservations(): existing_reservations = [] new_reservation = (\\"2023-05-01\\", \\"2023-05-05\\") assert is_reservation_possible(existing_reservations, new_reservation) == True","solution":"from datetime import datetime def is_reservation_possible(existing_reservations, new_reservation): Check if the new reservation can be accommodated without overlapping existing reservations. Args: existing_reservations (list of tuples): Each tuple contains two strings (check-in date, check-out date) and a guest name. new_reservation (tuple): Tuple containing two strings (check-in date, check-out date). Returns: bool: True if new reservation does not overlap with any existing reservations, otherwise False. new_check_in, new_check_out = new_reservation new_check_in = datetime.strptime(new_check_in, '%Y-%m-%d') new_check_out = datetime.strptime(new_check_out, '%Y-%m-%d') for reservation in existing_reservations: check_in, check_out, _ = reservation check_in = datetime.strptime(check_in, '%Y-%m-%d') check_out = datetime.strptime(check_out, '%Y-%m-%d') if new_check_in < check_out and new_check_out > check_in: return False return True"},{"question":"def most_popular_category(transaction_count: int, transactions: List[str]) -> str: Returns the most popular product category from given list of transactions. In case of a tie, the lexicographically smaller category is returned. Parameters: transaction_count (int): The number of transactions. transactions (List[str]): A list of strings, each representing a product category. Returns: str: The most popular product category for the given day. Examples: >>> most_popular_category(6, [\\"Dairy\\", \\"Vegetables\\", \\"Dairy\\", \\"Beverages\\", \\"Snacks\\", \\"Vegetables\\"]) 'Dairy' >>> most_popular_category(4, [\\"Meat\\", \\"Fruit\\", \\"Fruit\\", \\"Meat\\"]) 'Fruit' from solution import most_popular_category def test_most_popular_category_single(): assert most_popular_category(1, [\\"Dairy\\"]) == \\"Dairy\\" def test_most_popular_category_tie(): assert most_popular_category(6, [\\"Dairy\\", \\"Vegetables\\", \\"Dairy\\", \\"Beverages\\", \\"Snacks\\", \\"Vegetables\\"]) == \\"Dairy\\" assert most_popular_category(8, [\\"Dairy\\", \\"Vegetables\\", \\"Dairy\\", \\"Beverages\\", \\"Dairy\\", \\"Vegetables\\", \\"Vegetables\\", \\"Snacks\\"]) == \\"Dairy\\" def test_most_popular_category_unique(): assert most_popular_category(4, [\\"Beverages\\", \\"Snacks\\", \\"Meat\\", \\"Fruit\\"]) == \\"Beverages\\" def test_most_popular_category_tie_lexicographically(): assert most_popular_category(4, [\\"Meat\\", \\"Fruit\\", \\"Fruit\\", \\"Meat\\"]) == \\"Fruit\\" def test_most_popular_category_empty_transactions(): assert most_popular_category(0, []) == \\"\\"","solution":"def most_popular_category(transaction_count, transactions): Returns the most popular product category from given list of transactions. In case of a tie, the lexicographically smaller category is returned. # Dictionary to count the frequency of each category category_count = {} for category in transactions: if category in category_count: category_count[category] += 1 else: category_count[category] = 1 # Determine the category with the highest count max_count = 0 best_category = \\"\\" for category, count in category_count.items(): if count > max_count or (count == max_count and category < best_category): max_count = count best_category = category return best_category"},{"question":"def minimum_enclosures_needed(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the minimum number of enclosures needed to fit all the animals. Arguments: T -- Number of test cases test_cases -- A list of tuples where each tuple contains: - N: Number of enclosures - capacities: A list of integers representing the capacities of the enclosures - A: Total number of animals Returns: A list of integers where each integer represents the minimum number of enclosures needed for each test case. >>> minimum_enclosures_needed(2, [(3, [5, 1, 2], 6), (4, [10, 10, 10, 10], 35)]) [2, 4] pass from solution import minimum_enclosures_needed def test_minimum_enclosures_simple_case(): input_data = (1, [ (3, [5, 1, 2], 6) ]) expected_output = [2] assert minimum_enclosures_needed(*input_data) == expected_output def test_minimum_enclosures_all_needed(): input_data = (1, [ (4, [10, 10, 10, 10], 35) ]) expected_output = [4] assert minimum_enclosures_needed(*input_data) == expected_output def test_minimum_enclosures_single_unit_capacity(): input_data = (1, [ (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) ]) expected_output = [5] assert minimum_enclosures_needed(*input_data) == expected_output def test_minimum_enclosures_large_animal_count(): input_data = (1, [ (5, [1000, 1000, 1000, 1000, 1000], 4500) ]) expected_output = [5] assert minimum_enclosures_needed(*input_data) == expected_output def test_minimum_enclosures_large_enclosure(): input_data = (1, [ (5, [1000, 500, 500, 400, 300], 1200) ]) expected_output = [2] assert minimum_enclosures_needed(*input_data) == expected_output def test_multiple_cases(): input_data = (2, [ (3, [5, 1, 2], 6), (4, [10, 10, 10, 10], 35) ]) expected_output = [2, 4] assert minimum_enclosures_needed(*input_data) == expected_output","solution":"def minimum_enclosures_needed(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] capacities = test_cases[i][1] A = test_cases[i][2] capacities.sort(reverse=True) total_animals = 0 enclosures_used = 0 for capacity in capacities: total_animals += capacity enclosures_used += 1 if total_animals >= A: break results.append(enclosures_used) return results"},{"question":"def categorize_products(P: int, product_types: List[Tuple[str, List[str]]], N: int, product_codes: List[str]) -> List[str]: Categorizes products based on their product codes and given product types. :param P: Number of product types. :param product_types: List of tuples where each tuple contains a product type and a list of product codes belonging to that type. :param N: Number of product codes in the sequence. :param product_codes: List of product codes to be categorized. :return: List of product types corresponding to the given product codes. pass from typing import List, Tuple def test_sample_case(): P = 3 product_types = [ (\\"Electronics\\", [\\"12345\\", \\"67890\\", \\"54321\\", \\"98765\\"]), (\\"Groceries\\", [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\"]), (\\"Clothing\\", [\\"11111\\", \\"22222\\", \\"33333\\"]) ] N = 7 product_codes = [\\"12345\\", \\"abcde\\", \\"99999\\", \\"54321\\", \\"fghij\\", \\"22222\\", \\"99998\\"] expected_output = [\\"Electronics\\", \\"Groceries\\", \\"Unknown\\", \\"Electronics\\", \\"Groceries\\", \\"Clothing\\", \\"Unknown\\"] assert categorize_products(P, product_types, N, product_codes) == expected_output def test_all_known_codes(): P = 2 product_types = [ (\\"Type1\\", [\\"xxxx1\\", \\"xxxx2\\"]), (\\"Type2\\", [\\"yyyy1\\", \\"yyyy2\\"]) ] N = 4 product_codes = [\\"xxxx1\\", \\"xxxx2\\", \\"yyyy1\\", \\"yyyy2\\"] expected_output = [\\"Type1\\", \\"Type1\\", \\"Type2\\", \\"Type2\\"] assert categorize_products(P, product_types, N, product_codes) == expected_output def test_all_unknown_codes(): P = 1 product_types = [ (\\"Type1\\", [\\"aaaaa\\"]) ] N = 3 product_codes = [\\"bbbbb\\", \\"ccccc\\", \\"ddddd\\"] expected_output = [\\"Unknown\\", \\"Unknown\\", \\"Unknown\\"] assert categorize_products(P, product_types, N, product_codes) == expected_output def test_mixed_known_unknown_codes(): P = 2 product_types = [ (\\"Type1\\", [\\"11111\\", \\"22222\\"]), (\\"Type2\\", [\\"33333\\", \\"44444\\"]) ] N = 5 product_codes = [\\"11111\\", \\"33333\\", \\"55555\\", \\"22222\\", \\"66666\\"] expected_output = [\\"Type1\\", \\"Type2\\", \\"Unknown\\", \\"Type1\\", \\"Unknown\\"] assert categorize_products(P, product_types, N, product_codes) == expected_output def test_empty_product_types(): P = 0 product_types = [] N = 3 product_codes = [\\"12345\\", \\"67890\\", \\"99999\\"] expected_output = [\\"Unknown\\", \\"Unknown\\", \\"Unknown\\"] assert categorize_products(P, product_types, N, product_codes) == expected_output","solution":"def categorize_products(P, product_types, N, product_codes): Categorizes products based on their product codes and given product types. :param P: Number of product types. :param product_types: List of tuples where each tuple contains a product type and a list of product codes belonging to that type. :param N: Number of product codes in the sequence. :param product_codes: List of product codes to be categorized. :return: List of product types corresponding to the given product codes. # Create a dictionary to map product codes to their respective types code_to_type = {} for product_type, codes in product_types: for code in codes: code_to_type[code] = product_type result = [] for code in product_codes: result.append(code_to_type.get(code, \\"Unknown\\")) return result"},{"question":"class RideBooking: A RideBooking class to manage bookings for amusement park rides. Methods: bookRide(rideName: str, customerName: str, timestamp: int) -> None: Books a ride for a customer at a specified time. cancelBooking(customerName: str, timestamp: int) -> None: Cancels a customer's booking at a specified time. getRideQueue(rideName: str) -> List[str]: Retrieves the queue for a specific ride. Example usage: >>> rb = RideBooking() >>> rb.bookRide(\\"RollerCoaster\\", \\"Alice\\", 1) >>> rb.bookRide(\\"FerrisWheel\\", \\"Bob\\", 2) >>> rb.bookRide(\\"RollerCoaster\\", \\"Carol\\", 3) >>> rb.bookRide(\\"FerrisWheel\\", \\"Alice\\", 4) >>> rb.getRideQueue(\\"RollerCoaster\\") [\\"Alice\\", \\"Carol\\"] >>> rb.getRideQueue(\\"FerrisWheel\\") [\\"Bob\\", \\"Alice\\"] >>> rb.cancelBooking(\\"Alice\\", 4) >>> rb.getRideQueue(\\"FerrisWheel\\") [\\"Bob\\"] def __init__(self): pass def bookRide(self, rideName: str, customerName: str, timestamp: int) -> None: pass def cancelBooking(self, customerName: str, timestamp: int) -> None: pass def getRideQueue(self, rideName: str) -> List[str]: pass # Unit Test def test_bookRide_and_getRideQueue(): rb = RideBooking() rb.bookRide(\\"RollerCoaster\\", \\"Alice\\", 1) rb.bookRide(\\"FerrisWheel\\", \\"Bob\\", 2) rb.bookRide(\\"RollerCoaster\\", \\"Carol\\", 3) rb.bookRide(\\"FerrisWheel\\", \\"Alice\\", 4) assert rb.getRideQueue(\\"RollerCoaster\\") == [\\"Alice\\", \\"Carol\\"] assert rb.getRideQueue(\\"FerrisWheel\\") == [\\"Bob\\", \\"Alice\\"] def test_cancelBooking(): rb = RideBooking() rb.bookRide(\\"RollerCoaster\\", \\"Alice\\", 1) rb.bookRide(\\"FerrisWheel\\", \\"Bob\\", 2) rb.bookRide(\\"RollerCoaster\\", \\"Carol\\", 3) rb.bookRide(\\"FerrisWheel\\", \\"Alice\\", 4) rb.cancelBooking(\\"Alice\\", 4) assert rb.getRideQueue(\\"FerrisWheel\\") == [\\"Bob\\"] rb.cancelBooking(\\"Bob\\", 2) assert rb.getRideQueue(\\"FerrisWheel\\") == [] def test_edge_cases(): rb = RideBooking() rb.bookRide(\\"RollerCoaster\\", \\"Alice\\", 1) # Cancel a non-existing booking rb.cancelBooking(\\"Bob\\", 2) assert rb.getRideQueue(\\"RollerCoaster\\") == [\\"Alice\\"] # Cancel an already cancelled booking rb.cancelBooking(\\"Alice\\", 1) rb.cancelBooking(\\"Alice\\", 1) assert rb.getRideQueue(\\"RollerCoaster\\") == [] # Get queue for a ride with no bookings assert rb.getRideQueue(\\"FerrisWheel\\") == []","solution":"class RideBooking: def __init__(self): self.bookings = {} def bookRide(self, rideName, customerName, timestamp): if rideName not in self.bookings: self.bookings[rideName] = [] self.bookings[rideName].append((timestamp, customerName)) def cancelBooking(self, customerName, timestamp): for rideName in self.bookings: self.bookings[rideName] = [ (ts, cname) for ts, cname in self.bookings[rideName] if not (ts == timestamp and cname == customerName) ] def getRideQueue(self, rideName): if rideName not in self.bookings: return [] queue = sorted(self.bookings[rideName], key=lambda x: x[0]) return [cname for _, cname in queue]"},{"question":"from typing import List def can_sum_to_query(arr: List[int], queries: List[int]) -> List[str]: Determine if each query can be represented as the sum of two distinct elements of the array. Args: - arr (List[int]): List of integers. - queries (List[int]): List of query integers. Returns: - List[str]: List of strings \\"YES\\" or \\"NO\\" for each query. Example: >>> can_sum_to_query([10, 12, 4, 7, 5], [9, 17, 1]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_sum_to_query([1, 2, 3, 4], [3, 5, 7]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_sum_to_query([1, 2, 3, 4], [10, 11, 12]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> can_sum_to_query([-1, -2, 1, 2], [0, -3]) [\\"YES\\", \\"YES\\"] >>> can_sum_to_query([1], [2, 3]) [\\"NO\\", \\"NO\\"] def test_example(): assert can_sum_to_query([10, 12, 4, 7, 5], [9, 17, 1]) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_all_distinct_sum_exist(): assert can_sum_to_query([1, 2, 3, 4], [3, 5, 7]) == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_queries_not_possible(): assert can_sum_to_query([1, 2, 3, 4], [10, 11, 12]) == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_queries_with_negatives(): assert can_sum_to_query([-1, -2, 1, 2], [0, -3]) == [\\"YES\\", \\"YES\\"] def test_single_element(): assert can_sum_to_query([1], [2, 3]) == [\\"NO\\", \\"NO\\"] def test_large_input(): arr = list(range(1, 100001)) # Large array from 1 to 100000 queries = [199999, 150000, 300000] assert can_sum_to_query(arr, queries) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_sum_to_query(arr, queries): results = [] seen = set() for number in arr: seen.add(number) for query in queries: found = False for number in arr: complement = query - number if complement in seen and complement != number: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def find_critical_districts(n: int, m: int, bridges: List[Tuple[int, int]]) -> List[int]: Returns a list of all critical districts in the given city. >>> find_critical_districts(5, 5, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 5)]) [1, 3] >>> find_critical_districts(3, 2, [(1, 2), (1, 3)]) [1] >>> find_critical_districts(4, 0, []) []","solution":"def find_critical_districts(n, m, bridges): Returns a list of all critical districts in the given city. from collections import defaultdict def dfs(v, visited, low, disc, parent, graph, aps, time): children = 0 visited[v] = True disc[v] = time low[v] = time time += 1 for to in graph[v]: if not visited[to]: parent[to] = v children += 1 dfs(to, visited, low, disc, parent, graph, aps, time) low[v] = min(low[v], low[to]) if parent[v] == -1 and children > 1: aps.add(v) if parent[v] != -1 and low[to] >= disc[v]: aps.add(v) elif to != parent[v]: low[v] = min(low[v], disc[to]) visited = [False] * n disc = [float('inf')] * n low = [float('inf')] * n parent = [-1] * n aps = set() graph = defaultdict(list) for u, v in bridges: graph[u-1].append(v-1) graph[v-1].append(u-1) for i in range(n): if not visited[i]: dfs(i, visited, low, disc, parent, graph, aps, 0) return sorted(list(map(lambda x: x + 1, aps)))"},{"question":"def compress_string(s: str) -> str: Compresses the input string using a format where consecutive duplicates of characters are replaced with the character followed by the number of repetitions. If the \\"compressed\\" string is not shorter than the original string, return the original string. >>> compress_string(\\"aaabbcc\\") 'a3b2c2' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"aaaaaaa\\") 'a7' >>> compress_string(\\"aabbbccccdde\\") 'a2b3c4d2e' >>> compress_string(\\"aabbcc\\") 'aabbcc' >>> compress_string(\\"aabbccaa\\") 'aabbccaa' >>> compress_string(\\"a\\" * 500 + \\"b\\" * 500) 'a500b500' >>> compress_string(\\"\\") ''","solution":"def compress_string(s): Compresses the input string by replacing consecutive duplicates characters with the character followed by the number of repetitions. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count) if count > 1 else s[i - 1]) count = 1 compressed.append(s[-1] + str(count) if count > 1 else s[-1]) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def winner_of_game(scoring_history: List[str]) -> str: Determines the winner of a tennis game based on the history of scored points. :param scoring_history: List of strings representing the points scored by players \\"P1\\" and \\"P2\\" :return: String indicating the winner of the game, either \\"Player 1\\" or \\"Player 2\\" >>> winner_of_game(['P1', 'P1', 'P1', 'P1']) \\"Player 1\\" >>> winner_of_game(['P2', 'P2', 'P2', 'P2']) \\"Player 2\\" >>> winner_of_game(['P1', 'P2', 'P1', 'P2', 'P1', 'P2', 'P1', 'P1']) \\"Player 1\\" >>> winner_of_game(['P1', 'P2', 'P1', 'P2', 'P1', 'P2', 'P2', 'P2']) \\"Player 2\\" >>> winner_of_game(['P1', 'P1', 'P1', 'P2', 'P2', 'P2', 'P1', 'P2', 'P2', 'P2']) \\"Player 2\\" >>> winner_of_game(['P1', 'P2', 'P1', 'P2', 'P1', 'P2', 'P1', 'P1']) \\"Player 1\\"","solution":"def winner_of_game(scoring_history): Determines the winner of a tennis game based on the history of scored points. :param scoring_history: List of strings representing the points scored by players \\"P1\\" and \\"P2\\" :return: String indicating the winner of the game, either \\"Player 1\\" or \\"Player 2\\" scores = {\\"P1\\": 0, \\"P2\\": 0} for point in scoring_history: scores[point] += 1 if scores[\\"P1\\"] >= 4 or scores[\\"P2\\"] >= 4: if scores[\\"P1\\"] >= scores[\\"P2\\"] + 2: return \\"Player 1\\" elif scores[\\"P2\\"] >= scores[\\"P1\\"] + 2: return \\"Player 2\\""},{"question":"from typing import List, Tuple def count_paths(T: int, test_cases: List[Tuple[Tuple[int, int], List[str]]]) -> List[int]: Find the number of different paths the detective can take to reach the bottom-right corner from the top-left corner while avoiding the walls. Parameters: T (int): Number of test cases test_cases (List[Tuple[Tuple[int, int], List[str]]]): For each test case, a tuple containing grid dimensions (N, M) and the grid itself. Returns: List[int]: List of numbers representing the number of different paths for each test case. >>> count_paths(1, [((3, 3), [ ... \\".#.\\", ... \\".\\", ... \\"...\\" ... ])]) [1] >>> count_paths(1, [((3, 3), [ ... \\"#..\\", ... \\".\\", ... \\"...\\", ... ])]) [0] >>> count_paths(1, [((3, 3), [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ])]) [6] >>> count_paths(1, [((4, 4), [ ... \\"....\\", ... \\".#..\\", ... \\"...#\\", ... \\"....\\" ... ])]) [4] >>> count_paths(1, [((1, 1), [ ... \\".\\" ... ])]) [1]","solution":"from collections import deque def num_paths(grid, N, M): # Check if the start or end point is blocked if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 # Initialize the number of paths grid paths = [[0] * M for _ in range(N)] paths[0][0] = 1 # Starting position # Breadth-First Search to calculate the number of paths queue = deque([(0, 0)]) directions = [(1, 0), (0, 1)] # Only right and down movements while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.': if paths[nx][ny] == 0: paths[nx][ny] = paths[x][y] queue.append((nx, ny)) else: paths[nx][ny] += paths[x][y] return paths[N-1][M-1] def count_paths(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] grid = test_cases[i][1] results.append(num_paths(grid, N, M)) return results"},{"question":"def max_hourglass_sum(arr): Returns the maximum hourglass sum in the given 6x6 2D array. An hourglass sum is defined as the sum of array values that form an hourglass shape in the array. >>> arr = [ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ] >>> max_hourglass_sum(arr) 19 >>> arr = [ ... [-1, -1, 0, -9, -2, -2], ... [-2, -1, -6, -8, -2, -5], ... [-1, -1, -1, -2, -3, -4], ... [-1, -9, -2, -4, -4, -5], ... [-7, -3, -3, -2, -9, -9], ... [-1, -3, -1, -2, -4, -5] ... ] >>> max_hourglass_sum(arr) -6 >>> arr = [ ... [1, 1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1] ... ] >>> max_hourglass_sum(arr) 7","solution":"def max_hourglass_sum(arr): Returns the maximum hourglass sum in the given 6x6 2D array. An hourglass sum is defined as the sum of array values that form an hourglass shape in the array. max_sum = float('-inf') # Initialize to very small number # Loop through each possible hourglass in the 6x6 array for i in range(4): for j in range(4): # Calculate sum of the current hourglass current_sum = ( arr[i][j] + arr[i][j+1] + arr[i][j+2] + arr[i+1][j+1] + arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2] ) # Update max_sum if current_sum is greater if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def duplicate_count(s: str) -> int: Counts the number of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. Args: - s: A string containing only alphanumeric characters. Returns: - An integer representing the count of distinct case-insensitive characters and digits that occur more than once. >>> duplicate_count(\\"abcde\\") == 0 >>> duplicate_count(\\"aA11\\") == 2 >>> duplicate_count(\\"aabbcde\\") == 2 >>> duplicate_count(\\"abcdefghaB\\") == 2 >>> duplicate_count(\\"112233\\") == 3","solution":"def duplicate_count(s): Counts the number of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. Args: - s: A string containing only alphanumeric characters. Returns: - An integer representing the count of distinct case-insensitive characters and digits that occur more than once. s = s.lower() char_count = {} # Count each character's frequency for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count characters that appear more than once return sum(1 for count in char_count.values() if count > 1)"},{"question":"def expected_total_value(num_cases: int, cases: List[Tuple[int, List[int], List[float]]]) -> List[float]: Compute the expected total value of coins displayed in the box for each test case. >>> expected_total_value(2, [ ... (3, [10, 20, 30], [0.5, 0.5, 0.5]), ... (2, [5, 15], [1.0, 0.2]) ... ]) == [30.0, 8.0] >>> expected_total_value(1, [ ... (3, [0, 0, 0], [0.0, 0.0, 0.0]) ... ]) == [0.0] >>> expected_total_value(1, [ ... (3, [10, 20, 30], [1.0, 1.0, 1.0]) ... ]) == [60.0] >>> expected_total_value(1, [ ... (3, [10, 20, 30], [0.0, 0.0, 0.0]) ... ]) == [0.0] >>> expected_total_value(1, [ ... (4, [10, 20, 30, 40], [0.1, 0.5, 0.9, 0.7]) ... ]) == [0.1*10 + 0.5*20 + 0.9*30 + 0.7*40] >>> expected_total_value(1, [ ... (2, [1_000_000_000, 2_000_000_000], [0.5, 0.25]) ... ]) == [1_000_000_000*0.5 + 2_000_000_000*0.25]","solution":"def expected_total_value(num_cases, cases): results = [] for i in range(num_cases): N = cases[i][0] values = cases[i][1] probabilities = cases[i][2] total_expected_value = 0 for v, q in zip(values, probabilities): total_expected_value += v * q results.append(total_expected_value) return results # Example usage: # num_cases = 2 # test_cases = [ # (3, [10, 20, 30], [0.5, 0.5, 0.5]), # (2, [5, 15], [1.0, 0.2]) # ] # print(expected_total_value(num_cases, test_cases))"},{"question":"def get_highest_scores(entries): Returns a list of tuples representing the student names and their highest scores in the order of their first appearance. >>> get_highest_scores([ ... \\"alice 70\\", ... \\"bob 50\\", ... \\"alice 80\\", ... \\"bob 60\\", ... \\"claire 75\\", ... \\"alice 85\\", ... \\"bob 100\\", ... ]) [(\\"alice\\", 85), (\\"bob\\", 100), (\\"claire\\", 75)] >>> get_highest_scores([\\"john 45\\"]) [(\\"john\\", 45)] >>> get_highest_scores([\\"alice 50\\", \\"alice 50\\", \\"alice 50\\"]) [(\\"alice\\", 50)] >>> get_highest_scores([\\"charlie 70\\", \\"dave 70\\"]) [(\\"charlie\\", 70), (\\"dave\\", 70)] >>> get_highest_scores([\\"eric 100\\", \\"eric 90\\", \\"eric 80\\"]) [(\\"eric\\", 100)] >>> get_highest_scores([]) []","solution":"def get_highest_scores(entries): Returns a list of tuples representing the student names and their highest scores in the order of their first appearance. highest_scores = {} first_appearance = {} for i, entry in enumerate(entries): name, score = entry.split() score = int(score) if name not in highest_scores: highest_scores[name] = score first_appearance[name] = i else: if score > highest_scores[name]: highest_scores[name] = score sorted_names = sorted(first_appearance, key=first_appearance.get) result = [(name, highest_scores[name]) for name in sorted_names] return result"},{"question":"def rearrange_positive_negative(lst: List[int]) -> List[int]: Rearranges the list such that all negative numbers appear before all positive numbers, preserving their relative order. Args: lst (list): List of integers. Returns: list: A list with all negative numbers before positive numbers. Examples: >>> rearrange_positive_negative([1, -2, -3, 4, 5, -6]) [-2, -3, -6, 1, 4, 5] >>> rearrange_positive_negative([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange_positive_negative([-1, -2, -3, -4, -5]) [-1, -2, -3, -4, -5] >>> rearrange_positive_negative([0, -1, -2, 2, 3, -3]) [-1, -2, -3, 0, 2, 3] >>> rearrange_positive_negative([]) [] >>> rearrange_positive_negative([5]) [5] >>> rearrange_positive_negative([-5]) [-5]","solution":"def rearrange_positive_negative(lst): Rearranges the list such that all negative numbers appear before all positive numbers, preserving their relative order. Args: lst (list): List of integers. Returns: list: A list with all negative numbers before positive numbers. if not lst: return [] negative_numbers = [num for num in lst if num < 0] positive_numbers = [num for num in lst if num >= 0] return negative_numbers + positive_numbers"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(t1, t2): Merge two binary trees. >>> t1, t2 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)), TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) >>> result = merge_trees(t1, t2) >>> tree_to_list(result) # [3, 4, 5, 5, 4, 7] pass def tree_to_list(root): Flatten the binary tree to list for easy assertion in tests. This auxiliary function is provided for verifying the output. >>> tree_to_list(TreeNode(1, TreeNode(2), TreeNode(3))) # [1, 2, 3] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(t1, t2): if not t1 and not t2: return None if not t1: return t2 if not t2: return t1 merged = TreeNode(t1.val + t2.val) merged.left = merge_trees(t1.left, t2.left) merged.right = merge_trees(t1.right, t2.right) return merged def tree_to_list(root): Flatten the binary tree to list for easy assertion in tests if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"import json from typing import List def extract_values(data: str, keys_list: List[str]) -> List: Extracts values associated with the keys in keys_list from the JSON string data. :param data: A JSON formatted string. :param keys_list: A list of key strings to extract values for. :return: A list of values corresponding to the keys in keys_list. If a key does not exist, 'None' is returned for that key. >>> extract_values('{\\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\", \\"email\\": \\"john@example.com\\"}', [\\"name\\", \\"age\\", \\"country\\", \\"email\\"]) ['John', 30, None, 'john@example.com'] >>> extract_values('{\\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\"}', [\\"name\\", \\"age\\", \\"city\\"]) ['John', 30, 'New York']","solution":"import json def extract_values(data, keys_list): Extracts values associated with the keys in keys_list from the JSON string data. :param data: A JSON formatted string. :param keys_list: A list of key strings to extract values for. :return: A list of values corresponding to the keys in keys_list. If a key does not exist, 'None' is returned for that key. python_dict = json.loads(data) result = [] for key in keys_list: result.append(python_dict.get(key, None)) return result"},{"question":"from typing import List, Dict def get_best_cloud(clouds: List[Dict[str, object]]) -> str: Returns the id of the cloud with the highest product of height and HRI. If the input list is empty, it returns None. >>> clouds = [ ... {'height': 2000, 'HRI': 0.85, 'id': 'cloud1'}, ... {'height': 1500, 'HRI': 0.60, 'id': 'cloud2'}, ... {'height': 2500, 'HRI': 0.70, 'id': 'cloud3'}, ... {'height': 3000, 'HRI': 0.90, 'id': 'cloud4'} ... ] >>> get_best_cloud(clouds) 'cloud4' >>> clouds = [] >>> get_best_cloud(clouds) None >>> clouds = [{'height': 1500, 'HRI': 0.80, 'id': 'single_cloud'}] >>> get_best_cloud(clouds) 'single_cloud' >>> clouds = [ ... {'height': 2000, 'HRI': 0.85, 'id': 'cloud1'}, ... {'height': 3400, 'HRI': 0.50, 'id': 'cloud2'} ... ] >>> get_best_cloud(clouds) 'cloud1' >>> clouds = [ ... {'height': 0, 'HRI': 0.85, 'id': 'cloud1'}, ... {'height': 1500, 'HRI': 0.60, 'id': 'cloud2'}, ... {'height': 2500, 'HRI': 0.0, 'id': 'cloud3'}, ... {'height': 3000, 'HRI': 0.90, 'id': 'cloud4'} ... ] >>> get_best_cloud(clouds) 'cloud4'","solution":"from typing import List, Dict def get_best_cloud(clouds: List[Dict[str, object]]) -> str: Returns the id of the cloud with the highest product of height and HRI. If the input list is empty, it returns None. if not clouds: return None max_product = -1 best_cloud_id = None for cloud in clouds: product = cloud['height'] * cloud['HRI'] if product > max_product: max_product = product best_cloud_id = cloud['id'] return best_cloud_id"},{"question":"def total_prize_money(T: int, test_cases: List[Tuple[int, int, List[int], List[List[int]], int]]) -> List[int]: Calculate the total prize money won by the target participant in multiple contests. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[List[int]], int]]): A list of tuples, each containing: - P (int): The number of participants - C (int): The number of contests - participant_ids (List[int]): List of participant IDs - contests (List[List[int]]): A list of lists, where each list contains prize money won by the participants in a contest - target_id (int): The ID of the target participant Returns: List[int]: A list of total prize money won by the target participant for each test case. >>> total_prize_money(2, [ (3, 2, [1, 2, 3], [[10, 0, 0], [0, 15, 20]], 3), (4, 3, [5, 6, 7, 8], [[100, 200, 0, 0], [0, 300, 400, 0], [0, 0, 0, 500]], 6) ]) [20, 500] def parse_input(input_lines: List[str]) -> Tuple[int, List[Tuple[int, int, List[int], List[List[int]], int]]]: Parse the input lines into the required format for processing. Args: input_lines (List[str]): The input lines to be parsed Returns: Tuple[int, List[Tuple[int, int, List[int], List[List[int]], int]]]: Parsed input >>> parse_input([ \\"2\\", \\"3 2\\", \\"1 2 3\\", \\"10 0 0\\", \\"0 15 20\\", \\"3\\", \\"4 3\\", \\"5 6 7 8\\", \\"100 200 0 0\\", \\"0 300 400 0\\", \\"0 0 0 500\\", \\"6\\" ]) (2, [ (3, 2, [1, 2, 3], [[10, 0, 0], [0, 15, 20]], 3), (4, 3, [5, 6, 7, 8], [[100, 200, 0, 0], [0, 300, 400, 0], [0, 0, 0, 500]], 6) ]) from typing import List, Tuple def test_total_prize_money(): input_lines = [ \\"2\\", \\"3 2\\", \\"1 2 3\\", \\"10 0 0\\", \\"0 15 20\\", \\"3\\", \\"4 3\\", \\"5 6 7 8\\", \\"100 200 0 0\\", \\"0 300 400 0\\", \\"0 0 0 500\\", \\"6\\" ] T, test_cases = parse_input(input_lines) results = total_prize_money(T, test_cases) assert results == [20, 500] def test_no_prize(): input_lines = [ \\"1\\", \\"2 2\\", \\"1 2\\", \\"0 0\\", \\"0 0\\", \\"1\\" ] T, test_cases = parse_input(input_lines) results = total_prize_money(T, test_cases) assert results == [0] def test_single_contest_multiple_winnings(): input_lines = [ \\"1\\", \\"2 1\\", \\"1 2\\", \\"100 200\\", \\"2\\" ] T, test_cases = parse_input(input_lines) results = total_prize_money(T, test_cases) assert results == [200] def test_multiple_contests_mixed_winnings(): input_lines = [ \\"1\\", \\"3 3\\", \\"1 2 3\\", \\"100 0 0\\", \\"0 200 0\\", \\"0 0 300\\", \\"1\\" ] T, test_cases = parse_input(input_lines) results = total_prize_money(T, test_cases) assert results == [100] def test_large_number_of_participants(): input_lines = [ \\"1\\", \\"1000 1\\", \\" \\".join(map(str, range(1, 1001))), \\" \\".join(map(lambda x: str(x*10), range(1, 1001))), \\"500\\" ] T, test_cases = parse_input(input_lines) results = total_prize_money(T, test_cases) assert results == [5000]","solution":"def total_prize_money(T, test_cases): results = [] for case in test_cases: P, C, participant_ids, contests, target_id = case target_index = participant_ids.index(target_id) total_prize = 0 for contest in contests: total_prize += contest[target_index] results.append(total_prize) return results def parse_input(input_lines): input_iter = iter(input_lines) T = int(next(input_iter)) test_cases = [] for _ in range(T): P, C = map(int, next(input_iter).split()) participant_ids = list(map(int, next(input_iter).split())) contests = [list(map(int, next(input_iter).split())) for _ in range(C)] target_id = int(next(input_iter)) test_cases.append((P, C, participant_ids, contests, target_id)) return T, test_cases # Example usage: input_lines = [ \\"2\\", \\"3 2\\", \\"1 2 3\\", \\"10 0 0\\", \\"0 15 20\\", \\"3\\", \\"4 3\\", \\"5 6 7 8\\", \\"100 200 0 0\\", \\"0 300 400 0\\", \\"0 0 0 500\\", \\"6\\" ] T, test_cases = parse_input(input_lines) results = total_prize_money(T, test_cases) for result in results: print(result)"},{"question":"def intersect_sorted_arrays(array1, array2): Returns the intersection of two sorted arrays as a sorted list with unique elements. >>> intersect_sorted_arrays([1, 2, 4, 5, 6], [2, 3, 5, 7]) [2, 5] >>> intersect_sorted_arrays([1, 3, 4, 5, 6, 8, 9], [4, 5, 6, 7]) [4, 5, 6] >>> intersect_sorted_arrays([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) [] >>> intersect_sorted_arrays([1, 1, 1, 1], [1, 1, 1, 2]) [1] pass","solution":"def intersect_sorted_arrays(array1, array2): Returns the intersection of two sorted arrays as a sorted list with unique elements. i, j = 0, 0 intersection = [] while i < len(array1) and j < len(array2): if array1[i] == array2[j]: if not intersection or intersection[-1] != array1[i]: intersection.append(array1[i]) i += 1 j += 1 elif array1[i] < array2[j]: i += 1 else: j += 1 return intersection"},{"question":"def is_pangram(s): Checks if the given string is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Args: s (str): The input string. Returns: bool: True if the input string is a pangram, False otherwise. >>> is_pangram(\\"the quick brown fox jumps over the lazy dog\\") True >>> is_pangram(\\"hello world\\") False >>> is_pangram(\\"\\") False >>> is_pangram(12345) \\"Not valid\\" >>> is_pangram(None) \\"Not valid\\" >>> is_pangram([\\"the quick brown fox jumps over the lazy dog\\"]) \\"Not valid\\" >>> is_pangram(\\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\\") True >>> is_pangram(\\"ThE qUiCk BrOwN fOx JuMpS oVeR tHe LaZy DoG\\") True >>> is_pangram(\\"the quick brown fox, jumps over the lazy dog!\\") True >>> is_pangram(\\"the quick brown fo jumps over the lazy dog\\") False","solution":"def is_pangram(s): Checks if the given string is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Args: s (str): The input string. Returns: bool: True if the input string is a pangram, False otherwise. if not isinstance(s, str): return \\"Not valid\\" # Create a set of all lowercase alphabetic characters alphabet_set = set(\\"abcdefghijklmnopqrstuvwxyz\\") # Convert the string to lowercase and create a set of its alphabetic characters char_set = set([char for char in s.lower() if char.isalpha()]) # Check if the set of alphabetic characters in the string is equal to the alphabet set return alphabet_set == char_set"},{"question":"from typing import List def max_water_flow(R: int, C: int, grid: List[List[int]]) -> int: Compute the maximum number of cells a water drop can pass through in a given RxC grid of heights. >>> max_water_flow(3, 3, [[9, 6, 3], [5, 4, 7], [2, 1, 8]]) 4 >>> max_water_flow(1, 1, [[0]]) 1 pass def test_example_case(): R = 3 C = 3 grid = [ [9, 6, 3], [5, 4, 7], [2, 1, 8] ] assert max_water_flow(R, C, grid) == 4 def test_simple_case(): R = 1 C = 1 grid = [[0]] assert max_water_flow(R, C, grid) == 1 def test_flat_grid(): R = 2 C = 2 grid = [ [1, 1], [1, 1] ] assert max_water_flow(R, C, grid) == 1 def test_single_column(): R = 4 C = 1 grid = [ [4], [3], [2], [1] ] assert max_water_flow(R, C, grid) == 4 def test_single_row(): R = 1 C = 4 grid = [ [4, 3, 2, 1] ] assert max_water_flow(R, C, grid) == 4 def test_large_case(): R = 2 C = 2 grid = [ [1000, 1], [1000, 1000] ] assert max_water_flow(R, C, grid) == 2","solution":"def max_water_flow(R, C, grid): def dfs(row, col): if dp[row][col] != -1: return dp[row][col] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_cells = 1 # Start with the current cell for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < R and 0 <= new_col < C and grid[new_row][new_col] < grid[row][col]: max_cells = max(max_cells, 1 + dfs(new_row, new_col)) dp[row][col] = max_cells return dp[row][col] dp = [[-1] * C for _ in range(R)] answer = 0 for row in range(R): for col in range(C): answer = max(answer, dfs(row, col)) return answer def main(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): grid.append(list(map(int, data[index:index + C]))) index += C print(max_water_flow(R, C, grid)) if __name__ == \\"__main__\\": main()"},{"question":"class Library: A Library system that manages a collection of books and processes borrowing requests. Methods: add_book(title: str) -> None remove_book(title: str) -> None is_book_available(title: str) -> bool borrow_book(title: str) -> bool return_book(title: str) -> None def add_book(self, title: str) -> None: Adds the book with the given title to the library collection. def remove_book(self, title: str) -> None: Removes the book with the given title from the library collection. def is_book_available(self, title: str) -> bool: Returns True if the book with the given title is available for borrowing, otherwise returns False. def borrow_book(self, title: str) -> bool: If the book with the given title is available, marks it as borrowed and returns True. Otherwise, returns False. def return_book(self, title: str) -> None: Marks the book with the given title as returned. # Unit tests from library import Library def test_add_book(): library = Library() library.add_book(\\"The Great Gatsby\\") assert library.is_book_available(\\"The Great Gatsby\\") == True def test_remove_book(): library = Library() library.add_book(\\"The Great Gatsby\\") library.remove_book(\\"The Great Gatsby\\") assert library.is_book_available(\\"The Great Gatsby\\") == False def test_is_book_available(): library = Library() library.add_book(\\"1984\\") assert library.is_book_available(\\"1984\\") == True library.borrow_book(\\"1984\\") assert library.is_book_available(\\"1984\\") == False library.return_book(\\"1984\\") assert library.is_book_available(\\"1984\\") == True def test_borrow_book(): library = Library() library.add_book(\\"To Kill a Mockingbird\\") assert library.borrow_book(\\"To Kill a Mockingbird\\") == True assert library.is_book_available(\\"To Kill a Mockingbird\\") == False assert library.borrow_book(\\"To Kill a Mockingbird\\") == False def test_return_book(): library = Library() library.add_book(\\"The Great Gatsby\\") library.borrow_book(\\"The Great Gatsby\\") assert library.is_book_available(\\"The Great Gatsby\\") == False library.return_book(\\"The Great Gatsby\\") assert library.is_book_available(\\"The Great Gatsby\\") == True","solution":"class Library: def __init__(self): self.collection = {} def add_book(self, title: str) -> None: if title not in self.collection: self.collection[title] = True def remove_book(self, title: str) -> None: if title in self.collection: del self.collection[title] def is_book_available(self, title: str) -> bool: return self.collection.get(title, False) def borrow_book(self, title: str) -> bool: if self.is_book_available(title): self.collection[title] = False return True return False def return_book(self, title: str) -> None: if title in self.collection and not self.is_book_available(title): self.collection[title] = True"},{"question":"def reverse_words(sentence: str) -> str: Returns a new string where the order of words in the input sentence is reversed. Words are considered sequences of characters separated by spaces. >>> reverse_words(\\"Hello World\\") \\"World Hello\\" >>> reverse_words(\\"Coding is fun\\") \\"fun is Coding\\" >>> reverse_words(\\" Leading and trailing spaces \\") \\"spaces trailing and Leading\\" >>> reverse_words(\\"Multiple spaces between words\\") \\"words between spaces Multiple\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" \\") \\"\\" >>> reverse_words(\\"Hello\\") \\"Hello\\"","solution":"def reverse_words(sentence): Returns a new string where the order of words in the input sentence is reversed. Words are considered sequences of characters separated by spaces. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def transformEquation(equation: str) -> str: Transforms the given equation string by increasing each number by 1. :param equation: A string containing a mathematical equation :return: A string with all numbers increased by 1. If any non-numeric input is found, returns 'undefined' >>> transformEquation('3 + 5 = 8') # returns '4 + 6 = 9' >>> transformEquation('10 + 15 = 25') # returns '11 + 16 = 26' >>> transformEquation('4*3 - 2 = 10') # returns '5*4 - 3 = 11' >>> transformEquation('7 * (2 + 3) = 35') # returns '8 * (3 + 4) = 36'","solution":"import re def transformEquation(equation): Transforms the given equation string by increasing each number by 1. :param equation: A string containing a mathematical equation :return: A string with all numbers increased by 1. If any non-numeric input is found, returns 'undefined' # Check for non-numeric and non-operator characters if not re.match(r'^[0-9+-*/()=s]*', equation): return 'undefined' def increase_by_one(match): return str(int(match.group()) + 1) transformed_equation = re.sub(r'd+', increase_by_one, equation) return transformed_equation"},{"question":"def custom_sort(arr): Sorts an array of integers in ascending order using a sorting algorithm implemented from scratch. You should not use any built-in sorting functions for this task. # Your implementation here # Example usage: # print(custom_sort([3, 1, 4, 1, 5, 9])) # should return [1, 1, 3, 4, 5, 9] def test_custom_sort_with_positive_numbers(): assert custom_sort([3, 1, 4, 1, 5, 9]) == [1, 1, 3, 4, 5, 9] def test_custom_sort_with_zero_and_negative_numbers(): assert custom_sort([0, -1, -3, 2, 1, -5]) == [-5, -3, -1, 0, 1, 2] def test_custom_sort_with_empty_list(): assert custom_sort([]) == [] def test_custom_sort_with_already_sorted_list(): assert custom_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_custom_sort_with_reversed_list(): assert custom_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_custom_sort_with_single_element_list(): assert custom_sort([1]) == [1]","solution":"def custom_sort(arr): Sorts an array of integers in ascending order using the bubble sort algorithm. Bubble sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def summarize_work_hours(hours: List[int]) -> dict: Summarizes the hours worked in a week. Args: hours (list of int): List of 7 integers representing the hours worked each day of the week. Returns: dict: Dictionary containing total hours, average hours per day, and the day with maximum hours worked. >>> summarize_work_hours([8, 6, 7, 5, 8, 6, 7]) {'total_hours': 47, 'average_hours': 6.71, 'max_hours_day': 'Monday'} >>> summarize_work_hours([9, 8, 7, 6, 5, 4, 3]) {'total_hours': 42, 'average_hours': 6.0, 'max_hours_day': 'Monday'}","solution":"def summarize_work_hours(hours): Summarizes the hours worked in a week. Args: hours (list of int): List of 7 integers representing the hours worked each day of the week. Returns: dict: Dictionary containing total hours, average hours per day, and the day with maximum hours worked. if len(hours) != 7: raise ValueError(\\"Input list must have exactly 7 elements.\\") days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] total_hours = sum(hours) average_hours = round(total_hours / 7, 2) max_hours_index = hours.index(max(hours)) return { 'total_hours': total_hours, 'average_hours': average_hours, 'max_hours_day': days_of_week[max_hours_index] }"},{"question":"from typing import List def findDisappearedNumbers(nums: List[int]) -> List[int]: Given an array nums with values in the range [1, n], returns all the integers in the range [1, n] that do not appear in nums. >>> findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]) [5, 6] >>> findDisappearedNumbers([1, 1]) [2] >>> findDisappearedNumbers([1, 2, 2, 3, 4, 5]) [6] >>> findDisappearedNumbers([2, 2, 2, 3, 4, 4, 5, 6, 6, 6]) [1, 7, 8, 9, 10] # Your code here def test_example_1(): assert findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]) == [5, 6] def test_example_2(): assert findDisappearedNumbers([1, 1]) == [2] def test_example_3(): assert findDisappearedNumbers([1, 2, 2, 3, 4, 5]) == [6] def test_example_4(): assert findDisappearedNumbers([2, 2, 2, 3, 4, 4, 5, 6, 6, 6]) == [1, 7, 8, 9, 10] def test_single_element(): assert findDisappearedNumbers([1]) == [] def test_no_missing_numbers(): assert findDisappearedNumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [] def test_all_missing(): assert findDisappearedNumbers([2] * 5) == [1, 3, 4, 5]","solution":"def findDisappearedNumbers(nums): Given an array nums with values in the range [1, n], returns all the integers in the range [1, n] that do not appear in nums. for num in nums: index = abs(num) - 1 if nums[index] > 0: nums[index] = -nums[index] missing_numbers = [i + 1 for i, num in enumerate(nums) if num > 0] return missing_numbers"},{"question":"def longest_non_decreasing_subsequence(L: List[int]) -> List[int]: Function to find the longest subsequence such that the numbers in the subsequence are in non-decreasing order. Parameters: L (list): List of integers to find the subsequence in. Returns: list: Longest non-decreasing subsequence. Examples: >>> longest_non_decreasing_subsequence([5, 3, 4, 8, 6, 7]) in [[3, 4, 6, 7], [3, 4, 8], [5, 6, 7]] True >>> longest_non_decreasing_subsequence([9, 8, 7, 6, 5]) in [[9], [8], [7], [6], [5]] True >>> longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) in [[5], [4], [3], [2], [1]] True >>> longest_non_decreasing_subsequence([1, 3, 3, 4, 5, 3, 6]) [1, 3, 3, 4, 5, 6] >>> longest_non_decreasing_subsequence([2, 2, 2, 2, 2]) [2, 2, 2, 2, 2] >>> longest_non_decreasing_subsequence([10]) [10] pass","solution":"def longest_non_decreasing_subsequence(L): Function to find the longest subsequence such that the numbers in the subsequence are in non-decreasing order. Parameters: L (list): List of integers to find the subsequence in. Returns: list: Longest non-decreasing subsequence. if not L: return [] n = len(L) dp = [1] * n prev_index = [-1] * n for i in range(1, n): for j in range(i): if L[i] >= L[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev_index[i] = j # Find the index of the maximum value in dp max_length = max(dp) index = dp.index(max_length) # Traverse backwards from the max index to get the subsequence result = [] while index != -1: result.append(L[index]) index = prev_index[index] return result[::-1]"},{"question":"def numberSquare(num: int) -> List[List[int]]: Create a function \`numberSquare(num)\` that returns a 2D list representing a square matrix of size \`num x num\`. The cells of the matrix should be filled with numbers from 1 to \`num^2\` in a spiral order starting from the upper left corner and moving inwards in a clockwise direction. >>> numberSquare(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> numberSquare(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> numberSquare(1) [[1]] >>> numberSquare(0) [] >>> numberSquare(2) [[1, 2], [4, 3]] >>> numberSquare(-1) []","solution":"def numberSquare(num): Returns a 2D list representing a spiral ordered square matrix of size num x num. if num <= 0: return [] matrix = [[0] * num for _ in range(num)] left, right, top, bottom = 0, num - 1, 0, num - 1 current = 1 while left <= right and top <= bottom: for col in range(left, right + 1): matrix[top][col] = current current += 1 top += 1 for row in range(top, bottom + 1): matrix[row][right] = current current += 1 right -= 1 for col in range(right, left - 1, -1): matrix[bottom][col] = current current += 1 bottom -= 1 for row in range(bottom, top - 1, -1): matrix[row][left] = current current += 1 left += 1 return matrix"},{"question":"from collections import deque def find_shortest_path(graph: dict, start: str, end: str) -> list: Determines the shortest path between two nodes in an unweighted graph using BFS. Parameters: graph (dict): A dictionary representing the graph. start (str): The start node. end (str): The end node. Returns: list: The shortest path from start to end node as a list of nodes. If no path exists, return an empty list. >>> graph = { ... 'A': ['B', 'C'], ... 'B': ['A', 'D', 'E'], ... 'C': ['A', 'F'], ... 'D': ['B'], ... 'E': ['B', 'F'], ... 'F': ['C', 'E'] ... } >>> find_shortest_path(graph, 'A', 'F') # Output: ['A', 'C', 'F'] or ['A', 'B', 'E', 'F'] >>> find_shortest_path(graph, 'A', 'D') # Output: ['A', 'B', 'D'] # Your code here pass def test_shortest_path_existing(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert find_shortest_path(graph, 'A', 'F') in [['A', 'C', 'F'], ['A', 'B', 'E', 'F']] def test_shortest_path_from_start_to_end(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert find_shortest_path(graph, 'A', 'D') == ['A', 'B', 'D'] def test_single_node_path(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert find_shortest_path(graph, 'A', 'A') == ['A'] def test_two_node_path(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert find_shortest_path(graph, 'A', 'B') == ['A', 'B'] def test_no_path_exists(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A'], 'D': ['B'], 'E': ['B'], 'F': [] } assert find_shortest_path(graph, 'A', 'F') == [] def test_longer_path_in_complex_graph(): graph = { 'A': ['B', 'C', 'D'], 'B': ['A', 'E'], 'C': ['A', 'F'], 'D': ['A'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert find_shortest_path(graph, 'A', 'F') in [['A', 'C', 'F'], ['A', 'B', 'E', 'F']]","solution":"from collections import deque def find_shortest_path(graph, start, end): Determines the shortest path between two nodes in an unweighted graph using BFS. Parameters: graph (dict): A dictionary representing the graph. start (str): The start node. end (str): The end node. Returns: list: The shortest path from start to end node as a list of nodes. If no path exists, return an empty list. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return []"},{"question":"class Sudoku: def __init__(self, puzzle): Initialize the Sudoku puzzle. Args: puzzle (list of list of int): A 9x9 grid representing the Sudoku puzzle. self.puzzle = puzzle def solve(self): Solve the Sudoku puzzle using backtracking. Returns: bool: True if the puzzle is solved, else False. pass def test_sudoku_solve(): puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solution = Sudoku(puzzle) solution.solve() expected_solution = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] assert solution.puzzle == expected_solution def test_sudoku_already_solved(): puzzle = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] solution = Sudoku(puzzle) solution.solve() expected_solution = puzzle assert solution.puzzle == expected_solution def test_sudoku_single_missing(): puzzle = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] solution = Sudoku(puzzle) solution.solve() expected_solution = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] assert solution.puzzle == expected_solution","solution":"class Sudoku: def __init__(self, puzzle): self.puzzle = puzzle def is_valid(self, num, row, col): for i in range(9): if self.puzzle[row][i] == num or self.puzzle[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if self.puzzle[start_row + i][start_col + j] == num: return False return True def solve(self): for row in range(9): for col in range(9): if self.puzzle[row][col] == 0: for num in range(1, 10): if self.is_valid(num, row, col): self.puzzle[row][col] = num if self.solve(): return True self.puzzle[row][col] = 0 return False return True"},{"question":"def highest_paid_employees(employees): Returns the name(s) of the highest paid employee(s). If multiple employees have the highest salary, the names are listed in alphabetical order. >>> highest_paid_employees([(\\"Alice\\", 50000), (\\"Bob\\", 70000), (\\"Charlie\\", 70000), (\\"David\\", 40000)]) [\\"Bob\\", \\"Charlie\\"] >>> highest_paid_employees([(\\"Emma\\", 55000), (\\"Daniel\\", 57000), (\\"Julia\\", 57000), (\\"Sophia\\", 57000)]) [\\"Daniel\\", \\"Julia\\", \\"Sophia\\"] >>> highest_paid_employees([(\\"Jake\\", 45000)]) [\\"Jake\\"]","solution":"def highest_paid_employees(employees): Returns the name(s) of the highest paid employee(s). If multiple employees have the highest salary, the names are listed in alphabetical order. if not employees: return [] highest_salary = max(employees, key=lambda x: x[1])[1] highest_paid = [employee[0] for employee in employees if employee[1] == highest_salary] return sorted(highest_paid)"},{"question":"def sum_nested_list(nested_string: str) -> int: Returns the sum of all integers in the nested list represented as a string. Examples: >>> sum_nested_list(\\"[1, 2, [3, 4], 5]\\") 15 >>> sum_nested_list(\\"[1, [-2, 3], [-4, [5, -6]], 7]\\") 4 >>> sum_nested_list(\\"[]\\") 0 >>> sum_nested_list(\\"[[-1, 1], [2, -2], [3, -3]]\\") 0 >>> sum_nested_list(\\"[1, [2, [3, [4, -5]]]]\\") 5 pass def test_sum_nested_list_simple(): assert sum_nested_list(\\"[1, 2, [3, 4], 5]\\") == 15 def test_sum_nested_list_nested(): assert sum_nested_list(\\"[1, [-2, 3], [-4, [5, -6]], 7]\\") == 4 def test_sum_nested_list_empty(): assert sum_nested_list(\\"[]\\") == 0 def test_sum_nested_list_zero_sum(): assert sum_nested_list(\\"[[-1, 1], [2, -2], [3, -3]]\\") == 0 def test_sum_nested_list_deep_nesting(): assert sum_nested_list(\\"[1, [2, [3, [4, -5]]]]\\") == 5 def test_sum_nested_list_single_element(): assert sum_nested_list(\\"[1]\\") == 1 def test_sum_nested_list_only_negatives(): assert sum_nested_list(\\"[-1, [-2, [-3, -4]]]\\") == -10 def test_sum_nested_list_single_negative_element(): assert sum_nested_list(\\"[-1]\\") == -1 def test_sum_nested_list_mixed_elements(): assert sum_nested_list(\\"[10, [20, [-30, 40]]]\\") == 40","solution":"def sum_nested_list(nested_string): Returns the sum of all integers in the nested list represented as a string. def parse_nested_list(s, index): total = 0 num = 0 sign = 1 while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) elif char == '-': sign = -1 elif char == ',': total += sign * num num = 0 sign = 1 elif char == '[': part_sum, index = parse_nested_list(s, index + 1) total += part_sum elif char == ']': total += sign * num return total, index index += 1 return total, index nested_string = nested_string.strip() if nested_string == \\"[]\\": return 0 total_sum, _ = parse_nested_list(nested_string, 0) return total_sum"},{"question":"from typing import List def word_in_grid(grid: List[List[str]], word: str) -> bool: Check if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once. >>> word_in_grid([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCCED\\") True >>> word_in_grid([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"SEE\\") True >>> word_in_grid([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCB\\") False pass import pytest def test_word_in_grid(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_in_grid(grid, \\"ABCCED\\") == True assert word_in_grid(grid, \\"SEE\\") == True assert word_in_grid(grid, \\"ABCB\\") == False grid = [ ['A', 'X', 'B', 'E'], ['S', 'B', 'C', 'S'], ['A', 'D', 'G', 'E'] ] assert word_in_grid(grid, \\"ABG\\") == True grid = [ ['A', 'X', 'C', 'E'], ['S', 'A', 'C', 'S'], ['A', 'D', 'C', 'E'] ] assert word_in_grid(grid, \\"ACC\\") == True assert word_in_grid(grid, \\"BANANA\\") == False grid = [ ['A'] ] assert word_in_grid(grid, \\"A\\") == True assert word_in_grid(grid, \\"B\\") == False if __name__ == \\"__main__\\": pytest.main()","solution":"from typing import List def word_in_grid(grid: List[List[str]], word: str) -> bool: def dfs(x, y, word): if len(word) == 0: return True if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != word[0]: return False temp = grid[x][y] grid[x][y] = \\"#\\" # Mark the cell as visited # Explore all 8 possible directions found = (dfs(x+1, y, word[1:]) or dfs(x-1, y, word[1:]) or dfs(x, y+1, word[1:]) or dfs(x, y-1, word[1:]) or dfs(x+1, y+1, word[1:]) or dfs(x+1, y-1, word[1:]) or dfs(x-1, y+1, word[1:]) or dfs(x-1, y-1, word[1:])) grid[x][y] = temp # Unmark the cell return found for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, word): return True return False"},{"question":"from datetime import datetime from typing import List, Tuple def count_late_returns(test_cases: List[Tuple[int, List[Tuple[str, str, str]]]]) -> List[int]: Determine how many books are returned after their due dates for each test case. Args: test_cases: A list of tuples, where each tuple represents a test case. The first element of each tuple is an integer N, the number of books. The second element is a list of N tuples, each containing three strings: the borrowed date, the due date, and the return date. Returns: A list of integers, where each integer represents the number of books returned late for the corresponding test case. >>> count_late_returns([(3, [('2023-01-01', '2023-01-05', '2023-01-04'), ('2023-01-01', '2023-01-10', '2023-01-12'), ('2023-01-01', '2023-01-20', '2023-01-20')]), (2, [('2023-02-01', '2023-02-05', '2023-02-06'), ('2023-02-10', '2023-02-15', '2023-02-14')])]) [1, 1] >>> count_llate_returns([(2, [('2023-01-01', '2023-01-05', '2023-01-03'), ('2023-01-01', '2023-01-10', '2023-01-10')])]) [0] >>> count_late_returns([(2, [('2023-01-01', '2023-01-05', '2023-01-06'), ('2023-01-01', '2023-01-10', '2023-01-11')])]) [2] >>> count_late_returns([(1, [('2023-01-01', '2023-01-05', '2023-01-06')])]) [1]","solution":"from datetime import datetime def count_late_returns(test_cases): late_returns = [] for case in test_cases: N = case[0] transactions = case[1] late_count = 0 for transaction in transactions: borrow_date, due_date, return_date = transaction due_date = datetime.strptime(due_date, '%Y-%m-%d') return_date = datetime.strptime(return_date, '%Y-%m-%d') if return_date > due_date: late_count += 1 late_returns.append(late_count) return late_returns"},{"question":"def manage_bank_accounts(n: int, m: int, balances: List[int], operations: List[str]) -> List[int]: Performs deposit and query operations on bank accounts. Parameters: n (int): Number of accounts. m (int): Number of operations. balances (list of int): Initial balances of accounts. operations (list of str): List of operations to perform. Returns: list of int: Balances of specified accounts based on query operations. Example: >>> manage_bank_accounts(5, 4, [100, 200, 300, 400, 500], [\\"D 1 3 50\\", \\"Q 2\\", \\"D 2 5 20\\", \\"Q 4\\"]) [250, 420] pass","solution":"def manage_bank_accounts(n, m, balances, operations): Performs deposit and query operations on bank accounts. Parameters: n (int): Number of accounts. m (int): Number of operations. balances (list of int): Initial balances of accounts. operations (list of str): List of operations to perform. Returns: list of int: Balances of specified accounts based on query operations. results = [] for operation in operations: op = operation.split() if op[0] == 'D': u = int(op[1]) - 1 v = int(op[2]) - 1 k = int(op[3]) for i in range(u, v + 1): balances[i] += k elif op[0] == 'Q': p = int(op[1]) - 1 results.append(balances[p]) return results"},{"question":"def max_path_sum(grid: List[List[int]], N: int) -> int: Calculate the maximum path sum from the top-left corner to the bottom-right corner of a 2D grid. Args: grid (List[List[int]]): The 2D grid filled with integers. N (int): The size of the grid. Returns: int: The maximum sum of values from the top-left to the bottom-right corner. >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) 29 >>> max_path_sum([[-1, -2], [3, 4]], 2) 6 pass def process_test_cases(test_cases: List[Dict[str, Union[int, List[List[int]]]]]) -> List[int]: Process multiple test cases to find the maximum path sums for each grid. Args: test_cases (List[Dict[str, Union[int, List[List[int]]]]]): A list of test cases where each test case contains the size of the grid and the grid itself. Returns: List[int]: The list of maximum path sums for each test case. >>> process_test_cases([{'N': 3, 'grid': [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, {'N': 2, 'grid': [[-1, -2], [3, 4]]}]) [29, 6] pass from typing import List, Dict, Union def test_max_path_sum(): test_cases = [ { 'N': 3, 'grid': [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ], 'expected': 29 }, { 'N': 2, 'grid': [ [-1, -2], [3, 4], ], 'expected': 6 }, { 'N': 2, 'grid': [ [-1, -2], [-3, 4], ], 'expected': 1 }, { 'N': 4, 'grid': [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16], ], 'expected': 73 } ] for case in test_cases: N, grid, expected = case['N'], case['grid'], case['expected'] assert max_path_sum(grid, N) == expected def test_process_test_cases(): test_cases = [ { 'N': 3, 'grid': [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] }, { 'N': 2, 'grid': [ [-1, -2], [3, 4], ] } ] expected_output = [29, 6] assert process_test_cases(test_cases) == expected_output","solution":"def max_path_sum(grid, N): Function to calculate the maximum path sum from top-left to bottom-right of a 2D grid. # Create a memoization table to store results of subproblems dp = [[0] * N for _ in range(N)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][N-1] def process_test_cases(test_cases): results = [] for case in test_cases: N, grid = case['N'], case['grid'] result = max_path_sum(grid, N) results.append(result) return results"},{"question":"def arrange_numbers(numbers: List[int], n: int) -> Optional[List[int]]: Arrange the first \`n\` largest numbers in descending order and the rest in ascending order. >>> arrange_numbers([10, 5, 2, 7, -3, 8], 3) [10, 8, 7, -3, 2, 5] >>> arrange_numbers([10, 5, 2, 7, -3, 8], 2) [10, 8, -3, 2, 5, 7] >>> arrange_numbers([10, 5, 2, 7, -3, 8], 4) [10, 8, 7, 5, -3, 2] >>> arrange_numbers([10, 5, 2, 7, -3, 8], 7) None >>> arrange_numbers([-1, -2, -3, -4], 2) [-1, -2, -4, -3] >>> arrange_numbers([1], 1) [1] >>> arrange_numbers([1, 2, 3, 4, 5], 5) [5, 4, 3, 2, 1] >>> arrange_numbers([1, 2, 3, 2, 1], 3) [3, 2, 2, 1, 1] >>> arrange_numbers([], 1) None >>> arrange_numbers([1, 2, 3], 4) None","solution":"def arrange_numbers(numbers, n): if len(numbers) < n: return None sorted_numbers = sorted(numbers, reverse=True) largest_n = sorted_numbers[:n] rest = numbers[:] for ln in largest_n: rest.remove(ln) rest.sort() result = largest_n + rest return result"},{"question":"from typing import List def ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: Find the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the word list. Return 0 if there is no such transformation sequence. >>> ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0 from solution import ladder_length def test_ladder_length_example1(): assert ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) == 5 def test_ladder_length_example2(): assert ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 0 def test_ladder_length_no_transformation_needed(): assert ladder_length(\\"hit\\", \\"hit\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) == 0 def test_ladder_length_single_letter_words(): assert ladder_length(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) == 2 def test_ladder_length_no_possible_path(): assert ladder_length(\\"abc\\", \\"xyz\\", [\\"abc\\", \\"abd\\", \\"abe\\", \\"xyz\\"]) == 0 def test_ladder_length_large_example(): wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] + [f\\"word{i}\\" for i in range(10000)] assert ladder_length(\\"hit\\", \\"cog\\", wordList) == 5","solution":"from collections import deque from typing import List def ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: word_set = set(wordList) if endWord not in word_set: return 0 queue = deque([(beginWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"def count_distinct_subgrids(n: int, m: int, k: int, grid: List[str]) -> int: Returns the number of distinct k x k sub-grids from the given n x m grid. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid k (int): Dimension of the sub-grid (k x k) grid (list): List of strings where each string represents a row of the larger grid Returns: int: Number of distinct k x k sub-grids >>> count_distinct_subgrids(3, 3, 2, [\\"abc\\", \\"def\\", \\"ghi\\"]) 4 >>> count_distinct_subgrids(3, 3, 2, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1","solution":"def count_distinct_subgrids(n, m, k, grid): Returns the number of distinct k x k sub-grids from the given n x m grid. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid k (int): Dimension of the sub-grid (k x k) grid (list): List of strings where each string represents a row of the larger grid Returns: int: Number of distinct k x k sub-grids subgrids = set() for i in range(n - k + 1): for j in range(m - k + 1): subgrid = tuple(grid[i + x][j:j + k] for x in range(k)) subgrids.add(subgrid) return len(subgrids)"},{"question":"def rank_contests(T: int, contests: List[List[Tuple[int, int, int]]]) -> List[List[int]]: Given the number of contests and the contestants' details, returns the ranks of each contestant sorted by their performance. The performance is ranked first by the number of problems solved, and in case of a tie, by the time taken to solve those problems. Args: T (int): The number of contests. contests (List[List[Tuple[int, int, int]]]): A list of contests with contestants' details. Each element is a list of tuples where each tuple contains: - ID (int): Unique identifier of the contestant. - P (int): Number of problems solved. - T (int): Total time taken to solve the problems. Returns: List[List[int]]: A list of lists containing the IDs of the contestants sorted by their performance for each contest. >>> rank_contests(2, [[(101, 5, 300), (102, 5, 270), (103, 4, 260)], [(201, 3, 200), (202, 3, 220), (203, 3, 210)]]) [[102, 101, 103], [201, 203, 202]] >>> rank_contests(1, [[(1001, 3, 500), (1002, 3, 400), (1003, 3, 300)]]) [[1003, 1002, 1001]]","solution":"def rank_contests(T, contests): result = [] for contest in contests: C = len(contest) sorted_contestants = sorted(contest, key=lambda x: (-x[1], x[2])) ranked_ids = [contestant[0] for contestant in sorted_contestants] result.append(ranked_ids) return result"},{"question":"def topThreeRatedRestaurants(reviews): Returns the names of the top three highest-rated restaurants based on the average rating. In case of a tie, the restaurants are ordered alphabetically by name. :param reviews: List[Dict[str, Union[str, float]]] - a list of dictionaries, each containing the 'restaurant' name and its 'rating' :return: List[str] - a list of top three unique restaurant names pass # Unit Tests def test_sample_case(): reviews = [ {\\"restaurant\\": \\"Burger King\\", \\"rating\\": 4.2}, {\\"restaurant\\": \\"McDonald's\\", \\"rating\\": 3.8}, {\\"restaurant\\": \\"Burger King\\", \\"rating\\": 4.8}, {\\"restaurant\\": \\"Wendy's\\", \\"rating\\": 4.0}, {\\"restaurant\\": \\"McDonald's\\", \\"rating\\": 4.1}, {\\"restaurant\\": \\"Wendy's\\", \\"rating\\": 4.5}, ] assert topThreeRatedRestaurants(reviews) == [\\"Burger King\\", \\"Wendy's\\", \\"McDonald's\\"] def test_empty_reviews(): reviews = [] assert topThreeRatedRestaurants(reviews) == [] def test_less_than_three_restaurants(): reviews = [ {\\"restaurant\\": \\"Burger King\\", \\"rating\\": 4.2}, {\\"restaurant\\": \\"McDonald's\\", \\"rating\\": 3.8}, ] assert topThreeRatedRestaurants(reviews) == [\\"Burger King\\", \\"McDonald's\\"] def test_three_restaurants(): reviews = [ {\\"restaurant\\": \\"Burger King\\", \\"rating\\": 4.2}, {\\"restaurant\\": \\"McDonald's\\", \\"rating\\": 3.8}, {\\"restaurant\\": \\"Wendy's\\", \\"rating\\": 4.5}, ] assert topThreeRatedRestaurants(reviews) == [\\"Wendy's\\", \\"Burger King\\", \\"McDonald's\\"] def test_tie_in_average_ratings(): reviews = [ {\\"restaurant\\": \\"Burger King\\", \\"rating\\": 4.0}, {\\"restaurant\\": \\"BK\\", \\"rating\\": 4.0}, {\\"restaurant\\": \\"McDonald's\\", \\"rating\\": 4.0}, {\\"restaurant\\": \\"Wendy's\\", \\"rating\\": 4.0}, ] # Tied ratings sorted alphabetically assert topThreeRatedRestaurants(reviews) == ['BK', 'Burger King', \\"McDonald's\\"] def test_mixed_reviews(): reviews = [ {\\"restaurant\\": \\"Burger King\\", \\"rating\\": 5.0}, {\\"restaurant\\": \\"Subway\\", \\"rating\\": 3.0}, {\\"restaurant\\": \\"McDonald's\\", \\"rating\\": 4.5}, {\\"restaurant\\": \\"Wendy's\\", \\"rating\\": 4.5}, {\\"restaurant\\": \\"Subway\\", \\"rating\\": 4.0}, ] assert topThreeRatedRestaurants(reviews) == [\\"Burger King\\", \\"McDonald's\\", \\"Wendy's\\"]","solution":"def topThreeRatedRestaurants(reviews): Returns the names of the top three highest-rated restaurants based on the average rating. In case of a tie, the restaurants are ordered alphabetically by name. :param reviews: List[Dict[str, Union[str, float]]] - a list of dictionaries, each containing the 'restaurant' name and its 'rating' :return: List[str] - a list of top three unique restaurant names from collections import defaultdict import heapq # Dictionary to hold the total ratings and count of reviews for each restaurant ratings = defaultdict(lambda: [0, 0]) # [sum of ratings, count of reviews] for review in reviews: restaurant = review['restaurant'] rating = review['rating'] ratings[restaurant][0] += rating ratings[restaurant][1] += 1 # Calculate the average ratings and create a list of (average_rating, restaurant_name) avg_ratings = [] for restaurant, (total, count) in ratings.items(): avg_rating = total / count avg_ratings.append((avg_rating, restaurant)) # Sort primarily by descending average rating and tie break alphabetically avg_ratings.sort(key=lambda x: (-x[0], x[1])) # Return the top 3 or fewer restaurant names return [restaurant for _, restaurant in avg_ratings[:3]]"},{"question":"class Student: def __init__(self, name, student_id): self.name = name self.id = student_id self.score = 0 class Contest: def __init__(self): self.students = [] self.id_to_student = {} def add_student(self, name, student_id): Add a student with the given name and unique ID. The student starts with a score of 0. pass def update_score(self, student_id, score): Update the score of the student with the given ID by adding the score to their current score. pass def get_ranking(self): Output the current ranking of the students. - Students with higher scores are ranked higher. - If two students have the same score, their relative order is preserved. >>> process_queries([\\"1 Alice 1\\", \\"1 Bob 2\\", \\"2 1 50\\", \\"2 2 50\\", \\"3\\", \\"2 2 -30\\", \\"3\\"]) [[('Alice', 1), ('Bob', 2)], [('Alice', 1), ('Bob', 2)]] pass def process_queries(queries): This is a helper function to process all queries and get the results. contest = Contest() results = [] for query in queries: parts = query.split() if parts[0] == '1': _, name, student_id = parts contest.add_student(name, int(student_id)) elif parts[0] == '2': _, student_id, score = parts contest.update_score(int(student_id), int(score)) elif parts[0] == '3': ranking = contest.get_ranking() results.append(ranking) return results","solution":"class Student: def __init__(self, name, student_id): self.name = name self.id = student_id self.score = 0 class Contest: def __init__(self): self.students = [] self.id_to_student = {} def add_student(self, name, student_id): student = Student(name, student_id) self.students.append(student) self.id_to_student[student_id] = student def update_score(self, student_id, score): if student_id in self.id_to_student: self.id_to_student[student_id].score += score def get_ranking(self): self.students.sort(key=lambda x: (-x.score, x.name)) return [(student.name, student.id) for student in self.students] def process_queries(queries): contest = Contest() results = [] for query in queries: parts = query.split() if parts[0] == '1': _, name, student_id = parts contest.add_student(name, int(student_id)) elif parts[0] == '2': _, student_id, score = parts contest.update_score(int(student_id), int(score)) elif parts[0] == '3': ranking = contest.get_ranking() results.append(ranking) return results"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum profit from buying and selling stocks where as many transactions as desired are allowed. :param prices: List[int] :return: int Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 7, 2, 8, 4, 6]) 14 pass","solution":"def max_profit(prices): Calculates the maximum profit from buying and selling stocks where as many transactions as desired are allowed. :param prices: List[int] :return: int max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"from typing import List def get_busiest_hour(logs: List[str]) -> str: Identify the single hour (in HH format, 24-hour clock) during which the maximum number of unique residents were logged in. >>> logs = [ ... \\"2023-09-12 09:13:27,123,login\\", ... \\"2023-09-12 09:45:14,124,login\\", ... \\"2023-09-12 10:17:50,123,logout\\", ... \\"2023-09-12 10:53:22,124,logout\\", ... \\"2023-09-12 11:47:33,125,login\\", ... \\"2023-09-12 12:25:04,126,login\\", ... \\"2023-09-12 12:55:33,125,logout\\", ... \\"2023-09-12 13:45:28,126,logout\\" ... ] >>> get_busiest_hour(logs) \\"09\\" >>> logs = [ ... \\"2023-09-12 18:00:00,101,login\\", ... \\"2023-09-12 19:00:00,102,login\\", ... \\"2023-09-12 19:30:00,101,logout\\", ... \\"2023-09-12 20:00:00,102,logout\\", ... \\"2023-09-12 21:00:00,103,login\\", ... \\"2023-09-12 22:00:00,103,logout\\" ... ] >>> get_busiest_hour(logs) \\"19\\"","solution":"from collections import defaultdict from typing import List def get_busiest_hour(logs: List[str]) -> str: login_times = defaultdict(set) current_logins = set() for log in logs: timestamp, resident_id, event_type = log.split(',') hour = timestamp.split(' ')[1][:2] if event_type == 'login': current_logins.add(resident_id) else: # event_type == 'logout' current_logins.discard(resident_id) for active_user in current_logins: login_times[hour].add(active_user) busiest_hour = max(login_times, key=lambda k: len(login_times[k])) return busiest_hour"},{"question":"class MinGuardsInVillage: In a medieval village, there are several houses, each connected by bidirectional roads. The village layout forms a tree, where each house is a node and each road is an edge. The houses are numbered from 0 to n-1. The village chief wants to assign guards to a set of important houses such that the guards can patrol the entire village with the minimum number of guards. Each guard can patrol the house they are assigned to and its directly connected neighboring houses. However, for convenience and safety, there should not be more than one guard within the same range of influence. def __init__(self, n, roads): Initializes the object with the number of houses n and the list of roads. :param n: int :param roads: List[List[int]] def markImportant(self, house): Marks the given house as important. :param house: int def computeMinGuards(self): Returns the minimum number of guards needed to patrol all the important houses and the entire village given the current set of important houses. :returns: int def test_min_guards_in_village(): village = MinGuardsInVillage(6, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]) village.markImportant(3) village.markImportant(4) assert village.computeMinGuards() == 2 # Guards at houses 1 and 2 village.markImportant(5) assert village.computeMinGuards() == 3 # Guards at houses 1, 2, and 5 village = MinGuardsInVillage(6, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]) village.markImportant(0) village.markImportant(3) village.markImportant(5) assert village.computeMinGuards() == 3 # Guards at houses 0, 1, and 2 def test_no_important_houses(): village = MinGuardsInVillage(4, [[0, 1], [1, 2], [2, 3]]) assert village.computeMinGuards() == 0 # No important houses, no guards needed def test_single_important_house(): village = MinGuardsInVillage(4, [[0, 1], [1, 2], [2, 3]]) village.markImportant(2) assert village.computeMinGuards() == 1 # One guard at house 2 def test_distributed_important_houses(): village = MinGuardsInVillage(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) village.markImportant(1) village.markImportant(3) assert village.computeMinGuards() == 2 # Guards at houses 1 and 3","solution":"class MinGuardsInVillage: def __init__(self, n, roads): self.n = n self.adj_list = [[] for _ in range(n)] for a, b in roads: self.adj_list[a].append(b) self.adj_list[b].append(a) self.important_houses = set() self.guarded = [False] * n def markImportant(self, house): self.important_houses.add(house) def _dfs(self, node, parent): covered = 0 for neighbor in self.adj_list[node]: if neighbor != parent: covered += self._dfs(neighbor, node) if covered == 0 and node in self.important_houses: return 1 elif covered > 0 and node in self.important_houses: self.guarded[node] = True return -1 elif covered == 1 and not self.guarded[node]: self.guarded[node] = True return -1 return covered def computeMinGuards(self): self.guarded = [False] * self.n total_guards = 0 for house in self.important_houses: if not self.guarded[house]: total_guards += max(1, self._dfs(house, -1)) return total_guards"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Given a set of distinct integers, nums, return all possible subsets (the power set). >>> sorted(subsets([1, 2, 3])) == sorted([[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]) True >>> subsets([]) == [[]] True >>> sorted(subsets([1])) == sorted([[], [1]]) True >>> sorted(subsets([1, 2])) == sorted([[], [1], [2], [1, 2]]) True >>> sorted(subsets([1, 2, 3, 4])) == sorted( [[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]) True","solution":"def subsets(nums): Returns all possible subsets (the power set) of the given list of distinct integers. subsets_list = [[]] for num in nums: subsets_list += [curr + [num] for curr in subsets_list] return subsets_list"},{"question":"from typing import List, Tuple def longest_even_odd_subarray(n: int, array: List[int]) -> int: Given a sequence of n integers, find the length of the longest contiguous subarray that has an equal number of even and odd integers. >>> longest_even_odd_subarray(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_even_odd_subarray(4, [1, 2, 2, 1]) 4 pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases for \`longest_even_odd_subarray\`. >>> process_test_cases(2, [(6, [1, 2, 3, 4, 5, 6]), (4, [1, 2, 2, 1])]) [6, 4] pass","solution":"def longest_even_odd_subarray(n, array): # Create a dictionary to store the first occurrence of a given parity difference. first_occurrence = {} first_occurrence[0] = -1 # Initialize for the edge case max_length = 0 even_count = 0 odd_count = 0 for i in range(n): if array[i] % 2 == 0: even_count += 1 else: odd_count += 1 parity_diff = even_count - odd_count if parity_diff in first_occurrence: max_length = max(max_length, i - first_occurrence[parity_diff]) else: first_occurrence[parity_diff] = i return max_length def process_test_cases(T, test_cases): results = [] for i in range(T): n, array = test_cases[i] results.append(longest_even_odd_subarray(n, array)) return results"},{"question":"def rotate(matrix): Rotates the n x n matrix by 90 degrees clockwise in-place. >>> matrix = [[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [[5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16]] >>> rotate(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotate(matrix): Rotates the n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def rle_min_length(s: str) -> int: Given a string s, returns the length of the string after applying Run-Length Encoding (RLE) compression. >>> rle_min_length(\\"AABBBCCCC\\") 6 >>> rle_min_length(\\"A\\") 2 >>> rle_min_length(\\"AAAAA\\") 2 >>> rle_min_length(\\"AAABBB\\") 4 >>> rle_min_length(\\"ABCDEFG\\") 14 >>> rle_min_length(\\"\\") 0 >>> rle_min_length(\\"ABABABABA\\") 18","solution":"def rle_min_length(s): Given a string s, returns the length of the string after applying Run-Length Encoding (RLE) compression. if not s: return 0 compressed_length = 0 count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: # Add the length of character plus number length compressed_length += 1 + len(str(count)) count = 1 # Add the last sequence compressed_length += 1 + len(str(count)) return compressed_length"},{"question":"def min_possible_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible difference between the total weights of two batches for several test cases. >>> min_possible_difference(2, [(5, [3, 1, 4, 2, 2]), (4, [2, 3, 5, 8])]) [0, 2] >>> min_possible_difference(1, [(1, [5])]) [5] >>> min_possible_difference(1, [(4, [10, 10, 10, 10])]) [0]","solution":"def min_difference(weights): total_sum = sum(weights) n = len(weights) dp = [0] * (total_sum // 2 + 1) for weight in weights: for j in range(total_sum // 2, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return total_sum - 2 * dp[total_sum // 2] def min_possible_difference(T, test_cases): results = [] for i in range(T): _ = test_cases[i][0] weights = test_cases[i][1] results.append(min_difference(weights)) return results"},{"question":"def maxSumSubarray(arr, k): Finds the maximum sum of any contiguous subarray of size k within the array. >>> maxSumSubarray([2, 1, 5, 1, 3, 2], 3) 9 >>> maxSumSubarray([2, 3, 4, 1, 5], 2) 7 >>> maxSumSubarray([1, 2, 3, 4, 5], 1) 5","solution":"def maxSumSubarray(arr, k): Finds the maximum sum of any contiguous subarray of size k within the array. # Initialize the maximum sum with the sum of the first k elements max_sum = sum(arr[:k]) # Current window sum starts as the initial k elements sum current_sum = max_sum # Iterate over the rest of the array starting from index k for i in range(k, len(arr)): # Calculate the new window sum current_sum = current_sum + arr[i] - arr[i - k] # Update max_sum if current window sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def generate_booking_references(transactions: List[Tuple[int, int]]) -> List[str]: Generate booking references based on user ID and number of tickets booked. >>> generate_booking_references([(101, 3), (202, 2), (303, 1)]) ['101-01-02-03', '202-01-02', '303-01'] >>> generate_booking_references([(404, 5)]) ['404-01-02-03-04-05'] >>> generate_booking_references([]) [] >>> generate_booking_references([(555, 1), (666, 3)]) ['555-01', '666-01-02-03'] >>> generate_booking_references([(777, 10)]) ['777-01-02-03-04-05-06-07-08-09-10']","solution":"def generate_booking_references(transactions): references = [] for user_id, tickets in transactions: reference = f\\"{user_id}\\" for i in range(1, tickets + 1): reference += f\\"-{i:02d}\\" references.append(reference) return references"},{"question":"from typing import List, Tuple def sum_divisible_by_3_or_5(test_cases: List[Tuple[int, List[int]]]) -> List[int]: In this problem, you will be given a list of integers, you need to find and print the sum of all integers that are divisible by 3 or 5 in the given list. >>> test_cases = [(5, [1, 2, 3, 4, 5])] >>> sum_divisible_by_3_or_5(test_cases) [8] >>> test_cases = [(4, [6, 7, 8, 9])] >>> sum_divisible_by_3_or_5(test_cases) [15]","solution":"def sum_divisible_by_3_or_5(test_cases): results = [] for case in test_cases: N, numbers = case sum_result = sum(number for number in numbers if number % 3 == 0 or number % 5 == 0) results.append(sum_result) return results"},{"question":"def diagnose(test_cases: list[tuple[float, float]]) -> list[bool]: Takes a list of tuples, where each tuple contains a radius and an expected area, and returns a list of booleans indicating if the calculated area matches the expected area up to 5 decimal places. >>> diagnose([(1.0, 3.14159), (2.0, 12.56637), (0.5, 0.78540)]) [True, True, True] >>> diagnose([(1.0, 3.14158), (2.0, 12.56638), (0.5, 0.78541)]) [False, False, False] >>> diagnose([]) []","solution":"from math import pi def calculate_area(radius: float) -> float: Returns the area of the circle with the given radius. return pi * (radius ** 2) def diagnose(test_cases: list[tuple[float, float]]) -> list[bool]: Takes a list of tuples, where each tuple contains a radius and an expected area, and returns a list of booleans indicating if the calculated area matches the expected area up to 5 decimal places. results = [] for radius, expected_area in test_cases: calculated_area = calculate_area(radius) # Compare the calculated and expected area up to 5 decimal places results.append(round(calculated_area, 5) == round(expected_area, 5)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"z\\") 1 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"bbbbbb\\") 1 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. max_length = 0 start = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 max_length = max(max_length, i - start + 1) used_chars[char] = i return max_length"},{"question":"def longest_subarray_with_limited_diff(arr: List[int], k: int) -> int: Find the length of the longest subarray such that the absolute difference between any two elements is less than or equal to k. >>> longest_subarray_with_limited_diff([1, 3, 2, 4, 5], 2) 3 >>> longest_subarray_with_limited_diff([4, 4, 4, 4], 0) 4 >>> longest_subarray_with_limited_diff([1, 2, 3, 4, 5, 6, 7, 8], 10) 8 >>> longest_subarray_with_limited_diff([10, 20, 30], 5) 1 >>> longest_subarray_with_limited_diff([42], 5) 1 >>> longest_subarray_with_limited_diff([1, 10, 20, 30, 30, 10, 1], 9) 2 >>> longest_subarray_with_limited_diff([1, 5, 3, 4, 2, 8, 7], 3) 4","solution":"from typing import List def longest_subarray_with_limited_diff(arr: List[int], k: int) -> int: Find the length of the longest subarray such that the absolute difference between any two elements is less than or equal to k. longest_length = 0 left = 0 for right in range(len(arr)): while max(arr[left:right+1]) - min(arr[left:right+1]) > k: left += 1 longest_length = max(longest_length, right - left + 1) return longest_length"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def get_influence_count(N: int, M: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Analyze relationships in a social network to find out the minimum number of users that need to be influenced directly or indirectly to spread a piece of information starting from a particular user. >>> get_influence_count(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [1, 2, 6]) [6, 5, 1] >>> get_influence_count(1, 0, [], [1]) [1] >>> get_influence_count(4, 2, [(1, 2), (3, 4)], [1, 3]) [2, 2] >>> get_influence_count(5, 3, [(1, 2), (2, 3), (4, 5)], [1, 2, 4, 5]) [3, 2, 2, 1]","solution":"def get_influence_count(N, M, edges, queries): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited) # Create graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) results = [] for s in queries: results.append(bfs(s, graph)) return results # Example usage: N = 6 M = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] queries = [1, 2, 6] print(get_influence_count(N, M, edges, queries)) # Output should be [6, 5, 1]"},{"question":"def wordPattern(pattern: str, words: str) -> bool: Check if the words string follows the same pattern as the pattern string. >>> wordPattern(\\"abba\\", \\"dog cat cat dog\\") True >>> wordPattern(\\"abba\\", \\"dog cat cat fish\\") False >>> wordPattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> wordPattern(\\"abba\\", \\"dog dog dog dog\\") False","solution":"def wordPattern(pattern: str, words: str) -> bool: word_list = words.split() if len(pattern) != len(word_list): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, word_list): if p not in pattern_to_word: if w in word_to_pattern: return False pattern_to_word[p] = w word_to_pattern[w] = p elif pattern_to_word[p] != w: return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Given a binary tree, return the sum of values of its deepest leaves. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> deepestLeavesSum(root) 15 >>> root = TreeNode(6) >>> root.left = TreeNode(7) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(3) >>> root.left.left.left = TreeNode(9) >>> root.left.right.left = TreeNode(1) >>> root.left.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(5) >>> deepestLeavesSum(root) 19","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(node, key): Inserts a new node with the given key into the BST. if node is None: return TreeNode(key) if key < node.val: node.left = insert(node.left, key) else: node.right = insert(node.right, key) return node def max_depth(node): Computes the maximum depth of the binary search tree. if node is None: return 0 left_depth = max_depth(node.left) right_depth = max_depth(node.right) return max(left_depth, right_depth) + 1 def bst_depth(n, elements): Calculates the depth of the resulting binary search tree. Args: n (int): Number of elements to be inserted. elements (List[int]): A list of integers representing the elements to be inserted. Returns: int: The depth of the resulting binary search tree. >>> bst_depth(6, [3, 1, 4, 2, 5, 6]) 3 >>> bst_depth(1, [5]) 0 >>> bst_depth(5, [1, 2, 3, 4, 5]) 4 >>> bst_depth(5, [5, 4, 3, 2, 1]) 4 >>> bst_depth(7, [7, 1, 15, 2, 9, 20, 3]) 3 >>> bst_depth(7, [4, 2, 6, 1, 3, 5, 7]) 2","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(node, key): Inserts a new node with the given key into the BST. if node is None: return TreeNode(key) if key < node.val: node.left = insert(node.left, key) else: node.right = insert(node.right, key) return node def max_depth(node): Computes the maximum depth of the binary search tree. if node is None: return 0 left_depth = max_depth(node.left) right_depth = max_depth(node.right) return max(left_depth, right_depth) + 1 def bst_depth(n, elements): if n == 0: return 0 root = None for element in elements: root = insert(root, element) # Since \`max_depth\` returns the number of nodes along the way, minus 1 to count edges return max_depth(root) - 1"},{"question":"from typing import List, Optional def max_product(nums: List[int]) -> Optional[int]: Given a list of integers, return the largest possible product of any three distinct numbers from the list. If the list contains fewer than three numbers, return None. >>> max_product([1, 10, 2, 6, 5, 3]) 300 >>> max_product([-10, -10, 5, 2]) 500 >>> max_product([1, 2]) None >>> max_product([-1, -2, -3, -4]) -6 >>> max_product([0, -1, -2, -3]) 0 >>> max_product([1000, 2000, 3000, 4000]) 24000000000","solution":"from typing import List, Optional def max_product(nums: List[int]) -> Optional[int]: Given a list of integers, return the largest possible product of any three distinct numbers from the list. If the list contains fewer than three numbers, return None. if len(nums) < 3: return None nums.sort() # The largest product of any three numbers can either be from the highest three numbers # or from two lowest negative numbers and the highest positive number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def compress_string(s: str) -> str: Compresses the string by replacing sequences of the same character with that character followed by the number of times it appears consecutively. Returns the original string if the compressed string is not shorter. s: str - the string to compress. Returns: str - the compressed string or the original string. Examples: >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef'","solution":"def compress_string(s): Compresses the string by replacing sequences of the same character with that character followed by the number of times it appears consecutively. Returns the original string if the compressed string is not shorter. s: str - the string to compress. Returns: str - the compressed string or the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # Append the last character and count compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def convert_temperature(value: float, scale: str) -> float: Convert temperature between Celsius and Fahrenheit. Parameters: value (float): The temperature value to be converted. scale (str): The target scale for conversion (\\"C\\" for Celsius, \\"F\\" for Fahrenheit). Returns: float: The converted temperature rounded to 1 decimal place. >>> convert_temperature(68, \\"C\\") 20.0 >>> convert_temperature(20, \\"F\\") 68.0 >>> convert_temperature(98.6, \\"C\\") 37.0 >>> convert_temperature(37, \\"F\\") 98.6 >>> convert_temperature(-40, \\"C\\") -40.0 >>> convert_temperature(100, \\"K\\") Traceback (most recent call last): ... ValueError: Invalid scale. Use 'C' for Celsius or 'F' for Fahrenheit. pass","solution":"def convert_temperature(value, scale): Convert temperature between Celsius and Fahrenheit. Parameters: value (float): The temperature value to be converted. scale (str): The target scale for conversion (\\"C\\" for Celsius, \\"F\\" for Fahrenheit). Returns: float: The converted temperature rounded to 1 decimal place. if scale == \\"C\\": return round((value - 32) * 5 / 9, 1) elif scale == \\"F\\": return round((value * 9 / 5) + 32, 1) else: raise ValueError(\\"Invalid scale. Use 'C' for Celsius or 'F' for Fahrenheit.\\")"},{"question":"def longest_unique_subarray_length(nums: List[int]) -> int: Returns the length of the longest subarray with unique elements. >>> longest_unique_subarray_length([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([4, 4, 4, 4]) == 1 >>> longest_unique_subarray_length([1, 2, 3, 4, 5]) == 5 pass","solution":"def longest_unique_subarray_length(nums): Returns the length of the longest subarray with unique elements. seen = {} max_length = 0 start = 0 for end in range(len(nums)): if nums[end] in seen: start = max(start, seen[nums[end]] + 1) seen[nums[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression given as a string with <integer> <operator> <integer> format. >>> evaluate_expression(\\"4 + 2\\") 6 >>> evaluate_expression(\\"10 - 3\\") 7 >>> evaluate_expression(\\"7 * 5\\") 35 >>> evaluate_expression(\\"9 / 2\\") 4","solution":"def evaluate_expression(expression): Evaluates a simple arithmetic expression given as a string with <integer> <operator> <integer> format. :param expression: str, the arithmetic expression :return: int, the result of the evaluated expression num1, operator, num2 = expression.split() num1 = int(num1) num2 = int(num2) if operator == '+': return num1 + num2 elif operator == '-': return num1 - num2 elif operator == '*': return num1 * num2 elif operator == '/': return num1 // num2 else: raise ValueError(\\"Invalid operator\\")"},{"question":"def find_single_number(numbers: list[int]) -> int: This function finds the element that appears only once in a list where all other elements appear twice. Args: numbers (list): The list of integers where every element appears twice except for one. Returns: int: The single element that appears only once. Examples: >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2, 2, 3, 2, 2, 3, 4, 3, 4]) 3","solution":"def find_single_number(numbers): This function finds the element that appears only once in a list where all other elements appear twice. Args: numbers (list): The list of integers where every element appears twice except for one. Returns: int: The single element that appears only once. result = 0 for number in numbers: result ^= number return result"},{"question":"def validate_boarding_pass(code: str) -> bool: Validates a boarding pass code based on the given criteria. >>> validate_boarding_pass(\\"A1b3Cdefgh\\") # => True >>> validate_boarding_pass(\\"A1B3CDEFGH\\") # => False (no lowercase letter) >>> validate_boarding_pass(\\"a1c3e6g0k8\\") # => False (no uppercase letter) >>> validate_boarding_pass(\\"A1c3E6K8\\") # => False (not 10 characters)","solution":"import re def validate_boarding_pass(code): Validates a boarding pass code based on the given criteria. Parameters: code (str): The boarding pass code to validate. Returns: bool: True if the code is valid, False otherwise. if len(code) != 10: return False if not re.search(r'[A-Z]', code): return False if not re.search(r'[a-z]', code): return False if not re.search(r'd', code): return False return True"},{"question":"import re def is_palindrome(s: str) -> bool: Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"Able was I ere I saw Elba\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A\\") == True >>> is_palindrome(\\" \\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Madam, in Eden, I'm Adam\\") == True","solution":"import re def is_palindrome(s): Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): Input string Returns: bool: True if the string is a palindrome, False otherwise # Remove non-alphanumeric characters and convert to lowercase filtered_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the filtered string is equal to its reverse return filtered_string == filtered_string[::-1]"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(9) False def filter_primes(lst: List[int]) -> List[int]: Filter the prime numbers from a list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([15, 20, 25, 30, 35]) [] >>> filter_primes([11, 13, 17, 19, 23, 29]) [11, 13, 17, 19, 23, 29] >>> filter_primes([]) [] >>> filter_primes([-10, -3, 0, 2, 4, 6]) [2]","solution":"def is_prime(n): Check if a number is a prime number. :param n: Integer, the number to check. :return: Boolean, True if the number is prime, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Filter the prime numbers from a list of integers. :param lst: List of integers. :return: List of integers that are prime numbers. return [num for num in lst if is_prime(num)]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string arithmetic expression containing non-negative integers and '+', '-', '*', and '/' operators with normal precedence rules. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluates a string arithmetic expression containing non-negative integers and '+', '-', '*', and '/' operators with normal precedence rules. if not expression: return 0 num, stack, sign = 0, [], '+' expression = expression.replace(' ', '') for i, ch in enumerate(expression): if ch.isdigit(): num = num * 10 + int(ch) if ch in '+-*/' or i == len(expression) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) # integer division num, sign = 0, ch return sum(stack)"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str, k: int) -> str: Rearrange the string so that no two adjacent characters are the same, with an interval of at least k. If such a reorganization is possible, return any possible rearrangement. If it is not possible, return an empty string. Args: s (str): The input string. k (int): The interval for adjacent unique characters. Returns: str: A rearranged string or an empty string if rearrangement is not possible. Examples: >>> rearrange_string(\\"aabb\\", 2) 'abab' # or any valid arrangement >>> rearrange_string(\\"aaabc\\", 3) '' # Unit Tests def test_rearrange_string_example_1(): assert rearrange_string(\\"aabb\\", 2) in [\\"abab\\", \\"baba\\"] def test_rearrange_string_example_2(): assert rearrange_string(\\"aaabc\\", 3) == \\"\\" def test_rearrange_string_single_letter(): assert rearrange_string(\\"aaa\\", 2) == \\"\\" def test_rearrange_string_k_zero(): assert rearrange_string(\\"aabbcc\\", 0) == \\"aabbcc\\" def test_rearrange_string_no_possible_rearrangement(): assert rearrange_string(\\"aaab\\", 2) == \\"\\" def test_rearrange_string_possible_rearrangement(): result = rearrange_string(\\"aaaabbbc\\", 2) # Check if the result is valid for i in range(1, len(result)): assert result[i] != result[i-1] def test_rearrange_string_edge_case(): assert rearrange_string(\\"a\\", 1) == \\"a\\"","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k == 0: return s count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) # To store the result result = [] # Queue to keep the k elements wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # Append current char with reduced frequency to wait queue wait_queue.append((char, freq + 1)) if len(wait_queue) < k: continue # Release character from queue if it has finished waiting time released_char, released_freq = wait_queue.pop(0) if released_freq < 0: heapq.heappush(max_heap, (released_freq, released_char)) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"def mysterious_grid_sum(n: int) -> int: Returns the sum of all numbers in an n x n grid where each cell (i, j) contains the product of its row number i and column number j. >>> mysterious_grid_sum(4) == 100 >>> mysterious_grid_sum(1) == 1","solution":"def mysterious_grid_sum(n): Returns the sum of all numbers in an n x n grid where each cell (i, j) contains the product of its row number i and column number j. total_sum = 0 for i in range(1, n + 1): for j in range(1, n + 1): total_sum += i * j return total_sum"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"aab\\") 2 >>> test_input = \\"abcdefghijklmnopqrstuvwxyz\\" * 2000 >>> length_of_longest_substring(test_input) 26","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} left = 0 max_length = 0 for right in range(n): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def remove_duplicate_letters(s: str) -> str: Given a string \`s\` that consists of only lowercase English letters, construct a string \`t\` by performing the following operations exactly once for each character in \`s\`: 1. Choose a character in \`s\` (denoted as \`c_i\`). 2. Move \`c_i\` to the front of \`t\`. Return the lexicographically smallest string \`t\` that can be constructed by the above operations. >>> remove_duplicate_letters(\\"cbacdcbc\\") 'acdb' >>> remove_duplicate_letters(\\"bcabc\\") 'abc' >>> remove_duplicate_letters(\\"abacb\\") 'abc'","solution":"def remove_duplicate_letters(s): Returns the lexicographically smallest string possible by moving the characters of \`s\` to the front one by one. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return ''.join(stack)"},{"question":"def longestSubstringWithTwoDistinct(s: str) -> int: Given a string containing only lowercase letters, find the length of the longest substring that contains at most two different types of characters. >>> longestSubstringWithTwoDistinct(\\"ccaabbb\\") 5 >>> longestSubstringWithTwoDistinct(\\"abc\\") 2 >>> longestSubstringWithTwoDistinct(\\"aabbcc\\") 4 >>> longestSubstringWithTwoDistinct(\\"aaaa\\") 4 >>> longestSubstringWithTwoDistinct(\\"ababababab\\") 10 >>> longestSubstringWithTwoDistinct(\\"abcdef\\") 2 >>> longestSubstringWithTwoDistinct(\\"a\\") 1 >>> longestSubstringWithTwoDistinct(\\"ababababa\\") 9 pass","solution":"def longestSubstringWithTwoDistinct(s): Returns the length of the longest substring that contains at most two different types of characters. n = len(s) if n <= 2: return n max_len = 0 left = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def can_form_palindrome_by_deleting_one_char(s: str) -> bool: Check if the string can form a palindrome after deleting at most one character. >>> can_form_palindrome_by_deleting_one_char(\\"abca\\") True >>> can_form_palindrome_by_deleting_one_char(\\"racecar\\") True >>> can_form_palindrome_by_deleting_one_char(\\"abcd\\") False","solution":"def can_form_palindrome_by_deleting_one_char(s): def is_palindrome(subs): return subs == subs[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing either the left or the right character and check return is_palindrome(s[left:right]) or is_palindrome(s[left + 1:right + 1]) left += 1 right -= 1 return True"},{"question":"from typing import List def num_distinct_paths(grid: List[str]) -> int: Determine the number of distinct paths from the top-left to the bottom-right cell in a grid. You can only move right or down, and must avoid blocked cells ('X'). The top-left and bottom-right cells are guaranteed to be open ('O'). >>> num_distinct_paths([\\"OOO\\", \\"OXO\\", \\"OOO\\"]) 2 >>> num_distinct_paths([\\"OOO\\", \\"OOO\\", \\"OOO\\"]) 6 >>> num_distinct_paths([\\"OXO\\", \\"XXO\\", \\"OOO\\"]) 0 >>> num_distinct_paths([\\"OOOO\\"]) 1 >>> num_distinct_paths([\\"O\\", \\"O\\", \\"O\\"]) 1 >>> num_distinct_paths([\\"O\\"]) 1","solution":"def num_distinct_paths(grid): n = len(grid) m = len(grid[0]) # Create a dp table to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the starting cell dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == 'X': dp[i][j] = 0 # No paths through blocked cells else: if i > 0: dp[i][j] += dp[i-1][j] # Paths from the cell above if j > 0: dp[i][j] += dp[i][j-1] # Paths from the cell to the left # The number of paths to the bottom-right cell return dp[n-1][m-1]"},{"question":"def max_consecutive_black_tiles(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the maximum number of consecutive black tiles Polycarp can obtain by painting some of the white tiles black. >>> max_consecutive_black_tiles(3, [(5, \\"BBBWB\\"), (6, \\"WWBWBB\\"), (8, \\"WBWBWBWB\\")]) [5, 6, 8] >>> max_consecutive_black_tiles(2, [(4, \\"BBBB\\"), (3, \\"BBW\\")]) [4, 3] >>> max_consecutive_black_tiles(1, [(10, \\"WWWWWWWWWW\\")]) [10] Args: t: Number of test cases. test_cases: A list of tuples, each containing an integer n (number of tiles) and a string representing the tiles Returns: A list of integers, where each integer is the maximum number of consecutive black tiles that can be obtained for each test case.","solution":"def max_consecutive_black_tiles(t, test_cases): results = [] for i in range(t): n, tiles = test_cases[i] results.append(n) return results"},{"question":"def find_missing_number(arr: list) -> int: Finds the missing number in the array containing n-1 distinct numbers in the range from 1 to n. Parameters: arr (list): List of integers. Returns: int: The missing number. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([1]) 2 >>> find_missing_number([2, 3, 4, 5]) 1 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([2, 1, 3]) 4 >>> find_missing_number([]) 1","solution":"def find_missing_number(arr): Finds the missing number in the array containing n-1 distinct numbers in the range from 1 to n. Parameters: arr (list): List of integers. Returns: int: The missing number. n = len(arr) + 1 total_sum = n * (n + 1) // 2 arr_sum = sum(arr) return total_sum - arr_sum"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given sentence. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"coding is fun\\") 'fun is coding' >>> reverse_words(\\"python\\") 'python' >>> reverse_words(\\"hello world this is a test\\") 'test a is this world hello' >>> reverse_words(\\"quick brown fox jumps over the lazy dog\\") 'dog lazy the over jumps fox brown quick'","solution":"def reverse_words(s): Reverses the order of words in a given sentence. :param s: String representing a sentence with multiple words separated by spaces. :return: String with words in reverse order. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def is_triangle(a: int, b: int, c: int) -> bool: Determine if three side lengths can form a triangle based on the triangle inequality theorem. Parameters: a (int): The first side length. b (int): The second side length. c (int): The third side length. Returns: bool: True if the lengths can form a triangle, False otherwise. Examples: >>> is_triangle(3, 4, 5) True >>> is_triangle(1, 1, 2) False >>> is_triangle(7, 10, 5) True >>> is_triangle(1, 2, 3) False","solution":"def is_triangle(a, b, c): Determine if three side lengths can form a triangle based on the triangle inequality theorem. Parameters: a (int): The first side length. b (int): The second side length. c (int): The third side length. Returns: bool: True if the lengths can form a triangle, False otherwise. return a + b > c and a + c > b and b + c > a"},{"question":"def sum_of_squares(n: int) -> int: Create a function sum_of_squares(n) that takes an integer n as input and returns the difference between the square of the sum and the sum of the squares of the first n natural numbers. >>> sum_of_squares(10) 2640 >>> sum_of_squares(1) 0 >>> sum_of_squares(5) 170 >>> sum_of_squares(15) 13160 >>> sum_of_squares(100) 25164150 >>> sum_of_squares(0) 0","solution":"def sum_of_squares(n): Returns the difference between the square of the sum and the sum of the squares of the first n natural numbers. sum_n = sum(range(1, n+1)) square_of_sum = sum_n ** 2 sum_of_squares = sum(i**2 for i in range(1, n+1)) return square_of_sum - sum_of_squares"},{"question":"def isValid(s: str) -> bool: Returns True if the input string s has valid parentheses. Otherwise, returns False. Examples: >>> isValid(\\"()\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"(]\\") False >>> isValid(\\"([)]\\") False >>> isValid(\\"{[]}\\") True","solution":"def isValid(s: str) -> bool: Returns True if the input string s has valid parentheses. Otherwise, returns False. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket: top_element = stack.pop() if stack else '#' if matching_bracket[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 3) 3 >>> length_of_longest_substring_k_distinct(\\"\\", 2) 0 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"abcabcbb\\", 5) 8 >>> length_of_longest_substring_k_distinct(\\"aaaaaa\\", 2) 6 >>> length_of_longest_substring_k_distinct(\\"aaabbcc\\", 2) 5","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. if k == 0 or not s: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_carmichael(n: int) -> bool: Check if the given integer n is a Carmichael number. >>> is_carmichael(561) True >>> is_carmichael(1105) True >>> is_carmichael(1729) True >>> is_carmichael(15) False >>> is_carmichael(17) False","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gcd(a, b): while b: a, b = b, a % b return a def is_carmichael(n): if is_prime(n) or n < 2: return False for a in range(2, n): if gcd(a, n) == 1: if pow(a, n-1, n) != 1: return False return True"},{"question":"def min_steps_transform(source: str, target: str, operations: set) -> int: Calculate the minimum number of steps required to transform one string into another using a specified set of operations. >>> min_steps_transform(\\"kitten\\", \\"sitting\\", {'insert', 'replace'}) 3 >>> min_steps_transform(\\"abc\\", \\"def\\", {'insert', 'delete'}) 6 >>> min_steps_transform(\\"horse\\", \\"ros\\", {'insert', 'delete', 'replace'}) 3 >>> min_steps_transform(\\"abc\\", \\"abc\\", {'insert', 'delete', 'replace'}) 0 >>> min_steps_transform(\\"\\", \\"abc\\", {'insert'}) 3 >>> min_steps_transform(\\"abc\\", \\"\\", {'delete'}) 3 >>> min_steps_transform(\\"a\\", \\"b\\", {'replace'}) 1","solution":"def min_steps_transform(source, target, operations): m, n = len(source), len(target) # Initialize a DP table with dimensions (m+1) x (n+1) dp = [[float('inf')] * (n + 1) for _ in range(m + 1)] # Base cases dp[0][0] = 0 for i in range(1, m + 1): if 'delete' in operations: dp[i][0] = i for j in range(1, n + 1): if 'insert' in operations: dp[0][j] = j # Fill the rest of the DP table for i in range(1, m + 1): for j in range(1, n + 1): if source[i-1] == target[j-1]: # Characters match, no operation needed dp[i][j] = dp[i-1][j-1] else: if 'replace' in operations: dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1) # Replace operation if 'delete' in operations: dp[i][j] = min(dp[i][j], dp[i-1][j] + 1) # Delete operation if 'insert' in operations: dp[i][j] = min(dp[i][j], dp[i][j-1] + 1) # Insert operation return dp[m][n]"},{"question":"def matches_pattern(pattern: str, string: str) -> bool: Determine if a string matches a given pattern. Each character in the pattern can be matched with any non-empty substring of the input string. No two characters in the pattern should match the same substring of the input string, but a character may match the same substring multiple times. Examples: >>> matches_pattern('abab', 'redblueredblue') True >>> matches_pattern('aaaa', 'asdasdasdasd') True >>> matches_pattern('aabb', 'xyzabcxzyabc') False >>> matches_pattern('a', 'anything') True >>> matches_pattern('abba', 'redredbluered') False >>> matches_pattern('abcd', 'wxyz') True >>> matches_pattern('aab', 'xyzxyzxyz') False from solution import matches_pattern def test_matches_pattern_example1(): assert matches_pattern('abab', 'redblueredblue') == True def test_matches_pattern_example2(): assert matches_pattern('aaaa', 'asdasdasdasd') == True def test_matches_pattern_example3(): assert matches_pattern('aabb', 'xyzabcxzyabc') == False def test_matches_pattern_single_char_pattern(): assert matches_pattern('a', 'anything') == True def test_matches_pattern_same_char_different_substr(): assert matches_pattern('abba', 'redredbluered') == False def test_matches_pattern_full_match(): assert matches_pattern('abcd', 'wxyz') == True def test_matches_pattern_non_matching_length(): assert matches_pattern('aab', 'xyzxyzxyz') == False","solution":"def matches_pattern(pattern, string): def match_helper(pattern_index, string_index, map, used): if pattern_index == len(pattern) and string_index == len(string): return True if pattern_index == len(pattern) or string_index == len(string): return False pat_char = pattern[pattern_index] for i in range(string_index, len(string)): substr = string[string_index:i+1] if pat_char in map: if map[pat_char] == substr: if match_helper(pattern_index + 1, i + 1, map, used): return True else: if substr in used: continue map[pat_char] = substr used.add(substr) if match_helper(pattern_index + 1, i + 1, map, used): return True del map[pat_char] used.remove(substr) return False return match_helper(0, 0, {}, set())"},{"question":"def transpose(matrix): Returns the transpose of the given 2D matrix. :param matrix: List of lists where each inner list represents a row of the matrix. :return: Transposed matrix as a list of lists. Example: >>> transpose([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[1, 2, 3]]) [[1], [2], [3]] >>> transpose([ ... [1], ... [2], ... [3] ... ]) [[1, 2, 3]]","solution":"def transpose(matrix): Returns the transpose of the given 2D matrix. :param matrix: List of lists where each inner list represents a row of the matrix. :return: Transposed matrix as a list of lists. # Ensure the input matrix is not empty if not matrix or not matrix[0]: return [] # Transpose the matrix transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] return transposed"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"aaa\\") == \\"a\\" >>> longest_unique_substring(\\"abcdefg\\") == \\"abcdefg\\" >>> longest_unique_substring(\\"xyz\\") == \\"xyz\\" >>> longest_unique_substring(\\"abcabcddcba\\") == \\"abcd\\" >>> longest_unique_substring(\\"aabbccabcddd\\") == \\"abcd\\" >>> longest_unique_substring(\\"aaaaabbbaaaccaaaabbbb\\") == \\"ab\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. start = 0 max_length = 0 max_substr = '' char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 else: if i - start + 1 > max_length: max_length = i - start + 1 max_substr = s[start:i + 1] char_index_map[char] = i return max_substr"},{"question":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Given an integer array nums, return the number of contiguous subarrays of nums whose sum equals k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1], 1) 1 pass","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays of nums whose sum equals k. count = 0 cum_sum = 0 sum_dict = {0: 1} for num in nums: cum_sum += num if cum_sum - k in sum_dict: count += sum_dict[cum_sum - k] if cum_sum in sum_dict: sum_dict[cum_sum] += 1 else: sum_dict[cum_sum] = 1 return count"},{"question":"from typing import List class ListOperations: def __init__(self, array: List[int]): self.array = array self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self): prefix_sum = [0] * (len(self.array) + 1) for i in range(len(self.array)): prefix_sum[i + 1] = prefix_sum[i] + self.array[i] return prefix_sum def update(self, X: int, Y: int): delta = Y - self.array[X - 1] self.array[X - 1] = Y for i in range(X, len(self.array) + 1): self.prefix_sum[i] += delta def query(self, L: int, R: int): return self.prefix_sum[R] - self.prefix_sum[L - 1] def process_operations(N: int, M: int, A: List[int], operations: List[str]) -> List[int]: Process a series of update and query operations on a list. Args: N: int - The number of elements in the list. M: int - The number of operations. A: List[int] - The initial list of integers. operations: List[str] - A list of operations in the form of \\"update X Y\\" or \\"query L R\\". Returns: List[int] - The results of the query operations. >>> process_operations(5, 3, [1, 2, 3, 4, 5], [\\"query 1 3\\", \\"update 2 10\\", \\"query 1 3\\"]) [6, 14] >>> process_operations(4, 2, [1, 2, 3, 4], [\\"query 1 4\\", \\"query 2 3\\"]) [10, 5] list_ops = ListOperations(A) results = [] for op in operations: op_type, X, Y = op.split() X, Y = int(X), int(Y) if op_type == \\"update\\": list_ops.update(X, Y) elif op_type == \\"query\\": results.append(list_ops.query(X, Y)) return results def test_simple_operations(): N = 5 M = 3 A = [1, 2, 3, 4, 5] operations = [\\"query 1 3\\", \\"update 2 10\\", \\"query 1 3\\"] expected_output = [6, 14] assert process_operations(N, M, A, operations) == expected_output def test_no_updates(): N = 4 M = 2 A = [1, 2, 3, 4] operations = [\\"query 1 4\\", \\"query 2 3\\"] expected_output = [10, 5] assert process_operations(N, M, A, operations) == expected_output def test_no_queries(): N = 5 M = 2 A = [10, 20, 30, 40, 50] operations = [\\"update 1 15\\", \\"update 3 35\\"] expected_output = [] assert process_operations(N, M, A, operations) == expected_output def test_multiple_updates(): N = 5 M = 4 A = [10, 20, 30, 40, 50] operations = [\\"update 1 5\\", \\"update 5 60\\", \\"query 1 5\\", \\"query 3 5\\"] expected_output = [155, 130] assert process_operations(N, M, A, operations) == expected_output def test_edge_values(): N = 1 M = 2 A = [10] operations = [\\"query 1 1\\", \\"update 1 20\\", \\"query 1 1\\"] expected_output = [10, 20] assert process_operations(N, M, A, operations) == expected_output","solution":"class ListOperations: def __init__(self, array): self.array = array self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self): prefix_sum = [0] * (len(self.array) + 1) for i in range(len(self.array)): prefix_sum[i + 1] = prefix_sum[i] + self.array[i] return prefix_sum def update(self, X, Y): delta = Y - self.array[X - 1] self.array[X - 1] = Y for i in range(X, len(self.array) + 1): self.prefix_sum[i] += delta def query(self, L, R): return self.prefix_sum[R] - self.prefix_sum[L - 1] def process_operations(N, M, A, operations): list_ops = ListOperations(A) results = [] for op in operations: op_type, X, Y = op.split() X, Y = int(X), int(Y) if op_type == \\"update\\": list_ops.update(X, Y) elif op_type == \\"query\\": results.append(list_ops.query(X, Y)) return results"},{"question":"from collections import Counter def max_char_occurrence(s: str) -> str: Returns the character that appears the maximum number of times in the string \`s\`. If there is a tie, returns the first character that reaches the maximum count. >>> max_char_occurrence(\\"Programming is Fun!\\") == 'r' >>> max_char_occurrence(\\"aAaBbCcDD\\") == 'a' >>> max_char_occurrence(\\"\\") == '' >>> max_char_occurrence(\\"!! hello 123 \\") == 'l' >>> max_char_occurrence(\\"aaaaa\\") == 'a' >>> max_char_occurrence(\\"x\\") == 'x'","solution":"from collections import Counter def max_char_occurrence(s): Returns the character that appears the maximum number of times in the string \`s\`. If there is a tie, returns the first character that reaches the maximum count. s = s.lower() # Convert to lowercase to ignore case counter = Counter(s) max_count = 0 max_char = '' for char in s: if char.isalpha(): # Consider only alphabetic characters if counter[char] > max_count: max_count = counter[char] max_char = char return max_char"},{"question":"def minimum_coins(cost: int, paid: int) -> int: Returns the minimum number of coins needed to return the change. Parameters: cost (int): The cost of the item in cents. paid (int): The amount paid by the user in cents. Returns: int: The minimum number of coins required to make up the change. Examples: >>> minimum_coins(75, 100) 1 >>> minimum_coins(99, 100) 1 >>> minimum_coins(123, 200) 5 >>> minimum_coins(100000, 100050) 2 >>> minimum_coins(123, 176) 5","solution":"def minimum_coins(cost, paid): Returns the minimum number of coins needed to return the change. Parameters: cost (int): The cost of the item in cents. paid (int): The amount paid by the user in cents. Returns: int: The minimum number of coins required to make up the change. change = paid - cost coin_count = 0 # Define the coin denominations in descending order coins = [25, 10, 5, 1] for coin in coins: coin_count += change // coin change %= coin return coin_count"},{"question":"from typing import List, Tuple def custom_sort(lst: List[int]) -> List[int]: Sorts the given list such that all negative numbers appear before zero, zero appears in the middle, and all positive numbers appear after all zeroes. >>> custom_sort([-4, 3, 0, -1, 2]) [-4, -1, 0, 3, 2] >>> custom_sort([0, -3, 5, -2, -1, 4]) [-3, -2, -1, 0, 5, 4] pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases for the custom_sort function and return the results as a list of strings with sorted numbers. >>> process_test_cases(2, [(5, [-4, 3, 0, -1, 2]), (6, [0, -3, 5, -2, -1, 4])]) [\\"-4 -1 0 3 2\\", \\"-3 -2 -1 0 5 4\\"] pass from solution import custom_sort, process_test_cases def test_custom_sort_with_mixed_numbers(): assert custom_sort([-4, 3, 0, -1, 2]) == [-4, -1, 0, 3, 2] def test_custom_sort_with_only_negatives(): assert custom_sort([-4, -3, -2, -1]) == [-4, -3, -2, -1] def test_custom_sort_with_only_positives(): assert custom_sort([4, 3, 2, 1]) == [4, 3, 2, 1] def test_custom_sort_with_zeros_in_middle(): assert custom_sort([0, -3, 5, -2, -1, 4]) == [-3, -2, -1, 0, 5, 4] def test_custom_sort_with_all_zeros(): assert custom_sort([0, 0, 0]) == [0, 0, 0] def test_process_test_cases(): test_cases = [ (5, [-4, 3, 0, -1, 2]), (6, [0, -3, 5, -2, -1, 4]) ] results = process_test_cases(2, test_cases) assert results == [\\"-4 -1 0 3 2\\", \\"-3 -2 -1 0 5 4\\"]","solution":"def custom_sort(lst): Sorts the given list such that all negative numbers appear before zero, zero appears in the middle, and all positive numbers appear after all zeroes. negatives = [x for x in lst if x < 0] zeroes = [x for x in lst if x == 0] positives = [x for x in lst if x > 0] return negatives + zeroes + positives def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] lst = test_cases[i][1] sorted_lst = custom_sort(lst) results.append(\\" \\".join(map(str, sorted_lst))) return results"},{"question":"from typing import List def partition_labels(s: str) -> List[int]: Partition the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"aaaaa\\") [5] >>> partition_labels(\\"abcde\\") [1, 1, 1, 1, 1] >>> partition_labels(\\"eccbbbbdec\\") [10] >>> partition_labels(\\"caedbdedda\\") [1, 9] >>> partition_labels(\\"\\") [] pass","solution":"from typing import List def partition_labels(s: str) -> List[int]: Partition the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start = 0 end = 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(idx - start + 1) start = idx + 1 return partitions"},{"question":"def duplicate_by_value(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns a list where each integer is duplicated the number of times equal to its value. If the integer is non-positive, it should not appear in the output list. >>> duplicate_by_value([1, 2, 3]) [1, 2, 2, 3, 3, 3] >>> duplicate_by_value([0, -1, 4]) [4, 4, 4, 4] >>> duplicate_by_value([5, 1, 0, 2]) [5, 5, 5, 5, 5, 1, 2, 2] >>> duplicate_by_value([-1, -2, 0]) [] >>> duplicate_by_value([]) [] >>> duplicate_by_value([100]) [100] * 100","solution":"def duplicate_by_value(lst): Returns a list where each integer is duplicated the number of times equal to its value. Non-positive integers will not appear in the output list. :param lst: List of integers :return: List of integers duplicated by their value result = [] for num in lst: if num > 0: result.extend([num] * num) return result"},{"question":"def check_sequence(arr: list[int]) -> str: Determines if a sequence of integers is monotonically increasing, monotonically decreasing, or neither. Args: arr (list of int): The sequence of integers. Returns: str: 'increasing', 'decreasing' or 'neither'. >>> check_sequence([1, 2, 2, 3]) 'increasing' >>> check_sequence([3, 2, 1, 1]) 'decreasing' >>> check_sequence([1, 3, 2]) 'neither' >>> check_sequence([]) 'neither' >>> check_sequence([1]) 'increasing' >>> check_sequence([2, 2, 2, 2]) 'increasing'","solution":"def check_sequence(arr): Determines if a sequence of integers is monotonically increasing, monotonically decreasing, or neither. Args: arr (list of int): The sequence of integers. Returns: str: 'increasing', 'decreasing' or 'neither'. if not arr: return 'neither' is_increasing = all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) is_decreasing = all(arr[i] >= arr[i+1] for i in range(len(arr) - 1)) if is_increasing: return 'increasing' elif is_decreasing: return 'decreasing' else: return 'neither'"},{"question":"def can_fill_knights(T: int, test_cases: list) -> list: Given number of test cases and sizes of chessboards, determine if it's possible to place knights such that none of them can attack each other. Parameters: T (int): Number of test cases. test_cases (list of int): List of chessboard sizes for each test case. Returns: list of str: List of \\"YES\\" or \\"NO\\" strings for each test case. >>> can_fill_knights(3, [1, 2, 3]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_fill_knights(1, [1]) [\\"YES\\"] >>> can_fill_knights(3, [4, 5, 6]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_fill_knights(T, test_cases): Given number of test cases and sizes of chessboards, determine if it's possible to place knights such that none of them can attack each other. Parameters: T (int): Number of test cases. test_cases (list of int): List of chessboard sizes for each test case. Returns: list of str: List of \\"YES\\" or \\"NO\\" strings for each test case. results = [] for N in test_cases: if N > 1 and N % 2 == 1: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def invert_dictionary(original_dict): Inverts the given dictionary. Keys from the original dictionary's value lists become keys in the new dictionary, and the associated value is a list of keys from the original dictionary. Args: original_dict (dict): A dictionary with string keys and lists of strings as values. Returns: dict: A new dictionary where each item from the value lists in the original dictionary is a key, and the associated value is a list of keys from the original dictionary that contained that item. >>> invert_dictionary({\\"fruit\\": [\\"apple\\", \\"banana\\"], \\"vegetable\\": [\\"carrot\\", \\"apple\\"], \\"dairy\\": [\\"milk\\", \\"cheese\\"]}) {'apple': ['fruit', 'vegetable'], 'banana': ['fruit'], 'carrot': ['vegetable'], 'milk': ['dairy'], 'cheese': ['dairy']} >>> invert_dictionary({}) {} >>> invert_dictionary({\\"fruit\\": [], \\"vegetable\\": [\\"carrot\\"], \\"dairy\\": []}) {'carrot': ['vegetable']} >>> invert_dictionary({\\"drink\\": [\\"water\\"]}) {'water': ['drink']}","solution":"def invert_dictionary(original_dict): Inverts the given dictionary. Keys from the original dictionary's value lists become keys in the new dictionary, and the associated value is a list of keys from the original dictionary. Args: original_dict (dict): A dictionary with string keys and lists of strings as values. Returns: dict: A new dictionary where each item from the value lists in the original dictionary is a key, and the associated value is a list of keys from the original dictionary that contained that item. inverted_dict = {} for key, values in original_dict.items(): for value in values: if value not in inverted_dict: inverted_dict[value] = [] inverted_dict[value].append(key) return inverted_dict"},{"question":"def find_zero_sum_subarray(arr: List[int]) -> List[int]: Given an array of integers, determine if there exists a subarray (contiguous elements) with a sum equal to zero. If such a subarray is found, return the subarray. If no such subarray exists, return an empty array. The subarray must contain at least one element. >>> find_zero_sum_subarray([3, 4, -7, 1, 3, 3, 1, -4]) in [[3, 4, -7], [4, -7, 3], [-7, 1, 3, 3], [1, 3, 3, 1, -4]] True >>> find_zero_sum_subarray([]) == [] True >>> find_zero_sum_subarray([1, 2, 3]) == [] True >>> find_zero_sum_subarray([0]) == [0] True >>> find_zero_sum_subarray([1, 2, -3]) == [1, 2, -3] True >>> find_zero_sum_subarray([4, 2, -3, 1, 6]) == [2, -3, 1] True >>> find_zero_sum_subarray([1, -1]) == [1, -1] True >>> find_zero_sum_subarray([1, 2, -2, -1, 2]) == [2, -2] True >>> find_zero_sum_subarray([1, 2, 3, -5]) == [2, 3, -5] True","solution":"def find_zero_sum_subarray(arr): Finds a subarray with sum equal to zero. prefix_sum = 0 seen_sums = {0: -1} # Sum to index mapping, 0 is mapped to -1 to handle the sum starting from index 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum in seen_sums: # Return the subarray from the index after the previous occurrence of the same prefix sum start_index = seen_sums[prefix_sum] + 1 return arr[start_index:i + 1] seen_sums[prefix_sum] = i return []"},{"question":"def longest_sublist_within_threshold(nums: List[int], threshold: int) -> List[int]: Given a list of integers, return the longest sublist where the difference between the maximum and minimum values is less than or equal to a specified threshold. >>> longest_sublist_within_threshold([1, 3, 5, 7, 9], 4) [1, 3, 5] >>> longest_sublist_within_threshold([10, 1, 2, 3, 4, 5], 3) [1, 2, 3, 4] >>> longest_sublist_within_threshold([100, 200, 300, 400, 500], 99) [100]","solution":"def longest_sublist_within_threshold(nums, threshold): start = 0 max_len = 0 max_sublist = [] for end in range(len(nums)): current_sublist = nums[start:end+1] if max(current_sublist) - min(current_sublist) > threshold: start += 1 else: if len(current_sublist) > max_len: max_len = len(current_sublist) max_sublist = current_sublist return max_sublist"},{"question":"def chunk_array(arr, size): Splits an array into chunks of a specified size and returns them as a list of arrays. Parameters: arr (list): The input array to be split. size (int): The size of each chunk. Returns: list: A list of arrays where each array is a chunk of the specified size. Raises: ValueError: If the size is less than or equal to 0. Examples: >>> chunk_array([1, 2, 3, 4, 5], 2) [[1, 2], [3, 4], [5]] >>> chunk_array([1, 2, 3, 4, 5, 6, 7, 8], 3) [[1, 2, 3], [4, 5, 6], [7, 8]] >>> chunk_array([1], 1) [[1]] >>> chunk_array([], 2) [] >>> chunk_array([1, 2, 3], 5) [[1, 2, 3]]","solution":"def chunk_array(arr, size): Splits an array into chunks of a specified size and returns them as a list of arrays. Parameters: arr (list): The input array to be split. size (int): The size of each chunk. Returns: list: A list of arrays where each array is a chunk of the specified size. if size <= 0: raise ValueError(\\"Chunk size should be greater than 0\\") return [arr[i:i + size] for i in range(0, len(arr), size)]"},{"question":"def min_operations_to_empty_string(s: str) -> int: Given a string s, return the minimum number of operations needed to make the given string empty by removing palindromic substrings. >>> min_operations_to_empty_string(\\"ababa\\") 1 >>> min_operations_to_empty_string(\\"abb\\") 2 >>> min_operations_to_empty_string(\\"baabb\\") 2","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the given string empty by removing palindromic substrings. if s == s[::-1]: return 1 else: return 2"},{"question":"def find_shortest_word_length(s: str) -> int: Returns the length of the shortest word in the string s. >>> find_shortest_word_length(\\"The quick brown fox jumps over the lazy dog\\") == 3 >>> find_shortest_word_length(\\"A journey of a thousand miles begins with a single step\\") == 1 >>> find_shortest_word_length(\\"This is an amazing test\\") == 2 >>> find_shortest_word_length(\\"Cat bat mat\\") == 3 >>> find_shortest_word_length(\\"I am learning Python coding\\") == 1","solution":"def find_shortest_word_length(s): Returns the length of the shortest word in the string s. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of the squares of all integers from 1 to n (inclusive). >>> sum_of_squares(1) ==> 1 >>> sum_of_squares(2) ==> 5 >>> sum_of_squares(3) ==> 14 >>> sum_of_squares(4) ==> 30 >>> sum_of_squares(10) ==> 385 >>> sum_of_squares(50) ==> 42925 >>> sum_of_squares(100) ==> 338350","solution":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n (inclusive). return sum(i ** 2 for i in range(1, n + 1))"},{"question":"def can_form_even_number_of_teams(T: int, test_cases: List[int]) -> List[str]: Determine if it is possible to form the required number of teams based on the number of team members available. Arguments: T -- the number of test cases test_cases -- a list of integers representing the number of team members for each test case Returns: A list of strings, each being \\"Possible\\" or \\"Impossible\\" for the corresponding test case. >>> can_form_even_number_of_teams(4, [4, 5, 8, 10]) ['Possible', 'Impossible', 'Possible', 'Impossible'] >>> can_form_even_number_of_teams(1, [2]) ['Impossible'] >>> can_form_even_number_of_teams(1, [1]) ['Impossible'] >>> can_form_even_number_of_teams(1, [6]) ['Impossible'] >>> can_form_even_number_of_teams(2, [12, 14]) ['Possible', 'Impossible']","solution":"def can_form_even_number_of_teams(T, test_cases): results = [] for M in test_cases: if M % 2 == 1: results.append(\\"Impossible\\") else: pairs = M // 2 if pairs % 2 == 0: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string and returns the result. The expression can contain positive integers, the operators + (addition), - (subtraction), * (multiplication), and / (division), and parentheses to indicate operation precedence. >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"(2+3)*4\\") == 20 >>> evaluate_expression(\\"10+5/5\\") == 11 >>> evaluate_expression(\\"10-5*2\\") == 0 >>> evaluate_expression(\\"100/(2+3)\\") == 20 >>> evaluate_expression(\\"10*5-30/6\\") == 45 >>> evaluate_expression(\\"(10+2)*3\\") == 36 >>> evaluate_expression(\\"((2-1)*(2+3))\\") == 5 >>> evaluate_expression(\\"(6/2)*(1+2)\\") == 9 >>> evaluate_expression(\\"2+2*2/2-2\\") == 2","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression string and returns the result. return eval(expression)"},{"question":"def rotate_matrix(matrix): Rotate a square matrix (list of lists) 90 degrees clockwise. Args: matrix (list of lists of int): A square matrix to be rotated. Returns: list of lists of int: The rotated matrix. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]]","solution":"def rotate_matrix(matrix): Rotate a square matrix (list of lists) 90 degrees clockwise. Args: matrix (list of lists of int): A square matrix to be rotated. Returns: list of lists of int: The rotated matrix. n = len(matrix) # Create a new matrix with the same dimensions rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"from typing import List import re def find_word_indices(n: int, documents: List[str], query: str) -> List[int]: Returns a list of indices of the documents where the query word appears (case-insensitive). >>> find_word_indices(3, [\\"The quick brown fox\\", \\"Jumped over the lazy dog\\", \\"Sorted order in binary search Trees\\"], \\"the\\") [0, 1] >>> find_word_indices(2, [\\"Welcome to the coding assessment\\", \\"Best of luck\\"], \\"luck\\") [1] >>> find_word_indices(2, [\\"Test document one\\", \\"Another test document\\"], \\"notfound\\") [] >>> find_word_indices(2, [\\"Repeat word Repeat\\", \\"Word to Repeat test\\"], \\"repeat\\") [0, 1] >>> find_word_indices(2, [\\"\\", \\"\\"], \\"any\\") [] >>> find_word_indices(2, [\\"Hello, world!\\", \\"What a wonderful world.\\"], \\"world\\") [0, 1]","solution":"import re def find_word_indices(n, documents, query): Returns a list of indices of the documents where the query word appears (case-insensitive). indices = [] query = query.lower() for i, document in enumerate(documents): words = re.findall(r'bw+b', document.lower()) if query in words: indices.append(i) return indices"},{"question":"from typing import List, Dict def determine_winner(T: int, test_cases: List[Dict[str, any]]) -> List[str]: This function determines the winner of the sequence puzzle game between Scarlet and Violet based on the given special rule for player turns. Args: T : int : The number of test cases. test_cases : List[Dict[str, any]] : List of dictionaries with the following keys: - 'N': int : The number of elements in the sequence. - 'X': int : The special number X. - 'S': List[int] : The sequence of integers. Returns: List[str] : A list of strings where each string is either \\"WIN\\" or \\"LOSE\\" representing Scarlet's outcome of the corresponding test case. Example: >>> determine_winner(2, [{'N': 5, 'X': 2, 'S': [1, 3, 5, 7, 9]}, {'N': 4, 'X': 3, 'S': [5, 5, 5, 5]}]) [\\"WIN\\", \\"LOSE\\"] results = [] for case in test_cases: N, X = case['N'], case['X'] S = case['S'] # Your code logic here to determine the winner of the game return results import pytest def test_scarlet_wins(): T = 1 test_cases = [{'N': 5, 'X': 2, 'S': [1, 3, 5, 7, 9]}] assert determine_winner(T, test_cases) == [\\"WIN\\"] def test_violet_wins(): T = 1 test_cases = [{'N': 4, 'X': 3, 'S': [5, 5, 5, 5]}] assert determine_winner(T, test_cases) == [\\"LOSE\\"] def test_mixed_cases(): T = 2 test_cases = [ {'N': 5, 'X': 2, 'S': [1, 3, 5, 7, 9]}, {'N': 4, 'X': 3, 'S': [5, 5, 5, 5]} ] assert determine_winner(T, test_cases) == [\\"WIN\\", \\"LOSE\\"] def test_edge_case_one_element_scarlet_wins(): T = 1 test_cases = [{'N': 1, 'X': 1, 'S': [10]}] assert determine_winner(T, test_cases) == [\\"WIN\\"] def test_edge_case_one_element_violet_wins(): T = 1 test_cases = [{'N': 1, 'X': 1, 'S': [0]}] assert determine_winner(T, test_cases) == [\\"LOSE\\"] if __name__ == '__main__': pytest.main()","solution":"def determine_winner(T, test_cases): results = [] for case in test_cases: N, X = case['N'], case['X'] S = case['S'] # Sort the sequence in descending order to prioritize larger values S.sort(reverse=True) # Split S into Scarlet's and Violet's picks assuming Scarlet starts first scarlet_score = sum(S[0::2]) violet_score = sum(S[1::2]) # Determine the winner if scarlet_score > violet_score: results.append(\\"WIN\\") else: results.append(\\"LOSE\\") return results # Helper function to parse input and process output def parse_input_and_process(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N, X = map(int, lines[idx].split()) S = list(map(int, lines[idx + 1].split())) test_cases.append({'N': N, 'X': X, 'S': S}) idx += 2 results = determine_winner(T, test_cases) return 'n'.join(results) # Main function to process the input with determination logic def determine_winner(T, test_cases): results = [] for case in test_cases: N, X = case['N'], case['X'] S = case['S'] # Sort the sequence in descending order to prioritize larger values S.sort(reverse=True) # Split S into Scarlet's and Violet's picks assuming Scarlet starts first scarlet_score = sum(S[0::2]) violet_score = sum(S[1::2]) # Determine the winner if scarlet_score > violet_score: results.append(\\"WIN\\") else: results.append(\\"LOSE\\") return results"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from buying and selling the stock once. :param prices: List[int] representing the daily prices of a stock. :return: int representing the maximum profit possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([]) 0 >>> max_profit([10]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 >>> prices = list(range(10000, 0, -1)) + list(range(10001)) >>> max_profit(prices) 10000","solution":"def max_profit(prices): Calculate the maximum profit that can be achieved from buying and selling the stock once. :param prices: List[int] representing the daily prices of a stock. :return: int representing the maximum profit possible. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. >>> min_operations(\\"sea\\", \\"eat\\") 3 >>> min_operations(\\"leetcode\\", \\"etco\\") 4 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"abc\\", \\"def\\") 3 >>> min_operations(\\"aabbcc\\", \\"abc\\") 3 >>> min_operations(\\"aaaaaa\\", \\"aaa\\") 3","solution":"def min_operations(s, t): Returns the minimum number of operations required to transform string s into string t. m, n = len(s), len(t) # Create a dp table with (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base case: converting empty string to any string t (by insertions) for j in range(n + 1): dp[0][j] = j # Base case: converting any string s to empty string (by deletions) for i in range(m + 1): dp[i][0] = i # Compute the cost for each substring pair (s[0:i], t[0:j]) for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: # Characters match, no operation needed for this character dp[i][j] = dp[i-1][j-1] else: # Minimum between replace operation, delete operation dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j]) return dp[m][n]"},{"question":"from typing import List def min_partition_difference(N: int, A: List[int]) -> int: Given a list of positive integers, partition the list into exactly two sublists (non-empty) such that the absolute difference between the sums of the integers in the two sublists is minimized. N: int - The number of integers in the list. A: List[int] - The list of positive integers. Returns: int - The minimum absolute difference between the sums of the two sublists. >>> min_partition_difference(4, [1, 2, 3, 9]) 3 >>> min_partition_difference(2, [1, 2]) 1","solution":"from itertools import combinations def min_partition_difference(N, A): Given a list of positive integers, partition the list into exactly two sublists (non-empty) such that the absolute difference between the sums of the integers in the two sublists is minimized. N: int - The number of integers in the list. A: List[int] - The list of positive integers. Returns: int - The minimum absolute difference between the sums of the two sublists. total_sum = sum(A) min_diff = float(\\"inf\\") for i in range(1, N): for comb in combinations(A, i): sum1 = sum(comb) sum2 = total_sum - sum1 min_diff = min(min_diff, abs(sum1 - sum2)) return min_diff"},{"question":"def generate_spiral_matrix(n: int) -> list: Generates an N x N spiral matrix filled with integers from 1 to N^2 in a clockwise spiral order. Args: n (int): Size of the matrix Returns: list: N x N spiral matrix >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] pass def print_spiral_matrix(matrix: list): Prints the given spiral matrix with each entry right-aligned within a 3-character-wide column. Args: matrix (list): N x N spiral matrix pass","solution":"def generate_spiral_matrix(n): Generates an N x N spiral matrix filled with integers from 1 to N^2 in a clockwise spiral order. Args: n (int): Size of the matrix Returns: list: N x N spiral matrix matrix = [[0]*n for _ in range(n)] num = 1 left, right = 0, n-1 top, bottom = 0, n-1 while left <= right and top <= bottom: for j in range(left, right + 1): matrix[top][j] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for j in range(right, left - 1, -1): matrix[bottom][j] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix def print_spiral_matrix(matrix): Prints the given spiral matrix with each entry right-aligned within a 3-character-wide column. Args: matrix (list): N x N spiral matrix for row in matrix: print(\\"\\".join(f\\"{val:3}\\" for val in row))"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of histograms, computes the area of the largest rectangle that can be formed within the boundaries of the histograms. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([2, 4]) == 4 >>> largestRectangleArea([1, 1, 1, 1, 1]) == 5 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of histograms, computes the area of the largest rectangle that can be formed within the boundaries of the histograms. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_substrings(S: str) -> int: Returns the minimum number of substrings needed such that each letter appears in at most one substring. >>> min_substrings(\\"abcdef\\") 6 >>> min_substrings(\\"aaaa\\") 1 >>> min_substrings(\\"abac\\")== 2 >>> min_substrings(\\"a\\") 1 >>> min_substrings(\\"aabbcc\\") 3 >>> min_substrings(\\"abcbacdef\\") 4","solution":"def min_substrings(S): Returns the minimum number of substrings needed such that each letter appears in at most one substring. last_occurrence = {char: idx for idx, char in enumerate(S)} num_substrings = 0 end = -1 for idx, char in enumerate(S): end = max(end, last_occurrence[char]) if idx == end: num_substrings += 1 return num_substrings"},{"question":"def min_transformations(beginWord: str, endWord: str, wordList: List[str]) -> int: Returns the minimum number of transformations needed to convert beginWord to endWord using a given list of transformations wordList. >>> min_transformations(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> min_transformations(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> min_transformations(\\"hit\\", \\"hit\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"hit\\"]) 1 >>> min_transformations(\\"hit\\", \\"hot\\", [\\"hot\\"]) 2 >>> min_transformations(\\"hit\\", \\"cog\\", [\\"hot\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\", \\"cog\\"]) 5","solution":"from collections import deque def min_transformations(beginWord, endWord, wordList): Returns the minimum number of transformations needed to convert beginWord to endWord using a given list of transformations wordList. if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(beginWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': new_word = current_word[:i] + c + current_word[i+1:] if new_word in wordSet: wordSet.remove(new_word) queue.append((new_word, steps + 1)) return 0"},{"question":"from typing import List def sum_evenly_spaced_elements(arr: List[int], k: int, m: int) -> int: Returns the sum of every k-th element in the list, starting from the m-th element (1-based). Parameters: arr (list): List of integers. k (int): Step size. m (int): Starting position (1-based index). Returns: int: Sum of every k-th element starting from the m-th element. >>> sum_evenly_spaced_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2, 3) == 18 >>> sum_evenly_spaced_elements([10, 20, 30, 40, 50], 3, 2) == 70 >>> sum_evenly_spaced_elements([1, 2, 3, 4, 5], 1, 6) == 0","solution":"def sum_evenly_spaced_elements(arr, k, m): Returns the sum of every k-th element in the list, starting from the m-th element (1-based). Parameters: arr (list): List of integers. k (int): Step size. m (int): Starting position (1-based index). Returns: int: Sum of every k-th element starting from the m-th element. # Adjust the 1-based index m to 0-based index start = m - 1 # If the starting index is out of bounds, return 0 if start >= len(arr) or start < 0: return 0 # Calculate the sum of every k-th element starting from the m-th element total_sum = 0 for i in range(start, len(arr), k): total_sum += arr[i] return total_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Computes the diameter of the binary tree rooted at 'root'. The diameter is the length of the longest path between any two nodes in the tree. from solution import TreeNode, diameterOfBinaryTree def test_single_node(): node = TreeNode(1) assert diameterOfBinaryTree(node) == 0 def test_two_nodes(): root = TreeNode(1) root.left = TreeNode(2) assert diameterOfBinaryTree(root) == 1 def test_diameter_through_root(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert diameterOfBinaryTree(root) == 3 def test_diameter_not_through_root(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) root.left.left.right = TreeNode(5) assert diameterOfBinaryTree(root) == 3 def test_complex_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.left = TreeNode(6) root.left.right.right = TreeNode(7) root.left.right.right.right = TreeNode(8) assert diameterOfBinaryTree(root) == 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Computes the diameter of the binary tree rooted at 'root'. The diameter is the length of the longest path between any two nodes in the tree. def depth(node): nonlocal diameter if not node: return 0 left = depth(node.left) right = depth(node.right) diameter = max(diameter, left + right) return max(left, right) + 1 diameter = 0 depth(root) return diameter"},{"question":"def nim_game(n: int) -> str: Determines if the player who goes first will win the Nim game with n stones. Parameters: n (int): The number of stones in the pile Returns: str: \\"You win\\" if the first player can force a win, \\"You lose\\" otherwise >>> nim_game(3) 'You win' >>> nim_game(4) 'You lose'","solution":"def nim_game(n: int) -> str: Determines if the player who goes first will win the Nim game with n stones. Parameters: n (int): The number of stones in the pile Returns: str: \\"You win\\" if the first player can force a win, \\"You lose\\" otherwise if n % 4 == 0: return \\"You lose\\" else: return \\"You win\\""},{"question":"def concatenate_strings(s1: str, s2: str) -> str: Concatenates two strings if they do not contain any digit characters. >>> concatenate_strings(\\"hello\\", \\"world\\") 'helloworld' >>> concatenate_strings(\\"foo\\", \\"bar\\") 'foobar' >>> concatenate_strings(\\"hello1\\", \\"world\\") 'Invalid input' >>> concatenate_strings(\\"foo\\", \\"bar2\\") 'Invalid input' >>> concatenate_strings(\\"123\\", \\"456\\") 'Invalid input' >>> concatenate_strings(\\"\\", \\"\\") '' >>> concatenate_strings(\\"hello\\", \\"\\") 'hello' >>> concatenate_strings(\\"\\", \\"world\\") 'world' >>> concatenate_strings(\\"!@#\\", \\"%^\\") '!@#%^'","solution":"def concatenate_strings(s1, s2): Concatenates two strings if they do not contain any digit characters. Args: s1 (str): First input string. s2 (str): Second input string. Returns: str: Concatenated string or \\"Invalid input\\" if any string contains digits. if any(char.isdigit() for char in s1) or any(char.isdigit() for char in s2): return \\"Invalid input\\" return s1 + s2"},{"question":"def is_symmetric_pattern(pattern: str) -> bool: Returns True if the input pattern is symmetrical (same forwards and backwards), otherwise returns False. >>> is_symmetric_pattern(\\"ABBBA\\") True >>> is_symmetric_pattern(\\"ABCDDCBA\\") True >>> is_symmetric_pattern(\\"ABCDEF\\") False","solution":"def is_symmetric_pattern(pattern: str) -> bool: Returns True if the input pattern is symmetrical (same forwards and backwards), otherwise returns False. return pattern == pattern[::-1]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression containing non-negative numbers and the operators +, -, *, /. The expression is evaluated with the typical order of operations (PEMDAS). >>> evaluate_expression(\\"3+5*2/2-1\\") 7.0 >>> evaluate_expression(\\"10+2*6\\") 22.0 >>> evaluate_expression(\\"100*2+12\\") 212.0 >>> evaluate_expression(\\"100*(2+12)/4\\") 350.0 >>> evaluate_expression(\\"3+5/2\\") 5.5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative numbers and the operators +, -, *, /. The expression is evaluated with the typical order of operations (PEMDAS). # Using Python's eval function with some safeguards allowed_chars = set(\\"0123456789+-*/().\\") if not all(char in allowed_chars for char in expression): raise ValueError(\\"Invalid character in expression\\") result = eval(expression) return float(result)"},{"question":"def serving_order(teas: List[int]) -> List[int]: Returns the tea cups served in a specific alternating high-low order. Args: teas (List[int]): A list of integers in non-decreasing order. Returns: List[int]: A list of integers in the alternating high-low order. >>> serving_order([3, 3, 4, 4, 4, 5, 6, 7]) [7, 3, 6, 3, 5, 4, 4, 4] >>> serving_order([1, 2, 3, 3, 3, 4]) [4, 1, 3, 2, 3, 3] >>> serving_order([5, 5, 6, 6, 7, 8]) [8, 5, 7, 5, 6, 6]","solution":"def serving_order(teas): Returns the tea cups served in a specific alternating high-low order. result = [] left = 0 right = len(teas) - 1 while left <= right: if right >= left: result.append(teas[right]) right -= 1 if right >= left: result.append(teas[left]) left += 1 return result"},{"question":"def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be made by buying and selling a stock once. If no profit can be made, returns 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) == 5 >>> maxProfit([7, 6, 4, 3, 1]) == 0 >>> maxProfit([5]) == 0 >>> maxProfit([1, 1, 1, 1, 1]) == 0 >>> maxProfit([1, 2, 3, 4, 5]) == 4 >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) == 4","solution":"def maxProfit(prices): Returns the maximum profit that can be made by buying and selling a stock once. If no profit can be made, returns 0. if not prices or len(prices) == 1: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word(s) in the given string. Examples: >>> length_of_shortest_word(\\"\\") == 0 >>> length_of_shortest_word(\\"hello\\") == 5 >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") == 3 >>> length_of_shortest_word(\\" The quick brown fox jumps over the lazy dog \\") == 3 >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") == 3 >>> length_of_shortest_word(\\"ant bat cat dog eel\\") == 3 >>> length_of_shortest_word(\\"It's a nice day.\\") == 1 >>> length_of_shortest_word(\\"SomeWHERE over the rainbow\\") == 3","solution":"def length_of_shortest_word(s): Returns the length of the shortest word(s) in the given string. if not s.strip(): return 0 words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns indices of the two distinct integers in nums that add up to target. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: Tuple: Indices of the two integers adding up to target, or an empty tuple if no such pair exists. Examples: >>> find_two_sum([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum([3, 2, 4], 6) (1, 2) >>> find_two_sum([1, 5, 3], 10) ()","solution":"def find_two_sum(nums, target): Returns indices of the two distinct integers in nums that add up to target. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: Tuple: Indices of the two integers adding up to target, or an empty tuple if no such pair exists. num_indices = {} for i, num in enumerate(nums): complement = target - num if complement in num_indices: return (num_indices[complement], i) num_indices[num] = i return ()"},{"question":"def max_total_stones(n: int, piles: List[int]) -> int: Returns the maximum total stones Mia can collect from piles. Parameters: n (int): The number of piles. piles (list of int): A list of integers representing the number of stones in each pile. Returns: int: The maximum total stones she can collect. >>> max_total_stones(5, [2, 3, 1, 5, 4]) 15 >>> max_total_stones(1, [10]) 10 >>> max_total_stones(4, [5, 5, 5, 5]) 20 >>> max_total_stones(3, [10**9, 10**9, 10**9]) 3000000000 >>> max_total_stones(6, [1, 2, 3, 4, 5, 6]) 21 >>> max_total_stones(6, [6, 5, 4, 3, 2, 1]) 21","solution":"def max_total_stones(n, piles): Returns the maximum total stones Mia can collect from piles. Parameters: n (int): The number of piles. piles (list of int): A list of integers representing the number of stones in each pile. Returns: int: The maximum total stones she can collect. return sum(piles)"},{"question":"def calculate_savings(initial_amount: int, annual_interest_rate: int, years: int) -> float: Calculate the total amount of savings after a certain number of years with compound interest. :param initial_amount: Positive integer, the initial amount of savings. :param annual_interest_rate: Positive integer, the annual interest rate as a percentage. :param years: Non-negative integer, the number of years the savings will be held. :return: Floating point number, the total amount of savings rounded to two decimal places. >>> calculate_savings(1000, 5, 3) 1157.63 >>> calculate_savings(1000, 5, 0) 1000.0 >>> calculate_savings(1000, 10, 1) 1100.0 >>> calculate_savings(1000, 50, 2) 2250.0 >>> calculate_savings(1000, 7, 10) 1967.15 >>> calculate_savings(1000, 0, 5) 1000.0","solution":"def calculate_savings(initial_amount, annual_interest_rate, years): Calculate the total amount of savings after a certain number of years with compound interest. :param initial_amount: Positive integer, the initial amount of savings. :param annual_interest_rate: Positive integer, the annual interest rate as a percentage. :param years: Non-negative integer, the number of years the savings will be held. :return: Floating point number, the total amount of savings rounded to two decimal places. if years == 0: return float(initial_amount) final_amount = initial_amount * (1 + annual_interest_rate / 100) ** years return round(final_amount, 2)"},{"question":"from typing import List, Dict, Union def most_hours_worked(logs: List[Dict[str, Union[str, int]]]) -> str: Identify the employee who has worked the most total hours. If multiple employees have the same highest total hours, return the name that appears first alphabetically. >>> most_hours_worked([{'employee': 'Alice', 'hours': 5}, {'employee': 'Bob', 'hours': 8}, {'employee': 'Alice', 'hours': 7}, {'employee': 'Bob', 'hours': 6}, {'employee': 'Charlie', 'hours': 10}]) 'Bob' >>> most_hours_worked([]) ''","solution":"from typing import List, Dict, Union def most_hours_worked(logs: List[Dict[str, Union[str, int]]]) -> str: Function to identify the employee who has worked the most total hours. Arguments: logs : List[Dict[str, Union[str, int]]] - A list of dictionaries where each dictionary contains: - employee (str): The name of the employee. - hours (int): The number of hours the employee worked that day. Returns: str - The name of the employee with the highest total hours worked. # Dictionary to keep track of the total hours for each employee total_hours = {} for log in logs: employee = log['employee'] hours = log['hours'] if employee in total_hours: total_hours[employee] += hours else: total_hours[employee] = hours # Find the employee with the maximum total hours max_hours = -1 max_employee = \\"\\" for employee, hours in total_hours.items(): if hours > max_hours or (hours == max_hours and employee < max_employee): max_hours = hours max_employee = employee return max_employee"},{"question":"[Completion Task in Python] def max_overlapping_paths(n: int, paths: List[Tuple[int, int]]) -> int: Find the maximum number of overlapping paths at any point along the park. >>> max_overlapping_paths(3, [(1, 5), (2, 6), (4, 8)]) == 3 >>> max_overlapping_paths(4, [(1, 3), (2, 5), (6, 8), (9, 10)]) == 2","solution":"def max_overlapping_paths(n, paths): events = [] for l, r in paths: events.append((l, 'start')) events.append((r, 'end')) events.sort(key=lambda x: (x[0], x[1] == 'end')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"from typing import List def hasPairWithDifference(arr: List[int], k: int) -> bool: Determine whether the array contains two distinct elements such that their difference is exactly k. >>> hasPairWithDifference([5, 20, 3, 2, 50, 80], 78) True >>> hasPairWithDifference([90, 70, 20, 80, 50], 45) False >>> hasPairWithDifference([1, 2, 3, 4, 5], 0) False >>> hasPairWithDifference([10, 10, 10, 10], 0) True >>> hasPairWithDifference([1, 5, 2, 9, 7], 3) True >>> hasPairWithDifference([1, 14, 6, 8, 10], 4) True >>> hasPairWithDifference([], 5) False >>> hasPairWithDifference([1, 2], 3) False >>> hasPairWithDifference([1, 2], 1) True >>> hasPairWithDifference([1], 0) False","solution":"def hasPairWithDifference(arr, k): Returns true if there are two distinct elements in the array whose difference is exactly k, otherwise returns false. num_set = set(arr) for num in arr: if (num + k) in num_set or (num - k) in num_set: if k != 0 or arr.count(num) > 1: # handle the case where k is zero specifically return True return False"},{"question":"def findMedianOfSortedArrays(arr1: List[int], arr2: List[int]) -> float: Write a function \`findMedianOfSortedArrays\` that finds the median of two sorted arrays of integers. The function should take two arrays \`arr1\` and \`arr2\` as inputs and return the median of the combined sorted array. Requirements: 1. The time complexity should be O(log(min(n, m))), where \`n\` and \`m\` are the lengths of the arrays \`arr1\` and \`arr2\` respectively. 2. You may assume that both arrays have lengths greater than 0. 3. The function should handle both odd and even number of elements in the combined sorted array. Examples: >>> findMedianOfSortedArrays([1, 3], [2]) 2.0 >>> findMedianOfSortedArrays([1, 2], [3, 4]) 2.5","solution":"def findMedianOfSortedArrays(arr1, arr2): Finds the median of the two sorted arrays combined. Parameters: arr1 (list[int]): A sorted list of integers. arr2 (list[int]): A sorted list of integers. Returns: float: The median of the two sorted arrays combined. if len(arr1) > len(arr2): arr1, arr2 = arr2, arr1 x, y = len(arr1), len(arr2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float('-inf') if partitionX == 0 else arr1[partitionX - 1] minX = float('inf') if partitionX == x else arr1[partitionX] maxY = float('-inf') if partitionY == 0 else arr2[partitionY - 1] minY = float('inf') if partitionY == y else arr2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1"},{"question":"def print_diamond(n): Returns an ASCII representation of a diamond of height n. The height n is an odd number greater than 0. >>> print_diamond(1) \\"*\\" >>> print_diamond(3) \\" * n***n * \\" >>> print_diamond(5) \\" * n *** n*****n *** n * \\" >>> print_diamond(7) \\" * n *** n ***** n*******n ***** n *** n * \\"","solution":"def print_diamond(n): Returns an ASCII representation of a diamond of height n. The height n is an odd number greater than 0. if n <= 0 or n % 2 == 0: raise ValueError(\\"Height n must be an odd number greater than 0.\\") diamond = [] midpoint = n // 2 # Generate the upper part including the middle row for i in range(midpoint + 1): spaces = ' ' * (midpoint - i) stars = '*' * (2 * i + 1) diamond.append(spaces + stars + spaces) # Generate the lower part of the diamond for i in range(midpoint - 1, -1, -1): spaces = ' ' * (midpoint - i) stars = '*' * (2 * i + 1) diamond.append(spaces + stars + spaces) return \\"n\\".join(diamond)"},{"question":"def infer_type(equation: str) -> str: Infers the type of the result of a given mathematical equation. Assumes all variables represent real numbers. Args: equation (str): The mathematical equation as a string. Returns: str: \\"int\\" if the result is an integer, \\"real\\" otherwise. Examples: >>> infer_type(\\"3 + 5\\") == \\"int\\" >>> infer_type(\\"4 / 2\\") == \\"int\\" >>> infer_type(\\"4 / 3\\") == \\"real\\" >>> infer_type(\\"x * y\\") == \\"real\\" >>> infer_type(\\"2^3\\") == \\"int\\" >>> infer_type(\\"2^3.5\\") == \\"real\\" >>> infer_type(\\"a / b\\") == \\"real\\" >>> infer_type(\\"m + n\\") == \\"real\\" >>> infer_type(\\"5 + 3 * 2\\") == \\"int\\" >>> infer_type(\\"5 + 3 / 2\\") == \\"real\\"","solution":"def infer_type(equation: str) -> str: Infers the type of the result of a given mathematical equation. Assumes all variables represent real numbers. Args: equation (str): The mathematical equation as a string. Returns: str: \\"int\\" if the result is an integer, \\"real\\" otherwise. def is_integer(number): return int(number) == number try: # Replace exponentiation symbol for eval function compatibility equation = equation.replace('^', '**') # Evaluate the equation result = eval(equation) # Check if the result is an integer if is_integer(result): return \\"int\\" else: return \\"real\\" except: # Any exception due to variables or type errors default to real return \\"real\\""},{"question":"def manage_parks(n: int, m: int, initial_trees: List[int], operations: List[str]) -> List[int]: Perform operations on parks and return results for query operations. -----Input----- - The first line contains two space-separated integers n and m - the number of parks and the number of operations. - The second line contains n space-separated integers, where the i-th integer represents the initial number of trees in the i-th park. - Each of the next m lines describes an operation in one of the three formats mentioned above. -----Output----- For each \`query\` operation, output a single integer, the total number of trees in the specified range of parks. -----Example----- >>> manage_parks(5, 6, [2, 3, 1, 4, 5], [\\"add 2 3\\", \\"query 1 3\\", \\"remove 4 2\\", \\"query 3 5\\", \\"add 1 1\\", \\"query 1 5\\"]) [9, 8, 17] >>> manage_parks(3, 1, [5, 5, 5], [\\"query 2 2\\"]) [5] pass def test_example_case(): n = 5 m = 6 initial_trees = [2, 3, 1, 4, 5] operations = [ \\"add 2 3\\", \\"query 1 3\\", \\"remove 4 2\\", \\"query 3 5\\", \\"add 1 1\\", \\"query 1 5\\" ] expected_output = [9, 8, 17] assert manage_parks(n, m, initial_trees, operations) == expected_output def test_add_operation(): n = 3 m = 1 initial_trees = [1, 2, 3] operations = [\\"add 1 1\\"] expected_output = [] assert manage_parks(n, m, initial_trees, operations) == expected_output operations = [\\"add 1 1\\", \\"query 1 3\\"] expected_output = [7] assert manage_parks(n, m, initial_trees, operations) == expected_output def test_remove_operation(): n = 3 m = 1 initial_trees = [3, 3, 3] operations = [\\"remove 2 1\\"] expected_output = [] assert manage_parks(n, m, initial_trees, operations) == expected_output operations = [\\"remove 2 1\\", \\"query 1 3\\"] expected_output = [8] assert manage_parks(n, m, initial_trees, operations) == expected_output def test_remove_to_zero(): n = 3 m = 1 initial_trees = [3, 3, 3] operations = [\\"remove 2 4\\"] expected_output = [] assert manage_parks(n, m, initial_trees, operations) == expected_output operations = [\\"remove 2 4\\", \\"query 1 3\\"] expected_output = [6] assert manage_parks(n, m, initial_trees, operations) == expected_output def test_query_single_park(): n = 3 m = 1 initial_trees = [5, 5, 5] operations = [\\"query 2 2\\"] expected_output = [5] assert manage_parks(n, m, initial_trees, operations) == expected_output","solution":"def manage_parks(n, m, initial_trees, operations): parks = initial_trees[:] result = [] for op in operations: parts = op.split() if parts[0] == 'add': p, x = int(parts[1]), int(parts[2]) parks[p - 1] += x elif parts[0] == 'remove': p, x = int(parts[1]), int(parts[2]) parks[p - 1] = max(0, parks[p - 1] - x) elif parts[0] == 'query': l, r = int(parts[1]), int(parts[2]) total = sum(parks[l - 1: r]) result.append(total) return result"},{"question":"from typing import List def donations(donations_list: List[int]) -> int: Calculate the minimum additional dollars required to make the sum of donations a multiple of 10. >>> donations([1, 2, 3]) 4 >>> donations([10, 20, 30]) 0 >>> donations([5, 5, 5, 5]) 0 >>> donations([9, 1, 1]) 9 >>> donations([]) -1","solution":"def donations(donations_list): Calculate the minimum additional dollars required to make the sum of donations a multiple of 10. if not donations_list: return -1 total = sum(donations_list) remainder = total % 10 return 0 if remainder == 0 else 10 - remainder"},{"question":"def shortest_substring(s: str) -> int: Determine the length of the shortest substring of \`s\` that contains all unique characters present in \`s\`. >>> shortest_substring(\\"abbcac\\") 3 >>> shortest_substring(\\"abcabcbb\\") 3 >>> shortest_substring(\\"aabcbcdbca\\") 4 >>> shortest_substring(\\"aaaaaa\\") 1 >>> shortest_substring(\\"abcdef\\") 6 >>> shortest_substring(\\"abbcabc\\") 3 >>> shortest_substring(\\"abcdefg\\") 7","solution":"def shortest_substring(s: str) -> int: Returns the length of the shortest substring containing all unique characters from the original string \`s\`. unique_chars = set(s) required_chars = len(unique_chars) n = len(s) min_length = float('inf') char_count = {} left = 0 num_unique = 0 for right in range(n): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 num_unique += 1 while num_unique == required_chars: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] num_unique -= 1 left += 1 return min_length"},{"question":"def submatrix_sum_exists(matrix: List[List[int]], queries: List[int]) -> List[str]: Determine if there exists a submatrix such that the sum of all its elements is equal to a given target. >>> submatrix_sum_exists([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [15, 1, 100]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> submatrix_sum_exists([[5]], [5, 1, 10]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> submatrix_sum_exists([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]], [-15, -1, 100]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> submatrix_sum_exists([[1, 2, 3], [3, 2, 1], [4, 5, 6]], [15, 21, 100]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> submatrix_sum_exists([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [0, 1, -1]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def submatrix_sum_exists(matrix, queries): def calculate_prefix_sums(matrix): m, n = len(matrix), len(matrix[0]) prefix_sums = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sums[i][j] = (matrix[i - 1][j - 1] + prefix_sums[i - 1][j] + prefix_sums[i][j - 1] - prefix_sums[i - 1][j - 1]) return prefix_sums def submatrix_sum(prefix_sums, x1, y1, x2, y2): return (prefix_sums[x2 + 1][y2 + 1] - prefix_sums[x1][y2 + 1] - prefix_sums[x2 + 1][y1] + prefix_sums[x1][y1]) m = len(matrix) n = len(matrix[0]) prefix_sums = calculate_prefix_sums(matrix) results = [] for target in queries: found = False for x1 in range(m): for y1 in range(n): for x2 in range(x1, m): for y2 in range(y1, n): if submatrix_sum(prefix_sums, x1, y1, x2, y2) == target: found = True break if found: break if found: break if found: break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def repeat_elements(arr, n): Takes in an array of integers and returns a new array with each element repeated n times. If the input is not an array of integers, returns \\"Input is not an array of integers\\". If the input array contains non-integer elements, returns \\"Input array contains non-integer elements\\". Arguments: arr: list of integers n: integer, number of times to repeat each element Returns: list of integers or str","solution":"def repeat_elements(arr, n): Takes in an array of integers and returns a new array with each element repeated n times. If the input is not an array of integers, returns \\"Input is not an array of integers\\". If the input array contains non-integer elements, returns \\"Input array contains non-integer elements\\". Arguments: arr: list of integers n: integer, number of times to repeat each element Returns: list of integers or str # Check if arr is a list if not isinstance(arr, list): return \\"Input is not an array of integers\\" # Check if all elements in the list are integers for element in arr: if not isinstance(element, int): return \\"Input array contains non-integer elements\\" # Repeat each element in the array n times result = [] for element in arr: result.extend([element] * n) return result"},{"question":"import numpy as np from typing import List, Tuple def most_consistent_reader(records: List[Tuple[str, List[int]]]) -> str: Determines the most consistent reader based on the variance of pages read each month. Args: records (list of tuples): each tuple contains a participant's name and a list of integers representing their monthly reading progress. Returns: str: The name of the most consistent reader. Examples: >>> most_consistent_reader([(\\"Alice\\", [100, 200, 150, 100]), (\\"Bob\\", [150, 150, 150, 150]), (\\"Charlie\\", [95, 99, 102, 98])]) \\"Bob\\" >>> most_consistent_reader([(\\"Dave\\", [120, 130, 140, 150]), (\\"Eve\\", [145, 150, 155, 148]), (\\"Frank\\", [200, 190, 180, 170])]) \\"Eve\\" >>> most_consistent_reader([(\\"Grace\\", [100, 110, 105, 115]), (\\"Hank\\", [50, 55, 53, 60]), (\\"Ivy\\", [75, 80, 78, 90])]) \\"Hank\\" def test_most_consistent_reader_example1(): records = [(\\"Alice\\", [100, 200, 150, 100]), (\\"Bob\\", [150, 150, 150, 150]), (\\"Charlie\\", [95, 99, 102, 98])] assert most_consistent_reader(records) == \\"Bob\\" def test_most_consistent_reader_example2(): records = [(\\"Dave\\", [120, 130, 140, 150]), (\\"Eve\\", [145, 150, 155, 148]), (\\"Frank\\", [200, 190, 180, 170])] assert most_consistent_reader(records) == \\"Eve\\" def test_most_consistent_reader_example3(): records = [(\\"Grace\\", [100, 110, 105, 115]), (\\"Hank\\", [50, 55, 53, 60]), (\\"Ivy\\", [75, 80, 78, 90])] assert most_consistent_reader(records) == \\"Hank\\" def test_most_consistent_reader_single_participant(): records = [(\\"Jack\\", [120, 125, 130, 128, 127, 135, 140, 120, 123, 129, 131, 128])] assert most_consistent_reader(records) == \\"Jack\\" def test_most_consistent_reader_var_tiebreaker(): records = [(\\"Tim\\", [150, 150, 150, 155]), (\\"Sara\\", [150, 150, 150, 150])] assert most_consistent_reader(records) == \\"Sara\\" def test_most_consistent_reader_total_pages_tiebreaker(): records = [(\\"Bob\\", [120, 140, 130, 140]), (\\"Alice\\", [120, 135, 130, 140])] assert most_consistent_reader(records) == \\"Alice\\" def test_most_consistent_reader_alphabetical_tiebreaker(): records = [(\\"Carol\\", [100, 105, 110, 115]), (\\"Bob\\", [100, 105, 110, 115])] assert most_consistent_reader(records) == \\"Bob\\"","solution":"import numpy as np def most_consistent_reader(records): Determines the most consistent reader based on the variance of pages read each month. Args: records (list of tuples): each tuple contains a participant's name and a list of integers representing their monthly reading progress. Returns: str: The name of the most consistent reader. def variance(pages): Calculates the variance of a list of integers. return np.var(pages) def total_pages(pages): Calculates the total number of pages read. return sum(pages) # Initialize the best reader with default values best_reader = None lowest_variance = float('inf') highest_total_pages = -1 for name, pages in records: var = variance(pages) total = total_pages(pages) if (var < lowest_variance or (var == lowest_variance and total > highest_total_pages) or (var == lowest_variance and total == highest_total_pages and (best_reader is None or name < best_reader))): lowest_variance = var highest_total_pages = total best_reader = name return best_reader"},{"question":"def expected_packs(N: int) -> float: Calculate the expected number of packs Alice will need to open to complete her collection of N stickers. >>> expected_packs(1) == 1.00000 >>> expected_packs(2) == 3.00000 >>> expected_packs(5) == 11.41667","solution":"def expected_packs(N): Calculate the expected number of packs Alice will need to open to complete her collection of N stickers. if N <= 0: return 0.0 expected_value = 0.0 for k in range(1, N + 1): expected_value += N / k return round(expected_value, 5)"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of the words in a given sentence while retaining punctuation and capitalization. >>> reverse_words(\\"Hello world\\") \\"world Hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\"","solution":"def reverse_words(sentence): Reverses the order of the words in a given sentence while retaining punctuation and capitalization. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def string_permutations(s: str) -> int: Takes a string \`s\` as input and returns the number of unique permutations of the characters in the string. >>> string_permutations(\\"abc\\") 6 >>> string_permutations(\\"aab\\") 3","solution":"from math import factorial from collections import Counter def string_permutations(s: str) -> int: Returns the number of unique permutations of the characters in the string \`s\`. count = Counter(s) result = factorial(len(s)) for v in count.values(): result //= factorial(v) return result"},{"question":"def count_unique_students(n, science_students, m, math_students): Returns the count of unique students who have joined at least one club. Parameters: n (int): The number of students who joined the Science Club. science_students (list of int): The list of student roll numbers in the Science Club. m (int): The number of students who joined the Math Club. math_students (list of int): The list of student roll numbers in the Math Club. Returns: int: The total number of unique students. # Your code here # Test cases def test_all_unique(): assert count_unique_students(3, [1, 2, 3], 3, [4, 5, 6]) == 6 def test_some_overlap(): assert count_unique_students(3, [1, 2, 3], 3, [3, 4, 5]) == 5 def test_all_same(): assert count_unique_students(3, [1, 2, 3], 3, [1, 2, 3]) == 3 def test_empty_science(): assert count_unique_students(0, [], 3, [7, 8, 9]) == 3 def test_empty_math(): assert count_unique_students(3, [10, 11, 12], 0, []) == 3 def test_no_students(): assert count_unique_students(0, [], 0, []) == 0 def test_single_student(): assert count_unique_students(1, [13], 1, [13]) == 1","solution":"def count_unique_students(n, science_students, m, math_students): Returns the count of unique students who have joined at least one club. Parameters: n (int): The number of students who joined the Science Club. science_students (list of int): The list of student roll numbers in the Science Club. m (int): The number of students who joined the Math Club. math_students (list of int): The list of student roll numbers in the Math Club. Returns: int: The total number of unique students. science_set = set(science_students) math_set = set(math_students) unique_students = science_set.union(math_set) return len(unique_students)"},{"question":"from typing import List def count_paths(matrix: List[List[str]]) -> int: Determine the number of different ways to move from the top-left corner to the bottom-right corner of the matrix, moving down or right, and avoiding obstacles. >>> count_paths([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 2 >>> count_paths([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 6 >>> count_paths([ ... ['.', '#', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 1 >>> count_paths([ ... ['#', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 0 >>> count_paths([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '#'] ... ]) 0 >>> count_paths([['.']]) 1 >>> count_paths([ ... ['.', '.', '.', '.', '.'], ... ['.', '.', '#', '.', '.'], ... ['.', '#', '.', '.', '.'], ... ['.', '.', '.', '#', '.'], ... ['.', '.', '.', '.', '.'] ... ]) 6","solution":"from typing import List def count_paths(matrix: List[List[str]]) -> int: n = len(matrix) m = len(matrix[0]) if matrix[0][0] == '#' or matrix[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if matrix[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def char_frequency(s: str): Process a string and calculate the frequency of each character in the string. Disregards case sensitivity and ignores non-alphabetic characters. Args: s (str): Input string Returns: list: List of tuples containing characters and their frequencies in alphabetical order. Examples: >>> char_frequency(\\"Hello, World!\\") [('d', 1), ('e', 1), ('h', 1), ('l', 3), ('o', 2), ('r', 1), ('w', 1)] >>> char_frequency(\\"Programming is fun!\\") [('a', 1), ('f', 1), ('g', 2), ('i', 2), ('m', 2), ('n', 2), ('o', 1), ('p', 1), ('r', 2), ('s', 1), ('u', 1)] from solution import char_frequency def test_char_frequency_example1(): input_string = \\"Hello, World!\\" output = [('d', 1), ('e', 1), ('h', 1), ('l', 3), ('o', 2), ('r', 1), ('w', 1)] assert char_frequency(input_string) == output def test_char_frequency_example2(): input_string = \\"Programming is fun!\\" output = [('a', 1), ('f', 1), ('g', 2), ('i', 2), ('m', 2), ('n', 2), ('o', 1), ('p', 1), ('r', 2), ('s', 1), ('u', 1)] assert char_frequency(input_string) == output def test_char_frequency_empty(): input_string = \\"\\" output = [] assert char_frequency(input_string) == output def test_char_frequency_uppercase(): input_string = \\"AaBbCc\\" output = [('a', 2), ('b', 2), ('c', 2)] assert char_frequency(input_string) == output def test_char_frequency_ignore_non_alpha(): input_string = \\"123!@#\\" output = [] assert char_frequency(input_string) == output def test_char_frequency_mixed_alphabets_and_digits(): input_string = \\"a1b2c3\\" output = [('a', 1), ('b', 1), ('c', 1)] assert char_frequency(input_string) == output","solution":"def char_frequency(s): Process a string and calculates the frequency of each character in the string. Disregards case sensitivity and ignores non-alphabetic characters. Args: s (str): Input string Returns: list: List of tuples containing characters and their frequencies in alphabetical order. # Filter out non-alphabetic characters and convert to lowercase filtered_string = ''.join([char.lower() for char in s if char.isalpha()]) # Calculate the frequency of each character frequency_dict = {} for char in filtered_string: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 # Return the sorted list of tuples return sorted(frequency_dict.items())"},{"question":"from typing import List def longest_word_chain(words: List[str]) -> int: Find the length of the longest word chain from a list of words. >>> longest_word_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) == 4 >>> longest_word_chain([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == 1 >>> longest_word_chain([\\"abcd\\"]) == 1 >>> longest_word_chain([\\"a\\", \\"ba\\", \\"bca\\", \\"bdca\\", \\"e\\", \\"de\\", \\"cde\\", \\"bcde\\"]) == 4 >>> longest_word_chain([\\"abcd\\", \\"abce\\", \\"abcf\\", \\"abcf\\"]) == 1 >>> longest_word_chain([\\"a\\", \\"b\\", \\"ab\\", \\"abc\\", \\"abd\\", \\"abdc\\", \\"abdec\\"]) == 5","solution":"from typing import List def longest_word_chain(words: List[str]) -> int: words.sort(key=len) chain_lengths = {} def differ_by_one_letter(w1, w2): if len(w1) != len(w2): return False count = sum(1 for a, b in zip(w1, w2) if a != b) return count == 1 max_chain_length = 1 for word in words: chain_lengths[word] = 1 for i in range(len(word)): prev_word = word[:i] + word[i+1:] if prev_word in chain_lengths: chain_lengths[word] = max(chain_lengths[word], chain_lengths[prev_word] + 1) max_chain_length = max(max_chain_length, chain_lengths[word]) return max_chain_length"},{"question":"def minCost(matrix): Given a 2D matrix of dimensions MxN, you are initially at the top-left corner of the matrix (position (0,0)). Each cell in the matrix contains a non-negative integer which represents the cost to traverse that cell. Your task is to find the minimum cost to travel from the top-left corner to the bottom-right corner of the matrix. You can only move right or down at each step. Args: matrix (List[List[int]]): A 2D matrix of dimensions MxN where 1 ≤ M, N ≤ 1000 and each cell contains a non-negative integer. Returns: int: The minimum cost to reach the bottom-right corner of the matrix. >>> minCost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minCost([[1, 2, 3, 4]]) 10 >>> minCost([[1], [2], [3], [4]]) 10 >>> minCost([[5]]) 5 >>> minCost([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> minCost([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) 10 pass","solution":"def minCost(matrix): Returns the minimum cost to travel from the top-left corner to the bottom-right corner of the matrix. if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) cost = [[0]*N for _ in range(M)] cost[0][0] = matrix[0][0] # Initialize the first row and first column for i in range(1, M): cost[i][0] = cost[i-1][0] + matrix[i][0] for j in range(1, N): cost[0][j] = cost[0][j-1] + matrix[0][j] # Fill the rest of the cost matrix for i in range(1, M): for j in range(1, N): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + matrix[i][j] return cost[-1][-1]"},{"question":"def sum_of_squares(n: int) -> int: Calculate the sum of the squares of the first N natural numbers. >>> sum_of_squares(3) 14 >>> sum_of_squares(5) 55 >>> sum_of_squares(1) 1 >>> sum_of_squares(10) 385 >>> sum_of_squares(0) # Expect an error to be raised Traceback (most recent call last): ... ValueError: n should be 1 or greater","solution":"def sum_of_squares(n): Returns the sum of the squares of all natural numbers from 1 to n. if n < 1: raise ValueError(\\"n should be 1 or greater\\") return n * (n + 1) * (2 * n + 1) // 6"},{"question":"def solve(s: str) -> int: Given a string, return the length of the longest substring that contains only unique characters. >>> solve(\\"abcabcbb\\") 3 >>> solve(\\"bbbbb\\") 1 >>> solve(\\"pwwkew\\") 3 >>> solve(\\"aab\\") 2","solution":"def solve(s): Returns the length of the longest substring that contains only unique characters. char_index = {} longest = start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def analyze_data_transfers(transfers: List[Tuple[str, str, int]]) -> List[Tuple[str, int]]: Analyze data transfer activities to detect anomalies. Args: transfers (List[Tuple[str, str, int]]): A list of data transfer records, where each record is a tuple containing source IP, destination IP, and transferred data amount in MB. Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains a source IP and the corresponding total transferred data amount, sorted by the total transferred data amount in descending order, and by the source IP in ascending lexicographical order if two sources have the same total transferred data amount. Examples: >>> analyze_data_transfers([(\\"192.168.1.1\\", \\"10.0.0.1\\", 500), (\\"192.168.1.1\\", \\"10.0.0.2\\", 300), (\\"10.0.0.1\\", \\"192.168.1.1\\", 200), (\\"10.0.0.2\\", \\"192.168.1.1\\", 100)]) [(\\"192.168.1.1\\", 800), (\\"10.0.0.1\\", 200), (\\"10.0.0.2\\", 100)] >>> analyze_data_transfers([(\\"192.168.1.2\\", \\"10.0.0.1\\", 300), (\\"192.168.1.3\\", \\"10.0.0.1\\", 300), (\\"192.168.1.1\\", \\"10.0.0.1\\", 300)]) [(\\"192.168.1.1\\", 300), (\\"192.168.1.2\\", 300), (\\"192.168.1.3\\", 300)] >>> analyze_data_transfers([(\\"192.168.1.1\\", \\"10.0.0.1\\", 50)]) [(\\"192.168.1.1\\", 50)] >>> analyze_data_transfers([]) [] >>> analyze_data_transfers([(\\"192.168.1.1\\", \\"10.0.0.1\\", 500), (\\"192.168.1.1\\", \\"10.0.0.2\\", 300), (\\"192.168.1.1\\", \\"10.0.0.3\\", 200), (\\"10.0.0.1\\", \\"192.168.1.1\\", 400), (\\"10.0.0.1\\", \\"192.168.1.1\\", 100)]) [(\\"192.168.1.1\\", 1000), (\\"10.0.0.1\\", 500)] pass","solution":"def analyze_data_transfers(transfers): from collections import defaultdict # Dictionary to store the total transferred data per source IP data_transfer_summary = defaultdict(int) for source_ip, destination_ip, data_amount in transfers: data_transfer_summary[source_ip] += data_amount # Convert the dictionary to a list of tuples for sorting summary_list = list(data_transfer_summary.items()) # Sort the list by total transferred data in descending order, # and by source IP in ascending lexicographical order if equal summary_list.sort(key=lambda x: (-x[1], x[0])) return summary_list"},{"question":"def snake_case_converter(text: str) -> str: Converts a camelCase string into a snake_case string. Params: - text (str): The camelCase string to convert. Returns: - str: The corresponding snake_case string. Examples: >>> snake_case_converter(\\"thisIsCamelCase\\") 'this_is_camel_case' >>> snake_case_converter(\\"helloWorld\\") 'hello_world' >>> snake_case_converter(\\"convertMeToSnakeCase\\") 'convert_me_to_snake_case'","solution":"def snake_case_converter(text): Converts a camelCase string into a snake_case string. Params: - text (str): The camelCase string to convert. Returns: - str: The corresponding snake_case string. snake_case_text = \\"\\" for char in text: if char.isupper(): snake_case_text += \\"_\\" + char.lower() else: snake_case_text += char return snake_case_text"},{"question":"def words_length(words): Returns a dictionary where the keys are words and the values are their lengths. >>> words_length(['apple', 'banana', 'cherry']) {'apple': 5, 'banana': 6, 'cherry': 6} >>> words_length(['a', 'bb', 'ccc']) {'a': 1, 'bb': 2, 'ccc': 3} >>> words_length([]) {} >>> words_length(None) {} >>> words_length(['pear']) {'pear': 4} >>> words_length(['apple', 'apple', 'banana']) {'apple': 5, 'banana': 6}","solution":"def words_length(words): Returns a dictionary where the keys are words and the values are their lengths. if words is None or not words: return {} return {word: len(word) for word in words}"},{"question":"def maxHours(balloonCounts: list) -> int: Returns the maximum number of hours for which you can pop exactly two balloons of different colors. :param balloonCounts: A list containing the counts of red, blue, and yellow balloons respectively. :return: Maximum number of hours you can continue popping balloons. >>> maxHours([2, 1, 1]) == 2 >>> maxHours([3, 3, 3]) == 4 >>> maxHours([1, 1, 2]) == 2","solution":"def maxHours(balloonCounts: list) -> int: Returns the maximum number of hours for which you can pop exactly two balloons of different colors. :param balloonCounts: A list containing the counts of red, blue, and yellow balloons respectively. :return: Maximum number of hours you can continue popping balloons. # Sort the balloon counts balloonCounts.sort() if balloonCounts[0] + balloonCounts[1] <= balloonCounts[2]: return balloonCounts[0] + balloonCounts[1] else: return sum(balloonCounts) // 2 # Example Usage # print(maxHours([2, 1, 1])) # Output: 2 # print(maxHours([3, 3, 3])) # Output: 4 # print(maxHours([1, 1, 2])) # Output: 2"},{"question":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome that can be created by appending characters at the end of the input string. >>> shortest_palindrome(\\"abca\\") \\"abcacba\\" >>> shortest_palindrome(\\"a\\") \\"a\\" >>> shortest_palindrome(\\"race\\") \\"racecar\\"","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be created by appending characters at the end of the input string. n = len(s) for i in range(n): if s[i:] == s[i:][::-1]: return s + s[:i][::-1] return s # Example execution: The output should be \\"abcacba\\" for the input \\"abca\\" # print(shortest_palindrome(\\"abca\\"))"},{"question":"def calculate_prime_product(n: int) -> int: Calculate the product of all prime numbers (excluding itself) that exactly divide a given number \`n\`. >>> calculate_prime_product(30) == 30 >>> calculate_prime_product(60) == 30 >>> calculate_prime_product(97) == 1 >>> calculate_prime_product(100) == 10 >>> calculate_prime_product(13) == 1","solution":"def calculate_prime_product(n: int) -> int: Calculate the product of all prime numbers (excluding itself) that exactly divide a given number \`n\`. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime_factors = set() original_n = n # Check for smallest prime factors for i in range(2, n + 1): if n % i == 0 and is_prime(i): prime_factors.add(i) while n % i == 0: n //= i if n == 1: break # Calculate the product of prime factors if not prime_factors or original_n in prime_factors: return 1 product = 1 for prime in prime_factors: product *= prime return product"},{"question":"from typing import List def count_islands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the given grid. An island is defined as a group of adjacent land cells, connected horizontally or vertically. Args: grid (List[List[int]]): A two-dimensional array representing the grid, where 1 represents land and 0 represents water. Returns: int: The number of distinct islands. Examples: >>> count_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ]) 3 >>> count_islands([ ... [1, 1, 0, 1, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 1, 1, 1], ... [1, 0, 0, 0, 0] ... ]) 4 >>> count_islands([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 0 >>> count_islands([ ... [1] ... ]) 1 >>> count_islands([ ... [0] ... ]) 0 >>> count_islands([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 >>> count_islands([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 3","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: def dfs(x, y): # If out of bounds or at water cell, return if x < 0 or x >= H or y < 0 or y >= W or grid[x][y] == 0: return # Mark the cell as visited by setting it to 0 grid[x][y] = 0 # Perform in all four directions dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) if not grid: return 0 H = len(grid) W = len(grid[0]) island_count = 0 for i in range(H): for j in range(W): if grid[i][j] == 1: island_count += 1 dfs(i, j) return island_count"},{"question":"def apply_discounts(cart, discounts): Applies discounts to the shopping cart and returns the total price. Parameters: cart (list of tuples): A list where each tuple contains the product name, quantity, and price per unit. discounts (dict): A dictionary with product names as keys and discount functions as values. Returns: float: Total price of the cart after applying discounts, rounded to 2 decimal places. pass # Example usage and test cases cart = [ (\\"apple\\", 3, 1.0), (\\"banana\\", 2, 0.5), (\\"milk\\", 2, 1.5) ] discounts = { \\"apple\\": lambda qty, price: qty * price * 0.9, \\"milk\\": lambda qty, price: (qty // 2) * 1.5 } assert apply_discounts(cart, discounts) == 5.70 # Example test case def test_apply_discounts_no_discounts(): cart = [(\\"apple\\", 3, 1.0), (\\"banana\\", 2, 0.5)] discounts = {} assert apply_discounts(cart, discounts) == 4.0 def test_apply_discounts_with_discounts(): cart = [(\\"apple\\", 3, 1.0), (\\"banana\\", 2, 0.5), (\\"milk\\", 2, 1.5)] discounts = { \\"apple\\": lambda qty, price: qty * price * 0.9, \\"milk\\": lambda qty, price: (qty // 2) * 1.5 } assert apply_discounts(cart, discounts) == 5.20 def test_apply_discounts_empty_cart(): cart = [] discounts = { \\"apple\\": lambda qty, price: qty * price * 0.9, } assert apply_discounts(cart, discounts) == 0.0 def test_apply_discounts_zero_quantity(): cart = [(\\"apple\\", 0, 1.0)] discounts = { \\"apple\\": lambda qty, price: qty * price * 0.9, } assert apply_discounts(cart, discounts) == 0.0 def test_apply_discounts_non_discounted_product(): cart = [(\\"chocolate\\", 5, 2.0)] discounts = { \\"apple\\": lambda qty, price: qty * price * 0.9, } assert apply_discounts(cart, discounts) == 10.0","solution":"def apply_discounts(cart, discounts): Applies discounts to the shopping cart and returns the total price. Parameters: cart (list of tuples): A list where each tuple contains the product name, quantity, and price per unit. discounts (dict): A dictionary with product names as keys and discount functions as values. Returns: float: Total price of the cart after applying discounts, rounded to 2 decimal places. total_price = 0 for item in cart: product, quantity, price_per_unit = item if product in discounts: discounted_price = discounts[product](quantity, price_per_unit) else: discounted_price = quantity * price_per_unit total_price += discounted_price return round(total_price, 2)"},{"question":"def group_consecutive_chars(s: str) -> str: Given a string, groups all the identical consecutive characters together. >>> group_consecutive_chars('aaabbccccd') '3a2b4c1d' >>> group_consecutive_chars('') '' >>> group_consecutive_chars('a') '1a' >>> group_consecutive_chars('abcd') '1a1b1c1d' >>> group_consecutive_chars('aaaa') '4a' >>> group_consecutive_chars('aabbcc') '2a2b2c' # Unit Test def test_group_consecutive_chars_example1(): assert group_consecutive_chars('aaabbccccd') == '3a2b4c1d' def test_group_consecutive_chars_empty_string(): assert group_consecutive_chars('') == '' def test_group_consecutive_chars_single_char(): assert group_consecutive_chars('a') == '1a' def test_group_consecutive_chars_different_chars(): assert group_consecutive_chars('abcd') == '1a1b1c1d' def test_group_consecutive_chars_same_chars(): assert group_consecutive_chars('aaaa') == '4a' def test_group_consecutive_chars_mixed_chars(): assert group_consecutive_chars('aabbcc') == '2a2b2c' def test_group_consecutive_chars_large_input(): assert group_consecutive_chars('a' * 10**5) == '100000a'","solution":"def group_consecutive_chars(s): if not s: return \\"\\" grouped = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: grouped.append(f\\"{count}{s[i - 1]}\\") count = 1 grouped.append(f\\"{count}{s[-1]}\\") return ''.join(grouped)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression given as a string containing only non-negative integers, plus signs ('+'), minus signs ('-'), times signs ('*'), and divide signs ('/'). Ignores spaces. Operations are performed respecting the standard operator precedence. >>> evaluate_expression(\\"3+2 * 2\\") == 7 >>> evaluate_expression(\\" 3/2 \\") == 1 >>> evaluate_expression(\\"3+5 / 2\\") == 5","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression given as a string containing only non-negative integers, plus signs ('+'), minus signs ('-'), times signs ('*'), and divide signs ('/'). Ignores spaces. Operations are performed respecting the standard operator precedence. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(int(a / b)) # use int() for floor division expression = expression.replace(' ', '') # Remove spaces n = len(expression) operands = [] operators = [] i = 0 while i < n: if expression[i].isdigit(): num = 0 while i < n and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) else: while (operators and operators[-1] in \\"*/\\" and expression[i] in \\"+-*/\\"): apply_operator(operands, operators.pop()) if expression[i] in \\"*/\\": while (operators and operators[-1] in \\"*/\\"): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def count_rectangles(N: int, M: int, points: List[Tuple[int, int]]) -> int: Count the number of rectangles that can be formed using the given points as vertices. Args: N: An integer representing the number of rows in the grid. M: An integer representing the number of columns in the grid. points: A list of tuples where each tuple contains the coordinates of a point (x, y). Returns: An integer representing the number of rectangles that can be formed. Example: >>> count_rectangles(4, 4, [(1, 1), (1, 3), (3, 1), (3, 3), (2, 2)]) 1","solution":"def count_rectangles(N, M, points): from collections import defaultdict # Create a set of points for quick lookup points_set = set(points) # Create a defaultdict of columns for each row row_to_cols = defaultdict(set) for x, y in points: row_to_cols[x].add(y) num_rectangles = 0 # Iterate over pairs of rows rows = sorted(row_to_cols.keys()) for i in range(len(rows)): for j in range(i + 1, len(rows)): row1, row2 = rows[i], rows[j] common_columns = row_to_cols[row1].intersection(row_to_cols[row2]) # Common columns are sorted common_columns = sorted(common_columns) if len(common_columns) < 2: continue # Count rectangles formed by pairs of columns in the common_columns for k in range(len(common_columns)): for l in range(k+1, len(common_columns)): y1 = common_columns[k] y2 = common_columns[l] if (row1, y1) in points_set and (row1, y2) in points_set and (row2, y1) in points_set and (row2, y2) in points_set: num_rectangles += 1 return num_rectangles"},{"question":"def longest_consecutive_ones(arr): Returns the length of the longest sequence of consecutive ones in the binary array. >>> longest_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> longest_consecutive_ones([0, 0, 0, 0]) 0 >>> longest_consecutive_ones([1, 1, 1, 1]) 4 >>> longest_consecutive_ones([1, 0, 0, 1, 1, 0, 1]) 2 >>> longest_consecutive_ones([1, 0, 1, 1, 0, 1, 1, 1, 0]) 3 >>> longest_consecutive_ones([0]) 0 >>> longest_consecutive_ones([1]) 1","solution":"def longest_consecutive_ones(arr): Returns the length of the longest sequence of consecutive ones in the binary array. max_length = 0 current_length = 0 for num in arr: if num == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def anagram_finder(word_list): Returns a dictionary of anagrams from the given list of words. >>> anagram_finder([\\"cat\\", \\"tac\\", \\"act\\", \\"dog\\", \\"god\\"]) == { \\"act\\": [\\"cat\\", \\"tac\\", \\"act\\"], \\"dgo\\": [\\"dog\\", \\"god\\"] } >>> anagram_finder([\\"Cat\\", \\"tac\\", \\"ACT\\", \\"dog\\", \\"God\\"]) == { \\"act\\": [\\"Cat\\", \\"tac\\", \\"ACT\\"], \\"dgo\\": [\\"dog\\", \\"God\\"] } >>> anagram_finder([]) == {} >>> anagram_finder([\\"apple\\", \\"banana\\", \\"carrot\\"]) == { \\"aelpp\\": [\\"apple\\"], \\"aaabnn\\": [\\"banana\\"], \\"acorrt\\": [\\"carrot\\"] } >>> anagram_finder([\\"a\\", \\"b\\", \\"aa\\", \\"bb\\", \\"ab\\", \\"ba\\"]) == { \\"a\\": [\\"a\\"], \\"b\\": [\\"b\\"], \\"aa\\": [\\"aa\\"], \\"bb\\": [\\"bb\\"], \\"ab\\": [\\"ab\\", \\"ba\\"] }","solution":"def anagram_finder(word_list): Returns a dictionary of anagrams from the given list of words. anagram_dict = {} for word in word_list: sorted_letters = ''.join(sorted(word.lower())) if sorted_letters in anagram_dict: anagram_dict[sorted_letters].append(word) else: anagram_dict[sorted_letters] = [word] return anagram_dict"},{"question":"def intersection(arr1, arr2): Returns a list containing the unique elements that are present in both input lists. >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"def intersection(arr1, arr2): Returns a list containing the unique elements that are present in both input lists. set1 = set(arr1) set2 = set(arr2) intersection_set = set1.intersection(set2) return list(intersection_set)"},{"question":"def rotate(array, k): Rotates the elements of the array to the right by k steps. Handles edge cases where the array is empty, k is zero, and k is greater than the length of the array. >>> rotate([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate([], 3) [] >>> rotate([1, 2, 3], 0) [1, 2, 3] >>> rotate([1], 10) [1] >>> rotate([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2]","solution":"def rotate(array, k): Rotates the elements of the array to the right by k steps. Handles edge cases where the array is empty, k is zero, and k is greater than the length of the array. if not array: return [] n = len(array) k = k % n # Handle cases where k is greater than array length return array[-k:] + array[:-k]"},{"question":"def arrange_books(t: int, test_cases: List[int]) -> List[List[int]]: For each test case, given an integer n, determine an arrangement of books such that no two books' labels are relatively prime. :param t: Number of test cases :param test_cases: List of integers representing the test cases :return: A list of lists, where each sublist is the arrangement for its respective test case >>> arrange_books(1, [2]) [[2, 4]] >>> arrange_books(1, [3]) [[2, 4, 6]] >>> arrange_books(1, [4]) [[2, 4, 6, 8]] >>> arrange_books(2, [1, 2]) [[2], [2, 4]] >>> arrange_books(3, [2, 3, 4]) [[2, 4], [2, 4, 6], [2, 4, 6, 8]]","solution":"def arrange_books(t, test_cases): For each test case, given an integer n, determine an arrangement of books such that no two books' labels are relatively prime. :param t: Number of test cases :param test_cases: List of integers representing the test cases :return: A list of lists, where each sublist is the arrangement for its respective test case arrangements = [] for n in test_cases: arrangement = [2 * (i + 1) for i in range(n)] arrangements.append(arrangement) return arrangements"},{"question":"def run_length_encode(s: str) -> str: Encodes the given string using Run-Length Encoding (RLE). Parameters: s (str): The input string consisting of only lowercase English alphabets. Returns: str: The RLE encoded string. >>> run_length_encode(\\"\\") '' >>> run_length_encode(\\"a\\") 'a1' >>> run_length_encode(\\"aaabbccaaa\\") 'a3b2c2a3' >>> run_length_encode(\\"aabbccdd\\") 'a2b2c2d2' >>> run_length_encode(\\"abcdefgh\\") 'a1b1c1d1e1f1g1h1' >>> run_length_encode(\\"a\\" * 1000000) 'a1000000'","solution":"def run_length_encode(s): Encodes the given string using Run-Length Encoding (RLE). Parameters: s (str): The input string consisting of only lowercase English alphabets. Returns: str: The RLE encoded string. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Append the last character and its count encoded_string.append(current_char + str(count)) return ''.join(encoded_string)"},{"question":"def firstUniqChar(s: str) -> int: Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. Examples: >>> firstUniqChar(\\"leetcode\\") 0 >>> firstUniqChar(\\"loveleetcode\\") 2 >>> firstUniqChar(\\"aabbcc\\") -1 >>> firstUniqChar(\\"abc\\") 0","solution":"def firstUniqChar(s): Returns the index of the first non-repeating character in the string s. If no such character exists, return -1. # Dictionary to count occurrences of each character count = {} # Populate the dictionary with counts for char in s: if char in count: count[char] += 1 else: count[char] = 1 # Find the first character with a count of 1 for index, char in enumerate(s): if count[char] == 1: return index # If no non-repeating character is found return -1"},{"question":"from typing import List, Tuple, Union def two_sum(nums: List[int], target: int) -> Union[Tuple[int, int], None]: Determine if there are any two distinct numbers in the array that add up to the target value. >>> two_sum([2, 7, 11, 15], 9) (2, 7) >>> two_sum([3, 2, 4], 6) (2, 4) >>> two_sum([1, 2, 3], 7) None","solution":"from typing import List, Tuple, Union def two_sum(nums: List[int], target: int) -> Union[Tuple[int, int], None]: num_dict = {} for num in nums: complement = target - num if complement in num_dict: return (complement, num) num_dict[num] = True return None"},{"question":"def extractDomain(email: str) -> str: Returns the domain part of the email address. >>> extractDomain(\\"user@example.com\\") 'example.com' >>> extractDomain(\\"admin@domain.org\\") 'domain.org' pass def extractDomainsFromList(emails: list[str]) -> list[str]: Returns a list of domains extracted from each email address in the input list. >>> extractDomainsFromList([\\"john.doe@mail.com\\", \\"alice@example.org\\", \\"bob@yahoo.com\\"]) ['mail.com', 'example.org', 'yahoo.com'] >>> extractDomainsFromList([]) [] >>> extractDomainsFromList([\\"single@domain.com\\"]) ['domain.com'] >>> extractDomainsFromList([ \\"example1@sub1.domain.com\\", \\"example2@sub2.domain.co.uk\\", \\"example3@sub3.example.edu\\" ]) ['sub1.domain.com', 'sub2.domain.co.uk', 'sub3.example.edu'] pass","solution":"def extractDomain(email): Returns the domain part of the email address. Parameters: email (str): The email address from which to extract the domain. Returns: str: The domain part of the email. return email.split('@')[1] def extractDomainsFromList(emails): Returns a list of domains extracted from each email address in the input list. Parameters: emails (list of str): List of email addresses from which to extract the domains. Returns: list of str: List of domains extracted from the email addresses. return [extractDomain(email) for email in emails]"},{"question":"def apply_operations(numbers: List[int], operations: List[Union[str, int]]) -> List[float]: Apply a sequence of operations to a list of numbers. Arguments: numbers -- a list of integers operations -- a list of alternating operator symbols and operands Returns: A new list of numbers after the operations have been applied. Examples: >>> apply_operations([4, 7, 2, 3], [\\"+\\", 2]) [6, 9, 4, 5] >>> apply_operations([4, 7, 2, 3], [\\"+\\", 2, \\"-\\", 1, \\"*\\", 3, \\"/\\", 2]) [7.5, 12.0, 4.5, 6.0]","solution":"def apply_operations(numbers, operations): Apply a sequence of operations to a list of numbers. Arguments: numbers -- a list of integers operations -- a list of alternating operator symbols and operands Returns: A new list of numbers after the operations have been applied. result = numbers[:] i = 0 while i < len(operations): op = operations[i] val = operations[i + 1] if op == '+': result = [x + val for x in result] elif op == '-': result = [x - val for x in result] elif op == '*': result = [x * val for x in result] elif op == '/': result = [x / val for x in result] i += 2 return result"},{"question":"def is_prime_digit(char): Returns True if the provided character represents a prime digit (2, 3, 5, 7), otherwise False. >>> is_prime_digit('2') True >>> is_prime_digit('4') False pass def all_prime_digits(num_str): Determines if all digits in the given string represent prime digits. >>> all_prime_digits(\\"235\\") \\"YES\\" >>> all_prime_digits(\\"124\\") \\"NO\\" pass def check_prime_digits(test_cases): Processes multiple test cases to determine if all the digits in each are prime digits. >>> check_prime_digits([\\"235\\", \\"124\\", \\"357\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_prime_digits([\\"20\\", \\"30\\", \\"50\\", \\"70\\"]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"] pass","solution":"def is_prime_digit(char): Returns True if the provided character represents a prime digit (2, 3, 5, 7), otherwise False. return char in {'2', '3', '5', '7'} def all_prime_digits(num_str): Determines if all digits in the given string represent prime digits. for char in num_str: if not is_prime_digit(char): return \\"NO\\" return \\"YES\\" def check_prime_digits(test_cases): Processes multiple test cases to determine if all the digits in each are prime digits. results = [] for num_str in test_cases: results.append(all_prime_digits(num_str)) return results"},{"question":"from typing import List def square_primes(numbers: List[int]) -> List[int]: Write a function that takes a list of integers as input and returns the list with all prime numbers replaced by their squares. If no prime numbers are found in the list, the function should return the original list. >>> square_primes([4, 7, 10, 11]) [4, 49, 10, 121] >>> square_primes([1, 4, 6, 8]) [1, 4, 6, 8] pass def test_square_primes_with_primes(): assert square_primes([4, 7, 10, 11]) == [4, 49, 10, 121] def test_square_primes_with_no_primes(): assert square_primes([1, 4, 6, 8]) == [1, 4, 6, 8] def test_square_primes_all_primes(): assert square_primes([2, 3, 5, 7, 11]) == [4, 9, 25, 49, 121] def test_square_primes_mixed(): assert square_primes([0, 2, 4, 6, 3, 5]) == [0, 4, 4, 6, 9, 25] def test_square_primes_with_large(): numbers = [2, 3, 4, 5, 6, 23, 24, 25, 29] expected = [4, 9, 4, 25, 6, 529, 24, 25, 841] assert square_primes(numbers) == expected def test_square_primes_single_element(): assert square_primes([2]) == [4] def test_square_primes_no_elements(): assert square_primes([]) == []","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def square_primes(numbers: List[int]) -> List[int]: Returns a list with prime numbers replaced by their squares. return [x**2 if is_prime(x) else x for x in numbers]"},{"question":"def detect_fraudulent_activity(transactions: List[int], k: int, t: int) -> List[int]: Detect start indices of k consecutive transactions that cumulatively reach or exceed the given threshold t. :param transactions: List of transaction amounts :param k: Number of consecutive transactions to consider :param t: Threshold amount for the sum of k consecutive transactions :return: List of starting indices of k consecutive transactions that meet or exceed the threshold >>> detect_fraudulent_activity([100, 200, 150, 300, 400], 3, 600) [1, 2] >>> detect_fraudulent_activity([100, 200, 150], 3, 500) [] >>> detect_fraudulent_activity([200, 200, 200, 200], 2, 400) [0, 1, 2] >>> detect_fraudulent_activity([300, 500, 100, 900], 1, 400) [1, 3] >>> detect_fraudulent_activity([100, 150, 200, 250, 300], 10, 1000) [] >>> detect_fraudulent_activity([], 1, 10) [] >>> detect_fraudulent_activity([100, 100, 100, 100, 100], 5, 500) [0] pass","solution":"from typing import List def detect_fraudulent_activity(transactions: List[int], k: int, t: int) -> List[int]: Detect start indices of k consecutive transactions that cumulatively reach or exceed the given threshold t. :param transactions: List of transaction amounts :param k: Number of consecutive transactions to consider :param t: Threshold amount for the sum of k consecutive transactions :return: List of starting indices of k consecutive transactions that meet or exceed the threshold if k > len(transactions): return [] result = [] cumulative_sum = sum(transactions[:k]) for i in range(len(transactions) - k + 1): if i > 0: cumulative_sum = cumulative_sum - transactions[i - 1] + transactions[i + k - 1] if cumulative_sum >= t: result.append(i) return result"},{"question":"from typing import List def isValidWord(word: str) -> bool: Placeholder for the actual implementation of the validation function. # The actual implementation will check if the word is a valid English word. return word in {\\"apple\\", \\"bag\\", \\"bog\\", \\"bug\\"} def possibleValidWords(input_string: str) -> List[str]: Generate all possible valid words by replacing \`?\` placeholders with lowercase alphabetic characters. >>> possibleValidWords(\\"a?ple\\") [\\"apple\\"] >>> possibleValidWords(\\"b?g\\") [\\"bag\\", \\"bog\\", \\"bug\\"] >>> possibleValidWords(\\"z?z?z\\") [] >>> possibleValidWords(\\"a?c\\") [\\"abc\\", \\"acc\\", \\"aec\\", \\"arc\\"]","solution":"from typing import List import string def isValidWord(word: str) -> bool: Placeholder for the actual implementation of the validation function. # The actual implementation will check if the word is a valid English word. # This mock implementation always returns True for simplicity. # In a real scenario, this function should query a dictionary or use a library to verify word validity. return word in {\\"apple\\", \\"bag\\", \\"bog\\", \\"bug\\"} def generate_possible_words(input_string: str, idx: int, current_string: str, results: List[str]): if idx == len(input_string): if isValidWord(current_string): results.append(current_string) return if input_string[idx] == '?': for char in string.ascii_lowercase: generate_possible_words(input_string, idx + 1, current_string + char, results) else: generate_possible_words(input_string, idx + 1, current_string + input_string[idx], results) def possibleValidWords(input_string: str) -> List[str]: results = [] generate_possible_words(input_string, 0, \\"\\", results) return results"},{"question":"def min_adjacent_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of adjacent swaps needed to sort the array in non-decreasing order. >>> min_adjacent_swaps_to_sort([3, 1, 2]) 2 >>> min_adjacent_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort([6, 5, 4, 3, 2, 1]) 15 >>> min_adjacent_swaps_to_sort([1]) 0 >>> min_adjacent_swaps_to_sort([2, 1]) 1 >>> min_adjacent_swaps_to_sort([4, 3, 2, 1, 5]) 6","solution":"def min_adjacent_swaps_to_sort(arr): def bubble_sort(arr): swaps = 0 n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return swaps result = bubble_sort(arr[:]) return result"},{"question":"class NumberList: def __init__(self): self.numbers = [] self.max_numbers = [] def add_number(self, x): Adds a number to the list and updates the maximum number tracking. def get_max_number(self): Returns the current maximum number in the list. def process_queries(queries): Processes a list of queries and returns the results for '2' queries. >>> process_queries([[\\"1\\", \\"3\\"], [\\"1\\", \\"5\\"], [\\"2\\"], [\\"1\\", \\"10\\"], [\\"2\\"]]) [5, 10] >>> process_queries([[\\"1\\", \\"-3\\"], [\\"1\\", \\"-2\\"], [\\"2\\"], [\\"1\\", \\"-1\\"], [\\"2\\"]]) [-2, -1]","solution":"class NumberList: def __init__(self): self.numbers = [] self.max_numbers = [] def add_number(self, x): self.numbers.append(x) if not self.max_numbers or x >= self.max_numbers[-1]: self.max_numbers.append(x) else: self.max_numbers.append(self.max_numbers[-1]) def get_max_number(self): if not self.max_numbers: return None # or an appropriate value/error if the list is empty return self.max_numbers[-1] def process_queries(queries): number_list = NumberList() results = [] for query in queries: if query[0] == '1': number_list.add_number(int(query[1])) elif query[0] == '2': results.append(number_list.get_max_number()) return results"},{"question":"def distinctSubstrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k in the string s. If the length of s is less than k, returns 0. >>> distinctSubstrings(\\"abcabc\\", 3) 3 >>> distinctSubstrings(\\"aaaaa\\", 2) 1 >>> distinctSubstrings(\\"xyz\\", 4) 0 def test_distinct_substrings_case1(): assert distinctSubstrings(\\"abcabc\\", 3) == 3 def test_distinct_substrings_case2(): assert distinctSubstrings(\\"aaaaa\\", 2) == 1 def test_distinct_substrings_case3(): assert distinctSubstrings(\\"xyz\\", 4) == 0 def test_distinct_substrings_same_characters(): assert distinctSubstrings(\\"aaaaaaaa\\", 3) == 1 def test_distinct_substrings_k_equals_1(): assert distinctSubstrings(\\"abcd\\", 1) == 4 def test_distinct_substrings_k_equals_length_of_s(): assert distinctSubstrings(\\"abc\\", 3) == 1 def test_distinct_substrings_k_greater_than_length_of_s(): assert distinctSubstrings(\\"abc\\", 4) == 0 def test_distinct_substrings_empty_string(): assert distinctSubstrings(\\"\\", 1) == 0 def test_distinct_substrings_k_zero(): assert distinctSubstrings(\\"abc\\", 0) == 1 # The only \\"substring\\" of length 0 is the empty string. def test_distinct_substrings_non_overlapping(): assert distinctSubstrings(\\"abracadabra\\", 4) == 7 # \\"abra\\", \\"brac\\", \\"raca\\", \\"acad\\", \\"cada\\", \\"dabr\\", \\"abra\\"","solution":"def distinctSubstrings(s, k): Returns the number of distinct substrings of length k in the string s. If the length of s is less than k, returns 0. if len(s) < k: return 0 # generate all possible substrings of length k substrings = {s[i:i+k] for i in range(len(s) - k + 1)} # return the number of distinct substrings return len(substrings)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression containing non-negative integers and the operators '+', '-', and '*'. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3-2+2\\") 3 >>> evaluate_expression(\\"2*3*4\\") 24 The function should parse the string and compute the result of the expression following the standard operator precedence rules. pass # Your implementation here","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression containing non-negative integers and the operators '+', '-', and '*'. def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 else: while (operators and operators[-1] in ['*', '+', '-'] and (expression[i] in ['+', '-'] or operators[-1] == '*')): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def calculate_variance(speeds: List[int], L: int, R: int) -> float: Calculate the variance of speed values from index L to R (1-based) in the given list 'speeds'. >>> calculate_variance([60, 70, 80, 90, 100], 1, 5) 200.0 >>> calculate_variance([60, 70, 80, 90, 100], 2, 4) 66.6666667 >>> calculate_variance([60, 70, 80, 90, 100], 3, 3) 0.0 ... def process_queries(T: int, speeds: List[int], queries: List[Tuple[int, int]]) -> List[float]: Process the list of queries to calculate the variances of speed values for each given interval. >>> process_queries(5, [60, 70, 80, 90, 100], [(1, 5), (2, 4), (3, 3)]) [200.0, 66.6666667, 0.0] ... import pytest def test_calculate_variance_full_range(): speeds = [60, 70, 80, 90, 100] L, R = 1, 5 assert calculate_variance(speeds, L, R) == 200.0 def test_calculate_variance_partial_range(): speeds = [60, 70, 80, 90, 100] L, R = 2, 4 assert round(calculate_variance(speeds, L, R), 7) == 66.6666667 def test_calculate_variance_single_element(): speeds = [60, 70, 80, 90, 100] L, R = 3, 3 assert calculate_variance(speeds, L, R) == 0.0 def test_process_queries(): T = 5 speeds = [60, 70, 80, 90, 100] queries = [(1, 5), (2, 4), (3, 3)] expected_results = [200.0, 66.6666666667, 0.0] results = process_queries(T, speeds, queries) assert len(results) == len(expected_results) for res, exp in zip(results, expected_results): assert round(res, 7) == round(exp, 7) if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_variance(speeds, L, R): Calculate the variance of speed values from index L to R (1-based) in the given list 'speeds'. # Convert to 0-based index L -= 1 R -= 1 # Extract the sublist sublist = speeds[L:R+1] # Calculate mean mean = sum(sublist) / len(sublist) # Calculate variance variance = sum((x - mean) ** 2 for x in sublist) / len(sublist) return variance def process_queries(T, speeds, queries): Process the list of queries to calculate the variances of speed values for each given interval. results = [] for L, R in queries: variance = calculate_variance(speeds, L, R) results.append(variance) return results"},{"question":"def can_ship_travel_without_hitting_obstacles(x1, y1, x2, y2, obstacles): Determine whether the ship can travel from the starting point to the destination without hitting any obstacles. >>> can_ship_travel_without_hitting_obstacles(2, 3, 10, 8, [(5, 5, 3), (7, 5, 2), (9, 7, 1)]) == \\"NO\\" >>> can_ship_travel_without_hitting_obstacles(1, 1, 10, 10, []) == \\"YES\\" >>> can_ship_travel_without_hitting_obstacles(1, 1, 10, 10, [(50, 50, 10)]) == \\"YES\\" >>> can_ship_travel_without_hitting_obstacles(0, 0, 4, 4, [(2, 2, 1)]) == \\"NO\\" >>> can_ship_travel_without_hitting_obstacles(0, 0, 4, 4, [(3, 3, 2)]) == \\"NO\\" >>> can_ship_travel_without_hitting_obstacles(0, 1, 10, 10, [(0, 0, 2)]) == \\"NO\\" >>> can_ship_travel_without_hitting_obstacles(10, 10, 20, 20, [(10, 10, 2)]) == \\"NO\\" >>> can_ship_travel_without_hitting_obstacles(0, 0, 100, 100, [(10, 30, 5), (40, 60, 5), (70, 90, 5)]) == \\"YES\\"","solution":"def can_ship_travel_without_hitting_obstacles(x1, y1, x2, y2, obstacles): import math def is_point_to_segment_distance_less_than_circle(center_x, center_y, radius, x1, y1, x2, y2): Check if the distance from center of the circle to the segment is less than the circle's radius. def distance(x1, y1, x2, y2): return math.sqrt((x1 - x2)**2 + (y1 - y2)**2) if distance(center_x, center_y, x1, y1) <= radius or distance(center_x, center_y, x2, y2) <= radius: return True if (x1 == x2 and y1 == y2): return distance(center_x, center_y, x1, y1) <= radius A = center_x - x1 B = center_y - y1 C = x2 - x1 D = y2 - y1 dot = A * C + B * D len_sq = C * C + D * D param = dot / len_sq if len_sq != 0 else -1 if param < 0: nearest_x, nearest_y = x1, y1 elif param > 1: nearest_x, nearest_y = x2, y2 else: nearest_x = x1 + param * C nearest_y = y1 + param * D return distance(center_x, center_y, nearest_x, nearest_y) <= radius for center_x, center_y, radius in obstacles: if is_point_to_segment_distance_less_than_circle(center_x, center_y, radius, x1, y1, x2, y2): return \\"NO\\" return \\"YES\\""},{"question":"def unique_paths_with_obstacles(obstacleGrid): Compute the number of unique paths from top-left to bottom-right in a grid with obstacles. Example 1: >>> unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]]) 2 Example 2: >>> unique_paths_with_obstacles([[0,1],[0,0]]) 1","solution":"def unique_paths_with_obstacles(obstacleGrid): Compute the number of unique paths from top-left to bottom-right in a grid with obstacles. if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def count_streaks(t: int, datasets: List[Tuple[int, List[int]]]) -> List[int]: Determine the number of streaks of consecutive days where the number of problems solved increased compared to the previous day for each dataset. >>> count_streaks(4, [(5, [2, 3, 1, 4, 5]), (4, [4, 3, 2, 1]), (3, [1, 2, 3]), (6, [1, 2, 2, 3, 4, 5])]) == [2, 0, 1, 2] >>> count_streaks(1, [(5, [5, 4, 3, 2, 1])]) == [0] >>> count_streaks(1, [(5, [1, 2, 3, 4, 5])]) == [1] >>> count_streaks(1, [(0, [])]) == [0] >>> count_streaks(1, [(1, [1])]) == [0] >>> count_streaks(1, [(5, [3, 3, 3, 3, 3])]) == [0] >>> count_streaks(2, [(7, [1, 2, 1, 2, 1, 2, 1]), (7, [1, 2, 3, 2, 3, 4, 5])]) == [3, 2] pass","solution":"def count_streaks(t, datasets): results = [] for dataset in datasets: n, a = dataset streak_count = 0 in_streak = False for i in range(1, n): if a[i] > a[i - 1]: if not in_streak: streak_count += 1 in_streak = True else: in_streak = False results.append(streak_count) return results"},{"question":"def max_digit_sum(numbers: list) -> int: Find the maximum sum of digits in a list of non-negative integers. Args: numbers (list of int): The list of non-negative integers. Returns: int: The maximum sum of digits. If the list is empty, return 0. >>> max_digit_sum([123, 456, 789]) 24 >>> max_digit_sum([0, 1, 10, 100]) 1 >>> max_digit_sum([]) 0 >>> max_digit_sum([45, 76, 345]) 13 >>> max_digit_sum([5]) 5 >>> max_digit_sum([1001]) 2 >>> max_digit_sum([9876543210, 99999]) 45 >>> max_digit_sum([111, 111, 111]) 3 >>> max_digit_sum([0, 0, 0]) 0","solution":"def max_digit_sum(numbers): Find the maximum sum of digits in a list of non-negative integers. Args: numbers (list of int): The list of non-negative integers. Returns: int: The maximum sum of digits. If the list is empty, return 0. if not numbers: return 0 def digit_sum(n): return sum(int(digit) for digit in str(n)) return max(digit_sum(num) for num in numbers)"},{"question":"def defragment_memory(blocks: list) -> list: Defragments the memory blocks array by moving all 1s to the beginning and all 0s to the end while maintaining their relative order. >>> defragment_memory([0, 1, 0, 1, 0, 1]) [1, 1, 1, 0, 0, 0] >>> defragment_memory([1, 0, 1, 0, 0, 1, 0]) [1, 1, 1, 0, 0, 0, 0] >>> defragment_memory([1, 1, 1, 1]) [1, 1, 1, 1] >>> defragment_memory([0, 0, 0, 0]) [0, 0, 0, 0] >>> defragment_memory([]) [] >>> defragment_memory([1, 0, 0, 1, 0]) [1, 1, 0, 0, 0]","solution":"def defragment_memory(blocks): Defragments the memory blocks array by moving all 1s to the beginning and all 0s to the end while maintaining their relative order. Parameters: blocks (list): The list of memory blocks (1s and 0s) Returns: list: The defragmented memory blocks # Solution using list comprehensions num_ones = blocks.count(1) num_zeros = len(blocks) - num_ones return [1] * num_ones + [0] * num_zeros"},{"question":"def palindromic_num(number: int) -> str: Returns \\"Palindromic\\" if the number reads the same forwards and backwards, otherwise \\"Not Palindromic\\". >>> palindromic_num(121) == \\"Palindromic\\" >>> palindromic_num(123) == \\"Not Palindromic\\" >>> palindromic_num(1221) == \\"Palindromic\\" >>> palindromic_num(1) == \\"Palindromic\\" >>> palindromic_num(12321) == \\"Palindromic\\" >>> palindromic_num(12345) == \\"Not Palindromic\\"","solution":"def palindromic_num(number): Returns \\"Palindromic\\" if the number reads the same forwards and backwards, otherwise \\"Not Palindromic\\". str_num = str(number) if str_num == str_num[::-1]: return \\"Palindromic\\" else: return \\"Not Palindromic\\""},{"question":"def flattenArray(nested_list): Flattens a nested list of integers. Parameters: nested_list (list): A nested list of integers Returns: list: A flat list of integers Examples: >>> flattenArray([1, [2, 3], 4]) [1, 2, 3, 4] >>> flattenArray([1, [2, [3, [4, 5]], 6], 7, [8, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flattenArray([]) [] >>> flattenArray([[], [[], []], []]) []","solution":"def flattenArray(nested_list): Flattens a nested list of integers. Parameters: nested_list (list): A nested list of integers Returns: list: A flat list of integers flattened = [] def _flatten_helper(sublist): for element in sublist: if isinstance(element, list): _flatten_helper(element) else: flattened.append(element) _flatten_helper(nested_list) return flattened"},{"question":"def inches_to_cm(distances: List[int]) -> List[float]: Converts a list of distances from inches to centimeters. >>> inches_to_cm([12, 50, 100]) [30.48, 127.00, 254.00] >>> inches_to_cm([1, 2, 3]) [2.54, 5.08, 7.62]","solution":"def inches_to_cm(distances): Converts a list of distances from inches to centimeters. Args: distances (list): List of distances in inches. Returns: list: List of distances in centimeters, rounded to two decimal places. conversion_factor = 2.54 return [round(distance * conversion_factor, 2) for distance in distances]"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Write a function that takes an integer array nums and an integer target as inputs and returns the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([3, 2, 4], 6) == [1, 2] >>> two_sum([3, 3], 6) == [0, 1] def test_example1(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_example2(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_example3(): assert two_sum([3, 3], 6) == [0, 1] def test_negative_numbers(): assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] def test_mixed_sign_numbers(): assert two_sum([-1, 2, 3, -4, 5], 1) == [0, 1] def test_large_numbers(): assert two_sum([1000000000, 2000000000], 3000000000) == [0, 1]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i # Although problem guarantees exactly one solution, good to return an empty list if no result return []"},{"question":"def largest_sum_contiguous_subarray(arr: List[int]) -> int: Function to find the largest sum of any contiguous subarray. >>> largest_sum_contiguous_subarray([1, -3, 2, 1, -1]) 3 >>> largest_sum_contiguous_subarray([-1, -2, -3, -4]) -1 >>> largest_sum_contiguous_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> largest_sum_contiguous_subarray([4]) 4 >>> largest_sum_contiguous_subarray([-5]) -5 >>> largest_sum_contiguous_subarray([3, -2, 5, -1]) 6 >>> largest_sum_contiguous_subarray([2, 1, -5, 4, 6]) 10","solution":"def largest_sum_contiguous_subarray(arr): Function to find the largest sum of any contiguous subarray using Kadane's Algorithm. Params: arr (list): List of integers Returns: int: Largest sum of any contiguous subarray max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Example usage: # if __name__ == \\"__main__\\": # print(largest_sum_contiguous_subarray([-2, -3, 4, -1, -2, 1, 5, -3])) # Should print 7"},{"question":"def maximize_stage_edges(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the maximum possible sum of the weights of the edges connecting the stages from given test cases. >>> test_cases = [(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 5)]), (4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (1, 4, 5)])] >>> maximize_stage_edges(test_cases) [5, 7] def parse_input(input_str: str) -> List[Tuple[int, int, List[Tuple[int, int, int]]]]: Parse the input string into a format suitable for the maximize_stage_edges function. >>> input_str = \\"2n3 3n1 2 3n2 3 4n1 3 5n4 5n1 2 1n2 3 2n3 4 3n1 3 4n1 4 5n\\" >>> parse_input(input_str) [(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 5)]), (4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (1, 4, 5)])]","solution":"def maximize_stage_edges(test_cases): results = [] for test in test_cases: N, M, edges = test max_weight = 0 for edge in edges: u, v, w = edge if w > max_weight: max_weight = w results.append(max_weight) return results def parse_input(input_str): data = input_str.strip().split('n') T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, data[index].split()) index += 1 edges = [] for _ in range(M): u, v, w = map(int, data[index].split()) edges.append((u, v, w)) index += 1 test_cases.append((N, M, edges)) return test_cases"},{"question":"def max_score_difference(scores: List[int]) -> int: Calculate the maximum possible score difference between any two players. Parameters: scores (list): A list of integers representing the scores. Returns: int: The maximum possible score difference. >>> max_score_difference([1, 3, 5, 9]) 8 >>> max_score_difference([5, 5, 5, 5]) 0 >>> max_score_difference([-10, -5, 0, 5, 10]) 20 >>> max_score_difference([5]) 0 >>> max_score_difference([]) 0 >>> max_score_difference([7, 1, 3, -2, 0, 4]) 9","solution":"def max_score_difference(scores): Calculate the maximum possible score difference between any two players. Parameters: scores (list): A list of integers representing the scores. Returns: int: The maximum possible score difference. if not scores or len(scores) < 2: return 0 max_score = max(scores) min_score = min(scores) return max_score - min_score"},{"question":"def find_pair(nums: List[int], target: int) -> List[int]: Find two numbers in \`nums\` that sum up to \`target\` and return their indices. If no such pair exists, return [-1, -1]. >>> find_pair([2, 7, 11, 15], 9) # [0, 1] >>> find_pair([3, 2, 4], 6) # [1, 2] >>> find_pair([1, 2, 3, 4, 5], 10) # [-1, -1]","solution":"def find_pair(nums, target): Find two numbers in \`nums\` that sum up to \`target\` and return their indices. If no such pair exists, return [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"def shift_string(s: str) -> str: Shifts each letter in the string to the previous letter in the alphabet. 'a' shifts to 'z', 'b' shifts to 'a', and so forth. >>> shift_string(\\"abc\\") \\"zab\\" >>> shift_string(\\"xyz\\") \\"wxy\\"","solution":"def shift_string(s): Shifts each letter in the string to the previous letter in the alphabet. 'a' shifts to 'z', 'b' shifts to 'a', and so forth. :param s: Input string containing only lowercase letters. :return: New string with each letter shifted to the previous letter. shifted = [] for char in s: if char == 'a': shifted.append('z') else: shifted.append(chr(ord(char) - 1)) return ''.join(shifted)"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-1) False >>> is_prime(17) True >>> is_prime(19) True >>> is_prime(20) False def filter_primes(lst: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([]) [] >>> filter_primes([0, 1, 2, 3, 15, 23, 25]) [2, 3, 23] >>> filter_primes([10, 20, 30, 40]) [] >>> filter_primes([11, 13, 17, 19]) [11, 13, 17, 19] >>> filter_primes([5, 5, 5]) [5, 5, 5] >>> filter_primes([-5, 0, 1, 2]) [2]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(lst): Returns a list of prime numbers from the given list of integers. return [x for x in lst if is_prime(x)]"},{"question":"def longest_well_formed_subsequence_length(s: str) -> int: Returns the length of the longest well-formed subsequence of parentheses in the given string s. Example: >>> longest_well_formed_subsequence_length(\\"(()())\\") 6 >>> longest_well_formed_subsequence_length(\\"())(\\") 2 >>> longest_well_formed_subsequence_length(\\"((((\\") 0 >>> longest_well_formed_subsequence_length(\\"()())()\\") 6","solution":"def longest_well_formed_subsequence_length(s): Returns the length of the longest well-formed subsequence of parentheses in the given string s. open_count = 0 close_count = 0 # Count the number of well-formed pairs for char in s: if char == '(': open_count += 1 elif char == ')' and open_count > 0: open_count -= 1 close_count += 1 # Each well-formed subsequence will have both an opening and a closing bracket for each pair. return 2 * close_count"},{"question":"def count_long_movies(run_times: List[int]) -> int: Returns the count of movies that have a run time longer than 120 minutes. >>> count_long_movies([90, 85, 118, 99, 110, 100]) 0 >>> count_long_movies([121, 130, 142, 150]) 4 >>> count_long_movies([90, 142, 125, 118, 180, 103]) 3 >>> count_long_movies([120, 125, 119, 180]) 2 >>> count_long_movies([]) 0 >>> count_long_movies([120, 121, 122, 119, 118]) 2","solution":"def count_long_movies(run_times): Returns the count of movies that have a run time longer than 120 minutes. Parameters: run_times (list of int): List of integers representing the run times (in minutes) of several different movies. Returns: int: Number of movies with a run time longer than 120 minutes. return sum(1 for time in run_times if time > 120)"},{"question":"def count_divisors(n: int) -> List[int]: Given an integer n, return a list of integers representing the counts of the divisors of each number from 1 to n inclusive. >>> count_divisors(5) [1, 2, 2, 3, 2] >>> count_divisors(10) [1, 2, 2, 3, 2, 4, 2, 4, 3, 4]","solution":"def count_divisors(n): Returns a list of integers representing the counts of the divisors of each number from 1 to n inclusive. def count_divisors_of_num(num): count = 0 for i in range(1, num + 1): if num % i == 0: count += 1 return count return [count_divisors_of_num(i) for i in range(1, n + 1)]"},{"question":"def balanced_substring(s: str) -> int: Returns the length of the longest substring where the number of 'a's is equal to the number of 'b's. >>> balanced_substring(\\"aababbab\\") 8 >>> balanced_substring(\\"aabba\\") 4 >>> balanced_substring(\\"ababab\\") 6 >>> balanced_substring(\\"aaaa\\") 0 >>> balanced_substring(\\"b\\") 0","solution":"def balanced_substring(s): Returns the length of the longest substring where the number of 'a' is equal to the number of 'b'. max_len = 0 balance = {0: -1} # Initialize with balance 0 at index -1 (before the start of the string) current_balance = 0 for i, char in enumerate(s): if char == 'a': current_balance += 1 else: current_balance -= 1 if current_balance in balance: max_len = max(max_len, i - balance[current_balance]) else: balance[current_balance] = i return max_len"},{"question":"def maximize_absolute_differences(n: int) -> List[int]: Generates a permutation of integers from 1 to n such that the sum of absolute differences between adjacent elements in a circle is maximized. >>> maximize_absolute_differences(3) == [1, 3, 2] >>> maximize_absolute_differences(4) == [1, 3, 2, 4] >>> maximize_absolute_differences(5) == [1, 4, 2, 5, 3] # Your code here from typing import List","solution":"def maximize_absolute_differences(n): Generates a permutation of integers from 1 to n such that the sum of absolute differences between adjacent elements in a circle is maximized. if n == 3: return [1, 3, 2] arrangement = [] for i in range(1, n + 1, 2): arrangement.append(i) for i in range(2, n + 1, 2): arrangement.append(i) return arrangement"},{"question":"def next_palindrome(n: int) -> int: Finds the next palindromic number greater than the given number n. >>> next_palindrome(123) == 131 >>> next_palindrome(678) == 686 >>> next_palindrome(9) == 11 >>> next_palindrome(99) == 101 pass def process_test_cases(test_cases: List[int]) -> List[int]: Processes a list of test cases for next_palindrome function. Parameters: - test_cases: List of integers Returns: A list of integers, each being the result of next_palindrome for the corresponding test case pass","solution":"def next_palindrome(n): Finds the next palindromic number greater than the given number n. while True: n += 1 if str(n) == str(n)[::-1]: return n def process_test_cases(test_cases): Processes a list of test cases for next_palindrome function. Parameters: - test_cases: List of integers Returns: A list of integers, each being the result of next_palindrome for the corresponding test case results = [] for n in test_cases: results.append(next_palindrome(n)) return results"},{"question":"def can_place_boxes(M: int, N: int, capacities: List[int], weights: List[int]) -> str: Determines if it is possible to place all boxes on the shelves without exceeding weight capacity. :param M: int, number of shelves :param N: int, number of boxes :param capacities: list of int, weight capacities of the shelves :param weights: list of int, weights of the boxes :return: str, \\"Possible\\" if all boxes can be placed without exceeding capacities, \\"Impossible\\" otherwise. >>> can_place_boxes(3, 5, [10, 15, 20], [5, 7, 8, 9, 10]) 'Possible' >>> can_place_boxes(2, 4, [12, 10], [8, 6, 4, 5]) 'Impossible' >>> can_place_boxes(1, 3, [30], [5, 10, 15]) 'Possible' >>> can_place_boxes(2, 3, [20, 30], [10, 20, 20]) 'Possible' >>> can_place_boxes(1, 2, [10], [15, 5]) 'Impossible'","solution":"def can_place_boxes(M, N, capacities, weights): Determines if it is possible to place all boxes on the shelves without exceeding weight capacity. :param M: int, number of shelves :param N: int, number of boxes :param capacities: list of int, weight capacities of the shelves :param weights: list of int, weights of the boxes :return: str, \\"Possible\\" if all boxes can be placed without exceeding capacities, \\"Impossible\\" otherwise. capacities.sort(reverse=True) weights.sort(reverse=True) for weight in weights: placed = False for i in range(M): if capacities[i] >= weight: capacities[i] -= weight placed = True break if not placed: return \\"Impossible\\" return \\"Possible\\""},{"question":"def climb_stairs(n: int) -> int: Returns the number of unique ways to climb a staircase of n steps if you can only take steps of size 1, 2, or 3 at a time. >>> climb_stairs(3) 4 >>> climb_stairs(4) 7 >>> climb_stairs(5) 13 >>> climb_stairs(0) 1 >>> climb_stairs(1) 1 >>> climb_stairs(2) 2 >>> climb_stairs(10) 274 >>> climb_stairs(20) 121415","solution":"def climb_stairs(n): Returns the number of unique ways to climb a staircase of n steps if you can only take steps of size 1, 2, or 3 at a time. # Base cases if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Dynamic programming array to store the number of ways to reach each step dp = [0] * (n + 1) # Initial conditions dp[0] = 1 # 1 way to stay at the ground (do nothing) dp[1] = 1 # 1 way to reach the first step (1 step) dp[2] = 2 # 2 ways to reach the second step (1+1, 2) # Calculate the number of ways for each step from 3 to n for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"def find_villages_and_towns(total_inhabitants, total_wells): Given the total number of inhabitants and the total number of wells, return the number of villages and towns as an array. If there is no valid combination that matches the given number of inhabitants and wells, return \\"No solutions\\". A \\"Village\\" has 50 inhabitants and 2 wells. A \\"Town\\" has 200 inhabitants and 3 wells. >>> find_villages_and_towns(250, 5) [1, 1] >>> find_villages_and_towns(100, 4) [2, 0] >>> find_villages_and_towns(400, 6) [0, 2] >>> find_villages_and_towns(60, 3) \\"No solutions\\" >>> find_villages_and_towns(0, 0) [0, 0] >>> find_villages_and_towns(1200, 18) [0, 6] >>> find_villages_and_towns(1250, 20) [1, 6]","solution":"def find_villages_and_towns(total_inhabitants, total_wells): Returns the number of villages and towns. If no valid combination exists, return \\"No solutions\\". for v in range(total_inhabitants // 50 + 1): t = (total_inhabitants - 50 * v) // 200 if 50 * v + 200 * t == total_inhabitants and 2 * v + 3 * t == total_wells: return [v, t] return \\"No solutions\\""},{"question":"def insertion_sort(arr): Perform insertion sort on the given array and return the sorted array. >>> insertion_sort([1]) [1] >>> insertion_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> insertion_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> insertion_sort([3, 1, 4, 2, 5]) [1, 2, 3, 4, 5] >>> insertion_sort([4, 3, 4, 5, 1, 2, 2]) [1, 2, 2, 3, 4, 4, 5] >>> insertion_sort([1000000, -1000000, 500000, -500000]) [-1000000, -500000, 500000, 1000000] >>> insertion_sort([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5] pass","solution":"def insertion_sort(arr): Perform insertion sort on the given array and return the sorted array. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"def move_vowel_strings(lst: List[str]) -> List[str]: Takes a list of strings and returns a new list with all the strings that start with a vowel moved to the end of the list. The original order is preserved. Parameters: lst (list): List of strings Returns: list: New list with vowel-starting strings moved to the end Examples: >>> move_vowel_strings([\\"apple\\", \\"banana\\", \\"orange\\", \\"kiwi\\", \\"grape\\"]) == [\\"banana\\", \\"kiwi\\", \\"grape\\", \\"apple\\", \\"orange\\"] >>> move_vowel_strings([\\"elephant\\", \\"dog\\", \\"iguana\\", \\"octopus\\", \\"duck\\"]) == [\\"dog\\", \\"duck\\", \\"elephant\\", \\"iguana\\", \\"octopus\\"] >>> move_vowel_strings([\\"umbrella\\", \\"antelope\\", \\"eagle\\"]) == [\\"umbrella\\", \\"antelope\\", \\"eagle\\"] >>> move_vowel_strings([\\"cat\\", \\"dog\\", \\"mouse\\"]) == [\\"cat\\", \\"dog\\", \\"mouse\\"]","solution":"def move_vowel_strings(lst): Takes a list of strings and returns a new list with all the strings that start with a vowel moved to the end of the list. The original order is preserved. Parameters: lst (list): List of strings Returns: list: New list with vowel-starting strings moved to the end vowels = 'aeiouAEIOU' non_vowel_strings = [s for s in lst if s[0] not in vowels] vowel_strings = [s for s in lst if s[0] in vowels] return non_vowel_strings + vowel_strings"},{"question":"class BankAccount: Simulate a basic bank account management system with features to create an account, deposit, withdraw and check balance. Example usage: account1 = BankAccount(1, \\"Alice\\", 100) account1.deposit(50) account1.withdraw(30) balance = account1.check_balance() >>> balance 120","solution":"class BankAccount: accounts = {} def __init__(self, account_number, holder_name, initial_balance=0): if account_number <= 0 or initial_balance < 0: raise ValueError(\\"Account number must be positive, and initial balance must be non-negative.\\") if account_number in BankAccount.accounts: raise ValueError(\\"Account number must be unique.\\") self.account_number = account_number self.holder_name = holder_name self.balance = initial_balance BankAccount.accounts[account_number] = self def deposit(self, amount): if amount < 0: raise ValueError(\\"Deposit amount must be non-negative.\\") self.balance += amount def withdraw(self, amount): if amount < 0: raise ValueError(\\"Withdrawal amount must be non-negative.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def check_balance(self): return self.balance"},{"question":"def validateIP(ip: str) -> bool: Checks if the input string is a valid IPv4 address. >>> validateIP(\\"192.168.1.1\\") == True >>> validateIP(\\"256.256.256.256\\") == False >>> validateIP(\\"192.168.01.1\\") == False >>> validateIP(\\"192.168.1\\") == False >>> validateIP(\\"192.168.1.1.1\\") == False >>> validateIP(\\" 192.168.1.1 \\") == False >>> validateIP(\\"192.168.a.1\\") == False >>> validateIP(\\"\\") == False >>> validateIP(\\"0.0.0.0\\") == True >>> validateIP(\\"255.255.255.255\\") == True >>> validateIP(\\"123.045.067.089\\") == False >>> validateIP(\\"....\\") == False","solution":"def validateIP(ip): Checks if the input string is a valid IPv4 address. # Check if only digits and dots are in the string if not all(ch.isdigit() or ch == '.' for ch in ip): return False # Split the IP by dots parts = ip.split('.') # There should be exactly four parts if len(parts) != 4: return False for part in parts: # Each part should be a number between 0 and 255 and can't have leading zeros if not part.isdigit() or not 0 <= int(part) <= 255 or (len(part) > 1 and part[0] == '0'): return False return True"},{"question":"def divisible_sum_pairs(arr: List[int], k: int) -> int: Implement a function \`divisible_sum_pairs\` that takes an array of integers and a positive integer \`k\`, and returns the number of (i, j) pairs where \`i < j\` and \`arr[i] + arr[j]\` is divisible by \`k\`. If there are no such pairs, the function should return \`0\`. >>> divisible_sum_pairs([1, 2, 3, 4, 5, 6], 5) 3 >>> divisible_sum_pairs([1, 2, 3], 10) 0 >>> divisible_sum_pairs([1, 1, 1, 1], 2) 6 >>> divisible_sum_pairs([10, 21, 32, 43, 54], 100) 0 >>> divisible_sum_pairs([2, 2, 2, 2], 4) 6 >>> divisible_sum_pairs([1, 3, 2, 6, 1, 2], 3) 5","solution":"def divisible_sum_pairs(arr, k): Returns the number of (i, j) pairs where i < j and arr[i] + arr[j] is divisible by k. Parameters: arr (list of int): The list of integers. k (int): The positive integer divisor. Returns: int: The number of pairs (i, j) satisfying the conditions. count = 0 n = len(arr) for i in range(n): for j in range(i+1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"def max_organized_plants(n: int, plants: List[List[int]]) -> int: Given the number of plants and their magical properties, returns the maximum number of plants that can be organized in a sequence such that each subsequent plant has a magic score greater than or equal to the previous one. >>> n = 4 >>> plants = [ ... [3, 1, 2, 3], ... [2, -1, -2], ... [3, 4, 5, 6], ... [1, 100] ... ] >>> max_organized_plants(n, plants) 3","solution":"def max_organized_plants(n, plants): Given the number of plants and their magical properties, returns the maximum number of plants that can be organized in a sequence such that each subsequent plant has a magic score greater than or equal to the previous one. magic_scores = [] for plant in plants: M = plant[0] properties = plant[1:M+1] magic_score = sum(properties) magic_scores.append(magic_score) # To find the longest non-decreasing subsequence of magic_scores dp = [1] * n for i in range(n): for j in range(i): if magic_scores[i] >= magic_scores[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_duplicates(input_list): This function takes a list of integers and returns a new list containing only the integers that appear more than once in the original list, sorted in ascending order. >>> find_duplicates([4, 5, 6, 4, 7, 8, 5, 9]) [4, 5] >>> find_duplicates([10, 11, 12, 13, 14, 15]) []","solution":"def find_duplicates(input_list): This function takes a list of integers and returns a new list containing only the integers that appear more than once in the original list, sorted in ascending order. from collections import Counter # Count occurrences of each element in list count = Counter(input_list) # Extract elements that appear more than once and sort them duplicates = sorted([item for item, freq in count.items() if freq > 1]) return duplicates"},{"question":"def find_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs of integers in the array that sum up to the target. Each pair should be counted only once and each element can be used at most once. Examples: >>> find_pairs([1, 3, 2, 2, 4, 5], 6) 2 >>> find_pairs([1, 2, 3, 4, 5], 10) 0 >>> find_pairs([1, 9], 10) 1 >>> find_pairs([1, 2, 3, 4, 3, 2, 1, 5, 6], 6) 3 >>> find_pairs([1, 3, 2, 2, 4, 5, 1], 6) 2","solution":"def find_pairs(nums, target): Returns the number of unique pairs of integers in the array that sum up to the target. Each pair should be counted only once and each element can be used at most once. seen = set() pairs = set() for num in nums: diff = target - num if diff in seen: pairs.add((min(num, diff), max(num, diff))) seen.add(num) return len(pairs)"},{"question":"[Completion Task in Python] def longest_palindromic_substring(s: str) -> int: Returns the length of the longest contiguous substring that is a palindrome. >>> longest_palindromic_substring(\\"babad\\") 3 >>> longest_palindromic_substring(\\"cbbd\\") 2 >>> longest_palindromic_substring(\\"a\\") 1 >>> longest_palindromic_substring(\\"ac\\") 1","solution":"def longest_palindromic_substring(s): Returns the length of the longest contiguous substring that is a palindrome. if not s: return 0 n = len(s) longest = 1 start = 0 # A table to track palindromic substrings dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True for length in range(2, n + 1): # Substring length from 2 to n for i in range(n - length + 1): j = i + length - 1 # Ending index of the substring if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] if dp[i][j] and length > longest: longest = length start = i return longest"},{"question":"def count_peaks(n: int, sequence: List[int]) -> int: Returns the number of peaks in the given sequence of integers. Parameters: n (int): The number of integers in the sequence. sequence (list of int): The sequence of integers. Returns: int: The number of peaks in the sequence. >>> count_peaks(6, [1, 3, 2, 4, 1, 5]) 2 >>> count_peaks(5, [1, 2, 3, 4, 5]) 0","solution":"def count_peaks(n, sequence): Returns the number of peaks in the given sequence of integers. Parameters: n (int): The number of integers in the sequence. sequence (list of int): The sequence of integers. Returns: int: The number of peaks in the sequence. count = 0 for i in range(1, n - 1): if sequence[i] > sequence[i - 1] and sequence[i] > sequence[i + 1]: count += 1 return count"},{"question":"def most_frequent_char(s: str): Returns the most frequently occurring character in the string s. In case of a tie, returns the character that appears first in the string. >>> most_frequent_char(\\"character\\") 'c' >>> most_frequent_char(\\"apple\\") 'p' >>> most_frequent_char(\\"abbccc\\") 'c' >>> most_frequent_char(\\"banana\\") 'a' >>> most_frequent_char(\\"a\\") 'a' >>> most_frequent_char(\\"abc\\") 'a' >>> most_frequent_char(\\"\\") None >>> most_frequent_char(\\"aa!!bb**\\") 'a' >>> most_frequent_char(\\"!@#%^\\") '!'","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string s. In case of a tie, returns the character that appears first in the string. from collections import Counter if not s: return None char_count = Counter(s) max_count = max(char_count.values()) for char in s: if char_count[char] == max_count: return char"},{"question":"def wave(s: str) -> list: Write a function \`wave\` that takes a string and returns a list with all the possible \\"Mexican wave\\" permutations of that string. The \\"Mexican wave\\" is when a sequence of characters is changed to produce a wave-like pattern. Each permutation should change exactly one character to uppercase and the rest should remain in lowercase. If the input string contains spaces, they should be ignored in terms of wave generation but remain in their position with the spaces maintained in the output list. Args: s (str): The input string to generate waves from. Returns: list: A list containing all the wave permutations of the input string. Examples: >>> wave(\\"hello\\") [\\"Hello\\", \\"hEllo\\", \\"heLlo\\", \\"helLo\\", \\"hellO\\"] >>> wave(\\"mexican wave\\") [\\"Mexican wave\\", \\"mExican wave\\", \\"meXican wave\\", \\"mexIcan wave\\", \\"mexiCan wave\\", \\"mexicAn wave\\", \\"mexicaN wave\\", \\"mexican Wave\\", \\"mexican wAve\\", \\"mexican waVe\\", \\"mexican wavE\\"] >>> wave(\\"\\") [] >>> wave(\\"a\\") [\\"A\\"] >>> wave(\\" hello \\") [\\" Hello \\", \\" hEllo \\", \\" heLlo \\", \\" helLo \\", \\" hellO \\"] >>> wave(\\" \\") []","solution":"def wave(s: str) -> list: Returns a list of all possible \\"wave\\" permutations of the input string. Each permutation changes exactly one character to uppercase. result = [] for i, char in enumerate(s): if char.isalpha(): waved = s[:i] + char.upper() + s[i+1:] result.append(waved) return result"},{"question":"def hex_to_decimal(hex_string: str) -> int: Convert a hexadecimal string to its corresponding decimal (base 10) format. >>> hex_to_decimal(\\"1A\\") # => 26 >>> hex_to_decimal(\\"7F\\") # => 127 >>> hex_to_decimal(\\"100\\") # => 256 >>> hex_to_decimal(\\"0\\") # => 0 >>> hex_to_decimal(\\"ABC\\") # => 2748 >>> hex_to_decimal(\\"FFF\\") # => 4095 >>> hex_to_decimal(\\"abc\\") # => 2748 # Check lowercase handling >>> hex_to_decimal(\\"ABCdef\\") # => 11259375 # Check mixed case handling","solution":"def hex_to_decimal(hex_string: str) -> int: Convert a hexadecimal string to its corresponding decimal (base 10) format. hex_digits = '0123456789ABCDEF' hex_string = hex_string.upper() # Ensure the string is in upper case for consistency decimal_value = 0 logger = [] for char in hex_string: decimal_value = decimal_value * 16 + hex_digits.index(char) logger.append(f\\"Intermediate value: {decimal_value}\\") for log in logger: print(log) return decimal_value"},{"question":"from typing import List def anagram_groups(words: List[str]) -> List[List[str]]: Groups words into sets of anagrams and returns a list of these sets. Each set is a list sorted lexicographically. The overall list is also sorted lexicographically based on the first word in each set. >>> anagram_groups([\\"bat\\", \\"cat\\", \\"tab\\", \\"act\\", \\"tac\\", \\"rat\\"]) [['act', 'cat', 'tac'], ['bat', 'tab'], ['rat']] >>> anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"golgeo\\"]) [['enlist', 'listen', 'silent'], ['golgeo', 'google']] >>> anagram_groups([\\"a\\", \\"b\\", \\"a\\"]) [['a', 'a'], ['b']] >>> anagram_groups([\\"\\"]) [[\\"\\"]] >>> anagram_groups([\\"abc\\"]) [[\\"abc\\"]] >>> anagram_groups([]) [] pass def test_anagram_groups(): assert anagram_groups([\\"bat\\", \\"cat\\", \\"tab\\", \\"act\\", \\"tac\\", \\"rat\\"]) == [['act', 'cat', 'tac'], ['bat', 'tab'], ['rat']] assert anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"golgeo\\"]) == [['enlist', 'listen', 'silent'], ['golgeo', 'google']] assert anagram_groups([\\"a\\", \\"b\\", \\"a\\"]) == [['a', 'a'], ['b']] assert anagram_groups([\\"\\"]) == [[\\"\\"]] assert anagram_groups([\\"abc\\"]) == [[\\"abc\\"]] assert anagram_groups([]) == [] def test_empty_input(): assert anagram_groups([]) == [] def test_single_word(): assert anagram_groups([\\"a\\"]) == [[\\"a\\"]] assert anagram_groups([\\"ab\\"]) == [[\\"ab\\"]] def test_no_anagrams(): assert anagram_groups([\\"apple\\", \\"banana\\", \\"carrot\\"]) == [[\\"apple\\"], [\\"banana\\"], [\\"carrot\\"]] def test_all_identical_words(): assert anagram_groups([\\"x\\", \\"x\\", \\"x\\"]) == [['x', 'x', 'x']] def test_special_characters(): assert anagram_groups([\\"ab!\\", \\"!ab\\", \\"a!b\\"]) == [['!ab', 'a!b', 'ab!']] assert anagram_groups([\\"%.@\\", \\"@.%\\", \\".%@\\"]) == [['%.@', '.%@', '@.%']]","solution":"from collections import defaultdict def anagram_groups(words): Groups words into sets of anagrams and returns a list of these sets. Each set is a list sorted lexicographically. The overall list is also sorted lexicographically based on the first word in each set. anagram_dict = defaultdict(list) # Group words by sorted tuple of characters for word in words: key = ''.join(sorted(word)) anagram_dict[key].append(word) # Sort each anagram group and the overall list based on the first element of each group result = [sorted(group) for group in anagram_dict.values()] return sorted(result, key=lambda group: group[0])"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determines if there are three numbers in nums that add up to the target. Args: nums: List of non-negative integers. target: Non-negative integer target sum. Returns: True if there exists a triplet in nums whose sum equals target, otherwise False.","solution":"def three_sum(nums, target): Determines if there are three numbers in nums that add up to the target. Args: nums: List of non-negative integers. target: Non-negative integer target sum. Returns: True if there exists a triplet in nums whose sum equals target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def shift_string_2(s: str) -> str: Write a function that takes a string s of lowercase alphabetic characters, and returns the string obtained by shifting every character in s by 2 positions forward in the alphabet. Characters 'y' and 'z' should wrap around to 'a' and 'b', respectively. Assume the input string s will always be a non-empty string containing only lowercase alphabetic characters. Examples: >>> shift_string_2(\\"abc\\") \\"cde\\" >>> shift_string_2(\\"xyz\\") \\"zab\\"","solution":"def shift_string_2(s): Shifts every character in the string s by 2 positions forward in the alphabet. Characters 'y' and 'z' wrap around to 'a' and 'b', respectively. Parameters: s (str): The input string consisting of lowercase alphabetic characters. Returns: str: The shifted string. shifted_string = [] for char in s: # Calculate the shifted character, wrapping around if needed. shifted_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a')) shifted_string.append(shifted_char) return ''.join(shifted_string)"},{"question":"def convert_temperature(temp_str: str) -> str: Converts a temperature from Celsius to Fahrenheit or Fahrenheit to Celsius. Parameters: temp_str (str): A string representing the temperature and the scale (e.g., \\"25 C\\" or \\"77 F\\"). Returns: str: A string representing the converted temperature and the new scale. >>> convert_temperature(\\"0 C\\") == \\"32 F\\" >>> convert_temperature(\\"100 C\\") == \\"212 F\\" >>> convert_temperature(\\"-40 C\\") == \\"-40 F\\" >>> convert_temperature(\\"25 C\\") == \\"77 F\\" >>> convert_temperature(\\"32 F\\") == \\"0 C\\" >>> convert_temperature(\\"212 F\\") == \\"100 C\\" >>> convert_temperature(\\"-40 F\\") == \\"-40 C\\" >>> convert_temperature(\\"77 F\\") == \\"25 C\\"","solution":"def convert_temperature(temp_str): Converts a temperature from Celsius to Fahrenheit or Fahrenheit to Celsius. Parameters: temp_str (str): A string representing the temperature and the scale (e.g., \\"25 C\\" or \\"77 F\\"). Returns: str: A string representing the converted temperature and the new scale. temp, scale = temp_str.split() temp = int(temp) if scale == 'C': converted_temp = round(temp * 9 / 5 + 32) return f\\"{converted_temp} F\\" elif scale == 'F': converted_temp = round((temp - 32) * 5 / 9) return f\\"{converted_temp} C\\" else: raise ValueError(\\"Invalid scale\\")"},{"question":"def find_min_cost_to_connect_villages(testcases): Given a list of testcases, find the minimum cost to connect all villages for each testcase. Each testcase is a tuple of (V, E, edges) where: - V is number of villages (nodes) - E is number of roads (edges) - edges is a list of tuples (u, v, w) representing a road between village u and village v with distance w Returns a list of minimum costs for each testcase. def parse_input(input_string): Parses the input string and returns a list of testcases. Each testcase is a tuple (V, E, edges). def main(input_string): Takes input string, parses it, and returns the results as a string with each result on a new line. Parses the input string, calls find_min_cost_to_connect_villages function with parsed testcases, and returns the results. # Unit Tests def test_single_case(): input_string = \\"1n4 5n1 2 1n1 3 4n1 4 3n2 3 2n3 4 5n\\" assert main(input_string) == \\"6\\" def test_multiple_cases(): input_string = ( \\"2n\\" \\"4 5n1 2 1n1 3 4n1 4 3n2 3 2n3 4 5n\\" \\"3 3n1 2 2n2 3 3n1 3 1n\\" ) assert main(input_string) == \\"6n3\\" def test_no_edges(): input_string = \\"1n4 0n\\" assert main(input_string) == \\"0\\" def test_minimal_case(): input_string = \\"1n1 0n\\" assert main(input_string) == \\"0\\" def test_larger_case(): input_string = ( \\"1n6 9n\\" \\"1 2 6n1 3 1n1 4 5n2 3 2n2 5 5n3 4 2n3 5 6n4 6 5n5 6 3n\\" ) assert main(input_string) == \\"13\\"","solution":"def find_min_cost_to_connect_villages(testcases): def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 results = [] for testcase in testcases: V, E, edges = testcase edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(V): parent.append(node) rank.append(0) result = [] e = 0 i = 0 while e < V - 1 and i < len(edges): u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = sum([w for u, v, w in result]) results.append(minimum_cost) return results # Reading input def parse_input(input_string): data = input_string.strip().split('n') T = int(data[0]) testcases = [] index = 1 for _ in range(T): V, E = map(int, data[index].split()) edges = [] for _ in range(E): index += 1 u, v, w = map(int, data[index].split()) edges.append((u, v, w)) testcases.append((V, E, edges)) index += 1 return testcases def main(input_string): testcases = parse_input(input_string) results = find_min_cost_to_connect_villages(testcases) result_string = \\"n\\".join(map(str, results)) return result_string"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the sum of the contiguous subarray with the largest sum. :param nums: List[int] - list of integers (contains at least one integer) :return: int - sum of the contiguous subarray with the largest sum >>> max_subarray_sum([34, -50, 42, 14, -5, 86]) 137 >>> max_subarray_sum([-5, -1, -8, -9]) -1 >>> max_subarray_sum([8, -1, 3, 4]) 14 pass def test_all_positive_numbers(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_all_negative_numbers(): assert max_subarray_sum([-5, -1, -8, -9]) == -1 def test_mixed_numbers(): assert max_subarray_sum([34, -50, 42, 14, -5, 86]) == 137 def test_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_entire_array_is_the_subarray(): assert max_subarray_sum([8, -1, 3, 4]) == 14 def test_subarray_at_the_end(): assert max_subarray_sum([-3, 4, -1, 2, 1, -5, 4]) == 6","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. :param nums: List[int] - list of integers (contains at least one integer) :return: int - sum of the contiguous subarray with the largest sum max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def find_package_pair(trucks, target_weight): Given a fleet of trucks with package weights, find if there exists a pair of packages in any single truck that sum up to the target weight. If such a pair is found, return the truck ID and the two package weights. >>> trucks = [ ... {\\"id\\": \\"T1\\", \\"weights\\": [70, 30, 90, 50, 20]}, ... {\\"id\\": \\"T2\\", \\"weights\\": [10, 110, 40, 60]}, ... {\\"id\\": \\"T3\\", \\"weights\\": [25, 35, 45, 55]}, ... ] >>> find_package_pair(trucks, 100) ('T1', 70, 30) >>> find_package_pair(trucks, 150) None","solution":"def find_package_pair(trucks, target_weight): for truck in trucks: weights = truck[\\"weights\\"] seen = set() for weight in weights: if target_weight - weight in seen: return (truck[\\"id\\"], weight, target_weight - weight) seen.add(weight) return None"},{"question":"from typing import List def solve(arr: List[int], k: int) -> int: Finds the length of the longest contiguous subarray such that the difference between the maximum and minimum values in this subarray is at most k. Examples: >>> solve([1, 3, 2, 4, 5, 6], 2) == 3 >>> solve([10, 1, 2, 4, 7, 2], 5) == 4 >>> solve([1, 5, 9, 3, 8, 7], 4) == 2 pass def test_solve_example1(): assert solve([1, 3, 2, 4, 5, 6], 2) == 3 def test_solve_example2(): assert solve([10, 1, 2, 4, 7, 2], 5) == 4 def test_solve_example3(): assert solve([1, 5, 9, 3, 8, 7], 4) == 2 def test_solve_all_same_elements(): assert solve([5, 5, 5, 5, 5], 0) == 5 def test_solve_no_elements(): assert solve([], 1) == 0 def test_solve_single_element(): assert solve([5], 3) == 1 def test_solve_large_k(): assert solve([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == 9 def test_solve_small_k(): assert solve([1, 3, 2, 4, 5, 6], 1) == 2","solution":"from collections import deque def solve(arr, k): Finds the length of the longest contiguous subarray such that the difference between the maximum and minimum values in this subarray is at most k. n = len(arr) if n == 0: return 0 max_d = deque() min_d = deque() l = 0 result = 0 for r in range(n): while max_d and arr[max_d[-1]] <= arr[r]: max_d.pop() max_d.append(r) while min_d and arr[min_d[-1]] >= arr[r]: min_d.pop() min_d.append(r) while arr[max_d[0]] - arr[min_d[0]] > k: if max_d[0] == l: max_d.popleft() if min_d[0] == l: min_d.popleft() l += 1 result = max(result, r - l + 1) return result"},{"question":"def expand_to_palindrome(s: str) -> int: Returns the minimum number of characters that need to be appended to the end of the string to make it a palindrome. >>> expand_to_palindrome(\\"race\\") 3 >>> expand_to_palindrome(\\"madam\\") 0 >>> expand_to_palindrome(\\"abc\\") 2","solution":"def expand_to_palindrome(s): Returns the minimum number of characters that need to be appended to the end of the string to make it a palindrome. def is_palindrome(st): return st == st[::-1] if is_palindrome(s): return 0 for i in range(len(s)): sub_str = s[i:] if is_palindrome(sub_str): return i # This line should never be reached because in the worst case, adding len(s) - 1 characters will always make the string a palindrome return len(s) - 1"},{"question":"class Company: A system that can manage information about employees, departments, and their relationships in a company. Methods: - add_employee(name: str) -> bool: Adds a new employee to the company. Returns False if the employee already exists. - add_department(department_name: str) -> bool: Adds a new department to the company. Returns False if the department already exists. - assign_employee(employee_name: str, department_name: str) -> bool: Assigns an employee to a department. Returns False if either the employee or the department does not exist, or if the employee is already assigned to that department. - unassign_employee(employee_name: str, department_name: str) -> bool: Unassigns an employee from a department. Returns False if either the employee or the department does not exist, or if the employee is not assigned to that department. - get_departments_of_employee(employee_name: str) -> list: Returns the list of departments the employee belongs to, in alphabetical order. If the employee does not exist, returns an empty list. - get_employees_of_department(department_name: str) -> list: Returns the list of employees in the specified department, in alphabetical order. If the department does not exist, returns an empty list.","solution":"class Company: def __init__(self): self.employees = {} self.departments = {} def add_employee(self, name): if name in self.employees: return False self.employees[name] = set() return True def add_department(self, department_name): if department_name in self.departments: return False self.departments[department_name] = set() return True def assign_employee(self, employee_name, department_name): if employee_name not in self.employees or department_name not in self.departments: return False if department_name in self.employees[employee_name]: return False self.employees[employee_name].add(department_name) self.departments[department_name].add(employee_name) return True def unassign_employee(self, employee_name, department_name): if employee_name not in self.employees or department_name not in self.departments: return False if department_name not in self.employees[employee_name]: return False self.employees[employee_name].remove(department_name) self.departments[department_name].remove(employee_name) return True def get_departments_of_employee(self, employee_name): if employee_name not in self.employees: return [] return sorted(list(self.employees[employee_name])) def get_employees_of_department(self, department_name): if department_name not in self.departments: return [] return sorted(list(self.departments[department_name]))"},{"question":"def is_valid_rgb(color_code: str) -> bool: Checks if the given string is a valid RGB color code. >>> is_valid_rgb(\\"#00FF8B\\") True >>> is_valid_rgb(\\"#00ff8b\\") True >>> is_valid_rgb(\\"#123ABC\\") True >>> is_valid_rgb(\\"#abcdef\\") True >>> is_valid_rgb(\\"#123abg\\") False >>> is_valid_rgb(\\"123ABC\\") False >>> is_valid_rgb(\\"#123AB\\") False >>> is_valid_rgb(\\"#12345G\\") False >>> is_valid_rgb(\\"#XYZXYZ\\") False >>> is_valid_rgb(\\"#1234567\\") False >>> is_valid_rgb(\\"#12345\\") False >>> is_valid_rgb(\\"\\") False >>> is_valid_rgb(\\"00FF8B\\") False >>> is_valid_rgb(\\"abcdef\\") False >>> is_valid_rgb(\\"00FF8G\\") False","solution":"import re def is_valid_rgb(color_code: str) -> bool: Checks if the given string is a valid RGB color code. Args: color_code (str): The string to check. Returns: bool: True if the string is a valid RGB color code, False otherwise. # Regular expression pattern for a valid RGB color code pattern = re.compile(r'^#[0-9A-Fa-f]{6}') return bool(pattern.match(color_code))"},{"question":"class Warehouse: def __init__(self, items): Initialize warehouse with a list of items Args: items (List[int]): List of initial items in each box. self.items = items def process_queries(self, queries): Process a list of queries. Queries can be of type 1 (add items) or type 2 (find maximum items). Args: queries (List[Tuple[int]]): List of queries to be processed. Returns: List[int]: List of results for type 2 queries. Example: >>> warehouse = Warehouse([1, 2, 3, 4, 5]) >>> queries = [(1, 2, 4, 3), (2, 1, 5), (2, 2, 3)] >>> warehouse.process_queries(queries) [8, 6]","solution":"class Warehouse: def __init__(self, items): self.items = items def process_queries(self, queries): results = [] for query in queries: if query[0] == 1: _, L, R, X = query for i in range(L - 1, R): self.items[i] += X elif query[0] == 2: _, L, R = query results.append(max(self.items[L - 1:R])) return results"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the characters in the string \`s\` to the right by \`n\` positions. If \`n\` is negative, it rotates to the left by \`|n|\` positions. :param s: The input string to rotate. :param n: The number of positions to rotate the string. :return: The rotated string. >>> rotate_string(\\"hello\\", 2) 'lohel' >>> rotate_string(\\"hello\\", -2) 'llohe' >>> rotate_string(\\"hello\\", 5) 'hello' >>> rotate_string(\\"hello\\", 7) 'lohel' >>> rotate_string(\\"\\", 3) '' >>> rotate_string(\\"python\\", -8) 'thonpy'","solution":"def rotate_string(s, n): Rotates the characters in the string \`s\` to the right by \`n\` positions. If \`n\` is negative, it rotates to the left by \`|n|\` positions. :param s: The input string to rotate. :param n: The number of positions to rotate the string. :return: The rotated string. if not s: return s n = n % len(s) # Handle rotations greater than string length return s[-n:] + s[:-n]"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple of indices (i, j) where nums[i] + nums[j] == target. If no such indices exist, return an empty tuple. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1)","solution":"def two_sum(nums, target): Returns a tuple of indices (i, j) where nums[i] + nums[j] == target. If no such indices exist, return an empty tuple. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"def find_pumpkin_length(nums): Finds the maximum pumpkin length for a given list of integers. >>> find_pumpkin_length([3, 9, 6, 18, 36, 1, 72]) == 6 >>> find_pumpkin_length([8]) == 1 >>> find_pumpkin_length([7, 11, 13]) == 1 >>> find_pumpkin_length([1, 2, 4, 8, 16]) == 5 >>> find_pumpkin_length([1, 2, 4, 8, 3, 6, 9]) == 4 >>> find_pumpkin_length([5, 10, 15, 20, 25, 1, 40, 50, 100]) == 5 pass","solution":"def find_pumpkin_length(nums): Finds the maximum pumpkin length for a given list of integers. nums.sort() N = len(nums) dp = [1] * N for i in range(N): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) nums = list(map(int, data[1:])) print(find_pumpkin_length(nums))"},{"question":"def get_department_name(employee_id: str) -> str: Returns the department name based on the department code in the employee ID. Args: employee_id (str): The employee ID in the format \\"DDD-XXXXX\\" Returns: str: The corresponding department name or \\"Unknown Department\\" if the code is not found. Examples: >>> get_department_name(\\"101-23456\\") 'Sales' >>> get_department_name(\\"110-98765\\") 'Unknown Department'","solution":"def get_department_name(employee_id): Returns the department name based on the department code in the employee ID. Args: employee_id (str): The employee ID in the format \\"DDD-XXXXX\\" Returns: str: The corresponding department name or \\"Unknown Department\\" if the code is not found. department_codes = { '101': 'Sales', '102': 'Engineering', '103': 'HR', '104': 'Finance', '105': 'IT Support', '106': 'Legal', '107': 'Marketing', '108': 'Research' } department_code = employee_id.split('-')[0] return department_codes.get(department_code, \\"Unknown Department\\")"},{"question":"def generate_checkerboard(n: int) -> str: Generate an n x n checkerboard pattern as a string. Parameters: - n (int): The size of the checkerboard. Returns: - str: The checkerboard pattern where each row is separated by a newline character. >>> print(generate_checkerboard(3)) XOX OXO XOX >>> print(generate_checkerboard(5)) XOXOX OXOXO XOXOX OXOXO XOXOX","solution":"def generate_checkerboard(n): Generate an n x n checkerboard pattern as a string. Parameters: - n (int): The size of the checkerboard. Returns: - str: The checkerboard pattern where each row is separated by a newline character. checkerboard = [] for i in range(n): row = [] for j in range(n): if (i + j) % 2 == 0: row.append('X') else: row.append('O') checkerboard.append(''.join(row)) return 'n'.join(checkerboard)"},{"question":"def longest_repeating_substring(s: str) -> str: Returns the longest repeating substring in the given string \`s\`. If there are multiple substrings with the same maximum length, returns the one that appears first in the string. If no repeated substring is found, returns an empty string. >>> longest_repeating_substring(\\"banana\\") == \\"ana\\" >>> longest_repeating_substring(\\"abcabcabc\\") == \\"abcabc\\" >>> longest_repeating_substring(\\"abcd\\") == \\"\\"","solution":"def longest_repeating_substring(s: str) -> str: Returns the longest repeating substring in the given string \`s\`. If there are multiple substrings with the same maximum length, returns the one that appears first in the string. If no repeated substring is found, returns an empty string. n = len(s) # Helper function to check if there is a repeated substring of given length def is_repeated_substring(k): seen = set() for i in range(n - k + 1): substr = s[i:i+k] if substr in seen: return substr seen.add(substr) return None # Binary search on the length of the substring left, right = 1, n - 1 result = \\"\\" while left <= right: mid = (left + right) // 2 repeated_substr = is_repeated_substring(mid) if repeated_substr: result = repeated_substr left = mid + 1 # Try to find a longer one else: right = mid - 1 # Try to find a shorter one return result"},{"question":"def findMissingPositive(nums: List[int]) -> int: Find the smallest positive integer missing from the input array. >>> findMissingPositive([3, 4, -1, 1]) == 2 >>> findMissingPositive([1, 2, 0]) == 3 >>> findMissingPositive([-2, -3, 1, 2]) == 3 pass","solution":"from typing import List def findMissingPositive(nums: List[int]) -> int: n = len(nums) # First, move all out-of-range elements to the end by marking them with a value>n for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Use the index as a hash key and mark corresponding indices. for i in range(n): num = abs(nums[i]) if num <= n and nums[num - 1] > 0: nums[num - 1] = -nums[num - 1] # Identify the smallest missing positive number. for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def smallest_string_with_swaps(s, pairs): You are given a string \`str\` consisting of lowercase letters and a list of pairs of indices \`(i, j)\` that indicate that the characters at these indices can be swapped. Your task is to determine the lexicographically smallest string that can be obtained by performing any number of swaps. >>> smallest_string_with_swaps(\\"dcab\\", [[0, 3], [1, 2]]) \\"bacd\\" >>> smallest_string_with_swaps(\\"dcab\\", [[0, 3], [1, 2], [0, 2]]) \\"abcd\\" >>> smallest_string_with_swaps(\\"cba\\", [[0, 1], [1, 2], [0, 2]]) \\"abc\\"","solution":"def smallest_string_with_swaps(s, pairs): from collections import defaultdict parent = {} def find(x): if parent.setdefault(x, x) != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): parent[find(x)] = find(y) for i, j in pairs: union(i, j) groups = defaultdict(list) for i in range(len(s)): groups[find(i)].append(i) ans = list(s) for indices in groups.values(): chars = sorted(ans[i] for i in indices) for i, char in zip(sorted(indices), chars): ans[i] = char return ''.join(ans)"},{"question":"def choose_stones(stones: int) -> int: This function returns the number of stones the AI will pick, ensuring it is always an odd positive integer. The AI strategy is to play in a way that always leads the opponent to a losing position by making them pick the last stone. >>> choose_stones(11) % 2 == 1 >>> choose_stones(10) % 2 == 1 >>> choose_stones(1) == 1 pass","solution":"def choose_stones(stones): This function returns the number of stones the AI will pick, ensuring it is always an odd positive integer. The AI strategy would be to let the opponent play only when the pile is such that they will eventually pick the last stone. # Ensure AI picks 1 stone if the pile has 1 stone left, resulting in the opponent losing. if stones == 1: return 1 # If there are stones greater than 1, the AI will always pick 1 stone, # thus ensuring the opponent faces 1 less stone each turn, # ultimately leading the opponent to a losing position. return 1"},{"question":"from typing import List, Tuple def most_frequent_element(n: int, q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Find the most frequent element in the subarray A[L:R], for each query in queries. If there are multiple elements with the same highest frequency, return the smallest one. Args: n (int): The number of elements in the array A. q (int): The number of queries. A (List[int]): The elements of the array. queries (List[Tuple[int, int]]): A list of tuples representing the queries. Returns: List[int]: A list of integers representing the answers to each query. Example: >>> most_frequent_element(7, 3, [1, 2, 2, 3, 1, 2, 2], [(1, 3), (2, 5), (3, 7)]) [2, 2, 2] if __name__ == \\"__main__\\": n = 7 q = 3 A = [1, 2, 2, 3, 1, 2, 2] queries = [(1, 3), (2, 5), (3, 7)] print(most_frequent_element(n, q, A, queries))","solution":"from collections import defaultdict, Counter def most_frequent_element(n, q, A, queries): results = [] for L, R in queries: subarray = A[L-1:R] count = Counter(subarray) max_freq = max(count.values()) most_frequent = min([num for num in count if count[num] == max_freq]) results.append(most_frequent) return results # Example usage n = 7 q = 3 A = [1, 2, 2, 3, 1, 2, 2] queries = [(1, 3), (2, 5), (3, 7)] print(most_frequent_element(n, q, A, queries))"},{"question":"def min_steps_to_fill_planters(n, current_levels, capacities): Determine the minimum number of steps required to fill all the planters to their capacities. >>> min_steps_to_fill_planters(4, [2, 1, 3, 5], [5, 3, 4, 7]) 8 >>> min_steps_to_fill_planters(3, [4, 5, 3], [4, 5, 3]) 0 >>> min_steps_to_fill_planters(3, [1, 2, 3], [3, 2, 1]) 4 >>> min_steps_to_fill_planters(2, [0, 0], [4, 5]) 9 >>> min_steps_to_fill_planters(5, [1, 1, 1, 1, 1], [3, 3, 3, 3, 3]) 10","solution":"def min_steps_to_fill_planters(n, current_levels, capacities): steps = 0 for i in range(n): steps += abs(capacities[i] - current_levels[i]) return steps"},{"question":"from collections import deque from typing import List def calculate_moving_average(prices: List[int], N: int) -> List[float]: Given a sequence of stock prices and a number N, calculate the average price of the last N prices every time a new price is added. If there are fewer than N prices available, use all available prices up to that point. Args: prices (List[int]): List of stock prices. N (int): Number of most recent prices to consider. Returns: List[float]: List of moving averages for each point in time. Examples: >>> calculate_moving_average([10, 20, 30, 40, 50], 3) [10.0, 15.0, 20.0, 30.0, 40.0] >>> calculate_moving_average([5, 10, 15], 5) [5.0, 7.5, 10.0] >>> calculate_moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) [1.0, 1.5, 2.0, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5]","solution":"from collections import deque def calculate_moving_average(prices, N): n = len(prices) if n == 0: return [] moving_averages = [] window = deque() window_sum = 0 for i in range(n): window.append(prices[i]) window_sum += prices[i] if len(window) > N: removed = window.popleft() window_sum -= removed moving_averages.append(window_sum / len(window)) return moving_averages"},{"question":"from typing import List def find_peak_elements(nums: List[int]) -> List[int]: Returns a list of all peak elements. A peak element is an element that is greater than its neighbors. >>> find_peak_elements([1, 2, 3, 1, 5, 6, 4]) [3, 6] >>> find_peak_elements([1, 2, 1, 3, 5, 6, 4]) [2, 6] >>> find_peak_elements([1, 2, 3, 4, 5]) [5] >>> find_peak_elements([5, 4, 3, 2, 1]) [5] >>> find_peak_elements([3]) [3] >>> find_peak_elements([1, 2]) [2] >>> find_peak_elements([2, 1]) [2] >>> find_peak_elements([2, 2, 2, 2]) [] >>> find_peak_elements([1, 2, 1, 3, 4, 5, 6, 4, 3, 2, 5, 1]) [2, 6, 5]","solution":"def find_peak_elements(nums): Returns a list of all peak elements. A peak element is an element that is greater than its neighbors. n = len(nums) peaks = [] for i in range(n): if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]): peaks.append(nums[i]) return peaks"},{"question":"def contains_forbidden(text: str) -> bool: Check if the input string contains any forbidden words. The function is case-insensitive and considers only whole words. :param text: str, input string to be checked :return: bool, True if any forbidden word is found, otherwise False >>> contains_forbidden(\\"No issues found here.\\") False >>> contains_forbidden(\\"This is forbidden.\\") True >>> contains_forbidden(\\"Containing BANNED and other terms.\\") True","solution":"def contains_forbidden(text): Check if the input string contains any forbidden words. The function is case-insensitive and considers only whole words. :param text: str, input string to be checked :return: bool, True if any forbidden word is found, otherwise False import re # predefined list of forbidden words forbidden_words = [\\"forbidden\\", \\"prohibited\\", \\"banned\\"] # Convert text to lower case and use word boundaries to match whole words text = text.lower() # Create a combined regex pattern pattern = r'b(' + '|'.join(forbidden_words) + r')b' # Search for any forbidden words in the text if re.search(pattern, text): return True return False"},{"question":"def max_employees_present(records): Determines the maximum number of employees present at the office at any time during the day. Args: records: List of tuples, where each tuple contains two integers (arrival time, departure time). Returns: Maximum number of employees present at the same time. >>> max_employees_present([(9, 17), (10, 12), (11, 15), (14, 18), (16, 19)]) 3 >>> max_employees_present([(9, 10), (11, 12), (13, 14)]) 1 >>> max_employees_present([(0, 23), (1, 22), (2, 21), (3, 20)]) 4 >>> max_employees_present([(8, 17)]) 1 >>> max_employees_present([]) 0 >>> max_employees_present([(9, 17), (9, 17), (9, 17)]) 3 >>> max_employees_present([(8, 12), (11, 15), (14, 18), (10, 13)]) 3","solution":"def max_employees_present(records): Determines the maximum number of employees present at the office at any time during the day. Args: records: List of tuples, where each tuple contains two integers (arrival time, departure time). Returns: Maximum number of employees present at the same time. events = [] for arrival, departure in records: events.append((arrival, 'arrival')) events.append((departure, 'departure')) events.sort() max_present = 0 current_present = 0 for time, event in events: if event == 'arrival': current_present += 1 max_present = max(max_present, current_present) else: current_present -= 1 return max_present"},{"question":"def min_deletions_to_remove_char(s: str, c: str) -> int: Returns the minimum number of deletions required to remove all occurrences of the character c from string s. >>> min_deletions_to_remove_char(\\"abcabcabc\\", \\"b\\") 3 >>> min_deletions_to_remove_char(\\"hellohello\\", \\"l\\") 4 >>> min_deletions_to_remove_char(\\"mississippi\\", \\"s\\") 4 >>> min_deletions_to_remove_char(\\"abcdef\\", \\"x\\") 0 >>> min_deletions_to_remove_char(\\"python\\", \\"z\\") 0","solution":"def min_deletions_to_remove_char(s, c): Returns the minimum number of deletions required to remove all occurrences of the character c from string s. return s.count(c)"},{"question":"def is_beautiful(s: str) -> bool: Check if the given string is beautiful. A string is considered beautiful if no two adjacent characters are the same. >>> is_beautiful(\\"abc\\") True >>> is_beautiful(\\"aab\\") False >>> is_beautiful(\\"abac\\") True >>> is_beautiful(\\"\\") True","solution":"def is_beautiful(s: str) -> bool: Check if the given string is beautiful. A string is considered beautiful if no two adjacent characters are the same. :param s: The input string consisting of lowercase alphabets. :return: True if the string is beautiful, False otherwise. # An empty string or a single character string is trivially beautiful. if len(s) <= 1: return True # Iterate through the string and check for adjacent identical characters. for i in range(len(s) - 1): if s[i] == s[i + 1]: return False return True"},{"question":"from typing import List, Tuple, Optional def two_sum(arr: List[int], target: int) -> Optional[Tuple[int, int]]: Write a function that takes a list of integers and an integer target value, and returns a tuple of two integers from the list that sum up to the target value. >>> two_sum([2, 7, 11, 15], 9) (2, 7) >>> two_sum([3, 2, 4], 6) (2, 4) >>> two_sum([3, 3], 6) (3, 3) >>> two_sum([1, 2, 3], 7) None pass","solution":"def two_sum(arr, target): Returns a tuple of two integers from the list that sum up to the target value. If no such pair exists, return None. seen = {} for number in arr: complementary_number = target - number if complementary_number in seen: return (complementary_number, number) seen[number] = True return None"},{"question":"def duplicate_integers(nums: List[int]) -> List[int]: Given a list of non-negative integers, returns a new list where each integer is duplicated a number of times equal to its value. The order of integers is preserved. Parameters: nums (list): A list of non-negative integers. Returns: list: A new list with each integer duplicated as described. >>> duplicate_integers([1, 2, 3]) [1, 2, 2, 3, 3, 3] >>> duplicate_integers([0, 4, 1]) [4, 4, 4, 4, 1] >>> duplicate_integers([2, 1, 3]) [2, 2, 1, 3, 3, 3] >>> duplicate_integers([0, 0, 0]) [] >>> duplicate_integers([]) []","solution":"def duplicate_integers(nums): Given a list of non-negative integers, returns a new list where each integer is duplicated a number of times equal to its value. The order of integers is preserved. Parameters: nums (list): A list of non-negative integers. Returns: list: A new list with each integer duplicated as described. result = [] for num in nums: if num > 0: result.extend([num] * num) return result"},{"question":"def rearrange_linked_list(n: int, node_values: List[int]) -> List[int]: Reconstruct the linked list to satisfy the condition where no subset of nodes in the original list has the same sum as any subset of nodes in the new list. >>> rearrange_linked_list(2, [1, 2]) [2, 1] >>> rearrange_linked_list(4, [1000, 100, 10, 1]) [100, 1, 1000,10]","solution":"def rearrange_linked_list(n, node_values): # If the list has 1 node, there is no valid rearrangement possible if n == 1: return -1 # Sort the list to prevent ordered sums being equal node_values.sort() # Swap first and the last element in sorted list node_values[0], node_values[-1] = node_values[-1], node_values[0] return node_values"},{"question":"def largest_rectangle_area(heights): Find the largest rectangular area in a histogram. :param heights: List of integers representing the heights of the histogram blocks. :return: Integer representing the maximum area of the rectangular blocks. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([1, 2, 3, 4]) 6 >>> largest_rectangle_area([4, 3, 2, 1]) 6 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([0, 2, 0, 5, 0, 6, 0]) 6","solution":"def largest_rectangle_area(heights): Find the largest rectangular area in a histogram. :param heights: List of integers representing the heights of the histogram blocks. :return: Integer representing the maximum area of the rectangular blocks. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class MazeSolver: def __init__(self, grid): Initializes the MazeSolver with a grid. self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def has_path(self, start, end): Determine if there is a path from the start point to the end point. Uses depth-first search (DFS) or breadth-first search (BFS) algorithm to navigate through the grid. Args: start: A tuple (row, col) indicating the starting position. end: A tuple (row, col) indicating the ending position. Returns: A boolean indicating whether there is a path from the start point to the end point. Example: >>> maze_solver = MazeSolver([ [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) >>> maze_solver.has_path((0, 0), (4, 4)) True >>> maze_solver = MazeSolver([ [0, 1, 1, 1, 1], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) >>> maze_solver.has_path((0, 0), (4, 4)) False pass","solution":"class MazeSolver: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def has_path(self, start, end): start_row, start_col = start end_row, end_col = end if self.grid[start_row][start_col] == 1 or self.grid[end_row][end_col] == 1: return False visited = set() def dfs(row, col): if (row, col) == (end_row, end_col): return True if not (0 <= row < self.rows and 0 <= col < self.cols and self.grid[row][col] == 0 and (row, col) not in visited): return False visited.add((row, col)) # Explore neighbors: right, left, down, up return (dfs(row, col + 1) or dfs(row, col - 1) or dfs(row + 1, col) or dfs(row - 1, col)) return dfs(start_row, start_col)"},{"question":"def marathon_ranking(finish_time: int, overtakes: int) -> str: Determines the ranking of a runner based on their finish time and the number of other runners they have overtaken. >>> marathon_ranking(110, 10) \\"Elite\\" >>> marathon_ranking(150, 55) \\"Elite\\" >>> marathon_ranking(130, 25) \\"Pro\\" >>> marathon_ranking(190, 25) \\"Amateur\\" >>> marathon_ranking(160, 10) \\"Amateur\\"","solution":"def marathon_ranking(finish_time, overtakes): Determines the ranking of a runner based on their finish time and the number of other runners they have overtaken. Parameters: finish_time (int): Finish time of the runner in minutes. overtakes (int): Number of runners the runner has overtaken. Returns: str: The rank of the runner (Elite, Pro, or Amateur). if finish_time < 120 or overtakes > 50: return \\"Elite\\" elif 120 <= finish_time <= 180 and overtakes >= 20: return \\"Pro\\" else: return \\"Amateur\\""},{"question":"def raindrop_sound(n: int) -> str: Write a function which takes an integer as input and returns a string based on the following rules: - If the number has 3 as a factor, include \\"Pling\\" in the result. - If the number has 5 as a factor, include \\"Plang\\" in the result. - If the number has 7 as a factor, include \\"Plong\\" in the result. - If the number does not have any of 3, 5, or 7 as factors, return the number's digits as the result. >>> raindrop_sound(28) \\"Plong\\" >>> raindrop_sound(30) \\"PlingPlang\\" >>> raindrop_sound(34) \\"34\\" pass","solution":"def raindrop_sound(n: int) -> str: result = \\"\\" if n % 3 == 0: result += \\"Pling\\" if n % 5 == 0: result += \\"Plang\\" if n % 7 == 0: result += \\"Plong\\" if result == \\"\\": return str(n) return result"},{"question":"def is_armstrong_number(n: int) -> bool: Write a function that takes a positive integer \`n\` and returns \`True\` if \`n\` is an Armstrong number, and \`False\` otherwise. An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. >>> is_armstrong_number(153) == True >>> is_armstrong_number(9474) == True >>> is_armstrong_number(10) == False >>> is_armstrong_number(123) == False >>> is_armstrong_number(9926315) == True >>> is_armstrong_number(9926314) == False","solution":"def is_armstrong_number(n): Returns True if n is an Armstrong number, otherwise False. # Convert the number to a string to easily iterate through digits digits = str(n) # Calculate the number of digits num_digits = len(digits) # Calculate the sum of each digit raised to the power of num_digits armstrong_sum = sum(int(digit) ** num_digits for digit in digits) # Check if the calculated sum is equal to the original number return armstrong_sum == n"},{"question":"from typing import List def sum_consecutive_pairs(nums: List[int]) -> List[int]: Write a function that accepts a list of integers and returns a list of the sums of consecutive pairs of elements. If the list has an odd number of elements, simply add the last element by itself. >>> sum_consecutive_pairs([1, 2, 3, 4, 5]) == [3, 7, 5] >>> sum_consecutive_pairs([10, -10, 20, 30]) == [0, 50] >>> sum_consecutive_pairs([1]) == [1] >>> sum_consecutive_pairs([]) == [] >>> sum_consecutive_pairs([5, 3]) == [8] >>> sum_consecutive_pairs([-1, -2, -3, -4]) == [-3, -7] >>> sum_consecutive_pairs([4, 5, 6, 7, 8]) == [9, 13, 8] >>> sum_consecutive_pairs([1, -1, 2, -2, 3, -3, 4]) == [0, 0, 0, 4]","solution":"from typing import List def sum_consecutive_pairs(nums: List[int]) -> List[int]: Returns a list of the sums of consecutive pairs of elements in the input list. If the list has an odd number of elements, the last element is added by itself. result = [] for i in range(0, len(nums), 2): if i + 1 < len(nums): result.append(nums[i] + nums[i+1]) else: result.append(nums[i]) return result"},{"question":"def find_peak_time(T: int, test_cases: List[Tuple[int, List[Tuple[str, int]]]]) -> List[str]: Given a list of timestamps and the number of people entering or exiting a building, find the timestamp at which the maximum number of people are inside the building. >>> find_peak_time(2, [(5, [(\\"09:00\\", 5), (\\"09:30\\", -3), (\\"10:00\\", 4), (\\"10:30\\", -2), (\\"11:00\\", 3)]), (3, [(\\"12:00\\", 7), (\\"12:30\\", -4), (\\"13:00\\", 2)])]) [\\"11:00\\", \\"12:00\\"] >>> find_peak_time(1, [(4, [(\\"08:00\\", 2), (\\"09:00\\", 3), (\\"10:00\\", -2), (\\"11:00\\", 1)])]) [\\"09:00\\"] Args: T (int): Number of test cases test_cases (List[Tuple[int, List[Tuple[str, int]]]]): List of test cases with timestamps and population changes Returns: List[str]: List of timestamps with the maximum population inside the building","solution":"def find_peak_time(T, test_cases): results = [] for test_case in test_cases: N, data = test_case timestamps, changes = zip(*data) time_population = {} current_population = 0 for i in range(N): current_population += changes[i] time_population[timestamps[i]] = current_population max_population = max(time_population.values()) peak_time = min(time for time, pop in time_population.items() if pop == max_population) results.append(peak_time) return results"},{"question":"import numpy as np def concatenate_list_to_2d_space_separated(lst: str, k: int) -> np.ndarray: Given a space separated list of integers and an integer k, divide the list into k arrays of equal length and concatenate them along the columns to form a 2D NumPy array. >>> concatenate_list_to_2d_space_separated(\\"1 2 3 4 5 6\\", 2) array([[1, 4], [2, 5], [3, 6]]) >>> concatenate_list_to_2d_space_separated(\\"1 2 3 4 5 6 7 8\\", 2) array([[1, 5], [2, 6], [3, 7], [4, 8]]) >>> concatenate_list_to_2d_space_separated(\\"1 2 3 4 5 6 7 8 9 10 11 12\\", 3) array([[ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11], [ 4, 8, 12]]) >>> concatenate_list_to_2d_space_separated(\\"9 8 7 6 5 4 3 2 1 0\\", 2) array([[9, 4], [8, 3], [7, 2], [6, 1], [5, 0]]) >>> concatenate_list_to_2d_space_separated(\\"10000001 20000002 30000003 40000004\\", 4) array([[10000001, 20000002, 30000003, 40000004]])","solution":"import numpy as np def concatenate_list_to_2d_space_separated(lst, k): Given a space separated list of integers and an integer k, divides the list into k arrays of equal length and concatenate them along the columns to form a 2D NumPy array. Parameters: lst (str): Space separated list of integers. k (int): Number of arrays to divide the list into. Returns: np.ndarray: 2D array obtained by concatenating the k arrays along the columns. # Convert lst string to list of integers lst = list(map(int, lst.split())) n = len(lst) // k # Length of each segment # Divide the list into k arrays arrays = [np.array(lst[i * n: (i + 1) * n]) for i in range(k)] # Reshape each array to be a column vector and concatenate them along columns array_2d = np.concatenate([arr.reshape(-1, 1) for arr in arrays], axis=1) return array_2d"},{"question":"def day_of_week(date_str: str) -> str: Given a date string in the format \\"YYYY-MM-DD\\", returns the day of the week as a full name (e.g., \\"Monday\\", \\"Tuesday\\", etc.). >>> day_of_week(\\"2023-10-09\\") 'Monday' >>> day_of_week(\\"2021-12-25\\") 'Saturday'","solution":"from datetime import datetime def day_of_week(date_str): Given a date string in the format \\"YYYY-MM-DD\\", returns the day of the week as a full name (e.g., \\"Monday\\", \\"Tuesday\\", etc.). date_obj = datetime.strptime(date_str, \\"%Y-%m-%d\\") return date_obj.strftime(\\"%A\\")"},{"question":"def sum_of_squares(arr): Returns the sum of the squares of each element in the array. >>> sum_of_squares([1, 2, 3, 4]) 30 >>> sum_of_squares([0, 0, 0, 0]) 0 >>> sum_of_squares([0, 1, 2, 0]) 5 >>> sum_of_squares([-1, -2, -3, -4]) 30 >>> sum_of_squares([1, -1, 2, -2]) 10 >>> sum_of_squares([5]) 25 Parameters: arr (list of int): The list of integers. Returns: int: The sum of the squares of each element.","solution":"def sum_of_squares(arr): Returns the sum of the squares of each element in the array. Parameters: arr (list of int): The list of integers. Returns: int: The sum of the squares of each element. return sum(x ** 2 for x in arr)"},{"question":"def generate_cleaning_path(n): Generates a unique cleaning path for Code-cleaner 3000 to follow in an NxN grid. Parameters: n (int): Size of the grid (2 ≤ n ≤ 20) Returns: List[Tuple[int, int]]: A list of coordinates representing the cleaning path. pass # Example usage print(generate_cleaning_path(3))","solution":"def generate_cleaning_path(n): Generates a unique cleaning path for Code-cleaner 3000 to follow. Parameters: n (int): Size of the grid (2 ≤ n ≤ 20) Returns: List[Tuple[int, int]]: A list of coordinates representing the cleaning path. path = [] for i in range(n): if i % 2 == 0: for j in range(n): path.append((i, j)) else: for j in range(n-1, -1, -1): path.append((i, j)) return path"},{"question":"def max_product_of_three(numbers: str) -> int: Given a string containing a list of integers separated by commas (\`,\`), return the highest product obtainable by multiplying any three of the integers. If there are fewer than three numbers, return None/null. >>> max_product_of_three(\\"1,2,3,4\\") 24 >>> max_product_of_three(\\"1,2,-3,4\\") 8 >>> max_product_of_three(\\"1,2\\") None >> max_product_of_three(\\"\\") None","solution":"def max_product_of_three(numbers): Returns the maximum product of any three integers from the input string. If there are fewer than three numbers, return None. If input string is empty, return None. if not numbers: return None num_list = list(map(int, numbers.split(','))) if len(num_list) < 3: return None num_list.sort() # The maximum product can be obtained by either # 1. The product of the three largest numbers max_product1 = num_list[-1] * num_list[-2] * num_list[-3] # 2. The product of the two smallest numbers (which could be negative) and the largest number max_product2 = num_list[0] * num_list[1] * num_list[-1] return max(max_product1, max_product2)"},{"question":"def run_length_encode(s: str) -> str: Compresses the input string using Run-Length Encoding. Parameters: s (str): The input string consisting of uppercase English letters. Returns: str: The Run-Length Encoded string if shorter than the original, otherwise the original string. >>> run_length_encode(\\"AAAABBBCCDAA\\") 'A4B3C2D1A2' >>> run_length_encode(\\"ABCD\\") 'ABCD' >>> run_length_encode(\\"AAABBBCCCC\\") 'A3B3C4' >>> run_length_encode(\\"\\") '' >>> run_length_encode(\\"A\\") 'A' >>> run_length_encode(\\"AAAA\\") 'A4' >>> run_length_encode(\\"AABBCC\\") 'AABBCC' >>> run_length_encode(\\"AAABBBCCCDDD\\") 'A3B3C3D3' >>> run_length_encode(\\"A\\" * 100 + \\"B\\" * 50) 'A100B50'","solution":"def run_length_encode(s): Compresses the input string using Run-Length Encoding. Parameters: s (str): The input string consisting of uppercase English letters. Returns: str: The Run-Length Encoded string if shorter than the original, otherwise the original string. if len(s) == 0: return s encoded_string = [] last_char = s[0] count = 1 for char in s[1:]: if char == last_char: count += 1 else: encoded_string.append(f\\"{last_char}{count}\\") last_char = char count = 1 # Append the last character group encoded_string.append(f\\"{last_char}{count}\\") encoded_string = ''.join(encoded_string) if len(encoded_string) < len(s): return encoded_string else: return s"},{"question":"def alternate_case(input_string: str) -> str: Transforms the input string such that letters alternate in case, starting with uppercase, and numbers remain in their original position. >>> alternate_case(\\"a1b2c3D4\\") 'A1b2C3d4' >>> alternate_case(\\"3zXy5W9\\") '3ZxY5w9' >>> alternate_case(\\"abcdef\\") 'AbCdEf' >>> alternate_case(\\"ABCDEF\\") 'AbCdEf' >>> alternate_case(\\"123456\\") '123456'","solution":"def alternate_case(input_string): Transforms the input string such that letters alternate in case, starting with uppercase, and numbers remain in their original position. result = [] upper = True # Start with uppercase for char in input_string: if char.isalpha(): if upper: result.append(char.upper()) else: result.append(char.lower()) upper = not upper # Toggle case else: result.append(char) return ''.join(result)"},{"question":"from typing import List def longestIncreasingPath(matrix: List[List[int]]) -> int: Find the longest path in the matrix such that the path is strictly increasing in value. >>> matrix = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> longestIncreasingPath(matrix) 4 >>> matrix = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> longestIncreasingPath(matrix) 4 pass # Complete the function here","solution":"from typing import List def longestIncreasingPath(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) cache[x][y] = max_length return cache[x][y] m, n = len(matrix), len(matrix[0]) cache = [[-1] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] return max(dfs(x, y) for x in range(m) for y in range(n))"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix clockwise by 90 degrees in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [ [3, 1], [4, 2] ] pass def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_1x1_matrix(): matrix = [[1]] expected = [[1]] rotate_matrix(matrix) assert matrix == expected def test_rotate_5x5_matrix(): matrix = [ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] rotate_matrix(matrix) assert matrix == expected","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix clockwise by 90 degrees in place. n = len(matrix) # First, transpose the matrix: for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row: for i in range(n): matrix[i].reverse()"},{"question":"def next_char(s: str) -> str: Write a function that takes a string of English letters and returns another string where each character is replaced by the next character in the alphabet. If the character is 'z' or 'Z', it should be wrapped around to 'a' or 'A' respectively. Non-alphabetic characters should remain unchanged. >>> next_char(\\"abcXYZ\\") == \\"bcdYZA\\" >>> next_char(\\"Hello, World!\\") == \\"Ifmmp, Xpsme!\\" >>> next_char(\\"zZ\\") == \\"aA\\" from solution import next_char def test_next_char_only_lowercase(): assert next_char(\\"abcxyz\\") == \\"bcdyza\\" def test_next_char_only_uppercase(): assert next_char(\\"XYZABC\\") == \\"YZABCD\\" def test_next_char_mixed_case(): assert next_char(\\"abcXYZ\\") == \\"bcdYZA\\" def test_next_char_with_non_alpha_characters(): assert next_char(\\"Hello, World!\\") == \\"Ifmmp, Xpsme!\\" def test_next_char_wrap_around_edge_case(): assert next_char(\\"zZ\\") == \\"aA\\" def test_next_char_empty_string(): assert next_char(\\"\\") == \\"\\" def test_next_char_single_character(): assert next_char(\\"z\\") == \\"a\\" assert next_char(\\"Z\\") == \\"A\\" assert next_char(\\"A\\") == \\"B\\" def test_next_char_numbers_and_special_characters(): assert next_char(\\"1234!@#\\") == \\"1234!@#\\"","solution":"def next_char(s): result = [] for char in s: if 'a' <= char <= 'z': result.append(chr((ord(char) - ord('a') + 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': result.append(chr((ord(char) - ord('A') + 1) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"def sum_unique_elements(nums: List[int]) -> Union[int, str]: Takes a list of integers, removes duplicates, and returns the sum. If the list is empty, returns \\"List is empty\\". Args: nums (List[int]): A list of integers Returns: Union[int, str]: The sum of unique integers or \\"List is empty\\" if the list is empty Examples: >>> sum_unique_elements([1, 2, 3, 2, 4, 1]) 10 >>> sum_unique_elements([1, 2, 3, 4]) 10 >>> sum_unique_elements([]) \\"List is empty\\" >>> sum_unique_elements([5]) 5 >>> sum_unique_elements([3, 3, 3, 3]) 3 >>> sum_unique_elements([1, -1, 2, -2, 3]) 3","solution":"def sum_unique_elements(nums): Takes a list of integers, removes duplicates, and returns the sum. If the list is empty, returns \\"List is empty\\". if not nums: return \\"List is empty\\" unique_nums = list(set(nums)) # Removes duplicates return sum(unique_nums)"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Given a string \`s\`, return the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"\\") 0 >>> longest_substring_without_repeating_characters(\\"a\\") 1 >>> longest_substring_without_repeating_characters(\\"abcdef\\") 6 >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"aab\\") 2 >>> longest_substring_without_repeating_characters(\\"dvdf\\") 3 >>> longest_substring_without_repeating_characters(\\"tmmzuxt\\") 5 >>> longest_substring_without_repeating_characters(\\"anviaj\\") 5 >>> longest_substring_without_repeating_characters(\\"aabcdefgghh\\") 7 >>> longest_substring_without_repeating_characters(\\"aaabaaaabcd\\") 4 pass","solution":"def longest_substring_without_repeating_characters(s): Given a string \`s\`, return the length of the longest substring without repeating characters. if not s: return 0 # Dictionary to store the last positions of each character char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): # If the character is found in the map and the start is less than or equal to the character index if char in char_index_map and start <= char_index_map[char]: start = char_index_map[char] + 1 else: longest = max(longest, i - start + 1) # Update the last position of the character char_index_map[char] = i return longest"},{"question":"def can_sort_books(books: str) -> bool: Determine if it is possible to sort the books using the given operations. Given an initial sequence of books on a shelf represented by a string, return True if it is possible to sort the books in non-decreasing order by reversing any consecutive subsequence any number of times, otherwise return False. Example: >>> can_sort_books(\\"edcba\\") True >>> can_sort_books(\\"dcbaef\\") True","solution":"def can_sort_books(books): Determine if it's possible to sort the books using the given operations. Since every character in the input string is distinct and we can reverse any subsequence, it is always possible to sort the string using these operations. sorted_books = ''.join(sorted(books)) # Check if the sorted string is equal to the actual sorted version return books == sorted_books or True"},{"question":"def sum_of_digits(n: int) -> int: Calculate the sum of all the digits in an integer. Given an integer 'n' (where 'n >= 0'), return the sum of its digits. For negative cases, the absolute value of 'n' should be considered. Example: >>> sum_of_digits(12345) 15 >>> sum_of_digits(9876543210) 45","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the non-negative integer n. return sum(int(digit) for digit in str(n))"},{"question":"def find_unsorted_subarray(nums): Finds the shortest subarray which when sorted makes the entire array sorted. Args: nums: List[int] - the input array of integers. Returns: List[int] - the sorted subarray that needs to be sorted. Examples: >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) [4, 6, 8, 9, 10] >>> find_unsorted_subarray([1, 2, 3, 4]) [] >>> find_unsorted_subarray([1]) [] >>> find_unsorted_subarray([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]","solution":"def find_unsorted_subarray(nums): Finds the shortest subarray which when sorted makes the entire array sorted. Args: nums: List[int] - the input array of integers. Returns: List[int] - the sorted subarray that needs to be sorted. n = len(nums) start, end = 0, -1 max_val, min_val = float('-inf'), float('inf') for i in range(n): if nums[i] < max_val: end = i else: max_val = nums[i] for i in range(n-1, -1, -1): if nums[i] > min_val: start = i else: min_val = nums[i] if end == -1: return [] return sorted(nums[start:end+1])"},{"question":"def find_single(nums: List[int]) -> int: Find the integer that appears only once in the list where every other integer appears twice. >>> find_single([2, 2, 1]) 1 >>> find_single([4, 1, 2, 1, 2]) 4 >>> find_single([1]) 1 >>> find_single([17, 12, 18, 18, 12]) 17 >>> find_single([7, 3, 5, 3, 7, 9, 5]) 9 pass","solution":"def find_single(nums): Find the integer that appears only once in the list where every other integer appears twice. result = 0 for num in nums: result ^= num return result"},{"question":"from typing import List def differences_from_average(nums: List[int]) -> List[int]: Returns a new list where each element is the difference between the corresponding element in the original list and the average of the list, rounded to the nearest integer. Arguments: nums -- list of integers Returns: List of integers Examples: >>> differences_from_average([2, 4, 6, 8]) [-3, -1, 1, 3] >>> differences_from_average([10, 10, 10, 10]) [0, 0, 0, 0] >>> differences_from_average([-1, -3, -5, -7]) [3, 1, -1, -3] >>> differences_from_average([-2, 0, 2, 4]) [-3, -1, 1, 3]","solution":"def differences_from_average(nums): Returns a new list where each element is the difference between the corresponding element in the original list and the average of the list, rounded to the nearest integer. Arguments: nums -- list of integers Returns: List of integers if not nums: return [] avg = sum(nums) / len(nums) return [round(num - avg) for num in nums]"},{"question":"def judge_circle(moves: str) -> bool: Determines if the sequence of moves returns to the original starting position on a grid. Args: moves (str): string containing the moves Returns: bool: True if the moves return to the starting position, False otherwise >>> judge_circle(\\"UD\\") True >>> judge_circle(\\"LL\\") False","solution":"def judge_circle(moves): Determines if the sequence of moves returns to the original starting position on a grid. Args: moves (str): string containing the moves Returns: bool: True if the moves return to the starting position, False otherwise x, y = 0, 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"def wordFrequency(text: str) -> dict: Counts the frequency of each word in the given string. The function ignores punctuation and is case-insensitive. >>> wordFrequency(\\"\\") == {} >>> wordFrequency(\\"hello\\") == {\\"hello\\": 1} >>> wordFrequency(\\"hello hello\\") == {\\"hello\\": 2} >>> wordFrequency(\\"Hello hello\\") == {\\"hello\\": 2} >>> wordFrequency(\\"Hello, world! Hello.\\") == {\\"hello\\": 2, \\"world\\": 1} >>> wordFrequency(\\"This is a test. This test is only a test.\\") == {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1} >>> wordFrequency(\\"Coding is fun! Fun coding.\\") == {\\"coding\\": 2, \\"is\\": 1, \\"fun\\": 2} Parameters: text (str): The input string. Returns: dict: A dictionary where keys are words and values are their frequencies.","solution":"import re from collections import defaultdict def wordFrequency(text): Counts the frequency of each word in the given string. Parameters: text (str): The input string. Returns: dict: A dictionary where keys are words and values are their frequencies. # Convert text to lowercase text = text.lower() # Remove punctuation marks text = re.sub(r'[^ws]', '', text) # Split text into words words = text.split() # Use defaultdict to count word frequencies frequency_dict = defaultdict(int) for word in words: frequency_dict[word] += 1 return dict(frequency_dict)"},{"question":"def count_distinct_repeated_letters(s: str) -> int: Counts the distinct letters that appear more than once in the string. The comparison should be case-insensitive, but the count should be based on the original case. >>> count_distinct_repeated_letters(\\"abcdef\\") == 0 >>> count_distinct_repeated_letters(\\"aabbcc\\") == 3 >>> count_distinct_repeated_letters(\\"AaBbCc\\") == 3 >>> count_distinct_repeated_letters(\\"AabcBddeEf\\") == 4 >>> count_distinct_repeated_letters(\\"\\") == 0 >>> count_distinct_repeated_letters(\\"aA\\") == 1 >>> count_distinct_repeated_letters(\\"a1!A\\") == 1","solution":"def count_distinct_repeated_letters(s): Counts the distinct letters that appear more than once in the string. Args: s (str): The input string. Returns: int: The count of distinct letters that appear more than once. from collections import Counter # Normalize to lowercase for case-insensitive comparison normalized = s.lower() # Count occurrences of each character counter = Counter(normalized) # Filter to find characters that appear more than once repeated_characters = {char for char, count in counter.items() if count > 1} return len(repeated_characters)"},{"question":"def list_depth(lst: Any) -> int: Determines the depth of a nested list. The depth of a list is defined as the maximum depth of any nested list plus one. An empty list has a depth of 1. >>> list_depth([]) == 1 >>> list_depth([1, 2, 3]) == 1 >>> list_depth([1, [2, 3], 4]) == 2 >>> list_depth([1, [2, [3, 4], 5], 6]) == 3 >>> list_depth([1, [2, [3, [4, 5]]]]) == 4 >>> list_depth(5) == 0 >>> list_depth([1, \\"string\\", [2.5, [True, None]]]) == 3","solution":"def list_depth(lst): Determines the depth of a nested list. if not isinstance(lst, list): return 0 max_depth = 0 for item in lst: max_depth = max(max_depth, list_depth(item)) return max_depth + 1"},{"question":"def rotate_list(numbers: List[int], k: int) -> None: Rotates the input list 'numbers' by 'k' steps to the right in place. >>> a = [1, 2, 3, 4, 5, 6] >>> rotate_list(a, 2) >>> a [5, 6, 1, 2, 3, 4] >>> b = [1, 2, 3, 4, 5, 6] >>> rotate_list(b, 0) >>> b [1, 2, 3, 4, 5, 6] >>> c = [1] >>> rotate_list(c, 1) >>> c [1] >>> d = [10, 20, 30, 40] >>> rotate_list(d, 1) >>> d [40, 10, 20, 30] >>> e = [3, -1, 0, 7, 4] >>> rotate_list(e, 4) >>> e [-1, 0, 7, 4, 3]","solution":"def rotate_list(numbers, k): Rotates the input list 'numbers' by 'k' steps to the right in place. n = len(numbers) k = k % n # Handle cases where k is greater than the length of the list if k == 0: return # No rotation needed # Perform the rotation in place numbers[:] = numbers[-k:] + numbers[:-k]"},{"question":"def is_balanced(s: str) -> bool: Determines if the input string of parentheses is balanced. Args: s (str): input string containing only '(' and ')' Returns: bool: True if the string is balanced, False otherwise Examples: >>> is_balanced(\\"()\\") True >>> is_balanced(\\"(())\\") True >>> is_balanced(\\"(()\\") False >>> is_balanced(\\"())(\\") False","solution":"def is_balanced(s): Determines if the input string of parentheses is balanced. Args: s (str): input string containing only '(' and ')' Returns: bool: True if the string is balanced, False otherwise stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def reorganizeString(s: str) -> str: Rearranges the characters of the string such that no two adjacent characters are the same. If not possible, returns an empty string. >>> reorganizeString(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> reorganizeString(\\"aaab\\") == \\"\\" True >>> len(reorganizeString(\\"aabbbbcc\\")) == len(\\"aabbbbcc\\") True >>> all(reorganizeString(\\"aabbbbcc\\")[i] != reorganizeString(\\"aabbbbcc\\")[i+1] for i in range(len(reorganizeString(\\"aabbbbcc\\"))-1)) True >>> reorganizeString(\\"aaaa\\") == \\"\\" True >>> length = 12 >>> all(reorganizeString(\\"aabbccddeeff\\")[i] != reorganizeString(\\"aabbccddeeff\\")[i+1] for i in range(length-1)) True","solution":"from collections import Counter import heapq def reorganizeString(s): Rearranges the characters of the string such that no two adjacent characters are the same. If not possible, returns an empty string. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \\"\\" result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count+1, char result_string = \\"\\".join(result) if len(result_string) != len(s): return \\"\\" return result_string"},{"question":"def simplify_path(path: str) -> str: Simplifies a given UNIX file path to its absolute path. >>> simplify_path(\\"/home/\\") \\"/home\\" >>> simplify_path(\\"/../\\") \\"/\\" >>> simplify_path(\\"/home//foo/\\") \\"/home/foo\\" >>> simplify_path(\\"/a/./b/../../c/\\") \\"/c\\"","solution":"def simplify_path(path): Simplifies a given UNIX file path to its absolute path. parts = path.split('/') stack = [] for part in parts: if part == '' or part == '.': continue elif part == '..': if stack: stack.pop() else: stack.append(part) return '/' + '/'.join(stack)"},{"question":"def min_deletions_to_make_stable(s: str) -> int: Returns the minimum number of deletions required to make the string stable. A string is considered 'stable' if it does not contain any adjacent characters that are the same. >>> min_deletions_to_make_stable(\\"aab\\") 1 >>> min_deletions_to_make_stable(\\"aaaa\\") 3 from solution import min_deletions_to_make_stable def test_min_deletions_example1(): assert min_deletions_to_make_stable(\\"aab\\") == 1 def test_min_deletions_example2(): assert min_deletions_to_make_stable(\\"aaaa\\") == 3 def test_min_deletions_single_character(): assert min_deletions_to_make_stable(\\"a\\") == 0 def test_min_deletions_no_deletion_needed(): assert min_deletions_to_make_stable(\\"abcd\\") == 0 def test_min_deletions_alternating_characters(): assert min_deletions_to_make_stable(\\"abababab\\") == 0 def test_min_deletions_all_identical_characters(): assert min_deletions_to_make_stable(\\"bbbbbbb\\") == 6 # 7 characters, need to remove 6 def test_min_deletions_mixed_characters(): assert min_deletions_to_make_stable(\\"abccba\\") == 1 # Delete one 'c' def test_min_deletions_long_string(): assert min_deletions_to_make_stable(\\"aabbccddeeffgg\\") == 7 # Delete one character from each pair","solution":"def min_deletions_to_make_stable(s): Returns the minimum number of deletions required to make the string stable. A string is considered 'stable' if it does not contain any adjacent characters that are the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def isCircle(moves: str) -> bool: Determines if the robot ends up exactly at the starting position (0, 0) after the sequence of movements. Args: moves: A string containing the sequence of movements, where 'L' means left, 'R' means right, 'U' means up, and 'D' means down. Returns: bool: True if the robot ends up at the starting position (0, 0), False otherwise. Example: >>> isCircle(\\"UD\\") True >>> isCircle(\\"LLRR\\") True >>> isCircle(\\"U\\") False >>> isCircle(\\"L\\"*5000 + \\"R\\"*5000) True","solution":"def isCircle(moves): Returns True if the robot ends up at the starting position (0, 0) after the sequence of movements. Returns False otherwise. x, y = 0, 0 # starting position for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"from typing import List def combination_sum(nums: List[int], target: int) -> List[List[int]]: Given an array of distinct integers and an integer target, return all unique combinations of the array elements that add up to the target. You may return the combinations in any order. The same number can be used multiple times. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2], 1) [] >>> combination_sum([1], 1) [[1]] >>> combination_sum([1], 2) [[1, 1]]","solution":"def combination_sum(nums, target): def backtrack(remain, combo, start): if remain < 0: return elif remain == 0: result.append(list(combo)) else: for i in range(start, len(nums)): combo.append(nums[i]) backtrack(remain - nums[i], combo, i) combo.pop() result = [] backtrack(target, [], 0) return result"},{"question":"def trap(height: List[int]) -> int: Calculates the amount of trapped water in the elevation map. :param height: List[int], a list of non-negative integers representing elevation heights :return: int, the total amount of trapped water >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4,2,0,3,2,5]) == 9 >>> trap([]) == 0 >>> trap([1]) == 0 >>> trap([1, 2]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([1, 1, 1, 1]) == 0","solution":"def trap(height): Calculates the amount of trapped water in the elevation map. :param height: List[int], a list of non-negative integers representing elevation heights :return: int, the total amount of trapped water if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def tournament_winner(ts): Determine the winner of the tournament given the list of magic levels of the wizards for each test case. >>> tournament_winner([[4, 10, 40, 30, 20], [2, 50, 50], [5, 15, 25, 15, 25, 15]]) [40, 50, 25] >>> tournament_winner([[3, 5, 10, 15], [1, 100], [6, 1, 2, 3, 4, 5, 6]]) [15, 100, 6] >>> tournament_winner([[2, 7, 7], [4, 20, 5, 15, 10], [3, 1, 2, 3]]) [7, 20, 3] >>> tournament_winner([[1, 999], [2, 1, 2], [4, 4, 4, 4, 4]]) [999, 2, 4] >>> tournament_winner([[5, 10, 20, 30, 40, 50], [7, 44, 22, 33, 55, 66, 100, 200]]) [50, 200] >>> tournament_winner([[1, 5]]) [5] >>> tournament_winner([[1, 0]]) [0]","solution":"def tournament_winner(ts): Determine the winner of the tournament given the list of magic levels of the wizards for each test case. def find_winner(magic_levels): while len(magic_levels) > 1: next_round = [] for i in range(0, len(magic_levels), 2): if i + 1 < len(magic_levels): if magic_levels[i] >= magic_levels[i + 1]: next_round.append(magic_levels[i]) else: next_round.append(magic_levels[i + 1]) else: next_round.append(magic_levels[i]) magic_levels = next_round return magic_levels[0] result = [] for t in ts: n = t[0] magic_levels = t[1:] result.append(find_winner(magic_levels)) return result"},{"question":"def min_range_to_deliver_all_packages(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum range R so that the robot can deliver all packages in one go. >>> min_range_to_deliver_all_packages(2, [(4, [-5, 8, 2, -3]), (3, [10, -10, 0])]) [13, 20] >>> min_range_to_deliver_all_packages(1, [(1, [0])]) [0] >>> min_range_to_deliver_all_packages(1, [(3, [1, 2, 3])]) [2] >>> min_range_to_deliver_all_packages(1, [(3, [-1, -2, -3])]) [2] >>> min_range_to_deliver_all_packages(1, [(2, [1000000000, -1000000000])]) [2000000000] >>> min_range_to_deliver_all_packages(1, [(4, [-1, 1, 0, -1])]) [2] >>> min_range_to_deliver_all_packages(1, [(5, [1, 1, 1, 1, 1])]) [0] >>> locations = list(range(-500000, 500000)) >>> min_range_to_deliver_all_packages(1, [(1000000, locations)]) [999999]","solution":"def min_range_to_deliver_all_packages(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] locations = test_cases[i][1] min_position = min(locations) max_position = max(locations) R = max_position - min_position results.append(R) return results # Example usage: # T = 2 # test_cases = [ # (4, [-5, 8, 2, -3]), # (3, [10, -10, 0]) # ] # print(min_range_to_deliver_all_packages(T, test_cases)) # Output: [13, 20]"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a string. Parameters: s (str): The input string. Returns: str: A string with words in reverse order. Examples: >>> reverse_words(\\"The quick brown fox\\") 'fox brown quick The' >>> reverse_words(\\"Hello world! \\") 'world! Hello' >>> reverse_words(\\" a good example \\") 'example good a'","solution":"def reverse_words(s: str) -> str: Reverses the order of words in a string. Parameters: s (str): The input string. Returns: str: A string with words in reverse order. # Strip leading/trailing spaces and split the string into words words = s.strip().split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with a single space separator return ' '.join(reversed_words)"},{"question":"def can_complete_transaction(n, prices, m, selections, money): Determine if a vending machine transaction can be completed with a given amount of money. Parameters: n (int): Number of products in the machine. prices (list): List of prices of each product. m (int): Number of product selections for the transaction. selections (list): Indices of products selected for the transaction. money (int): Amount of money the customer has. Returns: str: \\"Yes\\" if the transaction can be completed, \\"No\\" otherwise. >>> can_complete_transaction(5, [10, 20, 30, 40, 50], 3, [1, 2, 3], 60) \\"Yes\\" >>> can_complete_transaction(4, [5, 10, 15, 20], 2, [1, 4], 25) \\"Yes\\" >>> can_complete_transaction(3, [1, 100, 1000], 2, [1, 3], 50) \\"No\\" pass def process_transactions(t, transactions): Process multiple vending machine transactions. Parameters: t (int): Number of test cases. transactions (list): List of tuples, each containing details of a single transaction. Returns: list: List of results for each transaction (\\"Yes\\" or \\"No\\"). >>> t = 3 >>> transactions = [ ... (5, [10, 20, 30, 40, 50], 3, [1, 2, 3], 60), ... (4, [5, 10, 15, 20], 2, [1, 4], 25), ... (3, [1, 100, 1000], 2, [1, 3], 50) ... ] >>> process_transactions(t, transactions) [\\"Yes\\", \\"Yes\\", \\"No\\"] pass","solution":"def can_complete_transaction(n, prices, m, selections, money): total_cost = sum(prices[idx - 1] for idx in selections) return \\"Yes\\" if money >= total_cost else \\"No\\" def process_transactions(t, transactions): results = [] for i in range(t): n = transactions[i][0] prices = transactions[i][1] m = transactions[i][2] selections = transactions[i][3] money = transactions[i][4] result = can_complete_transaction(n, prices, m, selections, money) results.append(result) return results"},{"question":"def count_bits(n: int) -> int: Returns the number of bits that are equal to one in the binary representation of the input number. >>> count_bits(0) 0 >>> count_bits(4) 1 >>> count_bits(7) 3 >>> count_bits(9) 2 >>> count_bits(10) 2","solution":"def count_bits(n): Returns the number of bits that are equal to one in the binary representation of the input number. Args: n (int): A non-negative integer. Returns: int: The count of bits set to one in the binary representation of n. return bin(n).count('1')"},{"question":"def judge_circle(instructions: str) -> bool: Determine if the robot returns to its original starting position after completing all the moves in the sequence. Args: instructions (str): A string consisting of characters 'U', 'D', 'L', and 'R'. Returns: bool: True if the robot returns to the origin, else False. Examples: >>> judge_circle(\\"UD\\") True >>> judge_circle(\\"LL\\") False >>> judge_circle(\\"RRDD\\") False >>> judge_circle(\\"LDRRULDL\\") False","solution":"def judge_circle(instructions): Returns True if the robot returns to the origin after executing all instructions. x, y = 0, 0 for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 return x == 0 and y == 0"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. Operations include swap, remove, and insert. >>> min_operations(\\"abcdef\\", \\"azced\\") 3 >>> min_operations(\\"hello\\", \\"hello\\") 0 >>> min_operations(\\"abc\\", \\"aebfcg\\") 3 >>> min_operations(\\"abcdefgh\\", \\"abc\\") 5 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3","solution":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. Operations include swap, remove, and insert. m, n = len(s1), len(s2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize table for base cases for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # If s2 is empty, remove all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def count_substring(main_string: str, sub_string: str) -> int: Returns the number of times the sub_string appears in the main_string without overlapping. >>> count_substring(\\"ababa\\", \\"aba\\") 1 >>> count_substring(\\"aaaa\\", \\"aa\\") 2 >>> count_substring(\\"abcabcabc\\", \\"abc\\") 3 >>> count_substring(\\"abcdef\\", \\"gh\\") 0 >>> count_substring(\\"abcdef\\", \\"\\") 0 >>> count_substring(\\"\\", \\"abc\\") 0 >>> count_substring(\\"\\", \\"\\") 0 >>> count_substring(\\"abc\\", \\"abcd\\") 0","solution":"def count_substring(main_string, sub_string): Returns the number of times the sub_string appears in the main_string without overlapping. if not sub_string: # If sub_string is empty return 0 count = 0 start = 0 while True: start = main_string.find(sub_string, start) if start == -1: # No more occurrences found break count += 1 start += len(sub_string) # Move past this occurrence return count"},{"question":"def palindromic_sum(arr: List[int]) -> bool: Check whether the sum of the elements of the given integer array is a palindromic number. A palindromic number is a number that remains the same when its digits are reversed. >>> palindromic_sum([1, 2, 3, 4]) # Returns False >>> palindromic_sum([11, 22, 3, 4]) # Returns True","solution":"def palindromic_sum(arr): Returns True if the sum of the elements in the array is a palindromic number, otherwise returns False. Parameters: arr (list of int): A list of integers Returns: bool: True if the sum is a palindromic number, False otherwise total_sum = sum(arr) str_sum = str(total_sum) return str_sum == str_sum[::-1]"},{"question":"def count_palindromic_substrings(s: str) -> int: Determine the number of palindromic substrings within the given string. Each character in the string is considered a valid palindromic substring. Args: s (str): The input string containing only lowercase English letters. Returns: int: The number of palindromic substrings in the given string s. Examples: >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 # Function to count palindromes centered at left and right def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindromes expand_around_center(i, i + 1) # Even length palindromes return count"},{"question":"from itertools import combinations from typing import List def generate_combinations(arr: List[int], max_len: int, sum_target: int) -> List[List[int]]: Generate all unique combinations of integers from the list \`arr\`, with the length of each combination not exceeding \`max_len\` and the sum of elements in each combination exactly being \`sum_target\`. Parameters: arr (list): List of integers to generate combinations from. max_len (int): Maximum length of each combination. sum_target (int): The sum that each combination should match. Returns: list: Unique combinations meeting the constraints. >>> generate_combinations([1, 2, 3, 4, 5], 3, 6) [[1, 2, 3], [1, 5], [2, 4]] >>> generate_combinations([1, 1, 2, 2, 3], 2, 3) [[1, 2], [3]] >>> generate_combinations([], 3, 6) [] >>> generate_combinations([1, 1, 1], 3, 6) [] >>> generate_combinations([1, 1, 2, 2, 3, 3], 2, 4) [[1, 3], [2, 2]] >>> generate_combinations([1, 2, 3, 4, 5], 2, 6) [[1, 5], [2, 4]] >>> generate_combinations([3], 1, 3) [[3]] >>> generate_combinations([1, 2, 3], 3, 6) [[1, 2, 3]] pass","solution":"from itertools import combinations def generate_combinations(arr, max_len, sum_target): Generate all unique combinations of integers from the list \`arr\`, with the length of each combination not exceeding \`max_len\` and the sum of elements in each combination exactly being \`sum_target\`. Parameters: arr (list): List of integers to generate combinations from. max_len (int): Maximum length of each combination. sum_target (int): The sum that each combination should match. Returns: list: Unique combinations meeting the constraints. result = set() arr.sort() for length in range(1, max_len + 1): for comb in combinations(arr, length): if sum(comb) == sum_target: result.add(comb) # Convert the set of tuple combinations into a sorted list of lists return sorted([list(comb) for comb in result])"},{"question":"def sum_of_two_largest_unique(numbers: List[int]) -> int: Returns the sum of the two largest unique numbers in the list. If the list contains less than two unique numbers, returns 0. >>> sum_of_two_largest_unique([5, 5, 4, 3]) 9 >>> sum_of_two_largest_unique([2, 1, 1]) 3 >>> sum_of_two_largest_unique([1]) 0","solution":"def sum_of_two_largest_unique(numbers): Returns the sum of the two largest unique numbers in the list. If the list contains less than two unique numbers, returns 0. unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return 0 unique_numbers.sort(reverse=True) return unique_numbers[0] + unique_numbers[1]"},{"question":"from typing import List def largest_connected_component(matrix: List[List[int]], x: int, y: int) -> int: Given a matrix of integers and a starting point (x, y), find the size of the largest connected component of adjacent cells that contain the same value, starting from the (x, y). >>> matrix = [ ... [1, 1, 0, 0, 0], ... [0, 1, 0, 1, 1], ... [1, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> largest_connected_component(matrix, 1, 1) 3 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> largest_connected_component(matrix, 0, 0) 1 >>> matrix = [ ... [1, 1], ... [1, 1] ... ] >>> largest_connected_component(matrix, 0, 1) 4","solution":"from typing import List, Tuple def largest_connected_component(matrix: List[List[int]], x: int, y: int) -> int: def dfs(matrix: List[List[int]], x: int, y: int, target: int, visited: set) -> int: if (x, y) in visited or x < 0 or y < 0 or x >= len(matrix) or y >= len(matrix[0]) or matrix[x][y] != target: return 0 visited.add((x, y)) size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(matrix, x + dx, y + dy, target, visited) return size target = matrix[x][y] visited = set() return dfs(matrix, x, y, target, visited)"},{"question":"from typing import List from collections import Counter def min_actions_to_organize_stamps(n: int, stamps: List[int]) -> int: Determine the minimum number of actions needed to organize the collection into sets of stamps where each set is homogeneous. ----Input---- - The first parameter is an integer n, the number of stamps in the collection. - The second parameter is a list of n integers, each representing the type of a stamp. ----Output---- - Return a single integer denoting the minimum number of actions required to organize the collection. >>> min_actions_to_organize_stamps(5, [2, 3, 2, 3, 2]) 2 >>> min_actions_to_organize_stamps(4, [1, 1, 1, 1]) 1 >>> min_actions_to_organize_stamps(4, [1, 2, 3, 4]) 4 >>> min_actions_to_organize_stamps(6, [5, 5, 6, 6, 6, 7]) 3 >>> min_actions_to_organize_stamps(1, [8]) 1","solution":"def min_actions_to_organize_stamps(n, stamps): from collections import Counter stamp_counter = Counter(stamps) # The number of unique types of stamps num_unique_types = len(stamp_counter) return num_unique_types"},{"question":"import math from typing import List, Tuple def largest_square_plot(l: int, w: int) -> Tuple[int, int]: Calculate the side length of the largest square plot that can be used to divide the entire field and the number of such square plots. >>> largest_square_plot(6, 9) (3, 6) >>> largest_square_plot(4, 5) (1, 20) def process_test_cases(t: int, cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Process multiple test cases to determine the largest square plot side length and number for each case. >>> process_test_cases(3, [(6, 9), (4, 5), (15, 10)]) [(3, 6), (1, 20), (5, 6)] >>> process_test_cases(2, [(10, 10), (7, 11)]) [(10, 1), (1, 77)]","solution":"import math def largest_square_plot(l, w): gcd = math.gcd(l, w) num_plots = (l // gcd) * (w // gcd) return gcd, num_plots def process_test_cases(t, cases): results = [] for l, w in cases: results.append(largest_square_plot(l, w)) return results"},{"question":"def detect_substring_anagram(s: str, p: str) -> bool: Write a function that checks if an anagram of a given pattern exists as a substring within a given string. Args: s (str): The string to be checked. p (str): The pattern to look for as an anagram. Returns: bool: True if an anagram of the pattern exists as a substring within the given string, False otherwise. >>> detect_substring_anagram(\\"cbaebabacd\\", \\"abc\\") True >>> detect_substring_anagram(\\"af\\", \\"be\\") False >>> detect_substring_anagram(\\"abcd\\", \\"abcd\\") True >>> detect_substring_anagram(\\"abcdefg\\", \\"hij\\") False >>> detect_substring_anagram(\\"aaaa\\", \\"aa\\") True >>> detect_substring_anagram(\\"a\\", \\"aa\\") False >>> detect_substring_anagram(\\"abababab\\", \\"aba\\") True >>> detect_substring_anagram(\\"abacbabc\\", \\"abc\\") True","solution":"def detect_substring_anagram(s, p): from collections import Counter len_s = len(s) len_p = len(p) if len_p > len_s: return False p_counter = Counter(p) window_counter = Counter(s[:len_p]) if p_counter == window_counter: return True for i in range(len_p, len_s): window_counter[s[i]] += 1 window_counter[s[i - len_p]] -= 1 if window_counter[s[i - len_p]] == 0: del window_counter[s[i - len_p]] if p_counter == window_counter: return True return False"},{"question":"from typing import List, Tuple def max_treasures_collected(grid: List[str], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determine the maximum number of treasures that can be collected starting from a given initial position and ending at a target position in a grid. >>> max_treasures_collected([\\".T...\\", \\".#.#.\\", \\"..T..\\", \\"#T#\\", \\"...T.\\"], (0, 0), (4, 4)) 3 >>> max_treasures_collected([\\".T.\\", \\"#.#\\", \\"..T\\"], (0, 0), (2, 2)) 2 >>> max_treasures_collected([\\"T.#\\", \\"#T#\\", \\"T.T\\"], (1, 0), (2, 2)) -1 >>> max_treasures_collected([\\"T.T\\", \\"#T#\\", \\"T#T\\"], (0, 0), (2, 1)) -1 >>> max_treasures_collected([\\".T.\\", \\"#\\", \\"...\\"], (0, 0), (2, 2)) -1","solution":"from collections import deque def max_treasures_collected(grid, start, end): M = len(grid) N = len(grid[0]) x1, y1 = start x2, y2 = end # Possible directions to move (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the start or end positions are obstacles if grid[x1][y1] == \\"#\\" or grid[x2][y2] == \\"#\\": return -1 # BFS Queue: store (x, y, number_of_treasures) queue = deque([(x1, y1, 0 if grid[x1][y1] != 'T' else 1)]) visited = {(x1, y1)} while queue: x, y, treasures = queue.popleft() # If we reached the end if (x, y) == (x2, y2): return treasures for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) new_treasures = treasures + (1 if grid[nx][ny] == 'T' else 0) queue.append((nx, ny, new_treasures)) # If we exhaust the queue and haven't found the end, return -1 return -1 def main(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) grid = [] index = 2 for i in range(M): grid.append(data[index]) index += 1 start = (int(data[index]) - 1, int(data[index + 1]) - 1) end = (int(data[index + 2]) - 1, int(data[index + 3]) - 1) print(max_treasures_collected(grid, start, end)) if __name__ == \\"__main__\\": main()"},{"question":"def longest_word(sentence: str) -> str: Returns the longest word in the sentence. If there are multiple longest words, returns the first one. >>> longest_word(\\"The quick brown fox jumped over the lazy dog\\") == \\"jumped\\" >>> longest_word(\\"I love eating pizza and pasta\\") == \\"eating\\" >>> longest_word(\\"dog cat rat bat hat mat\\") == \\"dog\\" >>> longest_word(\\"\\") == \\"\\" >>> longest_word(\\"Python\\") == \\"Python\\" >>> longest_word(\\"Hello, how are you doing today?\\") == \\"Hello,\\" >>> longest_word(\\"Good m@rning, h@ve a nice d@y!\\") == \\"m@rning,\\" >>> longest_word(\\"HeLLo ThERe EvERYONE\\") == \\"EvERYONE\\"","solution":"def longest_word(sentence): Returns the longest word in the sentence. If there are multiple longest words, returns the first one. words = sentence.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"from typing import List def is_magic_square(square: List[List[int]]) -> bool: Determines if a given 2D list (square) is a magic square. A magic square is a 2D square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same. Parameters: square (list of list of int): A 2D list representing the square grid. Returns: bool: True if the input is a magic square, False otherwise. pass def test_is_magic_square_true_case(): square = [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ] assert is_magic_square(square) == True def test_is_magic_square_false_case(): square = [ [1, 2], [3, 4] ] assert is_magic_square(square) == False def test_is_magic_square_large_true_case(): square = [ [16, 3, 2, 13], [5, 10, 11, 8 ], [9, 6, 7, 12], [4, 15, 14, 1 ] ] assert is_magic_square(square) == True def test_is_magic_square_large_false_case(): square = [ [16, 3, 2, 13], [5, 10, 11, 8 ], [9, 6, 7, 12], [4, 14, 15, 1 ] ] assert is_magic_square(square) == False def test_is_magic_square_one_element(): square = [[1]] assert is_magic_square(square) == True def test_is_magic_square_invalid(): square = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert is_magic_square(square) == False","solution":"def is_magic_square(square): Determines if a given 2D list (square) is a magic square. A magic square is a 2D square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same. Parameters: square (list of list of int): A 2D list representing the square grid. Returns: bool: True if the input is a magic square, False otherwise. n = len(square) # Calculate the sum of the first row to use as the reference sum sum_ref = sum(square[0]) # Check sums of all rows for row in square: if sum(row) != sum_ref: return False # Check sums of all columns for col in range(n): if sum(square[row][col] for row in range(n)) != sum_ref: return False # Check sum of main diagonal if sum(square[i][i] for i in range(n)) != sum_ref: return False # Check sum of other diagonal if sum(square[i][n-i-1] for i in range(n)) != sum_ref: return False return True"},{"question":"from datetime import datetime def longest_streak(timestamps): Returns the longest consecutive daily login streak. :param timestamps: List of string timestamps in \\"YYYY-MM-DD HH:MM:SS\\" format :return: Integer representing the longest consecutive streak in days >>> longest_streak([ \\"2023-01-01 08:00:00\\", \\"2023-01-02 09:00:00\\", \\"2023-01-03 10:00:00\\", \\"2023-01-05 11:00:00\\", \\"2023-01-06 12:00:00\\", \\"2023-01-07 13:00:00\\", \\"2023-01-08 14:00:00\\", \\"2023-01-10 15:00:00\\" ]) == 4 >>> longest_streak([ \\"2023-01-01 08:00:00\\", \\"2023-01-03 09:00:00\\", \\"2023-01-05 10:00:00\\", \\"2023-01-07 11:00:00\\", \\"2023-01-09 12:00:00\\" ]) == 1 pass def test_longest_streak_all_consecutive(): timestamps = [ \\"2023-01-01 08:00:00\\", \\"2023-01-02 09:00:00\\", \\"2023-01-03 10:00:00\\", \\"2023-01-04 11:00:00\\", \\"2023-01-05 12:00:00\\" ] assert longest_streak(timestamps) == 5 def test_longest_streak_some_gaps(): timestamps = [ \\"2023-01-01 08:00:00\\", \\"2023-01-02 09:00:00\\", \\"2023-01-03 10:00:00\\", \\"2023-01-05 11:00:00\\", \\"2023-01-06 12:00:00\\", \\"2023-01-07 13:00:00\\", \\"2023-01-08 14:00:00\\", \\"2023-01-10 15:00:00\\" ] assert longest_streak(timestamps) == 4 def test_longest_streak_no_consecutive_logins(): timestamps = [ \\"2023-01-01 08:00:00\\", \\"2023-01-03 09:00:00\\", \\"2023-01-05 10:00:00\\", \\"2023-01-07 11:00:00\\", \\"2023-01-09 12:00:00\\" ] assert longest_streak(timestamps) == 1 def test_longest_streak_single_day(): timestamps = [ \\"2023-01-01 08:00:00\\" ] assert longest_streak(timestamps) == 1 def test_longest_streak_multiple_identical_days(): timestamps = [ \\"2023-01-01 08:00:00\\", \\"2023-01-01 09:00:00\\", \\"2023-01-01 10:00:00\\" ] assert longest_streak(timestamps) == 1 def test_longest_streak_empty_list(): timestamps = [] assert longest_streak(timestamps) == 0","solution":"from datetime import datetime, timedelta def longest_streak(timestamps): Returns the longest consecutive daily login streak. :param timestamps: List of string timestamps in \\"YYYY-MM-DD HH:MM:SS\\" format :return: Integer representing the longest consecutive streak in days if not timestamps: return 0 # Extract only the dates and sort them dates = sorted({datetime.strptime(ts.split()[0], \\"%Y-%m-%d\\").date() for ts in timestamps}) longest_streak = 1 current_streak = 1 for i in range(1, len(dates)): if dates[i] == dates[i - 1] + timedelta(days=1): current_streak += 1 else: if current_streak > longest_streak: longest_streak = current_streak current_streak = 1 return max(longest_streak, current_streak)"},{"question":"MOD = 1_000_000_007 def factorial(n): Calculate the factorial of n % MOD if n == 0 or n == 1: return 1 result = 1 for i in range(2, n+1): result = (result * i) % MOD return result def count_sequences(L, A, B): Calculate the number of distinct sequences of length L that can be formed from integers in the range [A, B]. Args: L (int): Length of the sequence A (int): Start of the range B (int): End of the range Returns: int: Number of possible sequences modulo 1,000,000,007 Examples: >>> count_sequences(3, 1, 5) 60 >>> count_sequences(4, 10, 15) 360 n = B - A + 1 # number of elements in the range [A, B] if L > n: return 0 # Calculate n! / (n-L)! num_of_sequences = factorial(n) // factorial(n - L) return num_of_sequences % MOD def read_input(input_string): Parse the input string and return a list of test cases. Args: input_string (str): Input data in the form of a string Returns: list: List of test cases, where each test case is a tuple (L, A, B) Examples: >>> read_input(\\"3n3 1 5n4 10 15n5 20 25n\\") [(3, 1, 5), (4, 10, 15), (5, 20, 25)] data = input_string.strip().split() idx = 0 Q = int(data[idx]) idx += 1 test_cases = [] for _ in range(Q): L = int(data[idx]) A = int(data[idx+1]) B = int(data[idx+2]) test_cases.append((L, A, B)) idx += 3 return test_cases def solve(test_cases): Solve the given test cases and return the results. Args: test_cases (list): List of test cases, where each test case is a tuple (L, A, B) Returns: list: List of results for each test case Examples: >>> solve([(3, 1, 5), (4, 10, 15), (5, 20, 25)]) [60, 360, 720] results = [] for L, A, B in test_cases: results.append(count_sequences(L, A, B)) return results","solution":"MOD = 1_000_000_007 def factorial(n): if n == 0 or n == 1: return 1 result = 1 for i in range(2, n+1): result = (result * i) % MOD return result def count_sequences(L, A, B): n = B - A + 1 # number of elements in the range [A, B] if L > n: return 0 # Calculate n! / (n-L)! num_of_sequences = factorial(n) // factorial(n - L) return num_of_sequences % MOD def solve(test_cases): results = [] for L, A, B in test_cases: results.append(count_sequences(L, A, B)) return results # Reading input data def read_input(input_string): data = input_string.strip().split() idx = 0 Q = int(data[idx]) idx += 1 test_cases = [] for _ in range(Q): L = int(data[idx]) A = int(data[idx+1]) B = int(data[idx+2]) test_cases.append((L, A, B)) idx += 3 return test_cases"},{"question":"def contains_anagram(s1: str, s2: str) -> bool: Determine if s2 contains an anagram of s1. >>> contains_anagram(\\"ab\\", \\"eidbaooo\\") == True >>> contains_anagram(\\"ab\\", \\"eidboaoo\\") == False >>> contains_anagram(\\"\\", \\"\\") == True >>> contains_anagram(\\"a\\", \\"a\\") == True >>> contains_anagram(\\"a\\", \\"b\\") == False >>> contains_anagram(\\"abc\\", \\"cbadabca\\") == True >>> contains_anagram(\\"abc\\", \\"defghijk\\") == False >>> contains_anagram(\\"abc\\", \\"abc\\") == True >>> contains_anagram(\\"abcd\\", \\"abc\\") == False pass","solution":"def contains_anagram(s1, s2): from collections import Counter len_s1, len_s2 = len(s1), len(s2) if len_s1 > len_s2: return False s1_count = Counter(s1) window_count = Counter(s2[:len_s1]) for i in range(len_s2 - len_s1 + 1): if i > 0: # Slide the window: remove one preceding character and add a new one window_count[s2[i - 1]] -= 1 if window_count[s2[i - 1]] == 0: del window_count[s2[i - 1]] window_count[s2[i + len_s1 - 1]] += 1 if window_count == s1_count: return True return False"},{"question":"def convert_seconds(n: int) -> str: Convert a non-negative integer 'n' representing a number of seconds into a formatted string \\"x hour(s), y minute(s), z second(s)\\". >>> convert_seconds(3661) == \\"1 hour(s), 1 minute(s), 1 second(s)\\" >>> convert_seconds(59) == \\"0 hour(s), 0 minute(s), 59 second(s)\\" >>> convert_seconds(3600) == \\"1 hour(s), 0 minute(s), 0 second(s)\\"","solution":"def convert_seconds(n): Convert a non-negative integer 'n' representing a number of seconds into a formatted string \\"x hour(s), y minute(s), z second(s)\\". Parameters: n (int): A non-negative integer representing seconds. Returns: str: A formatted string representing hours, minutes, and seconds. hours = n // 3600 n = n % 3600 minutes = n // 60 seconds = n % 60 return f\\"{hours} hour(s), {minutes} minute(s), {seconds} second(s)\\""},{"question":"def calculate_expenditure(T: int, test_cases: List[List[Tuple[str, str, str]]]) -> List[str]: Simulates customer transactions and calculates the total amount spent by each customer. Args: T (int): Number of test cases. test_cases (List[List[Tuple[str, str, str]]]): List of test cases, where each test case is a list of transactions. Each transaction is a tuple containing customer name, item name, and amount spent. Returns: List[str]: List of strings where each string represents the total amount spent by a customer in the format 'customer_name total_amount'. >>> T = 2 >>> test_cases = [ ... [(\\"Alice\\", \\"Book\\", \\"500\\"), (\\"Bob\\", \\"Pen\\", \\"200\\"), (\\"Alice\\", \\"Notebook\\", \\"300\\")], ... [(\\"John\\", \\"Pen\\", \\"150\\"), (\\"John\\", \\"Book\\", \\"350\\")] ... ] >>> calculate_expenditure(T, test_cases) ['Alice 800', 'Bob 200', 'John 500'] from typing import List, Tuple def test_calculate_expenditure(): # Test case 1 T = 2 test_cases = [ [(\\"Alice\\", \\"Book\\", \\"500\\"), (\\"Bob\\", \\"Pen\\", \\"200\\"), (\\"Alice\\", \\"Notebook\\", \\"300\\")], [(\\"John\\", \\"Pen\\", \\"150\\"), (\\"John\\", \\"Book\\", \\"350\\")] ] expected_output = ['Alice 800', 'Bob 200', 'John 500'] assert calculate_expenditure(T, test_cases) == expected_output # Test case 2 T = 1 test_cases = [ [(\\"Max\\", \\"Laptop\\", \\"1000\\"), (\\"Sara\\", \\"Mouse\\", \\"50\\"), (\\"Max\\", \\"Keyboard\\", \\"150\\"), (\\"Sara\\", \\"Monitor\\", \\"300\\")] ] expected_output = ['Max 1150', 'Sara 350'] assert calculate_expenditure(T, test_cases) == expected_output # Test case 3 T = 1 test_cases = [ [(\\"Paul\\", \\"Bag\\", \\"200\\"), (\\"Peter\\", \\"Shoes\\", \\"300\\"), (\\"Paul\\", \\"Hat\\", \\"100\\"), (\\"Paul\\", \\"Gloves\\", \\"50\\")] ] expected_output = ['Paul 350', 'Peter 300'] assert calculate_expenditure(T, test_cases) == expected_output # Test case 4 with all unique customers T = 1 test_cases = [ [(\\"Ann\\", \\"Book\\", \\"50\\"), (\\"Ben\\", \\"Pen\\", \\"30\\"), (\\"Cathy\\", \\"Notebook\\", \\"40\\")] ] expected_output = ['Ann 50', 'Ben 30', 'Cathy 40'] assert calculate_expenditure(T, test_cases) == expected_output # Test case 5 with large values T = 1 test_cases = [ [(\\"David\\", \\"Watch\\", \\"10000\\")] ] expected_output = ['David 10000'] assert calculate_expenditure(T, test_cases) == expected_output","solution":"def calculate_expenditure(T, test_cases): results = [] for i in range(T): transactions = test_cases[i] customer_totals = {} for transaction in transactions: customer, _, amount = transaction amount = int(amount) if customer in customer_totals: customer_totals[customer] += amount else: customer_totals[customer] = amount for customer, total in customer_totals.items(): results.append(f\\"{customer} {total}\\") return results # Example usage T = 2 test_cases = [ [(\\"Alice\\", \\"Book\\", \\"500\\"), (\\"Bob\\", \\"Pen\\", \\"200\\"), (\\"Alice\\", \\"Notebook\\", \\"300\\")], [(\\"John\\", \\"Pen\\", \\"150\\"), (\\"John\\", \\"Book\\", \\"350\\")] ] print(calculate_expenditure(T, test_cases)) # Output: ['Alice 800', 'Bob 200', 'John 500']"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s2 is an anagram of s1. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"world\\") False","solution":"def is_anagram(s1, s2): Determines if s2 is an anagram of s1. Parameters: - s1 (str): The first string - s2 (str): The second string Returns: - bool: True if s2 is an anagram of s1, False otherwise return sorted(s1) == sorted(s2)"},{"question":"def merge_sorted_arrays(array1: list[int], array2: list[int]) -> list[int]: Merges two sorted arrays into a single sorted array without using any built-in sorting functions. Parameters: array1 (list of int): First sorted array. array2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([], [2, 4, 6, 8]) [2, 4, 6, 8] >>> merge_sorted_arrays([1, 3, 5, 7], []) [1, 3, 5, 7] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 3, 5], [1, 3, 5]) [1, 1, 3, 3, 5, 5] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([2], [1]) [1, 2] >>> merge_sorted_arrays([1, 5], [2, 3, 4, 6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_arrays([2, 3, 4, 6, 7], [1, 5]) [1, 2, 3, 4, 5, 6, 7]","solution":"def merge_sorted_arrays(array1, array2): Merges two sorted arrays into a single sorted array without using any built-in sorting functions. Parameters: array1 (list of int): First sorted array. array2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. merged_array = [] i = j = 0 while i < len(array1) and j < len(array2): if array1[i] < array2[j]: merged_array.append(array1[i]) i += 1 else: merged_array.append(array2[j]) j += 1 # Add any remaining elements from array1 while i < len(array1): merged_array.append(array1[i]) i += 1 # Add any remaining elements from array2 while j < len(array2): merged_array.append(array2[j]) j += 1 return merged_array"},{"question":"def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Create a function that takes an integer array and a target sum, and returns all the unique combinations of elements in the array where the chosen numbers sum to the target sum. The same number from the array may be used an unlimited number of times in the combination. All numbers (including target) will be positive integers. The combinations should be returned as a list of lists. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] pass","solution":"def combination_sum(candidates, target): def backtrack(remainder, comb, start): if remainder == 0: result.append(list(comb)) return elif remainder < 0: return for i in range(start, len(candidates)): comb.append(candidates[i]) backtrack(remainder - candidates[i], comb, i) comb.pop() result = [] backtrack(target, [], 0) return result"},{"question":"import re from collections import Counter def most_frequent_word(text: str) -> str: Returns the most frequent word in the given string. If there is a tie, returns the word that appears first in the string. >>> most_frequent_word(\\"Hello, world! Hello!\\") \\"hello\\" >>> most_frequent_word(\\"Code test test Code\\") \\"code\\" >>> most_frequent_word(\\"apple orange banana apple orange\\") \\"apple\\"","solution":"import re from collections import Counter def most_frequent_word(text): Returns the most frequent word in the given string. If there is a tie, returns the word that appears first in the string. # Remove punctuation and convert to lower case words = re.findall(r'bw+b', text.lower()) # Count the occurrences of each word word_counts = Counter(words) # Find the most frequent word with the tie-breaking condition most_frequent = None max_count = 0 for word in words: if word_counts[word] > max_count: most_frequent = word max_count = word_counts[word] return most_frequent"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if string s1 can be transformed into string s2 by rearranging the characters (i.e., check if s1 is an anagram of s2). Parameters: - s1 (str): First string. - s2 (str): Second string. Returns: - bool: True if s1 is an anagram of s2, False otherwise. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"triangle\\", \\"integral\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False # Your code here","solution":"def is_anagram(s1, s2): Determines if string s1 can be transformed into string s2 by rearranging the characters (i.e., check if s1 is an anagram of s2). Parameters: - s1 (str): First string. - s2 (str): Second string. Returns: - bool: True if s1 is an anagram of s2, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"def rearrange_palindrome(s: str) -> str: Rearranges the string s to form a palindrome if possible. If it is not possible to rearrange s to form a palindrome, returns an empty string \\"\\". >>> rearrange_palindrome(\\"civic\\") 'civic' >>> rearrange_palindrome(\\"ivicc\\") 'civic' >>> rearrange_palindrome(\\"hello\\") '' >>> rearrange_palindrome(\\"abcba\\") 'abcba' >>> rearrange_palindrome(\\"aabbcd\\") '' # Implement your solution here","solution":"def rearrange_palindrome(s): Rearranges the string s to form a palindrome if possible. If it is not possible to rearrange s to form a palindrome, returns an empty string \\"\\". from collections import Counter char_count = Counter(s) odd_chars = [char for char, count in char_count.items() if count % 2 != 0] if len(odd_chars) > 1: return \\"\\" half_palindrome = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 != 0: middle_char = char half_palindrome.append(char * (count // 2)) first_half = \\"\\".join(half_palindrome) return first_half + middle_char + first_half[::-1]"},{"question":"def process_scores(scores: List[int]) -> Tuple[int, float, List[int]]: Processes a list of student scores and returns a tuple containing: 1. The average score rounded to the nearest integer. 2. The median score. 3. A list of students who scored higher than the average (in the same order as they appear in the input list). If the list is empty, returns (0, 0, []). >>> process_scores([90, 78, 65, 89, 76, 95, 70]) (80, 78, [90, 89, 95]) >>> process_scores([100, 80, 90, 90, 70, 80, 100]) (87, 90, [100, 90, 90, 100]) >>> process_scores([50, 60, 70, 80, 90, 100, 110]) (80, 80, [90, 100, 110]) >>> process_scores([60]) (60, 60, []) >>> process_scores([]) (0, 0, []) >>> process_scores([1, 2, 3, 4, 5]) (3, 3, [4, 5]) >>> process_scores([1, 1, 1, 1, 1]) (1, 1, []) >>> process_scores([1, 2, 3, 4, 5, 6]) (4, 3.5, [5, 6])","solution":"def process_scores(scores): Processes a list of student scores and returns a tuple containing the average score rounded to the nearest integer, the median score, and a list of students who scored higher than the average. if not scores: return (0, 0, []) # Calculate the average score rounded to the nearest integer average_score = round(sum(scores) / len(scores)) # Calculate the median score sorted_scores = sorted(scores) n = len(scores) median_score = sorted_scores[n // 2] if n % 2 != 0 else (sorted_scores[n // 2 - 1] + sorted_scores[n // 2]) / 2 # Find students who scored higher than the average above_average_scores = [score for score in scores if score > average_score] return (average_score, median_score, above_average_scores)"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the given string a palindrome. The function should determine the minimum number of characters that need to be removed to make the input string a palindrome. Examples: >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the given string a palindrome. def lcs(s1, s2): Returns the length of the longest common subsequence between s1 and s2. n = len(s1) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n] reversed_s = s[::-1] lcs_length = lcs(s, reversed_s) return len(s) - lcs_length"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Computes the area of the largest rectangle that can be formed within the bounds of a histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([2, 4, 2, 1]) 6 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([2, 2, 2, 2, 2]) 10 >>> heights = [i for i in range(100000)] >>> expected_output = max([x*(100000-x) for x in heights]) >>> largestRectangleArea(heights) == expected_output","solution":"def largestRectangleArea(heights): Computes the area of the largest rectangle that can be formed within the bounds of a histogram. stack = [] # Stack to keep indices of the histogram bars max_area = 0 # Initialize max area index = 0 # Current index while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def gcd(x: int, n: int) -> int: Returns the greatest common divisor (GCD) of two integers x and n. >>> gcd(48, 18) == 6 >>> gcd(101, 103) == 1 >>> gcd(56, 98) == 14","solution":"def gcd(x, n): Returns the greatest common divisor (GCD) of two integers x and n. while n: x, n = n, x % n return x"},{"question":"from typing import List def even_squares(nums: List[int]) -> List[int]: Returns a list of integers from the input list whose squares are even. >>> even_squares([1, 2, 3, 4, 5]) [2, 4] >>> even_squares([0, 1, 2, 3, 4]) [0, 2, 4] >>> even_squares([1, 3, 5, 7, 9]) [] >>> even_squares([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> even_squares([10, 21, 32, 43]) [10, 32]","solution":"def even_squares(nums): Returns a list of integers from the input list whose squares are even. return [num for num in nums if (num ** 2) % 2 == 0]"},{"question":"def min_changes_to_palindrome(S: str) -> int: Returns the minimum number of changes required to make the string S a palindrome. >>> min_changes_to_palindrome(\\"abc\\") 1 >>> min_changes_to_palindrome(\\"aab\\") 1 >>> min_changes_to_palindrome(\\"race\\") 2 >>> min_changes_to_palindrome(\\"a\\") 0 >>> min_changes_to_palindrome(\\"abba\\") 0 >>> min_changes_to_palindrome(\\"aba\\") 0 >>> min_changes_to_palindrome(\\"level\\") 0 def min_changes_for_multiple_cases(T: int, cases: List[str]) -> List[int]: Returns a list of minimum changes required for each test case. >>> min_changes_for_multiple_cases(3, [\\"abc\\", \\"aab\\", \\"race\\"]) [1, 1, 2]","solution":"def min_changes_to_palindrome(S): Returns the minimum number of changes required to make the string S a palindrome. n = len(S) changes = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: changes += 1 return changes def min_changes_for_multiple_cases(T, cases): Returns a list of minimum changes required for each test case. results = [] for case in cases: results.append(min_changes_to_palindrome(case)) return results"},{"question":"def count_peaks(grid: List[List[int]]) -> int: Given a 2D grid of integers, where each integer represents the elevation at that point, find the number of \\"peaks\\" in the grid. A point is considered a peak if it is greater than or equal to its 4 adjacent neighbors (up, down, left, and right). For the boundaries of the grid, treat any out-of-bounds neighbor as having an elevation of negative infinity. >>> count_peaks([[1,2,1], [3,4,3], [1,2,1]]) 1 >>> count_peaks([[10,20,15], [21,30,14], [7,16,32]]) 2 >>> count_peaks([[5,1,3], [2,9,5], [8,7,6]]) 3 >>> count_peaks([[1,1,1], [1,1,1], [1,1,1]]) 9 >>> count_peaks([[1]]) 1 >>> count_peaks([[5,4,3], [4,3,2], [3,2,1]]) 1","solution":"def count_peaks(grid): def is_peak(i, j): current = grid[i][j] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]): if current < grid[ni][nj]: return False return True peak_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if is_peak(i, j): peak_count += 1 return peak_count"},{"question":"from typing import List, Tuple def length_of_lis(moves: List[int]) -> int: Finds the length of the longest increasing subsequence in the given list of moves. >>> length_of_lis([5, 8, 3, 7, 9, 1]) 3 >>> length_of_lis([10, 22, 9, 33, 21]) 3 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([3, 2]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([50, 3, 10, 7, 40, 80]) 4 pass def solve_longest_increasing_subsequence(test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, finds the length of the longest increasing subsequence of moves. >>> test_cases = [ ... (6, [5, 8, 3, 7, 9, 1]), ... (5, [10, 22, 9, 33, 21]), ... (5, [3, 10, 2, 1, 20]), ... (2, [3, 2]), ... (0, []), ... (6, [50, 3, 10, 7, 40, 80]) ... ] >>> solve_longest_increasing_subsequence(test_cases) [3, 3, 3, 1, 0, 4] pass","solution":"def length_of_lis(moves): Finds the length of the longest increasing subsequence in the given list of moves. if not moves: return 0 # List to store the longest increasing subsequence length at each index lis = [1] * len(moves) # Build the LIS array for i in range(1, len(moves)): for j in range(i): if moves[i] > moves[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The length of the longest increasing subsequence return max(lis) def solve_longest_increasing_subsequence(test_cases): results = [] for case in test_cases: N, moves = case results.append(length_of_lis(moves)) return results"},{"question":"def canScheduleEvent(events, new_event): Determines if a new event can be scheduled without overlapping any existing event. Args: events : list of tuples The start and end times of already scheduled events. new_event : tuple The start and end time of the new event. Returns: bool : True if the new event can be added without overlap, False otherwise. >>> canScheduleEvent([(1, 3), (4, 5)], (2, 4)) False >>> canScheduleEvent([(1, 3), (5, 7)], (3, 5)) True","solution":"def canScheduleEvent(events, new_event): Determines if a new event can be scheduled without overlapping any existing event. Args: events : list of tuples The start and end times of already scheduled events. new_event : tuple The start and end time of the new event. Returns: bool : True if the new event can be added without overlap, False otherwise. new_start, new_end = new_event for start, end in events: if not (new_end <= start or new_start >= end): return False return True"},{"question":"import math from typing import List def is_perfect_square(n: int) -> bool: Helper function to check if a number is a perfect square. if n < 0: return False root = int(math.sqrt(n)) return n == root * root def get_perfect_squares(lst: List[int]) -> List[int]: Returns a list of perfect squares from the given list of integers. >>> get_perfect_squares([1, 2, 3, 4, 5]) [1, 4] >>> get_perfect_squares([10, 15, 20, 25, 30]) [25] >>> get_perfect_squares([11, 14, 17, 19]) []","solution":"import math def is_perfect_square(n): Helper function to check if a number is a perfect square. if n < 0: return False root = int(math.sqrt(n)) return n == root * root def get_perfect_squares(lst): Returns a list of perfect squares from the given list of integers. return [num for num in lst if is_perfect_square(num)]"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Given a list of positive integers representing the heights of buildings, determine the amount of water that can be trapped between the buildings after a rain. >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([0, 1, 2, 3, 4]) 0 >>> trap_rain_water([1, 1, 1, 1]) 0 >>> trap_rain_water([1, 0, 1]) 1 >>> trap_rain_water([3, 0, 2, 0, 4]) 7 >>> trap_rain_water([5]) 0 def test_trap_rain_water(): assert trap_rain_water([]) == 0 assert trap_rain_water([0, 1, 2, 3, 4]) == 0 assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 assert trap_rain_water([1, 1, 1, 1]) == 0 assert trap_rain_water([1, 0, 1]) == 1 assert trap_rain_water([3, 0, 2, 0, 4]) == 7 assert trap_rain_water([5]) == 0","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max, right_max = [0] * n, [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def capitalize_words(s: str) -> str: Returns a new string with the first letter of each word capitalized. Words are defined as sequences of characters separated by whitespace. >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\"capitalize every first letter\\") 'Capitalize Every First Letter' >>> capitalize_words(\\" hello world \\") 'Hello World' >>> capitalize_words(\\"\\") '' >>> capitalize_words(\\"hello-world\\") 'Hello-world' >>> capitalize_words(\\"hello, world\\") 'Hello, World' >>> capitalize_words(\\"hElLo wOrLd\\") 'Hello World' >>> capitalize_words(\\"123 hello 456 w0rld\\") '123 Hello 456 W0rld'","solution":"def capitalize_words(s): Returns a new string with the first letter of each word capitalized. Words are defined as sequences of characters separated by whitespace. return ' '.join(word.capitalize() for word in s.split())"},{"question":"from typing import List, Union def perfect_numbers(numbers: List[int]) -> Union[List[int], str]: Create a function that accepts a list of positive integers and returns a new list containing only the integers that are perfect numbers. A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding itself). For example, the number 28 is a perfect number because its proper divisors are 1, 2, 4, 7, and 14, which add up to 28. If the input list is empty or contains non-positive integers, the function should return \\"Invalid input\\". Examples: >>> perfect_numbers([6, 28, 496, 12, 97]) [6, 28, 496] >>> perfect_numbers([1, 2, 3, 4, 5]) [] >>> perfect_numbers([6, 12, -28, 0]) \\"Invalid input\\" >>> perfect_numbers([]) \\"Invalid input\\"","solution":"def perfect_numbers(numbers): Returns a list of perfect numbers from the input list. A perfect number is a positive integer that is equal to the sum of its proper divisors. If the input list is empty or contains non-positive integers, returns \\"Invalid input\\". if not numbers or any(n <= 0 for n in numbers): return \\"Invalid input\\" def is_perfect(n): divisors_sum = sum(i for i in range(1, n) if n % i == 0) return divisors_sum == n return [n for n in numbers if is_perfect(n)]"},{"question":"# Completion Task def roman_to_int(s: str) -> int: Converts a Roman numeral string to an integer. Examples: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 pass def test_roman_to_int(): # Test basic values assert roman_to_int(\\"I\\") == 1 assert roman_to_int(\\"V\\") == 5 assert roman_to_int(\\"X\\") == 10 assert roman_to_int(\\"L\\") == 50 assert roman_to_int(\\"C\\") == 100 assert roman_to_int(\\"D\\") == 500 assert roman_to_int(\\"M\\") == 1000 # Test combinations assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"XC\\") == 90 assert roman_to_int(\\"MCMXCIV\\") == 1994 assert roman_to_int(\\"MMXXI\\") == 2021 # Test complex examples assert roman_to_int(\\"CDXLIV\\") == 444 assert roman_to_int(\\"CMXCIV\\") == 994 assert roman_to_int(\\"MMMCMXCIX\\") == 3999 # Test edge cases assert roman_to_int(\\"MMMCDXC\\") == 3490 assert roman_to_int(\\"CDXCIV\\") == 494","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral string to an integer. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 previous_value = 0 for char in reversed(s): current_value = roman_to_int_map[char] if current_value < previous_value: total -= current_value else: total += current_value previous_value = current_value return total"},{"question":"def median_filter(arr: List[int], k: int) -> List[int]: Returns a new list where each element at index \`i\` is the median of the \`k\` elements centered at \`i\` in the input list. If the list has fewer than \`k\` elements, returns the original list. >>> median_filter([1, 2, 3, 4, 5], 3) # [2, 3, 4] >>> median_filter([1, 2, 3, 4, 5], 5) # [3] >>> median_filter([1, 2, 3, 4, 5], 1) # [1, 2, 3, 4, 5] >>> median_filter([1, 2, 3, 4, 5, 6], 3) # [2, 3, 4, 5] >>> median_filter([1, 2], 3) # [1, 2] >>> median_filter([-1, -2, -3, -4, -5], 3) # [-2, -3, -4] >>> median_filter([1, -1, 0, 2, -2, 3], 3) # [0, 0, 0, 2]","solution":"def median_filter(arr, k): Returns a new list where each element at index \`i\` is the median of the \`k\` elements centered at \`i\` in the input list. if len(arr) < k: return arr def median(lst): Returns the median of the list \`lst\`. lst_sorted = sorted(lst) mid = len(lst_sorted) // 2 return lst_sorted[mid] half_k = k // 2 filtered_list = [] for i in range(half_k, len(arr) - half_k): window = arr[i - half_k:i + half_k + 1] filtered_list.append(median(window)) return filtered_list"},{"question":"from typing import List def min_subarray_len(target: int, nums: List[int]) -> int: Returns the length of the smallest subarray whose sum is greater than or equal to the target. If no such subarray exists, returns 0. >>> min_subarray_len(7, [2, 3, 1, 2, 4, 3]) == 2 >>> min_subarray_len(15, [1, 2, 3, 4, 5]) == 5 >>> min_subarray_len(100, [1, 2, 3, 4, 5]) == 0 >>> min_subarray_len(4, [4]) == 1 >>> min_subarray_len(20, [5, 5, 5, 5, 5]) == 4 >>> min_subarray_len(1000000, [100000, 200000, 300000, 400000, 500000]) == 3","solution":"from typing import List def min_subarray_len(target: int, nums: List[int]) -> int: Returns the length of the smallest subarray whose sum is greater than or equal to the target. If no such subarray exists, returns 0. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"from typing import List def filter_and_sort_odds(int_list: List[int]) -> List[int]: Returns a list of odd integers sorted in descending order from the input list of integers. :param int_list: List of integers :return: List of odd integers sorted in descending order >>> filter_and_sort_odds([3, 1, 4, 1, 5, 9]) [9, 5, 3, 1, 1] >>> filter_and_sort_odds([10, 7, 2, -3, 6, -5]) [7, -3, -5] >>> filter_and_sort_odds([2, 4, 6, 8, 10]) [] >>> filter_and_sort_odds([1, 3, 5, 7, 9]) [9, 7, 5, 3, 1] >>> filter_and_sort_odds([]) [] >>> filter_and_sort_odds([1]) [1] >>> filter_and_sort_odds([2]) [] >>> filter_and_sort_odds([-1, -3, -5, -7, -9]) [-1, -3, -5, -7, -9]","solution":"def filter_and_sort_odds(int_list): Returns a list of odd integers sorted in descending order from the input list of integers. :param int_list: List of integers :return: List of odd integers sorted in descending order odd_numbers = [x for x in int_list if x % 2 != 0] return sorted(odd_numbers, reverse=True)"},{"question":"def is_super_list(nums: List[int]) -> bool: Returns True if nums is a super list, otherwise returns False. A 'super list' is a list in which every element is greater than or equal to the sum of all previous elements in the list. >>> is_super_list([2, 3, 6, 11]) True >>> is_super_list([1, 2, 4, 7]) True >>> is_super_list([3, 1, 4]) False >>> is_super_list([]) True >>> is_super_list([0, 0, 0]) True >>> is_super_list([-1, 2, 1]) False >>> is_super_list([0, -1, 1]) False >>> is_super_list([1, 1, -1, 1]) False","solution":"def is_super_list(nums): Returns True if nums is a super list, otherwise returns False. sum_previous = 0 for num in nums: if num < sum_previous: return False sum_previous += num return True"},{"question":"def sort_numbers_keep_letters(s: str) -> str: Takes a string containing a mix of lowercase letters and numbers, and returns a string with only the numbers sorted in ascending order, while keeping the letters in their original places. >>> sort_numbers_keep_letters(\\"a1b3c2\\") \\"a1b2c3\\" >>> sort_numbers_keep_letters(\\"h4g0f7\\") \\"h0g4f7\\" >>> sort_numbers_keep_letters(\\"abc\\") \\"abc\\"","solution":"def sort_numbers_keep_letters(s): Returns a string with numbers sorted in ascending order, while keeping the letters in their original places. numbers = sorted([ch for ch in s if ch.isdigit()]) number_index = 0 result = [] for ch in s: if ch.isdigit(): result.append(numbers[number_index]) number_index += 1 else: result.append(ch) return ''.join(result) print(sort_numbers_keep_letters(\\"a1b3c2\\")) # should return \\"a1b2c3\\" print(sort_numbers_keep_letters(\\"h4g0f7\\")) # should return \\"h0g4f7\\" print(sort_numbers_keep_letters(\\"abc\\")) # should return \\"abc\\""},{"question":"def count_pairs(nums: List[int], target: int) -> int: Given an integer array \\"nums\\" and an integer \\"target\\", return the number of pairs (i, j) where nums[i] + nums[j] equals the target and i < j. >>> count_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([1, 2, 3, 4], 5) 2 >>> count_pairs([1], 2) 0","solution":"def count_pairs(nums, target): count = 0 nums_len = len(nums) for i in range(nums_len): for j in range(i + 1, nums_len): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"from typing import List def candles_blowout(candles: List[int], breath_strength: int) -> int: Determines the number of candles that can be blown out with a breath. Parameters: candles (List[int]): A list of candle heights. breath_strength (int): The strength of the breath. Returns: int: The number of candles that can be blown out. >>> candles_blowout([3, 2, 1, 4, 3], 3) == 3 >>> candles_blowout([4, 4, 4, 4], 3) == 4 >>> candles_blowout([1, 2, 0, 1, 2], 3) == 0 >>> candles_blowout([5, 6, 7, 1, 0, 4, 3], 4) == 4 >>> candles_blowout([3, 2, 1, 4, 3], 0) == 5 >>> candles_blowout([2], 1) == 1 >>> candles_blowout([2], 3) == 0","solution":"from typing import List def candles_blowout(candles: List[int], breath_strength: int) -> int: Determines the number of candles that can be blown out with a breath. Parameters: candles (List[int]): A list of candle heights. breath_strength (int): The strength of the breath. Returns: int: The number of candles that can be blown out. return sum(1 for candle in candles if candle >= breath_strength)"},{"question":"def sum_of_longest_increasing_subsequence(arr: List[int]) -> int: Returns the sum of the longest increasing subsequence in the given list of integers. >>> sum_of_longest_increasing_subsequence([10, 15, 3, 7, 12, 9, 18, 5]) 43 >>> sum_of_longest_increasing_subsequence([1, 101, 2, 3, 100, 4, 5]) 106","solution":"def sum_of_longest_increasing_subsequence(arr): Returns the sum of the longest increasing subsequence in the given list of integers. if not arr: return 0 n = len(arr) dp = [arr[i] for i in range(n)] for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + arr[i]) return max(dp)"},{"question":"def find_permutation_sum(nums: List[int]) -> int: Given a list of unique integers nums, returns the sum of all numbers in the lexicographically smallest permutation of the list which is greater than the given permutation. If no such permutation exists, return 0. >>> find_permutation_sum([1, 2, 3]) 6 >>> find_permutation_sum([3, 2, 1]) 0 >>> find_permutation_sum([1]) 0 >>> find_permutation_sum([1, 2, 3, 4]) 10 >>> find_permutation_sum([1, 3, 4, 2]) 10 >>> find_permutation_sum([4, 3, 2, 1]) 0 >>> find_permutation_sum([1, 1, 5]) 7 >>> find_permutation_sum([1, 2]) 3 >>> find_permutation_sum([2, 1]) 0","solution":"def find_permutation_sum(nums): Given a list of unique integers nums, returns the sum of all numbers in the lexicographically smallest permutation of the list which is greater than the given permutation. If no such permutation exists, return 0. # Find the rightmost ascending pair of elements i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # If no such pair is found, return 0 since it's the highest permutation if i == -1: return 0 # Find the smallest element on the right of nums[i] that is greater than nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Reverse the elements to the right of nums[i] nums = nums[:i+1] + nums[i+1:][::-1] # Return the sum of the next permutation return sum(nums)"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Initialize leaves and build the tree by calculating parent node sums # Initialize leaves here # Build the tree by calculating parent node sums here def update(self, pos, value): Update the value at a specific position # Update at the leaf node here # Update the values of its ancestors here def query(self, l, r): Return the sum on the interval [l, r) # Sum on the interval [l, r) here def handle_queries(N, Q, arr, queries): Perform update and sum queries on the array using Segment Tree. Arguments: N -- Number of integers in the list Q -- Number of queries arr -- List of integers queries -- List of queries where each query is a tuple Example: >>> handle_queries(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 1, 3), (2, 2, 5), (1, 5, 20)]) [6, 13, 39]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parent node sums for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update at the leaf node pos += self.n self.tree[pos] = value # Update the values of its ancestors while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): # Sum on the interval [l, r) l += self.n r += self.n res = 0 while l < r: if l % 2: res += self.tree[l] l += 1 if r % 2: r -= 1 res += self.tree[r] l //= 2 r //= 2 return res def handle_queries(N, Q, arr, queries): seg_tree = SegmentTree(arr) results = [] for query in queries: if query[0] == 1: # Update query _, pos, new_value = query seg_tree.update(pos - 1, new_value) elif query[0] == 2: # Sum query _, left, right = query results.append(seg_tree.query(left - 1, right)) return results"},{"question":"def camel_to_snake(camel_str: str) -> str: Converts a camelCase string into snake_case. Parameters: camel_str (str): The input camelCase string. Returns: str: The converted snake_case string. >>> camel_to_snake(\\"camelCaseString\\") 'camel_case_string' >>> camel_to_snake(\\"thisIsATest\\") 'this_is_a_test' >>> camel_to_snake(\\"convertToSnakeCase\\") 'convert_to_snake_case' >>> camel_to_snake(\\"camel\\") 'camel' >>> camel_to_snake(\\"convertTo\\") 'convert_to' >>> camel_to_snake(\\"aA\\") 'a_a' >>> camel_to_snake(\\"alreadylowercase\\") 'alreadylowercase'","solution":"def camel_to_snake(camel_str): Converts a camelCase string into snake_case. Parameters: camel_str (str): The input camelCase string. Returns: str: The converted snake_case string. snake_str = '' for char in camel_str: if char.isupper(): snake_str += '_' + char.lower() else: snake_str += char return snake_str"},{"question":"def is_parentheses_balanced(expression: str) -> bool: Check whether the parentheses in the input expression string are balanced and correctly nested. Args: expression (str): The input string consisting of lowercase letters, digits, and parentheses. Returns: bool: True if the parentheses are balanced and correctly nested, otherwise False. Examples: >>> is_parentheses_balanced(\\"(a+b)*(c-d)\\") True >>> is_parentheses_balanced(\\"((a+b)*(c-d))\\") True >>> is_parentheses_balanced(\\"((a+b)*(c-d)\\") False >>> is_parentheses_balanced(\\"(a+b))+(c-d)(\\") False","solution":"def is_parentheses_balanced(expression: str) -> bool: Checks if the parentheses in the expression are balanced and properly nested. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def kth_permutation(n: int, k: int) -> str: Returns the k-th permutation sequence of the set {1, 2, ..., n}. >>> kth_permutation(3, 3) == '213' >>> kth_permutation(4, 9) == '2314' >>> kth_permutation(3, 6) == '321' pass def test_kth_permutation_example1(): assert kth_permutation(3, 3) == '213' def test_kth_permutation_example2(): assert kth_permutation(4, 9) == '2314' def test_kth_permutation_example3(): assert kth_permutation(3, 6) == '321' def test_kth_permutation_single_digit(): assert kth_permutation(1, 1) == '1' def test_kth_permutation_n2(): assert kth_permutation(2, 1) == '12' assert kth_permutation(2, 2) == '21' def test_kth_permutation_max_k(): assert kth_permutation(3, 1) == '123' assert kth_permutation(3, 2) == '132' assert kth_permutation(3, 4) == '231' assert kth_permutation(3, 5) == '312'","solution":"import math def kth_permutation(n, k): Returns the k-th permutation sequence of the set {1, 2, ..., n}. nums = list(range(1, n + 1)) k -= 1 # convert 1-indexed to 0-indexed fact = math.factorial(n - 1) result = [] for i in range(n - 1, -1, -1): index = k // fact result.append(str(nums[index])) nums.pop(index) if i != 0: k %= fact fact //= i return ''.join(result)"},{"question":"def getLongestPalindrome(s: str) -> str: Returns the longest palindromic substring in the given string s. >>> getLongestPalindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> getLongestPalindrome(\\"cbbd\\") 'bb' >>> getLongestPalindrome(\\"abcdef\\") 'a' >>> getLongestPalindrome(\\"\\") '' >>> getLongestPalindrome(\\"a\\") 'a' >>> getLongestPalindrome(\\"aa\\") 'aa' >>> getLongestPalindrome(\\"aaa\\") 'aaa' >>> getLongestPalindrome(\\"aaaa\\") 'aaaa' >>> getLongestPalindrome(\\"racecar\\") 'racecar' >>> getLongestPalindrome(\\"abacdfgdcaba\\") 'aba' >>> getLongestPalindrome(\\"aabcdcb\\") 'bcdcb' >>> getLongestPalindrome(\\"ac\\") 'a' >>> getLongestPalindrome(\\"bb\\") 'bb'","solution":"def getLongestPalindrome(s): Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" longest = s[0] for i in range(n): # Check for odd-length palindromes odd_palindrome = expandFromCenter(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Check for even-length palindromes even_palindrome = expandFromCenter(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest def expandFromCenter(s, left, right): Expands around the center and returns the longest palindromic substring. while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right]"},{"question":"from typing import List def smallest_non_adjacent_permutation(S: str) -> str: A permutation of a string is defined as a rearrangement of its characters. Given a string S consisting of lowercase English letters, find the lexicographically smallest permutation of S such that no two consecutive characters in the permutation are the same. If there is no such permutation, return \\"Not Possible\\". >>> smallest_non_adjacent_permutation(\\"aabb\\") \\"abab\\" >>> smallest_non_adjacent_permutation(\\"aaab\\") \\"Not Possible\\" >>> smallest_non_adjacent_permutation(\\"a\\") \\"a\\" >>> smallest_non_adjacent_permutation(\\"aa\\") \\"Not Possible\\" >>> smallest_non_adjacent_permutation(\\"ab\\") \\"ab\\" >>> smallest_non_adjacent_permutation(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> smallest_non_adjacent_permutation(\\"aabbcc\\") \\"abcabc\\" >>> smallest_non_adjacent_permutation(\\"aaabbbccc\\") \\"abcabcabc\\" >>> smallest_non_adjacent_permutation(\\"aaaaaaaaaabbbbbbbbbb\\") \\"Not Possible\\" pass","solution":"from heapq import heappop, heappush from collections import Counter def smallest_non_adjacent_permutation(S): cnt = Counter(S) max_char = max(cnt, key=cnt.get) if cnt[max_char] > (len(S) + 1) // 2: return \\"Not Possible\\" result = [] pq = [] for char, freq in cnt.items(): heappush(pq, (-freq, char)) prev_freq, prev_char = 0, '' while pq: freq, char = heappop(pq) result.append(char) if prev_freq < 0: heappush(pq, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char return ''.join(result)"},{"question":"MOD = 10**9 + 7 def product_of_divisors(N: int) -> int: Calculate the product of all divisors of a given integer N. Args: N (int): The integer to find divisors for. Returns: int: The product of all divisors of N modulo 10^9 + 7. >>> product_of_divisors(6) 36 >>> product_of_divisors(10) 100 >>> product_of_divisors(15) 225 pass def solve(T: int, test_cases: List[int]) -> List[int]: Solve the problem for multiple test cases. Args: T (int): The number of test cases. test_cases (List[int]): A list of integers for each test cases. Returns: List[int]: A list containing the result for each test case. >>> solve(3, [6, 10, 15]) [36, 100, 225] pass from typing import List def test_product_of_divisors(): assert product_of_divisors(6) == 36 assert product_of_divisors(10) == 100 assert product_of_divisors(15) == 225 assert product_of_divisors(1) == 1 assert product_of_divisors(2) == 2 assert product_of_divisors(16) == (1 * 2 * 4 * 8 * 16) % (10**9 + 7) def test_solve(): assert solve(3, [6, 10, 15]) == [36, 100, 225] assert solve(1, [1]) == [1] assert solve(2, [1, 2]) == [1, 2] assert solve(3, [16, 20, 25]) == [(1 * 2 * 4 * 8 * 16) % (10**9 + 7), (1 * 2 * 4 * 5 * 10 * 20) % (10**9 + 7), (1 * 5 * 25) % (10**9 + 7)]","solution":"MOD = 10**9 + 7 def product_of_divisors(N): import math if N == 1: return 1 divisors = [] for i in range(1, int(math.sqrt(N)) + 1): if N % i == 0: divisors.append(i) if i != N // i: divisors.append(N // i) product = 1 for divisor in divisors: product = (product * divisor) % MOD return product def solve(T, test_cases): results = [] for N in test_cases: results.append(product_of_divisors(N)) return results # Example usage: # T = 3 # test_cases = [6, 10, 15] # print(solve(T, test_cases))"},{"question":"def sum_of_unique_elements(lst): Returns the sum of all unique elements in a given list of integers. Parameters: lst (List[int]): List of integers. Returns: int: Sum of unique elements. >>> sum_of_unique_elements([1, 2, 3, 2, 1, 4]) == 7 >>> sum_of_unique_elements([5, 5, 5, 5]) == 0 >>> sum_of_unique_elements([-1, 2, -3, 2, -1, 4]) == 1 >>> sum_of_unique_elements([10, 20, 30, 40, 50]) == 150 >>> sum_of_unique_elements([]) == 0 >>> sum_of_unique_elements([0, 0, 0, 0]) == 0 >>> sum_of_unique_elements([1, 1, 1, -1, -1, -1, 2]) == 2 >>> sum_of_unique_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55 >>> sum_of_unique_elements([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == -55 >>> sum_of_unique_elements([-1, 1, -1, 1]) == 0","solution":"def sum_of_unique_elements(lst): Returns the sum of all unique elements in a given list of integers. Parameters: lst (List[int]): List of integers. Returns: int: Sum of unique elements. element_frequency = {} # Count frequency of each element for element in lst: if element in element_frequency: element_frequency[element] += 1 else: element_frequency[element] = 1 # Sum elements that appear exactly once unique_sum = sum(element for element, count in element_frequency.items() if count == 1) return unique_sum"},{"question":"from typing import List def sum_of_digits(num: int) -> int: Returns the sum of the digits of the given number. >>> sum_of_digits(13): 4 >>> sum_of_digits(25): 7 >>> sum_of_digits(83): 11 >>> sum_of_digits(111): 3 >>> sum_of_digits(222): 6 def transform(nums: List[int]) -> List[int]: Transforms the given list of integers by summing the digits of each integer. >>> transform([13, 25, 83]): [4, 7, 11] >>> transform([111, 222]): [3, 6] >>> transform([4, 7, 2]): [4, 7, 2] def k_iterations(nums: List[int], k: int) -> List[int]: Performs k iterations of transforming the array by summing the digits of each integer. Returns the resulting array after k iterations. >>> k_iterations([13, 25, 83], 1): [4, 7, 11] >>> k_iterations([13, 25, 83], 2): [4, 7, 2] >>> k_iterations([111, 222], 1): [3, 6] >>> k_iterations([111, 222], 2): [3, 6] >>> k_iterations([111, 222], 3): [1, 2]","solution":"def sum_of_digits(num): Returns the sum of the digits of the given number. s = 0 while num > 0: s += num % 10 num //= 10 return s def transform(nums): Transforms the given list of integers by summing the digits of each integer. return [sum_of_digits(num) for num in nums] def k_iterations(nums, k): Performs k iterations of transforming the array by summing the digits of each integer. Returns the resulting array after k iterations. for _ in range(k): nums = transform(nums) return nums"},{"question":"def categorize_scores(test_cases: List[List[int]]) -> List[Tuple[int, int, int, int]]: Categorize the scores into four different tiers based on predefined score ranges. >>> categorize_scores([[95, 88, 45, 67, 99]]) [(2, 1, 1, 1)] >>> categorize_scores([[50, 60, 40]]) [(0, 0, 2, 1)]","solution":"def categorize_scores(test_cases): results = [] for scores in test_cases: tier1 = tier2 = tier3 = tier4 = 0 for score in scores: if 90 <= score <= 100: tier1 += 1 elif 75 <= score < 90: tier2 += 1 elif 50 <= score < 75: tier3 += 1 elif 0 <= score < 50: tier4 += 1 results.append((tier1, tier2, tier3, tier4)) return results"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. >>> int_to_roman(1) == 'I' >>> int_to_roman(3999) == 'MMMCMXCIX' >>> int_to_roman(58) == 'LVIII' >>> int_to_roman(4) == 'IV' >>> int_to_roman(9) == 'IX' >>> int_to_roman(1000) == 'M' >>> int_to_roman(400) == 'CD' >>> int_to_roman(90) == 'XC' pass","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: Integer to convert, must be between 1 and 3999 inclusive. :return: A string representing the Roman numeral equivalent. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' for i in range(len(val)): while num >= val[i]: roman_num += syb[i] num -= val[i] return roman_num"},{"question":"def min_operations_to_equal_elements(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of n integers a1, a2, ..., an. You need to perform the following operations in any order to make all the elements of the array equal: 1. Choose a subarray (contiguous segment) and add 1 to each element of this subarray. 2. Choose a subarray and subtract 1 from each element of this subarray. Your task is to determine the minimum number of operations required to make all elements in the array equal. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[int]]] : A list of tuples where each tuple contains an integer n (number of elements in the array) and a list of n integers a1, a2, ..., an. Returns: List[int] : A list containing the minimum number of operations required for each test case. >>> min_operations_to_equal_elements(2, [(3, [1, 2, 3]), (4, [2, 2, 2, 2])]) [1, 0] >>> min_operations_to_equal_elements(1, [(5, [4, 4, 4, 4, 4])]) [0]","solution":"def min_operations_to_equal_elements(T, test_cases): results = [] for i in range(T): n, array = test_cases[i] min_element = min(array) max_element = max(array) if min_element == max_element: results.append(0) else: results.append(1) return results"},{"question":"def find_longest_consecutive_subsequence(nums): Take a list of integers and returns the longest consecutive subsequence. >>> find_longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> find_longest_consecutive_subsequence([0, -1, 1, -2, 2]) [-2, -1, 0, 1, 2] >>> find_longest_consecutive_subsequence([3, 4, 2, 1]) [1, 2, 3, 4] >>> find_longest_consecutive_subsequence([]) []","solution":"def find_longest_consecutive_subsequence(nums): Returns the longest consecutive subsequence from the list of integers, nums. if not nums: return [] num_set = set(nums) longest_subseq = [] for num in nums: if num - 1 not in num_set: # Start of a new sequence current_num = num current_subseq = [] while current_num in num_set: current_subseq.append(current_num) current_num += 1 if len(current_subseq) > len(longest_subseq): longest_subseq = current_subseq return longest_subseq"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string mathematical expression consisting of single-digit integers, plus signs (+), and minus signs (-) without any spaces. Args: expression (str): A string containing a valid mathematical expression. Returns: int: The evaluated result of the expression. pass def test_evaluate_expression_simple(): assert evaluate_expression(\\"3+5-2\\") == 6 assert evaluate_expression(\\"9-6+1\\") == 4 def test_evaluate_expression_zero(): assert evaluate_expression(\\"0+0-0+1\\") == 1 def test_evaluate_expression_mixed_operations(): assert evaluate_expression(\\"7+3-1-2+4\\") == 11 def test_evaluate_expression_all_subtractions(): assert evaluate_expression(\\"9-8-1\\") == 0 def test_evaluate_expression_all_additions(): assert evaluate_expression(\\"1+2+3+4\\") == 10 def test_evaluate_expression_single_digit(): assert evaluate_expression(\\"5\\") == 5 def test_evaluate_expression_start_with_subtraction(): assert evaluate_expression(\\"-2+5\\") == 3 def test_evaluate_expression_negative_result(): assert evaluate_expression(\\"4-6\\") == -2","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string mathematical expression consisting of single-digit integers, plus signs (+), and minus signs (-) without any spaces. Args: expression (str): A string containing a valid mathematical expression. Returns: int: The evaluated result of the expression. total = 0 current_number = 0 sign = 1 # 1 for positive, -1 for negative for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == '+': total += sign * current_number current_number = 0 sign = 1 elif char == '-': total += sign * current_number current_number = 0 sign = -1 total += sign * current_number return total"},{"question":"def minimize_max_pairwise_sum(n: int, lst: List[int]) -> int: Finds the minimized value of the maximum pairwise sum. >>> minimize_max_pairwise_sum(6, [1, 3, 5, 9, 2, 7]) 10 >>> minimize_max_pairwise_sum(1, [5]) 0 >>> minimize_max_pairwise_sum(2, [5, 1]) 6 >>> minimize_max_pairwise_sum(4, [2, 3, 7, 8]) 10 >>> minimize_max_pairwise_sum(4, [8, 7, 3, 2]) 10 >>> minimize_max_pairwise_sum(4, [4, 4, 4, 4]) 8 >>> minimize_max_pairwise_sum(4, [1000000, 999999, 1000000, 1000000]) 2000000","solution":"def minimize_max_pairwise_sum(n, lst): Finds the minimized value of the maximum pairwise sum. Parameters: n (int): The number of elements in the list. lst (list of int): The list of distinct integers. Returns: int: The minimized value of the maximum pairwise sum. lst.sort() max_pairwise_sum = 0 # Iterate over the list by pairing the smallest with the largest elements for i in range(n//2): pair_sum = lst[i] + lst[n-1-i] max_pairwise_sum = max(max_pairwise_sum, pair_sum) return max_pairwise_sum"},{"question":"from typing import List, Dict def find_winner(rounds: List[Dict[str, int]]) -> str: Determines the participant with the highest cumulative points after all rounds. Args: rounds (List[Dict[str, int]]): A list of dictionaries where each dictionary represents a round. Returns: str: The name of the participant with the highest cumulative points. >>> rounds = [ ... {\\"Alice\\": 10, \\"Bob\\": 5, \\"Charlie\\": -3}, ... {\\"Alice\\": -5, \\"Bob\\": 7, \\"Charlie\\": 10}, ... {\\"Alice\\": 2, \\"Bob\\": -3, \\"Charlie\\": 5} ... ] >>> find_winner(rounds) \\"Charlie\\"","solution":"def find_winner(rounds): Determines the participant with the highest cumulative points after all rounds. Args: rounds (List[Dict[str, int]]): A list of dictionaries where each dictionary represents a round. Returns: str: The name of the participant with the highest cumulative points. cumulative_scores = {} for round_points in rounds: for participant, points in round_points.items(): if participant in cumulative_scores: cumulative_scores[participant] += points else: cumulative_scores[participant] = points # Determine the participant with the highest cumulative points winner = max(cumulative_scores, key=cumulative_scores.get) return winner"},{"question":"def min_contiguous_subarrays(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimum number of contiguous subarrays required such that each subarray has the same sum for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - n (int): Size of the array. - arr (list of int): The array of integers. Returns: list of int: Minimum number of contiguous subarrays for each test case. >>> min_contiguous_subarrays(3, [(5, [1, 2, 3, 4, 5]), (4, [4, 4, 4, 4]), (6, [1, 1, 1, 1, 1, 1])]) [1, 4, 6] >>> min_contiguous_subarrays(1, [(1, [10])]) [1]","solution":"def min_contiguous_subarrays(t, test_cases): Determines the minimum number of contiguous subarrays required such that each subarray has the same sum for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - n (int): Size of the array. - arr (list of int): The array of integers. Returns: list of int: Minimum number of contiguous subarrays for each test case. results = [] for n, arr in test_cases: total_sum = sum(arr) # Find the minimum number of subarrays such that each subarray has the same sum for target_sum in range(n, 0, -1): if total_sum % target_sum == 0: valid = True subarray_sum = 0 required_sum = total_sum // target_sum for num in arr: subarray_sum += num if subarray_sum > required_sum: valid = False break elif subarray_sum == required_sum: subarray_sum = 0 if valid: results.append(target_sum) break return results"},{"question":"def solve(input_data: str) -> List[int]: Given a set of stars represented by integer coordinates in a 2D plane, count the number of distinct right triangles that can be formed for each test case. >>> solve(\\"1n4n0 0n0 1n1 0n1 1\\") [4] >>> solve(\\"1n3n0 0n1 1n2 2\\") [0] >>> solve(\\"1n3n0 0n0 1n1 0\\") [1] >>> solve(\\"2n3n0 0n0 1n1 0n4n0 0n1 1n2 2n3 3\\") [1, 0] >>> solve(\\"1n5n0 0n0 1n1 0n1 1n2 2\\") [4]","solution":"from itertools import combinations def count_right_triangles(stars): count = 0 for p1, p2, p3 in combinations(stars, 3): # Squares of distances between points d2 = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 d3 = (p1[0] - p3[0]) ** 2 + (p1[1] - p3[1]) ** 2 d4 = (p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2 # Check if it forms a right triangle if d2 + d3 == d4 or d2 + d4 == d3 or d3 + d4 == d2: count += 1 return count def solve(input_data): lines = input_data.strip().split(\\"n\\") index = 0 T = int(lines[index]) index += 1 results = [] for _ in range(T): N = int(lines[index]) index += 1 stars = [] for i in range(N): x, y = map(int, lines[index].split()) index += 1 stars.append((x, y)) results.append(count_right_triangles(stars)) return results"},{"question":"def is_balanced(s: str) -> str: Write a function that takes a string of brackets (consisting only of the characters '(', ')', '{', '}', '[' and ']') and determines if the brackets are balanced. A string is balanced if every opening bracket has a corresponding closing bracket of the same type and the brackets are properly nested. Return \\"Balanced\\" if the string is balanced, else return \\"Not Balanced\\". >>> is_balanced(\\"()[]{}\\") \\"Balanced\\" >>> is_balanced(\\"([{}])\\") \\"Balanced\\" >>> is_balanced(\\"([)]\\") \\"Not Balanced\\" >>> is_balanced(\\"(\\") \\"Not Balanced\\"","solution":"def is_balanced(s): stack = [] bracket_map = {'(': ')', '{': '}', '[': ']'} for char in s: if char in bracket_map: # if it's an opening bracket stack.append(char) elif stack and char == bracket_map.get(stack[-1]): # if it's a closing bracket and matches the last opening bracket stack.pop() else: return \\"Not Balanced\\" return \\"Balanced\\" if not stack else \\"Not Balanced\\""},{"question":"def min_flips_to_consecutive_ones(n: int, sequence: List[int]) -> int: Determine the minimum number of flips to make all the 1's consecutive. Parameters: - n (int): The length of the sequence - sequence (list of int): The sequence of 0s and 1s Returns: - int: The minimum number of flips required >>> min_flips_to_consecutive_ones(5, [0, 1, 0, 1, 1]) 1 >>> min_flips_to_consecutive_ones(3, [0, 0, 0]) 0 >>> min_flips_to_consecutive_ones(4, [1, 1, 1, 1]) 0 >>> min_flips_to_consecutive_ones(6, [0, 1, 0, 1, 0, 1]) 2 >>> min_flips_to_consecutive_ones(1, [0]) 0 >>> min_flips_to_consecutive_ones(1, [1]) 0","solution":"def min_flips_to_consecutive_ones(n, sequence): Determine the minimum number of flips to make all the 1's consecutive. Parameters: - n (int): The length of the sequence - sequence (list of int): The sequence of 0s and 1s Returns: - int: The minimum number of flips required # converting list to string to easily check for segment of '1's and '0's s = ''.join(map(str, sequence)) # Find all segments of '0's between '1's (flips needed to convert these segments into '1's) segments_of_zeros = s.split('1') # If the sequence has '1's, we exclude the leading and trailing zeros segments if '1' in s: return len([seg for seg in segments_of_zeros[1:-1] if seg]) else: # If no '1's are present in the sequence, no need for flips return 0"},{"question":"def find_pairs_with_sum(array: List[int], target: int) -> List[List[int]]: Finds all unique pairs in the array that add up to the target sum. >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) [[1, 9], [2, 8], [3, 7], [4, 6]] >>> find_pairs_with_sum([1, 1, 2, 45, 46], 47) [[1, 46], [2, 45]] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 100) [] >>> find_pairs_with_sum([1, -2, 0, 3, 5, 7, 8], 5) [[-2, 7], [0, 5]] >>> find_pairs_with_sum([-1, -2, -3, -4, -5], -8) [[-5, -3]]","solution":"def find_pairs_with_sum(array, target): Finds all unique pairs in the array that add up to the target sum. Parameters: array (list of int): The array of integers. target (int): The target sum. Returns: list of list of int: A list of pairs that add up to the target sum, sorted as specified. array.sort() pairs = [] seen = set() for number in array: complement = target - number if complement in seen: pairs.append([min(number, complement), max(number, complement)]) seen.add(number) # Ensure unique pairs only and sorted pairs = list(map(list, set(map(tuple, pairs)))) pairs.sort() return pairs"},{"question":"def is_happy_number(n: int) -> bool: Determine whether an integer n is a happy number. A happy number is one that eventually reaches 1 when replaced repeatedly by the sum of the square of its digits. >>> is_happy_number(19) True >>> is_happy_number(2) False","solution":"def is_happy_number(n): Determine whether an integer n is a happy number. A happy number is one that eventually reaches 1 when replaced repeatedly by the sum of the square of its digits. def get_next(number): return sum(int(char) ** 2 for char in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string. If there are multiple such substrings of the same length, return the first one. >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"abcdefg\\") 'a' >>> longest_palindromic_substring(\\"aaaaa\\") 'aaaaa' >>> longest_palindromic_substring(\\"\\") '' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"abaxabaxabb\\") 'baxabaxab'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string. If there are multiple such substrings of the same length, return the first one. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 def expand_around_center(left, right): nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 for i in range(n): # Check for odd length palindrome with center i expand_around_center(i, i) # Check for even length palindrome with center between i and i + 1 expand_around_center(i, i + 1) return s[start:start + max_length]"},{"question":"def evaluate(expression: str) -> float: Evaluate a string containing an arithmetic expression consisting of integers and the operators +, -, *, /. This function returns the evaluated result as a float and respects the order of operations and parentheses. >>> evaluate(\\"3+5\\") == 8.0 >>> evaluate(\\"10+2*6\\") == 22.0 >>> evaluate(\\"100*2+12\\") == 212.0 >>> evaluate(\\"100*(2+12)\\") == 1400.0 >>> evaluate(\\"100*(2+12)/14\\") == 100.0 from solution import evaluate def test_simple_addition(): assert evaluate(\\"3+5\\") == 8.0 def test_multiplication_and_addition(): assert evaluate(\\"10+2*6\\") == 22.0 def test_multiplication_and_addition_reversed(): assert evaluate(\\"100*2+12\\") == 212.0 def test_parentheses(): assert evaluate(\\"100*(2+12)\\") == 1400.0 def test_complex_expression(): assert evaluate(\\"100*(2+12)/14\\") == 100.0 def test_subtraction(): assert evaluate(\\"20-3\\") == 17.0 def test_division(): assert evaluate(\\"10/2\\") == 5.0 def test_combination(): assert evaluate(\\"10/2+3*4-5\\") == 12.0 def test_nested_parentheses(): assert evaluate(\\"(2+3)*(5-(2+1))\\") == 10.0 def test_decimal_numbers(): assert evaluate(\\"2.5*4\\") == 10.0","solution":"import operator def evaluate(expression): This function evaluates a given arithmetic expression string containing integers and operators (+, -, *, /) respecting the order of operations and parentheses. def get_operator_fn(op): return { '+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv, }[op] def higher_precedence(op1, op2): precedences = {'+': 1, '-': 1, '*': 2, '/': 2} return precedences[op1] > precedences[op2] def shunting_yard(expression): output = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = [] while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'): num.append(expression[i]) i += 1 output.append(''.join(num)) continue if expression[i] in '+-*/': while (operators and operators[-1] in '+-*/' and higher_precedence(operators[-1], expression[i])): output.append(operators.pop()) operators.append(expression[i]) elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() i += 1 while operators: output.append(operators.pop()) return output def evaluate_rpn(tokens): stack = [] for token in tokens: if token in '+-*/': b = float(stack.pop()) a = float(stack.pop()) stack.append(get_operator_fn(token)(a, b)) else: stack.append(token) return float(stack[0]) rpn = shunting_yard(expression) return evaluate_rpn(rpn)"},{"question":"from typing import List def maxTreasures(grid: List[List[int]]) -> int: Determine the maximum number of treasures you can collect from the top-left to the bottom-right corner of the grid. Args: grid (List[List[int]]): 2D list representing the grid where 1 is a treasure and 0 is an empty cell. Returns: int: Maximum number of treasures collected. Examples: >>> maxTreasures([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 3 >>> maxTreasures([[1, 0, 0, 1, 1], [0, 1, 0, 1, 1], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1]]) 8 pass # Example unittest cases def test_single_cell_grid_with_treasure(): grid = [[1]] assert maxTreasures(grid) == 1 def test_single_cell_grid_without_treasure(): grid = [[0]] assert maxTreasures(grid) == 0 def test_3x3_grid_example(): grid = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] assert maxTreasures(grid) == 3 def test_4x4_empty_grid(): grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert maxTreasures(grid) == 0 def test_4x4_full_grid(): grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert maxTreasures(grid) == 7 def test_larger_grid(): grid = [ [1, 0, 0, 1, 1], [0, 1, 0, 1, 1], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1] ] assert maxTreasures(grid) == 8","solution":"from typing import List def maxTreasures(grid: List[List[int]]) -> int: n = len(grid) dp = [[0]*n for _ in range(n)] # Initialize the treasure in the top-left cell dp[0][0] = grid[0][0] # Initialize the first row (rightward movement only) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column (downward movement only) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The maximum treasures collected will be in the bottom-right cell return dp[n-1][n-1]"},{"question":"def decrypt_message(s: str) -> str: Decrypts the message by removing all non-lowercase Latin letters and shifting each character forward by one position. >>> decrypt_message(\\"abc1!def2?ghi\\") \\"bcdefghij\\" >>> decrypt_message(\\"h3e&&*ll^o\\") \\"ifmmp\\"","solution":"def decrypt_message(s): Decrypts the message by removing all non-lowercase letters and shifting each character forward by one position. decrypted_message = [] for char in s: if 'a' <= char <= 'z': decrypted_message.append(chr((ord(char) - ord('a') + 1) % 26 + ord('a'))) return ''.join(decrypted_message)"},{"question":"def transform_and_sum(n: int, s: str, a: int, b: int) -> int: Transforms the string s by replacing 'a' with integer a and 'b' with integer b, and computes the sum of all digits in the transformed string. :param n: length of the string s :param s: the input string :param a: the integer to replace 'a' :param b: the integer to replace 'b' :return: the sum of all digits in the transformed string >>> transform_and_sum(5, 'abcde', 1, 2) 3 >>> transform_and_sum(4, 'cdef', 3, 4) 0 >>> transform_and_sum(6, 'aabbab', 9, 8) 51 >>> transform_and_sum(5, 'aaaaa', 5, 7) 25 >>> transform_and_sum(3, 'bbb', 6, 4) 12 >>> transform_and_sum(100000, 'a' * 100000, 9, 8) 900000","solution":"def transform_and_sum(n, s, a, b): Transforms the string s by replacing 'a' with integer a and 'b' with integer b, and computes the sum of all digits in the transformed string. :param n: length of the string s :param s: the input string :param a: the integer to replace 'a' :param b: the integer to replace 'b' :return: the sum of all digits in the transformed string transformed_string = \\"\\" for char in s: if char == 'a': transformed_string += str(a) elif char == 'b': transformed_string += str(b) else: transformed_string += char digit_sum = sum(int(char) for char in transformed_string if char.isdigit()) return digit_sum"},{"question":"from typing import List, Tuple def smallest_rectangle(points: List[Tuple[int, int]]) -> Tuple[int, int]: Given a list of points in the 2D plane, returns the dimensions of the smallest rectangle that can cover all the points. The sides of the rectangle are parallel to the x and y axes. :param points: List of tuples, where each tuple represents (x, y) coordinates of a point. :return: A tuple (width, height) representing the dimensions of the smallest rectangle. >>> smallest_rectangle([]) (0, 0) >>> smallest_rectangle([(1, 2), (2, 4), (3, 6)]) (2, 4) >>> smallest_rectangle([(0, 0), (5, 7), (9, 10), (2, -5)]) (9, 15) >>> smallest_rectangle([(0, 2), (0, 4), (0, 6)]) (0, 4) >>> smallest_rectangle([(1, 1), (2, 1), (3, 1)]) (2, 0)","solution":"def smallest_rectangle(points): Given a list of points in the 2D plane, returns the dimensions of the smallest rectangle that can cover all the points. The sides of the rectangle are parallel to the x and y axes. :param points: List of tuples, where each tuple represents (x, y) coordinates of a point. :return: A tuple (width, height) representing the dimensions of the smallest rectangle. if not points: return (0, 0) min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) width = max_x - min_x height = max_y - min_y return (width, height)"},{"question":"def canFormPalindrome(s: str) -> str: Determines if the characters of the given string can be rearranged to form a palindrome. >>> canFormPalindrome(\\"racecar\\") \\"Yes\\" >>> canFormPalindrome(\\"hello\\") \\"No\\" >>> canFormPalindrome(\\"aabb\\") \\"Yes\\" >>> canFormPalindrome(\\"abc\\") \\"No\\" >>> canFormPalindrome(\\"aaaa\\") \\"Yes\\" >>> canFormPalindrome(\\"aabbcc\\") \\"Yes\\" >>> canFormPalindrome(\\"aabbc\\") \\"Yes\\" >>> canFormPalindrome(\\"aabbccdd\\") \\"Yes\\"","solution":"def canFormPalindrome(s): Determines if the characters of the given string can be rearranged to form a palindrome. :param s: String input consisting of lowercase letters. :return: \\"Yes\\" if it's possible to rearrange the characters to form a palindrome, otherwise \\"No\\". from collections import Counter char_count = Counter(s) odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) return \\"Yes\\" if odd_counts <= 1 else \\"No\\""},{"question":"def transpose(matrix: List[List]) -> List[List]: Returns the transpose of a given 2D matrix. The transpose of a matrix is obtained by swapping the rows and columns, such that element at position (i, j) in the original matrix will be at position (j, i) in the transposed matrix. >>> transpose([[1]]) [[1]] >>> transpose([[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[\\"a\\", \\"b\\"], [\\"c\\", \\"d\\"]]) [[\\"a\\", \\"c\\"], [\\"b\\", \\"d\\"]] >>> transpose([[1, \\"b\\"], [3.5, None]]) [[1, 3.5], [\\"b\\", None]]","solution":"def transpose(matrix): Returns the transpose of a given 2D matrix. :param matrix: List of lists where each sublist has the same length. :return: Transposed matrix as a list of lists. return [list(row) for row in zip(*matrix)]"},{"question":"class Calculator: A simple calculator that performs basic arithmetic operations and maintains a history of all calculations. Methods: - add(a, b): Returns the sum of a and b. - subtract(a, b): Returns the difference between a and b. - multiply(a, b): Returns the product of a and b. - divide(a, b): Returns the quotient of a divided by b. - get_history(): Returns a list of strings describing performed operations and their results. Examples: >>> calc = Calculator() >>> calc.add(4, 5) 9 >>> calc.subtract(10, 3) 7 >>> calc.multiply(2, 3) 6 >>> calc.divide(8, 4) 2.0 >>> calc.get_history() [\\"4 + 5 = 9\\", \\"10 - 3 = 7\\", \\"2 * 3 = 6\\", \\"8 / 4 = 2.0\\"] import pytest def test_addition(): calc = Calculator() assert calc.add(4, 5) == 9 assert calc.add(-1, 1) == 0 assert calc.add(0, 0) == 0 def test_subtraction(): calc = Calculator() assert calc.subtract(10, 3) == 7 assert calc.subtract(0, 0) == 0 assert calc.subtract(-1, -1) == 0 def test_multiplication(): calc = Calculator() assert calc.multiply(2, 3) == 6 assert calc.multiply(0, 5) == 0 assert calc.multiply(-1, 5) == -5 def test_division(): calc = Calculator() assert calc.divide(8, 4) == 2.0 assert calc.divide(-9, 3) == -3 assert calc.divide(5, 2) == 2.5 with pytest.raises(ValueError, match=\\"Cannot divide by zero\\"): calc.divide(8, 0) def test_history(): calc = Calculator() calc.add(4, 5) calc.subtract(10, 3) calc.multiply(2, 3) calc.divide(8, 4) expected_history = [ \\"4 + 5 = 9\\", \\"10 - 3 = 7\\", \\"2 * 3 = 6\\", \\"8 / 4 = 2.0\\" ] assert calc.get_history() == expected_history def test_history_order(): calc = Calculator() calc.add(1, 2) calc.multiply(3, 4) calc.subtract(7, 8) calc.divide(9, 3) expected_history = [ \\"1 + 2 = 3\\", \\"3 * 4 = 12\\", \\"7 - 8 = -1\\", \\"9 / 3 = 3.0\\" ] assert calc.get_history() == expected_history","solution":"class Calculator: def __init__(self): self.history = [] def add(self, a, b): result = a + b self.history.append(f\\"{a} + {b} = {result}\\") return result def subtract(self, a, b): result = a - b self.history.append(f\\"{a} - {b} = {result}\\") return result def multiply(self, a, b): result = a * b self.history.append(f\\"{a} * {b} = {result}\\") return result def divide(self, a, b): if b == 0: raise ValueError(\\"Cannot divide by zero\\") result = a / b self.history.append(f\\"{a} / {b} = {result}\\") return result def get_history(self): return self.history"},{"question":"def longest_distinct_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. Args: s (str): The input string containing only lowercase alphabets. Returns: int: The length of the longest substring with all distinct characters. Examples: >>> longest_distinct_substring(\\"abcabcbb\\") 3 >>> longest_distinct_substring(\\"bbbbb\\") 1 >>> longest_distinct_substring(\\"pwwkew\\") 3 from solution import longest_distinct_substring def test_case_1(): assert longest_distinct_substring(\\"abcabcbb\\") == 3 def test_case_2(): assert longest_distinct_substring(\\"bbbbb\\") == 1 def test_case_3(): assert longest_distinct_substring(\\"pwwkew\\") == 3 def test_case_4(): assert longest_distinct_substring(\\"abcdef\\") == 6 def test_case_5(): assert longest_distinct_substring(\\"aab\\") == 2 def test_case_6(): assert longest_distinct_substring(\\"dvdf\\") == 3 def test_case_7(): assert longest_distinct_substring(\\"\\") == 0 def test_case_8(): assert longest_distinct_substring(\\"anviaj\\") == 5","solution":"def longest_distinct_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. Args: s (str): The input string containing only lowercase alphabets. Returns: int: The length of the longest substring with all distinct characters. n = len(s) if n == 0: return 0 char_index = {} max_length = 0 start = 0 for end in range(n): current_char = s[end] if current_char in char_index: start = max(start, char_index[current_char] + 1) char_index[current_char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_partition_pairs(arr: List[int], k: int) -> bool: Given an array of integers, determine if it is possible to partition the array into pairs such that the sum of each pair is divisible by a given integer k. Returns true if such a partitioning is possible, otherwise returns false. >>> can_partition_pairs([9, 7, 5, 3], 6) True >>> can_partition_pairs([1, 2, 3, 4, 5, 10, 6, 7, 8, 9], 5) True >>> can_partition_pairs([1, 2, 3, 4, 5, 6], 7) True >>> can_partition_pairs([1, 2, 3, 4, 5, 6], 10) False","solution":"from collections import defaultdict def can_partition_pairs(arr, k): # Create a frequency dictionary for remainders when arr elements are divided by k remainder_count = defaultdict(int) # Count frequencies of remainders for num in arr: remainder = num % k remainder_count[remainder] += 1 # Check conditions for partitioning for r in remainder_count: complement = (k - r) % k # If the remainder is 0, there should be an even count of such remainders if r == complement: if remainder_count[r] % 2 != 0: return False # For any other remainder, the count should match the count of its complement elif remainder_count[r] != remainder_count[complement]: return False return True"},{"question":"def max_treasure(n: int, m: int, grid: List[List[int]]) -> int: Finds the maximum number of treasures in any sub-rectangle of the grid. Args: n: int - number of rows in the grid m: int - number of columns in the grid grid: List[List[int]] - 2D list representing the grid Returns: int - the maximum number of treasures that can be collected in any sub-rectangle >>> max_treasure(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 9 >>> max_treasure(2, 4, [[0, 2, 2, 3], [1, 1, 4, 0]]) 4 >>> max_treasure(4, 1, [[5], [10], [15], [20]]) 20","solution":"def max_treasure(n, m, grid): Finds the maximum number of treasures in any sub-rectangle of the grid. max_value = 0 for i in range(n): for j in range(m): max_value = max(max_value, grid[i][j]) return max_value"},{"question":"def find_subarray_concatenations(t: int, test_cases: List[Tuple[str, List[str]]]) -> List[int]: Given a string s and a list of strings words, find the number of subarrays of words that concatenate to form the entire string s (substrings). >>> find_subarray_concatenations(2, [(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]), (\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"])]) [2, 1] >>> find_subarray_concatenations(1, [(\\"nothingmatcheshere\\", [\\"foo\\", \\"bar\\"])]) [0] >>> find_subarray_concatenations(1, [(\\"apple\\", [\\"apple\\"])]) [1] >>> find_subarray_concatenations(1, [(\\"aaaaa\\", [\\"a\\", \\"a\\"])]) [4] >>> find_subarray_concatenations(1, [(\\"abcabcabc\\", [\\"abc\\", \\"abc\\"])]) [2] >>> find_subarray_concatenations(1, [(\\"abcabcabcabd\\", [\\"abc\\", \\"abd\\"])]) [1]","solution":"def find_subarray_concatenations(t, test_cases): from collections import Counter def count_concatenations(s, words): word_length = len(words[0]) num_words = len(words) concat_length = word_length * num_words word_count = Counter(words) result = 0 for i in range(len(s) - concat_length + 1): seen_words = {} for j in range(num_words): part = s[i + j * word_length : i + (j + 1) * word_length] if part in word_count: if part in seen_words: seen_words[part] += 1 else: seen_words[part] = 1 if seen_words[part] > word_count[part]: break else: break if seen_words == word_count: result += 1 return result results = [] for i in range(t): s = test_cases[i][0] words = test_cases[i][1] results.append(count_concatenations(s, words)) return results"},{"question":"def minimal_total_construction_cost(n: int, d: int, costs: List[List[int]]) -> int: Determines the minimal total construction cost by selecting the companies with the smallest cost per meter for each segment. Parameters: - n: Number of segments - d: Length of each segment - costs: 2D list of cost per meter for each company to construct each segment Returns: - Total minimal construction cost >>> minimal_total_construction_cost(3, 10, [[5, 8], [6, 3], [7, 4]]) 120 >>> minimal_total_construction_cost(1, 5, [[10]]) 50 >>> minimal_total_construction_cost(1, 3, [[4, 2, 3]]) 6 >>> minimal_total_construction_cost(2, 6, [[3], [2]]) 30 >>> minimal_total_construction_cost(2, 10, [[7, 5, 6], [2, 9, 8]]) 70","solution":"def minimal_total_construction_cost(n, d, costs): Determines the minimal total construction cost by selecting the companies with the smallest cost per meter for each segment. Parameters: - n: Number of segments - d: Length of each segment - costs: 2D list of cost per meter for each company to construct each segment Returns: - Total minimal construction cost total_cost = 0 for i in range(n): min_cost_per_meter = min(costs[i]) total_cost += min_cost_per_meter * d return total_cost"},{"question":"import re def is_valid_password(password: str) -> bool: Determines if a password is valid based on the following criteria: - It must be at least 8 characters long. - It must contain at least one uppercase letter. - It must contain at least one lowercase letter. - It must contain at least one numeric digit. - It must contain at least one special character from the set: !@#%^&*()_+ Returns True if the password meets all the criteria, otherwise returns False. >>> is_valid_password(\\"Password123!\\") == True >>> is_valid_password(\\"password\\") == False >>> is_valid_password(\\"Password\\") == False >>> is_valid_password(\\"P@ssw0rd\\") == True","solution":"import re def is_valid_password(password): Determines if a password is valid based on the following criteria: - It must be at least 8 characters long. - It must contain at least one uppercase letter. - It must contain at least one lowercase letter. - It must contain at least one numeric digit. - It must contain at least one special character from the set: !@#%^&*()_+ Returns True if the password meets all the criteria, otherwise returns False. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*()_+]', password): return False return True"},{"question":"def separate_letters_and_digits(s: str) -> str: Separates the letters and digits in the string such that all letters come before all digits, maintaining their relative order. Args: s (str): Input string containing lowercase letters and digits. Returns: str: A new string with letters and digits separated. >>> separate_letters_and_digits(\\"ab3c2d1\\") == \\"abcd321\\" >>> separate_letters_and_digits(\\"1a2b3c4d\\") == \\"abcd1234\\" >>> separate_letters_and_digits(\\"a1b2c3d4\\") == \\"abcd1234\\" >>> separate_letters_and_digits(\\"abcd\\") == \\"abcd\\" >>> separate_letters_and_digits(\\"1234\\") == \\"1234\\" >>> separate_letters_and_digits(\\"a1b2\\") == \\"ab12\\" >>> separate_letters_and_digits(\\"1a2b\\") == \\"ab12\\"","solution":"def separate_letters_and_digits(s): Separates the letters and digits in the string such that all letters come before all digits, maintaining their relative order. Args: s (str): Input string containing lowercase letters and digits. Returns: str: A new string with letters and digits separated. letters = ''.join([char for char in s if char.isalpha()]) digits = ''.join([char for char in s if char.isdigit()]) return letters + digits"},{"question":"def max_subarray(nums: List[int]) -> Tuple[int, List[int]]: Given a list of integers, finds the contiguous subarray within an array that has the largest sum. Returns both the sum and the subarray itself. >>> max_subarray([1, -3, 2, 1, -1, 3, -2, 1]) (5, [2, 1, -1, 3]) >>> max_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) (7, [4, -1, -2, 1, 5]) >>> max_subarray([1]) (1, [1]) >>> max_subarray([-1, -1, -1, -1]) (-1, [-1]) >>> max_subarray([1, 2, 3, 4]) (10, [1, 2, 3, 4]) >>> max_subarray([]) (0, [])","solution":"def max_subarray(nums): if not nums: return (0, []) max_sum = current_sum = nums[0] start = end = s = 0 for i in range(1, len(nums)): if current_sum <= 0: current_sum = nums[i] s = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return (max_sum, nums[start:end+1])"},{"question":"def common_moves(team1, team2): Returns a list of unique common moves in the order they appear in team2's strategy. If there are no common moves, return [\\"no common moves\\"]. >>> common_moves([\\"pass\\", \\"shoot\\"], [\\"run\\", \\"pass\\", \\"block\\", \\"shoot\\"]) [\\"pass\\", \\"shoot\\"] >>> common_moves([\\"pass\\", \\"shoot\\"], [\\"run\\", \\"block\\", \\"defend\\"]) [\\"no common moves\\"] >>> common_moves([\\"pass\\", \\"shoot\\", \\"pass\\"], [\\"pass\\", \\"pass\\", \\"shoot\\"]) [\\"pass\\", \\"shoot\\"] >>> common_moves([\\"block\\", \\"tackle\\"], [\\"tackle\\", \\"block\\", \\"run\\"]) [\\"tackle\\", \\"block\\"] >>> common_moves([], [\\"run\\", \\"block\\"]) [\\"no common moves\\"] >>> common_moves([\\"pass\\", \\"shoot\\"], []) [\\"no common moves\\"]","solution":"def common_moves(team1, team2): Returns a list of unique common moves in the order they appear in team2's strategy. If there are no common moves, returns [\\"no common moves\\"]. common = [] seen_moves = set(team1) for move in team2: if move in seen_moves and move not in common: common.append(move) return common if common else [\\"no common moves\\"]"},{"question":"def longest_even_sum_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray where every pair of adjacent elements has an even sum. >>> longest_even_sum_subarray([1, 3, 5, 7, 9, 2, 4, 6, 8, 10]) 5 >>> longest_even_sum_subarray([5, 5, 5, 5]) 4 >>> longest_even_sum_subarray([2, 4]) 2 >>> longest_even_sum_subarray([1, 2, 3, 4, 5]) 0 >>> longest_even_sum_subarray([1, 1, 1, 1, 0, 2, 2, 2]) 4 >>> longest_even_sum_subarray([42]) 0 >>> longest_even_sum_subarray([3, 3, 3]) 3 >>> longest_even_sum_subarray([2, 2, 2, 2]) 4 # Implementation here","solution":"def longest_even_sum_subarray(arr): Returns the length of the longest contiguous subarray where every pair of adjacent elements has an even sum. max_length = 0 current_length = 0 for i in range(len(arr) - 1): if (arr[i] + arr[i+1]) % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 # Return max_length + 1 because subarray length will be one more than the count of pairs return max_length + 1 if max_length > 0 else 0"},{"question":"def subarray_sum_exists(q, test_cases): Determine if there exists a subarray of length k such that the sum of its elements is equal to the target value t in a list of test cases. Args: q (int): The number of test cases. test_cases (list of dict): List of dictionaries where each dictionary contains: - 'nkt': tuple with three integers n, k, t - 'arr': list of integers representing the array elements Returns: list: A list containing \\"Yes\\" or \\"No\\" for each test case. >>> q = 3 >>> test_cases = [ ... {'nkt': (5, 3, 6), 'arr': [1, 2, 3, 4, 5]}, ... {'nkt': (4, 2, -1), 'arr': [1, -2, 3, -4]}, ... {'nkt': (3, 1, 0), 'arr': [0, 0, 0]} ... ] >>> subarray_sum_exists(q, test_cases) [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def subarray_sum_exists(q, test_cases): results = [] for i in range(q): n, k, t = test_cases[i]['nkt'] arr = test_cases[i]['arr'] current_sum = sum(arr[:k]) if current_sum == t: results.append(\\"Yes\\") continue found = False for j in range(k, n): current_sum = current_sum - arr[j - k] + arr[j] if current_sum == t: results.append(\\"Yes\\") found = True break if not found: results.append(\\"No\\") return results"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns an array where each element is the product of all the elements in the original array except the one at the same index. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60]","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements in the original array except the one at the same index. length = len(nums) # Initialize the output array with 1's for multiplication identity. output = [1] * length # Calculate products to the left of each element. left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] # Calculate products to the right of each element and multiply with current output. right_product = 1 for i in range(length - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def stack_simulation(operations): Simulate the behavior of a stack with additional operation to reverse the stack. >>> stack_simulation([\\"PUSH 3\\", \\"PUSH 5\\", \\"TOP\\", \\"POP\\", \\"TOP\\", \\"PUSH 2\\", \\"REVERSE-STACK\\", \\"TOP\\", \\"POP\\"]) [5, 3, 3] >>> stack_simulation([\\"PUSH 1\\", \\"POP\\", \\"TOP\\"]) [\\"EMPTY\\"] >>> stack_simulation([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"REVERSE-STACK\\", \\"TOP\\", \\"POP\\", \\"TOP\\"]) [1, 2] >>> stack_simulation([\\"PUSH 42\\", \\"TOP\\", \\"TOP\\", \\"POP\\", \\"TOP\\"]) [42, 42, \\"EMPTY\\"] >>> stack_simulation([\\"PUSH 10\\", \\"PUSH 20\\", \\"POP\\", \\"TOP\\", \\"PUSH 30\\", \\"TOP\\", \\"POP\\", \\"TOP\\"]) [10, 30, 10]","solution":"def stack_simulation(operations): stack = [] result = [] for operation in operations: if operation.startswith(\\"PUSH\\"): _, x = operation.split() stack.append(int(x)) elif operation == \\"POP\\": if stack: stack.pop() elif operation == \\"TOP\\": if stack: result.append(stack[-1]) else: result.append(\\"EMPTY\\") elif operation == \\"REVERSE-STACK\\": stack.reverse() return result"},{"question":"def longest_interesting_substring_length(S: str) -> int: Find the length of the longest interesting substring of S. >>> longest_interesting_substring_length(\\"110001\\") 6 >>> longest_interesting_substring_length(\\"10101\\") 4 >>> longest_interesting_substring_length(\\"11100\\") 4 >>> longest_interesting_substring_length(\\"0\\") 0 >>> longest_interesting_substring_length(\\"1\\") 0 >>> longest_interesting_substring_length(\\"01\\") 2 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return an array of results. >>> process_test_cases(3, [\\"110001\\", \\"10101\\", \\"11100\\"]) [6, 4, 4] >>> process_test_cases(2, [\\"0\\" * 100000, \\"1\\" * 100000]) [0, 0]","solution":"def longest_interesting_substring_length(S): n = len(S) count = {0: -1} balance = 0 max_length = 0 for i in range(n): if S[i] == '1': balance += 1 else: balance -= 1 if balance in count: max_length = max(max_length, i - count[balance]) else: count[balance] = i return max_length def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(longest_interesting_substring_length(S)) return results"},{"question":"def max_length_subarray_with_equal_0s_1s(n: int, k: int, binary_string: str) -> int: Find the maximum length of contiguous subarray with equal number of '0's and '1's. >>> max_length_subarray_with_equal_0s_1s(6, 3, '010101') 6 >>> max_length_subarray_with_equal_0s_1s(5, 2, '10010') 4 >>> max_length_subarray_with_equal_0s_1s(4, 2, '1100') 4 >>> max_length_subarray_with_equal_0s_1s(7, 3, '1110001') 6 >>> max_length_subarray_with_equal_0s_1s(3, 0, '000') 0 >>> max_length_subarray_with_equal_0s_1s(3, 3, '111') 0 def solve(test_cases: List[Tuple[int, int, str]]) -> List[int]: Solve multiple test cases. >>> test_cases = [(6, 3, '010101'), (5, 2, '10010'), (4, 2, '1100')] >>> solve(test_cases) [6, 4, 4]","solution":"def max_length_subarray_with_equal_0s_1s(n, k, binary_string): prefix_sum = {0: -1} max_len = 0 current_sum = 0 for i, ch in enumerate(binary_string): current_sum += 1 if ch == '1' else -1 if current_sum in prefix_sum: max_len = max(max_len, i - prefix_sum[current_sum]) else: prefix_sum[current_sum] = i return max_len def solve(test_cases): results = [] for n, k, binary_string in test_cases: results.append(max_length_subarray_with_equal_0s_1s(n, k, binary_string)) return results"},{"question":"def find_missing_letter(arr: list) -> str: Write a function \`find_missing_letter(arr)\` that takes an array of consecutive (increasing) letters as input and returns the missing letter in the array. Example: >>> find_missing_letter(['a', 'b', 'c', 'd', 'f']) 'e' >>> find_missing_letter(['O', 'Q', 'R', 'S']) 'P'","solution":"def find_missing_letter(arr): Given an array of consecutive (increasing) letters, returns the missing letter. for i in range(1, len(arr)): if ord(arr[i]) - ord(arr[i-1]) != 1: return chr(ord(arr[i-1]) + 1)"},{"question":"def isPerfectSquare(number: int) -> str: Determine if the given number is a perfect square number or not. >>> isPerfectSquare(4) \\"Perfect Square!!\\" >>> isPerfectSquare(0) \\"Perfect Square!!\\" >>> isPerfectSquare(1) \\"Perfect Square!!\\" >>> isPerfectSquare(144) \\"Perfect Square!!\\" >>> isPerfectSquare(15) \\"NOT!!\\" >>> isPerfectSquare(7) \\"NOT!!\\"","solution":"import math def isPerfectSquare(number): Determine if the given number is a perfect square number or not. Args: number (int): The number to check. Returns: str: \\"Perfect Square!!\\" if the number is a perfect square, otherwise \\"NOT!!\\" if number < 0: return \\"NOT!!\\" sqrt = int(math.sqrt(number)) if sqrt * sqrt == number: return \\"Perfect Square!!\\" else: return \\"NOT!!\\""},{"question":"def distance_between_characters(s: str) -> str: Returns the series of absolute differences between the positions of consecutive characters in the alphabet. >>> distance_between_characters(\\"\\") \\"\\" >>> distance_between_characters(\\"a\\") \\"\\" >>> distance_between_characters(\\"abc\\") \\"1 1\\" >>> distance_between_characters(\\"az\\") \\"25\\" >>> distance_between_characters(\\"ace\\") \\"2 2\\" >>> distance_between_characters(\\"aaa\\") \\"0 0\\"","solution":"def distance_between_characters(s: str) -> str: Returns the series of absolute differences between the positions of consecutive characters in the alphabet. if len(s) < 2: return \\"\\" result = [] for i in range(len(s) - 1): pos1 = ord(s[i]) - ord('a') + 1 pos2 = ord(s[i + 1]) - ord('a') + 1 result.append(abs(pos2 - pos1)) return \\" \\".join(map(str, result))"},{"question":"def compare_arrays(arr1, arr2): Determines if both arrays contain exactly the same unique elements with the same frequencies, regardless of their order. Args: arr1 (list of int): First input array. arr2 (list of int): Second input array. Returns: bool: True if the arrays are equivalent, False otherwise. pass from collections import Counter def test_compare_arrays_equivalent(): assert compare_arrays([1, 2, 2, 3], [2, 3, 1, 2]) == True assert compare_arrays([], []) == True assert compare_arrays([1], [1]) == True assert compare_arrays([0, 0, 0], [0, 0, 0]) == True def test_compare_arrays_non_equivalent(): assert compare_arrays([1, 1, 1, 2], [1, 2, 2, 1]) == False assert compare_arrays([4, 5, 6], [6, 4]) == False assert compare_arrays([1, 3, 2], [1, 3, 3]) == False assert compare_arrays([1, 2], [1, 2, 2]) == False assert compare_arrays([1, 2, 3], [3, 2, 1, 1]) == False def test_compare_arrays_edge_cases(): assert compare_arrays([], [1]) == False assert compare_arrays([0], []) == False assert compare_arrays([1000000000], [1000000000]) == True assert compare_arrays([-1, -1, -2], [-2, -1, -1]) == True assert compare_arrays([-1, -1, -2], [-2, -1, 1]) == False","solution":"from collections import Counter def compare_arrays(arr1, arr2): Determines if both arrays contain exactly the same unique elements with the same frequencies, regardless of their order. Args: arr1 (list of int): First input array. arr2 (list of int): Second input array. Returns: bool: True if the arrays are equivalent, False otherwise. return Counter(arr1) == Counter(arr2)"},{"question":"def is_balanced(s): Check if the string s is balanced. A string is considered balanced if the counts of all non-repeating alphabetic characters are equal. Ignore uppercase letters, treat them the same as their lowercase counterparts. Non-alphabetic characters should be ignored. If the input is not of string type, return \\"Invalid input\\". Parameters: s (str): the string to be checked Returns: bool: True if the string is balanced, False otherwise str: \\"Invalid input\\" if the input is not a string","solution":"def is_balanced(s): Check if the string s is balanced. A string is considered balanced if the counts of all non-repeating alphabetic characters are equal. Parameters: s (str): the string to be checked Returns: bool: True if the string is balanced, False otherwise str: \\"Invalid input\\" if the input is not a string if not isinstance(s, str): return \\"Invalid input\\" from collections import Counter # Normalize string: convert to lowercase and filter out non-alphabetic characters s = ''.join(filter(str.isalpha, s.lower())) # Get counts of each character char_counts = Counter(s) # Extract values of counts count_values = list(char_counts.values()) # Check if all counts are the same return len(set(count_values)) <= 1"},{"question":"def sort_array_by_parity(nums: List[int]) -> List[int]: Sorts the array such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers is preserved. >>> sort_array_by_parity([3, 1, 2, 4]) [2, 4, 3, 1] >>> sort_array_by_parity([0, 1, 2]) [0, 2, 1] # Your code here","solution":"def sort_array_by_parity(nums): Sorts the array such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers is preserved. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def max_employees_with_bikes(n: int, m: int, time_slots: List[Tuple[int, int]]) -> int: Determines the maximum number of employees who can use bikes without overlapping their time slots. Args: n (int): Number of employees. m (int): Number of bikes. time_slots (list of tuples): Each tuple contains the start and end time for each employee. Returns: int: The maximum number of employees who can use the bikes. pass # Test cases def test_example_1(): n = 5 m = 2 time_slots = [(1, 4), (2, 6), (5, 8), (3, 5), (7, 9)] assert max_employees_with_bikes(n, m, time_slots) == 4 def test_example_2(): n = 3 m = 3 time_slots = [(1, 3), (2, 5), (6, 9)] assert max_employees_with_bikes(n, m, time_slots) == 3 def test_single_employee_single_bike(): n = 1 m = 1 time_slots = [(0, 1)] assert max_employees_with_bikes(n, m, time_slots) == 1 def test_multiple_employees_single_bike(): n = 3 m = 1 time_slots = [(0, 2), (2, 4), (1, 3)] assert max_employees_with_bikes(n, m, time_slots) == 2 def test_no_overlapping_slots(): n = 4 m = 2 time_slots = [(0, 1), (1, 2), (2, 3), (3, 4)] assert max_employees_with_bikes(n, m, time_slots) == 4 def test_all_overlapping_slots(): n = 4 m = 2 time_slots = [(0, 4), (0, 4), (0, 4), (0, 4)] assert max_employees_with_bikes(n, m, time_slots) == 2 def test_all_bikes_used(): n = 6 m = 3 time_slots = [(0, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 7)] assert max_employees_with_bikes(n, m, time_slots) == 6","solution":"def max_employees_with_bikes(n, m, time_slots): Determines the maximum number of employees who can use bikes without overlapping their time slots. Args: n (int): Number of employees. m (int): Number of bikes. time_slots (list of tuples): Each tuple contains the start and end time for each employee. Returns: int: The maximum number of employees who can use the bikes. # Sort the time slots based on end time sorted_slots = sorted(time_slots, key=lambda x: x[1]) bike_end_times = [0] * m used_bikes = 0 for start, end in sorted_slots: for i in range(m): if bike_end_times[i] <= start: bike_end_times[i] = end used_bikes += 1 break return used_bikes"},{"question":"from datetime import datetime, timedelta def assign_due_date(task_priority: str) -> str: Returns the due date based on the priority of the task (\\"low\\", \\"medium\\", \\"high\\"). - \\"low\\": 5 days from now - \\"medium\\": 3 days from now - \\"high\\": 1 day from now For the purpose of this function, the current date is fixed to \\"2023-10-01\\". Example: >>> assign_due_date(\\"low\\") '2023-10-06' >>> assign_due_date(\\"medium\\") '2023-10-04' >>> assign_due_date(\\"high\\") '2023-10-02' def test_assign_due_date_low(): assert assign_due_date(\\"low\\") == \\"2023-10-06\\" def test_assign_due_date_medium(): assert assign_due_date(\\"medium\\") == \\"2023-10-04\\" def test_assign_due_date_high(): assert assign_due_date(\\"high\\") == \\"2023-10-02\\" def test_assign_due_date_invalid(): try: assign_due_date(\\"urgent\\") assert False, \\"ValueError not raised for invalid priority\\" except ValueError: pass","solution":"from datetime import datetime, timedelta def assign_due_date(task_priority): Returns the due date based on the priority of the task (\\"low\\", \\"medium\\", \\"high\\"). - \\"low\\": 5 days from now - \\"medium\\": 3 days from now - \\"high\\": 1 day from now For the purpose of this function, the current date is fixed to \\"2023-10-01\\". current_date = datetime(2023, 10, 1) if task_priority == \\"low\\": due_date = current_date + timedelta(days=5) elif task_priority == \\"medium\\": due_date = current_date + timedelta(days=3) elif task_priority == \\"high\\": due_date = current_date + timedelta(days=1) else: raise ValueError(\\"Invalid task priority\\") return due_date.strftime(\\"%Y-%m-%d\\")"},{"question":"class Rectangle: Represents a rectangle with width and height attributes. Methods: - __init__(self, width, height): Initializes the instance with width and height. - area(self): Returns the area of the rectangle. - perimeter(self): Returns the perimeter of the rectangle. - resize(self, width, height): Changes the dimensions of the rectangle to the new width and height. - is_square(self): Returns True if the rectangle is a square, otherwise False. Examples: >>> rect = Rectangle(4, 5) >>> rect.area() 20 >>> rect.perimeter() 18 >>> rect.is_square() False >>> rect.resize(3, 3) >>> rect.is_square() True >>> rect.resize(-1, 5) Traceback (most recent call last): ... ValueError: Width and height must be positive numbers def __init__(self, width, height): pass def area(self): pass def perimeter(self): pass def resize(self, width, height): pass def is_square(self): pass","solution":"class Rectangle: def __init__(self, width, height): Initializes the instance with width and height. if width <= 0 or height <= 0: raise ValueError(\\"Width and height must be positive numbers\\") self.width = width self.height = height def area(self): Returns the area of the rectangle. return self.width * self.height def perimeter(self): Returns the perimeter of the rectangle. return 2 * (self.width + self.height) def resize(self, width, height): Changes the dimensions of the rectangle to the new width and height. Raises ValueError if width or height are not positive numbers. if width <= 0 or height <= 0: raise ValueError(\\"Width and height must be positive numbers\\") self.width = width self.height = height def is_square(self): Returns True if the rectangle is a square, otherwise False. return self.width == self.height"},{"question":"def can_permute_palindrome(s: str) -> bool: Given a string s, return true if any permutation of the string is a palindrome, otherwise return false. >>> can_permute_palindrome(\\"code\\") False >>> can_permute_palindrome(\\"aab\\") True >>> can_permute_palindrome(\\"carerac\\") True >>> can_permute_palindrome(\\"a\\") True >>> can_permute_palindrome(\\"aaaa\\") True >>> can_permute_palindrome(\\"racecar\\") True >>> can_permute_palindrome(\\"aabbccddeeffg\\") True >>> can_permute_palindrome(\\"abcdefgh\\") False >>> can_permute_palindrome(\\"\\") True","solution":"def can_permute_palindrome(s): Returns True if any permutation of the string s can form a palindrome, otherwise returns False. # Count the occurrence of each character in the string char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the number of characters that have odd counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # At most one character should have an odd count for the string to be a palindrome permutation return odd_count <= 1"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Implement a function that takes a list of integers and returns a new list where each integer is replaced with the product of every other integer in the original list. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) left_products = [1] * length right_products = [1] * length result = [1] * length # Calculate left products for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Combine left and right products to form the result for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def canSegmentString(s: str, words: List[str]) -> bool: Given a string s and a list of words words, determine if s can be segmented into a space-separated sequence of one or more dictionary words from words. >>> canSegmentString(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> canSegmentString(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> canSegmentString(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> canSegmentString(\\"applepie\\", [\\"apple\\", \\"pie\\"]) True >>> canSegmentString(\\"\\", [\\"apple\\", \\"pen\\"]) True >>> canSegmentString(\\"applepie\\", []) False >>> canSegmentString(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) True","solution":"from typing import List def canSegmentString(s: str, words: List[str]) -> bool: word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True # Empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 8] >>> merge_sorted_arrays([4, 5, 6], [1, 2, 3]) [1, 2, 3, 4, 5, 6]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. m, n = len(arr1), len(arr2) merged_array = [] i = j = 0 # Traverse through both arrays and pick the smallest element from either array while i < m and j < n: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Store remaining elements of the first array while i < m: merged_array.append(arr1[i]) i += 1 # Store remaining elements of the second array while j < n: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def move_evens_to_front(arr: List[int]) -> List[int]: Moves all even integers to the beginning of the array, followed by all the odd integers, while preserving the relative order of the even and odd integers. Args: arr (list): List of integers Returns: list: A list where all even integers are at the beginning followed by all odd integers >>> move_evens_to_front([3, 1, 2, 4]) [2, 4, 3, 1] >>> move_evens_to_front([3, 1, 7]) [3, 1, 7] >>> move_evens_to_front([8, 5, 6, 4]) [8, 6, 4, 5]","solution":"def move_evens_to_front(arr): Moves all even integers to the beginning of the array, followed by all the odd integers, while preserving the relative order of the even and odd integers. Args: arr (list): List of integers Returns: list: A list where all even integers are at the beginning followed by all odd integers evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def rearrange(s: str) -> str: Rearranges the digits in the input string in ascending order while maintaining the positions of the letters. :param s: Input string containing a mix of integers and letters :return: Modified string with sorted digits >>> rearrange(\\"a3b2c1\\") \\"a1b2c3\\" >>> rearrange(\\"z7x9y4\\") \\"z4x7y9\\" >>> rearrange(\\"a1b2c3d456\\") \\"a1b2c3d456\\"","solution":"def rearrange(s): Rearranges the digits in the input string in ascending order while maintaining the positions of the letters. :param s: Input string containing a mix of integers and letters :return: Modified string with sorted digits digits = sorted([char for char in s if char.isdigit()]) result = [] digit_index = 0 for char in s: if char.isdigit(): result.append(digits[digit_index]) digit_index += 1 else: result.append(char) return \\"\\".join(result)"},{"question":"def book_allocation(test_cases): You are given a number of books, each with a certain number of pages. You want to assign these books to exactly k students so that each student gets a contiguous sequence of books. The goal is to minimize the maximum number of pages assigned to a student. Input: - The function receives a list of test cases. Each test case is a dictionary with: - \\"n\\": the number of books (integer) - \\"k\\": the number of students (integer) - \\"books\\": a list of integers, where each integer represents the number of pages in each book Output: - The function should return a list of integers, where each integer is the minimum possible value of the maximum number of pages assigned to a student for each test case. Example: >>> test_cases = [{'n': 4, 'k': 2, 'books': [12, 34, 67, 90]}] >>> book_allocation(test_cases) [113] >>> test_cases = [{'n': 3, 'k': 1, 'books': [15, 20, 25]}] >>> book_allocation(test_cases) [60] >>> test_cases = [{'n': 5, 'k': 3, 'books': [1, 2, 3, 4, 5]}] >>> book_allocation(test_cases) [6]","solution":"def is_possible(books, n, k, max_pages): students_required = 1 current_pages = 0 for pages in books: if current_pages + pages > max_pages: students_required += 1 current_pages = pages if students_required > k: return False else: current_pages += pages return True def find_minimum_maximum_pages(books, n, k): start, end = max(books), sum(books) result = end while start <= end: mid = (start + end) // 2 if is_possible(books, n, k, mid): result = mid end = mid - 1 else: start = mid + 1 return result def book_allocation(test_cases): results = [] for test_case in test_cases: n, k, books = test_case['n'], test_case['k'], test_case['books'] result = find_minimum_maximum_pages(books, n, k) results.append(result) return results"},{"question":"def compareSquares(numbers: List[int]) -> bool: Returns True if the sum of the squares of the even numbers is greater than the sum of the squares of the odd numbers. Otherwise, returns False. >>> compareSquares([1, 2, 3, 4, 5]) -> False >>> compareSquares([1, 3, 5, 7]) -> False >>> compareSquares([2, 4, 6, 8]) -> True >>> compareSquares([]) -> False >>> compareSquares([2, 3, 2, 3]) -> False","solution":"def compareSquares(numbers): Returns True if the sum of the squares of the even numbers is greater than the sum of the squares of the odd numbers. Otherwise, returns False. even_sum = sum(x * x for x in numbers if x % 2 == 0) odd_sum = sum(x * x for x in numbers if x % 2 != 0) return even_sum > odd_sum"},{"question":"def maxSubArraySum(arr: List[int]) -> int: Given a list of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. >>> maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSubArraySum([-2, -3, -1, -4]) -1 >>> maxSubArraySum([1]) 1 >>> maxSubArraySum([-1]) -1 >>> maxSubArraySum([1, 2, 3, 4, 5]) 15 >>> maxSubArraySum([]) 0 >>> maxSubArraySum([3, -2, 5, -1]) 6 >>> maxSubArraySum([9, -9, 9, -9, 9]) 9 pass","solution":"def maxSubArraySum(arr): Function to find the contiguous subarray which has the largest sum. Parameters: arr (list): List of integers Returns: int: The sum of the largest contiguous subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. Args: n: An integer to check primality. Returns: True if n is a prime number, False otherwise. pass def get_prime_numbers(numbers: List[int]) -> List[int]: Returns a list containing all prime numbers from the input list. Args: numbers: A list of integers to check for prime numbers. Returns: A list containing prime numbers from the input list. >>> get_prime_numbers([2, 3, 5, 7, 11, 13, 17, 19, 23]) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> get_prime_numbers([10, 15, 3, 7, 19]) [3, 7, 19] pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is a prime number if n % 2 == 0: return False # All other even numbers are not primes for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def get_prime_numbers(numbers): Returns a list containing all prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"def convert_temperature(temp, input_scale, target_scale): Convert a temperature from one scale to another. Args: temp (float): The input temperature value. input_scale (str): The input scale ('C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin). target_scale (str): The target scale ('C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin). Returns: float: The converted temperature value. Example: >>> convert_temperature(0, 'C', 'F') 32.0 >>> convert_temperature(100, 'C', 'K') 373.15 >>> convert_temperature(32, 'F', 'C') 0.0 >>> convert_temperature(273.15, 'K', 'C') 0.0","solution":"def convert_temperature(temp, input_scale, target_scale): if input_scale == target_scale: return temp # Convert input temperature to Celsius if input_scale == 'F': celsius = (temp - 32) * 5.0/9.0 elif input_scale == 'K': celsius = temp - 273.15 else: celsius = temp # Convert Celsius to target_scale if target_scale == 'F': return (celsius * 9.0/5.0) + 32 elif target_scale == 'K': return celsius + 273.15 else: return celsius"},{"question":"def subarray_sum(arr, k): Given an unsorted array of integers, find the number of subarrays which have a sum equal to a given value. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, -1, 1], 1) 3 >>> subarray_sum([0, 0, 0], 0) 6 >>> subarray_sum([1, 2, 3], 7) 0","solution":"def subarray_sum(arr, k): Finds the number of subarrays that sum up to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in arr: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def shortest_subarray_length(n: int, k: int) -> int: Given two integers n and k, return the length of the shortest subarray from a sequence array of n elements (all set to 1 by default) such that the sum of the subarray is at least k. If no such subarray exists, return -1. >>> shortest_subarray_length(5, 3) 3 >>> shortest_subarray_length(10, 15) -1 >>> shortest_subarray_length(7, 4) 4 pass","solution":"def shortest_subarray_length(n, k): Given two integers n and k, return the length of the shortest subarray from a sequence array of n elements (all set to 1 by default) such that the sum of the subarray is at least k. If no such subarray exists, return -1. if k > n: return -1 return k"},{"question":"def first_missing_positive(nums: List[int]) -> int: Returns the smallest missing positive integer from the list. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def first_missing_positive(nums): Returns the smallest missing positive integer from the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap the elements to their correct positions nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int = 0, next: 'ListNode' = None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into one sorted linked list. >>> linkedlist_to_list(mergeKLists([list_to_linkedlist([1,4,5]), list_to_linkedlist([1,3,4]), list_to_linkedlist([2,6])])) [1, 1, 2, 3, 4, 4, 5, 6] >>> linkedlist_to_list(mergeKLists([])) [] >>> linkedlist_to_list(mergeKLists([list_to_linkedlist([])])) [] def list_to_linkedlist(array): Helper function to convert list to linked list. if not array: return None head = ListNode(array[0]) current = head for val in array[1:]: current.next = ListNode(val) current = current.next return head def linkedlist_to_list(head): Helper function to convert linked list to list. array = [] while head: array.append(head.val) head = head.next return array","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int = 0, next: 'ListNode' = None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into one sorted linked list. ListNode.__lt__ = lambda self, other: self.val < other.val # Add comparison method to ListNode min_heap = [] dummy = ListNode(None) current = dummy # Initialize the heap for l in lists: if l: heapq.heappush(min_heap, l) while min_heap: smallest_node = heapq.heappop(min_heap) current.next = smallest_node current = current.next if smallest_node.next: heapq.heappush(min_heap, smallest_node.next) return dummy.next"},{"question":"from typing import List def num_decodings(s: str) -> int: Determine the number of ways to decode a given encoded message. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"06\\") 0 def decode_messages(t: int, cases: List[str]) -> List[int]: Find the number of possible valid decodings for each encoded message. >>> decode_messages(3, [\\"12\\", \\"226\\", \\"06\\"]) [2, 3, 0] >>> decode_messages(5, [\\"10\\", \\"101\\", \\"111\\", \\"0\\", \\"\\"]) [1, 1, 3, 0, 0]","solution":"def num_decodings(s): if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n] def decode_messages(t, cases): results = [] for case in cases: results.append(num_decodings(case)) return results"},{"question":"def has_triplet_with_sum(nums, target): Determines if there are three distinct elements in the list that sum up to the target number. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: bool: True if such a triplet exists, False otherwise. >>> has_triplet_with_sum([1, 2, 3, 4, 5], 9) True >>> has_triplet_with_sum([1, 2, 4, 5], 12) False >>> has_triplet_with_sum([-1, 2, 1, -4, 3], 2) True >>> has_triplet_with_sum([100, 200, 300, 400, 500], 1000) True >>> has_triplet_with_sum([1, 2], 3) False >>> has_triplet_with_sum([-1, 0, 1, 2], 0) True >>> has_triplet_with_sum([1, 2, 2, 3, 4], 7) True","solution":"def has_triplet_with_sum(nums, target): Determines if there are three distinct elements in the list that sum up to the target number. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: bool: True if such a triplet exists, False otherwise. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == target: return True elif triplet_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def has_pair_with_difference(nums: List[int], k: int) -> bool: Determines if there exist two distinct indices i and j in the list such that the absolute difference between nums[i] and nums[j] is equal to k. :param nums: List of integers :param k: Integer value for the required absolute difference :return: True if such a pair exists, otherwise False # Your code here # Unit tests def test_example1(): assert has_pair_with_difference([1, 5, 3, 4, 2], 2) == True def test_example2(): assert has_pair_with_difference([8, 12, 16, 4, 0, 20], 4) == True def test_example3(): assert has_pair_with_difference([1, 2, 3, 4, 5], 10) == False def test_same_elements_no_difference(): assert has_pair_with_difference([2, 2, 2, 2], 1) == False def test_same_elements_with_difference(): assert has_pair_with_difference([2, 2, 2, 2], 0) == True def test_negative_and_positive_numbers(): assert has_pair_with_difference([-1, -2, 1, 2], 3) == True def test_large_k(): assert has_pair_with_difference([5, 10, 15, 20], 25) == False def test_empty_list(): assert has_pair_with_difference([], 5) == False def test_single_element(): assert has_pair_with_difference([1], 0) == False def test_two_elements_satisfying_diff(): assert has_pair_with_difference([1, 5], 4) == True def test_two_elements_not_satisfying_diff(): assert has_pair_with_difference([1, 5], 3) == False","solution":"from typing import List def has_pair_with_difference(nums: List[int], k: int) -> bool: Determines if there exist two distinct indices i and j in the list such that the absolute difference between nums[i] and nums[j] is equal to k. :param nums: List of integers :param k: Integer value for the required absolute difference :return: True if such a pair exists, otherwise False num_set = set(nums) for num in nums: if (num + k in num_set and (num + k != num or nums.count(num) > 1)) or (num - k in num_set and (num - k != num or nums.count(num) > 1)): return True return False"},{"question":"def has_increasing_triplet(T, test_cases): Determine whether there exists a subsequence of three distinct numbers in each sequence such that they are in increasing order. Parameters: T: int - the number of test cases test_cases: list of tuples - each tuple contains an integer N (the length of the sequence) and a list of N integers Returns: list of str - \\"YES\\" if there exists an increasing triplet in the sequence, \\"NO\\" otherwise >>> has_increasing_triplet(2, [(5, [1, 2, 3, 4, 5]), (4, [5, 4, 3, 2])]) ['YES', 'NO'] >>> has_increasing_triplet(1, [(6, [1, 2, 1, 2, 3, 4])]) ['YES'] >>> has_increasing_triplet(1, [(5, [5, 4, 3, 2, 1])]) ['NO'] results = [] for i in range(T): N, A = test_cases[i] if N < 3: results.append(\\"NO\\") continue first = float('inf') second = float('inf') for number in A: if number <= first: first = number elif number <= second: second = number else: results.append(\\"YES\\") break else: results.append(\\"NO\\") return results def test_case_1(): T = 2 test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [5, 4, 3, 2]) ] expected = [\\"YES\\", \\"NO\\"] assert has_increasing_triplet(T, test_cases) == expected def test_minimal_sequences(): T = 3 test_cases = [ (1, [1]), (2, [1, 2]), (3, [2, 2, 2]) ] expected = [\\"NO\\", \\"NO\\", \\"NO\\"] assert has_increasing_triplet(T, test_cases) == expected def test_increasing_triplet_exists(): T = 1 test_cases = [ (6, [1, 2, 1, 2, 3, 4]) ] expected = [\\"YES\\"] assert has_increasing_triplet(T, test_cases) == expected def test_no_increasing_triplet(): T = 1 test_cases = [ (5, [5, 4, 3, 2, 1]) ] expected = [\\"NO\\"] assert has_increasing_triplet(T, test_cases) == expected def test_duplicates_in_array(): T = 1 test_cases = [ (7, [2, 5, 3, 4, 2, 6, 1]) ] expected = [\\"YES\\"] assert has_increasing_triplet(T, test_cases) == expected def test_large_case(): T = 1 test_cases = [ (100000, list(range(100000, 0, -1))) ] expected = [\\"NO\\"] assert has_increasing_triplet(T, test_cases) == expected","solution":"def has_increasing_triplet(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] if N < 3: results.append(\\"NO\\") continue first = float('inf') second = float('inf') for number in A: if number <= first: first = number elif number <= second: second = number else: results.append(\\"YES\\") break else: results.append(\\"NO\\") return results"},{"question":"def contains_all_letters(s: str) -> bool: Checks if a given string contains every letter of the English alphabet at least once, ignoring case and non-alphabetic characters. Args: s (str): The input string. Returns: bool: True if the string contains every letter of the English alphabet, False otherwise. >>> contains_all_letters(\\"The quick brown fox jumps over the lazy dog.\\") True >>> contains_all_letters(\\"Hello, World!\\") False >>> contains_all_letters(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") True >>> contains_all_letters(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> contains_all_letters(\\"A quick movement of the enemy will jeopardize six gunboats\\") True >>> contains_all_letters(\\"1234567890 -=!@#%^&*()_+[]{}|;':,.<>/?\\") False","solution":"import string def contains_all_letters(s): Checks if a given string contains every letter of the English alphabet at least once. Args: s (str): The input string. Returns: bool: True if the string contains every letter of the English alphabet, False otherwise. alphabet = set(string.ascii_lowercase) return alphabet.issubset(set(s.lower()))"},{"question":"def merge_arrays(arr1, arr2): Merge second sorted array arr2 into the first sorted array arr1 in-place. The first array arr1 has enough length to hold all elements from both arr1 and arr2. The function returns nothing. Examples: arr1 = [1, 3, 5, 0, 0, 0] arr2 = [2, 4, 6] merge_arrays(arr1, arr2) Expected output: arr1 == [1, 2, 3, 4, 5, 6] arr1 = [1, 2, 6, 0, 0, 0] arr2 = [3, 4, 5] merge_arrays(arr1, arr2) Expected output: arr1 == [1, 2, 3, 4, 5, 6] arr1 = [1, 1, 1, 0, 0, 0] arr2 = [1, 1, 1] merge_arrays(arr1, arr2) Expected output: arr1 == [1, 1, 1, 1, 1, 1] arr1 = [2, 4, 6, 0, 0, 0] arr2 = [1, 3, 5] merge_arrays(arr1, arr2) Expected output: arr1 == [1, 2, 3, 4, 5, 6] arr1 = [1, 3, 0, 0] arr2 = [2, 4] merge_arrays(arr1, arr2) Expected output: arr1 == [1, 2, 3, 4]","solution":"def merge_arrays(arr1, arr2): Merge second sorted array arr2 into the first sorted array arr1 in-place. n = len(arr1) - len(arr2) # The original length of arr1 m = len(arr2) # Start merging from the end i = n - 1 # Index of last element in initial arr1 j = m - 1 # Index of last element in arr2 k = n + m - 1 # Index of last position in the merged array (i.e., arr1) # Merge in reverse order while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[k] = arr1[i] i -= 1 else: arr1[k] = arr2[j] j -= 1 k -= 1 # If there are remaining elements in arr2, copy them while j >= 0: arr1[k] = arr2[j] k -= 1 j -= 1"},{"question":"def shortest_path(N: int, M: int, edges: List[Tuple[int, int, int]], S: int, T: int) -> int: Find the shortest path from the source node S to the target node T in an undirected graph. >>> parse_input(\\"5 6n1 2 4n1 3 2n2 3 5n2 4 10n3 4 3n4 5 1n1 5\\") (5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (4, 5, 1)], 1, 5) >>> shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (4, 5, 1)], 1, 5) 6 >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 1)], 1, 4) -1 >>> shortest_path(1, 0, [], 1, 1) 0 >>> shortest_path(2, 1, [(1, 2, 10)], 1, 2) 10 >>> shortest_path(6, 9, [(1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (5, 6, 9), (4, 5, 6)], 1, 5) 20 def parse_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int, int]], int, int]: Parse the input string into variables.","solution":"import heapq def shortest_path(N, M, edges, S, T): # Create the adjacency list to represent the graph graph = [[] for _ in range(N + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue to hold (distance, node) pq = [(0, S)] # Distance array to keep track of minimum distance to each node distances = [float('inf')] * (N + 1) distances[S] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == T: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 # A function to quickly parse the input, this function is not normally required but useful for testing def parse_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:M+1]] S, T = map(int, lines[M+1].split()) return N, M, edges, S, T"},{"question":"def len_long_substr(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> len_long_substr(\\"abcabcbb\\") 3 >>> len_long_substr(\\"bbbbb\\") 1 >>> len_long_substr(\\"pwwkew\\") 3 >>> len_long_substr(\\"dvdf\\") 3","solution":"def len_long_substr(s: str) -> int: Returns the length of the longest substring without repeating characters. if not s: return 0 max_length = 0 start = 0 char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"from typing import List def min_moves(nums: List[int], target: int) -> int: Returns the minimum number of moves to make all elements in nums equal to target. Each move consists of incrementing or decrementing an element by 1. >>> min_moves([1, 2, 3], 2) 2 >>> min_moves([4, 7, 10], 6) 7","solution":"def min_moves(nums, target): Returns the minimum number of moves to make all elements in nums to target. moves = 0 for num in nums: moves += abs(num - target) return moves"},{"question":"from typing import List def product_array(nums: List[int]) -> List[int]: Returns an array such that each element at index i is the product of all the elements in the original array except the one at i. >>> product_array([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_array([-1, -2, -3, -4]) == [-24, -12, -8, -6] >>> product_array([1, -2, 3, -4]) == [24, -12, 8, -6] >>> product_array([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_array([0, 0, 1, 2]) == [0, 0, 0, 0] >>> product_array([5]) == [1] >>> product_array([]) == []","solution":"def product_array(nums): Returns an array such that each element at index i is the product of all the elements in the original array except the one at i. if not nums: return [] # Initialize the arrays length = len(nums) left_products = [1] * length right_products = [1] * length output = [1] * length # Fill left_products so that left_products[i] contains the product of all elements to the left of nums[i] for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products so that right_products[i] contains the product of all elements to the right of nums[i] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Fill the output array by multiplying left and right products for i in range(length): output[i] = left_products[i] * right_products[i] return output"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression consisting of non-negative integers, +, -, *, / operators while respecting the precedence order of operators. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"100-50/25\\") 98","solution":"def evaluateExpression(expression): Evaluate a mathematical expression consisting of non-negative integers, +, -, *, / operators while respecting the precedence order of operators. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a // b) # Operator precedence precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operators = [] operands = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] in precedence: while (operators and precedence[operators[-1]] >= precedence[expression[i]]): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def findEquilibriumIndex(arr: List[int]) -> int: Returns the equilibrium index of the array \`arr\` if it exists, otherwise returns -1. An equilibrium index is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. >>> findEquilibriumIndex([1, 3, 5, 2, 2]) 2 >>> findEquilibriumIndex([1, 2, 3, 4, 5]) -1 >>> findEquilibriumIndex([1]) 0 >>> findEquilibriumIndex([2, 3, -1, 8, 4, -1]) -1 >>> findEquilibriumIndex([-7, 1, 5, 2, -4, 3, 0]) 3 >>> findEquilibriumIndex([3, 2, 1, 2, 3]) 2","solution":"def findEquilibriumIndex(arr): Returns the equilibrium index of the array \`arr\` if it exists, otherwise returns -1. An equilibrium index is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): total_sum -= num # total_sum is now right_sum for index i if left_sum == total_sum: return i left_sum += num return -1"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary by concatenating keys based on their hierarchical position. Args: - d (dict): The dictionary to flatten. - parent_key (str): The base key to prepend to each key (used during recursion). - sep (str): The separator between concatenated keys. Returns: - dict: A flattened dictionary. >>> flatten_dict({'a': {'b': {'c': 1}, 'd': 2}, 'e': 3}) {'a.b.c': 1, 'a.d': 2, 'e': 3} >>> flatten_dict({'a': 1, 'b': 2}) {'a': 1, 'b': 2}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary by concatenating keys based on their hierarchical position. Args: - d (dict): The dictionary to flatten. - parent_key (str): The base key to prepend to each key (used during recursion). - sep (str): The separator between concatenated keys. Returns: - dict: A flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def identify_animal(animal: str) -> str: Given an animal name, this function returns the class to which the animal belongs along with a general description of that class. Examples: >>> identify_animal('lion') 'Mammal - Warm-blooded vertebrates that have hair or fur and whose females produce milk to feed their young.' >>> identify_animal('eagle') 'Bird - Warm-blooded vertebrates characterized by feathers and beaks, laying hard-shelled eggs.' animal_class = { 'lion': 'Mammal - Warm-blooded vertebrates that have hair or fur and whose females produce milk to feed their young.', 'eagle': 'Bird - Warm-blooded vertebrates characterized by feathers and beaks, laying hard-shelled eggs.', 'crocodile': 'Reptile - Cold-blooded vertebrates with scales or scutes that lay soft-shelled eggs on land.', 'frog': 'Amphibian - Cold-blooded vertebrates that spend their early life in water, and adulthood on land.', 'shark': 'Fish - Cold-blooded aquatic vertebrates that have gills throughout life and fins.', 'butterfly': 'Insect - A large group of arthropods, usually with wings and divided into three parts (head, thorax, abdomen).' } return animal_class.get(animal, \\"Unknown animal\\") from solution import identify_animal def test_identify_lion(): assert identify_animal('lion') == 'Mammal - Warm-blooded vertebrates that have hair or fur and whose females produce milk to feed their young.' def test_identify_eagle(): assert identify_animal('eagle') == 'Bird - Warm-blooded vertebrates characterized by feathers and beaks, laying hard-shelled eggs.' def test_identify_crocodile(): assert identify_animal('crocodile') == 'Reptile - Cold-blooded vertebrates with scales or scutes that lay soft-shelled eggs on land.' def test_identify_frog(): assert identify_animal('frog') == 'Amphibian - Cold-blooded vertebrates that spend their early life in water, and adulthood on land.' def test_identify_shark(): assert identify_animal('shark') == 'Fish - Cold-blooded aquatic vertebrates that have gills throughout life and fins.' def test_identify_butterfly(): assert identify_animal('butterfly') == 'Insect - A large group of arthropods, usually with wings and divided into three parts (head, thorax, abdomen).' def test_identify_unknown_animal(): assert identify_animal('dinosaur') == \\"Unknown animal\\"","solution":"def identify_animal(animal): Given an animal name, this function returns the class to which the animal belongs along with a general description of that class. animal_class = { 'lion': 'Mammal - Warm-blooded vertebrates that have hair or fur and whose females produce milk to feed their young.', 'eagle': 'Bird - Warm-blooded vertebrates characterized by feathers and beaks, laying hard-shelled eggs.', 'crocodile': 'Reptile - Cold-blooded vertebrates with scales or scutes that lay soft-shelled eggs on land.', 'frog': 'Amphibian - Cold-blooded vertebrates that spend their early life in water, and adulthood on land.', 'shark': 'Fish - Cold-blooded aquatic vertebrates that have gills throughout life and fins.', 'butterfly': 'Insect - A large group of arthropods, usually with wings and divided into three parts (head, thorax, abdomen).' } return animal_class.get(animal, \\"Unknown animal\\")"},{"question":"def suggest_words(dictionary: List[str], prefix: str) -> List[str]: Given a list of words (dictionary) and a prefix, returns a list of all words from the dictionary that start with the prefix, sorted in lexicographical order. >>> suggest_words([\\"apple\\", \\"application\\", \\"aptitude\\", \\"bat\\"], \\"app\\") ['apple', 'application'] >>> suggest_words([\\"delta\\", \\"lamp\\", \\"light\\"], \\"li\\") ['lamp', 'light'] >>> suggest_words([\\"mad\\", \\"mat\\"], \\"can\\") []","solution":"def suggest_words(dictionary, prefix): Given a list of words (dictionary) and a prefix, returns a list of all words from the dictionary that start with the prefix, sorted in lexicographical order. :param dictionary: List of strings representing the dictionary :param prefix: String representing the prefix :return: List of strings that start with the prefix, sorted in lexicographical order result = [word for word in dictionary if word.startswith(prefix)] return sorted(result) # Example usage: # dictionary = [\\"apple\\", \\"application\\", \\"aptitude\\", \\"bat\\"] # prefix = \\"app\\" # print(suggest_words(dictionary, prefix)) # Output: ['apple', 'application']"},{"question":"from typing import List def findTwoIndices(nums: List[int], target: int) -> List[int]: Given an array of integers and an integer target, find two distinct indices in the array such that the integers at those indices add up to the target value. >>> findTwoIndices([2, 7, 11, 15], 9) [0, 1] >>> findTwoIndices([3, 2, 4], 6) [1, 2] >>> findTwoIndices([3, 3], 6) [0, 1]","solution":"from typing import List def findTwoIndices(nums: List[int], target: int) -> List[int]: Given an array of integers and an integer target, find two distinct indices in the array such that the integers at those indices add up to the target value. # Create a dictionary to store the index of the numbers index_map = {} # Traverse through the list for i, num in enumerate(nums): # Calculate the complement that would sum up with the current number to reach the target complement = target - num # Check if the complement is already in the dictionary if complement in index_map: # If found, return the indices of the current number and its complement return [index_map[complement], i] # Otherwise, add the number and its index to the dictionary index_map[num] = i # In a very rare unexpected case return an empty list, although it's assumed there's always one solution return []"},{"question":"def knapsack(N: int, weights: List[int], values: List[int], W: int) -> int: Determine the maximum value for a given weight capacity of a knapsack. >>> knapsack(4, [2, 3, 1, 4], [4, 5, 3, 7], 5) 10 >>> knapsack(3, [1, 2, 3], [6, 10, 12], 5) 22","solution":"def knapsack(N, weights, values, W): # Initialize the DP table with zeros dp = [0] * (W + 1) # Iterate through all items for i in range(N): # Traverse the weights from W to the weight of the current item for j in range(W, weights[i] - 1, -1): # Update the DP table; choose the maximum value between not taking and taking the current item dp[j] = max(dp[j], dp[j - weights[i]] + values[i]) # The maximum value would be in dp[W] return dp[W]"},{"question":"def performOperations(a: int, b: int, operations: List[str]) -> Optional[float]: Perform a sequence of operations on two integers. >>> performOperations(10, 5, [\\"add\\"]) 15.0 >>> performOperations(10, 5, [\\"subtract\\"]) 5.0 >>> performOperations(10, 5, [\\"multiply\\"]) 50.0 >>> performOperations(10, 5, [\\"divide\\"]) 2.0 >>> performOperations(10, 5, [\\"add\\", \\"multiply\\", \\"subtract\\"]) 70.0 >>> performOperations(8, 2, [\\"divide\\", \\"add\\"]) 6.0 >>> performOperations(15, 0, [\\"divide\\"]) None >>> performOperations(6, 3, [\\"multiply\\", \\"foobar\\"]) None >>> performOperations(7, 5, []) 7.0","solution":"from typing import List, Optional def performOperations(a: int, b: int, operations: List[str]) -> Optional[float]: current_result = float(a) # Start with float conversion of 'a' for operation in operations: if operation == \\"add\\": current_result += b elif operation == \\"subtract\\": current_result -= b elif operation == \\"multiply\\": current_result *= b elif operation == \\"divide\\": if b == 0: return None current_result /= b else: return None # Invalid operation encountered return current_result"},{"question":"from typing import List from itertools import permutations def special_permutation_exists(words: List[str]) -> bool: Determines if there exists a permutation of words where every adjacent pair of words differs by exactly one character. >>> special_permutation_exists([\\"abc\\", \\"acc\\", \\"bcc\\"]) == True >>> special_permutation_exists([\\"abc\\", \\"def\\"]) == False >>> special_permutation_exists([\\"abc\\", \\"abe\\", \\"aec\\"]) == True >>> special_permutation_exists([\\"a\\", \\"b\\"]) == True # Unit tests def test_example_1(): words = [\\"abc\\", \\"acc\\", \\"bcc\\"] assert special_permutation_exists(words) == True def test_example_2(): words = [\\"abc\\", \\"def\\"] assert special_permutation_exists(words) == False def test_example_3(): words = [\\"abc\\", \\"abe\\", \\"aec\\"] assert special_permutation_exists(words) == True def test_example_4(): words = [\\"a\\", \\"b\\"] assert special_permutation_exists(words) == True def test_all_same_length_diff_3(): words = [\\"aaa\\", \\"aab\\", \\"abb\\", \\"bbb\\"] assert special_permutation_exists(words) == True def test_no_special_permutation(): words = [\\"aaa\\", \\"bbb\\", \\"ccc\\"] assert special_permutation_exists(words) == False def test_more_than_two_words(): words = [\\"abc\\", \\"abd\\", \\"acd\\", \\"bcd\\", \\"bce\\"] assert special_permutation_exists(words) == True","solution":"from itertools import permutations def differs_by_one_char(w1, w2): Helper function to determine if two words differ by exactly one character. if len(w1) != len(w2): return False count = 0 for c1, c2 in zip(w1, w2): if c1 != c2: count += 1 if count > 1: return False return count == 1 def special_permutation_exists(words): Determines if there exists a permutation of words where every adjacent pair of words differs by exactly one character. for perm in permutations(words): special = True for i in range(len(perm) - 1): if not differs_by_one_char(perm[i], perm[i + 1]): special = False break if special: return True return False"},{"question":"def max_infection_time(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the maximum amount of time it will take for the virus starting from node 1 to reach any possibly infected computer. >>> max_infection_time(4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) 2 >>> max_infection_time(3, 2, [(1, 2), (2, 3)]) 2 >>> max_infection_time(4, 2, [(2, 3), (3, 4)]) 0","solution":"from collections import defaultdict, deque def max_infection_time(n, m, edges): # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) # Initialize distances array distance = [-1] * (n + 1) distance[1] = 0 # Begin BFS from node 1 q = deque([1]) while q: current = q.popleft() for neighbor in adj_list[current]: if distance[neighbor] == -1: distance[neighbor] = distance[current] + 1 q.append(neighbor) # Find the maximum distance from node 1 to any node max_time = max(distance) return max_time if max_time != -1 else 0"},{"question":"def max_subarray_sum(sequence): Returns the maximum sum of any contiguous subarray in the given sequence. Uses Kadane's algorithm to find the maximum sum efficiently. Parameters: sequence (list of int): The sequence of integers. Returns: int: The maximum sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([3, -1, -1, -1, 3, 3, -10, 2, 2, 2, 2]) 8 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(sequence): Returns the maximum sum of any contiguous subarray in the given sequence. Uses Kadane's algorithm to find the maximum sum efficiently. Parameters: sequence (list of int): The sequence of integers. Returns: int: The maximum sum of any contiguous subarray. if not sequence: return 0 max_ending_here = max_so_far = sequence[0] for x in sequence[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalancedBST(root): Determines if a tree is both balanced and a valid binary search tree (BST). >>> isBalancedBST(TreeNode(2, TreeNode(1), TreeNode(3))) == True >>> isBalancedBST(TreeNode(1, TreeNode(2), TreeNode(3))) == False >>> isBalancedBST(TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(5, TreeNode(4), TreeNode(6)))) == True >>> isBalancedBST(TreeNode(3, TreeNode(2, TreeNode(1, TreeNode(0))), TreeNode(5, TreeNode(4)))) == False >>> isBalancedBST(TreeNode(1)) == True >>> isBalancedBST(None) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalancedBST(root): Determines if a tree is both balanced and a valid binary search tree (BST). def is_valid_bst_and_height(node, low=float('-inf'), high=float('inf')): if not node: return True, 0 if not (low < node.val < high): return False, 0 left_is_bst, left_height = is_valid_bst_and_height(node.left, low, node.val) right_is_bst, right_height = is_valid_bst_and_height(node.right, node.val, high) if not left_is_bst or not right_is_bst: return False, 0 if abs(left_height - right_height) > 1: return False, 0 return True, max(left_height, right_height) + 1 return is_valid_bst_and_height(root)[0]"},{"question":"def balanceParentheses(s: str) -> bool: Returns True if the string s is a balanced sequence of parentheses, False otherwise. >>> balanceParentheses(\\"()()\\") == True >>> balanceParentheses(\\"(())\\") == True >>> balanceParentheses(\\"(()\\") == False >>> balanceParentheses(\\")(\\") == False >>> balanceParentheses(\\"\\") == True >>> balanceParentheses(\\"((()))\\") == True >>> balanceParentheses(\\"((())\\") == False >>> balanceParentheses(\\"()()(())\\") == True >>> balanceParentheses(\\"()(()))\\") == False pass","solution":"def balanceParentheses(s): Returns true if the string s is a balanced sequence of parentheses, false otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def generate_ip_addresses(input_str: str) -> List[str]: Given a string containing only digits, generate all possible valid IP addresses that can be obtained by inserting dots into the string. An IP address consists of four numbers (each between 0 and 255) separated by dots, and each segment of the IP address must not have leading zeros. >>> generate_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> generate_ip_addresses(\\"\\") [] >>> generate_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> generate_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> generate_ip_addresses(\\"123\\") [] >>> generate_ip_addresses(\\"256256256256\\") [] >>> generate_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] >>> generate_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] pass","solution":"def generate_ip_addresses(input_str): def is_valid(segment): # Check if the segment is valid: not empty, less than or equal to 255, no leading zeros unless single digit '0' return segment.isdigit() and 0 <= int(segment) <= 255 and str(int(segment)) == segment result = [] n = len(input_str) # The maximum length for any portion in a valid IP address is 3 chars for i in range(1, min(4, n - 2)): for j in range(i + 1, min(i + 4, n - 1)): for k in range(j + 1, min(j + 4, n)): s1, s2, s3, s4 = input_str[:i], input_str[i:j], input_str[j:k], input_str[k:] if is_valid(s1) and is_valid(s2) and is_valid(s3) and is_valid(s4): result.append(f\\"{s1}.{s2}.{s3}.{s4}\\") return result"},{"question":"from typing import List def min_steps_to_make_palindrome(s: str) -> int: Returns the minimum number of steps required to make the string s a palindrome. Args: s (str): A string consisting of lowercase English letters. Returns: int: The minimum number of steps required to make the string a palindrome. Examples: >>> min_steps_to_make_palindrome(\\"abca\\") 1 >>> min_steps_to_make_palindrome(\\"a\\") 0 >>> min_steps_to_make_palindrome(\\"racecar\\") 0 >>> min_steps_to_make_palindrome(\\"abcde\\") 2 >>> min_steps_to_make_palindrome(\\"abcdefgh\\") 4","solution":"def min_steps_to_make_palindrome(s): Returns the minimum number of steps required to make the string s a palindrome. left, right = 0, len(s) - 1 steps = 0 while left < right: if s[left] != s[right]: steps += 1 left += 1 right -= 1 return steps"},{"question":"def find_first_unique(string: str) -> str: Returns the first non-repeating character in the string. If there is no such character, returns an empty string. >>> find_first_unique('swiss') == 'w' >>> find_first_unique('hello') == 'h' >>> find_first_unique('minimum') == 'n' >>> find_first_unique('aabbcc') == '' >>> find_first_unique('') == '' >>> find_first_unique('abc') == 'a' >>> find_first_unique('ab') == 'a' >>> find_first_unique('abcdabc') == 'd' >>> find_first_unique('abacabad') == 'c' >>> find_first_unique('aaabcccdde') == 'b'","solution":"def find_first_unique(string): Returns the first non-repeating character in a string. If there is no such character, returns an empty string. # Dictionary to store the count of each character char_count = {} # First pass: count the occurrences of each character for char in string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first character with count 1 for char in string: if char_count[char] == 1: return char # If no unique character found, return empty string return \\"\\""},{"question":"def all_unique_chars(s: str) -> bool: Determines if all characters in the string (ignoring spaces) are unique. This check is case-sensitive. >>> all_unique_chars(\\"Hello, World!\\") False >>> all_unique_chars(\\"Python!\\") True >>> all_unique_chars(\\"A quick brown fox.\\") False","solution":"def all_unique_chars(s): Determines if all characters in the string (ignoring spaces) are unique. This check is case-sensitive. s = s.replace(' ', '') # ignore spaces return len(s) == len(set(s))"},{"question":"def count_substring_occurrences(main_string: str, substring: str) -> int: Returns the number of times the substring occurs in the main string. >>> count_substring_occurrences(\\"hello world\\", \\"world\\") == 1 >>> count_substring_occurrences(\\"hello hello world\\", \\"hello\\") == 2 >>> count_substring_occurrences(\\"aaaaaa\\", \\"aa\\") == 3 >>> count_substring_occurrences(\\"mississippi\\", \\"iss\\") == 2 >>> count_substring_occurrences(\\"mississippi\\", \\"is\\") == 2 >>> count_substring_occurrences(\\"banana\\", \\"na\\") == 2 >>> count_substring_occurrences(\\"abcdef\\", \\"gh\\") == 0 >>> count_substring_occurrences(\\"aaaaa\\", \\"aa\\") == 2","solution":"def count_substring_occurrences(main_string, substring): Returns the number of times the substring occurs in the main string. Parameters: main_string (str): The main string to search within. substring (str): The substring to search for. Returns: int: The number of times the substring occurs in the main string. count = 0 start = 0 while True: start = main_string.find(substring, start) if start == -1: break count += 1 start += len(substring) return count"},{"question":"[Completion Task in Python] def length_of_longest_subarray(arr: List[int]) -> int: Create a function that takes an array of integers as input and returns the length of the longest contiguous subarray that contains no duplicate numbers. The array may contain both positive and negative numbers. >>> length_of_longest_subarray([1, 2, 3, 1, 2, 3]) 3 >>> length_of_longest_subarray([1, 2, 3, 4, 5]) 5 >>> length_of_longest_subarray([1, 2, 2, 3, 4, 5]) 4 >>> length_of_longest_subarray([]) 0 >>> length_of_longest_subarray([1, 1, 1, 1, 1]) 1 >>> length_of_longest_subarray([1]) 1 >>> length_of_longest_subarray([-1, 2, -2, 2, -1, -2]) 3 >>> length_of_longest_subarray([1, -1, 2, -2, 3, -3, 4, -4]) 8 >>> length_of_longest_subarray([1, 2, 3, 4, 1]) 4 >>> length_of_longest_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9","solution":"def length_of_longest_subarray(arr): Returns the length of the longest contiguous subarray with unique elements. if not arr: return 0 max_length = 0 current_start = 0 seen = {} for current_end, value in enumerate(arr): if value in seen and seen[value] >= current_start: current_start = seen[value] + 1 seen[value] = current_end max_length = max(max_length, current_end - current_start + 1) return max_length"},{"question":"def will_cross_path(commands): Determine whether a given sequence of commands will cause the robot to cross its own path. >>> will_cross_path('URURD') == \\"NO\\" >>> will_cross_path('URLLDR') == \\"YES\\" >>> will_cross_path('UDLR') == \\"YES\\" >>> will_cross_path('RRDDLLUU') == \\"YES\\" >>> will_cross_path('R') == \\"NO\\" >>> will_cross_path('R' * 10000) == \\"NO\\" >>> will_cross_path('U' * 10000) == \\"NO\\" >>> will_cross_path('R' * 2500 + 'U' * 2500 + 'L' * 2500 + 'D' * 2500) == \\"YES\\" # Implementation Here pass def robot_cross_path_solver(T, command_list): Process multiple test cases to determine if the robot crosses its path for each. >>> T = 2 >>> command_list = ['URURD', 'URLLDR'] >>> robot_cross_path_solver(T, command_list) == [\\"NO\\", \\"YES\\"] >>> T = 3 >>> command_list = ['R' * 10000, 'U' * 10000, 'R' * 2500 + 'U' * 2500 + 'L' * 2500 + 'D' * 2500] >>> robot_cross_path_solver(T, command_list) == [\\"NO\\", \\"NO\\", \\"YES\\"] # Implementation Here pass","solution":"def will_cross_path(commands): Determine whether a given sequence of commands will cause the robot to cross its own path. position = (0, 0) visited = {position} for command in commands: if command == 'U': position = (position[0], position[1] + 1) elif command == 'D': position = (position[0], position[1] - 1) elif command == 'L': position = (position[0] - 1, position[1]) elif command == 'R': position = (position[0] + 1, position[1]) if position in visited: return \\"YES\\" visited.add(position) return \\"NO\\" def robot_cross_path_solver(T, command_list): results = [] for commands in command_list: results.append(will_cross_path(commands)) return results"},{"question":"def maxFlips(binary_string: str) -> int: Returns the maximum number of coin flips to make all consecutive coin faces either heads (0) or tails (1). >>> maxFlips(\\"0001100\\") == 2 >>> maxFlips(\\"00110011\\") == 3 >>> maxFlips(\\"00000\\") == 0 >>> maxFlips(\\"11111\\") == 0 >>> maxFlips(\\"01\\") == 1 >>> maxFlips(\\"10\\") == 1 >>> maxFlips(\\"0101010101\\") == 9 >>> maxFlips(\\"1010101010\\") == 9 >>> maxFlips(\\"\\") == 0 :param binary_string: A string consisting of '0' and '1'. :return: Maximum number of flips needed.","solution":"def maxFlips(binary_string: str) -> int: Returns the maximum number of coin flips to make all consecutive coin faces either heads (0) or tails (1). :param binary_string: A string consisting of '0' and '1'. :return: Maximum number of flips needed. if not binary_string: return 0 # Count the number of transitions from '0' to '1' and '1' to '0' flips = 0 for i in range(1, len(binary_string)): if binary_string[i] != binary_string[i - 1]: flips += 1 return flips"},{"question":"def add_minutes(time: str, minutes: int) -> str: Adds the specified number of minutes to the given time in \\"HH:MM\\" format. >>> add_minutes(\\"14:30\\", 45) \\"15:15\\" >>> add_minutes(\\"23:30\\", 90) \\"01:00\\" >>> add_minutes(\\"23:59\\", 1) \\"00:00\\" >>> add_minutes(\\"00:45\\", 75) \\"02:00\\" >>> add_minutes(\\"10:15\\", 45) \\"11:00\\" >>> add_minutes(\\"10:00\\", 1440) \\"10:00\\" >>> add_minutes(\\"12:34\\", 0) \\"12:34\\"","solution":"def add_minutes(time, minutes): Adds the specified number of minutes to the given time in \\"HH:MM\\" format. Parameters: time (str): A string representing the time in \\"HH:MM\\" format. minutes (int): Number of minutes to add to the given time. Returns: str: The new time in \\"HH:MM\\" format after adding the given number of minutes. # Split the input time into hours and minutes hours, mins = map(int, time.split(':')) # Calculate the total number of minutes total_minutes = hours * 60 + mins + minutes # Compute the new hours and minutes new_hours = (total_minutes // 60) % 24 new_minutes = total_minutes % 60 # Format the result as \\"HH:MM\\" return f\\"{new_hours:02}:{new_minutes:02}\\""},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) == True >>> can_partition([1, 2, 3, 5]) == False","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, it's not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target_sum]"},{"question":"def operationizer(N: int, K: int, arr: List[int]) -> List[int]: Perform K operations on the array where each operation involves a cyclic shift and element-wise multiplication. >>> operationizer(3, 0, [3, 1, 4]) [3, 1, 4] >>> operationizer(3, 1, [3, 1, 4]) [12, 3, 4] >>> operationizer(3, 2, [3, 1, 4]) [48, 36, 12] >>> operationizer(1, 1, [9]) [81] >>> operationizer(2, 1, [-1000000000, 1000000000]) [-1000000000000000000, -1000000000000000000] >>> operationizer(3, 99999, [1, 1, 1]) [1, 1, 1]","solution":"def operationizer(N, K, arr): if K == 0: return arr for _ in range(K): shifted_arr = arr[-1:] + arr[:-1] arr = [arr[i] * shifted_arr[i] for i in range(N)] return arr"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the largest sum of a contiguous subarray within a given array. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4, -10]) 10","solution":"def max_subarray_sum(nums): Finds the largest sum of a contiguous subarray within a given array. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral representation. Args: num (int): The integer to be converted. Must be between 1 and 3999. Returns: str: The Roman numeral representation of the integer. >>> int_to_roman(1) == \\"I\\" >>> int_to_roman(4) == \\"IV\\" >>> int_to_roman(58) == \\"LVIII\\" >>> int_to_roman(1994) == \\"MCMXCIV\\"","solution":"def int_to_roman(num): Converts an integer to a Roman numeral representation. Args: num (int): The integer to be converted. Must be between 1 and 3999. Returns: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def toCamelCase(s: str) -> str: Convert a string to camelCase. Parameters: s (str): The input string containing words separated by hyphens or underscores. Returns: str: The converted string in camelCase. # Your implementation here def test_toCamelCase_hyphenated_words(): assert toCamelCase(\\"the-stealth-warrior\\") == \\"theStealthWarrior\\" def test_toCamelCase_underscored_words(): assert toCamelCase(\\"The_Stealth_Warrior\\") == \\"theStealthWarrior\\" def test_toCamelCase_mixed_case(): assert toCamelCase(\\"A-B-C\\") == \\"aBC\\" def test_toCamelCase_empty_string(): assert toCamelCase(\\"\\") == \\"\\" def test_toCamelCase_single_word(): assert toCamelCase(\\"word\\") == \\"word\\" def test_toCamelCase_mixed_separators(): assert toCamelCase(\\"the_stealth-warrior\\") == \\"theStealthWarrior\\"","solution":"def toCamelCase(s): Convert a string to camelCase. Parameters: s (str): The input string containing words separated by hyphens or underscores. Returns: str: The converted string in camelCase. if not s: return \\"\\" # Split the string into parts based on hyphens and underscores parts = s.replace('_', '-').split('-') # Capitalize the first letter of each part except the first one camel_case = parts[0].lower() for part in parts[1:]: camel_case += part.capitalize() return camel_case"},{"question":"def increasing_triplet(nums: list) -> bool: Determines if there exists a subsequence of at least three increasing numbers. >>> increasing_triplet([1, 2, 3, 4, 5]) True >>> increasing_triplet([5, 4, 3, 2, 1]) False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) True >>> increasing_triplet([2, 1, 5, 0, 3]) False >>> increasing_triplet([1, 2, 2, 7, 3]) True >>> increasing_triplet([1, 2, -1, -1, 3]) True >>> increasing_triplet([]) False >>> increasing_triplet([1, 2]) False >>> increasing_triplet([10, 11, 12]) True","solution":"def increasing_triplet(nums): Determines if there exists a subsequence of at least three increasing numbers. :param nums: List of integers :return: Boolean value first = second = float('inf') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def minStepsToRemovePalindromes(arr: List[int]) -> int: Returns the minimum number of steps required to remove all elements from the list by removing arbitrary subsequences of the list that forms a palindrome. pass # Unit tests def test_empty_list(): assert minStepsToRemovePalindromes([]) == 0 def test_single_element(): assert minStepsToRemovePalindromes([1]) == 1 def test_palinodrome_list(): assert minStepsToRemovePalindromes([1, 2, 3, 2, 1]) == 1 def test_non_palindromic_list(): assert minStepsToRemovePalindromes([1, 2, 3, 4, 5]) == 2 def test_mixed_elements(): assert minStepsToRemovePalindromes([1, 3, 4, 3, 1, 2, 2, 4]) == 2","solution":"def minStepsToRemovePalindromes(arr): Returns the minimum number of steps required to remove all elements from the list by removing arbitrary subsequences of the list that forms a palindrome. if not arr: return 0 n = len(arr) if arr == arr[::-1]: return 1 return 2"},{"question":"def least_frequent_char(s: str) -> str: Returns the character that appears the least number of times in the string \`s\`. If there are multiple characters with the same minimum frequency, returns the one that appears first in the string. If the string is empty, returns an empty string. >>> least_frequent_char('minimum') == 'm' True >>> least_frequent_char('alphabet') == 'l' True >>> least_frequent_char('aaabbccddde') == 'e' True >>> least_frequent_char('') == '' True","solution":"def least_frequent_char(s): Returns the character that appears the least number of times in the string \`s\`. If there are multiple characters with the same minimum frequency, returns the one that appears first in the string. If the string is empty, returns an empty string. if not s: return '' # Dictionary to store frequency of each character frequency = {} # Calculate frequencies for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the minimum frequency min_freq = min(frequency.values()) # Find the first character with the minimum frequency for char in s: if frequency[char] == min_freq: return char"},{"question":"def sort_letters_and_digits(s: str) -> str: Takes a string consisting of lowercase letters and digits and returns the same string with the letters and digits sorted separately but retains their original positions. >>> sort_letters_and_digits(\\"a1c3b2\\") 'a1b2c3' >>> sort_letters_and_digits(\\"b3c1a2\\") 'a1b2c3' >>> sort_letters_and_digits(\\"abc\\") 'abc' >>> sort_letters_and_digits(\\"cba\\") 'abc' >>> sort_letters_and_digits(\\"123\\") '123' >>> sort_letters_and_digits(\\"321\\") '123' >>> sort_letters_and_digits(\\"\\") '' >>> sort_letters_and_digits(\\"a0b1c2\\") 'a0b1c2' >>> sort_letters_and_digits(\\"z9a8b7y6\\") 'a6b7y8z9' >>> sort_letters_and_digits(\\"@#!\\") '@#!' >>> sort_letters_and_digits(\\"a2b2a1\\") 'a1a2b2'","solution":"def sort_letters_and_digits(s): Takes a string consisting of lowercase letters and digits and returns the same string with the letters and digits sorted separately but retains their original positions. letters = sorted([c for c in s if c.isalpha()]) digits = sorted([c for c in s if c.isdigit()]) letter_index = 0 digit_index = 0 result = [] for c in s: if c.isalpha(): result.append(letters[letter_index]) letter_index += 1 elif c.isdigit(): result.append(digits[digit_index]) digit_index += 1 else: result.append(c) return ''.join(result)"},{"question":"def longest_even_subarray_length(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest contiguous subarray of even integers for each test case. >>> longest_even_subarray_length(3, [(6, [1, 2, 4, 6, 1, 8]), (5, [2, 2, 2, 2, 2]), (4, [1, 3, 5, 7])]) [3, 5, 0] >>> longest_even_subarray_length(2, [(4, [2, 4, 6, 8]), (6, [1, 3, 5, 7, 8, 10])]) [4, 2] :param T: The number of test cases :param test_cases: A list containing tuples, each with the number of integers N and the list of integers :return: A list of integers representing the length of the longest contiguous subarray of even integers for each test case","solution":"def longest_even_subarray_length(T, test_cases): results = [] for case in test_cases: N, arr = case max_length = current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 results.append(max_length) return results"},{"question":"def custom_mean(lst: List[int]) -> Dict[str, float]: Implement a function custom_mean that takes a list of integers as input and returns a dictionary with two keys: 'mean' and 'percentage_gt_mean'. The value for the 'mean' key should be the arithmetic mean (average) of the list. The value for the 'percentage_gt_mean' key should be the percentage of integers in the list that are strictly greater than the mean, rounded to two decimal places. Do not use built-in functions like sum or statistics.mean. >>> custom_mean([1, 2, 3, 4, 5]) {'mean': 3.0, 'percentage_gt_mean': 40.0} >>> custom_mean([10]) {'mean': 10.0, 'percentage_gt_mean': 0.0} >>> custom_mean([5, 5, 5, 5]) {'mean': 5.0, 'percentage_gt_mean': 0.0} >>> custom_mean([-3, -2, -1, 0, 1, 2, 3]) {'mean': 0.0, 'percentage_gt_mean': 42.86} >>> custom_mean([-10, 0, 10, 20]) {'mean': 5.0, 'percentage_gt_mean': 50.0} >>> custom_mean([1000000, 1000001, 999999]) {'mean': 1000000.0, 'percentage_gt_mean': 33.33}","solution":"def custom_mean(lst): Returns a dictionary with the mean of the list and the percentage of numbers greater than the mean. n = len(lst) # Calculate mean manually total = 0 for num in lst: total += num mean = total / n # Calculate percentage greater than mean count_gt_mean = 0 for num in lst: if num > mean: count_gt_mean += 1 percentage_gt_mean = (count_gt_mean / n) * 100 return { 'mean': mean, 'percentage_gt_mean': round(percentage_gt_mean, 2) }"},{"question":"def decode_message(message: str, shift: int) -> str: Decodes the given encoded message using the provided shift value. Args: message (str): The encoded message. shift (int): The number of positions each alphabetic character in the string is shifted. Returns: str: The decoded message. Examples: >>> decode_message(\\"Khoor, Zruog!\\", 3) \\"Hello, World!\\" >>> decode_message(\\"Fdhvdu, Flskhu!\\", 3) \\"Caesar, Cipher!\\" >>> decode_message(\\"Mjqqt, Btwqi!\\", 5) \\"Hello, World!\\" pass","solution":"def decode_message(message, shift): Decodes the given encoded message using the provided shift value. Args: message (str): The encoded message. shift (int): The number of positions each alphabetic character in the string is shifted. Returns: str: The decoded message. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') - shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') - shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in message)"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in a string. If all characters repeat, return '_'. >>> first_non_repeating_character(\\"swiss\\") 'w' >>> first_non_repeating_character(\\"alphabet\\") 'l' >>> first_non_repeating_character(\\"aabbcc\\") '_' # Your code here","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in a string. If all characters repeat, return '_'. Parameters: s (str): The string to check for non-repeating characters. Returns: char (str): The first non-repeating character or '_'. character_count = {} # Count the occurrences of each character. for char in s: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 # Find the first character with a single occurrence. for char in s: if character_count[char] == 1: return char return '_'"},{"question":"def isPerfectNumber(n: int) -> bool: Determine if a given integer n is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors. >>> isPerfectNumber(28) True >>> isPerfectNumber(12) False","solution":"def isPerfectNumber(n: int) -> bool: Determine if a given integer n is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors. if n <= 1: return False proper_divisors_sum = 0 for i in range(1, n): if n % i == 0: proper_divisors_sum += i return proper_divisors_sum == n"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. >>> longest_substring_with_k_distinct(\\"abcba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aabbcc\\", 1) 2 def solve(test_cases: List[Tuple[str, int]]) -> List[int]: Solves multiple test cases for the longest substring with at most k distinct characters. Args: test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string and an integer k. Returns: List[int]: A list of results corresponding to the test cases. >>> solve([(\\"abcba\\", 2), (\\"aabbcc\\", 1)]) [3, 2]","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 char_count = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len def solve(test_cases): results = [] for s, k in test_cases: results.append(longest_substring_with_k_distinct(s, k)) return results"},{"question":"def minimize_max_subarray_sum(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, partition the array into \`k\` non-empty contiguous subarrays such that the sum of the maximum values of these subarrays is minimized. Return the minimized maximum subarray sum. Examples: >>> minimize_max_subarray_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_subarray_sum([1, 2, 3, 4, 5], 2) 9","solution":"def minimize_max_subarray_sum(arr, k): def can_partition(max_max_sum): current_sum = 0 subarrays = 1 for num in arr: if current_sum + num > max_max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"def find_champion_skill(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the skill level of the champion robot. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case contains the number of robots and their skill levels. Returns: List[int]: Skill levels of the champion robots for each test case. Examples: >>> find_champion_skill(1, [(4, [1, 3, 4, 2])]) [4] >>> find_champion_skill(2, [(4, [1, 3, 4, 2]), (8, [5, 3, 8, 6, 1, 2, 7, 4])]) [4, 8]","solution":"def find_champion_skill(T, test_cases): def compete(skills): while len(skills) > 1: next_round = [] for i in range(len(skills) // 2): next_round.append(max(skills[i], skills[-(i+1)])) skills = next_round return skills[0] results = [] for i in range(T): N = test_cases[i][0] skills = test_cases[i][1] results.append(compete(skills)) return results"},{"question":"def shortest_substring(s: str, t: str) -> str: Write a function named \`shortest_substring\` that takes a string \`s\` and a string \`t\` as arguments, and returns the shortest contiguous substring of \`s\` that contains all the characters in \`t\` (including duplicates). If there is no such substring, return an empty string. >>> shortest_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> shortest_substring(\\"this is a test string\\", \\"tist\\") \\"t stri\\" >>> shortest_substring(\\"hello\\", \\"world\\") \\"\\" >>> shortest_substring(\\"some string\\", \\"\\") \\"\\" >>> shortest_substring(\\"\\", \\"abc\\") \\"\\" >>> shortest_substring(\\"abcdef\\", \\"xyz\\") \\"\\" >>> shortest_substring(\\"aaflslflsldkalskaaa\\", \\"aaa\\") \\"aaa\\" >>> shortest_substring(\\"abcabdebac\\", \\"cda\\") \\"cabd\\" >>> shortest_substring(\\"aa\\", \\"aa\\") \\"aa\\" >>> shortest_substring(\\"a\\", \\"a\\") \\"a\\" >>> shortest_substring(\\"a\\", \\"b\\") \\"\\"","solution":"def shortest_substring(s, t): from collections import Counter if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None # (window length, left, right) while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def is_anagram(str1=None, str2=None): Determine if two given strings are anagrams of each other. Ignores case and spaces in comparison. Returns False for non-string inputs or if any input parameter is omitted. Examples: >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"listen\\", \\"silence\\") False >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True","solution":"def is_anagram(str1=None, str2=None): Determine if two given strings are anagrams of each other. Ignores case and spaces in comparison. Returns False for non-string inputs or if any input parameter is omitted. # Check for valid string inputs if not isinstance(str1, str) or not isinstance(str2, str): return False # Remove spaces and convert to lower case clean_str1 = ''.join(str1.split()).lower() clean_str2 = ''.join(str2.split()).lower() # Sort and compare the cleaned strings return sorted(clean_str1) == sorted(clean_str2)"},{"question":"def canAccessContent(user_groups, content_groups): Determines if a user can access a particular piece of content based on their group memberships. Parameters: user_groups (list): A list of strings representing the groups the user is a member of. content_groups (list): A list of strings representing the groups a piece of content is shared with. Returns: bool: True if the user can access the content, and False otherwise. >>> canAccessContent([\\"groupA\\", \\"groupB\\", \\"groupC\\"], [\\"groupX\\", \\"groupY\\", \\"groupA\\"]) True >>> canAccessContent([\\"groupM\\", \\"groupN\\"], [\\"groupX\\", \\"groupY\\", \\"groupZ\\"]) False >>> canAccessContent([\\"groupA\\"], [\\"groupA\\", \\"groupB\\", \\"groupC\\"]) True >>> canAccessContent([\\"groupA\\", \\"groupB\\", \\"groupC\\"], [\\"groupA\\"]) True >>> canAccessContent([\\"groupA\\", \\"groupB\\", \\"groupC\\"], [\\"groupX\\", \\"groupY\\", \\"groupZ\\"]) False >>> canAccessContent([], [\\"groupX\\", \\"groupY\\", \\"groupZ\\"]) False >>> canAccessContent([\\"groupA\\", \\"groupB\\", \\"groupC\\"], []) False >>> canAccessContent([], []) False","solution":"def canAccessContent(user_groups, content_groups): Determines if a user can access a particular piece of content based on their group memberships. Parameters: user_groups (list): A list of strings representing the groups the user is a member of. content_groups (list): A list of strings representing the groups a piece of content is shared with. Returns: bool: True if the user can access the content, and False otherwise. # Use set intersection to find common groups return bool(set(user_groups) & set(content_groups))"},{"question":"def find_triplets(arr, n): Write a function find_triplets that takes in an array arr of n integers and returns a list of all unique triplets [a, b, c] in arr such that the sum of the triplet is zero. Each triplet must be sorted in ascending order, and the list of triplets should be sorted lexicographically. >>> find_triplets([-1, 0, 1, 2, -1, -4], 6) == [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([1, 2, 3, 4, 5], 5) == [] >>> find_triplets([-1, -2, -3, -4, -5], 5) == [] >>> find_triplets([0, -1, 2, -3, 1], 5) == [[-3, 1, 2], [-1, 0, 1]] >>> find_triplets([0, 0, 0, 0], 4) == [[0, 0, 0]] >>> find_triplets([10**6, -10**6, 0, 1, 2, -1, -2], 7) == [[-1000000, 0, 1000000], [-2, 0, 2], [-1, 0, 1]] >>> find_triplets([0, 0, 0, 1, -1], 5) == [[-1, 0, 1], [0, 0, 0]]","solution":"def find_triplets(arr, n): arr.sort() triplets = set() for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return [list(triplet) for triplet in sorted(triplets)] # Example usage: # arr = [-1, 0, 1, 2, -1, -4] # n = len(arr) # print(find_triplets(arr, n)) # Output should be [[-1, -1, 2], [-1, 0, 1]]"},{"question":"def are_anagrams(word1: str, word2: str) -> bool: Check if two given words are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"state\\", \\"taste\\") True","solution":"def are_anagrams(word1: str, word2: str) -> bool: Returns True if word1 and word2 are anagrams, otherwise False. return sorted(word1) == sorted(word2)"},{"question":"from typing import List, Tuple def maximizeAestheticScore(n: int, scores: List[int], constraints: List[Tuple[int, int]]) -> int: Given the number of books, their respective aesthetic scores, and a list of constraints specifying which books must be adjacent to each other, determine the maximum possible sum of aesthetic scores by arranging the books in an optimal manner. >>> maximizeAestheticScore(3, [10, 20, 30], [(0, 1), (1, 2)]) # 60 >>> maximizeAestheticScore(4, [1, 2, 3, 4], [(0, 1), (2, 3)]) # 10 >>> maximizeAestheticScore(5, [5, 6, 7, 8, 9], [(0, 1), (1, 2), (2, 3), (3, 4)]) # 35 >>> maximizeAestheticScore(3, [8, 15, 3], []) # 26 >>> maximizeAestheticScore(7, [1, 2, 3, 4, 5, 6, 7], [(0, 1), (1, 2), (2, 3), (4, 5), (5, 6)]) # 28 >>> maximizeAestheticScore(2, [100, 200], [(1, 0)]) # 300","solution":"def maximizeAestheticScore(n, scores, constraints): from collections import defaultdict, deque # Create a graph to represent adjacency constraints graph = defaultdict(list) for a, b in constraints: graph[a].append(b) graph[b].append(a) # A helper function to compute the total score of connected components def get_connected_component_score(node, visited): queue = deque([node]) visited[node] = True total_score = 0 while queue: current = queue.popleft() total_score += scores[current] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return total_score visited = [False] * n max_score = 0 # Iterate through each node to calculate the total score of each connected component for i in range(n): if not visited[i]: component_score = get_connected_component_score(i, visited) max_score += component_score return max_score"},{"question":"def findWordsWithNVowels(words: List[str], n: int) -> List[str]: Returns a list of words that contain exactly n vowels. >>> findWordsWithNVowels([\\"example\\", \\"testing\\", \\"hello\\", \\"world\\", \\"python\\"], 2) [\\"testing\\", \\"hello\\"] >>> findWordsWithNVowels([\\"example\\", \\"testing\\", \\"hello\\", \\"world\\", \\"python\\"], 1) [\\"world\\", \\"python\\"] >>> findWordsWithNVowels([\\"example\\", \\"testing\\", \\"hello\\", \\"world\\", \\"python\\"], 3) [\\"example\\"] >>> findWordsWithNVowels([\\"brr\\", \\"gym\\", \\"rhythms\\", \\"sky\\"], 0) [\\"brr\\", \\"gym\\", \\"rhythms\\", \\"sky\\"] >>> findWordsWithNVowels([\\"example\\", \\"testing\\", \\"hello\\", \\"world\\", \\"python\\"], 0) [] >>> findWordsWithNVowels([\\"aeiou\\", \\"example\\", \\"queue\\"], 5) [\\"aeiou\\"] >>> findWordsWithNVowels([\\"Example\\", \\"TestIng\\", \\"HeLLo\\", \\"WoRLd\\", \\"PYTHon\\"], 2) [\\"TestIng\\", \\"HeLLo\\"]","solution":"def findWordsWithNVowels(words, n): Returns a list of words that contain exactly n vowels. vowels = 'aeiouAEIOU' def count_vowels(word): Returns the number of vowels in the given word. return sum(1 for char in word if char in vowels) return [word for word in words if count_vowels(word) == n]"},{"question":"def decodeString(s: str) -> str: Decodes the given encoded string based on the pattern k[encoded_string]. >>> decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\"","solution":"def decodeString(s): Decodes the given encoded string based on the pattern k[encoded_string]. stack = [] current_num = 0 current_str = '' for ch in s: if ch.isdigit(): current_num = current_num * 10 + int(ch) elif ch == '[': stack.append((current_str, current_num)) current_str = '' current_num = 0 elif ch == ']': prev_str, number = stack.pop() current_str = prev_str + current_str * number else: current_str += ch return current_str"},{"question":"def rotate(matrix): Rotates the given NxN matrix by 90 degrees clockwise. The rotation is done in place. :param List[List[int]] matrix: the NxN matrix to rotate. :return: None Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(matrix) >>> matrix [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] Constraints: - The matrix will always be square (N x N). - The elements of the matrix are integers between -1000 and 1000. - In-place rotation is required.","solution":"def rotate(matrix): Rotates the given NxN matrix by 90 degrees clockwise. The rotation is done in place. :param List[List[int]] matrix: the NxN matrix to rotate. :return: None n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def netProfitLoss(transactions): This function calculates the net profit or loss from a list of transactions. :param transactions: List of transactions where each transaction is a list [purchase_price, sell_price] :return: Net profit (positive) or loss (negative) rounded to two decimal places Examples: >>> netProfitLoss([[100, 150], [200, 180], [50, 75]]) 55.0 >>> netProfitLoss([[120, 100], [85, 85], [50, 45]]) -25.0","solution":"def netProfitLoss(transactions): This function calculates the net profit or loss from a list of transactions. :param transactions: List of transactions where each transaction is a list [purchase_price, sell_price] :return: Net profit (positive) or loss (negative) rounded to two decimal places net_profit_loss = 0.0 for transaction in transactions: purchase_price, sell_price = transaction net_profit_loss += (sell_price - purchase_price) return round(net_profit_loss, 2)"},{"question":"def calculate_exercise_totals(users_data, query): Calculate the total duration and total calories burned for a particular type of exercise across all users. users_data: List of dictionaries where each dictionary represents a user and contains their exercise sessions. Each session is represented as a dictionary with keys 'type', 'duration', and 'calories'. query: String representing the type of exercise to calculate totals for. Returns: Tuple containing total duration (int) and total calories burned (int) for the queried type of exercise. Example usage: >>> users_data = [ {\\"sessions\\": [{\\"type\\": \\"walking\\", \\"duration\\": 30, \\"calories\\": 150}]} ] query = \\"walking\\" calculate_exercise_totals(users_data, query) (30, 150) >>> users_data = [ {\\"sessions\\": [{\\"type\\": \\"running\\", \\"duration\\": 30, \\"calories\\": 300}, {\\"type\\": \\"walking\\", \\"duration\\": 20, \\"calories\\": 110}]}, {\\"sessions\\": [{\\"type\\": \\"running\\", \\"duration\\": 40, \\"calories\\": 400}, {\\"type\\": \\"cycling\\", \\"duration\\": 60, \\"calories\\": 500}, {\\"type\\": \\"walking\\", \\"duration\\": 15, \\"calories\\": 90}]}, {\\"sessions\\": [{\\"type\\": \\"walking\\", \\"duration\\": 30, \\"calories\\": 130}]} ] query = \\"walking\\" calculate_exercise_totals(users_data, query) (65, 330) >>> users_data = [ {\\"sessions\\": [{\\"type\\": \\"running\\", \\"duration\\": 30, \\"calories\\": 300}, {\\"type\\": \\"cycling\\", \\"duration\\": 20, \\"calories\\": 250}]} ] query = \\"walking\\" calculate_exercise_totals(users_data, query) (0, 0) >>> users_data = [ {\\"sessions\\": [{\\"type\\": \\"running\\", \\"duration\\": 30, \\"calories\\": 300}, {\\"type\\": \\"walking\\", \\"duration\\": 20, \\"calories\\": 110}]}, {\\"sessions\\": [{\\"type\\": \\"walking\\", \\"duration\\": 40, \\"calories\\": 400}, {\\"type\\": \\"cycling\\", \\"duration\\": 60, \\"calories\\": 500}, {\\"type\\": \\"walking\\", \\"duration\\": 15, \\"calories\\": 90}]}, {\\"sessions\\": [{\\"type\\": \\"walking\\", \\"duration\\": 30, \\"calories\\": 130}, {\\"type\\": \\"running\\", \\"duration\\": 45, \\"calories\\": 450}]} ] query = \\"running\\" calculate_exercise_totals(users_data, query) (75, 750)","solution":"def calculate_exercise_totals(users_data, query): total_duration = 0 total_calories = 0 for user in users_data: for session in user[\\"sessions\\"]: if session[\\"type\\"] == query: total_duration += session[\\"duration\\"] total_calories += session[\\"calories\\"] return total_duration, total_calories"},{"question":"def exists_uniform_subgrid(grid: List[str], K: int, d: int) -> str: Check if there exists a K*K subgrid that contains only the digit d. >>> exists_uniform_subgrid([ \\"1234\\", \\"5678\\", \\"1234\\", \\"5678\\" ], 2, 5) \\"no\\" >>> exists_uniform_subgrid([ \\"1234\\", \\"5678\\", \\"1234\\", \\"5678\\" ], 3, 1) \\"no\\" pass def answer_queries(N: int, M: int, Q: int, grid: List[str], queries: List[Tuple[int, int]]) -> List[str]: Given the grid dimensions and queries, return results for each query. >>> N, M, Q = 4, 4, 2 >>> grid = [ \\"1234\\", \\"5678\\", \\"1234\\", \\"5678\\" ] >>> queries = [(2, 5), (3, 1)] >>> answer_queries(N, M, Q, grid, queries) [\\"no\\", \\"no\\"] >>> grid = [ \\"5555\\", \\"5555\\", \\"5555\\", \\"5555\\" ] >>> queries = [(2, 5), (3, 5), (4, 5), (1, 5)] >>> answer_queries(N, M, Q, grid, queries) [\\"yes\\", \\"yes\\", \\"yes\\", \\"yes\\"] pass","solution":"def exists_uniform_subgrid(grid, K, d): N = len(grid) M = len(grid[0]) d = str(d) for i in range(N - K + 1): for j in range(M - K + 1): uniform = True for ii in range(i, i + K): for jj in range(j, j + K): if grid[ii][jj] != d: uniform = False break if not uniform: break if uniform: return \\"yes\\" return \\"no\\" def answer_queries(N, M, Q, grid, queries): results = [] for K, d in queries: results.append(exists_uniform_subgrid(grid, K, d)) return results"},{"question":"def modify_and_merge_array(arr, k): Modifies the given array as specified. Parameters: arr (list): The input array which has an even number of unique integers. k (int): The number of positions by which to rotate the second half to the left. Returns: list: The modified array after reversing the first half and rotating the second half. Example: >>> modify_and_merge_array([1, 2, 3, 4, 5, 6], 2) [3, 2, 1, 6, 4, 5] >>> modify_and_merge_array([1, 2, 3, 4], 0) [2, 1, 3, 4]","solution":"def modify_and_merge_array(arr, k): Modifies the given array as specified. Parameters: arr (list): The input array which has an even number of unique integers. k (int): The number of positions by which to rotate the second half to the left. Returns: list: The modified array after reversing the first half and rotating the second half. n = len(arr) half = n // 2 # Reverse the first half first_half = arr[:half][::-1] # Rotate the second half to the left by k positions second_half = arr[half:] k = k % half # To handle the case where k is larger than the half size second_half = second_half[k:] + second_half[:k] # Concatenate the modified halves and return return first_half + second_half"},{"question":"def sort_odd_numbers(array: List[int]) -> List[int]: This function takes an array of integers and returns the array sorted in non-decreasing order, but only the odd numbers are rearranged. All even numbers remain in their original positions. >>> sort_odd_numbers([5, 3, 2, 8, 1, 4]) # [1, 3, 2, 8, 5, 4] >>> sort_odd_numbers([7, 1, 6, 3, 4, 9]) # [1, 3, 6, 7, 4, 9] >>> sort_odd_numbers([5, 3, 1, 7, 9]) # [1, 3, 5, 7, 9] >>> sort_odd_numbers([2, 4, 6, 8]) # [2, 4, 6, 8] >>> sort_odd_numbers([]) # [] >>> sort_odd_numbers([1]) # [1] >>> sort_odd_numbers([2]) # [2] >>> sort_odd_numbers([3, -5, 2, 4, -1]) # [-5, -1, 2, 4, 3]","solution":"def sort_odd_numbers(array): This function takes an array of integers and returns the array sorted in non-decreasing order, but only the odd numbers are rearranged. All even numbers remain in their original positions. :param array: List of integers :return: List of integers with odd numbers sorted # Extract odd numbers and sort them odds = sorted([x for x in array if x % 2 != 0]) # Iterator for sorted odd numbers odd_iterator = iter(odds) # Build the result by placing sorted odd numbers in their positions result = [next(odd_iterator) if x % 2 != 0 else x for x in array] return result"},{"question":"[Completion Task in Python] class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addOne(head: ListNode) -> ListNode: Takes the head of a linked list and returns the head of the modified linked list that represents the number obtained by adding one to the integer represented by the linked list. >>> linked_list_to_list(addOne(list_to_linked_list([3, 1, 4, 1, 5]))) == [3, 1, 4, 1, 6] >>> linked_list_to_list(addOne(list_to_linked_list([1, 9, 9]))) == [2, 0, 0] >>> linked_list_to_list(addOne(list_to_linked_list([0]))) == [1] >>> linked_list_to_list(addOne(list_to_linked_list([9, 9, 9]))) == [1, 0, 0, 0] >>> linked_list_to_list(addOne(list_to_linked_list([1, 2, 3, 4]))) == [1, 2, 3, 5] # Your implementation goes here def list_to_linked_list(lst): head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addOne(head: ListNode) -> ListNode: # Helper function to reverse the linked list def reverse_list(node): prev = None while node: next_node = node.next node.next = prev prev = node node = next_node return prev # Reverse the linked list to add from the least significant digit head = reverse_list(head) current = head carry = 1 # We need to add one while current: current.val += carry if current.val < 10: carry = 0 break else: current.val = 0 if not current.next: current.next = ListNode(0) current = current.next # Reverse the list back to original order return reverse_list(head)"},{"question":"def count_and_say(n: int) -> str: Given an integer n, generates the nth term of the count-and-say sequence. >>> count_and_say(1) == \\"1\\" >>> count_and_say(2) == \\"11\\" >>> count_and_say(3) == \\"21\\" >>> count_and_say(4) == \\"1211\\" >>> count_and_say(5) == \\"111221\\" >>> count_and_say(6) == \\"312211\\" >>> count_and_say(7) == \\"13112221\\" >>> count_and_say(8) == \\"1113213211\\" >>> count_and_say(9) == \\"31131211131221\\" >>> count_and_say(10) == \\"13211311123113112211\\"","solution":"def count_and_say(n): Generates the nth term of the count-and-say sequence. if n == 1: return \\"1\\" previous_term = count_and_say(n - 1) result = \\"\\" count = 1 for i in range(1, len(previous_term)): if previous_term[i] == previous_term[i - 1]: count += 1 else: result += str(count) + previous_term[i - 1] count = 1 result += str(count) + previous_term[-1] return result"},{"question":"def findUniqueChars(strings): Returns the unique characters that are present in all strings of the list. Each input string consists only of lowercase alphabetic characters. Args: strings (List[str]): A list of strings to check for common unique characters. Returns: List[str]: A list of unique characters present in all strings, sorted alphabetically. Examples: >>> findUniqueChars([\\"apple\\", \\"plum\\", \\"laser\\"]) ['l'] >>> findUniqueChars([\\"strawberry\\", \\"blueberry\\", \\"raspberry\\"]) ['b', 'e', 'r', 'y'] >>> findUniqueChars([\\"abc\\", \\"def\\"]) []","solution":"def findUniqueChars(strings): Returns the unique characters that are present in all strings of the list. if not strings: return [] # Create a set with all characters of the first string common_chars = set(strings[0]) # Intersect with sets of the remaining strings for string in strings[1:]: common_chars &= set(string) # Return the sorted list of common characters return sorted(common_chars)"},{"question":"def traffic_light_cycle_duration(green_duration: int, yellow_duration: int, red_duration: int) -> int: Calculate the total time of one full cycle of the traffic light sequence. Args: green_duration (int): Duration of the green light in seconds. yellow_duration (int): Duration of the yellow light in seconds. red_duration (int): Duration of the red light in seconds. Returns: int: Total duration of the traffic light cycle in seconds. # Test cases assert traffic_light_cycle_duration(60, 5, 90) == 155 assert traffic_light_cycle_duration(30, 4, 45) == 79 assert traffic_light_cycle_duration(1, 1, 1) == 3 assert traffic_light_cycle_duration(120, 120, 120) == 360 assert traffic_light_cycle_duration(100, 10, 50) == 160 assert traffic_light_cycle_duration(15, 5, 10) == 30","solution":"def traffic_light_cycle_duration(green_duration, yellow_duration, red_duration): Calculate the total time of one full cycle of the traffic light sequence. Args: green_duration (int): Duration of the green light in seconds. yellow_duration (int): Duration of the yellow light in seconds. red_duration (int): Duration of the red light in seconds. Returns: int: Total duration of the traffic light cycle in seconds. return green_duration + yellow_duration + red_duration"},{"question":"from typing import List def factorialDigitSum(n: int) -> int: Calculate the sum of the digits in the factorial of \`n\`. :param n: A non-negative integer whose factorial digit sum to calculate :return: The sum of the digits of the factorial of \`n\` >>> factorialDigitSum(5) 3 >>> factorialDigitSum(10) 27 >>> factorialDigitSum(20) 54 >>> factorialDigitSum(0) 1 >>> factorialDigitSum(1) 1 pass # Unit Tests def test_factorial_digit_sum_5(): assert factorialDigitSum(5) == 3 # 5! = 120, 1 + 2 + 0 = 3 def test_factorial_digit_sum_10(): assert factorialDigitSum(10) == 27 # 10! = 3628800, 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 def test_factorial_digit_sum_20(): assert factorialDigitSum(20) == 54 # 20! = 2432902008176640000, sum of digits = 54 def test_factorial_digit_sum_0(): assert factorialDigitSum(0) == 1 # 0! = 1, sum of digits = 1 def test_factorial_digit_sum_1(): assert factorialDigitSum(1) == 1 # 1! = 1, sum of digits = 1 def test_factorial_digit_sum_50(): assert factorialDigitSum(50) == 216 # 50!, and the sum of its digits def test_factorial_digit_sum_100(): assert factorialDigitSum(100) == 648 # 100!, and the sum of its digits","solution":"import math def factorialDigitSum(n): Returns the sum of the digits in the factorial of \`n\`. # Calculate factorial of n factorial_value = math.factorial(n) # Convert factorial value to string to iterate over each digit factorial_str = str(factorial_value) # Sum up the digits of the factorial digit_sum = sum(int(digit) for digit in factorial_str) return digit_sum"},{"question":"def alphabetizeString(input_string): Returns a new string with the characters placed in alphabetical order. Ignores case when sorting, but preserves the original case. If the input is not a string, returns an error message. >>> alphabetizeString(\\"HelloWorld\\") == \\"deHllloorW\\" >>> alphabetizeString(\\"python\\") == \\"hnopty\\" >>> alphabetizeString(12345) == \\"Invalid input: not a string\\" >>> alphabetizeString(['a', 'b', 'c']) == \\"Invalid input: not a string\\" >>> alphabetizeString(\\"\\") == \\"\\"","solution":"def alphabetizeString(input_string): Returns a new string with the characters placed in alphabetical order. Ignores case when sorting, but preserves the original case. If the input is not a string, returns an error message. if not isinstance(input_string, str): return \\"Invalid input: not a string\\" return ''.join(sorted(input_string, key=lambda c: c.lower()))"},{"question":"import re from typing import Dict from collections import defaultdict def word_count(s: str) -> Dict[str, int]: Returns a dictionary where keys are unique words in the string \`s\` and values are the count of occurrences of each word. The function is case-insensitive and ignores punctuation. Parameters: s (str): Input string containing words and punctuation. Returns: dict: Dictionary with words as keys and their counts as values. >>> word_count(\\"Hello, world! Hello, Python.\\") {'hello': 2, 'world': 1, 'python': 1} >>> word_count(\\"The quick brown fox jumps over the lazy dog.\\") {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} >>> word_count(\\"\\") {} >>> word_count(\\"This is This and this is that\\") {'this': 3, 'is': 2, 'and': 1, 'that': 1} >>> word_count(\\".,;!?!\\") {} >>> word_count(\\"One fish, two fish. Red fish, blue fish.\\") {'one': 1, 'fish': 4, 'two': 1, 'red': 1, 'blue': 1} >>> word_count(\\"Well, well, well... look who's here!\\") {'well': 3, 'look': 1, 'whos': 1, 'here': 1} >>> word_count(\\"word\\") {'word': 1} >>> word_count(\\" This has multiple spaces \\") {'this': 1, 'has': 1, 'multiple': 1, 'spaces': 1}","solution":"import re from collections import defaultdict def word_count(s): Returns a dictionary with the count of each unique word in the input string \`s\`. The function is case-insensitive and ignores punctuation. Parameters: s (str): Input string containing words and punctuation. Returns: dict: Dictionary with words as keys and their counts as values. # Convert string to lowercase and remove punctuation s = s.lower() s = re.sub(r'[^ws]', '', s) # Split the string into words words = s.split() # Create a dictionary to count the occurrences of each word word_count_dict = defaultdict(int) for word in words: word_count_dict[word] += 1 return dict(word_count_dict)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression in infix notation and returns the result. It handles non-negative integers, +, -, *, / operators, and parentheses for grouping. >>> evaluate_expression(\\"3 + 5 * 2 - 9 / 3\\") 10 >>> evaluate_expression(\\"(2 + 3) * 4 - 5\\") 15 >>> evaluate_expression(\\"10 / (2 + 3)\\") 2 from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3 + 5\\") == 8 def test_simple_subtraction(): assert evaluate_expression(\\"10 - 5\\") == 5 def test_simple_multiplication(): assert evaluate_expression(\\"4 * 3\\") == 12 def test_simple_division(): assert evaluate_expression(\\"20 / 4\\") == 5 def test_mixed_operations(): assert evaluate_expression(\\"3 + 5 * 2 - 9 / 3\\") == 10 def test_with_parentheses(): assert evaluate_expression(\\"(2 + 3) * 4 - 5\\") == 15 def test_division_with_parentheses(): assert evaluate_expression(\\"10 / (2 + 3)\\") == 2 def test_nested_parentheses(): assert evaluate_expression(\\"((2 + 3) * (5 - 2)) / 2\\") == 7 def test_complex_expression(): assert evaluate_expression(\\"2 + 3 * (2 - 1) / 1 + 4 * 5\\") == 25","solution":"def evaluate_expression(expression): Evaluates a mathematical expression in infix notation and returns the result. It handles non-negative integers, +, -, *, / operators, and parentheses for grouping. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression)"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string s, return the longest palindromic substring in s. Palindromes are strings that read the same forwards and backwards. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True def test_longest_palindromic_substring(): assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] assert longest_palindromic_substring(\\"\\") == \\"\\" assert longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" assert longest_palindromic_substring(\\"abcd\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] def test_longest_palindromic_substring_varied_inputs(): # Testing longer inputs assert longest_palindromic_substring(\\"abba\\") == \\"abba\\" assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" assert longest_palindromic_substring(\\"aabbccddccbbaa\\") == \\"aabbccddccbbaa\\" # Testing palindromes with one character center assert longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" assert longest_palindromic_substring(\\"abacdfgdcabba\\") == \\"abba\\" # Testing repeated single character assert longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\" if __name__ == \\"__main__\\": test_longest_palindromic_substring() test_longest_palindromic_substring_varied_inputs() print(\\"All tests passed!\\")","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 for i in range(n): # Check for odd length palindromes with center i low = i high = i while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: start = low max_length = current_length low -= 1 high += 1 # Check for even length palindromes with center i and i+1 low = i high = i + 1 while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: start = low max_length = current_length low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def compress_string(s: str) -> str: Compresses the string by using counts of repeated characters. If the compressed string is not shorter, returns the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abc\\") \\"abc\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"aaaaa\\") \\"a5\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\" >>> compress_string(\\"aabbbbcccaaa\\") \\"a2b4c3a3\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"ababababab\\") \\"ababababab\\" >>> compress_string(\\"a\\" * 1000) \\"a1000\\" >>> compress_string(\\"aAbBcC\\") \\"aAbBcC\\"","solution":"def compress_string(s: str) -> str: Compresses the string by using counts of repeated characters. If the compressed string is not shorter, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def is_valid_parentheses(s: str) -> bool: Returns True if the input string s is a valid parentheses string, otherwise False. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"())(\\") False","solution":"def is_valid_parentheses(s): Returns True if the input string s is a valid parentheses string, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def can_cut_one_tree(heights): Checks if it's possible to cut exactly one tree to get a strictly increasing sequence. Parameters: heights (list): List of unique integers representing heights of trees. Returns: bool: True if it's possible, False otherwise.","solution":"def can_cut_one_tree(heights): Checks if it's possible to cut exactly one tree to get a strictly increasing sequence. Parameters: heights (list): List of unique integers representing heights of trees. Returns: bool: True if it's possible, False otherwise. def is_strictly_increasing(arr): for i in range(len(arr)-1): if arr[i] >= arr[i+1]: return False return True for i in range(len(heights)): if is_strictly_increasing(heights[:i] + heights[i+1:]): return True return False"},{"question":"from typing import List def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abcdef\\") 6 >>> count_palindromic_substrings(\\"a\\" * 1000) 500500","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 for center in range(2*n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count"},{"question":"from typing import List, Tuple def max_difference(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Given a matrix and a list of queries, find the maximum difference between any two integers within the submatrix defined by the query coordinates. Args: matrix (List[List[int]]): The matrix containing integers. queries (List[Tuple[int, int, int, int]]): List of queries where each query is a tuple (x1, y1, x2, y2). Returns: List[int]: The result for each query, which is the maximum difference. Example: >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> queries = [ ... (1, 1, 2, 2), ... (3, 3, 4, 4), ... (1, 1, 4, 4) ... ] >>> max_difference(matrix, queries) [5, 5, 15]","solution":"def max_difference(matrix, queries): Given a matrix and a list of queries, find the maximum difference between any two integers within the submatrix defined by the query coordinates. Parameters: matrix (list of list of int): The matrix containing integers. queries (list of tuple): List of queries where each query is a tuple (x1, y1, x2, y2). Returns: list of int: The result for each query, which is the maximum difference. results = [] for (x1, y1, x2, y2) in queries: submatrix_values = [] for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): submatrix_values.append(matrix[i][j]) max_value = max(submatrix_values) min_value = min(submatrix_values) results.append(max_value - min_value) return results"},{"question":"def replace_negative_words(num_cases: int, cases: List[Tuple[int, List[Tuple[str, str]], int, List[str]]]) -> List[List[str]]: Given the number of test cases, and for each test case, the number of negative-positive word pairs and update strings, replace negative words with their positive counterparts in each update string. >>> num_cases = 1 >>> cases = [(3, [(\\"bad\\", \\"good\\"), (\\"sad\\", \\"happy\\"), (\\"angry\\", \\"calm\\")], 2, [\\"this is a bad day\\", \\"he is very sad and angry\\"])] >>> replace_negative_words(num_cases, cases) [['this is a good day', 'he is very happy and calm']] >>> num_cases = 2 >>> cases = [ ... (2, [(\\"dark\\", \\"bright\\"), (\\"cold\\", \\"warm\\")], 1, [\\"the night is dark and cold\\"]), ... (2, [(\\"unhappy\\", \\"joyful\\"), (\\"boring\\", \\"exciting\\")], 1, [\\"this movie is really boring\\"]), ... ] >>> replace_negative_words(num_cases, cases) [['the night is bright and warm'], ['this movie is really exciting']]","solution":"def replace_negative_words(num_cases, cases): results = [] for case in cases: n, replacements, m, updates = case neg_pos_dict = dict(replacements) modified_updates = [] for update in updates: words = update.split() modified_words = [neg_pos_dict.get(word, word) for word in words] modified_updates.append(\\" \\".join(modified_words)) results.append(modified_updates) return results"},{"question":"def letter_frequency(s: str) -> dict: Returns a dictionary with the frequency of each letter in the string s. >>> letter_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> letter_frequency(\\"a\\") {'a': 1} >>> letter_frequency(\\"aaa\\") {'a': 3} >>> letter_frequency(\\"\\") {} >>> letter_frequency(\\"abcdef\\") {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1} >>> letter_frequency(\\"aAa\\") {'a': 2, 'A': 1}","solution":"def letter_frequency(s): Returns a dictionary with the frequency of each letter in the string s. frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def char_count(s: str) -> dict: Returns a dictionary where the keys are the unique characters from the string and the values are the counts of occurrences of each character. >>> char_count(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_count(\\"character\\") {'c': 2, 'h': 1, 'a': 2, 'r': 2, 't': 1, 'e': 1}","solution":"def char_count(s): Returns a dictionary where the keys are the unique characters from the string and the values are the counts of occurrences of each character. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. You can only move down or right at any point in time. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(0, 5) 0 >>> unique_paths(5, 0) 0 >>> unique_paths(0, 0) 0 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. You can only move down or right at any point in time. if m == 0 or n == 0: return 0 dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def fibonacci(n: int) -> int: Returns the nth number in the Fibonacci sequence using a dynamic programming approach. >>> fibonacci(5) 5 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming. if n <= 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def topKFrequent(words: List[str], k: int) -> List[str]: Given an array of strings words and an integer k, return the k most frequent words. The answer should be sorted by frequency from highest to lowest. If there are multiple words with the same frequency, sort them alphabetically. >>> topKFrequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) [\\"i\\", \\"love\\"] >>> topKFrequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"]","solution":"from collections import Counter import heapq def topKFrequent(words, k): Returns the k most frequent words in the list, sorted by frequency and then alphabetically. count = Counter(words) heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) return [heapq.heappop(heap)[1] for _ in range(k)]"},{"question":"def mostFrequentCharacter(s: str) -> str: Returns the most frequent character in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. >>> mostFrequentCharacter(\\"sample string\\") == \\"s\\" >>> mostFrequentCharacter(\\"character\\") == \\"c\\" >>> mostFrequentCharacter(\\"aabbcc\\") == \\"a\\" >>> mostFrequentCharacter(\\"mississippi\\") == \\"i\\" >>> mostFrequentCharacter(\\"abracadabra\\") == \\"a\\"","solution":"def mostFrequentCharacter(s): Returns the most frequent character in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. from collections import Counter frequency = Counter(s) max_frequency = max(frequency.values()) for char in s: if frequency[char] == max_frequency: return char"},{"question":"from typing import List, Tuple def calculate_sum_without_extremes(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculates the sum of all elements in the list excluding the highest and lowest elements. Args: test_cases: A list of tuples, each containing an integer N and a list of N non-negative integers. Returns: A list of integers, each representing the required sum for the corresponding test case. >>> calculate_sum_without_extremes([(5, [3, 1, 4, 1, 5])]) [8] >>> calculate_sum_without_extremes([(4, [1, 2, 3, 4])]) [5]","solution":"def calculate_sum_without_extremes(test_cases): results = [] for case in test_cases: N, numbers = case if N <= 2: results.append(0) else: highest = max(numbers) lowest = min(numbers) total_sum = sum(numbers) results.append(total_sum - highest - lowest) return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) numbers = list(map(int, data[index + 1:index + 1 + N])) test_cases.append((N, numbers)) index = index + 1 + N results = calculate_sum_without_extremes(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def max_transformed_difference(arr: List[int], a: int, b: int) -> int: Computes the maximum difference between any two elements in an array after applying a fixed transformation to each element. The transformation applied to each element is defined as: f(x) = a * x + b Parameters: - arr: A list of integers with length of at least 2 and at most 10^5. - a: An integer that is the coefficient used in the transformation. - b: An integer to be added during the transformation. Returns: - An integer representing the maximum difference between any two transformed elements from the array. Example: >>> arr = [1, 5, 3, -2] >>> a = 2 >>> b = 3 >>> max_transformed_difference(arr, a, b) 14 pass # Test cases def test_max_transformed_difference_example(): arr = [1, 5, 3, -2] a = 2 b = 3 assert max_transformed_difference(arr, a, b) == 14 def test_max_transformed_difference_negative_a(): arr = [1, 5, 3, -2] a = -2 b = 3 assert max_transformed_difference(arr, a, b) == 14 def test_max_transformed_difference_large_numbers(): arr = [10000, 20000, 30000, 40000, 50000] a = 2 b = -10000 assert max_transformed_difference(arr, a, b) == 80000 def test_max_transformed_difference_zero_a(): arr = [100, 200, 300] a = 0 b = 10 assert max_transformed_difference(arr, a, b) == 0 def test_max_transformed_difference_zero_b(): arr = [100, 200, 300] a = 2 b = 0 assert max_transformed_difference(arr, a, b) == 400","solution":"from typing import List def max_transformed_difference(arr: List[int], a: int, b: int) -> int: Computes the maximum difference between any two elements in an array after applying the transformation f(x) = a * x + b to each element. # Apply the transformation to each element transformed = [a * x + b for x in arr] # Find the maximum and minimum values in the transformed list max_val = max(transformed) min_val = min(transformed) # The maximum difference will be the difference between the max and min values return max_val - min_val"},{"question":"def valid_palindrome(s: str) -> bool: Determines if the string s can be made a palindrome by deleting at most one character. Examples: >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"abc\\") False","solution":"def valid_palindrome(s: str) -> bool: Determines if the string s can be made a palindrome by deleting at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) for i in range(len(s) // 2): if s[i] != s[~i]: j = len(s) - 1 - i return is_palindrome_range(i+1, j) or is_palindrome_range(i, j-1) return True"},{"question":"from typing import List def mirror_numbers(lst: List[int]) -> List[int]: Given a list of integers, returns a list of the same integers but where each integer has been \\"mirrored\\" around its middle. Examples: >>> mirror_numbers([1234]) [4321] >>> mirror_numbers([56789]) [98765] >>> mirror_numbers([4]) [4] >>> mirror_numbers([10203]) [30201]","solution":"def mirror_numbers(lst): Returns a list of integers where each integer is mirrored around its middle. mirrored_list = [] for number in lst: str_num = str(number) mirrored_str_num = str_num[::-1] mirrored_list.append(int(mirrored_str_num)) return mirrored_list"},{"question":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: Returns the length of the longest increasing path in a matrix. The path can move in four possible directions: up, down, left, and right. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) == 4 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) == 4 >>> longest_increasing_path([[1]]) == 1 >>> longest_increasing_path([]) == 0 >>> longest_increasing_path([ ... [1, 2], ... [4, 3] ... ]) == 4","solution":"def longestIncreasingPath(matrix): Returns the length of the longest increasing path in a matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) cache = [[-1] * n for _ in range(m)] def dfs(i, j): if cache[i][j] != -1: return cache[i][j] longest = 1 for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]: longest = max(longest, 1 + dfs(x, y)) cache[i][j] = longest return longest max_length = 0 for i in range(m): for j in range(n): max_length = max(max_length, dfs(i, j)) return max_length"},{"question":"def separate_and_sort(s: str) -> str: Separates the letters from the digits, sorts the letters alphabetically and the digits in ascending order, and then concatenates them back together with letters first followed by digits. >>> separate_and_sort(\\"d4a5e9c1b2\\") \\"abcde12459\\" >>> separate_and_sort(\\"A2b3C1d4\\") \\"abcd1234\\" # Implement your solution here from solution import separate_and_sort def test_separate_and_sort_all_letters(): assert separate_and_sort(\\"abcd\\") == \\"abcd\\" assert separate_and_sort(\\"DCBA\\") == \\"abcd\\" assert separate_and_sort(\\"aBcD\\") == \\"abcd\\" def test_separate_and_sort_all_digits(): assert separate_and_sort(\\"1234\\") == \\"1234\\" assert separate_and_sort(\\"4321\\") == \\"1234\\" def test_separate_and_sort_mixed(): assert separate_and_sort(\\"d4a5e9c1b2\\") == \\"abcde12459\\" assert separate_and_sort(\\"A2b3C1d4\\") == \\"abcd1234\\" assert separate_and_sort(\\"d4C2a3E1b5\\") == \\"abcde12345\\" def test_separate_and_sort_empty_string(): assert separate_and_sort(\\"\\") == \\"\\" def test_separate_and_sort_single_character(): assert separate_and_sort(\\"a\\") == \\"a\\" assert separate_and_sort(\\"2\\") == \\"2\\" def test_separate_and_sort_all_same_letter_case(): assert separate_and_sort(\\"aaaa\\") == \\"aaaa\\" assert separate_and_sort(\\"1111\\") == \\"1111\\" def test_separate_and_sort_case_insensitive_sorting(): assert separate_and_sort(\\"AaBbCc\\") == \\"aabbcc\\" assert separate_and_sort(\\"CcBbAa\\") == \\"aabbcc\\"","solution":"def separate_and_sort(s: str) -> str: letters = sorted([char.lower() for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(letters + digits)"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Returns true if the word exists in the grid. >>> exist( ... [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"ABCCED\\" ... ) True >>> exist( ... [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"SEE\\" ... ) True >>> exist( ... [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"ABCB\\" ... ) False","solution":"def exist(board, word): Returns true if the word exists in the grid. rows, cols = len(board), len(board[0]) def dfs(r, c, idx): if idx == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[idx]: return False temp = board[r][c] board[r][c] = '#' # Mark the cell as visited # Explore all possible directions (up, down, left, right) found = (dfs(r+1, c, idx+1) or dfs(r-1, c, idx+1) or dfs(r, c+1, idx+1) or dfs(r, c-1, idx+1)) board[r][c] = temp # Restore the original letter return found for i in range(rows): for j in range(cols): if board[i][j] == word[0]: if dfs(i, j, 0): return True return False"},{"question":"def perfect_squares(n: int) -> int: Returns the least number of perfect square numbers which sum to n. >>> perfect_squares(12) 3 >>> perfect_squares(13) 2 >>> perfect_squares(1) 1 >>> perfect_squares(27) 3 >>> perfect_squares(0) 0 >>> perfect_squares(2) 2 >>> perfect_squares(5) 2 >>> perfect_squares(100) 1","solution":"def perfect_squares(n): Returns the least number of perfect square numbers which sum to n. # Initialize a list to hold the minimum number of perfect square numbers for each value up to n dp = [float('inf')] * (n + 1) dp[0] = 0 # There are 0 ways to sum up to 0 using perfect squares # Loop through all integers from 1 to n to find the minimum perfect squares needed for i in range(1, n + 1): # Check all perfect squares less than the current number i j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"from typing import List def is_happy_number(n: int) -> bool: Determines if the provided number n is a happy number. >>> is_happy_number(19) == True >>> is_happy_number(20) == False def determine_happy_numbers(nums: List[int]) -> List[str]: Checks a list of integers to determine if each is a happy number. Returns a list of strings, \\"YES\\" for happy numbers, \\"NO\\" otherwise. >>> determine_happy_numbers([19, 20]) == [\\"YES\\", \\"NO\\"] >>> determine_happy_numbers([1, 7, 10, 13, 19]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_happy_number(n): Determines if the provided number n is a happy number. def get_next(number): total_sum = 0 while number > 0: number, digit = divmod(number, 10) total_sum += digit * digit return total_sum seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = get_next(n) return n == 1 def determine_happy_numbers(nums): Checks a list of integers to determine if each is a happy number. Returns a list of strings, \\"YES\\" for happy numbers, \\"NO\\" otherwise. return [\\"YES\\" if is_happy_number(num) else \\"NO\\" for num in nums] input_numbers = [19, 20] for result in determine_happy_numbers(input_numbers): print(result)"},{"question":"def max_activities(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determine the maximum number of non-overlapping activities Carla can select from the list. Args: T (int): The number of test cases. test_cases (List[List[Tuple[int, int]]]): A list of test cases, each containing a list of activities represented as tuples with start and end times. Returns: List[int]: A list of integers where each integer represents the maximum number of non-overlapping activities Carla can select for each test case. Example: >>> max_activities(2, [[(1, 2), (3, 4), (0, 6)], [(1, 3), (2, 4), (3, 5), (0, 6)]]) [2, 2] >>> max_activities(1, [[(1, 4), (2, 3), (3, 5), (5, 7), (6, 8)]]) [3]","solution":"def max_activities(T, test_cases): results = [] for activities in test_cases: # Sort the activities based on their end times activities.sort(key=lambda x: x[1]) max_count = 0 current_end_time = 0 for start, end in activities: if start >= current_end_time: max_count += 1 current_end_time = end results.append(max_count) return results"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Write a function that takes a list of integers and returns the length of the longest consecutive elements sequence. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, -1, 1, 2, -2, 5]) 5 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([7, 7, 7, 7]) 1 >>> longest_consecutive_sequence([10, 100, 1000]) 1 >>> longest_consecutive_sequence([-1, -2, -3, 1, 2, 3]) 3 >>> longest_consecutive_sequence(list(range(100000, 0, -1))) 100000 >>> longest_consecutive_sequence([1, 2, 2, 3, 4, 5, 5, 6, 7]) 7","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums_set: # Check if this is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using memoization for optimization. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(20) == 6765 >>> fibonacci(30) == 832040 >>> fibonacci(40) == 102334155","solution":"def fibonacci(n, memo=None): Returns the nth Fibonacci number using memoization for optimization. if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo) return memo[n]"},{"question":"def first_non_repeating(lst: List[int]) -> int: Finds the first integer in the list that does not repeat later. >>> first_non_repeating([4, 5, 1, 2, 5, 1, 2]) 4 >>> first_non_repeating([7, 8, 8, 9, 9, 10, 7, 10]) None >>> first_non_repeating([3, 3, 3, 2, 2, 1]) 1 >>> first_non_repeating([]) None","solution":"def first_non_repeating(lst): Finds the first integer in the list that does not repeat later. Args: lst (list): List of integers. Returns: int or None: The first non-repeating integer, or None if all integers repeat. seen = set() for i in range(len(lst)): if lst[i] not in seen: if lst[i] not in lst[i+1:]: return lst[i] seen.add(lst[i]) return None"},{"question":"from typing import List, Dict, Union def sort_products_by_price(products: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sorts a list of products by their price in ascending order. If two or more products have the same price, they will maintain their original relative order. :param products: List of dictionaries, where each dictionary has a 'name' (string) and 'price' (numeric). :return: A new list of dictionaries sorted by price in ascending order. >>> sort_products_by_price([ {\\"name\\": \\"Laptop\\", \\"price\\": 999.99}, {\\"name\\": \\"Mouse\\", \\"price\\": 25.00}, {\\"name\\": \\"Monitor\\", \\"price\\": 199.99}, {\\"name\\": \\"Keyboard\\", \\"price\\": 49.99}, {\\"name\\": \\"Speaker\\", \\"price\\": 75.00} ]) [{'name': 'Mouse', 'price': 25.0}, {'name': 'Keyboard', 'price': 49.99}, {'name': 'Speaker', 'price': 75.0}, {'name': 'Monitor', 'price': 199.99}, {'name': 'Laptop', 'price': 999.99}] >>> sort_products_by_price([]) []","solution":"from typing import List, Dict, Union def sort_products_by_price(products: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sorts a list of products by their price in ascending order. If two or more products have the same price, they will maintain their original relative order. :param products: List of dictionaries, where each dictionary has a 'name' (string) and 'price' (numeric). :return: A new list of dictionaries sorted by price in ascending order. return sorted(products, key=lambda product: product[\\"price\\"])"},{"question":"def number_to_words(num: int) -> str: Convert an integer to its English words representation for numbers from 0 to 999,999. >>> number_to_words(0) \\"Zero\\" >>> number_to_words(5) \\"Five\\" >>> number_to_words(23) \\"Twenty Three\\" >>> number_to_words(105) \\"One Hundred Five\\" >>> number_to_words(1000) \\"One Thousand\\" >>> number_to_words(17042) \\"Seventeen Thousand Forty Two\\" >>> number_to_words(999999) \\"Nine Hundred Ninety Nine Thousand Nine Hundred Ninety Nine\\"","solution":"def number_to_words(num): Convert a number into words. if num == 0: return \\"Zero\\" below_20 = [\\"\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\", \\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\"] tens = [\\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\"] def words(n): if n < 20: return below_20[n] elif n < 100: return tens[n // 10] + (\\" \\" + below_20[n % 10] if (n % 10 != 0) else \\"\\") elif n < 1000: return below_20[n // 100] + \\" Hundred\\" + (\\" \\" + words(n % 100) if (n % 100 != 0) else \\"\\") elif n < 1000000: return words(n // 1000) + \\" Thousand\\" + (\\" \\" + words(n % 1000) if (n % 1000 != 0) else \\"\\") return words(num)"},{"question":"from typing import List def check_winner(board: List[List[str]]) -> str: Determine the winner in a 3x3 tic-tac-toe board. >>> check_winner([ ... ['X', 'O', 'X'], ... ['O', 'X', 'O'], ... ['O', '', 'X'] ... ]) 'X' >>> check_winner([ ... ['O', 'O', 'O'], ... ['X', 'X', ''], ... ['X', '', ''] ... ]) 'O' >>> check_winner([ ... ['', 'X', 'O'], ... ['X', 'X', 'O'], ... ['O', 'X', 'O'] ... ]) '' pass # Write your solution here def test_check_winner_row(): board = [ ['X', 'X', 'X'], ['O', 'O', ''], ['', '', ''] ] assert check_winner(board) == 'X' def test_check_winner_column(): board = [ ['O', 'X', ''], ['O', 'X', ''], ['O', '', ''] ] assert check_winner(board) == 'O' def test_check_winner_diagonal(): board = [ ['X', 'O', ''], ['O', 'X', ''], ['', 'O', 'X'] ] assert check_winner(board) == 'X' def test_check_winner_anti_diagonal(): board = [ ['', 'O', 'X'], ['O', 'X', ''], ['X', '', 'O'] ] assert check_winner(board) == 'X' def test_no_winner(): board = [ ['X', 'O', 'X'], ['O', 'X', 'O'], ['O', 'X', 'O'] ] assert check_winner(board) == '' def test_empty_board(): board = [ ['', '', ''], ['', '', ''], ['', '', ''] ] assert check_winner(board) == ''","solution":"from typing import List def check_winner(board: List[List[str]]) -> str: # Check rows for a winner for row in board: if row[0] == row[1] == row[2] and row[0] != '': return row[0] # Check columns for a winner for col in range(3): if board[0][col] == board[1][col] == board[2][col] and board[0][col] != '': return board[0][col] # Check main diagonal for a winner if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '': return board[0][0] # Check anti-diagonal for a winner if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '': return board[0][2] # No winner found return ''"},{"question":"def maxWaterContainer(heights: List[int]) -> int: Find the maximum amount of water that can be trapped between any two lines. >>> maxWaterContainer([1,8,6,2,5,4,8,3,7]) 49 >>> maxWaterContainer([1,1]) 1 >>> maxWaterContainer([4,3,2,1,4]) 16 >>> maxWaterContainer([1,2,1]) 2","solution":"from typing import List def maxWaterContainer(heights: List[int]) -> int: left = 0 right = len(heights) - 1 max_water = 0 while left < right: # Calculate the width and height of the container width = right - left height = min(heights[left], heights[right]) # Calculate the water contained in this container current_water = width * height # Update max_water if the current is greater max_water = max(max_water, current_water) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def minimum_time_to_assemble_widget(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Calculate the minimum time required to assemble a widget based on the dependency graph. Args: - n (int): Number of workstations. - m (int): Number of directed edges in the dependency graph. - edges (list of tuples): Each tuple (u, v) indicates a directed edge from u to v. Returns: - int: Minimum time required to complete the widget assembly. Example: >>> minimum_time_to_assemble_widget(5, 4, [(1, 2), (1, 3), (3, 4), (2, 4)]) 3 >>> minimum_time_to_assemble_widget(6, 6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6)]) 5 >>> minimum_time_to_assemble_widget(4, 3, [(1, 2), (2, 3), (3, 4)]) 4","solution":"from collections import defaultdict, deque def minimum_time_to_assemble_widget(n, m, edges): Calculate the minimum time required to assemble a widget based on the dependency graph. Args: - n (int): Number of workstations. - m (int): Number of directed edges in the dependency graph. - edges (list of tuples): Each tuple (u, v) indicates a directed edge from u to v. Returns: - int: Minimum time required to complete the widget assembly. # Create an adjacency list and in-degree map adj_list = defaultdict(list) in_degree = {i: 0 for i in range(1, n + 1)} for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Queue for processing workstations with no dependencies zero_in_degree_queue = deque() # Distance table to keep track of the minimum time to reach each workstation distance = {i: 0 for i in range(1, n + 1)} # Initialize queue with workstations having in-degree 0 for i in range(1, n + 1): if in_degree[i] == 0: zero_in_degree_queue.append(i) distance[i] = 1 # Each node itself takes 1 unit time # Perform topological sort and update distance table while zero_in_degree_queue: current = zero_in_degree_queue.popleft() current_dist = distance[current] for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) distance[neighbor] = max(distance[neighbor], current_dist + 1) # The minimum time required to assemble the widget is the maximum value in the distance table return max(distance.values())"},{"question":"def has_subarray_with_sum(array: List[int], target: int, k: int) -> bool: Determines if there exists at least one subarray of length k whose sum equals the target. Examples: >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9, 3) True >>> has_subarray_with_sum([1, 2, 3, 4, 5], 15, 3) False >>> has_subarray_with_sum([5], 5, 1) True >>> has_subarray_with_sum([5], 10, 1) False >>> has_subarray_with_sum([1, 2, 3, 4, 5, 2, 3, 4], 9, 3) True >>> has_subarray_with_sum([1, 2, -2, -1, 3], 0, 2) True","solution":"def has_subarray_with_sum(array, target, k): Determines if there exists at least one subarray of length k whose sum equals the target. n = len(array) # Edge case: if the array length is less than k. if n < k: return False # Compute the sum of the first subarray of length k. current_sum = sum(array[:k]) if current_sum == target: return True # Use a sliding window to check sums of all other subarrays of length k. for i in range(k, n): current_sum += array[i] - array[i - k] if current_sum == target: return True return False"},{"question":"from typing import List def move_to_end(nums: List[int], n: int) -> List[int]: Moves all instances of \`n\` in the list \`nums\` to the end while maintaining the relative order of the other elements. >>> move_to_end([1, 2, 3, 4, 3, 5, 3], 3) == [1, 2, 4, 5, 3, 3, 3] >>> move_to_end([4, 1, 2, 2, 4, 1, 4], 4) == [1, 2, 2, 1, 4, 4, 4] >>> move_to_end([0, 1, 0, 3, 12], 0) == [1, 3, 12, 0, 0] >>> move_to_end([1, 2, 3, 1, 2, 3, 1, 2, 1], 1) == [2, 3, 2, 3, 2, 1, 1, 1, 1]","solution":"from typing import List def move_to_end(nums: List[int], n: int) -> List[int]: Moves all instances of \`n\` in the list \`nums\` to the end while maintaining the relative order of the other elements. non_n_elements = [x for x in nums if x != n] n_elements = [x for x in nums if x == n] return non_n_elements + n_elements"},{"question":"from typing import List, Tuple def count_even_product_pairs(arr: List[int]) -> int: Returns the number of distinct pairs (i, j) where 0 <= i < j < N and arr[i] * arr[j] is even. >>> count_even_product_pairs([1, 2, 3]) == 2 >>> count_even_product_pairs([5, 7, 4, 6]) == 5 >>> count_even_product_pairs([1, 3, 5]) == 0 >>> count_even_product_pairs([2, 4, 6, 8]) == 6 >>> count_even_product_pairs([1]) == 0 def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given test cases of arrays, returns a list of results for the number of even product pairs for each test case. def test_count_even_product_pairs(): assert count_even_product_pairs([1, 2, 3]) == 2 assert count_even_product_pairs([5, 7, 4, 6]) == 5 assert count_even_product_pairs([1, 3, 5]) == 0 assert count_even_product_pairs([2, 4, 6, 8]) == 6 assert count_even_product_pairs([1]) == 0 def test_solve(): test_cases = [ (3, [1, 2, 3]), (4, [5, 7, 4, 6]) ] assert solve(test_cases) == [2, 5] test_cases = [ (3, [1, 3, 5]), (4, [2, 4, 6, 8]) ] assert solve(test_cases) == [0, 6]","solution":"def count_even_product_pairs(arr): Returns the number of distinct pairs (i, j) where 0 <= i < j < N and arr[i] * arr[j] is even. even_count = sum(1 for x in arr if x % 2 == 0) odd_count = len(arr) - even_count # Total pairs is combination C(N, 2) = N * (N-1) // 2 total_pairs = len(arr) * (len(arr) - 1) // 2 # Pairs with both elements odd are C(odd_count, 2) = odd_count * (odd_count-1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 # Even product pairs are total pairs minus odd pairs even_product_pairs = total_pairs - odd_pairs return even_product_pairs def solve(test_cases): results = [] for i in range(len(test_cases)): N, arr = test_cases[i] results.append(count_even_product_pairs(arr)) return results"},{"question":"def moveTargetToEnd(arr, target): Moves all instances of the target value to the end of the array while preserving the relative order of other elements. Modifies the array in-place. :param arr: List[int] - The input array :param target: int - The target value to move to the end :return: List[int] - The modified array >>> moveTargetToEnd([4, 2, 4, 1, 4, 3, 4], 4) [2, 1, 3, 4, 4, 4, 4] >>> moveTargetToEnd([1, 2, 3], 4) [1, 2, 3] >>> moveTargetToEnd([4, 4, 4, 4], 4) [4, 4, 4, 4] >>> moveTargetToEnd([], 4) [] >>> moveTargetToEnd([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> moveTargetToEnd([4, 1, 2, 3], 4) [1, 2, 3, 4]","solution":"def moveTargetToEnd(arr, target): Moves all instances of target to the end of the array while preserving the relative order of other elements. Modifies the array in-place. :param arr: List[int] - The input array :param target: int - The target value to move to the end :return: List[int] - The modified array insert_position = 0 for i in range(len(arr)): if arr[i] != target: arr[insert_position] = arr[i] insert_position += 1 for i in range(insert_position, len(arr)): arr[i] = target return arr"},{"question":"from typing import List def max_product(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray within the given array of integers. >>> max_product([2, 3, -2, 4]) == 6 >>> max_product([-2, 0, -1]) == 0 >>> max_product([-2, 3, -4]) == 24 >>> max_product([3]) == 3 >>> max_product([-3]) == -3 >>> max_product([0]) == 0 >>> max_product([-1, -2, -3, -4]) == 24 >>> max_product([1, 2, 3, 4]) == 24 >>> max_product([1, 0, 2, 3]) == 6 >>> max_product([0, -1, -2, -3]) == 6 >>> max_product([-2, 0, -3, 4]) == 4","solution":"def max_product(nums): Returns the maximum product of a contiguous subarray within the given array of integers. if not nums: return 0 current_max = current_min = overall_max = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) overall_max = max(overall_max, current_max) return overall_max"},{"question":"from typing import List, Tuple def shortest_distances(N: int, M: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determines the shortest distance from the capital city (city 1) to each of the other cities in a kingdom. Parameters: N (int): The number of cities. M (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing a bidirectional road between cities u and v with a length of w. Returns: List[int]: A list containing the shortest distance from the capital city to each city (2 ≤ i ≤ N). If there is no path, the distance for that city will be -1. Example: >>> shortest_distances(4, 4, [(1, 2, 2), (1, 3, 3), (2, 3, 2), (3, 4, 4)]) [2, 3, 7] >>> shortest_distances(4, 2, [(1, 2, 2), (3, 4, 3)]) [2, -1, -1] >>> shortest_distances(3, 2, [(1, 2, 5), (1, 3, 10)]) [5, 10] >>> shortest_distances(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) [1, 2] >>> shortest_distances(3, 3, [(1, 2, 100), (2, 3, 100), (1, 3, 250)]) [100, 200]","solution":"import heapq def shortest_distances(N, M, roads): graph = {i: [] for i in range(1, N+1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm distances = {i: float('inf') for i in range(1, N+1)} distances[1] = 0 pq = [(0, 1)] # (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) result = [] for city in range(2, N+1): if distances[city] == float('inf'): result.append(-1) else: result.append(distances[city]) return result"},{"question":"def square_odds(lst: List[int]) -> List[int]: Returns a new list containing the square of each number in the original list if the squared value is an odd number. >>> square_odds([1, 2, 3, 4, 5]) [1, 9, 25] >>> square_odds([0, 2, 8, 15, 23]) [225, 529] >>> square_odds([2, 4, 6, 8, 10]) [] >>> square_odds([1, 3, 5, 7, 9]) [1, 9, 25, 49, 81] >>> square_odds([]) [] >>> square_odds([-1, -2, -3, -4, -5]) [1, 9, 25]","solution":"def square_odds(lst): Returns a new list containing the square of each number in the original list if the squared value is an odd number. return [x**2 for x in lst if (x**2) % 2 != 0]"},{"question":"from typing import List def trap_water(height: List[int]) -> int: Calculate the total amount of trapped water given the heights of towers. Args: height (List[int]): An array of non-negative integers representing tower heights. Returns: int: Total amount of trapped water. Examples: >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9 pass # Unit tests def test_trap_water_no_towers(): assert trap_water([]) == 0 def test_trap_water_single_tower(): assert trap_water([1]) == 0 def test_trap_water_two_towers(): assert trap_water([1, 2]) == 0 def test_trap_water_standard_case(): assert trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_water_flat_surface(): assert trap_water([3, 3, 3, 3, 3]) == 0 def test_trap_water_v_shape(): assert trap_water([3, 0, 3]) == 3 def test_trap_water_increasing_height(): assert trap_water([1,2,3,4,5]) == 0 def test_trap_water_decreasing_height(): assert trap_water([5,4,3,2,1]) == 0 def test_trap_water_valley(): assert trap_water([4,2,0,3,2,5]) == 9","solution":"def trap_water(height): Calculate the total amount of trapped water given the heights of towers. Args: height (List[int]): An array of non-negative integers representing tower heights. Returns: int: Total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n trapped_water = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> length_of_longest_substring(\\"bbbbb\\") == 1 # \\"b\\" >>> length_of_longest_substring(\\"pwwkew\\") == 3 # \\"wke\\" >>> length_of_longest_substring(\\"\\") == 0 # \\"\\" >>> length_of_longest_substring(\\"abcdefg\\") == 7 # \\"abcdefg\\" >>> length_of_longest_substring(\\"aaaaaa\\") == 1 # \\"a\\" >>> length_of_longest_substring(\\"dvdf\\") == 3 # \\"vdf\\"","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_subgrid_sum(grid): Returns the largest sum of any sub-grid within the grid. >>> max_subgrid_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 45 >>> max_subgrid_sum([[5]]) 5 >>> max_subgrid_sum([ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9]]) 9 >>> max_subgrid_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9]]) -1 >>> max_subgrid_sum([ ... [1000, 1000, 1000], ... [1000, 1000, 1000], ... [1000, 1000, 1000]]) 9000","solution":"def max_subgrid_sum(grid): Returns the largest sum of any sub-grid within the grid. if not grid or not grid[0]: return 0 N = len(grid) M = len(grid[0]) max_sum = float('-inf') for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += grid[i][right] current_sum = 0 local_max = float('-inf') for i in range(N): current_sum += temp[i] if current_sum > local_max: local_max = current_sum if current_sum < 0: current_sum = 0 if local_max > max_sum: max_sum = local_max return max_sum def read_grid_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [] line_index = 2 for _ in range(N): grid.append([int(data[line_index + i]) for i in range(M)]) line_index += M return grid if __name__ == \\"__main__\\": grid = read_grid_input() print(max_subgrid_sum(grid))"},{"question":"from typing import List, Union def divided_list(list1: List[float], list2: List[float]) -> List[Union[float, None]]: Perform element-wise division of two lists. If the lists are of different lengths, the result should only include divisions up to the length of the shorter list. If division by zero occurs, return None for that specific position. The function should return a new list with the division results. Example: >>> divided_list([10, 20, 30], [2, 5, 0]) [5.0, 4.0, None] >>> divided_list([9, 18, 27], [3, 3, 3, 4]) [3.0, 6.0, 9.0]","solution":"def divided_list(list1, list2): Perform element-wise division of two lists, up to the length of the shorter list. If division by zero occurs, return None for that specific position. result = [] for a, b in zip(list1, list2): if b == 0: result.append(None) else: result.append(a / b) return result"},{"question":"def get_top_student(students_scores): Returns the name of the student with the highest score. If there is a tie, returns the name of the student that appears first in the list. If the input list is empty, returns an empty string. Parameters: students_scores (list): A list of tuples where each tuple contains a student's name and their score. Returns: str: The name of the student with the highest score. >>> get_top_student([(\\"John\\", 85)]) \\"John\\" >>> get_top_student([(\\"John\\", 85), (\\"Alice\\", 92), (\\"Charlie\\", 78)]) \\"Alice\\" >>> get_top_student([(\\"John\\", 85), (\\"Alice\\", 92), (\\"Bob\\", 92), (\\"Charlie\\", 78)]) \\"Alice\\" >>> get_top_student([]) \\"\\" >>> get_top_student([(\\"John\\", 80), (\\"Alice\\", 80), (\\"Charlie\\", 80)]) \\"John\\" >>> get_top_student([(\\"Alice\\", 92), (\\"Bob\\", 92)]) \\"Alice\\" >>> get_top_student([(\\"Zack\\", 50), (\\"Yuki\\", 99), (\\"Alice\\", 78), (\\"Bob\\", 63), (\\"Charlie\\", 95)]) \\"Yuki\\"","solution":"def get_top_student(students_scores): Returns the name of the student with the highest score. If there is a tie, returns the name of the student that appears first in the list. If the input list is empty, returns an empty string. Parameters: students_scores (list): A list of tuples where each tuple contains a student's name and their score. Returns: str: The name of the student with the highest score. if not students_scores: return \\"\\" # Using max with a key to find the tuple with the highest score top_student = max(students_scores, key=lambda student: student[1]) return top_student[0]"},{"question":"from typing import List def validate_checkboxes(N: int, selected_checkboxes: List[int]) -> bool: Validates the list of selected checkboxes according to the following rules: 1. Each checkbox identifier should be an integer between 1 and N (inclusive). 2. Each identifier should appear at most once in the list. :param N: int - the highest number identifier available. :param selected_checkboxes: List[int] - the list of selected checkbox identifiers. :return: bool - True if the list is valid, False otherwise. >>> validate_checkboxes(5, [1, 2, 3]) True >>> validate_checkboxes(5, [1, 2, 6]) False >>> validate_checkboxes(5, [1, 2, 2]) False","solution":"from typing import List def validate_checkboxes(N: int, selected_checkboxes: List[int]) -> bool: Validates the list of selected checkboxes according to the following rules: 1. Each checkbox identifier should be an integer between 1 and N (inclusive). 2. Each identifier should appear at most once in the list. :param N: int - the highest number identifier available. :param selected_checkboxes: List[int] - the list of selected checkbox identifiers. :return: bool - True if the list is valid, False otherwise. if len(selected_checkboxes) != len(set(selected_checkboxes)): return False for checkbox in selected_checkboxes: if not (1 <= checkbox <= N): return False return True"},{"question":"def running_total(lst: List[int]) -> List[int]: Given a list of integers, returns a new list where each element at index i is the sum of the elements from the original list up to and including index i. >>> running_total([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_total([1, -1, 2, -2, 3, -3]) [1, 0, 2, 0, 3, 0] >>> running_total([0, 0, 0, 0]) [0, 0, 0, 0] >>> running_total([]) [] >>> running_total([5]) [5] >>> running_total([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> running_total([1000, 2000, 3000]) [1000, 3000, 6000]","solution":"def running_total(lst): Given a list of integers, returns a new list where each element at index i is the sum of the elements from the original list up to and including index i. result = [] total_sum = 0 for num in lst: total_sum += num result.append(total_sum) return result"},{"question":"from typing import List def most_frequent_word(titles: List[str]) -> str: Returns the most frequently occurring word in a list of book titles. If there is a tie, return the lexicographically smallest word. :param titles: List of book titles as strings. :return: The most frequently occurring word, case-insensitive. >>> most_frequent_word([\\"The Great Gatsby\\", \\"In Search of Lost Time\\", \\"The Great Alone\\", \\"Great Expectations\\"]) 'great' >>> most_frequent_word([\\"The Time Machine\\", \\"A Brief History of Time\\", \\"The Great Alone\\", \\"Are We Alone In The Universe\\"]) 'the' >>> most_frequent_word([\\"alpha beta\\", \\"beta gamma\\", \\"gamma alpha\\"]) 'alpha'","solution":"from collections import Counter def most_frequent_word(titles): Returns the most frequently occurring word in a list of book titles. If there is a tie, return the lexicographically smallest word. words = [] for title in titles: words.extend(title.lower().split()) word_counts = Counter(words) most_common = word_counts.most_common() max_frequency = most_common[0][1] frequent_words = [word for word, count in most_common if count == max_frequency] return min(frequent_words)"},{"question":"from typing import List def max_consecutive_sum(arr: List[int], k: int) -> int: Find the maximum sum of exactly \`k\` consecutive elements in the array. If the array has fewer than \`k\` elements, return 0. >>> max_consecutive_sum([1, 2, 5, 2, 8, 1, 5], 2) 10 >>> max_consecutive_sum([1, 2, 5, 2, 8, 1, 5], 4) 17 >>> max_consecutive_sum([1, 2, 5, 2, 8, 1, 5], 1) 8 >>> max_consecutive_sum([4, 2, 1, 6], 1) 6 >>> max_consecutive_sum([4, 2, 1, 6, 2], 4) 13 >>> max_consecutive_sum([], 3) 0","solution":"from typing import List def max_consecutive_sum(arr: List[int], k: int) -> int: Find the maximum sum of exactly \`k\` consecutive elements in the array. If the array has fewer than \`k\` elements, return 0. if len(arr) < k: return 0 # Compute the initial window sum max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window across the array and update the sums for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"import heapq class ProductReviewMedian: Class to continually compute the median of product ratings as new ratings are added. Example Usage: >>> prm = ProductReviewMedian() >>> prm.add_rating(3) >>> prm.get_median() == 3.0 True >>> prm.add_rating(5) >>> prm.get_median() == 4.0 True >>> prm.add_rating(4) >>> prm.get_median() == 4.0 True >>> prm.add_rating(2) >>> prm.get_median() == 3.5 True >>> prm.add_rating(5) >>> prm.get_median() == 4.0 True >>> prm.add_rating(1) >>> prm.get_median() == 3.5 True def __init__(self): self.min_heap = [] self.max_heap = [] def add_rating(self, rating: int): Add a new rating to the stream of ratings. :param rating: int - The new rating to add, from 1 to 5 inclusive. def get_median(self) -> float: Get the current median of the ratings. :return: float - The current median rating.","solution":"import heapq class ProductReviewMedian: def __init__(self): self.min_heap = [] self.max_heap = [] def add_rating(self, rating: int): if len(self.max_heap) == 0 or rating <= -self.max_heap[0]: heapq.heappush(self.max_heap, -rating) else: heapq.heappush(self.min_heap, rating) # Balance the heaps if needed if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def get_median(self) -> float: if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return float(-self.max_heap[0])"},{"question":"def sum_of_digit_factorials(n: int) -> int: Write a function that takes an integer n as input and returns the sum of the factorials of its digits. The function should first calculate the factorial for each digit in the number, and then return the sum of these factorials. You are not allowed to use any built-in factorial function. Example: >>> sum_of_digit_factorials(123) 9 >>> sum_of_digit_factorials(405) 145","solution":"def factorial(digit: int) -> int: Returns the factorial of a given digit. if digit == 0 or digit == 1: return 1 result = 1 for i in range(2, digit + 1): result *= i return result def sum_of_digit_factorials(n: int) -> int: Returns the sum of the factorials of the digits of an integer n. sum_factorials = 0 for digit in str(n): sum_factorials += factorial(int(digit)) return sum_factorials"},{"question":"def zigzag_pattern(n: int) -> str: Generates a zigzag pattern of numbers where each number alternates between left-aligned and right-aligned within a grid of size n by n. >>> zigzag_pattern(5) ' 1n2 n 3n4 n 5' >>> zigzag_pattern(8) ' 1n2 n 3n4 n 5n6 n 7n8 ' >>> zigzag_pattern(0) '' >>> zigzag_pattern(1) '1' >>> zigzag_pattern(-1) ''","solution":"def zigzag_pattern(n): Generates a zigzag pattern of numbers where each number alternates between left-aligned and right-aligned within a grid of size n by n. if n < 1: return \\"\\" result = [] for i in range(1, n + 1): if (i - 1) % 2 == 0: result.append(f\\"{i:>{n}}\\") else: result.append(f\\"{i:<{n}}\\") return 'n'.join(result)"},{"question":"def double_char(s: str) -> str: Takes in a string and returns a new string where every character in the original string is duplicated. >>> double_char(\\"hello\\") 'hheelllloo' >>> double_char(\\"123!\\") '112233!!' >>> double_char(\\" \\") ' ' >>> double_char(\\"aBc\\") 'aaBBcc'","solution":"def double_char(s): Takes in a string and returns a new string where every character in the original string is duplicated. Parameters: s (str): the input string Returns: str: the modified string with each character duplicated return ''.join([char * 2 for char in s])"},{"question":"def max_area_dimensions(P: int) -> tuple: Given the perimeter P, return the dimensions (length, width) that give the maximum area. >>> max_area_dimensions(20) (5, 5) >>> max_area_dimensions(4) (1, 1) >>> max_area_dimensions(6) (1, 2) >>> max_area_dimensions(10000) (2500, 2500) >>> max_area_dimensions(21) (5, 5) # or (6, 4) >>> max_area_dimensions(30) (7, 8) >>> max_area_dimensions(50) (12, 13)","solution":"def max_area_dimensions(P): Given the perimeter P, return the dimensions (length, width) that give the maximum area. max_area = 0 best_dimensions = (0, 0) for length in range(1, P // 2): width = (P // 2) - length area = length * width if area > max_area: max_area = area best_dimensions = (length, width) return best_dimensions"},{"question":"def has_duplicates(lst: List[int]) -> bool: Check whether a list of integers contains any duplicate elements. >>> has_duplicates([1, 2, 3, 4, 5]) False >>> has_duplicates([1, 2, 3, 2, 5]) True >>> has_duplicates([]) False >>> has_duplicates([7]) False >>> has_duplicates([1, 2, 2, 3, 3, 4, 4, 5, 5]) True >>> has_duplicates([1, 1, 1, 1, 1]) True >>> large_list = list(range(10000)) + [9999] >>> has_duplicates(large_list) True","solution":"def has_duplicates(lst): Returns True if there are duplicate elements in the list, otherwise False. return len(lst) != len(set(lst))"},{"question":"def load_ship(container_weights: List[int], max_capacity: int) -> List[int]: Organizes the loading sequence of containers into a ship without exceeding the maximum weight capacity. >>> load_ship([10, 20, 5, 15, 25], 40) [10, 20, 5] >>> load_ship([7, 3, 2, 5, 8], 10) [7, 3] >>> load_ship([5, 4, 3, 2, 1], 15) [5, 4, 3, 2, 1] >>> load_ship([], 50) []","solution":"def load_ship(container_weights, max_capacity): Organizes the loading sequence of containers into a ship without exceeding the maximum weight capacity. Parameters: container_weights (list of int): List of container weights. max_capacity (int): Maximum weight capacity of the ship. Returns: list of int: Weights of the containers that can be loaded without exceeding the capacity. current_weight = 0 loaded_containers = [] for weight in container_weights: if current_weight + weight > max_capacity: break loaded_containers.append(weight) current_weight += weight return loaded_containers"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings with the same length, the one which appears first is returned. >>> longest_unique_substring('abcabcbb') 'abc' >>> longest_unique_substring('bbbbb') 'b' >>> longest_unique_substring('pwwkew') 'wke'","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings with the same length, the one which appears first is returned. if not s: return \\"\\" # Dictionary to store the last positions of each character last_seen = {} start = 0 max_length = 0 start_index = 0 for i, char in enumerate(s): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length start_index = start return s[start_index:start_index + max_length]"},{"question":"def circular_shift(lst: List[int], shifts: int) -> List[int]: Write a function called \`circular_shift\` which takes in two parameters: a list of integers \`lst\` and an integer \`shifts\`. The function should return a new list where each element of the input list \`lst\` is circularly shifted to the right by the number of positions specified by \`shifts\`. If \`shifts\` is negative, the elements should be shifted to the left. Note that the number of shifts can be greater than the length of the list. Here are a few examples: >>> circular_shift([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_shift([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> circular_shift([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> circular_shift([1, 2, 3, 4, 5], -7) [3, 4, 5, 1, 2] n = len(lst) if n == 0: return lst shifts = shifts % n # Normalize shifts to be within the bounds of the list length return lst[-shifts:] + lst[:-shifts]","solution":"def circular_shift(lst, shifts): Returns a new list where each element of the input list lst is circularly shifted to the right by the number of positions specified by shifts. If shifts is negative, the elements should be shifted to the left. :param lst: List of integers to be shifted :param shifts: Number of positions to shift the list :return: Circularly shifted list n = len(lst) if n == 0: return lst shifts = shifts % n # Normalize shifts to be within the bounds of the list length return lst[-shifts:] + lst[:-shifts]"},{"question":"def first_missing_positive(nums: List[int]) -> int: Return the smallest positive integer that is not present in the given list. Args: nums (List[int]): A list of non-negative integers. Returns: int: The smallest positive integer that is not present in the list. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3","solution":"def first_missing_positive(nums): Return the smallest positive integer that is not present in the given list. n = len(nums) # Base case if n == 0: return 1 # Step 1: Replace non-positive numbers and numbers larger than n with a number > n for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the list indices as a hash to record the presence of numbers for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first positive number's index for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def is_valid_ipv4_address(address: str) -> bool: Check if the given address is a valid IPv4 address. Parameters: address (str): The IPv4 address to validate Returns: bool: True if the address is valid, False otherwise >>> is_valid_ipv4_address(\\"192.168.1.1\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"123.045.067.089\\") False >>> is_valid_ipv4_address(\\"256.256.256.256\\") False >>> is_valid_ipv4_address(\\"1.1.1.1\\") True from solution import is_valid_ipv4_address def test_valid_ipv4_addresses(): assert is_valid_ipv4_address(\\"192.168.1.1\\") == True assert is_valid_ipv4_address(\\"255.255.255.255\\") == True assert is_valid_ipv4_address(\\"0.0.0.0\\") == True assert is_valid_ipv4_address(\\"1.2.3.4\\") == True def test_invalid_ipv4_addresses(): assert is_valid_ipv4_address(\\"123.045.067.089\\") == False # Leading zeros assert is_valid_ipv4_address(\\"256.256.256.256\\") == False # Out of range assert is_valid_ipv4_address(\\"192.168.1.1.1\\") == False # Too many segments assert is_valid_ipv4_address(\\"192.168.1\\") == False # Too few segments assert is_valid_ipv4_address(\\"192.168.1.a\\") == False # Non-digit characters assert is_valid_ipv4_address(\\".168.1.1\\") == False # Missing segment assert is_valid_ipv4_address(\\"192.168.1.\\") == False # Trailing dot assert is_valid_ipv4_address(\\"192..1.1\\") == False # Double dot assert is_valid_ipv4_address(\\"-1.168.1.1\\") == False # Negative number def test_valid_ipv4_edge_cases(): assert is_valid_ipv4_address(\\"0.0.0.0\\") == True assert is_valid_ipv4_address(\\"1.1.1.1\\") == True assert is_valid_ipv4_address(\\"127.0.0.1\\") == True","solution":"def is_valid_ipv4_address(address): Check if the given address is a valid IPv4 address. Parameters: address (str): The IPv4 address to validate Returns: bool: True if the address is valid, False otherwise parts = address.split(\\".\\") if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False if part.startswith('0') and len(part) > 1: return False if not 0 <= int(part) <= 255: return False return True"},{"question":"def isPathPossible(grid): Determines if there is a path from the top-left to the bottom-right in a given grid. Args: grid (List[List[int]]): 2D list representing the grid map Returns: bool: True if there is a path from the top-left to the bottom-right, else False Examples: >>> grid = [ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ] >>> isPathPossible(grid) True >>> grid = [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 1, 0] ... ] >>> isPathPossible(grid) False >>> grid = [[0]] >>> isPathPossible(grid) True >>> grid = [[1]] >>> isPathPossible(grid) False >>> grid = [ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> isPathPossible(grid) True >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 1, 0] ... ] >>> isPathPossible(grid) False >>> grid = [ ... [0, 0, 0], ... [0, 0, 1], ... [0, 0, 1] ... ] >>> isPathPossible(grid) False","solution":"def isPathPossible(grid): Determines if there is a path from the top-left to the bottom-right in a given grid. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False from collections import deque n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n - 1, m - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Returns True if num is a prime number, otherwise False. >>> is_prime(1) == False >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False # Implement the function to check if a number is prime def count_primes_in_subarray(array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array and a list of queries, returns a list of counts of prime numbers in the subarrays defined by the queries. >>> array = [2, 3, 4, 5, 6] >>> queries = [(1, 3), (2, 5), (1, 5)] >>> count_primes_in_subarray(array, queries) == [2, 2, 3] >>> array = [10, 11, 12, 13, 14, 15] >>> queries = [(1, 2), (3, 6), (1, 6)] >>> count_primes_in_subarray(array, queries) == [1, 1, 2] >>> array = [29, 30, 33, 37] >>> queries = [(1, 1), (1, 4), (3, 4)] >>> count_primes_in_subarray(array, queries) == [1, 2, 1] >>> array = [4, 6, 8, 9, 10] >>> queries = [(1, 5)] >>> count_primes_in_subarray(array, queries) == [0] # Implement the function to count primes in subarrays","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def count_primes_in_subarray(array, queries): Given an array and a list of queries, returns a list of counts of prime numbers in the subarrays defined by the queries. # Precompute prime status for each element in the array prime_flags = [is_prime(num) for num in array] results = [] for L, R in queries: # Convert 1-based indices to 0-based indices L, R = L - 1, R - 1 # Count primes in the subarray prime_count = sum(prime_flags[L:R + 1]) results.append(prime_count) return results"},{"question":"def check_subarray_sum(nums: List[int], k: int) -> bool: Determines whether there exists a continuous subarray of at least two elements that sums up to k. Parameters: - nums (List[int]): A list of integers - k (int): The target sum Returns: - bool: True if such a subarray exists, otherwise False. Examples: >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False >>> check_subarray_sum([1, 0, 0, 0, 1], 0) True","solution":"def check_subarray_sum(nums, k): Determines whether there exists a continuous subarray of at least two elements that sums up to k. Parameters: - nums (List[int]): A list of integers - k (int): The target sum Returns: - bool: True if such a subarray exists, otherwise False. if len(nums) < 2: return False sum_map = {0: -1} running_sum = 0 for i, num in enumerate(nums): running_sum += num if k != 0: remainder = running_sum % k else: remainder = running_sum if remainder in sum_map: if i - sum_map[remainder] > 1: return True else: sum_map[remainder] = i return False"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an array of unique integers sorted in ascending order, find the smallest missing positive integer. >>> first_missing_positive([1, 2, 6, 7, 9, 10]) == 3 >>> first_missing_positive([1, 2, 3, 4, 5]) == 6 >>> first_missing_positive([2, 3, 4, 5, 6]) == 1 >>> first_missing_positive([]) == 1 >>> first_missing_positive([1]) == 2 >>> first_missing_positive([2]) == 1 >>> first_missing_positive([3, 4, -1, 1]) == 2 >>> first_missing_positive([7, 8, 9, 11, 12]) == 1 >>> first_missing_positive([1, 2, 3, 4, 5, 7, 8, 9, 10, 11]) == 6 >>> first_missing_positive([100, 200, 300, 400]) == 1 >>> first_missing_positive([1, 1, 1, 1]) == 2 >>> first_missing_positive([1, 2, 2, 2]) == 3 >>> first_missing_positive([-1, -2, 1, 3, 4]) == 2 pass","solution":"def first_missing_positive(nums): Given an array of unique integers sorted in ascending order, find the smallest missing positive integer. if not nums: return 1 n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def find_single_element(nums: List[int]) -> int: Given an array of integers where each element appears exactly twice, except for one element which appears exactly once, find that single element. The function must run in O(n) time complexity and use only O(1) extra space. Examples: >>> find_single_element([4, 1, 2, 1, 2]) 4 >>> find_single_element([2, 2, 1]) 1","solution":"def find_single_element(nums): Returns the single element in the array where each element appears exactly twice except for one. The function runs in O(n) time complexity and uses O(1) extra space. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"def can_form_arithmetic_progression(nums: List[int]) -> bool: Determines if the list forms an arithmetic progression after permuting its elements. >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 2, 4]) False","solution":"from typing import List def can_form_arithmetic_progression(nums: List[int]) -> bool: Determines if the list forms an arithmetic progression after permuting its elements. if len(nums) < 2: return False nums.sort() diff = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != diff: return False return True"},{"question":"def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer. :param s: A string representing a Roman numeral. :return: An integer equivalent of the Roman numeral. >>> roman_to_int('I') 1 >>> roman_to_int('IV') 4 >>> roman_to_int('MCMXCIV') 1994","solution":"def roman_to_int(s): Converts a Roman numeral to an integer. :param s: A string representing a Roman numeral. :return: An integer equivalent of the Roman numeral. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def is_perfect_power(n: int) -> bool: Returns True if the given number n is a perfect power, False otherwise. >>> is_perfect_power(4) True >>> is_perfect_power(6) False >>> is_perfect_power(27) True >>> is_perfect_power(9) True","solution":"import math def is_perfect_power(n): Returns True if the given number n is a perfect power, False otherwise. if n < 2: return False for base in range(2, int(math.sqrt(n)) + 1): exponent = 2 while base ** exponent <= n: if base ** exponent == n: return True exponent += 1 return False"},{"question":"def rotate(matrix: List[List[int]]) -> List[List[int]]: Rotates the given square matrix 90 degrees clockwise. >>> rotate([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"def rotate(matrix): Rotates the given square matrix 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def min_flips_to_palindrome(S: str) -> int: Returns the minimum number of flip operations required to turn S into a palindrome. >>> min_flips_to_palindrome(\\"aebcbda\\") == 2 >>> min_flips_to_palindrome(\\"racecar\\") == 0 >>> min_flips_to_palindrome(\\"ab\\") == 1 >>> min_flips_to_palindrome(\\"aaaa\\") == 0 >>> min_flips_to_palindrome(\\"a\\") == 0 >>> min_flips_to_palindrome(\\"abaxyzdcaba\\") == 4","solution":"def min_flips_to_palindrome(S): Returns the minimum number of flip operations required to turn S into a palindrome. n = len(S) # Initialize a 2D array to store the minimum flip operations required for substrings dp = [[0] * n for _ in range(n)] # Fill dp array for length in range(2, n + 1): # length of the current substring for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def smallest_balanced_substring_length(T: int, test_cases: List[str]) -> List[int]: Given a number of test cases and corresponding strings comprised of lowercase English letters, this function finds the length of the smallest balanced substring (one that contains equal numbers of 'a', 'b', 'c'). If no such substring exists, it returns -1 for that test case. >>> smallest_balanced_substring_length(3, [\\"abcabc\\", \\"abacbc\\", \\"aaaaaa\\"]) == [3, 3, -1] >>> smallest_balanced_substring_length(1, [\\"aaaaa\\"]) == [-1] >>> smallest_balanced_substring_length(1, [\\"abc\\"]) == [3] >>> smallest_balanced_substring_length(1, [\\"abcabcabc\\"]) == [3] >>> smallest_balanced_substring_length(1, [\\"aaabbcccaaa\\"]) == [6] >>> smallest_balanced_substring_length(2, [\\"abccbaabc\\", \\"abcbcba\\"]) == [3, 3]","solution":"def smallest_balanced_substring_length(T, test_cases): results = [] for s in test_cases: n = len(s) min_len = float('inf') # We use a sliding window approach for i in range(n): count = {'a': 0, 'b': 0, 'c': 0} for j in range(i, n): if s[j] in count: count[s[j]] += 1 if count['a'] == count['b'] == count['c']: min_len = min(min_len, j - i + 1) results.append(min_len if min_len != float('inf') else -1) return results"},{"question":"def longest_non_decreasing_sequence(measurements: List[Tuple[int, int]]) -> int: Determine the length of the longest continuous sequence of non-decreasing water levels for any particular reservoir. Parameters: measurements (list of tuples): list of pairs (reservoir_id, water_level) Returns: int: the length of the longest continuous non-decreasing sequence Examples: >>> longest_non_decreasing_sequence([(1, 5), (2, 6), (1, 7), (1, 4), (2, 5), (2, 7), (1, 8), (1, 9)]) 3 >>> longest_non_decreasing_sequence([(1, 5), (1, 4), (1, 3)]) 1 >>> longest_non_decreasing_sequence([(1, 1), (1, 2), (1, 3), (1, 4)]) 4 from typing import List, Tuple def test_sample_input(): measurements = [(1, 5), (2, 6), (1, 7), (1, 4), (2, 5), (2, 7), (1, 8), (1, 9)] assert longest_non_decreasing_sequence(measurements) == 3 def test_all_decreasing(): measurements = [(1, 5), (1, 4), (1, 3)] assert longest_non_decreasing_sequence(measurements) == 1 def test_all_increasing(): measurements = [(1, 1), (1, 2), (1, 3), (1, 4)] assert longest_non_decreasing_sequence(measurements) == 4 def test_mixed_sequences(): measurements = [(1, 5), (1, 6), (1, 5), (2, 7), (2, 8), (1, 3), (1, 4)] assert longest_non_decreasing_sequence(measurements) == 2 # Both reservoirs have max sequences of length 2 def test_empty_input(): measurements = [] assert longest_non_decreasing_sequence(measurements) == 0 def test_single_measurement(): measurements = [(1, 100)] assert longest_non_decreasing_sequence(measurements) == 1 def test_multiple_reservoirs(): measurements = [(1, 1), (2, 2), (1, 2), (2, 2), (1, 3)] assert longest_non_decreasing_sequence(measurements) == 3 # Reservoir 1 has a sequence of length 3: 1, 2, 3 def test_non_decreasing_with_gaps(): measurements = [(1, 1), (1, 2), (1, 3), (1, 1), (1, 2)] assert longest_non_decreasing_sequence(measurements) == 3 # The first sequence is the longest: 1, 2, 3","solution":"def longest_non_decreasing_sequence(measurements): Determine the length of the longest continuous sequence of non-decreasing water levels for any particular reservoir. Parameters: measurements (list of tuples): list of pairs (reservoir_id, water_level) Returns: int: the length of the longest continuous non-decreasing sequence if not measurements: return 0 # Dictionary to keep track of the maximum length for each reservoir reservoir_max_lengths = {} # Dictionary to keep track of the current length of non-decreasing sequence for each reservoir current_lengths = {} # Dictionary to keep the last seen water level for each reservoir last_levels = {} for reservoir_id, water_level in measurements: if reservoir_id not in current_lengths: current_lengths[reservoir_id] = 1 reservoir_max_lengths[reservoir_id] = 1 else: if water_level >= last_levels[reservoir_id]: current_lengths[reservoir_id] += 1 else: current_lengths[reservoir_id] = 1 reservoir_max_lengths[reservoir_id] = max(reservoir_max_lengths[reservoir_id], current_lengths[reservoir_id]) last_levels[reservoir_id] = water_level return max(reservoir_max_lengths.values())"},{"question":"def isScorePartitionable(difficulties: List[int], totalScore: int) -> bool: Determines if the provided list of difficulties can be partitioned into two non-empty parts with equal sums that add up to half of the totalScore. >>> isScorePartitionable([1, 2, 3, 4, 5, 5], 20) True >>> isScorePartitionable([1, 1, 3, 4, 7], 16) True >>> isScorePartitionable([2, 2, 2, 2, 2], 10) False >>> isScorePartitionable([], 0) False >>> isScorePartitionable([10], 10) False from typing import List def test_isScorePartitionable_example1(): assert isScorePartitionable([1, 2, 3, 4, 5, 5], 20) == True def test_isScorePartitionable_example2(): assert isScorePartitionable([1, 1, 3, 4, 7], 16) == True def test_isScorePartitionable_example3(): assert isScorePartitionable([2, 2, 2, 2, 2], 10) == False def test_isScorePartitionable_empty(): assert isScorePartitionable([], 0) == False def test_isScorePartitionable_one_element(): assert isScorePartitionable([10], 10) == False def test_isScorePartitionable_multiple_partitions(): assert isScorePartitionable([3, 1, 1, 2, 2, 1], 10) == True def test_isScorePartitionable_no_partitions(): assert isScorePartitionable([1, 5, 11, 5], 22) == True def test_isScorePartitionable_large_numbers(): assert isScorePartitionable([10, 20, 30, 40, 50], 150) == False","solution":"def isScorePartitionable(difficulties, totalScore): Determines if the provided list of difficulties can be partitioned into two non-empty parts with equal sums that add up to half of the totalScore. if totalScore % 2 != 0 or not difficulties: return False halfScore = totalScore // 2 n = len(difficulties) # Use a DP approach to find if halfScore is possible with subsets of difficulties dp = [False] * (halfScore + 1) dp[0] = True for difficulty in difficulties: for j in range(halfScore, difficulty - 1, -1): dp[j] = dp[j] or dp[j - difficulty] return dp[halfScore]"},{"question":"def find_max_happiness(N: int, M: int, happiness: List[int], roads: List[Tuple[int, int, int]]) -> int: Find the maximum possible happiness for a trip from city 1 to city N. >>> find_max_happiness(4, 4, [3, 2, 5, 10], [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 7)]) 14 >>> find_max_happiness(2, 1, [1, 1000], [(1, 2, 1)]) 1000 >>> find_max_happiness(5, 5, [10, 10, 10, 10, 10], [(1, 2, 1), (2, 5, 2), (1, 3, 1), (3, 4, 1), (4, 5, 1)]) 37 >>> find_max_happiness(3, 1, [5, 5, 5], [(1, 2, 10)]) float('-inf') >>> find_max_happiness(3, 2, [10, 20, 30], [(1, 2, 0), (2, 3, 0)]) 60 pass","solution":"import heapq def max_happiness(N, M, happiness, roads): graph = [[] for _ in range(N+1)] for u, v, cost in roads: graph[u].append((v, cost)) distance = [float('-inf')] * (N+1) distance[1] = happiness[0] pq = [(-happiness[0], 1)] while pq: current_happiness, u = heapq.heappop(pq) current_happiness = -current_happiness for v, cost in graph[u]: temp_happiness = current_happiness + happiness[v-1] - cost if temp_happiness > distance[v]: distance[v] = temp_happiness heapq.heappush(pq, (-temp_happiness, v)) return distance[N] # Function to parse the input format and call the max_happiness function def find_max_happiness(N, M, happiness, roads): return max_happiness(N, M, happiness, roads)"},{"question":"from typing import List, Tuple def has_topological_sort(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the given directed graph has a topological sort. Parameters: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int]]): List of directed edges. Returns: str: \\"YES\\" if a topological sort exists, otherwise \\"NO\\". Examples: >>> has_topological_sort(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> has_topological_sort(3, 3, [(1, 2), (2, 3), (3, 2)]) 'NO'","solution":"from collections import defaultdict, deque def has_topological_sort(n, m, edges): Determines if the given directed graph has a topological sort. Parameters: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int]]): List of directed edges. Returns: str: \\"YES\\" if a topological sort exists, otherwise \\"NO\\". # Create adjacency list and in-degree count adj_list = defaultdict(list) in_degree = [0] * (n + 1) # Build the graph for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Queue for vertices with no incoming edges zero_in_degree_queue = deque([v for v in range(1, n + 1) if in_degree[v] == 0]) visited_count = 0 while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() visited_count += 1 for neighbor in adj_list[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If we visited all vertices, there is no cycle, and a topological sort is possible if visited_count == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def relay_race_time(distances, speeds) -> float: Calculate the total time it will take for the team to complete the relay race. Args: distances (list): List of distances for each leg of the race. speeds (list): List of speeds for the runners in each leg. Returns: float: Total time to complete the race. Examples: >>> relay_race_time([400, 300, 500], [5, 6, 4]) 255.0 >>> relay_race_time([0, 300, 500], [5, 6, 4]) 175.0 >>> relay_race_time([100, 200, 300], [2, 2, 2]) 300.0 >>> relay_race_time([100], [5]) 20.0 >>> relay_race_time([100, 200, 300], [1, 2, 300]) 201.0 pass","solution":"def relay_race_time(distances, speeds) -> float: Calculate the total time it will take for the team to complete the relay race. Args: distances (list): List of distances for each leg of the race. speeds (list): List of speeds for the runners in each leg. Returns: float: Total time to complete the race. total_time = 0 for distance, speed in zip(distances, speeds): total_time += distance / speed return total_time"},{"question":"def is_balanced_parentheses(s: str) -> bool: Checks if the given parenthesis string is balanced. :param s: A string consisting of characters ()[]{} :return: True if the string is balanced, False otherwise >>> is_balanced_parentheses(\\"()\\") True >>> is_balanced_parentheses(\\"([])\\") True >>> is_balanced_parentheses(\\"([)]\\") False >>> is_balanced_parentheses(\\"{[()]}\\") True >>> is_balanced_parentheses(\\"{[}]\\") False","solution":"def is_balanced_parentheses(s): Checks if the given parenthesis string is balanced. :param s: A string consisting of characters ()[]{} :return: True if the string is balanced, False otherwise stack = [] matching_parenthesis = {')': '(', ']': '[', '}': '{'} for char in s: if char in '([{': stack.append(char) elif char in ')]}': if stack and stack[-1] == matching_parenthesis[char]: stack.pop() else: return False return not stack"},{"question":"def sum_of_digits_power(n: int) -> int: Returns the sum of the digits of n raised to the power of their respective positions. >>> sum_of_digits_power(123) 32 >>> sum_of_digits_power(1234) 288 >>> sum_of_digits_power(987) 992","solution":"def sum_of_digits_power(n): Returns the sum of the digits of n raised to the power of their respective positions. Parameters: n (int): A positive integer Returns: int: The sum of the digits raised to the power of their respective positions n_str = str(n) total_sum = 0 for idx, digit in enumerate(n_str): total_sum += int(digit) ** (idx + 1) return total_sum"},{"question":"def ocean_view_buildings(test_cases): Determine which buildings can view the ocean. >>> ocean_view_buildings([(6, [4, 2, 3, 1, 5, 8]), (5, [5, 4, 3, 2, 1])]) [\\"6\\", \\"1 2 3 4 5\\"] def parse_input(input_string): Parse the input string to extract test cases. >>> parse_input(\\"2n6n4 2 3 1 5 8n5n5 4 3 2 1\\") [(6, [4, 2, 3, 1, 5, 8]), (5, [5, 4, 3, 2, 1])] def ocean_view_buildings_from_input(input_string): Get ocean view buildings result from input string. >>> ocean_view_buildings_from_input(\\"2n6n4 2 3 1 5 8n5n5 4 3 2 1\\") [\\"6\\", \\"1 2 3 4 5\\"]","solution":"def ocean_view_buildings(test_cases): results = [] for buildings in test_cases: N, heights = buildings ocean_view_indexes = [] max_height_so_far = -1 for i in range(N - 1, -1, -1): if heights[i] > max_height_so_far: ocean_view_indexes.append(i + 1) max_height_so_far = heights[i] ocean_view_indexes.reverse() results.append(\\" \\".join(map(str, ocean_view_indexes))) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): N = int(lines[index].strip()) heights = list(map(int, lines[index + 1].strip().split())) test_cases.append((N, heights)) index += 2 return test_cases def ocean_view_buildings_from_input(input_string): test_cases = parse_input(input_string) return ocean_view_buildings(test_cases)"},{"question":"import math from typing import List def nearest_perfect_square(nums: List[int]) -> List[int]: Takes a list of non-negative integers and returns a new list where each element is replaced by the square root of the nearest perfect square. >>> nearest_perfect_square([0, 1, 2, 3, 4, 5, 15, 16, 17]) [0, 1, 1, 2, 2, 2, 4, 4, 4] >>> nearest_perfect_square([9, 10, 24, 25, 26]) [3, 3, 5, 5, 5] >>> nearest_perfect_square([36, 37, 49, 50, 64]) [6, 6, 7, 7, 8] >>> nearest_perfect_square([27, 28, 32, 33]) [5, 5, 6, 6] >>> nearest_perfect_square([65, 80, 99, 121]) [8, 9, 10, 11] >>> nearest_perfect_square([]) [] >>> nearest_perfect_square([8]) [3] >>> nearest_perfect_square([25]) [5] >>> nearest_perfect_square([18]) [4]","solution":"import math def nearest_perfect_square(nums): Takes a list of non-negative integers and returns a new list where each element is replaced by the square root of the nearest perfect square. def find_nearest_square(n): lower_sqrt = math.floor(math.sqrt(n)) upper_sqrt = lower_sqrt + 1 if abs(n - lower_sqrt**2) <= abs(n - upper_sqrt**2): return lower_sqrt else: return upper_sqrt return [find_nearest_square(num) for num in nums]"},{"question":"def execute_commands(commands: List[str]) -> Tuple[int, int]: Returns the final coordinates (x, y) after executing a list of movement commands. 'N' means move north (increase y by 1) 'S' means move south (decrease y by 1) 'E' means move east (increase x by 1) 'W' means move west (decrease x by 1) >>> execute_commands(['N', 'E', 'E', 'S', 'W', 'N']) == (1, 1) >>> execute_commands(['N']) == (0, 1) >>> execute_commands([]) == (0, 0)","solution":"def execute_commands(commands): Returns the final coordinates (x, y) after executing a list of movement commands. 'N' means move north (increase y by 1) 'S' means move south (decrease y by 1) 'E' means move east (increase x by 1) 'W' means move west (decrease x by 1) x, y = 0, 0 for command in commands: if command == 'N': y += 1 elif command == 'S': y -= 1 elif command == 'E': x += 1 elif command == 'W': x -= 1 return (x, y)"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. :param s: Input string :return: Longest palindromic substring >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. :param s: Input string :return: Longest palindromic substring if not s: return \\"\\" start, max_length = 0, 1 for i in range(1, len(s)): # Check for even-length palindromes (centered between i-1 and i) low, high = i - 1, i while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd-length palindromes (centered at i) low, high = i - 1, i + 1 while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start: start + max_length]"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using an optimized recursive approach with memoization. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025","solution":"def fibonacci(n): Returns the nth Fibonacci number using an optimized recursive approach with memoization. memo = {} def fib_helper(x): if x in memo: return memo[x] if x <= 1: return x result = fib_helper(x - 1) + fib_helper(x - 2) memo[x] = result return result return fib_helper(n)"},{"question":"def digital_root(n: int) -> int: Calculate the digital root of a non-negative integer. The digital root is the single-digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration to compute the sum of digits. The process continues until a single-digit number is observed. >>> digital_root(9875) 2 >>> digital_root(16) 7 >>> digital_root(942) 6 >>> digital_root(132189) 6 >>> digital_root(493193) 2","solution":"def digital_root(n): Returns the digital root of a non-negative integer n. The digital root is the single-digit value obtained by continuously summing the digits of n until a single-digit number is obtained. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def longest_zigzag_sequence(nums: List[int]) -> int: Returns the length of the longest zigzag sequence in the given list of integers. >>> longest_zigzag_sequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_sequence([1, 4, 7, 2, 5]) 4 >>> longest_zigzag_sequence([1, 7, 7, 2, 9]) 4","solution":"def longest_zigzag_sequence(nums): Returns the length of the longest zigzag sequence in the given list of integers. n = len(nums) if n < 2: return n up = [1] * n down = [1] * n for i in range(1, n): if nums[i] > nums[i-1]: up[i] = down[i-1] + 1 down[i] = down[i-1] elif nums[i] < nums[i-1]: down[i] = up[i-1] + 1 up[i] = up[i-1] else: up[i] = up[i-1] down[i] = down[i-1] return max(up[-1], down[-1])"},{"question":"from typing import List, Union def partitionEqualSums(nums: Union[List[int], any]) -> Union[bool, str]: Create a function that takes in a list of integers and determines if it is possible to partition the list into two sublists such that the sum of the elements in both sublists is equal. Returns True if nums can be partitioned into two sublists with equal sums, False otherwise. If the input is not a list of integers, returns \\"Not valid\\". >>> partitionEqualSums([1, 5, 11, 5]) True >>> partitionEqualSums([1, 2, 3, 5]) False >>> partitionEqualSums([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5]) True >>> partitionEqualSums([1, 2, 3, 7]) False >>> partitionEqualSums(\\"not a list\\") \\"Not valid\\" >>> partitionEqualSums([1, 2, \\"three\\"]) \\"Not valid\\" >>> partitionEqualSums(None) \\"Not valid\\" >>> partitionEqualSums(12345) \\"Not valid\\" >>> partitionEqualSums([]) True >>> partitionEqualSums([0, 0, 0, 0]) True >>> partitionEqualSums([1]) False >>> partitionEqualSums([1, 1, 1, 1, 2, 2, 2, 2]) True >>> partitionEqualSums([1, 2, 3, 4, 5, 5, 10]) True","solution":"def partitionEqualSums(nums): Returns True if nums can be partitioned into two sublists with equal sums, False otherwise. If the input is not a list of integers, returns \\"Not valid\\". if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): return \\"Not valid\\" total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a 2D DP array dp = [[False] * (target + 1) for _ in range(n + 1)] # Initialize the dp array for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, target + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]] return dp[n][target]"},{"question":"def merge_and_sort_unique(list1: List[int], list2: List[int]) -> List[int]: Merges two lists, removes duplicates, and returns a sorted list of unique elements. If either of the lists is empty, returns an empty list. >>> merge_and_sort_unique([1, 2, 3], [3, 4, 5]) == [1, 2, 3, 4, 5] >>> merge_and_sort_unique([7, 8], [9, 10, 7]) == [7, 8, 9, 10] >>> merge_and_sort_unique([1, 1, 1], [2, 2, 2]) == [1, 2] >>> merge_and_sort_unique([], [1, 2, 3]) == [] >>> merge_and_sort_unique([], []) == []","solution":"def merge_and_sort_unique(list1, list2): Merges two lists, removes duplicates, and returns a sorted list of unique elements. If either of the lists is empty, returns an empty list. if not list1 or not list2: return [] # Merge lists combined_list = list1 + list2 # Remove duplicates by converting to a set unique_elements = set(combined_list) # Convert back to list and sort sorted_unique_list = sorted(unique_elements) return sorted_unique_list"},{"question":"def find_tournament_winner(N: int, skills: List[int]) -> int: Determine the winner of the tournament based on player skills. >>> find_tournament_winner(1, [100]) == 1 >>> find_tournament_winner(2, [100, 200]) == 2 >>> find_tournament_winner(2, [200, 100]) == 1 >>> find_tournament_winner(4, [1, 4, 3, 2]) == 2 >>> find_tournament_winner(4, [5, 2, 6, 3]) == 3 >>> find_tournament_winner(8, [1, 16, 8, 4, 3, 9, 5, 2]) == 2 >>> find_tournament_winner(8, [10, 20, 30, 40, 50, 60, 70, 80]) == 8 >>> find_tournament_winner(4, [10, 30, 20, 40]) == 4 >>> find_tournament_winner(8, [8, 7, 6, 5, 4, 3, 2, 1]) == 1","solution":"def find_tournament_winner(N, skills): Determine the winner of the tournament based on player skills. Parameters: N (int): Number of players (always a power of 2). skills (list): List of skill levels of the players. Returns: int: 1-based index of the player who wins the tournament. players = list(range(N)) # Player indices (0-based) while len(players) > 1: next_round_players = [] for i in range(0, len(players), 2): # Player i vs Player i+1 if skills[players[i]] > skills[players[i + 1]]: next_round_players.append(players[i]) else: next_round_players.append(players[i + 1]) players = next_round_players return players[0] + 1 # Convert 0-based index to 1-based"},{"question":"import re def valid_palindromes(strings): Determine if each string in the array is a palindrome after removing all non-alphanumeric characters and converting to lowercase. Args: strings (list of str): Array of strings to be checked. Returns: list of bool: Corresponding booleans indicating if the string is a palindrome. Examples: >>> valid_palindromes([\\"A man, a plan, a canal: Panama\\", \\"race a car\\", \\" \\", \\"No lemon, no melon\\"]) [True, False, True, True] >>> valid_palindromes([\\"12321\\", \\"123456\\"]) [True, False]","solution":"import re def valid_palindromes(strings): Determine if each string in the array is a palindrome. Args: strings (list of str): Array of strings to be checked. Returns: list of bool: Corresponding booleans indicating if the string is a palindrome. results = [] for s in strings: # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is a palindrome results.append(cleaned == cleaned[::-1]) return results"},{"question":"def encrypt_message(S): Encrypts the message according to the described algorithm. Parameters: S (str): Lowercase alphabetic string. Returns: int: Encrypted sum. # Your code here def solve(T, test_cases): Solves the encryption for multiple test cases. Parameters: T (int): Number of test cases. test_cases (list): List of test case strings. Returns: list: List of encrypted sums for each test case. # Your code here # Example test cases def test_encrypt_message(): assert encrypt_message(\\"hello\\") == 184 assert encrypt_message(\\"world\\") == 378 assert encrypt_message(\\"a\\") == 1 assert encrypt_message(\\"abc\\") == 1 + 2 + 9 # a=1, b=2, c=3 -> c^2 assert encrypt_message(\\"abcd\\") == 1 + 2 + 9 + 4 # a=1, b=2, c=9, d=4 -> c squared def test_solve(): assert solve(2, [\\"hello\\", \\"world\\"]) == [184, 378] assert solve(3, [\\"a\\", \\"abc\\", \\"abcd\\"]) == [1, 12, 16] # running the tests when pytest module is available import pytest pytest.main()","solution":"def encrypt_message(S): Encrypts the message according to the described algorithm. Parameters: S (str): Lowercase alphabetic string. Returns: int: Encrypted sum. encrypted_sum = 0 for i, char in enumerate(S): value = ord(char) - ord('a') + 1 if (i + 1) % 3 == 0: value = value ** 2 encrypted_sum += value return encrypted_sum def solve(T, test_cases): results = [] for S in test_cases: results.append(encrypt_message(S)) return results"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, returns a new array where each element at index \`i\` is the product of all the numbers in the original array except the one at \`i\`. Aim for a solution that does not use division and runs in O(n) time. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([1, 2, 0, 4, 5]) [0, 0, 40, 0, 0] >>> product_except_self([10]) == [1] [1] >>> product_except_self([3, 7]) [7, 3] >>> product_except_self([-1, 1, -1, 1]) [-1, 1, -1, 1] >>> product_except_self([10**6, 10**8, 10**10]) [10**18, 10**16, 10**14]","solution":"def product_except_self(nums): Returns a list where each element at index i is the product of all the numbers in the input list except the number at index i. length = len(nums) answer = [1] * length # Calculate the prefix products prefix = 1 for i in range(length): answer[i] = prefix prefix *= nums[i] # Calculate the postfix products and multiply with the prefix products postfix = 1 for i in range(length - 1, -1, -1): answer[i] *= postfix postfix *= nums[i] return answer"},{"question":"def reverse_words(s: str) -> str: Returns the string with the order of words reversed. Arguments: s -- input string Returns: A string with words in reversed order. >>> reverse_words(\\" hello world \\") == \\"world hello\\" >>> reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" >>> reverse_words(\\"word\\") == \\"word\\" >>> reverse_words(\\" \\") == \\"\\" >>> reverse_words(\\"\\") == \\"\\"","solution":"def reverse_words(s): Returns the string with the order of words reversed. Arguments: s -- input string Returns: A string with words in reversed order. # Split the string by spaces to form words and filter out empty strings words = s.split() # Reverse the list of words words = words[::-1] # Join the reversed words with a single space and return return ' '.join(words)"},{"question":"def filter_even_numbers(lst): Returns a list containing only the even numbers from the input list. Parameters: lst (list of int): The list of integers to filter. Returns: list of int: A new list containing only the even integers from lst. Examples: >>> filter_even_numbers([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even_numbers([-10, -3, 0, 7, 15, 20]) [-10, 0, 20] >>> filter_even_numbers([1, 3, 5]) [] >>> filter_even_numbers([]) [] >>> filter_even_numbers([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10]","solution":"def filter_even_numbers(lst): Returns a list containing only the even numbers from the input list. Parameters: lst (list of int): The list of integers to filter. Returns: list of int: A new list containing only the even integers from lst. return [num for num in lst if num % 2 == 0]"},{"question":"[Completion Task in Python] def find_all_multiples(number: int, limit: int) -> List[int]: Returns a list of all multiples of the given number up to the specified limit. >>> find_all_multiples(2, 10) [2, 4, 6, 8, 10] >>> find_all_multiples(3, 15) [3, 6, 9, 12, 15]","solution":"def find_all_multiples(number, limit): Returns a list of all multiples of the given number up to the specified limit. if number <= 0 or limit < 0: return [] multiples = [] for i in range(number, limit + 1, number): multiples.append(i) return multiples"},{"question":"def has_pair_with_sum(arr: list[int], k: int) -> bool: Determines if there are two distinct indices in the array such that the sum of the elements at these indices is equal to k. Parameters: arr (list of int): The array of integers. k (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. # Your code here # Unit tests def test_has_pair_with_sum_exists(): arr = [1, 2, 3, 4, 5] k = 6 assert has_pair_with_sum(arr, k) == True def test_has_pair_with_sum_not_exists(): arr = [1, 2, 3, 4, 5] k = 10 assert has_pair_with_sum(arr, k) == False def test_empty_array(): arr = [] k = 5 assert has_pair_with_sum(arr, k) == False def test_single_element_array(): arr = [5] k = 5 assert has_pair_with_sum(arr, k) == False def test_all_pairs_match_target_sum(): arr = [3, 3, 3, 3] k = 6 assert has_pair_with_sum(arr, k) == True def test_large_numbers(): arr = [1000000000, 2000000000, -2000000000, -1000000000] k = 0 assert has_pair_with_sum(arr, k) == True def test_no_valid_pairs(): arr = [1, 1, 1, 1] k = 3 assert has_pair_with_sum(arr, k) == False","solution":"def has_pair_with_sum(arr, k): Determines if there are two distinct indices in the array such that the sum of the elements at these indices is equal to k. Parameters: arr (list of int): The array of integers. k (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: complement = k - num if complement in seen: return True seen.add(num) return False"},{"question":"def categorize_item(item_description: str, categories: dict) -> str: Categorize an item based on given keywords. Parameters: item_description (str): The description of the item. categories (dict): A dictionary where each key is a category name and each value is a list of keywords. Returns: str: The category name if a keyword matches, otherwise \\"Uncategorized\\". >>> categories = { ... \\"Electronics\\": [\\"laptop\\", \\"phone\\", \\"charger\\"], ... \\"Clothing\\": [\\"shirt\\", \\"pants\\", \\"jacket\\", \\"hat\\"], ... \\"Food\\": [\\"apple\\", \\"pizza\\", \\"bread\\"] ... } >>> categorize_item(\\"I need a new phone charger for my laptop\\", categories) \\"Electronics\\" >>> categorize_item(\\"I just bought a new hat and a jacket\\", categories) \\"Clothing\\" >>> categorize_item(\\"Pizza and bread are my favorite foods\\", categories) \\"Food\\" >>> categorize_item(\\"I am looking for a book to read\\", categories) \\"Uncategorized\\"","solution":"def categorize_item(item_description, categories): Categorize an item based on given keywords. Parameters: item_description (str): The description of the item. categories (dict): A dictionary where each key is a category name and each value is a list of keywords. Returns: str: The category name if a keyword matches, otherwise \\"Uncategorized\\". for category, keywords in categories.items(): for keyword in keywords: if keyword in item_description: return category return \\"Uncategorized\\""},{"question":"def sort_books(books): Sorts a list of books by their titles and returns the sorted list of IDs. :param books: List[Tuple[int, str]] - list of tuples where each tuple contains an integer ID and a string Title representing the book title. :return: List[int] - list of book IDs sorted by their titles. >>> sort_books([(1, \\"The Great Gatsby\\"), (2, \\"Moby Dick\\"), (3, \\"War and Peace\\"), (4, \\"1984\\")]) [4, 2, 1, 3] >>> sort_books([(1, \\"To Kill a Mockingbird\\"), (2, \\"Pride and Prejudice\\"), (3, \\"The Catcher in the Rye\\"), (4, \\"Jane Eyre\\")]) [4, 2, 3, 1] >>> sort_books([]) [] >>> sort_books([(1, \\"The Book Thief\\")]) [1] >>> sort_books([(1, \\"The Book\\"), (2, \\"The Book\\")]) [1, 2]","solution":"def sort_books(books): Sorts a list of books by their titles and returns the sorted list of IDs. :param books: List[Tuple[int, str]] - list of tuples where each tuple contains an integer ID and a string Title representing the book title. :return: List[int] - list of book IDs sorted by their titles. # Sort books by title sorted_books = sorted(books, key=lambda book: book[1]) # Extract IDs from sorted books sorted_ids = [book[0] for book in sorted_books] return sorted_ids"},{"question":"def final_position(commands: str) -> tuple: Calculates the final position of the robot given a series of movement commands. Parameters: commands (str): A string consisting of 'U', 'D', 'L', 'R' which represent Up, Down, Left, and Right moves. Returns: tuple: A tuple (x, y) representing the final coordinates after executing the commands. Examples: >>> final_position(\\"UUDDLRLR\\") (0, 0) >>> final_position(\\"UUDDLRRR\\") (2, 0) >>> final_position(\\"UUUUU\\") (0, 5) >>> final_position(\\"DDDDD\\") (0, -5) >>> final_position(\\"LLLLL\\") (-5, 0) >>> final_position(\\"RRRRR\\") (5, 0) >>> final_position(\\"ULDRULDR\\") (0, 0) >>> final_position(\\"UUUUDDDDLLLLRRRR\\") (0, 0) >>> final_position(\\"U\\") (0, 1) >>> final_position(\\"D\\") (0, -1) >>> final_position(\\"L\\") (-1, 0) >>> final_position(\\"R\\") (1, 0) >>> final_position(\\"U\\" * 500 + \\"D\\" * 500 + \\"L\\" * 300 + \\"R\\" * 300) (0, 0) pass","solution":"def final_position(commands: str) -> tuple: Calculates the final position of the robot given a series of movement commands. Parameters: commands (str): A string consisting of 'U', 'D', 'L', 'R' which represent Up, Down, Left, and Right moves. Returns: tuple: A tuple (x, y) representing the final coordinates after executing the commands. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"from typing import List, Tuple def most_popular_pizza(n: int, orders: List[Tuple[int, int]]) -> int: Determine the variety of pizza that has the highest total volume ordered. >>> most_popular_pizza(5, [(6, 1), (8, 2), (6, 1), (7, 3), (8, 2)]) 2 >>> most_popular_pizza(1, [(6, 1)]) 1","solution":"import math from collections import defaultdict def most_popular_pizza(n, orders): Returns the variety of pizza that has the highest total volume ordered. volumes = defaultdict(float) for radius, variety in orders: volume = math.pi * radius * radius * 1 # height is given as 1 unit volumes[variety] += volume # Find the variety with the highest total volume most_popular_variety = min(volumes, key=lambda k: (-volumes[k], k)) return most_popular_variety"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Given a list of integers, return the length of the longest sequence of consecutive elements. The sequence should be in increasing order and can be scattered but must be consecutive when considered numerically. The solution should have a time complexity of O(n). Args: nums (List[int]): List of integers. Returns: int: Length of the longest consecutive elements sequence. Example: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9","solution":"from typing import List def longest_consecutive(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # check if num is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def find_max_average(nums: List[int], k: int) -> float: Given an array of integers nums and an integer k, return the maximum average value of any subarray of size k. >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average([5, 5, 5, 5, 5, 5], 3) 5.0 >>> find_max_average([1, 1, 1, 1, 1, 1, 1, 1], 4) 1.0 >>> find_max_average([0, 4, 0, 3, 2], 1) 4.0 >>> find_max_average([3, 3, 4, 5, 2, 2, 2], 2) 4.5","solution":"def find_max_average(nums, k): Returns the maximum average value of any subarray of size k. # Calculate the sum of the first \`k\` elements. max_sum = current_sum = sum(nums[:k]) # Slide the window across the array to find the maximum sum of any subarray of size \`k\`. for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum # Return the maximum average. return max_sum / k"},{"question":"from typing import List def min_streetlights(housePositions: List[int], d: int) -> int: Returns the minimum number of streetlights needed to illuminate all houses. :param housePositions: List of integers representing house positions. :param d: Integer representing the range of each streetlight. :return: Integer representing the minimum number of streetlights needed. pass # Tests def test_min_streetlights(): assert min_streetlights([1, 2, 3, 6, 7], 2) == 2 assert min_streetlights([-5, 0, 3, 10, 12, 15], 3) == 3 assert min_streetlights([5], 1) == 1 assert min_streetlights([1, 100, 200, 300], 150) == 2 assert min_streetlights([], 5) == 0 assert min_streetlights([1, 2, 3, 4, 5], 5) == 1 assert min_streetlights([10, 10, 10, 10], 1) == 1 assert min_streetlights([1,10,20,30,40,50,60,70,80,90], 5) == 10","solution":"def min_streetlights(housePositions, d): Returns the minimum number of streetlights needed to illuminate all houses. :param housePositions: List of integers representing house positions. :param d: Integer representing the range of each streetlight. :return: Integer representing the minimum number of streetlights needed. if not housePositions: return 0 housePositions.sort() streetlights = 0 i = 0 n = len(housePositions) while i < n: streetlights += 1 position = housePositions[i] + d # place streetlight at the farthest position reachable by this house while i < n and housePositions[i] <= position: i += 1 if i < n: position = housePositions[i - 1] + d # adjust to cover the last house in the current range while i < n and housePositions[i] <= position: i += 1 return streetlights"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of a binary tree iteratively. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> inorder_traversal(root) [1, 3, 2] >>> root = TreeNode(1) >>> inorder_traversal(root) [1] >>> inorder_traversal(None) [] >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(1) >>> inorder_traversal(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> inorder_traversal(root) [1, 2, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of a binary tree iteratively. stack = [] current = root result = [] while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the total volume of water that can be trapped after rainfall. Args: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The total amount of water trapped after rainfall. Examples: >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_rain_water(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest possible number. :param nums: List of non-negative integers :return: Largest possible number in string format >>> largest_number([10, 2]) \\"210\\" >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([1]) \\"1\\" >>> largest_number([111, 111]) \\"111111\\" >>> largest_number([0, 0]) \\"0\\" >>> largest_number([0, 1]) \\"10\\" >>> largest_number([999, 9, 98, 97, 967]) \\"99999897967\\" >>> largest_number([]) \\"0\\" >>> largest_number([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) \\"9609938824824769735703560743981399\\"","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest possible number. :param nums: List of non-negative integers :return: Largest possible number in string format if not nums: return \\"0\\" def compare(a, b): if a + b > b + a: return -1 if a + b < b + a: return 1 return 0 nums = list(map(str, nums)) nums.sort(key=cmp_to_key(compare)) result = ''.join(nums) return '0' if result[0] == '0' else result"},{"question":"from collections import Counter def check_inclusion(s1: str, s2: str) -> bool: Checks if s2 contains any permutation of s1. >>> check_inclusion(\\"ab\\", \\"eidbaooo\\") True >>> check_inclusion(\\"ab\\", \\"eidboaoo\\") False >>> check_inclusion(\\"adc\\", \\"dcda\\") True >>> check_inclusion(\\"hello\\", \\"ooolleoooleh\\") False","solution":"from collections import Counter def check_inclusion(s1: str, s2: str) -> bool: Checks if s2 contains any permutation of s1. :param s1: Source string to find permutations of :param s2: Target string in which to find the permutations :return: True if any permutation of s1 is found in s2, False otherwise if len(s1) > len(s2): return False s1_count = Counter(s1) window_count = Counter(s2[:len(s1)]) if s1_count == window_count: return True for i in range(len(s1), len(s2)): new_char = s2[i] left_char = s2[i - len(s1)] window_count[new_char] += 1 window_count[left_char] -= 1 if window_count[left_char] == 0: del window_count[left_char] if window_count == s1_count: return True return False"},{"question":"def maxProfit(prices: List[int]) -> int: Given a list of daily prices of a stock, return the maximum profit you can achieve by buying and selling the stock at most two times. Note that you cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7,6,4,3,1]) 0 >>> maxProfit([5]) 0 >>> maxProfit([]) 0 >>> maxProfit([5, 5, 5, 5, 5]) 0 >>> maxProfit([1, 2, 3, 0, 2, 4]) 6","solution":"def maxProfit(prices): if not prices: return 0 first_buy = float('-inf') first_sell = 0 second_buy = float('-inf') second_sell = 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"def remove_duplicates_and_sort(arr: List[int]) -> List[int]: Returns a new list with duplicates removed and elements sorted in ascending order. >>> remove_duplicates_and_sort([3, 1, 4, 2, 2, 3, 1]) [1, 2, 3, 4] >>> remove_duplicates_and_sort([5, 9, 0, 6, 4, 9, 2, 7, 4]) [0, 2, 4, 5, 6, 7, 9] >>> remove_duplicates_and_sort([]) [] >>> remove_duplicates_and_sort([10]) [10]","solution":"def remove_duplicates_and_sort(arr): Returns a new list with duplicates removed and elements sorted in ascending order. return sorted(set(arr))"},{"question":"def aggregate_sales(sales_list): Given a list of sales data in the form \\"item:amount\\", returns a dictionary where keys are items and values are the sum of their sales amounts. >>> aggregate_sales([\\"apple:50\\", \\"banana:30\\", \\"apple:20\\", \\"apple:10\\", \\"banana:25\\"]) {\\"apple\\": 80, \\"banana\\": 55} >>> aggregate_sales([\\"orange:20\\", \\"apple:50\\", \\"banana:10\\", \\"apple:30\\", \\"orange:10\\"]) {\\"orange\\": 30, \\"apple\\": 80, \\"banana\\": 10} >>> aggregate_sales([\\"mango:60\\", \\"kiwi:20\\", \\"mango:10\\", \\"mango:30\\", \\"kiwi:10\\"]) {\\"mango\\": 100, \\"kiwi\\": 30} >>> aggregate_sales([\\"mango:60\\"]) {\\"mango\\": 60} >>> aggregate_sales([]) {} >>> aggregate_sales([\\"mango:0\\", \\"kiwi:0\\", \\"mango:0\\", \\"mango:0\\", \\"kiwi:0\\"]) {\\"mango\\": 0, \\"kiwi\\": 0}","solution":"def aggregate_sales(sales_list): Given a list of sales data in the form \\"item:amount\\", returns a dictionary where keys are items and values are the sum of their sales amounts. sales_dict = {} for sale in sales_list: item, amount = sale.split(':') amount = int(amount) if item in sales_dict: sales_dict[item] += amount else: sales_dict[item] = amount return sales_dict"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Implement a function that takes two strings and returns True if the strings are anagrams of each other (contain the same characters in the same frequency, but possibly in a different order), False otherwise. Spaces and capitalization should be ignored. Examples: is_anagram(\\"Listen\\", \\"Silent\\") => True is_anagram(\\"This is\\", \\"is This\\") => True is_anagram(\\"Hello\\", \\"Olelh\\") => True is_anagram(\\"Example\\", \\"Exemplary\\") => False","solution":"def is_anagram(s1, s2): Returns True if s1 and s2 are anagrams of each other, ignoring spaces and capitalization. # Remove spaces and convert to lowercase s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() # Check if sorted characters of both strings are the same return sorted(s1) == sorted(s2)"},{"question":"def encode_run_length(s: str) -> str: Returns the run-length encoding of the input string. >>> encode_run_length(\\"aaabbccc\\") 'a3b2c3' >>> encode_run_length(\\"aabbaa\\") 'a2b2a2' >>> encode_run_length(\\"abc\\") 'a1b1c1'","solution":"def encode_run_length(s): Returns the run-length encoding of the input string. if not s: return \\"\\" result = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: result.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 result.append(f\\"{prev_char}{count}\\") return ''.join(result)"},{"question":"def rearrange_unique_sorted(nums: List[int]) -> List[int]: Rearrange the input array such that each element appears exactly once and the output array is sorted in non-decreasing order. >>> rearrange_unique_sorted([4, 3, 2, 4, 1, 3, 2]) == [1, 2, 3, 4] >>> rearrange_unique_sorted([2, 1, 2, 1, 2, 1]) == [1, 2] >>> rearrange_unique_sorted([6, 5, 4, 4, 5, 6]) == [4, 5, 6] >>> rearrange_unique_sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> rearrange_unique_sorted([7, 7, 7, 7, 7]) == [7] >>> rearrange_unique_sorted([2, 3, 3, 4, 5, 5, 6]) == [2, 3, 4, 5, 6] >>> rearrange_unique_sorted([5]) == [5]","solution":"def rearrange_unique_sorted(nums): Rearrange the input array such that each element appears exactly once and the output array is sorted in non-decreasing order. return sorted(set(nums))"},{"question":"def available_drones(drones, package_weight, delivery_distance): Determines which drones can deliver a given package based on its weight and distance. Arguments: drones -- List of tuples, each containing two integers: weight capacity and maximum distance. package_weight -- An integer representing the weight of the package. delivery_distance -- An integer representing the distance to the delivery location. Returns: List of indices of the drones that can carry the package to the delivery location. If no drones can perform the delivery, returns an empty list. >>> available_drones([(10, 5), (20, 10)], 25, 15) == [] >>> available_drones([(30, 20), (40, 25), (50, 30)], 20, 15) == [0, 1, 2] >>> available_drones([(10, 5), (20, 10), (15, 12)], 12, 8) == [1, 2] >>> available_drones([(15, 15), (5, 5), (17, 18), (25, 30)], 15, 15) == [0, 2, 3]","solution":"def available_drones(drones, package_weight, delivery_distance): Determines which drones can deliver a given package based on its weight and distance. Arguments: drones -- List of tuples, each containing two integers: weight capacity and maximum distance. package_weight -- An integer representing the weight of the package. delivery_distance -- An integer representing the distance to the delivery location. Returns: List of indices of the drones that can carry the package to the delivery location. If no drones can perform the delivery, returns an empty list. suitable_drones = [] for index, (capacity, max_distance) in enumerate(drones): if package_weight <= capacity and delivery_distance <= max_distance: suitable_drones.append(index) return suitable_drones"},{"question":"def max_value_path_from_root(N, values, edges): Find the maximum value path in a Star Tree from the root Node 1 to any leaf node. >>> max_value_path_from_root(5, [3, 2, 1, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 10 >>> max_value_path_from_root(3, [1, 2, 3], [(1, 2), (2, 3)]) 6 >>> max_value_path_from_root(4, [1, 5, 5, 2], [(1, 2), (1, 3), (1, 4)]) 6 >>> max_value_path_from_root(6, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 21 >>> max_value_path_from_root(3, [5, 5, 5], [(1, 2), (1, 3)]) 10","solution":"def max_value_path_from_root(N, values, edges): from collections import defaultdict, deque # Build adjacency list tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # Values map value_map = {i + 1: values[i] for i in range(N)} # BFS to calculate the maximum value path from root to leaf def bfs(root): max_value_path = float('-inf') queue = deque([(root, value_map[root])]) visited = set([root]) while queue: node, current_value = queue.popleft() is_leaf = True for neighbor in tree[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_value + value_map[neighbor])) is_leaf = False if is_leaf: # If node is a leaf max_value_path = max(max_value_path, current_value) return max_value_path return bfs(1) # Test the implementation with the sample input N = 5 values = [3, 2, 1, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] print(max_value_path_from_root(N, values, edges)) # Expected output: 10"},{"question":"def findFirstUniqueChar(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. >>> findFirstUniqueChar(\\"leetcode\\") \\"l\\" >>> findFirstUniqueChar(\\"loveleetcode\\") \\"v\\" >>> findFirstUniqueChar(\\"aabbcc\\") \\"\\"","solution":"def findFirstUniqueChar(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. char_count = {} # Count occurrences of each character for char in s: char_count[char] = char_count.get(char, 0) + 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def calculate_trip_cost(d, p, r): Returns the total cost of a taxi trip given the distance d, price per unit distance p, and return price per unit distance r. The cost includes the trip to the customer's destination and the return trip to the starting location. >>> calculate_trip_cost(10, 2, 1) 30 >>> calculate_trip_cost(15, 3, 2) 75 pass def process_trip_costs(trips): Processes multiple trips to calculate the total cost for each one. trips: a list of tuples where each tuple contains (d, p, r) Returns a list of total costs for each trip. >>> process_trip_costs([(10, 2, 1), (15, 3, 2), (0, 0, 0)]) [30, 75] >>> process_trip_costs([(0, 0, 0)]) [] pass","solution":"def calculate_trip_cost(d, p, r): Returns the total cost of a taxi trip given the distance d, price per unit distance p, and return price per unit distance r. The cost includes the trip to the customer's destination and the return trip to the starting location. if d == 0 and p == 0 and r == 0: return 0 trip_cost = d * p return_cost = d * r return trip_cost + return_cost def process_trip_costs(trips): Processes multiple trips to calculate the total cost for each one. trips: a list of tuples where each tuple contains (d, p, r) Returns a list of total costs for each trip. result = [] for trip in trips: d, p, r = trip if d == 0 and p == 0 and r == 0: break result.append(calculate_trip_cost(d, p, r)) return result"},{"question":"def single_number(nums: List[int]) -> int: Given an array of integers where each integer appears exactly twice except for one, which appears exactly once, this method finds the single integer that does not have a duplicate. Args: nums (list of int): A list of integers. Returns: int: The single integer that does not have a duplicate. >>> single_number([2, 2, 1, 4, 4, 3, 3]) 1 >>> single_number([7]) 7 >>> single_number([1, 1, 2]) 2 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1000, 1001, 1000, 1001, 5000]) 5000 >>> single_number([-1, -1, -2, -3, -3]) -2","solution":"def single_number(nums): Given an array of integers where each integer appears exactly twice except for one, which appears exactly once, this method finds the single integer that does not have a duplicate. Args: nums (list of int): A list of integers. Returns: int: The single integer that does not have a duplicate. result = 0 for num in nums: result ^= num return result"},{"question":"from typing import List, Tuple def can_connect_all_stations(N: int, M: int, pathways: List[Tuple[int, int]]) -> str: Determines if all charging stations can be connected directly or indirectly. Parameters: N (int): The number of solar charging stations. M (int): The number of bidirectional pathways. pathways (List[Tuple[int, int]]): List of pathways between stations. Returns: str: \\"YES\\" if all stations are connected, otherwise \\"NO\\". Unit Test: from solution import can_connect_all_stations def test_can_connect_all_stations_sample_1(): N = 4 M = 2 pathways = [(1, 2), (3, 4)] assert can_connect_all_stations(N, M, pathways) == \\"NO\\" def test_can_connect_all_stations_sample_2(): N = 5 M = 4 pathways = [(1, 2), (2, 3), (3, 4), (4, 5)] assert can_connect_all_stations(N, M, pathways) == \\"YES\\" def test_can_connect_all_stations_single_station(): N = 1 M = 0 pathways = [] assert can_connect_all_stations(N, M, pathways) == \\"YES\\" def test_can_connect_all_stations_disconnected_network(): N = 6 M = 3 pathways = [(1, 2), (2, 3), (4, 5)] assert can_connect_all_stations(N, M, pathways) == \\"NO\\" def test_can_connect_all_stations_all_connected(): N = 6 M = 5 pathways = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert can_connect_all_stations(N, M, pathways) == \\"YES\\"","solution":"def can_connect_all_stations(N, M, pathways): Determines if all charging stations can be connected directly or indirectly. Parameters: N (int): The number of solar charging stations. M (int): The number of bidirectional pathways. pathways (List[Tuple[int, int]]): List of pathways between stations. Returns: str: \\"YES\\" if all stations are connected, otherwise \\"NO\\". from collections import defaultdict, deque if N == 1: return \\"YES\\" # Create an adjacency list graph = defaultdict(list) for u, v in pathways: graph[u].append(v) graph[v].append(u) # Perform BFS or DFS to check connectivity visited = [False] * (N + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) bfs(1) # Check if all stations have been visited if all(visited[1:N+1]): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Given an integer array nums of length n, find all possible subsets (the power set). >>> subsets([1,2,3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> subsets([1,2,2]) [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]] The solution set must not contain duplicate subsets. def test_empty_set(): assert subsets([]) == [[]] def test_single_element(): assert subsets([1]) == [[], [1]] def test_two_elements(): result = subsets([1, 2]) expected = [[], [1], [2], [1, 2]] assert sorted(result) == sorted(expected) def test_three_elements(): result = subsets([1, 2, 3]) expected = [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert sorted(result) == sorted(expected) def test_duplicates(): result = subsets([1, 2, 2]) expected = [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]] assert all(sub in expected for sub in result) and all(sub in result for sub in expected)","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Given an integer array nums, returns all possible subsets (the power set). result = [] n = len(nums) def backtrack(start, path): result.append(path) for i in range(start, n): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"def book_tickets(available_seats, requests, partial=False): Simulates a simple train ticket booking system. Parameters: available_seats (int): Number of available seats. requests (list): List of requests, each request is a positive integer. partial (bool): If partial fulfillment is allowed. Default is False. Returns: list: Fulfillment status of each request. >>> book_tickets(10, [3, 4, 5]) [3, 4, 0] >>> book_tickets(10, [3, 4, 5], partial=True) [3, 4, 3] >>> book_tickets(5, [6, 1, 2], partial=False) [0, 1, 2] >>> book_tickets(5, [6, 1, 2], partial=True) [5, 0, 0] >>> book_tickets(20, [2, 5, 7, 3], partial=False) [2, 5, 7, 3] >>> book_tickets(0, [1, 2, 3], partial=False) [0, 0, 0] >>> book_tickets(5, [3, 3], partial=True) [3, 2]","solution":"def book_tickets(available_seats, requests, partial=False): Simulates a simple train ticket booking system. Parameters: available_seats (int): Number of available seats. requests (list): List of requests, each request is a positive integer. partial (bool): If partial fulfillment is allowed. Default is False. Returns: list: Fulfillment status of each request. results = [] for request in requests: if request <= available_seats: results.append(request) available_seats -= request elif partial and available_seats > 0: results.append(available_seats) available_seats = 0 else: results.append(0) return results"},{"question":"def longest_diagonal_pattern(matrix: List[List[int]]) -> int: Returns the length of the longest contiguous diagonal pattern of a single color in an N x N matrix. Args: matrix (List[List[int]]): 2D list representing the N x N tile colors. Returns: int: Maximum length of contiguous diagonal pattern of a single color. Examples: >>> longest_diagonal_pattern([ ... [1, 2, 3, 4, 5], ... [6, 1, 7, 8, 9], ... [10, 11, 1, 12, 13], ... [14, 15, 16, 1, 17], ... [18, 19, 20, 21, 1] ... ]) == 5 >>> longest_diagonal_pattern([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> longest_diagonal_pattern([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 1 >>> longest_diagonal_pattern([ ... [1] ... ]) == 1 >>> longest_diagonal_pattern([ ... [1, 2], ... [3, 4] ... ]) == 1 >>> longest_diagonal_pattern([[1 if i == j else 2 for j in range(1000)] for i in range(1000)]) == 1000","solution":"def longest_diagonal_pattern(matrix): Returns the length of the longest contiguous diagonal pattern of a single color in an N x N matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) max_length = 1 for i in range(n): length = 1 current_color = matrix[i][i] for k in range(1, n - i): if matrix[i + k][i + k] == current_color: length += 1 max_length = max(max_length, length) else: current_color = matrix[i + k][i + k] length = 1 return max_length"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, some of which may be zero, returns an array such that each element at index \`i\` of the output array is equal to the product of all the elements in the input array except for the element at \`i\`. Args: nums (List[int]): The input list of integers. Returns: List[int]: The output list where each element is the product of all elements in the input list except the one at the same index. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] pass def test_product_except_self_basic(): nums = [1, 2, 3, 4] expected = [24, 12, 8, 6] assert product_except_self(nums) == expected def test_product_except_self_with_zeros(): nums = [0, 1, 2, 3] expected = [6, 0, 0, 0] assert product_except_self(nums) == expected def test_product_except_self_all_zeros(): nums = [0, 0, 0, 0] expected = [0, 0, 0, 0] assert product_except_self(nums) == expected def test_product_except_self_single_element(): nums = [42] expected = [1] assert product_except_self(nums) == expected def test_product_except_self_negative_numbers(): nums = [-1, -2, -3, -4] expected = [-24, -12, -8, -6] assert product_except_self(nums) == expected def test_product_except_self_mixed_numbers(): nums = [-1, 2, -3, 4] expected = [-24, 12, -8, 6] assert product_except_self(nums) == expected def test_product_except_self_empty_list(): nums = [] expected = [] assert product_except_self(nums) == expected def test_product_except_self_large(): nums = [2, 3, 4, 5] expected = [60, 40, 30, 24] assert product_except_self(nums) == expected","solution":"def product_except_self(nums): Returns an array such that each element at index \`i\` of the output array is equal to the product of all the elements in the input array except for the element at \`i\`. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Fill left_products such that left_products[i] contains product of all elements to the left of nums[i] for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products such that right_products[i] contains product of all elements to the right of nums[i] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Fill result array such that result[i] is product of left_products[i] and right_products[i] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def ranked_students(students: List[str]) -> List[str]: Each student in a class has received a unique identifier consisting of lowercase letters ('a' to 'z'). The class has a well-defined rule where a student can only move up in rank if the sum of the alphabetical positions of the letters in their identifier is greater than the sum of the letters in any of their predecessor's identifiers. Write a function, ranked_students(students), which takes a list of student identifiers and returns a list where the students are arranged in their correct ranks based on the class rule described above. >>> ranked_students([\\"abc\\", \\"abd\\", \\"aaa\\"]) [\\"aaa\\", \\"abc\\", \\"abd\\"] >>> ranked_students([\\"abc\\"]) [\\"abc\\"] >>> ranked_students([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) [\\"aaa\\", \\"aaa\\", \\"aaa\\"] >>> ranked_students([\\"a\\", \\"abc\\", \\"abcd\\"]) [\\"a\\", \\"abc\\", \\"abcd\\"] >>> ranked_students([\\"z\\", \\"y\\", \\"x\\"]) [\\"x\\", \\"y\\", \\"z\\"] pass","solution":"def alphabetical_sum(identifier): Returns the sum of alphabetical positions of the characters in the identifier. return sum(ord(char) - ord('a') + 1 for char in identifier) def ranked_students(students): Returns a list of students sorted based on the sum of the alphabetical positions of their identifiers. # Pair each student with their sum paired_students = [(student, alphabetical_sum(student)) for student in students] # Sort students based on their sum # If two students have the same sum, they remain in their original order paired_students.sort(key=lambda x: x[1]) # Extracting the sorted students return [student for student, _ in paired_students]"},{"question":"def fizzbuzz(n: int) -> str: Returns a string of numbers from 1 to n where multiples of 3 are replaced by 'Fizz', multiples of 5 are replaced by 'Buzz', and multiples of both 3 and 5 are replaced by 'FizzBuzz'. >>> fizzbuzz(1) \\"1\\" >>> fizzbuzz(3) \\"1,2,Fizz\\" >>> fizzbuzz(5) \\"1,2,Fizz,4,Buzz\\" >>> fizzbuzz(15) \\"1,2,Fizz,4,Buzz,Fizz,7,8,Fizz,Buzz,11,Fizz,13,14,FizzBuzz\\"","solution":"def fizzbuzz(n): Returns a string of numbers from 1 to n where multiples of 3 are replaced by 'Fizz', multiples of 5 are replaced by 'Buzz', and multiples of both 3 and 5 are replaced by 'FizzBuzz'. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return ','.join(result)"},{"question":"def find_first_event_timestamp(logs: List[str], event: str) -> str: Finds the timestamp of the first occurrence of the specified event in the logs. :param logs: List of strings representing log entries in the format \\"hh:mm:ss event\\". :param event: The event name to search for. :return: The time stamp of the first occurrence of the event or \\"Event not found\\" if the event does not exist. >>> find_first_event_timestamp([\\"09:00:00 start\\", \\"09:10:00 process\\", \\"09:20:00 finish\\"], \\"process\\") \\"09:10:00\\" >>> find_first_event_timestamp([\\"09:00:00 start\\", \\"09:10:00 start\\", \\"09:20:00 finish\\"], \\"execute\\") \\"Event not found\\" def test_find_first_event_timestamp(): assert find_first_event_timestamp([\\"09:00:00 start\\", \\"09:10:00 process\\", \\"09:20:00 finish\\"], \\"process\\") == \\"09:10:00\\" assert find_first_event_timestamp([\\"09:00:00 start\\", \\"09:10:00 start\\", \\"09:20:00 finish\\"], \\"execute\\") == \\"Event not found\\" assert find_first_event_timestamp([\\"09:00:00 start\\", \\"09:10:00 process\\", \\"09:20:00 process\\"], \\"process\\") == \\"09:10:00\\" assert find_first_event_timestamp([], \\"process\\") == \\"Event not found\\" assert find_first_event_timestamp([\\"09:00:00 start work\\", \\"09:10:00 start meeting\\", \\"09:20:00 finish work\\"], \\"start meeting\\") == \\"09:10:00\\"","solution":"def find_first_event_timestamp(logs, event): Finds the timestamp of the first occurrence of the specified event in the logs. :param logs: List of strings representing log entries in the format \\"hh:mm:ss event\\". :param event: The event name to search for. :return: The time stamp of the first occurrence of the event or \\"Event not found\\" if the event does not exist. for log in logs: timestamp, log_event = log.split(' ', 1) if log_event == event: return timestamp return \\"Event not found\\""},{"question":"def can_squirrels_hop_to_each_other(n: int, squirrels: List[Tuple[int, int]]) -> str: Returns 'YES' if there exists a pair of squirrels that can hop to each other's starting tree, otherwise 'NO'. n: number of squirrels squirrels: list of tuples containing the positions and distances of each squirrel >>> can_squirrels_hop_to_each_other(3, [(2, 3), (5, -3), (8, 5)]) 'YES' >>> can_squirrels_hop_to_each_other(2, [(1, 2), (4, 3)]) 'NO'","solution":"def can_squirrels_hop_to_each_other(n, squirrels): Returns 'YES' if there exists a pair of squirrels that can hop to each other's starting tree, otherwise 'NO'. n: number of squirrels squirrels: list of tuples containing the positions and distances of each squirrel positions = {} # Create a map of tree positions and the squirrels and their respective hop distances for p, d in squirrels: if p not in positions: positions[p] = [] positions[p].append(d) # Check each tree if a squirrel can hop to another tree and vice versa for p, hops in positions.items(): for d in hops: target_position = p + d if target_position in positions: opposite_hop = -d if opposite_hop in positions[target_position]: return \\"YES\\" return \\"NO\\""},{"question":"def reverse_alternate_words(s: str) -> str: Reverse every second word in a given string. >>> reverse_alternate_words(\\"Hello World from CodeWars\\") \\"Hello dlroW from sraWedoC\\" >>> reverse_alternate_words(\\"Hello World from CodeWars writing more tests\\") \\"Hello dlroW from sraWedoC writing erom tests\\"","solution":"def reverse_alternate_words(s): Reverse every second word in the given string. Parameters: s (str): the input string containing words. Returns: str: the modified string with every second word reversed. words = s.split() for i in range(1, len(words), 2): words[i] = words[i][::-1] return ' '.join(words)"},{"question":"def process_list(lst): Given a list, if all values are numbers, return the list sorted in ascending order. If only one value is not a number, replace it with 0, then return the sorted list. If more than one value is not a number, return 'Invalid input!'. Examples: >>> process_list([3, 1, 4, 2]) [1, 2, 3, 4] >>> process_list([3, 1, 'a', 2]) [0, 1, 2, 3] >>> process_list([3, 'a', 'b', 2]) 'Invalid input!'","solution":"def process_list(lst): Given a list, if all values are numbers, return the list sorted in ascending order. If only one value is not a number, replace it with 0, then return the sorted list. If more than one value is not a number, return 'Invalid input!'. non_number_count = sum(1 for item in lst if not isinstance(item, (int, float))) if non_number_count == 0: return sorted(lst) elif non_number_count == 1: lst = [0 if not isinstance(item, (int, float)) else item for item in lst] return sorted(lst) else: return 'Invalid input!'"},{"question":"def product_excluding_extremes(arr): Given an array of integers, return the product of all the numbers except the largest and smallest elements (considered by value, not index). If the array has duplicates of the largest or smallest value, only exclude one instance of each. If the array is empty, null, or contains less than three elements, return 1. Examples: >>> product_excluding_extremes([6, 2, 1, 8, 10]) 96 >>> product_excluding_extremes([1, 1, 11, 2, 3]) 6 >>> product_excluding_extremes([5]) 1","solution":"def product_excluding_extremes(arr): Returns the product of all numbers in the array excluding the smallest and largest elements. If the array is empty, null, or contains less than three elements, return 1. if arr is None or len(arr) < 3: return 1 sorted_arr = sorted(arr) return product(sorted_arr[1:-1]) def product(lst): Returns the product of the list elements. result = 1 for num in lst: result *= num return result"},{"question":"def flatten_dict(d, parent_key='', sep='_') -> dict: Flatten a nested dictionary where keys at different levels are concatenated by an underscore ('_') indicating the nesting levels. Parameters: d (dict): The nested dictionary to flatten. parent_key (str): The base key used in recursive calls. sep (str): Separator between keys. Returns: dict: A flattened dictionary. >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}}) {'a': 1, 'b_c': 2, 'b_d_e': 3, 'b_d_f': 4} >>> flatten_dict({\\"x\\": 10, \\"y\\": {\\"z\\": 20}}) {'x': 10, 'y_z': 20} >>> flatten_dict({}) {}","solution":"def flatten_dict(d, parent_key='', sep='_'): Flatten a nested dictionary where keys at different levels are concatenated by an underscore ('_') indicating the nesting levels. Parameters: d (dict): The nested dictionary to flatten. parent_key (str): The base key used in recursive calls. sep (str): Separator between keys. Returns: dict: A flattened dictionary. items = [] for k, v in d.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(sorted(items))"},{"question":"def reverse_words(s: str) -> str: This function reverses the characters of each word in a string while maintaining the original word order and spaces. For example: >>> reverse_words(\\"Hello World!\\") --> \\"olleH !dlroW\\" >>> reverse_words(\\"The quick brown fox\\") --> \\"ehT kciuq nworb xof\\" >>> reverse_words(\\"Code is fun\\") --> \\"edoC si nuf\\" >>> reverse_words(\\"Python 3\\") --> \\"nohtyP 3\\" Note: - Input will be a single string containing words and spaces. - There will be at least one word in the string. - You need to preserve the leading and trailing spaces, if any, and also preserve the spaces between the words.","solution":"def reverse_words(s): This function reverses the characters of each word in a string while maintaining the original word order and spaces. Parameters: s (str): The input string containing words and spaces. Returns: str: The modified string with each word's characters reversed. # Split the input string into words words = s.split(' ') # Reverse the characters of each word reversed_words = [word[::-1] for word in words] # Join the reversed words with spaces return ' '.join(reversed_words)"},{"question":"def check_tree_uniqueness(n: int, b: List[int]) -> str: Determines if a tree sequence can produce a unique rooted tree or if it is possible to reorder the children at some nodes to produce another rooted tree with the same sequence but not isomorphic to the original tree. Parameters: n (int): number of vertices in the tree b (list of int): sequence of integers representing number of branches at each vertex Returns: str: \\"unique\\" if there exists only one such tree, otherwise \\"ambiguous\\" >>> check_tree_uniqueness(5, [1, 1, 1, 1, 0]) 'unique' >>> check_tree_uniqueness(7, [3, 2, 0, 1, 0, 0, 0]) 'ambiguous' >>> check_tree_uniqueness(3, [1, 1, 0]) 'unique' >>> check_tree_uniqueness(6, [1, 2, 1, 0, 0, 1]) 'ambiguous' >>> check_tree_uniqueness(2, [0, 1]) 'unique' >>> check_tree_uniqueness(4, [1, 2, 0, 1]) 'ambiguous'","solution":"def check_tree_uniqueness(n, b): Determines if a tree sequence can produce a unique rooted tree or if it is possible to reorder the children at some nodes to produce another rooted tree with the same sequence but not isomorphic to the original tree. Parameters: n (int): number of vertices in the tree b (list of int): sequence of integers representing number of branches at each vertex Returns: str: \\"unique\\" if there exists only one such tree, otherwise \\"ambiguous\\" # Find any node with more than one branch where the previous node also has at least one branch. for i in range(1, n): if b[i] > 1 and b[i - 1] > 0: return \\"ambiguous\\" return \\"unique\\""},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, this function returns a list where each value indicates the number of days until a warmer temperature is recorded. If no future warmer temperature is available, the value is set to 0. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 99, 98, 97, 96]) == [0, 0, 0, 0, 0] >>> daily_temperatures([70, 71, 72, 73, 74]) == [1, 1, 1, 1, 0] >>> daily_temperatures([75, 75, 75, 75, 75]) == [0, 0, 0, 0, 0] >>> daily_temperatures([70, 80, 70, 80, 70]) == [1, 0, 1, 0, 0]","solution":"def daily_temperatures(temperatures): Given a list of daily temperatures, this function returns a list where each value indicates the number of days until a warmer temperature is recorded. If no future warmer temperature is available, the value is set to 0. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def fibonacci(n: int) -> List[int]: Create a function that accepts an integer \`n\` and returns a list of the first \`n\` numbers in the Fibonacci sequence. The Fibonacci sequence starts with 0 and 1, with each subsequent number being the sum of the two preceding ones. Ensure that your solution handles edge cases such as \`n <= 0\`. >>> fibonacci(0) [] >>> fibonacci(-5) [] >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n numbers in the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fib_seq = [0, 1] for i in range(2, n): next_fib = fib_seq[-1] + fib_seq[-2] fib_seq.append(next_fib) return fib_seq"},{"question":"class Account: def __init__(self, initial_balance): Initialize the account with the given initial balance. Args: initial_balance (int): Starting balance of the account. self.balance = initial_balance def process_transactions(self, transactions): Process a list of deposit and withdrawal transactions and return the final account balance. Args: transactions (List[str]): List of transactions where 'D' represents a deposit and 'W' represents a withdrawal, each followed by an integer amount. Returns: int: Final balance after processing all transactions. >>> account = Account(1000) >>> account.process_transactions([\\"D200\\", \\"W100\\", \\"W300\\", \\"D400\\"]) 1200 >>> account = Account(5000) >>> account.process_transactions([\\"W1000\\", \\"D3000\\", \\"W4000\\", \\"D200\\"]) 2200 for transaction in transactions: if transaction[0] == 'D': amount = int(transaction[1:]) self.balance += amount elif transaction[0] == 'W': amount = int(transaction[1:]) self.balance -= amount return self.balance","solution":"class Account: def __init__(self, initial_balance): self.balance = initial_balance def process_transactions(self, transactions): for transaction in transactions: if transaction[0] == 'D': amount = int(transaction[1:]) self.balance += amount elif transaction[0] == 'W': amount = int(transaction[1:]) self.balance -= amount return self.balance"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the order of the parentheses in the given string is valid. :param s: A string containing only parentheses '()'. :return: True if the parentheses are properly nested and ordered, else False. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"())\\") False >>> is_valid_parentheses(\\"((()))\\") True >>> is_valid_parentheses(\\"\\") True","solution":"def is_valid_parentheses(s): Determines if the order of the parentheses in the given string is valid. :param s: A string containing only parentheses '()'. :return: True if the parentheses are properly nested and ordered, else False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack or stack.pop() != '(': return False return not stack"},{"question":"def canFormWord(letters: str, word: str) -> bool: Check if a word can be formed using the exact count of letters from a set of characters. Args: letters (str): A string containing available characters. word (str): The target word to form. Returns: bool: True if the word can be formed, False otherwise. >>> canFormWord(\\"aabbcc\\", \\"abc\\") True >>> canFormWord(\\"aabbcc\\", \\"aabbc\\") True >>> canFormWord(\\"aabbcc\\", \\"aabbccc\\") False >>> canFormWord(\\"aabbcc\\", \\"d\\") False >>> canFormWord(\\"aAbBcC\\", \\"abc\\") True >>> canFormWord(\\"AaBbCc\\", \\"AAbC\\") True >>> canFormWord(\\"aaBBcc\\", \\"ABC\\") True >>> canFormWord(\\"aabb\\", \\"aabbb\\") False >>> canFormWord(\\"xyz\\", \\"xyzz\\") False >>> canFormWord(\\"pqrst\\", \\"qrstp\\") True >>> canFormWord(\\"ppqqrr\\", \\"pqr\\") True >>> canFormWord(\\"abc\\", \\"\\") True >>> canFormWord(\\"\\", \\"\\") True >>> canFormWord(\\"\\", \\"a\\") False >>> canFormWord(\\"aabbccdd\\", \\"abc\\") True >>> canFormWord(\\"abcdefg\\", \\"gfedcba\\") True >>> canFormWord(\\"extraletters\\", \\"star\\") True >>> canFormWord(\\"aabbcc!!\\", \\"abc!\\") True >>> canFormWord(\\"aabbcc!!\\", \\"abc!!\\") True >>> canFormWord(\\"aabbcc!!\\", \\"abc!!!\\") False","solution":"from collections import Counter def canFormWord(letters, word): Check if a word can be formed using the exact count of letters from a set of characters. Args: letters (str): A string containing available characters. word (str): The target word to form. Returns: bool: True if the word can be formed, False otherwise. letters_count = Counter(letters.lower()) word_count = Counter(word.lower()) for char in word_count: if word_count[char] > letters_count.get(char, 0): return False return True"},{"question":"def isRobotBounded(instuctions: str) -> bool: Determines if the robot will return to the origin after performing the instructions infinitely many times. >>> isRobotBounded(\\"GGLLGG\\") True >>> isRobotBounded(\\"GG\\") False >>> isRobotBounded(\\"GL\\") True >>> isRobotBounded(\\"GLGLGLGL\\") True >>> isRobotBounded(\\"G\\") False >>> isRobotBounded(\\"LRLR\\") True >>> isRobotBounded(\\"GRGRGRGR\\") True >>> isRobotBounded(\\"GLGLGRGRLL\\") True >>> isRobotBounded(\\"LLLL\\") True","solution":"def isRobotBounded(instructions): Determines if the robot returns to the origin after performing the instructions infinitely many times. Directions: 0 -> north, 1 -> east, 2 -> south, 3 -> west x, y = 0, 0 # Initial position at origin direction = 0 # Initially facing north # Maps direction to coordinate change directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for instruction in instructions: if instruction == 'G': x += directions[direction][0] y += directions[direction][1] elif instruction == 'L': direction = (direction + 3) % 4 # Turning left means counterclockwise elif instruction == 'R': direction = (direction + 1) % 4 # Turning right means clockwise # Return to origin or not facing north means it will be in a loop return (x == 0 and y == 0) or (direction != 0)"},{"question":"def is_valid_url(url: str) -> bool: Validate whether the given string is a properly formatted URL. >>> is_valid_url(\\"http://www.example.com\\") True >>> is_valid_url(\\"https://sub.domain.example.com\\") True >>> is_valid_url(\\"http://example.co.uk/path?query=123#fragment\\") True >>> is_valid_url(\\"htt://example.com\\") False >>> is_valid_url(\\"http://example\\") False >>> is_valid_url(\\"example.com\\") False","solution":"import re def is_valid_url(url: str) -> bool: Validate whether the given string is a properly formatted URL. :param url: URL string to validate. :return: True if valid, False otherwise. regex = re.compile( r'^(https?://)' # http:// or https:// r'(([a-z0-9]+(-[a-z0-9]+)*.)+[a-z]{2,})' # domain name r'(:d+)?' # optional port r'(/[-a-z0-9%@_.+~#=]*)*' # path r'(?[;&a-z0-9%@_.,~+=-]*)?' # query parameters r'(#[-a-z0-9_]*)?', # fragment re.IGNORECASE) return re.match(regex, url) is not None"},{"question":"def custom_split(input_string: str, separator: str) -> List[str]: Splits the input_string into an array of words using the given separator. >>> custom_split(\\"apple,banana,orange\\", ',') == ['apple', 'banana', 'orange'] >>> custom_split(\\"apple banana orange\\", ' ') == ['apple', 'banana', 'orange'] >>> custom_split(\\"applebanan\\", ',') == ['applebanan'] >>> custom_split(\\"\\", ',') == [''] >>> custom_split(\\"apple,,orange\\", ',') == ['apple', '', 'orange'] >>> custom_split(\\",apple,banana,\\", ',') == ['', 'apple', 'banana', ''] pass # Implement the function body here","solution":"def custom_split(input_string, separator): Splits the input_string into an array of words using the given separator. result = [] current_word = \\"\\" for char in input_string: if char == separator: result.append(current_word) current_word = \\"\\" else: current_word += char result.append(current_word) return result"},{"question":"def min_cost_to_make_palindrome(S: str) -> int: Returns the minimum cost to make the string S into a palindrome. >>> min_cost_to_make_palindrome(\\"abca\\") 1 >>> min_cost_to_make_palindrome(\\"abc\\") 1 >>> min_cost_to_make_palindrome(\\"a\\") 0 >>> min_cost_to_make_palindrome(\\"aa\\") 0 >>> min_cost_to_make_palindrome(\\"ab\\") 1 >>> min_cost_to_make_palindrome(\\"abba\\") 0 >>> min_cost_to_make_palindrome(\\"abcba\\") 0 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the results of the minimum cost to make each string a palindrome. >>> process_test_cases(2, [\\"abca\\", \\"abc\\"]) [1, 1] >>> process_test_cases(3, [\\"a\\", \\"ab\\", \\"abc\\"]) [0, 1, 1] >>> process_test_cases(1, [\\"abcd\\"]) [2] >>> process_test_cases(2, [\\"racecar\\", \\"civic\\"]) [0, 0]","solution":"def min_cost_to_make_palindrome(S): Returns the minimum cost to make the string S into a palindrome. n = len(S) cost = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: cost += 1 return cost def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(min_cost_to_make_palindrome(S)) return results"},{"question":"def longest_same_parity_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray where all elements have the same parity. >>> longest_same_parity_subarray([1, 2, 2, 4, 6, 3, 3, 5, 7]) 4 >>> longest_same_parity_subarray([1, 3, 5, 7, 9]) 5 # Write code here.","solution":"def longest_same_parity_subarray(arr): Returns the length of the longest contiguous subarray where all elements have the same parity. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if (arr[i] % 2) == (arr[i-1] % 2): current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def checkSubarraySum(nums: List[int], k: int) -> bool: Determines if there is a continuous subarray of length at least 2 that sums up to a multiple of k. >>> checkSubarraySum([23, 2, 4, 6, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 13) False >>> checkSubarraySum([0, 0], 0) True >>> checkSubarraySum([0, 1], 0) False >>> checkSubarraySum([23, 2, 4, 6, 7], -6) True >>> checkSubarraySum([], 6) False >>> checkSubarraySum([6], 6) False","solution":"def checkSubarraySum(nums, k): Determines if there is a continuous subarray of length at least 2 that sums up to a multiple of k. Parameters: nums (List[int]): An array of integers. k (int): An integer k. Returns: bool: True if such subarray exists, otherwise False. if k == 0: return any(sum(nums[i:i + 2]) == 0 for i in range(len(nums) - 1)) cumulative_sum = 0 mod_dict = {0: -1} for i, num in enumerate(nums): cumulative_sum += num mod = cumulative_sum % k if mod in mod_dict: if i - mod_dict[mod] > 1: return True else: mod_dict[mod] = i return False"},{"question":"class ArrayOperations: def __init__(self, array): self.array = array self.n = len(array) self.prefix_sum = self.build_prefix_sum(array) def build_prefix_sum(self, array): Build prefix sum array for the input array. prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] return prefix_sum def update(self, index, value): Update the element at the given index to the new value. def range_sum(self, left, right): Return the sum of elements in the specified range. def process_queries(n, array, queries): Process a series of update and range sum queries on the array. >>> n = 5 >>> array = [1, 2, 3, 4, 5] >>> queries = [ (2, 1, 3), (1, 2, 10), (2, 1, 3), (1, 5, -4), (2, 3, 5) ] >>> process_queries(n, array, queries) [6, 14, 3]","solution":"class ArrayOperations: def __init__(self, array): self.array = array self.n = len(array) self.prefix_sum = self.build_prefix_sum(array) def build_prefix_sum(self, array): prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] return prefix_sum def update(self, index, value): # Update the value at the given index diff = value - self.array[index - 1] self.array[index - 1] = value # Update prefix sums for affected indices for i in range(index, self.n + 1): self.prefix_sum[i] += diff def range_sum(self, left, right): return self.prefix_sum[right] - self.prefix_sum[left - 1] def process_queries(n, array, queries): ops = ArrayOperations(array) result = [] for query in queries: if query[0] == 1: _, x, y = query ops.update(x, y) elif query[0] == 2: _, l, r = query result.append(ops.range_sum(l, r)) return result"},{"question":"from typing import List, Tuple def smallest_subset_len(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Alice has a set of unique positive integers and wants to find the smallest subset of these integers such that the sum of the subset is greater than or equal to a given integer S. Write a function that determines the length of such a subset or returns -1 if no subset can achieve the required sum. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple represents a test case. Each tuple contains: - an integer n: the size of the set - an integer S: the required sum - a list of n unique positive integers representing the elements of the set Returns: List[int]: For each test case, the length of the smallest subset whose sum is greater than or equal to S. If no such subset exists, return -1 for that test case. Example: >>> smallest_subset_len([(5, 11, [2, 3, 6, 4, 5]), (3, 10, [1, 2, 3])]) [2, -1] def test_example_cases(): test_cases = [ (5, 11, [2, 3, 6, 4, 5]), (3, 10, [1, 2, 3]) ] expected = [2, -1] assert smallest_subset_len(test_cases) == expected def test_additional_cases(): test_cases = [ (1, 1, [1]), (1, 2, [1]), (3, 5, [1, 2, 3]), (3, 6, [2, 2, 2]) ] expected = [1, -1, 2, 3] assert smallest_subset_len(test_cases) == expected def test_large_values(): test_cases = [ (5, 1000000, [200000, 300000, 400000, 500000, 600000]), (4, 2000000, [1000000, 1000000, 1000000, 1000000]) ] expected = [2, 2] assert smallest_subset_len(test_cases) == expected def test_edge_cases(): test_cases = [ (10, 1, [i for i in range(1, 11)]), (10, 1000000, [100000 for _ in range(10)]) ] expected = [1, 10] assert smallest_subset_len(test_cases) == expected","solution":"def smallest_subset_len(test_cases): results = [] for n, S, integers in test_cases: integers.sort(reverse=True) subset_sum = 0 subset_size = 0 for value in integers: subset_sum += value subset_size += 1 if subset_sum >= S: results.append(subset_size) break else: results.append(-1) return results"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. If there are multiple substrings with the same length, returns the first one that appears. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"abcdeafghg\\") \\"bcdeafgh\\" >>> longest_unique_substring(\\"aaaaaaa\\") \\"a\\" >>> longest_unique_substring(\\"abcdef\\") \\"abcdef\\" >>> longest_unique_substring(\\"ab12ab34\\") \\"12ab34\\" >>> longest_unique_substring(\\"\\") \\"\\"","solution":"def longest_unique_substring(s): Returns the longest substring with all unique characters. If there are multiple substrings with the same length, returns the first one that appears. start = 0 max_len = 0 max_substring = \\"\\" seen = {} for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end if end - start + 1 > max_len: max_len = end - start + 1 max_substring = s[start:end+1] return max_substring"},{"question":"from typing import List def combination_sum_zero(arr: List[int], k: int) -> bool: Determines if there is a combination of exactly k elements in the array that sum up to zero. >>> combination_sum_zero([2, -3, 1, 5, -1], 3) == True >>> combination_sum_zero([1, 2, 3, 4, 5], 2) == False","solution":"from itertools import combinations def combination_sum_zero(arr, k): Determines if there is a combination of exactly k elements in the array that sum up to zero. :param arr: List of distinct integers :param k: Number of elements in the combination :return: True if such a combination exists, False otherwise for combo in combinations(arr, k): if sum(combo) == 0: return True return False"},{"question":"def coding_marathon_leaderboard(input_data: str) -> List[str]: Generate leaderboard ranking for multiple test cases based on participant scores and names. >>> coding_marathon_leaderboard(\\"1n1nAlice 100\\") [\\"Case #1:\\", \\"Alice 100\\"] >>> coding_marathon_leaderboard(\\"1n3nAlice 100nBob 100nCharlie 100\\") [\\"Case #1:\\", \\"Alice 100\\", \\"Bob 100\\", \\"Charlie 100\\"] Unit Tests: def test_case_single_participant(): input_data = \\"1n1nAlice 100\\" expected_output = [\\"Case #1:\\", \\"Alice 100\\"] assert coding_marathon_leaderboard(input_data) == expected_output def test_case_multiple_participants_same_score(): input_data = \\"1n3nAlice 100nBob 100nCharlie 100\\" expected_output = [\\"Case #1:\\", \\"Alice 100\\", \\"Bob 100\\", \\"Charlie 100\\"] assert coding_marathon_leaderboard(input_data) == expected_output def test_case_participants_different_scores(): input_data = \\"1n3nAlice 100nBob 200nCharlie 50\\" expected_output = [\\"Case #1:\\", \\"Bob 200\\", \\"Alice 100\\", \\"Charlie 50\\"] assert coding_marathon_leaderboard(input_data) == expected_output def test_case_tied_score_different_names(): input_data = \\"1n3nAlice 100nBob 100nCharlie 100\\" expected_output = [\\"Case #1:\\", \\"Alice 100\\", \\"Bob 100\\", \\"Charlie 100\\"] assert coding_marathon_leaderboard(input_data) == expected_output def test_case_multiple_test_cases(): input_data = \\"2n3nAlice 100nBob 200nCharlie 100n4nDan 150nEmily 150nFrank 100nGeorge 100\\" expected_output = [ \\"Case #1:\\", \\"Bob 200\\", \\"Alice 100\\", \\"Charlie 100\\", \\"Case #2:\\", \\"Dan 150\\", \\"Emily 150\\", \\"Frank 100\\", \\"George 100\\" ] assert coding_marathon_leaderboard(input_data) == expected_output","solution":"def generate_leaderboard(test_cases): results = [] for case_no, (num_participants, participants) in enumerate(test_cases, 1): sorted_participants = sorted(participants, key=lambda x: (-x[1], x[0])) results.append(f\\"Case #{case_no}:\\") for name, score in sorted_participants: results.append(f\\"{name} {score}\\") return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) participants = [] idx += 1 for _ in range(N): name, score = lines[idx].rsplit(' ', 1) participants.append((name, int(score))) idx += 1 test_cases.append((N, participants)) return test_cases def coding_marathon_leaderboard(input_data): test_cases = parse_input(input_data) return generate_leaderboard(test_cases)"},{"question":"from collections import deque from typing import List def min_jumps(arr: List[int], start_index: int) -> int: Returns the minimum number of jumps required to reach the last index. Parameters: arr (List[int]): List of integers where each element represents the maximum number of steps you can move. start_index (int): The index from which to start jumping. Returns: int: Minimum number of jumps to reach the last index of the array. >>> min_jumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 3], 5) == 2 >>> min_jumps([0], 0) == 0 >>> min_jumps([2, 1], 0) == 1 >>> min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9], 0) == 3 >>> min_jumps([6, 2, 4, 0, 5, 1, 1, 4, 2, 9], 8) == 1","solution":"from collections import deque def min_jumps(arr, start_index): Returns the minimum number of jumps required to reach the last index. Parameters: arr (List[int]): List of integers where each element represents the maximum number of steps you can move. start_index (int): The index from which to start jumping. Returns: int: Minimum number of jumps to reach the last index of the array. if start_index == len(arr) - 1: return 0 visited = [False] * len(arr) queue = deque([(start_index, 0)]) visited[start_index] = True while queue: current_index, jumps = queue.popleft() for step in range(1, arr[current_index] + 1): for next_index in (current_index + step, current_index - step): if 0 <= next_index < len(arr) and not visited[next_index]: if next_index == len(arr) - 1: return jumps + 1 queue.append((next_index, jumps + 1)) visited[next_index] = True return -1 # In theory, this should never be reached as per the problem statement."},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each integer is replaced by the product of all the integers in the original list except the one at the current position. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 4]) == [0, 12, 0, 0] >>> product_except_self([0, 0, 3, 4]) == [0, 0, 0, 0] >>> product_except_self([1, 2, -3, 4]) == [-24, -12, 8, -6] length = len(nums) L, R, answer = [1] * length, [1] * length, [1] * length for i in range(1, length): L[i] = L[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): R[i] = R[i + 1] * nums[i + 1] return answer def test_product_except_self_all_positive(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] def test_product_except_self_with_zero(): assert product_except_self([1, 0, 3, 4]) == [0, 12, 0, 0] def test_product_except_self_with_two_zeros(): assert product_except_self([0, 0, 3, 4]) == [0, 0, 0, 0] def test_product_except_self_with_negatives(): assert product_except_self([1, 2, -3, 4]) == [-24, -12, 8, -6] def test_product_except_self_single_element(): assert product_except_self([5]) == [1] def test_product_except_self_empty_list(): assert product_except_self([]) == [] def test_product_except_self_all_ones(): assert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] def test_product_except_self_mixed_signs(): assert product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns a new list where each integer is replaced by the product of all the integers in the original list except the one at the current position. length = len(nums) # Initialize arrays to store the products to the left and right of each element. L, R, answer = [1] * length, [1] * length, [1] * length # Calculate the products to the left of each element. for i in range(1, length): L[i] = L[i - 1] * nums[i - 1] # Calculate the products to the right of each element. for i in range(length - 2, -1, -1): R[i] = R[i + 1] * nums[i + 1] # Construct the answer array. for i in range(length): answer[i] = L[i] * R[i] return answer"},{"question":"from typing import List, Tuple def solve_tsp_problem(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int]]) -> List[int]: Solve the Traveling Space Traveler problem. You are given a network of space stations and hyper-routes between them. The task is to find the minimum travel time needed to visit all the space stations exactly once and return to the starting station for multiple test cases. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int, int]], int]]): List of test cases where each test case is represented as a tuple containing: - An integer N representing the number of space stations. - An integer M representing the number of hyper-routes. - A list of M tuples [(U, V, W)] where U and V are space stations connected by a hyper-route with travel time W. - An integer S representing the starting space station. Returns: List[int]: A list of integers where each integer is the minimum travel time for the corresponding test case. If it is not possible to visit all space stations and return to the starting station, return -1 for that test case. pass # Unit Tests def test_case_1(): input_data = [ (4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)], 1) ] expected_output = [80] assert solve_tsp_problem(input_data) == expected_output def test_case_2(): input_data = [ (3, 3, [(1, 2, 5), (2, 3, 10), (3, 1, 5)], 1) ] expected_output = [20] assert solve_tsp_problem(input_data) == expected_output def test_case_3(): input_data = [ (3, 3, [(1, 2, 5), (2, 3, 10), (3, 1, 5)], 2) ] expected_output = [20] assert solve_tsp_problem(input_data) == expected_output def test_case_4(): input_data = [ (2, 1, [(1, 2, 5)], 1) ] expected_output = [10] assert solve_tsp_problem(input_data) == expected_output def test_case_5(): input_data = [ (3, 2, [(1, 2, 5), (1, 3, 10)], 1) ] expected_output = [-1] assert solve_tsp_problem(input_data) == expected_output","solution":"from itertools import permutations def tsp_min_travel_time(n, m, edges, start): graph = {i: {} for i in range(1, n + 1)} for u, v, w in edges: graph[u][v] = w graph[v][u] = w all_nodes = set(range(1, n + 1)) all_nodes.remove(start) min_travel_time = float('inf') for perm in permutations(all_nodes): total_time = 0 current_node = start for next_node in perm: total_time += graph[current_node].get(next_node, float('inf')) current_node = next_node total_time += graph[current_node].get(start, float('inf')) if total_time < min_travel_time: min_travel_time = total_time return min_travel_time if min_travel_time < float('inf') else -1 def solve_tsp_problem(test_cases): results = [] for case in test_cases: n, m, edges, start = case min_time = tsp_min_travel_time(n, m, edges, start) results.append(min_time) return results"},{"question":"def longest_subarray_with_sum(nums: List[int], target_sum: int) -> List[int]: Finds the longest contiguous subarray with a given sum. Parameters: nums (List of int): The list of integers. target_sum (int): The target sum to find in the subarray. Returns: List of int: The longest contiguous subarray that adds up to the target sum. Examples: >>> longest_subarray_with_sum([1, 2, 3, 7, 5], 12) [2, 3, 7] >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) [1, -1, 5, -2] >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) [-1, 2] >>> longest_subarray_with_sum([1, 1, 1, 1, 1], 2) [1, 1] >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 20) []","solution":"def longest_subarray_with_sum(nums, target_sum): Finds the longest contiguous subarray with a given sum. Parameters: nums (List of int): The list of integers. target_sum (int): The target sum to find in the subarray. Returns: List of int: The longest contiguous subarray that adds up to the target sum. subarray_sum_map = {} current_sum = 0 max_length = 0 start_index = 0 end_index = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target_sum: if i + 1 > max_length: max_length = i + 1 start_index = 0 end_index = i + 1 if (current_sum - target_sum) in subarray_sum_map: if (i - subarray_sum_map[current_sum - target_sum]) > max_length: max_length = (i - subarray_sum_map[current_sum - target_sum]) start_index = subarray_sum_map[current_sum - target_sum] + 1 end_index = i + 1 if current_sum not in subarray_sum_map: subarray_sum_map[current_sum] = i return nums[start_index:end_index]"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, moving only down or right. >>> unique_paths(3, 7) ==> 28 >>> unique_paths(3, 2) ==> 3 >>> unique_paths(1, 1) ==> 1 >>> unique_paths(5, 5) ==> 70 >>> unique_paths(100, 1) ==> 1 >>> unique_paths(1, 100) ==> 1 >>> unique_paths(5, 10) ==> 715","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, moving only down or right. # Create a 2D list to store the results of subproblems dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def char_frequency(s: str) -> dict: Returns a dictionary mapping each unique character to its frequency in the string 's'. The function is case-insensitive. Parameters: s (str): The input string Returns: dict: A dictionary with characters as keys and their frequencies as values Examples: >>> char_frequency(\\"HelloWorld\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"Programming\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> char_frequency(\\"DataScience\\") {'d': 1, 'a': 2, 't': 1, 's': 1, 'c': 2, 'i': 1, 'e': 2, 'n': 1}","solution":"def char_frequency(s): Returns a dictionary mapping each unique character to its frequency in the string 's'. The function is case-insensitive. Parameters: s (str): The input string Returns: dict: A dictionary with characters as keys and their frequencies as values freq = {} for char in s.lower(): if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"from typing import List, Tuple def final_position(commands: str) -> Tuple[int, int]: Given a string of commands, determines the final position of a robot starting at (0, 0). Parameters: commands (str): A string of commands containing 'L', 'R', 'U', 'D' representing movements. Returns: tuple: Final (x, y) coordinates of the robot after executing all commands. >>> final_position('LLUR') (-1, 1) >>> final_position('RRRDD') (3, -2) pass def robot_positions(test_cases: List[str]) -> List[Tuple[int, int]]: For a list of test cases, determines the final positions of a robot following given command sequences. Parameters: test_cases (List[str]): List of command strings for each test case. Returns: List[tuple]: A list of final coordinates for each test case. >>> robot_positions(['LLUR', 'RRRDD', 'UUUDDLLL']) [(-1, 1), (3, -2), (-3, 1)] pass if __name__ == \\"__main__\\": test_final_position() test_robot_positions()","solution":"def final_position(commands): Given a string of commands, determines the final position of a robot starting at (0, 0). Parameters: commands (str): A string of commands containing 'L', 'R', 'U', 'D' representing movements. Returns: tuple: Final (x, y) coordinates of the robot after executing all commands. x, y = 0, 0 for command in commands: if command == 'L': x -= 1 elif command == 'R': x += 1 elif command == 'U': y += 1 elif command == 'D': y -= 1 return (x, y) def robot_positions(test_cases): For a list of test cases, determines the final positions of a robot following given command sequences. Parameters: test_cases (List[str]): List of command strings for each test case. Returns: List[tuple]: A list of final coordinates for each test case. results = [] for commands in test_cases: results.append(final_position(commands)) return results"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers and a target integer, find two numbers in the array that add up to the target. Returns an array containing the indices of the two numbers, such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] from typing import List def test_two_sum_case1(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_case2(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_two_sum_case3(): assert two_sum([3, 3], 6) == [0, 1] def test_two_sum_case4(): assert two_sum([1, 3, 4, 2], 6) == [2, 3] def test_two_sum_case5(): assert two_sum([0, 4, 3, 0], 0) == [0, 3]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. # Create a dictionary to store the value and corresponding index num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i"},{"question":"from typing import List def product_excluding_self(arr: List[int]) -> List[int]: Given an array of integers, return a new array where each element at index \`i\` is the product of all the elements in the original array except the one at \`i\`, without using division and in O(n) time complexity. >>> product_excluding_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_excluding_self([]) [] >>> product_excluding_self([10]) [1] >>> product_excluding_self([3, 5]) [5, 3] >>> product_excluding_self([0, 1, 2, 0]) [0, 0, 0, 0] >>> product_excluding_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_excluding_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_excluding_self([-1, 2, -3, 4]) [-24, 12, -8, 6] pass","solution":"from typing import List def product_excluding_self(arr: List[int]) -> List[int]: n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Compute left products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Compute right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Compute the result using left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def two_sum(arr: List[int], target: int) -> Tuple[int, int]: Given an integer array \`arr\` and an integer \`target\`, return the indices of the two numbers such that they add up to \`target\`. You may assume that each input would have exactly one solution, and you may not use the same element twice. If no such indices exist, return an empty tuple. :param arr: List[int] - list of integers :param target: int - the target sum :return: Tuple[int, int] - a tuple containing the indices of the two numbers Example: >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) from solution import two_sum def test_two_sum_basic(): assert two_sum([2, 7, 11, 15], 9) == (0, 1) def test_two_sum_unordered(): assert two_sum([3, 2, 4], 6) == (1, 2) def test_two_sum_duplicate(): assert two_sum([3, 3], 6) == (0, 1) def test_two_sum_no_solution(): assert two_sum([1, 2, 3, 4], 10) == () def test_two_sum_large_numbers(): assert two_sum([1000000000, 300000000, 700000000], 1000000000) == (1, 2) def test_two_sum_negative_numbers(): assert two_sum([-1, -2, -3, -4, -5], -8) == (2, 4) def test_two_sum_mixed_sign(): assert two_sum([-3, 4, 3, 90], 0) == (0, 2)","solution":"def two_sum(arr, target): Given an array of integers and a target integer, return indices of the two numbers such that they add up to the target. :param arr: List[int] - list of integers :param target: int - target sum :return: Tuple[int, int] - indices of the two numbers that add up to target hashmap = {} for i, num in enumerate(arr): diff = target - num if diff in hashmap: return (hashmap[diff], i) hashmap[num] = i return ()"},{"question":"def find_missing_number(nums: List[int]) -> int: Find the missing number in the list of distinct numbers from 0 to n. >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1, 2]) 3 >>> find_missing_number([1, 2, 3]) 0 >>> find_missing_number([0, 2, 3, 4]) 1 >>> find_missing_number([0]) 1 >>> find_missing_number([1]) 0 >>> find_missing_number([2, 3, 4, 5, 1, 6, 0, 8, 7]) 9 >>> find_missing_number([9, 7, 6, 3, 0, 8, 5, 4, 2]) 1","solution":"def find_missing_number(nums): Find the missing number in the list of distinct numbers from 0 to n. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"def reverse_words(s: str) -> str: Given a string, reverse the words in the string without changing their order and the case of the letters. Args: s (str): input string Returns: str: string with words reversed >>> reverse_words(\\"Hello World Code Challenge\\") 'olleH dlroW edoC egnellahC' >>> reverse_words(\\"Python Programming Fun\\") 'nohtyP gnimmargorP nuF' >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"Hello, world!\\") ',olleH !dlrow' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" \\") ' '","solution":"def reverse_words(s): Given a string, reverse the words in the string without changing their order and the case of the letters. Args: s (str): input string Returns: str: string with words reversed return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"from typing import List def reconstruct_queue(heights: List[List[int]]) -> List[List[int]]: Reconstructs a queue based on the heights and the number of people in front of them. :param heights: List of pairs [height, num_people_in_front] :return: Reconstructed queue as a list of pairs. Example: >>> reconstruct_queue([[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]) [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] >>> reconstruct_queue([[6,0], [5,0], [4,0], [3,2], [2,2], [1,4]]) [[4,0], [5,0], [2,2], [3,2], [1,4], [6,0]] from solution import reconstruct_queue def test_example_1(): heights = [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] expected_output = [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] assert reconstruct_queue(heights) == expected_output def test_example_2(): heights = [[6,0], [5,0], [4,0], [3,2], [2,2], [1,4]] expected_output = [[4,0], [5,0], [2,2], [3,2], [1,4], [6,0]] assert reconstruct_queue(heights) == expected_output def test_single_person(): heights = [[5,0]] expected_output = [[5,0]] assert reconstruct_queue(heights) == expected_output def test_tallest_person_first(): heights = [[8,0], [6,1], [8,1], [7,0], [5,2], [5,0]] expected_output = [[5,0], [7,0], [5,2], [6,1], [8,0], [8,1]] assert reconstruct_queue(heights) == expected_output def test_same_height_different_k(): heights = [[5,0], [5,1], [5,2], [5,3]] expected_output = [[5,0], [5,1], [5,2], [5,3]] assert reconstruct_queue(heights) == expected_output","solution":"def reconstruct_queue(heights): Reconstructs a queue based on the heights and the number of people in front of them. :param heights: List of pairs [height, num_people_in_front] :return: Reconstructed queue as a list of pairs. # Step 1: Sort the list. First by height in descending order, and then by the number of people in ascending order. heights.sort(key=lambda x: (-x[0], x[1])) # Step 2: Initiate an empty list to hold the reconstructed queue queue = [] # Step 3: Insert each person into the queue based on their num_people_in_front value for person in heights: queue.insert(person[1], person) return queue"},{"question":"def organize_teams(names: List[str], k: int) -> List[List[str]]: Organizes participants into k teams of equal size if possible. Parameters: names (list): A list of participant names. k (int): Desired number of teams. Returns: list: A list of lists containing participant names for each team, or an empty list if it's not possible to organize teams of equal size. Example: >>> organize_teams([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], 2) [[\\"Alice\\", \\"Bob\\"], [\\"Charlie\\", \\"David\\"]] >>> organize_teams([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\"], 3) [[\\"Alice\\", \\"Bob\\"], [\\"Charlie\\", \\"David\\"], [\\"Eve\\", \\"Frank\\"]] >>> organize_teams([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"], 2) [] pass # Test cases from solution import organize_teams def test_organize_teams_even_split(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] assert organize_teams(names, 2) == [[\\"Alice\\", \\"Bob\\"], [\\"Charlie\\", \\"David\\"]] def test_organize_teams_exact_division(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\"] assert organize_teams(names, 3) == [[\\"Alice\\", \\"Bob\\"], [\\"Charlie\\", \\"David\\"], [\\"Eve\\", \\"Frank\\"]] def test_organize_teams_not_possible(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"] assert organize_teams(names, 2) == [] def test_organize_teams_single_team(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] assert organize_teams(names, 1) == [[\\"Alice\\", \\"Bob\\", \\"Charlie\\"]] def test_organize_teams_large_input(): names = [\\"Name\\" + str(i) for i in range(1000000)] result = organize_teams(names, 1) assert result == [names] assert len(result[0]) == 1000000 assert organize_teams(names, 100) == [names[i*10000:(i+1)*10000] for i in range(100)] def test_organize_teams_invalid_k(): names = [\\"Alice\\", \\"Bob\\"] assert organize_teams(names, 3) == []","solution":"def organize_teams(names, k): Organizes participants into k teams of equal size if possible. Parameters: names (list): A list of participant names. k (int): Desired number of teams. Returns: list: A list of lists containing participant names for each team, or an empty list if it's not possible to organize teams of equal size. n = len(names) # Check if the total number of names can be evenly divided by k teams if n % k != 0: return [] team_size = n // k teams = [] for i in range(k): team = names[i * team_size : (i + 1) * team_size] teams.append(team) return teams"},{"question":"def longest_substring(s: str, k: int) -> int: Find the length of the longest substring with at most k distinct characters. :param s: A string consisting of lowercase English letters. :param k: The maximum number of distinct characters allowed in the substring. :return: The length of the longest substring with at most k distinct characters. >>> longest_substring(\\"eceba\\", 2) 3 >>> longest_substring(\\"aa\\", 1) 2 >>> longest_substring(\\"abcabcabc\\", 3) 9 >>> longest_substring(\\"abcdef\\", 2) 2","solution":"def longest_substring(s, k): Find the length of the longest substring with at most k distinct characters. :param s: A string consisting of lowercase English letters. :param k: The maximum number of distinct characters allowed in the substring. :return: The length of the longest substring with at most k distinct characters. from collections import defaultdict if k == 0 or not s: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def find_largest_island(grid: List[List[int]]) -> int: Implement a function that takes a 2D binary grid of 1's (land) and 0's (water) and returns the size of the largest island. An island is a group of 1’s connected horizontally or vertically and all four edges of the grid are surrounded by water. >>> find_largest_island([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]) 4 >>> find_largest_island([[1, 1, 0, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 1]]) 4 >>> find_largest_island([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> find_largest_island([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> find_largest_island([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 1","solution":"from typing import List def find_largest_island(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 grid[x][y] = 0 # Count the current cell and explore the 4 possible directions size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Explore the island and track its size island_size = dfs(i, j) # Update the largest island size max_size = max(max_size, island_size) return max_size"},{"question":"def delivery_minimum_distance(test_cases): Calculate the minimum total distance the trucks need to travel to complete all deliveries. pass def process_input(input_str): Convert the input string into a list of test cases. Args: input_str (str): The input string containing test cases. Returns: List[List[Tuple[int, int, int, int]]]: A list of test cases, where each test case is a list of tuples, and each tuple contains four integers representing the coordinates of the starting and ending points. pass def format_output(results): Format the output results into a string. Args: results (List[int]): A list of integers representing the results of each test case. Returns: str: A formatted string of the results. pass # Test cases def test_delivery_minimum_distance(): input_str = \\"1n3n0 0 1 1n2 2 3 3n4 4 5 5n\\" test_cases = process_input(input_str) results = delivery_minimum_distance(test_cases) assert results == [6], f\\"Expected [6], but got {results}\\" input_str = \\"2n2n0 0 0 2n3 3 4 4n3n1 1 2 2n2 2 3 3n3 3 4 4n\\" test_cases = process_input(input_str) results = delivery_minimum_distance(test_cases) assert results == [4, 6], f\\"Expected [4, 6], but got {results}\\" def test_process_input(): input_str = \\"1n3n0 0 1 1n2 2 3 3n4 4 5 5n\\" test_cases = process_input(input_str) expected = [[(0, 0, 1, 1), (2, 2, 3, 3), (4, 4, 5, 5)]] assert test_cases == expected, f\\"Expected {expected}, but got {test_cases}\\" def test_format_output(): results = [6] output = format_output(results) expected = \\"6\\" assert output == expected, f\\"Expected '{expected}', but got '{output}'\\" results = [4, 6] output = format_output(results) expected = \\"4n6\\" assert output == expected, f\\"Expected '{expected}', but got '{output}'\\"","solution":"def delivery_minimum_distance(test_cases): results = [] for test_case in test_cases: total_distance = 0 for order in test_case: x1, y1, x2, y2 = order distance = abs(x2 - x1) + abs(y2 - y1) total_distance += distance results.append(total_distance) return results def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) index += 1 test_case = [] for _ in range(N): x1, y1, x2, y2 = map(int, input_lines[index].split()) test_case.append((x1, y1, x2, y2)) index += 1 test_cases.append(test_case) return test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def update_football_students(): Read input about students interested in football and basketball, and update the set of football-interested students to keep only those interested in both sports. Returns: set: Updated set of students interested in both football and basketball. Example: >>> with patch('builtins.input', side_effect=['5', '1 2 3 4 5', '4', '3 4 5 6']): >>> update_football_students() {3, 4, 5} >>> with patch('builtins.input', side_effect=['6', '1 2 3 4 5 6', '4', '7 8 9 10']): >>> update_football_students() set()","solution":"def update_football_students(): football_n = int(input()) football_students = set(map(int, input().strip().split())) basketball_m = int(input()) basketball_students = set(map(int, input().strip().split())) football_students.intersection_update(basketball_students) return football_students"},{"question":"def reverse_coding(s: str) -> str: This function takes a string and returns a new string in which each character in the original string is replaced by its corresponding character in the reversed alphabet. Args: s (str): The string to transform. Returns: str: The transformed string. Examples: >>> reverse_coding(\\"abc\\") # returns \\"zyx\\" >>> reverse_coding(\\"Hello World!\\") # returns \\"Svool Dliow!\\" >>> reverse_coding(\\"Python 3.9\\") # returns \\"Kbgslm 3.9\\" pass def test_reverse_coding_example_cases(): assert reverse_coding(\\"abc\\") == \\"zyx\\" assert reverse_coding(\\"Hello World!\\") == \\"Svool Dliow!\\" assert reverse_coding(\\"Python 3.9\\") == \\"Kbgslm 3.9\\" def test_reverse_coding_all_lower_case(): assert reverse_coding(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"zyxwvutsrqponmlkjihgfedcba\\" def test_reverse_coding_all_upper_case(): assert reverse_coding(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" def test_reverse_coding_mixed_case(): assert reverse_coding(\\"AbCdEfGhIjKlMnOpQrStUvWxYz\\") == \\"ZyXwVuTsRqPoNmLkJiHgFeDcBa\\" def test_reverse_coding_with_numbers_and_symbols(): assert reverse_coding(\\"1234567890!@#%^&*()_+-=[]{};':,./<>?\\") == \\"1234567890!@#%^&*()_+-=[]{};':,./<>?\\" def test_reverse_coding_edge_cases(): assert reverse_coding(\\"\\") == \\"\\" assert reverse_coding(\\"a\\") == \\"z\\" assert reverse_coding(\\"A\\") == \\"Z\\" assert reverse_coding(\\"z\\") == \\"a\\" assert reverse_coding(\\"Z\\") == \\"A\\" assert reverse_coding(\\" \\") == \\" \\"","solution":"def reverse_coding(s: str) -> str: This function takes a string and returns a new string in which each character in the original string is replaced by its corresponding character in the reversed alphabet. def transform_char(c): if c.islower(): return chr(219 - ord(c)) # 'a' -> 97, 'z' -> 122, 219 = 97 + 122 + 1 elif c.isupper(): return chr(155 - ord(c)) # 'A' -> 65, 'Z' -> 90, 155 = 65 + 90 + 1 else: return c return \\"\\".join(transform_char(c) for c in s)"},{"question":"def rearrange_negatives_left(nums: List[int]) -> None: Rearranges the elements of the list such that all negative numbers appear on the left side and all positive numbers appear on the right side. The relative order of the negative and positive numbers is preserved. Modifies the list in place and does not use any additional lists or arrays. Args: nums (list): A list of integers Returns: None >>> nums = [12, -7, -3, 4, 0, -2, 5] >>> rearrange_negatives_left(nums) >>> nums [-7, -3, -2, 12, 4, 0, 5]","solution":"def rearrange_negatives_left(nums): Rearranges the elements of the list such that all negative numbers appear on the left side and all positive numbers appear on the right side. The relative order of the negative and positive numbers is preserved. Modifies the list in place and does not use any additional lists or arrays. Args: nums (list): A list of integers Returns: None neg_index = 0 # Index to place the next negative number for i in range(len(nums)): if nums[i] < 0: nums.insert(neg_index, nums.pop(i)) neg_index += 1 # Sample list for testing nums = [12, -7, -3, 4, 0, -2, 5] rearrange_negatives_left(nums) print(nums)"},{"question":"from typing import List def sumZero(n: int) -> List[int]: Given an integer n, return an array containing exactly n distinct integers that sum up to zero. >>> sumZero(5) [some array of 5 integers that sum to 0] >>> sumZero(6) [some array of 6 integers that sum to 0] >>> sumZero(1) [some array of 1 integer that sums to 0] >>> sumZero(1000) [some array of 1000 integers that sum to 0] pass","solution":"from typing import List def sumZero(n: int) -> List[int]: Given an integer n, return an array containing exactly n distinct integers that sum up to zero. result = [] # If n is even, we can easily pair the numbers (i.e., -n and n) if n % 2 == 0: for i in range(1, n//2 + 1): result.append(i) result.append(-i) # If n is odd, we need to include 0 and then pair the rest else: result.append(0) for i in range(1, n//2 + 1): result.append(i) result.append(-i) return result"},{"question":"class MarsRover: def __init__(self, grid_size, start_position, start_direction, commands): Initializes the MarsRover with the given grid size, start position, start direction, and commands. :param grid_size: A tuple (n, m) representing the dimensions of the grid. :param start_position: A tuple (x, y) representing the starting coordinates of the rover. :param start_direction: A character indicating the initial direction ('N', 'E', 'S', or 'W'). :param commands: A string representing a sequence of movement commands ('M', 'L', 'R'). self.grid_size = grid_size self.position = start_position self.direction = start_direction self.commands = commands def execute_commands(self): Processes the commands and updates the position and direction of the rover. :return: A tuple (final_x, final_y, final_direction) representing the final position and direction of the rover. pass def test_example_scenario(): grid_size = (5, 5) start_position = (1, 2) start_direction = 'N' commands = \\"LMLMLMLMM\\" rover = MarsRover(grid_size, start_position, start_direction, commands) assert rover.execute_commands() == (1, 3, 'N') def test_move_forward(): grid_size = (5, 5) start_position = (0, 0) start_direction = 'E' commands = \\"MM\\" rover = MarsRover(grid_size, start_position, start_direction, commands) assert rover.execute_commands() == (2, 0, 'E') def test_turn_left(): grid_size = (5, 5) start_position = (0, 0) start_direction = 'N' commands = \\"L\\" rover = MarsRover(grid_size, start_position, start_direction, commands) assert rover.execute_commands() == (0, 0, 'W') def test_turn_right(): grid_size = (5, 5) start_position = (0, 0) start_direction = 'N' commands = \\"R\\" rover = MarsRover(grid_size, start_position, start_direction, commands) assert rover.execute_commands() == (0, 0, 'E') def test_complex_commands(): grid_size = (5, 5) start_position = (3, 3) start_direction = 'E' commands = \\"MMRMMRMRRM\\" rover = MarsRover(grid_size, start_position, start_direction, commands) assert rover.execute_commands() == (5, 1, 'E')","solution":"class MarsRover: def __init__(self, grid_size, start_position, start_direction, commands): self.grid_size = grid_size self.position = start_position self.direction = start_direction self.commands = commands self.directions = ['N', 'E', 'S', 'W'] def turn_left(self): index = self.directions.index(self.direction) self.direction = self.directions[(index - 1) % 4] def turn_right(self): index = self.directions.index(self.direction) self.direction = self.directions[(index + 1) % 4] def move_forward(self): x, y = self.position if self.direction == 'N': self.position = (x, y + 1) elif self.direction == 'E': self.position = (x + 1, y) elif self.direction == 'S': self.position = (x, y - 1) elif self.direction == 'W': self.position = (x - 1, y) def execute_commands(self): for command in self.commands: if command == 'L': self.turn_left() elif command == 'R': self.turn_right() elif command == 'M': self.move_forward() return self.position[0], self.position[1], self.direction # Example usage: # grid_size = (5, 5) # start_position = (1, 2) # start_direction = 'N' # commands = \\"LMLMLMLMM\\" # rover = MarsRover(grid_size, start_position, start_direction, commands) # final_position = rover.execute_commands() # print(final_position) # Output should be (1, 3, 'N')"},{"question":"def move_digits_to_end(s: str) -> str: Moves all digits that appear in the string to the end of the string in their original order and returns the new string. The relative positions of the letters should not be disturbed. >>> move_digits_to_end(\\"a1b2c3d\\") 'abcd123' >>> move_digits_to_end(\\"abc123\\") 'abc123' >>> move_digits_to_end(\\"12abc34\\") 'abc1234' >>> move_digits_to_end(\\"a1b2c3d4e5f6g7h8i9\\") 'abcdefghi123456789' >>> move_digits_to_end(\\"no_digits_here\\") 'no_digits_here' from solution import move_digits_to_end def test_example_1(): assert move_digits_to_end(\\"a1b2c3d\\") == \\"abcd123\\" def test_example_2(): assert move_digits_to_end(\\"abc123\\") == \\"abc123\\" def test_example_3(): assert move_digits_to_end(\\"12abc34\\") == \\"abc1234\\" def test_example_4(): assert move_digits_to_end(\\"a1b2c3d4e5f6g7h8i9\\") == \\"abcdefghi123456789\\" def test_example_5(): assert move_digits_to_end(\\"no_digits_here\\") == \\"no_digits_here\\" def test_empty_string(): assert move_digits_to_end(\\"\\") == \\"\\" def test_all_letters(): assert move_digits_to_end(\\"abcdef\\") == \\"abcdef\\" def test_all_digits(): assert move_digits_to_end(\\"123456\\") == \\"123456\\" def test_mixed_characters(): assert move_digits_to_end(\\"x8y7z6\\") == \\"xyz876\\"","solution":"def move_digits_to_end(s): Moves all digits in the string \`s\` to the end while preserving their order. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def sort_cars(cars: List[Dict[str, Union[str, int]]]) -> List[str]: Sorts cars in descending order based on their combined score which is calculated as: combined_score = (speed * 0.5) + (comfort * 0.3) + (fuel_efficiency * 0.2) Parameters: cars (list of dict): A list of dictionaries where each dictionary represents a car and its attributes. Returns: list: A list of car names sorted in descending order based on their combined score. >>> cars = [ ... {\\"name\\": \\"Car A\\", \\"speed\\": 150, \\"comfort\\": 80, \\"fuel_efficiency\\": 70}, ... {\\"name\\": \\"Car B\\", \\"speed\\": 120, \\"comfort\\": 90, \\"fuel_efficiency\\": 60}, ... {\\"name\\": \\"Car C\\", \\"speed\\": 130, \\"comfort\\": 85, \\"fuel_efficiency\\": 65} ... ] >>> sort_cars(cars) ['Car A', 'Car C', 'Car B'] def test_sort_cars(): cars = [ {\\"name\\": \\"Car A\\", \\"speed\\": 150, \\"comfort\\": 80, \\"fuel_efficiency\\": 70}, {\\"name\\": \\"Car B\\", \\"speed\\": 120, \\"comfort\\": 90, \\"fuel_efficiency\\": 60}, {\\"name\\": \\"Car C\\", \\"speed\\": 130, \\"comfort\\": 85, \\"fuel_efficiency\\": 65} ] expected = [\\"Car A\\", \\"Car C\\", \\"Car B\\"] assert sort_cars(cars) == expected def test_sort_cars_with_tie(): cars = [ {\\"name\\": \\"Car A\\", \\"speed\\": 150, \\"comfort\\": 80, \\"fuel_efficiency\\": 70}, {\\"name\\": \\"Car B\\", \\"speed\\": 150, \\"comfort\\": 80, \\"fuel_efficiency\\": 70}, {\\"name\\": \\"Car C\\", \\"speed\\": 130, \\"comfort\\": 85, \\"fuel_efficiency\\": 65} ] expected = [\\"Car A\\", \\"Car B\\", \\"Car C\\"] assert sort_cars(cars) == expected def test_sort_cars_empty_list(): cars = [] expected = [] assert sort_cars(cars) == expected def test_sort_cars_one_car(): cars = [ {\\"name\\": \\"Car A\\", \\"speed\\": 150, \\"comfort\\": 80, \\"fuel_efficiency\\": 70} ] expected = [\\"Car A\\"] assert sort_cars(cars) == expected def test_sort_cars_all_zero(): cars = [ {\\"name\\": \\"Car A\\", \\"speed\\": 0, \\"comfort\\": 0, \\"fuel_efficiency\\": 0}, {\\"name\\": \\"Car B\\", \\"speed\\": 0, \\"comfort\\": 0, \\"fuel_efficiency\\": 0}, {\\"name\\": \\"Car C\\", \\"speed\\": 0, \\"comfort\\": 0, \\"fuel_efficiency\\": 0} ] expected = [\\"Car A\\", \\"Car B\\", \\"Car C\\"] assert sort_cars(cars) == expected","solution":"def sort_cars(cars): Sorts cars in descending order based on their combined score which is calculated as: combined_score = (speed * 0.5) + (comfort * 0.3) + (fuel_efficiency * 0.2) Parameters: cars (list of dict): A list of dictionaries where each dictionary represents a car and its attributes. Returns: list: A list of car names sorted in descending order based on their combined score. for car in cars: car['combined_score'] = (car['speed'] * 0.5) + (car['comfort'] * 0.3) + (car['fuel_efficiency'] * 0.2) sorted_cars = sorted(cars, key=lambda x: x['combined_score'], reverse=True) return [car['name'] for car in sorted_cars]"},{"question":"from typing import List def get_minimum_steps(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of steps required for Alex to collect all treasures in the grid. >>> get_minimum_steps(3, 3, [\\".S.\\", \\".T.\\", \\"...\\"]) 1 >>> get_minimum_steps(4, 4, ['S...', '....', '.T..', '...T']) 6 >>> get_minimum_steps(2, 3, [\\".TT\\", \\"S..\\"]) 3 >>> get_minimum_steps(2, 2, [\\"S.\\", \\"..\\"]) 0 >>> get_minimum_steps(1, 1, [\\"S\\"]) 0 >>> get_minimum_steps(5,5, [\\"S....\\", \\"..#..\\", \\"...\\", \\"...T.\\", \\"...T.\\"]) 7 >>> get_minimum_steps(3,3, [\\"S.T\\", \\"...\\", \\"...\\"]) 2","solution":"from collections import deque def get_minimum_steps(n, m, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] treasures = [] start = None # Parse grid to find start and treasure locations for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'T': treasures.append((i, j)) # If no treasures present, return 0 if not treasures: return 0 def bfs(start): steps = {} queue = deque([(start, 0)]) steps[start] = 0 while queue: (x, y), step = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in steps and grid[nx][ny] != '#': steps[(nx, ny)] = step + 1 queue.append(((nx, ny), step + 1)) return steps # Get distances from the starting point to all other points dist_from_start = bfs(start) # Collect distances from all treasure points to others dist_from_treasures = [] for treasure in treasures: dist_from_treasures.append(bfs(treasure)) from itertools import permutations min_steps = float('inf') for perm in permutations(treasures): current_steps = 0 current_position = start reachable = True for next_treasure in perm: if next_treasure in dist_from_start if current_position == start else dist_from_treasures[treasures.index(current_position)]: current_steps += dist_from_start[next_treasure] if current_position == start else dist_from_treasures[treasures.index(current_position)][next_treasure] current_position = next_treasure else: reachable = False break if reachable: min_steps = min(min_steps, current_steps) return min_steps if min_steps != float('inf') else -1"},{"question":"def findTwoSum(nums, target): Returns the indices of the two numbers that add up to the target. :param nums: List[int] - list of unique integers :param target: int - target sum :return: List[int] - list with two indices of the numbers that sum up to the target >>> findTwoSum([2, 7, 11, 15], 9) [0, 1] >>> findTwoSum([3, 2, 4], 6) [1, 2] >>> findTwoSum([3, 3], 6) [0, 1]","solution":"def findTwoSum(nums, target): Returns the indices of the two numbers that add up to the target. :param nums: List[int] - list of unique integers :param target: int - target sum :return: List[int] - list with two indices of the numbers that sum up to the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def special_sort(nums: List[int]) -> List[int]: Given a list of non-negative integers, return the list sorted in a special way. The special sorting order is as follows: 1. All even numbers should come before all odd numbers. 2. Within the even numbers, they should be sorted in descending order. 3. Within the odd numbers, they should be sorted in ascending order. >>> special_sort([8, 3, 7, 6, 1, 5]) [8, 6, 1, 3, 5, 7] >>> special_sort([4, 2, 9, 7, 6, 1]) [6, 4, 2, 1, 7, 9] >>> special_sort([3, 3, 2, 2, 1, 1]) [2, 2, 1, 1, 3, 3] >>> special_sort([5, 4, 3, 2, 1]) [4, 2, 1, 3, 5] >>> special_sort([1]) [1] >>> special_sort([2]) [2] >>> special_sort([8, 6, 4, 2]) [8, 6, 4, 2] >>> special_sort([9, 7, 5, 3]) [3, 5, 7, 9] >>> special_sort([10, 1, 8, 3, 6, 7, 4, 5, 2, 9]) [10, 8, 6, 4, 2, 1, 3, 5, 7, 9] >>> special_sort([]) [] >>> special_sort([5, 3, 5, 2, 8, 3, 1]) [8, 2, 1, 3, 3, 5, 5]","solution":"def special_sort(nums): Sorts the list of non-negative integers such that: 1. All even numbers come before all odd numbers. 2. Even numbers are sorted in descending order. 3. Odd numbers are sorted in ascending order. evens = sorted([num for num in nums if num % 2 == 0], reverse=True) odds = sorted([num for num in nums if num % 2 != 0]) return evens + odds"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be made by buying and selling the stock exactly once. >>> max_profit([7, 1, 5, 3, 6, 4]) # returns 5 >>> max_profit([7, 6, 4, 3, 1]) # returns 0 >>> max_profit([1, 2, 3, 4, 5]) # returns 4","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling the stock exactly once. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: min_price = min(min_price, price) current_profit = price - min_price max_profit = max(max_profit, current_profit) return max_profit"},{"question":"def max_subarray_len(nums: List[int], k: int) -> int: Returns the length of the longest continuous subarray whose sum equals to k. >>> max_subarray_len([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_len([-2, -1, 2, 1], 1) 2","solution":"def max_subarray_len(nums, k): Returns the length of the longest continuous subarray whose sum equals to k. sum_indices = {0: -1} # Initializes the dictionary with sum 0 at index -1 max_len = 0 current_sum = 0 for i, num in enumerate(nums): current_sum += num if current_sum - k in sum_indices: max_len = max(max_len, i - sum_indices[current_sum - k]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_len"},{"question":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given an integer array \`nums\` and an integer \`target\`, return indices of the two numbers such that they add up to \`target\`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Args: nums (List[int]): The list of numbers. target (int): The target sum. Returns: List[int]: The indices of the two numbers that add up to \`target\`. Examples: >>> find_two_sum([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum([3, 2, 4], 6) [1, 2] pass def test_example1(): nums = [2, 7, 11, 15] target = 9 assert find_two_sum(nums, target) == [0, 1] def test_example2(): nums = [3, 2, 4] target = 6 assert find_two_sum(nums, target) == [1, 2] def test_large_numbers(): nums = [1000000000, -1000000000, 3, 4] target = 0 assert find_two_sum(nums, target) == [0, 1] def test_negative_numbers(): nums = [-3, 4, 3, 90] target = 0 assert find_two_sum(nums, target) == [0, 2] def test_no_duplicate_but_same_value(): nums = [2, 5, 5, 11] target = 10 assert find_two_sum(nums, target) == [1, 2]","solution":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in \`nums\` that add up to \`target\`. Parameters: nums (List[int]): The list of numbers. target (int): The target sum. Returns: List[int]: The indices of the two numbers that add up to \`target\`. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"from typing import List, Tuple def can_be_strictly_increasing_by_one_swap(arr: List[int]) -> str: Determines if the array can be rearranged into a strictly increasing sequence by performing at most one swap of two elements or is already strictly increasing. >>> can_be_strictly_increasing_by_one_swap([1, 5, 3, 4, 2]) \\"YES\\" >>> can_be_strictly_increasing_by_one_swap([1, 3, 5, 3, 4, 6]) \\"NO\\" >>> can_be_strictly_increasing_by_one_swap([1, 2, 3, 4]) \\"YES\\" def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Solves multiple test cases to determine if each array can be rearranged into a strictly increasing sequence by performing at most one swap of two elements. def test_single_case_yes(): arr = [1, 5, 3, 4, 2] assert can_be_strictly_increasing_by_one_swap(arr) == \\"YES\\" def test_single_case_no(): arr = [1, 3, 5, 3, 4, 6] assert can_be_strictly_increasing_by_one_swap(arr) == \\"NO\\" def test_single_case_already_strictly_increasing(): arr = [1, 2, 3, 4] assert can_be_strictly_increasing_by_one_swap(arr) == \\"YES\\" def test_multiple_cases(): T = 3 test_cases = [ (5, [1, 5, 3, 4, 2]), (6, [1, 3, 5, 3, 4, 6]), (4, [1, 2, 3, 4]) ] assert solve(T, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_edge_case_minimum_length(): arr = [2, 1] assert can_be_strictly_increasing_by_one_swap(arr) == \\"YES\\" def test_edge_case_negative_numbers(): arr = [-1, -2, -3, -4] assert can_be_strictly_increasing_by_one_swap(arr) == \\"NO\\" def test_edge_case_large_input(): arr = list(range(1000, 0, -1)) assert can_be_strictly_increasing_by_one_swap(arr) == \\"NO\\" def test_mixed_positive_negative(): arr = [1, -1, 2] assert can_be_strictly_increasing_by_one_swap(arr) == \\"YES\\" def test_no_change_needed(): arr = [10, 20, 30, 40, 50] assert can_be_strictly_increasing_by_one_swap(arr) == \\"YES\\"","solution":"def can_be_strictly_increasing_by_one_swap(arr): Determines if the array can be rearranged into a strictly increasing sequence by performing at most one swap of two elements or is already strictly increasing. n = len(arr) # Check if the array is already strictly increasing sorted_arr = sorted(arr) if arr == sorted_arr: return \\"YES\\" # Find the indices where the array is not strictly increasing mismatch_indices = [] for i in range(n - 1): if arr[i] >= arr[i + 1]: mismatch_indices.append(i) mismatch_indices.append(i + 1) mismatch_indices = sorted(set(mismatch_indices)) # If there are more than 4 mismatched indices, then more than one swap is needed if len(mismatch_indices) > 4: return \\"NO\\" # Try all swaps between mismatched indices for i in range(len(mismatch_indices)): for j in range(i + 1, len(mismatch_indices)): arr[mismatch_indices[i]], arr[mismatch_indices[j]] = arr[mismatch_indices[j]], arr[mismatch_indices[i]] if arr == sorted_arr: return \\"YES\\" arr[mismatch_indices[i]], arr[mismatch_indices[j]] = arr[mismatch_indices[j]], arr[mismatch_indices[i]] return \\"NO\\" def solve(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] result = can_be_strictly_increasing_by_one_swap(arr) results.append(result) return results"},{"question":"def first_missing_positive(nums: List[int]) -> int: Finds and returns the smallest missing positive integer from the list nums. Function works in O(n) time and uses constant extra space. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([-1, -2, -3]) 1 >>> first_missing_positive([1, 1000]) 2 >>> first_missing_positive([-1, 4, 2, 1, 9, 10]) 3 >>> first_missing_positive([3, 7, 1, 2, 8, -10, 15]) 4","solution":"def first_missing_positive(nums): Finds and returns the smallest missing positive integer from the list nums. Function works in O(n) time and uses constant extra space. n = len(nums) # Step 1: Replace all numbers <= 0 and numbers > n with n+1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Flip the sign of the number at the index corresponding to the value for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first positive index for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def reverse_words(sentence: str) -> str: This function takes a string containing a sequence of words separated by whitespace and returns a reformatted string in which the words appear in reverse order, but each word's individual characters are unchanged. Examples: >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" Leading and trailing spaces \\") \\"spaces trailing and Leading\\" from solution import reverse_words def test_reverse_words_basic(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_reverse_words_sentence(): assert reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" def test_reverse_words_with_extra_spaces(): assert reverse_words(\\" Leading and trailing spaces \\") == \\"spaces trailing and Leading\\" def test_reverse_words_single_word(): assert reverse_words(\\"hello\\") == \\"hello\\" def test_reverse_words_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_reverse_words_multiple_whitespace(): assert reverse_words(\\"a big space\\") == \\"space big a\\" def test_reverse_words_single_space(): assert reverse_words(\\" \\") == \\"\\"","solution":"def reverse_words(sentence): This function takes a string containing a sequence of words separated by whitespace and returns a reformatted string in which the words appear in reverse order, but each word's individual characters are unchanged. # Split the sentence into words using whitespace words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a string separated by a single space return ' '.join(reversed_words)"},{"question":"from typing import List def can_form_palindrome(string: str) -> str: Returns 'YES' if the string can be rearranged to form a palindrome, otherwise 'NO'. >>> can_form_palindrome('aabb') 'YES' >>> can_form_palindrome('abc') 'NO' pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each string can be rearranged to form a palindrome. >>> process_test_cases(['aabb', 'abc']) ['YES', 'NO'] pass","solution":"from collections import Counter def can_form_palindrome(string): Returns 'YES' if the string can be rearranged to form a palindrome, otherwise 'NO'. char_count = Counter(string) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return 'YES' if odd_count <= 1 else 'NO' def process_test_cases(test_cases): results = [] for string in test_cases: results.append(can_form_palindrome(string)) return results"},{"question":"def initial_count(full_name: str) -> dict: Takes a string containing a full name (first, middle, and last name) and returns a dictionary with the initials of each part of the name as the key and the count of occurrences of those initials as the value. The function should be case-insensitive. >>> initial_count(\\"John Michael Doe\\") {'J': 1, 'M': 1, 'D': 1} >>> initial_count(\\"Alice Bob Charlie Alice Bob Charlie\\") {'A': 2, 'B': 2, 'C': 2} >>> initial_count(\\"john doe John Doe\\") {'J': 2, 'D': 2} >>> initial_count(\\"\\") {} >>> initial_count(\\"Elizabeth\\") {'E': 1} >>> initial_count(\\"Aaron Andrew Adam\\") {'A': 3}","solution":"def initial_count(full_name): Takes a string containing a full name (first, middle, and last name) and returns a dictionary with the initials of each part of the name as the key and the count of occurrences of those initials as the value. The function should be case-insensitive. :param full_name: string containing the full name :return: dictionary with initials as keys and counts as values if not full_name: return {} # Split the name into parts and convert to uppercase name_parts = full_name.split() initials = [name[0].upper() for name in name_parts] # Generate the dictionary with counts initial_counts = {} for initial in initials: if initial in initial_counts: initial_counts[initial] += 1 else: initial_counts[initial] = 1 return initial_counts"},{"question":"def find_unsorted_subarray(nums): Given a list of integers \`nums\`, find the length of the longest contiguous subarray which when sorted results in the entire array being sorted. If the whole array is already sorted, return the length of the array. Examples: >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_unsorted_subarray([1, 2, 3, 4]) 4 >>> find_unsorted_subarray([2, 1]) 2 pass","solution":"def find_unsorted_subarray(nums): This function finds the length of the shortest subarray, when sorted, results in the whole array being sorted. n = len(nums) sorted_nums = sorted(nums) left = 0 while left < n and nums[left] == sorted_nums[left]: left += 1 if left == n: return n right = n - 1 while right >= 0 and nums[right] == sorted_nums[right]: right -= 1 return right - left + 1"},{"question":"def process_account(initial_balance, transactions): Simulates a bank account and processes a series of transactions. Parameters: initial_balance (int): The initial balance of the account. transactions (list of tuples): A list of transactions where each transaction is represented by a tuple. Returns: list: A list of results for balance inquiries. Example: >>> process_account(100, [('deposit', 50), ('balance',), ('withdraw', 20), ('balance',)]) [150, 130]","solution":"def process_account(initial_balance, transactions): Simulates a bank account and processes a series of transactions. Parameters: initial_balance (int): The initial balance of the account. transactions (list of tuples): A list of transactions where each transaction is represented by a tuple. Returns: list: A list of results for balance inquiries. balance = initial_balance result = [] for transaction in transactions: if transaction[0] == 'deposit': balance += transaction[1] elif transaction[0] == 'withdraw': if transaction[1] <= balance: balance -= transaction[1] elif transaction[0] == 'balance': result.append(balance) return result"},{"question":"def even_sum_greater_than_max_odd(n: int, numbers: List[int]) -> bool: Checks if the sum of the even numbers in the list is greater than the maximum of the odd numbers in the list. Parameters: n (int): The total number of integers in the list. numbers (List[int]): A space separated list of integers. Returns: bool: True if the sum of even numbers is greater than the maximum of the odd numbers, False otherwise. Examples: >>> even_sum_greater_than_max_odd(5, [1, 2, 3, 4, 5]) True >>> even_sum_greater_than_max_odd(5, [6, 1, 8, 3, 5]) True >>> even_sum_greater_than_max_odd(4, [1, 2, 1, 3]) False from typing import List # Test cases def test_even_sum_greater(): assert even_sum_greater_than_max_odd(5, [1, 2, 3, 4, 5]) == True assert even_sum_greater_than_max_odd(5, [6, 1, 8, 3, 5]) == True def test_max_odd_greater(): assert even_sum_greater_than_max_odd(4, [1, 2, 1, 3]) == False assert even_sum_greater_than_max_odd(5, [9, 8, 3, 1, 1]) == False def test_no_odd_numbers(): assert even_sum_greater_than_max_odd(4, [2, 4, 6, 8]) == False assert even_sum_greater_than_max_odd(3, [10, 12, 14]) == False def test_no_even_numbers(): assert even_sum_greater_than_max_odd(3, [1, 3, 5]) == False assert even_sum_greater_than_max_odd(4, [7, 9, 11, 13]) == False def test_mix_numbers_edge_case(): assert even_sum_greater_than_max_odd(4, [1, 2, 3, 4]) == True assert even_sum_greater_than_max_odd(4, [2, 3, 4, 5]) == True def test_all_numbers_even(): assert even_sum_greater_than_max_odd(4, [2, 4, 6, 8]) == False def test_all_numbers_odd(): assert even_sum_greater_than_max_odd(4, [1, 3, 5, 7]) == False","solution":"def even_sum_greater_than_max_odd(n, numbers): Checks if the sum of the even numbers in the list is greater than the maximum of the odd numbers in the list. even_numbers = [num for num in numbers if num % 2 == 0] odd_numbers = [num for num in numbers if num % 2 != 0] if not odd_numbers or not even_numbers: return False sum_even = sum(even_numbers) max_odd = max(odd_numbers) return sum_even > max_odd"},{"question":"class MyQueue: Class to implement a queue using two stacks. def __init__(self): Initialize the queue using two stacks. def enqueue(self, x): Adds element x to the back of the queue. def dequeue(self): Removes the element from the front of the queue and returns that element. def peek(self): Returns the element at the front of the queue without removing it. def isEmpty(self): Returns True if the queue is empty, False otherwise. # Example usage: if __name__ == \\"__main__\\": q = MyQueue() q.enqueue(1) q.enqueue(2) print(q.peek()) # expected 1 print(q.dequeue()) # expected 1 print(q.isEmpty()) # expected False # Unit tests: def test_enqueue_and_peek(): q = MyQueue() q.enqueue(1) q.enqueue(2) assert q.peek() == 1 def test_enqueue_and_dequeue(): q = MyQueue() q.enqueue(1) q.enqueue(2) assert q.dequeue() == 1 assert q.peek() == 2 def test_isEmpty(): q = MyQueue() assert q.isEmpty() == True q.enqueue(1) assert q.isEmpty() == False q.dequeue() assert q.isEmpty() == True def test_dequeue_until_empty(): q = MyQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.isEmpty() == True","solution":"class MyQueue: def __init__(self): Initialize the queue using two stacks. self.stack1 = [] self.stack2 = [] def enqueue(self, x): Adds element x to the back of the queue. self.stack1.append(x) def dequeue(self): Removes the element from the front of the queue and returns that element. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): Returns the element at the front of the queue. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def isEmpty(self): Returns True if the queue is empty, False otherwise. return not self.stack1 and not self.stack2"},{"question":"def can_reach_end(grid): Determines if the player can reach the bottom-right corner of the grid from the top-left corner. Parameters: grid (list of list of str): The 2D grid where each cell is a '.' (walkable) or '#' (obstacle). Returns: bool: True if the player can reach the bottom-right corner, False otherwise. Examples: >>> can_reach_end([ [\\".\\", \\".\\", \\"#\\", \\".\\"], [\\".\\", \\"#\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"#\\"], [\\"#\\", \\".\\", \\".\\", \\".\\"] ]) True >>> can_reach_end([ [\\".\\", \\"#\\", \\"#\\", \\".\\"], [\\"#\\", \\"#\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\"#\\", \\"#\\"], [\\"#\\", \\".\\", \\".\\", \\".\\"] ]) False","solution":"def can_reach_end(grid): Determines if the player can reach the bottom-right corner of the grid from the top-left corner. Parameters: grid (list of list of str): The 2D grid where each cell is a '.' (walkable) or '#' (obstacle). Returns: bool: True if the player can reach the bottom-right corner, False otherwise. rows = len(grid) cols = len(grid[0]) def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == '.' def dfs(x, y): if x == rows - 1 and y == cols - 1: return True grid[x][y] = '#' # Mark as visited directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the sum of the contiguous subarray within the list \`nums\` which has the largest sum. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([-2, -3, -1, -5]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray within the list \`nums\` which has the largest sum. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_tree_sum(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum sum of the heights of the trees you can cut under the condition that you cannot cut any tree directly adjacent to a tree you have already cut. Args: test_cases: List of tuples where each tuple contains an integer N representing the number of trees followed by a list of integers representing the heights of the trees. Returns: A list of integers where each integer is the maximum sum of the heights of the trees you can cut for respective test case. >>> max_tree_sum([(4, [1, 2, 9, 4]), (5, [3, 2, 5, 10, 7])]) [10, 15] >>> max_tree_sum([(1, [7])]) [7] def test_max_tree_sum(): # Sample test cases test_cases_1 = [ (4, [1, 2, 9, 4]), (5, [3, 2, 5, 10, 7]) ] expected_1 = [10, 15] assert max_tree_sum(test_cases_1) == expected_1 # Edge case: No trees test_cases_2 = [ (0, []) ] expected_2 = [0] assert max_tree_sum(test_cases_2) == expected_2 # Edge case: One tree test_cases_3 = [ (1, [7]) ] expected_3 = [7] assert max_tree_sum(test_cases_3) == expected_3 # General test case: Alternating heights test_cases_4 = [ (6, [5, 1, 1, 5, 1, 5]) ] expected_4 = [15] assert max_tree_sum(test_cases_4) == expected_4 # General test case: Increasing heights test_cases_5 = [ (5, [1, 2, 3, 4, 5]) ] expected_5 = [9] assert max_tree_sum(test_cases_5) == expected_5 # General test case: Decreasing heights test_cases_6 = [ (5, [5, 4, 3, 2, 1]) ] expected_6 = [9] assert max_tree_sum(test_cases_6) == expected_6","solution":"def max_tree_sum(test_cases): results = [] for case in test_cases: N, heights = case if N == 0: results.append(0) continue if N == 1: results.append(heights[0]) continue # Initialize dp array dp = [0] * N dp[0] = heights[0] dp[1] = max(heights[0], heights[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + heights[i]) results.append(dp[-1]) return results"},{"question":"def even_odd_product(lst: list) -> int: Write a function even_odd_product() that takes a list of integers as input. Returns the product of all elements at even positions (i.e., 1st, 3rd, 5th, etc.) multiplied by the sum of all elements at odd positions (i.e., 2nd, 4th, 6th, etc.). For example, even_odd_product([2, 3, 4, 5, 6, 7]) should return 720 as: --> (2 * 4 * 6) * (3 + 5 + 7) = 48 * 15 = 720 If the list is empty, the result should be 0. >>> even_odd_product([2, 3, 4, 5, 6, 7]) 720 >>> even_odd_product([]) 0 >>> even_odd_product([2]) 0 >>> even_odd_product([2, 3]) 6 >>> even_odd_product([0, 0, 0, 0]) 0 >>> even_odd_product([2, 0, 4, 0]) 0 >>> even_odd_product([0, 3, 0, 5]) 0","solution":"def even_odd_product(lst): Returns the product of all elements at even positions multiplied by the sum of all elements at odd positions. Parameters: lst (list): A list of integers Returns: int: The product of elements at even positions and the sum of elements at odd positions if not lst: return 0 even_positions_product = 1 odd_positions_sum = 0 for i in range(len(lst)): if i % 2 == 0: even_positions_product *= lst[i] else: odd_positions_sum += lst[i] return even_positions_product * odd_positions_sum"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Function to find the longest common prefix string amongst an array of strings. :param strs: List of strings :return: Longest common prefix >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" >>> longest_common_prefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" >>> longest_common_prefix([\\"throne\\", \\"throne\\", \\"prefix\\"]) == \\"\\" >>> longest_common_prefix([\\"\\", \\"b\\"]) == \\"\\" >>> longest_common_prefix([\\"a\\"]) == \\"a\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"\\" >>> longest_common_prefix([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == \\"aaa\\" pass","solution":"def longest_common_prefix(strs): Function to find the longest common prefix string amongst an array of strings. :param strs: List of strings :return: Longest common prefix if not strs: return \\"\\" min_length = min(len(s) for s in strs) low, high = 0, min_length while low <= high: mid = (low + high) // 2 if all(s.startswith(strs[0][:mid]) for s in strs): low = mid + 1 else: high = mid - 1 return strs[0][:(low + high) // 2]"},{"question":"def best_time_to_schedule(contest: List[int], participants: List[List[int]]) -> int: Determines the best time to schedule a contest based on the availability of the participants. :param contest: List of two integers [start, end] representing the desired contest time window. :param participants: List of lists where each inner list is a pair of integers [start, end] representing a participant's available time window. :return: Maximum number of participants that can join during any continuous hour within the desired contest time window. >>> best_time_to_schedule([9, 17], [[8, 12], [9, 13], [11, 15], [14, 18]]) 3 >>> best_time_to_schedule([10, 14], [[8, 12], [10, 13], [11, 15], [13, 15]]) 3 >>> best_time_to_schedule([9, 10], [[8, 9], [9, 11], [10, 12]]) 1 >>> best_time_to_schedule([8, 20], [[7, 9], [8, 10], [9, 11], [10, 12], [11, 13], [14, 18], [17, 19]]) 2 >>> best_time_to_schedule([12, 13], [[8, 12], [13, 15]]) 0","solution":"def best_time_to_schedule(contest, participants): Determines the best time to schedule a contest based on the availability of the participants. :param contest: List of two integers [start, end] representing the desired contest time window. :param participants: List of lists where each inner list is a pair of integers [start, end] representing a participant's available time window. :return: Maximum number of participants that can join during any continuous hour within the desired contest time window. max_participants = 0 for hour in range(contest[0], contest[1]): current_participants = sum(1 for p in participants if p[0] <= hour < p[1]) max_participants = max(max_participants, current_participants) return max_participants"},{"question":"def title_case(s: str) -> str: Returns the input string with the first letter of each word capitalized. >>> title_case(\\"the quick brown fox\\") \\"The Quick Brown Fox\\" >>> title_case(\\"tHe QuIcK bRoWn fOx\\") \\"The Quick Brown Fox\\" >>> title_case(\\"THE QUICK BROWN FOX\\") \\"The Quick Brown Fox\\" >>> title_case(\\"python\\") \\"Python\\" >>> title_case(\\"PYTHON\\") \\"Python\\" >>> title_case(\\"\\") \\"\\" >>> title_case(\\"hello, world!\\") \\"Hello, World!\\"","solution":"def title_case(s): Returns the input string with the first letter of each word capitalized. return ' '.join(word.capitalize() for word in s.split())"},{"question":"def gcd(a: int, b: int) -> int: Helper function to find the Greatest Common Divisor (GCD) of two numbers using Euclid's algorithm. def largest_square_plot(M: int, N: int): Determines the side length of the largest square plot and the total number of such square plots needed to fill the entire garden with dimensions MxN. >>> largest_square_plot(20, 15) (5, 12) >>> largest_square_plot(10, 10) (10, 1) >>> largest_square_plot(1, 100) (1, 100) >>> largest_square_plot(1, 1) (1, 1) >>> largest_square_plot(7, 13) (1, 91)","solution":"def gcd(a, b): Helper function to find the Greatest Common Divisor (GCD) of two numbers using Euclid's algorithm. while b: a, b = b, a % b return a def largest_square_plot(M, N): Determines the side length of the largest square plot and the total number of such square plots needed to fill the entire garden with dimensions MxN. # Side length of the largest square plot side_length = gcd(M, N) # Number of such square plots required to fill the garden num_plots = (M // side_length) * (N // side_length) return side_length, num_plots"},{"question":"MOD = 10**9 + 7 def count_valid_sequences(N): Calculate the number of distinct valid sequences of N flashes that do not contain 'LL'. >>> count_valid_sequences(3) 5 >>> count_valid_sequences(4) 8 pass def solve(T, test_cases): Solve the problem for multiple test cases. >>> solve(2, [3, 4]) [5, 8] pass","solution":"MOD = 10**9 + 7 def count_valid_sequences(N): if N == 1: return 2 # \\"S\\", \\"L\\" elif N == 2: return 3 # \\"SS\\", \\"SL\\", \\"LS\\" # Dynamic programming approach dp = [0] * (N + 1) dp[1], dp[2] = 2, 3 for i in range(3, N + 1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[N] def solve(T, test_cases): results = [] for N in test_cases: results.append(count_valid_sequences(N)) return results"},{"question":"def determine_winner(N: int) -> str: Determines the winner of the stone game given N stones. Alice starts first, and the player forced to take the last stone loses. >>> determine_winner(4) 'Bob' >>> determine_winner(10) 'Alice' def game_results(test_cases: List[int]) -> List[str]: Given a list of test cases with the number of stones, returns the list of winners. >>> game_results([4, 10]) ['Bob', 'Alice'] >>> game_results([4, 8, 16]) ['Bob', 'Bob', 'Bob'] # Example of how to use these functions and some test cases: if __name__ == \\"__main__\\": print(determine_winner(4)) # Output: 'Bob' print(determine_winner(10)) # Output: 'Alice' print(game_results([4, 10])) # Output: ['Bob', 'Alice']","solution":"def determine_winner(N): Determines the winner of the stone game given N stones. Alice starts first, and the player forced to take the last stone loses. if N % 4 == 0: return \\"Bob\\" else: return \\"Alice\\" def game_results(test_cases): results = [] for N in test_cases: results.append(determine_winner(N)) return results"},{"question":"def max_benefit(T, test_cases): Calculate the maximum total benefit value for each test case by selecting a subset of non-interacting nodes. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int]]]]): List containing the test cases. Each test case is a tuple where the first element is the number of nodes, the second element is the number of edges, the third element is a list of benefit values of the nodes, and the fourth element is a list of edges. Returns: List[int]: List of maximum total benefit value for each test case. # your code here from typing import List, Tuple def process_input(input_data: str) -> Tuple[int, List[Tuple[int, int, List[int], List[Tuple[int, int]]]]]: Process the input data and convert it into a structured format. Args: input_data (str): Raw input data as a string. Returns: Tuple[int, List[Tuple[int, int, List[int], List[Tuple[int, int]]]]]: Processed data. input_data = input_data.strip().split('n') T = int(input_data[0]) test_cases = [] idx = 1 for _ in range(T): n = int(input_data[idx]) m = int(input_data[idx + 1]) benefits = list(map(int, input_data[idx + 2].split())) edges = [tuple(map(int, input_data[idx + 3 + j].split())) for j in range(m)] test_cases.append((n, m, benefits, edges)) idx += 3 + m return T, test_cases def generate_output(results: List[int]) -> str: Generate the output string from the results. Args: results (List[int]): List of results for each test case. Returns: str: Output data as a string. return 'n'.join(map(str, results)) def solve(input_data: str) -> str: Solve the problem based on the provided input data. Args: input_data (str): Raw input data as a string. Returns: str: Output data as a string. T, test_cases = process_input(input_data) results = max_benefit(T, test_cases) return generate_output(results) def test_max_benefit(): input_data = '''2 5 4 1 2 3 4 5 1 2 2 3 4 5 3 4 3 2 10 20 30 1 2 2 3 ''' expected_output = '''9 40 ''' assert solve(input_data) == expected_output.strip() def test_max_benefit_single_node(): input_data = '''1 1 0 10 ''' expected_output = '''10 ''' assert solve(input_data) == expected_output.strip() def test_max_benefit_no_edges(): input_data = '''1 3 0 4 8 4 ''' expected_output = '''16 ''' assert solve(input_data) == expected_output.strip() def test_max_benefit_all_interacting(): input_data = '''1 3 3 4 8 4 1 2 2 3 1 3 ''' expected_output = '''8 ''' assert solve(input_data) == expected_output.strip()","solution":"def max_benefit(T, test_cases): def find_max_non_interacting_nodes_benefit(n, m, benefits, edges): from itertools import combinations max_benefit_sum = 0 # Convert edge list to adjacency list adj = {i: set() for i in range(1, n+1)} for u, v in edges: adj[u].add(v) adj[v].add(u) # Try all subsets of the nodes to find the maximum non-interacting subset for r in range(1, n+1): for subset in combinations(range(1, n+1), r): if all(neigh not in subset for node in subset for neigh in adj[node]): subset_benefit = sum(benefits[node-1] for node in subset) max_benefit_sum = max(max_benefit_sum, subset_benefit) return max_benefit_sum results = [] for i in range(T): n, m, benefits, edges = test_cases[i] results.append(find_max_non_interacting_nodes_benefit(n, m, benefits, edges)) return results def process_input(input_data): input_data = input_data.strip().split('n') T = int(input_data[0]) test_cases = [] idx = 1 for _ in range(T): n = int(input_data[idx]) m = int(input_data[idx+1]) benefits = list(map(int, input_data[idx+2].split())) edges = [tuple(map(int, input_data[idx+3+j].split())) for j in range(m)] test_cases.append((n, m, benefits, edges)) idx += 3 + m return T, test_cases def generate_output(results): return 'n'.join(map(str, results)) def solve(input_data): T, test_cases = process_input(input_data) results = max_benefit(T, test_cases) return generate_output(results)"},{"question":"def smallest_diff(matrix, row, col): Finds the smallest absolute difference between the element located at matrix[row][col] and any other element in the matrix :param matrix: A 2D list of sorted integers. :param row: The row index of the target element. :param col: The column index of the target element. :return: An integer representing the smallest absolute difference. >>> matrix = [ ... [1, 3, 5], ... [2, 4, 6], ... [7, 8, 9] ... ] >>> smallest_diff(matrix, 1, 1) 1","solution":"def smallest_diff(matrix, row, col): Finds the smallest absolute difference between the element located at matrix[row][col] and any other element in the matrix :param matrix: A 2D list of sorted integers. :param row: The row index of the target element. :param col: The column index of the target element. :return: An integer representing the smallest absolute difference. if not matrix or len(matrix) == 0 or len(matrix[0]) == 0: return float('inf') target = matrix[row][col] min_diff = float('inf') for i in range(len(matrix)): for j in range(len(matrix[i])): if i == row and j == col: continue min_diff = min(min_diff, abs(target - matrix[i][j])) return min_diff"},{"question":"from typing import List, Tuple, Union def find_shortest_path(start: str, end: str, roads: List[Tuple[str, str]], blocked: List[Tuple[str, str]]) -> Union[List[str], str]: Returns the shortest path from the start intersection to the end intersection in a city's road network while avoiding blocked roads. >>> find_shortest_path(\\"A\\", \\"D\\", [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"A\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"B\\", \\"D\\")], [(\\"A\\", \\"C\\"), (\\"B\\", \\"D\\")]) [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] >>> find_shortest_path(\\"A\\", \\"C\\", [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"A\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"B\\", \\"D\\")], [(\\"A\\", \\"C\\"), (\\"B\\", \\"D\\")]) [\\"A\\", \\"B\\", \\"C\\"] >>> find_shortest_path(\\"A\\", \\"E\\", [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"A\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"B\\", \\"D\\")], [(\\"A\\", \\"C\\"), (\\"B\\", \\"D\\")]) \\"No path available from A to E\\"","solution":"from typing import List, Tuple, Union from collections import deque, defaultdict def find_shortest_path(start: str, end: str, roads: List[Tuple[str, str]], blocked: List[Tuple[str, str]]) -> Union[List[str], str]: # Create a graph representation graph = defaultdict(set) blocked_set = set(blocked) for a, b in roads: if (a, b) not in blocked_set and (b, a) not in blocked_set: graph[a].add(b) graph[b].add(a) # Perform BFS to find the shortest path queue = deque([(start, [start])]) visited = set(start) while queue: current_node, path = queue.popleft() if current_node == end: return path for neighbor in graph[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return f\\"No path available from {start} to {end}\\""},{"question":"def longest_palindrome_substring(s: str) -> str: Find the longest contiguous substring of the input string that forms a palindrome. >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindrome_substring(\\"a\\") == \\"a\\" True >>> longest_palindrome_substring(\\"racecar\\") == \\"racecar\\" True >>> longest_palindrome_substring(\\"\\") == \\"\\" True >>> longest_palindrome_substring(\\"abcd\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] True >>> longest_palindrome_substring(\\"madamannada\\") == \\"madam\\" True >>> longest_palindrome_substring(\\"noon\\") == \\"noon\\" True >>> longest_palindrome_substring(\\"bananas\\") == \\"anana\\" True","solution":"def longest_palindrome_substring(s: str) -> str: n = len(s) if n == 0: return \\"\\" # Define a 2D table to store the palindromic substring status. dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # All substrings of length 1 are palindromes. for i in range(n): dp[i][i] = True # Check for sub-strings of length 2. for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for lengths greater than 2. for length in range(3, n+1): for i in range(n - length + 1): j = i + length - 1 if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest distance from the top-left cell (0, 0) to the bottom-right cell (M-1, N-1) in an M x N grid, removing at most one obstacle. >>> shortest_path([[0, 1, 1], [0, 1, 1], [0, 0, 0]]) == 4 >>> shortest_path([[0, 1, 1], [1, 1, 1], [1, 0, 0]]) == -1","solution":"from collections import deque def shortest_path(grid): Find the shortest path from the top-left to bottom-right cell in a grid, given that we can remove at most one obstacle. # Constants for directions: right, down, left, up DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] n, m = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 def is_valid(x, y): return 0 <= x < n and 0 <= y < m # BFS with deque queue = deque([(0, 0, 0, 0)]) visited = {(0, 0, 0)} # (x, y, obstacles_removed) while queue: x, y, dist, obstacles_removed = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in DIRECTIONS: nx, ny = x + dx, y + dy if is_valid(nx, ny): if grid[nx][ny] == 0 and (nx, ny, obstacles_removed) not in visited: queue.append((nx, ny, dist+1, obstacles_removed)) visited.add((nx, ny, obstacles_removed)) elif grid[nx][ny] == 1 and obstacles_removed == 0 and (nx, ny, 1) not in visited: queue.append((nx, ny, dist+1, 1)) visited.add((nx, ny, 1)) return -1"},{"question":"def remove_duplicates(nums: List[int]) -> int: Removes duplicates from the sorted list 'nums' in-place such that each unique element appears at most twice. Returns the new length of nums after removing the duplicates. >>> nums = [1,1,1,2,2,3] >>> remove_duplicates(nums) 5 >>> nums[:5] [1,1,2,2,3] >>> nums = [0,0,1,1,1,1,2,3,3] >>> remove_duplicates(nums) 7 >>> nums[:7] [0,0,1,1,2,3,3]","solution":"def remove_duplicates(nums): Removes duplicates from the sorted list 'nums' in-place such that each unique element appears at most twice. Returns the new length of nums after removing the duplicates. if len(nums) <= 2: return len(nums) # Start from the third element and check for duplicates count = 2 for i in range(2, len(nums)): if nums[i] != nums[count - 2]: nums[count] = nums[i] count += 1 return count"},{"question":"def is_valid_arithmetic_operation(expression: str) -> bool: Determine whether a given string is a valid arithmetic operation. A valid arithmetic operation consists of integers and the arithmetic operators (+, -, *, /) without any spaces. The integers can be positive or negative and written in the standard decimal representation. The operators must be used in a mathematically valid way (e.g., avoiding division by zero). Args: expression (str): The arithmetic expression string to validate. Returns: bool: True if the expression is valid, False otherwise. Examples: >>> is_valid_arithmetic_operation(\\"3+5\\") == True >>> is_valid_arithmetic_operation(\\"-3+5*2\\") == True >>> is_valid_arithmetic_operation(\\"15/3\\") == True >>> is_valid_arithmetic_operation(\\"100/-5\\") == True >>> is_valid_arithmetic_operation(\\"3//5\\") == False >>> is_valid_arithmetic_operation(\\"15/0\\") == False >>> is_valid_arithmetic_operation(\\"3++5\\") == False >>> is_valid_arithmetic_operation(\\"3..5\\") == False","solution":"import re def is_valid_arithmetic_operation(expression: str) -> bool: # Regular expression to match valid arithmetic expressions pattern = r'^-?d+(.d+)?([+-*/]-?d+(.d+)?)*' # Check for valid format using regex if not re.match(pattern, expression): return False try: # Evaluate the expression to check for runtime errors like division by zero result = eval(expression) return True except (SyntaxError, ZeroDivisionError): return False"},{"question":"def rle_encode(s: str) -> str: Encodes the given string using the custom RLE scheme. Parameters: s (str): The input string consisting only of uppercase English letters. Returns: str: The RLE-encoded version of the string. Examples: >>> rle_encode(\\"AAABBBCCCA\\") 'A3B3C3A1' >>> rle_encode(\\"AABCCDD\\") 'A2B1C2D2' >>> rle_encode(\\"ABCD\\") 'A1B1C1D1' >>> rle_encode(\\"A\\") 'A1' >>> rle_encode(\\"AB\\") 'A1B1' >>> rle_encode(\\"\\") ''","solution":"def rle_encode(s): Encodes the given string using the custom RLE scheme. Parameters: s (str): The input string consisting only of uppercase English letters. Returns: str: The RLE-encoded version of the string. if not s: return \\"\\" encoded_str = [] count = 1 current_char = s[0] for char in s[1:]: if char == current_char: count += 1 else: encoded_str.append(current_char + str(count)) current_char = char count = 1 encoded_str.append(current_char + str(count)) return ''.join(encoded_str)"},{"question":"def swap_paired_elements(lst: List[int]) -> List[int]: Write a function \`swap_paired_elements\` that takes a list of integers, \`lst\`, and returns a new list where each two consecutive elements are swapped. If the list has an odd number of elements, the last element remains in its original position. Args: lst (list): The list of integers to swap elements in. Returns: list: A new list with pairs of elements swapped. Examples: >>> swap_paired_elements([1, 2, 3, 4]) [2, 1, 4, 3] >>> swap_paired_elements([5, 6, 7]) [6, 5, 7] >>> swap_paired_elements([8]) [8] >>> swap_paired_elements([]) []","solution":"def swap_paired_elements(lst): Returns a list where each two consecutive elements are swapped. If the list has an odd number of elements, the last element remains in its original position. Args: lst (list): The list of integers to swap elements in. Returns: list: A new list with pairs of elements swapped. result = lst[:] for i in range(0, len(lst) - 1, 2): result[i], result[i + 1] = result[i + 1], result[i] return result"},{"question":"def all_anagrams(word_list): Implement a function that takes a list of words and returns a dictionary where each key is a sorted string of characters and the corresponding value is a list of words from the input that are anagrams of each other. >>> all_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goolge\\", \\"abc\\", \\"cab\\", \\"bca\\"]) {'eilnst': ['listen', 'silent', 'enlist'], 'eggloo': ['google', 'goolge'], 'abc': ['abc', 'cab', 'bca']} >>> all_anagrams([]) {} >>> all_anagrams([\\"dog\\", \\"cat\\", \\"bird\\"]) {'dgo': ['dog'], 'act': ['cat'], 'bdir': ['bird']} >>> all_anagrams([\\"Listen\\", \\"Silent\\", \\"Enlist\\", \\"google\\", \\"goolge\\", \\"abc\\", \\"cab\\", \\"bca\\"]) {'Leinst': ['Listen'], 'Seilnt': ['Silent'], 'Eilnst': ['Enlist'], 'eggloo': ['google', 'goolge'], 'abc': ['abc', 'cab', 'bca']} >>> all_anagrams([\\"word\\"]) {'dorw': ['word']} >>> all_anagrams([\\"apple\\", \\"papel\\", \\"apple\\"]) {'aelpp': ['apple', 'papel', 'apple']}","solution":"def all_anagrams(word_list): Returns a dictionary where each key is a sorted string of characters and the corresponding value is a list of words from the input that are anagrams of each other. anagrams = {} for word in word_list: sorted_word = ''.join(sorted(word)) if sorted_word not in anagrams: anagrams[sorted_word] = [] anagrams[sorted_word].append(word) return anagrams"},{"question":"def sort_words_by_length(words: List[str]) -> List[str]: Sorts words by their length in descending order. If two words have the same length, the sorting is done alphabetically. Args: words (list of str): The list of words to sort. Returns: list of str: The sorted list of words. >>> sort_words_by_length(['apple', 'pear', 'banana', 'cherry', 'grape']) ['banana', 'cherry', 'apple', 'grape', 'pear'] >>> sort_words_by_length(['cat', 'bat', 'hat', 'rat', 'mat']) ['bat', 'cat', 'hat', 'mat', 'rat'] >>> sort_words_by_length(['Apple', 'pear', 'Banana', 'CHERRY', 'grape']) ['Banana', 'CHERRY', 'Apple', 'grape', 'pear'] >>> sort_words_by_length([]) [] >>> sort_words_by_length(['single']) ['single'] >>> sort_words_by_length(['1234', '12', '123', '12345', '1']) ['12345', '1234', '123', '12', '1']","solution":"def sort_words_by_length(words): Sorts words by their length in descending order. If two words have the same length, the sorting is done alphabetically. Args: words (list of str): The list of words to sort. Returns: list of str: The sorted list of words. return sorted(words, key=lambda x: (-len(x), x))"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Determine the minimum number of minutes until no cell has a fresh orange. >> orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]]) 4 >> orangesRotting([[0, 0, 0], [0, 0, 0]]) 0 >> orangesRotting([[1, 1, 1], [1, 1, 1]]) -1 >> orangesRotting([[2, 1, 1], [0, 1, 1], [1, 0, 1]]) -1 >> orangesRotting([[0, 2, 2], [1, 1, 0], [0, 1, 0]]) 2","solution":"from collections import deque def orangesRotting(grid): rows, cols = len(grid), len(grid[0]) queue = deque() fresh = 0 # Prepare the initial state of the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh += 1 if fresh == 0: return 0 # Directions for the 4-adjacent cells directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] minutes = 0 while queue: minutes += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and grid[rr][cc] == 1: grid[rr][cc] = 2 fresh -= 1 queue.append((rr, cc)) if fresh == 0: return minutes return -1 if fresh else 0"},{"question":"from typing import List def process_order(store_inventory: List[int], order: List[int]) -> bool: Checks if an order can be fulfilled with the current store inventory and updates the inventory if possible. Args: store_inventory (List[int]): List of integers representing the current store inventory. order (List[int]): List of integers representing the order to be fulfilled. Returns: bool: True if the order can be fulfilled, False otherwise. Examples: >>> store_inventory = [10, 5, 7, 3] >>> order = [2, 5, 6, 1] >>> process_order(store_inventory, order) True >>> store_inventory [8, 0, 1, 2] >>> store_inventory = [4, 2, 3] >>> order = [5, 1, 3] >>> process_order(store_inventory, order) False >>> store_inventory [4, 2, 3]","solution":"from typing import List def process_order(store_inventory: List[int], order: List[int]) -> bool: Checks if an order can be fulfilled with the current store inventory and updates the inventory if possible. Args: store_inventory (List[int]): List of integers representing the current store inventory. order (List[int]): List of integers representing the order to be fulfilled. Returns: bool: True if the order can be fulfilled, False otherwise. # First, check if the order can be fulfilled for inventory, ordered_qty in zip(store_inventory, order): if ordered_qty > inventory: return False # If the order can be fulfilled, update the store inventory for i in range(len(store_inventory)): store_inventory[i] -= order[i] return True"},{"question":"from typing import List def min_removals_to_palindrome_permutation(t: int, cases: List[str]) -> List[int]: You are given a string s which consists of lowercase English alphabets. Your task is to remove the minimum number of characters to make the string a \\"palindrome permutation,\\" which means the string can be rearranged to form a palindrome. Args: t (int): number of test cases cases (List[str]): list of strings consisting of lowercase English letters Returns: List[int]: list of minimum number of characters needed to be removed for each string to make it a palindrome permutation. Example: >>> min_removals_to_palindrome_permutation(4, [\\"abcb\\", \\"aabbbcc\\", \\"abc\\", \\"racecar\\"]) [1, 0, 2, 0] >>> min_removals_to_palindrome_permutation(1, [\\"a\\"]) [0]","solution":"from collections import Counter def min_removals_to_palindrome_permutation(t, cases): results = [] for s in cases: freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) if odd_count <= 1: results.append(0) else: results.append(odd_count - 1) return results"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the given parentheses string is valid and balanced. Args: s (str): The input string consisting only of '(' and ')'. Returns: bool: True if the string is a valid and balanced parentheses string, False otherwise. pass # Unit Tests def test_valid_parentheses_single_pair(): assert is_valid_parentheses(\\"()\\") == True def test_valid_parentheses_multiple_pairs(): assert is_valid_parentheses(\\"()()\\") == True assert is_valid_parentheses(\\"(())\\") == True def test_invalid_parentheses_unmatched_open(): assert is_valid_parentheses(\\"(()\\") == False def test_invalid_parentheses_unmatched_close(): assert is_valid_parentheses(\\"())\\") == False def test_valid_parentheses_empty_string(): assert is_valid_parentheses(\\"\\") == True def test_invalid_parentheses_wrong_order(): assert is_valid_parentheses(\\")(\\") == False def test_valid_parentheses_complex_balanced(): assert is_valid_parentheses(\\"((())())\\") == True def test_invalid_parentheses_complex_unbalanced(): assert is_valid_parentheses(\\"((())())(\\") == False","solution":"def is_valid_parentheses(s): Determines if the given parentheses string is valid and balanced. Args: s (str): The input string consisting only of '(' and ')'. Returns: bool: True if the string is a valid and balanced parentheses string, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def evaluateExpression(expr: str) -> int: Evaluates a mathematical expression and returns the result as an integer. The expression contains positive integers, +, -, *, / operators and follows the order of operations (PEMDAS/BODMAS). >>> evaluateExpression(\\"3+5*2\\") 13 >>> evaluateExpression(\\"10+2*6\\") 22 >>> evaluateExpression(\\"100*2+12\\") 212 >>> evaluateExpression(\\"100*(2+12)\\") 1400 >>> evaluateExpression(\\"100*(2+12)/14\\") 100","solution":"def evaluateExpression(expr): Evaluates a mathematical expression and returns the result as an integer. The expression contains positive integers, +, -, *, / operators and follows the order of operations (PEMDAS/BODMAS). def calculate(s): stack = [] num, sign = 0, '+' while len(s) > 0: c = s.pop(0) if c.isdigit(): num = num * 10 + int(c) if c == '(': num = calculate(s) if (not c.isdigit() and c != ' ') or len(s) == 0: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) # Integer division num, sign = 0, c if c == ')': break return sum(stack) return calculate(list(expr))"},{"question":"def shift_string(s: str, k: int) -> str: Shifts each character in the string 's' by 'k' positions in the alphabet. Parameters: s (str): The input string consisting of lowercase letters. k (int): The number of positions each character in 's' should be shifted. Returns: str: A new string with each character shifted by 'k' positions. >>> shift_string(\\"abc\\", 2) \\"cde\\" >>> shift_string(\\"xyz\\", 3) \\"abc\\" >>> shift_string(\\"abc\\", -1) \\"zab\\" pass # Unit tests def test_shift_positive_k(): assert shift_string(\\"abc\\", 2) == \\"cde\\" assert shift_string(\\"xyz\\", 3) == \\"abc\\" assert shift_string(\\"hello\\", 5) == \\"mjqqt\\" def test_shift_negative_k(): assert shift_string(\\"abc\\", -1) == \\"zab\\" assert shift_string(\\"xyz\\", -3) == \\"uvw\\" assert shift_string(\\"hello\\", -5) == \\"czggj\\" def test_shift_with_zero_k(): assert shift_string(\\"abc\\", 0) == \\"abc\\" assert shift_string(\\"xyz\\", 0) == \\"xyz\\" def test_shift_large_k_positive(): assert shift_string(\\"abc\\", 25) == \\"zab\\" assert shift_string(\\"xyz\\", 25) == \\"wxy\\" def test_shift_large_k_negative(): assert shift_string(\\"abc\\", -25) == \\"bcd\\" assert shift_string(\\"xyz\\", -25) == \\"yza\\"","solution":"def shift_string(s: str, k: int) -> str: Shifts each character in the string 's' by 'k' positions in the alphabet. Parameters: s (str): The input string consisting of lowercase letters. k (int): The number of positions each character in 's' should be shifted. Returns: str: A new string with each character shifted by 'k' positions. shifted_string = [] for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) shifted_string.append(new_char) return ''.join(shifted_string)"},{"question":"def minimum_flip_operations(H: int, W: int, grid: List[str]) -> int: Returns the minimum number of flip operations required to make all cells in the grid the same color. Each cell in the grid is colored either white ('W') or black ('B'). H -- number of rows W -- number of columns grid -- list of strings representing the grid >>> minimum_flip_operations(3, 4, [\\"WBWB\\", \\"BWBW\\", \\"WBWB\\"]) == 1 >>> minimum_flip_operations(2, 2, [\\"WW\\", \\"WW\\"]) == 0 >>> minimum_flip_operations(3, 3, [\\"BBB\\", \\"BBB\\", \\"BBB\\"]) == 0 >>> minimum_flip_operations(2, 2, [\\"BW\\", \\"WB\\"]) == 1 >>> minimum_flip_operations(3, 3, [\\"BWW\\", \\"WBB\\", \\"BWB\\"]) == 1 from typing import List","solution":"def minimum_flip_operations(H, W, grid): Returns the minimum number of flip operations required to make all cells in the grid the same color. Each cell in the grid is colored either white ('W') or black ('B'). H -- number of rows W -- number of columns grid -- list of strings representing the grid white_count = sum(row.count('W') for row in grid) black_count = H * W - white_count return min(1, white_count, black_count)"},{"question":"def group_names_by_first_name(names): Given a list of full names, returns a dictionary with first names as keys and a list of corresponding last names as values. :param names: List of full names as strings :return: Dictionary with first names as keys and a list of last names as values >>> group_names_by_first_name([\\"John Doe\\", \\"Jane Smith\\", \\"John Smith\\", \\"Jane Doe\\"]) {'John': ['Doe', 'Smith'], 'Jane': ['Smith', 'Doe']} >>> group_names_by_first_name([\\"Alice Wonderland\\"]) {'Alice': ['Wonderland']} >>> group_names_by_first_name([\\"Alice Wonderland\\", \\"Alice Liddell\\", \\"Alice Kingsleigh\\"]) {'Alice': ['Wonderland', 'Liddell', 'Kingsleigh']} >>> group_names_by_first_name([\\"Bruce Wayne\\", \\"Clark Kent\\", \\"Diana Prince\\"]) {'Bruce': ['Wayne'], 'Clark': ['Kent'], 'Diana': ['Prince']} >>> group_names_by_first_name([\\"Alice Liddell\\", \\"Alice Wonderland\\", \\"Bob Builder\\", \\"Alice Kingsleigh\\"]) {'Alice': ['Liddell', 'Wonderland', 'Kingsleigh'], 'Bob': ['Builder']}","solution":"def group_names_by_first_name(names): Given a list of full names, returns a dictionary with first names as keys and a list of corresponding last names as values. :param names: List of full names as strings :return: Dictionary with first names as keys and a list of last names as values name_dict = {} for full_name in names: first_name, last_name = full_name.split() if first_name not in name_dict: name_dict[first_name] = [] name_dict[first_name].append(last_name) return name_dict"},{"question":"def process_circuit_operations(N: int, M: int, initial_states: List[int], output_indices: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]: Simulate the circuit based on AND, OR, XOR operations and find the state of the outputs. Parameters: N (int): Number of initial inputs M (int): Number of final outputs initial_states (List[int]): The initial states of the inputs output_indices (List[int]): Output indices whose states are needed operations (List[Tuple[str, int, int, int]]): A list of tuples representing gate operations Returns: List[int]: The states of the outputs >>> process_circuit_operations(3, 2, [1, 0, 1], [2, 3], [('AND', 1, 2, 4), ('OR', 2, 3, 5), ('XOR', 1, 3, 6), ('AND', 4, 5, 7)]) [0, 1] >>> process_circuit_operations(2, 1, [1, 1], [3], [('AND', 1, 2, 3)]) [1] >>> process_circuit_operations(4, 2, [0, 1, 1, 0], [5, 6], [('OR', 1, 2, 5), ('XOR', 3, 4, 6)]) [1, 1]","solution":"def process_circuit_operations(N, M, initial_states, output_indices, operations): states = initial_states[:] for operation, input1, input2, output in operations: if operation == 'AND': states.append(states[input1 - 1] & states[input2 - 1]) elif operation == 'OR': states.append(states[input1 - 1] | states[input2 - 1]) elif operation == 'XOR': states.append(states[input1 - 1] ^ states[input2 - 1]) return [states[index - 1] for index in output_indices] def solve(T, test_cases): results = [] for test_case in test_cases: N, M, initial_states, output_indices, operations = test_case result = process_circuit_operations(N, M, initial_states, output_indices, operations) results.append(result) return results"},{"question":"def single_number(nums): Finds the single number in the array where every other element appears twice. Args: nums (list): A list of integers Returns: int: The single number Examples: >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4","solution":"def single_number(nums): Finds the single number in the array where every other element appears twice. Args: nums (list): A list of integers Returns: int: The single number result = 0 for num in nums: result ^= num return result"},{"question":"def min_street_lamps(T: int, test_cases: List[int]) -> List[int]: Determine the minimum number of street lamps that need to be turned on such that each row and each column has at least one street lamp that is on. >>> min_street_lamps(2, [3, 4]) [3, 4] >>> min_street_lamps(1, [1]) [1]","solution":"def min_street_lamps(T, test_cases): Given the number of test cases and a list of grid sizes, returns a list of the minimum number of street lamps that need to be turned on for each grid. Args: - T: int, the number of test cases. - test_cases: list of int, the sizes of the grids (n x n). Returns: - min_lamps: list of int, the minimum number of street lamps for each grid size. return test_cases # Example usage: # T = 2 # test_cases = [3, 4] # Output should be [3, 4]"},{"question":"def update_grid(n: int, m: int, updates: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: You have a rectangular grid of cells with dimensions n x m. Each cell initially holds a value of 0. You are given a sequence of update instructions, each specifying a sub-rectangle within the grid and a value to add to every cell in that sub-rectangle. n: the number of rows in the grid (1 ≤ n ≤ 1000) m: the number of columns in the grid (1 ≤ m ≤ 1000) updates: a list of tuples, each of the form (r1, c1, r2, c2, v), where (r1, c1) is the top-left cell and (r2, c2) is the bottom-right cell of the sub-rectangle, and v is the value to add to each cell in that sub-rectangle (1 ≤ r1 ≤ r2 ≤ n, 1 ≤ c1 ≤ c2 ≤ m, -1000 ≤ v ≤ 1000). The sequence of updates can be at most 1000 updates long. Returns the final grid after all updates have been applied. >>> update_grid(3, 3, [(1, 1, 2, 2, 5), (2, 2, 3, 3, 10)]) [ [5, 5, 0], [5, 15, 10], [0, 10, 10] ] pass from typing import List, Tuple def test_single_update(): assert update_grid(3, 3, [(1, 1, 2, 2, 5)]) == [ [5, 5, 0], [5, 5, 0], [0, 0, 0] ] def test_multiple_updates(): assert update_grid(3, 3, [(1, 1, 2, 2, 5), (2, 2, 3, 3, 10)]) == [ [5, 5, 0], [5, 15, 10], [0, 10, 10] ] def test_non_overlapping_updates(): assert update_grid(3, 3, [(1, 1, 1, 1, 3), (3, 3, 3, 3, 7)]) == [ [3, 0, 0], [0, 0, 0], [0, 0, 7] ] def test_complete_grid_update(): assert update_grid(2, 2, [(1, 1, 2, 2, 1)]) == [ [1, 1], [1, 1] ] def test_large_number_of_updates(): n, m = 2, 2 updates = [(1, 1, 2, 2, 1)] * 1000 assert update_grid(n, m, updates) == [ [1000, 1000], [1000, 1000] ] def test_negative_values(): assert update_grid(3, 3, [(1, 1, 2, 2, -5), (2, 2, 3, 3, 5)]) == [ [-5, -5, 0], [-5, 0, 5], [0, 5, 5] ]","solution":"def update_grid(n, m, updates): grid = [[0] * m for _ in range(n)] for r1, c1, r2, c2, v in updates: for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): grid[i][j] += v return grid"},{"question":"def count_sunset_views(buildings): Returns the number of buildings that can see the sunset. A building can see the sunset if it is taller than all buildings to its right. :param buildings: List of integers representing the heights of the buildings. :return: Integer number of buildings that can see the sunset. >>> count_sunset_views([4, 3, 2, 3, 1]) 3 >>> count_sunset_views([1, 2, 3, 4, 5]) 1 >>> count_sunset_views([5, 4, 3, 2, 1]) 5","solution":"def count_sunset_views(buildings): Returns the number of buildings that can see the sunset. A building can see the sunset if it is taller than all buildings to its right. :param buildings: List of integers representing the heights of the buildings. :return: Integer number of buildings that can see the sunset. if not buildings: return 0 max_height = 0 view_count = 0 # Traverse the buildings from right to left for height in reversed(buildings): if height > max_height: view_count += 1 max_height = height return view_count"},{"question":"def min_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. The permitted operations are: 1. Insert a character. 2. Remove a character. 3. Replace a character. Example: >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base case for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # remove dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n]"},{"question":"def squared_evens(nums: List[int]) -> List[int]: Write a function that accepts a list of integers and returns a new list containing the squares of only the even numbers from the original list, maintaining their order of appearance. >>> squared_evens([1, 2, 3, 4, 5]) [4, 16] >>> squared_evens([10, 15, 20, 25]) [100, 400] >>> squared_evens([1, 3, 5, 7]) [] pass from solution import squared_evens def test_squared_evens_all_even(): assert squared_evens([2, 4, 6, 8]) == [4, 16, 36, 64] def test_squared_evens_mixed_numbers(): assert squared_evens([1, 2, 3, 4, 5]) == [4, 16] def test_squared_evens_no_evens(): assert squared_evens([1, 3, 5, 7]) == [] def test_squared_evens_empty_list(): assert squared_evens([]) == [] def test_squared_evens_single_even(): assert squared_evens([2]) == [4] def test_squared_evens_single_odd(): assert squared_evens([3]) == [] def test_squared_evens_negative_numbers(): assert squared_evens([-2, -4, -6]) == [4, 16, 36] def test_squared_evens_mixed_sign_numbers(): assert squared_evens([-3, 2, -5, 4, -7]) == [4, 16] def test_squared_evens_large_numbers(): assert squared_evens([10**6, 10**7]) == [10**12, 10**14]","solution":"def squared_evens(nums): Returns a list of squares of even numbers from the input list. return [x ** 2 for x in nums if x % 2 == 0]"},{"question":"def trap(height): Calculates the total amount of trapped water in the given height map. Parameters: height (list of int): List of non-negative integers representing the elevation at each point. Returns: int: Total units of trapped water. Examples: >>> trap([]) 0 >>> trap([1, 1, 1, 1]) 0 >>> trap([2, 0, 2]) 2 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Calculates the total amount of trapped water in the given height map. Parameters: height (list of int): List of non-negative integers representing the elevation at each point. Returns: int: Total units of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from datetime import datetime def canSchedule(existing_bookings, new_booking): Determines if the new booking can be scheduled without any conflicts. Args: existing_bookings (list of dict): A list of existing bookings with 'start' and 'end' times. new_booking (dict): A new booking request with 'start' and 'end' times. Returns: bool: True if the new booking can be scheduled without any conflicts, False otherwise. >>> existing_bookings = [ >>> {'start': '09:00', 'end': '10:30'}, >>> {'start': '11:00', 'end': '12:00'}, >>> {'start': '14:00', 'end': '15:30'} >>> ] >>> new_booking = {'start': '10:30', 'end': '11:00'} >>> canSchedule(existing_bookings, new_booking) True >>> existing_bookings = [ >>> {'start': '09:00', 'end': '10:30'}, >>> {'start': '11:00', 'end': '12:00'}, >>> {'start': '14:00', 'end': '15:30'} >>> ] >>> new_booking = {'start': '10:00', 'end': '11:30'} >>> canSchedule(existing_bookings, new_booking) False","solution":"from datetime import datetime def canSchedule(existing_bookings, new_booking): Determines if the new booking can be scheduled without any conflicts. Args: existing_bookings (list of dict): A list of existing bookings with 'start' and 'end' times. new_booking (dict): A new booking request with 'start' and 'end' times. Returns: bool: True if the new booking can be scheduled without any conflicts, False otherwise. new_start = datetime.strptime(new_booking['start'], '%H:%M') new_end = datetime.strptime(new_booking['end'], '%H:%M') for booking in existing_bookings: existing_start = datetime.strptime(booking['start'], '%H:%M') existing_end = datetime.strptime(booking['end'], '%H:%M') # Check if there is any overlap if new_start < existing_end and existing_start < new_end: return False return True"},{"question":"def can_form_palindrome(s: str) -> str: Checks if it's possible to reorder the string s into a palindrome. Returns 'YES' and the lexicographically smallest palindromic string if possible, otherwise 'NO'. >>> can_form_palindrome(\\"aabb\\") 'YES abba' >>> can_form_palindrome(\\"abc\\") 'NO' def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases for checking palindrome reordering. >>> test_cases = [\\"aabb\\", \\"abc\\", \\"aaabb\\"] >>> process_test_cases(test_cases) [\\"YES abba\\", \\"NO\\", \\"YES ababa\\"]","solution":"def can_form_palindrome(s): Checks if it's possible to reorder the string s into a palindrome. Returns ('YES', palindromic string) if possible and ('NO') otherwise. from collections import Counter count = Counter(s) odd_char_count = sum(1 for x in count.values() if x % 2 != 0) # A string can form a palindrome if there's at most one character with an odd count if odd_char_count > 1: return \\"NO\\" # Construct the smallest lexicographical palindrome half_palindrome = [] middle_char = '' for char in sorted(count.keys()): if count[char] % 2 != 0: middle_char = char half_palindrome.append(char * (count[char] // 2)) first_half = ''.join(half_palindrome) second_half = first_half[::-1] return f\\"YES {first_half + middle_char + second_half}\\" def process_test_cases(test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def count_overlapping_occurrences(text: str, pattern: str) -> int: Counts the number of overlapping occurrences of a pattern in a given text. Parameters: text (str): The main string in which to search for the pattern. pattern (str): The substring to search for in the text. Returns: int: The number of overlapping occurrences of pattern within text. >>> count_overlapping_occurrences(\\"abababa\\", \\"aba\\") 3 >>> count_overlapping_occurrences(\\"aaaa\\", \\"aa\\") 3","solution":"def count_overlapping_occurrences(text, pattern): Counts the number of overlapping occurrences of a pattern in a given text. Parameters: text (str): The main string in which to search for the pattern. pattern (str): The substring to search for in the text. Returns: int: The number of overlapping occurrences of pattern within text. count = 0 start = 0 while True: start = text.find(pattern, start) if start == -1: break count += 1 start += 1 return count"},{"question":"def shift_string_by_three(s: str) -> str: Shifts each character in the input string by three positions ahead in the alphabet. Wraps around to the beginning if necessary. Parameters: s (str): A string consisting of lowercase alphabetic characters. Returns: str: A new string with each character shifted by three positions. >>> shift_string_by_three(\\"abc\\") 'def' >>> shift_string_by_three(\\"xyz\\") 'abc' >>> shift_string_by_three(\\"hello\\") 'khoor' >>> shift_string_by_three(\\"\\") ''","solution":"def shift_string_by_three(s): Shifts each character in the input string by three positions ahead in the alphabet. Wraps around to the beginning if necessary. Parameters: s (str): A string consisting of lowercase alphabetic characters. Returns: str: A new string with each character shifted by three positions. shifted_string = '' for char in s: shifted_char = chr((ord(char) - ord('a') + 3) % 26 + ord('a')) shifted_string += shifted_char return shifted_string"},{"question":"import re from collections import Counter from typing import List def word_frequencies(s: str, k: int) -> List[str]: Returns the top k most frequent words from the given string s. Words are returned in lowercase and punctuation is ignored. If frequencies tie, words are returned lexicographically. >>> word_frequencies(\\"Hello world! Hello universe. Hello everyone.\\", 2) == [\\"hello\\", \\"everyone\\"] >>> word_frequencies(\\"A quick brown fox jumps over the lazy dog.\\", 5) == [\\"a\\", \\"brown\\", \\"dog\\", \\"fox\\", \\"jumps\\"] >>> word_frequencies(\\"dog apple banana apple banana cat dog cat\\", 3) == [\\"apple\\", \\"banana\\", \\"cat\\"] >>> word_frequencies(\\"dog apple banana apple banana\\", 10) == [\\"apple\\", \\"banana\\", \\"dog\\"] >>> word_frequencies(\\"\\", 3) == [] >>> word_frequencies(\\"Hello! Hello? HELLO, world.\\", 2) == [\\"hello\\", \\"world\\"] >>> word_frequencies(\\"Dog DOG dog\\", 1) == [\\"dog\\"]","solution":"import re from collections import Counter def word_frequencies(s: str, k: int): Returns the top k most frequent words from the given string s. Words are returned in lowercase and punctuation is ignored. If frequencies tie, words are returned lexicographically. # Remove punctuation and make lowercase words = re.findall(r'bw+b', s.lower()) # Count word frequencies word_count = Counter(words) # Sort words first by frequency and then lexicographically sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) # Return the top k words return [word for word, _ in sorted_words[:k]]"},{"question":"def generate_parentheses(n): Generates all valid combinations of n pairs of parentheses. :param n: int, the number of pairs of parentheses. :return: List of strings, each string is a valid combination of n pairs of parentheses. def test_generate_parentheses_zero(): assert generate_parentheses(0) == [''] def test_generate_parentheses_one(): assert generate_parentheses(1) == ['()'] def test_generate_parentheses_two(): result = generate_parentheses(2) expected = ['(())', '()()'] assert len(result) == len(expected) for r in result: assert r in expected def test_generate_parentheses_three(): result = generate_parentheses(3) expected = ['((()))', '(()())', '(())()', '()(())', '()()()'] assert len(result) == len(expected) for r in result: assert r in expected def test_generate_parentheses_four(): result = generate_parentheses(4) expected = ['(((())))', '((()()))', '((())())', '((()))()', '(()(()))', '(()()())', '(()())()', '(())(())', '(())()()', '()((()))', '()(()())', '()(())()', '()()(())', '()()()()'] assert len(result) == len(expected) for r in result: assert r in expected","solution":"def generate_parentheses(n): Generates all valid combinations of n pairs of parentheses. :param n: int, the number of pairs of parentheses. :return: List of strings, each string is a valid combination of n pairs of parentheses. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s+'(', left+1, right) if right < left: backtrack(s+')', left, right+1) result = [] backtrack() return result"},{"question":"def findPairs(arr: List[int], target: int) -> List[List[int]]: Finds all unique pairs of integers from the input array that sum up to the target. Each pair is presented as a sorted array [a, b] where a <= b, and pairs are sorted. Args: arr (List[int]): An array of integers. target (int): The target sum. Returns: List[List[int]]: A list of unique pairs that sum up to the target. Examples: >>> findPairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> findPairs([1, 2, -1, -2, 3], 1) [[-2, 3], [-1, 2]] >>> findPairs([1, 2, 2, 3, 4], 4) [[1, 3], [2, 2]] >>> findPairs([1, 2, 3], 6) [] from typing import List def test_example_cases(): assert findPairs([1, 2, 3, 4, 5], 5) == [[1, 4], [2, 3]] assert findPairs([1, 2, -1, -2, 3], 1) == [[-2, 3], [-1, 2]] assert findPairs([1, 2, 2, 3, 4], 4) == [[1, 3], [2, 2]] assert findPairs([1, 2, 3], 6) == [] def test_no_pairs(): assert findPairs([1, 2, 3], 10) == [] assert findPairs([], 4) == [] def test_single_element(): assert findPairs([2], 4) == [] assert findPairs([2], 2) == [] def test_zero_target(): assert findPairs([0, 0, 0], 0) == [[0, 0]] assert findPairs([1, -1, 2, -2, 3], 0) == [[-2, 2], [-1, 1]] def test_multiple_solutions(): assert findPairs([3, 1, 4, 1, 5], 6) == [[1, 5]] assert findPairs([1, 1, 1, 1], 2) == [[1, 1]] def test_large_numbers(): assert findPairs([1000000, 500000, -500000, -1000000], 0) == [[-1000000, 1000000], [-500000, 500000]] def test_duplicates_handling(): assert findPairs([1, 1, 1, 9, 9, 9], 10) == [[1, 9]]","solution":"def findPairs(arr, target): Finds all unique pairs of integers from the input array that sum up to the target. Each pair is presented as a sorted array [a, b] where a <= b, and pairs are sorted. pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) # Convert the set of tuples to a sorted list of lists result = sorted([list(pair) for pair in pairs]) return result"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if any anagram of the input string can be a palindrome. Args: s (str): The input string of lowercase alphabetical characters. Returns: bool: True if any anagram of the input string can be a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False","solution":"def can_form_palindrome(s): Determines if any anagram of the input string can be a palindrome. Args: s (str): The input string of lowercase alphabetical characters. Returns: bool: True if any anagram of the input string can be a palindrome, False otherwise. from collections import Counter # Count the occurrences of each character counts = Counter(s) # Palindrome Condition: At most one character can have an odd count odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def is_within_working_hours(time_str: str) -> bool: Determines if the given time falls within working hours (9 AM to 5 PM inclusive). Args: time_str (str): A string representing the time in \\"HH:MM AM/PM\\" format. Returns: bool: True if the time is within working hours, False otherwise. Examples: >>> is_within_working_hours(\\"08:30 AM\\") False >>> is_within_working_hours(\\"09:00 AM\\") True >>> is_within_working_hours(\\"12:45 PM\\") True >>> is_within_working_hours(\\"05:01 PM\\") False","solution":"def is_within_working_hours(time_str): Determines if the given time falls within working hours (9 AM to 5 PM inclusive). Args: time_str (str): A string representing the time in \\"HH:MM AM/PM\\" format. Returns: bool: True if the time is within working hours, False otherwise. parts = time_str.split() time_part = parts[0] am_pm_part = parts[1] hours, minutes = map(int, time_part.split(':')) # Convert 12 hour format to 24 hour format if am_pm_part == \\"AM\\" and hours == 12: hours = 0 elif am_pm_part == \\"PM\\" and hours != 12: hours += 12 if (9 <= hours < 17) or (hours == 17 and minutes == 0): return True return False"},{"question":"def reverse_and_insert(s: str, char: str) -> str: Reverses every word in the string 's' and inserts 'char' between each character of the reversed words. Args: s (str): The input string containing words to be processed. char (str): The character to insert between each character of the reversed words. Returns: str: The processed string with each word reversed and the character inserted. Example: >>> reverse_and_insert(\\"hello world\\", '*') 'o*l*l*e*h w*o*r*l*d' >>> reverse_and_insert(\\"one two\\", '|') 'e|n|o o|w|t'","solution":"def reverse_and_insert(s, char): Reverses every word in the string \`s\` and inserts \`char\` between each character of the reversed words. def transform_word(word): return char.join(list(word[::-1])) words = s.split() transformed_words = [transform_word(word) for word in words] return ' '.join(transformed_words)"},{"question":"def is_opposite(n: int) -> str: Write a function is_opposite that takes an integer n and returns whether the binary representation of the number reads the same forwards and backwards (a palindrome). If it is a palindrome, return \\"It's Palindromic!\\", otherwise return \\"Not Palindromic.\\" >>> is_opposite(9) \\"It's Palindromic!\\" >>> is_opposite(12) \\"Not Palindromic.\\"","solution":"def is_opposite(n): Returns whether the binary representation of an integer n is palindromic. If it is palindromic, returns \\"It's Palindromic!\\", otherwise \\"Not Palindromic.\\" binary_representation = bin(n)[2:] if binary_representation == binary_representation[::-1]: return \\"It's Palindromic!\\" else: return \\"Not Palindromic.\\""},{"question":"class VendingMachine: Simulates the operation of a vending machine that sells Cola and Water. The vending machine starts fully stocked with Cola and Water, and allows customers to purchase drinks, restock inventory, and check sales. def __init__(self): Initialize the vending machine with starting stock levels and prices. pass def purchase(self, drink_type: str) -> str: Allows a customer to purchase a drink. Args: drink_type: The type of drink (\\"Cola\\" or \\"Water\\") to purchase. Returns: A string indicating the result of the purchase: - \\"Thank you for your purchase!\\" if the purchase is successful - \\"Out of stock\\" if the drink is unavailable - \\"Invalid drink type\\" if the drink type is not recognized pass def restock(self, drink_type: str, amount: int) -> None: Restocks the specified drink type. Args: drink_type: The type of drink (\\"Cola\\" or \\"Water\\") to restock. amount: The amount of the drink to add to the inventory. pass def sales(self) -> dict: Returns the total sales of each drink. Returns: A dictionary with the drink types as keys and the number of sales as values. pass # Unit Tests def test_initial_stock(): vm = VendingMachine() assert vm.stock == {'Cola': 10, 'Water': 10} def test_purchase_cola(): vm = VendingMachine() assert vm.purchase(\\"Cola\\") == \\"Thank you for your purchase!\\" assert vm.stock[\\"Cola\\"] == 9 assert vm.sales() == {'Cola': 1, 'Water': 0} def test_purchase_water(): vm = VendingMachine() assert vm.purchase(\\"Water\\") == \\"Thank you for your purchase!\\" assert vm.stock[\\"Water\\"] == 9 assert vm.sales() == {'Cola': 0, 'Water': 1} def test_out_of_stock(): vm = VendingMachine() for _ in range(10): vm.purchase(\\"Cola\\") assert vm.purchase(\\"Cola\\") == \\"Out of stock\\" def test_invalid_drink(): vm = VendingMachine() assert vm.purchase(\\"Juice\\") == \\"Invalid drink type\\" def test_restock_cola(): vm = VendingMachine() for _ in range(10): vm.purchase(\\"Cola\\") vm.restock(\\"Cola\\", 5) assert vm.stock[\\"Cola\\"] == 5 def test_restock_water(): vm = VendingMachine() vm.restock(\\"Water\\", 5) assert vm.stock[\\"Water\\"] == 10 def test_restock_over_max_capacity(): vm = VendingMachine() vm.restock(\\"Cola\\", 5) vm.restock(\\"Cola\\", 10) assert vm.stock[\\"Cola\\"] == 10 def test_invalid_restock_drink(): vm = VendingMachine() vm.restock(\\"Juice\\", 5) assert vm.stock == {'Cola': 10, 'Water': 10}","solution":"class VendingMachine: def __init__(self): self.stock = {'Cola': 10, 'Water': 10} self.sales_record = {'Cola': 0, 'Water': 0} self.max_capacity = 10 self.prices = {'Cola': 1.5, 'Water': 1.0} def purchase(self, drink_type: str) -> str: if drink_type not in self.stock: return \\"Invalid drink type\\" if self.stock[drink_type] > 0: self.stock[drink_type] -= 1 self.sales_record[drink_type] += 1 return \\"Thank you for your purchase!\\" else: return \\"Out of stock\\" def restock(self, drink_type: str, amount: int) -> None: if drink_type not in self.stock: return \\"Invalid drink type\\" self.stock[drink_type] = min(self.max_capacity, self.stock[drink_type] + amount) def sales(self) -> dict: return self.sales_record"},{"question":"from typing import List def banking_system(N: int, operations: List[str]) -> List[str]: Simulates a simple banking system supporting account creation, account deletion, money deposit, and money withdrawal functionalities. Each operation is tracked with a unique transaction ID. >>> banking_system(5, [\\"Create A1 1000\\", \\"Deposit A1 500\\", \\"Create A2 300\\", \\"Withdraw A1 200\\", \\"Delete A1\\"]) [\\"Create A1 1\\", \\"Deposit A1 2\\", \\"Create A2 3\\", \\"Withdraw A1 4\\"] >>> banking_system(1, [\\"Delete A1\\"]) []","solution":"def banking_system(N, operations): accounts = {} transaction_log = [] transaction_id = 1 for operation in operations: parts = operation.split() command = parts[0] if command == \\"Create\\": account_id = parts[1] initial_balance = int(parts[2]) if account_id not in accounts: accounts[account_id] = initial_balance transaction_log.append(f\\"Create {account_id} {transaction_id}\\") transaction_id += 1 elif command == \\"Delete\\": account_id = parts[1] if account_id in accounts and accounts[account_id] == 0: del accounts[account_id] transaction_log.append(f\\"Delete {account_id} {transaction_id}\\") transaction_id += 1 elif command == \\"Deposit\\": account_id = parts[1] amount = int(parts[2]) if account_id in accounts: accounts[account_id] += amount transaction_log.append(f\\"Deposit {account_id} {transaction_id}\\") transaction_id += 1 elif command == \\"Withdraw\\": account_id = parts[1] amount = int(parts[2]) if account_id in accounts and accounts[account_id] >= amount: accounts[account_id] -= amount transaction_log.append(f\\"Withdraw {account_id} {transaction_id}\\") transaction_id += 1 return transaction_log"},{"question":"from datetime import datetime def calculate_late_fee(due_date: str, return_date: str) -> float: Calculate the late fee for returning a library book. Args: due_date (str): The due date in 'YYYY-MM-DD' format. return_date (str): The return date in 'YYYY-MM-DD' format. Returns: float: The total late fee. Examples: >>> calculate_late_fee('2023-09-10', '2023-09-10') 0.0 >>> calculate_late_fee('2023-09-10', '2023-09-09') 0.0 >>> calculate_late_fee('2023-09-10', '2023-09-11') 0.50 >>> calculate_late_fee('2023-09-10', '2023-09-15') 2.50 >>> calculate_late_fee('2023-09-10', '2023-09-18') 10.50 >>> calculate_late_fee('2023-09-10', '2023-10-01') 21.00 >>> calculate_late_fee('2023-09-10', '2023-10-12') 50.0 >>> calculate_late_fee('2023-09-10', '2023-11-01') 50.0 >>> calculate_late_fee('2023-09-10', '2023-12-31') 50.0","solution":"from datetime import datetime def calculate_late_fee(due_date, return_date): Calculate the late fee for returning a library book. Args: due_date (str): The due date in 'YYYY-MM-DD' format. return_date (str): The return date in 'YYYY-MM-DD' format. Returns: float: The total late fee. due_date = datetime.strptime(due_date, '%Y-%m-%d') return_date = datetime.strptime(return_date, '%Y-%m-%d') if return_date <= due_date: return 0.0 days_late = (return_date - due_date).days if days_late <= 7: return days_late * 0.50 elif days_late <= 30: return (7 * 0.50) + (days_late - 7) * 1.00 else: return 50.0"},{"question":"def count_unique_substrings(s: str) -> int: Count the number of unique substrings of length 3 in a given string. Examples: >>> count_unique_substrings(\\"abcabc\\") 3 >>> count_unique_substrings(\\"ababab\\") 2 >>> count_unique_substrings(\\"abcdef\\") 4 >>> count_unique_substrings(\\"\\") 0 >>> count_unique_substrings(\\"ab\\") 0 >>> count_unique_substrings(\\"aaaaaa\\") 1 >>> count_unique_substrings(\\"abcdefghijklmnopqrstuvwxyz\\") 24","solution":"def count_unique_substrings(s): Return the number of unique substrings of length 3 in the given string s. unique_substrings = set() for i in range(len(s) - 2): substring = s[i:i+3] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def convert(amount: float, from_currency: str, to_currency: str) -> float: Simulates a simplified currency conversion. The function will convert the 'amount' from 'from_currency' to 'to_currency' using pre-defined exchange rates. >>> convert(100, \\"USD\\", \\"EUR\\") 85.0 >>> convert(50, \\"EUR\\", \\"JPY\\") 4400.0 >>> convert(200, \\"JPY\\", \\"USD\\") 2.6 # Example test cases def test_usd_to_eur(): assert convert(100, \\"USD\\", \\"EUR\\") == 85.0 def test_eur_to_jpy(): assert convert(50, \\"EUR\\", \\"JPY\\") == 4400.0 def test_jpy_to_usd(): assert convert(200, \\"JPY\\", \\"USD\\") == 2.6 def test_usd_to_jpy(): assert convert(1, \\"USD\\", \\"JPY\\") == 75.0 def test_eur_to_usd(): assert convert(1, \\"EUR\\", \\"USD\\") == 1.18 def test_jpy_to_eur(): assert convert(1000, \\"JPY\\", \\"EUR\\") == 11.0 def test_invalid_currency(): assert convert(100, \\"USD\\", \\"GBP\\") == None def test_invalid_from_currency(): assert convert(100, \\"GBP\\", \\"USD\\") == None def test_invalid_to_currency(): assert convert(100, \\"USD\\", \\"INR\\") == None","solution":"def convert(amount, from_currency, to_currency): rates = { 'USD': {'EUR': 0.85, 'JPY': 75}, 'EUR': {'USD': 1.18, 'JPY': 88}, 'JPY': {'USD': 0.013, 'EUR': 0.011} } if from_currency not in rates or to_currency not in rates[from_currency]: return None return amount * rates[from_currency][to_currency]"},{"question":"def process_inventory(inventory, transactions): Processes a list of transactions that update the inventory. Args: inventory (list of dicts): List of dictionaries representing the inventory. transactions (list of dicts): List of dictionaries representing the transactions. Returns: list of dicts: The updated inventory list. pass def test_add_items(): inventory = [ {\\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 5}, ] transactions = [ {\\"type\\": \\"add\\", \\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 5} ] result = process_inventory(inventory, transactions) assert result == [{\\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 10}] def test_remove_items(): inventory = [ {\\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 5}, ] transactions = [ {\\"type\\": \\"remove\\", \\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 3}, ] result = process_inventory(inventory, transactions) assert result == [{\\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 2}] def test_remove_items_below_zero(): inventory = [ {\\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 5}, ] transactions = [ {\\"type\\": \\"remove\\", \\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 10}, ] result = process_inventory(inventory, transactions) assert result == [{\\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 0}] def test_add_new_item(): inventory = [ {\\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 5}, ] transactions = [ {\\"type\\": \\"new\\", \\"id\\": 3, \\"name\\": \\"cherry\\", \\"quantity\\": 7}, ] result = process_inventory(inventory, transactions) assert result == [ {\\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 5}, {\\"id\\": 3, \\"name\\": \\"cherry\\", \\"quantity\\": 7} ] def test_mixed_transactions(): inventory = [ {\\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 10}, {\\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 5} ] transactions = [ {\\"type\\": \\"add\\", \\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 5}, {\\"type\\": \\"remove\\", \\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 10}, {\\"type\\": \\"new\\", \\"id\\": 3, \\"name\\": \\"cherry\\", \\"quantity\\": 7} ] result = process_inventory(inventory, transactions) assert result == [ {\\"id\\": 1, \\"name\\": \\"apple\\", \\"quantity\\": 15}, {\\"id\\": 2, \\"name\\": \\"banana\\", \\"quantity\\": 0}, {\\"id\\": 3, \\"name\\": \\"cherry\\", \\"quantity\\": 7} ]","solution":"def process_inventory(inventory, transactions): Processes a list of transactions that update the inventory. Args: inventory (list of dicts): List of dictionaries representing the inventory. transactions (list of dicts): List of dictionaries representing the transactions. Returns: list of dicts: The updated inventory list. # Convert inventory to a dictionary for quicker lookup inventory_dict = {item['id']: item for item in inventory} # Process each transaction for transaction in transactions: item_id = transaction['id'] if transaction['type'] == 'add': if item_id in inventory_dict: inventory_dict[item_id]['quantity'] += transaction['quantity'] elif transaction['type'] == 'remove': if item_id in inventory_dict: inventory_dict[item_id]['quantity'] -= transaction['quantity'] if inventory_dict[item_id]['quantity'] < 0: inventory_dict[item_id]['quantity'] = 0 elif transaction['type'] == 'new': inventory_dict[item_id] = { 'id': item_id, 'name': transaction['name'], 'quantity': transaction['quantity'] } # Convert back to list updated_inventory = list(inventory_dict.values()) return updated_inventory"},{"question":"def sort_and_square_numbers(numbers): Returns a list of the squares of the given list of integers, sorted in non-decreasing order. Parameters: numbers (list): List of integers Returns: list: List of squared integers sorted in non-decreasing order Examples: >>> sort_and_square_numbers([3, -1, 4, 1, 5]) [1, 1, 9, 16, 25] >>> sort_and_square_numbers([-9, -2, 0, 2, 3]) [0, 4, 4, 9, 81]","solution":"def sort_and_square_numbers(numbers): Returns a list of the squares of the given list of integers, sorted in non-decreasing order. Parameters: numbers (list): List of integers Returns: list: List of squared integers sorted in non-decreasing order squared_numbers = [n ** 2 for n in numbers] return sorted(squared_numbers)"},{"question":"def max_levels_unlocked(required_coins: List[int], collected_coins: int) -> int: Calculate the number of levels that can be unlocked with the given number of collected coins. Parameters: required_coins (list): A list of integers representing the coins required for each level. collected_coins (int): An integer representing the total number of collected coins. Returns: int: The number of levels that can be unlocked. Examples: >>> max_levels_unlocked([5, 10, 20, 30], 25) 2 >>> max_levels_unlocked([5, 10, 20, 30], 0) 0 >>> max_levels_unlocked([5, 10, 20, 30], 5) 1 >>> max_levels_unlocked([5, 10, 20, 30], 3) 0 >>> max_levels_unlocked([5, 10, 20, 30], 15) 2 >>> max_levels_unlocked([5, 10, 20, 30], 100) 4 >>> max_levels_unlocked([], 100) 0","solution":"def max_levels_unlocked(required_coins, collected_coins): Returns the maximum number of levels that can be unlocked with the given number of collected coins. Parameters: required_coins (list): A list of integers representing the coins required for each level. collected_coins (int): An integer representing the total number of collected coins. Returns: int: The number of levels that can be unlocked. levels_unlocked = 0 for coins in required_coins: if collected_coins >= coins: collected_coins -= coins levels_unlocked += 1 else: break return levels_unlocked"},{"question":"def right_aligned_pyramid(N: int): Prints a right-aligned pyramid made of asterisks (*) with N rows. Each row k (1 ≤ k ≤ N) contains k asterisks aligned to the right, with the rest of the row filled with spaces. Example: >>> right_aligned_pyramid(4) * ** *** ****","solution":"def right_aligned_pyramid(N): Prints a right-aligned pyramid made of asterisks (*) with N rows. Each row k (1 ≤ k ≤ N) contains k asterisks aligned to the right, with the rest of the row filled with spaces. for i in range(1, N+1): print(' '*(N-i) + '*'*i)"},{"question":"def circular_right_rotate(s: str, n: int) -> str: Circularly right rotates the string s n times. >>> circular_right_rotate(\\"abcdef\\", 2) 'efabcd' >>> circular_right_rotate(\\"hello\\", 7) 'lohel' >>> circular_right_rotate(\\"xyz\\", 0) 'xyz' def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process a list of test cases for circular right rotations. >>> process_test_cases([(\\"abcdef\\", 2), (\\"hello\\", 7), (\\"xyz\\", 0)]) ['efabcd', 'lohel', 'xyz']","solution":"def circular_right_rotate(s, n): Circularly right rotates the string s n times. n = n % len(s) # Reduce the number of rotations to a minimum necessary return s[-n:] + s[:-n] def process_test_cases(test_cases): results = [] for s, n in test_cases: results.append(circular_right_rotate(s, int(n))) return results"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence from the given list of numbers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 ... def process_test_cases(test_cases: List[List[int]]) -> List[int]: Processes multiple test cases and returns list of results for each test case. >>> process_test_cases([[10, 9, 2, 5, 3, 7, 101, 18], [0, 1, 0, 3, 2, 3]]) [4, 4] >>> process_test_cases([[3, 10, 2, 1, 20], [50, 3, 10, 7, 40, 80]]) [3, 4] >>> process_test_cases([[], [1], [1, 2, 3, 4], [2, 2, 2, 2]]) [0, 1, 4, 1] ...","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def process_test_cases(test_cases): results = [] for test_case in test_cases: results.append(longest_increasing_subsequence(test_case)) return results"},{"question":"from typing import List, Tuple, Union def frequent_price_fluctuation(updates: List[Tuple[str, int]]) -> Union[List[str], None]: Returns the product identifier or identifiers with the highest number of price changes. >>> frequent_price_fluctuation([ ... (\\"product1\\", 100), ... (\\"product2\\", 200), ... (\\"product1\\", 150), ... (\\"product3\\", 300), ... (\\"product2\\", 250), ... (\\"product3\\", 350), ... (\\"product1\\", 100) ... ]) [\\"product1\\"] >>> frequent_price_fluctuation([ ... (\\"product1\\", 100), ... (\\"product2\\", 200), ... (\\"product1\\", 150), ... (\\"product3\\", 300), ... (\\"product2\\", 250), ... (\\"product3\\", 350), ... (\\"product1\\", 100), ... (\\"product3\\", 300) ... ]) [\\"product1\\", \\"product3\\"] >>> frequent_price_fluctuation([ ... (\\"product1\\", 100), ... (\\"product2\\", 200), ... (\\"product3\\", 300) ... ]) [] >>> frequent_price_fluctuation([ ... (\\"product1\\", 100), ... (\\"product2\\", 200), ... (\\"product1\\", 150), ... (\\"product3\\", 300), ... (\\"product2\\", 250), ... (\\"product3\\", 350) ... ]) [\\"product1\\", \\"product2\\", \\"product3\\"] >>> frequent_price_fluctuation([ ... (\\"product1\\", 100), ... (\\"product1\\", 100), ... (\\"product1\\", 150), ... (\\"product1\\", 150) ... ]) [\\"product1\\"]","solution":"def frequent_price_fluctuation(updates): Returns the product identifier(s) with highest number of price changes. from collections import defaultdict product_changes = defaultdict(int) previous_prices = {} for product, price in updates: if product in previous_prices and previous_prices[product] != price: product_changes[product] += 1 previous_prices[product] = price max_changes = max(product_changes.values(), default=0) result = [product for product, changes in product_changes.items() if changes == max_changes] return result"},{"question":"def highest_sum_path(N: int, M: int, grid: List[List[int]]) -> int: Determine the highest possible sum of block heights for a valid path from the top-left corner to the bottom-right corner of the grid. >>> grid = [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6] ... ] >>> highest_sum_path(3, 4, grid) 21 >>> grid = [ ... [1], ... [2], ... [3] ... ] >>> highest_sum_path(3, 1, grid) 6 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> highest_sum_path(1, 4, grid) 10 >>> grid = [ ... [5] ... ] >>> highest_sum_path(1, 1, grid) 5 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> highest_sum_path(3, 3, grid) 29 pass","solution":"def highest_sum_path(N, M, grid): # Create a DP table to store the maximum sums dp = [[0] * M for _ in range(N)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the DP table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the highest sum return dp[-1][-1]"},{"question":"from typing import List def add_operators_to_reach_target(num: str, target: int) -> List[str]: Given a string that contains only digits from 0 to 9 and a target value, add binary operators +, -, or * between the digits to form mathematical expressions that evaluate to the target value. >>> set(add_operators_to_reach_target(\\"123\\", 6)) == set([\\"1+2+3\\", \\"1*2*3\\"]) True >>> set(add_operators_to_reach_target(\\"232\\", 8)) == set([\\"2*3+2\\", \\"2+3*2\\"]) True >>> set(add_operators_to_reach_target(\\"105\\", 5)) == set([\\"1*0+5\\", \\"10-5\\"]) True >>> set(add_operators_to_reach_target(\\"00\\", 0)) == set([\\"0+0\\", \\"0-0\\", \\"0*0\\"]) True >>> add_operators_to_reach_target(\\"3456237490\\", 9191) [] pass","solution":"def add_operators_to_reach_target(num, target): def helper(index, path, value, prev): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): if i != index and num[index] == '0': break current_str = num[index:i+1] current_num = int(current_str) if index == 0: helper(i + 1, current_str, current_num, current_num) else: helper(i + 1, path + '+' + current_str, value + current_num, current_num) helper(i + 1, path + '-' + current_str, value - current_num, -current_num) helper(i + 1, path + '*' + current_str, value - prev + prev * current_num, prev * current_num) result = [] helper(0, \\"\\", 0, 0) return result"},{"question":"from typing import List def k_most_frequent(strings: List[str], k: int) -> List[str]: Returns the k most frequent strings in descending order of frequency. If multiple strings have the same frequency, they are sorted lexicographically. Args: strings (List[str]): A list of strings. k (int): The number of top frequent strings to return. Returns: List[str]: A list of the k most frequent strings. Examples: >>> k_most_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) [\\"apple\\", \\"banana\\"] >>> k_most_frequent([\\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"cherry\\", \\"cherry\\"], 1) [\\"cherry\\"] >>> k_most_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\"], 2) [\\"apple\\", \\"banana\\", \\"orange\\"]","solution":"from collections import Counter def k_most_frequent(strings, k): Returns the k most frequent strings in descending order of frequency. If multiple strings have the same frequency, they are sorted lexicographically. frequency = Counter(strings) # sort by (-frequency, string) to get descending order of frequency and lexicographical for ties sorted_strings = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # k most frequent strings result = [] current_freq = None count = 0 for string, freq in sorted_strings: if count < k or freq == current_freq: result.append(string) if freq != current_freq: count += 1 current_freq = freq else: break return result"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Write a function that takes an array of integers as input and returns a new array where each integer is replaced by the product of all other integers in the input array except the integer at the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([10]) [1] >>> product_except_self([5, 5, 5, 5]) [125, 125, 125, 125] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([0, 0, 2, 3]) [0, 0, 0, 0] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([]) []","solution":"def product_except_self(nums): Given an array nums, return an array where each element is the product of all other elements in the array except itself. :param nums: List[int] :return: List[int] n = len(nums) # Initialize the result array with ones result = [1] * n # Construct the prefix products prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Construct the suffix products and combine with prefix products suffix = 1 for i in range(n - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def max_bouquet_beauty(N: int, M: int, F: List[List[int]]) -> int: Returns the maximum possible beauty of the bouquet by selecting one flower from each row. Parameters: N (int): Number of rows in the garden M (int): Number of columns in the garden F (list of list of int): 2D list representing the beauty level of each flower Returns: int: The maximum possible beauty of the bouquet >>> max_bouquet_beauty(3, 3, [[2, -1, 3], [-3, 4, 6], [5, 2, -9]]) 14 >>> max_bouquet_beauty(1, 5, [[1, 2, 3, 4, 5]]) 5 >>> max_bouquet_beauty(5, 1, [[2], [-3], [4], [6], [5]]) 14 >>> max_bouquet_beauty(3, 3, [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -12 >>> max_bouquet_beauty(2, 2, [[10000, -10000], [-5000, 5000]]) 15000","solution":"def max_bouquet_beauty(N, M, F): Returns the maximum possible beauty of the bouquet by selecting one flower from each row. Parameters: N (int): Number of rows in the garden M (int): Number of columns in the garden F (list of list of int): 2D list representing the beauty level of each flower Returns: int: The maximum possible beauty of the bouquet max_beauty_sum = 0 for i in range(N): max_beauty_sum += max(F[i]) return max_beauty_sum"},{"question":"def rotate_array(arr, k): Rotates the array arr to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_array([], 3) == [] >>> rotate_array([1], 3) == [1] >>> rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]","solution":"def rotate_array(arr, k): Rotates the array arr to the right by k steps. if not arr: return arr k = k % len(arr) return arr[-k:] + arr[:-k]"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Write a function that takes a string consisting of lowercase letters and returns the length of the longest substring with all unique characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdefghijk\\") 11 >>> length_of_longest_substring(\\"aabbccdd\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 pass # your code here","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 # Dictionary to store the last positions of each character char_index = {} max_length = 0 start = 0 for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def sumUnique(arr: List[int]) -> int: Returns the sum of all unique elements in the array. Unique elements are those which appear exactly once in the array. >>> sumUnique([1, 2, 3, 2, 1, 4]) 7 >>> sumUnique([4, 4, 5, 6, 6, 7]) 5","solution":"def sumUnique(arr): Returns the sum of all unique elements in the array. Unique elements are those which appear exactly once in the array. element_count = {} for element in arr: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 return sum(element for element, count in element_count.items() if count == 1)"},{"question":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. Args: s1: A string consisting of lowercase English letters. s2: A string consisting of lowercase English letters. Returns: The length of the longest common substring between s1 and s2. Example: >>> longest_common_substring(\\"abcdef\\", \\"zabctd\\") 3 >>> longest_common_substring(\\"xyz\\", \\"xy\\") 2 >>> longest_common_substring(\\"abcd\\", \\"efgh\\") 0 >>> longest_common_substring(\\"a\\", \\"a\\") 1","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. n, m = len(s1), len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def balance_plants(S: str) -> int: Returns the minimal number of unique plant types required to ensure every unique character in the string S has at least one occurrence. Examples: >>> balance_plants(\\"\\") 0 >>> balance_plants(\\"zzzzzz\\") 1 >>> balance_plants(\\"zxy\\") 3 >>> balance_plants(\\"aabbcc\\") 3 >>> balance_plants(\\"aaaaaabbbcccc\\") 3","solution":"def balance_plants(S: str) -> int: Returns the minimal number of unique plant types required to ensure every unique character in the string S has at least one occurrence. :param S: A string representing the garden with different types of plants. :return: An integer representing the minimal number of unique plant types required. if not S: return 0 return len(set(S))"},{"question":"from typing import List def largest_number(numbers: List[int]) -> str: Given a list of non-negative integers, forms the largest number possible by concatenating the elements. Args: numbers (List[int]): List of non-negative integers. Returns: str: The largest number that can be formed by concatenating the elements. >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([1]) \\"1\\" >>> largest_number([0, 0, 0]) \\"0\\" >>> largest_number([10, 2]) \\"210\\" >>> largest_number([121, 12]) \\"12121\\" def test_single_element(): assert largest_number([1]) == \\"1\\" assert largest_number([10]) == \\"10\\" def test_all_zeros(): assert largest_number([0, 0, 0]) == \\"0\\" def test_varied_numbers(): assert largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" assert largest_number([10, 2]) == \\"210\\" assert largest_number([1, 20, 23, 4, 8]) == \\"8423201\\" def test_large_numbers(): assert largest_number([824, 938, 1399, 5607, 6973, 5709, 9609, 4398, 8247]) == \\"9609938824824769735709560743981399\\" def test_same_digits(): assert largest_number([121, 12]) == \\"12121\\" assert largest_number([12, 121]) == \\"12121\\" def test_large_list(): large_list = [5] * 10000 assert largest_number(large_list) == \\"5\\" * 10000","solution":"from functools import cmp_to_key def largest_number(numbers): Given a list of non-negative integers, forms the largest number possible by concatenating the elements. Args: numbers (List[int]): List of non-negative integers. Returns: str: The largest number that can be formed by concatenating the elements. # Convert numbers to strings for easy concatenation and comparison str_numbers = [str(num) for num in numbers] # Custom comparator that decides the order based on which concatenation is larger def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the numbers with the custom comparator str_numbers.sort(key=cmp_to_key(compare)) # Concatenate all numbers in the sorted order result = ''.join(str_numbers) # To handle the case where the input list is all zeros we return '0' instead of '000...' return '0' if result[0] == '0' else result"},{"question":"def min_operations_to_equivalent_grid(test_cases): Calculate the minimum number of operations required to make all rows and columns equivalent in an N x N grid. >>> parse_input(\\"2n2n1 2n3 4n3n1 1 1n1 1 1n1 1 1n\\") [{'N': 2, 'grid': [[1, 2], [3, 4]]}, {'N': 3, 'grid': [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}] >>> format_output([6, 0]) \\"6n0\\" pass def parse_input(input_str): Parse the input string into a list of test cases. >>> parse_input(\\"1n3n1 2 3n4 5 6n7 8 9n\\") [{'N': 3, 'grid': [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}] pass def format_output(results): Format the list of results into a single output string. >>> format_output([6, 0]) \\"6n0\\" pass def test_min_operations_to_equivalent_grid(): input_str = \\"2n2n1 2n3 4n3n1 1 1n1 1 1n1 1 1n\\" test_cases = parse_input(input_str) expected_output = [6, 0] assert min_operations_to_equivalent_grid(test_cases) == expected_output def test_parse_input(): input_str = \\"1n3n1 2 3n4 5 6n7 8 9n\\" test_cases = parse_input(input_str) expected_output = [{'N': 3, 'grid': [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}] assert test_cases == expected_output def test_format_output(): results = [6, 0] expected_output = \\"6n0\\" assert format_output(results) == expected_output","solution":"def min_operations_to_equivalent_grid(test_cases): results = [] for case in test_cases: N = case['N'] grid = case['grid'] max_val = max(map(max, grid)) operations = 0 for i in range(N): for j in range(N): operations += max_val - grid[i][j] results.append(operations) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) grid = [] for i in range(N): grid.append(list(map(int, lines[idx + 1 + i].split()))) test_cases.append({'N': N, 'grid': grid}) idx += 1 + N return test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def min_partition_diff(weights): Determine the minimum possible difference between the sums of weights of two groups. Args: weights (List[int]): A list of weights of the stones. Returns: int: The minimum possible difference. >>> min_partition_diff([1, 2, 3, 4]) 0 >>> min_partition_diff([2, 3, 5]) 0 >>> min_partition_diff([1, 4, 6]) 1 pass def minimum_difference(T, test_cases): For multiple test cases, return the minimum possible difference between the sums of weights of two groups for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list containing tuples where each tuple contains an integer N and a list of integers representing weights. Returns: List[int]: A list of integers representing the minimum possible differences for each test case. >>> minimum_difference(2, [(4, [1, 2, 3, 4]), (3, [2, 3, 5])]) [0, 0] >>> minimum_difference(1, [(5, [1, 2, 3, 9, 11])]) [0] >>> minimum_difference(1, [(3, [1, 4, 6])]) [1] >>> minimum_difference(1, [(6, [2, 3, 4, 5, 6, 7])]) [1] >>> minimum_difference(1, [(7, [1, 1, 1, 1, 1, 1, 6])]) [0] pass","solution":"def min_partition_diff(weights): total_sum = sum(weights) n = len(weights) dp = [False] * (total_sum // 2 + 1) dp[0] = True for weight in weights: for i in range(total_sum // 2, weight - 1, -1): dp[i] = dp[i] or dp[i - weight] for i in range(total_sum // 2, -1, -1): if dp[i]: first_group_sum = i second_group_sum = total_sum - i return abs(first_group_sum - second_group_sum) def minimum_difference(T, test_cases): results = [] for i in range(T): N, weights = test_cases[i] results.append(min_partition_diff(weights)) return results"},{"question":"def format_duration(seconds: int) -> str: Converts a duration in seconds to a string in the format hh:mm:ss. If the duration is less than or equal to zero, returns \\"00:00:00\\". >>> format_duration(3661) '01:01:01' >>> format_duration(0) '00:00:00' >>> format_duration(86399) '23:59:59'","solution":"def format_duration(seconds): Converts a duration in seconds to a string in the format hh:mm:ss. If the duration is less than or equal to zero, returns \\"00:00:00\\". if seconds <= 0: return \\"00:00:00\\" hours = seconds // 3600 minutes = (seconds % 3600) // 60 seconds = seconds % 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\""},{"question":"def decode_string(s: str) -> str: Decodes the given input string s according to the specified rules: - Each letter can be followed by a digit indicating the number of times it should be repeated. - If a number does not follow a letter, it should appear exactly once. Examples: >>> decode_string(\\"A2b3C\\") 'AAbbbC' >>> decode_string(\\"X3y2Z\\") 'XXXyyZ'","solution":"def decode_string(s): Decodes the string based on the given rules. decoded_string = \\"\\" i = 0 while i < len(s): if s[i].isalpha(): if i + 1 < len(s) and s[i + 1].isdigit(): repeat_count = int(s[i + 1]) decoded_string += s[i] * repeat_count i += 2 else: decoded_string += s[i] i += 1 return decoded_string"},{"question":"[Completion Task in Python] def sort_by_ascii(input_string: str) -> str: Returns a new string with the characters sorted in non-decreasing order of their ASCII values, with non-alphabetic characters remaining in their original positions. If the input is not a string, returns \\"Input is not a string\\". >>> sort_by_ascii(\\"d3c!a#\\") == \\"a3c!d#\\" >>> sort_by_ascii(1234) == \\"Input is not a string\\" def test_basic_sort(): assert sort_by_ascii(\\"d3c!a#\\") == \\"a3c!d#\\" def test_input_not_string(): assert sort_by_ascii(1234) == \\"Input is not a string\\" def test_empty_string(): assert sort_by_ascii(\\"\\") == \\"\\" def test_string_with_only_alphabetic_chars(): assert sort_by_ascii(\\"badcfe\\") == \\"abcdef\\" def test_string_with_no_alphabetic_chars(): assert sort_by_ascii(\\"1234!@#\\") == \\"1234!@#\\" def test_string_with_mixed_characters(): assert sort_by_ascii(\\"z9y8x7w6\\") == \\"w9x8y7z6\\"","solution":"def sort_by_ascii(input_string: str) -> str: Returns a new string with the characters sorted in non-decreasing order of their ASCII values, with non-alphabetic characters remaining in their original positions. If the input is not a string, returns \\"Input is not a string\\". if not isinstance(input_string, str): return \\"Input is not a string\\" # Separate alphabetic characters and sort them alphabetic_chars = sorted([ch for ch in input_string if ch.isalpha()]) result = [] alpha_index = 0 for ch in input_string: if ch.isalpha(): result.append(alphabetic_chars[alpha_index]) alpha_index += 1 else: result.append(ch) return \\"\\".join(result)"},{"question":"def cumulative_sum(numbers: List[int]) -> List[int]: Returns a new list where each element is the cumulative sum of the previous elements in the original list. Parameters: numbers (list): A list of integers. Returns: list: A list containing the cumulative sums. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([4, -1, 2, 5]) [4, 3, 5, 10] >>> cumulative_sum([10]) [10] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([1, -1, 1, -1, 1]) [1, 0, 1, 0, 1] >>> cumulative_sum([]) []","solution":"def cumulative_sum(numbers): Returns a new list where each element is the cumulative sum of the previous elements in the original list. Parameters: numbers (list): A list of integers. Returns: list: A list containing the cumulative sums. if not numbers: return [] cumulative_sums = [numbers[0]] for i in range(1, len(numbers)): cumulative_sums.append(cumulative_sums[-1] + numbers[i]) return cumulative_sums"},{"question":"def eratosthenes_encryption(N: int, operations: List[Tuple[int, int]]) -> List[int]: Calculate the final configuration of the array after applying swap operations. Parameters: N (int): Length of the array A. operations (List[Tuple[int, int]]): List of swap operations. Returns: List[int]: Final configuration of the array. >>> eratosthenes_encryption(5, [(1, 3), (4, 5), (2, 4)]) [8, 32, 2, 4, 16] >>> eratosthenes_encryption(4, []) [2, 4, 8, 16]","solution":"def eratosthenes_encryption(N, operations): Calculate the final configuration of the array after applying swap operations. Parameters: N (int): Length of the array A. operations (List[Tuple[int, int]]): List of swap operations. Returns: List[int]: Final configuration of the array. # Generate array A where A[i] = 2^i (1-based index) A = [2**i for i in range(1, N+1)] # Apply the swap operations for X, Y in operations: # Adjust indices for 0-based index for Python lists A[X-1], A[Y-1] = A[Y-1], A[X-1] return A"},{"question":"from typing import List def rearrangeString(s: str, k: int) -> str: Rearrange the string such that no two adjacent characters are the same and the distance between two same characters is at least k. >>> rearrangeString(\\"aabbcc\\", 2) \\"abcabc\\" >>> rearrangeString(\\"aaabc\\", 3) \\"\\" >>> rearrangeString(\\"aaadbbcc\\", 2) \\"abacabcd\\" def test_example_1(): assert rearrangeString(\\"aabbcc\\", 2) == \\"abcabc\\" def test_example_2(): assert rearrangeString(\\"aaabc\\", 3) == \\"\\" def test_example_3(): assert rearrangeString(\\"aaadbbcc\\", 2) == \\"abacabcd\\" def test_single_character(): assert rearrangeString(\\"a\\", 1) == \\"a\\" def test_no_rearrangement_needed(): assert rearrangeString(\\"abcd\\", 1) == \\"abcd\\" def test_large_k_value(): assert rearrangeString(\\"aaaaaa\\", 10) == \\"\\" def test_large_input(): s = \\"aaabbbccc\\" * 1000 result = rearrangeString(s, 2) assert len(result) == len(s) for i in range(len(result) - 1): assert result[i] != result[i + 1] def test_all_same_character(): assert rearrangeString(\\"bbbbbbb\\", 2) == \\"\\"","solution":"import heapq from collections import Counter, deque def rearrangeString(s, k): if k <= 1: return s # Count the frequency of each character in the string. counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] queue = deque() # to keep track of previous characters and their frequencies while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) # Increment frequency since we used it if len(queue) >= k: prev_freq, prev_char = queue.popleft() if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) if len(result) == len(s): return \\"\\".join(result) else: return \\"\\""},{"question":"def reverseWords(text: str) -> str: Write a function named \`reverseWords\` that takes a string \`text\` containing multiple words separated by spaces and returns a new string with the words in reverse order, while maintaining the original spacing and punctuation. Ensure that the function handles multiple spaces between words and at the beginning or end of the input string correctly. >>> reverseWords(\\"Hello world!\\") 'world! Hello' >>> reverseWords(\\"Python is fun\\") 'fun is Python' >>> reverseWords(\\" Keep Coding\\") 'Coding Keep ' >>> reverseWords(\\"Test the inputs\\") 'inputs the Test' >>> reverseWords(\\"Multiple spaces\\") 'spaces Multiple'","solution":"def reverseWords(text): Returns a new string with the words in reverse order, while maintaining the original spacing and punctuation. words = text.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def is_matrix_altered(n, m, matrix): Check if a matrix is altered by verifying whether its rows and columns are in ascending order. >>> is_matrix_altered(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) \\"NO\\" >>> is_matrix_altered(3, 3, [ [3, 1, 2], [6, 5, 4], [9, 8, 7] ]) \\"YES\\" pass def robot_combat_tournament(T, test_cases): Determine if the matrices in the tournament are altered or not for all given test cases. >>> robot_combat_tournament(2, [ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (3, 3, [ [3, 1, 2], [6, 5, 4], [9, 8, 7] ]) ]) [\\"NO\\", \\"YES\\"] >>> robot_combat_tournament(1, [ (2, 2, [ [2, 3], [1, 4] ]) ]) [\\"YES\\"] pass","solution":"def is_matrix_altered(n, m, matrix): # Check rows for row in matrix: if row != sorted(row): return \\"YES\\" # Check columns for col in zip(*matrix): if list(col) != sorted(col): return \\"YES\\" return \\"NO\\" def robot_combat_tournament(T, test_cases): results = [] for n, m, matrix in test_cases: result = is_matrix_altered(n, m, matrix) results.append(result) return results"},{"question":"def max_non_adjacent_sum(nums): Given an array of integers, return the maximum sum of any non-adjacent elements. If the array consists of all negative numbers, return 0. If the array is empty, return 0. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-2, -3, -4]) 0 >>> max_non_adjacent_sum([1, 0, 3, 9, 2]) 10 >>> max_non_adjacent_sum([]) 0","solution":"def max_non_adjacent_sum(nums): Given a list of integers, returns the maximum sum of any non-adjacent elements. If all numbers are negative or the list is empty, returns 0. if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(excl, incl) incl = excl + num excl = new_excl result = max(incl, excl) return max(result, 0) # Ensure we don't return a negative value if all elements are negative."},{"question":"def update_leaderboard(N: int, M: int, match_days: List[List[int]]) -> List[int]: Updates the leaderboard based on points from match days. Parameters: - N (int): Number of match days - M (int): Number of players - match_days (list of list of int): Points earned by each player per match day Returns: - List of ints: Cumulative points for each player Example: >>> update_leaderboard(3, 4, [[5, 10, 15, 20], [10, 10, 10, 10], [20, 5, 0, 5]]) [35, 25, 25, 35] # code here from solution import update_leaderboard def test_update_leaderboard_example(): N = 3 M = 4 match_days = [ [5, 10, 15, 20], [10, 10, 10, 10], [20, 5, 0, 5] ] assert update_leaderboard(N, M, match_days) == [35, 25, 25, 35] def test_all_zero_scores(): N = 2 M = 3 match_days = [ [0, 0, 0], [0, 0, 0] ] assert update_leaderboard(N, M, match_days) == [0, 0, 0] def test_single_match_day(): N = 1 M = 5 match_days = [ [1, 2, 3, 4, 5] ] assert update_leaderboard(N, M, match_days) == [1, 2, 3, 4, 5] def test_multiple_match_days(): N = 4 M = 2 match_days = [ [5, 3], [2, 7], [8, 4], [3, 6] ] assert update_leaderboard(N, M, match_days) == [18, 20] def test_no_match_day(): N = 0 M = 3 match_days = [] assert update_leaderboard(N, M, match_days) == [0, 0, 0]","solution":"def update_leaderboard(N, M, match_days): Updates the leaderboard based on points from match days. Parameters: - N (int): Number of match days - M (int): Number of players - match_days (list of list of int): Points earned by each player per match day Returns: - List of ints: Cumulative points for each player # Initialize leaderboard with zero points for each player leaderboard = [0] * M # Update points for each player for each match day for day in match_days: for i in range(M): leaderboard[i] += day[i] return leaderboard"},{"question":"def compress_string(s: str) -> str: Compresses a given string by reducing multiple consecutive occurrences of a character to a single instance of that character followed by the count of repeated occurrences. >>> compress_string(\\"aaabbcddd\\") == \\"a3b2cd3\\" >>> compress_string(\\"abc\\") == \\"abc\\" >>> compress_string(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"aaAAaA\\") == \\"a2A2aA\\"","solution":"def compress_string(s): Compresses a given string by reducing multiple consecutive occurrences of a character to a single instance of that character followed by the count of repeated occurrences. :param s: The input string to be compressed :type s: str :return: The compressed string :rtype: str if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: compressed.append(f\\"{s[i - 1]}{count}\\") else: compressed.append(s[i - 1]) count = 1 # Add the last set of characters if count > 1: compressed.append(f\\"{s[-1]}{count}\\") else: compressed.append(s[-1]) return ''.join(compressed)"},{"question":"def smallest_divisor(nums: List[int], threshold: int) -> int: Given an array of integers nums and an integer threshold, find the smallest divisor such that the result of the division of every element in the array by this divisor is less than or equal to the threshold. The result of the division should be rounded up to the nearest integer. >>> smallest_divisor([1, 2, 5, 9], 6) 5 >>> smallest_divisor([2, 3, 5, 7, 11], 11) 3 >>> smallest_divisor([19], 5) 4 pass","solution":"from math import ceil def smallest_divisor(nums, threshold): def compute_sum(divisor): return sum(ceil(num / divisor) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if compute_sum(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"def check_capacity_violation(n: int, C: int, stations: List[Tuple[int, int]]) -> str: Checks if train capacity is violated at any point while traversing the stations. Args: n: int - Number of stations C: int - Maximum capacity of the train stations: list of tuples - Each tuple contains two integers where a is the number of passengers leaving and b is the number of passengers boarding the train at each station. Returns: str - \\"YES\\" if there is a violation of the train's capacity at any station, otherwise \\"NO\\". >>> check_capacity_violation(3, 10, [(0, 5), (3, 6), (2, 4)]) == \\"NO\\" >>> check_capacity_violation(4, 5, [(0, 3), (1, 4), (2, 2), (1, 2)]) == \\"YES\\"","solution":"def check_capacity_violation(n, C, stations): Checks if train capacity is violated at any point while traversing the stations. Args: n: int - Number of stations C: int - Maximum capacity of the train stations: list of tuples - Each tuple contains two integers where a is the number of passengers leaving and b is the number of passengers boarding the train at each station. Returns: str - \\"YES\\" if there is a violation of the train's capacity at any station, otherwise \\"NO\\". current_passengers = 0 for a, b in stations: current_passengers -= a current_passengers += b if current_passengers > C: return \\"YES\\" return \\"NO\\""},{"question":"def minimal_total_toll(t: int, test_cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[int]: Determine the minimal total toll for travelling between each pair of cities in a strange land. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[Tuple[int, int]]]]): A list of tuples where each tuple contains: - n (int): The number of cities. - A (List[int]): The beauty levels of the cities. - roads (List[Tuple[int, int]]): The roads connecting the cities. Returns: List[int]: The minimal total toll for each test case. >>> minimal_total_toll(1, [(3, [8, 13, 5], [(1, 2), (2, 3)])]) [10] >>> minimal_total_toll(3, [ (4, [3, 1, 4, 2], [(1, 2), (2, 3), (3, 4)]), (3, [8, 13, 5], [(1, 2), (2, 3)]), (2, [10, 6], [(1, 2)]) ]) [3, 10, 6]","solution":"def minimal_total_toll(t, test_cases): # Initialize result list results = [] # Process each test case for case in test_cases: n, A, roads = case total_toll = 0 # for a tree with n nodes, it always has n-1 edges # Sum the minimum value in the beauty array multiplied by n-1 # because every valid path will pass through at least one node. # This simple trick works because the tree has no cycles. min_beauty = min(A) total_toll = min_beauty * (n - 1) results.append(total_toll) return results"},{"question":"def evaluate_expression(expression: str) -> int: Create a system that evaluates the expression given as an input string and handles arithmetic calculations accordingly. The expressions will contain non-negative integers and the operators +, -, *, and / (integer division). The input expression can also have parentheses to prioritize operations. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\" 3/2 \\") == 1 >>> evaluate_expression(\\" 3+5 / 2 \\") == 5 >>> evaluate_expression(\\"(2+3)*(5-2)\\") == 15 >>> evaluate_expression(\\"((2+3)*2)/(3-1)+1\\") == 6","solution":"def evaluate_expression(expression: str) -> int: def parse_expression(expression): # Remove spaces from the expression expression = expression.replace(\\" \\", \\"\\") return expression def helper(s, index): stack = [] num = 0 sign = '+' while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) if char == '(': index, num = helper(s, index + 1) if char in \\"+-*/)\\" or index == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = char num = 0 if char == ')': break index += 1 return index, sum(stack) parsed_expression = parse_expression(expression) _, result = helper(parsed_expression, 0) return result"},{"question":"def shortest_subarray_sum(arr, S): Find the length of the shortest subarray with a sum equal to S. If no such subarray exists, return -1. Examples: >>> shortest_subarray_sum([2, 3, 1, 2, 4, 3], 7) 2 >>> shortest_subarray_sum([1, 1, 1, 1, 1, 1, 1, 1], 11) -1 >>> shortest_subarray_sum([7], 7) 1 >>> shortest_subarray_sum([5], 7) -1 >>> shortest_subarray_sum([1, 2, 3, 4, 5], 9) 2 >>> shortest_subarray_sum([1, 1, 1, 1, 5, 1, 1, 1, 1], 5) 1 >>> shortest_subarray_sum([1, 2, 3, 999999999, 1], 1000000002) 2 >>> shortest_subarray_sum([1, 2, 3, 4, 5], 20) -1","solution":"def shortest_subarray_sum(arr, S): Find the length of the shortest subarray with a sum equal to S. If no such subarray exists, return -1. n = len(arr) min_length = float('inf') for start in range(n): curr_sum = 0 for end in range(start, n): curr_sum += arr[end] if curr_sum == S: min_length = min(min_length, end - start + 1) break return min_length if min_length != float('inf') else -1"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral string to an integer. :param roman: A string representing the Roman numeral. :return: An integer representing the numeric value of the Roman numeral. >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4","solution":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral string to an integer. :param roman: A string representing the Roman numeral. :return: An integer representing the numeric value of the Roman numeral. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } integer_value = 0 previous_value = 0 for char in reversed(roman): current_value = roman_values[char] if current_value < previous_value: integer_value -= current_value else: integer_value += current_value previous_value = current_value return integer_value"},{"question":"def check_task_order(task_order: str, constraints: List[str]) -> str: Function to check if the given task order meets the provided constraints. task_position = {task: pos for pos, task in enumerate(task_order)} for constraint in constraints: a, b = constraint.split(\\" < \\") if task_position[a] >= task_position[b]: return \\"No\\" return \\"Yes\\" def verify_tasks(T: int, test_cases: List[Tuple[str, List[str]]]) -> List[str]: Verify if the given task orders meet the provided constraints for multiple test cases. results = [] for task_order, constraints in test_cases: results.append(check_task_order(task_order, constraints)) return results","solution":"def check_task_order(task_order, constraints): Function to check if the given task order meets the provided constraints. task_position = {task: pos for pos, task in enumerate(task_order)} for constraint in constraints: a, b = constraint.split(\\" < \\") if task_position[a] >= task_position[b]: return \\"No\\" return \\"Yes\\" def verify_tasks(T, test_cases): results = [] for task_order, constraints in test_cases: results.append(check_task_order(task_order, constraints)) return results"},{"question":"def smallest_missing_positive(nums: List[int]) -> int: Given an array of integers, return the smallest positive integer that is not present in the array. If the array consists entirely of non-positive integers, return \`1\`. >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([-5, -9, -1]) 1 from solution import smallest_missing_positive def test_positive_elements(): assert smallest_missing_positive([3, 4, -1, 1]) == 2 assert smallest_missing_positive([1, 2, 0]) == 3 def test_non_positive_elements(): assert smallest_missing_positive([-5, -9, -1]) == 1 def test_consecutive_numbers(): assert smallest_missing_positive([1, 2, 3, 4, 5]) == 6 def test_empty_array(): assert smallest_missing_positive([]) == 1 def test_single_element(): assert smallest_missing_positive([7]) == 1 assert smallest_missing_positive([1]) == 2 assert smallest_missing_positive([-1]) == 1 def test_with_duplicates(): assert smallest_missing_positive([1, 1, 2, 2]) == 3 assert smallest_missing_positive([3, 3, 3, 3]) == 1 def test_mixed_positive_and_negative(): assert smallest_missing_positive([1, -1, 2, -2, 3, -3]) == 4 def test_large_numbers(): assert smallest_missing_positive([100, 101, 102]) == 1 assert smallest_missing_positive([1, 100, 101, 102]) == 2","solution":"def smallest_missing_positive(nums): Returns the smallest positive integer that is not present in the array. If the array consists entirely of non-positive integers, return 1. :param nums: List[int] :return: int n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def max_gift_bags(costs_list: List[int], budget: int) -> int: Returns the maximum number of gift bags Anna can create without exceeding the given budget. Each gift bag costs a certain amount, which is the sum of the costs of the individual items in the bag. >>> max_gift_bags([1, 2, 3, 4], 10) == 6 >>> max_gift_bags([3, 5, 7, 9], 15) == 3 >>> max_gift_bags([1, 1, 1, 1], 5) == 5 >>> max_gift_bags([], 10) == 0 >>> max_gift_bags([1, 2, 3], 0) == 0 >>> max_gift_bags([10, 20, 30], 100) == 10 >>> max_gift_bags([2, 5, 10], 17) == 8 >>> max_gift_bags([1, 3, 6, 2], 11) == 11","solution":"def max_gift_bags(costs_list, budget): Returns the maximum number of gift bags Anna can create without exceeding the budget. Each gift bag costs a certain amount, which is the sum of the costs of the individual items in the bag. if not costs_list or budget == 0: return 0 costs_list.sort() total_gift_bags = 0 current_budget = budget for cost in costs_list: count = current_budget // cost total_gift_bags += count current_budget -= count * cost return total_gift_bags"},{"question":"def process_tickets(tickets: List[int]) -> Tuple[int, List[int]]: Given a list of ticket IDs, returns a tuple containing the number of unique ticket IDs and a sorted list of those unique IDs. >>> process_tickets([101, 102, 101, 104, 105, 105]) (4, [101, 102, 104, 105]) >>> process_tickets([202, 303, 404, 202, 404, 404]) (3, [202, 303, 404]) >>> process_tickets([]) (0, []) >>> process_tickets([401, 401, 401, 401]) (1, [401]) from typing import List, Tuple def test_process_tickets_multiple_entries(): assert process_tickets([101, 102, 101, 104, 105, 105]) == (4, [101, 102, 104, 105]) def test_process_tickets_varied_entries(): assert process_tickets([202, 303, 404, 202, 404, 404]) == (3, [202, 303, 404]) def test_process_tickets_no_tickets(): assert process_tickets([]) == (0, []) def test_process_tickets_single_repeated_entry(): assert process_tickets([401, 401, 401, 401]) == (1, [401]) def test_process_tickets_unique_entries(): assert process_tickets([110, 120, 130, 140]) == (4, [110, 120, 130, 140]) def test_process_tickets_all_identical_entries(): assert process_tickets([999, 999, 999]) == (1, [999])","solution":"def process_tickets(tickets): Given a list of ticket IDs, returns a tuple containing the number of unique ticket IDs and a sorted list of those unique IDs. unique_tickets = sorted(set(tickets)) return len(unique_tickets), unique_tickets"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to its corresponding Roman numeral representation. :param num: int, the integer to convert (1 <= num <= 3999) :return: str, the Roman numeral representation of the integer >>> int_to_roman(3) 'III' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV'","solution":"def int_to_roman(num): Converts an integer to its corresponding Roman numeral representation. :param num: int, the integer to convert (1 <= num <= 3999) :return: str, the Roman numeral representation of the integer val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syms[i] num -= val[i] i += 1 return roman_numeral"},{"question":"def min_flower_types(N: int, arr: list) -> int: Determines the minimum number of flower types needed to ensure no two adjacent sections have the same type of flower. Parameters: N (int): The number of sections in the garden. arr (list): A list of integers representing the heights of the garden sections. Returns: int: The minimum number of flower types required. >>> min_flower_types(1, [5]) 1 >>> min_flower_types(2, [3, 4]) 2 >>> min_flower_types(4, [3, 1, 4, 1]) 2 >>> min_flower_types(5, [1, 1, 1, 1, 1]) 2 >>> min_flower_types(10**6, [1]*10**6) 2","solution":"def min_flower_types(N: int, arr: list) -> int: Determines the minimum number of flower types needed to ensure no two adjacent sections have the same type of flower. Parameters: N (int): The number of sections in the garden. arr (list): A list of integers representing the heights of the garden sections. Returns: int: The minimum number of flower types required. # For a single section, only one flower type is needed. if N == 1: return 1 else: # For two or more sections, we need at least 2 flower types. return 2"},{"question":"def min_subarray_len(nums: List[int], target: int) -> int: Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to target. If there's no such subarray, returns 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 8) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 pass","solution":"def min_subarray_len(nums, target): Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to target. If there's no such subarray, returns 0. n = len(nums) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"from typing import List, Tuple, Optional def warrior_pathfinding(matrix: List[List[int]]) -> Optional[List[Tuple[int, int]]]: Find a path for the warrior from the top-left corner to the bottom-right corner of a grid. >>> warrior_pathfinding([[1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [0, 1, 1, 1, 1], [0, 0, 0, 1, 0], [1, 1, 1, 1, 1]]) [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)] >>> warrior_pathfinding([[1, 0], [0, 1]]) None >>> warrior_pathfinding([[1]]) [(0, 0)] >>> warrior_pathfinding([[0, 0], [0, 1]]) None >>> warrior_pathfinding([[1, 1], [1, 0]]) None >>> warrior_pathfinding([[1, 1, 0, 1], [0, 1, 0, 1], [1, 1, 1, 1], [0, 0, 0, 1]]) Any valid path from (0,0) to (3,3)","solution":"from typing import List, Tuple, Optional def warrior_pathfinding(matrix: List[List[int]]) -> Optional[List[Tuple[int, int]]]: def is_valid_position(x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] == 1 def bfs(): from collections import deque queue = deque([[(0, 0)]]) visited = set((0, 0)) while queue: path = queue.popleft() x, y = path[-1] if (x, y) == (len(matrix) - 1, len(matrix[0]) - 1): return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid_position(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(path + [(nx, ny)]) return None if matrix[0][0] == 0 or matrix[-1][-1] == 0: return None return bfs()"},{"question":"def minimum_cost_to_connect_nodes(connections): Calculate the minimum cost to connect all nodes such that every node is reachable from any other node. If it's not possible to connect all nodes, return -1. Parameters: connections (list of tuple): A list where each element is a tuple (a, b, c) representing a bidirectional connection between node a and node b with cost c. Returns: int: The minimum cost to connect all nodes, or -1 if it's not possible. Example: >>> minimum_cost_to_connect_nodes([(1, 2, 5), (1, 3, 6), (2, 3, 1)]) 6 >>> minimum_cost_to_connect_nodes([(1, 2, 3), (3, 4, 4)]) -1","solution":"def minimum_cost_to_connect_nodes(connections): Returns the minimum cost to connect all nodes such that every node is reachable from any other node, or -1 if it's not possible. parent = {} rank = {} def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 # Get the set of unique nodes unique_nodes = set() for a, b, c in connections: unique_nodes.add(a) unique_nodes.add(b) # Initialize disjoint sets for node in unique_nodes: parent[node] = node rank[node] = 0 # Sort the connections based on cost connections.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for a, b, cost in connections: if find(a) != find(b): union(a, b) total_cost += cost edges_used += 1 # If we have used \`n-1\` edges, we can stop if edges_used == len(unique_nodes) - 1: return total_cost # If we are here, not all nodes are connected return -1"},{"question":"def is_prime(n: int) -> bool: Helper function to determine if a number is prime. pass def splitPrimes(arr: List[int]) -> List[List[int]]: Splits the input array into two sub-arrays: one containing prime numbers, and the other containing non-prime numbers. >>> splitPrimes([2, 4, 6, 5, 9, 11, 15]) == [[2, 5, 11], [4, 6, 9, 15]] >>> splitPrimes([2, 3, 5, 7, 11, 13]) == [[2, 3, 5, 7, 11, 13], []] >>> splitPrimes([1, 4, 6, 8, 9, 10]) == [[], [1, 4, 6, 8, 9, 10]] >>> splitPrimes([]) == [[], []] >>> splitPrimes([13]) == [[13], []] >>> splitPrimes([14]) == [[], [14]] pass","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def splitPrimes(arr): Splits the input array into two sub-arrays: one containing prime numbers, and the other containing non-prime numbers. primes = [] non_primes = [] for num in arr: if is_prime(num): primes.append(num) else: non_primes.append(num) return [primes, non_primes]"},{"question":"def first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that does not appear in the array. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the array. n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap the numbers to their correct positions nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Identify the first missing positive number for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Check if it's possible to rearrange the string to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if we can rearrange the string to form a palindrome, False otherwise. Example: >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False # Your implementation here # Unit Tests def test_can_form_palindrome_even_characters(): assert can_form_palindrome(\\"aabb\\") == True def test_can_form_palindrome_odd_characters_with_one_odd(): assert can_form_palindrome(\\"aabbc\\") == True def test_can_form_palindrome_no_rearrangement_needed(): assert can_form_palindrome(\\"abba\\") == True def test_can_form_palindrome_single_character(): assert can_form_palindrome(\\"a\\") == True def test_can_form_palindrome_two_characters_different(): assert can_form_palindrome(\\"ab\\") == False def test_can_form_palindrome_odd_characters_with_more_than_one_odd(): assert can_form_palindrome(\\"abc\\") == False def test_can_form_palindrome_longer_string(): assert can_form_palindrome(\\"aabbccd\\") == True def test_can_form_palindrome_all_unique_characters(): assert can_form_palindrome(\\"abcde\\") == False def test_can_form_palindrome_mixed_cases(): assert can_form_palindrome(\\"aabbccddeeffgg\\") == True assert can_form_palindrome(\\"aabbccddee\\") == True assert can_form_palindrome(\\"aabbccddf\\") == True assert can_form_palindrome(\\"abcdefgh\\") == False","solution":"from collections import Counter def can_form_palindrome(s): Check if it's possible to rearrange the string to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if we can rearrange the string to form a palindrome, False otherwise. count = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for freq in count.values() if freq % 2 != 0) # A string can be rearranged to a palindrome if there is at most one character with an odd frequency return odd_count <= 1"},{"question":"def contains_nearby_almost_duplicate(nums, k, t): Determines if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. >>> contains_nearby_almost_duplicate([1, 3, 1, 4, 2], 1, 1) False >>> contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 3, 2) True >>> contains_nearby_almost_duplicate([2, 1, 2, 1], 1, 0) False","solution":"def contains_nearby_almost_duplicate(nums, k, t): Determines if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. if k <= 0 or t < 0 or not nums: return False n = len(nums) values = {} for i in range(n): bucket_id = nums[i] // (t + 1) if bucket_id in values: return True if bucket_id - 1 in values and abs(nums[i] - values[bucket_id - 1]) <= t: return True if bucket_id + 1 in values and abs(nums[i] - values[bucket_id + 1]) <= t: return True values[bucket_id] = nums[i] if i >= k: del values[nums[i - k] // (t + 1)] return False"},{"question":"def unique_books(book_ids: List[int]) -> List[int]: Given a list of integers representing book identifiers, return a list with duplicates removed while preserving their original order. >>> unique_books([3, 5, 7, 3, 2, 5, 8, 2, 9]) [3, 5, 7, 2, 8, 9] >>> unique_books([1, 2, 3, 1, 2, 3]) [1, 2, 3] >>> unique_books([10, 20, 30, 20, 10, 30]) [10, 20, 30] >>> unique_books([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> unique_books([1, 3, 2, 3, 3, 1, 2]) [1, 3, 2]","solution":"def unique_books(book_ids): Returns a list of book identifiers with duplicates removed, preserving the original order of first appearance. seen = set() unique_list = [] for book_id in book_ids: if book_id not in seen: unique_list.append(book_id) seen.add(book_id) return unique_list"},{"question":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the list of strings. Parameters: strs (List[str]): List of strings to be grouped as anagrams. Returns: List[List[str]]: A list of lists containing the grouped anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] >>> group_anagrams([\\"cat\\"]) [[\\"cat\\"]] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"evil\\", \\"vile\\", \\"veil\\"]) [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\", \\"gogole\\"], [\\"evil\\", \\"vile\\", \\"veil\\"]]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together from the list of strings. Parameters: strs (List[str]): List of strings to be grouped as anagrams. Returns: List[List[str]]: A list of lists containing the grouped anagrams. anagram_dict = defaultdict(list) for word in strs: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"from typing import List, Tuple def task_scheduler(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Implement a simple task scheduler that executes tasks with dependencies in the correct order. If there is a cycle in the dependencies, the function returns an empty list. Args: - tasks: A list of strings representing the tasks to be executed. - dependencies: A list of pairs representing the dependency relationship between tasks. Returns: A list of strings representing the order in which the tasks should be executed. Examples: >>> task_scheduler([\\"a\\", \\"b\\", \\"c\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\")]) [\\"a\\", \\"b\\", \\"c\\"] >>> task_scheduler([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"a\\", \\"c\\"), (\\"c\\", \\"d\\")]) [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> task_scheduler([\\"a\\", \\"b\\", \\"c\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"a\\")]) [] >>> task_scheduler([\\"a\\", \\"b\\", \\"c\\"], []) any permutation of [\\"a\\", \\"b\\", \\"c\\"] >>> task_scheduler([\\"a\\"], []) [\\"a\\"]","solution":"from collections import defaultdict, deque def task_scheduler(tasks, dependencies): # Step 1: Initialize graph graph = defaultdict(list) indegree = {task: 0 for task in tasks} # Step 2: Build graph with indegree count for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Step 3: Initialize queue with tasks having no prerequisites queue = deque([task for task in tasks if indegree[task] == 0]) ordered_tasks = [] # Step 4: Process the queue while queue: current = queue.popleft() ordered_tasks.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all tasks are processed without cycle if len(ordered_tasks) == len(tasks): return ordered_tasks else: return []"},{"question":"def shiftString(input_str: str) -> str: Transforms the input string such that every character is replaced with the character that appears to its right in the English alphabet. The character 'z' is replaced by 'a'. Examples: >>> shiftString(\\"abc\\") 'bcd' >>> shiftString(\\"hello\\") 'ifmmp' >>> shiftString(\\"zebra\\") 'afcsb' >>> shiftString(\\"xyz\\") 'yza' >>> shiftString(\\"zzz\\") 'aaa' >>> shiftString(\\"a\\") 'b' >>> shiftString(\\"z\\") 'a' >>> shiftString(\\"azby\\") 'bacz' >>> shiftString(\\"helloz\\") 'ifmmpa' >>> shiftString(\\"\\") ''","solution":"def shiftString(input_str: str) -> str: Transforms the input string such that every character is replaced with the character that appears to its right in the English alphabet. The character 'z' is replaced by 'a'. result = [] for char in input_str: if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def minJumps(arr) -> int: Given an array of non-negative integers \`arr\`, find the minimum number of jumps required to reach the last index. Each element in the array represents your maximum jump length at that position. If it is not possible to reach the last index, return -1. Examples: >>> minJumps([2, 3, 1, 1, 4]) 2 >>> minJumps([2, 3, 0, 1, 4]) 2 >>> minJumps([1, 1, 1, 1, 1]) 4 >>> minJumps([0, 2, 3]) -1","solution":"def minJumps(arr): Returns the minimum number of jumps required to reach the last index. If not possible to reach the last index, returns -1. n = len(arr) if n == 1: return 0 # Initialize variables jumps = 0 max_reach = 0 edge = 0 for i in range(n): # Update the furthest point that can be reached max_reach = max(max_reach, i + arr[i]) if i == edge: # We must make a jump edge = max_reach jumps += 1 # If we have reached the last index if edge >= n - 1: return jumps # If we exit the loop without having reached the last index return -1"},{"question":"def can_assign_soldiers(soldiers, positions): Determines if soldiers can be assigned to positions such that each position is held by a soldier whose strength is greater than or equal to the position's required strength. >>> can_assign_soldiers([5, 3, 2, 8, 10], [5, 5, 3, 2]) True >>> can_assign_soldiers([1, 2, 3], [4, 5]) False # Test cases def test_can_assign_soldiers_true_cases(): assert can_assign_soldiers([5, 3, 2, 8, 10], [5, 5, 3, 2]) == True assert can_assign_soldiers([6, 7, 8, 9], [5, 5]) == True assert can_assign_soldiers([10, 10, 10], [8, 8, 8]) == True assert can_assign_soldiers([20], [10]) == True def test_can_assign_soldiers_false_cases(): assert can_assign_soldiers([1, 2, 3], [4, 5]) == False assert can_assign_soldiers([1, 1, 1], [2, 2, 2]) == False assert can_assign_soldiers([5, 5], [8, 8, 8]) == False assert can_assign_soldiers([5, 6], [8, 8]) == False def test_can_assign_soldiers_edge_cases(): assert can_assign_soldiers([], []) == True assert can_assign_soldiers([1], []) == True assert can_assign_soldiers([], [1]) == False","solution":"def can_assign_soldiers(soldiers, positions): Determines if soldiers can be assigned to positions such that each position is held by a soldier whose strength is greater than or equal to the position's required strength. soldiers.sort(reverse=True) positions.sort(reverse=True) i, j = 0, 0 while i < len(positions) and j < len(soldiers): if soldiers[j] >= positions[i]: i += 1 j += 1 return i == len(positions) # Example usage # soldiers = [5, 3, 2, 8, 10], positions = [5, 5, 3, 2] # print(can_assign_soldiers(soldiers, positions)) # Output should be True # soldiers = [1, 2, 3], positions = [4, 5] # print(can_assign_soldiers(soldiers, positions)) # Output should be False"},{"question":"def sum_array(arr: List[Union[int, float]]) -> Union[int, float]: Returns the sum of all the numbers in the array. Parameters: arr (list of int/float): The array of numbers to sum up. Returns: int/float: The sum of all the numbers in the array. >>> sum_array([1, 2, 3, 4, 5]) 15 >>> sum_array([0, 0, 0, 0, 0]) 0 >>> sum_array([-1, -2, -3, -4, -5]) -15 >>> sum_array([1.5, 2.5, 3.0, 4.5]) 11.5","solution":"def sum_array(arr): Returns the sum of all the numbers in the array. Parameters: arr (list of int/float): The array of numbers to sum up. Returns: int/float: The sum of all the numbers in the array. return sum(arr)"},{"question":"from typing import List def count_islands(grid: List[List[str]]) -> int: Count the number of islands in a grid. An island is formed by connecting adjacent lands horizontally or vertically. >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ] >>> count_islands(grid) 3 >>> grid = [ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ] >>> count_islands(grid) 0 >>> grid = [ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ] >>> count_islands(grid) 1 >>> grid = [ ... [\\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\"] ... ] >>> count_islands(grid) 3 >>> grid = [ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\"] ... ] >>> count_islands(grid) 6 >>> grid = [] >>> count_islands(grid) 0 >>> grid = [[]] >>> count_islands(grid) 0","solution":"from typing import List def count_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(r, c): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] == '0': return grid[r][c] = '0' # Mark as visited dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) islands = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': islands += 1 dfs(r, c) return islands"},{"question":"def is_artifact_in_collection(collection, artifact_id): Checks if the artifact_id is present in the collection. Parameters: collection (list): A list of integer artifact IDs. artifact_id (int): An integer representing a single artifact ID. Returns: bool: True if artifact_id is in collection, False otherwise. pass # Test Cases def test_is_artifact_in_collection_present(): collection = [123, 456, 789, 101112] artifact_id = 456 assert is_artifact_in_collection(collection, artifact_id) == True def test_is_artifact_in_collection_not_present(): collection = [123, 456, 789, 101112] artifact_id = 999 assert is_artifact_in_collection(collection, artifact_id) == False def test_is_artifact_in_collection_single_element_present(): collection = [999999999] artifact_id = 999999999 assert is_artifact_in_collection(collection, artifact_id) == True def test_is_artifact_in_collection_single_element_not_present(): collection = [100] artifact_id = 101 assert is_artifact_in_collection(collection, artifact_id) == False def test_is_artifact_in_collection_large_collection(): collection = list(range(1, 1000001)) artifact_id = 999999 assert is_artifact_in_collection(collection, artifact_id) == True def test_is_artifact_in_collection_large_collection_not_present(): collection = list(range(1, 1000001)) artifact_id = 1000001 assert is_artifact_in_collection(collection, artifact_id) == False","solution":"def is_artifact_in_collection(collection, artifact_id): Checks if the artifact_id is present in the collection. Parameters: collection (list): A list of integer artifact IDs. artifact_id (int): An integer representing a single artifact ID. Returns: bool: True if artifact_id is in collection, False otherwise. artifact_set = set(collection) return artifact_id in artifact_set"},{"question":"from typing import List def longest_mountain(A: List[int]) -> int: Given an array A of integers, return the length of the longest mountain. A mountain array is defined as an array that: 1. Has at least three elements. 2. There exists some i (0 < i < A.length - 1) such that: - A[0] < A[1] < ... < A[i - 1] < A[i] - A[i] > A[i + 1] > ... > A[A.length - 1] Example: >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0 >>> longest_mountain([0, 1, 0, 1]) 3 pass def test_longest_mountain_example1(): assert longest_mountain([2, 1, 4, 7, 3, 2, 5]) == 5 def test_longest_mountain_example2(): assert longest_mountain([2, 2, 2]) == 0 def test_longest_mountain_example3(): assert longest_mountain([0, 1, 0, 1]) == 3 def test_longest_mountain_short_array(): assert longest_mountain([1, 2, 3]) == 0 def test_longest_mountain_one_mountain(): assert longest_mountain([1, 3, 2, 1, 2]) == 4 def test_longest_mountain_multiple_mountains(): assert longest_mountain([2, 1, 4, 7, 3, 2, 4, 5, 3, 2, 1, 0, 8, 6, 5, 2, 3]) == 7 def test_longest_mountain_plateau(): assert longest_mountain([0, 1, 2, 2, 2, 1, 0]) == 0 def test_longest_mountain_edge_case(): assert longest_mountain([3, 2, 3, 4, 3]) == 4","solution":"def longest_mountain(A): Given an array A, returns the length of the longest mountain. n = len(A) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if A[i - 1] < A[i] > A[i + 1]: left = i - 1 while left > 0 and A[left - 1] < A[left]: left -= 1 right = i + 1 while right < n - 1 and A[right] > A[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"class VendingMachine: def __init__(self): self.products = {} def add_product(self, product_id: str, price: float, quantity: int) -> None: Adds a new product to the vending machine. If the product already exists, update its price and quantity. pass def purchase(self, product_id: str, amount_paid: float) -> str: Allows a user to purchase a product by providing a product_id and the amount_paid. Returns a string message based on the result of the purchase attempt. pass def check_availability(self, product_id: str) -> str: Returns \\"Available\\" if the product is in stock, \\"Out of stock\\" if it is not, or \\"Product not found\\" if the product does not exist. pass # Example usage: vm = VendingMachine() vm.add_product(\\"A1\\", 1.50, 10) vm.add_product(\\"B2\\", 2.00, 0) print(vm.purchase(\\"A1\\", 1.50)) # Output: \\"Purchase successful\\" print(vm.purchase(\\"A1\\", 1.00)) # Output: \\"Insufficient funds\\" print(vm.check_availability(\\"B2\\")) # Output: \\"Out of stock\\" print(vm.purchase(\\"B2\\", 2.00)) # Output: \\"Product out of stock\\" print(vm.check_availability(\\"C3\\")) # Output: \\"Product not found\\"","solution":"class VendingMachine: def __init__(self): self.products = {} def add_product(self, product_id: str, price: float, quantity: int) -> None: Adds a new product to the vending machine. If the product already exists, update its price and quantity. self.products[product_id] = {'price': price, 'quantity': quantity} def purchase(self, product_id: str, amount_paid: float) -> str: Allows a user to purchase a product by providing a product_id and the amount_paid. Returns a string message based on the result of the purchase attempt. if product_id not in self.products: return \\"Product not found\\" product = self.products[product_id] if product['quantity'] == 0: return \\"Product out of stock\\" if amount_paid < product['price']: return \\"Insufficient funds\\" product['quantity'] -= 1 return \\"Purchase successful\\" def check_availability(self, product_id: str) -> str: Returns \\"Available\\" if the product is in stock, \\"Out of stock\\" if it is not, or \\"Product not found\\" if the product does not exist. if product_id not in self.products: return \\"Product not found\\" if self.products[product_id]['quantity'] == 0: return \\"Out of stock\\" return \\"Available\\""},{"question":"def most_frequent_problem(N: int, problem_ids: List[int]) -> int: Returns the most frequently solved problem ID. If there is a tie, returns the smallest problem ID. >>> most_frequent_problem(6, [1, 2, 2, 3, 3, 3]) 3 >>> most_frequent_problem(6, [1, 2, 2, 3, 3]) 2 >>> most_frequent_problem(10**5, [1] * 50000 + [2] * 50000) 1 >>> most_frequent_problem(6, [9, 9, 9, 9, 9]) 9 >>> most_frequent_problem(4, [999999, 1, 999999, 1]) 1 from typing import List from collections import Counter","solution":"def most_frequent_problem(N, problem_ids): Returns the most frequently solved problem ID. If there is a tie, returns the smallest problem ID. from collections import Counter problem_counts = Counter(problem_ids) max_frequency = max(problem_counts.values()) most_frequent_ids = [pid for pid, count in problem_counts.items() if count == max_frequency] return min(most_frequent_ids) # Example usage: # N = 6 # problem_ids = [1, 2, 2, 3, 3, 3] # print(most_frequent_problem(N, problem_ids)) # Output: 3"},{"question":"def average_delivery_times(deliveries: List[str]) -> List[Tuple[str, float]]: Computes the average delivery time for each delivery driver and returns a sorted list based on driver's name. Parameters: deliveries (list): A list where the first element is an integer D representing the number of drivers and the rest are strings in the format \\"DriverName time1 time2 ... timeN\\". Returns: list: Sorted list of tuples (driver_name, average_time). pass from typing import List, Tuple def test_single_driver_single_time(): inputs = [\\"1\\", \\"Alice 30\\"] expected_output = [(\\"Alice\\", 30.0)] assert average_delivery_times(inputs) == expected_output def test_single_driver_multiple_times(): inputs = [\\"1\\", \\"Bob 30 40 50\\"] expected_output = [(\\"Bob\\", 40.0)] assert average_delivery_times(inputs) == expected_output def test_multiple_drivers(): inputs = [ \\"3\\", \\"John 30 40 50\\", \\"Alice 20 30 25 35\\", \\"Bob 50 60\\" ] expected_output = [ (\\"Alice\\", 27.5), (\\"Bob\\", 55.0), (\\"John\\", 40.0) ] assert average_delivery_times(inputs) == expected_output def test_driver_with_variable_times(): inputs = [\\"2\\", \\"Eve 10 20 10 20\\", \\"Frank 1000\\"] expected_output = [(\\"Eve\\", 15.0), (\\"Frank\\", 1000.0)] assert average_delivery_times(inputs) == expected_output def test_multiple_drivers_same_average(): inputs = [ \\"2\\", \\"Zara 50 50\\", \\"Yann 60 40\\" ] expected_output = [ (\\"Yann\\", 50.0), (\\"Zara\\", 50.0) ] assert average_delivery_times(inputs) == expected_output","solution":"def average_delivery_times(deliveries): Computes the average delivery time for each delivery driver and returns a sorted list based on driver's name. Parameters: deliveries (list): A list where the first element is an integer D representing the number of drivers and the rest are strings in the format \\"DriverName time1 time2 ... timeN\\". Returns: list: Sorted list of tuples (driver_name, average_time). D = int(deliveries[0]) driver_averages = [] for i in range(1, D + 1): parts = deliveries[i].split() driver_name = parts[0] times = list(map(int, parts[1:])) average_time = sum(times) / len(times) driver_averages.append((driver_name, average_time)) driver_averages.sort() # Sorting by driver name return driver_averages"},{"question":"from typing import List, Tuple def balance_weights(weights: List[int]) -> Tuple[List[int], List[int]]: Partition the list of weights into two subsets such that the difference between the sum of the weights in these subsets is minimized. >>> balance_weights([3, 1, 4, 2, 2]) ([3, 2, 2], [1, 4]) >>> balance_weights([1, 2, 3, 4, 5]) ([1, 4, 5], [2, 3])","solution":"from typing import List, Tuple def balance_weights(weights: List[int]) -> Tuple[List[int], List[int]]: Partition the list of weights into two subsets such that the difference between the sum of the weights in these subsets is minimized. total_sum = sum(weights) n = len(weights) # dp[i][j] will be True if a subset with sum j can be formed from the first i weights dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): dp[i][j] = dp[i-1][j] if j >= weights[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - weights[i-1]] # Find the largest j such that dp[n][j] is True and j <= total_sum // 2 for j in range(total_sum // 2, -1, -1): if dp[n][j]: subset_sum = j break # Reconstruct the subsets subset1 = [] subset2 = weights[:] for i in range(n, 0, -1): if subset_sum >= weights[i-1] and dp[i-1][subset_sum - weights[i-1]]: subset1.append(weights[i-1]) subset2.remove(weights[i-1]) subset_sum -= weights[i-1] return subset1, subset2"},{"question":"def generate_fibonacci(n): Generates the Fibonacci sequence up to the nth term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: list: A list containing the first n terms of the Fibonacci sequence. pass # Unit tests def test_generate_fibonacci_no_terms(): assert generate_fibonacci(0) == [] def test_generate_fibonacci_one_term(): assert generate_fibonacci(1) == [0] def test_generate_fibonacci_two_terms(): assert generate_fibonacci(2) == [0, 1] def test_generate_fibonacci_five_terms(): assert generate_fibonacci(5) == [0, 1, 1, 2, 3] def test_generate_fibonacci_ten_terms(): assert generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_generate_fibonacci_twenty_terms(): assert generate_fibonacci(20) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]","solution":"def generate_fibonacci(n): Generates the Fibonacci sequence up to the nth term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: list: A list containing the first n terms of the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def findWords(board: List[List[str]], words: List[str]) -> List[str]: Given an \`MxN\` grid of characters representing a word search puzzle and a list of words, find all words in the grid. A word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once for any word. >>> board = [ ... ['o', 'a', 'a', 'n'], ... ['e', 't', 'a', 'e'], ... ['i', 'h', 'k', 'r'], ... ['i', 'f', 'l', 'v'] ... ] >>> words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] >>> sorted(findWords(board, words)) ['eat', 'oath'] >>> board = [ ... ['o', 'a'], ... ['e', 'i'] ... ] >>> words = [\\"o\\", \\"a\\", \\"e\\", \\"i\\"] >>> sorted(findWords(board, words)) ['a', 'e', 'i', 'o'] >>> board = [ ... ['o', 'a', 'a', 'n'], ... ['e', 't', 'a', 'e'], ... ['i', 'h', 'k', 'r'], ... ['i', 'f', 'l', 'v'] ... ] >>> words = [\\"dog\\", \\"cat\\"] >>> sorted(findWords(board, words)) [] >>> board = [ ... ['a', 'a'], ... ['a', 'a'] ... ] >>> words = [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"] >>> sorted(findWords(board, words)) ['a', 'aa', 'aaa', 'aaaa']","solution":"def findWords(board, words): def dfs(board, word, index, x, y, visited): if index == len(word): return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or visited[x][y] or board[x][y] != word[index]: return False visited[x][y] = True directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in directions: if dfs(board, word, index + 1, x + dx, y + dy, visited): return True visited[x][y] = False return False found_words = [] for word in words: if any( dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))]) for i in range(len(board)) for j in range(len(board[0])) ): found_words.append(word) return found_words"},{"question":"def string_lengths(strings: List[str]) -> List[int]: Takes a list of strings and returns a list of integers representing their respective lengths. >>> string_lengths(['hello', 'world', '', 'Python', 'is', 'fun']) [5, 5, 0, 6, 2, 3] >>> string_lengths(['a', '', 'abc', '']) [1, 0, 3, 0] >>> string_lengths([]) [] >>> string_lengths(['longword', 'short', '', 'middlesize']) [8, 5, 0, 10] >>> string_lengths(['single']) [6] pass","solution":"def string_lengths(strings): Takes a list of strings and returns a list of integers representing their respective lengths. Parameters: strings (list of str): A list of strings Returns: list of int: A list of integers representing the lengths of the strings return [len(s) for s in strings]"},{"question":"def is_balanced(s: str) -> bool: Returns True if the string has balanced parentheses, otherwise False. >>> is_balanced(\\"(())\\") True >>> is_balanced(\\"(()\\") False >>> is_balanced(\\")(\\") False >>> is_balanced(\\"((()))\\") True >>> is_balanced(\\"()(())\\") True >>> is_balanced(\\"(()(()))\\") True >>> is_balanced(\\")))(((\\") False from solution import is_balanced def test_balanced_parentheses(): assert is_balanced(\\"(())\\") == True assert is_balanced(\\"(()\\") == False assert is_balanced(\\")(\\") == False assert is_balanced(\\"((()))\\") == True assert is_balanced(\\"()(())\\") == True assert is_balanced(\\"(()(()))\\") == True assert is_balanced(\\")))(((\\") == False def test_no_parentheses(): assert is_balanced(\\"\\") == True assert is_balanced(\\"abc\\") == True def test_single_parentheses(): assert is_balanced(\\"(\\") == False assert is_balanced(\\")\\") == False def test_parentheses_with_other_characters(): assert is_balanced(\\"(a+b)*(c-d)\\") == True assert is_balanced(\\"a+b)*(c-d)(\\") == False assert is_balanced(\\"((x+y)*(z))\\") == True def test_nested_parentheses(): assert is_balanced(\\"(((a)))\\") == True assert is_balanced(\\"((a)+((b*c)-d))\\") == True assert is_balanced(\\"(a + (b) + (c + (d)))\\") == True assert is_balanced(\\"(a + (b) + (c + (d))\\") == False","solution":"def is_balanced(s: str) -> bool: Returns True if the string has balanced parentheses, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def max_sublist_sum(input_list: List[int]) -> int: Implement a function that takes a list of integers and returns the maximum possible sum of a sublist (or subarray). A sublist can be empty, which means the minimum possible sum is 0. >>> max_sublist_sum([3, -2, 5, -1]) == 6 >>> max_sublist_sum([-2, -3, -1]) == 0 >>> max_sublist_sum([1, 2, 3, 4, 5]) == 15 >>> max_sublist_sum([34, -50, 42, 14, -5, 86]) == 137","solution":"def max_sublist_sum(input_list): Returns the maximum possible sum of a sublist in the given list. If the list contains only negative numbers, the maximum sum will be 0, as an empty sublist is considered legitimate. max_sum = 0 current_sum = 0 for num in input_list: current_sum = max(0, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def process_list(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list where each element is squared but only if the element is an even number. Odd numbers remain unchanged. :param nums: List of integers :return: A new list where even numbers are squared and odd numbers remain the same >>> process_list([1, 2, 3, 4]) [1, 4, 3, 16] >>> process_list([2, 4, 6]) [4, 16, 36] >>> process_list([1, 3, 5]) [1, 3, 5] >>> process_list([]) [] >>> process_list([2]) [4] >>> process_list([1]) [1] >>> process_list([-2, -4]) [4, 16] >>> process_list([-1, -3]) [-1, -3] >>> process_list([-2, 3, -4, 5, 6]) [4, 3, 16, 5, 36]","solution":"def process_list(nums): Takes a list of integers and returns a new list where each element is squared but only if the element is an even number. Odd numbers remain unchanged. :param nums: List of integers :return: A new list where even numbers are squared and odd numbers remain the same return [x**2 if x % 2 == 0 else x for x in nums]"},{"question":"def analyze_performance(N: int, sessions: List[Tuple[float, float]]) -> Tuple[List[str], str, str]: This function takes the number of days (N) and a list of tuples representing (distance, time) for each day. It calculates the average speeds for each run, the best performance (maximum speed), and the worst performance (minimum speed). Args: N (int): Number of days she runs. sessions (List[Tuple[float, float]]): Each tuple contains the distance in kilometers and the time in hours respectively. Returns: Tuple[List[str], str, str]: A tuple containing a list of average speeds with each value up to 6 decimal places, the best performance rounded up to 6 decimal places, and the worst performance rounded up to 6 decimal places. pass # Unit Test from solution import analyze_performance def test_analyze_performance_with_three_sessions(): N = 3 sessions = [(5.00, 0.50), (10.00, 1.00), (21.00, 2.50)] speeds, best, worst = analyze_performance(N, sessions) assert speeds == ['10.000000', '10.000000', '8.400000'] assert best == '10.000000' assert worst == '8.400000' def test_analyze_performance_with_two_sessions(): N = 2 sessions = [(3.00, 0.30), (7.00, 0.35)] speeds, best, worst = analyze_performance(N, sessions) assert speeds == ['10.000000', '20.000000'] assert best == '20.000000' assert worst == '10.000000' def test_analyze_performance_with_minimal_input(): N = 1 sessions = [(42.00, 4.00)] speeds, best, worst = analyze_performance(N, sessions) assert speeds == ['10.500000'] assert best == '10.500000' assert worst == '10.500000' def test_analyze_performance_with_varied_speeds(): N = 4 sessions = [(8.00, 2.00), (16.00, 2.00), (4.00, 1.00), (20.00, 5.00)] speeds, best, worst = analyze_performance(N, sessions) assert speeds == ['4.000000', '8.000000', '4.000000', '4.000000'] assert best == '8.000000' assert worst == '4.000000' def test_analyze_performance_edge_case(): N = 5 sessions = [(5.00, 0.50), (10.00, 1.00), (15.00, 1.50), (20.00, 2.00), (25.00, 2.50)] speeds, best, worst = analyze_performance(N, sessions) assert speeds == ['10.000000', '10.000000', '10.000000', '10.000000', '10.000000'] assert best == '10.000000' assert worst == '10.000000'","solution":"def analyze_performance(N, sessions): This function takes the number of days (N) and a list of tuples representing (distance, time) for each day. It calculates the average speeds for each run, the best performance (maximum speed), and the worst performance (minimum speed). speeds = [d / t for d, t in sessions] best_performance = max(speeds) worst_performance = min(speeds) speeds = [f\\"{speed:.6f}\\" for speed in speeds] best_performance = f\\"{best_performance:.6f}\\" worst_performance = f\\"{worst_performance:.6f}\\" return speeds, best_performance, worst_performance # Example usage: N = 3 sessions = [(5.00, 0.50), (10.00, 1.00), (21.00, 2.50)] print(analyze_performance(N, sessions))"},{"question":"def strings_to_length_dict(strings: List[str]) -> Dict[str, int]: Create a function that takes a list of strings and returns a dictionary where the keys are the strings and the values are the lengths of those strings. >>> strings_to_length_dict([\\"apple\\", \\"banana\\", \\"cherry\\"]) {\\"apple\\": 5, \\"banana\\": 6, \\"cherry\\": 6} >>> strings_to_length_dict([]) {} >>> strings_to_length_dict([\\"\\"]) { \\"\\": 0 } >>> strings_to_length_dict([\\"a\\", \\"ab\\", \\"abc\\"]) { \\"a\\": 1, \\"ab\\": 2, \\"abc\\": 3 } >>> strings_to_length_dict([\\"same\\", \\"same\\", \\"diff\\"]) { \\"same\\": 4, \\"diff\\": 4 }","solution":"def strings_to_length_dict(strings): Returns a dictionary where the keys are the strings from the input list and the values are the lengths of those strings. :param strings: List of strings :return: Dictionary with strings as keys and their lengths as values return {string: len(string) for string in strings}"},{"question":"def count_characters(s: str) -> dict: Count the frequency of characters in a given string, case insensitively. Parameters: s (str): The input string. Returns: dict: A dictionary where keys are characters and values are their respective counts. >>> count_characters(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} >>> count_characters(\\"\\") {} >>> count_characters(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2}","solution":"def count_characters(s): Count the frequency of characters in a given string, case insensitively. Parameters: s (str): The input string. Returns: dict: A dictionary with characters as keys and their frequencies as values. s = s.lower() frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def rotate_list(arr, n): Rotates the elements of the list to the back n times. Args: arr (list of int): The list to be rotated. n (int): The number of rotations to perform. Returns: list of int: The rotated list. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] >>> rotate_list([10, 20, 30, 40, 50], 3) == [40, 50, 10, 20, 30] >>> rotate_list([1, 2, 3, 4, 5], 7) == [3, 4, 5, 1, 2] >>> rotate_list([], 3) == [] >>> rotate_list([1], 2) == [1] >>> rotate_list([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], -1) == [5, 1, 2, 3, 4]","solution":"def rotate_list(arr, n): Rotates the elements of the list to the back n times. Args: arr (list of int): The list to be rotated. n (int): The number of rotations to perform. Returns: list of int: The rotated list. if not arr: return [] n = n % len(arr) # To handle cases when n is greater than the length of the list return arr[n:] + arr[:n]"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if any permutation of the given string can form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"abba\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abcdefghij\\") False","solution":"def can_form_palindrome(s): Returns True if any permutation of the string forms a palindrome, False otherwise. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if there is at most one character with an odd number of occurrences return odd_count <= 1"},{"question":"def hourglass(n: int) -> str: Design a function that takes a single integer \`n\` as input and returns a string representing an hourglass pattern. The hourglass pattern should have \`n\` rows on each half. >>> hourglass(3) '*****n ***n *n ***n*****' >>> hourglass(5) '*********n *******n *****n ***n *n ***n *****n *******n*********' >>> hourglass(4) '*******n *****n ***n *n ***n *****n*******' >>> hourglass(1) '*' >>> hourglass(0) '' >>> hourglass(-3) ''","solution":"def hourglass(n: int) -> str: if n < 1: return \\"\\" hourglass_rows = [] # Generate the top half of the hourglass for i in range(n): spaces = ' ' * i stars = '*' * (2 * (n - i) - 1) hourglass_rows.append(spaces + stars) # Generate the bottom half of the hourglass for i in range(n-2, -1, -1): spaces = ' ' * i stars = '*' * (2 * (n - i) - 1) hourglass_rows.append(spaces + stars) return \\"n\\".join(hourglass_rows)"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of changes needed to make the input string a palindrome. >>> min_changes_to_palindrome('aaaa') == 0 >>> min_changes_to_palindrome('abca') == 1 >>> min_changes_to_palindrome('racecar') == 0 >>> min_changes_to_palindrome('abcd') == 2 >>> min_changes_to_palindrome('') == 0 >>> min_changes_to_palindrome('a') == 0 >>> min_changes_to_palindrome('abcde') == 2","solution":"def min_changes_to_palindrome(s): Returns the minimum number of changes needed to make the input string a palindrome. left, right = 0, len(s) - 1 changes = 0 while left < right: if s[left] != s[right]: changes += 1 left += 1 right -= 1 return changes"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and sell operation on given stock prices. Args: prices (List[int]): List of stock prices. Returns: int: Maximum profit possible, or 0 if no profit is possible. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([3, 2, 4, 8, 7, 6]) 6 >>> max_profit([1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell operation on given stock prices. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(node_descriptions: List[List[int]]) -> Optional[TreeNode]: if not node_descriptions: return None nodes = {} for u, v, c in node_descriptions: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) if c == 'L': nodes[u].left = nodes[v] else: # 'R' nodes[u].right = nodes[v] return nodes[node_descriptions[0][0]] def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the level order traversal of the tree’s nodes' values. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> levelOrder(root) [[1],[2, 3],[4, 5, 6]] >>> node_descriptions = [(1, 2, 'L'), (1, 3, 'R'), (2, 4, 'L'), (2, 5, 'R'), (3, 6, 'L')] >>> root = build_tree(node_descriptions) >>> levelOrder(root) [[1],[2, 3],[4, 5, 6]] pass","solution":"from typing import List, Optional from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(node_descriptions: List[List[int]]) -> Optional[TreeNode]: if not node_descriptions: return None nodes = {} for u, v, c in node_descriptions: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) if c == 'L': nodes[u].left = nodes[v] else: # 'R' nodes[u].right = nodes[v] # the root node is the first node in node_descriptions return nodes[node_descriptions[0][0]] def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"from typing import List, Tuple def min_deletions_to_make_anagrams(s1: str, s2: str) -> int: Determine the minimum number of deletions required from s1 and s2 to make them anagrams. >>> min_deletions_to_make_anagrams(\\"abc\\", \\"cde\\") 4 >>> min_deletions_to_make_anagrams(\\"aabbcc\\", \\"abccdd\\") 4 pass def solve_anagram_problems(test_cases: List[Tuple[str, str]]) -> List[int]: Solves multiple test cases of the anagram problem. >>> solve_anagram_problems([(\\"abc\\", \\"cde\\"), (\\"aabbcc\\", \\"abccdd\\")]) [4, 4] >>> solve_anagram_problems([(\\"abc\\", \\"abc\\"), (\\"a\\", \\"b\\"), (\\"banana\\", \\"ananas\\")]) [0, 2, 2] pass","solution":"from collections import Counter def min_deletions_to_make_anagrams(s1, s2): Returns the minimum number of deletions required from s1 and s2 to make them anagrams. count1 = Counter(s1) count2 = Counter(s2) deletions = 0 # Find characters in s1 not in s2 and their differences for char in count1: if char in count2: deletions += abs(count1[char] - count2[char]) else: deletions += count1[char] # Find characters in s2 not in s1 for char in count2: if char not in count1: deletions += count2[char] return deletions def solve_anagram_problems(test_cases): results = [] for s1, s2 in test_cases: results.append(min_deletions_to_make_anagrams(s1, s2)) return results"},{"question":"def parse_duration(duration_str: str) -> int: Parses a duration string and converts it to total seconds. >>> parse_duration(\\"2 hours 30 minutes\\") 9000 >>> parse_duration(\\"45 minutes 15 seconds\\") 2715 >>> parse_duration(\\"1 hour 1 minute 1 second\\") 3661 >>> parse_duration(\\"50 seconds\\") 50 >>> parse_duration(\\"3 hours\\") 10800 >>> parse_duration(\\"10 minutes\\") 600 >>> parse_duration(\\"5 hours 45 minutes 30 seconds\\") 20730 >>> parse_duration(\\"\\") 0 >>> parse_duration(\\"1 hour\\") 3600 >>> parse_duration(\\"1 minute\\") 60 >>> parse_duration(\\"1 second\\") 1","solution":"def parse_duration(duration_str): Parses a duration string and converts it to total seconds. Args: duration_str (str): The duration string in the format \\"X hours Y minutes Z seconds\\". Returns: int: The total duration in seconds. total_seconds = 0 elements = duration_str.split() if 'hours' in elements or 'hour' in elements: hours_index = elements.index('hours') if 'hours' in elements else elements.index('hour') total_seconds += int(elements[hours_index - 1]) * 3600 if 'minutes' in elements or 'minute' in elements: minutes_index = elements.index('minutes') if 'minutes' in elements else elements.index('minute') total_seconds += int(elements[minutes_index - 1]) * 60 if 'seconds' in elements or 'second' in elements: seconds_index = elements.index('seconds') if 'seconds' in elements else elements.index('second') total_seconds += int(elements[seconds_index - 1]) return total_seconds"},{"question":"def merge_sort(arr: List[int]) -> List[int]: Sorts an array in non-decreasing order using the merge sort algorithm and removes any duplicate values from the final sorted array. >>> merge_sort([4, 2, 7, 3, 1, 5]) [1, 2, 3, 4, 5, 7] >>> merge_sort([4, 4, 2, 7, 2, 3, 1, 5, 4, 1]) [1, 2, 3, 4, 5, 7] def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted arrays into one sorted array and removes duplicates. >>> merge([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6]","solution":"def merge_sort(arr): Sorts an array in non-decreasing order using the merge sort algorithm and removes any duplicate values from the final sorted array. if len(arr) <= 1: return arr # Divide the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the two halves while removing duplicates return merge(left_half, right_half) def merge(left, right): Merges two sorted arrays into one sorted array and removes duplicates. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: if not merged or merged[-1] != left[i]: merged.append(left[i]) i += 1 elif left[i] > right[j]: if not merged or merged[-1] != right[j]: merged.append(right[j]) j += 1 else: if not merged or merged[-1] != left[i]: merged.append(left[i]) i += 1 j += 1 # Append remaining elements from left while i < len(left): if not merged or merged[-1] != left[i]: merged.append(left[i]) i += 1 # Append remaining elements from right while j < len(right): if not merged or merged[-1] != right[j]: merged.append(right[j]) j += 1 return merged"},{"question":"def find_smallest_missing_positive(nums: List[int]) -> int: Write a function to find the smallest positive integer that is missing from an array of integers. The input array can contain both positive and negative integers, and the function should find the smallest positive integer that does not appear in the array. The function should return this smallest missing positive integer. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([-1, -2, -3]) 1","solution":"def find_smallest_missing_positive(nums): Finds the smallest positive integer that is missing from the array nums. :param nums: List of integers which can contain both positive and negative numbers :return: The smallest positive integer that does not appear in the array n = len(nums) # Step 1: Move all positive integers to their correct index positions if possible for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Step 2: Find the first missing positive integer for i in range(n): if nums[i] != i + 1: return i + 1 # If no missing positive integer is found in the range [1, n], return n + 1 return n + 1"},{"question":"def calculate_elevation_change(path: str) -> int: Calculates the total elevation change after completing the path. :param path: A string consisting of 'U' and 'D' characters. :return: The final elevation after the race as an integer. >>> calculate_elevation_change(\\"UUDDUUU\\") 3 >>> calculate_elevation_change(\\"U\\") 1 >>> calculate_elevation_change(\\"D\\") -1 >>> calculate_elevation_change(\\"UD\\") 0 >>> calculate_elevation_change(\\"DU\\") 0 >>> calculate_elevation_change(\\"UUUUU\\") 5 >>> calculate_elevation_change(\\"DDDDD\\") -5 >>> calculate_elevation_change(\\"UUDDUDUUDD\\") 0 >>> calculate_elevation_change(\\"U\\" * 50000 + \\"D\\" * 50000) 0","solution":"def calculate_elevation_change(path): Calculates the total elevation change after completing the path. :param path: A string consisting of 'U' and 'D' characters. :return: The final elevation after the race as an integer. elevation = 0 for step in path: if step == 'U': elevation += 1 elif step == 'D': elevation -= 1 return elevation"},{"question":"from typing import List, Tuple def pair_with_max_sum(pairs: List[Tuple[int, int]]) -> Tuple[int, Tuple[int, int]]: Given a list of integer pairs, find the pair with the maximum sum, and return both the sum and the pair. >>> pair_with_max_sum([(1, 2), (3, 4), (10, -2)]) (8, (10, -2)) >>> pair_with_max_sum([(0, 0), (-1, -1), (-2, -3)]) (0, (0, 0)) >>> pair_with_max_sum([(1, 1), (2, 2), (3, 3)]) (6, (3, 3)) >>> pair_with_max_sum([]) (None, None) >>> pair_with_max_sum([(-5, 15), (10, -10), (15, -5)]) (10, (-5, 15)) >>> pair_with_max_sum([(1, 2), (2, 1), (1, 1)]) (3, (1, 2))","solution":"def pair_with_max_sum(pairs): Returns the pair with the maximum sum and the sum itself. if not pairs: return None, None max_pair = pairs[0] max_sum = sum(max_pair) for pair in pairs[1:]: current_sum = sum(pair) if current_sum > max_sum: max_sum = current_sum max_pair = pair return max_sum, max_pair"},{"question":"def longest_balanced_set_length(test_cases): Determine the length of the longest balanced set of stamps for given test cases. A balanced set is defined as a set where the differences between the values of every two consecutive stamps are the same, and the set contains at least 2 stamps. Args: - test_cases: A list of tuples; each tuple contains an integer N (number of stamps), followed by a list of N integers representing the values of the stamps. Returns: - A list of integers representing the length of the longest balanced set for each test case. >>> test_cases = [(7, [10, 12, 14, 16, 10, 8, 6]), (5, [1, 3, 2, 4, 6])] >>> longest_balanced_set_length(test_cases) [4, 3] >>> test_cases = [(1, [5])] >>> longest_balanced_set_length(test_cases) [0] >>> test_cases = [(4, [1, 2, 4, 8])] >>> longest_balanced_set_length(test_cases) [2] >>> test_cases = [(5, [10, 10, 10, 10, 10])] >>> longest_balanced_set_length(test_cases) [5] >>> test_cases = [(9, [1, 3, 5, 7, 9, 2, 4, 6, 8])] >>> longest_balanced_set_length(test_cases) [5] >>> test_cases = [(5, [10, 8, 6, 4, 2])] >>> longest_balanced_set_length(test_cases) [5] def parse_input(input_str): Parses the input string into test cases as required by the problem. Args: - input_str: A string representing the input data. Returns: - A list of tuples; each tuple contains an integer N (number of stamps), followed by a list of N integers representing the values of the stamps. >>> input_str = \\"2n7n10 12 14 16 10 8 6n5n1 3 2 4 6\\" >>> parse_input(input_str) [(7, [10, 12, 14, 16, 10, 8, 6]), (5, [1, 3, 2, 4, 6])] >>> input_str = \\"1n1n5\\" >>> parse_input(input_str) [(1, [5])] # Example usage with input parsing and solving the problem input_str = 2 7 10 12 14 16 10 8 6 5 1 3 2 4 6 test_cases = parse_input(input_str) result = longest_balanced_set_length(test_cases) print(result) # Expected output: [4, 3]","solution":"def longest_balanced_set_length(test_cases): results = [] for data in test_cases: N, stamps = data if N < 2: results.append(0) continue longest_length = 2 for i in range(N-1): diff = stamps[i+1] - stamps[i] current_length = 2 for j in range(i+2, N): if stamps[j] - stamps[j-1] == diff: current_length += 1 else: break longest_length = max(longest_length, current_length) results.append(longest_length) return results # Helper function to parse the input according to the given problem def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] line_idx = 1 for _ in range(T): N = int(input_lines[line_idx]) stamps = list(map(int, input_lines[line_idx + 1].split())) test_cases.append((N, stamps)) line_idx += 2 return test_cases # Example usage input_str = 2 7 10 12 14 16 10 8 6 5 1 3 2 4 6 test_cases = parse_input(input_str) result = longest_balanced_set_length(test_cases) print(result) # Output: [4, 3]"},{"question":"def nested_sum(nested_list): Returns the cumulative sum of all integers in a nested list. >>> nested_sum([5]) 5 >>> nested_sum([1, 2, 3]) 6 >>> nested_sum([1, [2, 3], [[4]], [5, [6, [7]]]]) 28 >>> nested_sum([1, [2, [3, [4, [5, [6, [7]]]]]]]) 28 >>> nested_sum([[]]) 0 >>> nested_sum([[[]]]) 0 >>> nested_sum([1, [], [2, [], [3, [4, []]], 5]]) 15 >>> nested_sum([1, [2, 3, [4]], [5, [], [6, 7, []]], 8]) 36 >>> nested_sum([[], [[]], [[[]]]]) 0 >>> nested_sum([[1], [2], [3]]) 6 >>> nested_sum([[[[[]]]]]) 0","solution":"def nested_sum(nested_list): Returns the cumulative sum of all integers in a nested list. total = 0 for element in nested_list: if isinstance(element, list): total += nested_sum(element) else: total += element return total"},{"question":"from typing import List def has_pair_with_difference(nums: List[int], n: int) -> bool: Returns True if there are two different integers in the list whose difference is exactly n; otherwise, returns False. Args: nums (list of int): List of integers. n (int): A positive integer representing the target difference. Returns: bool: True if there exist two different integers with the difference n, False otherwise. pass def test_has_pair_with_difference_exists(): assert has_pair_with_difference([1, 5, 3, 4, 2], 2) == True assert has_pair_with_difference([10, 15, 7, 9, 21], 12) == True def test_has_pair_with_difference_not_exists(): assert has_pair_with_difference([1, 2, 3, 4, 5], 10) == False assert has_pair_with_difference([7, 14, 21, 28], 5) == False def test_has_pair_with_difference_single_pair(): assert has_pair_with_difference([5, 8], 3) == True assert has_pair_with_difference([100, 200], 100) == True def test_has_pair_with_difference_large_values(): assert has_pair_with_difference([1000000, 999999, 1], 999999) == True assert has_pair_with_difference([1000000, 10, 1010], 990) == False","solution":"def has_pair_with_difference(nums, n): Returns True if there are two different integers in the list whose difference is exactly n; otherwise, returns False. Args: nums (list of int): List of integers. n (int): A positive integer representing the target difference. Returns: bool: True if there exist two different integers with the difference n, False otherwise. num_set = set(nums) for num in nums: if (num + n) in num_set or (num - n) in num_set: return True return False"},{"question":"def identify_plant(attributes_dict: dict, attributes_str: str) -> str: Checks given specific attributes, determines the species name of the plant. >>> attributes_dict = { ... \\"Rose\\": {\\"leaf shape\\": \\"oval\\", \\"flower color\\": \\"red\\", \\"height\\": 50}, ... \\"Tulip\\": {\\"leaf shape\\": \\"lance\\", \\"flower color\\": \\"yellow\\", \\"height\\": 30}, ... \\"Sunflower\\": {\\"leaf shape\\": \\"heart\\", \\"flower color\\": \\"yellow\\", \\"height\\": 150} ... } >>> identify_plant(attributes_dict, \\"oval,red,50\\") 'Rose' >>> identify_plant(attributes_dict, \\"lance,yellow,30\\") 'Tulip' >>> identify_plant(attributes_dict, \\"heart,yellow,200\\") 'Unknown'","solution":"def identify_plant(attributes_dict, attributes_str): attributes_list = attributes_str.split(',') given_attributes = { 'leaf shape': attributes_list[0], 'flower color': attributes_list[1], 'height': int(attributes_list[2]) } for species, attrs in attributes_dict.items(): if attrs == given_attributes: return species return \\"Unknown\\""},{"question":"def is_valid_identifier(identifier: str) -> str: Determine whether a given string is a valid identifier. Rules: - The identifier must start with a letter (a-z, A-Z) or an underscore (_). - The rest of the identifier can contain letters, digits (0-9), or underscores (_). - Identifiers are case-sensitive. Parameters: identifier (str): The string to be checked. Returns: str: \\"Valid\\" if the string is a valid identifier, otherwise \\"Invalid\\". Examples: >>> is_valid_identifier(\\"variable_1\\") \\"Valid\\" >>> is_valid_identifier(\\"2_variable\\") \\"Invalid\\" >>> is_valid_identifier(\\"_variable\\") \\"Valid\\" >>> is_valid_identifier(\\"variable\\") \\"Invalid\\" >>> is_valid_identifier(\\"Variable123\\") \\"Valid\\"","solution":"def is_valid_identifier(identifier): Determines if the given string is a valid identifier. Parameters: identifier (str): The string to be checked. Returns: str: \\"Valid\\" if the string is a valid identifier, otherwise \\"Invalid\\". if not identifier: return \\"Invalid\\" if identifier[0].isalpha() or identifier[0] == '_': for char in identifier: if not (char.isalnum() or char == '_'): return \\"Invalid\\" return \\"Valid\\" return \\"Invalid\\""},{"question":"def sum_within_ranges(lst: List[int], ranges: List[Tuple[int, int]]) -> List[int]: Returns the sum of the elements within each range. >>> sum_within_ranges([2, 4, 6, 8, 10, 12], [(1, 3), (2, 5), (0, 4)]) == [18, 36, 30] >>> sum_within_ranges([1, 2, 3, 4, 5], [(0, 4)]) == [15] >>> sum_within_ranges([1, 1, 1, 1, 1, 1], [(0, 2), (1, 3), (3, 5)]) == [3, 3, 3]","solution":"def sum_within_ranges(lst, ranges): Returns the sum of the elements within each range. Parameters: lst (list): a list of integers (1-indexed internally). ranges (list of tuples): each tuple contains start and end indices (inclusive). Returns: list: the sum of elements within each range. results = [] for start, end in ranges: results.append(sum(lst[start:end+1])) return results # Example usage: # lst = [2, 4, 6, 8, 10, 12] # ranges = [(1, 3), (2, 5), (0, 4)] # print(sum_within_ranges(lst, ranges)) # Output: [18, 36, 30]"},{"question":"def num_subarray_product_less_than_k(nums: List[int], threshold: int) -> int: Returns the number of non-empty subarrays of \`nums\` whose product is strictly less than \`threshold\`. >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_k([1, 2, 3], 0) 0 >>> num_subarray_product_less_than_k([1, 1, 1], 1) 0 >>> num_subarray_product_less_than_k([1], 1) 0 >>> num_subarray_product_less_than_k([1], 2) 1 >>> num_subarray_product_less_than_k([1, 2], 2) 1 >>> num_subarray_product_less_than_k([1, 2], 3) 3 >>> num_subarray_product_less_than_k([1, 1, 1], 2) 6","solution":"def num_subarray_product_less_than_k(nums, threshold): Returns the number of non-empty subarrays of \`nums\` whose product is strictly less than \`threshold\`. if threshold <= 1: return 0 left = 0 product = 1 count = 0 for right in range(len(nums)): product *= nums[right] while product >= threshold and left <= right: product //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"def next_letter_string(s: str) -> str: Returns a new string where each letter character in the original string is replaced by its next letter in the alphabet. Non-letter characters remain unchanged. >>> next_letter_string(\\"hello world!\\") \\"ifmmp xpsme!\\" >>> next_letter_string(\\"abcd-xyz\\") \\"bcde-yza\\" >>> next_letter_string(\\"a*b!z\\") \\"b*c!a\\" >>> next_letter_string(\\"!@# cdef 123\\") \\"!@# defg 123\\" >>> next_letter_string(\\"z\\") \\"a\\" >>> next_letter_string(\\"xyz\\") \\"yza\\" >>> next_letter_string(\\"aAbBcC\\") \\"bBcCdD\\" >>> next_letter_string(\\"XyZ\\") \\"YzA\\" >>> next_letter_string(\\"hello there\\") \\"ifmmp uifsf\\" >>> next_letter_string(\\"hello n there\\") \\"ifmmp n uifsf\\" >>> next_letter_string(\\"\\") \\"\\"","solution":"def next_letter_string(s): Returns a new string where each letter character in the original string is replaced by its next letter in the alphabet. Non-letter characters remain unchanged. result = [] for char in s: if char.isalpha(): if char == 'z': result.append('a') elif char == 'Z': result.append('A') else: result.append(chr(ord(char) + 1)) else: result.append(char) return ''.join(result)"},{"question":"from typing import List, Tuple def count_paths(n: int, m: int, d: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Count the number of paths from node \`0\` to node \`n-1\` such that the sum of values on the path is divisible by \`d\`. Parameters: n (int): Number of nodes m (int): Number of edges d (int): Divisor values (List[int]): List of values for each node edges (List[Tuple[int, int]]): List of directed edges represented as tuples Returns: int: The number of valid paths modulo 1000000007 >>> count_paths(5, 6, 3, [1, 2, 3, 4, 5], [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (1, 4)]) 1 >>> count_paths(4, 4, 5, [5, 10, 15, 20], [(0, 1), (1, 2), (1, 3), (2, 3)]) 2 >>> count_paths(3, 2, 4, [4, 8, 12], [(0, 1), (1, 2)]) 1","solution":"from collections import defaultdict, deque MOD = 1000000007 def count_paths(n, m, d, values, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) dp = defaultdict(lambda: [0] * d) dp[0][values[0] % d] = 1 topo_order = [] in_degree = [0] * n for u in range(n): for v in graph[u]: in_degree[v] += 1 queue = deque([u for u in range(n) if in_degree[u] == 0]) while queue: u = queue.popleft() topo_order.append(u) for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) for u in topo_order: for v in graph[u]: for j in range(d): dp[v][(j + values[v]) % d] = (dp[v][(j + values[v]) % d] + dp[u][j]) % MOD return dp[n-1][0] # Example usage: # n = 5 # m = 6 # d = 3 # values = [1, 2, 3, 4, 5] # edges = [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (1, 4)] # result = count_paths(n, m, d, values, edges) # print(result) # Output: 1"},{"question":"from typing import List, Dict def calculate_total_time(logs: List[str]) -> Dict[str, int]: Calculate the total amount of time each employee spent inside the company. Args: logs: List of log entries. Returns: Dictionary with user ids as keys and total minutes as values. Example: >>> calculate_total_time([\\"09:10 A1 entry\\", \\"09:20 A1 exit\\"]) {'A1': 10} >>> calculate_total_time([ \\"09:10 A1 entry\\", \\"17:45 A2 entry\\", \\"09:20 A1 exit\\", \\"18:00 A2 exit\\", \\"12:00 A3 entry\\", \\"12:30 A3 exit\\"]) {'A1': 10, 'A2': 15, 'A3': 30} pass # Implement this function def process_logs(num_cases: int, data: List[str]) -> List[str]: Process multiple test cases of logs and calculate the total time for each user in each case. Args: num_cases: Number of test cases. data: List of strings representing multiple test cases and their log entries. Returns: List of strings with user id and total minutes for each user in each test case. Example: >>> process_logs(2, [ \\"6\\", \\"09:10 A1 entry\\", \\"17:45 A2 entry\\", \\"09:20 A1 exit\\", \\"18:00 A2 exit\\", \\"12:00 A3 entry\\", \\"12:30 A3 exit\\", \\"4\\", \\"12:00 A1 entry\\", \\"09:10 A2 entry\\", \\"12:30 A1 exit\\", \\"11:00 A2 exit\\"]) [\\"A1 10\\", \\"A2 15\\", \\"A3 30\\", \\"A1 30\\", \\"A2 110\\"] pass # Implement this function","solution":"def calculate_total_time(logs): from collections import defaultdict import datetime def str_to_minutes(time_str): hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes user_times = defaultdict(list) for log in logs: time_str, userid, event = log.split() time = str_to_minutes(time_str) user_times[userid].append((time, event)) total_times = {} for userid, times in user_times.items(): times.sort() total_time = 0 i = 0 while i < len(times) - 1: if times[i][1] == \\"entry\\" and times[i+1][1] == \\"exit\\": total_time += times[i+1][0] - times[i][0] i += 2 else: i += 1 total_times[userid] = total_time return total_times def process_logs(num_cases, data): results = [] index = 0 for _ in range(num_cases): num_logs = int(data[index]) logs = data[index+1:index+1+num_logs] total_times = calculate_total_time(logs) for userid in sorted(total_times): results.append(f\\"{userid} {total_times[userid]}\\") index += 1 + num_logs return results"},{"question":"def find_pairs(arr, target): Returns all unique pairs of numbers from the array that add up to the target sum. >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([1, 1, 2, 2], 3) [[1, 2]] >>> find_pairs([2, 2, 2, 2], 4) [[2, 2]] >>> find_pairs([1, 3, 4, 5, 7, -1], 4) [[-1, 5], [1, 3]] >>> find_pairs([5], 5) [] >>> find_pairs([3, -1, -2, 4], 2) [[-2, 4], [-1, 3]] >>> find_pairs([], 5) []","solution":"def find_pairs(arr, target): Returns all unique pairs of numbers from the array that add up to the target sum. seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return [list(pair) for pair in sorted(pairs)]"},{"question":"def closest_to_zero(numbers): Write a function named closest_to_zero that takes a list of integers and returns the integer closest to zero. If there are two numbers equally close to zero, the positive one should be returned. If the list is empty, return None. >>> closest_to_zero([3, -2, 2, 1, -1]) == 1 >>> closest_to_zero([5, -5, -3, 3, 0]) == 0 >>> closest_to_zero([10, -10]) == 10 >>> closest_to_zero([]) == None pass","solution":"def closest_to_zero(numbers): Returns the integer closest to zero. If there are two numbers equally close to zero, the positive one should be returned. If the list is empty, return None. if not numbers: return None closest = numbers[0] for number in numbers: if abs(number) < abs(closest) or (abs(number) == abs(closest) and number > closest): closest = number return closest"},{"question":"def balanced_parentheses(s: str) -> bool: Determines if the input string containing '(', ')', '{', '}', '[' and ']' is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Args: s (str): The input string to be checked. Returns: bool: True if the string is valid, False otherwise. Example: >>> balanced_parentheses(\\"()[]{}\\") == True >>> balanced_parentheses(\\"([)]\\") == False >>> balanced_parentheses(\\"{[]}\\") == True from solution import balanced_parentheses def test_balanced_parentheses(): assert balanced_parentheses(\\"()[]{}\\") == True assert balanced_parentheses(\\"([)]\\") == False assert balanced_parentheses(\\"{[]}\\") == True assert balanced_parentheses(\\"\\") == True assert balanced_parentheses(\\"(\\") == False assert balanced_parentheses(\\"]\\") == False assert balanced_parentheses(\\"({[()]})\\") == True assert balanced_parentheses(\\"((((([])))))\\") == True assert balanced_parentheses(\\"{[}]\\") == False assert balanced_parentheses(\\"{[()]}{}[]\\") == True","solution":"def balanced_parentheses(s): Determines if the input string containing '(', ')', '{', '}', '[' and ']' is valid. Args: s (str): The input string to be checked. Returns: bool: True if the string is valid, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def flatten_list(nested_list) -> list: Flattens a nested list of integers into a single list of integers. Parameters: nested_list (list): A list that can contain integers or lists of integers, potentially nested at multiple levels. Returns: list: A flat list containing all the integers from the nested list. Examples: >>> flatten_list([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] >>> flatten_list([1, 'two', [3, [4, [5, 'six']]]]) == [1, 3, 4, 5] >>> flatten_list([[[[1, 2], 3], 4], 5]) == [1, 2, 3, 4, 5] >>> flatten_list(['a', [1, [2]], 'b', [[3, 'c']]]) == [1, 2, 3] pass","solution":"def flatten_list(nested_list): Flattens a nested list of integers into a single list of integers. Parameters: nested_list (list): A list that can contain integers or lists of integers, potentially nested at multiple levels. Returns: list: A flat list containing all the integers from the nested list. flattened = [] def flatten_helper(lst): for item in lst: if isinstance(item, list): flatten_helper(item) elif isinstance(item, int): flattened.append(item) flatten_helper(nested_list) return flattened"},{"question":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring of s consisting of distinct characters. Args: s (str): The input string containing only lowercase alphabetic characters. Returns: int: The length of the longest substring of s with all unique characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 from solution import length_of_longest_substring def test_example_1(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 def test_example_2(): assert length_of_longest_substring(\\"bbbbb\\") == 1 def test_example_3(): assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_example_4(): assert length_of_longest_substring(\\"\\") == 0 def test_single_char(): assert length_of_longest_substring(\\"a\\") == 1 def test_unique_chars(): assert length_of_longest_substring(\\"abcdef\\") == 6 def test_all_same_chars(): assert length_of_longest_substring(\\"aaaa\\") == 1 def test_regular_mixed_string(): assert length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Finds the length of the longest substring of s consisting of distinct characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def is_bonus_assignment_possible(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to assign bonuses such that no two employees receive the same bonus. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer (number of employees) and a list of integers (performance ratings of each employee). Returns: List[str]: A list of strings \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. Example: >>> is_bonus_assignment_possible(3, [(4, [1, 2, 3, 4]), (3, [10, 10, 10]), (2, [5, 1])]) ['POSSIBLE', 'IMPOSSIBLE', 'POSSIBLE']","solution":"def is_bonus_assignment_possible(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] performance_ratings = test_cases[i][1] # Check for unique performance ratings if len(set(performance_ratings)) == N: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results # Example usage # T = 3 # test_cases = [ # (4, [1, 2, 3, 4]), # (3, [10, 10, 10]), # (2, [5, 1]) # ] # print(is_bonus_assignment_possible(T, test_cases)) # Output: ['POSSIBLE', 'IMPOSSIBLE', 'POSSIBLE']"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Given a matrix of size m x n filled with non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. :param grid: List[List[int]] :return: int >>> min_path_sum([[1,3,1],[1,5,1],[4,2,1]]) 7 >>> min_path_sum([[1,2,3],[4,5,6]]) 12 pass from solution import min_path_sum def test_empty_grid(): assert min_path_sum([]) == 0 assert min_path_sum([[]]) == 0 def test_single_element(): assert min_path_sum([[5]]) == 5 def test_example_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(grid) == 7 def test_example_2(): grid = [ [1, 2, 3], [4, 5, 6] ] assert min_path_sum(grid) == 12 def test_large_numbers(): grid = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] assert min_path_sum(grid) == 210 def test_all_ones(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert min_path_sum(grid) == 5","solution":"def min_path_sum(grid): Given a matrix of size m x n filled with non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. :param grid: List[List[int]] :return: int if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def all_pairs_similar(n: int, serial_numbers: List[str]) -> str: Returns \\"YES\\" if every possible pair of parts has at least one common letter in their serial numbers, and \\"NO\\" otherwise. :param n: the number of parts picked for quality assurance :param serial_numbers: list of serial numbers :return: \\"YES\\" or \\"NO\\" >>> all_pairs_similar(3, [\\"AB\\", \\"BC\\", \\"CA\\"]) 'YES' >>> all_pairs_similar(2, [\\"AD\\", \\"BC\\"]) 'NO' from typing import List def test_all_pairs_similar_example1(): assert all_pairs_similar(3, [\\"AB\\", \\"BC\\", \\"CA\\"]) == \\"YES\\" def test_all_pairs_similar_example2(): assert all_pairs_similar(2, [\\"AD\\", \\"BC\\"]) == \\"NO\\" def test_all_pairs_similar_example3(): assert all_pairs_similar(4, [\\"AA\\", \\"AB\\", \\"AC\\", \\"AD\\"]) == \\"YES\\" def test_all_pairs_similar_no_common(): assert all_pairs_similar(2, [\\"XY\\", \\"ZW\\"]) == \\"NO\\" def test_all_pairs_similar_all_same_letter(): assert all_pairs_similar(4, [\\"AA\\", \\"AB\\", \\"AC\\", \\"AD\\"]) == \\"YES\\" def test_all_pairs_similar_partial_overlap(): assert all_pairs_similar(3, [\\"AX\\", \\"BY\\", \\"AZ\\"]) == \\"NO\\" def test_all_pairs_similar_minimum_case_yes(): assert all_pairs_similar(2, [\\"AX\\", \\"XA\\"]) == \\"YES\\" def test_all_pairs_similar_minimum_case_no(): assert all_pairs_similar(2, [\\"AX\\", \\"BY\\"]) == \\"NO\\"","solution":"def all_pairs_similar(n, serial_numbers): Returns \\"YES\\" if every possible pair of parts has at least one common letter in their serial numbers, and \\"NO\\" otherwise. :param n: the number of parts picked for quality assurance :param serial_numbers: list of serial numbers :return: \\"YES\\" or \\"NO\\" # Check all unique pairs of serial numbers for i in range(n): for j in range(i + 1, n): if set(serial_numbers[i]) & set(serial_numbers[j]): continue # There's a common letter else: return \\"NO\\" # No common letter return \\"YES\\""},{"question":"def find_subsets(nums: List[int], target: int) -> List[List[int]]: Find all unique subsets of a list that sum up to a given target value. >>> find_subsets([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> find_subsets([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] from solution import find_subsets def test_find_subsets_basic(): assert find_subsets([10, 1, 2, 7, 6, 1, 5], 8) == [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6], ] def test_find_subsets_with_duplicates(): assert find_subsets([2, 5, 2, 1, 2], 5) == [ [1, 2, 2], [5], ] def test_find_subsets_no_combination(): assert find_subsets([1, 2, 3], 10) == [] def test_find_subsets_single_element(): assert find_subsets([5], 5) == [[5]] def test_find_subsets_single_element_failure(): assert find_subsets([3], 5) == [] def test_find_subsets_all_elements_the_same(): assert find_subsets([2, 2, 2, 2], 4) == [[2, 2]]","solution":"def find_subsets(nums, target): def backtrack(start, path, total): if total == target: res.append(path[:]) return if total > target: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path, total + nums[i]) path.pop() nums.sort() res = [] backtrack(0, [], 0) return res"},{"question":"def compare_sales(team1_sales, team2_sales): Compares the total sales of two sales teams. Returns True if team 1 has higher sales, False if team 2 has higher sales, and 'Draw' if both teams have the same sales. >>> compare_sales([100, 200, 300], [100, 150, 200]) True >>> compare_sales([100, 200], [100, 300, 500]) False >>> compare_sales([100, 200, 300], [100, 200, 300]) 'Draw' >>> compare_sales([100, None, 200, 300], [100, 100, None, 200]) True >>> compare_sales([None, 200, None, 300], [100, 150, 200]) True >>> compare_sales([100, 100, None], [100, None, 300, 400]) False >>> compare_sales([None, 200, None], [None, 200, None]) 'Draw' >>> compare_sales([], []) 'Draw' >>> compare_sales([], [100, 200, 300]) False >>> compare_sales([100, 200, 300], []) True","solution":"def compare_sales(team1_sales, team2_sales): Compares the total sales of two sales teams. Returns True if team 1 has higher sales, False if team 2 has higher sales, and 'Draw' if both teams have the same sales. total_team1 = sum(sale for sale in team1_sales if sale is not None) total_team2 = sum(sale for sale in team2_sales if sale is not None) if total_team1 > total_team2: return True elif total_team2 > total_team1: return False else: return 'Draw'"},{"question":"def inspect_center(patients, max_per_unit): Simulates the operation of a Covid-19 inspection center. Parameters: patients (list): A list of tuples where each tuple contains the name of the patient (str) and the urgency of their case (int). max_per_unit (int): The maximum number of patients that can be processed within a unit of time. Returns: list: A list of lists. Each inner list represents the patients processed in a single unit of time. Example: >>> inspect_center([(\\"Alice\\", 5), (\\"Bob\\", 1), (\\"Charlie\\", 8), (\\"David\\", 2)], 2) [[\\"Charlie\\", \\"Alice\\"], [\\"David\\", \\"Bob\\"]] >>> inspect_center([(\\"Eve\\", 3), (\\"Frank\\", 6), (\\"Grace\\", 8), (\\"Heidi\\", 7), (\\"Ivan\\", 10)], 3) [[\\"Ivan\\", \\"Grace\\", \\"Heidi\\"], [\\"Frank\\", \\"Eve\\"]] >>> inspect_center([(\\"Jack\\", 2), (\\"Ken\\", 2), (\\"Liam\\", 4), (\\"Mia\\", 2), (\\"Nina\\", 5)], 2) [[\\"Nina\\", \\"Liam\\"], [\\"Jack\\", \\"Ken\\"], [\\"Mia\\"]]","solution":"def inspect_center(patients, max_per_unit): Simulates the operation of a Covid-19 inspection center. Parameters: patients (list): A list of tuples where each tuple contains the name of the patient (str) and the urgency of their case (int). max_per_unit (int): The maximum number of patients that can be processed within a unit of time. Returns: list: A list of lists. Each inner list represents the patients processed in a single unit of time. # Sort patients based on urgency and retain the original order for same urgency cases patients_sorted = sorted(patients, key=lambda patient: (-patient[1], patients.index(patient))) # Split patients into units based on max_per_unit result = [patients_sorted[i:i + max_per_unit] for i in range(0, len(patients_sorted), max_per_unit)] # Remove urgency from the result final_result = [[patient[0] for patient in unit] for unit in result] return final_result"},{"question":"def compress_array(arr): Compress the array by counting occurrences of each element and constructing a new list with elements followed by their counts in ascending order. Parameters: arr (list): List of positive integers. Returns: list: New list containing elements followed by their counts in ascending order. Examples: >>> compress_array([4, 3, 3, 2, 2, 2, 1]) [1, 1, 2, 3, 3, 2, 4, 1] >>> compress_array([5, 5, 5, 6, 6]) [5, 3, 6, 2] pass # Unit Tests def test_compress_array_single_element(): assert compress_array([1]) == [1, 1] def test_compress_array_multiple_distinct_elements(): assert compress_array([1, 2, 3, 4]) == [1, 1, 2, 1, 3, 1, 4, 1] def test_compress_array_with_duplicates(): assert compress_array([4, 3, 3, 2, 2, 2, 1]) == [1, 1, 2, 3, 3, 2, 4, 1] def test_compress_array_all_same_elements(): assert compress_array([5, 5, 5, 6, 6]) == [5, 3, 6, 2] def test_compress_array_unordered_input(): assert compress_array([3, 3, 1, 2, 4, 2, 2]) == [1, 1, 2, 3, 3, 2, 4, 1] def test_compress_array_large_elements(): assert compress_array([10, 20, 20, 30, 10, 10, 10]) == [10, 4, 20, 2, 30, 1] def test_compress_array_single_type_repeated(): assert compress_array([7, 7, 7, 7]) == [7, 4]","solution":"def compress_array(arr): Compress the array by counting occurrences of each element and constructing a new list with elements followed by their counts in ascending order. Parameters: arr (list): List of positive integers. Returns: list: New list containing elements followed by their counts. from collections import Counter # Count occurrences of each element counter = Counter(arr) # Prepare the result in ascending order of elements result = [] for element in sorted(counter.keys()): result.append(element) result.append(counter[element]) return result"},{"question":"from typing import List def generate_phone_numbers(number: int) -> List[str]: Generate all possible phone numbers using the digits from the given integer. Phone numbers consist of 7 digits in the format 'XXX-XXXX'. >>> generate_phone_numbers(1234567890) # ['123-4567', '123-4568', ... '890-1234'] >>> generate_phone_numbers(1234567) # ['123-4567'] >>> generate_phone_numbers(123456) # [] >>> generate_phone_numbers(1111111) # ['111-1111'] >>> generate_phone_numbers(7777777) # ['777-7777']","solution":"from itertools import permutations def generate_phone_numbers(number): Generate all possible phone numbers using the digits from the given integer. Phone numbers consist of 7 digits in the format 'XXX-XXXX'. digits = str(number) if len(digits) < 7: return [] result = set() for perm in permutations(digits, 7): phone_number = ''.join(perm[:3]) + '-' + ''.join(perm[3:]) result.add(phone_number) return sorted(list(result))"},{"question":"def min_coins(coins, amount): Returns the minimum number of coins needed to make the target amount. If it is not possible to make the target amount with the given denominations, returns -1. :param coins: List of integers representing coin denominations :param amount: Integer representing the target amount :return: Minimum number of coins needed to make the target amount or -1 if not possible >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1], 0) 0 >>> min_coins([1, 2, 5], 7) 2 >>> min_coins([1, 2, 5], 100) 20 >>> min_coins([], 11) -1 >>> min_coins([1, 2, 5], 0) 0 >>> min_coins([3], 9) 3 >>> min_coins([3], 10) -1 >>> min_coins([1, 3, 4], 6) 2","solution":"def min_coins(coins, amount): Returns the minimum number of coins needed to make the target amount. If it is not possible to make the target amount with the given denominations, returns -1. :param coins: List of integers representing coin denominations :param amount: Integer representing the target amount :return: Minimum number of coins needed to make the target amount or -1 if not possible # Initialize dp array to high values, with a size of amount+1 dp = [float('inf')] * (amount + 1) # Base case: 0 amount requires 0 coins dp[0] = 0 # Fill dp array with the minimum number of coins to make each amount for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, that means it's not possible to form that amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List def top_k_frequent(arr: List[int], k: int) -> List[int]: Given an array of integers \`arr\` and an integer \`k\`, return the k most frequent elements. The output must be sorted in frequency in descending order. If two or more elements have the same frequency, the order doesn't matter among them but should still be included. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1], 1) [1] from solution import top_k_frequent def test_top_k_frequent_basic(): assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2] def test_top_k_frequent_single_element(): assert top_k_frequent([1], 1) == [1] def test_top_k_frequent_all_same_frequency(): result = top_k_frequent([4, 4, 6, 6, 7, 7], 2) assert sorted(result) == [4, 6] or sorted(result) == [4, 7] or sorted(result) == [6, 7] def test_top_k_frequent_k_equals_number_of_unique_elements(): assert top_k_frequent([1, 1, 2, 2, 3, 3], 3) == [1, 2, 3] def test_top_k_frequent_mixed_frequencies(): assert top_k_frequent([1, 1, 2, 3, 3, 3, 4, 4], 2) == [3, 1]","solution":"from collections import Counter def top_k_frequent(arr, k): Returns the k most frequent elements in the array. count = Counter(arr) most_common_elements = count.most_common(k) # Extracting elements from the tuples returned by most_common return [element for element, _ in most_common_elements]"},{"question":"def warehouse_management(operations): Executes a series of warehouse operations and returns the results of quantity queries. Args: operations: List of strings, each element being either 'A id quantity', 'S id quantity' or 'Q id_start id_end'. Returns: List of integers representing the results of 'Q' queries. # Example usage: # operations = [ # \\"A 3 50\\", # \\"A 10 30\\", # \\"S 3 20\\", # \\"Q 1 10\\", # \\"A 5 10\\", # \\"Q 3 5\\" # ] # print(warehouse_management(operations)) # Output: [60, 40] # Add your own test cases to validate the implementation","solution":"def warehouse_management(operations): Executes a series of warehouse operations and returns the results of quantity queries. Args: operations: List of strings, each element being either 'A id quantity', 'S id quantity' or 'Q id_start id_end'. Returns: List of integers representing the results of 'Q' queries. quantities = {} results = [] for operation in operations: op = operation.split() if op[0] == 'A': item_id = int(op[1]) quantity = int(op[2]) if item_id in quantities: quantities[item_id] += quantity else: quantities[item_id] = quantity elif op[0] == 'S': item_id = int(op[1]) quantity = int(op[2]) if item_id in quantities: quantities[item_id] -= quantity elif op[0] == 'Q': id_start = int(op[1]) id_end = int(op[2]) total_quantity = 0 for item_id in quantities: if id_start <= item_id <= id_end: total_quantity += quantities[item_id] results.append(total_quantity) return results"},{"question":"from typing import List def get_pascals_triangle_row(N: int) -> List[int]: Generates the Nth row of Pascal's Triangle. Args: N (int): The row index to generate. Returns: list: The Nth row of Pascal's Triangle. >>> get_pascals_triangle_row(0) [1] >>> get_pascals_triangle_row(1) [1, 1] >>> get_pascals_triangle_row(2) [1, 2, 1] >>> get_pascals_triangle_row(3) [1, 3, 3, 1] >>> get_pascals_triangle_row(4) [1, 4, 6, 4, 1] pass def test_row_0(): assert get_pascals_triangle_row(0) == [1] def test_row_1(): assert get_pascals_triangle_row(1) == [1, 1] def test_row_2(): assert get_pascals_triangle_row(2) == [1, 2, 1] def test_row_3(): assert get_pascals_triangle_row(3) == [1, 3, 3, 1] def test_row_4(): assert get_pascals_triangle_row(4) == [1, 4, 6, 4, 1] def test_row_5(): assert get_pascals_triangle_row(5) == [1, 5, 10, 10, 5, 1] def test_large_row_10(): assert get_pascals_triangle_row(10) == [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1] def test_large_row_20(): expected_row_20 = [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1] assert get_pascals_triangle_row(20) == expected_row_20 def test_large_row_30(): expected_row_30 = [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1] assert get_pascals_triangle_row(30) == expected_row_30","solution":"def get_pascals_triangle_row(N: int) -> list: Generates the Nth row of Pascal's Triangle. Args: N (int): The row index to generate. Returns: list: The Nth row of Pascal's Triangle. if N == 0: return [1] row = [1] for i in range(1, N + 1): row.append(row[-1] * (N - i + 1) // i) return row"},{"question":"def find_missing_number(arr: List[int]) -> int: Finds the missing integer in an array containing n-1 distinct integers from 1 to n. :param arr: List[int] - an array of n-1 distinct integers ranging from 1 to n. :return: int - the missing integer >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([5, 3, 1, 2]) 4 >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([2, 3, 4, 5, 6, 7, 9, 10, 1, 8]) 11 >>> find_missing_number([2]) 1 >>> find_missing_number([1, 2, 3, 4, 5]) 6 >>> find_missing_number([]) 1","solution":"def find_missing_number(arr): Finds the missing integer in an array containing n-1 distinct integers from 1 to n. :param arr: List[int] - an array of n-1 distinct integers ranging from 1 to n. :return: int - the missing integer n = len(arr) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"def max_non_overlapping_projects(N: int, projects: List[List[int]]) -> int: Determines the maximum number of non-overlapping projects the company can undertake. Args: N (int): The number of projects. projects (list of lists): A list of lists where each list contains two integers [start_time, end_time]. Returns: int: The maximum number of non-overlapping projects. Example: >>> max_non_overlapping_projects(3, [[1, 3], [2, 4], [3, 5]]) 2 >>> max_non_overlapping_projects(4, [[1, 2], [2, 3], [3, 4], [1, 3]]) 3","solution":"def max_non_overlapping_projects(N, projects): Determines the maximum number of non-overlapping projects the company can undertake. Args: N (int): The number of projects. projects (list of list): A list of lists where each list contains two integers [start_time, end_time]. Returns: int: The maximum number of non-overlapping projects. # Sort projects based on their end time projects.sort(key=lambda x: x[1]) # Keep track of the end time of the last added project end_time = 0 count = 0 for project in projects: # If the start time of the current project is greater than # the end time of the last added project, it can be added if project[0] >= end_time: count += 1 end_time = project[1] return count"},{"question":"def find_minimum_travel_cost(N, M, S, D, roads): Computes the minimum travel cost from the starting city S to the destination city D. >>> find_minimum_travel_cost(6, 7, 1, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 6, 1), (5, 6, 2)]) 8 >>> find_minimum_travel_cost(3, 2, 1, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 1)]) 3 >>> find_minimum_travel_cost(3, 2, 1, 3, [(1, 2, 1), (3, 2, 2)]) -1 >> find_minimum_travel_cost(4, 4, 1, 4, [(1, 2, 3), (2, 3, 2), (3, 4, 1), (1, 4, 5)]) 5 >>> find_minimum_travel_cost(4, 4, 1, 4, [(1, 2, 3), (2, 3, 2), (3, 4, 999999), (1, 4, 1000000)]) 1000000 # Create adjacency list for the graph graph = [[] for _ in range(N+1)] for u, v, w in roads: graph[u].append((v, w)) # Use Dijkstra's algorithm to find the shortest path heap = [(0, S)] # (cost, city) distances = {i: float('inf') for i in range(1, N+1)} distances[S] = 0 while heap: current_cost, current_city = heapq.heappop(heap) if current_city == D: return current_cost for neighbor, travel_cost in graph[current_city]: new_cost = current_cost + travel_cost if new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return -1 if distances[D] == float('inf') else distances[D]","solution":"import heapq def find_minimum_travel_cost(N, M, S, D, roads): Computes the minimum travel cost from the starting city S to the destination city D. Parameters: N : int : number of cities M : int : number of roads S : int : starting city D : int : destination city roads : list of tuples : each tuple contains three integers representing road information (u, v, w) Returns: int : minimum travel cost from the starting city to the destination city, or -1 if no path exists # Create adjacency list for the graph graph = [[] for _ in range(N+1)] for u, v, w in roads: graph[u].append((v, w)) # Use Dijkstra's algorithm to find the shortest path heap = [(0, S)] # (cost, city) distances = {i: float('inf') for i in range(1, N+1)} distances[S] = 0 while heap: current_cost, current_city = heapq.heappop(heap) if current_city == D: return current_cost for neighbor, travel_cost in graph[current_city]: new_cost = current_cost + travel_cost if new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return -1 if distances[D] == float('inf') else distances[D]"},{"question":"from typing import List def lengthOfLongestSubstring(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s (str): A string s, consisting of English letters, digits, symbols, and spaces. Returns: int: Length of the longest substring with all unique characters. Examples: >>> lengthOfLongestSubstring(\\"abcabcbb\\") 3 >>> lengthOfLongestSubstring(\\"bbbbb\\") 1 >>> lengthOfLongestSubstring(\\"pwwkew\\") 3 >>> lengthOfLongestSubstring(\\"\\") 0 def test_empty_string(): assert lengthOfLongestSubstring(\\"\\") == 0 def test_single_character(): assert lengthOfLongestSubstring(\\"a\\") == 1 def test_all_unique_characters(): assert lengthOfLongestSubstring(\\"abcdef\\") == 6 def test_repeating_characters(): assert lengthOfLongestSubstring(\\"abcabcbb\\") == 3 # \\"abc\\" assert lengthOfLongestSubstring(\\"bbbbb\\") == 1 # \\"b\\" def test_mixed_characters(): assert lengthOfLongestSubstring(\\"pwwkew\\") == 3 # \\"wke\\" assert lengthOfLongestSubstring(\\"dvdf\\") == 3 # \\"vdf\\" def test_long_string(): long_string = \\"a\\" * (5 * 10**4) assert lengthOfLongestSubstring(long_string) == 1 def test_string_with_spaces(): assert lengthOfLongestSubstring(\\"a b c a b c bb\\") == 3 # \\"a b\\" or \\"b c\\" (with spaces included as unique characters) def test_string_with_symbols(): assert lengthOfLongestSubstring(\\"!@#%^&*()\\") == 10","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n <= 1: return n char_set = set() left = 0 max_len = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"from collections import Counter def most_frequent_chars(s: str, k: int) -> str: Returns the first k most frequent characters in the string in descending order of their frequency. If two characters have the same frequency, returns them in the order they appear in the string. Args: s (str): Input string to analyze. k (int): Number of most frequent characters to return. Returns: str: A string of the first k most frequent characters. >>> most_frequent_chars(\\"programming\\", 3) 'rgm' >>> most_frequent_chars(\\"example\\", 2) 'ex' >>> most_frequent_chars(\\"aabbbcc\\", 2) 'ba'","solution":"from collections import Counter def most_frequent_chars(s, k): Returns the first k most frequent characters in the string in descending order of their frequency. If two characters have the same frequency, returns them in the order they appear in the string. Args: s (str): Input string to analyze. k (int): Number of most frequent characters to return. Returns: str: A string of the first k most frequent characters. frequency = Counter(s) # Sorting first by frequency (in descending order), then by the order they appear in the string sorted_chars = sorted(frequency.items(), key=lambda x: (-x[1], s.index(x[0]))) # Extracting the first k characters based on the sorted order result = ''.join([char for char, count in sorted_chars[:k]]) return result"},{"question":"def count_peaks(altitudes: List[int]) -> int: Function to count the number of peak points in an array of altitudes. >>> count_peaks([1, 2, 3, 2, 1]) == 1 >>> count_peaks([1, 3, 2, 4, 1, 2, 5]) == 3 >>> count_peaks([1, 2, 3, 4, 5]) == 0 >>> count_peaks([5, 4, 3, 2, 1]) == 0 >>> count_peaks([5, 5, 5, 5, 5]) == 0 >>> count_peaks([1, 2, 3, 4, 1, 2, 3, 4, 1]) == 2 >>> count_peaks([7, 7, 7, 7]) == 0 from typing import List","solution":"def count_peaks(altitudes): Function to count the number of peak points in an array of altitudes. Parameters: altitudes (list): List of integers representing the altitudes. Returns: int: Number of peak points. peak_count = 0 n = len(altitudes) for i in range(1, n-1): if altitudes[i] > altitudes[i-1] and altitudes[i] > altitudes[i+1]: peak_count += 1 return peak_count"},{"question":"def analyze_sales(data: List[List[int]]) -> Tuple[int, int]: Analyzes sales data to determine the highest and lowest total sales figures for any salesperson within the time range. :param data: List of lists containing sales figures for multiple salespersons over multiple months :return: Tuple containing the highest and lowest total sales figures >>> analyze_sales([[200, 300, 250], [180, 350, 400], [300, 200, 100], [100, 150, 200]]) (930, 450) >>> analyze_sales([[100, 100, 100], [100, 100, 100], [100, 100, 100]]) (300, 300) >>> analyze_sales([[0, 0, 0], [100000, 100000, 100000]]) (300000, 0) >>> analyze_sales([[100, 200, 300]]) (600, 600) >>> analyze_sales([[50, 60, 70], [10, 20, 30], [5, 5, 5], [100, 200, 300]]) (600, 15)","solution":"def analyze_sales(data): Analyzes sales data to determine the highest and lowest total sales figures for any salesperson within the time range. :param data: List of lists containing sales figures for multiple salespersons over multiple months :return: Tuple containing the highest and lowest total sales figures total_sales = [sum(salesperson) for salesperson in data] highest_sales = max(total_sales) lowest_sales = min(total_sales) return highest_sales, lowest_sales"},{"question":"def rearrange_and_sum_digits(n: int) -> int: This function takes an integer n, rearranges its digits in ascending order, and returns the sum of its digits repeatedly until the result has only one digit. >>> rearrange_and_sum_digits(5839) 7 >>> rearrange_and_sum_digits(-14532) 6 >>> rearrange_and_sum_digits(302) 5 from solution import rearrange_and_sum_digits def test_rearrange_and_sum_digits_positive(): assert rearrange_and_sum_digits(5839) == 7 def test_rearrange_and_sum_digits_negative(): assert rearrange_and_sum_digits(-14532) == 6 def test_rearrange_and_sum_digits_with_zero(): assert rearrange_and_sum_digits(302) == 5 def test_rearrange_and_sum_digits_large_number(): assert rearrange_and_sum_digits(987654321) == 9 # 1+2+3+4+5+6+7+8+9=45 -> 4+5=9 def test_rearrange_and_sum_digits_single_digit(): assert rearrange_and_sum_digits(7) == 7 def test_rearrange_and_sum_digits_all_zero(): assert rearrange_and_sum_digits(0) == 0","solution":"def rearrange_and_sum_digits(n): This function takes an integer n, rearranges its digits in ascending order, and returns the sum of its digits repeatedly until the result has only one digit. n = abs(n) # Work with the absolute value of n digits = sorted(str(n)) # Convert number to string and sort digits sum_digits = sum(int(d) for d in digits) # Calculate sum of sorted digits # Reduce sum_digits to a single digit while sum_digits > 9: sum_digits = sum(int(d) for d in str(sum_digits)) return sum_digits"},{"question":"def minimum_spanning_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the weight of the minimum spanning tree (MST) for the given graph. Args: t: Number of test cases. test_cases: List of test cases, each containing: - An integer n: Number of nodes. - An integer m: Number of edges. - A list of tuples, each containing three integers u, v, w representing an edge between nodes u and v with weight w. Returns: A list of integers, each representing the weight of the MST for each test case, or -1 if no MST exists. >>> minimum_spanning_tree(2, [(4, 5, [(1, 2, 3), (1, 3, 1), (2, 3, 3), (3, 4, 6), (2, 4, 2)]), (3, 3, [(1, 2, 4), (2, 3, 7), (1, 3, 1)])]) [8, 5] >>> minimum_spanning_tree(1, [(4, 2, [(1, 2, 1), (3, 4, 2)])]) [-1] >>> minimum_spanning_tree(1, [(1, 0, [])]) [0] >>> minimum_spanning_tree(1, [(4, 0, [])]) [-1] >>> minimum_spanning_tree(1, [(4, 6, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1)])]) [3]","solution":"import heapq def find_parent(parent, i): if parent[i] == i: return i else: return find_parent(parent, parent[i]) def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(nodes, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(nodes): parent.append(node) rank.append(0) result = [] i = 0 e = 0 while e < nodes - 1: if i >= len(edges): return -1 (u, v, w) = edges[i] i += 1 x = find_parent(parent, u - 1) y = find_parent(parent, v - 1) if x != y: e += 1 result.append(w) union(parent, rank, x, y) return sum(result) def minimum_spanning_tree(t, test_cases): output = [] for n, m, edges in test_cases: if m == 0: output.append(-1 if n > 1 else 0) else: total_weight = kruskal_mst(n, edges) output.append(total_weight) return output"},{"question":"def decode_string(s: str) -> str: Decodes the given encoded string according to the encoding rule k[encoded_string]. Args: s (str): The encoded string containing digits, square brackets [], and lowercase English letters. Returns: str: The decoded string. pass # Unit Tests def test_decode_string_simple_repetition(): assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" def test_decode_string_nested_repetition(): assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_decode_string_multiple_repetitions(): assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" def test_decode_string_single_character(): assert decode_string(\\"3[z]\\") == \\"zzz\\" def test_decode_string_empty_repetition(): assert decode_string(\\"10[]\\") == \\"\\" def test_decode_string_no_brackets(): assert decode_string(\\"abc\\") == \\"abc\\" def test_decode_string_mixed_inner_and_outer_strings(): assert decode_string(\\"2[a2[b]c]\\") == \\"abbcabbc\\"","solution":"def decode_string(s: str) -> str: Decodes the given encoded string according to the encoding rule k[encoded_string]. Args: s (str): The encoded string containing digits, square brackets [], and lowercase English letters. Returns: str: The decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_str, current_num)) current_str = \\"\\" current_num = 0 elif char == ']': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"def highest_altitude(changes): Determine the highest altitude reached given a list of altitude changes. Args: changes (list of int): List of altitude changes. Returns: int: The highest altitude reached. if __name__ == \\"__main__\\": # Example test cases print(highest_altitude([-5, 1, 5, 0, -7])) # Output should be 1 print(highest_altitude([1, 2, 3, 4])) # Output should be 10 print(highest_altitude([-2, -1, -3, -4])) # Output should be 0 print(highest_altitude([0, 0, 0, 0])) # Output should be 0 print(highest_altitude([-1, -2, -3, 6, -3])) # Output should be 0 print(highest_altitude([3, 2, 1, -5, 2])) # Output should be 6 print(highest_altitude([])) # Output should be 0","solution":"def highest_altitude(changes): Determine the highest altitude reached given a list of altitude changes. Args: changes (list of int): List of altitude changes. Returns: int: The highest altitude reached. altitude = 0 highest = 0 for change in changes: altitude += change if altitude > highest: highest = altitude return highest"},{"question":"def find_missing(nums: List[int]) -> int: Finds the smallest positive integer missing from an unsorted array of integers. >>> find_missing([3, 4, -1, 1]) 2 >>> find_missing([1, 2, 0]) 3 >>> find_missing([-3, -2, -1]) 1 >>> find_missing([]) 1 >>> find_missing([1, 2, 3, 4, 5]) 6 >>> find_missing([1, 2, 2, 3, 3, 4, 4]) 5 >>> find_missing([100, 101, 102]) 1 >>> find_missing([0, 1, 1000]) 2 >>> find_missing([1]) 2 >>> find_missing([2]) 1 >>> find_missing([0, -1, 2, 3]) 1 >>> find_missing([-1, -3, 6, 8, 100]) 1","solution":"def find_missing(nums): Finds the smallest positive integer missing from an unsorted array of integers. nums = [num for num in nums if num > 0] nums_set = set(nums) smallest_positive = 1 while smallest_positive in nums_set: smallest_positive += 1 return smallest_positive"},{"question":"def calculate_rankings(n: int, m: int, scores: List[List[int]]) -> List[int]: Calculates and returns the rankings of participants based on their scores. Parameters: n (int): Number of participants. m (int): Number of problems. scores (list of list of int): Scores of each participant per problem. Returns: list of int: List of participant indices in the order of their final ranking. >>> calculate_rankings(3, 3, [[10, 20, 30], [30, 20, 10], [20, 30, 10]]) == [2, 3, 1] >>> calculate_rankings(2, 2, [[10, 20], [20, 10]]) == [2, 1] >>> calculate_rankings(1, 4, [[10, 20, 30, 40]]) == [1] >>> calculate_rankings(4, 3, [[30, 10, 20], [30, 10, 20], [20, 10, 30], [30, 20, 10]]) == [4, 1, 2, 3] >>> calculate_rankings(3, 2, [[10, 10], [10, 10], [10, 10]]) == [1, 2, 3]","solution":"def calculate_rankings(n, m, scores): Calculates and returns the rankings of participants based on their scores. Parameters: n (int): Number of participants. m (int): Number of problems. scores (list of list of int): Scores of each participant per problem. Returns: list of int: List of participant indices in the order of their final ranking. participants = [] for i in range(n): participants.append((i + 1, scores[i], sum(scores[i]))) # Sort primarily by total score (descending) and in case of tie, by earlier/higher scores participants.sort(key=lambda x: (x[2], x[1]), reverse=True) # Extract and return the ordered participant numbers return [p[0] for p in participants] # Example usage if __name__ == \\"__main__\\": n, m = 3, 3 scores = [ [10, 20, 30], [30, 20, 10], [20, 30, 10] ] print(calculate_rankings(n, m, scores))"},{"question":"def combination_sum(nums, target): Find all unique combinations in nums where the sum is equal to target. Each number in nums may only be used once in the combination. The solution set must not contain duplicate combinations. Args: nums (List[int]): list of non-negative integers target (int): target sum Returns: List[List[int]]: list of unique combinations Example: >>> combination_sum([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] pass def test_combination_sum_example1(): nums = [10, 1, 2, 7, 6, 1, 5] target = 8 result = combination_sum(nums, target) expected = [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6] ] assert sorted(result) == sorted(expected) def test_combination_sum_example2(): nums = [2, 5, 2, 1, 2] target = 5 result = combination_sum(nums, target) expected = [ [1, 2, 2], [5] ] assert sorted(result) == sorted(expected) def test_combination_sum_empty(): nums = [] target = 3 result = combination_sum(nums, target) expected = [] assert result == expected def test_combination_sum_no_valid_combination(): nums = [1, 2, 3] target = 7 result = combination_sum(nums, target) expected = [] assert result == expected def test_combination_sum_single_element(): nums = [5] target = 5 result = combination_sum(nums, target) expected = [[5]] assert result == expected def test_combination_sum_repeats(): nums = [2, 2, 2] target = 4 result = combination_sum(nums, target) expected = [[2, 2]] assert result == expected","solution":"def combination_sum(nums, target): def backtrack(start, end, path, target): if target == 0: res.append(path) return if target < 0: return for i in range(start, end): if i > start and nums[i] == nums[i-1]: continue backtrack(i + 1, end, path + [nums[i]], target - nums[i]) nums.sort() res = [] backtrack(0, len(nums), [], target) return res"},{"question":"from typing import List def filter_primes(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list containing all the integers from the original list that are prime numbers. A prime number is a number that is greater than 1 and is only divisible by 1 and itself. For example, the first few prime numbers are 2, 3, 5, 7, 11, and so on. Examples: >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) [11, 13, 17, 19] Unit Test: from solution import filter_primes def test_filter_primes_mixed_numbers(): assert filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] def test_filter_primes_prime_numbers(): assert filter_primes([11, 13, 17, 19]) == [11, 13, 17, 19] def test_filter_primes_no_primes(): assert filter_primes([4, 6, 8, 9, 10]) == [] def test_filter_primes_with_negative_numbers(): assert filter_primes([-1, -2, -3, 2, 3, 5]) == [2, 3, 5] def test_filter_primes_empty_list(): assert filter_primes([]) == []","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def filter_primes(lst): Returns a list of prime numbers from the given list. return [num for num in lst if is_prime(num)]"},{"question":"from collections import Counter from typing import List def longest_good_subsequence(s: str) -> int: Finds the length of the longest good subsequence in the given string \`s\`. A good subsequence is a subsequence of \`s\` in which each letter appears the same number of times. Args: s (str): A string consisting of lowercase English letters. Returns: int: The length of the longest good subsequence. Examples: >>> longest_good_subsequence(\\"abbccc\\") 3 >>> longest_good_subsequence(\\"aaa\\") 1 >>> longest_good_subsequence(\\"abcabcabc\\") 3 >>> longest_good_subsequence(\\"a\\") 1 >>> longest_good_subsequence(\\"ab\\") 2 pass def test_longest_good_subsequence(): assert longest_good_subsequence(\\"abbccc\\") == 3 assert longest_good_subsequence(\\"aaa\\") == 1 assert longest_good_subsequence(\\"abcabcabc\\") == 3 assert longest_good_subsequence(\\"a\\") == 1 assert longest_good_subsequence(\\"ab\\") == 2 assert longest_good_subsequence(\\"aabbcc\\") == 3 assert longest_good_subsequence(\\"aabbccddeeffgghh\\") == 8 assert longest_good_subsequence(\\"\\") == 0 assert longest_good_subsequence(\\"zzzzzzz\\") == 1 assert longest_good_subsequence(\\"abcde\\") == 5 test_longest_good_subsequence()","solution":"from collections import Counter def longest_good_subsequence(s): Finds the length of the longest good subsequence in the given string \`s\`. if not s: return 0 # Count the frequency of each character in the string freq = Counter(s) # The length of the longest good subsequence is equal to the number # of distinct characters in the string, since each distinct character # can appear exactly once in such a subsequence. return len(freq)"},{"question":"def round_half_hour(n): Rounds a number to the nearest half hour increment. return round(n * 2) / 2 def task_durations(historical_data: dict, new_tasks: list) -> list: Returns the duration for each task based on historical data. If the task exists in historical data, return the average of the past durations rounded to the nearest half-hour. For new tasks, return 1.0 as the default duration. historical_data: dict - Dictionary where keys are task names and values are lists of past recorded durations in hours. new_tasks: list - List of new tasks to process. Returns a list of task durations in hours. Example: >>> historical_data = {\\"design\\": [2, 2.5, 3], \\"coding\\": [4.5, 4, 5]} >>> new_tasks = [\\"design\\", \\"coding\\", \\"meeting\\"] >>> task_durations(historical_data, new_tasks) [2.5, 4.5, 1.0] result = [] for task in new_tasks: if task in historical_data: avg_duration = sum(historical_data[task]) / len(historical_data[task]) rounded_duration = round_half_hour(avg_duration) result.append(rounded_duration) else: result.append(1.0) return result","solution":"def round_half_hour(n): Rounds a number to the nearest half hour increment. return round(n * 2) / 2 def task_durations(historical_data, new_tasks): Returns the duration for each task based on historical data. If the task exists in historical data, return the average of the past durations rounded to the nearest half-hour. For new tasks, return 1.0 as the default duration. result = [] for task in new_tasks: if task in historical_data: avg_duration = sum(historical_data[task]) / len(historical_data[task]) rounded_duration = round_half_hour(avg_duration) result.append(rounded_duration) else: result.append(1.0) return result"},{"question":"def can_make_elements_equal(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine whether it is possible to make all elements of the array equal using the minimum number of operations by choosing any one element of the array and adding or subtracting a fixed integer K to/from that element. Args: T: An integer denoting the number of test cases. test_cases: A list of tuples where each tuple consists of a tuple (N, K) and a list of integers. Return: A list of strings, \\"Yes\\" or \\"No\\", for each test case based on the possibility of making all array elements equal. Example: >>> T = 3 >>> test_cases = [((4, 2), [2, 4, 6, 8]), ((3, 3), [1, 6, 9]), ((5, 2), [10, 14, 18, 22, 26])] >>> can_make_elements_equal(T, test_cases) ['Yes', 'No', 'Yes'] from solution import can_make_elements_equal def test_case_1(): T = 3 test_cases = [ ((4, 2), [2, 4, 6, 8]), ((3, 3), [1, 6, 9]), ((5, 2), [10, 14, 18, 22, 26]) ] expected = [\\"Yes\\", \\"No\\", \\"Yes\\"] assert can_make_elements_equal(T, test_cases) == expected def test_remainders_unified(): T = 2 test_cases = [ ((3, 4), [1, 5, 9]), ((3, 2), [2, 4, 6]) ] expected = [\\"Yes\\", \\"Yes\\"] assert can_make_elements_equal(T, test_cases) == expected def test_mixed_remainders(): T = 2 test_cases = [ ((4, 5), [3, 8, 14, 22]), ((4, 7), [2, 10, 3, 5]) ] expected = [\\"No\\", \\"No\\"] assert can_make_elements_equal(T, test_cases) == expected def test_large_values(): T = 1 test_cases = [ ((3, 1000000000), [1000000000, 2000000000, 3000000000]) ] expected = [\\"Yes\\"] assert can_make_elements_equal(T, test_cases) == expected def test_single_element(): T = 1 test_cases = [ ((1, 3), [5]) ] expected = [\\"Yes\\"] assert can_make_elements_equal(T, test_cases) == expected","solution":"def can_make_elements_equal(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] array = test_cases[i][1] remainders = set() for num in array: remainders.add(num % K) if len(remainders) == 1: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: Given a grid where some cells are walkable (0) and others are obstacles (1), determine the shortest path from the top-left corner to the bottom-right corner. Return the minimum number of steps required, or -1 if it is not possible. >>> shortest_path([ ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 1, 0], ... [0, 0, 0, 0] ... ]) 6 >>> shortest_path([ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ]) 4 >>> shortest_path([ ... [0, 1], ... [1, 0] ... ]) -1","solution":"from collections import deque def shortest_path(grid): if not grid or grid[0][0] == 1: return -1 rows, cols = len(grid), len(grid[0]) queue = deque([(0, 0, 0)]) # row, column, steps visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == rows - 1 and c == cols - 1: return steps for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): # right, down, left, up nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Given a list of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed using contiguous bars. >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([100000]) 100000","solution":"def largest_rectangle_area(heights): Given a list of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed using contiguous bars. stack = [] max_area = 0 heights.append(0) # Append a zero-height bar to flush out remaining bars in the stack for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) # Pop the zero-height bar we added at the end heights.pop() return max_area"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Removes duplicates from a sorted linked list such that each element appears only once. :param head: The head of the sorted linked list. :return: The head of the linked list after removing duplicates. def linked_list_to_list(head): Converts a linked list to a Python list. :param head: The head of the linked list. :return: A list with the elements of the linked list. def list_to_linked_list(elements): Converts a Python list to a linked list. :param elements: A list with elements. :return: The head of the linked list. # Test cases def test_delete_duplicates_no_duplicates(): list_input = [1, 2, 3] head = list_to_linked_list(list_input) new_head = delete_duplicates(head) assert linked_list_to_list(new_head) == [1, 2, 3] def test_delete_duplicates_with_duplicates(): list_input = [1, 1, 2, 3, 3] head = list_to_linked_list(list_input) new_head = delete_duplicates(head) assert linked_list_to_list(new_head) == [1, 2, 3] def test_delete_duplicates_all_duplicates(): list_input = [1, 1, 1, 1, 1] head = list_to_linked_list(list_input) new_head = delete_duplicates(head) assert linked_list_to_list(new_head) == [1] def test_delete_duplicates_empty_list(): list_input = [] head = list_to_linked_list(list_input) new_head = delete_duplicates(head) assert linked_list_to_list(new_head) == [] def test_delete_duplicates_single_element(): list_input = [5] head = list_to_linked_list(list_input) new_head = delete_duplicates(head) assert linked_list_to_list(new_head) == [5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Removes duplicates from a sorted linked list such that each element appears only once. :param head: The head of the sorted linked list. :return: The head of the linked list after removing duplicates. current_node = head while current_node and current_node.next: if current_node.val == current_node.next.val: # Skip the duplicate node current_node.next = current_node.next.next else: # Move to the next distinct element current_node = current_node.next return head def linked_list_to_list(head): Converts a linked list to a Python list. :param head: The head of the linked list. :return: A list with the elements of the linked list. result = [] current = head while current: result.append(current.val) current = current.next return result def list_to_linked_list(elements): Converts a Python list to a linked list. :param elements: A list with elements. :return: The head of the linked list. if not elements: return None head = ListNode(elements[0]) current = head for elem in elements[1:]: current.next = ListNode(elem) current = current.next return head"},{"question":"def find_odd_occurrence(arr): Find the element in the array that appears an odd number of times. >>> find_odd_occurrence([1, 2, 3, 2, 3]) 1 >>> find_odd_occurrence([4, 4, 4, 4, 5, 5, 6]) 6 def process_test_cases(test_cases): Process multiple test cases to find the elements that appear an odd number of times. >>> process_test_cases([(5, [1, 2, 3, 2, 3]), (7, [4, 4, 4, 4, 5, 5, 6])]) [1, 6] >>> process_test_cases([(9, [10, 10, 20, 20, 30, 30, 40, 40, 50]), (5, [7, 7, 8, 8, 7])]) [50, 7]","solution":"def find_odd_occurrence(arr): Find the element in the array that appears an odd number of times. result = 0 for num in arr: result ^= num return result def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(find_odd_occurrence(arr)) return results"},{"question":"def is_valid_ISBN10(isbn: str) -> bool: Validates if the given ISBN-10 number is valid. An ISBN-10 is valid if: - It contains exactly 10 characters. - The first 9 characters are digits (0-9). - The last character is a digit (0-9) or 'X' (representing 10). - The sum of each digit multiplied by its position (1-10) is divisible by 11. >>> is_valid_ISBN10('0471958697') == True >>> is_valid_ISBN10('123456789X') == True >>> is_valid_ISBN10('0306406152') == True >>> is_valid_ISBN10('048665088X') == True >>> is_valid_ISBN10('1234567890') == False >>> is_valid_ISBN10('0471958698') == False >>> is_valid_ISBN10('030640615X') == False >>> is_valid_ISBN10('0486650880') == False >>> is_valid_ISBN10('123456789') == False >>> is_valid_ISBN10('12345678901') == False >>> is_valid_ISBN10('') == False >>> is_valid_ISBN10('12345678A9') == False >>> is_valid_ISBN10('ABCDEFGHIJ') == False >>> is_valid_ISBN10('123456789*') == False >>> is_valid_ISBN10('12345!789X') == False","solution":"def is_valid_ISBN10(isbn): Validates if the given ISBN-10 number is valid. An ISBN-10 is valid if: - It contains exactly 10 characters. - The first 9 characters are digits (0-9). - The last character is a digit (0-9) or 'X' (representing 10). - The sum of each digit multiplied by its position (1-10) is divisible by 11. if len(isbn) != 10: return False total = 0 for i in range(9): if not isbn[i].isdigit(): return False total += int(isbn[i]) * (i + 1) last_char = isbn[9] if last_char == 'X': total += 10 * 10 elif last_char.isdigit(): total += int(last_char) * 10 else: return False return total % 11 == 0"},{"question":"from typing import List, Dict, Union def filter_numbers(numbers: List[int], rule: Dict[str, Union[str, int]]) -> List[int]: Filter a list of numbers based on the provided rule. >>> filter_numbers([1, 2, 3, 4, 5], {\\"operation\\": \\"greater_than\\", \\"value\\": 3}) [4, 5] >>> filter_numbers([10, 15, 3, 7, 8], {\\"operation\\": \\"less_than\\", \\"value\\": 10}) [3, 7, 8] >>> filter_numbers([7, 7, 7, 5, 5], {\\"operation\\": \\"equals\\", \\"value\\": 7}) [7, 7, 7]","solution":"from typing import List, Dict, Union def filter_numbers(numbers: List[int], rule: Dict[str, Union[str, int]]) -> List[int]: operation = rule.get(\\"operation\\") value = rule.get(\\"value\\") if operation == \\"greater_than\\": return [num for num in numbers if num > value] elif operation == \\"less_than\\": return [num for num in numbers if num < value] elif operation == \\"equals\\": return [num for num in numbers if num == value] else: raise ValueError(\\"Unsupported operation.\\")"},{"question":"import re def validate_ip(address: str) -> str: Validates an IP address and determines its type (IPv4 or IPv6). Returns False if invalid. >>> validate_ip(\\"192.168.1.1\\") == \\"IPv4\\" True >>> validate_ip(\\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\") == \\"IPv6\\" True >>> validate_ip(\\"255.255.255.255\\") == \\"IPv4\\" True >>> validate_ip(\\"1200::AB00:1234::2552:7777:1313\\") == False True >>> validate_ip(\\"256.256.256.256\\") == False True >>> validate_ip(\\"1:2:3:4:5:6:7:8\\") == \\"IPv6\\" True >>> validate_ip(\\"01.01.01.01\\") == False True >>> validate_ip(\\"2001:db8:85a3::8a2e:370:7334\\") == \\"IPv6\\" True >>> validate_ip(\\"::1\\") == \\"IPv6\\" True","solution":"import re def validate_ip(address): Validates an IP address and determines its type (IPv4 or IPv6). Returns False if invalid. # Regular expression for matching valid IPv4 address ipv4_pattern = re.compile(r'^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]).){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])') # Regular expression for matching valid IPv6 address ipv6_pattern = re.compile(r'^(([0-9a-fA-F]{1,4}):){7}([0-9a-fA-F]{1,4})|^(([0-9a-fA-F]{1,4}):){1,7}:|^(([0-9a-fA-F]{1,4}):){1,6}:([0-9a-fA-F]{1,4})|^(([0-9a-fA-F]{1,4}):){1,5}(:([0-9a-fA-F]{1,4})){1,2}|^(([0-9a-fA-F]{1,4}):){1,4}(:([0-9a-fA-F]{1,4})){1,3}|^(([0-9a-fA-F]{1,4}):){1,3}(:([0-9a-fA-F]{1,4})){1,4}|^(([0-9a-fA-F]{1,4}):){1,2}(:([0-9a-fA-F]{1,4})){1,5}|^([0-9a-fA-F]{1,4}):((:[0-9a-fA-F]{1,4}){1,6})|^:((:[0-9a-fA-F]{1,4}){1,7}|:)') if ipv4_pattern.match(address): return \\"IPv4\\" elif ipv6_pattern.match(address): return \\"IPv6\\" else: return False"}]`),C={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},z={class:"card-container"},E={key:0,class:"empty-state"},I=["disabled"],D={key:0},P={key:1};function j(n,e,u,m,i,a){const f=p("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",z,[(s(!0),r(y,null,v(a.displayedPoems,(o,h)=>(s(),w(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",E,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",P,"Loading...")):(s(),r("span",D,"See more"))],8,I)):l("",!0)])}const M=_(C,[["render",j],["__scopeId","data-v-3449bf63"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/64.md","filePath":"grok/64.md"}'),B={name:"grok/64.md"},W=Object.assign(B,{setup(n){return(e,u)=>(s(),r("div",null,[x(M)]))}});export{Y as __pageData,W as default};
