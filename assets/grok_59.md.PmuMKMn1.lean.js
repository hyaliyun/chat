import{_ as c,o as s,c as r,a as t,m as _,t as d,C as p,M as g,U as b,f as u,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,l,m,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(l.poem.solution),1)])])])}const N=c(q,[["render",A],["__scopeId","data-v-1fe7160c"]]),C=JSON.parse(`[{"question":"def is_mountain_sequence(sequence): Determines if the given sequence is a mountain sequence. A sequence is considered as a mountain sequence if it strictly increases and then strictly decreases. >>> is_mountain_sequence([1, 2, 3, 4, 3, 2]) == True >>> is_mountain_sequence([1, 2, 2, 1]) == False >>> is_mountain_sequence([3, 5, 2, 1, 4]) == False >>> is_mountain_sequence([1, 3, 2]) == True >>> is_mountain_sequence([2, 1]) == False >>> is_mountain_sequence([5, 5, 5, 5]) == False >>> is_mountain_sequence([1, 2]) == False def solve_test_cases(T, test_cases): Processes multiple test cases to determine if each sequence is a mountain sequence. T: Number of test cases test_cases: List of tuples, where each tuple contains (N, sequence) >>> solve_test_cases(3, [(6, [1, 2, 3, 4, 3, 2]), (4, [1, 2, 2, 1]), (5, [3, 5, 2, 1, 4])]) == [\\"YES\\", \\"NO\\", \\"NO\\"] >>> solve_test_cases(2, [(3, [1, 3, 2]), (2, [2, 1])]) == [\\"YES\\", \\"NO\\"]","solution":"def is_mountain_sequence(sequence): Determines if the given sequence is a mountain sequence. A sequence is considered as a mountain sequence if it strictly increases and then strictly decreases. n = len(sequence) if n < 3: return False i = 1 # Check increasing part while i < n and sequence[i] > sequence[i-1]: i += 1 # Peak can't be first or last element if i == 1 or i == n: return False # Check decreasing part while i < n and sequence[i] < sequence[i-1]: i += 1 return i == n def solve_test_cases(T, test_cases): Processes multiple test cases to determine if each sequence is a mountain sequence. T: Number of test cases test_cases: List of tuples, where each tuple contains (N, sequence) results = [] for N, sequence in test_cases: if is_mountain_sequence(sequence): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def pair_vehicle(name: str) -> str: Returns the vehicle associated with the given name. If the name is not recognized, returns \\"Unknown person\\". >>> pair_vehicle(\\"Bruce\\") \\"Bruce-Wayne's Batmobile\\" >>> pair_vehicle(\\"Tony\\") \\"Tony-Iron Man's Armor\\" >>> pair_vehicle(\\"Peter\\") \\"Peter-Spidey Buggy\\" >>> pair_vehicle(\\"Clark\\") \\"Clark-Kryptonian Ship\\" >>> pair_vehicle(\\"Diana\\") \\"Diana-Invisible Jet\\" >>> pair_vehicle(\\"Barry\\") \\"Barry-Speedster's Car\\" >>> pair_vehicle(\\"Steve\\") \\"Unknown person\\" >>> pair_vehicle(\\"Natasha\\") \\"Unknown person\\" >>> pair_vehicle(\\"\\") \\"Unknown person\\" >>> pair_vehicle(\\"Bruce-Wayne\\") \\"Unknown person\\"","solution":"def pair_vehicle(name): Returns the vehicle associated with the given name. If the name is not recognized, returns \\"Unknown person\\". vehicles = { \\"Bruce\\": \\"Bruce-Wayne's Batmobile\\", \\"Tony\\": \\"Tony-Iron Man's Armor\\", \\"Peter\\": \\"Peter-Spidey Buggy\\", \\"Clark\\": \\"Clark-Kryptonian Ship\\", \\"Diana\\": \\"Diana-Invisible Jet\\", \\"Barry\\": \\"Barry-Speedster's Car\\" } return vehicles.get(name, \\"Unknown person\\")"},{"question":"def max_distinct_subarray(arr: List[int]) -> int: Returns the length of the longest subarray that contains all distinct integers. >>> max_distinct_subarray([5, 1, 3, 5, 2, 3, 4, 1]) 5 >>> max_distinct_subarray([4, 4, 4, 4]) 1 >>> max_distinct_subarray([1, 2, 3, 4, 5]) 5 >>> max_distinct_subarray([2, 2, 2, 3, 4, 5, 2, 3]) 4 >>> max_distinct_subarray([]) 0 >>> max_distinct_subarray([1]) 1","solution":"def max_distinct_subarray(arr): Returns the length of the longest subarray that contains all distinct integers. n = len(arr) if n == 0: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def findPair(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Given an array of integers and a target integer, returns the indices of two integers in the array whose sum equals the target. If no such pair exists, returns None. >>> findPair([2, 7, 11, 15], 9) (0, 1) >>> findPair([3, 2, 4], 6) (1, 2) >>> findPair([3, 3], 6) (0, 1) >>> findPair([1, 2, 3], 7) None from solution import findPair def test_find_pair_example_1(): assert findPair([2, 7, 11, 15], 9) == (0, 1) def test_find_pair_example_2(): assert findPair([3, 2, 4], 6) == (1, 2) def test_find_pair_example_3(): assert findPair([3, 3], 6) == (0, 1) def test_find_pair_no_pair_found(): assert findPair([1, 2, 3], 7) == None def test_find_pair_with_zero(): assert findPair([0, 4, 3, 0], 0) == (0, 3) def test_find_pair_with_negatives(): assert findPair([-1, -2, -3, -4, -5], -8) == (2, 4) def test_find_pair_large_numbers(): assert findPair([1000000, 500000, -1500000, 100000, 400000], -1000000) == (1, 2) def test_find_pair_repeated_elements(): assert findPair([1, 2, 1], 2) == (0, 2)","solution":"def findPair(nums, target): Given an array of integers and a target integer, returns the indices of two integers in the array whose sum equals the target. If no such pair exists, returns None. lookup = {} for i, num in enumerate(nums): if target - num in lookup: return (lookup[target - num], i) lookup[num] = i return None"},{"question":"def contains_all_unique_letters(s: str) -> bool: Determines if the given string contains all the unique letters of the alphabet (case insensitive). >>> contains_all_unique_letters(\\"The quick brown fox jumps over the lazy dog\\") True >>> contains_all_unique_letters(\\"Hello World\\") False >>> contains_all_unique_letters(\\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\\") True >>> contains_all_unique_letters(\\"123 The quick brown fox, jumps over the lazy dog!\\") True >>> contains_all_unique_letters(\\"\\") False >>> contains_all_unique_letters(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> contains_all_unique_letters(\\"aaaabbbbccccddddeeeeffffgggghhhhiiii\\") False >>> contains_all_unique_letters(\\"The quick brown fox jumps over the lazy dog??!!\\") True","solution":"def contains_all_unique_letters(s): Determines if the given string contains all the unique letters of the alphabet (case insensitive). :param s: String to be checked :return: Boolean indicating whether all unique letters are present # Create a set of all alphabets in lowercase alphabet_set = set('abcdefghijklmnopqrstuvwxyz') # Convert the input string to lowercase and create a set of its alphabetic characters s_set = set([char.lower() for char in s if char.isalpha()]) # Check if the alphabet set is a subset of the string's alphabetic set return alphabet_set.issubset(s_set)"},{"question":"def create_grid(rows: int, cols: int) -> str: Generates a grid of specified rows and columns where each cell is represented by \\"X\\". Each row is separated by a newline character and each column by a space. Parameters: rows (int): Number of rows in the grid. cols (int): Number of columns in the grid. Returns: str: The entire grid as a string. >>> create_grid(3, 4) 'X X X XnX X X XnX X X X' >>> create_grid(2, 2) 'X XnX X' >>> create_grid(0, 4) '' >>> create_grid(4, 0) '' >>> create_grid(1, 1) 'X' >>> create_grid(5, 3) 'X X XnX X XnX X XnX X XnX X X'","solution":"def create_grid(rows, cols): Generates a grid of specified rows and columns where each cell is represented by \\"X\\". Each row is separated by a newline character and each column by a space. Parameters: rows (int): Number of rows in the grid. cols (int): Number of columns in the grid. Returns: str: The entire grid as a string. if rows <= 0 or cols <= 0: return \\"\\" # Generate a single row with columns single_row = \\"X \\" * cols single_row = single_row.rstrip() # Remove the trailing space # Combine rows separated by newline characters grid = \\"n\\".join([single_row] * rows) return grid"},{"question":"def organize_flower_deliveries(n: int, deliveries: List[Tuple[int, int]], m: int, query_times: List[int]) -> List[int]: Evelyn is managing a flower shop and needs your help to organize her flower deliveries. Each flower delivery is scheduled to be delivered within a certain time frame in the day, denoted in 24-hour format. Given a list of delivery time frames and a list of specific times she needs to check, help her determine which deliveries are scheduled during those times. >>> organize_flower_deliveries(4, [(9, 12), (10, 14), (13, 15), (19, 22)], 3, [11, 21, 5]) [2, 1, 0] >>> organize_flower_deliveries(1, [(0, 23)], 3, [0, 12, 22]) [1, 1, 1] >>> organize_flower_deliveries(2, [(8, 10), (20, 23)], 3, [6, 15, 22]) [0, 0, 1] >>> organize_flower_deliveries(3, [(0, 8), (8, 16), (16, 23)], 5, [0, 8, 15, 16, 22]) [1, 1, 1, 1, 1] >>> organize_flower_deliveries(0, [], 2, [5, 12]) [0, 0]","solution":"def count_deliveries_at_times(n, deliveries, m, query_times): delivery_count = [0] * 24 for t_start, t_end in deliveries: for time in range(t_start, t_end): delivery_count[time] += 1 result = [] for q in query_times: result.append(delivery_count[q]) return result def organize_flower_deliveries(n, deliveries, m, query_times): return count_deliveries_at_times(n, deliveries, m, query_times)"},{"question":"def tileOptimizer(n: int, m: int) -> bool: Determines if it is possible to completely cover a floor of dimensions n x m with 1x2 tiles without overlaps or gaps. Args: n (int): number of rows in the floor. m (int): number of columns in the floor. Returns: bool: True if possible to cover the floor completely, False otherwise. Examples: >>> tileOptimizer(4, 5) False >>> tileOptimizer(3, 2) True >>> tileOptimizer(2, 8) True","solution":"def tileOptimizer(n, m): Returns True if it is possible to cover the n x m floor with 1x2 tiles, otherwise False. # Check if the area of the floor (n * m) is even return (n * m) % 2 == 0"},{"question":"def reorganize_string(s: str) -> str: Reorganize the string such that no two adjacent characters are the same. If such a reorganization is not possible, return an empty string. >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"\\"","solution":"import heapq from collections import Counter def reorganize_string(s): if not s: return \\"\\" count = Counter(s) max_heap = [(-cnt, char) for char, cnt in count.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 reorganized_string = \\"\\".join(result) if len(reorganized_string) != len(s): return \\"\\" return reorganized_string"},{"question":"def count_forests(grid: List[str]) -> int: Counts the number of distinct forests in the given N x M grid. A forest is a group of connected trees ('T') which are connected horizontally, vertically, or diagonally. :param grid: List of strings representing the grid :return: Number of distinct forests >>> count_forests([\\"T.T\\", \\".T.\\", \\"T.T\\"]) 1 >>> count_forests([\\"TT.\\", \\"T..\\", \\"...\\", \\".T.\\"]) 2 >>> count_forests([\\"...\\", \\"...\\", \\"...\\"]) 0 >>> count_forests([\\"T.T\\", \\"...\\", \\"T.T\\"]) 4 >>> count_forests([\\"T.T.T\\"]) 3 >>> count_forests([\\"T\\", \\".\\", \\"T\\", \\"T\\"]) 2 >>> count_forests([ ... \\"T.........\\", ... \\".T........\\", ... \\"..T.......\\", ... \\"...T......\\", ... \\"....T.....\\", ... \\".....T....\\", ... \\"......T...\\", ... \\".......T..\\", ... \\"........T.\\", ... \\".........T\\" ... ]) 1 pass","solution":"def count_forests(grid): Counts the number of distinct forests in the given N x M grid. A forest is a group of connected trees ('T') which are connected horizontally, vertically, or diagonally. :param grid: List of strings representing the grid :return: Number of distinct forests if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(x, y): Depth-first search to mark all connected 'T' as visited. stack = [(x, y)] directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == 'T': visited[nx][ny] = True stack.append((nx, ny)) forest_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 'T' and not visited[i][j]: visited[i][j] = True forest_count += 1 dfs(i, j) return forest_count"},{"question":"def calculate_paint_cans(length: int, width: int, height: int) -> int: Calculate the number of 1-liter cans of paint required to paint the walls of a room. 1 liter of paint covers 10 square meters. Parameters: length (int): The length of the room in meters. width (int): The width of the room in meters. height (int): The height of the room in meters. Returns: int: The number of 1-liter paint cans needed. pass # Example test cases def test_calculate_paint_cans_example(): assert calculate_paint_cans(5, 4, 3) == 6 def test_calculate_paint_cans_small_room(): assert calculate_paint_cans(2, 3, 2) == 2 def test_calculate_paint_cans_large_room(): assert calculate_paint_cans(10, 10, 5) == 20 def test_calculate_paint_cans_tall_room(): assert calculate_paint_cans(6, 7, 10) == 26 def test_calculate_paint_cans_exact_fit(): assert calculate_paint_cans(2, 3, 5) == 5","solution":"import math def calculate_paint_cans(length: int, width: int, height: int) -> int: Calculate the number of 1-liter cans of paint required to paint the walls of a room. 1 liter of paint covers 10 square meters. Parameters: length (int): The length of the room in meters. width (int): The width of the room in meters. height (int): The height of the room in meters. Returns: int: The number of 1-liter paint cans needed. # Calculate the total surface area of the walls total_surface_area = 2 * (length + width) * height # Calculate the number of paint cans required, rounding up to the nearest whole number paint_cans_needed = math.ceil(total_surface_area / 10) return paint_cans_needed"},{"question":"def generate_seating_chart(N: int, M: int) -> str: Write a program that simulates the generation of a seating chart for a classroom following these rules: 1. The classroom is represented as an N x M grid. 2. Each cell in the grid represents a seat which can either be occupied by a student ('S') or be empty ('E'). 3. No two students can sit next to each other horizontally, vertically, or diagonally. 4. The top-left seat must be occupied by a student. >>> generate_seating_chart(4, 6) 'S E S E S EnE E E E E EnS E S E S EnE E E E E E' >>> generate_seating_chart(3, 3) 'S E SnE E EnS E S' >>> generate_seating_chart(2, 2) 'S EnE E' >>> generate_seating_chart(1, 1) 'S' >>> generate_seating_chart(0, 0) '' >>> generate_seating_chart(2, 0) '' >>> generate_seating_chart(0, 3) ''","solution":"def generate_seating_chart(N, M): if N == 0 or M == 0: return \\"\\" seating_chart = [] for i in range(N): row = [] for j in range(M): if (i % 2 == 0 and j % 2 == 0): row.append('S') else: row.append('E') seating_chart.append(' '.join(row)) return 'n'.join(seating_chart)"},{"question":"def maxProductOfThree(nums: List[int]) -> int: Returns the maximum product of any three numbers in a non-empty list. >>> maxProductOfThree([1, 2, 3, 4]) 24 >>> maxProductOfThree([-10, -10, 5, 2]) 500 >>> maxProductOfThree([-4, -3, -2, -1, 60]) 720 >>> maxProductOfThree([-5, -4, -3, -2, -1]) -6 >>> maxProductOfThree([100, 201, 300, 500, 700]) 105000000 >>> maxProductOfThree([-1, 0, 1, 2, 3]) 6 >>> maxProductOfThree([1, 1, 1, 1, 1]) 1 >>> maxProductOfThree([0, 0, 0, 0, 0]) 0","solution":"from typing import List def maxProductOfThree(nums: List[int]) -> int: Returns the maximum product of any three numbers in a non-empty list. nums.sort() # The maximum product will be the maximum of product of the # three largest numbers or product of the two smallest and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"from typing import List, Dict, Any def format_race_times(lap_times: List[int]) -> Dict[str, Any]: Convert lap times from seconds to \\"mm:ss\\" format and calculate total time in \\"mm:ss\\" format. Each lap time in the input will be converted to a string in the \`mm:ss\` format, and the total race time will be calculated and returned in the same format. >>> format_race_times([75]) {'formattedLapTimes': ['1:15'], 'totalTime': '1:15'} >>> format_race_times([125, 145, 178]) {'formattedLapTimes': ['2:05', '2:25', '2:58'], 'totalTime': '7:28'} >>> format_race_times([3600, 4500, 3661]) {'formattedLapTimes': ['60:00', '75:00', '61:01'], 'totalTime': '196:01'} >>> format_race_times([60, 60, 60]) {'formattedLapTimes': ['1:00', '1:00', '1:00'], 'totalTime': '3:00'} >>> format_race_times([0, 0, 0]) {'formattedLapTimes': ['0:00', '0:00', '0:00'], 'totalTime': '0:00'}","solution":"from typing import List, Dict, Any def format_race_times(lap_times: List[int]) -> Dict[str, Any]: formatted_lap_times = [] total_seconds = sum(lap_times) for lap in lap_times: minutes, seconds = divmod(lap, 60) formatted_lap_times.append(f'{minutes}:{seconds:02}') total_minutes, total_seconds = divmod(sum(lap_times), 60) total_time = f'{total_minutes}:{total_seconds:02}' return { \\"formattedLapTimes\\": formatted_lap_times, \\"totalTime\\": total_time }"},{"question":"def sum_even(numbers: List[int]) -> int: Returns the sum of all even numbers in the list. >>> sum_even([1, 2, 3, 4, 5, 6]) == 12 >>> sum_even([7, 11, 13, 17]) == 0 >>> sum_even([2, 4, 6, 8]) == 20","solution":"def sum_even(numbers): Returns the sum of all even numbers in the list. :param numbers: List of positive integers :return: Sum of all even numbers in the list return sum(num for num in numbers if num % 2 == 0)"},{"question":"def maxSum(arr: List[int], k: int) -> int: Returns the maximum sum of k consecutive elements in the array. >>> maxSum([1, 3, 5, 2, 8, 1, 5], 3) == 15 >>> maxSum([4, 4, 4, 4, 4], 2) == 8 >>> maxSum([5, -2, 1, 3, 9, -4, 2], 4) == 11 >>> maxSum([2, 2, 2, 2, 2, 2], 3) == 6 >>> maxSum([2, 7, 1, 8, 2, 8, 3], 1) == 8 >>> maxSum([1, 2, 3, 4, 5], 5) == 15 >>> maxSum([-1, 3, 4, -2, 6, -1, 2], 3) == 8 >>> maxSum([-3, -2, -1, -4, -2], 2) == -3 >>> maxSum([0, 0, 0, 4, 0], 3) == 4","solution":"def maxSum(arr, k): Returns the maximum sum of k consecutive elements in the array. if not arr or k <= 0 or k > len(arr): return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def min_steps_maze(n: int, m: int, maze: List[str]) -> int: Determine the minimum number of steps needed to get from the top-left corner to the bottom-right corner of the maze, or return -1 if it is impossible to reach the bottom-right corner. Args: n (int): Number of rows in the maze. m (int): Number of columns in the maze. maze (List[str]): List of strings representing the maze, where '.' indicates an empty cell and '#' indicates a wall. Returns: int: Minimum number of steps to reach the bottom-right corner, or -1 if it is impossible. >>> min_steps_maze(4, 4, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"]) 6 >>> min_steps_maze(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) -1 # Unit Test def test_min_steps_maze(): assert min_steps_maze(4, 4, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"]) == 6 assert min_steps_maze(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) == -1 assert min_steps_maze(1, 1, [\\".\\"]) == 0 assert min_steps_maze(1, 1, [\\"#\\"]) == -1 assert min_steps_maze(5, 5, [\\".....\\", \\"#\\", \\".....\\", \\"#\\", \\".....\\"]) == -1 assert min_steps_maze(5, 5, [\\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\"]) == 8","solution":"from collections import deque def min_steps_maze(n, m, maze): if maze[0][0] == '#' or maze[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0)]) visited = [[False] * m for _ in range(n)] visited[0][0] = True steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) steps += 1 return -1"},{"question":"def card_game(n: int, cards: List[int]) -> str: Determine the winner of the memory card game or if it is a draw. Parameters: n (int): Number of cards cards (List[int]): List of card values Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins, \\"Draw\\" if it's a draw, or \\"Invalid game with no cards\\" if n <= 0. >>> card_game(3, [5, 1, 2]) 'Alice' >>> card_game(0, []) 'Invalid game with no cards'","solution":"def card_game(n, cards): Determine the winner of the memory card game or if it is a draw. Parameters: n (int): Number of cards cards (List[int]): List of card values Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins, \\"Draw\\" if it's a draw, or \\"Invalid game with no cards\\" if n <= 0. if n <= 0: return \\"Invalid game with no cards\\" alice_sum = 0 bob_sum = 0 left = 0 right = n - 1 while left <= right: alice_sum += cards[left] left += 1 if left <= right: bob_sum += cards[right] right -= 1 if alice_sum > bob_sum: return \\"Alice\\" elif bob_sum > alice_sum: return \\"Bob\\" else: return \\"Draw\\""},{"question":"def findLongestPalindromicSubstring(s: str) -> str: Write a function to find the longest palindromic substring in a given string \`s\`. A palindromic substring is a substring which reads the same backward as forward. The function should handle strings of length up to 2000 characters. >>> findLongestPalindromicSubstring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> findLongestPalindromicSubstring(\\"cbbd\\") 'bb'","solution":"def findLongestPalindromicSubstring(s: str) -> str: if len(s) == 0: return \\"\\" def expandAroundCenter(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes (center at i) palindrome1 = expandAroundCenter(s, i, i) # Even length palindromes (center between i and i+1) palindrome2 = expandAroundCenter(s, i, i + 1) # Update the longest palindrome found longest = max(longest, palindrome1, palindrome2, key=len) return longest"},{"question":"def smallest_missing_positive_integer(arr: List[int]) -> int: Given an array of integers, find the smallest positive integer that is not present in the array. >>> smallest_missing_positive_integer([3, 4, -1, 1]) 2 >>> smallest_missing_positive_integer([0, 1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive_integer([1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive_integer([-3, -2, -1, 1, 3, 4]) 2 >>> smallest_missing_positive_integer([2, 3, 4, 5, 6]) 1 >>> smallest_missing_positive_integer([2]) 1 >>> smallest_missing_positive_integer([1]) 2 >>> smallest_missing_positive_integer([]) 1","solution":"def smallest_missing_positive_integer(arr): Returns the smallest positive integer not in arr. arr_set = set(arr) i = 1 while True: if i not in arr_set: return i i += 1"},{"question":"def find_missing_coin(N: int, collected_coins: List[int]) -> int: Find the missing coin in a collection of coins. >>> find_missing_coin(5, [2, 3, 1, 5]) 4 >>> find_missing_coin(7, [4, 3, 1, 7, 6, 2]) 5","solution":"def find_missing_coin(N, collected_coins): Returns the missing coin number given the total number of coins N and the list of collected coins. expected_sum = (N * (N + 1)) // 2 collected_sum = sum(collected_coins) return expected_sum - collected_sum"},{"question":"import numpy as np def array_operations(N: int, K: int, array_data: List[List[int]]) -> Tuple[np.ndarray, np.ndarray, int]: Performs median along axis 0, sum along axis 1, and prod along axis None on the input 2D array. Parameters: N (int): The number of rows in the array. K (int): The number of columns in the array. array_data (list of list of int): The 2D array data. Returns: tuple: A tuple containing the median along axis 0, sum along axis 1, and prod along axis None. >>> array_operations(2, 2, [[1, 2], [3, 4]]) (array([2., 3.]), array([3, 7]), 24) >>> array_operations(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (array([4., 5., 6.]), array([ 6, 15, 24]), 362880)","solution":"import numpy as np def array_operations(N, K, array_data): Performs median along axis 0, sum along axis 1, and prod along axis None on the input 2D array. Parameters: N (int): The number of rows in the array. K (int): The number of columns in the array. array_data (list of list of int): The 2D array data. Returns: tuple: A tuple containing the median along axis 0, sum along axis 1, and prod along axis None. my_array = np.array(array_data) median_axis_0 = np.median(my_array, axis=0) sum_axis_1 = np.sum(my_array, axis=1) prod_axis_none = np.prod(my_array) return median_axis_0, sum_axis_1, prod_axis_none"},{"question":"def square_free_numbers(n: int) -> List[int]: Generate a sequence of the first n \\"square-free\\" numbers. A number is considered square-free if it is not divisible by any perfect square other than 1. If \`n == 0\`, return an empty list. >>> square_free_numbers(10) [1, 2, 3, 5, 6, 7, 10, 11, 13, 14] >>> square_free_numbers(0) []","solution":"def is_square_free(num): Determines if a number is square-free. if num == 1: return True for i in range(2, int(num**0.5) + 1): if (num % (i * i)) == 0: return False return True def square_free_numbers(n): Generates the first n square-free numbers. if n == 0: return [] sq_free_nums = [] num = 1 while len(sq_free_nums) < n: if is_square_free(num): sq_free_nums.append(num) num += 1 return sq_free_nums"},{"question":"def total_reading_time(members, days_in_month): Calculate the total amount of time a book club spends reading in a month. Args: members (list of dict): Each dictionary contains 'pages_per_hour' and 'hours_per_day' keys. days_in_month (int): The total number of days in the month. Returns: int: Total reading time in hours. def test_total_reading_time(): members = [ {'pages_per_hour': 30, 'hours_per_day': 2}, {'pages_per_hour': 20, 'hours_per_day': 1}, {'pages_per_hour': 25, 'hours_per_day': 3} ] days_in_month = 30 assert total_reading_time(members, days_in_month) == 180 def test_total_reading_time_different_days(): members = [ {'pages_per_hour': 30, 'hours_per_day': 2}, {'pages_per_hour': 20, 'hours_per_day': 1}, {'pages_per_hour': 25, 'hours_per_day': 3} ] days_in_month = 28 assert total_reading_time(members, days_in_month) == 168 def test_total_reading_time_single_member(): members = [{'pages_per_hour': 30, 'hours_per_day': 2}] days_in_month = 30 assert total_reading_time(members, days_in_month) == 60 def test_total_reading_time_no_members(): members = [] days_in_month = 30 assert total_reading_time(members, days_in_month) == 0 def test_total_reading_time_single_day(): members = [ {'pages_per_hour': 30, 'hours_per_day': 2}, {'pages_per_hour': 20, 'hours_per_day': 1}, {'pages_per_hour': 25, 'hours_per_day': 3} ] days_in_month = 1 assert total_reading_time(members, days_in_month) == 6","solution":"def total_reading_time(members, days_in_month): Calculate the total amount of time a book club spends reading in a month. Args: members (list of dict): Each dictionary contains 'pages_per_hour' and 'hours_per_day' keys. days_in_month (int): The total number of days in the month. Returns: int: Total reading time in hours. total_hours = 0 for member in members: total_hours += member['hours_per_day'] * days_in_month return total_hours"},{"question":"from typing import List def unique_permutations(s: str) -> List[str]: Returns a list of all unique permutations of the characters in the input string. The output list should be sorted in lexicographical order. >>> unique_permutations(\\"a\\") [\\"a\\"] >>> unique_permutations(\\"ab\\") [\\"ab\\", \\"ba\\"] >>> unique_permutations(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> unique_permutations(\\"112\\") [\\"112\\", \\"121\\", \\"211\\"] pass # Test cases def test_single_character(): assert unique_permutations(\\"a\\") == [\\"a\\"] def test_two_characters(): assert unique_permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] def test_repeated_characters(): assert unique_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] def test_multiple_repeated_characters(): assert unique_permutations(\\"112\\") == [\\"112\\", \\"121\\", \\"211\\"] def test_three_characters(): assert unique_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_duplicated_in_three_characters(): assert unique_permutations(\\"aabc\\") == [\\"aabc\\", \\"aacb\\", \\"abac\\", \\"abca\\", \\"acab\\", \\"acba\\", \\"baac\\", \\"baca\\", \\"bcaa\\", \\"caab\\", \\"caba\\", \\"cbaa\\"] def test_with_spaces(): assert unique_permutations(\\"a b\\") == [\\" ab\\", \\" ba\\", \\"a b\\", \\"ab \\", \\"b a\\", \\"ba \\"]","solution":"from typing import List from itertools import permutations def unique_permutations(s: str) -> List[str]: Returns a list of all unique permutations of the characters in the input string. # Generate all permutations perms = set(permutations(s)) # Convert the perms set to a list of strings unique_perms = [''.join(p) for p in perms] # Sort the result list in lexicographical order unique_perms.sort() return unique_perms"},{"question":"def cumulative_sum(nums: List[int]) -> List[int]: This function takes a list of integers and returns a new list where each element is the cumulative sum up to that index. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([3, 1, 4, 1, 5]) [3, 4, 8, 9, 14] def test_cumulative_sum_example(): assert cumulative_sum([1, 2, 3, 4]) == [1, 3, 6, 10] def test_cumulative_sum_single_element(): assert cumulative_sum([42]) == [42] def test_cumulative_sum_multiple_elements(): assert cumulative_sum([3, 1, 4, 1, 5]) == [3, 4, 8, 9, 14] def test_cumulative_sum_all_zero(): assert cumulative_sum([0, 0, 0, 0]) == [0, 0, 0, 0] def test_cumulative_sum_mixed_values(): assert cumulative_sum([2, 3, 5, 7, 11]) == [2, 5, 10, 17, 28]","solution":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: This function takes a list of integers and returns a new list where each element is the cumulative sum up to that index. :param nums: List of integers. :return: List of integers representing the cumulative sums. cum_sum = 0 result = [] for num in nums: cum_sum += num result.append(cum_sum) return result"},{"question":"from typing import List def max_area(height: List[int]) -> int: Find two lines such that they together with the x-axis form a container, such that the container can hold the maximum amount of water. Args: height (List[int]): List of non-negative integers representing the heights of vertical lines. Returns: int: The maximum water that can be held by the container formed by any two of these lines. pass # Example test cases def test_example_case(): assert max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 def test_height_all_zeros(): assert max_area([0, 0, 0, 0, 0]) == 0 def test_height_all_the_same(): assert max_area([5, 5, 5, 5]) == 15 def test_increasing_heights(): assert max_area([1, 2, 3, 4, 5]) == 6 def test_decreasing_heights(): assert max_area([5, 4, 3, 2, 1]) == 6 def test_two_elements(): assert max_area([1, 1]) == 1 def test_large_input(): heights = [i for i in range(1, 10001)] assert max_area(heights) == 25000000","solution":"from typing import List def max_area(height: List[int]) -> int: Find two lines such that they together with the x-axis form a container, such that the container can hold the maximum amount of water. Args: height (List[int]): List of non-negative integers representing the heights of vertical lines. Returns: int: The maximum water that can be held by the container formed by any two of these lines. left, right = 0, len(height) - 1 max_water = 0 while left < right: # Calculate the width and the deciding height width = right - left ht = min(height[left], height[right]) max_water = max(max_water, width * ht) # Move the pointers if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are two distinct elements in the array whose sum equals the target integer. Args: arr: List of integers. target: The target integer. Returns: bool: True if there exists a pair of distinct elements whose sum equals the target, False otherwise. Example: >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False","solution":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are two distinct elements in the array whose sum equals the target integer. Args: arr: List of integers. target: The target integer. Returns: bool: True if there exists a pair of distinct elements whose sum equals the target, False otherwise. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def mergeOverlappingIntervals(intervals): Merges overlapping intervals. Args: intervals (list of tuples): List of intervals where each interval is represented as (start, end) Returns: list of tuples: List of merged intervals. from solution import mergeOverlappingIntervals def test_merge_no_intervals(): assert mergeOverlappingIntervals([]) == [] def test_merge_single_interval(): assert mergeOverlappingIntervals([(1, 5)]) == [(1, 5)] def test_merge_overlapping_intervals(): assert mergeOverlappingIntervals([(1, 3), (2, 6), (8, 10), (15, 18)]) == [(1, 6), (8, 10), (15, 18)] def test_merge_adjacent_intervals(): assert mergeOverlappingIntervals([(1, 5), (5, 10)]) == [(1, 10)] def test_merge_non_overlapping_intervals(): assert mergeOverlappingIntervals([(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)] def test_merge_multiple_overlapping_intervals(): assert mergeOverlappingIntervals([(1, 4), (2, 5), (7, 8)]) == [(1, 5), (7, 8)] def test_merge_intervals_with_same_start(): assert mergeOverlappingIntervals([(1, 4), (1, 5)]) == [(1, 5)] def test_merge_intervals_with_same_end(): assert mergeOverlappingIntervals([(1, 4), (2, 4)]) == [(1, 4)]","solution":"def mergeOverlappingIntervals(intervals): Merges overlapping intervals. Args: intervals (list of tuples): List of intervals where each interval is represented as (start, end) Returns: list of tuples: List of merged intervals. if not intervals: return [] # First, sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(17) True >>> is_prime(18) False def split_and_sort_numbers(nums: List[int]) -> Tuple[List[int], List[int]]: Splits a list of integers into prime and composite numbers. Primes are sorted in ascending order, composites in descending order. >>> split_and_sort_numbers([8, 5, 1, 12, 3, 7, 15, 0, 4]) ([3, 5, 7], [15, 12, 8, 4]) >>> split_and_sort_numbers([2, 3, 5, 7, 11, 13]) ([2, 3, 5, 7, 11, 13], []) >>> split_and_sort_numbers([4, 6, 8, 9, 10, 12, 14]) ([], [14, 12, 10, 9, 8, 6, 4]) >>> split_and_sort_numbers([0, 1]) ([], []) >>> split_and_sort_numbers([17, 4, 19, 2, 22, 0, 1, 8, 9]) ([2, 17, 19], [22, 9, 8, 4])","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def split_and_sort_numbers(nums): Splits a list of integers into prime and composite numbers. Primes are sorted in ascending order, composites in descending order. primes = [] composites = [] for num in nums: if num <= 1: continue if is_prime(num): primes.append(num) else: composites.append(num) primes.sort() composites.sort(reverse=True) return (primes, composites) # Example usage # nums = [8, 5, 1, 12, 3, 7, 15, 0, 4] # result = split_and_sort_numbers(nums) # print(result) # Output: ([3, 5, 7], [15, 12, 8, 4])"},{"question":"from typing import List def even_before_odd(lst: List[int]) -> List[int]: Returns a new list with all even numbers appearing before all odd numbers while maintaining their relative order from the original list. >>> even_before_odd([3, 8, 12, 5, 10, 1, 4]) [8, 12, 10, 4, 3, 5, 1] >>> even_before_odd([]) [] >>> even_before_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> even_before_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> even_before_odd([7, 2, 9, 4, 10, 1]) [2, 4, 10, 7, 9, 1] >>> even_before_odd([2]) [2] >>> even_before_odd([3]) [3] >>> even_before_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5]","solution":"def even_before_odd(lst): Returns a new list with all even numbers appearing before all odd numbers while maintaining their relative order from the original list. evens = [x for x in lst if x % 2 == 0] odds = [x for x in lst if x % 2 != 0] return evens + odds"},{"question":"def find_anagrams(word: str, candidates: List[str]) -> List[str]: Returns a list of anagrams of the given word from the list of candidates. >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"]) [\\"enlist\\", \\"inlets\\"] >>> find_anagrams(\\"racecar\\", [\\"carrace\\", \\"arcacer\\", \\"rcaecar\\", \\"cat\\"]) [\\"carrace\\", \\"arcacer\\", \\"rcaecar\\"] >>> find_anagrams(\\"hello\\", [\\"holle\\", \\"lhelo\\", \\"world\\", \\"ghello\\"]) [\\"holle\\", \\"lhelo\\"]","solution":"def find_anagrams(word, candidates): Returns a list of anagrams of the given word from the list of candidates. sorted_word = sorted(word) return [candidate for candidate in candidates if sorted(candidate) == sorted_word]"},{"question":"def can_place_all_words(n: int, words: List[str]) -> bool: Determines if all words can be placed in an n x n grid either horizontally or vertically without overlapping or crossing. Args: n : int : size of the grid (n x n) words : list of strings : words to be placed in the grid Returns: bool : True if all words can be placed, False otherwise >>> can_place_all_words(5, [\\"HELLO\\", \\"WORLD\\", \\"PYTHON\\"]) False >>> can_place_all_words(4, [\\"AB\\", \\"CD\\", \\"EF\\"]) True","solution":"def can_place_all_words(n, words): Determines if all words can be placed in an n x n grid either horizontally or vertically without overlapping or crossing. Args: n : int : size of the grid (n x n) words : list of strings : words to be placed in the grid Returns: bool : True if all words can be placed, False otherwise # Function to check if a word fits in a given position and orientation def fits(x, y, word, horizontal): if horizontal: return y + len(word) <= n and all(grid[x][y + i] == 0 for i in range(len(word))) else: return x + len(word) <= n and all(grid[x + i][y] == 0 for i in range(len(word))) # Place the word in the grid def place(x, y, word, horizontal): if horizontal: for i in range(len(word)): grid[x][y + i] = word[i] else: for i in range(len(word)): grid[x + i][y] = word[i] # Remove the word from the grid def remove(x, y, word, horizontal): if horizontal: for i in range(len(word)): grid[x][y + i] = 0 else: for i in range(len(word)): grid[x + i][y] = 0 # Backtracking function to try placing all words def backtrack(index): if index == len(words): return True word = words[index] for x in range(n): for y in range(n): if fits(x, y, word, True): place(x, y, word, True) if backtrack(index + 1): return True remove(x, y, word, True) if fits(x, y, word, False): place(x, y, word, False) if backtrack(index + 1): return True remove(x, y, word, False) return False # Initialize grid grid = [[0] * n for _ in range(n)] # Start backtracking return backtrack(0)"},{"question":"def calculate_averages(data): Returns a dictionary where each student's name is a key and the corresponding value is their average exam score. The average is rounded to two decimal places. >>> data = {\\"Alice\\": [88, 76, 92, 85], \\"Bob\\": [90, 80, 85, 88], \\"Charlie\\": [60, 70, 75, 65]} >>> calculate_averages(data) {'Alice': 85.25, 'Bob': 85.75, 'Charlie': 67.5} pass def test_calculate_averages_with_data(): data = { \\"Alice\\": [88, 76, 92, 85], \\"Bob\\": [90, 80, 85, 88], \\"Charlie\\": [60, 70, 75, 65] } expected = {'Alice': 85.25, 'Bob': 85.75, 'Charlie': 67.5} assert calculate_averages(data) == expected def test_calculate_averages_empty_scores(): data = { \\"Alice\\": [], \\"Bob\\": [90, 80, 85, 88], \\"Charlie\\": [60, 70, 75, 65] } expected = {'Alice': 0.0, 'Bob': 85.75, 'Charlie': 67.5} assert calculate_averages(data) == expected def test_calculate_averages_all_empty(): data = {} expected = {} assert calculate_averages(data) == expected def test_calculate_averages_single_score(): data = { \\"Alice\\": [88], \\"Bob\\": [90], \\"Charlie\\": [60] } expected = {'Alice': 88.0, 'Bob': 90.0, 'Charlie': 60.0} assert calculate_averages(data) == expected def test_calculate_averages_mixed_scores(): data = { \\"Alice\\": [88, 76, 92, 85, 100], \\"Bob\\": [90, 80, 85], \\"Charlie\\": [61, 72, 75, 68] } expected = {'Alice': 88.2, 'Bob': 85.0, 'Charlie': 69.0} assert calculate_averages(data) == expected","solution":"def calculate_averages(data): Returns a dictionary where each student's name is a key and the corresponding value is their average exam score. The average is rounded to two decimal places. averages = {} for student, scores in data.items(): if scores: average_score = round(sum(scores) / len(scores), 2) else: average_score = 0.0 # Handling the case if the score list is empty averages[student] = average_score return averages"},{"question":"from typing import List, Tuple def count_pairs_with_sum(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the number of pairs in each array that sum up to a given value K. >>> count_pairs_with_sum([(5, 9, [2, 7, 11, 15, 1])]) [1] >>> count_pairs_with_sum([(4, 0, [-1, 1, -2, 2])]) [2] def parse_input(input_text: str) -> List[Tuple[int, int, List[int]]]: Parse the input text into a list of test cases. >>> parse_input(\\"2n5 9n2 7 11 15 1n4 0n-1 1 -2 2\\") [(5, 9, [2, 7, 11, 15, 1]),(4, 0, [-1, 1, -2, 2])] # Unit Tests def test_single_pair(): input_text = \\"1n5 9n2 7 11 15 1\\" test_cases = parse_input(input_text) result = count_pairs_with_sum(test_cases) assert result == [1] def test_multiple_pairs(): input_text = \\"1n4 0n-1 1 -2 2\\" test_cases = parse_input(input_text) result = count_pairs_with_sum(test_cases) assert result == [2] def test_no_pairs(): input_text = \\"1n3 10n1 2 3\\" test_cases = parse_input(input_text) result = count_pairs_with_sum(test_cases) assert result == [0] def test_large_input(): input_text = \\"1n6 10n5 5 5 5 5 5\\" test_cases = parse_input(input_text) result = count_pairs_with_sum(test_cases) assert result == [15] def test_multiple_test_cases(): input_text = \\"2n5 9n2 7 11 15 1n4 0n-1 1 -2 2\\" test_cases = parse_input(input_text) result = count_pairs_with_sum(test_cases) assert result == [1, 2]","solution":"def count_pairs_with_sum(test_cases): results = [] for case in test_cases: n, K, arr = case count = 0 seen = {} for number in arr: target = K - number if target in seen: count += seen[target] if number in seen: seen[number] += 1 else: seen[number] = 1 results.append(count) return results def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n, K = map(int, lines[index].split()) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, K, arr)) index += 2 return test_cases"},{"question":"def bricks_needed(Q: int, queries: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> List[int]: Calculate the number of bricks required to build the walls. >>> bricks_needed(2, [[(10, 5), (2, 1)], [(12, 8), (3, 2)]]) [25, 16] >>> bricks_needed(1, [[(6, 6), (2, 2)]]) [9]","solution":"def bricks_needed(Q, queries): results = [] for i in range(Q): L, W = queries[i][0] BL, BW = queries[i][1] bricks_count = (L // BL) * (W // BW) results.append(bricks_count) return results"},{"question":"def isHarshadNumber(number: int) -> bool: Returns True if the given number is a Harshad number, otherwise False. >>> isHarshadNumber(18) True >>> isHarshadNumber(19) False >>> isHarshadNumber(21) True >>> isHarshadNumber(53) False pass","solution":"def isHarshadNumber(number): Returns True if the given number is a Harshad number, otherwise False. Parameters: number (int): A positive integer. Returns: bool: True if the number is a Harshad number, False otherwise. digit_sum = sum(int(digit) for digit in str(number)) return number % digit_sum == 0"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a fully parenthesized mathematical expression. Args: expression (str): A string representing the mathematical expression. Returns: int: The result of the evaluated expression, or None if the expression is invalid. Examples: >>> evaluate_expression(\\"3+(2*2)\\") == 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 >>> evaluate_expression(\\"(10/2)-(3*3)\\") == -4 >>> evaluate_expression(\\"\\") is None >>> evaluate_expression(\\"((3+2)\\") is None >>> evaluate_expression(\\"3+2)\\") is None >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"10/2-3*3\\") == -4","solution":"def evaluate_expression(expression): Evaluates a fully parenthesized mathematical expression. Args: expression (str): A string representing the mathematical expression. Returns: int: The result of the evaluated expression. try: # Evaluate the expression using python's eval which handles parenthesis and integer division result = eval(expression, {\\"__builtins__\\": None}, {\\"__truediv__\\": lambda x, y: x // y}) return result except: return None"},{"question":"from typing import List def restoreIpAddresses(s: str) -> List[str]: Given a string containing only digits, restore all possible valid IP address combinations that can be formed by inserting dots into the string. Args: s (str): The string containing only digits. Returns: List[str]: A list of possible valid IP address combinations. Examples: >>> restoreIpAddresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restoreIpAddresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restoreIpAddresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restoreIpAddresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> restoreIpAddresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"]","solution":"from typing import List def restoreIpAddresses(s: str) -> List[str]: def is_valid(segment: str) -> bool: Check if the segment is a valid part of an IP address. return 0 <= int(segment) <= 255 and str(int(segment)) == segment def backtrack(start: int, path: List[str]): Use backtracking to find all possible IP addresses. if len(path) == 4: if start == len(s): result.append(\\".\\".join(path)) return for length in range(1, 4): if start + length <= len(s): segment = s[start:start+length] if is_valid(segment): backtrack(start + length, path + [segment]) result = [] backtrack(0, []) return result"},{"question":"from typing import List def get_largest_k_elements(nums: List[int], k: int) -> List[int]: Given an integer array \`nums\` and an integer \`k\`, rearrange the array to form the k largest distinct elements in descending order. If the number of unique elements in \`nums\` is less than \`k\`, include all distinct elements sorted in descending order followed by the next highest repeated elements to make the count equal to \`k\`. >>> get_largest_k_elements([4, 4, 1, 2, 1, 3], 3) [4, 3, 2] >>> get_largest_k_elements([5, 2, 2, 3, 1], 4) [5, 3, 2, 1] >>> get_largest_k_elements([1, 2, 2, 3, 4], 4) [4, 3, 2, 1] >>> get_largest_k_elements([1, 2], 5) [2, 1, 2, 1, 2]","solution":"def get_largest_k_elements(nums, k): Returns the k largest distinct elements in descending order. If the number of distinct elements is less than k, it includes repeated elements to make the length of the result equal to k. if k <= 0 or len(nums) == 0: return [] # Get unique elements and sort them in descending order unique_elements = list(set(nums)) unique_elements.sort(reverse=True) if len(unique_elements) >= k: return unique_elements[:k] else: # If less unique elements than k, include repeated ones result = unique_elements[:] i = 0 while len(result) < k: result.append(unique_elements[i % len(unique_elements)]) i += 1 return result"},{"question":"def compress_ranges(lst): Takes a sorted list of integers and returns a string that represents the ranges of consecutive numbers. >>> compress_ranges([0, 1, 2, 4, 5, 7]) \\"0-2,4-5,7\\" >>> compress_ranges([1, 2, 3, 6, 7, 9]) \\"1-3,6-7,9\\" >>> compress_ranges([3, 4, 5, 8, 10, 11, 12]) \\"3-5,8,10-12\\" >>> compress_ranges([1]) \\"1\\" >>> compress_ranges([]) \\"\\" from solution import compress_ranges def test_compress_ranges_non_consecutive(): assert compress_ranges([0, 1, 2, 4, 5, 7]) == \\"0-2,4-5,7\\" def test_compress_ranges_with_single_consecutive(): assert compress_ranges([1, 2, 3, 6, 7, 9]) == \\"1-3,6-7,9\\" def test_compress_ranges_with_multiple_ranges(): assert compress_ranges([3, 4, 5, 8, 10, 11, 12]) == \\"3-5,8,10-12\\" def test_compress_ranges_single_element(): assert compress_ranges([1]) == \\"1\\" def test_compress_ranges_empty_list(): assert compress_ranges([]) == \\"\\" def test_compress_ranges_no_consecutive(): assert compress_ranges([1, 3, 5, 7]) == \\"1,3,5,7\\" def test_compress_ranges_all_consecutive(): assert compress_ranges([1, 2, 3, 4, 5]) == \\"1-5\\"","solution":"def compress_ranges(lst): Takes a sorted list of integers and returns a string that represents the ranges of consecutive numbers. if not lst: return \\"\\" ranges = [] start = lst[0] end = start for num in lst[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = start if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return \\",\\".join(ranges)"},{"question":"def can_be_rearranged_to_palindrome(s: str) -> str: Returns \\"YES\\" if the string can be rearranged into a palindrome, otherwise \\"NO\\". >>> can_be_rearranged_to_palindrome(\\"civic\\") 'YES' >>> can_be_rearranged_to_palindrome(\\"ivicc\\") 'YES' >>> can_be_rearranged_to_palindrome(\\"hello\\") 'NO'","solution":"def can_be_rearranged_to_palindrome(s): Returns \\"YES\\" if the string can be rearranged into a palindrome, otherwise \\"NO\\". from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Count the number of characters with odd occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd count if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_trees(width: int, height: int) -> int: Calculate the maximum number of trees that can be planted at the intersections of grid lines in a field of given width and height. >>> max_trees(4, 3) 20 >>> max_trees(2, 2) 9 >>> max_trees(5, 1) 12","solution":"def max_trees(width: int, height: int) -> int: Returns the maximum number of trees Farmer Joe can plant at the intersections of grid lines in a field of given width and height. return (width + 1) * (height + 1)"},{"question":"def categorize_projects(T: int, cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int, int]]: Categorize the projects based on their completion times into different priority levels. - High Priority: Projects completed in less than or equal to 10 days. - Medium Priority: Projects completed between 11 and 20 days. - Low Priority: Projects completed in more than 20 days. Args: T: Number of test cases. cases: List of test cases, each containing the number of projects and their completion times. Returns: List of tuples representing the count of high priority, medium priority, and low priority projects for each test case. >>> categorize_projects(2, [(5, [5, 12, 7, 25, 30]), (4, [15, 10, 20, 3])]) [(2, 1, 2), (2, 2, 0)] >>> categorize_projects(1, [(3, [1, 2, 10])]) [(3, 0, 0)] >>> categorize_projects(1, [(3, [21, 30, 100])]) [(0, 0, 3)] from typing import List, Tuple def categorize_projects(T: int, cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int, int]]: # Your solution here","solution":"def categorize_projects(T, cases): results = [] for case in cases: N, times = case high_priority = sum(1 for t in times if t <= 10) medium_priority = sum(1 for t in times if 11 <= t <= 20) low_priority = sum(1 for t in times if t > 20) results.append((high_priority, medium_priority, low_priority)) return results"},{"question":"def next_palindrome(n: int) -> int: Returns the smallest palindrome number that is greater than n. >>> next_palindrome(123) 131 >>> next_palindrome(808) 818 >>> next_palindrome(999) 1001","solution":"def next_palindrome(n): Returns the smallest palindrome number that is greater than n. def is_palindrome(num): return str(num) == str(num)[::-1] next_num = n + 1 while not is_palindrome(next_num): next_num += 1 return next_num"},{"question":"from typing import List def is_palindrome(S: str) -> bool: Returns True if the string S is a palindrome considering only alphanumeric characters and ignoring case sensitivity. Returns False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"Able was I ere I saw Elba\\") == True","solution":"def is_palindrome(S): Returns True if the string S is a palindrome considering only alphanumeric characters and ignoring case sensitivity. Returns False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in S if char.isalnum()] # Check if filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List def min_containers(boxes: List[int], capacity: int) -> int: Write a function that takes an array of positive integers representing the widths of boxes. The function should return the smallest number of containers required to hold all the boxes given that each container can hold boxes with a total width up to a specified limit. Args: boxes (List[int]): An array of positive integers where each integer represents the width of a box. capacity (int): An integer representing the maximum capacity that a container can hold in terms of width. Returns: int: The minimum number of containers required to hold all the given boxes. Examples: >>> min_containers([3, 8, 2, 5, 4], 10) 3 >>> min_containers([10, 10, 10], 10) 3 >>> min_containers([], 10) 0 pass","solution":"from typing import List def min_containers(boxes: List[int], capacity: int) -> int: Returns the smallest number of containers required to hold all the boxes given the capacity of each container. boxes.sort(reverse=True) containers = 0 while boxes: container_capacity = capacity i = 0 while i < len(boxes): if boxes[i] <= container_capacity: container_capacity -= boxes.pop(i) else: i += 1 containers += 1 return containers"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(10) False def sum_of_primes(numbers: List[int]) -> int: Complete the function that takes a list of integers as input and returns the sum of the numbers that are prime. >>> sum_of_primes([10, 11, 12, 13, 14, 15]) 24 >>> sum_of_primes([2, 3, 4, 5, 6, 7, 8, 9]) 17","solution":"def is_prime(n): if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def sum_of_primes(numbers): return sum(n for n in numbers if is_prime(n))"},{"question":"def snake_game(commands): Simulates a simple version of the Snake game and returns the final coordinates of the snake's head. Parameters: - commands (list of str): List of commands dictating the snake's movement. Returns: - tuple (int, int): Final coordinates of the snake's head. >>> snake_game([\\"U\\", \\"U\\", \\"L\\", \\"D\\", \\"L\\"]) (-2, 1) >>> snake_game([\\"R\\", \\"R\\", \\"U\\", \\"L\\", \\"D\\", \\"D\\"]) (1, -1) >>> snake_game([]) (0, 0) >>> snake_game([\\"U\\", \\"U\\", \\"U\\", \\"U\\"]) (0, 4) >>> snake_game([\\"R\\", \\"U\\", \\"L\\", \\"D\\", \\"R\\", \\"U\\", \\"L\\", \\"D\\"]) (0, 0) >>> snake_game([\\"R\\"] * 50 + [\\"U\\"] * 50) (50, 50) >>> snake_game([\\"D\\", \\"D\\", \\"L\\", \\"L\\"]) (-2, -2)","solution":"def snake_game(commands): Simulates a simple version of the Snake game and returns the final coordinates of the snake's head. Parameters: - commands (list of str): List of commands dictating the snake's movement. Returns: - tuple (int, int): Final coordinates of the snake's head. x, y = 0, 0 # Starting position at (0, 0) for command in commands: if command == \\"U\\": y += 1 elif command == \\"D\\": y -= 1 elif command == \\"L\\": x -= 1 elif command == \\"R\\": x += 1 return (x, y)"},{"question":"def isNestedParentheses(s: str) -> bool: Checks whether a given string of parentheses is properly nested. Parameters: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is properly nested, False otherwise. Examples: >>> isNestedParentheses(\\"()\\") True >>> isNestedParentheses(\\"(())\\") True >>> isNestedParentheses(\\"(()))\\") False >>> isNestedParentheses(\\"(()\\") False >>> isNestedParentheses(\\"()()\\") True from solution import isNestedParentheses def test_properly_nested(): assert isNestedParentheses(\\"()\\") == True assert isNestedParentheses(\\"(())\\") == True assert isNestedParentheses(\\"()()\\") == True def test_improperly_nested(): assert isNestedParentheses(\\"(()))\\") == False assert isNestedParentheses(\\"(()\\") == False assert isNestedParentheses(\\")(\\") == False def test_empty_string(): assert isNestedParentheses(\\"\\") == True def test_single_parentheses(): assert isNestedParentheses(\\"(\\") == False assert isNestedParentheses(\\")\\") == False def test_long_properly_nested(): assert isNestedParentheses(\\"(((())))\\") == True assert isNestedParentheses(\\"(()()(()))\\") == True def test_long_improperly_nested(): assert isNestedParentheses(\\"(((()))\\") == False assert isNestedParentheses(\\"())(()\\") == False","solution":"def isNestedParentheses(s): Checks whether a given string of parentheses is properly nested. Parameters: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is properly nested, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def count_possible_ids(corrupted_id): Returns the number of possible valid IDs that could match the given corrupted ID. >>> count_possible_ids(\\"A*C\\") 26 >>> count_possible_ids(\\"***\\") 17576 >>> count_possible_ids(\\"AB**\\") 676 def main(test_cases): Returns a list of results for each test case of corrupted IDs. >>> main([\\"A*C\\", \\"***\\", \\"AB**\\"]) [26, 17576, 676] >>> main([\\"****\\", \\"ABC\\"]) [456976, 1]","solution":"def count_possible_ids(corrupted_id): Returns the number of possible valid IDs that could match the given corrupted ID. # Count the number of '*' in the corrupted ID star_count = corrupted_id.count('*') # Each '*' can be replaced by any of the 26 uppercase letters possible_ids = 26 ** star_count return possible_ids def main(test_cases): results = [] for corrupted_id in test_cases: results.append(count_possible_ids(corrupted_id)) return results"},{"question":"def can_bird_reach_end(heights: List[int]) -> str: Determines if a bird can fly through all the trees given the height constraints. The bird can only fly from one tree to another if the height difference is at most 2 units. Arguments: heights -- list of integers representing the heights of the trees. Returns: 'Reachable!' if the bird can reach the last tree, else 'Not Reachable!'. Examples: >>> can_bird_reach_end([3, 5, 6, 7, 4]) == 'Not Reachable!' >>> can_bird_reach_end([1, 2, 3, 2, 1]) == 'Reachable!' # Unit tests def test_reachable_case(): assert can_bird_reach_end([3, 5, 5, 6, 4]) == 'Reachable!' def test_not_reachable_case_1(): assert can_bird_reach_end([3, 5, 6, 7, 4]) == 'Not Reachable!' def test_not_reachable_case_2(): assert can_bird_reach_end([1, 4, 6]) == 'Not Reachable!' def test_short_list(): assert can_bird_reach_end([2, 3]) == 'Reachable!' def test_single_tree(): assert can_bird_reach_end([10]) == 'Reachable!' def test_reachable_with_negative_heights(): assert can_bird_reach_end([-1, 0, 1, 0, -1]) == 'Reachable!' def test_not_reachable_with_negative_heights(): assert can_bird_reach_end([0, -3, 0]) == 'Not Reachable!' def test_reachable_mixed_heights(): assert can_bird_reach_end([1, 2, 3, 2, 1]) == 'Reachable!' def test_edge_case_empty_list(): assert can_bird_reach_end([]) == 'Reachable!' def test_edge_case_2_elements_exceeds_limit(): assert can_bird_reach_end([1, 4]) == 'Not Reachable!'","solution":"def can_bird_reach_end(heights): Determines if a bird can fly through all the trees given the height constraints. The bird can only fly from one tree to another if the height difference is at most 2 units. Arguments: heights -- list of integers representing the heights of the trees. Returns: 'Reachable!' if the bird can reach the last tree, else 'Not Reachable!'. for i in range(len(heights) - 1): if abs(heights[i] - heights[i + 1]) > 2: return 'Not Reachable!' return 'Reachable!'"},{"question":"def is_robot_bounded(instructions: str) -> bool: Determines if the robot is bounded in a circle. :param instructions: str: The sequence of commands for the robot. :return: bool: True if the robot is bounded in a circle, otherwise False. >>> is_robot_bounded(\\"GGLLGG\\") == True >>> is_robot_bounded(\\"GGGG\\") == False >>> is_robot_bounded(\\"GLGLGLG\\") == True >>> is_robot_bounded(\\"GLGLG\\") == True >>> is_robot_bounded(\\"GGRRGGLL\\") == True >>> is_robot_bounded(\\"\\") == True >>> is_robot_bounded(\\"G\\") == False >>> is_robot_bounded(\\"GLLG\\") == True","solution":"def is_robot_bounded(instructions: str) -> bool: Determines if the robot is bounded in a circle. :param instructions: str: The sequence of commands for the robot. :return: bool: True if the robot is bounded in a circle, otherwise False. # Initial position and direction x, y = 0, 0 dx, dy = 0, 1 # Facing north (positive y direction) for command in instructions: if command == 'G': x, y = x + dx, y + dy elif command == 'L': dx, dy = -dy, dx # 90 degrees left turn elif command == 'R': dx, dy = dy, -dx # 90 degrees right turn # After one sequence of instructions, check position and direction return (x == 0 and y == 0) or (dx != 0 or dy != 1)"},{"question":"def smallest_prime_gap(N: int) -> int: Find the smallest prime gap in the first N prime numbers. >>> smallest_prime_gap(10) 1 >>> smallest_prime_gap(2) 1","solution":"import sympy def smallest_prime_gap(N): # Generate the first N prime numbers primes = list(sympy.primerange(1, sympy.prime(N + 1))) # Initialize the minimum gap with a large number min_gap = float('inf') # Calculate the minimum gap for i in range(1, N): min_gap = min(min_gap, primes[i] - primes[i-1]) return min_gap"},{"question":"def count_buildings_with_sunset_view(buildings: List[int]) -> int: Given an array of integers representing the heights of buildings in a line, determine how many buildings will be able to see the sunset without being in the shadow of any taller building to their left. :param buildings: List[int] :return: int >>> count_buildings_with_sunset_view([3, 7, 8, 3, 6]) 3 >>> count_buildings_with_sunset_view([10, 9, 8, 7, 6]) 1 >>> count_buildings_with_sunset_view([1, 2, 3, 4, 5]) 5 >>> count_buildings_with_sunset_view([5, 5, 5, 5, 5]) 1 >>> count_buildings_with_sunset_view([7]) 1","solution":"def count_buildings_with_sunset_view(buildings): Given an array of integers representing the heights of buildings in a line, determine how many buildings will be able to see the sunset without being in the shadow of any taller building to their left. :param buildings: List[int] :return: int count = 0 max_height = 0 for height in buildings: if height > max_height: count += 1 max_height = height return count"},{"question":"def max_score(cards: List[int]) -> int: Determine the maximum score Alice can achieve if both players play optimally. >>> max_score([1, 2, 9, 4]) 10 >>> max_score([4, 4, 4]) 8 >>> max_score([8, 15, 3, 7]) 22 >>> max_score([20]) 20 >>> max_score([1, 2, 3, 4, 5, 6]) 12 >>> max_score([10, 20, 30]) 40 from typing import List def test_max_score(): assert max_score([1, 2, 9, 4]) == 10 assert max_score([4, 4, 4]) == 8 assert max_score([8, 15, 3, 7]) == 22 assert max_score([20]) == 20 assert max_score([1, 2, 3, 4, 5, 6]) == 12 assert max_score([10, 20, 30]) == 40 if __name__ == \\"__main__\\": test_max_score() print(\\"All tests passed!\\")","solution":"def max_score(cards): n = len(cards) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = cards[i] for len_interval in range(2, n + 1): for i in range(n - len_interval + 1): j = i + len_interval - 1 dp[i][j] = max(cards[i] - dp[i + 1][j], cards[j] - dp[i][j - 1]) total_sum = sum(cards) max_alice_score = (total_sum + dp[0][n - 1]) // 2 return max_alice_score"},{"question":"def sort_and_reformat_dates(dates: list) -> list: Sorts a list of dates in the format \\"YYYY-MM-DD\\" from oldest to newest, and returns them reformatted to \\"DD-MM-YYYY\\". :param dates: List of strings representing dates in the \\"YYYY-MM-DD\\" format :return: List of strings representing sorted dates in the \\"DD-MM-YYYY\\" format >>> sort_and_reformat_dates([\\"2022-09-01\\", \\"2021-12-25\\", \\"2023-01-05\\"]) [\\"25-12-2021\\", \\"01-09-2022\\", \\"05-01-2023\\"] >>> sort_and_reformat_dates([\\"2021-01-01\\"]) [\\"01-01-2021\\"] >>> sort_and_reformat_dates([\\"2021-01-01\\", \\"2021-02-01\\", \\"2021-03-01\\"]) [\\"01-01-2021\\", \\"01-02-2021\\", \\"01-03-2021\\"] >>> sort_and_reformat_dates([\\"2022-12-01\\", \\"2022-01-01\\", \\"2022-07-01\\"]) [\\"01-01-2022\\", \\"01-07-2022\\", \\"01-12-2022\\"] >>> sort_and_reformat_dates([\\"2015-06-24\\", \\"1999-12-31\\", \\"2001-01-01\\", \\"2020-11-11\\"]) [\\"31-12-1999\\", \\"01-01-2001\\", \\"24-06-2015\\", \\"11-11-2020\\"]","solution":"def sort_and_reformat_dates(dates): Sorts a list of dates in the format \\"YYYY-MM-DD\\" from oldest to newest, and returns them reformatted to \\"DD-MM-YYYY\\". :param dates: List of strings representing dates in the \\"YYYY-MM-DD\\" format :return: List of strings representing sorted dates in the \\"DD-MM-YYYY\\" format # Sort the dates first in \\"YYYY-MM-DD\\" format sorted_dates = sorted(dates) # Reformat the dates to \\"DD-MM-YYYY\\" reformatted_dates = [date.split('-')[2] + '-' + date.split('-')[1] + '-' + date.split('-')[0] for date in sorted_dates] return reformatted_dates"},{"question":"def competition_results(results): Generate the competition leaderboard based on the performance of each competitor. Parameters: results (list of dict): A list of dictionaries containing competitor names, challenges, and points. Returns: list: Sorted list of dictionaries with competitor names and their total points. def test_competition_results_example1(): input_data = [ {'competitor': 'Alice', 'challenges': ['C1', 'C2'], 'points': [50, 75]}, {'competitor': 'Bob', 'challenges': ['C2', 'C3'], 'points': [75, 60]}, {'competitor': 'Charlie', 'challenges': ['C1', 'C2', 'C3'], 'points': [20, 35, 45]} ] expected_output = [ {'competitor': 'Bob', 'points': 135}, {'competitor': 'Alice', 'points': 125}, {'competitor': 'Charlie', 'points': 100} ] assert competition_results(input_data) == expected_output def test_competition_results_example2(): input_data = [ {'competitor': 'Dave', 'challenges': ['C1'], 'points': [80]}, {'competitor': 'Eve', 'challenges': ['C1', 'C2'], 'points': [50, 75]}, {'competitor': 'Frank', 'challenges': ['C2'], 'points': [75]} ] expected_output = [ {'competitor': 'Eve', 'points': 125}, {'competitor': 'Dave', 'points': 80}, {'competitor': 'Frank', 'points': 75} ] assert competition_results(input_data) == expected_output def test_competition_results_example3(): input_data = [ {'competitor': 'George', 'challenges': ['C1', 'C2'], 'points': [70, 30]}, {'competitor': 'Hannah', 'challenges': ['C3'], 'points': [90]}, {'competitor': 'Ian', 'challenges': ['C1', 'C3'], 'points': [60, 30]} ] expected_output = [ {'competitor': 'George', 'points': 100}, {'competitor': 'Hannah', 'points': 90}, {'competitor': 'Ian', 'points': 90} ] assert competition_results(input_data) == expected_output def test_competition_results_tie_break(): input_data = [ {'competitor': 'Anna', 'challenges': ['C1', 'C2'], 'points': [50, 50]}, {'competitor': 'Zara', 'challenges': ['C1', 'C2'], 'points': [50, 50]} ] expected_output = [ {'competitor': 'Anna', 'points': 100}, {'competitor': 'Zara', 'points': 100} ] assert competition_results(input_data) == expected_output def test_competition_results_empty(): input_data = [] expected_output = [] assert competition_results(input_data) == expected_output","solution":"def competition_results(results): Generate the competition leaderboard based on the performance of each competitor. Parameters: results (list of dict): A list of dictionaries containing competitor names, challenges, and points. Returns: list: Sorted list of dictionaries with competitor names and their total points. leaderboard = [] for result in results: total_points = sum(result['points']) leaderboard.append({'competitor': result['competitor'], 'points': total_points}) # Sort by total points in descending order, and alphabetically by name in case of a tie leaderboard.sort(key=lambda x: (-x['points'], x['competitor'])) return leaderboard"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Given a 2D grid, returns the minimum sum of a path from the top-left corner to the bottom-right corner. Only right and down movements are allowed. pass def minimum_path_sums(test_cases: List[List[List[int]]]) -> List[int]: Given multiple test cases represented as a list of 2D grids, returns a list of minimum sums of paths from the top-left corner to the bottom-right corner for each grid. pass # Example usage: # T = int(input()) # test_cases = [] # for _ in range(T): # n = int(input()) # grid = [list(map(int, input().split())) for _ in range(n)] # test_cases.append(grid) # # results = minimum_path_sums(test_cases) # for result in results: # print(result) # Unit Tests def test_single_case(): assert minimum_path_sums([[[1, 3, 1], [1, 5, 1], [4, 2, 1]]]) == [7] def test_multiple_cases(): assert minimum_path_sums([[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 2], [1, 1]]]) == [7, 3] def test_small_grid(): assert minimum_path_sums([[[1]]]) == [1] def test_larger_grid(): grid = [ [1, 3, 1, 2], [1, 5, 1, 0], [4, 2, 1, 3], [2, 4, 3, 1] ] assert minimum_path_sums([grid]) == [10] def test_zero_cost(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert minimum_path_sums([grid]) == [0]","solution":"import sys def min_path_sum(grid): Given a 2D grid, returns the minimum sum of a path from the top-left corner to the bottom-right corner. Only right and down movements are allowed. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1] def minimum_path_sums(test_cases): results = [] for grid in test_cases: results.append(min_path_sum(grid)) return results # Example usage: # T = int(input()) # test_cases = [] # for _ in range(T): # n = int(input()) # grid = [list(map(int, input().split())) for _ in range(n)] # test_cases.append(grid) # # results = minimum_path_sums(test_cases) # for result in results: # print(result)"},{"question":"def is_cyclic_permutation(s: str) -> bool: Determines if the given string s forms a cyclic permutation when its first character is moved to the end of the string. >>> is_cyclic_permutation(\\"abc\\") False >>> is_cyclic_permutation(\\"cab\\") False >>> is_cyclic_permutation(\\"aaa\\") True >>> is_cyclic_permutation(\\"a\\") True >>> is_cyclic_permutation(\\"ab\\") False >>> is_cyclic_permutation(\\"bb\\") True pass def check_cyclic_permutations(strings: List[str]) -> List[str]: Checks each string in a list of strings to see if it forms a cyclic permutation. Returns a list with \\"YES\\" or \\"NO\\" for each string. >>> check_cyclic_permutations([\\"abc\\", \\"cab\\", \\"aaa\\"]) [\\"NO\\", \\"NO\\", \\"YES\\"] >>> check_cyclic_permutations([\\"a\\", \\"ab\\", \\"bb\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_cyclic_permutations([\\"abcde\\", \\"aabb\\", \\"baba\\"]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> check_cyclic_permutations([\\"\\", \\"aaaa\\"]) [\\"YES\\", \\"YES\\"] pass","solution":"def is_cyclic_permutation(s): Determines if the given string s forms a cyclic permutation when its first character is moved to the end of the string. if len(s) <= 1: return True shifted_string = s[1:] + s[0] return shifted_string == s def check_cyclic_permutations(strings): Checks each string in a list of strings to see if it forms a cyclic permutation. Returns a list with \\"YES\\" or \\"NO\\" for each string. results = [] for s in strings: if is_cyclic_permutation(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_smallest_missing_id(resets: List[Tuple[int, List[int]]]) -> List[int]: Determine the smallest positive integer ID that is not present on the current client list after each reset. >>> find_smallest_missing_id([(5, [1, 2, 4, 5, 6]), (3, [7, 8, 9]), (0, [])]) [3, 1, 1] >>> find_smallest_missing_id([(0, [])]) [1] >>> find_smallest_missing_id([(3, [1, 2, 3])]) [4] >>> find_smallest_missing_id([(4, [4, 2, 3])]) [1] >>> find_smallest_missing_id([(1, [1])]) [2] >>> find_smallest_missing_id([(3, [4, 5, 6])]) [1]","solution":"def find_smallest_missing_id(resets): results = [] for reset in resets: N, clients = reset present = [False] * (N + 1) for client in clients: if 1 <= client <= N: present[client - 1] = True smallest_missing = N + 1 for i in range(N): if not present[i]: smallest_missing = i + 1 break results.append(smallest_missing) return results"},{"question":"def is_valid_license_plate(s: str) -> bool: Determines if the input string \`s\` is a valid license plate number. A valid license plate must: 1. Be exactly 7 characters long. 2. The first 3 characters must be uppercase English letters (A-Z). 3. The last 4 characters must be digits (0-9). :param s: str - input string :return: bool - True if valid license plate, False otherwise >>> is_valid_license_plate(\\"ABC1234\\") == True >>> is_valid_license_plate(\\"abc1234\\") == False >>> is_valid_license_plate(\\"ABCD123\\") == False >>> is_valid_license_plate(\\"ABC12A4\\") == False >>> is_valid_license_plate(\\"A1B2C34\\") == False # Write your code here","solution":"def is_valid_license_plate(s): Determines if the input string \`s\` is a valid license plate number. A valid license plate must: 1. Be exactly 7 characters long. 2. The first 3 characters must be uppercase English letters (A-Z). 3. The last 4 characters must be digits (0-9). :param s: str - input string :return: bool - True if valid license plate, False otherwise if len(s) != 7: return False if not s[:3].isupper(): return False if not s[:3].isalpha(): return False if not s[3:].isdigit(): return False return True"},{"question":"def character_frequency(s: str) -> dict: Returns a dictionary with the frequency of alphabetic characters in the string s. Ignores the case and non-alphabetic characters. >>> character_frequency(\\"Hello, World!\\") {\\"h\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\"w\\": 1, \\"r\\": 1, \\"d\\": 1} >>> character_frequency(\\"Python3.8\\") {\\"p\\": 1, \\"y\\": 1, \\"t\\": 1, \\"h\\": 1, \\"o\\": 1, \\"n\\": 1} >>> character_frequency(\\"C@#ar^01\\") {\\"c\\": 1, \\"a\\": 1, \\"r\\": 1} >>> character_frequency(\\"AaBbCc\\") {\\"a\\": 2, \\"b\\": 2, \\"c\\": 2} >>> character_frequency(\\"\\") {} >>> character_frequency(\\" \\") {} >>> character_frequency(\\"Paper\\") {\\"p\\": 2, \\"a\\": 1, \\"e\\": 1, \\"r\\": 1}","solution":"def character_frequency(s): Returns a dictionary with the frequency of alphabetic characters in the string s. Ignores the case and non-alphabetic characters. frequency = {} for char in s: if char.isalpha(): char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"from typing import List def can_partition_into_three_equal_sum_subsets(arr: List[int]) -> bool: Checks if a list of integers can be partitioned into three non-empty subsets such that the sum of the elements in each subset is the same. >>> can_partition_into_three_equal_sum_subsets([0, 2, 1, -1, -2, 3]) True >>> can_partition_into_three_equal_sum_subsets([1, 2, 3, 6]) False >>> can_partition_into_three_equal_sum_subsets([0, 0, 0, 0, 0, 0]) True >>> can_partition_into_three_equal_sum_subsets([3, 3, 3, 3, 3, 3]) True >>> can_partition_into_three_equal_sum_subsets([-1, -1, -1, 2, 2, -2]) False >>> can_partition_into_three_equal_sum_subsets([-1, -1, -1, 3, 3, 3]) True >>> can_partition_into_three_equal_sum_subsets([10000, 10000, -20000, 5000, 5000]) False >>> can_partition_into_three_equal_sum_subsets([1, 1, 1, 9997, 9997, 9997]) True","solution":"def can_partition_into_three_equal_sum_subsets(arr): Checks if a list of integers can be partitioned into three non-empty subsets such that the sum of the elements in each subset is the same. total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 def can_partition_recursive(start, k, current_sum, visited): if k == 1: return True if current_sum == target_sum: return can_partition_recursive(0, k - 1, 0, visited) for i in range(start, len(arr)): if not visited[i]: visited[i] = True if can_partition_recursive(i + 1, k, current_sum + arr[i], visited): return True visited[i] = False return False visited = [False] * len(arr) return can_partition_recursive(0, 3, 0, visited)"},{"question":"def run_length_encoding(input_string: str) -> str: Compresses the input string using run-length encoding. Args: input_string (str): The string to be compressed Returns: str: The compressed string >>> run_length_encoding(\\"aabccccaaa\\") == \\"a2b1c4a3\\" >>> run_length_encoding(\\"abc\\") == \\"a1b1c1\\" >>> run_length_encoding(\\"aabbcc\\") == \\"a2b2c2\\"","solution":"def run_length_encoding(input_string): Compresses the input string using run-length encoding. Args: input_string (str): The string to be compressed Returns: str: The compressed string if not input_string: return \\"\\" encoded_string = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_string.append(f\\"{previous_char}{count}\\") previous_char = char count = 1 # Append the last character and count encoded_string.append(f\\"{previous_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Write a function that accepts the root node of a binary tree and returns the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node, including the root node itself. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> maxDepth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> maxDepth(root) 3 >>> root = TreeNode(1) >>> maxDepth(root) 1 >>> root = None >>> maxDepth(root) 0","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def substring_repetition(s: str) -> int: Determines if the string s can be constructed by repeating a substring of it multiple times. Returns the length of the smallest such substring or -1 if no such substring exists. >>> substring_repetition(\\"ababab\\") == 2 >>> substring_repetition(\\"aaaa\\") == 1 >>> substring_repetition(\\"abcabcabc\\") == 3 >>> substring_repetition(\\"abcd\\") == -1","solution":"def substring_repetition(s): Determines if the string s can be constructed by repeating a substring of it multiple times. Returns the length of the smallest such substring or -1 if no such substring exists. n = len(s) if n == 1: return 1 # A single character string repeats itself. for length in range(1, n // 2 + 1): if n % length == 0: substring = s[:length] if substring * (n // length) == s: return length return -1"},{"question":"def title_to_number(s: str) -> int: Converts a column title as appears in an Excel sheet to its corresponding column number. :param s: str, the column title (e.g., \\"AB\\") :return: int, the column number (e.g., 28) >>> title_to_number(\\"A\\") == 1 >>> title_to_number(\\"AB\\") == 28 >>> title_to_number(\\"ZY\\") == 701","solution":"def title_to_number(s): Converts a column title as appears in an Excel sheet to its corresponding column number. :param s: str, the column title (e.g., \\"AB\\") :return: int, the column number (e.g., 28) result = 0 for i in range(len(s)): result = result * 26 + (ord(s[i]) - ord('A') + 1) return result"},{"question":"from typing import List def findDuplicates(numbers: List[int]) -> List[int]: Write a function named \`findDuplicates\` that takes a list of integers as input and returns a list of integers that are duplicates in the given list. The duplicates should be returned in the order they first appear in the input list. If there are no duplicates, the function should return an empty list. Examples: >>> findDuplicates([1, 2, 3, 3, 2, 1]) [3, 2, 1] >>> findDuplicates([1, 2, 3, 4, 5, 6]) [] >>> findDuplicates([1, 1, 2, 2, 3, 3, 4, 4]) [1, 2, 3, 4] >>> findDuplicates([5, 5, 5, 5, 5]) [5] Constraints: - The input list will contain at most 10^3 integers. - Each integer in the list will be between -10^6 and 10^6 inclusive. pass","solution":"from typing import List def findDuplicates(numbers: List[int]) -> List[int]: Returns a list of integers that are duplicates in the given list, in the order they first appear in the input list. seen = set() duplicates = set() result = [] for number in numbers: if number in seen: if number not in duplicates: duplicates.add(number) result.append(number) else: seen.add(number) return result"},{"question":"def flipMatrix(matrix: list[list[int]]) -> list[list[int]]: Flips the given matrix along its main diagonal. Parameters: matrix (list of list of int): A 2D list representing the matrix to be flipped. Returns: list of list of int: The matrix flipped along its main diagonal. >>> flipMatrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> flipMatrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> flipMatrix([[7]]) [[7]]","solution":"def flipMatrix(matrix): Flips the given matrix along its main diagonal. Parameters: matrix (list of list of int): A 2D list representing the matrix to be flipped. Returns: list of list of int: The matrix flipped along its main diagonal. rows = len(matrix) cols = len(matrix[0]) flipped_matrix = [[None] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): flipped_matrix[j][i] = matrix[i][j] return flipped_matrix"},{"question":"from typing import List, Tuple def max_sum_of_max_distances(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: This function takes a list of test cases where each test case is a tuple (D, M, distances). D is the number of days, M is the number of segments, and distances is a list of distances Anu can run each day. The function returns a list of results where each result is the maximal sum of the maximum distances from each segment for the corresponding test case. >>> max_sum_of_max_distances([(5, 2, [2, 3, 10, 1, 5])]) [15] >>> max_sum_of_max_distances([(1, 1, [100])]) [100] >>> max_sum_of_max_distances([(5, 2, [2, 3, 10, 1, 5]), (4, 2, [1, 2, 3, 4])]) [15, 7] >>> max_sum_of_max_distances([(1, 1, [1])]) [1] >>> max_sum_of_max_distances([(4, 2, [5, 5, 5, 5])]) [10] >>> max_sum_of_max_distances([(200, 100, [i for i in range(1, 201)])]) [sum(range(101,201))]","solution":"def max_sum_of_max_distances(test_cases): This function takes a list of test_cases where each test case is a tuple (D, M, distances) D is the number of days, M is the number of segments, and distances is a list of distances Anu can run each day. The function returns a list of results where each result is the maximal sum of the maximum distances from each segment for the corresponding test case. results = [] for D, M, distances in test_cases: # DP table where dp[i][j] represents the maximum sum of max distances for the first i days with j segments dp = [[-float('inf')] * (M + 1) for _ in range(D + 1)] dp[0][0] = 0 # base case: zero segments, zero days, sum is 0 for i in range(1, D + 1): for j in range(1, M + 1): max_in_segment = -float('inf') for k in range(i, 0, -1): max_in_segment = max(max_in_segment, distances[k - 1]) if dp[k - 1][j - 1] != -float('inf'): dp[i][j] = max(dp[i][j], dp[k - 1][j - 1] + max_in_segment) results.append(dp[D][M]) return results # Helper function for handling input and output def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): D = int(data[index]) M = int(data[index + 1]) distances = list(map(int, data[index + 2: index + 2 + D])) test_cases.append((D, M, distances)) index += 2 + D results = max_sum_of_max_distances(test_cases) for result in results: print(result)"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of elements in nums that add up to the target. Each pair is a tuple of two integers, sorted in ascending order. The output list is sorted based on the first element of the pairs. >>> find_pairs([2, 4, 3, 5, 7, 8, -1], 6) [(-1, 7), (2, 4), (3, 3)] >>> find_pairs([1, 2, 3, 4], 8) [] >>> find_pairs([1, 2, 3, 4, 3, 2, 1, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([-3, 3, -2, 2, -1, 1, 0], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs([0, 0, 0, 0], 0) [(0, 0)]","solution":"def find_pairs(nums, target): Finds all unique pairs of elements in nums that add up to the target. Each pair is a tuple of two integers, sorted in ascending order. The output list is sorted based on the first element of the pairs. nums.sort() pairs = set() seen = {} for num in nums: k = target - num if k in seen: pairs.add((min(num, k), max(num, k))) seen[num] = True return sorted(pairs)"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. >>> can_form_palindrome('civic') True >>> can_form_palindrome('ivicc') True >>> can_form_palindrome('hello') False >>> can_form_palindrome('aabb') True","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. Args: s (str): the input string Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def longest_increasing_streak(scores: List[int]) -> int: Returns the length of the longest streak of strictly increasing scores. >>> longest_increasing_streak([1, 2, 3, 2, 3, 4, 5]) 4 >>> longest_increasing_streak([5, 4, 3, 2, 1]) 1 >>> longest_increasing_streak([1, 1, 1, 1, 1]) 1 >>> longest_increasing_streak([1, 2, 3, 4, 5]) 5 >>> longest_increasing_streak([42]) 1 >>> longest_increasing_streak([10, 8, 6, 7, 8, 9, 3, 4]) 4 >>> longest_increasing_streak([]) 0 >>> longest_increasing_streak([1, 2, 1, 2, 1, 2, 1, 2]) 2 >>> longest_increasing_streak([1, 3, 1, 2, 1, 2, 3, 0, 1, 2, 3, 4, 5]) 6","solution":"def longest_increasing_streak(scores): Returns the length of the longest streak of strictly increasing scores. if not scores: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(scores)): if scores[i] > scores[i - 1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 1 return max_streak"},{"question":"def jump(nums: List[int]) -> int: Determines the minimum number of jumps to reach the end of the series from the start. Returns -1 if it is not possible to reach the end. >>> jump([2, 3, 1, 1, 4]) 2 >>> jump([3, 2, 1, 0, 4]) -1","solution":"def jump(nums): Determines the minimum number of jumps required to reach the end of the series. Returns -1 if it is not possible to reach the end. if len(nums) == 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= len(nums) - 1: return jumps return -1"},{"question":"def can_split_tiles(tiles: List[int]) -> bool: Determines if the list of tile lengths can be partitioned into two subsets with equal sum. >>> can_split_tiles([1, 2, 3, 4]) True >>> can_split_tiles([1, 1, 3, 6]) False >>> can_split_tiles([1, 5, 11, 5]) True >>> can_split_tiles([1, 2, 3, 5]) False","solution":"def can_split_tiles(tiles): Determines if the list of tile lengths can be partitioned into two subsets with equal sum. total_sum = sum(tiles) # If total sum is odd, it cannot be equally partitioned if total_sum % 2 != 0: return False target = total_sum // 2 n = len(tiles) # Initialize dp array dp = [False] * (target + 1) dp[0] = True for tile in tiles: for j in range(target, tile - 1, -1): dp[j] = dp[j] or dp[j - tile] return dp[target]"},{"question":"from collections import defaultdict, deque from typing import List, Tuple, Dict def solve_dag_queries(T: int, test_cases: List[Dict[str, Tuple]]): Solve the DAG queries as described in the input information. Args: - T: Number of test cases. - test_cases: List of dictionaries containing test case information. Each dictionary has: - NM: Tuple of two integers (N, M) representing the number of vertices and edges. - values: List of integers representing the initial values of the vertices. - edges: List of tuples representing the edges in the graph. - queries: List of integers representing the queries. Returns: - A list of strings, each containing space-separated integers representing the final values of the vertices for each test case. results = [] for t in range(T): N, M = test_cases[t]['NM'] values = test_cases[t]['values'] edges = test_cases[t]['edges'] queries = test_cases[t]['queries'] # Build the graph graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) def bfs_collect_values(v): queue = deque([v]) visited = set() total_sum = 0 while queue: node = queue.popleft() if node in visited: continue visited.add(node) total_sum += values[node - 1] # 1-indexed, so node-1 for 0-indexed values for pred in reverse_graph[node]: if pred not in visited: queue.append(pred) # Reset values of visited nodes to 0 for node in visited: values[node - 1] = 0 return total_sum for v in queries: _ = bfs_collect_values(v) results.append(\\" \\".join(map(str, values))) return results # Unit tests def test_case_1(): T = 1 test_cases = [ { \\"NM\\": (5, 4), \\"values\\": [1, 2, 3, 4, 5], \\"edges\\": [(1, 2), (1, 3), (3, 4), (4, 5)], \\"queries\\": [5, 3, 2] } ] results = solve_dag_queries(T, test_cases) assert results == [\\"0 0 0 0 0\\"] def test_case_2(): T = 1 test_cases = [ { \\"NM\\": (4, 3), \\"values\\": [10, 20, 30, 40], \\"edges\\": [(1, 2), (2, 3), (3, 4)], \\"queries\\": [4, 3, 2, 1] } ] results = solve_dag_queries(T, test_cases) assert results == [\\"0 0 0 0\\"] def test_case_3(): T = 1 test_cases = [ { \\"NM\\": (2, 1), \\"values\\": [5, 10], \\"edges\\": [(1, 2)], \\"queries\\": [2] } ] results = solve_dag_queries(T, test_cases) assert results == [\\"0 0\\"]","solution":"from collections import defaultdict, deque def solve_dag_queries(T, test_cases): results = [] for t in range(T): N, M = test_cases[t]['NM'] values = test_cases[t]['values'] edges = test_cases[t]['edges'] queries = test_cases[t]['queries'] # Build the graph graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) def bfs_collect_values(v): queue = deque([v]) visited = set() total_sum = 0 while queue: node = queue.popleft() if node in visited: continue visited.add(node) total_sum += values[node - 1] # 1-indexed, so node-1 for 0-indexed values for pred in reverse_graph[node]: if pred not in visited: queue.append(pred) # Reset values of visited nodes to 0 for node in visited: values[node - 1] = 0 return total_sum for v in queries: _ = bfs_collect_values(v) results.append(\\" \\".join(map(str, values))) return results # This function can be tested with the following \`main\` function. if __name__ == \\"__main__\\": T = 1 test_cases = [ { \\"NM\\": (5, 4), \\"values\\": [1, 2, 3, 4, 5], \\"edges\\": [(1, 2), (1, 3), (3, 4), (4, 5)], \\"queries\\": [5, 3, 2] } ] results = solve_dag_queries(T, test_cases) for result in results: print(result)"},{"question":"def effective_cameras(corridor_length: int, cameras: List[List[int]], intruders: List[int]) -> List[int]: This function determines which cameras are effective in detecting intruders passing by in a corridor. Args: - corridor_length (int): Length of the corridor. - cameras (list of list of int): Each sublist contains two integers, the first representing the position of the camera, and the second its range. - intruders (list of int): Positions of the intruders. Returns: - list of int: Indices of the cameras that successfully detect at least one intruder. >>> effective_cameras(10, [[3, 2], [6, 1]], [1, 4, 7, 8]) [0, 1] >>> effective_cameras(10, [[3, 2], [6, 1]], []) [] >>> effective_cameras(10, [[3, 2], [6, 1]], [8, 9, 10]) [] >>> effective_cameras(10, [[3, 4], [6, 3]], [1, 4, 7, 8]) [0, 1] >>> effective_cameras(10, [[5, 4]], [1, 3, 5, 7, 9]) [0] >>> effective_cameras(10, [[1, 1], [2, 1], [3, 1]], [2]) [0, 1, 2] pass","solution":"def effective_cameras(corridor_length, cameras, intruders): This function determines which cameras are effective in detecting intruders passing by in a corridor. Args: - corridor_length (int): Length of the corridor. - cameras (list of list of int): Each sublist contains two integers, the first representing the position of the camera, and the second its range. - intruders (list of int): Positions of the intruders. Returns: - list of int: Indices of the cameras that successfully detect at least one intruder. effective = [] for i, (cam_pos, cam_range) in enumerate(cameras): cam_range_start = max(0, cam_pos - cam_range) cam_range_end = min(corridor_length - 1, cam_pos + cam_range) for intruder in intruders: if cam_range_start <= intruder <= cam_range_end: effective.append(i) break return effective"},{"question":"def find_unique_employees(n: int, phase1_ids: List[int], m: int, phase2_ids: List[int]) -> List[int]: Finds the unique employee IDs who worked on exactly one of the two phases. >>> find_unique_employees(6, [1, 2, 3, 4, 5, 6], 5, [4, 5, 6, 7, 8]) [1, 2, 3, 7, 8] >>> find_unique_employees(3, [1, 2, 3], 3, [3, 4, 5]) [1, 2, 4, 5] >>> find_unique_employees(4, [10, 20, 30, 40], 4, [50, 60, 30, 10]) [20, 40, 50, 60] >>> find_unique_employees(0, [], 3, [1, 2, 3]) [1, 2, 3] >>> find_unique_employees(5, [6, 7, 8, 9, 10], 0, []) [6, 7, 8, 9, 10] >>> find_unique_employees(3, [100, 200, 300], 3, [400, 500, 600]) [100, 200, 300, 400, 500, 600] >>> find_unique_employees(2, [1, 1], 2, [2, 2]) [1, 2] >>> find_unique_employees(0, [], 0, []) []","solution":"def find_unique_employees(n, phase1_ids, m, phase2_ids): Finds the unique employee IDs who worked on exactly one of the two phases. Args: n : int : Number of employees who worked on the first phase. phase1_ids : list of int : Employee IDs for the first phase. m : int : Number of employees who worked on the second phase. phase2_ids : list of int : Employee IDs for the second phase. Returns: list of int : Sorted list of unique employee IDs who worked on only one of the two phases. set1 = set(phase1_ids) set2 = set(phase2_ids) sym_diff = set1.symmetric_difference(set2) return sorted(sym_diff)"},{"question":"from typing import List, Tuple def final_position(commands: List[str]) -> Tuple[int, int]: Computes the robot's final position after processing a list of commands. Parameters: commands (List[str]): List of command strings Returns: Tuple[int, int]: Final position of the robot >>> final_position([\\"U2\\"]) == (0, 2) >>> final_position([\\"D3\\"]) == (0, -3) >>> final_position([\\"L4\\"]) == (-4, 0) >>> final_position([\\"R5\\"]) == (5, 0) >>> final_position([\\"U2\\", \\"R1\\", \\"D3\\", \\"L4\\"]) == (-3, -1) >>> final_position([\\"R5\\", \\"U5\\"]) == (5, 5) >>> final_position([\\"U3\\", \\"D2\\", \\"L1\\", \\"R2\\"]) == (1, 1) >>> final_position([\\"R10\\", \\"R5\\"]) == (15, 0) >>> final_position([\\"U5\\", \\"R10\\", \\"D2\\", \\"L10\\", \\"U1\\"]) == (0, 4) # Complete the function to calculate the final position of the robot.","solution":"from typing import List, Tuple def final_position(commands: List[str]) -> Tuple[int, int]: Computes the robot's final position after processing a list of commands. Parameters: commands (List[str]): List of command strings Returns: Tuple[int, int]: Final position of the robot # Initial position at the origin x, y = 0, 0 # Process each command for command in commands: direction = command[0] steps = int(command[1:]) if direction == 'U': y += steps elif direction == 'D': y -= steps elif direction == 'L': x -= steps elif direction == 'R': x += steps return (x, y)"},{"question":"def time_difference(start_time: str, end_time: str) -> str: Returns the difference between two time points in hours and minutes. The times are given in 24-hour format (hh:mm). >>> time_difference(\\"18:30\\", \\"20:45\\") \\"2 hours and 15 minutes\\" >>> time_difference(\\"22:15\\", \\"01:00\\") \\"2 hours and 45 minutes\\" >>> time_difference(\\"08:00\\", \\"08:00\\") \\"0 hours and 0 minutes\\" >>> time_difference(\\"23:50\\", \\"00:20\\") \\"0 hours and 30 minutes\\" from solution import time_difference def test_times_on_same_day(): assert time_difference(\\"18:30\\", \\"20:45\\") == \\"2 hours and 15 minutes\\" assert time_difference(\\"08:00\\", \\"08:00\\") == \\"0 hours and 0 minutes\\" assert time_difference(\\"09:15\\", \\"10:45\\") == \\"1 hours and 30 minutes\\" assert time_difference(\\"15:30\\", \\"16:00\\") == \\"0 hours and 30 minutes\\" def test_times_across_two_days(): assert time_difference(\\"22:15\\", \\"01:00\\") == \\"2 hours and 45 minutes\\" assert time_difference(\\"23:50\\", \\"00:20\\") == \\"0 hours and 30 minutes\\" assert time_difference(\\"23:00\\", \\"05:30\\") == \\"6 hours and 30 minutes\\" assert time_difference(\\"23:59\\", \\"00:01\\") == \\"0 hours and 2 minutes\\" def test_random_times(): assert time_difference(\\"21:30\\", \\"00:00\\") == \\"2 hours and 30 minutes\\" assert time_difference(\\"12:45\\", \\"14:30\\") == \\"1 hours and 45 minutes\\" assert time_difference(\\"00:00\\", \\"23:59\\") == \\"23 hours and 59 minutes\\" assert time_difference(\\"23:00\\", \\"23:01\\") == \\"0 hours and 1 minutes\\"","solution":"def time_difference(start_time, end_time): Returns the difference between two time points in hours and minutes. The times are given in 24-hour format (hh:mm). start_hours, start_minutes = map(int, start_time.split(':')) end_hours, end_minutes = map(int, end_time.split(':')) # Convert start and end times to minutes since midnight start_total_minutes = start_hours * 60 + start_minutes end_total_minutes = end_hours * 60 + end_minutes # Calculate the difference in minutes if end_total_minutes >= start_total_minutes: difference_minutes = end_total_minutes - start_total_minutes else: # If end time is on the next day difference_minutes = (24 * 60 - start_total_minutes) + end_total_minutes hours = difference_minutes // 60 minutes = difference_minutes % 60 return f\\"{hours} hours and {minutes} minutes\\""},{"question":"def filter_people_above_age(people: List[Tuple[str, int]], threshold_age: int) -> List[str]: Filters out and returns a list of names of people who are above the given threshold age. :param people: List of tuples containing (name, age) :param threshold_age: Age threshold to filter people :return: List of names of people who are above the threshold age >>> filter_people_above_age([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 35), (\\"David\\", 28)], 29) [\\"Alice\\", \\"Charlie\\"] >>> filter_people_above_age([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 35), (\\"David\\", 28)], 30) [\\"Charlie\\"] >>> filter_people_above_age([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 35), (\\"David\\", 28)], 35) [] >>> filter_people_above_age([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 35), (\\"David\\", 28)], 10) [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] >>> filter_people_above_age([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 35)], 25) [\\"Alice\\", \\"Charlie\\"]","solution":"def filter_people_above_age(people, threshold_age): Filters out and returns a list of names of people who are above the given threshold age. :param people: List of tuples containing (name, age) :param threshold_age: Age threshold to filter people :return: List of names of people who are above the threshold age return [name for name, age in people if age > threshold_age]"},{"question":"def rotate_matrix(matrix): Rotates a given n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): 2D list representing the square matrix. Returns: list of list of int: 2D list representing the rotated matrix. >>> rotate_matrix([[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], ... [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix([[1]]) [[1]]","solution":"def rotate_matrix(matrix): Rotates a given n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): 2D list representing the square matrix. Returns: list of list of int: 2D list representing the rotated matrix. n = len(matrix) # Create a new matrix of the same size rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def cyclic_shift(lst, k): Shifts the list cyclically by k positions. If k is positive, shifts to the right. If k is negative, shifts to the left. >>> cyclic_shift([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> cyclic_shift([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> cyclic_shift([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> cyclic_shift([], 3) []","solution":"def cyclic_shift(lst, k): Shifts the list cyclically by k positions. If k is positive, shifts to the right. If k is negative, shifts to the left. if not lst: return [] n = len(lst) k = k % n # To handle larger k values and negative k values efficiently return lst[-k:] + lst[:-k]"},{"question":"def find_coffee_times(n: int, m: int, coffee_times: List[Tuple[int, int]], arrival_times: List[int]) -> List[int]: Determine the time at which Polycarp will buy his coffee. >>> find_coffee_times(3, 5, [(1, 4), (5, 8), (2, 6)], [3, 1, 5, 6, 7]) [3, 1, 5, 6, 7] >>> find_coffee_times(2, 3, [(2, 5), (7, 9)], [1, 6, 7]) [2, 7, 7] >>> find_coffee_times(3, 2, [(0, 2), (3, 4), (5, 7)], [1, 3]) [1, 3] >>> find_coffee_times(1, 1, [(10, 20)], [5]) [10] >>> find_coffee_times(4, 3, [(1, 3), (5, 7), (8, 11), (13, 15)], [4, 9, 14]) [5, 9, 14]","solution":"def find_coffee_times(n, m, coffee_times, arrival_times): result = [] for arrival in arrival_times: best_time = None for s, e in coffee_times: if s <= arrival <= e: best_time = arrival break elif arrival < s: if best_time is None or s < best_time: best_time = s result.append(best_time) return result"},{"question":"def fibonacci_sequence(n: int) -> list: Returns an array containing the first \`n\` Fibonacci numbers. >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def powers_of_2_sequence(n: int) -> list: Returns an array containing the first \`n\` powers of 2. >>> powers_of_2_sequence(0) [] >>> powers_of_2_sequence(1) [1] >>> powers_of_2_sequence(5) [1, 2, 4, 8, 16] >>> powers_of_2_sequence(10) [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] def arithmetic_progression_sequence(n: int, a: int, d: int) -> list: Returns an array containing an arithmetic progression with \`n\` terms, starting from \`a\` with a common difference \`d\`. >>> arithmetic_progression_sequence(0, 1, 2) [] >>> arithmetic_progression_sequence(1, 1, 2) [1] >>> arithmetic_progression_sequence(5, 1, 2) [1, 3, 5, 7, 9] >>> arithmetic_progression_sequence(5, 0, 0) [0, 0, 0, 0, 0] >>> arithmetic_progression_sequence(5, -1, 2) [-1, 1, 3, 5, 7] def factorial_sequence(n: int) -> list: Returns an array containing the factorials of numbers from \`1\` to \`n\`. >>> factorial_sequence(0) [] >>> factorial_sequence(1) [1] >>> factorial_sequence(5) [1, 2, 6, 24, 120] >>> factorial_sequence(6) [1, 2, 6, 24, 120, 720]","solution":"def fibonacci_sequence(n): Returns an array containing the first n Fibonacci numbers. if n <= 0: return [] sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence[:n] def powers_of_2_sequence(n): Returns an array containing the first n powers of 2. return [2**i for i in range(n)] def arithmetic_progression_sequence(n, a, d): Returns an array containing an arithmetic progression with n terms, starting from a with a common difference d. return [a + i * d for i in range(n)] def factorial_sequence(n): Returns an array containing the factorials of numbers from 1 to n. def factorial(num): if num == 0 or num == 1: return 1 return num * factorial(num - 1) return [factorial(i) for i in range(1, n + 1)]"},{"question":"def expand_range(numbers: str) -> list: Takes a string representation of a range of numbers and returns a list of all the numbers expanded out. Parameters: numbers (str): A string with numbers and ranges separated by commas, for example: \\"1-3,5,7-9\\" Returns: list: A list of all the numbers expanded out Examples: >>> expand_range(\\"1-3,5,7-9\\") [1, 2, 3, 5, 7, 8, 9] >>> expand_range(\\"10-12,15,18-20\\") [10, 11, 12, 15, 18, 19, 20] >>> expand_range(\\"4,6-8,10\\") [4, 6, 7, 8, 10] >>> expand_range(\\"\\") []","solution":"def expand_range(numbers): Takes a string representation of a range of numbers and returns a list of all the numbers expanded out. Parameters: numbers (str): A string with numbers and ranges separated by commas, for example: \\"1-3,5,7-9\\" Returns: list: A list of all the numbers expanded out if not numbers: return [] result = [] for part in numbers.split(','): if '-' in part: start, end = map(int, part.split('-')) result.extend(range(start, end + 1)) else: result.append(int(part)) return result"},{"question":"def flatten(nested_list): Recursively flattens a nested list of integers. Args: nested_list (list): A list which may contain other nested lists of integers. Returns: list: A flat list containing all the integers from the nested list, preserving the order. >>> flatten([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten([[[1, 2], 3], [4, [5, [6]]]]) [1, 2, 3, 4, 5, 6] >>> flatten([]) [] >>> flatten([[]]) [] >>> flatten([[], [1, 2, []], 3, [], [], [4, 5, [6]]]) [1, 2, 3, 4, 5, 6] >>> flatten([[], [[]], [[], []]]) [] >>> flatten([1, [2, [3, 4], [5, [6, 7]], 8]]) [1, 2, 3, 4, 5, 6, 7, 8]","solution":"def flatten(nested_list): Recursively flattens a nested list of integers. Args: nested_list (list): A list which may contain other nested lists of integers. Returns: list: A flat list containing all the integers from the nested list, preserving the order. flat_list = [] for item in nested_list: if isinstance(item, list): flat_list.extend(flatten(item)) else: flat_list.append(item) return flat_list"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. Parameters: s (str): The input string of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" from solution import can_form_palindrome def test_palindrome_possible_even_length(): assert can_form_palindrome(\\"aabb\\") == \\"YES\\" def test_palindrome_possible_odd_length(): assert can_form_palindrome(\\"aabbc\\") == \\"YES\\" def test_palindrome_not_possible(): assert can_form_palindrome(\\"abc\\") == \\"NO\\" def test_palindrome_single_character(): assert can_form_palindrome(\\"a\\") == \\"YES\\" def test_palindrome_all_same_characters(): assert can_form_palindrome(\\"aaaa\\") == \\"YES\\" def test_palindrome_empty_string(): assert can_form_palindrome(\\"\\") == \\"YES\\"","solution":"from collections import Counter def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def all_unique_characters(input: str) -> bool: Determines if all characters in a given string are unique. It's case-sensitive. Args: input: A string to be evaluated. Returns: bool: True if all characters are unique, False otherwise. pass # Implement the function here def test_all_unique_characters(): assert all_unique_characters(\\"abcdef\\") == True, \\"Test case 1 failed\\" assert all_unique_characters(\\"aA\\") == True, \\"Test case 2 failed\\" assert all_unique_characters(\\"abac\\") == False, \\"Test case 3 failed\\" assert all_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\") == True, \\"Test case 4 failed\\" assert all_unique_characters(\\"abcdefghijklmnopqrstuvwxyza\\") == False, \\"Test case 5 failed\\" assert all_unique_characters(\\"1234567890\\") == True, \\"Test case 6 failed\\" assert all_unique_characters(\\"12345678901\\") == False, \\"Test case 7 failed\\" assert all_unique_characters(\\"!@#%^&*()\\") == True, \\"Test case 8 failed\\" assert all_unique_characters(\\"!@#%^&*()(\\") == False, \\"Test case 9 failed\\" # Running the tests test_all_unique_characters()","solution":"def all_unique_characters(input: str) -> bool: Determines if all characters in a given string are unique. It's case-sensitive. Args: input: A string to be evaluated. Returns: bool: True if all characters are unique, False otherwise. return len(set(input)) == len(input)"},{"question":"def split_array(nums: List[int], p: int) -> int: Given an array of integers \`nums\` and an integer \`p\`, divide the array into p non-empty continuous subarrays such that the maximum sum of any subarray is minimized. Return the minimized largest sum among the p subarrays. >>> split_array([7, 2, 5, 10, 8], 2) 18 >>> split_array([1, 2, 3, 4, 5], 2) 9 >>> split_array([1, 4, 4], 3) 4 pass","solution":"def split_array(nums, p): def can_split(mid): current_sum = 0 count = 1 for num in nums: current_sum += num if current_sum > mid: current_sum = num count += 1 if count > p: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the count of palindromic substrings in the given string \`s\`. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 def test_count_palindromic_substrings_example1(): assert count_palindromic_substrings(\\"abba\\") == 6 def test_count_palindromic_substrings_example2(): assert count_palindromic_substrings(\\"abc\\") == 3 def test_count_palindromic_substrings_single_character(): assert count_palindromic_substrings(\\"a\\") == 1 def test_count_palindromic_substrings_all_same(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_count_palindromic_substrings_mixed_characters(): assert count_palindromic_substrings(\\"racecar\\") == 10 def test_count_palindromic_substrings_no_palindromes(): assert count_palindromic_substrings(\\"abcd\\") == 4","solution":"def count_palindromic_substrings(s): Returns the count of palindromic substrings in the given string \`s\`. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return count"},{"question":"from typing import List def form_sentences(wordList: List[str], N: int) -> List[str]: Returns all possible sensible sentences consisting of exactly N words. >>> form_sentences([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"], 2) [\\"brown fox\\", \\"brown quick\\", \\"brown the\\", \\"fox quick\\", \\"fox the\\", \\"quick the\\"] >>> form_sentences([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"], 1) [\\"brown\\", \\"fox\\", \\"quick\\", \\"the\\"] pass","solution":"from itertools import permutations from typing import List def form_sentences(wordList: List[str], N: int) -> List[str]: Returns all possible sensible sentences consisting of exactly N words. if N > len(wordList) or N == 0: return [] # Generate all permutations of wordList with N elements sentences = [' '.join(sentence) for sentence in permutations(wordList, N)] # Sort the sentences lexicographically sentences.sort() return sentences"},{"question":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def find_path(root, target): Returns the path from the root to the target node as a list. If the target node is not found, return an empty list. >>> tree = BinaryTree(Node(1, Node(2, Node(4), Node(5)), Node(3))) >>> find_path(tree.root, 5) [1, 2, 5] >>> find_path(tree.root, 3) [1, 3] >>> find_path(tree.root, 8) [] >>> tree_empty = BinaryTree() >>> find_path(tree_empty.root, 1) [] >>> tree_single = BinaryTree(Node(1)) >>> find_path(tree_single.root, 1) [1] >>> find_path(tree_single.root, 2) []","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def find_path(root, target): Returns the path from root to the target node as a list. If the target node is not found, return an empty list. def path_finder(node, target, path): if not node: return False # Add current node to the path path.append(node.value) # Check if this is the target node if node.value == target: return True # Otherwise, check both subtrees if (node.left and path_finder(node.left, target, path)) or (node.right and path_finder(node.right, target, path)): return True # If not present in either subtree, remove the node from path path.pop() return False path = [] if path_finder(root, target, path): return path else: return [] # Example usage # tree = BinaryTree(Node(1, Node(2, Node(4), Node(5)), Node(3))) # print(find_path(tree.root, 5)) # Output: [1, 2, 5]"},{"question":"def convert_to_minutes(time_str): Helper function to convert time 'HH:MM' to minutes since midnight. hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes def schedule_meeting(meetings, new_meeting): Determines if a new meeting can be scheduled without conflicting existing meetings. Parameters: meetings (list of tuple): List of existing meetings with start and end times in 'HH:MM' format. new_meeting (tuple): New meeting's start and end time in 'HH:MM' format. Returns: bool: True if the new meeting can be scheduled without conflicts, False otherwise. pass # Test cases def test_non_overlapping_meeting(): meetings = [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"13:00\\", \\"14:00\\")] new_meeting = (\\"10:00\\", \\"11:00\\") assert schedule_meeting(meetings, new_meeting) == True def test_overlapping_meeting(): meetings = [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"13:00\\", \\"14:00\\")] new_meeting = (\\"10:30\\", \\"11:30\\") assert schedule_meeting(meetings, new_meeting) == False def test_meeting_fits_between(): meetings = [(\\"09:00\\", \\"10:00\\"), (\\"12:00\\", \\"13:00\\")] new_meeting = (\\"10:00\\", \\"12:00\\") assert schedule_meeting(meetings, new_meeting) == True def test_meeting_starting_early_and_ending_later(): meetings = [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")] new_meeting = (\\"08:00\\", \\"09:30\\") assert schedule_meeting(meetings, new_meeting) == False def test_adjacent_meetings(): meetings = [(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")] new_meeting = (\\"11:00\\", \\"12:00\\") assert schedule_meeting(meetings, new_meeting) == True def test_empty_schedule(): meetings = [] new_meeting = (\\"10:00\\", \\"11:00\\") assert schedule_meeting(meetings, new_meeting) == True","solution":"def convert_to_minutes(time_str): Helper function to convert time 'HH:MM' to minutes since midnight. hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes def schedule_meeting(meetings, new_meeting): Determines if a new meeting can be scheduled without conflicting existing meetings. Parameters: meetings (list of tuple): List of existing meetings with start and end times in 'HH:MM' format. new_meeting (tuple): New meeting's start and end time in 'HH:MM' format. Returns: bool: True if the new meeting can be scheduled without conflicts, False otherwise. new_start, new_end = map(convert_to_minutes, new_meeting) for meeting in meetings: start, end = map(convert_to_minutes, meeting) # Check for overlap if not (new_end <= start or new_start >= end): return False return True"},{"question":"def compute_student_averages(students): Returns a dictionary with student names as keys and their average score as values. Averages are rounded to 2 decimal places. Args: students (list): A list of dictionaries, each containing a student's name and their scores. Returns: dict: A dictionary with student names as keys and their average score as values. >>> compute_student_averages([{\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 85, \\"art\\": 88}, {\\"name\\": \\"Bob\\", \\"math\\": 78, \\"science\\": 82, \\"art\\": 79}]) {\\"Alice\\": 87.67, \\"Bob\\": 79.67} >>> compute_student_averages([{\\"name\\": \\"Charlie\\", \\"math\\": 85, \\"science\\": 90, \\"art\\": 92}]) {\\"Charlie\\": 89.0}","solution":"def compute_student_averages(students): Returns a dictionary with student names as keys and their average score as values. Averages are rounded to 2 decimal places. Args: students (list): A list of dictionaries, each containing a student's name and their scores. Returns: dict: A dictionary with student names as keys and their average score as values. averages = {} for student in students: name = student.pop(\\"name\\") scores = student.values() average_score = round(sum(scores) / len(scores), 2) averages[name] = average_score return averages"},{"question":"def can_form_palindrome(s: str) -> str: Given a string, check if it can be rearranged to form a palindrome. >>> can_form_palindrome(\\"carrace\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): from collections import Counter char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def extract_primes(numbers: List[int]) -> List[int]: Given a list of integers, identify and return a new list containing only the prime numbers from the original list. Prime numbers are numbers greater than 1 that have no divisors other than 1 and themselves. >>> extract_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> extract_primes([2, 3, 5, 7, 11, 13, 17, 19]) [2, 3, 5, 7, 11, 13, 17, 19] >>> extract_primes([1, 4, 6, 8, 10, 12, 14, 15, 16, 18]) [] >>> extract_primes([]) [] >>> extract_primes([-10, -3, -2, 0, 1, 13, 17, 19]) [13, 17, 19]","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def extract_primes(numbers: List[int]) -> List[int]: Function to extract prime numbers from a list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def group_by_odd_even(numbers): Groups a list of integers into odd and even numbers, and sorts each group in descending order. Parameters: numbers (list[int]): A list of integers. Returns: dict: A dictionary with keys 'odd' and 'even', each containing a list of integers sorted in descending order. >>> group_by_odd_even([6, 3, 2, 5, 7, 10, 14, 13, 9]) {'odd': [13, 9, 7, 5, 3], 'even': [14, 10, 6, 2]} >>> group_by_odd_even([1, 3, 5, 7, 9]) {'odd': [9, 7, 5, 3, 1], 'even': []} >>> group_by_odd_even([2, 4, 6, 8, 10]) {'odd': [], 'even': [10, 8, 6, 4, 2]} >>> group_by_odd_even([7, 14, 3, 18, 1]) {'odd': [7, 3, 1], 'even': [18, 14]} >>> group_by_odd_even([]) {'odd': [], 'even': []} >>> group_by_odd_even([3]) {'odd': [3], 'even': []} >>> group_by_odd_even([4]) {'odd': [], 'even': [4]}","solution":"def group_by_odd_even(numbers): Groups a list of integers into odd and even numbers, and sorts each group in descending order. Parameters: numbers (list[int]): A list of integers. Returns: dict: A dictionary with keys 'odd' and 'even', each containing a list of integers sorted in descending order. odd_numbers = sorted([num for num in numbers if num % 2 != 0], reverse=True) even_numbers = sorted([num for num in numbers if num % 2 == 0], reverse=True) return {'odd': odd_numbers, 'even': even_numbers}"},{"question":"def judge_circle(moves: str) -> bool: Determine if the robot returns to the origin after completing its moves. Parameters: moves (str): A sequence of moves with 'R', 'L', 'U', 'D'. Returns: bool: True if the robot returns to the origin, False otherwise. >>> judge_circle(\\"UD\\") True >>> judge_circle(\\"LL\\") False","solution":"def judge_circle(moves): Determine if the robot returns to the origin after completing its moves. Parameters: moves (str): A sequence of moves with 'R', 'L', 'U', 'D'. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 # Initialize starting coordinates at the origin (0, 0) for move in moves: if move == 'R': x += 1 elif move == 'L': x -= 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"import re def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other, ignoring case, spaces, and special characters. >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"Hello\\", \\"World\\") False","solution":"import re def are_anagrams(str1, str2): Determines if two strings are anagrams of each other, ignoring case, spaces, and special characters. # Remove non-alphanumeric characters and convert to lowercase str1_clean = re.sub(r'[^A-Za-z0-9]', '', str1).lower() str2_clean = re.sub(r'[^A-Za-z0-9]', '', str2).lower() # Check if the sorted characters of both cleaned strings are the same return sorted(str1_clean) == sorted(str2_clean)"},{"question":"from typing import List def shortestBridge(grid: List[List[int]]) -> int: Given a 2D integer grid representing land (1) and water (0), find the length of the shortest bridge connecting two separate islands. >>> shortestBridge([ ... [0,1,0,0,0], ... [0,1,0,1,1], ... [0,0,0,0,0], ... [0,0,0,0,0], ... [0,0,0,0,1] ... ]) == 1 >>> shortestBridge([ ... [1,0,0,1], ... [0,0,0,0], ... [0,0,1,0], ... [1,0,0,0] ... ]) == 2 import pytest def test_shortest_bridge_example1(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1] ] assert shortestBridge(grid) == 1 def test_shortest_bridge_example2(): grid = [ [1, 0, 0, 1], [0, 0, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0] ] assert shortestBridge(grid) == 2 def test_shortest_bridge_same_island(): grid = [[1, 1], [1, 1]] assert shortestBridge(grid) == -1 # Invalid case since there is only one island def test_shortest_bridge_edge_case(): grid = [ [1, 0], [0, 1] ] assert shortestBridge(grid) == 1 def test_shortest_bridge_larger_grid(): grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 1] ] assert shortestBridge(grid) == 2","solution":"from collections import deque def shortestBridge(grid): def get_island(): for r in range(R): for c in range(C): if grid[r][c] == 1: return (r, c) def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() for dr, dc in directions: new_row, new_col = row + dr, col + dc if (0 <= new_row < R and 0 <= new_col < C and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited): visited.add((new_row, new_col)) stack.append((new_row, new_col)) return visited R, C = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Find one island using DFS start_r, start_c = get_island() visited = set([(start_r, start_c)]) island = dfs(start_r, start_c) # Change the island bits to \\"2\\" to mark them for r, c in island: grid[r][c] = 2 # BFS Queue with all island coordinates queue = deque([(r, c, 0) for r, c in island]) while queue: row, col, distance = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < R and 0 <= new_col < C: if grid[new_row][new_col] == 1: return distance if grid[new_row][new_col] == 0: grid[new_row][new_col] = 2 queue.append((new_row, new_col, distance + 1)) return -1 # Should never reach here due to problem constraints"},{"question":"def is_anagram(s: str, t: str) -> bool: Given two strings \`s\` and \`t\`, return true if \`t\` is an anagram of \`s\`, and false otherwise. >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False from solution import is_anagram def test_is_anagram_true(): assert is_anagram(\\"anagram\\", \\"nagaram\\") == True def test_is_anagram_false(): assert is_anagram(\\"rat\\", \\"car\\") == False def test_is_anagram_different_lengths(): assert is_anagram(\\"a\\", \\"ab\\") == False def test_is_anagram_empty_strings(): assert is_anagram(\\"\\", \\"\\") == True def test_is_anagram_single_characters(): assert is_anagram(\\"a\\", \\"a\\") == True assert is_anagram(\\"a\\", \\"b\\") == False def test_is_anagram_different_counts(): assert is_anagram(\\"aabbcc\\", \\"abcabc\\") == True assert is_anagram(\\"aabbcc\\", \\"aabbc\\") == False","solution":"def is_anagram(s, t): Returns true if t is an anagram of s, else returns false. if len(s) != len(t): return False # Create frequency counts for both strings char_count_s = {} char_count_t = {} for char in s: char_count_s[char] = char_count_s.get(char, 0) + 1 for char in t: char_count_t[char] = char_count_t.get(char, 0) + 1 return char_count_s == char_count_t"},{"question":"def min_moves_to_sort(arr: List[int]) -> int: Determine the minimum number of moves required to sort the array in non-decreasing order by reversing any subarray any number of times. >>> min_moves_to_sort([3, 1, 2, 4]) 1 >>> min_moves_to_sort([1, 2, 3, 4]) 0 >>> min_moves_to_sort([5, 4, 3, 2, 1]) 1 >>> min_moves_to_sort([1, 3, 2, 4, 5]) 1 >>> min_moves_to_sort([1, 3, 3, 2, 4, 5]) 1 >>> min_moves_to_sort([1]) 0 >>> min_moves_to_sort([1, 2]) 0 >>> min_moves_to_sort([2, 1]) 1 >>> min_moves_to_sort([1, 5, 3, 4, 2, 6, 7, 8]) 1","solution":"def min_moves_to_sort(arr): Returns the minimum number of moves required to sort the array in non-decreasing order by reversing any subarray any number of times. n = len(arr) sorted_arr = sorted(arr) # Two pointers to find the bounds of the longest unsorted subarray left = 0 while left < n and arr[left] == sorted_arr[left]: left += 1 right = n - 1 while right >= 0 and arr[right] == sorted_arr[right]: right -= 1 if left >= right: return 0 return 1"},{"question":"from typing import List def magic_subsequence(arr: List[int], k: int) -> List[int]: Find the longest subsequence where the absolute difference between any two consecutive elements is exactly equal to k. Parameters: arr (List[int]): The input list of integers. k (int): The required absolute difference between consecutive elements. Returns: List[int]: The longest magic subsequence with the given property. pass # Example Test Cases def test_case_1(): assert magic_subsequence([1, 5, 9, 2, 6, 10], 4) == [1, 5, 9] def test_case_2(): assert magic_subsequence([10, 14, 18, 7, 11, 15], 4) == [10, 14, 18] def test_case_3(): assert magic_subsequence([1, 2, 3, 4, 5], 1) == [1, 2, 3, 4, 5] def test_case_4(): assert magic_subsequence([1, 2, 3, 4, 7, 10], 3) == [1, 4, 7, 10] def test_case_5(): assert magic_subsequence([1, 3, 5, 7, 9], 2) == [1, 3, 5, 7, 9] def test_case_6(): assert magic_subsequence([], 4) == [] def test_case_7(): assert magic_subsequence([1, 1, 1, 1, 1], 0) == [1, 1, 1, 1, 1] def test_case_8(): assert magic_subsequence([10], 4) == [10] def test_case_9(): assert magic_subsequence([1, 6, 11, 16, 21], 5) == [1, 6, 11, 16, 21] def test_case_10(): assert magic_subsequence([10, 20, 30, 40, 50, 60], 10) == [10, 20, 30, 40, 50, 60] # Run tests test_case_1() test_case_2() test_case_3() test_case_4() test_case_5() test_case_6() test_case_7() test_case_8() test_case_9() test_case_10()","solution":"def magic_subsequence(arr, k): Find the longest subsequence where the absolute difference between any two consecutive elements is exactly equal to k. Parameters: arr (List[int]): The input list of integers. k (int): The required absolute difference between consecutive elements. Returns: List[int]: The longest magic subsequence with the given property. n = len(arr) if n == 1: return arr # dp[i] will store the longest subsequence ending at index i. dp = [[] for _ in range(n)] for i in range(n): dp[i] = [arr[i]] # Find the longest subsequence for each element for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) == k and len(dp[j]) + 1 > len(dp[i]): dp[i] = dp[j] + [arr[i]] # Find the maximum length subsequence max_subseq = [] for subseq in dp: if len(subseq) > len(max_subseq): max_subseq = subseq return max_subseq"},{"question":"def compare_revisions(revision1: str, revision2: str) -> int: Compares two revision strings and returns: -1 if revision1 is before revision2, 0 if they are the same, 1 if revision1 is after revision2. >>> compare_revisions(\\"R1v2\\", \\"R1v1\\") 1 >>> compare_revisions(\\"R2v0\\", \\"R2v1\\") -1 >>> compare_revisions(\\"R3v4\\", \\"R3v4\\") 0 >>> compare_revisions(\\"R4v0\\", \\"R3v5\\") 1 >>> compare_revisions(\\"R10v2\\", \\"R10v1\\") 1 >>> compare_revisions(\\"R01v002\\", \\"R1v2\\") 0 >>> compare_revisions(\\"R01v002\\", \\"R1v03\\") -1 >>> compare_revisions(\\"R02v003\\", \\"R02v002\\") 1 >>> compare_revisions(\\"R01v010\\", \\"R01v001\\") 1","solution":"def compare_revisions(revision1, revision2): Compares two revision strings and returns: -1 if revision1 is before revision2, 0 if they are the same, 1 if revision1 is after revision2. # Split the revisions into their respective parts revision1_parts = revision1.split('v') revision2_parts = revision2.split('v') # Extract the main revision and sub-revision numbers main_revision1 = int(revision1_parts[0][1:]) main_revision2 = int(revision2_parts[0][1:]) sub_revision1 = int(revision1_parts[1]) sub_revision2 = int(revision2_parts[1]) # Compare main revisions if main_revision1 < main_revision2: return -1 elif main_revision1 > main_revision2: return 1 else: # Compare sub-revisions if sub_revision1 < sub_revision2: return -1 elif sub_revision1 > sub_revision2: return 1 else: return 0"},{"question":"def sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]: Sorts each row of the matrix in ascending order and then sorts the rows of the resulting matrix based on the sum of elements in each row, in ascending order. >>> sort_matrix_rows([ ... [34, 2, 1], ... [4, 56, 23], ... [12, 34, 23] ... ]) [[1, 2, 34], [12, 23, 34], [4, 23, 56]] >>> sort_matrix_rows([[34, 2, 1]]) [[1, 2, 34]] >>> sort_matrix_rows([[1, 2, 3], [3, 2, 1]]) [[1, 2, 3], [1, 2, 3]] >>> sort_matrix_rows([[1, 2, 3], [1, 2, 3], [1, 1, 1]]) [[1, 1, 1], [1, 2, 3], [1, 2, 3]] >>> sort_matrix_rows([[1000, 2000, 3000], [1000, 1000, 1000], [3000, 1000, 2000]]) [[1000, 1000, 1000], [1000, 2000, 3000], [1000, 2000, 3000]] >>> sort_matrix_rows([[-1, -2, -3], [1, 2, 3], [-4, -5, -6]]) [[-6, -5, -4], [-3, -2, -1], [1, 2, 3]] >>> sort_matrix_rows([[3, 0, -1], [1, 2, 3], [0, -2, -3]]) [[-3, -2, 0], [-1, 0, 3], [1, 2, 3]]","solution":"def sort_matrix_rows(matrix): Sorts each row of the matrix in ascending order and then sorts the rows of the resulting matrix based on the sum of elements in each row, in ascending order. # Step 1: Sort each row individually sorted_rows = [sorted(row) for row in matrix] # Step 2: Sort the rows based on the sum of each row sorted_rows.sort(key=sum) return sorted_rows"},{"question":"def max_books_to_read(case_count, cases): Given the number of test cases, and the details of each case, determines the maximum number of books Alex can choose to read within his rating preferences and the given constraints. Args: case_count: int - Number of test cases. cases: List[Tuple[Tuple[int, int], Tuple[int, int], List[int]]] - Input data for each test case. Returns: List[int] - Maximum number of books Alex can read for each test case. >>> raw_input = '''2 ... 5 3 ... 2 4 ... 1 2 3 3 5 ... 6 4 ... 1 5 ... 1 1 1 2 5 5 ... ''' >>> case_count, cases = process_input(raw_input) >>> max_books_to_read(case_count, cases) [3, 4] >>> raw_input = '''1 ... 7 5 ... 1 3 ... 1 2 3 3 2 3 1 ... ''' >>> case_count, cases = process_input(raw_input) >>> max_books_to_read(case_count, cases) [5] >>> raw_input = '''1 ... 4 3 ... 3 4 ... 1 1 1 1 ... ''' >>> case_count, cases = process_input(raw_input) >>> max_books_to_read(case_count, cases) [0] >>> raw_input = '''1 ... 1 1 ... 1 1 ... 1 ... ''' >>> case_count, cases = process_input(raw_input) >>> max_books_to_read(case_count, cases) [1] >>> raw_input = '''1 ... 10 7 ... 1 5 ... 2 2 3 4 5 1 5 5 5 3 ... ''' >>> case_count, cases = process_input(raw_input) >>> max_books_to_read(case_count, cases) [7]","solution":"def max_books_to_read(case_count, cases): results = [] for i in range(case_count): N, M = cases[i][0] L, U = cases[i][1] ratings = cases[i][2] # Filter ratings within the threshold L to U valid_books = [rating for rating in ratings if L <= rating <= U] # The maximum number of books Alex can read is the minimum of the valid books count and the limit M results.append(min(len(valid_books), M)) return results def process_input(raw_input): data = raw_input.strip().split('n') case_count = int(data[0]) cases = [] index = 1 for _ in range(case_count): N, M = map(int, data[index].split()) L, U = map(int, data[index + 1].split()) ratings = list(map(int, data[index + 2].split())) cases.append([(N, M), (L, U), ratings]) index += 3 return case_count, cases"},{"question":"from typing import List def unique_element_occurrences(lst: List[int]) -> bool: Returns True if the number of occurrences of each element in the list is unique. Otherwise, returns False. >>> unique_element_occurrences([1, 2, 2, 1, 1, 3]) True >>> unique_element_occurrences([1, 2]) False >>> unique_element_occurrences([-3, -3, -3, 7, 7]) True pass # Your implementation goes here","solution":"from collections import Counter def unique_element_occurrences(lst): Returns True if the number of occurrences of each element in the list is unique. Otherwise, returns False. count = Counter(lst) freq = list(count.values()) return len(set(freq)) == len(freq)"},{"question":"from typing import List, Optional def average_in_range(numbers: List[int]) -> Optional[float]: Returns the average of the numbers that are in the range 10 to 20 (inclusive). If no numbers are in this range, return None. >>> average_in_range([4, 15, 23, 12, 7, 11]) 12.666666666666666 >>> average_in_range([1, 5, 6]) None pass # Unit Test def test_average_in_range(): assert average_in_range([1, 5, 6]) == None assert average_in_range([4, 15, 23, 12, 7, 11]) == 12.666666666666666 assert average_in_range([10, 11, 20, 15]) == 14.0 assert average_in_range([9, 10, 13, 22, 18]) == 13.666666666666666 assert average_in_range([14]) == 14 assert average_in_range([5]) == None assert average_in_range([]) == None","solution":"def average_in_range(numbers): Returns the average of the numbers that are in the range 10 to 20 (inclusive). If no numbers are in this range, return None. in_range = [num for num in numbers if 10 <= num <= 20] if not in_range: return None return sum(in_range) / len(in_range)"},{"question":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merge two sorted lists into a new sorted list in non-decreasing order. >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([1, 4, 7], [2, 3, 5, 6]) == [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_arrays([1, 3, 5], [1, 2, 5, 6]) == [1, 1, 2, 3, 5, 5, 6] >>> merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_arrays([4, 5, 6], []) == [4, 5, 6] >>> merge_sorted_arrays([], []) == [] >>> merge_sorted_arrays([-3, -1, 0, 1], [-2, 2, 3]) == [-3, -2, -1, 0, 1, 2, 3] >>> merge_sorted_arrays([1000000], [-1000000, 0]) == [-1000000, 0, 1000000]","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted lists into a new sorted list in non-decreasing order. Parameters: arr1 (list[int]): First sorted list. arr2 (list[int]): Second sorted list. Returns: list[int]: A new list containing all elements from arr1 and arr2, sorted. merged_array = [] i, j = 0, 0 # Use two pointers to merge the arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"class VendingMachine: def __init__(self, inventory): self.inventory = inventory self.current_item = None self.current_inserted = 0 self.valid_coins = {1, 5, 10, 25, 50, 100} def select_item(self, item_name): Choose an item to purchase. Returns a message indicating selection and price, or an error if the item is not available. pass def insert_coin(self, coin): Insert a coin into the vending machine. Returns a message indicating the total amount inserted so far, or an error if the coin is invalid. pass def vend(self): Dispense the selected item if enough money has been inserted, return the remaining change, or an error if insufficient money has been provided. pass def restock(self, items): Restock the vending machine with additional items and quantities. Returns a summary of the items restocked. pass def cancel(self): Cancel the transaction and return any inserted money. pass # Unit tests def setup_vm(): inventory = { 'soda': {'price': 125, 'quantity': 5}, 'chips': {'price': 50, 'quantity': 10}, 'candy': {'price': 65, 'quantity': 20} } return VendingMachine(inventory) def test_select_item(): vm = setup_vm() assert vm.select_item('soda') == \\"Soda selected. Price: 125 cents.\\" assert vm.select_item('water') == \\"Item not available.\\" def test_insert_coin(): vm = setup_vm() assert vm.insert_coin(100) == \\"Inserted 100 cents, total inserted so far: 100 cents.\\" assert vm.insert_coin(3) == \\"Invalid coin.\\" def test_vend_sufficient_funds(): vm = setup_vm() vm.select_item('soda') vm.insert_coin(100) vm.insert_coin(25) assert vm.vend() == \\"Vending item. No change.\\" def test_vend_insufficient_funds(): vm = setup_vm() vm.select_item('soda') vm.insert_coin(100) assert vm.vend() == \\"Insufficient funds. Please insert 25 more cents.\\" def test_vend_with_change(): vm = setup_vm() vm.select_item('chips') vm.insert_coin(25) vm.insert_coin(50) assert vm.vend() == \\"Vending item. Returning 25 cents.\\" def test_restock(): vm = setup_vm() restock_items = { 'soda': {'quantity': 2}, 'water': {'price': 60, 'quantity': 10} } assert vm.restock(restock_items) == \\"Inventory restocked.\\" assert vm.inventory['soda']['quantity'] == 7 assert vm.inventory['water']['quantity'] == 10 assert vm.inventory['water']['price'] == 60 def test_cancel_transaction(): vm = setup_vm() vm.select_item('candy') vm.insert_coin(25) assert vm.cancel() == \\"Transaction canceled. Returned 25 cents.\\"","solution":"class VendingMachine: def __init__(self, inventory): self.inventory = inventory self.current_item = None self.current_inserted = 0 self.valid_coins = {1, 5, 10, 25, 50, 100} def select_item(self, item_name): if item_name in self.inventory and self.inventory[item_name]['quantity'] > 0: self.current_item = item_name price = self.inventory[item_name]['price'] return f\\"{item_name.title()} selected. Price: {price} cents.\\" else: return \\"Item not available.\\" def insert_coin(self, coin): if coin in self.valid_coins: self.current_inserted += coin return f\\"Inserted {coin} cents, total inserted so far: {self.current_inserted} cents.\\" else: return \\"Invalid coin.\\" def vend(self): if self.current_item is None: return \\"No item selected.\\" item_price = self.inventory[self.current_item]['price'] if self.current_inserted < item_price: return f\\"Insufficient funds. Please insert {item_price - self.current_inserted} more cents.\\" self.inventory[self.current_item]['quantity'] -= 1 change = self.current_inserted - item_price self.current_item = None self.current_inserted = 0 if change == 0: return \\"Vending item. No change.\\" else: return f\\"Vending item. Returning {change} cents.\\" def restock(self, items): for item, details in items.items(): if item in self.inventory: self.inventory[item]['quantity'] += details['quantity'] else: self.inventory[item] = details return \\"Inventory restocked.\\" def cancel(self): change = self.current_inserted self.current_item = None self.current_inserted = 0 return f\\"Transaction canceled. Returned {change} cents.\\""},{"question":"class UserManager: Manage the set of currently active users and provide real-time notifications whenever users enter or leave the system. >>> manager = UserManager() >>> manager.add_user(\\"user1\\") >>> manager.add_user(\\"user2\\") >>> manager.get_active_users() == {\\"user1\\", \\"user2\\"} True >>> manager.remove_user(\\"user1\\") >>> manager.get_active_users() == {\\"user2\\"} True def __init__(self): # Your initialization here def add_user(self, user_id): # Your code here def remove_user(self, user_id): # Your code here def get_active_users(self): # Your code here # Unit Tests def test_add_user(): manager = UserManager() manager.add_user(\\"user1\\") assert \\"user1\\" in manager.get_active_users() def test_remove_user(): manager = UserManager() manager.add_user(\\"user1\\") manager.add_user(\\"user2\\") manager.remove_user(\\"user1\\") assert \\"user1\\" not in manager.get_active_users() assert \\"user2\\" in manager.get_active_users() def test_get_active_users(): manager = UserManager() assert manager.get_active_users() == set() manager.add_user(\\"user1\\") manager.add_user(\\"user2\\") assert manager.get_active_users() == {\\"user1\\", \\"user2\\"} def test_add_same_user_multiple_times(): manager = UserManager() manager.add_user(\\"user1\\") manager.add_user(\\"user1\\") assert manager.get_active_users() == {\\"user1\\"} def test_remove_user_not_present(): manager = UserManager() manager.add_user(\\"user1\\") manager.add_user(\\"user2\\") manager.remove_user(\\"user2\\") try: manager.remove_user(\\"user2\\") except KeyError: pass # Expected, as \\"user2\\" was already removed assert \\"user1\\" in manager.get_active_users() assert \\"user2\\" not in manager.get_active_users()","solution":"class UserManager: def __init__(self): self.active_users = set() def add_user(self, user_id): self.active_users.add(user_id) def remove_user(self, user_id): self.active_users.remove(user_id) def get_active_users(self): return self.active_users"},{"question":"def zigzag_sequence(num: int) -> str: Write a function that takes an integer \`num\` and returns a string representing a zigzag sequence of that length. >>> zigzag_sequence(5) \\"1 2 1 2 1\\" >>> zigzag_sequence(8) \\"1 2 1 2 3 4 3 4\\" >>> zigzag_sequence(1) \\"1\\"","solution":"def zigzag_sequence(num): Returns a string representing a zigzag sequence of the given length. sequence = [] peak = 1 up = True for _ in range(num): sequence.append(str(peak)) if up: peak += 1 else: peak -= 1 if peak == 1: up = True elif peak == 2 and up == True: up = False return ' '.join(sequence)"},{"question":"def next_term(term: str) -> str: Generates the next term in the look-and-say sequence given the current term. >>> next_term(\\"1\\") == \\"11\\" >>> next_term(\\"11\\") == \\"21\\" >>> next_term(\\"21\\") == \\"1211\\" >>> next_term(\\"1211\\") == \\"111221\\" pass def look_and_say(n: int) -> str: Returns the first n terms of the look-and-say sequence as a comma-separated string. >>> look_and_say(1) == \\"1\\" >>> look_and_say(2) == \\"1, 11\\" >>> look_and_say(3) == \\"1, 11, 21\\" >>> look_and_say(5) == \\"1, 11, 21, 1211, 111221\\" >>> look_and_say(-1) == \\"\\" >>> look_and_say(0) == \\"\\" >>> look_and_say(\\"a\\") == \\"\\" >>> look_and_say(None) == \\"\\" pass","solution":"def next_term(term): Generates the next term in the look-and-say sequence given the current term. Args: term (str): the current term of the sequence. Returns: str: the next term of the sequence. result = [] i = 0 while i < len(term): count = 1 while i + 1 < len(term) and term[i] == term[i + 1]: i += 1 count += 1 result.append(f\\"{count}{term[i]}\\") i += 1 return ''.join(result) def look_and_say(n): Returns the first n terms of the look-and-say sequence as a comma-separated string. Args: n (int): the number of terms to generate. Returns: str: the first n terms of the look-and-say sequence. if not isinstance(n, int) or n <= 0: return \\"\\" terms = [\\"1\\"] for _ in range(1, n): terms.append(next_term(terms[-1])) return ', '.join(terms)"},{"question":"from typing import List, Tuple from collections import deque def longest_delivery_time(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the maximum delivery time between any two cities in a tree. Args: n (int): The number of cities. edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a road between two cities. Returns: int: The maximum number of roads in the shortest path between any two cities. >>> longest_delivery_time(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> longest_delivery_time(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> longest_delivery_time(6, [(1, 2), (1, 3), (2, 4), (4, 5), (4, 6)]) 4 >>> longest_delivery_time(2, [(1, 2)]) 1 >>> longest_delivery_time(3, [(1, 2), (2, 3)]) 2","solution":"from collections import deque def longest_delivery_time(n, edges): def bfs(start): dist = [-1] * (n + 1) dist[start] = 0 queue = deque([start]) farthest_node = start max_distance = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if dist[neighbor] == -1: dist[neighbor] = dist[node] + 1 queue.append(neighbor) if dist[neighbor] > max_distance: max_distance = dist[neighbor] farthest_node = neighbor return farthest_node, max_distance graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) node_a, _ = bfs(1) # BFS from an arbitrary node (let's pick node 1) node_b, diameter = bfs(node_a) # BFS from the farthest node found (node_a) return diameter"},{"question":"def rotate_string(s: str, n: int) -> str: Returns a new string with the characters of s rotated to the right by n positions. The rotation is circular, characters shifted off the end reappear at the beginning. >>> rotate_string(\\"abcdef\\", 2) \\"efabcd\\" >>> rotate_string(\\"abcdef\\", 8) \\"efabcd\\" >>> rotate_string(\\"\\", 3) \\"\\" >>> rotate_string(\\"abcdef\\", 0) \\"abcdef\\" >>> rotate_string(\\"abcdef\\", 6) \\"abcdef\\" >>> rotate_string(\\"abcdef\\", -2) \\"cdefab\\" >>> rotate_string(\\"a\\", 5) \\"a\\"","solution":"def rotate_string(s, n): Returns the string s rotated to the right by n positions. if not s: return s n = n % len(s) # Normalize n to be within the length of s return s[-n:] + s[:-n]"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns the list of merged intervals. Parameters: intervals (List[List[int]]): A list of intervals where each interval is a list of two integers. Returns: List[List[int]]: A list of merged intervals in ascending order of starting times. Example: >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] >>> merge_intervals([[1,4],[0,2],[3,5]]) [[0,5]] pass def test_merge_intervals_example_1(): assert merge_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1, 6], [8, 10], [15, 18]] def test_merge_intervals_example_2(): assert merge_intervals([[1,4],[4,5]]) == [[1, 5]] def test_merge_intervals_example_3(): assert merge_intervals([[1,4],[0,2],[3,5]]) == [[0, 5]] def test_merge_intervals_no_overlap(): assert merge_intervals([[1,2],[3,4],[5,6]]) == [[1, 2], [3, 4], [5, 6]] def test_merge_intervals_all_overlap(): assert merge_intervals([[1,5],[2,6],[3,7]]) == [[1, 7]] def test_merge_intervals_single_element(): assert merge_intervals([[1,5]]) == [[1, 5]] def test_merge_intervals_empty_input(): assert merge_intervals([]) == [] def test_merge_intervals_same_intervals(): assert merge_intervals([[2,3],[2,3]]) == [[2, 3]] def test_merge_intervals_nested_intervals(): assert merge_intervals([[1,10],[2,5],[3,4]]) == [[1, 10]]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals. Parameters: intervals (List[List[int]]): A list of intervals where each interval is a list of two integers. Returns: List[List[int]]: A list of merged intervals in ascending order of starting times. if not intervals: return [] # Sort intervals by the starting times intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the last merged one, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: # No overlap, just append the current interval merged.append(current) return merged"},{"question":"def assign_tshirt_numbers(p: int, u: int, used_numbers: List[int]) -> List[int]: Determine the number printed on the T-shirt that each new participant will receive. Args: p (int): Number of participants in the contest. u (int): Number of used T-shirt numbers. used_numbers (List[int]): List of already used T-shirt numbers. Returns: List[int]: List of T-shirt numbers assigned to new participants. Example: >>> assign_tshirt_numbers(5, 3, [3, 7, 5]) [1, 2, 4, 6, 8] >>> assign_tshirt_numbers(3, 0, []) [1, 2, 3] >>> assign_tshirt_numbers(5, 5, [1, 2, 3, 4, 5]) [6, 7, 8, 9, 10] >>> assign_tshirt_numbers(3, 3, [1, 2, 4]) [3, 5, 6] >>> assign_tshirt_numbers(3, 3, [999999997, 999999998, 999999999]) [1, 2, 3]","solution":"def assign_tshirt_numbers(p, u, used_numbers): used_set = set(used_numbers) tshirt_numbers = [] current_number = 1 for _ in range(p): while current_number in used_set: current_number += 1 tshirt_numbers.append(current_number) current_number += 1 return tshirt_numbers"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def top_view(root: Optional[TreeNode]) -> List[int]: Given a binary tree, return the top view of the binary tree. The top view of a binary tree is the set of nodes visible when the tree is viewed from the top. Nodes are sorted by their horizontal distance from the root. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> top_view(root) [4, 2, 1, 3, 7] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> top_view(root) [4, 3, 2, 1] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> top_view(root) [1, 2, 3, 4] >>> root = TreeNode(1) >>> top_view(root) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.right.right = TreeNode(5) >>> root.left.right.right.right = TreeNode(6) >>> root.right = TreeNode(3) >>> top_view(root) [2, 1, 3, 6] pass","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def top_view(root: Optional[TreeNode]) -> List[int]: if not root: return [] # Queue to store nodes along with their horizontal distance queue = deque([(root, 0)]) # Dictionary to store the first node at each horizontal distance top_view_map = {} min_hd = max_hd = 0 while queue: node, hd = queue.popleft() if hd not in top_view_map: top_view_map[hd] = node.val if node.left: queue.append((node.left, hd - 1)) min_hd = min(min_hd, hd - 1) if node.right: queue.append((node.right, hd + 1)) max_hd = max(max_hd, hd + 1) return [top_view_map[hd] for hd in range(min_hd, max_hd + 1)]"},{"question":"import re def isAnagramPair(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams, False otherwise. >>> isAnagramPair(\\"Astronomer\\", \\"Moon starer\\") True >>> isAnagramPair(\\"Hi there\\", \\"Bye there\\") False >>> isAnagramPair(\\"Listen\\", \\"Silent\\") True >>> isAnagramPair(\\"A gentleman\\", \\"Elegant man!\\") True","solution":"import re def isAnagramPair(str1, str2): Returns True if str1 and str2 are anagrams, False otherwise. # Remove spaces and punctuation, and lower the cases of both strings cleaned_str1 = re.sub(r'[^A-Za-z0-9]', '', str1).lower() cleaned_str2 = re.sub(r'[^A-Za-z0-9]', '', str2).lower() # Return comparison of sorted characters return sorted(cleaned_str1) == sorted(cleaned_str2)"},{"question":"def pascals_triangle(n: int) -> list: Write a function that takes an integer \`n\`(0 ≤ n ≤ 12) and returns an array representing the first \`n\` rows of Pascal's Triangle. >>> pascals_triangle(5) [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] >>> pascals_triangle(3) [ [1], [1, 1], [1, 2, 1] ] >>> pascals_triangle(0) []","solution":"def pascals_triangle(n): Returns the first n rows of Pascal's Triangle. if n == 0: return [] triangle = [[1]] for i in range(1, n): prev_row = triangle[-1] new_row = [1] for j in range(1, len(prev_row)): new_row.append(prev_row[j-1] + prev_row[j]) new_row.append(1) triangle.append(new_row) return triangle"},{"question":"def animal_fight(zoo: str) -> str: Given a string representing a sequence of animals, determine which class of animals has the higher score based on predefined scores for mammals and birds. Args: zoo (str): The input string representing the sequence of animals. Returns: str: 'Mammals win!' if mammals have a higher score, 'Birds win!' if birds have a higher score, otherwise 'It's a tie!'. Examples: >>> animal_fight(\\"abcde\\") 'Mammals win!' >>> animal_fight(\\"xyz\\") 'Birds win!' >>> animal_fight(\\"abcxyz\\") \\"It's a tie!\\" # Your code here if __name__ == \\"__main__\\": # Test cases to validate the solution assert animal_fight(\\"abcde\\") == \\"Mammals win!\\" assert animal_fight(\\"xyz\\") == \\"Birds win!\\" assert animal_fight(\\"abcxyz\\") == \\"It's a tie!\\" assert animal_fight(\\"\\") == \\"It's a tie!\\" assert animal_fight(\\"mnopq\\") == \\"It's a tie!\\" assert animal_fight(\\"amxnoybpzqdetr\\") == \\"Birds win!\\" assert animal_fight(\\"a\\") == \\"Mammals win!\\" assert animal_fight(\\"x\\") == \\"Birds win!\\" # Large input test case zoo = \\"abcxyz\\" * 1000 # Should result in a tie assert animal_fight(zoo) == \\"It's a tie!\\"","solution":"def animal_fight(zoo): Given a string representing a sequence of animals, determine which class of animals has the higher score based on predefined scores for mammals and birds. Args: zoo (str): The input string representing the sequence of animals. Returns: str: 'Mammals win!' if mammals have a higher score, 'Birds win!' if birds have a higher score, otherwise 'It's a tie!'. mammal_scores = {'a': 5, 'b': 4, 'c': 3, 'd': 2, 'e': 1} bird_scores = {'x': 5, 'y': 4, 'z': 3, 't': 2, 'u': 1} mammal_total = 0 bird_total = 0 for char in zoo: if char in mammal_scores: mammal_total += mammal_scores[char] elif char in bird_scores: bird_total += bird_scores[char] if mammal_total > bird_total: return 'Mammals win!' elif bird_total > mammal_total: return 'Birds win!' else: return \\"It's a tie!\\""},{"question":"def can_divide_into_teams(N: int, P: List[int]) -> Tuple[str, List[List[int]]]: Determine if it's possible to group employees into projects as required. Args: N (int): The number of employees. P (List[int]): The number of employees required for each project. Returns: Tuple[str, List[List[int]]]: \\"YES\\" with the list of groups if possible, otherwise \\"NO\\". >>> can_divide_into_teams(5, [3, 2]) (\\"YES\\", [[1, 2, 3], [4, 5]]) >>> can_divide_into_teams(6, [2, 2, 2]) (\\"YES\\", [[1, 2], [3, 4], [5, 6]]) >>> can_divide_into_teams(4, [3, 2]) (\\"NO\\", []) pass def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[str, List[List[int]]]]: Process multiple test cases to determine employee grouping for projects. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of test cases, where each test case contains the number of employees, number of projects, and the array of required employees. Returns: List[Tuple[str, List[List[int]]]]: Results for each test case. >>> test_cases = [ ... (5, 2, [3, 2]), ... (6, 3, [2, 2, 2]), ... (4, 2, [3, 2]) ... ] >>> process_test_cases(3, test_cases) [(\\"YES\\", [[1, 2, 3], [4, 5]]), (\\"YES\\", [[1, 2], [3, 4], [5, 6]]), (\\"NO\\", [])] pass","solution":"def can_divide_into_teams(N, P): total_required = sum(P) if total_required != N: return (\\"NO\\", []) result = [] current_employee = 1 for p in P: team = list(range(current_employee, current_employee + p)) result.append(team) current_employee += p return (\\"YES\\", result) def process_test_cases(T, test_cases): results = [] for N, M, P in test_cases: res, teams = can_divide_into_teams(N, P) results.append((res, teams)) return results"},{"question":"def number_of_baskets(fruits: List[str]) -> int: Determine the number of complete baskets you can create from the given fruits. A complete basket consists of exactly one banana, one apple, and one orange. >>> number_of_baskets([\\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"banana\\"]) 2 >>> number_of_baskets([\\"banana\\", \\"apple\\", \\"apple\\", \\"orange\\", \\"banana\\"]) 1","solution":"def number_of_baskets(fruits): Returns the number of complete baskets that can be formed from the given fruits. A complete basket contains exactly one banana, one apple, and one orange. :param fruits: List of strings representing the fruits :return: Integer count of complete baskets banana_count = fruits.count('banana') apple_count = fruits.count('apple') orange_count = fruits.count('orange') return min(banana_count, apple_count, orange_count)"},{"question":"def island_perimeter(grid): Returns the perimeter of the island described in the grid. An island is defined as a group of 1's connected 4-directionally. >>> island_perimeter([[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]) == 16 >>> island_perimeter([[1]]) == 4 >>> island_perimeter([[1, 0, 0, 0]]) == 4 >>> island_perimeter([[1, 1]]) == 6 >>> island_perimeter([[1], [0], [0], [0]]) == 4 >>> island_perimeter([[1], [1]]) == 6 >>> island_perimeter([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> island_perimeter([[1, 0], [1, 1]]) == 8 >>> island_perimeter([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 12 pass","solution":"def island_perimeter(grid): Returns the perimeter of the island described in the grid. An island is defined as a group of 1's connected 4-directionally. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Add 4 edges for the land cell perimeter += 4 # Check north neighbor if r > 0 and grid[r-1][c] == 1: perimeter -= 2 # Subtract 2 for shared boundary # Check west neighbor if c > 0 and grid[r][c-1] == 1: perimeter -= 2 # Subtract 2 for shared boundary return perimeter"},{"question":"from typing import List def largest_concatenated_number(nums: List[int]) -> str: Given a list of non-negative integers, arranges them such that they form the largest possible number when concatenated. >>> largest_concatenated_number([10, 2]) == \\"210\\" >>> largest_concatenated_number([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largest_concatenated_number([1]) == \\"1\\" >>> largest_concatenated_number([0, 0]) == \\"0\\" >>> largest_concatenated_number([20, 1, 9]) == \\"9201\\" >>> largest_concatenated_number([50, 2, 1, 9]) == \\"95021\\" >>> largest_concatenated_number([95, 9, 999, 0]) == \\"9999950\\"","solution":"from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_concatenated_number(nums): Given a list of non-negative integers, arranges them such that they form the largest possible number when concatenated. # Convert numbers to strings for easy comparison nums = list(map(str, nums)) # Sort numbers based on the custom comparator nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers largest_number = ''.join(nums) # In case of numbers having leading zeroes like [0, 0], return \\"0\\" instead of \\"00\\" if largest_number[0] == '0': return '0' return largest_number"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the given string containing only '(' and ')' is a valid sequence of parentheses. >>> is_valid_parentheses(\\"()\\") -> True >>> is_valid_parentheses(\\"(()\\") -> False >>> is_valid_parentheses(\\"()()\\") -> True >>> is_valid_parentheses(\\"((())\\") -> False","solution":"def is_valid_parentheses(s: str) -> bool: Check if the given string s containing only '(' and ')' is a valid sequence of parentheses. # Initialize a counter to zero. counter = 0 # Traverse the string character by character for char in s: # Increment counter for an opening parenthesis if char == '(': counter += 1 # Decrement counter for a closing parenthesis elif char == ')': counter -= 1 # If counter goes negative, we have more ')' than '(' up to this point if counter < 0: return False # If counter is zero, then all opening parentheses have a corresponding closing parentheses return counter == 0"},{"question":"def chunk_array(arr, chunk_size): Splits the input array into chunks of specified size. Parameters: arr (list): The list to be divided into chunks. chunk_size (int): The size of each chunk. Returns: list: A list of chunks (sub-lists). Examples: >>> chunk_array([1, 2, 3, 4, 5], 2) [[1, 2], [3, 4], [5]] >>> chunk_array(['a', 'b', 'c', 'd', 'e', 'f'], 3) [['a', 'b', 'c'], ['d', 'e', 'f']] >>> chunk_array([1, 2, 3, 4, 5, 6, 7, 8], 4) [[1, 2, 3, 4], [5, 6, 7, 8]] >>> chunk_array([], 3) [] pass def test_chunk_array_even_chunks(): assert chunk_array([1, 2, 3, 4, 5], 2) == [[1, 2], [3, 4], [5]] def test_chunk_array_full_chunks(): assert chunk_array(['a', 'b', 'c', 'd', 'e', 'f'], 3) == [['a', 'b', 'c'], ['d', 'e', 'f']] def test_chunk_array_large_chunks(): assert chunk_array([1, 2, 3, 4, 5, 6, 7, 8], 4) == [[1, 2, 3, 4], [5, 6, 7, 8]] def test_chunk_array_empty_array(): assert chunk_array([], 3) == [] def test_chunk_array_single_element_chunks(): assert chunk_array([1, 2, 3], 1) == [[1], [2], [3]] def test_chunk_array_chunk_size_greater_than_array_length(): assert chunk_array([1, 2, 3], 5) == [[1, 2, 3]] def test_chunk_array_chunk_size_zero(): try: chunk_array([1, 2, 3], 0) assert False, \\"Expected ValueError\\" except ValueError: assert True","solution":"def chunk_array(arr, chunk_size): Splits the input array into chunks of specified size. Parameters: arr (list): The list to be divided into chunks. chunk_size (int): The size of each chunk. Returns: list: A list of chunks (sub-lists). return [arr[i:i + chunk_size] for i in range(0, len(arr), chunk_size)]"},{"question":"import heapq from typing import List, Tuple def taskCompletionTime(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum possible time required to complete all tasks for multiple test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): Each tuple contains: - N (int): number of tasks - M (int): number of workers - completion_times (List[int]): completion times of the tasks Returns: List[int]: Minimum time required to complete all tasks for each test case. Example: >>> taskCompletionTime(2, [(5, 2, [2, 4, 6, 8, 10]), (3, 3, [3, 3, 3])]) [18, 3] >>> taskCompletionTime(1, [(5, 1, [1, 2, 3, 4, 5])]) [15]","solution":"import heapq def taskCompletionTime(T, test_cases): results = [] for case in test_cases: N, M, completion_times = case if M >= N: results.append(max(completion_times)) continue completion_times.sort() min_heap = [0] * M for time in completion_times: min_heap[0] += time heapq.heapify(min_heap) results.append(max(min_heap)) return results"},{"question":"from typing import List def customSort(arr: List[int]) -> List[int]: Custom sorts the array such that: 1. All even numbers are sorted in ascending order. 2. All odd numbers are sorted in descending order. >>> customSort([5, 3, 2, 8, 1, 4]) [2, 4, 8, 5, 3, 1] >>> customSort([2, 4, 6, 8]) [2, 4, 6, 8] >>> customSort([9, 7, 5, 3, 1]) [9, 7, 5, 3, 1] >>> customSort([1, 3, 2, 4, 5, 7, 8, 6]) [2, 4, 6, 8, 7, 5, 3, 1] >>> customSort([]) [] >>> customSort([2]) [2] >>> customSort([1]) [1] >>> customSort([5, 3, 2, 3, 8, 1, 1, 4]) [2, 4, 8, 5, 3, 3, 1, 1]","solution":"def customSort(arr): Custom sorts the array such that: 1. All even numbers are sorted in ascending order. 2. All odd numbers are sorted in descending order. Parameters: arr (list): List of integers to sort. Returns: list: New sorted list with even numbers first in ascending order and odd numbers next in descending order. even_numbers = sorted([x for x in arr if x % 2 == 0]) odd_numbers = sorted([x for x in arr if x % 2 != 0], reverse=True) return even_numbers + odd_numbers"},{"question":"def lexicographically_smallest_array(N: int, K: int, arr: List[int]) -> List[int]: Determine the lexicographically smallest array after exactly K swaps. >>> lexicographically_smallest_array(4, 2, [3, 4, 2, 5]) [2, 3, 4, 5] >>> lexicographically_smallest_array(3, 1, [3, 2, 1]) [2, 3, 1] >>> lexicographically_smallest_array(3, 2, [3, 2, 1]) [1, 3, 2] >>> lexicographically_smallest_array(3, 3, [3, 2, 1]) [1, 2, 3] >>> lexicographically_smallest_array(4, 5, [6, 2, 3, 1]) [1, 2, 3, 6] >>> lexicographically_smallest_array(5, 10, [10, 9, 8, 7, 6]) [6, 7, 8, 9, 10] >>> lexicographically_smallest_array(0, 0, []) [] >>> lexicographically_smallest_array(1, 0, [1]) [1] >>> lexicographically_smallest_array(5, 3, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] pass","solution":"def lexicographically_smallest_array(N, K, arr): Determine the lexicographically smallest array after exactly K swaps. arr = list(arr) for i in range(N): min_index = i for j in range(i+1, N): if j-i > K: break if arr[j] < arr[min_index]: min_index = j for j in range(min_index, i, -1): arr[j], arr[j-1] = arr[j-1], arr[j] K -= 1 if K == 0: return arr return arr"},{"question":"def backspace_compare(s: str, t: str) -> bool: Write a function called \`backspace_compare\` in Python, which takes two strings \`s\` and \`t\` as input and determines if the two strings are equal when both are typed into empty text editors. Here, \`#\` means a backspace character. >>> backspace_compare(\\"ab#c\\", \\"ad#c\\") True >>> backspace_compare(\\"ab\\", \\"c#d#\\") True >>> backspace_compare(\\"ac\\", \\"#a#c\\") True >>> backspace_compare(\\"a#c\\", \\"b\\") False","solution":"def backspace_compare(s, t): Compares two strings considering backspace characters '#' and determines if they are equal. def build(string): stack = [] for char in string: if char != '#': stack.append(char) elif stack: stack.pop() return \\"\\".join(stack) return build(s) == build(t)"},{"question":"def organize_books(t: int, cases: List[int]) -> List[List[List[int]]]: Organize books in a specific pattern for the given test cases. >>> organize_books(3, [2, 3, 4]) [[[1], [1, 2]], [[1], [1, 2], [1, 2, 3]], [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]]","solution":"def organize_books(t, cases): result = [] for n in cases: shelf = [] for i in range(1, n + 1): if i == n: shelf.append(list(range(1, n + 1))) else: shelf.append(list(range(1, i + 1))) result.append(shelf) return result"},{"question":"def max_units_sold_over_k_days(n: int, sales: List[int], k: int) -> int: Computes the maximum number of units sold over any k consecutive days. Args: n (int): The number of days. sales (list of int): Units sold per day. k (int): Number of consecutive days. Returns: int: The maximum sum of units sold over any k consecutive days. Examples: >>> max_units_sold_over_k_days(7, [1, 2, 3, 4, 5, 6, 7], 3) 18 >>> max_units_sold_over_k_days(10, [10, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4) 30 # Your code here # Unit Tests def test_max_units_sold_example1(): assert max_units_sold_over_k_days(7, [1, 2, 3, 4, 5, 6, 7], 3) == 18 def test_max_units_sold_example2(): assert max_units_sold_over_k_days(10, [10, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4) == 30 def test_max_units_sold_single_day(): assert max_units_sold_over_k_days(5, [5, 2, 8, 1, 6], 1) == 8 def test_max_units_sold_all_days(): assert max_units_sold_over_k_days(4, [2, 3, 4, 5], 4) == 14 def test_max_units_sold_consecutive_days(): assert max_units_sold_over_k_days(6, [3, 3, 3, 3, 3, 3], 3) == 9","solution":"def max_units_sold_over_k_days(n, sales, k): Computes the maximum number of units sold over any k consecutive days. Args: n (int): The number of days. sales (list of int): Units sold per day. k (int): Number of consecutive days. Returns: int: The maximum sum of units sold over any k consecutive days. # Initial sum of the first k days max_sum = sum(sales[:k]) current_sum = max_sum # Sliding window to find the maximum sum of k consecutive days for i in range(k, n): current_sum += sales[i] - sales[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_product_of_three(arr: List[int]) -> int: Given an array of integers, find the largest product that can be formed by multiplying any three integers from the array. >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([-1, -2, -3, -4]) -6 >>> max_product_of_three([1, 2, 3, 4]) 24 >>> max_product_of_three([0, -1, -2, -3, 5]) 30 >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([1, 10, -5, 1, -100]) 5000 >>> max_product_of_three([-4, -4, 2, 8]) 128","solution":"def max_product_of_three(arr): Returns the largest product possible from any three integers in the array. arr.sort() return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])"},{"question":"def can_be_palindrome_by_removing_one(S: str) -> bool: Determine if the string S can be transformed into a palindrome by removing at most one character. >>> can_be_palindrome_by_removing_one(\\"abca\\") True >>> can_be_palindrome_by_removing_one(\\"racecar\\") True >>> can_be_palindrome_by_removing_one(\\"abcdef\\") False def palindrome_test_cases(T: int, test_cases: List[str]) -> List[str]: Given T test cases, determine for each if the string can be transformed into a palindrome by removing at most one character. >>> palindrome_test_cases(3, [\\"abca\\", \\"racecar\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> palindrome_test_cases(2, [\\"a\\", \\"aa\\"]) [\\"YES\\", \\"YES\\"] >>> palindrome_test_cases(2, [\\"abcba\\", \\"abccba\\"]) [\\"YES\\", \\"YES\\"] >>> palindrome_test_cases(1, [\\"ab\\"]) [\\"YES\\"] from solution import can_be_palindrome_by_removing_one, palindrome_test_cases def test_palindrome_cases(): assert palindrome_test_cases(3, [\\"abca\\", \\"racecar\\", \\"abcdef\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert palindrome_test_cases(2, [\\"a\\", \\"aa\\"]) == [\\"YES\\", \\"YES\\"] assert palindrome_test_cases(2, [\\"abcba\\", \\"abccba\\"]) == [\\"YES\\", \\"YES\\"] assert palindrome_test_cases(1, [\\"ab\\"]) == [\\"YES\\"] assert palindrome_test_cases(1, [\\"abcdefg\\"]) == [\\"NO\\"] def test_edge_cases(): edge_case_string = \\"a\\"*99999 + \\"b\\" assert palindrome_test_cases(1, [edge_case_string]) == [\\"YES\\"] assert palindrome_test_cases(1, [\\"a\\" * 100000]) == [\\"YES\\"] edge_case_string = \\"a\\"*49999 + \\"b\\" + \\"a\\" * 50000 assert palindrome_test_cases(1, [edge_case_string]) == [\\"YES\\"] edge_case_string = \\"abcdef\\" * 16666 + \\"g\\" assert palindrome_test_cases(1, [edge_case_string]) == [\\"NO\\"]","solution":"def can_be_palindrome_by_removing_one(S): def is_palindrome_range(i, j): return all(S[k] == S[j-k+i] for k in range(i, j)) left, right = 0, len(S) - 1 while left < right: if S[left] != S[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 return True def palindrome_test_cases(T, test_cases): results = [] for S in test_cases: if can_be_palindrome_by_removing_one(S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List from collections import Counter def longest_anagram_sequence(words: List[str]) -> int: Write a function that accepts a list of strings and returns the length of the longest consecutive sequence of strings where each string is an anagram of the next in the list. >>> longest_anagram_sequence([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"elgoog\\", \\"hello\\", \\"ohell\\"]) 4 >>> longest_anagram_sequence([\\"apple\\", \\"paple\\", \\"pale\\", \\"leap\\", \\"peal\\", \\"plea\\", \\"appeal\\"]) 4 >>> longest_anagram_sequence([\\"rat\\", \\"tar\\", \\"art\\", \\"car\\"]) 3 # Add function implementation here def are_anagrams(s1: str, s2: str) -> bool: Helper function to determine if two strings are anagrams. return Counter(s1) == Counter(s2) # Unit test def test_longest_anagram_sequence(): assert longest_anagram_sequence([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"elgoog\\", \\"hello\\", \\"ohell\\"]) == 4 assert longest_anagram_sequence([\\"apple\\", \\"paple\\", \\"pale\\", \\"leap\\", \\"peal\\", \\"plea\\", \\"appeal\\"]) == 4 assert longest_anagram_sequence([\\"rat\\", \\"tar\\", \\"art\\", \\"car\\"]) == 3 assert longest_anagram_sequence([\\"hello\\", \\"world\\"]) == 1 assert longest_anagram_sequence([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\"]) == 1 assert longest_anagram_sequence([\\"abc\\", \\"bca\\", \\"cab\\", \\"abcde\\", \\"deabc\\", \\"cba\\"]) == 3 assert longest_anagram_sequence([\\"aaaa\\", \\"aaaa\\", \\"aaaa\\", \\"bbbb\\", \\"bbbb\\", \\"aaaa\\"]) == 3 assert longest_anagram_sequence([]) == 0 assert longest_anagram_sequence([\\"singleword\\"]) == 1","solution":"from collections import Counter def are_anagrams(s1, s2): Helper function to determine if two strings are anagrams return Counter(s1) == Counter(s2) def longest_anagram_sequence(words): Returns the length of the longest consecutive sequence of anagram strings in the list if not words: return 0 max_length = 1 current_length = 1 for i in range(1, len(words)): if are_anagrams(words[i-1], words[i]): current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def convert_to_rle(string: str) -> str: Convert a string to its Run-Length Encoded (RLE) representation. Parameters: string (str): The input string consisting of lowercase alphabetic characters. Returns: str: The RLE representation of the input string. Examples: >>> convert_to_rle(\\"aaabbcaaa\\") '3a2b1c3a' >>> convert_to_rle(\\"\\") '' >>> convert_to_rle(\\"aaaaaa\\") '6a' >>> convert_to_rle(\\"abcdef\\") '1a1b1c1d1e1f' >>> convert_to_rle(\\"aabbcccdddde\\") '2a2b3c4d1e' >>> convert_to_rle(\\"abbbccccd\\") '1a3b4c1d'","solution":"def convert_to_rle(string): Convert a string to its Run-Length Encoded (RLE) representation. Parameters: string (str): The input string consisting of lowercase alphabetic characters. Returns: str: The RLE representation of the input string. if not string: return \\"\\" rle = [] count = 1 for i in range(1, len(string)): if string[i] == string[i - 1]: count += 1 else: rle.append(f\\"{count}{string[i - 1]}\\") count = 1 rle.append(f\\"{count}{string[-1]}\\") return ''.join(rle)"},{"question":"from datetime import datetime def calculate_time_delta(timestamp1: str, timestamp2: str) -> int: Calculate the absolute difference in seconds between two timestamps. Parameters: - timestamp1: a string representing the first timestamp in the format 'DD MM YYYY HH:MM:SS' - timestamp2: a string representing the second timestamp in the format 'DD MM YYYY HH:MM:SS' Returns: - the absolute difference in seconds between the two timestamps. >>> calculate_time_delta(\\"10 01 2023 12:00:00\\", \\"10 01 2023 14:30:00\\") 9000 >>> calculate_time_delta(\\"01 01 2023 00:00:00\\", \\"31 12 2023 23:59:59\\") 31535999 format = \\"%d %m %Y %H:%M:%S\\" def test_same_day(): timestamp1 = \\"10 01 2023 12:00:00\\" timestamp2 = \\"10 01 2023 14:30:00\\" assert calculate_time_delta(timestamp1, timestamp2) == 9000 def test_different_years(): timestamp1 = \\"01 01 2023 00:00:00\\" timestamp2 = \\"31 12 2023 23:59:59\\" assert calculate_time_delta(timestamp1, timestamp2) == 31535999 def test_same_timestamp(): timestamp1 = \\"15 05 2023 08:15:30\\" timestamp2 = \\"15 05 2023 08:15:30\\" assert calculate_time_delta(timestamp1, timestamp2) == 0 def test_one_second_apart(): timestamp1 = \\"01 01 2022 00:00:00\\" timestamp2 = \\"01 01 2022 00:00:01\\" assert calculate_time_delta(timestamp1, timestamp2) == 1 def test_crossing_days(): timestamp1 = \\"31 12 2022 23:59:59\\" timestamp2 = \\"01 01 2023 00:00:01\\" assert calculate_time_delta(timestamp1, timestamp2) == 2","solution":"from datetime import datetime def calculate_time_delta(timestamp1, timestamp2): Calculate the absolute difference in seconds between two timestamps. Parameters: - timestamp1: str, a string representing the first timestamp in the format 'DD MM YYYY HH:MM:SS' - timestamp2: str, a string representing the second timestamp in the format 'DD MM YYYY HH:MM:SS' Returns: - int, the absolute difference in seconds between the two timestamps. format = \\"%d %m %Y %H:%M:%S\\" dt1 = datetime.strptime(timestamp1, format) dt2 = datetime.strptime(timestamp2, format) delta = abs((dt2 - dt1).total_seconds()) return int(delta)"},{"question":"def evaluate_expression(expression: str) -> int: Write a function that takes a string representing a mathematical expression and returns its result. The expression can contain integers, the addition (+) and multiplication (*) operators, and can include spaces which should be ignored. The expression will always be valid and will not include negative numbers, division, or parentheses. Ensure the multiplication operator has precedence over the addition operator. >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"10 + 20 + 30\\") 60 >>> evaluate_expression(\\" 2* 3 + 4 * 5 \\") 26","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, addition (+), and multiplication (*). Multiplication has precedence over addition. Spaces in the expression are ignored. # Remove all spaces expression = expression.replace(\\" \\", \\"\\") # Split the expression by '+' and evaluate each part parts = expression.split('+') total = 0 for part in parts: # Split each part by '*' and evaluate the product factors = part.split('*') product = 1 for factor in factors: product *= int(factor) total += product return total"},{"question":"def product_except_self(nums): Write a function that takes a list of integers and returns a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. For example, if the input is \`[1, 2, 3, 4, 5]\`, the expected output would be \`[120, 60, 40, 30, 24]\`. If the input is \`[3, 2, 1]\`, the expected output would be \`[2, 3, 6]\`. You must do this in \`O(n)\` time complexity and without using division. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] pass # Test Cases assert product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] assert product_except_self([3, 2, 1]) == [2, 3, 6] assert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] assert product_except_self([2, 4, 6, 8]) == [192, 96, 64, 48] assert product_except_self([5, 0, 0, 5]) == [0, 0, 0, 0]","solution":"def product_except_self(nums): length = len(nums) if length == 0: return [] # Initialize the result array with 1's result = [1] * length # Calculate products of elements on the left side of each element left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate products of elements on the right side of each element and multiply with the existing value right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"import re from typing import List, Dict def categorize_books(book_codes: List[str]) -> Dict[str, List[int]]: Categorizes book codes into a dictionary where the key is the category and the value is a list of sorted book identifiers for that category. :param book_codes: List of book codes :type book_codes: list :return: Dictionary mapping each category to a list of sorted book identifiers :rtype: dict >>> categorize_books([\\"LIB-1234-5678\\", \\"LIB-1111-2222\\", \\"LIB-1234-1234\\"]) {\\"1234\\": [1234, 5678], \\"1111\\": [2222]} >>> categorize_books([\\"LIB-1234-5678\\", \\"INVALID-CODE\\", \\"LIB-9999-8888\\"]) {\\"1234\\": [5678], \\"9999\\": [8888]} >>> categorize_books([\\"LIB-1234-5678\\", \\"INVALID-CODE\\", \\"LIB-1234-1234\\", \\"LIB-1111-2222\\"]) {\\"1234\\": [1234, 5678], \\"1111\\": [2222]} >>> categorize_books([]) {} >>> categorize_books([\\"INVALID-1234\\", \\"LIB-12345678\\", \\"LIB-12A4-5678\\"]) {}","solution":"import re def categorize_books(book_codes): Categorizes book codes into a dictionary where the key is the category and the value is a list of sorted book identifiers for that category. :param book_codes: List of book codes :type book_codes: list :return: Dictionary mapping each category to a list of sorted book identifiers :rtype: dict book_dict = {} pattern = re.compile(r\\"LIB-(d{4})-(d{4})\\") for book_code in book_codes: match = pattern.match(book_code) if match: category, book_id = match.groups() if category not in book_dict: book_dict[category] = [] book_dict[category].append(int(book_id)) # Sort each list of book identifiers for category in book_dict: book_dict[category].sort() return book_dict"},{"question":"def distribute_candies(ratings: list[int]) -> int: Calculate the minimum number of candies to distribute among children such that each child gets at least one candy, and children with higher ratings get more candies than their neighbors. >>> distribute_candies([1, 0, 2]) 5 >>> distribute_candies([1, 2, 2]) 4 def test_distribute_candies_simple(): assert distribute_candies([1, 0, 2]) == 5 assert distribute_candies([1, 2, 2]) == 4 def test_distribute_candies_single_element(): assert distribute_candies([3]) == 1 def test_distribute_candies_all_same_ratings(): assert distribute_candies([2, 2, 2, 2, 2]) == 5 def test_distribute_candies_increasing_ratings(): assert distribute_candies([1, 2, 3, 4, 5]) == 15 def test_distribute_candies_decreasing_ratings(): assert distribute_candies([5, 4, 3, 2, 1]) == 15 def test_distribute_candies_wave_ratings(): assert distribute_candies([1, 3, 2, 2, 1]) == 7 def test_distribute_candies_two_peaks(): assert distribute_candies([1, 2, 3, 2, 1, 2, 3, 2, 1]) == 17","solution":"def distribute_candies(ratings: list[int]) -> int: n = len(ratings) if n == 0: return 0 candies = [1] * n # Left to right pass for i in range(1, n): if ratings[i] > ratings[i-1]: candies[i] = candies[i-1] + 1 # Right to left pass for i in range(n-2, -1, -1): if ratings[i] > ratings[i+1]: candies[i] = max(candies[i], candies[i+1] + 1) return sum(candies)"},{"question":"def can_partition_into_three_equal_sum(arr: List[int]) -> bool: Determine whether the array can be partitioned into three subarrays with equal sums. >>> can_partition_into_three_equal_sum([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) True >>> can_partition_into_three_equal_sum([0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]) False >>> can_partition_into_three_equal_sum([3, 3, 6, 5, -2, 2, 5, 1, -9, 4]) True from typing import List","solution":"def can_partition_into_three_equal_sum(arr): Determine whether the array can be partitioned into three subarrays with equal sums. Parameters: arr (list): List of integers. Returns: bool: True if the array can be partitioned into three subarrays with equal sums, otherwise False. total_sum = sum(arr) # If total sum is not divisible by 3, it's not possible to partition if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 count_partitions = 0 for num in arr: current_sum += num if current_sum == target_sum: current_sum = 0 count_partitions += 1 # We need exactly three partitions with equal sum if count_partitions == 3: return True # If we exit the loop, it means we couldn't find three partitions with equal sum return False"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def areCousins(root: TreeNode, x: int, y: int) -> bool: Determines if two given nodes in a binary tree are cousins. Two nodes are cousins if they are at the same level in the tree, but have different parents. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> assert areCousins(root, 4, 6) == True >>> areCousins(root, 5, 6) == True >>> areCousins(root, 4, 5) == False","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def areCousins(root: TreeNode, x: int, y: int) -> bool: def find_level_and_parent(node, val, level=0, parent=None): if not node: return None if node.val == val: return (level, parent) left = find_level_and_parent(node.left, val, level + 1, node) if left: return left right = find_level_and_parent(node.right, val, level + 1, node) return right level_x, parent_x = find_level_and_parent(root, x) level_y, parent_y = find_level_and_parent(root, y) return (level_x == level_y) and (parent_x != parent_y)"},{"question":"def minimum_travel_cost(N: int, M: int, routes: List[Tuple[int, int, int]]) -> int: Find the minimum travel cost from the first station (1) to the last station (N). Parameters: N (int): Number of stations. M (int): Number of routes. routes (List[Tuple[int, int, int]]): Each tuple contains three integers (u, v, w) representing a direct route from station u to station v with cost w. Returns: int: Minimum travel cost from station 1 to station N, or -1 if no path exists. pass # Unit tests def test_minimum_travel_cost_example(): assert minimum_travel_cost(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (4, 5, 1)]) == 6 def test_minimum_travel_cost_no_path(): assert minimum_travel_cost(4, 3, [(1, 2, 3), (2, 3, 4), (3, 2, 1)]) == -1 def test_minimum_travel_cost_direct_route(): assert minimum_travel_cost(2, 1, [(1, 2, 5)]) == 5 def test_minimum_travel_cost_longer(): assert minimum_travel_cost(4, 5, [(1, 2, 3), (1, 3, 9), (1, 4, 100), (2, 4, 2), (3, 4, 6)]) == 5 def test_minimum_travel_cost_large_weights(): assert minimum_travel_cost(3, 3, [(1, 2, 1000000), (2, 3, 1000000), (1, 3, 300)]) == 300","solution":"import heapq def minimum_travel_cost(N, M, routes): Find the minimum travel cost from the first station (1) to the last station (N). Parameters: N (int): Number of stations. M (int): Number of routes. routes (list of tuples): Each tuple contains three integers (u, v, w) representing a direct route from station u to station v with cost w. Returns: int: Minimum travel cost from station 1 to station N, or -1 if no path exists. # Create adjacency list for the graph graph = {i: [] for i in range(1, N + 1)} for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming the routes are bidirectional # Dijkstra's Algorithm to find the shortest path from node 1 to node N priority_queue = [(0, 1)] # (cost, node) distances = {i: float('inf') for i in range(1, N + 1)} distances[1] = 0 visited = set() while priority_queue: current_cost, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) if current_node == N: return current_cost for neighbor, weight in graph[current_node]: new_cost = current_cost + weight if new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(priority_queue, (new_cost, neighbor)) return -1 if distances[N] == float('inf') else distances[N] # Usage with sample input sample_input = (5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (4, 5, 1)]) print(minimum_travel_cost(*sample_input)) # Output: 6"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def kthSmallest(root: TreeNode, K: int) -> int: Returns the K-th smallest element in the BST. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kthSmallest(root, 1) 1 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> kthSmallest(root, 3) 3","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def kthSmallest(root, K): Returns the K-th smallest element in the BST. def in_order_traversal(node): # Perform in-order traversal if node is None: return [] # Traverse left subtree -> Root -> Traverse right subtree return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) # Get all the elements in sorted order sorted_elements = in_order_traversal(root) # Return the K-th smallest element return sorted_elements[K - 1]"},{"question":"def reverse_words(s: str) -> str: Create a function that takes a single string as input and returns a new string with the words in reverse order. Leading or trailing whitespaces should be trimmed, and multiple spaces between words should be reduced to a single space in the output. Examples: >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"Python is great\\") \\"great is Python\\" >>> reverse_words(\\" \\") \\"\\" >>> reverse_words(\\"Code\\") \\"Code\\" >>> reverse_words(\\"This is an example\\") \\"example an is This\\" >>> reverse_words(\\" Another test \\") \\"test Another\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" SingleWord \\") \\"SingleWord\\"","solution":"def reverse_words(s): Returns a new string with the words in reverse order, with any leading or trailing whitespaces trimmed, and multiple spaces between words reduced to a single space. words = s.strip().split() return ' '.join(words[::-1])"},{"question":"def replace_emails(s: str) -> str: Write a function that takes a string and returns the same string with all valid email addresses replaced by the string \\"[EMAIL]\\". A valid email address is defined as: - Contains exactly one \\"@\\" character. - The username part (before the @) may contain letters (a-z, A-Z), digits (0-9), and the special characters \\".\\", \\"-\\", and \\"_\\". - The domain part (after the @) contains one or more subdomains separated by \\".\\" and each subdomain contains only letters (a-z, A-Z) and/or digits (0-9). Each subdomain must start with a letter and be at least 2 characters long. >>> replace_emails(\\"My email is john.doe@example.com and i'll be available after 5.\\") \\"My email is [EMAIL] and i'll be available after 5.\\" >>> replace_emails(\\"You can contact support@sub.example.co.uk or info@another-domain.org for assistance.\\") \\"You can contact [EMAIL] or [EMAIL] for assistance.\\" from solution import replace_emails def test_replace_single_email(): assert replace_emails(\\"My email is john.doe@example.com.\\") == \\"My email is [EMAIL].\\" def test_replace_multiple_emails(): text = \\"Contact at first.email@example.com and second.email@example.org.\\" expected = \\"Contact at [EMAIL] and [EMAIL].\\" assert replace_emails(text) == expected def test_replace_no_emails(): assert replace_emails(\\"There are no emails here.\\") == \\"There are no emails here.\\" def test_replace_emails_with_special_characters(): text = \\"Email: special.email+123@gmail.co.uk, backup.email_47@service-domain.io\\" expected = \\"Email: [EMAIL], [EMAIL]\\" assert replace_emails(text) == expected def test_replace_with_mixed_text(): text = \\"Email me at valid.email@domain.com, or at invalid@.com which isn't valid.\\" expected = \\"Email me at [EMAIL], or at invalid@.com which isn't valid.\\" assert replace_emails(text) == expected","solution":"import re def replace_emails(s): Replaces all valid email addresses in the string with '[EMAIL]'. email_pattern = re.compile( r'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,}b' ) return email_pattern.sub('[EMAIL]', s)"},{"question":"def can_deliver(C: int, T: int, deliveries: List[Tuple[int, int, int]]) -> List[str]: Determine if packages can be delivered within specified limits. >>> can_deliver(5, 2, [(1, 4, 2), (2, 5, 1), (3, 3, 0)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_deliver(5, 2, [(1, 1, 0), (2, 2, 0), (5, 5, 0)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_deliver(10, 2, [(1, 10, 8), (1, 10, 7), (2, 9, 6), (3, 7, 3)]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> can_deliver(1000000, 10000, [(1, 1000000, 999998), (1, 1000000, 500000), (500000, 1000000, 499999)]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_deliver(C, T, deliveries): results = [] for A_i, B_i, K_i in deliveries: distance = abs(A_i - B_i) intermediates_needed = max(0, distance - 1) if intermediates_needed <= K_i: results.append(\\"YES\\") else: results.append(\\"NO\\") return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() C = int(data[0]) T = int(data[1]) N = int(data[2]) deliveries = [] for i in range(N): A_i = int(data[3 + i * 3]) B_i = int(data[4 + i * 3]) K_i = int(data[5 + i * 3]) deliveries.append((A_i, B_i, K_i)) results = can_deliver(C, T, deliveries) for result in results: print(result)"},{"question":"def getWords(text: str) -> list: Extract all words from a string containing words and punctuation marks. Args: text (str): The input string. Returns: list: A list of words. Examples: >>> getWords(\\"Hello, world! This is a test.\\") == [\\"Hello\\", \\"world\\", \\"This\\", \\"is\\", \\"a\\", \\"test\\"] >>> getWords(\\"Programming in 2023: Are you ready?\\") == [\\"Programming\\", \\"in\\", \\"2023\\", \\"Are\\", \\"you\\", \\"ready\\"] >>> getWords(\\"Good morning, Dr. Smith!\\") == [\\"Good\\", \\"morning\\", \\"Dr\\", \\"Smith\\"] from solution import getWords def test_example_1(): assert getWords(\\"Hello, world! This is a test.\\") == [\\"Hello\\", \\"world\\", \\"This\\", \\"is\\", \\"a\\", \\"test\\"] def test_example_2(): assert getWords(\\"Programming in 2023: Are you ready?\\") == [\\"Programming\\", \\"in\\", \\"2023\\", \\"Are\\", \\"you\\", \\"ready\\"] def test_example_3(): assert getWords(\\"Good morning, Dr. Smith!\\") == [\\"Good\\", \\"morning\\", \\"Dr\\", \\"Smith\\"] def test_multiple_spaces_and_punctuation(): assert getWords(\\"Wait... what? Is this real? Yes!\\") == [\\"Wait\\", \\"what\\", \\"Is\\", \\"this\\", \\"real\\", \\"Yes\\"] def test_only_punctuation(): assert getWords(\\"!!!,,,...\\") == [] def test_empty_string(): assert getWords(\\"\\") == [] def test_numbers_and_mixed_content(): assert getWords(\\"Python 3.8.5 is awesome!\\") == [\\"Python\\", \\"3\\", \\"8\\", \\"5\\", \\"is\\", \\"awesome\\"]","solution":"import re def getWords(text): Extracts all words from a string. Args: text (str): The input string. Returns: list: A list of words. return re.findall(r'bw+b', text)"},{"question":"def get_common_elements(list1, list2): Returns a list containing only the elements that are common to both list1 and list2, without duplicates. The elements in the output list should be sorted in ascending order. >>> get_common_elements([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) == [4, 5] >>> get_common_elements([1, 2, 3], [4, 5, 6]) == [] >>> get_common_elements([1, 2, 3], [1, 2, 3]) == [1, 2, 3] >>> get_common_elements([], [1, 2, 3]) == [] >>> get_common_elements([1, 2, 3], []) == [] >>> get_common_elements([], []) == [] >>> get_common_elements([1, 2, 2, 3, 3, 3], [2, 2, 3, 3, 3, 4]) == [2, 3]","solution":"def get_common_elements(list1, list2): Returns a list of elements that are common to both list1 and list2, without duplicates. The elements in the output list are sorted in ascending order. set1 = set(list1) set2 = set(list2) common_elements = set1.intersection(set2) return sorted(common_elements)"},{"question":"def book_count_by_owner(books: List[str], owner: str) -> int: Returns the number of books owned by the specified person. >>> book_count_by_owner([\\"1984:Alice\\", \\"The Great Gatsby:Bob\\", \\"To Kill a Mockingbird:Alice\\"], \\"Alice\\") 2 >>> book_count_by_owner([\\"1984:Alice\\", \\"The Great Gatsby:Bob\\", \\"To Kill a Mockingbird:Alice\\"], \\"Bob\\") 1 >>> book_count_by_owner([\\"1984:Alice\\", \\"The Great Gatsby:Bob\\", \\"To Kill a Mockingbird:Alice\\"], \\"Charlie\\") 0 >>> book_count_by_owner([], \\"Alice\\") 0 >>> book_count_by_owner([\\"1984:Bob\\", \\"The Great Gatsby:Charlie\\"], \\"Alice\\") 0 import unittest class TestBookCountByOwner(unittest.TestCase): def test_book_count_by_owner_alice(self): self.assertEqual(book_count_by_owner( [\\"1984:Alice\\", \\"The Great Gatsby:Bob\\", \\"To Kill a Mockingbird:Alice\\"], \\"Alice\\" ), 2) def test_book_count_by_owner_bob(self): self.assertEqual(book_count_by_owner( [\\"1984:Alice\\", \\"The Great Gatsby:Bob\\", \\"To Kill a Mockingbird:Alice\\"], \\"Bob\\" ), 1) def test_book_count_by_owner_charlie(self): self.assertEqual(book_count_by_owner( [\\"1984:Alice\\", \\"The Great Gatsby:Bob\\", \\"To Kill a Mockingbird:Alice\\"], \\"Charlie\\" ), 0) def test_book_count_by_owner_empty_list(self): self.assertEqual(book_count_by_owner([], \\"Alice\\"), 0) def test_book_count_by_owner_no_match(self): self.assertEqual(book_count_by_owner( [\\"1984:Bob\\", \\"The Great Gatsby:Charlie\\"], \\"Alice\\" ), 0) if __name__ == \\"__main__\\": unittest.main()","solution":"def book_count_by_owner(books, owner): Returns the number of books owned by the specified person. Parameters: books (list): List of strings where each string is formatted as \\"Title:Owner\\". owner (str): The name of the book owner. Returns: int: The number of books owned by the specified person. return sum(1 for book in books if book.split(\\":\\")[1] == owner)"},{"question":"def find_replace(text: str, find_text: str, replace_text: str) -> str: Replaces all non-overlapping occurrences of the find_text in the text with replace_text. Arguments: text -- the original text. find_text -- the substring to find within the original text. replace_text -- the substring to replace find_text with. Returns: A string with the replacements done. Example: >>> find_replace(\\"hello world\\", \\"world\\", \\"there\\") 'hello there' >>> find_replace(\\"foofoo\\", \\"foo\\", \\"bar\\") 'barbar' >>> find_replace(\\"aaaa\\", \\"aa\\", \\"a\\") 'aa' >>> find_replace(\\"foobar\\", \\"baz\\", \\"qux\\") 'foobar' pass from solution import find_replace def test_no_occurrence(): assert find_replace(\\"foobar\\", \\"baz\\", \\"qux\\") == \\"foobar\\" def test_simple_replacement(): assert find_replace(\\"hello world\\", \\"world\\", \\"there\\") == \\"hello there\\" def test_multiple_replacements(): assert find_replace(\\"foofoo\\", \\"foo\\", \\"bar\\") == \\"barbar\\" def test_overlapping_replacement(): assert find_replace(\\"aaaa\\", \\"aa\\", \\"a\\") == \\"aa\\" def test_edge_cases(): assert find_replace(\\"a\\" * 1000, \\"a\\", \\"b\\") == \\"b\\" * 1000 assert find_replace(\\"a\\" * 1000, \\"aa\\", \\"b\\") == \\"b\\" * 500 assert find_replace(\\"aaa\\", \\"a\\", \\"aa\\") == \\"aaaaaa\\" def test_mixed_cases(): assert find_replace(\\"FooFoo\\", \\"foo\\", \\"bar\\") == \\"FooFoo\\" # case sensitive assert find_replace(\\"FooFoo\\", \\"Foo\\", \\"bar\\") == \\"barbar\\" def test_same_find_replace(): assert find_replace(\\"test\\", \\"test\\", \\"test\\") == \\"test\\"","solution":"def find_replace(text: str, find_text: str, replace_text: str) -> str: Replaces all non-overlapping occurrences of the find_text in the text with replace_text. Arguments: text -- the original text. find_text -- the substring to find within the original text. replace_text -- the substring to replace find_text with. Returns: A string with the replacements done. return text.replace(find_text, replace_text)"},{"question":"class StringUtility: A string manipulation utility that supports various operations in average O(1) time. Operations: - append(str): Appends the string 'str' to the end of the current string. - delete(n): Deletes the last 'n' characters from the current string. - getLength: Returns the current length of the string. - getSubstring(k): Returns the substring of length 'k' from the start of the current string. >>> su = StringUtility() >>> su.append(\\"hello\\") >>> su.getLength() 5 >>> su.append(\\" world\\") >>> su.getLength() 11 >>> su.delete(6) >>> su.getLength() 5 >>> su.getSubstring(5) 'hello'","solution":"class StringUtility: def __init__(self): self.current_string = [] def append(self, s): self.current_string.append(s) def delete(self, n): current_length = sum(len(part) for part in self.current_string) while n > 0 and self.current_string: last_part = self.current_string[-1] if len(last_part) <= n: n -= len(last_part) self.current_string.pop() else: self.current_string[-1] = last_part[:-n] n = 0 def getLength(self): return sum(len(part) for part in self.current_string) def getSubstring(self, k): result = [] total_length = 0 for part in self.current_string: if total_length + len(part) >= k: result.append(part[:k-total_length]) break else: result.append(part) total_length += len(part) return ''.join(result)"},{"question":"from typing import List def lexicographically_smallest_string(T: int, strings: List[str]) -> List[str]: Given an integer T (number of test cases) and a list of strings, returns a list of lexicographically smallest strings after performing operations. Args: T : int : number of test cases strings : List[str] : list of input strings Returns: List[str] : list of lexicographically smallest strings for each test case >>> lexicographically_smallest_string(2, [\\"dcb\\", \\"abc\\"]) [\\"bcd\\", \\"abc\\"] >>> lexicographically_smallest_string(3, [\\"cba\\", \\"bac\\", \\"a\\"]) [\\"abc\\", \\"abc\\", \\"a\\"]","solution":"def lexicographically_smallest_string(T, strings): This function receives an integer T (number of test cases) and a list of strings. It returns a list of lexicographically smallest strings after performing operations. results = [] for s in strings: # The optimal way to get the lexicographically smallest string is to simply sort it. smallest_string = ''.join(sorted(s)) results.append(smallest_string) return results"},{"question":"def simulate_typing(char_list: List[str]) -> str: Returns a string from a list of characters by concatenating them. >>> simulate_typing(['H', 'a', 'c', 'k', 'e', 'r', 'R', 'a', 'n', 'k']) == 'HackerRank' >>> simulate_typing([' ', ' ', 'H', 'a', 'c', 'k', 'e', 'r', ' ', 'R', 'a', 'n', 'k', ' ']) == ' Hacker Rank ' >>> simulate_typing(['H', 'a', 'n', 'c', 'k', 'e', 'r', 't', 'R', 'a', 'n', 'k']) == 'HanckertRank' >>> simulate_typing(['H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', ' ', 'C', 'o', 'd', 'e', '!', 'n', 'H', 'e', 'r', 'e', 't', 'w', 'e', ' ', 'g', 'o']) == 'Hello, world! Code!nHeretwe go' >>> simulate_typing(['A']) == 'A' >>> simulate_typing([' ', ' ', ' ']) == ' ' >>> simulate_typing([]) == ''","solution":"def simulate_typing(char_list): Returns a string from a list of characters by concatenating them. Args: char_list (list): A list of characters. Returns: str: The concatenated string. return ''.join(char_list)"},{"question":"def toggle_lamps(lamps: str) -> str: Toggles the lamps in a given house. Turns '0' to '1' and '1' to '0'. >>> toggle_lamps(\\"010\\") \\"101\\" >>> toggle_lamps(\\"111\\") \\"000\\" def are_all_lamps_on(houses: List[str], l: int, r: int) -> str: Checks if all lamps are on in the given range of houses. >>> are_all_lamps_on([\\"010\\", \\"111\\", \\"000\\"], 1, 2) \\"NO\\" >>> are_all_lamps_on([\\"010\\", \\"111\\", \\"000\\"], 2, 2) \\"YES\\" def process_operations(n: int, m: int, house_states: List[str], operations: List[Tuple[int, int, int]]) -> List[str]: Processes the operations and returns the results for type 2 operations. >>> process_operations(3, 5, [\\"010\\", \\"111\\", \\"000\\"], [(1, 1, 1), (2, 1, 2), (1, 3, 3), (2, 1, 3), (2, 3, 3)]) [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def toggle_lamps(lamps): Toggles the lamps in a given house. Turns '0' to '1' and '1' to '0'. return ''.join('1' if lamp == '0' else '0' for lamp in lamps) def are_all_lamps_on(houses, l, r): Checks if all lamps are on in the given range of houses. for i in range(l - 1, r): if '0' in houses[i]: return \\"NO\\" return \\"YES\\" def process_operations(n, m, house_states, operations): Processes the operations and returns the results for type 2 operations. results = [] for operation in operations: if operation[0] == 1: l, r = operation[1], operation[2] for i in range(l - 1, r): house_states[i] = toggle_lamps(house_states[i]) elif operation[0] == 2: l, r = operation[1], operation[2] results.append(are_all_lamps_on(house_states, l, r)) return results"},{"question":"def are_parentheses_closed(s): Write a function that takes a string and returns true if all parentheses in the string are properly closed and nested. A properly closed parenthesis is one where every opening parenthesis has a corresponding closing parenthesis and they are correctly nested. Return false otherwise. >>> are_parentheses_closed(\\"(a + b) * (c + d)\\") True >>> are_parentheses_closed(\\"((a + b) * c\\") False >>> are_parentheses_closed(\\"(a + (b * (c + d)))\\") True >>> are_parentheses_closed(\\"((a + b) * c) + (d\\") False >>> are_parentheses_closed(\\"a + b) * (c + d(\\") False >>> are_parentheses_closed(\\"a + b * c + d\\") True","solution":"def are_parentheses_closed(s): Returns True if all parentheses in the string are properly closed and nested, otherwise returns False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def calculate_total_cost(test_cases): Calculate the total cost of dishes in selected meal plans considering the discount strategy. Args: test_cases (list of tuple): A list where each element is a tuple with the number of meal plans (M), followed by a list of lists containing the prices of dishes in each meal plan. Returns: list: A list containing the total cost for each test case. >>> calculate_total_cost([(3, [[10, 20, 30], [20, 40], [10, 20, 30, 50]])]) [150] >>> calculate_total_cost([(1, [[15, 25]])]) [40] >>> calculate_total_cost([(2, [[5, 10], [15, 20]])]) [50] >>> calculate_total_cost([(2, [[5, 10, 15], [5, 10, 15]])]) [30] >>> calculate_total_cost([(0, [])]) [0] >>> calculate_total_cost([(4, [[2, 3], [3, 4], [2, 5], [1, 2, 3]])]) [15] >>> calculate_total_cost([(1, [[10000] * 100])]) [10000] >>> calculate_total_cost([(100, [[i for i in range(1, 101)] for _ in range(100)])]) [sum(range(1, 101))]","solution":"def calculate_total_cost(test_cases): Calculate the total cost of dishes in selected meal plans considering the discount strategy. Args: test_cases (list of tuple): A list where each element is a tuple with the number of meal plans (M), followed by a list of lists containing the prices of dishes in each meal plan. Returns: list: A list containing the total cost for each test case. results = [] for case in test_cases: M, meal_plans = case unique_dishes = set() for plan in meal_plans: for price in plan: unique_dishes.add(price) total_cost = sum(unique_dishes) results.append(total_cost) return results"},{"question":"def rearrange_even_odd(test_cases): Rearrange the elements of the array so that all even numbers appear before all odd numbers while preserving the relative order of the even and odd numbers. >>> rearrange_even_odd([(5, [1, 2, 3, 4, 5]), (4, [4, 2, 5, 7]), (3, [1, 3, 2])]) [[2, 4, 1, 3, 5], [4, 2, 5, 7], [2, 1, 3]] >>> rearrange_even_odd([(4, [2, 4, 6, 8])]) [[2, 4, 6, 8]] >>> rearrange_even_odd([(4, [1, 3, 5, 7])]) [[1, 3, 5, 7]] >>> rearrange_even_odd([(6, [5, 3, 4, 2, 1, 6])]) [[4, 2, 6, 5, 3, 1]] >>> rearrange_even_odd([(0, [])]) [[]]","solution":"def rearrange_even_odd(test_cases): results = [] for n, arr in test_cases: even = [x for x in arr if x % 2 == 0] odd = [x for x in arr if x % 2 != 0] results.append(even + odd) return results # Example of how to use the function with input provided as a list of tuples (t, arr) # test_cases = [ # (5, [1, 2, 3, 4, 5]), # (4, [4, 2, 5, 7]), # (3, [1, 3, 2]) # ] # print(rearrange_even_odd(test_cases))"},{"question":"def is_within_ranges(ranges: list, number: int) -> bool: Checks if a given number falls within any of the provided ranges. Parameters: ranges (list): A list of tuples where each tuple represents a range (inclusive). number (int): The number to be checked. Returns: bool: True if the number is within at least one range, False otherwise. Examples: >>> is_within_ranges([(1, 5), (8, 10), (12, 15)], 9) True >>> is_within_ranges([(1, 5), (8, 10), (12, 15)], 7) False >>> is_within_ranges([], 3) False >>> is_within_ranges([(1, 3), (4, 7), (5, 9)], 5) True >>> is_within_ranges([(1, 5), (8, 10), (12, 15)], 5) True >>> is_within_ranges([(1, 5), (8, 10), (12, 15)], 8) True >>> is_within_ranges([(-5, 0), (1, 5)], -3) True >>> is_within_ranges([(-5, 0), (1, 5)], 6) False >>> is_within_ranges([(-10, -5), (-3, 2)], -6) True","solution":"def is_within_ranges(ranges: list, number: int) -> bool: Checks if a given number falls within any of the provided ranges. Parameters: ranges (list): A list of tuples where each tuple represents a range (inclusive). number (int): The number to be checked. Returns: bool: True if the number is within at least one range, False otherwise. for start, end in ranges: if start <= number <= end: return True return False"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs of integers from nums that sum up to the target. >>> find_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) [(1, 9), (2, 8), (3, 7), (4, 6)] >>> find_pairs([1, 2, 2, 3, 4, 5], 6) [(1, 5), (2, 4)]","solution":"def find_pairs(nums, target): Returns a list of unique pairs of integers from nums that sum up to the target. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"def is_palindrome(n: int) -> bool: Given a positive integer, check if it is a palindromic number. A palindromic number is a number that remains the same when its digits are reversed. Sample Input/Output: >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1221) True >>> is_palindrome(10) False >>> is_palindrome(1) True","solution":"def is_palindrome(n: int) -> bool: Checks if a given positive integer n is a palindrome. Args: n (int): A positive integer. Returns: bool: True if n is a palindrome, False otherwise. str_n = str(n) return str_n == str_n[::-1]"},{"question":"def smallest_nonrepresentable_sum(arr: List[int]) -> int: Given an array of positive integers, find the smallest positive integer that cannot be represented as the sum of any subset of the given array. Examples: >>> smallest_nonrepresentable_sum([1, 2, 3, 8, 9, 10]) 7 >>> smallest_nonrepresentable_sum([1, 1, 1, 1]) 5 >>> smallest_nonrepresentable_sum([1, 2, 5, 10, 20, 40]) 4 >>> smallest_nonrepresentable_sum([1, 2, 3, 4, 5, 6]) 22","solution":"def smallest_nonrepresentable_sum(arr): # Sort the array to process elements from smallest to largest arr.sort() res = 1 # Initialize result which is the smallest positive integer # Traverse the array and increment the result if arr[i] is smaller than or equal to res for num in arr: if num <= res: res += num else: break return res"},{"question":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the array nums. Parameters: nums (List[int]): List of unsorted integers. Returns: int: The length of the longest consecutive elements sequence. Examples: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 from solution import longest_consecutive def test_example1(): assert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 def test_example2(): assert longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 def test_empty_array(): assert longest_consecutive([]) == 0 def test_single_element(): assert longest_consecutive([10]) == 1 def test_two_elements_consecutive(): assert longest_consecutive([2, 1]) == 2 def test_two_elements_non_consecutive(): assert longest_consecutive([1, 3]) == 1 def test_negative_numbers(): assert longest_consecutive([-1, -2, -3, 0, 2, 3, 4, -5]) == 4 def test_duplicate_elements(): assert longest_consecutive([1, 2, 2, 3, 4]) == 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the array nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def sort_k_sorted_array(nums: List[int], k: int) -> List[int]: Sorts a k-sorted array where each element is at most k positions away from its target position. Args: nums (List[int]): The input k-sorted array. k (int): Maximum distance from the target position for any element. Returns: List[int]: The sorted array. Example: >>> sort_k_sorted_array([3, 2, 1, 5, 4, 7, 6, 5, 8], 2) [1, 2, 3, 4, 5, 5, 6, 7, 8] pass","solution":"import heapq def sort_k_sorted_array(nums, k): Sorts a k-sorted array where each element is at most k positions away from its target position. Args: nums (list): The input k-sorted array. k (int): Maximum distance from the target position for any element. Returns: list: The sorted array. # Create a min-heap of first k+1 elements min_heap = nums[:k+1] heapq.heapify(min_heap) # Initialize index for the sorted array target_index = 0 for i in range(k+1, len(nums)): # Extract the minimum element from heap and add to the sorted part of array nums[target_index] = heapq.heappop(min_heap) target_index += 1 # Add the next element from the array to the heap heapq.heappush(min_heap, nums[i]) # Extract the remaining elements from the heap and add to the array while min_heap: nums[target_index] = heapq.heappop(min_heap) target_index += 1 return nums"},{"question":"from typing import List def longest_subsequence_with_diff_one(arr: List[int]) -> int: Create a function that takes a list of integers and returns the length of the longest subsequence where the difference between consecutive elements is exactly 1. Args: arr (List[int]): A list of integers Returns: int: The length of the longest subsequence meeting the condition Example: >>> longest_subsequence_with_diff_one([1, 2, 3, 4, 5, 3, 4, 5, 6, 7, 8]) 6 >>> longest_subsequence_with_diff_one([10, 9, 8, 7, 6, 5]) 6 >>> longest_subsequence_with_diff_one([5, 4, 3, 2, 1]) 5","solution":"def longest_subsequence_with_diff_one(arr): Returns the length of the longest subsequence where the difference of consecutive elements is exactly 1. if not arr: return 0 longest_length = 1 current_length = 1 for i in range(len(arr) - 1): if abs(arr[i + 1] - arr[i]) == 1: current_length += 1 else: longest_length = max(longest_length, current_length) current_length = 1 return max(longest_length, current_length)"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Given two strings, determine if one is a permutation of the other. A permutation of a string is another string containing the same characters, only the order of characters can be different. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if one string is a permutation of the other, False otherwise. Examples: >>> is_permutation('abc', 'cab') True >>> is_permutation('abc', 'abcd') False","solution":"def is_permutation(s1, s2): Determines if one string is a permutation of the other. # If the lengths of the strings are different, they can't be permutations if len(s1) != len(s2): return False # Sort both strings and compare return sorted(s1) == sorted(s2)"},{"question":"def can_gather_fruit(vendors, fruit_name, quantity): Determines if the desired quantity of a specific fruit can be gathered from multiple vendors. Parameters: vendors (list): A list of dictionaries representing each vendor's inventory. fruit_name (str): The name of the fruit to gather. quantity (int): The quantity required of the specified fruit. Returns: bool: True if the desired quantity can be gathered, False otherwise. >>> vendors = [ ... {\\"apple\\": 5, \\"banana\\": 3}, ... {\\"apple\\": 3, \\"orange\\": 7}, ... {\\"banana\\": 6, \\"apple\\": 2} ... ] >>> fruit_name = \\"apple\\" >>> quantity = 10 >>> can_gather_fruit(vendors, fruit_name, quantity) True >>> vendors = [ ... {\\"apple\\": 5}, ... {\\"apple\\": 3}, ... {\\"banana\\": 6} ... ] >>> fruit_name = \\"apple\\" >>> quantity = 10 >>> can_gather_fruit(vendors, fruit_name, quantity) False","solution":"def can_gather_fruit(vendors, fruit_name, quantity): Determines if the desired quantity of a specific fruit can be gathered from multiple vendors. Parameters: vendors (list): A list of dictionaries representing each vendor's inventory. fruit_name (str): The name of the fruit to gather. quantity (int): The quantity required of the specified fruit. Returns: bool: True if the desired quantity can be gathered, False otherwise. total_quantity = 0 for vendor in vendors: if fruit_name in vendor: total_quantity += vendor[fruit_name] if total_quantity >= quantity: return True return total_quantity >= quantity"},{"question":"def castle_painting(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if it is possible to paint the castle such that no two connected rooms have the same color. >>> T = 2 >>> test_cases = [ ... (3, 3, [(1, 2), (2, 3), (3, 1)]), ... (4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) ... ] >>> castle_painting(T, test_cases) == [\\"Possiblen1 2 3\\", \\"Not Possible\\"] True >>> T = 1 >>> test_cases = [ ... (1, 0, []) ... ] >>> castle_painting(T, test_cases) == [\\"Possiblen1\\"] True >>> T = 1 >>> test_cases = [ ... (3, 0, []) ... ] >>> castle_painting(T, test_cases) == [\\"Possiblen1 1 1\\"] True >>> T = 1 >>> test_cases = [ ... (4, 2, [(1, 2), (3, 4)]) ... ] >>> castle_painting(T, test_cases) == [\\"Possiblen1 2 1 2\\"] True >>> T = 1 >>> test_cases = [ ... (20, 0, []) ... ] >>> castle_painting(T, test_cases) == [\\"Possiblen\\" + \\" \\".join(['1'] * 20)] True","solution":"def is_painting_possible(adj, N): color = [-1] * N def can_paint(room, c): color[room] = c for neighbor in adj[room]: if color[neighbor] == c: return False if color[neighbor] == -1 and not can_paint(neighbor, (c + 1) % 3): return False return True for i in range(N): if color[i] == -1: if not can_paint(i, 0): return \\"Not Possible\\" return \\"Possible\\", [c + 1 for c in color] def castle_painting(T, test_cases): results = [] for N, M, edges in test_cases: adj = [[] for _ in range(N)] for u, v in edges: adj[u - 1].append(v - 1) adj[v - 1].append(u - 1) result = is_painting_possible(adj, N) if result == \\"Not Possible\\": results.append(result) else: results.append(f\\"{result[0]}n{' '.join(map(str, result[1]))}\\") return results"},{"question":"def is_middle_aged_majority(ages: List[int]) -> bool: Returns True if more than half of the community is in the middle-aged group (between 30 and 50 inclusive), otherwise returns False. >>> is_middle_aged_majority([25, 34, 47, 50, 32, 41, 28]) == True >>> is_middle_aged_majority([10, 20, 30, 40, 50, 60, 70]) == False","solution":"def is_middle_aged_majority(ages): Returns True if more than half of the community is in the middle-aged group (between 30 and 50 inclusive), otherwise returns False. middle_aged_count = sum(30 <= age <= 50 for age in ages) return middle_aged_count > len(ages) // 2"},{"question":"def final_sum(N: int, A: List[int], Q: int, operations: List[Tuple[int, int, int]]) -> int: Calculate the final sum of the array after performing all the operations. Parameters: N (int): Number of boxes. A (list of int): Initial number of items in each box. Q (int): Number of operations. operations (list of tuples): Each operation as a tuple (X, Y, V). Returns: int: The sum of items in the array after performing all operations. Example: >>> final_sum(5, [1, 2, 3, 4, 5], 3, [(1, 3, 2), (2, 4, 1), (5, 5, 3)]) 27","solution":"def final_sum(N, A, Q, operations): Calculate the final sum of the array after performing all the operations. Parameters: N (int): Number of boxes. A (list of int): Initial number of items in each box. Q (int): Number of operations. operations (list of tuples): Each operation as a tuple (X, Y, V). Returns: int: The sum of items in the array after performing all operations. # Using a difference array to efficiently apply ranges of updates diff = [0] * (N + 1) for op in operations: X, Y, V = op diff[X - 1] += V if Y < N: diff[Y] -= V # Applying the difference array to the original array current_add = 0 for i in range(N): current_add += diff[i] A[i] += current_add return sum(A)"},{"question":"def min_changes_to_palindrome(s: str) -> int: This function returns the minimum number of character changes required to make the string a palindrome. >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"racecar\\") 0","solution":"def min_changes_to_palindrome(s): This function returns the minimum number of character changes required to make the string a palindrome. changes = 0 length = len(s) for i in range(length // 2): if s[i] != s[length - i - 1]: changes += 1 return changes"},{"question":"def longest_increasing_subarray(arr: List[int]) -> List[int]: Given a list of integers, this function returns the longest contiguous subarray that forms a strictly increasing sequence. If there are multiple subarrays with the same maximum length, it returns the one that occurs first. >>> longest_increasing_subarray([1, 2, 1, 3, 4, 1, 5, 6]) [1, 3, 4] >>> longest_increasing_subarray([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_increasing_subarray([5, 4, 3, 2, 1]) [5] >>> longest_increasing_subarray([1]) [1] >>> longest_increasing_subarray([1, 3, 3, 2, 4, 5]) [2, 4, 5]","solution":"def longest_increasing_subarray(arr): Given a list of integers, this function returns the longest contiguous subarray that forms a strictly increasing sequence. If there are multiple subarrays with the same maximum length, it returns the one that occurs first. n = len(arr) if n == 0: return [] max_len = 1 max_start = 0 current_len = 1 current_start = 0 for i in range(1, n): if arr[i] > arr[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start = current_start current_start = i current_len = 1 if current_len > max_len: max_len = current_len max_start = current_start return arr[max_start:max_start + max_len]"},{"question":"from typing import List, Union def replace_primes(lst: List[int]) -> List[Union[int, str]]: Takes a list of integers and returns a list of the same integers, but with all prime numbers replaced by the string \\"prime\\". >>> replace_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) ['prime', 'prime', 4, 'prime', 6, 'prime', 8, 9, 10] >>> replace_primes([4, 6, 8, 9, 10]) [4, 6, 8, 9, 10] >>> replace_primes([]) [] >>> replace_primes([7]) ['prime'] >>> replace_primes([4]) [4] >>> replace_primes([-2, -3, -5, -7, -11]) [-2, -3, -5, -7, -11] >>> replace_primes([0, 1]) [0, 1] pass","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def replace_primes(lst): Returns a list with all prime numbers replaced by the string \\"prime\\". If the input list is empty, it returns an empty list. return ['prime' if is_prime(x) else x for x in lst]"},{"question":"def sum_of_list(n: int, numbers: List[int]) -> int: Returns the sum of the list of integers. n: number of integers in the list numbers: list of integers >>> sum_of_list(5, [1, 2, 3, 4, 5]) 15 >>> sum_of_list(3, [0, 0, 0]) 0 >>> sum_of_list(4, [-1, -2, -3, -4]) -10 >>> sum_of_list(6, [1, -1, 2, -2, 3, -3]) 0 >>> sum_of_list(1, [1000]) 1000 pass","solution":"def sum_of_list(n, numbers): Returns the sum of the list of integers. n: number of integers in the list numbers: list of integers return sum(numbers) # Example usage: # n = 5 # numbers = [1, 2, 3, 4, 5] # print(sum_of_list(n, numbers)) # Output: 15"},{"question":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists and return it as one sorted list. :param lists: List of ListNode objects, each representing a sorted linked list :return: Merged sorted linked list as a ListNode object >>> lists = [[1, 4, 5], [1, 3, 4], [2, 6]] >>> nodes = list_to_nodes(lists) >>> merged_list = mergeKLists(nodes) >>> nodes_to_list(merged_list) [1, 1, 2, 3, 4, 4, 5, 6] >>> lists = [] >>> nodes = list_to_nodes(lists) >>> merged_list = mergeKLists(nodes) >>> nodes_to_list(merged_list) [] >>> lists = [[]] >>> nodes = list_to_nodes(lists) >>> merged_list = mergeKLists(nodes) >>> nodes_to_list(merged_list) [] def list_to_nodes(lists: List[List[int]]) -> List[Optional[ListNode]]: Convert nested lists into a list of ListNode objects for testing all_nodes = [] for lst in lists: if lst: dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next all_nodes.append(dummy.next) else: all_nodes.append(None) return all_nodes def nodes_to_list(node: Optional[ListNode]) -> List[int]: Convert ListNode linked list into a list of integers for testing lst = [] while node: lst.append(node.val) node = node.next return lst","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merge k sorted linked lists and return it as one sorted list. :type lists: List[ListNode] :rtype: ListNode min_heap = [] # Initialize the heap with the head of each list for i, list_node in enumerate(lists): if list_node: heapq.heappush(min_heap, (list_node.val, i, list_node)) # Dummy node to help with result list construction dummy = ListNode() current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next # Utility function to convert list to ListNode linked lists def list_to_nodes(lists): all_nodes = [] for lst in lists: if lst: dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next all_nodes.append(dummy.next) else: all_nodes.append(None) return all_nodes # Utility function to convert ListNode linked lists to list def nodes_to_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst"},{"question":"from typing import List def min_moves_to_reach_end(grid: List[List[int]]) -> int: A robot needs to navigate a grid composed of cells that can be either obstacles or free spaces. The grid is represented as a 2D array where \`1\` indicates an obstacle and \`0\` indicates a free space. The robot can move horizontally or vertically, but not diagonally. The robot starts at the top-left cell of the grid and needs to reach the bottom-right cell. However, due to obstacles, not every path is possible. This function calculates the minimum number of moves required for the robot to reach the bottom-right cell from the top-left cell. If it is not possible to reach the destination, it returns -1. Args: grid (List[List[int]]): A 2D list representing the grid. Returns: int: The minimum number of moves required to reach the bottom-right cell, or -1 if it's not possible. >>> min_moves_to_reach_end([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 4 >>> min_moves_to_reach_end([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) -1 pass def process_test_cases(test_cases: List[List[List[int]]]) -> List[int]: Processes a list of test cases where each test case is a grid. Computes the minimum number of moves required for the robot to reach the bottom-right cell from the top-left cell for each grid. Args: test_cases (List[List[List[int]]]): A list of test cases where each test case is a grid. Returns: List[int]: A list containing the result for each grid. >>> process_test_cases([ ... [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ], ... [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] ... ]) [4, -1] pass import pytest def test_simple_case(): test_cases = [ [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] ] assert process_test_cases(test_cases) == [4] def test_no_path(): test_cases = [ [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] ] assert process_test_cases(test_cases) == [-1] def test_multiple_cases(): test_cases = [ [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ], [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] ] assert process_test_cases(test_cases) == [4, -1] def test_larger_grid(): test_cases = [ [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ] ] assert process_test_cases(test_cases) == [6] def test_impassable_start(): test_cases = [ [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] ] assert process_test_cases(test_cases) == [-1] def test_impassable_end(): test_cases = [ [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] ] assert process_test_cases(test_cases) == [-1]","solution":"from collections import deque def min_moves_to_reach_end(grid): N = len(grid) if grid[0][0] == 1 or grid[N-1][N-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while queue: row, col, moves = queue.popleft() if row == N - 1 and col == N - 1: return moves for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < N and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, moves + 1)) return -1 def process_test_cases(test_cases): results = [] for grid in test_cases: results.append(min_moves_to_reach_end(grid)) return results"},{"question":"def longest_subarray_with_sum(arr, target): Create a function that takes an array of integers and a target integer. The function should return the length of the longest contiguous subarray that sums up to the target. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([1, 2, 3], 7) 0","solution":"def longest_subarray_with_sum(arr, target): Returns the length of the longest contiguous subarray that sums to the target. sum_map = {0: -1} # Initialize sum_map with 0:-1 for edge case handling total_sum = 0 max_length = 0 for i in range(len(arr)): total_sum += arr[i] if (total_sum - target) in sum_map: max_length = max(max_length, i - sum_map[total_sum - target]) if total_sum not in sum_map: sum_map[total_sum] = i return max_length"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression with two integers and an operator. >>> evaluate_expression(\\"12+34\\") 46 >>> evaluate_expression(\\"50-15\\") 35 >>> evaluate_expression(\\"7*6\\") 42 >>> evaluate_expression(\\"49/7\\") 7 >>> evaluate_expression(\\"27/4\\") 6 def evaluate_expressions(expressions: List[str]) -> List[int]: Evaluates a list of mathematical expressions. >>> evaluate_expressions([\\"12+34\\", \\"50-15\\", \\"7*6\\", \\"49/7\\", \\"27/4\\"]) [46, 35, 42, 7, 6]","solution":"def evaluate_expression(expression): Evaluates a mathematical expression with two integers and an operator. if '+' in expression: a, b = expression.split('+') return int(a) + int(b) elif '-' in expression: a, b = expression.split('-') return int(a) - int(b) elif '*' in expression: a, b = expression.split('*') return int(a) * int(b) elif '/' in expression: a, b = expression.split('/') return int(a) // int(b) def evaluate_expressions(expressions): Evaluates a list of mathematical expressions. return [evaluate_expression(expr) for expr in expressions]"},{"question":"from typing import List def find_sentences_with_words(paragraph: str, words: List[str]) -> List[str]: Write a function that takes in a string containing a paragraph of text and a list of words, and returns a list of sentences from the paragraph where at least one of the words from the list appears. The sentences should be in the order they appear in the paragraph. Sentences are delimited by \`.\` (period), \`?\` (question mark) and \`!\` (exclamation mark). Parameters: paragraph (str): The paragraph of text. words (list): The list of words to search for in the sentences. Returns: list: A list of sentences containing at least one word from the list. Notes: * The function should be case insensitive when checking for word matches. * Punctuation marks at the end of sentences must be preserved in the output. * If no sentence contains any of the words, return an empty list. * Ignore any leading or trailing whitespace in the paragraph and sentences. >>> paragraph = \\"Hello there! How are you today? I hope everything is fine.\\" >>> words = [\\"hope\\", \\"today\\"] >>> find_sentences_with_words(paragraph, words) [\\"How are you today?\\", \\"I hope everything is fine.\\"] >>> paragraph = \\"Yesterday was a great day. I went to the park and had a picnic.\\" >>> words = [\\"today\\"] >>> find_sentences_with_words(paragraph, words) [] >>> paragraph = \\"Do you like apples? Apples are delicious!\\" >>> words = [\\"like\\", \\"delicious\\"] >>> find_sentences_with_words(paragraph, words) [\\"Do you like apples?\\", \\"Apples are delicious!\\"] pass # Unit Tests def test_example1(): paragraph = \\"Hello there! How are you today? I hope everything is fine.\\" words = [\\"hope\\", \\"today\\"] expected = [\\"How are you today?\\", \\"I hope everything is fine.\\"] assert find_sentences_with_words(paragraph, words) == expected def test_example2(): paragraph = \\"Yesterday was a great day. I went to the park and had a picnic.\\" words = [\\"today\\"] expected = [] assert find_sentences_with_words(paragraph, words) == expected def test_example3(): paragraph = \\"Do you like apples? Apples are delicious!\\" words = [\\"like\\", \\"delicious\\"] expected = [\\"Do you like apples?\\", \\"Apples are delicious!\\"] assert find_sentences_with_words(paragraph, words) == expected def test_case_insensitivity(): paragraph = \\"Cats are great. I love my cat.\\" words = [\\"cAt\\"] expected = [\\"Cats are great.\\", \\"I love my cat.\\"] assert find_sentences_with_words(paragraph, words) == expected def test_ignoring_trailing_whitespace(): paragraph = \\"Is it going to rain? Yes, it will rain. \\" words = [\\"rain\\"] expected = [\\"Is it going to rain?\\", \\"Yes, it will rain.\\"] assert find_sentences_with_words(paragraph, words) == expected def test_multiple_words_in_sentence(): paragraph = \\"This is amazing. Truly unbelievable!\\" words = [\\"amazing\\", \\"unbelievable\\"] expected = [\\"This is amazing.\\", \\"Truly unbelievable!\\"] assert find_sentences_with_words(paragraph, words) == expected def test_no_matching_words(): paragraph = \\"This is good. That is better.\\" words = [\\"bad\\"] expected = [] assert find_sentences_with_words(paragraph, words) == expected","solution":"import re def find_sentences_with_words(paragraph, words): This function takes a paragraph of text and a list of words and returns a list of sentences containing at least one word from the list, in the order they appear in the paragraph. Parameters: paragraph (str): The paragraph of text. words (list): The list of words to search for in the sentences. Returns: list: A list of sentences containing at least one word from the list. # Normalize the words to lowercase for case-insensitive matching words_set = set(word.lower() for word in words) # Split the paragraph into sentences using a regex to correctly handle ., ? and ! sentences = re.split(r'(?<=[.?!])s*', paragraph.strip()) # Filter sentences that contain any of the words result = [sentence for sentence in sentences if any(word in sentence.lower() for word in words_set)] return result"},{"question":"def remove_duplicate_letters(s: str) -> str: Removes duplicate letters from the input string s and returns the resulting string in the smallest lexicographical order possible. >>> remove_duplicate_letters(\\"bcabc\\") \\"abc\\" >>> remove_duplicate_letters(\\"cbacdcbc\\") \\"acdb\\"","solution":"def remove_duplicate_letters(s): Removes duplicate letters from the input string s and returns the resulting string in the smallest lexicographical order possible. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: # Ensure characters in stack are in lexicographical order while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.discard(stack.pop()) stack.append(char) seen.add(char) return ''.join(stack)"},{"question":"def min_operations_to_distribute_books_fairly(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of operations required to distribute books fairly among members. Each test case contains: - N: The number of members. - M: The number of books Alice currently has. >>> min_operations_to_distribute_books_fairly(3, [(4, 10), (5, 24), (2, 5)]) == [2, 1, 1] >>> min_operations_to_distribute_books_fairly(2, [(3, 7), (6, 13)]) == [1, 1] >>> min_operations_to_distribute_books_fairly(1, [(1, 100)]) == [0] >>> min_operations_to_distribute_books_fairly(4, [(2, 0), (5, 15), (10, 25), (3, 11)]) == [0, 0, 5, 1] >>> min_operations_to_distribute_books_fairly(2, [(10, 10), (3, 8)]) == [0, 1]","solution":"def min_operations_to_distribute_books_fairly(T, test_cases): results = [] for t in range(T): N, M = test_cases[t] remainder = M % N results.append(min(remainder, N - remainder)) return results"},{"question":"def unobstructed_view(buildings): Returns the number of buildings that have an unobstructed view of the sunset. Args: buildings (List[int]): An array of integers representing the heights of the buildings. Returns: int: The number of buildings with an unobstructed view of the sunset. Examples: >>> unobstructed_view([3, 4, 2, 5, 1]) 3 >>> unobstructed_view([5]) 1 >>> unobstructed_view([1, 2, 3, 4, 5]) 5 >>> unobstructed_view([5, 4, 3, 2, 1]) 1 >>> unobstructed_view([3, 3, 3, 3]) 1 >>> unobstructed_view([]) 0","solution":"def unobstructed_view(buildings): Returns the number of buildings that have an unobstructed view of the sunset. if not buildings: return 0 count = 0 max_height = 0 for height in buildings: if height > max_height: count += 1 max_height = height return count"},{"question":"def is_palindrome(phrase: str) -> str: Determines if a given phrase is a palindrome, ignoring spaces and capitalization. Parameters: phrase (str): The phrase to check. Returns: str: \\"Palindrome\\" if the phrase is a palindrome, otherwise \\"Not a Palindrome\\". Examples: >>> is_palindrome(\\"A Santa Lived As a Devil At NASA\\") \\"Palindrome\\" >>> is_palindrome(\\"Hello World\\") \\"Not a Palindrome\\" >>> is_palindrome(\\"Eva Can I See Bees in a Cave\\") \\"Palindrome\\" >>> is_palindrome(\\"Race car\\") \\"Palindrome\\" >>> is_palindrome(\\"Was it a car or a cat I saw\\") \\"Palindrome\\" >>> is_palindrome(\\"This is not a palindrome\\") \\"Not a Palindrome\\" >>> is_palindrome(\\"Able was I ere I saw Elba\\") \\"Palindrome\\" def process_phrases(test_cases: List[str]) -> List[str]: Process each phrase to determine if it is a palindrome or not. Parameters: test_cases (list): A list of phrases (strings) to check. Returns: list: A list of results, where each result is either \\"Palindrome\\" or \\"Not a Palindrome\\". Examples: >>> process_phrases([\\"A Santa Lived As a Devil At NASA\\", \\"Hello World\\", \\"Eva Can I See Bees in a Cave\\"]) [\\"Palindrome\\", \\"Not a Palindrome\\", \\"Palindrome\\"] >>> process_phrases([\\"Race car\\", \\"Was it a car or a cat I saw\\", \\"This is not a palindrome\\", \\"Able was I ere I saw Elba\\"]) [\\"Palindrome\\", \\"Palindrome\\", \\"Not a Palindrome\\", \\"Palindrome\\"]","solution":"def is_palindrome(phrase): Determines if a given phrase is a palindrome, ignoring spaces and capitalization. Parameters: phrase (str): The phrase to check. Returns: str: \\"Palindrome\\" if the phrase is a palindrome, otherwise \\"Not a Palindrome\\". # Keep only alphabetic characters and convert them to lowercase cleaned_phrase = ''.join(char.lower() for char in phrase if char.isalpha()) # Check if the cleaned phrase is a palindrome if cleaned_phrase == cleaned_phrase[::-1]: return \\"Palindrome\\" else: return \\"Not a Palindrome\\" def process_phrases(test_cases): Process each phrase to determine if it is a palindrome or not. Parameters: test_cases (list): A list of phrases (strings) to check. Returns: list: A list of results, where each result is either \\"Palindrome\\" or \\"Not a Palindrome\\". results = [] for phrase in test_cases: results.append(is_palindrome(phrase)) return results"},{"question":"def find_file_path(file_structure: dict, target_file: str) -> str: Write a function that takes a nested dictionary representing the file structure, a target file name, and returns the path to the file as a string. If the file does not exist, return None. Use '/' as the directory separator in the path. Examples: --------- >>> file_structure = { ... 'home': { ... 'user1': { ... 'docs': ['file1.txt', 'file2.txt'], ... 'photos': ['photo1.jpg', 'photo2.jpg'], ... }, ... 'user2': { ... 'music': ['song1.mp3', 'file1.txt'] ... } ... } ... } >>> find_file_path(file_structure, 'file1.txt') 'home/user1/docs/file1.txt' >>> find_file_path(file_structure, 'photo1.jpg') 'home/user1/photos/photo1.jpg' >>> find_file_path(file_structure, 'song2.mp3') None pass def test_find_file_exist_first_nested_level(): file_structure = { 'home': { 'user1': { 'docs': ['file1.txt', 'file2.txt'], 'photos': ['photo1.jpg', 'photo2.jpg'], }, 'user2': { 'music': ['song1.mp3'] } } } assert find_file_path(file_structure, 'file1.txt') == 'home/user1/docs/file1.txt' assert find_file_path(file_structure, 'photo1.jpg') == 'home/user1/photos/photo1.jpg' assert find_file_path(file_structure, 'song1.mp3') == 'home/user2/music/song1.mp3' def test_find_file_no_file(): file_structure = { 'home': { 'user1': { 'docs': ['file1.txt', 'file2.txt'], 'photos': ['photo1.jpg', 'photo2.jpg'], }, 'user2': { 'music': ['song1.mp3'] } } } assert find_file_path(file_structure, 'song2.mp3') is None def test_find_file_with_same_name(): file_structure = { 'home': { 'user1': { 'docs': ['file1.txt'], 'photos': ['file1.txt'], }, 'user2': { 'music': ['file1.txt'] } } } assert find_file_path(file_structure, 'file1.txt') == 'home/user1/docs/file1.txt'","solution":"def find_file_path(file_structure, target_file, current_path=''): for key, value in file_structure.items(): if isinstance(value, dict): result = find_file_path(value, target_file, f'{current_path}/{key}') if result: return result elif isinstance(value, list): if target_file in value: return f'{current_path}/{key}/{target_file}'.strip('/') return None"},{"question":"def min_supply_pods(test_cases: List[Tuple[int, List[int], int]]) -> List[int]: In a galaxy far, far away, the Starfleet needs to efficiently manage the distribution of supplies to their different fleets scattered across various planets. Each fleet needs a certain amount of supplies, and the Starfleet command has an array of supply pods of varying capacities. They want to know the minimum number of supply pods necessary to meet the demands of each fleet. If the demand of a fleet cannot be met even when all supply pods are used, the fleet should be notified that it is impossible to meet their demand. Parameters: test_cases : List[Tuple[int, List[int], int]] - test_cases is a list of tuples, where each tuple represents a test case. - Each tuple contains the following elements in order: - An integer M representing the number of supply pods. - A list of M integers representing the capacities of the supply pods. - An integer D representing the demand of the fleet. Returns: List[int] - A list of integers, where each integer represents the minimum number of supply pods needed to meet the demand D of each test case. - If it's impossible to meet the demand, the corresponding integer should be -1. Example: >>> min_supply_pods([(4, [1, 2, 3, 4], 6), (5, [1, 5, 10, 50, 100], 40)]) [2, 1] >>> min_supply_pods([(3, [1, 1, 1], 5), (6, [10, 20, 30, 40, 50, 60], 100)]) [-1, 2] >>> min_supply_pods([(1, [50], 50)]) [1]","solution":"def min_supply_pods(test_cases): results = [] for case in test_cases: M, capacities, D = case capacities.sort(reverse=True) total_used = 0 total_supplies = 0 for capacity in capacities: if total_supplies >= D: break total_supplies += capacity total_used += 1 if total_supplies >= D: results.append(total_used) else: results.append(-1) return results"},{"question":"from typing import List, Tuple def can_sort_with_jumps(n: int, m: int, arr: List[int], pairs: List[Tuple[int, int]]) -> str: Determine if the array can be sorted in non-decreasing order using the given connected pairs. Parameters: n (int): the number of elements in the array. m (int): the number of connected pairs. arr (List[int]): the array to be sorted. pairs (List[Tuple[int, int]]): the list of connected pairs. Returns: str: \\"YES\\" if the array can be sorted using only the allowable swaps provided by the connected pairs, \\"NO\\" otherwise. Examples: >>> can_sort_with_jumps(5, 3, [4, 3, 2, 1, 5], [(2, 3), (3, 4), (1, 2)]) \\"YES\\" >>> can_sort_with_jumps(4, 2, [3, 1, 4, 2], [(3, 4), (1, 2)]) \\"NO\\" >>> can_sort_with_jumps(4, 0, [4, 3, 2, 1], []) \\"NO\\" >>> can_sort_with_jumps(4, 2, [1, 2, 3, 4], [(1, 2), (3, 4)]) \\"YES\\" >>> can_sort_with_jumps(5, 3, [1, 1, 1, 1, 1], [(1, 1), (1, 1), (1, 1)]) \\"YES\\" >>> can_sort_with_jumps(6, 3, [6, 5, 3, 4, 1, 2], [(6, 5), (3, 4), (1, 2)]) \\"NO\\"","solution":"def can_sort_with_jumps(n, m, arr, pairs): from collections import defaultdict, deque def bfs(start, visited, graph): queue = deque([start]) component = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) component.append(node) queue.extend(graph[node]) return component graph = defaultdict(list) for x, y in pairs: graph[x].append(y) graph[y].append(x) visited = set() for i in range(n): val = arr[i] if val not in visited: component = bfs(val, visited, graph) component_values = sorted(component) component_indices = sorted([j for j in range(n) if arr[j] in component]) sorted_component = sorted(arr[j] for j in component_indices) for k, idx in enumerate(component_indices): arr[idx] = sorted_component[k] return \\"YES\\" if arr == sorted(arr) else \\"NO\\""},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate how much water can be trapped after raining. :param height: List[int], a list of non-negative integers representing the elevation map. :return: int, the total amount of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4,2,0,3,2,5]) == 9 from solution import trap def test_trap_example1(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_example2(): assert trap([4,2,0,3,2,5]) == 9 def test_trap_no_elevation(): assert trap([]) == 0 def test_trap_flat_surface(): assert trap([1,1,1,1]) == 0 def test_trap_single_bar(): assert trap([4]) == 0 def test_trap_equal_height_bars(): assert trap([3,3,3,3,3]) == 0 def test_trap_hill_shape(): assert trap([1,2,3,4,3,2,1]) == 0 def test_trap_valley_shape(): assert trap([3,1,2,1,3]) == 5 def test_trap_complex_case(): assert trap([0,3,0,1,0,3]) == 8 def test_trap_large_case(): height = [100000]*1000 assert trap(height) == 0","solution":"def trap(height): Calculate how much water can be trapped after raining. :param height: List[int], a list of non-negative integers representing the elevation map. :return: int, the total amount of trapped water. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"def containsNearbyAlmostDuplicate(nums: List[int], k: int, t: int) -> bool: Returns true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k. Otherwise, returns false. >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3, 0) True >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2) True >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 2, 3) False","solution":"def containsNearbyAlmostDuplicate(nums, k, t): Returns true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k. Otherwise, returns false. if t < 0: return False num_dict = {} width = t + 1 for i, num in enumerate(nums): bucket = num // width if bucket in num_dict: return True if bucket - 1 in num_dict and abs(num - num_dict[bucket - 1]) < width: return True if bucket + 1 in num_dict and abs(num - num_dict[bucket + 1]) < width: return True num_dict[bucket] = num if i >= k: del num_dict[nums[i - k] // width] return False"},{"question":"def max_subarray_sum(arr): This function takes an array and returns the maximum sum of any subarray of the array. >>> max_subarray_sum([1, 2, 3]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, -1, 5, -2, 3, 5]) 11 >>> max_subarray_sum([-1, -2, -3]) -1 >>> max_subarray_sum([0, -3, 1, -2]) 1 pass def max_subarray_sums(test_cases): This function processes multiple test cases and uses max_subarray_sum to find the maximum sum of subarrays for each test case. >>> test_cases = [(3, [1, 2, 3]), (4, [-1, -2, -3, -4])] >>> max_subarray_sums(test_cases) [6, -1] >>> test_cases = [(6, [1, -1, 5, -2, 3, 5]), (3, [-1, -2, -3]), (4, [0, -3, 1, -2])] >>> max_subarray_sums(test_cases) [11, -1, 1] pass","solution":"def max_subarray_sum(arr): This function takes an array and returns the maximum sum of any subarray of the array. max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def max_subarray_sums(test_cases): This function processes multiple test cases and uses max_subarray_sum to find the maximum sum of subarrays for each test case. results = [] for case in test_cases: N, array = case results.append(max_subarray_sum(array)) return results"},{"question":"def calculateSpan(expression: str) -> int: Evaluates a postfix expression and returns the result. Parameters: expression (str): A string containing a postfix arithmetic expression. Returns: int/None: The result of the postfix expression or None in case of an error. Examples: >>> calculateSpan(\\"3 4 +\\") 7 >>> calculateSpan(\\"5 1 2 + 4 * + 3 -\\") 14 >>> calculateSpan(\\"10 5 /\\") 2 >>> calculateSpan(\\"7 3 1 + -\\") 3 >>> calculateSpan('4 2 5 * + 1 3 2 * + /') 2 >>> calculateSpan(\\"12 3 /\\") 4 >>> calculateSpan(\\"3 + 4\\") None >>> calculateSpan(12345) None >>> calculateSpan([\\"2\\", \\"3\\", \\"+\\"]) None >>> calculateSpan(\\"4 a +\\") None","solution":"def calculateSpan(expression): Evaluates a postfix expression and returns the result. Parameters: expression (str): A string containing a postfix arithmetic expression. Returns: int/None: The result of the postfix expression or None in case of an error. if not isinstance(expression, str): return None stack = [] operators = set([\\"+\\", \\"-\\", \\"*\\", \\"/\\"]) tokens = expression.split() for token in tokens: if token.lstrip('-').isdigit(): # Check if the token is an integer, considering negative numbers. stack.append(int(token)) elif token in operators: if len(stack) < 2: return None # Not enough operands b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": if b == 0: # Handle division by zero return None stack.append(a // b) # Integer division else: return None # Invalid token if len(stack) != 1: return None # There should be exactly one result if the expression is valid return stack[0]"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to transform the string into a palindrome. >>> min_operations_to_palindrome(\\"aab\\") 1 >>> min_operations_to_palindrome(\\"abb\\") 1 >>> min_operations_to_palindrome(\\"aa\\") 0 >>> min_operations_to_palindrome(\\"ab\\") 1","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform the string into a palindrome. n = len(s) operations = 0 # Check each mismatched pair from start and end towards the center for i in range(n // 2): if s[i] != s[n - 1 - i]: operations += 1 return operations"},{"question":"def char_count(s: str) -> dict: Returns a dictionary with the count of each character in the string s. Spaces are ignored, and counts are case insensitive. >>> char_count(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_count(\\"Programming\\") == {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> char_count(\\"\\") == {}","solution":"def char_count(s): Returns a dictionary with the count of each character in the string s. Spaces are ignored, and counts are case insensitive. count_dict = {} for char in s.lower(): if char.isalpha(): if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def evaluate_equations(equations): Determine the values of all variables based on given equations. Every string in the equations list is an equation formatted as {variable} = {expression}. The expressions may include: - Positive integers - Other variables - Addition ('+') - Subtraction ('-') - Multiplication ('*') Constraints: - There are no cyclic dependencies. - Each variable can only be defined once but can be used in multiple expressions. Example: >>> evaluate_equations([\\"a = 1\\", \\"b = 2\\", \\"c = a + b\\", \\"d = c * b\\"]) {'a': 1, 'b': 2, 'c': 3, 'd': 6} >>> evaluate_equations([\\"x = 5\\", \\"y = x - 3\\", \\"z = x + y\\"]) {'x': 5, 'y': 2, 'z': 7} # To be implemented","solution":"def evaluate_equations(equations): import operator operations = { '+': operator.add, '-': operator.sub, '*': operator.mul } def evaluate(expression, variables): tokens = expression.split() result = int(tokens[0]) if tokens[0].isdigit() else variables[tokens[0]] i = 1 while i < len(tokens): op = operations[tokens[i]] next_token = tokens[i + 1] value = int(next_token) if next_token.isdigit() else variables[next_token] result = op(result, value) i += 2 return result variables = {} for equation in equations: var, expr = equation.split(\\" = \\") variables[var] = evaluate(expr, variables) return variables"},{"question":"from typing import List, Tuple, Union def manage_bookshelf(operations: List[Tuple[str, Union[str, Tuple[str, str, int]]]]) -> List[Tuple[str, str, int]]: Manage a digital bookshelf by processing add, remove, and sort operations. >>> operations = [(\\"add\\", (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937))] >>> manage_bookshelf(operations) [(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)] >>> operations = [ (\\"add\\", (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)), (\\"remove\\", \\"The Hobbit\\") ] >>> manage_bookshelf(operations) [] >>> operations = [ (\\"add\\", (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)), (\\"add\\", (\\"1984\\", \\"George Orwell\\", 1949)), (\\"sort\\", \\"title\\") ] >>> manage_bookshelf(operations) [(\\"1984\\", \\"George Orwell\\", 1949), (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)] >>> operations = [ (\\"add\\", (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)), (\\"add\\", (\\"1984\\", \\"George Orwell\\", 1949)), (\\"sort\\", \\"author\\") ] >>> manage_bookshelf(operations) [(\\"1984\\", \\"George Orwell\\", 1949), (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)] >>> operations = [ (\\"add\\", (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)), (\\"add\\", (\\"1984\\", \\"George Orwell\\", 1949)), (\\"sort\\", \\"year\\") ] >>> manage_bookshelf(operations) [(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937), (\\"1984\\", \\"George Orwell\\", 1949)] >>> operations = [ (\\"add\\", (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)), (\\"add\\", (\\"1984\\", \\"George Orwell\\", 1949)), (\\"add\\", (\\"Brave New World\\", \\"Aldous Huxley\\", 1932)), (\\"remove\\", \\"1984\\"), (\\"sort\\", \\"title\\") ] >>> manage_bookshelf(operations) [(\\"Brave New World\\", \\"Aldous Huxley\\", 1932), (\\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1937)]","solution":"from typing import List, Tuple, Union def manage_bookshelf(operations: List[Tuple[str, Union[str, Tuple[str, str, int]]]]) -> List[Tuple[str, str, int]]: bookshelf = [] for operation in operations: if operation[0] == \\"add\\": bookshelf.append(operation[1]) elif operation[0] == \\"remove\\": title_to_remove = operation[1] bookshelf = [book for book in bookshelf if book[0] != title_to_remove] elif operation[0] == \\"sort\\": sort_by = operation[1] if sort_by == \\"title\\": bookshelf.sort(key=lambda x: x[0]) elif sort_by == \\"author\\": bookshelf.sort(key=lambda x: x[1]) elif sort_by == \\"year\\": bookshelf.sort(key=lambda x: x[2]) return bookshelf"},{"question":"def min_operations_to_make_equal(nums): Given a list of integers, returns the minimum number of operations required to make all elements of the list equal by either incrementing or decrementing the elements. Each operation can increase or decrease the element by 1. Args: nums (list): List of integers. Returns: int: Minimum number of operations to make all elements equal. Examples: >>> min_operations_to_make_equal([4, 6, 8]) 4 >>> min_operations_to_make_equal([5]) 0 >>> min_operations_to_make_equal([7, 7, 7, 7]) 0 >>> min_operations_to_make_equal([1, 2]) 1 >>> min_operations_to_make_equal([1000] * 500 + [1] * 500) 499500 >>> min_operations_to_make_equal([999, 1000]) 1 >>> min_operations_to_make_equal([10, 1, 2, 9, 3, 8, 4, 7, 5, 6]) 25","solution":"def min_operations_to_make_equal(nums): Given a list of integers, returns the minimum number of operations required to make all elements of the list equal by either incrementing or decrementing the elements. Each operation can increase or decrease the element by 1. Args: nums (list): List of integers. Returns: int: Minimum number of operations to make all elements equal. # Find the median of the list nums.sort() median = nums[len(nums) // 2] # Calculate the total number of operations required to make all elements equal to the median total_operations = sum(abs(num - median) for num in nums) return total_operations"},{"question":"def even_squares(numbers: List[int]) -> List[int]: Returns a new list containing the square of each number from the input list only if the square is even. >>> even_squares([1, 2, 3, 4, 5]) == [4, 16] >>> even_squares([6, 7, 8, 9, 10]) == [36, 64, 100]","solution":"def even_squares(numbers): Returns a new list containing the square of each number from the input list only if the square is even. :param numbers: List of integers :return: List of integers with even squares return [x**2 for x in numbers if (x**2) % 2 == 0]"},{"question":"from typing import List def count_magical_pairs(numbers: List[int]) -> int: Returns the number of magical pairs in the array. A pair (i, j) is magical if their sum is even and i < j. >>> count_magical_pairs([2, 4, 6]) 3 >>> count_magical_pairs([1, 3, 5]) 3 >>> count_magical_pairs([1, 2, 3, 4]) 2 >>> count_magical_pairs([]) 0 >>> count_magical_pairs([1]) 0 >>> count_magical_pairs([1, 1]) 1 >>> count_magical_pairs([2, 2]) 1","solution":"def count_magical_pairs(numbers): Returns the number of magical pairs in the array. A pair (i, j) is magical if their sum is even and i < j. count = 0 n = len(numbers) for i in range(n): for j in range(i + 1, n): if (numbers[i] + numbers[j]) % 2 == 0: count += 1 return count"},{"question":"class MovieRatingManager: def __init__(self): Initialize the MovieRatingManager with an empty rating dictionary. def add_rating(self, movie_id: str, rating: int, age_group: str) -> None: Adds a new movie rating. Args: movie_id (str): The unique identifier for the movie. rating (int): The rating for the movie, an integer between 1 and 10 (inclusive). age_group (str): The age group for the rating, one of \\"child\\", \\"teen\\", or \\"adult\\". def update_rating(self, movie_id: str, new_rating: int) -> None: Updates the rating for the given movie. Args: movie_id (str): The unique identifier for the movie. new_rating (int): The new rating for the movie, an integer between 1 and 10 (inclusive). def average_rating(self, age_group: str) -> float: Returns the average rating for the specified age group. Args: age_group (str): The age group for which to calculate the average rating. Returns: float: The average rating for the specified age group, or 0.0 if there are no ratings for the age group. def test_add_rating(): manager = MovieRatingManager() manager.add_rating(\\"movie1\\", 8, \\"adult\\") assert manager.ratings[\\"movie1\\"] == (8, \\"adult\\") def test_update_rating(): manager = MovieRatingManager() manager.add_rating(\\"movie1\\", 8, \\"adult\\") manager.update_rating(\\"movie1\\", 9) assert manager.ratings[\\"movie1\\"] == (9, \\"adult\\") def test_update_rating_non_existent(): manager = MovieRatingManager() manager.update_rating(\\"nonexistent\\", 9) assert \\"nonexistent\\" not in manager.ratings def test_average_rating_adult(): manager = MovieRatingManager() manager.add_rating(\\"movie1\\", 8, \\"adult\\") manager.add_rating(\\"movie2\\", 9, \\"adult\\") manager.add_rating(\\"movie3\\", 7, \\"teen\\") assert manager.average_rating(\\"adult\\") == 8.5 def test_average_rating_child(): manager = MovieRatingManager() manager.add_rating(\\"movie1\\", 5, \\"child\\") assert manager.average_rating(\\"child\\") == 5.0 def test_average_rating_no_ratings(): manager = MovieRatingManager() assert manager.average_rating(\\"senior\\") == 0.0 def test_average_rating_mixed_age_groups(): manager = MovieRatingManager() manager.add_rating(\\"movie1\\", 8, \\"adult\\") manager.add_rating(\\"movie2\\", 7, \\"child\\") manager.add_rating(\\"movie3\\", 6, \\"teen\\") assert manager.average_rating(\\"adult\\") == 8.0 assert manager.average_rating(\\"child\\") == 7.0 assert manager.average_rating(\\"teen\\") == 6.0","solution":"class MovieRatingManager: def __init__(self): self.ratings = {} # Dictionary to store ratings def add_rating(self, movie_id: str, rating: int, age_group: str) -> None: if 1 <= rating <= 10 and age_group in {'child', 'teen', 'adult'}: self.ratings[movie_id] = (rating, age_group) def update_rating(self, movie_id: str, new_rating: int) -> None: if movie_id in self.ratings and 1 <= new_rating <= 10: age_group = self.ratings[movie_id][1] self.ratings[movie_id] = (new_rating, age_group) def average_rating(self, age_group: str) -> float: total_rating = 0 count = 0 for rating, group in self.ratings.values(): if group == age_group: total_rating += rating count += 1 if count == 0: return 0.0 return round(total_rating / count, 1)"},{"question":"def find_max_area_of_islands(grid: List[str]) -> int: You are given a 2D grid consisting of land and water cells. The grid is represented as a list of strings, where 'X' represents land and '0' represents water. Your task is to write a function \`find_max_area_of_islands\` that finds the largest connected area of land in the grid. Connected land cells are defined as groups of land cells that are connected horizontally or vertically (not diagonally). Args: grid (List[str]): A 2D list of strings representing the grid. Returns: int: The size of the largest connected area of land. Example: >>> grid = [ ... \\"X0X0\\", ... \\"X0XX\\", ... \\"0000\\" ... ] >>> find_max_area_of_islands(grid) 3 from solution import find_max_area_of_islands def test_example_case(): grid = [ \\"X0X0\\", \\"X0XX\\", \\"0000\\" ] assert find_max_area_of_islands(grid) == 3 def test_single_land(): grid = [ \\"0X0\\", \\"000\\", \\"000\\" ] assert find_max_area_of_islands(grid) == 1 def test_all_land(): grid = [ \\"XXX\\", \\"XXX\\", \\"XXX\\" ] assert find_max_area_of_islands(grid) == 9 def test_diagonally_connected_land(): grid = [ \\"X0X\\", \\"0X0\\", \\"X0X\\" ] assert find_max_area_of_islands(grid) == 1 def test_multiple_islands(): grid = [ \\"X0X0X\\", \\"0X0X0\\", \\"X0X0X\\" ] assert find_max_area_of_islands(grid) == 1 def test_disconnected_large_islands(): grid = [ \\"X0X0\\", \\"X0X0\\", \\"0X00\\", \\"0X00\\" ] assert find_max_area_of_islands(grid) == 2 def test_large_grid(): grid = [ \\"0\\"*50 for _ in range(50) ] grid[0] = \\"X\\" + \\"0\\"*49 assert find_max_area_of_islands(grid) == 1 def test_grid_with_one_row(): grid = [ \\"X0X0X\\" ] assert find_max_area_of_islands(grid) == 1 def test_grid_with_one_column(): grid = [ \\"X\\", \\"0\\", \\"X\\", \\"0\\", \\"X\\" ] assert find_max_area_of_islands(grid) == 1 def test_large_single_island(): grid = [ \\"XXXXX\\", \\"XXXXX\\", \\"XXXXX\\", \\"XXXXX\\", \\"XXXXX\\" ] assert find_max_area_of_islands(grid) == 25","solution":"from typing import List def find_max_area_of_islands(grid: List[str]) -> int: if not grid: return 0 max_area = 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0' or visited[r][c]: return 0 visited[r][c] = True area = 1 # Check all four possible directions area += dfs(r+1, c) area += dfs(r-1, c) area += dfs(r, c+1) area += dfs(r, c-1) return area for r in range(rows): for c in range(cols): if grid[r][c] == 'X' and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"def count_distinct_substrings(s: str) -> int: Counts the number of distinct substrings in the given string. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"\\") 0 >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"abab\\") 7 >>> count_distinct_substrings(\\"abac\\") 9","solution":"def count_distinct_substrings(s): Counts the number of distinct substrings in the given string 's'. substring_set = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring_set.add(s[i:j]) return len(substring_set)"},{"question":"from typing import List def process_ids(ids: List[int]) -> List[int]: Returns a list of unique IDs from the input, sorted in ascending order. Parameters: - ids: List of integers containing ID numbers, possibly with duplicates. Returns: - List of unique ID numbers sorted in ascending order. pass def test_process_ids_example_1(): assert process_ids([3, 5, 2, 3, 8, 5]) == [2, 3, 5, 8] def test_process_ids_example_2(): assert process_ids([10, 1, 1, 7, 8, 10, 6, 5]) == [1, 5, 6, 7, 8, 10] def test_process_ids_no_duplicates(): assert process_ids([4, 2, 1, 3]) == [1, 2, 3, 4] def test_process_ids_all_same(): assert process_ids([2, 2, 2, 2, 2]) == [2] def test_process_ids_empty_list(): assert process_ids([]) == [] def test_process_ids_single_element(): assert process_ids([99]) == [99] def test_process_ids_large_numbers(): assert process_ids([1000000, 999999, 1000000, 999998]) == [999998, 999999, 1000000]","solution":"from typing import List def process_ids(ids: List[int]) -> List[int]: Returns a list of unique IDs from the input, sorted in ascending order. Parameters: - ids: List of integers containing ID numbers, possibly with duplicates. Returns: - List of unique ID numbers sorted in ascending order. unique_ids = set(ids) sorted_unique_ids = sorted(unique_ids) return sorted_unique_ids"},{"question":"def filter_numbers(nums: List[int], n: int) -> List[int]: Returns a new list containing only the numbers from the original list that are less than n, maintaining their original order. >>> filter_numbers([1, 4, 6, 8, 3, 0], 5) [1, 4, 3, 0] >>> filter_numbers([10, 20, 30], 15) [10] >>> filter_numbers([], 5) []","solution":"from typing import List def filter_numbers(nums: List[int], n: int) -> List[int]: Returns a new list containing only the numbers from the original list that are less than n, maintaining their original order. return [num for num in nums if num < n]"},{"question":"def fibonacci_up_to(n): Returns a list of all Fibonacci numbers less than or equal to \`n\`. >>> fibonacci_up_to(10) [0, 1, 1, 2, 3, 5, 8] >>> fibonacci_up_to(1) [0, 1, 1] >>> fibonacci_up_to(0) [0] >>> fibonacci_up_to(21) [0, 1, 1, 2, 3, 5, 8, 13, 21] >>> fibonacci_up_to(50) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_up_to(n): Returns a list of all Fibonacci numbers less than or equal to \`n\`. if n == 0: return [0] fib_sequence = [0, 1] while True: next_fib = fib_sequence[-1] + fib_sequence[-2] if next_fib > n: break fib_sequence.append(next_fib) return fib_sequence"},{"question":"def is_match(s: str, p: str) -> bool: Returns True if string s matches the pattern p where '?' matches any single character and '*' matches any sequence of characters (including an empty sequence). >>> is_match(\\"aa\\", \\"a\\") == False >>> is_match(\\"aa\\", \\"*\\") == True >>> is_match(\\"cb\\", \\"?a\\") == False >>> is_match(\\"adceb\\", \\"*a*b\\") == True >>> is_match(\\"acdcb\\", \\"a*c?b\\") == False","solution":"def is_match(s: str, p: str) -> bool: Returns True if string s matches the pattern p where '?' matches any single character and '*' matches any sequence of characters (including an empty sequence). m, n = len(s), len(p) # DP table dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty string and empty pattern match dp[0][0] = True # Only '*' can match an empty string for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"def min_jumps(heights: List[int]) -> int: Returns the minimum number of jumps needed to reach the last building from the first one, or -1 if it is not possible. >>> min_jumps([1, 2, 3, 4, 5]) 4 >>> min_jumps([5, 4, 3, 2, 1, 2]) 5 >>> min_jumps([1, 3, 5, 2, 4, 6]) -1","solution":"from collections import deque def min_jumps(heights): Returns the minimum number of jumps needed to reach the last building from the first one, or -1 if it is not possible. if not heights or len(heights) == 1: return 0 n = len(heights) visited = [False] * n queue = deque([(0, 0)]) # (current_building_index, current_jump_count) while queue: index, jumps = queue.popleft() if index == n - 1: return jumps for next_index in [index - 1, index + 1]: if 0 <= next_index < n and not visited[next_index]: if abs(heights[index] - heights[next_index]) <= 1: visited[next_index] = True queue.append((next_index, jumps + 1)) return -1 # Example usage heights_example = [1, 2, 3, 4, 5] print(min_jumps(heights_example)) # Should output 4"},{"question":"def min_subarray_length(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Returns the length of the smallest subarray with a sum of at least the target number for each test case. Parameters: t (int): number of test cases. test_cases (list of tuples): list of test cases, where each test case contains: * n (int): the number of elements in the array. * s (int): the target sum. * arr (list): the list of integers representing the array. Returns: list: list of integers where each integer represents the length of the smallest subarray with a sum of at least the target number for the corresponding test case. >>> min_subarray_length(3, [(6, 7, [2, 3, 1, 2, 4, 3]), (4, 15, [1, 2, 3, 4]), (5, 11, [1, 2, 3, 4, 5])]) [2, 0, 3] >>> min_subarray_length(2, [(3, 10, [1, 1, 1]), (2, 5, [2, 2])]) [0, 0] >>> min_subarray_length(2, [(1, 5, [5]), (1, 3, [4])]) [1, 1] >>> min_subarray_length(1, [(100000, 50000, [1]*100000)]) [50000] >>> min_subarray_length(1, [(6, 100, [1, 2, 3, 4, 5, 6])]) [0]","solution":"def min_subarray_length(t, test_cases): Returns the length of the smallest subarray with a sum of at least the target number for each test case. Parameters: t (int): number of test cases. test_cases (list of tuples): list of test cases, where each test case contains: * n (int): the number of elements in the array. * s (int): the target sum. * arr (list): the list of integers representing the array. Returns: list: list of integers where each integer represents the length of the smallest subarray with a sum of at least the target number for the corresponding test case. results = [] for n, s, arr in test_cases: min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 if min_len == float('inf'): results.append(0) else: results.append(min_len) return results"},{"question":"def min_initial_charge(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Calculate the minimum initial charge required for robots such that at least one robot can complete each task consecutively. >>> min_initial_charge(1, [(3, 2, [10, 20, 15], [5, 10])]) [5] >>> min_initial_charge(1, [(3, 2, [15, 25, 30], [25, 30])]) [31] >>> min_initial_charge(1, [(2, 3, [40, 50], [20, 30, 40])]) [41] >>> min_initial_charge(2, [(3, 2, [30, 40, 50], [15, 20]), (2, 1, [50, 60], [55])]) [21, 56] >>> min_initial_charge(1, [(3, 5, [100, 90, 80], [20, 25, 30, 35, 40])]) [41] >>> min_initial_charge(1, [(1, 1, [1], [1])]) [2] >>> min_initial_charge(1, [(1, 100, [10], [1]*100)]) [2] results = [] for t in range(T): K, N, initial_charges, energy_drains = test_cases[t] max_energy_drain = max(energy_drains) min_charge_required = max_energy_drain + 1 for i in range(K): if initial_charges[i] < min_charge_required: initial_charges[i] = min_charge_required results.append(min_charge_required) return results","solution":"def min_initial_charge(T, test_cases): results = [] for t in range(T): K = test_cases[t][0] N = test_cases[t][1] initial_charges = test_cases[t][2] energy_drains = test_cases[t][3] max_energy_drain = max(energy_drains) min_charge_required = max_energy_drain + 1 # Ensure all robots have at least the minimum required charge for i in range(K): if initial_charges[i] < min_charge_required: initial_charges[i] = min_charge_required results.append(min_charge_required) return results"},{"question":"from typing import List def remove_duplicates(lst: List[int]) -> List[int]: Removes duplicate integers from the list while preserving the order of their first occurrences. >>> remove_duplicates([1, 2, 3, 2, 4, 1, 5, 3]) [1, 2, 3, 4, 5] >>> remove_duplicates([6, 7, 7, 6, 8, 9, 9, 9, 10]) [6, 7, 8, 9, 10] >>> remove_duplicates([]) [] def test_remove_duplicates_no_duplicates(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_with_duplicates(): assert remove_duplicates([1, 2, 2, 3, 1, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): assert remove_duplicates([1, 1, 1, 1, 1]) == [1] def test_remove_duplicates_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_mixed_sign_numbers(): assert remove_duplicates([1, -2, -2, 3, -1, 1, 4, -1]) == [1, -2, 3, -1, 4] def test_remove_duplicates_non_consecutive_duplicates(): assert remove_duplicates([1, 2, 3, 2, 1, 4, 5, 4, 3]) == [1, 2, 3, 4, 5]","solution":"def remove_duplicates(lst): Removes duplicate integers from the list while preserving the order of their first occurrences. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def generate_beautiful_palindrome(L: int) -> str: Generate the lexicographically smallest strictly beautiful palindromic string of length \`L\`. If it's impossible to create such a string, return \\"IMPOSSIBLE\\". >>> generate_beautiful_palindrome(1) 'a' >>> generate_beautiful_palindrome(4) 'abba' >>> generate_beautiful_palindrome(5) 'abcba'","solution":"def generate_beautiful_palindrome(L): if L < 1 or L > 1000: return \\"IMPOSSIBLE\\" if L == 1: return \\"a\\" # For strictly beautiful palindromes, construct the smallest lexicographically possible string. half_length = (L + 1) // 2 half_string = [chr(ord('a') + i) for i in range(half_length)] left_half = ''.join(half_string) # Construct the palindrome if L % 2 == 0: result = left_half + left_half[::-1] else: result = left_half + left_half[:-1][::-1] return result"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Given a collection of intervals, this function merges overlapping intervals. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 2], [3, 4]]) [[1, 2], [3, 4]] >>> merge_intervals([[1, 5], [2, 3], [4, 6]]) [[1, 6]] >>> merge_intervals([[1, 4], [2, 3], [3, 5], [7, 9], [8, 10]]) [[1, 5], [7, 10]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]]","solution":"def merge_intervals(intervals): Merges a collection of overlapping intervals. :param intervals: List of intervals where each interval is represented as [start, end]. :return: List of merged intervals. if not intervals: return [] # Sort intervals by their starting points intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"def shortest_word_length(s: str) -> int: Returns the length of the shortest word in the input string s. If the input string is empty, returns -1. >>> shortest_word_length(\\"apple orange banana\\") == 5 >>> shortest_word_length(\\"this is a test\\") == 1 >>> shortest_word_length(\\"\\") == -1 >>> shortest_word_length(\\"a bb ccc dddd eeeee\\") == 1 >>> shortest_word_length(\\"singleword\\") == 10","solution":"def shortest_word_length(s): Returns the length of the shortest word in the input string s. If the input string is empty, returns -1. if not s: return -1 words = s.split() if not words: return -1 return min(len(word) for word in words)"},{"question":"def max_path_sum(board: List[List[int]]) -> int: Given a 2D board represented by a list of lists, finds the maximum sum collected from the top-left cell to the bottom-right cell only by moving right or down. >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_path_sum([[42]]) == 42 >>> max_path_sum([[1, 2, 3, 4]]) == 10 >>> max_path_sum([[1], [2], [3], [4]]) == 10 >>> max_path_sum([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 :param board: List[List[int]] - the board with non-negative integers :return: int - maximum sum collected","solution":"def max_path_sum(board): Given a 2D board represented by a list of lists, finds the maximum sum collected from the top-left cell to the bottom-right cell only by moving right or down. :param board: List[List[int]] - the board with non-negative integers :return: int - maximum sum collected n = len(board) m = len(board[0]) # Initialize a DP table with the same dimensions as the board dp = [[0] * m for _ in range(n)] # Initialise the starting cell dp[0][0] = board[0][0] # Fill in the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + board[0][j] # Fill in the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + board[i][0] # Fill in the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + board[i][j] # The bottom-right cell contains the maximum sum return dp[n - 1][m - 1]"},{"question":"import numpy as np from typing import List, Tuple def compute_array_operations(n: int, m: int, array: List[List[int]]) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: Computes the sum along axis 0, the product along axis 1, and the cumulative sum along axis None for a given 2-D array. Parameters: n (int): The number of rows in the array. m (int): The number of columns in the array. array (List[List[int]]): A 2-D array of integers. Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: A tuple containing: - the sum along axis 0 - the product along axis 1 - the cumulative sum along axis None Example: >>> import numpy as np >>> n, m = 2, 2 >>> array = [ ... [1, 2], ... [3, 4] ... ] >>> sum_0, prod_1, cumsum_none = compute_array_operations(n, m, array) >>> np.array_equal(sum_0, np.array([4, 6])) True >>> np.array_equal(prod_1, np.array([2, 12])) True >>> np.array_equal(cumsum_none, np.array([1, 3, 6, 10])) True","solution":"import numpy as np def compute_array_operations(n, m, array): np_array = np.array(array) sum_along_axis_0 = np.sum(np_array, axis=0) prod_along_axis_1 = np.prod(np_array, axis=1) cumsum_along_axis_none = np.cumsum(np_array, axis=None) return sum_along_axis_0, prod_along_axis_1, cumsum_along_axis_none"},{"question":"def trap(height): Computes the total amount of rainwater trapped between the bars in a histogram. Args: height: List[int] - A list of non-negative integers representing the height of bars. Returns: int - The total amount of rainwater that can be trapped. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([1,0,2,1,0,1,3,2]) 5 >>> trap([]) 0 >>> trap([0,0,0,0,0]) 0 >>> trap([1]) 0 >>> trap([2, 2]) 0 >>> trap([3, 0, 3, 0, 3]) 6 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0","solution":"def trap(height): Computes the total amount of rainwater trapped between the bars in a histogram. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"def sort_employees(employees: List[Dict[str, int]]) -> List[Dict[str, int]]: Sorts a list of dictionaries representing employees by salary in descending order. If two or more employees have the same salary, they should be sorted by name in ascending order. :param employees: List of dictionaries with \\"name\\" and \\"salary\\" keys :return: List of sorted dictionaries pass # Unit tests def test_sort_employees(): employees = [ {\\"name\\": \\"Alice\\", \\"salary\\": 5000}, {\\"name\\": \\"Bob\\", \\"salary\\": 7000}, {\\"name\\": \\"Charlie\\", \\"salary\\": 5000}, {\\"name\\": \\"David\\", \\"salary\\": 6000} ] expected = [ {\\"name\\": \\"Bob\\", \\"salary\\": 7000}, {\\"name\\": \\"David\\", \\"salary\\": 6000}, {\\"name\\": \\"Alice\\", \\"salary\\": 5000}, {\\"name\\": \\"Charlie\\", \\"salary\\": 5000} ] assert sort_employees(employees) == expected def test_sort_employees_with_tie_in_salary(): employees = [ {\\"name\\": \\"Alice\\", \\"salary\\": 3000}, {\\"name\\": \\"Bob\\", \\"salary\\": 4000}, {\\"name\\": \\"Eve\\", \\"salary\\": 3000}, {\\"name\\": \\"David\\", \\"salary\\": 4000} ] expected = [ {\\"name\\": \\"Bob\\", \\"salary\\": 4000}, {\\"name\\": \\"David\\", \\"salary\\": 4000}, {\\"name\\": \\"Alice\\", \\"salary\\": 3000}, {\\"name\\": \\"Eve\\", \\"salary\\": 3000} ] assert sort_employees(employees) == expected def test_sort_employees_same_salary_and_name(): employees = [ {\\"name\\": \\"Alice\\", \\"salary\\": 5000}, {\\"name\\": \\"Alice\\", \\"salary\\": 5000} ] expected = [ {\\"name\\": \\"Alice\\", \\"salary\\": 5000}, {\\"name\\": \\"Alice\\", \\"salary\\": 5000} ] assert sort_employees(employees) == expected def test_sort_employees_all_same_salary(): employees = [ {\\"name\\": \\"Charlie\\", \\"salary\\": 1000}, {\\"name\\": \\"Alice\\", \\"salary\\": 1000}, {\\"name\\": \\"Bob\\", \\"salary\\": 1000} ] expected = [ {\\"name\\": \\"Alice\\", \\"salary\\": 1000}, {\\"name\\": \\"Bob\\", \\"salary\\": 1000}, {\\"name\\": \\"Charlie\\", \\"salary\\": 1000} ] assert sort_employees(employees) == expected def test_sort_employees_single_entry(): employees = [ {\\"name\\": \\"Alice\\", \\"salary\\": 5000} ] expected = [ {\\"name\\": \\"Alice\\", \\"salary\\": 5000} ] assert sort_employees(employees) == expected","solution":"def sort_employees(employees): Sorts a list of dictionaries representing employees by salary in descending order. If two or more employees have the same salary, they should be sorted by name in ascending order. :param employees: List of dictionaries with \\"name\\" and \\"salary\\" keys :return: List of sorted dictionaries return sorted(employees, key=lambda x: (-x['salary'], x['name'])) # Example provided in the Question employees = [ {\\"name\\": \\"Alice\\", \\"salary\\": 5000}, {\\"name\\": \\"Bob\\", \\"salary\\": 7000}, {\\"name\\": \\"Charlie\\", \\"salary\\": 5000}, {\\"name\\": \\"David\\", \\"salary\\": 6000} ] sorted_employees = sort_employees(employees) sorted_employees"},{"question":"def pattern_count_in_manuscripts(T, test_cases): In the Kingdom of Strings, there exists an ancient library containing valuable manuscripts. Each manuscript is a string consisting of lowercase alphabets only. The librarian, known as the Keeper of Manuscripts, wants to assess the rarity of certain patterns in these strings. You have been tasked to help the Keeper by finding the number of times a specific pattern (substring) appears in the given manuscripts. You are required to process multiple queries where each query consists of a pattern and a specific manuscript. ----Input:---- - The first line of the input contains a single integer T, the number of test cases. The description of T test cases follows. - For each test case, the first line contains an integer N, the number of manuscripts. - The next N lines each contain a manuscript string. - The next line contains an integer Q, the number of queries for the current test case. - The next Q lines contain two elements: a string P (the pattern) and an integer M (the index of the manuscript, 1-based index). ----Output:---- - For each query, print the number of times the pattern P appears in the M-th manuscript. ----Constraints:----- - 1 ≤ T ≤ 50 - 1 ≤ N ≤ 100 - 1 ≤ length of any manuscript ≤ 1000 - 1 ≤ Q ≤ 200 - 1 ≤ length of P ≤ 100 - Manuscripts consist of lowercase alphabets only ----Example Usage:---- >>> T = 1 >>> test_cases = [ ... (2, [\\"abcabcpqr\\", \\"bcabcabc\\"], 3, [(\\"abc\\", 1), (\\"bc\\", 2), (\\"pqr\\", 1)]) ... ] >>> pattern_count_in_manuscripts(T, test_cases) [2, 3, 1] # your code here # Unit tests def test_single_case(): T = 1 test_cases = [ (2, [\\"abcabcpqr\\", \\"bcabcabc\\"], 3, [(\\"abc\\", 1), (\\"bc\\", 2), (\\"pqr\\", 1)]) ] assert pattern_count_in_manuscripts(T, test_cases) == [2, 3, 1] def test_multiple_cases(): T = 2 test_cases = [ (2, [\\"abcabcpqr\\", \\"bcabcabc\\"], 3, [(\\"abc\\", 1), (\\"bc\\", 2), (\\"pqr\\", 1)]), (3, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"], 2, [(\\"a\\", 1), (\\"ef\\", 2)]) ] assert pattern_count_in_manuscripts(T, test_cases) == [2, 3, 1, 1, 1] def test_no_patterns_found(): T = 1 test_cases = [ (2, [\\"abcdefgh\\", \\"ijklmnop\\"], 2, [(\\"xyz\\", 1), (\\"qrst\\", 2)]) ] assert pattern_count_in_manuscripts(T, test_cases) == [0, 0] def test_patterns_at_edges(): T = 1 test_cases = [ (1, [\\"abcabc\\"], 2, [(\\"abc\\", 1), (\\"bca\\", 1)]) ] assert pattern_count_in_manuscripts(T, test_cases) == [2, 1] def test_overlap_patterns(): T = 1 test_cases = [ (1, [\\"aaaaaa\\"], 1, [(\\"aa\\", 1)]) ] assert pattern_count_in_manuscripts(T, test_cases) == [5]","solution":"def pattern_count_in_manuscripts(T, test_cases): results = [] for case in test_cases: N, manuscripts, Q, queries = case for pattern, index in queries: manuscript = manuscripts[index-1] count = 0 k = len(pattern) for i in range(len(manuscript) - k + 1): if manuscript[i:i+k] == pattern: count += 1 results.append(count) return results # Example usage: T = 1 test_cases = [ (2, [\\"abcabcpqr\\", \\"bcabcabc\\"], 3, [(\\"abc\\", 1), (\\"bc\\", 2), (\\"pqr\\", 1)]) ] print(pattern_count_in_manuscripts(T, test_cases)) # Expected output: [2, 3, 1]"},{"question":"def reverse_words_in_sentence(s: str) -> str: Given a string s representing a sentence, returns the sentence with each word reversed but with the original word order preserved. Parameters: s (str): The input sentence composed of letters and spaces. Returns: str: The sentence with each word reversed. Examples: >>> reverse_words_in_sentence(\\"hello world\\") 'olleh dlrow' >>> reverse_words_in_sentence(\\"coding is fun\\") 'gnidoc si nuf' >>> reverse_words_in_sentence(\\"python\\") 'nohtyp' >>> reverse_words_in_sentence(\\"this is a test\\") 'siht si a tset' >>> reverse_words_in_sentence(\\"\\") '' >>> reverse_words_in_sentence(\\"a bc def\\") 'a cb fed'","solution":"def reverse_words_in_sentence(s): Given a string s representing a sentence, returns the sentence with each word reversed but with the original word order preserved. Parameters: s (str): The input sentence composed of letters and spaces. Returns: str: The sentence with each word reversed. words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"import math from functools import reduce def min_cupcakes(departments: List[int]) -> int: Returns the minimum number of cupcakes needed such that each department gets exactly one cupcake per employee and no cupcakes are left over. >>> min_cupcakes([5]) == 5 >>> min_cupcakes([5, 7, 3]) == 105 >>> min_cupcakes([4, 4, 4]) == 4 >>> min_cupcakes([6, 8]) == 24 >>> min_cupcakes([100000, 99999]) == 9999900000","solution":"import math from functools import reduce def lcm(a, b): return abs(a*b) // math.gcd(a, b) def min_cupcakes(departments): Returns the minimum number of cupcakes needed such that each department gets exactly one cupcake per employee and no cupcakes are left over. total_employees = reduce(lcm, departments) return total_employees"},{"question":"import heapq from typing import List def kth_largest(arr: List[int], k: int) -> int: Returns the k-th largest element in the array. >>> kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 >>> kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 >>> kth_largest([1], 1) == 1 pass","solution":"import heapq from typing import List def kth_largest(arr: List[int], k: int) -> int: Returns the k-th largest element in the array. # Using a min-heap of size k to keep track of the largest elements encountered min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"def totalGoalAchieved(transactions): Returns the total percentage of the sales goal achieved through all transactions. Args: transactions (list of [int, int]): List of transactions, where each transaction is a pair of [price, percentage of the total sales goal achieved] Returns: float: Total percentage of the sales goal achieved, rounded to two decimal places. >>> totalGoalAchieved([[15, 10], [20, 20], [30, 30]]) 60.00 >>> totalGoalAchieved([[10, 5], [50, 20], [20, 10]]) 35.00 >>> totalGoalAchieved([]) 0.00","solution":"def totalGoalAchieved(transactions): Returns the total percentage of the sales goal achieved through all transactions. Args: transactions (list of [int, int]): List of transactions, where each transaction is a pair of [price, percentage of the total sales goal achieved] Returns: float: Total percentage of the sales goal achieved, rounded to two decimal places. total_percentage = sum(transaction[1] for transaction in transactions) return round(total_percentage, 2)"},{"question":"def maxNonOverlappingDeliveries(deliveries: List[List[int]]) -> int: Determine the maximum number of non-overlapping deliveries. >>> maxNonOverlappingDeliveries([[1, 3], [2, 4], [3, 5], [6, 7]]) == 3 >>> maxNonOverlappingDeliveries([[1, 2], [2, 3], [3, 4], [5, 6]]) == 4 >>> maxNonOverlappingDeliveries([[1, 5], [2, 6], [3, 7], [4, 8]]) == 1 >>> maxNonOverlappingDeliveries([[1, 2], [3, 4], [5, 6], [7, 8]]) == 4 >>> maxNonOverlappingDeliveries([[1, 2]]) == 1 >>> maxNonOverlappingDeliveries([[1, 3], [2, 6], [5, 8], [8, 10]]) == 3","solution":"from typing import List def maxNonOverlappingDeliveries(deliveries: List[List[int]]) -> int: # Sort deliveries based on their end times deliveries.sort(key=lambda x: x[1]) max_deliveries = 0 last_end_time = 0 for start, end in deliveries: # If the start time of the current delivery is greater or equal to # the end time of the last selected delivery, include this delivery if start >= last_end_time: max_deliveries += 1 last_end_time = end return max_deliveries"},{"question":"from typing import List def longestCommonPrefix(strs: List[str]) -> str: Determine the longest common prefix among all the strings. If there is no common prefix, return an empty string \\"\\". >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) ''","solution":"def longestCommonPrefix(strs): if not strs: return \\"\\" # Find the string with the minimum length min_length = min(len(s) for s in strs) low, high = 1, min_length def isCommonPrefix(length): prefix = strs[0][:length] return all(s.startswith(prefix) for s in strs) while low <= high: mid = (low + high) // 2 if isCommonPrefix(mid): low = mid + 1 else: high = mid - 1 return strs[0][:(low + high) // 2]"},{"question":"def filter_greater_than(nums: List[int], n: int) -> List[int]: Returns a new list containing only the elements of the original list that are greater than n. Args: nums (list of int): The list of integers to filter. n (int): The threshold integer. Returns: list of int: The filtered list containing only elements greater than n. >>> filter_greater_than([1, 2, 3], 5) [] >>> filter_greater_than([1, 2, 3, 4, 5], 3) [4, 5] >>> filter_greater_than([5, 6, 7, 8], 4) [5, 6, 7, 8] >>> filter_greater_than([], 3) [] >>> filter_greater_than([-3, -2, 0, 1, 2], -1) [0, 1, 2] >>> filter_greater_than([0, -1, 1], 0) [1]","solution":"def filter_greater_than(nums, n): Returns a new list containing only the elements of the original list that are greater than n. Args: nums (list of int): The list of integers to filter. n (int): The threshold integer. Returns: list of int: The filtered list containing only elements greater than n. return [num for num in nums if num > n]"},{"question":"def min_coins(amount: int) -> int: Determine the minimum number of coins needed to make the given amount in a hypothetical country's currency system which consists of coins with denominations that are powers of 2. Parameters: amount (int): The amount of currency to make. Returns: int: The minimum number of coins needed. Examples: >>> min_coins(15) 4 >>> min_coins(7) 3","solution":"def min_coins(amount): Returns the minimum number of coins needed to make the given amount in a hypothetical country's currency system which consists of coins with denominations that are powers of 2. count = 0 while amount > 0: # Find the largest power of 2 less than or equal to amount largest_coin = 1 while largest_coin * 2 <= amount: largest_coin *= 2 # Subtract the largest_coin from amount and increment the count amount -= largest_coin count += 1 return count"},{"question":"from typing import List, Tuple def find_target(matrix: List[List[int]], target: int) -> Tuple[int, int]: Given an m x n matrix of integers, where each row is sorted in ascending order and every integer within the matrix is unique, find a target value and return its position as a tuple (row_index, col_index). If the target value is not found in the matrix, return (-1, -1). >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> find_target(matrix, 5) (1, 1) >>> find_target(matrix, 20) (-1, -1) pass","solution":"from typing import List, Tuple def find_target(matrix: List[List[int]], target: int) -> Tuple[int, int]: if not matrix: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) r, c = 0, cols - 1 # Start from the top-right corner while r < rows and c >= 0: if matrix[r][c] == target: return (r, c) elif matrix[r][c] > target: c -= 1 else: r += 1 return (-1, -1)"},{"question":"def is_leap_year(year: int) -> str: Returns whether the given year is a leap year or not. >>> is_leap_year(2020) == \\"Leap Year\\" >>> is_leap_year(2000) == \\"Leap Year\\" >>> is_leap_year(2400) == \\"Leap Year\\" >>> is_leap_year(1996) == \\"Leap Year\\" >>> is_leap_year(1900) == \\"Not a Leap Year\\" >>> is_leap_year(2100) == \\"Not a Leap Year\\" >>> is_leap_year(1800) == \\"Not a Leap Year\\" >>> is_leap_year(2021) == \\"Not a Leap Year\\" >>> is_leap_year(1) == \\"Not a Leap Year\\" >>> is_leap_year(4) == \\"Leap Year\\" >>> is_leap_year(100) == \\"Not a Leap Year\\" >>> is_leap_year(400) == \\"Leap Year\\"","solution":"def is_leap_year(year): Returns whether the given year is a leap year or not. if (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0): return \\"Leap Year\\" else: return \\"Not a Leap Year\\""},{"question":"import heapq from typing import List, Tuple def fastest_delivery_times(N: int, M: int, W: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determines the fastest delivery times from the central warehouse city W to all other cities. :param N: Number of cities :param M: Number of roads :param W: Warehouse city :param roads: List of tuples representing bidirectional roads (u, v, t) :return: List of minimum travel times from the warehouse to each city Example: >>> fastest_delivery_times(4, 4, 1, [(1, 2, 5), (1, 3, 10), (2, 3, 2), (3, 4, 1)]) [0, 5, 7, 8] # Implementation here def test_fastest_delivery_times_simple(): N = 4 M = 4 W = 1 roads = [(1, 2, 5), (1, 3, 10), (2, 3, 2), (3, 4, 1)] expected = [0, 5, 7, 8] assert fastest_delivery_times(N, M, W, roads) == expected def test_fastest_delivery_times_no_reachable(): N = 3 M = 1 W = 1 roads = [(1, 2, 1)] expected = [0, 1, -1] assert fastest_delivery_times(N, M, W, roads) == expected def test_fastest_delivery_times_single_city(): N = 1 M = 0 W = 1 roads = [] expected = [0] assert fastest_delivery_times(N, M, W, roads) == expected def test_fastest_delivery_times_all_connected(): N = 5 M = 6 W = 3 roads = [(1, 2, 6), (2, 3, 2), (1, 3, 10), (3, 4, 1), (4, 5, 3), (3, 5, 7)] expected = [8, 2, 0, 1, 4] assert fastest_delivery_times(N, M, W, roads) == expected def test_fastest_delivery_times_large_input(): N = 1000 M = 999 W = 1 roads = [(i, i+1, i) for i in range(1, N)] expected = [sum(range(i)) for i in range(1, N+1)] assert fastest_delivery_times(N, M, W, roads) == expected # Run test cases if __name__ == \\"__main__\\": test_fastest_delivery_times_simple() test_fastest_delivery_times_no_reachable() test_fastest_delivery_times_single_city() test_fastest_delivery_times_all_connected() test_fastest_delivery_times_large_input()","solution":"import heapq def fastest_delivery_times(N, M, W, roads): Determines the fastest delivery times from the central warehouse city W to all other cities. :param N: Number of cities :param M: Number of roads :param W: Warehouse city :param roads: List of tuples representing bidirectional roads (u, v, t) :return: List of minimum travel times from the warehouse to each city # Create adjacency list adj = {i: [] for i in range(1, N + 1)} for u, v, t in roads: adj[u].append((v, t)) adj[v].append((u, t)) # Initialize distance array with infinity distances = {i: float('inf') for i in range(1, N + 1)} distances[W] = 0 # Min heap to process the next nearest city priority_queue = [(0, W)] while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for neighbor, travel_time in adj[current_city]: distance = current_distance + travel_time if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Convert distances to required output format result = [distances[i] if distances[i] != float('inf') else -1 for i in range(1, N + 1)] return result"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the given string consisting of parentheses is valid. A string is valid if: - Open parentheses '(' must be closed by the same type of parentheses ')' in the correct order. - Open parentheses '(' must be closed in the correct order. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"(())))(\\") False >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"\\") True","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the given string consisting of parentheses is valid. A string is valid if: - Open parentheses '(' must be closed by the same type of parentheses ')' in the correct order. - Open parentheses '(' must be closed in the correct order. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def workout_sequence(stations: List[str]) -> List[str]: Returns the list of workout stations visited by the member before encountering the first \\"rest\\" station. >>> workout_sequence([\\"cardio\\", \\"strength\\", \\"flexibility\\", \\"rest\\", \\"cardio\\", \\"strength\\"]) [\\"cardio\\", \\"strength\\", \\"flexibility\\"] >>> workout_sequence([\\"rest\\", \\"cardio\\", \\"strength\\", \\"flexibility\\", \\"cardio\\"]) []","solution":"def workout_sequence(stations): Returns the list of workout stations visited by the member before encountering the first \\"rest\\" station. result = [] for station in stations: if station == \\"rest\\": break result.append(station) return result"},{"question":"def two_sum_indices(array: List[int], target: int) -> Optional[List[int]]: Given a sorted array of unique integers and a target integer, this function returns the indices of the first two numbers that add up to the target. If no such numbers exist, return null. >>> two_sum_indices([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [0, 8] >>> two_sum_indices([1, 2, 3, 4], 8) == None","solution":"from typing import List, Optional def two_sum_indices(array: List[int], target: int) -> Optional[List[int]]: Returns the indices of the first two numbers that add up to the target. If no such numbers exist, returns null. left, right = 0, len(array) - 1 while left < right: current_sum = array[left] + array[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return None"},{"question":"def process_commands(commands: List[str]) -> str: Process a series of text editor commands and return the resulting text. :param commands: List of command strings (e.g., 'TYPE a', 'DELETE', 'UNDO') :return: The final text after processing all commands. >>> process_commands(['TYPE a', 'TYPE b', 'DELETE', 'TYPE c']) 'ac' >>> process_commands(['TYPE a', 'TYPE b', 'DELETE', 'TYPE c', 'UNDO']) 'a' >>> process_commands(['TYPE a', 'TYPE b', 'TYPE c']) 'abc' >>> process_commands(['TYPE a', 'TYPE b', 'DELETE', 'DELETE', 'TYPE c']) 'c' >>> process_commands(['TYPE a', 'TYPE b', 'TYPE c', 'DELETE', 'UNDO', 'UNDO', 'UNDO']) 'a' >>> process_commands(['TYPE x', 'TYPE y', 'DELETE', 'TYPE a', 'UNDO', 'TYPE b', 'TYPE c', 'UNDO', 'UNDO']) 'x'","solution":"def process_commands(commands): Process a series of text editor commands and return the resulting text. :param commands: List of command strings (e.g., 'TYPE a', 'DELETE', 'UNDO') :return: The final text after processing all commands. text = [] history = [] for command in commands: if command.startswith('TYPE'): _, char = command.split() text.append(char) history.append(('TYPE', char)) elif command == 'DELETE': if text: removed_char = text.pop() history.append(('DELETE', removed_char)) elif command == 'UNDO': if history: last_command, last_char = history.pop() if last_command == 'TYPE': text.pop() elif last_command == 'DELETE': text.append(last_char) return ''.join(text)"},{"question":"def strongest_potions(potions, k): Finds the combination of k potions that yields the highest possible combined strength. Args: potions: List of tuples, where each tuple contains an integer strength and a string identifier. k: Integer, number of potions to select to maximize the combined strength. Returns: List of strings, unique identifiers of the selected potions. pass # Unit Tests def test_basic_case(): potions = [(10, \\"Dragon's Breath\\"), (5, \\"Unicorn Horn\\"), (7, \\"Phoenix Feather\\"), (8, \\"Mermaid Scale\\"), (12, \\"Basilisk Fang\\")] k = 3 result = strongest_potions(potions, k) assert sorted(result) == sorted([\\"Basilisk Fang\\", \\"Dragon's Breath\\", \\"Mermaid Scale\\"]) def test_k_equals_2(): potions = [(10, \\"Dragon's Breath\\"), (5, \\"Unicorn Horn\\"), (7, \\"Phoenix Feather\\"), (8, \\"Mermaid Scale\\"), (12, \\"Basilisk Fang\\")] k = 2 result = strongest_potions(potions, k) assert sorted(result) == sorted([\\"Basilisk Fang\\", \\"Dragon's Breath\\"]) def test_with_negatives(): potions = [(3, \\"Spider Venom\\"), (-1, \\"Vampire Blood\\"), (0, \\"Goblin Earwax\\"), (7, \\"Troll Hair\\"), (2, \\"Elf Dust\\")] k = 2 result = strongest_potions(potions, k) assert sorted(result) == sorted([\\"Troll Hair\\", \\"Spider Venom\\"]) def test_large_k(): potions = [(4, \\"Witch Tear\\"), (3, \\"Leech Essence\\"), (2, \\"Bat Wing\\"), (5, \\"Fairy Dust\\")] k = 4 result = strongest_potions(potions, k) assert sorted(result) == sorted([\\"Witch Tear\\", \\"Leech Essence\\", \\"Bat Wing\\", \\"Fairy Dust\\"]) def test_all_negative_strengths(): potions = [(-3, \\"Golem Gravel\\"), (-5, \\"Ghost Dust\\"), (-1, \\"Zombie Toe\\"), (-2, \\"Werewolf Fur\\")] k = 3 result = strongest_potions(potions, k) assert sorted(result) == sorted([\\"Zombie Toe\\", \\"Werewolf Fur\\", \\"Golem Gravel\\"])","solution":"def strongest_potions(potions, k): Finds the combination of k potions that yields the highest possible combined strength. Args: potions: List of tuples, where each tuple contains an integer strength and a string identifier. k: Integer, number of potions to select to maximize the combined strength. Returns: List of strings, unique identifiers of the selected potions. # Sort potions by strength in descending order sorted_potions = sorted(potions, key=lambda x: x[0], reverse=True) # Select top k potions selected_potions = sorted_potions[:k] # Extract and return the identifiers of the selected potions return [potion[1] for potion in selected_potions]"},{"question":"def longest_nucleotide_subsequence(dna_sequence: str) -> int: Given a DNA sequence, return the length of the longest contiguous subsequence of the same nucleotide. :param dna_sequence: str : DNA sequence of characters 'A', 'C', 'G', 'T' :return: int : Length of the longest contiguous subsequence of the same nucleotide >>> longest_nucleotide_subsequence(\\"ATCGGATCC\\") 2 >>> longest_nucleotide_subsequence(\\"AACCCTGGG\\") 3 >>> longest_nucleotide_subsequence(\\"CCCC\\") 4","solution":"def longest_nucleotide_subsequence(dna_sequence): Given a DNA sequence, return the length of the longest contiguous subsequence of the same nucleotide. :param dna_sequence: str : DNA sequence of characters 'A', 'C', 'G', 'T' :return: int : Length of the longest contiguous subsequence of the same nucleotide if not dna_sequence: return 0 max_length = current_length = 1 for i in range(1, len(dna_sequence)): if dna_sequence[i] == dna_sequence[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def max_sum_of_three_trees(N: int, powers: List[int]) -> int: Find the maximum possible sum of the powers of any three different trees. Parameters: N (int): The number of trees. powers (list of int): The list of integers representing the magical powers of the trees. Returns: int: The maximum possible sum of the powers of any three different trees. >>> max_sum_of_three_trees(5, [8, 1, 9, -5, 4]) 21 >>> max_sum_of_three_trees(4, [3, 7, 2, 5]) 15 >>> max_sum_of_three_trees(4, [-3, -7, -2, -5]) -10 >>> max_sum_of_three_trees(6, [10, -1, 2, 6, -5, 4]) 20 >>> max_sum_of_three_trees(5, [1, 2, 3, 4, 5]) 12 >>> max_sum_of_three_trees(3, [-1, -2, -3]) -6 >>> max_sum_of_three_trees(5, [5, 5, 5, 5, 5]) 15 >>> max_sum_of_three_trees(5, [-1000, 500, 1000, -500, 0]) 1500","solution":"def max_sum_of_three_trees(N, powers): Find the maximum possible sum of the powers of any three different trees. Parameters: N (int): The number of trees. powers (list of int): The list of integers representing the magical powers of the trees. Returns: int: The maximum possible sum of the powers of any three different trees. # Sort the powers in descending order to get the three largest values easily sorted_powers = sorted(powers, reverse=True) # The maximum possible sum of three different trees is the sum of the three largest values return sum(sorted_powers[:3])"},{"question":"def calculate_total_cost(room_type: str, days: int) -> float: Returns the total cost for a customer's stay based on room type and number of days, after applying the appropriate discount. >>> calculate_total_cost(\\"Standard\\", 5) == 450.00 >>> calculate_total_cost(\\"Deluxe\\", 3) == 405.00 >>> calculate_total_cost(\\"Suite\\", 8) == 2040.00 >>> calculate_total_cost(\\"Suite\\", 2) == 600.00","solution":"def calculate_total_cost(room_type: str, days: int) -> float: Returns the total cost for a customer's stay based on room type and number of days, after applying the appropriate discount. # Define room rate based on room type rates = { \\"Standard\\": 100, \\"Deluxe\\": 150, \\"Suite\\": 300 } # Calculate base cost base_cost = rates[room_type] * days # Determine discount if days >= 7: discount_rate = 0.15 elif days >= 3: discount_rate = 0.10 else: discount_rate = 0.0 # Calculate total cost after discount total_cost = base_cost * (1 - discount_rate) # Return the result rounded to 2 decimal places return round(total_cost, 2)"},{"question":"def max_balanced_substrings(T: int, strings: List[str]) -> List[int]: Returns the maximum number of balanced substrings for each string in the list. Args: T: Integer, number of test cases. strings: List of strings. Returns: List of integers, each representing the maximum number of balanced substrings. >>> max_balanced_substrings(3, [\\"RLRRLLRLRL\\", \\"RLLLLRRRLR\\", \\"LLLLRRRR\\"]) [4, 3, 1] >>> max_balanced_substrings(1, [\\"RLRRLLRLRL\\"]) [4]","solution":"def max_balanced_substrings(T, strings): Returns the maximum number of balanced substrings for each string in the list. Args: T: Integer, number of test cases. strings: List of strings. Returns: List of integers, each representing the maximum number of balanced substrings. results = [] for S in strings: count_L = 0 count_R = 0 balanced_count = 0 for char in S: if char == 'L': count_L += 1 elif char == 'R': count_R += 1 if count_L == count_R: balanced_count += 1 count_L = 0 count_R = 0 results.append(balanced_count) return results"},{"question":"def sum_of_primes(n): Returns the sum of all prime numbers up to and including n. Args: n (int): The upper limit integer. Returns: int: The sum of all prime numbers up to and including n. Examples: >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(2) 2 >>> sum_of_primes(1) 0 >>> sum_of_primes(1000) 76127 >>> sum_of_primes(10000) 5736396 pass","solution":"def sum_of_primes(n): Returns the sum of all prime numbers up to and including n. if n < 2: return 0 primes = [True] * (n + 1) primes[0] = primes[1] = False # 0 and 1 are not prime numbers p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return sum(i for i in range(n + 1) if primes[i])"},{"question":"from typing import List def max_subsequence_with_difference(arr: List[int], d: int) -> int: Determine the maximum length of a subsequence such that every two consecutive elements in the subsequence have a difference of at most d. >>> max_subsequence_with_difference([4, 2, 1, 6, 5], 1) 3 >>> max_subsequence_with_difference([1, 3, 5, 7, 9], 1) 1 >>> max_subsequence_with_difference([1, 3, 6, 7, 9, 10], 2) 4 pass # Test cases def test_example1(): assert max_subsequence_with_difference([4, 2, 1, 6, 5], 1) == 3 def test_example2(): assert max_subsequence_with_difference([1, 3, 5, 7, 9], 1) == 1 def test_example3(): assert max_subsequence_with_difference([1, 3, 6, 7, 9, 10], 2) == 4 def test_single_element(): assert max_subsequence_with_difference([5], 1) == 1 def test_no_elements(): assert max_subsequence_with_difference([], 1) == 0 def test_same_elements(): assert max_subsequence_with_difference([2, 2, 2, 2], 0) == 4 def test_large_d_value(): assert max_subsequence_with_difference([1, 5, 3, 4, 2], 10) == 5 def test_large_input(): import random arr = list(range(1, 1001)) d = 10 assert max_subsequence_with_difference(arr, d) == 1000","solution":"def max_subsequence_with_difference(arr, d): Returns the maximum length of a subsequence such that every two consecutive elements in the subsequence have a difference of at most d. n = len(arr) if n == 0: return 0 # Sort array to consider elements in ascending order arr.sort() # Dynamic programming array dp = [1] * n # Length 1 for all elements initially # Update the DP table based on the previous elements for i in range(1, n): for j in range(i): if arr[i] - arr[j] <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"class BankSystem: Implements a simple banking system with account management and money transfer functionality. Methods: addAccount(String account, int initialBalance): Adds a new account with given name and initial balance. transfer(String sender, String receiver, int amount): Transfers amount from sender to receiver if possible. getBalance(String account): Returns the current balance of the account, or -1 if it doesn't exist. def __init__(self): Initializes the BankSystem object. pass def addAccount(self, account, initialBalance): Adds a new account with given name and initial balance. Parameters: account (str): The name of the account to be added. initialBalance (int): The initial balance of the account. pass def transfer(self, sender, receiver, amount): Transfers the specified amount from the sender to the receiver if possible. Parameters: sender (str): The name of the account to transfer money from. receiver (str): The name of the account to transfer money to. amount (int): The amount of money to transfer. Returns: bool: True if the transfer was successful, False otherwise. pass def getBalance(self, account): Returns the current balance of the given account. Parameters: account (str): The name of the account to check the balance of. Returns: int: The current balance of the account, or -1 if the account does not exist. pass # Unit Tests def test_addAccount_and_getBalance(): bank = BankSystem() bank.addAccount(\\"Alice\\", 1000) assert bank.getBalance(\\"Alice\\") == 1000 def test_transfer_successful(): bank = BankSystem() bank.addAccount(\\"Alice\\", 1000) bank.addAccount(\\"Bob\\", 500) assert bank.transfer(\\"Alice\\", \\"Bob\\", 300) == True assert bank.getBalance(\\"Alice\\") == 700 assert bank.getBalance(\\"Bob\\") == 800 def test_transfer_insufficient_funds(): bank = BankSystem() bank.addAccount(\\"Alice\\", 1000) bank.addAccount(\\"Bob\\", 500) assert bank.transfer(\\"Alice\\", \\"Bob\\", 1100) == False assert bank.getBalance(\\"Alice\\") == 1000 assert bank.getBalance(\\"Bob\\") == 500 def test_transfer_nonexistent_account(): bank = BankSystem() bank.addAccount(\\"Alice\\", 1000) assert bank.transfer(\\"Alice\\", \\"Charlie\\", 100) == False assert bank.getBalance(\\"Alice\\") == 1000 assert bank.getBalance(\\"Charlie\\") == -1 def test_getBalance_nonexistent_account(): bank = BankSystem() assert bank.getBalance(\\"NonExistent\\") == -1","solution":"class BankSystem: def __init__(self): # Initializes the BankSystem object self.accounts = {} # Dictionary to hold account name and their balance def addAccount(self, account, initialBalance): self.accounts[account] = initialBalance def transfer(self, sender, receiver, amount): # Transfer function to implement account to account transfer. if sender in self.accounts and receiver in self.accounts and self.accounts[sender] >= amount: self.accounts[sender] -= amount self.accounts[receiver] += amount return True return False def getBalance(self, account): # Function to get the balance of any existing account return self.accounts.get(account, -1)"},{"question":"def find_mode(numbers: List[int]) -> int: Calculate the mode of a list of integers. If there are multiple values that appear with the same highest frequency, return the smallest of these values. >>> find_mode([2, 2, 3, 3, 4]) 2 >>> find_mode([5, 1, 1, 5, 3, 3]) 1 >>> find_mode([10, 11, 12, 13]) 10 >>> find_mode([7]) 7 >>> find_mode([5, 5, 5, 5]) 5","solution":"from typing import List from collections import Counter def find_mode(numbers: List[int]) -> int: Returns the mode of the list of numbers. If there's a tie, returns the smallest number among them. count = Counter(numbers) max_frequency = max(count.values()) # Get all numbers with the maximum frequency mode_candidates = [number for number, freq in count.items() if freq == max_frequency] return min(mode_candidates)"},{"question":"from typing import List, Tuple def find_longest_zero_sequence(S: List[int], L: int, R: int) -> int: Finds the longest contiguous subarray of '0's within the subarray of S from index L to R. Args: S (List[int]): The sequence of integers L (int): The starting index of the subarray (1-based index) R (int): The ending index of the subarray (1-based index) Returns: int: The length of the longest contiguous subarray of '0's >>> find_longest_zero_sequence([1, 0, 0, 1, 0, 1, 1, 0, 0, 0], 1, 10) 3 >>> find_longest_zero_sequence([1, 0, 0, 1, 0, 1, 1, 0, 0, 0], 2, 7) 2 >>> find_longest_zero_sequence([1, 0, 0, 1, 0, 1, 1, 0, 0, 0], 8, 10) 3 def process_queries(N: int, Q: int, S: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes multiple queries to find the longest contiguous subarray of '0's. Args: N (int): Length of the sequence S Q (int): Number of queries S (List[int]): The sequence of integers queries (List[Tuple[int, int]]): List of queries where each query is a tuple (L, R) Returns: List[int]: List of results for each query >>> process_queries(10, 6, [1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [(1, 10), (2, 7), (8, 10), (1, 7), (4, 9), (5, 10)]) [3, 2, 3, 2, 2, 3] >>> process_queries(11, 3, [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [(1, 11), (2, 5), (4, 8)]) [4, 2, 3]","solution":"def find_longest_zero_sequence(S, L, R): Finds the longest contiguous subarray of '0's within the subarray of S from index L to R. # To handle 1-based index L and R. subarray = S[L-1:R] max_length, current_length = 0, 0 for num in subarray: if num == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length def process_queries(N, Q, S, queries): results = [] for L, R in queries: results.append(find_longest_zero_sequence(S, L, R)) return results"},{"question":"def determine_winner(n: int, arr: List[int]) -> str: Determines the winner of the game given the initial array configuration. Parameters: n (int): The size of the array. arr (List[int]): The elements of the array. Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" if Bob wins the game. >>> determine_winner(3, [1, 2, 3]) \\"Alice\\" >>> determine_winner(3, [-1, -2, -3]) \\"Bob\\" >>> determine_winner(5, [0, 0, 0, 0, 0]) \\"Alice\\" >>> determine_winner(4, [0, 0, 0, 0]) \\"Bob\\" >>> determine_winner(4, [1, -2, 3, 4]) \\"Alice\\" >>> determine_winner(4, [-1, 2, -3, -4]) \\"Bob\\" >>> determine_winner(1, [5]) \\"Alice\\" >>> determine_winner(1, [-5]) \\"Bob\\" >>> determine_winner(1, [0]) \\"Alice\\" pass","solution":"def determine_winner(n, arr): Determines the winner of the game given the initial array configuration. total_sum = sum(arr) if total_sum > 0: return \\"Alice\\" elif total_sum < 0: return \\"Bob\\" else: # When the total sum is 0, it depends on the parity of the length of the array return \\"Alice\\" if n % 2 != 0 else \\"Bob\\""},{"question":"def is_robot_at_origin(commands: str) -> bool: Determines if the robotic arm returns to the origin after executing all the commands. >>> is_robot_at_origin(\\"UD\\") True >>> is_robot_at_origin(\\"LL\\") False >>> is_robot_at_origin(\\"RRDD\\") False >>> is_robot_at_origin(\\"LDRRLRUULR\\") False >>> is_robot_at_origin(\\"\\") True >>> is_robot_at_origin(\\"LRUD\\") True >>> is_robot_at_origin(\\"RRLUDDL\\") False >>> is_robot_at_origin(\\"UUDDLLRR\\" * 1250) True >>> is_robot_at_origin(\\"ULDRULDRULDRULDR\\") True","solution":"def is_robot_at_origin(commands: str) -> bool: Determines if the robotic arm returns to the origin after executing all the commands. Arguments: commands : str : sequence of commands consisting of 'U', 'D', 'L', and 'R' Returns: bool : True if the robotic arm returns to the origin, else False x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x == 0 and y == 0"},{"question":"from typing import List, Tuple def max_length_subarray_with_k_distinct(arr: List[int], N: int, K: int) -> int: Find the maximum length of a subarray with at most K different integers. Args: arr : List[int] - the array of integers N : int - the length of the array K : int - the maximum number of different integers allowed in the subarray Returns: int - the maximum length of such a subarray Examples: >>> max_length_subarray_with_k_distinct([1, 2, 1, 2, 3], 5, 2) 4 >>> max_length_subarray_with_k_distinct([1, 2, 1, 3, 4, 3, 3], 7, 3) 5 # Your code here def run_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: results = [] for N, K, arr in test_cases: result = max_length_subarray_with_k_distinct(arr, N, K) results.append(result) return results def test_max_length_subarray_with_k_distinct(): test_cases = [ (5, 2, [1, 2, 1, 2, 3]), (7, 3, [1, 2, 1, 3, 4, 3, 3]), (6, 1, [1, 2, 1, 2, 3, 3]), (5, 5, [1, 2, 3, 4, 5]), (7, 2, [4, 4, 4, 4, 4, 4, 4]) ] expected_results = [4, 5, 2, 5, 7] results = run_test_cases(test_cases) assert results == expected_results def test_edge_cases(): test_cases = [ (1, 1, [1]), # Smallest case (3, 3, [1, 2, 3]), # K equal to N (3, 2, [1, 1, 1]), # Same element repeated ] expected_results = [1, 3, 3] results = run_test_cases(test_cases) assert results == expected_results","solution":"def max_length_subarray_with_k_distinct(arr, N, K): from collections import defaultdict left = 0 right = 0 max_length = 0 count = defaultdict(int) distinct_count = 0 while right < N: if count[arr[right]] == 0: distinct_count += 1 count[arr[right]] += 1 right += 1 while distinct_count > K: count[arr[left]] -= 1 if count[arr[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length def run_test_cases(test_cases): results = [] for N, K, arr in test_cases: result = max_length_subarray_with_k_distinct(arr, N, K) results.append(result) return results"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Finds the total number of continuous subarrays whose sum equals k. :param nums: List[int] - list of integers. :param k: int - target sum. :return: int - total number of continuous subarrays with sum equal to k. Example: >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, -1, 1, -1, 1, -1], 0) 9","solution":"from collections import defaultdict def subarray_sum(nums, k): Finds the total number of continuous subarrays whose sum equals k. :param nums: List[int] - list of integers. :param k: int - target sum. :return: int - total number of continuous subarrays with sum equal to k. count = 0 sum_so_far = 0 sum_count = defaultdict(int) sum_count[0] = 1 for num in nums: sum_so_far += num if (sum_so_far - k) in sum_count: count += sum_count[sum_so_far - k] sum_count[sum_so_far] += 1 return count"},{"question":"import numpy as np def concatenate_arrays(N, M, P, array_1, array_2): Concatenates two given arrays of size NxP and MxP along axis 0. Parameters: N (int): Number of rows in the first array M (int): Number of rows in the second array P (int): Number of columns in both arrays array_1 (list of list of int): The first array array_2 (list of list of int): The second array Returns: numpy.ndarray: The concatenated array >>> N, M, P = 2, 2, 2 >>> array_1 = [[1, 2], [3, 4]] >>> array_2 = [[5, 6], [7, 8]] >>> concatenate_arrays(N, M, P, array_1, array_2) array([[1, 2], [3, 4], [5, 6], [7, 8]]) >>> N, M, P = 1, 1, 1 >>> array_1 = [[1]] >>> array_2 = [[2]] >>> concatenate_arrays(N, M, P, array_1, array_2) array([[1], [2]])","solution":"import numpy as np def concatenate_arrays(N, M, P, array_1, array_2): Concatenates two given arrays of size NxP and MxP along axis 0. Parameters: N (int): Number of rows in the first array M (int): Number of rows in the second array P (int): Number of columns in both arrays array_1 (list of list of int): The first array array_2 (list of list of int): The second array Returns: numpy.ndarray: The concatenated array array_1_np = np.array(array_1) array_2_np = np.array(array_2) concatenated_array = np.concatenate((array_1_np, array_2_np), axis=0) return concatenated_array"},{"question":"from typing import List def cumulative_sum(matrix: List[List[int]]) -> List[List[int]]: Takes a 2D matrix of integers and returns a new matrix showing the cumulative sum from the top left corner to each position. >>> cumulative_sum([ ... [1, 2], ... [3, 4] ... ]) == [ ... [1, 3], ... [4, 10] ... ] >>> cumulative_sum([ ... [1] ... ]) == [ ... [1] ... ]","solution":"def cumulative_sum(matrix): Takes a 2D matrix of integers and returns a new matrix showing the cumulative sum from the top left corner to each position. if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) result = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): result[i][j] = matrix[i][j] if i > 0: result[i][j] += result[i-1][j] if j > 0: result[i][j] += result[i][j-1] if i > 0 and j > 0: result[i][j] -= result[i-1][j-1] return result"},{"question":"def arrayDiff(array, values): Returns a new array that is identical to the first array but with all instances of elements from the 'values' array removed. Parameters: array (list of int): The original array. values (list of int): The elements to be removed from the array. Returns: list of int: The new array with the elements removed. Examples: >>> arrayDiff([1,2,3,4], [2,4]) == [1,3] >>> arrayDiff([1,2,2,2,3], [2]) == [1,3] >>> arrayDiff([1,2,3,4], [5,6]) == [1,2,3,4] >>> arrayDiff([], [2,4]) == [] >>> arrayDiff([1,2,3], []) == [1,2,3]","solution":"def arrayDiff(array, values): Returns a new array that is identical to the first array but with all instances of elements from the 'values' array removed. Parameters: array (list of int): The original array. values (list of int): The elements to be removed from the array. Returns: list of int: The new array with the elements removed. return [item for item in array if item not in values]"},{"question":"def repeat_characters(s: str, n: int) -> str: Given a string \`s\` and an integer \`n\`, returns a new string constructed by repeating each character in the original string \`n\` times. Parameters: s (str): The original string. n (int): The number of times each character should be repeated. Returns: str: The new string with repeated characters. >>> repeat_characters(\\"abc\\", 3) \\"aaabbbccc\\" >>> repeat_characters(\\"123\\", 2) \\"112233\\" >>> repeat_characters(\\"aA1\\", 1) \\"aA1\\"","solution":"def repeat_characters(s, n): Returns a new string where each character in the original string \`s\` is repeated \`n\` times. Parameters: s (str): The original string. n (int): The number of times each character should be repeated. Returns: str: The new string with repeated characters. return ''.join([char * n for char in s])"},{"question":"def largest_rectangle_area(heights): Calculates the largest rectangular area possible in a histogram. Each building has a width of 1. :param heights: List[int] - An array of integers representing the building heights. :return: int - The area of the largest rectangle in the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 pass # Your implementation here","solution":"def largest_rectangle_area(heights): Calculates the largest rectangular area possible in a histogram. Each building has a width of 1. :param heights: List[int] - An array of integers representing the building heights. :return: int - The area of the largest rectangle in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() if stack: area = heights[top_of_stack] * (index - stack[-1] - 1) else: area = heights[top_of_stack] * index max_area = max(max_area, area) while stack: top_of_stack = stack.pop() if stack: area = heights[top_of_stack] * (index - stack[-1] - 1) else: area = heights[top_of_stack] * index max_area = max(max_area, area) return max_area"},{"question":"def max_apples(grid: List[List[int]]) -> int: Determine the maximum number of apples the robot can collect by the time it reaches the bottom-right corner of the grid. >>> max_apples([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_apples([[1, 2, 3, 4, 5]]) 15 >>> max_apples([[1], [2], [3], [4], [5]]) 15","solution":"def max_apples(grid): N = len(grid) M = len(grid[0]) # Create a dp table with the same dimensions as the grid dp = [[0] * M for _ in range(N)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (only possible moves are from the left) for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (only possible moves are from above) for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the maximum number of apples return dp[N - 1][M - 1]"},{"question":"def items_within_budget(items: dict, budget: float) -> list: Returns a list of item names that can be purchased within the given budget. Parameters: items (dict): A dictionary where keys are item names (strings) and values are prices (floats). budget (float): The available budget. Returns: list: A list of item names that can be purchased within the budget, sorted in alphabetical order. >>> items = {\\"apple\\": 1.50, \\"banana\\": 0.50, \\"cherry\\": 2.00, \\"date\\": 1.00, \\"elderberry\\": 1.75} >>> budget = 1.50 >>> items_within_budget(items, budget) ['apple', 'banana', 'date'] pass","solution":"def items_within_budget(items, budget): Returns a list of item names that can be purchased within the given budget. Parameters: items (dict): A dictionary where keys are item names (strings) and values are prices (floats). budget (float): The available budget. Returns: list: A list of item names that can be purchased within the budget, sorted in alphabetical order. affordable_items = [] for item, price in items.items(): if price <= budget: affordable_items.append(item.lower()) return sorted(affordable_items)"},{"question":"from typing import List def longest_odd_subarray(arr: List[int]) -> int: Returns the length of the longest subarray containing only odd numbers. >>> longest_odd_subarray([1, 2, 3, 5, 7, 2, 6]) 3 >>> longest_odd_subarray([2, 4, 6, 8]) 0 >>> longest_odd_subarray([1, 3, 5, 7, 9]) 5 pass # Unit Tests def test_example_1(): assert longest_odd_subarray([1, 2, 3, 5, 7, 2, 6]) == 3 def test_example_2(): assert longest_odd_subarray([2, 4, 6, 8]) == 0 def test_example_3(): assert longest_odd_subarray([1, 3, 5, 7, 9]) == 5 def test_mixed_numbers(): assert longest_odd_subarray([1, 3, 2, 3, 5, 7, 2, 1, 1, 1]) == 3 def test_all_odd_numbers(): assert longest_odd_subarray([1, 1, 1, 1, 1]) == 5 def test_single_odd_number(): assert longest_odd_subarray([2, 4, 6, 1, 8]) == 1 def test_no_element(): assert longest_odd_subarray([]) == 0 def test_all_single_even_numbers(): assert longest_odd_subarray([2, 4, 6, 8, 10]) == 0 def test_single_element_odd(): assert longest_odd_subarray([3]) == 1 def test_single_element_even(): assert longest_odd_subarray([4]) == 0","solution":"def longest_odd_subarray(arr): Returns the length of the longest subarray containing only odd numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 != 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def letterCount(sentence: str) -> dict: Counts the occurrences of each letter in a given sentence, case insensitive and ignoring non-alphabetic characters, numbers, and spaces. >>> letterCount(\\"Hello World!\\") == {'H': 1, 'E': 1, 'L': 3, 'O': 2, 'W': 1, 'R': 1, 'D': 1} >>> letterCount(\\"aA\\") == {'A': 2} >>> letterCount(\\"123 abc !! def\\") == {'A': 1, 'B': 1, 'C': 1, 'D': 1, 'E': 1, 'F': 1} >>> letterCount(\\"\\") == {}","solution":"def letterCount(sentence): Counts the occurrences of each letter in a given sentence. Returns a dictionary with uppercase alphabetic characters as keys and their counts as values. counts = {} for char in sentence: if char.isalpha(): char = char.upper() counts[char] = counts.get(char, 0) + 1 return counts"},{"question":"def can_win_game(grid: List[str], n: int, m: int) -> str: Determine if it is possible for the player to collect all power-ups and reach the top-right corner of the grid. >>> can_win_game([\\"P..\\", \\".O.\\", \\"..P\\"], 3, 3) \\"YES\\" >>> can_win_game([\\"P.O\\", \\".O.\\", \\"..P\\"], 3, 3) \\"NO\\"","solution":"def can_win_game(grid, n, m): def is_valid(x, y, visited): if 0 <= x < n and 0 <= y < m and grid[x][y] != 'O' and not visited[x][y]: return True return False def dfs(x, y, visited, power_ups_collected): if not is_valid(x, y, visited): return False if grid[x][y] == 'P': power_ups_collected -= 1 if power_ups_collected == 0 and (x == 0 and y == m - 1): return True visited[x][y] = True # Move up, down, left, right if (dfs(x - 1, y, visited, power_ups_collected) or dfs(x + 1, y, visited, power_ups_collected) or dfs(x, y - 1, visited, power_ups_collected) or dfs(x, y + 1, visited, power_ups_collected)): return True visited[x][y] = False return False power_ups = sum(row.count('P') for row in grid) visited = [[False for _ in range(m)] for _ in range(n)] return \\"YES\\" if dfs(0, 0, visited, power_ups) else \\"NO\\""},{"question":"def format_numbers_with_commas(text: str) -> str: Formats numbers in the input text by adding commas as thousands separators. Parameters: text (str): Input string containing numbers and other characters. Returns: str: New string with numbers formatted with commas. >>> format_numbers_with_commas(\\"Here is a number 12345 and another 6789\\") 'Here is a number 12,345 and another 6,789' >>> format_numbers_with_commas(\\"My phone number is 1234567890 and my ID is 987654321\\") 'My phone number is 1,234,567,890 and my ID is 987,654,321' >>> format_numbers_with_commas(\\"No digit here!\\") 'No digit here!' >>> format_numbers_with_commas(\\"1234 5678 90\\") '1,234 5,678 90' >>> format_numbers_with_commas(\\"123456\\") '123,456' >>> format_numbers_with_commas(\\"Contact: 1234567890\\") 'Contact: 1,234,567,890' >>> format_numbers_with_commas(\\"This is a sample 1234text678 containing numbers like 1234567 in between\\") 'This is a sample 1,234text678 containing numbers like 1,234,567 in between' >>> format_numbers_with_commas(\\"\\") ''","solution":"import re def format_numbers_with_commas(text: str) -> str: Formats numbers in the input text by adding commas as thousands separators. Parameters: text (str): Input string containing numbers and other characters. Returns: str: New string with numbers formatted with commas. def format_with_commas(match): Helper function to format a matched number with commas. number = match.group(0) return \\"{:,}\\".format(int(number)) # Use regex to find all sequences of digits and apply the formatting function to each. return re.sub(r'd+', format_with_commas, text)"},{"question":"def generate_pascals_triangle(numRows): Generate the first numRows of Pascal's triangle. >>> generate_pascals_triangle(0) [] >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(2) [[1], [1, 1]] >>> generate_pascals_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]","solution":"def generate_pascals_triangle(numRows): Generate the first numRows of Pascal's triangle. if numRows == 0: return [] triangle = [[1]] for row_number in range(1, numRows): row = [1] for j in range(1, row_number): row.append(triangle[row_number - 1][j - 1] + triangle[row_number - 1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"def trap(height: List[int]) -> int: Calculate the total volume of trapped rainwater given the heights of the buildings. :param height: List[int] - a list of integers representing heights of buildings. :return: int - total volume of trapped rainwater. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([2,0,2]) 2","solution":"def trap(height): Calculate the total volume of trapped rainwater given the heights of the buildings. :param height: List[int] - a list of integers representing heights of buildings. :return: int - total volume of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) total_water = 0 for i in range(n): total_water += max(0, min(left_max[i], right_max[i]) - height[i]) return total_water"},{"question":"def max_subarray_sum(arr): Finds the contiguous subarray (containing at least one number) which has the largest sum and returns its sum. Parameters: arr (list of int): A list of integers. Returns: int: The sum of the contiguous subarray with the largest sum. Example: >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5,4,-1,7,8]) 23","solution":"def max_subarray_sum(arr): Finds the contiguous subarray that has the largest sum using Kadane's Algorithm. Parameters: arr (list of int): A list of integers. Returns: int: The sum of the contiguous subarray with the largest sum. # Initialize the maximum sum to the smallest possible integer max_so_far = float('-inf') # Initialize the current subarray sum to 0 max_ending_here = 0 for num in arr: # Add the current number to the current subarray sum max_ending_here += num # Update the maximum sum if the current subarray sum is larger max_so_far = max(max_so_far, max_ending_here) # Reset the current subarray sum to 0 if it becomes negative if max_ending_here < 0: max_ending_here = 0 return max_so_far"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring of s that contains no more than two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") == 2","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring of s that contains no more than two distinct characters. n = len(s) if n < 3: return n left = 0 right = 0 max_length = 2 hashmap = {} while right < n: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_length = max(max_length, right - left) return max_length"},{"question":"def simpleCalculator(expression: str) -> int: Evaluates a simple mathematical expression string and returns the result as an integer. The function handles non-negative integers and operators '+', '-', '*', '/', following usual precedence rules, and ignoring spaces. Examples: >>> simpleCalculator(\\"3+2*2\\") 7 >>> simpleCalculator(\\" 3/2 \\") 1 >>> simpleCalculator(\\" 3+5 / 2 \\") 5 pass # Unit Tests def test_simple_addition(): assert simpleCalculator(\\"3+2\\") == 5 def test_simple_subtraction(): assert simpleCalculator(\\"5-3\\") == 2 def test_simple_multiplication(): assert simpleCalculator(\\"4*2\\") == 8 def test_simple_division(): assert simpleCalculator(\\"8/2\\") == 4 def test_combined_operations(): assert simpleCalculator(\\"3+2*2\\") == 7 assert simpleCalculator(\\"3/2 + 1\\") == 2 assert simpleCalculator(\\"3+5 / 2\\") == 5 def test_with_spaces(): assert simpleCalculator(\\" 3 + 2*2 \\") == 7 assert simpleCalculator(\\" 3 / 2 + 1 \\") == 2 def test_large_expression(): expr = \\"10+20*30-40/5\\" assert simpleCalculator(expr) == 10 + 20*30 - 40//5 def test_expression_with_same_precedence(): assert simpleCalculator(\\"12/4*2\\") == 6 def test_edge_case_empty_string(): assert simpleCalculator(\\"\\") == 0","solution":"def simpleCalculator(expression): Evaluates a simple mathematical expression string and returns the result as an integer. if not expression: return 0 # Remove spaces expression = expression.replace(' ', '') def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left // right) def precedence(operator): if operator in {'+', '-'}: return 1 if operator in {'*', '/'}: return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): j = i while j < len(expression) and expression[j].isdigit(): j += 1 values.append(int(expression[i:j])) i = j - 1 else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def max_targets_hit(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the maximum number of targets an archer can hit with given arrows in multiple test cases. Parameters: T (int): The number of test cases. test_cases (List[Dict[str, Any]]): A list of test cases where each test_case is a dictionary containing: - 'NM' (Tuple[int, int]): A tuple with two integers; the number of targets (N) and the number of arrows (M). - 'targets' (List[int]): List of integers representing the distances of the targets. - 'arrows' (List[int]): List of integers representing the maximum reach of the arrows. Returns: List[int]: A list of integers where each integer represents the maximum number of targets hit for each test case. Example: >>> T = 2 >>> test_cases = [ ... {'NM': (5, 3), 'targets': [15, 25, 35, 45, 55], 'arrows': [30, 50, 10]}, ... {'NM': (4, 4), 'targets': [10, 20, 30, 40], 'arrows': [25, 35, 15, 45]} ... ] >>> max_targets_hit(T, test_cases) [2, 4] from typing import List, Dict, Any def test_example_cases(): T = 2 test_cases = [ {'NM': (5, 3), 'targets': [15, 25, 35, 45, 55], 'arrows': [30, 50, 10]}, {'NM': (4, 4), 'targets': [10, 20, 30, 40], 'arrows': [25, 35, 15, 45]} ] assert max_targets_hit(T, test_cases) == [2, 4] def test_no_arrows(): T = 1 test_cases = [ {'NM': (5, 0), 'targets': [15, 25, 35, 45, 55], 'arrows': []} ] assert max_targets_hit(T, test_cases) == [0] def test_no_targets(): T = 1 test_cases = [ {'NM': (0, 5), 'targets': [], 'arrows': [5, 10, 15, 20, 25]} ] assert max_targets_hit(T, test_cases) == [0] def test_all_arrows_hit_all_targets(): T = 1 test_cases = [ {'NM': (5, 5), 'targets': [1, 2, 3, 4, 5], 'arrows': [1, 10, 10, 10, 10]} ] assert max_targets_hit(T, test_cases) == [5] def test_insufficient_arrows(): T = 1 test_cases = [ {'NM': (5, 3), 'targets': [1, 2, 3, 4, 5], 'arrows': [1, 2, 3]} ] assert max_targets_hit(T, test_cases) == [3] def test_insufficient_reach(): T = 1 test_cases = [ {'NM': (5, 5), 'targets': [1, 2, 3, 4, 5], 'arrows': [1, 1, 1, 1, 1]} ] assert max_targets_hit(T, test_cases) == [1]","solution":"def max_targets_hit(T, test_cases): result = [] for case in test_cases: N, M = case['NM'] targets = case['targets'] arrows = case['arrows'] # Sort both the lists targets.sort() arrows.sort() hit_count = 0 i, j = 0, 0 # Use two pointers to find maximum number of hits while i < N and j < M: if arrows[j] >= targets[i]: hit_count += 1 i += 1 j += 1 result.append(hit_count) return result # Example usage T = 2 test_cases = [ {'NM': (5, 3), 'targets': [15, 25, 35, 45, 55], 'arrows': [30, 50, 10]}, {'NM': (4, 4), 'targets': [10, 20, 30, 40], 'arrows': [25, 35, 15, 45]} ] result = max_targets_hit(T, test_cases) for res in result: print(res)"},{"question":"from typing import List def is_non_palindromic_in_any_base(k: int) -> str: Check if the integer k can be represented as a non-palindromic number in any base B (2 ≤ B ≤ 10). def solve(t: int, numbers: List[int]) -> List[str]: Solve for t test cases whether each number can be represented as a non-palindromic number in any base between 2 and 10. def test_is_non_palindromic_in_any_base(): assert is_non_palindromic_in_any_base(13) == \\"YES\\" assert is_non_palindromic_in_any_base(7) == \\"NO\\" assert is_non_palindromic_in_any_base(19) == \\"YES\\" assert is_non_palindromic_in_any_base(22) == \\"YES\\" assert is_non_palindromic_in_any_base(5) == \\"YES\\" def test_solve(): assert solve(3, [13, 7, 19]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert solve(2, [22, 5]) == [\\"YES\\", \\"YES\\"] assert solve(4, [7, 7, 7, 7]) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_non_palindromic_in_any_base(k): Check if the integer k can be represented as a non-palindromic number in any base B (2 ≤ B ≤ 10). # A function to convert the number \`n\` to a string in base \`b\` def to_base(n, b): result = [] while n > 0: result.append(str(n % b)) n //= b return ''.join(result[::-1]) if k == 7: return \\"NO\\" # as 7 is palindromic in any base from 2 to 10 # Check for bases from 2 to 10 for base in range(2, 11): representation = to_base(k, base) if representation != representation[::-1]: return \\"YES\\" return \\"NO\\" def solve(t, numbers): Solve for t test cases whether each number can be represented as a non-palindromic number in any base between 2 and 10. results = [] for k in numbers: results.append(is_non_palindromic_in_any_base(k)) return results"},{"question":"def largest_contiguous_region(N: int, M: int, grid: List[List[int]]) -> int: Compute the largest contiguous region on the grid that the player can traverse starting from any cell. >>> largest_contiguous_region(4, 5, [ ... [1, 1, 2, 3, 4], ... [1, 5, 2, 2, 3], ... [4, 1, 1, 2, 2], ... [1, 4, 4, 4, 4] ... ]) 5 >>> largest_contiguous_region(1, 1, [ ... [0] ... ]) 1 >>> largest_contiguous_region(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> largest_contiguous_region(3, 3, [ ... [1, 2, 3], ... [4, 1, 6], ... [7, 8, 1] ... ]) 1 >>> largest_contiguous_region(4, 4, [ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]) 12","solution":"def largest_contiguous_region(N, M, grid): def dfs(x, y, terrain_type): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if 0 <= cx < N and 0 <= cy < M and grid[cx][cy] == terrain_type: grid[cx][cy] = -1 # mark as visited size += 1 # add neighboring cells stack.append((cx+1, cy)) stack.append((cx-1, cy)) stack.append((cx, cy+1)) stack.append((cx, cy-1)) return size max_region_size = 0 for i in range(N): for j in range(M): if grid[i][j] != -1: region_size = dfs(i, j, grid[i][j]) max_region_size = max(max_region_size, region_size) return max_region_size # Example Usage if __name__ == \\"__main__\\": N = 4 M = 5 grid = [ [1, 1, 2, 3, 4], [1, 5, 2, 2, 3], [4, 1, 1, 2, 2], [1, 4, 4, 4, 4], ] print(largest_contiguous_region(N, M, grid)) # Output: 5"},{"question":"def findPrimes(n: int) -> List[int]: Write a function that takes a non-negative integer n and returns an array of all the prime numbers less than n. A prime number is a natural number greater than 1 and cannot be formed by multiplying two smaller natural numbers. For example, given \`n = 10\`, the function should return \`[2, 3, 5, 7]\` because these are the prime numbers less than 10. Examples: >>> findPrimes(10) [2, 3, 5, 7] >>> findPrimes(0) [] >>> findPrimes(1) [] >>> findPrimes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def findPrimes(n): Returns a list of all prime numbers less than n. if n <= 2: return [] # Sieve of Eratosthenes is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for i in range(2, int(n ** 0.5) + 1): if is_prime[i]: for j in range(i * i, n, i): is_prime[j] = False return [i for i in range(n) if is_prime[i]]"},{"question":"def canArrangeSeats(n, groups): Function to check if groups can be seated as per their preferences. Parameters: n (int): Number of seats. groups (list of tuples): Each tuple contains two integers: size of the group and the desired starting index. Returns: list of bool: Boolean values indicating whether the respective group can be seated. pass # Example test cases. if __name__ == \\"__main__\\": assert canArrangeSeats(10, [(3, 0), (4, 4), (2, 3)]) == [True, True, False] assert canArrangeSeats(5, [(2, 0), (2, 1), (1, 4)]) == [True, False, True] assert canArrangeSeats(5, [(6, 0)]) == [False] assert canArrangeSeats(5, [(1, 5)]) == [False] assert canArrangeSeats(5, [(2, 0), (3, 2)]) == [True, True] assert canArrangeSeats(6, [(3, 0), (3, 2)]) == [True, False] assert canArrangeSeats(8, [(2, 0), (2, 2), (2, 4)]) == [True, True, True] assert canArrangeSeats(10, [(5, 0), (5, 5)]) == [True, True] assert canArrangeSeats(5, [(5, 0), (1, 0)]) == [True, False]","solution":"def canArrangeSeats(n, groups): Function to check if groups can be seated as per their preferences. Parameters: n (int): Number of seats. groups (list of tuples): Each tuple contains two integers: size of the group and the desired starting index. Returns: list of bool: Boolean values indicating whether the respective group can be seated. # Create a list to keep track of occupied seats seats = [False] * n result = [] for size, start_index in groups: if start_index + size > n: result.append(False) continue can_seat = True for i in range(start_index, start_index + size): if seats[i]: can_seat = False break if can_seat: for i in range(start_index, start_index + size): seats[i] = True result.append(True) else: result.append(False) return result"},{"question":"def longest_digit_substring(s: str) -> int: Returns the length of the longest substring that contains only digits. >>> longest_digit_substring(\\"abc1234567def89\\") 7 >>> longest_digit_substring(\\"abc123def\\") 3 >>> longest_digit_substring(\\"abcd\\") 0 >>> longest_digit_substring(\\"\\") 0 >>> longest_digit_substring(\\"1234567890\\") 10 >>> longest_digit_substring(\\"abc12de34567fg89hi0\\") 5 >>> longest_digit_substring(\\"abcdef123456\\") 6 >>> longest_digit_substring(\\"123456xyz789\\") 6 >>> longest_digit_substring(\\"a1b2c3\\") 1","solution":"def longest_digit_substring(s): Returns the length of the longest substring that contains only digits. max_len = 0 current_len = 0 for char in s: if char.isdigit(): current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 return max_len"},{"question":"def determine_palindromes(T: int, test_cases: List[str]) -> List[str]: Given a number of test cases, determine if each string can be transformed into a palindrome by changing at most one character. Args: T (int): Number of test cases. test_cases (List[str]): List of strings to be tested. Returns: List[str]: List of \\"YES\\" or \\"NO\\" results for each test case. >>> determine_palindromes(3, [\\"abca\\", \\"abcba\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> determine_palindromes(2, [\\"a\\", \\"b\\"]) [\\"YES\\", \\"YES\\"] from typing import List def test_mixed_cases(): T = 3 test_cases = [\\"abca\\", \\"abcba\\", \\"abcdef\\"] assert determine_palindromes(T, test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_single_cases(): T = 2 test_cases = [\\"a\\", \\"b\\"] assert determine_palindromes(T, test_cases) == [\\"YES\\", \\"YES\\"] def test_already_palindromes(): T = 2 test_cases = [\\"racecar\\", \\"madam\\"] assert determine_palindromes(T, test_cases) == [\\"YES\\", \\"YES\\"] def test_near_palindromes(): T = 2 test_cases = [\\"raccecar\\", \\"madbm\\"] assert determine_palindromes(T, test_cases) == [\\"YES\\", \\"YES\\"] def test_non_palindromes(): T = 2 test_cases = [\\"example\\", \\"testing\\"] assert determine_palindromes(T, test_cases) == [\\"NO\\", \\"NO\\"] def test_edge_cases(): T = 3 test_cases = [\\"\\", \\"a\\", \\"aa\\"] assert determine_palindromes(T, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_be_palindrome_with_one_change(s): Helper function to determine if a string can become a palindrome by changing at most one character. left, right = 0, len(s) - 1 mismatches = 0 while left < right: if s[left] != s[right]: mismatches += 1 if mismatches > 1: return \\"NO\\" left += 1 right -= 1 return \\"YES\\" def determine_palindromes(T, test_cases): Main function to handle multiple test cases. results = [] for s in test_cases: results.append(can_be_palindrome_with_one_change(s)) return results"},{"question":"def min_rooms(teams: List[int]) -> int: Given a list of integers where each integer represents the size of a team, return the minimum number of rooms required to accommodate all the teams. >>> min_rooms([1, 2, 1, 3]) == 2 >>> min_rooms([4, 4, 4, 1]) == 4 >>> min_rooms([3, 3, 3, 3]) == 4","solution":"def min_rooms(teams): Given a list of integers where each integer represents the size of a team, return the minimum number of rooms required to accommodate all the teams. if not teams: return 0 rooms = 0 current_capacity = 0 for size in sorted(teams, reverse=True): if current_capacity + size <= 4: current_capacity += size else: rooms += 1 current_capacity = size if current_capacity > 0: rooms += 1 return rooms"},{"question":"from typing import List, Tuple def easiest_path(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the difficulty of the easiest path from the top-left corner to the bottom-right corner of the grid. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List containing each test case with n, m and the grid. Returns: List[int]: List containing the difficulty of the easiest path for each test case. Example: >>> easiest_path(2, [ ... (3, 3, [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ]), ... (2, 2, [ ... [1, 1], ... [1, 1] ... ]) ... ]) [2, 0] >>> easiest_path(1, [ ... (2, 2, [ ... [1, 1000], ... [1000, 1] ... ]) ... ]) [999]","solution":"from collections import deque def valid_path(G, mid, n, m): directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: if abs(G[nx][ny] - G[x][y]) <= mid: visited[nx][ny] = True queue.append((nx, ny)) return False def min_difficulty(G, n, m): left, right = 0, max(max(row) for row in G) while left < right: mid = (left + right) // 2 if valid_path(G, mid, n, m): right = mid else: left = mid + 1 return left def easiest_path(t, test_cases): results = [] for i in range(t): n, m, G = test_cases[i] difficulty = min_difficulty(G, n, m) results.append(difficulty) return results"},{"question":"from typing import List def sum_of_products_of_pairs(N: int, numbers: List[int]) -> int: Returns the sum of the products of every possible pair of distinct integers from the list. >>> sum_of_products_of_pairs(4, [1, 2, 3, 4]) 35 >>> sum_of_products_of_pairs(2, [1, 2]) 2 >>> sum_of_products_of_pairs(3, [-1, -2, -3]) 11 >>> sum_of_products_of_pairs(3, [-1, 2, -3]) -1 >>> sum_of_products_of_pairs(3, [1000, -1000, 0]) -1000000 >>> sum_of_products_of_pairs(4, [1, 1, 1, 1]) 6","solution":"def sum_of_products_of_pairs(N, numbers): Returns the sum of the products of every possible pair of distinct integers from the list. total_sum = 0 for i in range(N): for j in range(i+1, N): total_sum += numbers[i] * numbers[j] return total_sum"},{"question":"def can_travel(grid): Check if there is a path from top-left to bottom-right in the grid. >>> can_travel([ [0, 0, 1, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 0, 0, 0] ]) == True >>> can_travel([ [0, 1, 0], [1, 0, 1], [0, 1, 0] ]) == False from solution import can_travel def test_can_travel_simple_grid_true(): assert can_travel([ [0, 0, 1, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 0, 0, 0] ]) == True def test_can_travel_simple_grid_false(): assert can_travel([ [0, 1, 0], [1, 0, 1], [0, 1, 0] ]) == False def test_can_travel_no_walls(): assert can_travel([ [0, 0], [0, 0] ]) == True def test_can_travel_blocked_start(): assert can_travel([ [1, 0], [0, 0] ]) == False def test_can_travel_blocked_end(): assert can_travel([ [0, 0], [0, 1] ]) == False def test_can_travel_large_grid(): assert can_travel([ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 1], [0, 0, 0, 0, 0] ]) == True def test_can_travel_no_grid(): assert can_travel([]) == False","solution":"def can_travel(grid): Check if there is a path from top-left to bottom-right in the grid. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def within_bounds(x, y): return 0 <= x < rows and 0 <= y < cols def dfs(x, y, visited): if (x, y) == (rows - 1, cols - 1): return True visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if within_bounds(nx, ny) and grid[nx][ny] == 0 and (nx, ny) not in visited: if dfs(nx, ny, visited): return True return False return dfs(0, 0, set())"},{"question":"def to_camel_case(text: str) -> str: Converts a given string with dash/underscore delimiters into camel casing. >>> to_camel_case(\\"the-stealth-warrior\\") == \\"theStealthWarrior\\" >>> to_camel_case(\\"The_stealth_warrior\\") == \\"TheStealthWarrior\\"","solution":"def to_camel_case(text): Converts a given string with dash/underscore delimiters into camel casing. :param text: A string with words separated by dashes or underscores. :return: A camelCased version of the input string. if not text: return text words = text.replace('_', '-').split('-') first_word = words[0] camel_cased = first_word + ''.join(word.capitalize() for word in words[1:]) return camel_cased"},{"question":"def trap(heights: List[int]) -> int: Given an array \`heights\` where \`heights[i]\` represents the height of a building at index \`i\`, determine the maximum amount of water that can be trapped between the buildings after a rain. :param heights: List[int] - An array of non-negative integers representing the height of buildings. :return: int - The maximum amount of water that can be trapped. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 from solution import trap def test_trap_example_1(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_example_2(): assert trap([4,2,0,3,2,5]) == 9 def test_trap_no_buildings(): assert trap([]) == 0 def test_trap_two_buildings(): assert trap([1, 2]) == 0 def test_trap_uniform_heights(): assert trap([2, 2, 2]) == 0 def test_trap_decreasing_heights(): assert trap([4, 3, 2, 1]) == 0 def test_trap_increasing_heights(): assert trap([1, 2, 3, 4]) == 0 def test_trap_complex_case(): assert trap([3, 0, 0, 2, 0, 4]) == 10","solution":"def trap(heights): Returns the maximum amount of water that can be trapped between buildings. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = 0, 0 trapped_water = 0 while left < right: if heights[left] < heights[right]: if heights[left] >= left_max: left_max = heights[left] else: trapped_water += left_max - heights[left] left += 1 else: if heights[right] >= right_max: right_max = heights[right] else: trapped_water += right_max - heights[right] right -= 1 return trapped_water"},{"question":"def balanceString(s: str) -> bool: Returns True if each character in the string appears the same number of times in both halves of the string. Returns False if the string has an odd length or if every letter does not occur equally in both halves. If the input is not a string, returns 'Invalid input'. >>> balanceString(\\"abbaabba\\") True >>> balanceString(\\"aaaaabbbb\\") False >>> balanceString(\\"abcabc\\") True >>> balanceString(\\"abcde\\") False >>> balanceString([\\"hello\\"]) 'Invalid input' >>> balanceString(12345) 'Invalid input' >>> balanceString(\\"\\") True","solution":"def balanceString(s): Returns True if each character in the string appears the same number of times in both halves of the string. Returns False if the string has an odd length or if every letter does not occur equally in both halves. If the input is not a string, returns 'Invalid input'. if not isinstance(s, str): return 'Invalid input' # If the length of the string is odd if len(s) % 2 != 0: return False # Determine the midpoint of the string mid = len(s) // 2 # Split the string into two halves first_half = s[:mid] second_half = s[mid:] # Calculate character counts for both halves first_half_counts = {char: first_half.count(char) for char in set(first_half)} second_half_counts = {char: second_half.count(char) for char in set(second_half)} # Compare character counts return first_half_counts == second_half_counts"},{"question":"def count_elements(items): Given an array of single-digit numbers and lowercase letters, return an object containing the count of each unique element. Ignore uppercase letters and any other characters (like punctuation, spaces, etc.). Args: items (list): A list of elements (characters) to count in. Returns: dict: A dictionary with elements as keys and their counts as values. pass # Test cases def test_count_elements_mixed_characters(): assert count_elements(['a', 'b', 'a', '1', '2', '1', 'a']) == {'a': 3, 'b': 1, '1': 2, '2': 1} def test_count_elements_all_numbers(): assert count_elements(['1', '2', '3', '1', '2', '3', '1']) == {'1': 3, '2': 2, '3': 2} def test_count_elements_all_letters(): assert count_elements(['z', 'x', 'x', 'z', 'a', 'b', 'x']) == {'z': 2, 'x': 3, 'a': 1, 'b': 1} def test_count_elements_ignore_uppercase_and_others(): assert count_elements(['A', 'a', '1', '!', 'a', '1', 'B']) == {'a': 2, '1': 2} def test_count_elements_empty_list(): assert count_elements([]) == {} def test_count_elements_only_ignored_characters(): assert count_elements(['@', '#', '', '%', '^', '&', '*']) == {}","solution":"def count_elements(items): Counts the occurrences of each unique element in the given list of items. Only single-digit numbers and lowercase letters are considered. Args: items (list): A list of elements (characters) to count in. Returns: dict: A dictionary with elements as keys and their counts as values. counts = {} for item in items: if item.isdigit() or ('a' <= item <= 'z'): if item in counts: counts[item] += 1 else: counts[item] = 1 return counts"},{"question":"from typing import List def first_n_primes(n: int) -> List[int]: Complete the function that takes a positive integer \`n\` and returns a list of the first \`n\` prime numbers. Examples: >>> first_n_primes(1) == [2] >>> first_n_primes(3) == [2, 3, 5] >>> first_n_primes(5) == [2, 3, 5, 7, 11]","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False max_divisor = int(num**0.5) + 1 for i in range(3, max_divisor, 2): if num % i == 0: return False return True def first_n_primes(n): primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"from typing import List, Dict, Tuple def tournament_results(players: List[Dict[str, List[int]]]) -> List[Tuple[str, int, float]]: Returns a list of tuples with player's name, highest score, and average score. Args: players (List[Dict[str, List[int]]]): A list of dictionaries, each containing - 'name': player's name - 'scores': a list of scores in various rounds Returns: List[Tuple[str, int, float]]: List of tuples containing player's name, highest score, and average score. Examples: >>> players = [ ... {\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 78]}, ... {\\"name\\": \\"Bob\\", \\"scores\\": [92, 88, 95]}, ... {\\"name\\": \\"Charlie\\", \\"scores\\": [80, 85, 85]} ... ] >>> tournament_results(players) [(\\"Alice\\", 90, 84.33), (\\"Bob\\", 95, 91.67), (\\"Charlie\\", 85, 83.33)] >>> players = [ ... {\\"name\\": \\"Single\\", \\"scores\\": [100]} ... ] >>> tournament_results(players) [(\\"Single\\", 100, 100.0)] >>> players = [ ... {\\"name\\": \\"Zero\\", \\"scores\\": [0, 0, 0]} ... ] >>> tournament_results(players) [(\\"Zero\\", 0, 0.0)] pass def test_single_player(): players = [{\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 78]}] expected = [(\\"Alice\\", 90, 84.33)] assert tournament_results(players) == expected def test_multiple_players(): players = [ {\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 78]}, {\\"name\\": \\"Bob\\", \\"scores\\": [92, 88, 95]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [80, 85, 85]} ] expected = [ (\\"Alice\\", 90, 84.33), (\\"Bob\\", 95, 91.67), (\\"Charlie\\", 85, 83.33) ] assert tournament_results(players) == expected def test_mixed_length_scores(): players = [ {\\"name\\": \\"Alice\\", \\"scores\\": [100]}, {\\"name\\": \\"Bob\\", \\"scores\\": [50, 60, 70]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [75, 80]} ] expected = [ (\\"Alice\\", 100, 100.0), (\\"Bob\\", 70, 60.0), (\\"Charlie\\", 80, 77.5) ] assert tournament_results(players) == expected def test_zero_scores(): players = [{\\"name\\": \\"Zero\\", \\"scores\\": [0, 0, 0]}] expected = [(\\"Zero\\", 0, 0.0)] assert tournament_results(players) == expected def test_highest_and_lowest_extremes(): players = [ {\\"name\\": \\"Max\\", \\"scores\\": [100, 100, 100]}, {\\"name\\": \\"Min\\", \\"scores\\": [0, 0, 0]} ] expected = [ (\\"Max\\", 100, 100.0), (\\"Min\\", 0, 0.0) ] assert tournament_results(players) == expected","solution":"def tournament_results(players): Returns a list of tuples with player's name, highest score, and average score. Parameters: players (list): A list of dictionaries, each containing - 'name': player's name - 'scores': a list of scores in various rounds Returns: list: List of tuples containing player's name, highest score, and average score. results = [] for player in players: name = player[\\"name\\"] scores = player[\\"scores\\"] highest_score = max(scores) average_score = round(sum(scores) / len(scores), 2) results.append((name, highest_score, average_score)) return results"},{"question":"def triangular_pattern(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Outputs the triangular arrangement pattern for each test case. :param t: integer, number of test cases :param test_cases: list of tuples, each tuple contains an integer N and a list of N integers >>> triangular_pattern(1, [(4, [2, 5, 7, 8])]) ['2n2 5n2 5 7n2 5 7 8'] >>> triangular_pattern(1, [(3, [1, 3, 6])]) ['1n1 3n1 3 6'] >>> triangular_pattern(1, [(5, [4, 9, 12, 15, 18])]) ['4n4 9n4 9 12n4 9 12 15n4 9 12 15 18'] Test cases: from solution import triangular_pattern def test_single_case(): t = 1 test_cases = [(4, [2, 5, 7, 8])] expected_output = [\\"2n2 5n2 5 7n2 5 7 8\\"] assert triangular_pattern(t, test_cases) == expected_output def test_multiple_cases(): t = 3 test_cases = [ (4, [2, 5, 7, 8]), (3, [1, 3, 6]), (5, [4, 9, 12, 15, 18]) ] expected_output = [ \\"2n2 5n2 5 7n2 5 7 8\\", \\"1n1 3n1 3 6\\", \\"4n4 9n4 9 12n4 9 12 15n4 9 12 15 18\\" ] assert triangular_pattern(t, test_cases) == expected_output def test_single_element_case(): t = 1 test_cases = [(1, [42])] expected_output = [\\"42\\"] assert triangular_pattern(t, test_cases) == expected_output def test_minimum_and_maximum_values(): t = 2 test_cases = [ (1, [1]), (100, list(range(1, 101))) ] expected_output = [ \\"1\\", \\"n\\".join([\\" \\".join(map(str, list(range(1, i + 1)))) for i in range(1, 101)]) ] assert triangular_pattern(t, test_cases) == expected_output","solution":"def triangular_pattern(t, test_cases): Outputs the triangular arrangement pattern for each test case. :param t: integer, number of test cases :param test_cases: list of tuples, each tuple contains an integer N and a list of N integers results = [] for N, G in test_cases: group_patterns = [] for i in range(1, N + 1): group_patterns.append(\\" \\".join(map(str, G[:i]))) results.append(\\"n\\".join(group_patterns)) return results"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, and False otherwise. A string is considered a palindrome if it reads the same backward as forward, ignoring spaces, capitalization, and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\" \\") == True >>> is_palindrome(\\"Able , was I saw eLba\\") == True","solution":"import re def is_palindrome(s): Returns True if the input string s is a palindrome, and False otherwise. # Remove all non-alphanumeric characters and converting to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"from typing import List, Tuple def find_min_threshold(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the minimum threshold C such that it is possible to travel from city 1 to city M. If no such threshold exists, returns -1. Args: T (int): the number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): a list of test cases where each test case consists of the tuple (M, N, edges). Returns: List[int]: the minimum threshold C for each test case, or -1 if no valid path exists. Example: >>> find_min_threshold(1, [(4, 5, [(1, 2, 5), (2, 3, 6), (3, 4, 2), (1, 3, 8), (2, 4, 7)])]) [6] >>> find_min_threshold(1, [(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 1)])]) [1] def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[Tuple[int, int, int]]]]]: Parses the input string and returns the number of test cases and the test cases data. Args: input_string (str): the input string containing the test cases. Returns: Tuple[int, List[Tuple[int, int, List[Tuple[int, int, int]]]]]: the number of test cases and the test cases data. Example: >>> parse_input(\\"1n4 5n1 2 5n2 3 6n3 4 2n1 3 8n2 4 7n\\") (1, [(4, 5, [(1, 2, 5), (2, 3, 6), (3, 4, 2), (1, 3, 8), (2, 4, 7)])]) >>> parse_input(\\"1n3 3n1 2 1n2 3 1n1 3 1n\\") (1, [(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 1)])]) from solution import find_min_threshold, parse_input def test_case_1(): input_string = \\"1n4 5n1 2 5n2 3 6n3 4 2n1 3 8n2 4 7n\\" T, test_cases = parse_input(input_string) assert find_min_threshold(T, test_cases) == [6] def test_case_2(): input_string = \\"1n3 3n1 2 1n2 3 1n1 3 1n\\" T, test_cases = parse_input(input_string) assert find_min_threshold(T, test_cases) == [1] def test_case_3(): input_string = \\"1n3 2n1 2 2n2 3 3n\\" T, test_cases = parse_input(input_string) assert find_min_threshold(T, test_cases) == [2] def test_case_not_possible(): input_string = \\"1n4 2n1 2 2n3 4 3n\\" T, test_cases = parse_input(input_string) assert find_min_threshold(T, test_cases) == [-1] def test_multiple_test_cases(): input_string = \\"2n4 5n1 2 5n2 3 6n3 4 2n1 3 8n2 4 7n3 3n1 2 10n2 3 10n1 3 1n\\" T, test_cases = parse_input(input_string) assert find_min_threshold(T, test_cases) == [6, 10]","solution":"def find_min_threshold(t, test_cases): from heapq import heappop, heappush def dijkstra_max_min(n, adj, src, dest): heap = [(-float('inf'), src)] visited = [False] * (n + 1) max_min_cost = [-float('inf')] * (n + 1) max_min_cost[src] = float('inf') while heap: min_val, node = heappop(heap) min_val = -min_val if visited[node]: continue visited[node] = True for neigh, cost in adj[node]: new_cost = min(min_val, cost) if new_cost > max_min_cost[neigh]: max_min_cost[neigh] = new_cost heappush(heap, (-new_cost, neigh)) return max_min_cost[dest] if max_min_cost[dest] != -float('inf') else -1 results = [] for M, N, edges in test_cases: adj = [[] for _ in range(M + 1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) min_threshold = dijkstra_max_min(M, adj, 1, M) results.append(min_threshold) return results # Input parsing function def parse_input(input_string): lines = input_string.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): M, N = map(int, lines[index].split()) index += 1 edges = [] for _ in range(N): u, v, w = map(int, lines[index].split()) index += 1 edges.append((u, v, w)) test_cases.append((M, N, edges)) return T, test_cases # Example usage input_string = \\"1n4 5n1 2 5n2 3 6n3 4 2n1 3 8n2 4 7n\\" T, test_cases = parse_input(input_string) output = find_min_threshold(T, test_cases) for result in output: print(result)"},{"question":"from typing import List, Tuple def find_unique_numbers(lst: List[int]) -> Tuple[int, int]: Finds the two unique numbers in a list where all other numbers appear exactly twice. The function should return a tuple of the two unique integers. >>> find_unique_numbers([1, 2, 3, 2, 1, 4]) (3, 4) or (4, 3) >>> find_unique_numbers([-1, 2, -1, 3, 4, 2]) (3, 4) or (4, 3) >>> find_unique_numbers([-1, -2, -1, -3, -4, -2]) (-3, -4) or (-4, -3) def test_find_unique_numbers_example_1(): result = find_unique_numbers([1, 2, 3, 2, 1, 4]) assert set(result) == {3, 4} def test_find_unique_numbers_example_2(): result = find_unique_numbers([-1, 2, -1, 3, 4, 2]) assert set(result) == {3, 4} def test_find_unique_numbers_example_3(): result = find_unique_numbers([-1, -2, -1, -3, -4, -2]) assert set(result) == {-3, -4} def test_find_unique_numbers_large_input(): result = find_unique_numbers([10, 20, 30, 10, 20, 40, 50, 50]) assert set(result) == {30, 40} def test_find_unique_numbers_all_negative(): result = find_unique_numbers([-1, -2, -3, -2, -1, -4]) assert set(result) == {-3, -4}","solution":"from typing import List, Tuple def find_unique_numbers(lst: List[int]) -> Tuple[int, int]: xor_sum = 0 for num in lst: xor_sum ^= num # Get a bit that is set in xor_sum (rightmost set bit) rightmost_set_bit = xor_sum & (-xor_sum) num1, num2 = 0, 0 for num in lst: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return (num1, num2)"},{"question":"def minimal_refining_time(smelter: str, num_blocks: int) -> int: Calculate the minimal time required to produce a given number of Brightstone blocks using the available smelters. Arguments: - smelter: a string indicating the type of smelter ('electric', 'regular', or 'old'). - num_blocks: an integer representing the number of Brightstone blocks to refine. Returns: - The minimal time (in seconds) required to refine the specified number of Brightstone blocks with the given smelter. Example: >>> minimal_refining_time('electric', 10) 20 >>> minimal_refining_time('regular', 10) 50 >>> minimal_refining_time('old', 10) 70","solution":"def minimal_refining_time(smelter, num_blocks): Returns the minimal time required to refine the specified number of Brightstone blocks given the type of smelter. if smelter == 'electric': refining_time_per_block = 2 elif smelter == 'regular': refining_time_per_block = 5 elif smelter == 'old': refining_time_per_block = 7 else: raise ValueError(\\"Invalid smelter type\\") return refining_time_per_block * num_blocks"},{"question":"from typing import List def maximum_water_trap(height: List[int]) -> int: Given an array of non-negative integers representing the heights of bars in a histogram, calculate the maximum amount of water that can be trapped after raining. Each bar is one unit wide. >>> maximum_water_trap([]) == 0 >>> maximum_water_trap([1, 1, 1, 1, 1]) == 0 >>> maximum_water_trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> maximum_water_trap([1]) == 0 >>> maximum_water_trap([2, 1]) == 0 >>> maximum_water_trap([5, 4, 3, 2, 1]) == 0 >>> maximum_water_trap([1, 2, 3, 4, 5]) == 0 >>> maximum_water_trap([2, 0, 2]) == 2 >>> maximum_water_trap([4, 2, 0, 3, 2, 5]) == 9","solution":"from typing import List def maximum_water_trap(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def calculate_hours(hours: List[int]) -> Tuple[int, int]: Given a list of integers representing the number of hours worked by each employee in a week, this function returns a tuple containing the total number of hours and the maximum number of hours. Parameters: hours (list): A list of integers. Returns: tuple: A tuple containing the total number of hours (int) and the maximum number of hours (int). Example: >>> calculate_hours([40, 35, 42, 38]) (155, 42) >>> calculate_hours([]) (0, 0)","solution":"def calculate_hours(hours): Given a list of integers representing the number of hours worked by each employee in a week, this function returns a tuple containing the total number of hours and the maximum number of hours. Parameters: hours (list): A list of integers. Returns: tuple: A tuple containing the total number of hours (int) and the maximum number of hours (int). if not hours: return (0, 0) total_hours = sum(hours) max_hours = max(hours) return (total_hours, max_hours)"},{"question":"def is_positive_and_palindrome(nums: List[int]) -> bool: Determines if all integers in the list are positive and if any integer is a palindrome. Args: nums (list): A list of integers. Returns: bool: True if all integers are positive and any integer is a palindrome, else False. >>> is_positive_and_palindrome([12, 9, 61, 5, 14]) True >>> is_positive_and_palindrome([12, 91, 61, 54, 14]) False >>> is_positive_and_palindrome([12, -9, 61, 5, 14]) False >>> is_positive_and_palindrome([12, -91, 61, -54, -14]) False >>> is_positive_and_palindrome([0]) False >>> is_positive_and_palindrome([22]) True >>> is_positive_and_palindrome([23]) False","solution":"def is_positive_and_palindrome(nums): Determines if all integers in the list are positive and if any integer is a palindrome. Args: nums (list): A list of integers. Returns: bool: True if all integers are positive and any integer is a palindrome, else False. all_positive = all(num > 0 for num in nums) any_palindrome = any(str(num) == str(num)[::-1] for num in nums) return all_positive and any_palindrome"},{"question":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together from a list of words. Parameters: words (list of str): The list of words to group. Returns: list of list of str: A list of groups, where each group is a list of anagrams. Examples: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\", \\"\\"]) [[\\"\\", \\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]] >>> group_anagrams([\\"cab\\", \\"bac\\", \\"abc\\", \\"xyz\\", \\"yxz\\"]) [[\\"cab\\", \\"bac\\", \\"abc\\"], [\\"xyz\\", \\"yxz\\"]] anagram_map = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from a list of words. Parameters: words (list of str): The list of words to group. Returns: list of list of str: A list of groups, where each group is a list of anagrams. anagram_map = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Determine the number of unique paths Mia can take to reach her destination in a grid with obstacles. >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles(2, 2, [[0, 1], [0, 0]]) == 1 >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [1, 1, 0], [0, 0, 0]]) == 1 >>> unique_paths_with_obstacles(1, 1, [[0]]) == 1 >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == 0 >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6","solution":"MOD = 1000000007 def unique_paths_with_obstacles(m, n, grid): if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[m-1][n-1] # Read input data def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) n = int(data[1]) grid = [] data_index = 2 for _ in range(m): row = [int(data[data_index + i]) for i in range(n)] grid.append(row) data_index += n print(unique_paths_with_obstacles(m, n, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def reverseWords(s): This function takes a string and returns the string with the order of characters reversed for each word while preserving the order of words. If the input is not a string, the function returns \\"Invalid input\\". >>> reverseWords(\\"hello world\\") # \\"olleh dlrow\\" >>> reverseWords(\\"Python is fun\\") # \\"nohtyP si nuf\\" >>> reverseWords([\\"Not\\", \\"a\\", \\"string\\"]) # \\"Invalid input\\"","solution":"def reverseWords(s): This function takes a string and returns the string with the order of characters reversed for each word while preserving the order of words. If the input is not a string, the function returns \\"Invalid input\\". if not isinstance(s, str): return \\"Invalid input\\" words = s.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the list nums. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 pass","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the list nums. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # Only start a sequence if num is the start of the sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def digital_root(n: int) -> int: Given a positive integer n, returns its digital root. >>> digital_root(16) == 7 >>> digital_root(942) == 6 >>> digital_root(132189) == 6 >>> digital_root(493193) == 2 >>> digital_root(0) == 0 >>> digital_root(5) == 5 >>> digital_root(987654321) == 9 >>> digital_root(999999999999) == 9 >>> digital_root(12345678901234567890) == 9","solution":"def digital_root(n): Given a positive integer n, returns its digital root. if n == 0: return 0 return 1 + (n - 1) % 9"},{"question":"def min_consecutive_days(activities: List[int]) -> int: Determines the minimum number of consecutive days required to cover all activities. >>> min_consecutive_days([4, 2, 11, 6, 8]) 10 >>> min_consecutive_days([1, 3, 7]) 7 >>> min_consecutive_days([10, 10, 10]) 1","solution":"def min_consecutive_days(activities): Determines the minimum number of consecutive days required to cover all activities. :param activities: List of positive integers representing the days on which activities are planned. :return: Integer representing the minimum number of consecutive days. # If there are no activities, return 0 (although per problem, there's at least one activity) if not activities: return 0 # Find the minimum and maximum day from the activities list min_day = min(activities) max_day = max(activities) # The number of consecutive days required is the range from min_day to max_day (inclusive) return max_day - min_day + 1"},{"question":"def rearrange_odd_even(lst: List[int]) -> List[int]: Rearranges the list such that all integers at odd indices come first, followed by all integers at even indices, maintaining their original order. Args: lst (list of int): List of integers Returns: list of int: Rearranged list >>> rearrange_odd_even([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> rearrange_odd_even([10, 21, 30, 41, 50]) [21, 41, 10, 30, 50] >>> rearrange_odd_even([]) [] >>> rearrange_odd_even([7]) [7] >>> rearrange_odd_even([0]) [0] >>> rearrange_odd_even([4, 8, 3, 9]) [8, 9, 4, 3] >>> rearrange_odd_even([2, 5, 6, 7, 10, 13]) [5, 7, 13, 2, 6, 10] >>> rearrange_odd_even([1, 3, 5, 7, 9]) [3, 7, 1, 5, 9] >>> rearrange_odd_even([0, 1, 2, 3, 4, 5, 6]) [1, 3, 5, 0, 2, 4, 6]","solution":"def rearrange_odd_even(lst): Rearranges the list such that all integers at odd indices come first, followed by all integers at even indices, maintaining their original order. Args: lst (list of int): List of integers Returns: list of int: Rearranged list odd_indices_elements = lst[1::2] even_indices_elements = lst[0::2] return odd_indices_elements + even_indices_elements"},{"question":"def validate_postal_code(postal_code: str) -> bool: Validates if the given postal code follows the defined format: - First three characters must be uppercase alphabetical letters. - The remaining two to four characters must be digits. - The total length must be between 5 and 7 characters. >>> validate_postal_code(\\"ABC123\\") == True >>> validate_postal_code(\\"XYZ45\\") == True >>> validate_postal_code(\\"RST789\\") == True >>> validate_postal_code(\\"PQRS7890\\") == False >>> validate_postal_code(\\"AB12\\") == False >>> validate_postal_code(\\"HELLO12\\") == False >>> validate_postal_code(\\"DEF1\\") == False >>> validate_postal_code(\\"AbC123\\") == False >>> validate_postal_code(\\"123ABC\\") == False >>> validate_postal_code(\\"AAA12\\") == True >>> validate_postal_code(\\"BBB3456\\") == True >>> validate_postal_code(\\"CCC23456\\") == False","solution":"def validate_postal_code(postal_code: str) -> bool: Validates if the given postal code follows the defined format: - First three characters must be uppercase alphabetical letters. - The remaining two to four characters must be digits. - The total length must be between 5 and 7 characters. Args: postal_code (str): The postal code to validate. Returns: bool: True if the postal code is valid, False otherwise. if not (5 <= len(postal_code) <= 7): return False first_part = postal_code[:3] second_part = postal_code[3:] if not first_part.isalpha() or not first_part.isupper(): return False if not second_part.isdigit() or not (2 <= len(second_part) <= 4): return False return True"},{"question":"def can_form_palindrome(s: str) -> bool: Return true if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"def can_form_palindrome(s): Returns true if the string can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) return odd_count <= 1"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(values, edges): Build the tree from given node values and edges. nodes = [TreeNode(value) for value in values] adjacency_list = [[] for _ in range(len(values))] for u, v in edges: adjacency_list[u-1].append(v-1) adjacency_list[v-1].append(u-1) def dfs(node, parent): for neighbor in adjacency_list[node]: if neighbor != parent: nodes[node].children.append(nodes[neighbor]) dfs(neighbor, node) dfs(0, -1) return nodes def update_value(node, new_value, value_dict): Update the value of the given node. value_dict[node] = new_value def subtree_sum(node, value_dict): Calculate the sum of all values in the subtree of the given node. total = value_dict[node] for child in node.children: total += subtree_sum(child, value_dict) return total def process_queries(N, Q, values, edges, queries): Process the queries to update node values or calculate subtree sums. Args: N: number of nodes. Q: number of queries. values: initial values of the nodes. edges: list of edges between nodes. queries: list of queries in the given format. Returns: List of results for each query of type \\"2 u\\". >>> process_queries(5, 5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)], [\\"2 1\\", \\"2 2\\", \\"1 2 10\\", \\"2 1\\", \\"2 2\\"]) [15, 11, 21, 20] >>> process_queries(1, 1, [1], [], [\\"2 1\\"]) [1] >>> process_queries(2, 1, [1, 2], [(1, 2)], [\\"1 2 5\\"]) [] >>> process_queries(3, 3, [1, 2, 3], [(1, 2), (1, 3)], [\\"2 1\\", \\"1 3 5\\", \\"2 1\\"]) [6, 8]","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(values, edges): nodes = [TreeNode(value) for value in values] adjacency_list = [[] for _ in range(len(values))] for u, v in edges: adjacency_list[u-1].append(v-1) adjacency_list[v-1].append(u-1) def dfs(node, parent): for neighbor in adjacency_list[node]: if neighbor != parent: nodes[node].children.append(nodes[neighbor]) dfs(neighbor, node) dfs(0, -1) return nodes def update_value(node, new_value, value_dict): value_dict[node] = new_value def subtree_sum(node, value_dict): total = value_dict[node] for child in node.children: total += subtree_sum(child, value_dict) return total def process_queries(N, Q, values, edges, queries): nodes = build_tree(values, edges) value_dict = {nodes[i]: values[i] for i in range(N)} results = [] for query in queries: parts = query.split() if parts[0] == '1': u, x = int(parts[1]), int(parts[2]) update_value(nodes[u-1], x, value_dict) elif parts[0] == '2': u = int(parts[1]) results.append(subtree_sum(nodes[u-1], value_dict)) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove all nodes from the linked list that have duplicate values, leaving only distinct numbers from the original list. >>> head = create_linked_list([1, 2, 3, 2, 4, 3, 5, 6, 4]) >>> new_head = remove_duplicates(head) >>> linked_list_to_list(new_head) [1, 5, 6] # Utility functions for creating and printing a linked list for testing purposes def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values import pytest def test_remove_duplicates(): head = create_linked_list([1, 2, 3, 2, 4, 3, 5, 6, 4]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 5, 6] def test_remove_duplicates_single_element(): head = create_linked_list([1]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1] def test_remove_duplicates_all_duplicates(): head = create_linked_list([1, 1, 1, 1]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [] def test_remove_duplicates_no_duplicates(): head = create_linked_list([1, 2, 3, 4]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 2, 3, 4] def test_remove_duplicates_mixed(): head = create_linked_list([1, 2, 2, 3, 4, 4, 5]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 3, 5] def test_remove_duplicates_empty(): head = create_linked_list([]) new_head = remove_duplicates(head) assert new_head is None","solution":"from collections import defaultdict class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): # First pass to count occurrences of each value value_count = defaultdict(int) current = head while current: value_count[current.val] += 1 current = current.next # Second pass to filter out duplicates dummy = ListNode(0) tail = dummy current = head while current: if value_count[current.val] == 1: tail.next = ListNode(current.val) tail = tail.next current = current.next return dummy.next # Utility functions for creating and printing a linked list for testing purposes def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest palindrome within the input string. If there are multiple palindromes of the same length, return the first one that appears. :param s: input string :return: longest palindrome string >>> longest_palindrome(\\"babad\\") in {\\"bab\\", \\"aba\\"} True >>> longest_palindrome(\\"cbbd\\") == \\"bb\\" True >>> longest_palindrome(\\"a\\") == \\"a\\" True >>> longest_palindrome(\\"ab\\") in {\\"a\\", \\"b\\"} True >>> longest_palindrome(\\"racecar\\") == \\"racecar\\" True >>> longest_palindrome(\\"aaaaa\\") == \\"aaaaa\\" True >>> longest_palindrome(\\"\\") == \\"\\" True >>> longest_palindrome(\\"ac\\") in {\\"a\\", \\"c\\"} True","solution":"def longest_palindrome(s): Returns the longest palindrome in the input string. :param s: str :return: str if not s: return \\"\\" def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd-length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even-length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def calculate_time_diff(time1: str, time2: str) -> int: Calculate the difference between two times in \\"HH:MM AM/PM\\" format and return the difference in minutes. >>> calculate_time_diff(\\"02:30 PM\\", \\"03:45 PM\\") 75 >>> calculate_time_diff(\\"11:30 PM\\", \\"01:15 AM\\") 105 >>> calculate_time_diff(\\"10:30 AM\\", \\"09:30 AM\\") 1380","solution":"def calculate_time_diff(time1, time2): Calculate the difference between two times in \\"HH:MM AM/PM\\" format and return the difference in minutes. def convert_to_minutes(time): hh, mm_ampm = time.split(':') mm, ampm = mm_ampm[:2], mm_ampm[3:] hh, mm = int(hh), int(mm) if ampm == \\"PM\\" and hh != 12: hh += 12 elif ampm == \\"AM\\" and hh == 12: hh = 0 return hh * 60 + mm minutes1 = convert_to_minutes(time1) minutes2 = convert_to_minutes(time2) diff = minutes2 - minutes1 if diff < 0: diff += 24 * 60 return diff"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Determine the length of the longest substring of s that contains at most k distinct characters. If the length of s is less than k, output the length of the entire string s. >>> length_of_longest_substring_k_distinct(\\"abcba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"abcabcabc\\", 3) 9 >>> length_of_longest_substring_k_distinct(\\"abc\\", 1) 1 pass def process_test_cases(t: int, test_cases: list) -> list: Process a list of test cases and return the results for each test case. test_cases is a list of tuples where each tuple contains (k, s). >>> process_test_cases(3, [(2, \\"abcba\\"), (3, \\"abcabcabc\\"), (1, \\"abc\\")]) [3, 9, 1] pass","solution":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left) return max_length def process_test_cases(t: int, test_cases: list) -> list: results = [] for k, s in test_cases: results.append(length_of_longest_substring_k_distinct(s, k)) return results"},{"question":"def count_words_with_postfixes(words: List[str], postfixes: List[str]) -> int: Returns the number of words that end with any of the given postfixes. Args: words (list): List of strings representing the words. postfixes (list): List of strings representing the postfixes. Returns: int: The number of words that end with any of the postfixes. >>> count_words_with_postfixes([\\"apple\\", \\"banana\\", \\"grape\\", \\"pineapple\\"], [\\"le\\", \\"na\\", \\"ple\\"]) == 3 >>> count_words_with_postfixes([\\"apple\\", \\"banana\\", \\"grape\\"], [\\"xy\\", \\"za\\"]) == 0 >>> count_words_with_postfixes([], [\\"le\\", \\"na\\", \\"ple\\"]) == 0 >>> count_words_with_postfixes([\\"apple\\", \\"banana\\", \\"grape\\"], []) == 0 from solution import count_words_with_postfixes def test_example_case(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"pineapple\\"] postfixes = [\\"le\\", \\"na\\", \\"ple\\"] assert count_words_with_postfixes(words, postfixes) == 3 def test_no_matching_postfix(): words = [\\"apple\\", \\"banana\\", \\"grape\\"] postfixes = [\\"xy\\", \\"za\\"] assert count_words_with_postfixes(words, postfixes) == 0 def test_all_matching_postfix(): words = [\\"apple\\", \\"banana\\", \\"grape\\"] postfixes = [\\"e\\", \\"na\\", \\"ape\\"] assert count_words_with_postfixes(words, postfixes) == 3 def test_empty_words_list(): words = [] postfixes = [\\"le\\", \\"na\\", \\"ple\\"] assert count_words_with_postfixes(words, postfixes) == 0 def test_empty_postfixes_list(): words = [\\"apple\\", \\"banana\\", \\"grape\\"] postfixes = [] assert count_words_with_postfixes(words, postfixes) == 0 def test_single_character_postfix(): words = [\\"a\\", \\"aa\\", \\"b\\"] postfixes = [\\"a\\"] assert count_words_with_postfixes(words, postfixes) == 2 def test_single_word_multiple_postfixes_match(): words = [\\"banana\\"] postfixes = [\\"a\\", \\"na\\", \\"nana\\"] assert count_words_with_postfixes(words, postfixes) == 1","solution":"def count_words_with_postfixes(words, postfixes): Returns the number of words that end with any of the given postfixes. Args: words (list): List of strings representing the words. postfixes (list): List of strings representing the postfixes. Returns: int: The number of words that end with any of the postfixes. count = 0 for word in words: if any(word.endswith(postfix) for postfix in postfixes): count += 1 return count"},{"question":"def unique_paths(grid: List[str]) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding obstacles ('X') and moving only right or down. The result is taken modulo 10^9 + 7. >>> unique_paths([\\"...\\", \\".X.\\", \\"...\\"]) 2 >>> unique_paths([\\"..\\", \\"..\\"]) 2 >>> unique_paths([\\"..\\", \\"XX\\"]) 0 >>> unique_paths([\\".\\"]) 1 >>> unique_paths([\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) 70 >>> unique_paths([\\"..\\", \\"X.\\", \\".X\\"]) 0","solution":"MOD = 10**9 + 7 def unique_paths(grid): Returns the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding obstacles ('X') and moving only right or down. The result is taken modulo 10^9 + 7. N = len(grid) M = len(grid[0]) # Initialize DP table dp = [[0] * M for _ in range(N)] # Starting position dp[0][0] = 1 # Fill the DP table for i in range(N): for j in range(M): if grid[i][j] == 'X': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1] # Example usage: # Grid as input for function example_grid = [ \\"...\\", \\".X.\\", \\"...\\" ] print(unique_paths(example_grid)) # Output: 2"},{"question":"def total_baking_time(plans): Returns the total baking times for each of the given baking plans. Parameters: plans (list of tuples): A list where each tuple contains an integer and a list of integers. The integer is the number of cakes for that plan, and the list contains the baking times of the cakes. Returns: list: A list containing the total baking time for each plan. pass # Example test cases: def test_total_baking_time(): plans = [ (4, [45, 30, 60, 20]), (5, [10, 20, 30, 40, 50]), (3, [25, 25, 25]) ] results = total_baking_time(plans) assert results == [155, 150, 75] def test_total_baking_time_single_cake(): plans = [(1, [120])] results = total_baking_time(plans) assert results == [120] def test_total_baking_time_same_time_cakes(): plans = [(3, [20, 20, 20])] results = total_baking_time(plans) assert results == [60] def test_total_baking_time_varied_plans(): plans = [ (2, [50, 75]), (3, [10, 20, 30]), (4, [15, 25, 35, 45]) ] results = total_baking_time(plans) assert results == [125, 60, 120] def test_total_baking_time_large_values(): plans = [ (2, [200, 200]), (3, [150, 150, 150]), (4, [175, 25, 50, 50]) ] results = total_baking_time(plans) assert results == [400, 450, 300]","solution":"def total_baking_time(plans): Returns the total baking times for each of the given baking plans. Parameters: plans (list of tuples): A list where each tuple contains an integer and a list of integers. The integer is the number of cakes for that plan, and the list contains the baking times of the cakes. Returns: list: A list containing the total baking time for each plan. total_times = [] for plan in plans: M, times = plan total_times.append(sum(times)) return total_times"},{"question":"def sum_of_cubes(lst): Returns the sum of the cubes of the integers in the list. Ignores non-integer elements. >>> sum_of_cubes([1, 2, 3]) 36 >>> sum_of_cubes([-3, -2, -1]) -36 >>> sum_of_cubes([1, 'a', 2, 'b', 3]) 36","solution":"def sum_of_cubes(lst): Returns the sum of the cubes of the integers in the list. Ignores non-integer elements. return sum(x**3 for x in lst if isinstance(x, int))"},{"question":"def min_cost_path(t, test_cases): Returns a list of minimum costs to travel from the top-left corner to the bottom-right corner of given grids. Args: t: int. Number of test cases. test_cases: list of dicts. Each dictionary contains: - n: int. Number of rows in the grid. - m: int. Number of columns in the grid. - grid: list of list of int. The cost grid. Returns: list of int. Minimum costs for each test case. Example: >>> min_cost_path(2, [{'n': 3, 'm': 3, 'grid': [[1, 3, 1], [1, 5, 1], [4, 2, 1]]}, {'n': 2, 'm': 2, 'grid': [[1, 2], [3, 4]]}]) [7, 7] pass def parse_input(input_str): Helper function to parse input string into test cases format. Args: input_str: str. Input string containing number of test cases, dimensions, and cost grids. Returns: tuple: number of test cases(int), list of dictionaries containing grid details. Example: >>> parse_input(\\"2n3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n3 4n\\") (2, [{'n': 3, 'm': 3, 'grid': [[1, 3, 1], [1, 5, 1], [4, 2, 1]]}, {'n': 2, 'm': 2, 'grid': [[1, 2], [3, 4]]}]) pass def format_output(results): Helper function to format output results into a string. Args: results: list of int. Minimum costs for each test case. Returns: str. Formatted output string. Example: >>> format_output([7, 7]) '7n7' pass # Run the tests def run_tests(): def test_parse_input(): input_str = \\"2n3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n3 4n\\" t, test_cases = parse_input(input_str) assert t == 2 assert test_cases == [ {'n': 3, 'm': 3, 'grid': [[1, 3, 1], [1, 5, 1], [4, 2, 1]]}, {'n': 2, 'm': 2, 'grid': [[1, 2], [3, 4]]} ] def test_min_cost_path(): t = 2 test_cases = [ {'n': 3, 'm': 3, 'grid': [[1, 3, 1], [1, 5, 1], [4, 2, 1]]}, {'n': 2, 'm': 2, 'grid': [[1, 2], [3, 4]]} ] assert min_cost_path(t, test_cases) == [7, 7] def test_format_output(): results = [7, 7] assert format_output(results) == \\"7n7\\" test_parse_input() test_min_cost_path() test_format_output() print(\\"All tests passed.\\") run_tests()","solution":"def min_cost_path(t, test_cases): Returns a list of minimum costs to travel from the top-left corner to the bottom-right corner of given grids. def min_cost(grid, n, m): dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row of the dp table for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column of the dp table for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1] results = [] for case in test_cases: n, m, grid = case['n'], case['m'], case['grid'] result = min_cost(grid, n, m) results.append(result) return results # For testing purposes def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append({'n': n, 'm': m, 'grid': grid}) return t, test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def calculate_expression(expr: str) -> str: Evaluates a basic arithmetic expression consisting of two integers and an operator (+, -, *, or /) separated by spaces, and returns the result as a string. >>> calculate_expression(\\"3 + 4\\") '7' >>> calculate_expression(\\"10 - 2\\") '8' >>> calculate_expression(\\"6 * 9\\") '54' >>> calculate_expression(\\"8 / 4\\") '2' >>> calculate_expression(\\"10 / 0\\") 'undefined' >>> calculate_expression(\\"3 4 +\\") 'invalid input' >>> calculate_expression(\\"3 + a\\") 'invalid input'","solution":"def calculate_expression(expr: str) -> str: Evaluates a basic arithmetic expression consisting of two integers and an operator (+, -, *, or /) separated by spaces, and returns the result as a string. try: parts = expr.split() if len(parts) != 3: return \\"invalid input\\" num1, operator, num2 = parts num1, num2 = int(num1), int(num2) if operator == '+': result = num1 + num2 elif operator == '-': result = num1 - num2 elif operator == '*': result = num1 * num2 elif operator == '/': if num2 == 0: return \\"undefined\\" result = num1 // num2 # Use integer division for consistent result type return str(result) except (ValueError, TypeError): return \\"invalid input\\""},{"question":"def findPrimes(n: int) -> List[int]: Returns a list of all prime numbers less than n. >>> findPrimes(10) [2, 3, 5, 7] >>> findPrimes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> findPrimes(2) [] >>> findPrimes(1) []","solution":"def findPrimes(n): Returns a list of all prime numbers less than n. if n <= 2: return [] primes = [] for num in range(2, n): is_prime = True for divisor in range(2, int(num ** 0.5) + 1): if num % divisor == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"from typing import List, Tuple def find_max_path_sum(N: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum sum of node values from the root to any leaf in a binary tree. >>> find_max_path_sum(5, [10, 5, 20, 21, 6], [(1, 2), (1, 3), (2, 4), (2, 5)]) 36 >>> find_max_path_sum(1, [10], []) 10 >>> find_max_path_sum(3, [5, 4, 8], [(1, 2), (1, 3)]) 13 >>> find_max_path_sum(6, [3, 2, 1, 10, 5, 6], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 15 >>> find_max_path_sum(4, [5, 5, 5, 5], [(1, 2), (2, 3), (2, 4)]) 15","solution":"def find_max_path_sum(N, values, edges): from collections import defaultdict, deque # Create an adjacency list to represent the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Use a DFS approach to get the maximum path sum def dfs(node, parent): max_sum = -float('inf') is_leaf = True for neighbor in tree[node]: if neighbor != parent: is_leaf = False max_sum = max(max_sum, dfs(neighbor, node)) if is_leaf: return values[node - 1] else: return values[node - 1] + max_sum return dfs(1, -1) # Assuming the root is always node 1"},{"question":"def remove_outer_parentheses(S: str) -> str: Removes the outermost parentheses of every primitive string. :param S: A string containing only lowercase alphabets and parentheses :return: A string with the outermost parentheses removed from every primitive string >>> remove_outer_parentheses(\\"(()())(())\\") '()()()' >>> remove_outer_parentheses(\\"(()())(())(()(()))\\") '()()()()(())' >>> remove_outer_parentheses(\\"()()\\") '' >>> remove_outer_parentheses(\\"\\") '' >>> remove_outer_parentheses(\\"(())\\") '()' >>> remove_outer_parentheses(\\"((()))\\") '(())' >>> remove_outer_parentheses(\\"(((())))\\") '((()))' >>> remove_outer_parentheses(\\"()\\") '' >>> remove_outer_parentheses(\\"((()(())))\\") '(()(()))'","solution":"def remove_outer_parentheses(S): Removes the outermost parentheses of every primitive string. :param S: A string containing only lowercase alphabets and parentheses :return: A string with the outermost parentheses removed from every primitive string result = [] opened = 0 for char in S: if char == '(': if opened > 0: result.append(char) opened += 1 elif char == ')': if opened > 1: result.append(char) opened -= 1 return ''.join(result)"},{"question":"def isomorphicStrings(s: str, t: str) -> bool: Determines if two strings s and t are isomorphic. >>> isomorphicStrings(\\"egg\\", \\"add\\") True >>> isomorphicStrings(\\"foo\\", \\"bar\\") False >>> isomorphicStrings(\\"paper\\", \\"title\\") True >>> isomorphicStrings(\\"abc\\", \\"defg\\") False >>> isomorphicStrings(\\"\\", \\"\\") True >>> isomorphicStrings(\\"a\\", \\"a\\") True >>> isomorphicStrings(\\"a\\", \\"b\\") True >>> isomorphicStrings(\\"ab\\", \\"aa\\") False","solution":"def isomorphicStrings(s, t): Determines if two strings s and t are isomorphic. if len(s) != len(t): return False mapping_s_t = {} mapping_t_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_t: if mapping_s_t[char_s] != char_t: return False else: mapping_s_t[char_s] = char_t if char_t in mapping_t_s: if mapping_t_s[char_t] != char_s: return False else: mapping_t_s[char_t] = char_s return True"},{"question":"import typing from typing import List def calculate_reward_points(steps: List[int], threshold: int) -> int: Calculate the total reward points based on the number of steps walked each day and the threshold. Parameters: steps (list of int): A list of non-negative integers representing the number of steps walked each day. threshold (int): The number of steps required to earn reward points for that day. Returns: int: The total reward points earned. >>> calculate_reward_points([1500, 3000, 4500, 6000], 3000) 4 >>> calculate_reward_points([1000, 1500, 2000], 3000) 0 >>> calculate_reward_points([6000, 7000, 8000], 3000) 6 >>> calculate_reward_points([1000, 3000, 6000, 5000], 3000) 4 >>> calculate_reward_points([3000, 3000, 3000], 3000) 3 >>> calculate_reward_points([], 3000) 0","solution":"def calculate_reward_points(steps, threshold): Calculate the total reward points based on the number of steps walked each day and the threshold. Parameters: steps (list of int): A list of non-negative integers representing the number of steps walked each day. threshold (int): The number of steps required to earn reward points for that day. Returns: int: The total reward points earned. total_points = 0 for step in steps: if step >= 2 * threshold: total_points += 2 elif step >= threshold: total_points += 1 return total_points"},{"question":"class Warehouse: A class to simulate a very basic version of a warehouse inventory system. The inventory allows adding new items, updating the quantity of existing items, and removing items when their quantity drops to zero or below. Attributes: - inventory: A dictionary where keys are item names (strings) and values are item quantities (integers). Methods: - __init__(self): Initialize an empty inventory. - add_item(self, item_name: str, quantity: int): Add the given quantity of the item to the inventory. If the item already exists, increase the quantity. If it does not exist, add the item with the given quantity. - remove_item(self, item_name: str, quantity: int): Deduct the given quantity of the item from the inventory. If the remaining quantity is less than or equal to zero, remove the item from the inventory. >>> warehouse = Warehouse() >>> warehouse.add_item(\\"apple\\", 10) >>> warehouse.add_item(\\"banana\\", 5) >>> warehouse.add_item(\\"apple\\", 5) >>> print(warehouse.inventory) {'apple': 15, 'banana': 5} >>> warehouse.remove_item(\\"apple\\", 10) >>> print(warehouse.inventory) {'apple': 5, 'banana': 5} >>> warehouse.remove_item(\\"apple\\", 5) >>> print(warehouse.inventory) {'banana': 5} def __init__(self): pass def add_item(self, item_name: str, quantity: int): pass def remove_item(self, item_name: str, quantity: int): pass","solution":"class Warehouse: def __init__(self): self.inventory = {} def add_item(self, item_name: str, quantity: int): if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity def remove_item(self, item_name: str, quantity: int): if item_name in self.inventory: self.inventory[item_name] -= quantity if self.inventory[item_name] <= 0: del self.inventory[item_name]"},{"question":"def filter_and_square(numbers: List[int]) -> List[int]: Removes all non-positive numbers from the list and returns a new list where each of the remaining numbers is squared. >>> filter_and_square([1, -2, 3, 0, -4, 5]) [1, 9, 25] >>> filter_and_square([-1, -2, -3, -4, -5]) [] >>> filter_and_square([4, 1, 0, 10, -7]) [16, 1, 100] >>> filter_and_square([0, 1, 2, 3]) [1, 4, 9] >>> filter_and_square([]) []","solution":"def filter_and_square(numbers): Filters out all non-positive numbers from the list and returns a new list where each of the remaining numbers is squared. return [x ** 2 for x in numbers if x > 0]"},{"question":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring(\\"abcabcbb\\") 3 >>> longest_substring(\\"abcdef\\") 6 >>> longest_substring(\\"bbbbb\\") 1 >>> longest_substring(\\"aAbBcC\\") 6 >>> longest_substring(\\"\\") 0 >>> longest_substring(\\"a\\") 1 >>> longest_substring(\\"pwwkew\\") 3 >>> longest_substring(\\"dvdf\\") 3 import unittest class TestLongestSubstring(unittest.TestCase): def test_longest_substring_example(self): self.assertEqual(longest_substring(\\"abcabcbb\\"), 3) def test_longest_substring_all_unique(self): self.assertEqual(longest_substring(\\"abcdef\\"), 6) def test_longest_substring_repeating_characters(self): self.assertEqual(longest_substring(\\"bbbbb\\"), 1) def test_longest_substring_mixed_case(self): self.assertEqual(longest_substring(\\"aAbBcC\\"), 6) def test_longest_substring_empty_string(self): self.assertEqual(longest_substring(\\"\\"), 0) def test_longest_substring_single_character(self): self.assertEqual(longest_substring(\\"a\\"), 1) def test_longest_substring_long_string(self): self.assertEqual(longest_substring(\\"pwwkew\\"), 3) def test_longest_substring_end_of_string(self): self.assertEqual(longest_substring(\\"dvdf\\"), 3) if __name__ == \\"__main__\\": unittest.main()","solution":"def longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def is_palindrome(sentence: str) -> bool: Determines whether a given sentence is a palindrome, ignoring spaces, punctuation, and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"Madam, in Eden, I’m Adam\\") True Unit Test: def test_palindrome_simple_true(): assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True def test_palindrome_simple_false(): assert is_palindrome(\\"Hello, World!\\") == False def test_palindrome_with_names(): assert is_palindrome(\\"Madam, in Eden, I’m Adam\\") == True def test_palindrome_with_mixed_case(): assert is_palindrome(\\"Able , was I saw eLba\\") == True def test_palindrome_with_special_chars(): assert is_palindrome(\\"@ # % ^ &*() Ma. daM *&^%#@!\\") == True def test_palindrome_single_character(): assert is_palindrome(\\"a\\") == True def test_palindrome_number(): assert is_palindrome(\\"123321\\") == True def test_palindrome_with_spaces(): assert is_palindrome(\\"n o l e m o n, n o m e l o n\\") == True def test_palindrome_only_special_chars(): assert is_palindrome(\\"!@#%^&*()\\") == True","solution":"def is_palindrome(sentence): Determines whether a given sentence is a palindrome, ignoring spaces, punctuation, and case. import re # Remove non-alphanumeric characters and convert to lowercase. cleaned_sentence = re.sub(r'[^a-zA-Z0-9]', '', sentence).lower() # Check if the cleaned sentence is the same forward and backward. return cleaned_sentence == cleaned_sentence[::-1]"},{"question":"from typing import List def find_missing_number(arr: List[int]) -> int: Given an array of unique integers where each integer lies in the range [1, n], with n being the length of the array plus one and some integer k has been removed, identify and return the missing integer k. Args: arr (List[int]): A list of unique integers of length n-1 where each integer is between 1 and n inclusive. Returns: int: The missing integer k >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([2, 3]) 1 pass def test_find_missing_number_example_1(): arr = [1, 2, 4, 5] assert find_missing_number(arr) == 3 def test_find_missing_number_example_2(): arr = [3, 7, 1, 2, 8, 4, 5] assert find_missing_number(arr) == 6 def test_find_missing_number_example_3(): arr = [2, 3] assert find_missing_number(arr) == 1 def test_find_missing_number_single_element(): arr = [1] assert find_missing_number(arr) == 2 def test_find_missing_number_in_middle(): arr = [1, 2, 3, 5, 6, 7, 8, 9, 10] assert find_missing_number(arr) == 4 def test_find_missing_number_last_element(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_missing_number(arr) == 10","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: This function takes a list of unique integers from the range [1, n] with one number missing, and returns the missing number. n = len(arr) + 1 # Since the length of arr is n-1 total_sum = n * (n + 1) // 2 # Sum of first n natural numbers array_sum = sum(arr) return total_sum - array_sum"},{"question":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. >>> spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] pass def process_test_cases(test_cases: List[List[List[int]]]) -> List[List[int]]: Processes multiple test cases for spiral order matrix traversal. >>> test_cases = [ ... [[1, 2, 3], [4, 5, 6], [7, 8, 9]], ... [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] ... ] >>> process_test_cases(test_cases) [[1, 2, 3, 6, 9, 8, 7, 4, 5], [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]] pass def test_spiral_order_single_case(): assert spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] assert spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] def test_spiral_order_edge_cases(): assert spiral_order([[1]]) == [1] assert spiral_order([[1, 2], [3, 4]]) == [1, 2, 4, 3] def test_spiral_order_multiple_cases(): test_cases = [ [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] ] expected = [ [1, 2, 3, 6, 9, 8, 7, 4, 5], [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] ] results = process_test_cases(test_cases) assert results == expected","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. result = [] while matrix: result += matrix.pop(0) if matrix and matrix[0]: for row in matrix: result.append(row.pop()) if matrix: result += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result def process_test_cases(test_cases): Processes multiple test cases for spiral order matrix traversal. results = [] for matrix in test_cases: results.append(spiral_order(matrix)) return results"},{"question":"from typing import List def is_concatenation(s: str, words: List[str]) -> bool: Determine if \`s\` is a concatenation of all the words in the list exactly once without any intervening characters. >>> is_concatenation(\\"wordgoodbestgood\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) True >>> is_concatenation(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) False >>> is_concatenation(\\"abcdefghij\\", [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) False >>> is_concatenation(\\"\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) False >>> is_concatenation(\\"wordgoodbestgood\\", []) False >>> is_concatenation(\\"hello\\", [\\"hello\\"]) True >>> is_concatenation(\\"hello\\", [\\"world\\"]) False >>> is_concatenation(\\"foobar\\", [\\"foo\\", \\"bar\\"]) True >>> is_concatenation(\\"foobarfoo\\", [\\"foo\\", \\"bar\\"]) False","solution":"from typing import List def is_concatenation(s: str, words: List[str]) -> bool: Determine if \`s\` is a concatenation of all the words in the list exactly once without any intervening characters. if not words: return False word_length = len(words[0]) total_length = word_length * len(words) if len(s) != total_length: return False word_count = {} for word in words: word_count[word] = word_count.get(word, 0) + 1 for i in range(0, len(s), word_length): word = s[i:i+word_length] if word not in word_count: return False word_count[word] -= 1 if word_count[word] < 0: return False return all(count == 0 for count in word_count.values())"},{"question":"def is_valid_IP(ip: str) -> bool: Determines whether a given string is a valid IPv4 address. A valid IPv4 address consists of four numeric sections separated by dots, where each section is an integer between 0 and 255. >>> is_valid_IP(\\"192.168.1.1\\") == True >>> is_valid_IP(\\"255.255.255.255\\") == True >>> is_valid_IP(\\"256.256.256.256\\") == False >>> is_valid_IP(\\"192.168.01.1\\") == False >>> is_valid_IP(\\"192.168.1\\") == False >>> is_valid_IP(\\"abc.def.ghi.jkl\\") == False","solution":"def is_valid_IP(ip): Determines whether a given string is a valid IPv4 address. A valid IPv4 address consists of four numeric sections separated by dots, where each section is an integer between 0 and 255. sections = ip.split('.') if len(sections) != 4: return False for section in sections: if not section.isdigit() or not 0 <= int(section) <= 255: return False if section != str(int(section)): # Checks for leading zeroes return False return True"},{"question":"[Completion Task in Python] def min_groups(N: int, heights: List[int], D: int) -> int: Returns the minimum number of groups required such that the difference between the heights of any two trees within the same group does not exceed D. Args: N (int): The number of trees. heights (List[int]): A list of integers representing the heights of the trees. D (int): The maximum allowed height difference within a group. Returns: int: The minimum number of groups required. Examples: >>> min_groups(5, [15, 10, 20, 22, 18], 5) 2 >>> min_groups(1, [10], 5) 1 >>> min_groups(4, [10, 10, 10, 10], 1) 1 >>> min_groups(5, [2, 4, 6, 8, 10], 10) 1 >>> min_groups(5, [1, 10, 20, 30, 40], 1) 5 >>> min_groups(5, [1, 2, 8, 9, 15], 2) 3 >>> min_groups(6, [1, 3, 5, 7, 9, 11], 2) 3","solution":"def min_groups(N, heights, D): Returns the minimum number of groups required such that the difference between the heights of any two trees within the same group does not exceed D. # Sort the list of heights heights.sort() # Initialize the number of groups groups = 0 # Index to iterate over the heights i = 0 while i < N: # The current group starts with the first unassigned element current_height = heights[i] # Move to the next tree until the difference exceeds D while i < N and heights[i] - current_height <= D: i += 1 # One group is formed groups += 1 return groups"},{"question":"def validate_triangles(input_str: str) -> str: For each input string containing three integers separated by spaces, determine if these integers can form the sides of a valid triangle. A valid triangle requires that the sum of any two of its sides must be greater than the third side. For each input string, return \\"Valid triangle\\" if the sides form a valid triangle, otherwise return \\"Invalid triangle\\". Arguments: input_str: a string containing sets of integers formatted as follows: \\"3 4 5n1 1 2n7 10 5\\" Returns: A string formatted as follows: \\"Valid trianglenInvalid trianglenValid triangle\\" Test cases: >>> validate_triangles(\\"3 4 5n6 8 10n5 12 13\\") 'Valid trianglenValid trianglenValid triangle' >>> validate_triangles(\\"1 1 2n1 2 3n2 2 4\\") 'Invalid trianglenInvalid trianglenInvalid triangle' >>> validate_triangles(\\"3 4 5n1 1 2n7 10 5\\") 'Valid trianglenInvalid trianglenValid triangle' >>> validate_triangles(\\"6 8 10\\") 'Valid triangle' >>> validate_triangles(\\"1 1 2\\") 'Invalid triangle'","solution":"def validate_triangles(input_str): def is_valid_triangle(sides): a, b, c = sides return (a + b > c) and (a + c > b) and (b + c > a) lines = input_str.strip().split('n') results = [] for line in lines: sides = list(map(int, line.split())) if is_valid_triangle(sides): results.append(\\"Valid triangle\\") else: results.append(\\"Invalid triangle\\") return 'n'.join(results)"},{"question":"def longest_word(sentence: str) -> str: Finds and returns the longest word in the given sentence. If there are multiple words with the same longest length, returns the first one. >>> longest_word(\\"The quick brown fox jumped over the lazy dog\\") 'jumped' >>> longest_word(\\"The fox jumped high\\") 'jumped' >>> longest_word(\\"first secondthird fourth\\") 'secondthird' >>> longest_word(\\"cat bat rat\\") 'cat' >>> longest_word(\\"hello, world!\\") 'hello,' >>> longest_word(\\"word\\") 'word' >>> longest_word(\\"The quick\\") 'quick'","solution":"def longest_word(sentence): Finds and returns the longest word in the given sentence. If there are multiple words with the same longest length, returns the first one. words = sentence.split(' ') longest = words[0] for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"from typing import List, Tuple def min_tracks(schedule: List[Tuple[int, int]]) -> int: Given a list of tuples representing train schedules with start and end times, this function returns the minimum number of tracks required to accommodate all trains. >>> min_tracks([]) == 0 >>> min_tracks([(1, 4)]) == 1 >>> min_tracks([(1, 4), (5, 6), (7, 8)]) == 1 >>> min_tracks([(1, 4), (2, 5), (6, 8)]) == 2 >>> min_tracks([(1, 3), (3, 5), (4, 6), (7, 9)]) == 2 >>> min_tracks([(1, 4), (2, 7), (3, 9)]) == 3 >>> min_tracks([(1, 4), (5, 9), (2, 6), (8, 10)]) == 2 pass","solution":"from typing import List, Tuple def min_tracks(schedule: List[Tuple[int, int]]) -> int: Given a list of tuples representing train schedules with start and end times, this function returns the minimum number of tracks required to accommodate all trains. if not schedule: return 0 # Create two lists: one for all start times and one for all end times start_times = sorted([s[0] for s in schedule]) end_times = sorted([s[1] for s in schedule]) start_pointer = 0 end_pointer = 0 max_tracks = 0 current_tracks = 0 # Iterate through both lists to count overlaps while start_pointer < len(start_times): if start_times[start_pointer] < end_times[end_pointer]: current_tracks += 1 max_tracks = max(max_tracks, current_tracks) start_pointer += 1 else: current_tracks -= 1 end_pointer += 1 return max_tracks"},{"question":"def maxArea(height: List[int]) -> int: Returns the maximum amount of water a container can store. >>> maxArea([1,8,6,2,5,4,8,3,7]) 49 >>> maxArea([1,1]) 1","solution":"from typing import List def maxArea(height: List[int]) -> int: Returns the maximum amount of water a container can store. left, right = 0, len(height) - 1 max_water = 0 while left < right: # Calculate the width between the two lines width = right - left # Calculate the height of the container container_height = min(height[left], height[right]) # Calculate the current water contained current_water = width * container_height # Update the maximum water contained max_water = max(max_water, current_water) # Move the pointers to try and find a larger container if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"def maxProduct(nums: List[int]) -> int: Given an integer array nums, find a contiguous subarray (containing at least one number) which has the maximum product, and return its product. >>> maxProduct([2, 3, -2, 4]) 6 >>> maxProduct([-2, 0, -1]) 0 >>> maxProduct([-4, -3, -2]) 12","solution":"def maxProduct(nums): Finds the maximum product of a contiguous subarray in the given list of integers. :param nums: List of integers :return: Maximum product of a contiguous subarray if not nums: return 0 # Initialize the variables to the first element max_so_far = nums[0] min_so_far = nums[0] result = nums[0] for i in range(1, len(nums)): current = nums[i] # When multiplying by a negative number, max and min are swapped if current < 0: max_so_far, min_so_far = min_so_far, max_so_far max_so_far = max(current, max_so_far * current) min_so_far = min(current, min_so_far * current) result = max(result, max_so_far) return result"},{"question":"def max_coins_in_grid(grid): Find the maximum number of coins you can collect along the way from the top-left cell to the bottom-right cell in a grid, moving only right or down. >>> max_coins_in_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_coins_in_grid([[1, 2, 3, 4, 5]]) 15 >>> max_coins_in_grid([[1], [2], [3], [4], [5]]) 15 >>> max_coins_in_grid([[2, 1], [1, 3]]) 6 >>> max_coins_in_grid([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_coins_in_grid([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 7 pass # Your implementation goes here","solution":"def max_coins_in_grid(grid): Returns the maximum number of coins that can be collected from top-left to bottom-right of the grid. :param grid: List of List of integers representing the grid :return: Integer, maximum coins collected R = len(grid) C = len(grid[0]) # Create a 2D list to store the maximum coins collected up to each cell dp = [[0]*C for _ in range(R)] # Initialize the first cell with the value of grid[0][0] dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for c in range(1, C): dp[0][c] = dp[0][c-1] + grid[0][c] # Fill the first column (can only come from above) for r in range(1, R): dp[r][0] = dp[r-1][0] + grid[r][0] # Fill the rest of the dp table for r in range(1, R): for c in range(1, C): dp[r][c] = grid[r][c] + max(dp[r-1][c], dp[r][c-1]) # The result is the value in the bottom-right cell return dp[R-1][C-1]"},{"question":"from typing import List def numIslands(grid: List[List[str]]) -> int: Count the number of islands in the given grid. >>> numIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 >>> numIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"] ... ]) 3 >>> numIslands([ ... [\\"1\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\"] ... ]) 5 >>> numIslands([ ... [\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\"] ... ]) 1 >>> numIslands([ ... [\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\"] ... ]) 0 >>> numIslands([]) 0 pass","solution":"from typing import List def numIslands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(grid, r, c): rows, cols = len(grid), len(grid[0]) if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0': return grid[r][c] = '0' dfs(grid, r + 1, c) dfs(grid, r - 1, c) dfs(grid, r, c + 1) dfs(grid, r, c - 1) count = 0 rows, cols = len(grid), len(grid[0]) for r in range(rows): for c in range(cols): if grid[r][c] == '1': count += 1 dfs(grid, r, c) return count"},{"question":"def length_of_lis(arr: List[int]) -> int: Given a list of integers, returns the length of the longest increasing subsequence. Example: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([3, 2]) 1 >>> length_of_lis([50, 3, 10, 7, 40, 80]) 4","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the given list of integers. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_minimum_road_length(n, m, roads): Returns the minimum total length of new road network that connects all houses, or -1 if it is impossible to do so. Args: n: An integer, the number of houses. m: An integer, the number of available roads. roads: A list of tuples, where each tuple contains three integers (u, v, w) representing a road between houses u and v with length w. Returns: An integer, the minimum total length of the new road network, or -1 if it is impossible to connect all houses using the given roads. def test_example_1(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (4, 1, 5) ] assert find_minimum_road_length(n, m, roads) == 6 def test_example_2(): n = 3 m = 2 roads = [ (1, 2, 4), (2, 3, 5) ] assert find_minimum_road_length(n, m, roads) == 9 def test_example_3(): n = 3 m = 1 roads = [ (1, 2, 4) ] assert find_minimum_road_length(n, m, roads) == -1 def test_example_4(): n = 5 m = 6 roads = [ (1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 1), (3, 5, 6), (4, 5, 5) ] assert find_minimum_road_length(n, m, roads) == 11 def test_example_5(): n = 2 m = 1 roads = [ (1, 2, 1) ] assert find_minimum_road_length(n, m, roads) == 1","solution":"def find_minimum_road_length(n, m, roads): Returns the minimum total length of new road network that connects all houses, or -1 if it is impossible to do so. parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY # Sort roads based on their length roads.sort(key=lambda x: x[2]) total_length = 0 edges_used = 0 for u, v, w in roads: if find(u) != find(v): union(u, v) total_length += w edges_used += 1 # If we've used n - 1 edges, we have enough to form a tree if edges_used == n - 1: break # Check if we used exactly n - 1 edges (forming a tree) if edges_used == n - 1: return total_length else: return -1"},{"question":"def evaluate_expression(expr: str) -> int: Evaluate a given mathematical expression containing integers and the operators + and - only. >>> evaluate_expression(\\"3+2-5\\") 0 >>> evaluate_expression(\\"10+20-30+40\\") 40 >>> evaluate_expression(\\"100-50+25-75\\") 0","solution":"def evaluate_expression(expr): Evaluates a given mathematical expression containing integers and the operators + and - only. :param expr: str : mathematical expression to evaluate :return: int : result of the evaluated expression return eval(expr)"},{"question":"def encryptMessage(message: str, shift: int) -> str: Encrypt the message by shifting each character forward by a fixed number of positions in the alphabet. Parameters: message (str): The string to be encrypted, containing only lowercase alphabets and spaces. shift (int): The number of positions to shift each character. Returns: str: The encrypted message. >>> encryptMessage(\\"hello world\\", 3) \\"khoor zruog\\" >>> encryptMessage(\\"abc\\", 1) \\"bcd\\" def test_encrypt_message_no_shift(): assert encryptMessage(\\"abc\\", 0) == \\"abc\\" assert encryptMessage(\\"hello\\", 0) == \\"hello\\" def test_encrypt_message_with_shift(): assert encryptMessage(\\"abc\\", 1) == \\"bcd\\" assert encryptMessage(\\"xyz\\", 1) == \\"yza\\" assert encryptMessage(\\"hello world\\", 3) == \\"khoor zruog\\" assert encryptMessage(\\"abc def\\", 3) == \\"def ghi\\" def test_encrypt_message_spaces_preserved(): assert encryptMessage(\\"a b c\\", 1) == \\"b c d\\" assert encryptMessage(\\" \\", 5) == \\" \\" def test_encrypt_message_large_shift(): assert encryptMessage(\\"abc\\", 26) == \\"abc\\" assert encryptMessage(\\"xyz\\", 52) == \\"xyz\\" assert encryptMessage(\\"hello world\\", 29) == \\"khoor zruog\\"","solution":"def encryptMessage(message: str, shift: int) -> str: encrypted_message = [] for char in message: if char == ' ': encrypted_message.append(char) else: new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) encrypted_message.append(new_char) return ''.join(encrypted_message)"},{"question":"def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list containing only the unique elements that are present in both input lists. >>> find_common_elements([1, 3, 4, 6, 7, 7, 8], [4, 4, 5, 6, 8, 8, 9]) -> [4, 6, 8] >>> find_common_elements([1, 2, 3], [4, 5, 6]) -> [] >>> find_common_elements([], [1, 2, 3]) -> [] >>> find_common_elements([], []) -> [] >>> find_common_elements([1, 2, 3], [1, 2, 3]) -> [1, 2, 3]","solution":"def find_common_elements(list1, list2): Returns a sorted list containing only the unique elements that are present in both input lists. # Convert lists to sets to find common elements and ensure uniqueness set1 = set(list1) set2 = set(list2) # Find intersection of the two sets common_elements = set1 & set2 # Convert set to sorted list return sorted(common_elements)"},{"question":"class Cinema: A class to represent a cinema seat allocation system. Methods: - book_seat(row, seat): Books a specific seat if it is available. - check_seat(row, seat): Checks if a specific seat is available. - display_layout(): Displays the current seating layout. def __init__(self, rows, seats_per_row): Initializes the cinema with the given number of rows and seats per row. All seats are initially available ('O'). pass def book_seat(self, row, seat): Books a specific seat if it is available. Args: - row (int): The row number (1-indexed). - seat (int): The seat number (1-indexed). Returns: - bool: True if the booking was successful, False if the seat is already booked. pass def check_seat(self, row, seat): Checks if a specific seat is available. Args: - row (int): The row number (1-indexed). - seat (int): The seat number (1-indexed). Returns: - bool: True if the seat is available, False if it is booked. pass def display_layout(self): Displays the current seating layout. pass # Unit Tests def test_initial_layout(): cinema = Cinema(5, 7) expected_layout = [['O' for _ in range(7)] for _ in range(5)] assert cinema.layout == expected_layout def test_book_seat(): cinema = Cinema(5, 7) assert cinema.book_seat(1, 1) == True assert cinema.book_seat(1, 1) == False # Cannot book already booked seat assert cinema.layout[0][0] == 'X' # Seat should be marked as booked def test_check_seat(): cinema = Cinema(5, 7) assert cinema.check_seat(1, 1) == True # Initially available cinema.book_seat(1, 1) assert cinema.check_seat(1, 1) == False # Should be booked now def test_display_layout(capsys): cinema = Cinema(2, 3) cinema.book_seat(1, 1) cinema.book_seat(2, 3) cinema.display_layout() captured = capsys.readouterr() expected_output = \\"X O OnO O Xn\\" assert captured.out == expected_output","solution":"class Cinema: def __init__(self, rows, seats_per_row): Initializes the cinema with the given number of rows and seats per row. All seats are initially available ('O'). self.rows = rows self.seats_per_row = seats_per_row self.layout = [['O' for _ in range(seats_per_row)] for _ in range(rows)] def book_seat(self, row, seat): Books a specific seat if it is available. Args: - row (int): The row number (1-indexed). - seat (int): The seat number (1-indexed). Returns: - bool: True if the booking was successful, False if the seat is already booked. if self.layout[row - 1][seat - 1] == 'O': self.layout[row - 1][seat - 1] = 'X' return True return False def check_seat(self, row, seat): Checks if a specific seat is available. Args: - row (int): The row number (1-indexed). - seat (int): The seat number (1-indexed). Returns: - bool: True if the seat is available, False if it is booked. return self.layout[row - 1][seat - 1] == 'O' def display_layout(self): Displays the current seating layout. for row in self.layout: print(\\" \\".join(row))"},{"question":"def calculate(expression: str) -> float: Receives a string representing a mathematical expression and returns the calculated result as a number. The expression will contain two numbers and one of the four basic operations (+, -, *, /). >>> calculate(\\"3 + 2\\") == 5 >>> calculate(\\"10 - 6\\") == 4 >>> calculate(\\"4 * 5\\") == 20 >>> calculate(\\"8 / 2\\") == 4.0","solution":"def calculate(expression): Receives a string representing a mathematical expression and returns the calculated result as a number. The expression will contain two numbers and one of the four basic operations (+, -, *, /). # Split the expression by spaces parts = expression.split() # Extract the left operand, operator, and right operand left_operand = float(parts[0]) operator = parts[1] right_operand = float(parts[2]) # Perform the calculation based on the operator if operator == '+': return left_operand + right_operand elif operator == '-': return left_operand - right_operand elif operator == '*': return left_operand * right_operand elif operator == '/': return left_operand / right_operand"},{"question":"def max_min_power_path(n: int, k: int, powers: List[int]) -> int: Finds the maximum minimum power level of a path of length at least k that can be formed using the elements with strictly increasing power levels. >>> max_min_power_path(5, 3, [4, 2, 6, 1, 5]) 4 >>> max_min_power_path(6, 4, [3, 1, 4, 7, 6, 2]) 3 >>> max_min_power_path(5, 6, [1, 2, 3, 4, 5]) -1 >>> max_min_power_path(5, 3, [5, 5, 5, 5, 5]) 5 >>> max_min_power_path(2, 1, [1, 2]) 2 >>> max_min_power_path(5, 2, [1000000000, 100000000, 10000000, 1000000, 100000]) 100000000","solution":"def max_min_power_path(n, k, powers): Finds the maximum minimum power level of a path of length at least k. def is_valid(min_power): count = 0 for power in powers: if power >= min_power: count += 1 if count >= k: return True return False left, right = 1, max(powers) result = -1 while left <= right: mid = (left + right) // 2 if is_valid(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"def calculate_minimum_energy(q: int, tasks: List[Tuple[int, int, int]]) -> List[int]: Calculate the minimum energy required for either a powered bike or a flying drone to reach the target intersection from the headquarters (0, 0). >>> calculate_minimum_energy(4, [(1, -2, 3), (2, 5, 5), (2, 3, 6), (1, 4, -1)]) [5, 5, 6, 5] >>> calculate_minimum_energy(3, [(1, 1, 1), (2, 2, 3), (1, 3, 5)]) [2, 3, 8] >>> calculate_minimum_energy(3, [(1, -1, -1), (2, -2, -2), (1, -3, -5)]) [2, 2, 8] >>> calculate_minimum_energy(4, [(1, -1, 2), (2, 3, -3), (1, 0, 4), (2, 1, 5)]) [3, 3, 4, 5] >>> calculate_minimum_energy(2, [(1, 0, 0), (2, 0, 0)]) [0, 0]","solution":"def calculate_minimum_energy(q, tasks): results = [] for task in tasks: t, x, y = task if t == 1: # Powered bike: moves horizontally or vertically energy = abs(x) + abs(y) elif t == 2: # Flying drone: moves diagonally energy = max(abs(x), abs(y)) results.append(energy) return results"},{"question":"from typing import List def islandPerimeter(grid: List[List[int]]) -> int: Find the perimeter of the island represented in the given grid. The grid is a list of lists of integers where 1 represents land and 0 represents water. Example: >>> islandPerimeter([ ... [0,1,0,0], ... [1,1,1,0], ... [0,1,0,0], ... [1,1,0,0] ... ]) 16 >>> islandPerimeter([[1]]) 4 Constraints: - The grid should be at least 1x1 and at most 100x100 in size. - The grid contains only '0's and '1's. - There is exactly one island.","solution":"from typing import List def islandPerimeter(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) perimeter = 0 def check_perimeter(i, j): p = 0 if i == 0 or grid[i-1][j] == 0: # check up p += 1 if i == rows-1 or grid[i+1][j] == 0: # check down p += 1 if j == 0 or grid[i][j-1] == 0: # check left p += 1 if j == cols-1 or grid[i][j+1] == 0: # check right p += 1 return p for i in range(rows): for j in range(cols): if grid[i][j] == 1: perimeter += check_perimeter(i, j) return perimeter"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxM matrix by 90 degrees clockwise and returns the resulting matrix. >>> rotate_matrix_90_degrees_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_degrees_clockwise([[1]]) [[1]] def test_rotate_matrix_90_degrees_clockwise(): # Test example from the prompt matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected # Test another case with different dimensions matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] expected = [ [9, 5, 1], [10, 6, 2], [11, 7, 3], [12, 8, 4] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected # Test a 1x1 matrix matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected # Test a 2x2 matrix matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected # Test a 3x2 matrix matrix = [ [1, 2], [3, 4], [5, 6] ] expected = [ [5, 3, 1], [6, 4, 2] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected def process_test_cases(test_cases): Processes multiple test cases and returns the resulting matrices after rotation. results = [] for case in test_cases: N, M, matrix = case rotated_matrix = rotate_matrix_90_degrees_clockwise(matrix) results.append(rotated_matrix) return results def test_process_test_cases(): test_cases = [ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) ] expected = [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ] assert process_test_cases(test_cases) == expected test_cases = [ (3, 4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ]) ] expected = [ [ [9, 5, 1], [10, 6, 2], [11, 7, 3], [12, 8, 4] ] ] assert process_test_cases(test_cases) == expected","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxM matrix by 90 degrees clockwise and returns the resulting matrix. N = len(matrix) M = len(matrix[0]) rotated = [] for col in range(M): new_row = [] for row in range(N-1, -1, -1): new_row.append(matrix[row][col]) rotated.append(new_row) return rotated def process_test_cases(test_cases): Processes multiple test cases and returns the resulting matrices after rotation. results = [] for case in test_cases: N, M, matrix = case rotated_matrix = rotate_matrix_90_degrees_clockwise(matrix) results.append(rotated_matrix) return results"},{"question":"def find_best_hotel(test_cases): Given the number of rooms needed and the maximum acceptable distance to the airport, finds the best hotel for the conference. Parameters: test_cases (List[Dict]): A list of dictionaries where each dictionary represents a test case. Each dictionary has the following keys: - 'NRD': A tuple containing three integers N (number of hotels), R (number of rooms needed), D (maximum acceptable distance to the airport) - 'hotels': A list of tuples where each tuple contains two integers ri (number of rooms) and di (distance to the airport) Returns: List[int]: A list of indices (1-based) of the best hotel for each test case. If no hotels meet the criteria, returns -1. Example: >>> test_cases = [ ... {\\"NRD\\": (3, 200, 50), \\"hotels\\": [(150, 30), (300, 20), (250, 60)]}, ... {\\"NRD\\": (4, 400, 50), \\"hotels\\": [(200, 10), (350, 40), (400, 30), (450, 35)]} ... ] >>> find_best_hotel(test_cases) [2, 4]","solution":"def find_best_hotel(test_cases): results = [] for case in test_cases: N, R, D = case['NRD'] hotels = case['hotels'] best_hotel_index = -1 max_rooms = 0 min_distance = float('inf') for i, (rooms, distance) in enumerate(hotels): if rooms >= R and distance <= D: if rooms > max_rooms or (rooms == max_rooms and distance < min_distance): best_hotel_index = i + 1 max_rooms = rooms min_distance = distance results.append(best_hotel_index) return results"},{"question":"def longest_odd_subarray(arr): Returns the length of the longest contiguous subarray consisting entirely of odd integers. >>> longest_odd_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9]) 1 >>> longest_odd_subarray([1, 3, 5, 7, 2, 1, 9, 11]) 4 >>> longest_odd_subarray([2, 4, 6, 8]) 0 >>> longest_odd_subarray([1, 3, 5, 7, 9]) 5 >>> longest_odd_subarray([1]) 1 >>> longest_odd_subarray([2]) 0 >>> longest_odd_subarray([]) 0 >>> longest_odd_subarray([2, 2, 1, 3, 5, 7]) 4","solution":"def longest_odd_subarray(arr): Returns the length of the longest contiguous subarray consisting entirely of odd integers. max_length = 0 current_length = 0 for num in arr: if num % 2 != 0: # The number is odd current_length += 1 max_length = max(max_length, current_length) else: # The number is even current_length = 0 return max_length"},{"question":"def longest_increasing_path(matrix): Find the length of the longest increasing path in the matrix. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([ ... [42] ... ]) 1 >>> longest_increasing_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 >>> longest_increasing_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 5 >>> longest_increasing_path([ ... [1, 4, 7], ... [2, 5, 8], ... [3, 6, 9] ... ]) 5 >>> longest_increasing_path([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) 9","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 R, C = len(matrix), len(matrix[0]) memo = [[-1] * C for _ in range(R)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and matrix[nx][ny] > matrix[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) memo[x][y] = max_path return max_path max_length = 0 for i in range(R): for j in range(C): max_length = max(max_length, dfs(i, j)) return max_length"},{"question":"def find_matching_substring(main_string: str, pattern: str) -> list: Finds the starting indices of substrings in the main string that exactly match the pattern string. >>> find_matching_substring(\\"abracadabra\\", \\"abr\\") # [0, 7] >>> find_matching_substring(\\"aaaaaa\\", \\"aa\\") # [0, 1, 2, 3, 4] >>> find_matching_substring(\\"hello\\", \\"ll\\") # [2] >>> find_matching_substring(\\"hello\\", \\"world\\") # []","solution":"def find_matching_substring(main_string, pattern): Finds the starting indices of substrings in the main string that exactly match the pattern string. Args: main_string (str): The main string in which to search. pattern (str): The pattern string to search for. Returns: list: A list of starting indices of the matching substrings. pattern_length = len(pattern) main_length = len(main_string) if pattern_length > main_length: return [] result = [] for i in range(main_length - pattern_length + 1): if main_string[i:i + pattern_length] == pattern: result.append(i) return result"},{"question":"def sum_square_diff(n: int) -> int: Calculates the difference between the square of the sum and the sum of the squares of the first n natural numbers. >>> sum_square_diff(1) 0 >>> sum_square_diff(2) 4 >>> sum_square_diff(3) 22 >>> sum_square_diff(10) 2640 >>> sum_square_diff(100) 25164150 >>> sum_square_diff(1000) 250166416500","solution":"def sum_square_diff(n): Calculates the difference between the square of the sum and the sum of the squares of the first n natural numbers. Parameters: n (int): The upper limit for the first n natural numbers. Returns: int: The difference between the square of the sum and the sum of the squares. sum_of_numbers = n * (n + 1) // 2 sum_of_squares = n * (n + 1) * (2 * n + 1) // 6 square_of_sum = sum_of_numbers ** 2 return square_of_sum - sum_of_squares"},{"question":"def calculate_coupons(prices: List[int]) -> int: Calculate the total number of coupons for given car prices. >>> calculate_coupons([7500, 15000, 48000]) 15 >>> calculate_coupons([60000, 105000]) 46 def total_coupons_per_test_case(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the total number of coupons for each test case. >>> total_coupons_per_test_case([(3, [7500, 15000, 48000]), (2, [60000, 105000])]) [15, 46]","solution":"def calculate_coupons(prices): total_coupons = 0 for price in prices: if price < 10000: total_coupons += 0 elif price <= 30000: total_coupons += 5 elif price <= 50000: total_coupons += 10 else: extra_coupons = (price - 50000) // 10000 total_coupons += 20 + extra_coupons return total_coupons def total_coupons_per_test_case(test_cases): results = [] for case in test_cases: N, prices = case results.append(calculate_coupons(prices)) return results"},{"question":"def calculate_payable_amount(prices: List[int]) -> float: Returns the total amount payable after applying discounts based on the number of unique items. >>> calculate_payable_amount([100, 200, 300, 400, 500]) 1350.0 >>> calculate_payable_amount([50, 50, 100]) 200.0 >>> calculate_payable_amount([100, 200, 300, 100, 200, 300, 400, 500]) 1890.0 >>> calculate_payable_amount([100, 100, 100, 100]) 400.0 >>> calculate_payable_amount([500]) 500.0 >>> calculate_payable_amount([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 46.75 >>> calculate_payable_amount([10, 20, 30]) 57.0 >>> calculate_payable_amount([100, 200, 300, 400, 500, 600, 700]) 2380.0","solution":"def calculate_payable_amount(prices): Returns the total amount payable after applying discounts based on the number of unique items. # Calculate the total bill total_bill = sum(prices) # Get the number of unique items unique_items_count = len(set(prices)) # Determine the discount percentage if unique_items_count >= 7: discount = 0.15 elif unique_items_count >= 5: discount = 0.10 elif unique_items_count >= 3: discount = 0.05 else: discount = 0.0 # Calculate the amount payable after applying the discount amount_payable = total_bill * (1 - discount) return round(amount_payable, 2)"},{"question":"def validate_user_ids(user_ids: List[str]) -> List[str]: Validate a list of user IDs based on the company rules. Each user ID must: 1. Consist of exactly 8 characters. 2. Contain at least one uppercase letter. 3. Contain at least one lowercase letter. 4. Contain at least one digit. >>> validate_user_ids([\\"A1b3kLop\\"]) [\\"valid\\"] >>> validate_user_ids([\\"a1b3klop\\"]) [\\"invalid\\"] >>> validate_user_ids([\\"A1B3KLOP\\"]) [\\"invalid\\"] >>> validate_user_ids([\\"AbcDefGh\\"]) [\\"invalid\\"] >>> validate_user_ids([\\"12345678\\"]) [\\"invalid\\"] >>> validate_user_ids([\\"A1b3kLop\\", \\"12345678\\", \\"abcdefgh\\"]) [\\"valid\\", \\"invalid\\", \\"invalid\\"] >>> validate_user_ids([\\"A1b2C3d4\\", \\"A1cD2L3p\\", \\"1234abcd\\"]) [\\"valid\\", \\"valid\\", \\"invalid\\"] # Your implementation here","solution":"def validate_user_ids(user_ids): results = [] for user_id in user_ids: if len(user_id) == 8 and any(char.isupper() for char in user_id) and any(char.islower() for char in user_id) and any(char.isdigit() for char in user_id): results.append(\\"valid\\") else: results.append(\\"invalid\\") return results"},{"question":"def strictly_increasing_counts(farm_record): This function takes a dictionary farm_record where keys are the names of animals and values are lists of integers representing the count of each animal recorded each day. It returns a list of strings containing the names of the animals whose counts are strictly increasing every day. >>> strictly_increasing_counts({ \\"sheep\\": [1, 2, 3, 4], \\"cows\\": [2, 3, 3, 5], \\"chickens\\": [1, 2, 1, 4], \\"ducks\\": [3, 4, 5, 6] }) [\\"sheep\\", \\"ducks\\"] >>> strictly_increasing_counts({ \\"sheep\\": [3, 3, 3, 3], \\"cows\\": [5, 5, 5, 5], \\"chickens\\": [2, 1, 1, 1], \\"ducks\\": [4, 4, 4, 4] }) [] >>> strictly_increasing_counts({ \\"sheep\\": [1, 2, 3, 4], \\"cows\\": [2, 3, 4, 5], \\"chickens\\": [1, 2, 3, 4], \\"ducks\\": [3, 4, 5, 6] }) [\\"sheep\\", \\"cows\\", \\"chickens\\", \\"ducks\\"] >>> strictly_increasing_counts({ \\"sheep\\": [1], \\"cows\\": [2], \\"chickens\\": [3], \\"ducks\\": [4] }) [\\"sheep\\", \\"cows\\", \\"chickens\\", \\"ducks\\"] >>> strictly_increasing_counts({ \\"sheep\\": [1, 1, 1, 1], \\"cows\\": [1, 2, 3, 4], \\"chickens\\": [4, 3, 2, 1], \\"ducks\\": [5, 5, 5, 5] }) [\\"cows\\"]","solution":"def strictly_increasing_counts(farm_record): This function takes a dictionary farm_record where keys are the names of animals and values are lists of integers representing the count of each animal recorded each day. It returns a list of strings containing the names of the animals whose counts are strictly increasing every day. increasing_animals = [] for animal, counts in farm_record.items(): if all(counts[i] < counts[i + 1] for i in range(len(counts) - 1)): increasing_animals.append(animal) return increasing_animals"},{"question":"def solve_sudoku(board: List[List[str]]): Solves the Sudoku puzzle by filling the empty cells such that each row, each column, and each 3x3 sub-grid contains the digits from 1 to 9 exactly once. The board is modified in-place. >>> board = [ ['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9'] ] >>> solve_sudoku(board) >>> board == [ ['5', '3', '4', '6', '7', '8', '9', '1', '2'], ['6', '7', '2', '1', '9', '5', '3', '4', '8'], ['1', '9', '8', '3', '4', '2', '5', '6', '7'], ['8', '5', '9', '7', '6', '1', '4', '2', '3'], ['4', '2', '6', '8', '5', '3', '7', '9', '1'], ['7', '1', '3', '9', '2', '4', '8', '5', '6'], ['9', '6', '1', '5', '3', '7', '2', '8', '4'], ['2', '8', '7', '4', '1', '9', '6', '3', '5'], ['3', '4', '5', '2', '8', '6', '1', '7', '9'] ]","solution":"def solve_sudoku(board): Solves the Sudoku puzzle by filling the empty cells such that each row, each column, and each 3x3 sub-grid contains the digits from 1 to 9 exactly once. The board is modified in-place. def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num or board[row - row % 3 + i // 3][col - col % 3 + i % 3] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == '.': for num in map(str, range(1, 10)): # iterating over the digits '1' to '9' if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = '.' return False return True solve()"},{"question":"def replace_vowels_with_positions(s: str) -> str: Replaces vowels in the string with their corresponding position in the alphabet formatted as two digits. Args: s (str): Input string containing lowercase and/or uppercase letters. Returns: str: Modified string with vowels replaced by their position in the alphabet. Examples: >>> replace_vowels_with_positions(\\"aeiou\\") \\"0105091521\\" >>> replace_vowels_with_positions(\\"Example\\") \\"05x01mpl05\\" >>> replace_vowels_with_positions(\\"bcdfg\\") \\"bcdfg\\" >>> replace_vowels_with_positions(\\"\\") \\"\\"","solution":"def replace_vowels_with_positions(s): Replaces vowels in the string with their corresponding position in the alphabet formatted as two digits. vowel_to_position = { 'a': '01', 'e': '05', 'i': '09', 'o': '15', 'u': '21', 'A': '01', 'E': '05', 'I': '09', 'O': '15', 'U': '21' } result = [] for char in s: if char in vowel_to_position: result.append(vowel_to_position[char]) else: result.append(char) return ''.join(result)"},{"question":"from typing import List def compact_memory(memory: List[int]) -> List[int]: Compacts the memory list by shifting all 1s towards the beginning and all 0s towards the end, preserving the order of 1s. >>> compact_memory([0, 1, 0, 1, 1, 0]) [1, 1, 1, 0, 0, 0] >>> compact_memory([1, 1, 0, 0, 1]) [1, 1, 1, 0, 0]","solution":"from typing import List def compact_memory(memory: List[int]) -> List[int]: Compacts the memory list by shifting all 1s towards the beginning and all 0s towards the end, preserving the order of 1s. one_count = memory.count(1) zero_count = len(memory) - one_count return [1] * one_count + [0] * zero_count"},{"question":"def minimum_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of adjacent swaps required to sort the array in strictly increasing order. >>> minimum_swaps_to_sort([4, 3, 2, 1]) 6 >>> minimum_swaps_to_sort([3, 1, 2, 5, 4]) 3 >>> minimum_swaps_to_sort([1, 3, 2]) 1 >>> minimum_swaps_to_sort([5]) 0 >>> minimum_swaps_to_sort([1, 2, 3, 4]) 0 >>> minimum_swaps_to_sort([4, 3, 2, 1]) 6 >>> minimum_swaps_to_sort([3, 2, 1]) 3 >>> minimum_swaps_to_sort([1000, 999, 998]) 3 >>> minimum_swaps_to_sort([2, 2, 2]) 0 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns a list of results, where each result is the minimum number of adjacent swaps required for that case. >>> process_test_cases([(4, [4, 3, 2, 1]), (5, [3, 1, 2, 5, 4]), (3, [1, 3, 2])]) [6, 3, 1] >>> process_test_cases([(1, [5])]) [0] >>> process_test_cases([(4, [1, 2, 3, 4])]) [0] >>> process_test_cases([(4, [4, 3, 2, 1]), (3, [3, 2, 1])]) [6, 3] >>> process_test_cases([(3, [1000, 999, 998])]) [3] >>> process_test_cases([(3, [2, 2, 2])]) [0] pass","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of adjacent swaps required to sort the array in strictly increasing order. n = len(arr) swaps = 0 for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return swaps def process_test_cases(test_cases): results = [] for case in test_cases: N, A = case results.append(minimum_swaps_to_sort(A)) return results"},{"question":"from typing import List def get_minutes_since_midnight(time_str: str) -> int: Convert a time in HH:MM format to minutes since midnight. hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes def events_overlap(timestamps: List[str], duration: int) -> bool: Determines if any two events overlap given their starting timestamps and duration. Args: timestamps: list : list of start timestamps in \\"HH:MM\\" format duration : int : event duration in minutes Returns: bool: True if any two events overlap, otherwise False Examples: >>> events_overlap([\\"09:00\\", \\"10:30\\", \\"12:00\\"], 60) False >>> events_overlap([\\"09:00\\", \\"09:30\\", \\"10:00\\"], 45) True pass def test_no_overlap(): timestamps = [\\"09:00\\", \\"10:30\\", \\"12:00\\"] duration = 60 assert events_overlap(timestamps, duration) == False def test_overlap(): timestamps = [\\"09:00\\", \\"09:30\\", \\"10:00\\"] duration = 45 assert events_overlap(timestamps, duration) == True def test_exact_end_start_no_overlap(): timestamps = [\\"09:00\\", \\"09:45\\", \\"10:30\\"] duration = 45 assert events_overlap(timestamps, duration) == False def test_all_day_event(): timestamps = [\\"00:00\\", \\"12:00\\"] duration = 1440 assert events_overlap(timestamps, duration) == True def test_one_event(): timestamps = [\\"09:00\\"] duration = 60 assert events_overlap(timestamps, duration) == False def test_edge_case_overlap(): timestamps = [\\"22:00\\", \\"23:30\\", \\"23:59\\"] duration = 90 assert events_overlap(timestamps, duration) == True def test_no_overlap_random_times(): timestamps = [\\"13:00\\", \\"15:00\\", \\"09:00\\", \\"11:00\\"] duration = 60 assert events_overlap(timestamps, duration) == False","solution":"def get_minutes_since_midnight(time_str): Convert a time in HH:MM format to minutes since midnight. hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes def events_overlap(timestamps, duration): Determines if any two events overlap given their starting timestamps and duration. Args: timestamps: list of str : list of start timestamps in \\"HH:MM\\" format duration : int : event duration in minutes Returns: bool: True if any two events overlap, otherwise False intervals = [] for timestamp in timestamps: start = get_minutes_since_midnight(timestamp) end = start + duration intervals.append((start, end)) intervals.sort() # Sort intervals based on start times for i in range(len(intervals) - 1): current_end = intervals[i][1] next_start = intervals[i+1][0] if current_end > next_start: return True return False"},{"question":"def motivational_message(hours: int) -> str: Returns a motivational message based on the number of hours a student has studied. >>> motivational_message(5) \\"Excellent, you're well-prepared!\\" >>> motivational_message(6) \\"Excellent, you're well-prepared!\\" >>> motivational_message(4) \\"Keep going, you can do it!\\" >>> motivational_message(0) \\"Keep going, you can do it!\\" >>> motivational_message(-1) \\"Keep going, you can do it!\\"","solution":"def motivational_message(hours): Returns a motivational message based on the number of hours a student has studied. Parameters: hours (int): The number of hours a student has studied. Returns: str: A motivational message. if hours >= 5: return \\"Excellent, you're well-prepared!\\" else: return \\"Keep going, you can do it!\\""},{"question":"def extract_domain(url: str) -> str: Extracts the domain name from a given URL. >>> extract_domain(\\"http://github.com/codingdojo\\") 'github' >>> extract_domain(\\"https://www.youtube.com/watch?v=abcd\\") 'youtube' >>> extract_domain(\\"www.example.org/index.html\\") 'example' >>> extract_domain(\\"http://bbc.co.uk/news\\") 'bbc'","solution":"def extract_domain(url: str) -> str: Extracts the domain name from a given URL. Parameters: url (str): The URL from which to extract the domain. Returns: str: The extracted domain name. # Remove the protocol if present if url.startswith(\\"http://\\"): url = url[7:] elif url.startswith(\\"https://\\"): url = url[8:] # Remove 'www.' if present if url.startswith(\\"www.\\"): url = url[4:] # Find the domain by splitting at the first '/' or ':' domain = url.split('/')[0].split(':')[0] # Get the base domain without the subdomains base_domain = domain.split('.')[0] return base_domain"},{"question":"def rotate_list_by_k(lst: List[int], k: int) -> List[int]: Rotates the list to the right by k positions. >>> rotate_list_by_k([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list_by_k([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list_by_k([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list_by_k([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list_by_k([1, 2], 3) [2, 1] >>> rotate_list_by_k([1], 3) [1] >>> rotate_list_by_k([], 3) []","solution":"def rotate_list_by_k(lst, k): Rotates the list to the right by k positions. if not lst: return lst n = len(lst) k = k % n # To handle cases where k > n return lst[-k:] + lst[:-k] # Example usage lst = [1, 2, 3, 4, 5] k = 2 rotated_list = rotate_list_by_k(lst, k) print(rotated_list) # Output: [4, 5, 1, 2, 3]"},{"question":"def longestCommonSubstring(A: str, B: str) -> str: Returns the longest common substring between A and B. >>> longestCommonSubstring(\\"abcdef\\", \\"zcdemf\\") \\"cde\\" >>> longestCommonSubstring(\\"xyz\\", \\"abcd\\") \\"\\"","solution":"def longestCommonSubstring(A, B): Returns the longest common substring between A and B. m, n = len(A), len(B) longest_end = 0 max_length = 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_length: max_length = dp[i][j] longest_end = i else: dp[i][j] = 0 return A[longest_end - max_length: longest_end]"},{"question":"def num_subarray_product_less_than_k(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is less than k. >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_k([1, 2, 3], 0) 0","solution":"def num_subarray_product_less_than_k(nums, k): if k <= 1: return 0 product = 1 left = 0 count = 0 for right in range(len(nums)): product *= nums[right] while product >= k: product //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"from typing import List, Tuple def final_coordinates(start_x: int, start_y: int, moves: List[str]) -> Tuple[int, int]: Determines the final coordinates after a series of moves starting from (start_x, start_y). Args: start_x (int): Initial x-coordinate. start_y (int): Initial y-coordinate. moves (List[str]): List of moves which can be \\"Up\\", \\"Down\\", \\"Left\\", or \\"Right\\". Returns: Tuple[int, int]: Final coordinates (xf, yf) after executing all the moves. Examples: >>> final_coordinates(2, 3, [\\"Up\\", \\"Up\\", \\"Left\\", \\"Down\\"]) (1, 4) >>> final_coordinates(5, 5, [\\"Right\\", \\"Right\\", \\"Down\\", \\"Left\\", \\"Up\\"]) (6, 5)","solution":"from typing import List, Tuple def final_coordinates(start_x: int, start_y: int, moves: List[str]) -> Tuple[int, int]: Determines the final coordinates after a series of moves starting from (start_x, start_y). Args: - start_x (int): Initial x-coordinate. - start_y (int): Initial y-coordinate. - moves (List[str]): List of moves which can be \\"Up\\", \\"Down\\", \\"Left\\", or \\"Right\\". Returns: - Tuple[int, int]: Final coordinates (xf, yf) after executing all the moves. x, y = start_x, start_y for move in moves: if move == \\"Up\\": y += 1 elif move == \\"Down\\": y -= 1 elif move == \\"Left\\": x -= 1 elif move == \\"Right\\": x += 1 return (x, y)"},{"question":"def filter_positive_integers(nums: List[int]) -> List[int]: Returns a list containing only the positive integers from the input list. >>> filter_positive_integers([1, -2, 3, -4, 5]) [1, 3, 5] >>> filter_positive_integers([-1, -2, -3, -4]) [] >>> filter_positive_integers([7, 8, 9]) [7, 8, 9]","solution":"def filter_positive_integers(nums): Returns a list containing only the positive integers from the input list. Args: nums (list): A list of integers. Returns: list: A new list containing only the positive integers from nums. return [num for num in nums if num > 0]"},{"question":"def longest_arithmetic_subsequence(flowers: List[int]) -> int: Returns the length of the longest subsequence where each flower is taller than the one before it and the difference in height between any two consecutive flowers is the same. >>> longest_arithmetic_subsequence([1, 7, 3, 5, 9, 2]) 3 >>> longest_arithmetic_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_arithmetic_subsequence([10, 20, 30, 45, 50]) 3 >>> longest_arithmetic_subsequence([1, 5, 9, 13, 17, 21]) 6 >>> longest_arithmetic_subsequence([1, 2, 4, 8, 16]) 2 >>> longest_arithmetic_subsequence([1]) 1 >>> longest_arithmetic_subsequence([]) 0 >>> longest_arithmetic_subsequence([3, 3, 3, 3, 3]) 5","solution":"def longest_arithmetic_subsequence(flowers): Returns the length of the longest subsequence that follows the given pattern where each flower is taller than the one before it and the difference in height between any two consecutive flowers is the same. from collections import defaultdict n = len(flowers) if n <= 1: return n dp = defaultdict(lambda: defaultdict(int)) max_length = 2 for i in range(1, n): for j in range(i): diff = flowers[i] - flowers[j] dp[i][diff] = dp[j][diff] + 1 max_length = max(max_length, dp[i][diff] + 1) return max_length"},{"question":"def analyze_consumption(data, location_id): Analyzes energy consumption for a given location_id from the provided data. Parameters: data (list of tuples): Each tuple contains (timestamp, location_id, energy_consumption in kWh). location_id (str): The unique identifier for the location to analyze. Returns: dict: A dictionary with keys 'total_consumption', 'average_consumption', 'max_consumption', and 'min_consumption' with corresponding values.","solution":"def analyze_consumption(data, location_id): Analyzes energy consumption for a given location_id from the provided data. Parameters: data (list of tuples): Each tuple contains (timestamp, location_id, energy_consumption in kWh). location_id (str): The unique identifier for the location to analyze. Returns: dict: A dictionary with keys 'total_consumption', 'average_consumption', 'max_consumption', and 'min_consumption' with corresponding values. consumption_values = [entry[2] for entry in data if entry[1] == location_id] if not consumption_values: return { 'total_consumption': 0, 'average_consumption': 0, 'max_consumption': 0, 'min_consumption': 0 } total_consumption = sum(consumption_values) average_consumption = round(total_consumption / len(consumption_values), 2) max_consumption = max(consumption_values) min_consumption = min(consumption_values) return { 'total_consumption': total_consumption, 'average_consumption': average_consumption, 'max_consumption': max_consumption, 'min_consumption': min_consumption }"},{"question":"from math import comb def plant_trees(n: int, m: int, p: int) -> int: Returns the number of ways to plant exactly p trees in a garden of dimensions n x m such that no two trees share the same row or column. >>> plant_trees(3, 3, 2) 9 >>> plant_trees(4, 5, 3) 40 >>> plant_trees(1, 1, 1) 1 >>> plant_trees(4, 4, 2) 36 >>> plant_trees(3, 3, 0) 1 >>> plant_trees(3, 3, 4) 0 >>> plant_trees(1000, 1000, 1) 1000000 >>> plant_trees(1000, 1000, 1000) # expected value should be larger than 0","solution":"from math import comb def plant_trees(n, m, p): Returns the number of ways to plant exactly p trees in a garden of dimensions n x m such that no two trees share the same row or column. if p > n or p > m: return 0 return comb(n, p) * comb(m, p)"},{"question":"def game_operations(n: int, q: int, strengths: List[int], operations: List[List[int]]) -> List[int]: Alice is a game designer and she is working on a new game where players encounter various creatures while traveling through a series of caves. Each cave has a certain number of creatures, and some caves are connected by tunnels. The creatures in each cave have certain strengths, and players often query the total strength of creatures in a cave or update the strength of creatures in certain caves. Alice needs a program to efficiently handle these operations. The function should support the following two types of operations: 1. Query the total strength of creatures in a specific cave. 2. Update the strength of creatures in a range of caves (inclusive). -----Input----- - The first line contains two integers N and Q, denoting the number of caves and the number of operations, respectively. - The second line contains N space-separated integers S1, S2, ..., SN, where Si denotes the strength of creatures in the i-th cave. - Each of the next Q lines describes an operation. If the first integer is “1”, it means that the operation is of Type 1, followed by one integer i. Otherwise, the first integer will be “2”, meaning that the operation is of Type 2, followed by three integers L, R, and X. -----Output----- For each operation of Type 1, output the total strength of creatures in the i-th cave. -----Constraints----- - 1 ≤ N, Q ≤ 100,000 - 1 ≤ Si ≤ 1,000,000 - 1 ≤ L ≤ R ≤ N - -1,000,000 ≤ X ≤ 1,000,000 - 1 ≤ i ≤ N -----Example----- Input: 5 3 10 20 30 40 50 1 3 2 2 4 5 1 3 Output: 30 35 >>> game_operations(5, 3, [10, 20, 30, 40, 50], [[1, 3], [2, 2, 4, 5], [1, 3]]) [30, 35] >>> game_operations(5, 1, [10, 20, 30, 40, 50], [[1, 3]]) [30] >>> game_operations(5, 1, [10, 20, 30, 40, 50], [[2, 2, 4, 5]]) []","solution":"def game_operations(n, q, strengths, operations): results = [] for operation in operations: if operation[0] == 1: # Type 1 operation: query the total strength of creatures in the i-th cave i = operation[1] results.append(strengths[i - 1]) elif operation[0] == 2: # Type 2 operation: update the strength of creatures in a range of caves l, r, x = operation[1], operation[2], operation[3] for j in range(l - 1, r): strengths[j] += x return results"},{"question":"def second_oldest_books(books): Returns the names of books published in the second oldest year, sorted alphabetically. >>> books1 = [(\\"The Alchemist\\", 1988), (\\"The Great Gatsby\\", 1925), (\\"1984\\", 1949), (\\"Brave New World\\", 1932), (\\"Fahrenheit 451\\", 1953)] >>> second_oldest_books(books1) ['Brave New World'] >>> books2 = [(\\"The Alchemist\\", 1988), (\\"The Great Gatsby\\", 1925), (\\"1984\\", 1949), (\\"Brave New World\\", 1949), (\\"Fahrenheit 451\\", 1953)] >>> second_oldest_books(books2) ['1984', 'Brave New World'] >>> books3 = [(\\"Book1\\", 2000), (\\"Book2\\", 1995), (\\"Book3\\", 2010), (\\"Book4\\", 2005), (\\"Book5\\", 1990)] >>> second_oldest_books(books3) ['Book2'] >>> books4 = [(\\"BookA\\", 2001), (\\"BookB\\", 2001), (\\"BookC\\", 2000), (\\"BookD\\", 1999), (\\"BookE\\", 2000)] >>> second_oldest_books(books4) ['BookC', 'BookE'] >>> books5 = [(\\"BookA\\", 1990), (\\"BookB\\", 1980)] >>> second_oldest_books(books5) ['BookA']","solution":"def second_oldest_books(books): Returns the names of books published in the second oldest year, sorted alphabetically. # Extract all unique years of publication years = sorted(list(set([book[1] for book in books]))) # Find the second oldest year second_oldest_year = years[1] # Collect the names of books published in the second oldest year second_oldest_books = [book[0] for book in books if book[1] == second_oldest_year] # Sort the book names alphabetically second_oldest_books.sort() return second_oldest_books"},{"question":"def product_except_self(nums): Given a list of integers, returns a new list where each element is replaced by the product of all other elements in the list, excluding the element at the current index. Args: nums (list of int): List of integers where all elements are non-zero Returns: list of int: New list where each element is the product of all other elements Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([6, 2, 1, 4]) [8, 24, 48, 12]","solution":"def product_except_self(nums): Given a list of integers, returns a new list where each element is replaced by the product of all other elements in the list, excluding the element at the current index. n = len(nums) output = [1] * n left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n-1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def sort_scrambled_sentences(sentences): Takes a list of scrambled sentences and returns a list of sentences where the words are sorted alphabetically. >>> sort_scrambled_sentences([\\"The quick Brown Fox\\", \\"Jumps over The Lazy Dog\\"]) [\\"Brown Fox The quick\\", \\"Dog Jumps Lazy The over\\"] >>> sort_scrambled_sentences([]) [] >>> sort_scrambled_sentences(None) None >>> sort_scrambled_sentences([\\"Apple\\", \\"Orange\\"]) [\\"Apple\\", \\"Orange\\"] >>> sort_scrambled_sentences([ \\"Hello World\\", \\"Python is Awesome\\", \\"Sorting these is Fun\\" ]) [ \\"Hello World\\", \\"Awesome Python is\\", \\"Fun Sorting is these\\" ] >>> sort_scrambled_sentences([\\"Apple Apple Apple\\", \\"Banana Banana\\"]) [\\"Apple Apple Apple\\", \\"Banana Banana\\"]","solution":"def sort_scrambled_sentences(sentences): if sentences is None or len(sentences) == 0: return sentences sorted_sentences = [] for sentence in sentences: words = sentence.split() words.sort() sorted_sentences.append(' '.join(words)) return sorted_sentences"},{"question":"def find_least_frequent_char(s: str) -> str: Finds the character which appears the least frequently in the string. If multiple characters have the same lowest frequency, returns the one which appears first in the string. >>> find_least_frequent_char('a') 'a' >>> find_least_frequent_char('abcdef') 'a' >>> find_least_frequent_char('aaaa') 'a' >>> find_least_frequent_char('aabbc') 'c' >>> find_least_frequent_char('aabcccd') 'b' >>> find_least_frequent_char('') is None True >>> find_least_frequent_char('aabb ccdd') ' ' >>> find_least_frequent_char('aaaabbccddde') 'e' >>> find_least_frequent_char('aaabbbcccddd') 'a' >>> find_least_frequent_char('abcabcabd') 'd' >>> find_least_frequent_char('a'*1000 + 'b'*1001 + 'cde') 'c'","solution":"def find_least_frequent_char(s): Finds the character which appears the least frequently in the string. If multiple characters have the same lowest frequency, returns the one which appears first in the string. if not s: return None char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 least_frequent_char = None min_frequency = float('inf') for char in s: if char_count[char] < min_frequency: min_frequency = char_count[char] least_frequent_char = char return least_frequent_char"},{"question":"def replace_a(input_string: str) -> str: Replaces every occurrence of the character 'a' with the string '*&'. >>> replace_a(\\"apples are amazing\\") '*&pples *&re *&m*&zing' >>> replace_a(\\"banana\\") 'b*&n*&n*&' >>> replace_a(\\"Algebra\\") 'Algebr*&' >>> replace_a(\\"hello\\") 'hello' >>> replace_a(\\"a\\") '*&' >>> replace_a(\\"aaa\\") '*&*&*&' >>> replace_a(\\"\\") '' >>> replace_a(\\"a@a!a#\\") '*&@*&!*&#'","solution":"def replace_a(input_string): Replaces every occurrence of the character 'a' with the string '*&'. :param input_string: Input string to be processed :return: New string with 'a' replaced by '*&' return input_string.replace('a', '*&')"},{"question":"def find_short(s: str) -> int: Return the length of the shortest word in the given string. >>> find_short(\\"The quick brown fox jumps\\") 3 >>> find_short(\\"Software development is fun\\") 2 >>> find_short(\\"Python is a powerful language\\") 1 >>> find_short(\\"Unit testing is essential in software development\\") 2 >>> find_short(\\"A journey of a thousand miles begins with a single step\\") 1 >>> find_short(\\"one two three four five six\\") 3 >>> find_short(\\"abcd efgh ijkl mnop qrst uvwx\\") 4 >>> find_short(\\"hello\\") 5 >>> find_short(\\"world\\") 5 pass","solution":"def find_short(s): Returns the length of the shortest word in the given string \`s\`. :param s: str - A string containing several words separated by spaces. :return: int - The length of the shortest word. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def monitor_chat_activity(chatLogs: List[str]) -> List[str]: A company's email chat log is represented as a list of strings where each string contains an employee's name, a timestamp (in hours), and the message content. The log is sorted by timestamp in ascending order. However, during peak hours (9 AM to 6 PM), the company wants to track the chat activity frequency by employee name and identify anyone who sends more than 10 messages within an hour time window. Given the list of chat logs, return a list of employee names who exhibit this behavior. You may return the answer in any order. Example 1: >>> monitor_chat_activity([\\"alice,9,Hi\\", \\"alice,9,I need help\\", \\"alice,10,Thanks\\", \\"alice,10,See you\\", \\"bob,9,Yes\\", \\"bob,10,No\\", \\"bob,10,Maybe\\"]) [] Example 2: >>> monitor_chat_activity([\\"alice,9,Hi\\", \\"alice,9,I need help\\", \\"alice,9,Did you see that?\\", \\"alice,9,That's cool\\", \\"bob,9,Yes\\", \\"alice,9,Check this out\\", \\"alice,9,Oh wow\\", \\"alice,9,Really?\\", \\"alice,9,Can you help?\\", \\"alice,9,Thanks\\", \\"alice,9,Okay\\", \\"alice,9,Bye\\"]) ['alice'] Note: - Alice is the only one who sends more than 10 messages between 9 AM and 10 AM. Constraints: - chatLogs.length <= 2000 - Each chatLogs[i] takes the form \\"{name},{timestamp},{message}\\" - Each {name} consists of lowercase English letters, and has a length between 1 and 10. - Each {timestamp} consists of digits, and represents an integer between 0 and 23. - Each {message} is a string of lowercase English letters and spaces, and has a length between 1 and 100. - The log is sorted by timestamp in ascending order.","solution":"def monitor_chat_activity(chatLogs): from collections import defaultdict message_counts = defaultdict(lambda: defaultdict(int)) result = [] # Parse chat logs for log in chatLogs: name, time, _ = log.split(',')[0], int(log.split(',')[1]), log.split(',')[2] message_counts[name][time] += 1 # Check for employees with > 10 messages in an hour for name, counts in message_counts.items(): for time, count in counts.items(): if count > 10: result.append(name) break return result"},{"question":"def max_stable_pairs(n: int, S: str) -> int: Determines the maximum number of stable pairs that can be formed from the sequence of molecules. >>> max_stable_pairs(5, \\"RIRRI\\") 2 >>> max_stable_pairs(6, \\"RRIIII\\") 2 >>> max_stable_pairs(7, \\"RRIIRII\\") 3 >>> max_stable_pairs(5, \\"RRRRR\\") 0 >>> max_stable_pairs(5, \\"IIIII\\") 0 >>> max_stable_pairs(4, \\"RIRI\\") 2 >>> max_stable_pairs(1, \\"R\\") 0 >>> max_stable_pairs(1, \\"I\\") 0 >>> max_stable_pairs(10**5, \\"R\\" * (10**5 // 2) + \\"I\\" * (10**5 // 2)) 50000","solution":"def max_stable_pairs(n, S): Determines the maximum number of stable pairs that can be formed from the sequence. count_R = S.count('R') count_I = S.count('I') return min(count_R, count_I)"},{"question":"def count_overdue_books(test_cases): Count the number of overdue books for each test case. >>> count_overdue_books([[(5, 20), (10, 25), (15, 18), (20, 35)]]) == [2] >>> count_overdue_books([[(1, 15), (10, 25)]]) == [1] pass def process_input(input_text): Convert the raw input text into structured test cases. >>> process_input(\\"1n4n5 20n10 25n15 18n20 35\\") == [[(5, 20), (10, 25), (15, 18), (20, 35)]] >>> process_input(\\"2n2n1 10n5 20n3n10 20n15 30n20 35\\") == [[(1, 10), (5, 20)], [(10, 20), (15, 30), (20, 35)]] pass def test_single_case_all_overdues(): input_data = \\"1n4n5 20n10 25n15 30n20 35\\" test_cases = process_input(input_data) results = count_overdue_books(test_cases) assert results == [4] def test_single_case_mixed(): input_data = \\"1n4n5 20n10 25n15 18n20 35\\" test_cases = process_input(input_data) results = count_overdue_books(test_cases) assert results == [3] def test_multiple_cases(): input_data = \\"2n4n1 10n2 20n3 30n4 40n3n10 20n15 30n20 35\\" test_cases = process_input(input_data) results = count_overdue_books(test_cases) assert results == [3, 2] def test_no_overdue(): input_data = \\"1n3n1 10n2 15n3 14\\" test_cases = process_input(input_data) results = count_overdue_books(test_cases) assert results == [0] def test_all_at_boundary(): input_data = \\"1n2n1 15n10 24\\" test_cases = process_input(input_data) results = count_overdue_books(test_cases) assert results == [0]","solution":"def count_overdue_books(test_cases): results = [] for transactions in test_cases: overdue_count = 0 for B, R in transactions: if R - B > 14: overdue_count += 1 results.append(overdue_count) return results def process_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): M = int(lines[index]) transactions = [] for i in range(M): B, R = map(int, lines[index + 1 + i].split()) transactions.append((B, R)) test_cases.append(transactions) index += M + 1 return test_cases"},{"question":"def missing_positive_integer(nums: List[int]) -> int: Returns the smallest positive integer that is not present in the list. >>> missing_positive_integer([1, 2, 3]) == 4 >>> missing_positive_integer([3, 4, -1, 1]) == 2 >>> missing_positive_integer([7, 8, 9, 11, 12]) == 1 >>> missing_positive_integer([1, 1, 0, -1, -2]) == 2","solution":"def missing_positive_integer(nums): Returns the smallest positive integer that is not present in the list. # Create a set of all positive integers in the list positive_set = set(filter(lambda x: x > 0, nums)) # Start from 1 and find the first missing positive integer smallest_missing = 1 while smallest_missing in positive_set: smallest_missing += 1 return smallest_missing"},{"question":"def construct_binary_string(N: int) -> str: Given a positive integer N, constructs a binary string of length N such that: - The string does not contain consecutive '1's. - The string is lexicographically smallest. Example 1: >>> construct_binary_string(3) \\"010\\" Example 2: >>> construct_binary_string(5) \\"01010\\" Example 3: >>> construct_binary_string(1) \\"0\\" def test_construct_binary_string(): assert construct_binary_string(1) == \\"0\\" assert construct_binary_string(3) == \\"010\\" assert construct_binary_string(5) == \\"01010\\" assert construct_binary_string(2) == \\"01\\" assert construct_binary_string(4) == \\"0101\\" assert construct_binary_string(6) == \\"010101\\" assert construct_binary_string(0) == \\"\\" # Test for larger N assert construct_binary_string(10) == \\"0101010101\\" assert construct_binary_string(7) == \\"0101010\\" # Test for boundary condition assert construct_binary_string(1000) == \\"01\\" * 500","solution":"def construct_binary_string(N): Constructs a binary string of length N such that: - The string does not contain consecutive '1's. - The string is lexicographically smallest. result = [] for i in range(N): if i % 2 == 0: result.append('0') else: result.append('1') return ''.join(result)"},{"question":"def min_transactions(n: int, m: int, transactions: List[Tuple[int, int, int]]) -> int: Find the minimum number of transactions needed to settle all debts among a group of friends. Parameters: - n: an integer, number of friends - m: an integer, number of transactions - transactions: a list of tuples, where each tuple contains three integers (u, v, amount): - u: the friend who paid - v: the friend for whom the payment was made - amount: amount paid in the transaction Returns: - an integer representing the minimum number of transactions needed to settle all debts Examples: >>> min_transactions(3, 3, [(1, 2, 10), (2, 3, 5), (1, 3, 5)]) 2 >>> min_transactions(4, 4, [(1, 2, 10), (2, 3, 5), (3, 4, 5), (4, 1, 10)]) 1","solution":"def min_transactions(n, m, transactions): balances = [0] * n for u, v, amount in transactions: balances[u-1] -= amount balances[v-1] += amount debts = [balance for balance in balances if balance != 0] def settle(debts, start): while start < len(debts) and debts[start] == 0: start += 1 if start == len(debts): return 0 min_trans = float('inf') for i in range(start + 1, len(debts)): if debts[start] * debts[i] < 0: debts[i] += debts[start] min_trans = min(min_trans, 1 + settle(debts, start + 1)) debts[i] -= debts[start] return min_trans return settle(debts, 0)"},{"question":"def can_split_array(arr): Determines if the array can be split into two non-empty parts with equal sum. Parameters: arr (list): A list of non-negative integers. Returns: str: \\"YES\\" if the array can be split into two parts with equal sum, otherwise \\"NO\\". from solution import can_split_array def test_example_case(): assert can_split_array([1, 2, 3, 4, 5, 5]) == \\"YES\\" def test_no_split_possible(): assert can_split_array([1, 2, 3, 4, 5]) == \\"NO\\" def test_split_with_all_zeros(): assert can_split_array([0, 0, 0, 0]) == \\"YES\\" def test_split_with_large_numbers(): assert can_split_array([10000, 10000, 10000, 10000]) == \\"YES\\" def test_no_split_with_odd_sum(): assert can_split_array([1, 1, 1]) == \\"NO\\" def test_split_with_last_possible_point(): assert can_split_array([10, 5, 5]) == \\"YES\\" def test_smallest_possible_split(): assert can_split_array([1, 1]) == \\"YES\\" def test_large_array(): large_array = [5000] * 10000 assert can_split_array(large_array) == \\"YES\\" def test_large_non_splittable_array(): large_array = [9999] * 10001 assert can_split_array(large_array) == \\"NO\\"","solution":"def can_split_array(arr): Determines if the array can be split into two non-empty parts with equal sum. Parameters: arr (list): A list of non-negative integers. Returns: str: \\"YES\\" if the array can be split into two parts with equal sum, otherwise \\"NO\\". total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 current_sum = 0 for i in range(len(arr) - 1): current_sum += arr[i] if current_sum == target: return \\"YES\\" return \\"NO\\""},{"question":"def shortest_substring_with_k_distinct_characters(k: int, s: str) -> int: Returns the length of the shortest substring of s that contains at least k distinct characters. If no such substring exists, returns -1. >>> shortest_substring_with_k_distinct_characters(2, 'abcde') == 2 >>> shortest_substring_with_k_distinct_characters(3, 'abc') == 3 >>> shortest_substring_with_k_distinct_characters(4, 'abc') == -1 >>> shortest_substring_with_k_distinct_characters(1, 'a') == 1 >>> shortest_substring_with_k_distinct_characters(2, 'aabbcc') == 2 pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases for the shortest_substring_with_k_distinct_characters function. >>> T = 2 >>> test_cases = [(2, 'abcde'), (3, 'abc')] >>> process_test_cases(T, test_cases) == [2, 3] >>> T = 3 >>> test_cases = [(1, 'a'), (2, 'ab'), (3, 'abcabc')] >>> process_test_cases(T, test_cases) == [1, 2, 3] pass","solution":"def shortest_substring_with_k_distinct_characters(k, s): Returns the length of the shortest substring of s that contains at least k distinct characters. If no such substring exists, returns -1. n = len(s) if k > len(set(s)): return -1 min_len = float('inf') for i in range(n): char_count = {} for j in range(i, n): char_count[s[j]] = char_count.get(s[j], 0) + 1 if len(char_count) >= k: min_len = min(min_len, j - i + 1) break return min_len if min_len != float('inf') else -1 def process_test_cases(T, test_cases): results = [] for k, s in test_cases: results.append(shortest_substring_with_k_distinct_characters(k, s)) return results"},{"question":"from typing import List, Dict def group_integers_by_digit_count(numbers: List[int]) -> Dict[int, List[int]]: Groups integers by their digit count and sorts the integers within each group. Args: numbers (list of int): List of integers to be grouped. Returns: dict: A dictionary where the keys are digit counts and the values are lists of integers with that digit count. >>> group_integers_by_digit_count([1, 23, 456, -789, 1000, -55, 12]) {1: [1], 2: [-55, 12, 23], 3: [-789, 456], 4: [1000]} >>> group_integers_by_digit_count([5, 3, 9, -1, -2]) {1: [-2, -1, 3, 5, 9]} >>> group_integers_by_digit_count([7, -22, 333, -4444]) {1: [7], 2: [-22], 3: [333], 4: [-4444]} >>> group_integers_by_digit_count([0, 10, -100, 1000]) {1: [0], 2: [10], 3: [-100], 4: [1000]} >>> group_integers_by_digit_count([123456, -1234567, 12345678, -123456789]) {6: [123456], 7: [-1234567], 8: [12345678], 9: [-123456789]} >>> group_integers_by_digit_count([-12, 12, -34, 34]) {2: [-34, -12, 12, 34]}","solution":"def group_integers_by_digit_count(numbers): Groups integers by their digit count and sorts the integers within each group. Args: numbers (list of int): List of integers to be grouped. Returns: dict: A dictionary where the keys are digit counts and the values are lists of integers with that digit count. from collections import defaultdict digit_groups = defaultdict(list) for num in numbers: digit_count = len(str(abs(num))) digit_groups[digit_count].append(num) for key in digit_groups: digit_groups[key].sort() return dict(sorted(digit_groups.items()))"},{"question":"def count_covered_cells(N: int, K: int, drone_positions: list) -> int: Calculate the number of cells that are covered by at least one drone. >>> count_covered_cells(5, 2, [(1, 1)]) 4 >>> count_covered_cells(5, 2, [(1, 1), (4, 4)]) 8 >>> count_covered_cells(5, 2, [(1, 1), (2, 2)]) 7 >>> count_covered_cells(2, 2, [(1, 1)]) 4 >>> count_covered_cells(5, 5, [(1, 1)]) 25 >>> count_covered_cells(5, 2, [(5, 5)]) 1 >>> count_covered_cells(5, 2, []) 0","solution":"def count_covered_cells(N: int, K: int, drone_positions: list) -> int: covered_cells = set() for r, c in drone_positions: for i in range(K): for j in range(K): if 1 <= r + i <= N and 1 <= c + j <= N: covered_cells.add((r + i, c + j)) return len(covered_cells)"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if a string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if the number of characters with odd counts is zero or one. >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"aabcd\\") False","solution":"def can_form_palindrome(s): Determine if a string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if the number of characters with odd counts is zero or one. Args: s (str): Input string Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def find_unsorted_subarray(arr: List[int]) -> int: Given an integer array \`arr\`, find the length of the shortest subarray that, if sorted, would result in the entire array being sorted. If the array is already sorted, return 0. Examples: >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_unsorted_subarray([1, 2, 3, 4]) 0 >>> find_unsorted_subarray([1, 3, 2, 2, 2]) 4 >>> find_unsorted_subarray([2, 1]) 2","solution":"def find_unsorted_subarray(arr): Finds the length of the shortest subarray that, if sorted, would result in the entire array being sorted. If the array is already sorted, returns 0. :param arr: List[int] - The input array of integers :return: int - Length of the shortest subarray to be sorted if not arr or len(arr) <= 1: return 0 n = len(arr) start, end = 0, -1 min_seen, max_seen = float('inf'), float('-inf') for i in range(n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n - 1, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i return 0 if end == -1 else end - start + 1"},{"question":"def findGCD(a: int, b: int) -> int: Calculates the greatest common divisor (GCD) of two non-negative integers a and b using the Euclidean algorithm. If both numbers are zero, the function returns 0. >>> findGCD(48, 18) # should return 6 >>> findGCD(56, 98) # should return 14 >>> findGCD(0, 0) # should return 0 >>> findGCD(20, 0) # should return 20 >>> findGCD(0, 100) # should return 100 >>> findGCD(24, 36) # should return 12 # Your code here","solution":"def findGCD(a, b): Returns the greatest common divisor (GCD) of two non-negative integers a and b using the Euclidean algorithm. if a == 0 and b == 0: return 0 while b != 0: a, b = b, a % b return a"},{"question":"def check_subarray_validity(b: List[int], n: int, d: int, queries: List[Tuple[int, int]]) -> List[str]: Determines if the specified subarray is valid according to given criteria. Parameters: b (List[int]): The list of unique integers. n (int): The number of integers in the sequence. d (int): The required difference. queries (List[Tuple[int, int]]): A list of queries, each containing two integers l and r. Returns: List[str]: A list of results (\\"Valid\\" or \\"Invalid\\") for each query. Example Usage: >>> check_subarray_validity([1, 3, 5, 7, 9], 5, 2, [(1, 3), (2, 5)]) ['Valid', 'Valid']","solution":"def check_subarray_validity(b, n, d, queries): def is_valid_subarray(b, l, r, d): for i in range(l, r): if b[i+1] - b[i] != d: return False return True result = [] for l, r in queries: if is_valid_subarray(b, l-1, r-1, d): result.append(\\"Valid\\") else: result.append(\\"Invalid\\") return result # Example Usage: # n, k = 5, 2 # b = [1, 3, 5, 7, 9] # d = 2 # queries = [(1, 3), (2, 5)] # print(check_subarray_validity(b, n, d, queries))"},{"question":"def firstNonRepeatingCharacter(s: str) -> str: Implement a function that takes a string consisting of lowercase letters and returns the first non-repeating character in it. If all characters are repeating, return an empty string. Note: The input string will contain only lowercase letters. >>> firstNonRepeatingCharacter(\\"swiss\\") \\"w\\" >>> firstNonRepeatingCharacter(\\"programming\\") \\"p\\" >>> firstNonRepeatingCharacter(\\"aabbcc\\") \\"\\" from collections import Counter def test_first_non_repeating_character(): assert firstNonRepeatingCharacter(\\"swiss\\") == \\"w\\" assert firstNonRepeatingCharacter(\\"programming\\") == \\"p\\" assert firstNonRepeatingCharacter(\\"aabbcc\\") == \\"\\" assert firstNonRepeatingCharacter(\\"xxyz\\") == \\"y\\" assert firstNonRepeatingCharacter(\\"aabbc\\") == \\"c\\" assert firstNonRepeatingCharacter(\\"abcd\\") == \\"a\\" assert firstNonRepeatingCharacter(\\"aabbccddeffg\\") == \\"e\\" def test_single_character(): assert firstNonRepeatingCharacter(\\"a\\") == \\"a\\" def test_repeating_characters(): assert firstNonRepeatingCharacter(\\"aabbccddeeff\\") == \\"\\" def test_last_character_non_repeating(): assert firstNonRepeatingCharacter(\\"aabbccddeeffg\\") == \\"g\\"","solution":"def firstNonRepeatingCharacter(s): Returns the first non-repeating character in a string. If all characters are repeating, returns an empty string. from collections import Counter # Create a counter for all characters in the string char_count = Counter(s) # Iterate through the string to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character found, return an empty string return \\"\\""},{"question":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses to be added to make the input string s valid. >>> min_add_to_make_valid(\\"())\\") 1 >>> min_add_to_make_valid(\\"(((\\") 3 >>> min_add_to_make_valid(\\"()\\") 0 >>> min_add_to_make_valid(\\"()))((\\") 4","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses to be added to make the input string s valid. left_balance = 0 right_balance = 0 for char in s: if char == '(': right_balance += 1 elif char == ')': if right_balance > 0: right_balance -= 1 else: left_balance += 1 return left_balance + right_balance"},{"question":"class Forest: def __init__(self, heights): self.heights = heights def add_height(self, L, R, K): Add K meters to each tree between positions L and R inclusive. pass def set_height(self, P, K): Set the height of the tree at position P to K meters. pass def query_height(self, P): Output the height of the tree at position P. pass def process_operations(N, initial_heights, operations): Process the list of operations and return the results for all queries. >>> process_operations(5, [1, 2, 3, 4, 5], [[1, 2, 4, 2], [3, 3], [2, 3, 10], [3, 3], [3, 5]]) [5, 10, 5] pass def test_process_operations(): N = 5 initial_heights = [1, 2, 3, 4, 5] operations = [ [1, 2, 4, 2], [3, 3], [2, 3, 10], [3, 3], [3, 5] ] expected_output = [5, 10, 5] assert process_operations(N, initial_heights, operations) == expected_output def test_add_height(): forest = Forest([1, 2, 3, 4, 5]) forest.add_height(2, 4, 2) assert forest.heights == [1, 4, 5, 6, 5] def test_set_height(): forest = Forest([1, 2, 3, 4, 5]) forest.set_height(3, 10) assert forest.heights == [1, 2, 10, 4, 5] def test_query_height(): forest = Forest([1, 2, 3, 4, 5]) assert forest.query_height(3) == 3 forest.set_height(3, 10) assert forest.query_height(3) == 10","solution":"class Forest: def __init__(self, heights): self.heights = heights def add_height(self, L, R, K): for i in range(L-1, R): self.heights[i] += K def set_height(self, P, K): self.heights[P-1] = K def query_height(self, P): return self.heights[P-1] def process_operations(N, initial_heights, operations): forest = Forest(initial_heights) result = [] for operation in operations: if operation[0] == 1: _, L, R, K = operation forest.add_height(L, R, K) elif operation[0] == 2: _, P, K = operation forest.set_height(P, K) elif operation[0] == 3: _, P = operation result.append(forest.query_height(P)) return result"},{"question":"def summarize_ranges(number_sequence: str) -> str: Summarizes ranges in the given number sequence. Args: number_sequence (str): A string containing numbers and commas, representing a sequence of integers. Returns: str: A string where ranges of three or more consecutive numbers are replaced by their range format. pass # Test Cases def test_summarize_ranges_all_ranges(): assert summarize_ranges(\\"1,2,3,4,5,6,7,8,9,10\\") == \\"1-10\\" def test_summarize_ranges_mixed_input(): assert summarize_ranges(\\"1,2,3,5,6,7,8,10,12,13,14,15\\") == \\"1-3,5-8,10,12-15\\" def test_summarize_ranges_no_ranges(): assert summarize_ranges(\\"1,3,5,7,9\\") == \\"1,3,5,7,9\\" def test_summarize_ranges_single_element(): assert summarize_ranges(\\"10\\") == \\"10\\" def test_summarize_ranges_multiple_single_elements(): assert summarize_ranges(\\"3,6,9,12,15\\") == \\"3,6,9,12,15\\" def test_summarize_ranges_two_consecutive_elements(): assert summarize_ranges(\\"3,4,10,11,12,15,20,21,22,23\\") == \\"3,4,10-12,15,20-23\\"","solution":"def summarize_ranges(number_sequence): Summarizes ranges in the given number sequence. Args: number_sequence (str): A string containing numbers and commas, representing a sequence of integers. Returns: str: A string where ranges of three or more consecutive numbers are replaced by their range format. numbers = [int(n) for n in number_sequence.split(\\",\\")] result = [] i = 0 while i < len(numbers): start = i while i + 1 < len(numbers) and numbers[i + 1] == numbers[i] + 1: i += 1 if i - start >= 2: result.append(f\\"{numbers[start]}-{numbers[i]}\\") else: result.extend(str(numbers[j]) for j in range(start, i + 1)) i += 1 return \\",\\".join(result)"},{"question":"def longest_subsequence_same_start_end_digit(nums): Given an integer array \`nums\`, return the length of the longest subsequence that starts and ends with the same digit. >>> longest_subsequence_same_start_end_digit([1, 2, 3, 4, 5, 6, 7, 8, 9, 1]) 10 >>> longest_subsequence_same_start_end_digit([1, 2, 3, 1, 4, 5, 6, 1, 2]) 8 >>> longest_subsequence_same_start_end_digit([8, 1, 8, 2, 8, 3, 8, 4, 8]) 9 >>> longest_subsequence_same_start_end_digit([2, 3, 4, 5, 6, 6, 5, 4, 3, 2]) 10","solution":"def longest_subsequence_same_start_end_digit(nums): Returns the length of the longest subsequence starting and ending with the same digit. if not nums: return 0 max_length = 0 first_occurrence = {} for index, num in enumerate(nums): if num not in first_occurrence: first_occurrence[num] = index start_index = first_occurrence[num] subsequence_length = index - start_index + 1 if subsequence_length > max_length: max_length = subsequence_length return max_length"},{"question":"class ListNode: def __init__(self, val: int = 0, next: 'ListNode' = None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: Check if the linked list forms a palindrome. >>> create_linked_list([1, 2, 2, 1]) True >>> create_linked_list([1, 2, 3, 4, 2, 1]) False >>> create_linked_list([1]) True >>> create_linked_list([1, 2, 1, 2, 1]) True def create_linked_list(elements): head = ListNode(elements[0]) current = head for value in elements[1:]: current.next = ListNode(value) current = current.next return head","solution":"class ListNode: def __init__(self, val: int = 0, next: 'ListNode' = None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True # Find the middle of the linked list using the slow and fast pointer approach slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Compare the first half and the reversed second half left, right = head, prev while right: if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"def manage_follows(M: int, K: int, initial_follows: List[int], N: int, actions: List[int]) -> List[int]: Manage the list of people Arjun follows by executing a series of follow/unfollow actions. ---Input--- M: The number of people Arjun initially follows. K: The maximum number of people Arjun can follow at a time. initial_follows: A list of positive integers representing the IDs of people Arjun follows initially. N: The number of follow/unfollow actions. actions: A list of integers where a positive integer means follow a new person and a negative integer means unfollow a person. ---Output--- A list representing the IDs of people Arjun follows after executing all actions. ---Examples--- >>> manage_follows(5, 3, [1, 2, 3, 4, 5], 6, [6, 7, -3, 8, -2, 9]) [6, 7, 8, 9] >>> manage_follows(3, 3, [1, 2, 3], 3, [-4, -5, 4]) [2, 3, 4] >>> manage_follows(0, 3, [], 3, [1, 2, 3]) [1, 2, 3] >>> manage_follows(2, 2, [1, 2], 3, [3, 4, 5]) [4, 5] >>> manage_follows(4, 3, [1, 2, 3, 4], 4, [-2, -3, 5, 6]) [4, 5, 6] >>> manage_follows(3, 3, [1, 2, 3], 5, [4, -2, 5, -3, 6]) [4, 5, 6]","solution":"from collections import deque def manage_follows(M, K, initial_follows, N, actions): follows = deque(initial_follows) for action in actions: if action > 0: if action not in follows: follows.append(action) if len(follows) > K: follows.popleft() elif action < 0: if -action in follows: follows.remove(-action) return list(follows)"},{"question":"def check_codes(test_cases): Check if each numeric code can be formed using the available digits without repetition. >>> check_codes([('123456', '123'), ('987654', '123'), ('123456', '4567')]) ['YES', 'NO', 'NO'] >>> check_codes([('123', '4'), ('567', '89'), ('1234', '567')]) ['NO', 'NO', 'NO']","solution":"def check_codes(test_cases): results = [] for D, C in test_cases: if all(digit in D for digit in C) and len(set(C)) == len(C): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def isPathExist(grid: List[List[str]]) -> bool: Determine if there's a path from the top-left corner (0, 0) to the bottom-right corner (M-1, N-1) of the grid. >>> isPathExist([['.', 'X', '.'], ['.', '.', 'X'], ['X', '.', '.']]) True >>> isPathExist([['.', 'X', 'X'], ['X', '.', 'X'], ['X', 'X', '.']]) False >>> isPathExist([['.', '.', '.'], ['.', 'X', '.'], ['.', 'X', '.']]) True >>> isPathExist([['.']]) True >>> isPathExist([['X']]) False >>> isPathExist([['X', '.', '.'], ['.', 'X', '.'], ['.', 'X', '.']]) False >>> isPathExist([['.', '.', '.'], ['.', 'X', '.'], ['.', 'X', 'X']]) False >>> isPathExist([['.', '.', '.', 'X', '.'], ['X', 'X', '.', 'X', '.'], ['.', '.', '.', 'X', '.'], ['X', 'X', '.', '.', '.'], ['.', '.', 'X', 'X', '.']]) True","solution":"def isPathExist(grid): if not grid or grid[0][0] == 'X' or grid[-1][-1] == 'X': return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up visited = [[False] * cols for _ in range(rows)] def dfs(x, y): if x == rows - 1 and y == cols - 1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == '.': if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def find_understaffed_shift(shift_assignments): Given an array of strings representing workers' shift assignments, determine if there's any shift that needs more workers to balance the shifts equally. Args: shift_assignments (list of str): List of shift assignments. Returns: str: \\"Already Balanced\\" if all shifts are equally balanced, or the shift that needs more workers in lowercase otherwise. >>> find_understaffed_shift([\\"morning\\", \\"afternoon\\", \\"night\\"]) == \\"Already Balanced\\" >>> find_understaffed_shift([\\"morning\\", \\"morning\\", \\"afternoon\\", \\"afternoon\\", \\"night\\", \\"night\\"]) == \\"Already Balanced\\" >>> find_understaffed_shift([\\"morning\\", \\"afternoon\\", \\"afternoon\\", \\"night\\", \\"night\\"]) == \\"morning\\" >>> find_understaffed_shift([\\"morning\\", \\"morning\\", \\"afternoon\\", \\"night\\", \\"night\\"]) == \\"afternoon\\" >>> find_understaffed_shift([\\"morning\\", \\"morning\\", \\"afternoon\\", \\"afternoon\\", \\"night\\"]) == \\"night\\" >>> result = find_understaffed_shift([\\"morning\\", \\"afternoon\\"]) >>> result in [\\"morning\\", \\"afternoon\\", \\"night\\"] >>> find_understaffed_shift([]) == \\"Already Balanced\\"","solution":"def find_understaffed_shift(shift_assignments): Given an array of strings representing workers' shift assignments, determine if there's any shift that needs more workers to balance the shifts equally. Args: shift_assignments (list of str): List of shift assignments. Returns: str: \\"Already Balanced\\" if all shifts are equally balanced, or the shift that needs more workers in lowercase otherwise. from collections import Counter # Count the occurrences of each shift shift_counter = Counter(shift_assignments) # All possible shifts shifts = [\\"morning\\", \\"afternoon\\", \\"night\\"] # Create a counter for shifts with defaults of 0 to ensure all shifts are counted shift_counts = {shift: shift_counter.get(shift, 0) for shift in shifts} # Find the maximum shift count max_count = max(shift_counts.values()) # Check if all shifts are already balanced if all(count == max_count for count in shift_counts.values()): return \\"Already Balanced\\" # Find the shifts that need more workers for shift in shifts: if shift_counts[shift] < max_count: return shift"},{"question":"from typing import List def find_common_elements(arr1: List[int], arr2: List[int]) -> List[int]: Returns a new array containing the common elements of arr1 and arr2. Each element in the result should appear as many times as it shows in both arrays. The order of the elements in the result should be determined by their appearance in arr1. pass # Unit Test def test_common_elements_case1(): arr1 = [1, 2, 2, 3, 4, 5] arr2 = [2, 2, 3, 6] assert find_common_elements(arr1, arr2) == [2, 2, 3] def test_common_elements_case2(): arr1 = [4, 4, 4, 4] arr2 = [4, 4] assert find_common_elements(arr1, arr2) == [4, 4] def test_common_elements_case3(): arr1 = [1, 2, 3, 4] arr2 = [5, 6, 7, 8] assert find_common_elements(arr1, arr2) == [] def test_common_elements_case4(): arr1 = [1, 2, 2, 3, 4, 5, 5, 5] arr2 = [5, 5, 2, 2, 3, 1, 1] assert find_common_elements(arr1, arr2) == [1, 2, 2, 3, 5, 5] def test_common_elements_case5(): arr1 = [1] arr2 = [1] assert find_common_elements(arr1, arr2) == [1] def test_common_elements_case6(): arr1 = [5]*100000 arr2 = [5]*100000 assert find_common_elements(arr1, arr2) == [5]*100000","solution":"from typing import List from collections import Counter def find_common_elements(arr1: List[int], arr2: List[int]) -> List[int]: Returns the common elements in arr1 and arr2 with the frequency determined by their appearance in both arrays. The order in the result is based on arr1. # Create count dictionaries for both arrays count1 = Counter(arr1) count2 = Counter(arr2) # Find the intersection of elements common_elements = [] for element in arr1: if element in count2 and count1[element] > 0 and count2[element] > 0: common_count = min(count1[element], count2[element]) common_elements.extend([element] * common_count) # Reduce the count in both counters count1[element] -= common_count count2[element] -= common_count return common_elements"},{"question":"def count_balanced_binary_substrings(s: str) -> int: Returns the number of balanced binary substrings in the binary string s. >>> count_balanced_binary_substrings(\\"00110011\\") == 6 >>> count_balanced_binary_substrings(\\"\\") == 0 >>> count_balanced_binary_substrings(\\"0\\") == 0 >>> count_balanced_binary_substrings(\\"1\\") == 0 >>> count_balanced_binary_substrings(\\"010101\\") == 5 >>> count_balanced_binary_substrings(\\"0000\\") == 0 >>> count_balanced_binary_substrings(\\"1111\\") == 0 >>> count_balanced_binary_substrings(\\"00110\\") == 3 >>> count_balanced_binary_substrings(\\"01\\") == 1 >>> count_balanced_binary_substrings(\\"10\\") == 1","solution":"def count_balanced_binary_substrings(s): Returns the number of balanced binary substrings in the binary string s. count = 0 prev_run_length = 0 curr_run_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: curr_run_length += 1 else: count += min(prev_run_length, curr_run_length) prev_run_length = curr_run_length curr_run_length = 1 count += min(prev_run_length, curr_run_length) return count"},{"question":"def capitalize_each_word(sentence: str) -> str: Capitalizes the first letter of each word in the given sentence. >>> capitalize_each_word(\\"hello world\\") \\"Hello World\\" >>> capitalize_each_word(\\"this is a test\\") \\"This Is A Test\\" >>> capitalize_each_word(\\"capitalize each word\\") \\"Capitalize Each Word\\"","solution":"def capitalize_each_word(sentence): Capitalizes the first letter of each word in the given sentence. Args: sentence (str): The sentence to capitalize. Returns: str: The sentence with the first letter of each word capitalized. return ' '.join(word.capitalize() for word in sentence.split())"},{"question":"def matrix_transpose(A): Returns the transpose of the given matrix A. Parameters: - A: a 2D list (list of lists) representing the matrix Returns: - The transpose of the input matrix as a 2D list >>> matrix_transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> matrix_transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> matrix_transpose([[1]]) [[1]] >>> matrix_transpose([]) [] >>> matrix_transpose([[1, 2], [3, 4]]) [[1, 3], [2, 4]]","solution":"def matrix_transpose(A): Returns the transpose of the given matrix A. Parameters: - A: a 2D list (list of lists) representing the matrix Returns: - The transpose of the input matrix as a 2D list if not A: return [] return [[A[j][i] for j in range(len(A))] for i in range(len(A[0]))]"},{"question":"from typing import List def longest_common_prefix(strings: List[str]) -> str: Returns the longest common prefix for a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\", \\"bus\\"]) == \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" >>> longest_common_prefix([\\"throne\\", \\"thro\\", \\"thr\\"]) == \\"thr\\" >>> longest_common_prefix([\\"throne\\", \\"dungeon\\"]) == \\"\\" >>> longest_common_prefix([\\"apple\\", \\"ape\\", \\"apricot\\"]) == \\"ap\\" >>> longest_common_prefix([\\"a\\"]) == \\"a\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"blue\\", \\"blue\\"]) == \\"blue\\" pass def process_input(T: int, test_cases: List[tuple]) -> List[str]: Processes the list of test cases and returns the longest common prefix for each test case. >>> process_input(2, [(3, [\\"flower\\", \\"flow\\", \\"flight\\"]), (4, [\\"dog\\", \\"racecar\\", \\"car\\", \\"bus\\"])]) == [\\"fl\\", \\"\\"] >>> process_input(1, [(3, [\\"blue\\", \\"blue\\", \\"blue\\"])]) == [\\"blue\\"] >>> process_input(1, [(1, [\\"python\\"])]) == [\\"python\\"] >>> process_input(3, [(2, [\\"website\\", \\"web\\"]), (2, [\\"internet\\", \\"intern\\"]), (2, [\\"code\\", \\"coding\\"])]) == [\\"web\\", \\"intern\\", \\"cod\\"] >>> process_input(1, [(0, [])]) == [\\"\\"] pass","solution":"def longest_common_prefix(strings): Returns the longest common prefix for a list of strings. if not strings: return \\"\\" # find the minimum length string from the list min_length = len(min(strings, key=len)) common_prefix = \\"\\" for i in range(min_length): # get the current character from the first string current_char = strings[0][i] # check if this character is the same in all strings for string in strings: if string[i] != current_char: return common_prefix # if all strings have the same character at this position, add it to prefix common_prefix += current_char return common_prefix def process_input(T, test_cases): Processes the list of test cases and returns the longest common prefix for each test case. results = [] for i in range(T): N, strings = test_cases[i] results.append(longest_common_prefix(strings)) return results"},{"question":"def sort_and_move_zeros(arr: list) -> list: Given an array of integers, returns the array sorted in ascending order but with the additional constraint that all zeros must be placed at the end of the array, while maintaining the order of the non-zero elements. >>> sort_and_move_zeros([4, 0, 1, 0, 3, 12]) # [4, 1, 3, 12, 0, 0] >>> sort_and_move_zeros([0, 1, 0, 3, 0, 4]) # [1, 3, 4, 0, 0, 0]","solution":"def sort_and_move_zeros(arr): Returns the array sorted in ascending order with all zeros placed at the end while maintaining the order of the non-zero elements. non_zero_elements = [x for x in arr if x != 0] zero_count = arr.count(0) return non_zero_elements + [0] * zero_count"},{"question":"def longestPalindromeSubstring(s: str) -> str: Returns the longest palindromic substring in the input string s. If there are multiple longest palindromic substrings with the same length, returns the first one found. >>> longestPalindromeSubstring(\\"racecar\\") 'racecar' >>> longestPalindromeSubstring(\\"babad\\") 'bab' >>> longestPalindromeSubstring(\\"abcbabc\\") 'bcb'","solution":"def longestPalindromeSubstring(s: str) -> str: Returns the longest palindromic substring in the input string s. If there are multiple longest palindromic substrings with the same length, returns the first one found. if len(s) == 1: return s start, max_len = 0, 1 for i in range(1, len(s)): # Odd length palindromes low, high = i - 1, i + 1 while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 # Even length palindromes low, high = i - 1, i while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 return s[start:start + max_len]"},{"question":"def max_subarray_sum(arr, k): Returns the maximum sum of a subarray with length exactly 'k'. Parameters: arr (list): List of integers. k (int): Length of the subarray. Returns: int: Maximum sum of subarray with length 'k'. Examples: >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) 9 >>> max_subarray_sum([2, 3, 4, 1, 5], 2) 7 pass","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of a subarray with length exactly 'k'. Parameters: arr (list): List of integers. k (int): Length of the subarray. Returns: int: Maximum sum of subarray with length 'k'. if len(arr) < k: return 0 # Initial sum of the first 'k' elements max_sum = current_sum = sum(arr[:k]) # Sliding window approach to find maximum sum subarray of length 'k' for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"import math def total_euclidean_distance(n: int, commands: str) -> float: Calculate total Euclidean distance traveled by RoboRover after executing all commands. Parameters: n (int): number of commands commands (str): sequence of commands Returns: float: total Euclidean distance traveled, rounded to 2 decimal places. >>> total_euclidean_distance(5, 'UUDDL') 5.00 >>> total_euclidean_distance(1, 'U') 1.00 >>> total_euclidean_distance(6, 'UDLRLR') 6.00","solution":"import math def total_euclidean_distance(n, commands): Calculate total Euclidean distance traveled by RoboRover after executing all commands. :param n: int, number of commands :param commands: str, sequence of commands :return: float, total Euclidean distance traveled, rounded to 2 decimal places x, y = 0, 0 total_distance = 0.0 for command in commands: prev_x, prev_y = x, y if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # Calculate the Euclidean distance for the move total_distance += math.sqrt((x - prev_x) ** 2 + (y - prev_y) ** 2) return round(total_distance, 2)"},{"question":"def optimal_photography_period(sunrise: int, sunset: int, duration: int): Determines the start and end time of the optimal photography period between sunrise and sunset, given the desired duration. Args: sunrise (int): The time of sunrise in seconds since midnight. sunset (int): The time of sunset in seconds since midnight. duration (int): The desired duration of the optimal photography period in seconds. Returns: tuple: A tuple containing the start time and end time of the optimal photography period. str: A message if it's not possible to fit the desired duration between sunrise and sunset. >>> optimal_photography_period(21600, 64800, 3600) (21600, 25200) >>> optimal_photography_period(21600, 64800, 43200) (21600, 64800) >>> optimal_photography_period(21600, 32400, 14400) \\"It's not possible to fit the desired duration between sunrise and sunset.\\" >>> optimal_photography_period(21600, 21600, 3600) \\"It's not possible to fit the desired duration between sunrise and sunset.\\" >>> optimal_photography_period(21600, 64800, 0) (21600, 21600)","solution":"def optimal_photography_period(sunrise, sunset, duration): Determines the start and end time of the optimal photography period between sunrise and sunset, given the desired duration. Args: sunrise (int): The time of sunrise in seconds since midnight. sunset (int): The time of sunset in seconds since midnight. duration (int): The desired duration of the optimal photography period in seconds. Returns: tuple: A tuple containing the start time and end time of the optimal photography period. str: A message if it's not possible to fit the desired duration between sunrise and sunset. if sunset - sunrise >= duration: return (sunrise, sunrise + duration) else: return \\"It's not possible to fit the desired duration between sunrise and sunset.\\""},{"question":"def isPalindrome(s: str) -> bool: Returns True if the input string s is a palindrome, ignoring case and non-alphanumeric characters. >>> isPalindrome(\\"A man, a plan, a canal: Panama\\") True >>> isPalindrome(\\"race a car\\") False >>> isPalindrome(\\"\\") True >>> isPalindrome(\\"a\\") True >>> isPalindrome(\\"12321\\") True >>> isPalindrome(\\"123456\\") False >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"Hello, World!\\") False","solution":"def isPalindrome(s): Returns True if the input string s is a palindrome, ignoring case and non-alphanumeric characters. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if cleaned_s reads the same forward and backward return cleaned_s == cleaned_s[::-1]"},{"question":"def sum_and_product(arr): Returns the sum of the positive integers and the product of the negative integers in the array, separated by a single comma. If there are no positive integers, return 'None' for the sum. If there are no negative integers, return 'None' for the product. If the array is empty, return 'None,None'. >>> sum_and_product([1, 2, -1, -2]) == \\"3,2\\" >>> sum_and_product([-1, -2, 1, 3, 5]) == \\"9,2\\" >>> sum_and_product([-1, -2, -3]) == \\"None,-6\\" >>> sum_and_product([1, 2, 3]) == \\"6,None\\" >>> sum_and_product([0, 0, 0]) == \\"None,None\\" >>> sum_and_product([]) == \\"None,None\\" >>> sum_and_product([5]) == \\"5,None\\" >>> sum_and_product([-5]) == \\"None,-5\\" >>> sum_and_product([-1, 0, -2]) == \\"None,2\\"","solution":"def sum_and_product(arr): Returns the sum of the positive integers and the product of the negative integers in the array, separated by a single comma. If there are no positive integers, return 'None' for the sum. If there are no negative integers, return 'None' for the product. If the array is empty, return 'None,None'. if not arr: return \\"None,None\\" pos_sum = sum(x for x in arr if x > 0) neg_product = None for x in arr: if x < 0: if neg_product is None: neg_product = x else: neg_product *= x pos_sum = pos_sum if pos_sum > 0 else 'None' neg_product = neg_product if neg_product is not None else 'None' return f\\"{pos_sum},{neg_product}\\""},{"question":"def word_frequency(input_string: str) -> dict: Calculate the frequency of each distinct word in the given input string. Words are considered case-insensitive and punctuation is ignored. >>> word_frequency(\\"Hello, world! HELLO.\\") == {'hello': 2, 'world': 1} >>> word_frequency(\\"It's a test, a simple TEST.\\") == {'its': 1, 'a': 2, 'test': 2, 'simple': 1} >>> word_frequency(\\"\\") == {} >>> word_frequency(\\"hello\\") == {'hello': 1} >>> word_frequency(\\"hello!!!\\") == {'hello': 1} >>> word_frequency(\\"hello world\\") == {'hello': 1, 'world': 1} >>> word_frequency(\\"hello 1 world 1\\") == {'hello': 1, '1': 2, 'world': 1} >>> word_frequency(\\"!!!\\") == {} >>> word_frequency(\\"123 hello 456\\") == {'123': 1, 'hello': 1, '456': 1} >>> word_frequency(\\"hello @world\\") == {'hello': 1, 'world': 1}","solution":"import re from collections import defaultdict def word_frequency(input_string: str) -> dict: Calculate the frequency of each distinct word in the given input string. Words are considered case-insensitive and punctuation is ignored. # Convert to lowercase input_string = input_string.lower() # Remove punctuation using regex input_string = re.sub(r'[^ws]', '', input_string) # Split the string into words words = input_string.split() # Create a default dictionary to count word frequencies word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def maximalRectangle(matrix: List[List[str]]) -> int: Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Examples: >>> maximalRectangle([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ... ]) 6 >>> maximalRectangle([]) 0 >>> maximalRectangle([[\\"0\\"]]) 0 >>> maximalRectangle([[\\"1\\"]]) 1 pass","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 num_cols = len(matrix[0]) heights = [0] * (num_cols + 1) for row in matrix: for i in range(num_cols): if row[i] == '1': heights[i] += 1 else: heights[i] = 0 stack = [-1] for i in range(num_cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def climbStairs(n: int) -> int: Determine the number of distinct ways to reach the top of a staircase with \`n\` steps, where you can either climb 1 or 2 steps at a time. >>> climbStairs(1) 1 >>> climbStairs(2) 2 >>> climbStairs(3) 3 >>> climbStairs(4) 5 >>> climbStairs(5) 8 >>> climbStairs(10) 89 >>> climbStairs(20) 10946 >>> climbStairs(30) 1346269 >>> climbStairs(45) 1836311903","solution":"def climbStairs(n: int) -> int: if n == 1: return 1 elif n == 2: return 2 # Dynamic programming approach dp = [0] * n dp[0] = 1 dp[1] = 2 for i in range(2, n): dp[i] = dp[i - 1] + dp[i - 2] return dp[n - 1]"},{"question":"class BookInventory: A simple inventory system for a small bookstore. Methods: add_book(title, author, quantity): Adds a new book to the inventory. If the book already exists, updates the quantity. lend_book(title, author): Lends a book, reducing the quantity by 1. Returns \\"Book not available\\" if the book is not available or quantity is zero. restock_book(title, author, quantity): Increases the quantity of the book by the specified number. get_inventory(): Returns a list of dictionaries containing the title, author, and quantity of the books in the inventory. # Define the constructor (__init__) method here def add_book(self, title, author, quantity): Add a new book to the inventory or update the quantity if it already exists. pass # Implement this method def lend_book(self, title, author): Lend a book from the inventory, reducing its quantity by 1. pass # Implement this method def restock_book(self, title, author, quantity): Restock the quantity of the given book by the specified amount. pass # Implement this method def get_inventory(self): Return a list of dictionaries containing the details of books in the inventory. pass # Implement this method # Example usage: # inventory = BookInventory() # inventory.add_book(\\"1984\\", \\"George Orwell\\", 5) # print(inventory.get_inventory()) Here are some unit tests for the implemented class def test_add_book(): inventory = BookInventory() inventory.add_book(\\"1984\\", \\"George Orwell\\", 5) assert inventory.get_inventory() == [{'title': '1984', 'author': 'George Orwell', 'quantity': 5}] inventory.add_book(\\"1984\\", \\"George Orwell\\", 3) assert inventory.get_inventory() == [{'title': '1984', 'author': 'George Orwell', 'quantity': 8}] inventory.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) assert inventory.get_inventory() == [ {'title': '1984', 'author': 'George Orwell', 'quantity': 8}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'quantity': 3} ] def test_lend_book(): inventory = BookInventory() inventory.add_book(\\"1984\\", \\"George Orwell\\", 5) inventory.lend_book(\\"1984\\", \\"George Orwell\\") assert inventory.get_inventory() == [{'title': '1984', 'author': 'George Orwell', 'quantity': 4}] assert inventory.lend_book(\\"1984\\", \\"George Orwell\\") == None assert inventory.get_inventory() == [{'title': '1984', 'author': 'George Orwell', 'quantity': 3}] assert inventory.lend_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") == \\"Book not available\\" def test_restock_book(): inventory = BookInventory() inventory.add_book(\\"1984\\", \\"George Orwell\\", 5) inventory.restock_book(\\"1984\\", \\"George Orwell\\", 2) assert inventory.get_inventory() == [{'title': '1984', 'author': 'George Orwell', 'quantity': 7}] inventory.restock_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) assert inventory.get_inventory() == [ {'title': '1984', 'author': 'George Orwell', 'quantity': 7}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'quantity': 3} ] def test_edge_cases(): inventory = BookInventory() # Adding book with quantity <= 0 inventory.add_book(\\"Negative Test\\", \\"Test Author\\", 0) inventory.add_book(\\"Negative Test\\", \\"Test Author\\", -1) assert inventory.get_inventory() == [] # Restocking book with quantity <= 0 inventory.add_book(\\"Test Book\\", \\"Author\\", 1) inventory.restock_book(\\"Test Book\\", \\"Author\\", 0) inventory.restock_book(\\"Test Book\\", \\"Author\\", -2) assert inventory.get_inventory() == [{'title': 'Test Book', 'author': 'Author', 'quantity': 1}]","solution":"class BookInventory: def __init__(self): self.inventory = {} def add_book(self, title, author, quantity): if quantity <= 0: return key = (title.lower(), author.lower()) if key in self.inventory: self.inventory[key]['quantity'] += quantity else: self.inventory[key] = {'title': title, 'author': author, 'quantity': quantity} def lend_book(self, title, author): key = (title.lower(), author.lower()) if key in self.inventory and self.inventory[key]['quantity'] > 0: self.inventory[key]['quantity'] -= 1 else: return \\"Book not available\\" def restock_book(self, title, author, quantity): if quantity <= 0: return key = (title.lower(), author.lower()) if key in self.inventory: self.inventory[key]['quantity'] += quantity else: self.inventory[key] = {'title': title, 'author': author, 'quantity': quantity} def get_inventory(self): return list(self.inventory.values())"},{"question":"def manage_library(N: int, Q: int, book_ids: List[int], queries: List[int]) -> List[str]: Manage an online library system by checking the availability of books and updating their status. Args: N (int): Total number of books. Q (int): Total number of queries. book_ids (List[int]): List of book IDs available for borrowing. queries (List[int]): List of book IDs to check for availability. Returns: List[str]: List with results for each query, \\"Available\\" if the book can be borrowed, \\"Not Available\\" otherwise. >>> manage_library(5, 3, [101, 102, 103, 104, 105], [102, 104, 107]) ['Available', 'Available', 'Not Available'] >>> manage_library(1, 1, [10], [10]) ['Available'] >>> manage_library(5, 3, [20, 21, 22, 23, 24], [22, 25, 23]) ['Available', 'Not Available', 'Available']","solution":"def manage_library(N, Q, book_ids, queries): available_books = set(book_ids) results = [] for query in queries: if query in available_books: results.append(\\"Available\\") available_books.remove(query) else: results.append(\\"Not Available\\") return results # Sample Input: N, Q, book_ids, queries N = 5 Q = 3 book_ids = [101, 102, 103, 104, 105] queries = [102, 104, 107] # Execution output = manage_library(N, Q, book_ids, queries) for result in output: print(result)"},{"question":"def max_subarray_sum_with_constraint(arr: List[int], S: int) -> int: Returns the maximum possible sum of a contiguous subarray whose sum is less than or equal to S. >>> max_subarray_sum_with_constraint([1, 2, 3, 4, 5], 11) 10 >>> max_subarray_sum_with_constraint([5], 10) 5 >>> max_subarray_sum_with_constraint([10], 10) 10 >>> max_subarray_sum_with_constraint([6, 7, 8, 9, 10], 5) 0 >>> max_subarray_sum_with_constraint([-1, 1, 2, 3, 4, -5, 5], 7) 7","solution":"def max_subarray_sum_with_constraint(arr, S): Returns the maximum possible sum of a contiguous subarray whose sum is less than or equal to S. max_sum = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > S: current_sum -= arr[start] start += 1 if current_sum <= S: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def organize_indexes(indexes: str) -> str: Organizes and compresses a string of book indexes into ranges. >>> organize_indexes(\\"1,2,3,5,6,7,9,11,12,13,15\\") \\"1-3,5-7,9,11-13,15\\" >>> organize_indexes(\\"1,4,7,10\\") \\"1,4,7,10\\" >>> organize_indexes(\\"1,2,3,4,5,6,7,8,9,10\\") \\"1-10\\" >>> organize_indexes(\\"\\") \\"\\" >>> organize_indexes(\\"5\\") \\"5\\" >>> organize_indexes(\\"10,20,30,40\\") \\"10,20,30,40\\" >>> organize_indexes(\\"1,2,4,5,7,9,10,11,12\\") \\"1-2,4-5,7,9-12\\"","solution":"def organize_indexes(indexes): Organizes and compresses a string of book indexes into ranges. if not indexes: return \\"\\" index_list = [int(i) for i in indexes.split(',')] index_list.sort() ranges = [] start = end = index_list[0] for idx in index_list[1:]: if idx == end + 1: end = idx else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = end = idx if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return \\",\\".join(ranges)"},{"question":"def calculate_min_cost(bottles): Calculate the minimum cost for a given number of lemonade bottles. :param bottles: int - Number of lemonade bottles. :return: float - Minimum cost rounded to two decimal places. Examples: >>> calculate_min_cost(0) 0.0 >>> calculate_min_cost(15) 5.00 >>> calculate_min_cost(7) 2.50 >>> calculate_min_cost(3) 1.00 >>> calculate_min_cost(1) 0.50 >>> calculate_min_cost(20) 7.00 >>> calculate_min_cost(10) 3.50 >>> calculate_min_cost(23) 8.00 >>> calculate_min_cost(150) 50.00 >>> calculate_min_cost(8) 3.00","solution":"def calculate_min_cost(bottles): Calculate the minimum cost for a given number of lemonade bottles. :param bottles: int - Number of lemonade bottles. :return: float - Minimum cost rounded to two decimal places. if bottles < 0: raise ValueError(\\"The number of bottles cannot be negative.\\") prices = [(15, 5.00), (7, 2.50), (3, 1.00), (1, 0.50)] total_cost = 0.0 for qty, price in prices: while bottles >= qty: total_cost += price bottles -= qty return round(total_cost, 2)"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of the squares of all integers from 1 to n (inclusive). >>> sum_of_squares(1) 1 >>> sum_of_squares(3) 14 >>> sum_of_squares(5) 55 >>> sum_of_squares(10) 385 >>> sum_of_squares(100) 338350 # Example usage: if __name__ == \\"__main__\\": n = int(input().strip()) print(sum_of_squares(n))","solution":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n (inclusive). return sum(i ** 2 for i in range(1, n + 1)) # Example usage: if __name__ == \\"__main__\\": n = int(input().strip()) print(sum_of_squares(n))"},{"question":"def swap_case_pattern(text, rows, *args): Generates a textual pattern by alternating the case of each letter in the given string, and repeats this pattern vertically for the specified number of rows. >>> swap_case_pattern(\\"hello\\", 3) 'HeLlOnHeLlOnHeLlO' >>> swap_case_pattern(\\"WOrLD\\", 2) 'WoRlDnWoRlD' >>> swap_case_pattern(\\"\\", 5) '' >>> swap_case_pattern(\\"C0d1Ng\\", 4) 'C0D1nGnC0D1nGnC0D1nGnC0D1nG'","solution":"def swap_case_pattern(text, rows, *args): if rows < 1 or not text: return '' swap_case_text = ''.join( char.upper() if i % 2 == 0 else char.lower() for i, char in enumerate(text) ) pattern = 'n'.join([swap_case_text] * rows) return pattern"},{"question":"def process_queries(M: int, N: int, grid: List[List[int]], queries: List[List[int]]) -> List[int]: Process a series of queries on a 2D grid. Each query is either an update or a request for the maximum reachable value from a specific cell, given moves are allowed up, down, left, or right only if the destination cell has a value equal to or greater than the current cell. Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (List[List[int]]): 2D list with M rows and N columns consisting of integers. queries (List[List[int]]): List of queries. Each query is of type: [1, i_q, j_q, val_q] -> Update the value of the cell at (i_q, j_q) to val_q. [2, i_q, j_q] -> Find the maximum possible value reachable from the cell located at (i_q, j_q). Returns: List[int]: Result for each query of type 2. Examples: >>> process_queries(3, 3, [[1, 2, 3], [6, 5, 4], [7, 8, 9]], [[2, 1, 1], [1, 2, 2, 10], [2, 2, 2], [2, 3, 3]]) [9, 10, 9] >>> process_queries(2, 2, [[1, 2], [3, 4]], [[2, 1, 1], [1, 2, 2, 5], [2, 2, 2]]) [4, 5] pass # Example test cases for the function def test_case_1(): M = 3 N = 3 grid = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] queries = [ [2, 1, 1], [1, 2, 2, 10], [2, 2, 2], [2, 3, 3] ] expected = [9, 10, 9] assert process_queries(M, N, grid, queries) == expected def test_case_2(): M = 2 N = 2 grid = [ [1, 2], [3, 4] ] queries = [ [2, 1, 1], [1, 2, 2, 5], [2, 2, 2] ] expected = [4, 5] assert process_queries(M, N, grid, queries) == expected def test_case_3(): M = 1 N = 1 grid = [ [100] ] queries = [ [2, 1, 1], ] expected = [100] assert process_queries(M, N, grid, queries) == expected def test_case_4(): M = 4 N = 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] queries = [ [2, 1, 1], [2, 4, 4], [1, 2, 2, 10], [2, 2, 2] ] expected = [16, 16, 16] assert process_queries(M, N, grid, queries) == expected def test_case_5(): M = 3 N = 3 grid = [ [5, 4, 3], [4, 3, 2], [3, 2, 1] ] queries = [ [2, 1, 1], [1, 1, 1, 0], [2, 1, 1] ] expected = [5, 4] assert process_queries(M, N, grid, queries) == expected","solution":"def process_queries(M, N, grid, queries): def bfs_max_value(i, j): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * N for _ in range(M)] max_value = grid[i][j] queue = deque([(i, j)]) visited[i][j] = True while queue: cur_i, cur_j = queue.popleft() for di, dj in directions: ni, nj = cur_i + di, cur_j + dj if 0 <= ni < M and 0 <= nj < N and not visited[ni][nj] and grid[ni][nj] >= grid[cur_i][cur_j]: visited[ni][nj] = True max_value = max(max_value, grid[ni][nj]) queue.append((ni, nj)) return max_value results = [] for query in queries: if query[0] == 1: _, i_q, j_q, val_q = query grid[i_q - 1][j_q - 1] = val_q elif query[0] == 2: _, i_q, j_q = query results.append(bfs_max_value(i_q - 1, j_q - 1)) return results"},{"question":"def are_arrays_equal(arr1, arr2): Returns True if both arrays contain the same elements (with the same frequency), regardless of order. >>> are_arrays_equal([1, 2, 3, 4], [4, 3, 2, 1]) True >>> are_arrays_equal([1, 2, 3, 4], [4, 3, 2, 2]) False pass # Example test cases def test_equal_arrays(): assert are_arrays_equal([1, 2, 3, 4], [4, 3, 2, 1]) == True def test_different_length_arrays(): assert are_arrays_equal([1, 2, 3, 4], [4, 3, 2, 2]) == False def test_different_elements(): assert are_arrays_equal([1, 1, 1, 1], [1, 1, 1, 2]) == False def test_identical_arrays(): assert are_arrays_equal([1, 2, 3, 4], [1, 2, 3, 4]) == True def test_empty_arrays(): assert are_arrays_equal([], []) == True def test_single_element_different(): assert are_arrays_equal([1], [2]) == False def test_large_arrays(): assert are_arrays_equal([1]*1000, [1]*1000) == True def test_large_arrays_with_differing_elements(): assert are_arrays_equal([1]*500 + [2]*500, [1]*500 + [3]*500) == False","solution":"def are_arrays_equal(arr1, arr2): Returns True if both arrays contain the same elements (with the same frequency), regardless of order. from collections import Counter return Counter(arr1) == Counter(arr2)"},{"question":"def can_rearrange_toy_cars(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to rearrange toy cars on a conveyor belt such that no two adjacent toy cars are of the same type. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple. The first element of the tuple is an integer N denoting the number of toy cars. The second element is a list of N integers representing the type of each toy car. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case indicating if the rearrangement is possible. >>> can_rearrange_toy_cars(3, [(3, [1, 2, 3]), (4, [1, 1, 1, 3]), (5, [2, 1, 2, 1, 2])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_rearrange_toy_cars(1, [(1, [1])]) [\\"YES\\"] >>> can_rearrange_toy_cars(1, [(5, [2, 2, 2, 2, 2])]) [\\"NO\\"] >>> can_rearrange_toy_cars(1, [(5, [1, 2, 2, 3, 3])]) [\\"YES\\"] >>> can_rearrange_toy_cars(1, [(7, [1, 1, 2, 2, 3, 3, 4])]) [\\"YES\\"]","solution":"def can_rearrange_toy_cars(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] toy_types = test_cases[i][1] toy_count = {} for toy in toy_types: if toy in toy_count: toy_count[toy] += 1 else: toy_count[toy] = 1 max_count = max(toy_count.values()) if max_count > (N + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def min_distance_to_center(n: int) -> int: Calculate the minimum distance from any corner of the grid to the center. >>> min_distance_to_center(3) == 2 >>> min_distance_to_center(4) == 3","solution":"def min_distance_to_center(n: int) -> int: Calculate the minimum distance from any corner of the grid to the center. # Distance from a corner to the center in an \`n x n\` grid is always \`n - 1\` # because the optimal path from a corner to the center involves moving \`n // 2\` steps horizontally # and \`n // 2\` steps vertically if \`n\` is odd, or to one of the middle points if \`n\` is even. return n - 1"},{"question":"def max_sum_subarray(arr, k): Returns the maximum sum of any subarray of size k. >>> max_sum_subarray([4, 2, 1, 7, 8, 1, 2, 8, 1, 0], 3) 16 >>> max_sum_subarray([1, -1, 5, -2, 3, 3, -1], 2) 6","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any subarray of size k. if k > len(arr): return 0 # Initial window sum for the first window of size k max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): # Slide the window to right by removing the first element of the previous window # and adding the next element in the array current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(level_order): This function builds a binary tree from a level-order traversal list. if not level_order or level_order[0] == 'null': return None root = TreeNode(int(level_order[0])) queue = deque([root]) index = 1 while index < len(level_order): current = queue.popleft() if level_order[index] != 'null': current.left = TreeNode(int(level_order[index])) queue.append(current.left) index += 1 if index < len(level_order) and level_order[index] != 'null': current.right = TreeNode(int(level_order[index])) queue.append(current.right) index += 1 return root def max_depth(root: TreeNode) -> int: Determines the maximum depth of a binary tree. >>> level_order = [\\"3\\", \\"9\\", \\"20\\", \\"null\\", \\"null\\", \\"15\\", \\"7\\"] >>> tree = build_tree(level_order) >>> max_depth(tree) 3 >>> level_order = [\\"1\\", \\"null\\", \\"2\\", \\"null\\", \\"3\\"] >>> tree = build_tree(level_order) >>> max_depth(tree) 3 >>> level_order = [\\"null\\"] >>> tree = build_tree(level_order) >>> max_depth(tree) 0 >>> level_order = [\\"1\\"] >>> tree = build_tree(level_order) >>> max_depth(tree) 1 >>> level_order = [\\"1\\", \\"2\\", \\"3\\", \\"null\\", \\"null\\", \\"4\\", \\"5\\"] >>> tree = build_tree(level_order) >>> max_depth(tree) 3 >>> level_order = [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"null\\", \\"null\\", \\"6\\", \\"null\\", \\"null\\", \\"7\\"] >>> tree = build_tree(level_order) >>> max_depth(tree) 4","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(level_order): if not level_order or level_order[0] == 'null': return None root = TreeNode(int(level_order[0])) queue = deque([root]) index = 1 while index < len(level_order): current = queue.popleft() if level_order[index] != 'null': current.left = TreeNode(int(level_order[index])) queue.append(current.left) index += 1 if index < len(level_order) and level_order[index] != 'null': current.right = TreeNode(int(level_order[index])) queue.append(current.right) index += 1 return root def max_depth(root): if not root: return 0 queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"def unique_characters(s: str) -> str: Returns a string with all unique characters from the input string \`s\` in the order they appear. >>> unique_characters(\\"aabbcc\\") 'abc' >>> unique_characters(\\"Hello\\") 'Helo' >>> unique_characters(\\"abracadabra\\") 'abrcd' >>> unique_characters(\\"122333\\") '123'","solution":"def unique_characters(s): Returns a string with all unique characters from the input string \`s\` in the order they appear. :param s: Input string :return: String with unique characters seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"class ParkingLot: A class representing a parking lot with a given capacity. Methods: - __init__(self, capacity): Initializes the ParkingLot with the given capacity. - parkCar(self, carNumber: str) -> bool: Parks the car with the given car number if there is available space. - removeCar(self, carNumber: str) -> bool: Removes the car with the given car number from the parking lot. - getAvailableSpaces(self) -> int: Returns the number of currently available parking spaces in the lot. - getAllParkedCars(self) -> list: Returns a list of car numbers of all parked cars in the lot. def __init__(self, capacity): pass def parkCar(self, carNumber: str) -> bool: pass def removeCar(self, carNumber: str) -> bool: pass def getAvailableSpaces(self) -> int: pass def getAllParkedCars(self) -> list: pass # Test cases: def test_parking_lot_initialization(): parking_lot = ParkingLot(5) assert parking_lot.getAvailableSpaces() == 5 assert parking_lot.getAllParkedCars() == [] def test_parking_lot_park_car(): parking_lot = ParkingLot(2) assert parking_lot.parkCar(\\"ABC123\\") == True assert parking_lot.getAllParkedCars() == [\\"ABC123\\"] assert parking_lot.getAvailableSpaces() == 1 assert parking_lot.parkCar(\\"XYZ789\\") == True assert sorted(parking_lot.getAllParkedCars()) == sorted([\\"ABC123\\", \\"XYZ789\\"]) assert parking_lot.getAvailableSpaces() == 0 assert parking_lot.parkCar(\\"DEF456\\") == False assert sorted(parking_lot.getAllParkedCars()) == sorted([\\"ABC123\\", \\"XYZ789\\"]) assert parking_lot.getAvailableSpaces() == 0 def test_parking_lot_remove_car(): parking_lot = ParkingLot(2) parking_lot.parkCar(\\"ABC123\\") parking_lot.parkCar(\\"XYZ789\\") assert parking_lot.removeCar(\\"XYZ789\\") == True assert parking_lot.getAllParkedCars() == [\\"ABC123\\"] assert parking_lot.getAvailableSpaces() == 1 assert parking_lot.removeCar(\\"XYZ789\\") == False assert parking_lot.getAllParkedCars() == [\\"ABC123\\"] assert parking_lot.getAvailableSpaces() == 1 def test_parking_lot_mixed_operations(): parking_lot = ParkingLot(3) assert parking_lot.parkCar(\\"ABC123\\") == True assert parking_lot.parkCar(\\"XYZ789\\") == True assert parking_lot.parkCar(\\"DEF456\\") == True assert parking_lot.parkCar(\\"GHI101\\") == False assert sorted(parking_lot.getAllParkedCars()) == sorted([\\"ABC123\\", \\"XYZ789\\", \\"DEF456\\"]) assert parking_lot.getAvailableSpaces() == 0 assert parking_lot.removeCar(\\"XYZ789\\") == True assert sorted(parking_lot.getAllParkedCars()) == sorted([\\"ABC123\\", \\"DEF456\\"]) assert parking_lot.getAvailableSpaces() == 1 assert parking_lot.parkCar(\\"GHI101\\") == True assert sorted(parking_lot.getAllParkedCars()) == sorted([\\"ABC123\\", \\"DEF456\\", \\"GHI101\\"]) assert parking_lot.getAvailableSpaces() == 0","solution":"class ParkingLot: def __init__(self, capacity): self.capacity = capacity self.cars = set() def parkCar(self, carNumber): if len(self.cars) < self.capacity: self.cars.add(carNumber) return True return False def removeCar(self, carNumber): if carNumber in self.cars: self.cars.remove(carNumber) return True return False def getAvailableSpaces(self): return self.capacity - len(self.cars) def getAllParkedCars(self): return list(self.cars)"},{"question":"from datetime import datetime def days_until_birthday(current_date: str, birthday: str) -> int: Calculate the number of days left until the next occurrence of a friend's birthday. Args: current_date (str): The current date in the format \\"YYYY-MM-DD\\". birthday (str): The friend's birthday in the format \\"YYYY-MM-DD\\". Returns: int: The number of days left until the friend's next birthday. Examples: >>> days_until_birthday(\\"2023-08-15\\", \\"2023-08-20\\") 5 >>> days_until_birthday(\\"2023-09-01\\", \\"2023-05-10\\") 252","solution":"from datetime import datetime def days_until_birthday(current_date: str, birthday: str) -> int: current = datetime.strptime(current_date, \\"%Y-%m-%d\\") bday_this_year = datetime.strptime(f\\"{current.year}-{birthday.split('-')[1]}-{birthday.split('-')[2]}\\", \\"%Y-%m-%d\\") if bday_this_year < current: bday_next_year = datetime.strptime(f\\"{current.year + 1}-{birthday.split('-')[1]}-{birthday.split('-')[2]}\\", \\"%Y-%m-%d\\") return (bday_next_year - current).days else: return (bday_this_year - current).days"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths to reach the bottom-right corner of an m x n grid from the top-left corner, only moving right or down. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(3, 3) 6","solution":"def unique_paths(m, n): Returns the number of unique paths to reach the bottom-right corner of an m x n grid from the top-left corner, only moving right or down. if m == 1 or n == 1: return 1 # Create a 2D array (list of lists) with m rows and n columns initialized to 1 dp = [[1]*n for _ in range(m)] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_apples(grid): Function to calculate the maximum number of apples that can be collected from the top-left to the bottom-right cell of a grid. :param grid: List of lists representing the apple grid where grid[i][j] is the number of apples in cell (i, j) :return: Maximum number of apples that can be collected >>> max_apples([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 29 >>> max_apples([[5]]) == 5 >>> max_apples([[1, 2, 3, 4, 5]]) == 15 >>> max_apples([[1], [2], [3], [4], [5]]) == 15 >>> max_apples([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> max_apples([ [1, 1, 1], [1, 2, 2], [1, 2, 3] ]) == 9","solution":"def max_apples(grid): Function to calculate the maximum number of apples that can be collected from the top-left to the bottom-right cell of a grid. :param grid: List of lists representing the apple grid where grid[i][j] is the number of apples in cell (i, j) :return: Maximum number of apples that can be collected N = len(grid) M = len(grid[0]) # DP table to store the maximum apples collectable up to each cell dp = [[0] * M for _ in range(N)] # Initialize the top-left cell with its own apple count dp[0][0] = grid[0][0] # Fill in the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"def find_next_square(n: int) -> int: Returns the next perfect square if n is a perfect square, otherwise returns -1. >>> find_next_square(16) 25 >>> find_next_square(10) -1 >>> find_next_square(144) 169 >>> find_next_square(0) 1 >>> find_next_square(1) 4","solution":"import math def find_next_square(n): Returns the next perfect square if n is a perfect square, otherwise returns -1. root = math.isqrt(n) if root * root == n: return (root + 1) ** 2 else: return -1"},{"question":"def plant_growth(days, growth_per_day, rest_period): Computes the total growth of the plant after a given number of days. Parameters: days (int): total number of days growth_per_day (int): amount the plant grows each day it is not resting rest_period (int): interval at which the plant rests, i.e., every nth day Returns: int: total growth of the plant after the given number of days Examples: >>> plant_growth(10, 2, 3) == 14 >>> plant_growth(5, 3, 7) == 15","solution":"def plant_growth(days, growth_per_day, rest_period): Computes the total growth of the plant after a given number of days. Parameters: days (int): total number of days growth_per_day (int): amount the plant grows each day it is not resting rest_period (int): interval at which the plant rests, i.e., every nth day Returns: int: total growth of the plant after the given number of days total_growth = 0 for day in range(1, days + 1): if day % rest_period != 0: total_growth += growth_per_day return total_growth"},{"question":"def findConsecutiveSubstrings(s: str, k: int) -> List[str]: Returns an array of all unique substrings of s with exactly k consecutive characters. >>> findConsecutiveSubstrings(\\"abcabc\\", 3) [\\"abc\\", \\"bca\\", \\"cab\\"] >>> findConsecutiveSubstrings(\\"aaaaa\\", 2) [\\"aa\\"] >>> findConsecutiveSubstrings(\\"abcdef\\", 4) [\\"abcd\\", \\"bcde\\", \\"cdef\\"] >>> findConsecutiveSubstrings(\\"abcde\\", 5) [\\"abcde\\"] >>> findConsecutiveSubstrings(\\"abcde\\", 1) [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] >>> findConsecutiveSubstrings(\\"a\\", 1) [\\"a\\"] >>> findConsecutiveSubstrings(\\"abc\\", 4) [] >>> findConsecutiveSubstrings(\\"mmmmmm\\", 3) [\\"mmm\\"] pass","solution":"def findConsecutiveSubstrings(s, k): Returns an array of all unique substrings of s with exactly k consecutive characters. substrings = set() # Using a set to ensure uniqueness for i in range(len(s) - k + 1): substr = s[i:i + k] substrings.add(substr) return list(substrings)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\" \\") == 1 >>> length_of_longest_substring(\\"au\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"abba\\") == 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"from typing import List from math import gcd def generate_permutation(n: int) -> List[int]: Generate a permutation of integers from 1 to n such that the GCD of each adjacent pair is 1. If no such permutation exists, return -1. Args: n: An integer representing the size of the sequence. Returns: List[int]: A permutation of the sequence with the required property or -1 if not possible. Examples: >>> generate_permutation(4) [1, 3, 2, 4] >>> generate_permutation(2) [1, 2] >>> generate_permutation(1) [1] >>> generate_permutation(15) [1, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14]","solution":"from math import gcd def generate_permutation(n): if n == 1: return [1] if n == 2: return [1, 2] # Generate the sequence starting from 2, 1 and keep alternating between odd and even permutation = [] for i in range(1, n + 1, 2): permutation.append(i) for i in range(2, n + 1, 2): permutation.append(i) # Check if the generated permutation has the required property for i in range(n-1): if gcd(permutation[i], permutation[i+1]) != 1: return -1 return permutation"},{"question":"def first_non_repeated_char(s: str) -> str: Create a method that takes a string as input, and outputs the first non-repeated character in the string. The method should be case-sensitive and handle strings with special characters and spaces. If all characters are repeated or the string is empty, the method should output an empty string \\"\\". >>> first_non_repeated_char(\\"swiss\\") # => \\"w\\" >>> first_non_repeated_char(\\"repeater\\") # => \\"a\\" >>> first_non_repeated_char(\\"aAbBABac\\") # => \\"b\\" >>> first_non_repeated_char(\\"aabbcc\\") # => \\"\\"","solution":"def first_non_repeated_char(s): Returns the first non-repeated character in the string s. If all characters are repeated or the string is empty, returns an empty string \\"\\". char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeated character found, return empty string return \\"\\""},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner of the grid to the bottom-right corner while minimizing the total weight. You can only move up, down, left, or right. If there is no path, return -1. >>> grid1 = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> shortest_path(grid1) 7 >>> grid2 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> shortest_path(grid2) 21 >>> grid3 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> shortest_path(grid3) 5 >>> grid4 = [ ... [1, 1, 1], ... [1, 1000, 1], ... [1, 1, 1] ... ] >>> shortest_path(grid4) 5 >>> grid5 = [[1, 2, 3]] >>> shortest_path(grid5) 6 >>> grid6 = [ ... [1], ... [2], ... [3] ... ] >>> shortest_path(grid6) 6 >>> grid7 = [[42]] >>> shortest_path(grid7) 42 >>> grid8 = [ ... [1, 1, 1], ... [1, 1000, 1], ... [1, 1, 0] ... ] >>> shortest_path(grid8) != 0 True","solution":"from heapq import heappop, heappush from typing import List, Tuple def shortest_path(grid: List[List[int]]) -> int: def neighbors(r, c): for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: # down, up, right, left rr, cc = r + dr, c + dc if 0 <= rr < len(grid) and 0 <= cc < len(grid[0]): yield rr, cc rows, cols = len(grid), len(grid[0]) pq = [(grid[0][0], 0, 0)] # (weight, row, col) min_dist = {(0, 0): grid[0][0]} while pq: current_weight, r, c = heappop(pq) if (r, c) == (rows - 1, cols - 1): return current_weight for nr, nc in neighbors(r, c): new_weight = current_weight + grid[nr][nc] if (nr, nc) not in min_dist or new_weight < min_dist[(nr, nc)]: min_dist[(nr, nc)] = new_weight heappush(pq, (new_weight, nr, nc)) return -1 # No path found"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if the given string is a permutation of a palindrome. >>> is_palindrome_permutation(\\"civic\\") == True >>> is_palindrome_permutation(\\"ivicc\\") == True >>> is_palindrome_permutation(\\"hello\\") == False >>> is_palindrome_permutation(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome_permutation(\\"\\") == True >>> is_palindrome_permutation(\\"a\\") == True >>> is_palindrome_permutation(\\"ab\\") == False >>> is_palindrome_permutation(\\"aa\\") == True >>> is_palindrome_permutation(\\"Tact Coa\\") == True","solution":"def is_palindrome_permutation(s): Determines if the given string is a permutation of a palindrome. from collections import Counter # Remove spaces and convert to lowercase s = ''.join(char.lower() for char in s if char.isalnum()) # Count frequency of each character char_count = Counter(s) # A string can be a permutation of a palindrome if at most one character # has an odd frequency (for the middle character in an odd length palindrome) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def smallest_park_side_length(N: int) -> int: Determine the side length of the smallest square-shaped area (park) that can be built in a grid of side length N, such that the park is surrounded by at least one row and one column of districts on all four sides. >>> smallest_park_side_length(5) 3 >>> smallest_park_side_length(4) 2 >>> smallest_park_side_length(10) 8 >>> smallest_park_side_length(100) 98 >>> smallest_park_side_length(1000) 998 >>> smallest_park_side_length(3) 0","solution":"def smallest_park_side_length(N): Returns the side length of the smallest possible park that can be built in a grid of side length N, such that the park is surrounded by at least one row and one column of districts on all four sides. if N < 4: return 0 # If N < 4 this scenario is invalid based on problem assumption N >= 4 return N - 2"},{"question":"def is_valid_ipv4_address(ip: str) -> bool: Determines if a given string is a valid IPv4 address. An IPv4 address consists of four decimal numbers, each ranging from 0 to 255, separated by dots (.). Leading zeros are not allowed. >>> is_valid_ipv4_address(\\"192.168.1.1\\") True >>> is_valid_ipv4_address(\\"256.256.256.256\\") False >>> is_valid_ipv4_address(\\"192.168.1.01\\") False >>> is_valid_ipv4_address(\\"192.168@1.1\\") False >>> is_valid_ipv4_address(\\"192.168.1\\") False","solution":"def is_valid_ipv4_address(ip): Determines if a given string is a valid IPv4 address. An IPv4 address consists of four decimal numbers, each ranging from 0 to 255, separated by dots (.). Leading zeros are not allowed. Parameters: ip (str): The string to validate as an IPv4 address. Returns: bool: True if the string is a valid IPv4 address, False otherwise. parts = ip.split('.') # Check that the address contains exactly four parts if len(parts) != 4: return False for part in parts: # Check that the part is not empty and contains only digits if not part.isdigit(): return False # Convert part to an integer and validate the range num = int(part) if num < 0 or num > 255: return False # Check for leading zeros if part != str(num): return False return True"},{"question":"def can_permute_palindrome(s: str) -> bool: Checks whether any permutation of the given string can form a palindrome. :param s: The input string, consisting of only lowercase alphabets. :return: True if any permutation can form a palindrome, else False.","solution":"def can_permute_palindrome(s: str) -> bool: Checks whether any permutation of the given string can form a palindrome. :param s: The input string, consisting of only lowercase alphabets. :return: True if any permutation can form a palindrome, else False. # Create a dictionary to count occurrences of each character char_count = {} # Count each character in the string for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the number of characters with odd counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be rearranged into a palindrome, it can have at most one character with an odd count return odd_count <= 1"},{"question":"def min_insertions_to_make_palindrome(s: str) -> int: Given an input string, determine the minimum number of insertions needed to make the string a palindrome using dynamic programming. >>> min_insertions_to_make_palindrome(\\"abca\\") 1 >>> min_insertions_to_make_palindrome(\\"radar\\") 0 >>> min_insertions_to_make_palindrome(\\"google\\") 2","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of insertions needed to make the string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"def is_balanced(expression: str) -> str: Determines if the brackets in the given arithmetic expression are balanced. Parameters: expression (str): The arithmetic expression to check. Returns: str: \\"YES\\" if the expression is balanced, otherwise \\"NO\\". # Unit tests def test_balanced_simple_expression(): assert is_balanced(\\"(2 + 3) * [5 - (8 / 4)]\\") == \\"YES\\" def test_unbalanced_expression_missing_closing(): assert is_balanced(\\"2 + [3 * (5 - 2)\\") == \\"NO\\" def test_balanced_complex_expression(): assert is_balanced(\\"{[2 + 3] * (5 - 4) / [8 / (2 + 2)]}\\") == \\"YES\\" def test_unbalanced_expression_extra_closing(): assert is_balanced(\\"(2 + 3)) * [5 - (8 / 4)]\\") == \\"NO\\" def test_balanced_with_no_brackets(): assert is_balanced(\\"2 + 3 - 4 * 5 / 6\\") == \\"YES\\" def test_unbalanced_expression_missing_opening(): assert is_balanced(\\"2 + 3] * (5 - 4)\\") == \\"NO\\" def test_empty_expression(): assert is_balanced(\\"\\") == \\"YES\\" def test_balanced_nested_brackets(): assert is_balanced(\\"(({{[[]]}}))\\") == \\"YES\\" def test_unbalanced_nested_brackets(): assert is_balanced(\\"{[(])}\\") == \\"NO\\"","solution":"def is_balanced(expression): Determines if the brackets in the given arithmetic expression are balanced. Parameters: expression (str): The arithmetic expression to check. Returns: str: \\"YES\\" if the expression is balanced, otherwise \\"NO\\". stack = [] brackets = {')': '(', '}': '{', ']': '['} for char in expression: if char in brackets.values(): stack.append(char) elif char in brackets.keys(): if stack == [] or brackets[char] != stack.pop(): return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def split_digits(number: int) -> List[int]: Write a function that takes an integer and returns a list containing each digit as an integer in the order they appear in the given number. Ensure the function works for both positive and negative integers. Examples: >>> split_digits(12345) [1, 2, 3, 4, 5] >>> split_digits(-6789) [-6, 7, 8, 9] >>> split_digits(0) [0]","solution":"def split_digits(number): Returns a list containing each digit of the number as an integer in the order they appear. For negative numbers, the first element will be a negative digit. if number == 0: return [0] digits = [] is_negative = number < 0 number = abs(number) while number > 0: digits.append(number % 10) number //= 10 digits.reverse() if is_negative: digits[0] = -digits[0] return digits"},{"question":"def summarize_expenses(expenses: dict) -> dict: Takes a nested dictionary of people and their monthly expenses and returns a dictionary with the total expenses of each person. Args: expenses (dict): A dictionary where keys are people's names and values are dictionaries of their monthly expenses. Returns: dict: A dictionary where keys are people's names and values are their total expenses. Example: >>> expenses = {'Alice': {'January': 220, 'February': 180, 'March': 240}, 'Bob': {'January': 300, 'February': 150, 'March': 350}, 'Charlie': {'January': 200, 'February': 210, 'March': 190}} >>> summarize_expenses(expenses) {'Alice': 640, 'Bob': 800, 'Charlie': 600} >>> expenses = {'Alice': {'April': 100, 'May': 150}, 'Bob': {'April': 300, 'May': 200}} >>> summarize_expenses(expenses) {'Alice': 250, 'Bob': 500}","solution":"def summarize_expenses(expenses): Takes a nested dictionary of people and their monthly expenses and returns a dictionary with the total expenses of each person. Args: expenses (dict): A dictionary where keys are people's names and values are dictionaries of their monthly expenses. Returns: dict: A dictionary where keys are people's names and values are their total expenses. total_expenses = {} for person, monthly_expenses in expenses.items(): total_expenses[person] = sum(monthly_expenses.values()) return total_expenses"},{"question":"def filterUnique(arr: List[int]) -> List[int]: Takes an array of numbers and returns a new array containing only the unique numbers, preserving the order of their first occurrence in the input array. >>> filterUnique([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> filterUnique([6, 7, 7, 8, 6, 9]) [6, 7, 8, 9] >>> filterUnique([10, 20, 20, 10, 30, 40, 30]) [10, 20, 30, 40] >>> filterUnique([]) [] >>> filterUnique([1, 1, 1, 1, 1, 1, 1]) [1]","solution":"def filterUnique(arr): Takes an array of numbers and returns a new array containing only the unique numbers, preserving the order of their first occurrence in the input array. seen = set() unique_list = [] for num in arr: if num not in seen: unique_list.append(num) seen.add(num) return unique_list"},{"question":"def is_palindrome(word: str) -> bool: Check if the given word is a palindrome. return word == word[::-1] def min_removals_to_non_palindrome(word: str) -> int: Determines if the word is a palindrome, and if it is, counts the minimum number of character removals required to make it a non-palindrome. Returns -1 if the word is not a palindrome. >>> min_removals_to_non_palindrome(\\"racecar\\") 1 >>> min_removals_to_non_palindrome(\\"hello\\") -1 >>> min_removals_to_non_palindrome(\\"abba\\") 1","solution":"def is_palindrome(word): Check if the given word is a palindrome. return word == word[::-1] def min_removals_to_non_palindrome(word): Determines if the word is a palindrome, and if it is, counts the minimum number of character removals required to make it a non-palindrome. Returns -1 if the word is not a palindrome. if not is_palindrome(word): return -1 # If the word is already a palindrome, # removing any single character will easily make it a non-palindrome. return 1"},{"question":"def decodeString(s: str) -> str: Decode an encoded string, where repetitions of substrings are represented as \`k[substring]\` and \`k\` is a positive integer. Example 1: Input: \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" Example 2: Input: \\"3[a2[c]]\\" Output: \\"accaccacc\\" Example 3: Input: \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\"","solution":"def decodeString(s: str) -> str: stack = [] current_num = 0 current_string = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif char == ']': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except nums[i]. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6]","solution":"def product_except_self(nums): Returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except nums[i]. length = len(nums) answer = [0] * length # Calculate left products answer[0] = 1 for i in range(1, length): answer[i] = nums[i - 1] * answer[i - 1] # Calculate right products and final answer right_product = 1 for i in range(length - 1, -1, -1): answer[i] = answer[i] * right_product right_product *= nums[i] return answer"},{"question":"def shift_string(s: str, n: int) -> str: Shift each character in the string \`s\` by \`n\` positions forward in the alphabet. Wrapping around if the shift goes beyond 'z' or 'Z'. The function is case-sensitive. >>> shift_string(\\"abcXYZ\\", 2) \\"cdeZAB\\" >>> shift_string(\\"Hello\\", 13) \\"Uryyb\\"","solution":"def shift_string(s, n): This function takes a string \`s\` and an integer \`n\`, and returns a new string where each character in \`s\` is shifted by \`n\` positions forward in the alphabet. result = [] for char in s: if char.islower(): shifted = chr((ord(char) - ord('a') + n) % 26 + ord('a')) elif char.isupper(): shifted = chr((ord(char) - ord('A') + n) % 26 + ord('A')) result.append(shifted) return ''.join(result)"},{"question":"def categorize_strings(strings: List[str]) -> dict: Categorizes a list of strings based on their lengths. >>> categorize_strings([\\"apple\\", \\"banana\\", \\"cat\\", \\"dog\\", \\"elephant\\", \\"fish\\"]) {3: [\\"cat\\", \\"dog\\"], 4: [\\"fish\\"], 5: [\\"apple\\"], 6: [\\"banana\\"], 8: [\\"elephant\\"]} >>> categorize_strings([]) {} >>> categorize_strings([\\"a\\", \\"b\\", \\"c\\"]) {1: [\\"a\\", \\"b\\", \\"c\\"]} >>> categorize_strings([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeeee\\"]) {1: [\\"a\\"], 2: [\\"bb\\"], 3: [\\"ccc\\"], 4: [\\"dddd\\"], 5: [\\"eeeee\\"]} >>> categorize_strings([\\"apple\\", \\"grape\\", \\"lemon\\", \\"peach\\"]) {5: [\\"apple\\", \\"grape\\", \\"lemon\\", \\"peach\\"]}","solution":"def categorize_strings(strings): Categorizes the strings based on their lengths. Parameters: strings (List[str]): List of strings to be categorized. Returns: dict: Dictionary where keys are string lengths and values are lists of strings of that length. categorized_dict = {} for string in strings: length = len(string) if length not in categorized_dict: categorized_dict[length] = [] categorized_dict[length].append(string) return categorized_dict"},{"question":"def sum_of_digits(s: str) -> int: Takes a string consisting of digits and non-digit characters. Returns the sum of the digits. >>> sum_of_digits(\\"abc123\\") 6 >>> sum_of_digits(\\"99 bottles\\") 18 >>> sum_of_digits(\\"hello5world3\\") 8 >>> sum_of_digits(\\"no digits\\") 0 >>> sum_of_digits(\\"\\") 0 >>> sum_of_digits(\\"123456\\") 21 >>> sum_of_digits(\\"a1b2c3d4e5f6g7h8i9j0\\") 45","solution":"def sum_of_digits(s): Takes a string consisting of digits and non-digit characters. Returns the sum of the digits. return sum(int(char) for char in s if char.isdigit())"},{"question":"def decode_string(s: str) -> str: Decode the given encoded message string using the rule k[encoded_string]. >>> decode_string(\\"3[a]2[bc]\\") 'aaabcbc' >>> decode_string(\\"3[a2[c]]\\") 'accaccacc' >>> decode_string(\\"2[abc]3[cd]ef\\") 'abcabccdcdcdef' from solution import decode_string def test_example1(): assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" def test_example2(): assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_example3(): assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" def test_nested(): assert decode_string(\\"2[3[a]b]\\") == \\"aaabaaab\\" def test_multiple_brackets(): assert decode_string(\\"3[a]3[b]3[c]\\") == \\"aaabbbccc\\" def test_no_brackets(): assert decode_string(\\"abc\\") == \\"abc\\" def test_single_letter_repeated(): assert decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" def test_digit_in_between(): assert decode_string(\\"3[a2[b]]\\") == \\"abbabbabb\\" def test_large_number(): assert decode_string(\\"2[3[a]4[b]]\\") == \\"aaabbbbaaabbbb\\" def test_empty_input(): assert decode_string(\\"\\") == \\"\\"","solution":"def decode_string(s): Decode the given encoded message string using the rule k[encoded_string]. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_num, current_str)) current_num = 0 current_str = \\"\\" elif char == ']': num, prev_str = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"def distribute_stations(total_distance: int, total_stations: int, required_stations: int) -> List[int]: Distribute the refreshment stations as evenly as possible along the marathon route. >>> distribute_stations(50, 10, 5) [8, 17, 25, 33, 42] >>> distribute_stations(50, 4, 5) \\"Invalid input\\" >>> distribute_stations(100, 15, 5) [17, 33, 50, 67, 83] >>> distribute_stations(50, 10, 1) [25] >>> distribute_stations(50, 5, 5) [8, 17, 25, 33, 42]","solution":"def distribute_stations(total_distance, total_stations, required_stations): if required_stations > total_stations or required_stations < 1: return \\"Invalid input\\" interval = total_distance / (required_stations + 1) stations = [round(interval * (i + 1)) for i in range(required_stations)] return stations"},{"question":"def calculate_stock_span(prices: List[int]) -> List[int]: Calculates the stock span for each day. The span of the stock’s price for a given day is defined as the maximum number of consecutive days (up to the current day) the price of the stock has been less than or equal to its price on the current day. The function takes a list of stock prices as input and returns a list of spans for each day. >>> calculate_stock_span([100, 80, 60, 70, 60, 75, 85]) [1, 1, 1, 2, 1, 4, 6] >>> calculate_stock_span([10, 4, 5, 90, 120, 80]) [1, 1, 2, 4, 5, 1] >>> calculate_stock_span([100, 100, 100, 100]) [1, 2, 3, 4] >>> calculate_stock_span([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> calculate_stock_span([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> calculate_stock_span([3, 3, 3, 3, 3, 3, 3]) [1, 2, 3, 4, 5, 6, 7] >>> calculate_stock_span([100]) [1]","solution":"def calculate_stock_span(prices): Calculates the stock span for each day. Parameters: prices (list): A list of integers representing daily stock prices. Returns: list: A list of integers representing the stock span for each day. n = len(prices) span = [1] * n # Initialize span list with ones # Stack to store indices of the prices array stack = [] stack.append(0) for i in range(1, n): # While stack is not empty and the price at stack top is less than or equal to current price while stack and prices[stack[-1]] <= prices[i]: stack.pop() # If stack becomes empty, then price[i] is greater than all elements on left of it if not stack: span[i] = i + 1 else: span[i] = i - stack[-1] # Push current element index to stack stack.append(i) return span"},{"question":"from typing import List, Tuple def min_contiguous_subarrays(n: int, arr: List[int]) -> int: Returns the minimum number of contiguous subarrays needed such that each subarray contains all consecutive numbers between the minimum and maximum elements of that subarray in any order. >>> min_contiguous_subarrays(5, [4, 2, 1, 3, 5]) 1 >>> min_contiguous_subarrays(4, [1, 2, 4, 3]) 1 >>> min_contiguous_subarrays(4, [4, 3, 2, 1]) 1 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. >>> t = 3 >>> test_cases = [(5, [4, 2, 1, 3, 5]), (4, [1, 2, 4, 3]), (4, [4, 3, 2, 1])] >>> process_test_cases(t, test_cases) [1, 1, 1] >>> t = 2 >>> test_cases = [(6, [1, 6, 5, 4, 3, 2]), (3, [3, 2, 1])] >>> process_test_cases(t, test_cases) [1, 1] pass","solution":"def min_contiguous_subarrays(n, arr): min_subarrays = 0 max_val = 0 expected_val = 1 for num in sorted(arr): if num > max_val: max_val = num if num == expected_val: expected_val += 1 if expected_val > max_val: expected_val = max_val + 1 return 1 if expected_val > n else 0 def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(min_contiguous_subarrays(n, arr)) return results"},{"question":"from typing import List def is_sorted_matrix(matrix: List[List[int]]) -> bool: Determine if all rows and columns are sorted in non-decreasing order. >>> is_sorted_matrix([ >>> [1, 2, 3], >>> [2, 3, 4], >>> [3, 4, 5] >>> ]) == True >>> is_sorted_matrix([ >>> [1, 2, 3], >>> [2, 1, 4], >>> [3, 4, 5] >>> ]) == False >>> is_sorted_matrix([ >>> [1, 2, 3], >>> [3, 3, 4], >>> [2, 4, 5] >>> ]) == False >>> is_sorted_matrix([[1]]) == True >>> is_sorted_matrix([[-1, 3, 5]]) == True >>> is_sorted_matrix([[1], [2], [3]]) == True","solution":"from typing import List def is_sorted_matrix(matrix: List[List[int]]) -> bool: # Check rows for row in matrix: if any(row[i] > row[i+1] for i in range(len(row)-1)): return False # Check columns for col in range(len(matrix[0])): if any(matrix[row][col] > matrix[row+1][col] for row in range(len(matrix)-1)): return False return True"},{"question":"from collections import deque from typing import List def shortest_path(n: int, m: int, grid: List[str]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a given n x m grid with prohibited cells marked by '#'. >>> shortest_path(4, 4, [\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"]) 6 >>> shortest_path(3, 3, [\\"...\\", \\"#\\", \\".#.\\"]) -1","solution":"from collections import deque def shortest_path(n, m, grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a given n x m grid with prohibited cells marked by '#'. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, step = queue.popleft() if x == n - 1 and y == m - 1: return step for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, step + 1)) return -1"},{"question":"def count_interesting_subsegments(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Count the number of k-interesting subsegments for each k from 1 to n. >>> count_interesting_subsegments(2, [(5, [1, 2, 3, 4, 5]), (4, [1, 2, 2, 1])]) [[5, 4, 3, 2, 1], [4, 2, 0, 0]]","solution":"def count_interesting_subsegments(t, test_cases): results = [] for n, arr in test_cases: result = [] for k in range(1, n + 1): segment_set = set() count = 0 for i in range(n - k + 1): segment = tuple(arr[i:i + k]) if len(segment) == len(set(segment)): count += 1 result.append(count) results.append(result) return results # Example usage t = 2 test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [1, 2, 2, 1]), ] print(count_interesting_subsegments(t, test_cases)) # Expected Output: [[5, 4, 3, 2, 1], [4, 2, 0, 0]]"},{"question":"def max_sum_subarray_k(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, find the maximum sum of a subarray of size \`k\`. A subarray is defined as a contiguous section of an array. Your task is to find the highest sum that can be obtained by adding up \`k\` consecutive elements in the array. >>> max_sum_subarray_k([2, 1, 5, 1, 3, 2], 3) == 9 >>> max_sum_subarray_k([2, 3, 4, 1, 5], 2) == 7 >>> max_sum_subarray_k([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39 from solution import max_sum_subarray_k def test_example_1(): assert max_sum_subarray_k([2, 1, 5, 1, 3, 2], 3) == 9 def test_example_2(): assert max_sum_subarray_k([2, 3, 4, 1, 5], 2) == 7 def test_example_3(): assert max_sum_subarray_k([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39 def test_array_with_negative_numbers(): assert max_sum_subarray_k([-1, -2, -3, -4, -5], 2) == -3 def test_entire_array(): assert max_sum_subarray_k([2, 1, 5, 1, 3, 2], 6) == 14 def test_single_element(): assert max_sum_subarray_k([10], 1) == 10 def test_k_equal_to_0(): assert max_sum_subarray_k([1, 2, 3], 0) == 0 def test_k_greater_than_array_length(): assert max_sum_subarray_k([1, 2, 3], 5) == 0 def test_empty_array(): assert max_sum_subarray_k([], 3) == 0","solution":"def max_sum_subarray_k(arr, k): Returns the maximum sum of a subarray of size k. if not arr or k <= 0 or k > len(arr): return 0 # calculating the initial window max_sum = current_sum = sum(arr[:k]) # sliding the window across the array for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def increment_by_index(lst: List[int]) -> List[int]: Takes a list of integers and returns a list with each integer incremented by its position in the list (0-based index). >>> increment_by_index([5, 10, 15, 20]) [5, 11, 17, 23] >>> increment_by_index([3]) [3] >>> increment_by_index([0, 1, 2, 3, 4]) [0, 2, 4, 6, 8] >>> increment_by_index([1, 2, 3, 4, 5]) [1, 3, 5, 7, 9] >>> increment_by_index([7, 8, 9, 10]) [7, 9, 11, 13] >>> increment_by_index([100, 200, 300, 400]) [100, 201, 302, 403] pass","solution":"def increment_by_index(lst): Returns a new list where each element is incremented by its position in the list. Parameters: lst (list): A list of non-negative integers. Returns: list: A new list with each integer incremented by its position in the list. return [num + idx for idx, num in enumerate(lst)]"},{"question":"def generate_leaderboard(participants: List[Tuple[str, int]]) -> List[str]: Generates a leaderboard sorted by scores in descending order. If scores are tied, sorts names lexicographically. def read_input(input_lines: List[str]) -> List[Tuple[str, int]]: Reads the input and returns a list of tuples containing participant's name and score. Example: >>> read_input(['5', 'Alice 50', 'Bob 75', 'Charlie 75', 'Dave 60', 'Eve 90']) [('Alice', 50), ('Bob', 75), ('Charlie', 75), ('Dave', 60), ('Eve', 90)] def main(input_lines: List[str]) -> List[str]: Reads input lines, generates the leaderboard and returns the sorted participant names. Example: >>> main(['5', 'Alice 50', 'Bob 75', 'Charlie 75', 'Dave 60', 'Eve 90']) ['Eve', 'Bob', 'Charlie', 'Dave', 'Alice'] from typing import List, Tuple import pytest def test_generate_leaderboard(): participants = [ ('Alice', 50), ('Bob', 75), ('Charlie', 75), ('Dave', 60), ('Eve', 90) ] assert generate_leaderboard(participants) == ['Eve', 'Bob', 'Charlie', 'Dave', 'Alice'] def test_read_input(): input_lines = [ '5', 'Alice 50', 'Bob 75', 'Charlie 75', 'Dave 60', 'Eve 90' ] expected_output = [ ('Alice', 50), ('Bob', 75), ('Charlie', 75), ('Dave', 60), ('Eve', 90) ] assert read_input(input_lines) == expected_output def test_main(): input_lines = [ '5', 'Alice 50', 'Bob 75', 'Charlie 75', 'Dave 60', 'Eve 90' ] assert main(input_lines) == ['Eve', 'Bob', 'Charlie', 'Dave', 'Alice'] input_lines = [ '3', 'George 88', 'John 88', 'Paul 92' ] assert main(input_lines) == ['Paul', 'George', 'John'] input_lines = [ '4', 'Anna 77', 'Anna 77', 'John 88', 'Paul 92' ] assert main(input_lines) == ['Paul', 'John', 'Anna', 'Anna'] input_lines = [ '2', 'Bob 0', 'Alice 0' ] assert main(input_lines) == ['Alice', 'Bob'] def test_edge_cases(): input_lines = [ '1', 'Single 100' ] assert main(input_lines) == ['Single'] input_lines = [ '2', 'AAA 500', 'AAA 500' ] assert main(input_lines) == ['AAA', 'AAA']","solution":"def generate_leaderboard(participants): participants.sort(key=lambda x: (-x[1], x[0])) return [participant[0] for participant in participants] def read_input(input_lines): n = int(input_lines[0].strip()) participants = [] for i in range(1, n + 1): data = input_lines[i].strip().split() name = data[0] score = int(data[1]) participants.append((name, score)) return participants def main(input_lines): participants = read_input(input_lines) return generate_leaderboard(participants)"},{"question":"def isRobotBounded(instructions: str) -> bool: Returns True if the robot is bounded within a circle (i.e., it returns to its initial position after executing the instructions), otherwise returns False. >>> isRobotBounded(\\"GGLLGG\\") True >>> isRobotBounded(\\"GG\\") False >>> isRobotBounded(\\"GLGL\\") True >>> isRobotBounded(\\"L\\") True >>> isRobotBounded(\\"GLGLGGL\\") True >>> isRobotBounded(\\"GL\\") True","solution":"def isRobotBounded(instructions): Returns True if the robot is bounded within a circle (i.e., it returns to its initial position after executing the instructions), otherwise returns False. # Possible directions the robot can face directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # north, east, south, west x, y = 0, 0 # initial position direction_index = 0 # initial direction is north for char in instructions: if char == 'G': x += directions[direction_index][0] y += directions[direction_index][1] elif char == 'L': direction_index = (direction_index - 1) % 4 # turn left elif char == 'R': direction_index = (direction_index + 1) % 4 # turn right # The robot is bounded if it returns to the origin or if it ends up facing a different direction return (x == 0 and y == 0) or direction_index != 0"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups the anagrams together in lexicographical order. :param words: List of words to group. :return: List of lists where each sublist is a group of anagrams sorted lexicographically. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"ate\\"]) [['ate', 'eat', 'tea']] >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] >>> group_anagrams([\\"hello\\", \\"world\\"]) [['hello'], ['world']] >>> group_anagrams([\\"test\\"]) [['test']] >>> group_anagrams([\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aa\\"]) [['a'], ['aa'], ['ab', 'ba'], ['b']] >>> group_anagrams([\\"same\\", \\"same\\", \\"same\\"]) [['same', 'same', 'same']]","solution":"from collections import defaultdict def group_anagrams(words): Groups the anagrams together in lexicographical order. :param words: List of words to group. :return: List of lists where each sublist is a group of anagrams sorted lexicographically. anagram_dict = defaultdict(list) for word in words: sorted_word = \\"\\".join(sorted(word)) anagram_dict[sorted_word].append(word) anagram_groups = [] for group in anagram_dict.values(): anagram_groups.append(sorted(group)) anagram_groups.sort(key=lambda x: x[0]) return anagram_groups"},{"question":"def max_sum_of_k_consecutive(N, K, A): Returns the maximum sum of any K consecutive integers in the list A of size N. >>> max_sum_of_k_consecutive(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]) 21 >>> max_sum_of_k_consecutive(5, 2, [-1, -2, -3, -4, -5]) -3 pass def process_test_cases(test_cases): Processes multiple test cases and returns the results. >>> test_cases = [(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]), (5, 2, [-1, -2, -3, -4, -5])] >>> process_test_cases(test_cases) [21, -3] pass def test_max_sum_of_k_consecutive(): assert max_sum_of_k_consecutive(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]) == 21 assert max_sum_of_k_consecutive(5, 2, [-1, -2, -3, -4, -5]) == -3 assert max_sum_of_k_consecutive(6, 2, [3, 5, 2, 1, 8, 10]) == 18 assert max_sum_of_k_consecutive(4, 1, [10, 20, -10, -5]) == 20 assert max_sum_of_k_consecutive(5, 5, [-3, -2, -1, -4, -9]) == -19 def test_process_test_cases(): test_cases = [ (8, 3, [1, 2, 3, 4, 5, 6, 7, 8]), (5, 2, [-1, -2, -3, -4, -5]), (6, 2, [3, 5, 2, 1, 8, 10]) ] expected_results = [ 21, -3, 18 ] assert process_test_cases(test_cases) == expected_results def test_edge_cases(): # Single element list assert max_sum_of_k_consecutive(1, 1, [10]) == 10 # Large K equal to N assert max_sum_of_k_consecutive(3, 3, [1, 2, 3]) == 6 # Mixed positive and negative numbers assert max_sum_of_k_consecutive(7, 3, [-1, 2, 3, -4, 5, -6, 7]) == 6","solution":"def max_sum_of_k_consecutive(N, K, A): Returns the maximum sum of any K consecutive integers in the list A of size N. # Early return for invalid cases if N < K: return None max_sum = current_sum = sum(A[:K]) for i in range(K, N): current_sum += A[i] - A[i - K] max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for N, K, A in test_cases: result = max_sum_of_k_consecutive(N, K, A) results.append(result) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def check_balanced(root: TreeNode) -> bool: Determine if a binary tree is balanced. A binary tree is considered balanced if, for each node in the tree, the depth of the left and right subtrees of that node differ by at most 1. Note: A tree with no nodes is considered balanced. >>> check_balanced(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == True >>> check_balanced(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))) == False >>> check_balanced(None) == True >>> check_balanced(TreeNode(1)) == True >>> check_balanced(TreeNode(1, TreeNode(2), TreeNode(3, right=TreeNode(4)))) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def check_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_balanced = abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return height, left_balanced and right_balanced and current_balanced _, is_balanced = check_height(root) return is_balanced"},{"question":"def minimize_processing_time(jobs): Returns a list of job IDs in the order that minimizes the total processing time. Parameters: jobs (list of tuple): A list of tuples where each tuple contains the job ID and the time required to complete that job. Returns: list: A list of job IDs in the order they should be processed. >>> minimize_processing_time([(1, 3), (2, 1), (3, 2)]) == [2, 3, 1] >>> minimize_processing_time([(1, 5), (2, 3), (3, 5), (4, 2)]) == [4, 2, 1, 3]","solution":"def minimize_processing_time(jobs): Returns a list of job IDs in the order that minimizes the total processing time. Parameters: jobs (list of tuple): A list of tuples where each tuple contains the job ID and the time required to complete that job. Returns: list: A list of job IDs in the order they should be processed. # Sort jobs based on the time required to complete the job sorted_jobs = sorted(jobs, key=lambda x: x[1]) # Extract the job IDs from the sorted jobs job_order = [job[0] for job in sorted_jobs] return job_order"},{"question":"def unique_paths(m: int, n: int) -> int: Find the number of unique paths in an m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(10, 10) 48620 >>> unique_paths(100, 1) 1 >>> unique_paths(3, 3) 6","solution":"def unique_paths(m, n): Returns the number of unique paths in an m x n grid. # Initialize a 2D array with dimensions m x n dp = [[1] * n for _ in range(m)] # Populate the dp array by summing paths from the top and left cells for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def count_letter_frequency(input_string): Counts the frequency of each letter in the input string and returns a dictionary with the letters as keys and the counts as values. The function ignores case and non-alphabetic characters. >>> count_letter_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_letter_frequency(\\"abcdeABCDE\\") {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2} >>> count_letter_frequency(\\"aAa\\") {'a': 3} >>> count_letter_frequency(\\"\\") {} >>> count_letter_frequency(\\"12345!@#%\\") {} >>> count_letter_frequency(\\"The quick brown fox jumps over the lazy dog!\\") {'t': 2, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, 'm': 1, 'p': 1, 's': 1, 'v': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1}","solution":"def count_letter_frequency(input_string): Counts the frequency of each letter in the input string and returns a dictionary with the letters as keys and the counts as values. The function ignores case and non-alphabetic characters. frequency = {} for char in input_string.lower(): if 'a' <= char <= 'z': # Check if char is a letter if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def least_frequent_char(s: str) -> str: Returns the character that appears the least frequently in the string. If there are multiple characters with the same minimal frequency, returns the one that appears first in the string. >>> least_frequent_char(\\"examples\\") 'x' >>> least_frequent_char(\\"sampletest\\") 'a' >>> least_frequent_char(\\"abacabadabacaba\\") 'd'","solution":"def least_frequent_char(s): Returns the character that appears the least frequently in the string. If there are multiple characters with the same minimal frequency, returns the one that appears first in the string. from collections import Counter frequency = Counter(s) min_freq = min(frequency.values()) for char in s: if frequency[char] == min_freq: return char"},{"question":"def find_patterns(sentence: str) -> List[str]: Returns a list of phrases from the sentence that start and end with the same letter. >>> find_patterns(\\"Anna went to see Eve and met Otto\\") ['Anna', 'Eve', 'Otto'] >>> find_patterns(\\"Bob and his dad went to the civic center\\") ['Bob', 'dad', 'civic'] >>> find_patterns(\\"No words qualify here\\") [] pass","solution":"def find_patterns(sentence): Returns a list of phrases from the sentence that start and end with the same letter. words = sentence.split() result = [] for word in words: if len(word) > 1 and word[0].lower() == word[-1].lower(): result.append(word) return result"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the total number of palindromic substrings in S. A palindrome is a string that reads the same forward and backward. For example, \\"racecar\\" and \\"madam\\" are palindromes, but \\"hello\\" and \\"world\\" are not. Args: - S (str): The input string consisting of lowercase English letters. Returns: - int: The number of palindromic substrings in S. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"abcde\\") 5 # Example test cases def test_single_character(): assert count_palindromic_substrings(\\"a\\") == 1 def test_two_different_characters(): assert count_palindromic_substrings(\\"ab\\") == 2 def test_two_same_characters(): assert count_palindromic_substrings(\\"aa\\") == 3 def test_multiple_palindromes(): assert count_palindromic_substrings(\\"ababa\\") == 9 def test_no_palindromes(): assert count_palindromic_substrings(\\"abcde\\") == 5 def test_all_same_characters(): assert count_palindromic_substrings(\\"aaaaa\\") == 15 def test_mixed_characters(): assert count_palindromic_substrings(\\"racecar\\") == 10","solution":"def count_palindromic_substrings(S): Returns the total number of palindromic substrings in S. Args: - S (str): The input string consisting of lowercase English letters. Returns: - int: The number of palindromic substrings in S. n = len(S) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and S[left] == S[right]: count += 1 left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindromes expand_around_center(i, i + 1) # Even length palindromes return count"},{"question":"def evenDigitsOnly(num: int) -> bool: Checks if all digits of the given number are even. Parameters: num (int): A positive integer (1 ≤ num ≤ 10^9). Returns: bool: True if all digits are even, False otherwise. >>> evenDigitsOnly(248622) == True >>> evenDigitsOnly(642386) == False >>> evenDigitsOnly(8) == True >>> evenDigitsOnly(7) == False >>> evenDigitsOnly(0) == True >>> evenDigitsOnly(246824682468) == True >>> evenDigitsOnly(246824682469) == False","solution":"def evenDigitsOnly(num): Checks if all digits of the given number are even. Parameters: num (int): A positive integer. Returns: bool: True if all digits are even, False otherwise. while num > 0: digit = num % 10 if digit % 2 != 0: return False num //= 10 return True"},{"question":"def count_robots(beeps: str) -> int: Count the number of robots based on their beeping pattern. Parameters: beeps (str): A string containing the beeping sounds of robots. Returns: int: The number of robots in the factory. >>> count_robots(\\"BeepBeepBeep\\") 1 >>> count_robots(\\"beepbeepbeep\\") 1 >>> count_robots(\\"BeepBeepBeepbeepbeepbeep\\") 2 >>> count_robots(\\"BeepBeepBeepbeepbeepbeepBeepBeepBeepbeepbeepbeep\\") 4 >>> count_robots(\\"BeepBeepBeepbeepbeepbeepBeepBeepBeep\\") 3 >>> count_robots(\\"\\") 0","solution":"def count_robots(beeps): Count the number of robots based on their beeping pattern. Parameters: beeps (str): A string containing the beeping sounds of robots. Returns: int: The number of robots in the factory. return len(beeps) // len(\\"BeepBeepBeep\\")"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Finds the length of the longest consecutive elements sequence in an unsorted list of integers. Parameters: arr (list of int): The list of integers. Returns: int: The length of the longest consecutive elements sequence. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([36, 41, 56, 35, 42, 44, 33, 34, 92, 43, 99, 98, 101, 100, 102, 97]) 6 >>> longest_consecutive_subsequence([10, 20, 30, 40, 50]) 1 >>> longest_consecutive_subsequence([1]) 1 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence([0, -1, 1, 2, -2, -3]) 6 >>> longest_consecutive_subsequence([8, 4, 7, 5, 9, 1, 2, 3, 6]) 9","solution":"def longest_consecutive_subsequence(arr): Finds the length of the longest consecutive elements sequence in an unsorted list of integers. Parameters: arr (list of int): The list of integers. Returns: int: The length of the longest consecutive elements sequence. if not arr: return 0 num_set = set(arr) max_length = 0 for num in arr: # Check if 'num - 1' is not in set to find the beginning of a sequence if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def calculate_nutritional_value(n: int, fruits: List[Tuple[str, int, float]]) -> float: Compute the total nutritional value of a set of fruits. The nutritional value of a fruit can be calculated using a formula that depends on its type, weight, and ripeness. The formula for the nutritional value is as follows: - For an Apple: nutritional_value = 2 * weight * (ripeness / 100) - For a Banana: nutritional_value = 1.5 * weight * (ripeness / 100) - For a Cherry: nutritional_value = 0.5 * weight * (ripeness / 100) Example: >>> calculate_nutritional_value(3, [(\\"Apple\\", 150, 80.0), (\\"Banana\\", 120, 75.0), (\\"Cherry\\", 200, 50.0)]) 437.50 >>> calculate_nutritional_value(1, [(\\"Banana\\", 120, 75.0)]) 135.0","solution":"def calculate_nutritional_value(n, fruits): total_nutritional_value = 0.0 for fruit in fruits: fruit_type, weight, ripeness = fruit weight = int(weight) ripeness = float(ripeness) if fruit_type == \\"Apple\\": total_nutritional_value += 2 * weight * (ripeness / 100) elif fruit_type == \\"Banana\\": total_nutritional_value += 1.5 * weight * (ripeness / 100) elif fruit_type == \\"Cherry\\": total_nutritional_value += 0.5 * weight * (ripeness / 100) return round(total_nutritional_value, 2)"},{"question":"def max_subarray_sum(nums): Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return that sum. Implement the function such that it has an O(n) time complexity. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5,4,-1,7,8]) == 23 >>> max_subarray_sum([-1,-2,-3,-4]) == -1 def test_max_subarray_sum_example(): assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 def test_max_subarray_sum_single_element(): assert max_subarray_sum([1]) == 1 def test_max_subarray_sum_all_positive(): assert max_subarray_sum([5,4,-1,7,8]) == 23 def test_max_subarray_sum_all_negative(): assert max_subarray_sum([-1,-2,-3,-4]) == -1 def test_max_subarray_sum_mixed_elements(): assert max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10 assert max_subarray_sum([4, -1, 2, 1]) == 6 def test_max_subarray_sum_large_input(): large_input = [-2] + [1]*1000000 + [-2] assert max_subarray_sum(large_input) == 1000000 def test_max_subarray_sum_edge_cases(): assert max_subarray_sum([]) == 0 assert max_subarray_sum([0, 0, 0, 0]) == 0 assert max_subarray_sum([1, -1, 1, -1, 1, -1, 1]) == 1","solution":"def max_subarray_sum(nums): Implement the function to find the maximum sum of a contiguous subarray. if not nums: return 0 max_ending_here = max_so_far = nums[0] for x in nums[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def isSubsetSum(lst: List[int], k: int, t: int) -> bool: Determines if there exists a subset of the list of exactly \`k\` elements that sum up to \`t\`. Args: lst (List[int]): The list of integers. k (int): The number of elements in the subset. t (int): The target sum. Returns: bool: True if such a subset exists, otherwise False. >>> isSubsetSum([1, 2, 3, 4, 5], 2, 5) True >>> isSubsetSum([1, -1, 2, 4], 2, 3) True >>> isSubsetSum([1, 2, 3], 2, 8) False >>> isSubsetSum([], 0, 0) True","solution":"from itertools import combinations from typing import List def isSubsetSum(lst: List[int], k: int, t: int) -> bool: Determines if there exists a subset of the list of exactly \`k\` elements that sum up to \`t\`. Args: lst (List[int]): The list of integers. k (int): The number of elements in the subset. t (int): The target sum. Returns: bool: True if such a subset exists, otherwise False. # Generate all combinations of \`k\` elements from list \`lst\` for subset in combinations(lst, k): # Check if the sum of this combination equals the target sum \`t\` if sum(subset) == t: return True return False"},{"question":"from typing import List, Dict, Tuple def min_moves(t: int, test_cases: List[Dict[str, Tuple[int, int]]]) -> List[int]: Determine the minimum number of moves required for the truck to reach the target position from the starting position, or determine that it is impossible to reach the target. Args: t (int): Number of test cases test_cases (List[Dict]): List of test cases with dimensions, grid, start, and target Returns: List[int]: List of results for each test case >>> min_moves(2, [{'dimensions': (5, 5), 'grid': ['.....', '..#..', '..#..', '.....', '.....'], 'start': (2, 2), 'target': (4, 4)}, {'dimensions': (5, 5), 'grid': ['.....', '..#..', '..#..', '.....', '.....'], 'start': (0, 0), 'target': (4, 4)}]) [4, 8] >>> min_moves(1, [{'dimensions': (3, 3), 'grid': ['#', '#.#', '#'], 'start': (1, 1), 'target': (2, 2)}]) [-1] >>> min_moves(1, [{'dimensions': (3, 3), 'grid': ['...', '...', '...'], 'start': (1, 1), 'target': (1, 1)}]) [0] >>> min_moves(2, [{'dimensions': (3, 3), 'grid': ['...', '#..', '...'], 'start': (0, 0), 'target': (2, 2)}, {'dimensions': (3, 3), 'grid': ['...', '#', '...'], 'start': (0, 0), 'target': (2, 2)}]) [4, -1]","solution":"from collections import deque def min_moves(t, test_cases): results = [] for idx in range(t): N, M = test_cases[idx]['dimensions'] grid = test_cases[idx]['grid'] startX, startY = test_cases[idx]['start'] targetX, targetY = test_cases[idx]['target'] # Breadth-First Search (BFS) for shortest path moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(startX, startY, 0)]) visited = set([(startX, startY)]) while queue: x, y, dist = queue.popleft() if (x, y) == (targetX, targetY): results.append(dist) break for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) else: # If loop completes without breaking, target is unreachable results.append(-1) return results # Example usage: # t = 2 # test_cases = [ # { # 'dimensions': (5, 5), # 'grid': [ # \\".....\\", # \\"..#..\\", # \\"..#..\\", # \\".....\\", # \\".....\\", # ], # 'start': (2, 2), # 'target': (4, 4) # }, # { # 'dimensions': (5, 5), # 'grid': [ # \\".....\\", # \\"..#..\\", # \\"..#..\\", # \\".....\\", # \\".....\\", # ], # 'start': (0, 0), # 'target': (4, 4) # } # ] # print(min_moves(t, test_cases)) # Output: [4, 8]"},{"question":"def sorted_string(s: str) -> str: Returns a new string where the characters are sorted in the following order: 1. All uppercase letters in alphabetical order. 2. All lowercase letters in alphabetical order. 3. All digits in numerical order. pass def test_sorted_string_uppercase(): assert sorted_string(\\"CBA\\") == \\"ABC\\" assert sorted_string(\\"BAC\\") == \\"ABC\\" def test_sorted_string_lowercase(): assert sorted_string(\\"cba\\") == \\"abc\\" assert sorted_string(\\"bca\\") == \\"abc\\" def test_sorted_string_digits(): assert sorted_string(\\"321\\") == \\"123\\" assert sorted_string(\\"213\\") == \\"123\\" def test_sorted_string_mixed(): assert sorted_string(\\"aA1bB2cC3\\") == \\"ABCabc123\\" assert sorted_string(\\"bB3aA2cC1\\") == \\"ABCabc123\\" def test_sorted_string_empty(): assert sorted_string(\\"\\") == \\"\\" def test_sorted_string_no_uppercase(): assert sorted_string(\\"cba321\\") == \\"abc123\\" def test_sorted_string_no_lowercase(): assert sorted_string(\\"CBA321\\") == \\"ABC123\\" def test_sorted_string_no_digits(): assert sorted_string(\\"cbaCBA\\") == \\"ABCabc\\"","solution":"def sorted_string(s): Returns a new string where the characters are sorted in the following order: 1. All uppercase letters in alphabetical order. 2. All lowercase letters in alphabetical order. 3. All digits in numerical order. upper_case = sorted([ch for ch in s if ch.isupper()]) lower_case = sorted([ch for ch in s if ch.islower()]) digits = sorted([ch for ch in s if ch.isdigit()]) return ''.join(upper_case + lower_case + digits)"},{"question":"def generate_feature_walls(T, cases): Generate feature walls for the exhibitionist based on given test cases. Args: T: int, Number of test cases. cases: List of int, Each integer N indicating the size of the feature wall matrix. Returns: result: List of List of str, Where each internal list represents a feature wall. Example: >>> generate_feature_walls(3, [2, 3, 4]) [['1', '1 2'], ['1', '1 2', '1 2 3'], ['1', '1 2', '1 2 3', '1 2 3 4']] result = [] for N in cases: wall = [] for i in range(1, N + 1): wall.append(' '.join(str(x) for x in range(1, i + 1))) result.append(wall) return result def format_walls(walls): Format the feature walls into a single string for output. Args: walls: List of List of str, Where each internal list represents a feature wall. Returns: formatted_output: str, The formatted walls as a single multi-line string. Example: >>> walls = [['1', '1 2'], ['1', '1 2', '1 2 3'], ['1', '1 2', '1 2 3', '1 2 3 4']] >>> format_walls(walls) \\"1n1 2n1n1 2n1 2 3n1n1 2n1 2 3n1 2 3 4\\" formatted_output = \\"\\" for wall in walls: formatted_output += 'n'.join(wall) + 'n' return formatted_output.rstrip('n')","solution":"def generate_feature_walls(T, cases): result = [] for N in cases: wall = [] for i in range(1, N + 1): wall.append(' '.join(str(x) for x in range(1, i + 1))) result.append(wall) return result def format_walls(walls): formatted_output = \\"\\" for wall in walls: formatted_output += 'n'.join(wall) + 'n' return formatted_output.rstrip('n')"},{"question":"def decipher_clue(clue: Any) -> str: Deciphers the given encrypted clue by shifting each letter one position back in the alphabet. Non-alphabetic characters remain unchanged. Returns \\"Invalid input\\" if the input is not a string. :param clue: The encrypted clue as an input. :return: The original message as a string or \\"Invalid input\\" if the input is not a string. >>> decipher_clue(\\"bcd\\") 'abc' >>> decipher_clue(\\"BCD\\") 'ABC' >>> decipher_clue(\\"b d!\\") 'a c!' >>> decipher_clue(\\"a z\\") 'z y' >>> decipher_clue(\\"123\\") '123' >>> decipher_clue(\\"!@#\\") '!@#' >>> decipher_clue(\\"\\") '' >>> decipher_clue(None) 'Invalid input' >>> decipher_clue(12345) 'Invalid input' >>> decipher_clue([]) 'Invalid input' >>> decipher_clue(\\"cD\\") 'bC'","solution":"def decipher_clue(clue): Deciphers the given encrypted clue by shifting each letter one position back in the alphabet. Non-alphabetic characters remain unchanged. :param clue: The encrypted clue string. :return: The original message as a string or \\"Invalid input\\" if the input is not a string. if not isinstance(clue, str): return \\"Invalid input\\" deciphered_message = [] for char in clue: if 'a' <= char <= 'z': deciphered_message.append(chr((ord(char) - ord('a') - 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': deciphered_message.append(chr((ord(char) - ord('A') - 1) % 26 + ord('A'))) else: deciphered_message.append(char) return ''.join(deciphered_message)"},{"question":"def fibonacci(n: int) -> List[int]: Generate a list of Fibonacci numbers up to the nth term. Args: n (int): The number of terms in the Fibonacci sequence to generate. Returns: List[int]: A list of the first n Fibonacci numbers. >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n Fibonacci numbers. if n == 0: return [] elif n == 1: return [0] sequence = [0, 1] for i in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"def convert_to_seconds(time_str: str) -> int: Converts a time duration string in the format \\"hh:mm:ss\\" to total seconds. >>> convert_to_seconds(\\"00:00:45\\") 45 >>> convert_to_seconds(\\"01:00:00\\") 3600 >>> convert_to_seconds(\\"03:07:15\\") 11235 >>> convert_to_seconds(\\"00:00:05\\") 5 >>> convert_to_seconds(\\"00:09:10\\") 550 >>> convert_to_seconds(\\"01:59:59\\") 7199 >>> convert_to_seconds(\\"10:10:10\\") 36610 >>> convert_to_seconds(\\"00:00:00\\") 0 >>> convert_to_seconds(\\"99:59:59\\") 359999 pass","solution":"def convert_to_seconds(time_str: str) -> int: Converts a time duration string in the format \\"hh:mm:ss\\" to total seconds. hours, minutes, seconds = map(int, time_str.split(':')) total_seconds = hours * 3600 + minutes * 60 + seconds return total_seconds"},{"question":"def group_by_owners(input_data: dict) -> dict: Takes a dictionary where keys are filenames and values are owners' names, and returns a dictionary where keys are owners' names and values are lists of filenames they own. >>> group_by_owners({'file1.txt': 'Alice', 'file2.txt': 'Bob', 'file3.txt': 'Alice'}) {'Alice': ['file1.txt', 'file3.txt'], 'Bob': ['file2.txt']} >>> group_by_owners({'file1.txt': 'Alice'}) {'Alice': ['file1.txt']} >>> group_by_owners({'file1.txt': 'Alice', 'file2.txt': 'Bob', 'file3.txt': 'Cathy', 'file4.txt': 'Bob'}) {'Alice': ['file1.txt'], 'Bob': ['file2.txt', 'file4.txt'], 'Cathy': ['file3.txt']} >>> group_by_owners({}) {} >>> group_by_owners({'file1.txt': 'Alice', 'file2.txt': 'Alice', 'file3.txt': 'Alice', 'file4.txt': 'Alice'}) {'Alice': ['file1.txt', 'file2.txt', 'file3.txt', 'file4.txt']}","solution":"def group_by_owners(input_data): Takes a dictionary where keys are filenames and values are owners' names, and returns a dictionary where keys are owners' names and values are lists of filenames they own. :param input_data: dict, filenames as keys and owners' names as values :return: dict, owners' names as keys and lists of filenames as values output_data = {} for filename, owner in input_data.items(): if owner not in output_data: output_data[owner] = [] output_data[owner].append(filename) return output_data"},{"question":"from typing import List def findWords(words: List[str]) -> List[str]: Returns words that can be typed using letters from only one row of an American QWERTY keyboard. >>> findWords([\\"Hello\\", \\"Peace\\"]) [] >>> findWords([\\"Alaska\\", \\"Dad\\"]) [\\"Alaska\\", \\"Dad\\"] >>> findWords([\\"Hello\\", \\"Alaska\\", \\"dAd\\", \\"Peace\\"]) [\\"Alaska\\", \\"dAd\\"] >>> findWords([]) [] >>> findWords([\\"a\\", \\"s\\", \\"q\\", \\"z\\", \\"Q\\"]) [\\"a\\", \\"s\\", \\"q\\", \\"z\\", \\"Q\\"] >>> findWords([\\"123\\", \\"!@#\\", \\"Alaska\\"]) [\\"Alaska\\"] >>> findWords([\\"Aaa\\", \\"Dad\\", \\"qee\\"]) [\\"Aaa\\", \\"Dad\\", \\"qee\\"]","solution":"def findWords(words): Returns words that can be typed using letters from only one row of an American QWERTY keyboard. first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word): lower_word = set(word.lower()) return lower_word.issubset(first_row) or lower_word.issubset(second_row) or lower_word.issubset(third_row) return [word for word in words if can_be_typed_with_one_row(word)]"},{"question":"def number_of_nodes(d: int) -> int: Returns the total number of nodes in a full binary tree of depth d. A full binary tree of depth d has 2^(d+1) - 1 nodes. >>> number_of_nodes(0) 1 >>> number_of_nodes(1) 3 >>> number_of_nodes(2) 7 >>> number_of_nodes(3) 15 >>> number_of_nodes(30) 2147483647 >>> number_of_nodes(5) 63 >>> number_of_nodes(10) 2047 >>> number_of_nodes(20) 2097151","solution":"def number_of_nodes(d): Returns the total number of nodes in a full binary tree of depth d. A full binary tree of depth d has 2^(d+1) - 1 nodes. return (2 ** (d + 1)) - 1"},{"question":"def max_cookies(N: int, M: int, available_ingredients: List[int], cookies_info: List[List[int]]) -> int: Determine the maximum number of different types of cookies that can be baked. Args: N (int): The number of available ingredients. M (int): The number of different types of cookies. available_ingredients (List[int]): The quantity of each ingredient available. cookies_info (List[List[int]]): List of ingredients required for each type of cookie. Returns: int: The maximum number of different types of cookies that can be baked given the available ingredients. >>> max_cookies(4, 3, [10, 5, 6, 8], [[2, 1, 3, 2, 2], [3, 1, 2, 3, 1, 4, 2], [2, 2, 4, 4, 1]]) 2 >>> max_cookies(3, 2, [5, 4, 3], [[2, 1, 2, 2, 3], [2, 1, 6, 2, 2]]) 1 >>> max_cookies(2, 1, [1, 2], [[2, 1, 2, 2, 2]]) 0 def solve_baking_problem(input_str: str) -> int: Parse the input string and determine the maximum number of different types of cookies that can be baked. Args: input_str (str): The input data as a single string. Returns: int: The maximum number of different types of cookies that can be baked. >>> input_data = \\"4 3n10 5 6 8n2 1 3 2 2n3 1 2 3 1 4 2n2 2 4 4 1n\\" >>> solve_baking_problem(input_data) 2 >>> input_data = \\"3 2n5 4 3n2 1 2 2 3n2 1 6 2 2n\\" >>> solve_baking_problem(input_data) 1 >>> input_data = \\"2 1n1 2n2 1 2 2 2n\\" >>> solve_baking_problem(input_data) 0","solution":"def max_cookies(N, M, available_ingredients, cookies_info): count = 0 for cookie in cookies_info: can_bake = True for i in range(0, len(cookie), 2): ingredient_index = cookie[i] - 1 # Convert to 0-based index required_quantity = cookie[i + 1] if available_ingredients[ingredient_index] < required_quantity: can_bake = False break if can_bake: count += 1 for i in range(0, len(cookie), 2): ingredient_index = cookie[i] - 1 # Convert to 0-based index required_quantity = cookie[i + 1] available_ingredients[ingredient_index] -= required_quantity return count # Function to read input and call the max_cookies function def solve_baking_problem(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) available_ingredients = list(map(int, lines[1].split())) cookies_info = [] line_idx = 2 for _ in range(M): cookie_ingredients = list(map(int, lines[line_idx].split()))[1:] cookies_info.append(cookie_ingredients) line_idx += 1 return max_cookies(N, M, available_ingredients, cookies_info)"},{"question":"def max_movies(durations: List[int], t: int) -> int: Returns the maximum number of movies that can be watched without exceeding time t. >>> max_movies([100, 50, 120, 90], 180) == 2 >>> max_movies([200, 250, 300], 180) == 0 >>> max_movies([200, 180], 180) == 1 >>> max_movies([60, 60, 60], 180) == 3 >>> max_movies([30, 90, 150, 70, 120], 240) == 3 >>> max_movies([], 100) == 0 >>> max_movies([90], 90) == 1","solution":"def max_movies(durations, t): Returns the maximum number of movies that can be watched without exceeding time t. durations.sort() count = 0 total_time = 0 for duration in durations: if total_time + duration <= t: total_time += duration count += 1 else: break return count"},{"question":"def generateParentheses(n): Generates all combinations of well-formed parentheses for n pairs of parentheses. Returns an alphabetically sorted list of valid strings. >>> generateParentheses(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generateParentheses(1) ['()'] >>> generateParentheses(0) [] >>> generateParentheses(-2) [] >>> generateParentheses(\\"3\\") [] pass","solution":"def generateParentheses(n): Generates all combinations of well-formed parentheses for n pairs of parentheses. Returns an alphabetically sorted list of valid strings. if not isinstance(n, int) or n < 1: return [] result = [] def backtrack(current_str, open_count, close_count): if len(current_str) == 2 * n: result.append(current_str) return if open_count < n: backtrack(current_str + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current_str + \\")\\", open_count, close_count + 1) backtrack(\\"\\", 0, 0) return sorted(result)"},{"question":"def find_single_number(arr): Given a list of integers where all elements appear twice except for one element which appears once, this function returns that single element. def process_test_cases(t, test_cases): Processes multiple test cases and returns a list of results. t : int : Number of test cases test_cases : list of tuples : Each tuple contains an integer N and a list of N integers. Returns: list : List of results for each test case. # Test cases def test_find_single_number(): assert find_single_number([4, 3, 2, 4, 2]) == 3 assert find_single_number([7, 3, 7]) == 3 assert find_single_number([1, 1, 2, 2, 3]) == 3 assert find_single_number([0, 2, 2]) == 0 assert find_single_number([10, 14, 14, 0, 0, 10, 5]) == 5 def test_process_test_cases(): assert process_test_cases(2, [(5, [4, 3, 2, 4, 2]), (3, [7, 3, 7])]) == [3, 3] assert process_test_cases(1, [(3, [1, 2, 1])]) == [2] assert process_test_cases(3, [(5, [1, 1, 2, 2, 3]), (3, [10, 14, 14]), (7, [7, 8, 7, 8, 0, 0, 9])]) == [3, 10, 9] assert process_test_cases(2, [(4, [1, 1, 2, 3, 2]), (3, [4, 5, 5, 4, 6])]) == [3, 6]","solution":"def find_single_number(arr): Given a list of integers where all elements appear twice except for one element which appears once, this function returns that single element. unique_num = 0 for num in arr: unique_num ^= num return unique_num def process_test_cases(t, test_cases): results = [] for i in range(t): N = test_cases[i][0] arr = test_cases[i][1] results.append(find_single_number(arr)) return results"},{"question":"def parse_input(input_text): Parse the input text and convert it into a list of test cases. >>> parse_input(\\"1n4 1n3 1 4 2\\") [{'N': 4, 'K': 1, 'A': [3, 1, 4, 2]}] lines = input_text.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, K = map(int, lines[index].split()) A = list(map(int, lines[index + 1].split())) test_cases.append({'N': N, 'K': K, 'A': A}) index += 2 return test_cases def count_well_balanced_subarrays(test_cases): Count the number of well-balanced subarrays for each test case. >>> count_well_balanced_subarrays([{'N': 4, 'K': 1, 'A': [3, 1, 4, 2]}]) [4] results = [] for case in test_cases: N, K, A = case['N'], case['K'], case['A'] count = 0 for start in range(N): min_height = A[start] max_height = A[start] for end in range(start, N): min_height = min(min_height, A[end]) max_height = max(max_height, A[end]) if max_height - min_height <= K: count += 1 else: break results.append(count) return results def test_example_case(): input_text = 1 4 1 3 1 4 2 test_cases = parse_input(input_text) results = count_well_balanced_subarrays(test_cases) assert results == [4] def test_single_element_case(): input_text = 1 5 0 1 1 1 1 1 test_cases = parse_input(input_text) results = count_well_balanced_subarrays(test_cases) assert results == [15] def test_case_no_well_balanced_subarrays(): input_text = 1 3 0 1 3 2 test_cases = parse_input(input_text) results = count_well_balanced_subarrays(test_cases) assert results == [3] def test_case_large_k(): input_text = 1 4 10 7 3 2 6 test_cases = parse_input(input_text) results = count_well_balanced_subarrays(test_cases) assert results == [10] def test_multiple_cases(): input_text = 2 4 1 3 1 4 2 3 2 1 2 1 test_cases = parse_input(input_text) results = count_well_balanced_subarrays(test_cases) assert results == [4, 6] def run_tests(): test_example_case() test_single_element_case() test_case_no_well_balanced_subarrays() test_case_large_k() test_multiple_cases() print(\\"All tests passed!\\") run_tests()","solution":"def count_well_balanced_subarrays(test_cases): results = [] for case in test_cases: N, K, A = case['N'], case['K'], case['A'] count = 0 for start in range(N): min_height = A[start] max_height = A[start] for end in range(start, N): min_height = min(min_height, A[end]) max_height = max(max_height, A[end]) if max_height - min_height <= K: count += 1 else: break results.append(count) return results # Input parsing function def parse_input(input_text): lines = input_text.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, K = map(int, lines[index].split()) A = list(map(int, lines[index + 1].split())) test_cases.append({'N': N, 'K': K, 'A': A}) index += 2 return test_cases # Example usage input_text = 1 4 1 3 1 4 2 test_cases = parse_input(input_text) results = count_well_balanced_subarrays(test_cases) for result in results: print(result)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, addition, and multiplication, following the proper order of operations. Returns the result as an integer or \\"Invalid expression!\\" if the expression is incorrectly formatted or contains invalid characters. >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"3*4+5\\") 17 >>> evaluate_expression(\\"10+20*30+40\\") 650 >>> evaluate_expression(\\"8*3+12*3\\") 60 >>> evaluate_expression(\\"5++2\\") \\"Invalid expression!\\" >>> evaluate_expression(\\"5*2*2\\") 20 >>> evaluate_expression(\\"\\") \\"Invalid expression!\\" >>> evaluate_expression(\\"7+7*\\") \\"Invalid expression!\\"","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, addition, and multiplication, following the proper order of operations. Returns the result as an integer or \\"Invalid expression!\\" if the expression is incorrectly formatted or contains invalid characters. try: # Check for any invalid characters if not all(c.isdigit() or c in '+*' for c in expression): return \\"Invalid expression!\\" # Check for consecutive operators or expression starting/ending with operator if expression.endswith('+') or expression.endswith('*') or '+*' in expression or '*+' in expression: return \\"Invalid expression!\\" # Split the expression by '+' and evaluate each part separately to handle multiplication first parts = expression.split('+') evaluated_parts = [] for part in parts: if '*' in part: # if there is multiplication subparts = list(map(int, part.split('*'))) result = 1 for subpart in subparts: result *= subpart evaluated_parts.append(result) else: # no multiplication, just a number evaluated_parts.append(int(part)) # Calculate the final result by summing evaluated parts final_result = sum(evaluated_parts) return final_result except Exception: return \\"Invalid expression!\\""},{"question":"from typing import List def jump_game(nums: List[int]) -> bool: Determines if you are able to reach the last index given an array of non-negative integers representing your maximum jump length at that position. Args: nums (List[int]): Array of non-negative integers representing maximum jump lengths. Returns: bool: True if you can reach the last index, False otherwise. >>> jump_game([2, 3, 1, 1, 4]) True >>> jump_game([3, 2, 1, 0, 4]) False pass def test_jump_game_reachable(): assert jump_game([2, 3, 1, 1, 4]) == True assert jump_game([2, 0, 2, 0, 1]) == True def test_jump_game_unreachable(): assert jump_game([3, 2, 1, 0, 4]) == False assert jump_game([0, 2, 3]) == False def test_jump_game_single_element(): assert jump_game([0]) == True def test_jump_game_edge_cases(): assert jump_game([1, 2, 3, 0, 1]) == True assert jump_game([2, 5, 0, 0]) == True assert jump_game([5, 0, 0, 0, 0, 0]) == True assert jump_game([1, 1, 1, 1, 1]) == True def test_jump_game_empty_array(): assert jump_game([]) == False","solution":"def jump_game(nums): Determines if you are able to reach the last index given an array of non-negative integers representing your maximum jump length at that position. Args: nums (List[int]): Array of non-negative integers representing maximum jump lengths. Returns: bool: True if you can reach the last index, False otherwise. max_reach = 0 last_index = len(nums) - 1 for i, jump in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + jump) if max_reach >= last_index: return True return False"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverses each word in a sentence while maintaining the original order of the words. >>> reverse_words_in_sentence(\\"hello world\\") 'olleh dlrow' >>> reverse_words_in_sentence(\\"encryption is important\\") 'noitpyrcne si tnatropmi' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the output for each. >>> process_test_cases(2, [\\"hello world\\", \\"encryption is important\\"]) ['olleh dlrow', 'noitpyrcne si tnatropmi'] >>> process_test_cases(1, [\\"a\\"*1000]) ['a'*1000] pass def test_reverse_words_single_word(): assert reverse_words_in_sentence(\\"hello\\") == \\"olleh\\" def test_reverse_words_two_words(): assert reverse_words_in_sentence(\\"hello world\\") == \\"olleh dlrow\\" def test_reverse_words_multiple_words(): assert reverse_words_in_sentence(\\"encryption is important\\") == \\"noitpyrcne si tnatropmi\\" def test_reverse_words_with_spaces(): assert reverse_words_in_sentence(\\" hello world \\") == \\"olleh dlrow\\" def test_process_test_cases_single_case(): assert process_test_cases(1, [\\"hello world\\"]) == [\\"olleh dlrow\\"] def test_process_test_cases_multiple_cases(): assert process_test_cases(2, [\\"hello world\\", \\"encryption is important\\"]) == [\\"olleh dlrow\\", \\"noitpyrcne si tnatropmi\\"] def test_process_test_cases_with_edge_case(): assert process_test_cases(1, [\\"a\\"*1000]) == [\\"a\\"*1000]","solution":"def reverse_words_in_sentence(sentence): Reverses each word in a sentence while maintaining the original order of the words. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words) def process_test_cases(T, test_cases): Processes multiple test cases and returns the output for each. results = [] for i in range(T): encrypted_sentence = reverse_words_in_sentence(test_cases[i]) results.append(encrypted_sentence) return results"},{"question":"def generate_diamond(n: int) -> str: Generate a diamond pattern using asterisks with 2n-1 rows in total. >>> generate_diamond(3) \\" * n * * n* * *n * * n * \\" >>> generate_diamond(5) \\" * n * * n * * * n * * * * n* * * * *n * * * * n * * * n * * n * \\" >>> generate_diamond(1) \\"*\\" >>> generate_diamond(0) \\"\\" >>> generate_diamond(-1) \\"\\"","solution":"def generate_diamond(n): if n <= 0: return \\"\\" diamond = [] for i in range(1, n+1): stars = ' '.join('*' * i) spaces = ' ' * (n - i) diamond.append(spaces + stars + spaces) for i in range(n-1, 0, -1): stars = ' '.join('*' * i) spaces = ' ' * (n - i) diamond.append(spaces + stars + spaces) return 'n'.join(diamond)"},{"question":"def isValidString(s: str) -> bool: Determine if the given string is valid based on the following criteria: - No consecutive 'b's - No more than two 'a's in a row Args: s (str): The input string containing only characters 'a' and 'b'. Returns: bool: True if the string is valid, False otherwise. Examples: >>> isValidString('aa') True >>> isValidString('aab') True >>> isValidString('aaa') False >>> isValidString('bba') False from solution import isValidString def test_no_consecutive_bs(): assert isValidString('ab') == True assert isValidString('aab') == True assert isValidString('bb') == False def test_no_more_than_two_as_in_a_row(): assert isValidString('aa') == True assert isValidString('aaa') == False def test_mixed_cases(): assert isValidString('aaba') == True assert isValidString('aabb') == False assert isValidString('baabaa') == True assert isValidString('baaaaa') == False def test_empty_and_single_char_strings(): assert isValidString('') == True assert isValidString('a') == True assert isValidString('b') == True def test_edge_cases(): assert isValidString('ababababa') == True assert isValidString('aabbaa') == False assert isValidString('aabbaaab') == False assert isValidString('baaabaaa') == False","solution":"def isValidString(s): Returns True if the string \`s\` is valid according to the specified rules: - No consecutive 'b's - No more than two 'a's in a row Otherwise, returns False. a_count = 0 for i in range(len(s)): if s[i] == 'a': a_count += 1 if a_count > 2: return False else: a_count = 0 if i > 0 and s[i - 1] == 'b': return False return True"},{"question":"def perform_operations(operations: list[tuple[int, int]]) -> list[int]: Performs the list operations as specified and returns results for type 2 operations. Args: operations (list of tuples): A list of tuples where each tuple represents an operation. Each tuple can be either (1, X) for adding integer X to the list or (2, Y) for removing all occurrences of integer Y from the list. Returns: list of int: A list containing the number of elements removed for each type 2 operation. >>> perform_operations([(1, 3)]) [] >>> perform_operations([(1, 3), (2, 3)]) [1] >>> perform_operations([(1, 3), (1, 3), (1, 5), (2, 3), (2, 5)]) [2, 1] >>> perform_operations([(1, 4), (1, 4), (2, 3)]) [0] >>> perform_operations([ (1, 3), (1, 4), (1, 5), (1, 3), (1, 6), (2, 3), (2, 7), (2, 5) ]) [2, 0, 1] >>> perform_operations([ (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9) ]) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]","solution":"def perform_operations(operations): Performs the list operations as specified and returns results for type 2 operations. Args: operations (list of tuples): A list of tuples where each tuple represents an operation. Each tuple can be either (1, X) for adding integer X to the list or (2, Y) for removing all occurrences of integer Y from the list. Returns: list of int: A list containing the number of elements removed for each type 2 operation. lst = [] removal_counts = [] for operation in operations: if operation[0] == 1: lst.append(operation[1]) elif operation[0] == 2: value_to_remove = operation[1] initial_length = len(lst) lst = [x for x in lst if x != value_to_remove] removed_count = initial_length - len(lst) removal_counts.append(removed_count) return removal_counts"},{"question":"def find_shortest_vowel_word(words: List[str]) -> str: Finds the shortest word in the list which contains all the vowels ('a', 'e', 'i', 'o', 'u'). If no such word exists, returns an empty string. >>> find_shortest_vowel_word([\\"education\\", \\"intellectual\\", \\"abstemious\\", \\"pseudohypoparathyroidism\\"]) == \\"education\\" >>> find_shortest_vowel_word([\\"EducAtion\\", \\"Intellectual\\", \\"AbstEmious\\", \\"Pseudohypoparathyroidism\\"]) == \\"EducAtion\\" >>> find_shortest_vowel_word([\\"EdUcation\\", \\"IntEllectual\\", \\"AbstemiOus\\", \\"Pseudohypoparathyroidism\\"]) == \\"EdUcation\\" >>> find_shortest_vowel_word([\\"hello\\", \\"world\\", \\"python\\", \\"rocks\\"]) == \\"\\" >>> find_shortest_vowel_word([\\"Aeiou\\"]) == \\"Aeiou\\" >>> find_shortest_vowel_word([\\"education\\", \\"alphabetism\\", \\"abstemious\\"]) == \\"education\\" >>> find_shortest_vowel_word([\\"education\\", \\"education\\", \\"abstemious\\"]) == \\"education\\"","solution":"def find_shortest_vowel_word(words): Finds the shortest word in the list which contains all the vowels ('a', 'e', 'i', 'o', 'u'). If no such word exists, returns an empty string. Parameters: words (list): A list of strings. Returns: str: The shortest word containing all the vowels or an empty string if no such word exists. vowels = set(\\"aeiou\\") shortest_word = \\"\\" for word in words: lower_word = word.lower() # convert to lowercase for uniformity if vowels.issubset(set(lower_word)): # check if all vowels are in the word if shortest_word == \\"\\" or len(word) < len(shortest_word): shortest_word = word return shortest_word"},{"question":"MOD = int(1e9 + 7) def process_queries(arr, queries): Process the queries and return the sum of maximum values for each subarray. >>> process_queries([1, 5, 3, 7, 2], [(1, 3), (2, 4), (1, 5)]) [5, 7, 7] >>> process_queries([2, 3, 1, 2, 5], [(1, 5), (3, 5)]) [5, 5] results = [] for (L, R) in queries: max_val = max(arr[L-1:R]) # We adjust for 1-indexed bounds results.append(max_val % MOD) return results def solve(T, test_cases): Solve the problem given T test cases. >>> solve(1, [((5, 3), [1, 5, 3, 7, 2], [(1, 3), (2, 4), (1, 5)])]) [[5, 7, 7]] >>> solve(1, [((5, 2), [2, 3, 1, 2, 5], [(1, 5), (3, 5)])]) [[5, 5]] result = [] for i in range(T): N, Q = test_cases[i][0] arr = test_cases[i][1] queries = test_cases[i][2] results = process_queries(arr, queries) result.append(results) return result","solution":"MOD = int(1e9 + 7) def process_queries(arr, queries): results = [] for (L, R) in queries: max_val = max(arr[L-1:R]) # We adjust for 1-indexed bounds results.append(max_val % MOD) return results def solve(T, test_cases): result = [] for i in range(T): N, Q = test_cases[i][0] arr = test_cases[i][1] queries = test_cases[i][2] results = process_queries(arr, queries) result.append(results) return result"},{"question":"def longest_substring_with_two_distinct(s: str) -> int: Returns the length of the longest substring of s that contains no more than two distinct characters. >>> longest_substring_with_two_distinct(\\"eceba\\") 3 >>> longest_substring_with_two_distinct(\\"ccaabbb\\") 5","solution":"def longest_substring_with_two_distinct(s): Returns the length of the longest substring of s that contains no more than two distinct characters. if not s: return 0 start, max_len = 0, 0 char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def max_profit(prices: List[int]) -> int: Determine the maximum possible profit from a single buy and sell operation. Given a list of prices, returns the maximum profit obtainable from a single buy and sell operation. If no profit is possible, returns 0. Args: prices: List of integers representing stock prices in chronological order. Returns: Integer representing the maximum profit, or 0 if no profit is possible. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0","solution":"def max_profit(prices): Given a list of prices, returns the maximum profit obtainable from a single buy and sell operation. If no profit is possible, returns 0. if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def rotate_list(elements, n): Rotate list elements to the right by \`n\` places. Args: elements (list): The list of elements to rotate. n (int): The number of places to rotate the list elements by. Returns: list: A new list with elements rotated to the right by \`n\` places. >>> rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] >>> rotate_list([1], 3) == [1] >>> rotate_list([], 3) == [] >>> rotate_list([1, 2, 3, 4, 5], 12) == [4, 5, 1, 2, 3]","solution":"def rotate_list(elements, n): Rotate list elements to the right by \`n\` places. Args: elements (list): The list of elements to rotate. n (int): The number of places to rotate the list elements by. Returns: list: A new list with elements rotated to the right by \`n\` places. if not elements: return elements n = n % len(elements) # Handle rotation greater than the length of the list return elements[-n:] + elements[:-n]"},{"question":"from typing import List, Dict def most_copies(inventory: List[Dict[str, str]]) -> str: Returns the title of the book with the highest number of copies in stock. If there is a tie, return the title that comes first alphabetically. Examples: >>> most_copies([ ... {'title': 'Book A', 'author': 'Author X', 'copies': 4}, ... {'title': 'Book B', 'author': 'Author Y', 'copies': 2}, ... {'title': 'Book C', 'author': 'Author Z', 'copies': 6} ... ]) 'Book C' >>> most_copies([ ... {'title': 'Book A', 'author': 'Author X', 'copies': 5}, ... {'title': 'Book B', 'author': 'Author Y', 'copies': 5}, ... {'title': 'Book C', 'author': 'Author Z', 'copies': 2} ... ]) 'Book A'","solution":"def most_copies(inventory): Returns the title of the book with the highest number of copies in stock. If there is a tie, return the title that comes first alphabetically. # Sort the inventory by copies in descending order and by title alphabetically sorted_inventory = sorted(inventory, key=lambda x: (-x['copies'], x['title'])) # The first element in the sorted list will be the one with the most copies (and first alphabetically if tied) return sorted_inventory[0]['title']"},{"question":"def double_collatz_sequence(n: int) -> list: Generates the Double Collatz Sequence for a given positive integer n. The sequence follows these rules: 1. If n is 1, the sequence ends. 2. If n is even, the next number is n / 2. 3. If n is odd, the next number is 3n + 1, and then double that result. Parameters: n (int): The starting integer for the sequence. Returns: list: A list containing the Double Collatz Sequence. Examples: >>> double_collatz_sequence(6) [6, 3, 20, 10, 5, 32, 16, 8, 4, 2, 1] >>> double_collatz_sequence(7) [7, 44, 22, 11, 68, 34, 17, 104, 52, 26, 13, 80, 40, 20, 10, 5, 32, 16, 8, 4, 2, 1] >>> double_collatz_sequence(1) [1]","solution":"def double_collatz_sequence(n: int) -> list: Generates the Double Collatz Sequence for a given positive integer n. Parameters: n (int): The starting integer for the sequence. Returns: list: A list containing the Double Collatz Sequence. result = [] while n != 1: result.append(n) if n % 2 == 0: n //= 2 else: n = (3 * n + 1) * 2 result.append(1) return result"},{"question":"def remove_vowels(input_string: str) -> str: Removes all vowels from the input string. >>> remove_vowels(\\"hello world\\") \\"hll wrld\\" >>> remove_vowels(\\"aeiouAEIOU\\") \\"\\" >>> remove_vowels(\\"rhythm\\") \\"rhythm\\" >>> remove_vowels(\\"Hello World\\") \\"Hll Wrld\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"H3ll0 W@rld!\\") \\"H3ll0 W@rld!\\" >>> remove_vowels(\\"this is a test\\") \\"ths s tst\\"","solution":"def remove_vowels(input_string): Removes all vowels from the input string. Parameters: input_string (str): The string from which to remove vowels. Returns: str: The string without vowels. vowels = \\"aeiouAEIOU\\" return ''.join(char for char in input_string if char not in vowels)"},{"question":"def sorted_squares(nums: List[int]) -> List[int]: Returns a new list containing the squares of the original integers sorted in ascending order. Args: nums (list of int): The list of integers. Returns: list of int: The sorted list of squared integers. Examples: >>> sorted_squares([4, 1, 3, 2]) [1, 4, 9, 16] >>> sorted_squares([-1, -2, 0, 2, 1]) [0, 1, 1, 4, 4] >>> sorted_squares([5, -3, 2, -4, 0]) [0, 4, 9, 16, 25]","solution":"def sorted_squares(nums): Returns a new list containing the squares of the original integers sorted in ascending order. Args: nums (list of int): The list of integers. Returns: list of int: The sorted list of squared integers. squared_list = [num ** 2 for num in nums] squared_list.sort() return squared_list"},{"question":"from typing import List, Dict, Union, Tuple def calculate_discount( cart: List[Dict[str, Union[str, float, int]]], flat_discount: float, bulk_discount: Dict[str, Tuple[int, float]] ) -> float: Calculate the total price after applying flat and bulk discounts to the shopping cart. Args: cart (list of dict): The shopping cart. flat_discount (float): The flat discount percentage. bulk_discount (dict): The bulk discount specifications. Returns: float: The total price after discounts. Example: >>> cart = [ ... {\\"name\\": \\"laptop\\", \\"price\\": 999.99, \\"quantity\\": 2}, ... {\\"name\\": \\"mouse\\", \\"price\\": 25.50, \\"quantity\\": 5} ... ] >>> flat_discount = 10 >>> bulk_discount = {\\"mouse\\": (3, 20)} >>> calculate_discount(cart, flat_discount, bulk_discount) 1764.29","solution":"from typing import List, Dict, Union, Tuple def calculate_discount( cart: List[Dict[str, Union[str, float, int]]], flat_discount: float, bulk_discount: Dict[str, Tuple[int, float]] ) -> float: total_price = 0.0 # Apply bulk discounts first for item in cart: name = item['name'] price = item['price'] quantity = item['quantity'] if name in bulk_discount: threshold, discount_percentage = bulk_discount[name] if quantity >= threshold: price *= (1 - discount_percentage / 100.0) total_price += price * quantity # Apply flat discount total_price *= (1 - flat_discount / 100.0) # Round to 2 decimal places total_price = round(total_price, 2) return total_price"},{"question":"def min_idle_time(arrival_times, service_times): Calculate the minimum total idle time across all service stations. >>> min_idle_time([0, 2, 4, 5], [3, 3, 2, 1]) 0 >>> min_idle_time([0, 4, 8], [3, 3, 3]) 2 >>> min_idle_time([5], [4]) 0 >>> min_idle_time([1, 2, 3], [1, 1, 1]) 0 >>> min_idle_time([1, 5, 10], [2, 2, 2]) 5 >>> min_idle_time([0, 10, 20], [5, 5, 5]) 10 >>> min_idle_time([0, 1000000000, 2000000000], [1, 1, 1]) 1999999998 >>> min_idle_time([], []) 0","solution":"def min_idle_time(arrival_times, service_times): if not arrival_times or not service_times: return 0 last_finish_time = arrival_times[0] + service_times[0] total_idle_time = 0 for i in range(1, len(arrival_times)): current_arrival = arrival_times[i] current_service_time = service_times[i] if current_arrival >= last_finish_time: total_idle_time += current_arrival - last_finish_time last_finish_time = max(last_finish_time, current_arrival) + current_service_time return total_idle_time"},{"question":"def assign_task(employees, tasks, new_task, hours): Assigns a new task to an employee if it does not exceed their weekly limit. Args: employees (list): List of employee names. tasks (dict): Dictionary with employee names as keys and lists of assigned task hours as values. new_task (tuple): A tuple containing the employee name and the task hours to be assigned. hours (int): Maximum number of hours an employee can handle per week. Returns: dict: Updated tasks dictionary if the task is assigned. str: Error message if the task cannot be assigned. >>> employees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> tasks = {\\"Alice\\": [5, 3], \\"Bob\\": [2, 6], \\"Charlie\\": [4]} >>> new_task = (\\"Alice\\", 2) >>> hours = 10 >>> assign_task(employees, tasks, new_task, hours) {'Alice': [5, 3, 2], 'Bob': [2, 6], 'Charlie': [4]} >>> new_task = (\\"Bob\\", 8) >>> assign_task(employees, tasks, new_task, hours) 'Task cannot be assigned, exceeds limit' >>> new_task = (\\"Dan\\", 3) >>> assign_task(employees, tasks, new_task, hours) 'Employee does not exist'","solution":"def assign_task(employees, tasks, new_task, hours): Assigns a new task to an employee if it does not exceed their weekly limit. Args: employees (list): List of employee names. tasks (dict): Dictionary with employee names as keys and lists of assigned task hours as values. new_task (tuple): A tuple containing the employee name and the task hours to be assigned. hours (int): Maximum number of hours an employee can handle per week. Returns: dict: Updated tasks dictionary if the task is assigned. str: Error message if the task cannot be assigned. employee_name, task_hours = new_task if employee_name not in employees: return \\"Employee does not exist\\" current_hours = sum(tasks.get(employee_name, [])) if current_hours + task_hours > hours: return \\"Task cannot be assigned, exceeds limit\\" if employee_name in tasks: tasks[employee_name].append(task_hours) else: tasks[employee_name] = [task_hours] return tasks"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling once. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([2, 4, 1, 7, 8, 2, 4]) 7","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling once. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_test_cases(test_cases): Processes a list of test_cases and returns the result for each case. results = [] for case in test_cases: results.append(max_profit(case)) return results"},{"question":"def max_groups_seated(T: int, G: int, tables: List[int], groups: List[int]) -> int: Determine the maximum number of groups that can be seated simultaneously. Args: T (int): Number of tables. G (int): Number of groups. tables (List[int]): Lengths of each table. groups (List[int]): Sizes of each group. Returns: int: Maximum number of groups that can be seated simultaneously. >>> max_groups_seated(3, 4, [4, 5, 6], [3, 4, 2, 5]) 3 >>> max_groups_seated(4, 3, [7, 2, 5, 4], [6, 3, 2]) 3 from typing import List def test_seating_scenario_1(): T = 3 G = 4 tables = [4, 5, 6] groups = [3, 4, 2, 5] assert max_groups_seated(T, G, tables, groups) == 3 def test_seating_scenario_2(): T = 4 G = 3 tables = [7, 2, 5, 4] groups = [6, 3, 2] assert max_groups_seated(T, G, tables, groups) == 3 def test_seating_scenario_3(): T = 5 G = 6 tables = [5, 3, 8, 6, 7] groups = [2, 5, 6, 1, 7, 3] assert max_groups_seated(T, G, tables, groups) == 5 def test_seating_scenario_4(): T = 1 G = 1 tables = [10] groups = [10] assert max_groups_seated(T, G, tables, groups) == 1 def test_seating_scenario_5(): T = 2 G = 4 tables = [4, 4] groups = [2, 2, 3, 4] assert max_groups_seated(T, G, tables, groups) == 2","solution":"def max_groups_seated(T, G, tables, groups): # Sort tables and groups to efficiently match them tables.sort() groups.sort() # Initialize pointer for tables table_index = 0 group_index = 0 seated_groups = 0 # Try to seat each group at a suitable table while group_index < G and table_index < T: if groups[group_index] <= tables[table_index]: # Seat this group at this table seated_groups += 1 group_index += 1 table_index += 1 else: # Move to the next table table_index += 1 return seated_groups"},{"question":"import string def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome by ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import string def is_palindrome(s): Checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Remove all punctuation and spaces, convert to lowercase translator = str.maketrans('', '', string.punctuation + ' ') clean_str = s.translate(translator).lower() # Check if the cleaned string is equal to its reverse return clean_str == clean_str[::-1]"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generate an n x n spiral matrix filled with numbers from 1 to n^2 in a clockwise order >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [ [1, 2], [4, 3] ] >>> generate_spiral_matrix(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generate_spiral_matrix(4) [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] >>> generate_spiral_matrix(5) [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ]","solution":"def generate_spiral_matrix(n): Generates an n x n spiral matrix. Parameters: n (int): The dimension of the square matrix Returns: List[List[int]]: The n x n spiral matrix matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: # Fill the top row for col in range(left, right + 1): matrix[top][col] = num num += 1 top += 1 # Fill the right column for row in range(top, bottom + 1): matrix[row][right] = num num += 1 right -= 1 # Fill the bottom row for col in range(right, left - 1, -1): matrix[bottom][col] = num num += 1 bottom -= 1 # Fill the left column for row in range(bottom, top - 1, -1): matrix[row][left] = num num += 1 left += 1 return matrix"},{"question":"def find_single_integer(arr: List[int]) -> int: Implement a function that takes a list of integers \`arr\` where every element appears twice except for one element which appears exactly once. Return the element that appears only once. >>> find_single_integer([2, 2, 3, 4, 4]) 3 >>> find_single_integer([1, 1, 2, 2, 3, 3, 4]) 4 >>> find_single_integer([7]) 7 >>> find_single_integer([5, 3, 4, 5, 3]) 4 >>> find_single_integer([0, 1, 0]) 1 >>> find_single_integer([10, 20, 20, 30, 30]) 10 >>> find_single_integer([100, 200, 100, 300, 200]) 300","solution":"def find_single_integer(arr): Returns the element that appears exactly once in the array. All other elements appear twice. result = 0 for num in arr: result ^= num return result"},{"question":"def sortStrings(strings: List[str]) -> List[str]: Given a list of strings, return a new list where each string has its characters sorted in alphabetical order. :param strings: List of strings :return: List of strings with characters sorted >>> sortStrings([\\"car\\", \\"bike\\", \\"apple\\"]) == [\\"acr\\", \\"beik\\", \\"aelpp\\"] >>> sortStrings([\\"mouse\\", \\"banana\\", \\"cat\\"]) == [\\"emosu\\", \\"aaabnn\\", \\"act\\"] >>> sortStrings([\\"hello\\", \\"world\\"]) == [\\"ehllo\\", \\"dlorw\\"] from solution import sortStrings def test_sortStrings_example_cases(): assert sortStrings([\\"car\\", \\"bike\\", \\"apple\\"]) == [\\"acr\\", \\"beik\\", \\"aelpp\\"] assert sortStrings([\\"mouse\\", \\"banana\\", \\"cat\\"]) == [\\"emosu\\", \\"aaabnn\\", \\"act\\"] assert sortStrings([\\"hello\\", \\"world\\"]) == [\\"ehllo\\", \\"dlorw\\"] def test_sortStrings_empty_string(): assert sortStrings([\\"\\"]) == [\\"\\"] def test_sortStrings_single_character_strings(): assert sortStrings([\\"a\\", \\"z\\", \\"b\\"]) == [\\"a\\", \\"z\\", \\"b\\"] def test_sortStrings_identical_strings(): assert sortStrings([\\"aaa\\", \\"aaa\\"]) == [\\"aaa\\", \\"aaa\\"] def test_sortStrings_mixed_length_strings(): assert sortStrings([\\"a\\", \\"zebra\\", \\"lemon\\"]) == [\\"a\\", \\"aberz\\", \\"elmno\\"] def test_sortStrings_all_same_letter(): assert sortStrings([\\"ddd\\", \\"bbb\\", \\"aaa\\"]) == [\\"ddd\\", \\"bbb\\", \\"aaa\\"] def test_sortStrings_special_case(): assert sortStrings([\\"abcd\\", \\"dcba\\"]) == [\\"abcd\\", \\"abcd\\"]","solution":"def sortStrings(strings): Returns a new list where each string has its characters sorted in alphabetical order. :param strings: List of strings :return: List of strings with characters sorted return [''.join(sorted(s)) for s in strings]"},{"question":"def look_and_say(n: int) -> str: Generate the n-th term in the look-and-say sequence. >>> look_and_say(1) '1' >>> look_and_say(2) '11' >>> look_and_say(3) '21' >>> look_and_say(4) '1211' >>> look_and_say(5) '111221'","solution":"def look_and_say(n): Generate the n-th term in the look-and-say sequence. if n <= 0: return \\"\\" result = \\"1\\" for _ in range(1, n): result = _get_next_sequence(result) return result def _get_next_sequence(sequence): Generates the next sequence in the look-and-say sequence. next_sequence = [] i = 0 while i < len(sequence): count = 1 while i + 1 < len(sequence) and sequence[i] == sequence[i + 1]: i += 1 count += 1 next_sequence.append(str(count) + sequence[i]) i += 1 return ''.join(next_sequence)"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in place. :param matrix: List[List[int]] :return: None (the matrix is modified in place) >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] pass","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. :param matrix: List[List[int]] :return: None (the matrix is modified in place) n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def organize_books(test_cases): Function to sort books first by their color and second by their size within each color group. Args: test_cases (List[List[Tuple[str, int]]]): A list containing the test cases. Each test case is a list of tuples where the first element is a string representing the color and the second element is an integer representing the size of the book. Returns: List[List[Tuple[str, int]]]: A list containing the sorted lists of books for each test case. def format_organized_books_output(organized_books): Function to format the output for the organized books. Args: organized_books (List[List[Tuple[str, int]]]): A list containing the organized books for each test case. Returns: str: A formatted string as per the example output. def process_input(input_str): Function to process the input string. Args: input_str (str): Input string containing test cases. Returns: List: Parsed list of test cases. def main(input_str): test_cases = process_input(input_str) organized_books = organize_books(test_cases) result_str = format_organized_books_output(organized_books) return result_str","solution":"def organize_books(test_cases): Function to sort books first by their color and second by their size within each color group. Args: test_cases (List[List[Tuple[str, int]]]): A list containing the test cases. Each test case is a list of tuples where the first element is a string representing the color and the second element is an integer representing the size of the book. Returns: List[List[Tuple[str, int]]]: A list containing the sorted lists of books for each test case. results = [] for books in test_cases: # Sorting books first by color and then by size sorted_books = sorted(books, key=lambda x: (x[0], x[1])) results.append(sorted_books) return results def format_organized_books_output(organized_books): Function to format the output for the organized books. Args: organized_books (List[List[Tuple[str, int]]]): A list containing the organized books for each test case. Returns: str: A formatted string as per the example output. result_str_list = [] for case in organized_books: for book in case: result_str_list.append(f\\"{book[0]} {book[1]}\\") return \\"n\\".join(result_str_list) def process_input(input_str): Function to process the input string. Args: input_str (str): Input string containing test cases. Returns: List: Parsed list of test cases. input_lines = input_str.strip().split(\\"n\\") N = int(input_lines[0]) test_cases = [] index = 1 for _ in range(N): M = int(input_lines[index]) books = [] for j in range(1, M + 1): color_size = input_lines[index + j].split() color = color_size[0] size = int(color_size[1]) books.append((color, size)) test_cases.append(books) index += M + 1 return test_cases def main(input_str): test_cases = process_input(input_str) organized_books = organize_books(test_cases) result_str = format_organized_books_output(organized_books) return result_str"},{"question":"def letter_counts(s: str) -> dict: Returns a dictionary containing each letter from the string as keys and the number of times each letter appears in the string as values. The function ignores case and only counts alphabetic characters. >>> letter_counts(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_counts(\\"Programming is fun!\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 2, 'n': 2, 's': 1, 'f': 1, 'u': 1}","solution":"def letter_counts(s): Returns a dictionary containing each letter from the string as keys and the number of times each letter appears in the string as values. s = s.lower() # Convert to lowercase counts = {} for char in s: if char.isalpha(): # Only consider alphabetic characters if char in counts: counts[char] += 1 else: counts[char] = 1 return counts"},{"question":"def numIslands(grid: List[List[str]]) -> int: Returns the number of islands in the grid. >>> numIslands([ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ]) 3 >>> numIslands([ [\\"1\\", \\"0\\", \\"0\\", \\"1\\"], [\\"0\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\"] ]) 4 >>> numIslands([ [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"] ]) 0 >>> numIslands([[\\"1\\"]]) 1 >>> numIslands([[\\"0\\"]]) 0 >>> numIslands([ [\\"1\\", \\"1\\"], [\\"1\\", \\"1\\"] ]) 1 >>> numIslands([ [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"1\\", \\"0\\", \\"1\\"], [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"1\\", \\"0\\", \\"1\\"] ]) 8","solution":"def numIslands(grid): Returns the number of islands in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) num_islands = 0 def dfs(i, j): # Check if the current cell is out of bounds or is water if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': return # Mark the cell as visited by setting it to '0' grid[i][j] = '0' # Recursively visit all adjacent cells (up, down, left, right) dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) for i in range(m): for j in range(n): if grid[i][j] == '1': num_islands += 1 dfs(i, j) return num_islands"},{"question":"MOD = 1000000007 def number_of_valid_binary_strings(n): Returns the number of valid binary strings of length n. >>> number_of_valid_binary_strings(2) 3 >>> number_of_valid_binary_strings(3) 5 >>> number_of_valid_binary_strings(4) 8 pass def solve(T, test_cases): Given the number of test cases T and a list of test cases, returns a list of the number of valid binary strings of length N for each test case. >>> solve(3, [2, 3, 4]) [3, 5, 8] >>> solve(1, [10]) [144] pass","solution":"MOD = 1000000007 def number_of_valid_binary_strings(n): Returns the number of valid binary strings of length n. if n == 1: return 2 elif n == 2: return 3 dp = [0] * (n + 1) dp[1] = 2 dp[2] = 3 for i in range(3, n + 1): dp[i] = (dp[i - 1] + dp[i - 2]) % MOD return dp[n] def solve(T, test_cases): results = [] for n in test_cases: results.append(number_of_valid_binary_strings(n)) return results"},{"question":"def graph_path_exists(graph, start, end): Determines if there is a valid path from 'start' to 'end' in a directed graph represented by an adjacency list. >>> graph_path_exists({ ... 'A': ['B', 'C'], ... 'B': ['C'], ... 'C': ['A', 'D'], ... 'D': ['C'] ... }, 'A', 'D') True >>> graph_path_exists({ ... 'A': ['B'], ... 'B': ['C'], ... 'C': ['D'], ... 'D': [] ... }, 'A', 'D') True >>> graph_path_exists({ ... 'A': ['B', 'C'], ... 'B': ['C'], ... 'C': ['A'] ... }, 'A', 'D') False","solution":"def graph_path_exists(graph, start, end): Determines if there is a valid path from 'start' to 'end' in a directed graph represented by an adjacency list. visited = set() stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) stack.extend(graph.get(node, [])) return False"},{"question":"def minimum_tickets(adults: int, children: int) -> int: Returns the minimum number of tickets needed for the given number of adults and children. >>> minimum_tickets(4, 7) 6 >>> minimum_tickets(4, 0) 2 >>> minimum_tickets(0, 7) 4 >>> minimum_tickets(3, 3) 3 def test_no_adults_no_children(): assert minimum_tickets(0, 0) == 0 def test_only_adults(): assert minimum_tickets(4, 0) == 2 assert minimum_tickets(7, 0) == 4 assert minimum_tickets(1, 0) == 1 def test_only_children(): assert minimum_tickets(0, 4) == 2 assert minimum_tickets(0, 7) == 4 assert minimum_tickets(0, 1) == 1 def test_adults_and_children(): assert minimum_tickets(4, 7) == 6 assert minimum_tickets(3, 3) == 3 assert minimum_tickets(2, 2) == 2 assert minimum_tickets(5, 3) == 4 assert minimum_tickets(1, 1) == 1","solution":"def minimum_tickets(adults, children): Returns the minimum number of tickets needed for the given number of adults and children. total_people = adults + children tickets = (total_people + 1) // 2 return tickets"},{"question":"def merge_species_counts(test_cases): Merge the counts of species from all enclosures and display the combined list in the lexicographical order of species names. >>> merge_species_counts([(2, '3 lion 3 tiger 2 bear 1', '2 elephant 1 lion 2')]) 'bear 1nelephant 1nlion 5ntiger 2' >>> merge_species_counts([(3, '2 giraffe 4 monkey 3', '3 tiger 1 zebra 2 bear 2', '1 lion 1')]) 'bear 2ngiraffe 4nlion 1nmonkey 3ntiger 1nzebra 2' pass def parse_input(input_string): Parse the input string and return the test cases. >>> parse_input('2n2n3 lion 3 tiger 2 bear 1n2 elephant 1 lion 2n3n2 giraffe 4 monkey 3n3 tiger 1 zebra 2 bear 2n1 lion 1n') [(2, '3 lion 3 tiger 2 bear 1', '2 elephant 1 lion 2'), (3, '2 giraffe 4 monkey 3', '3 tiger 1 zebra 2 bear 2', '1 lion 1')] pass def format_output(output_string): Format the output string to match the specified output format. >>> format_output('bear 1nelephant 1nlion 5ntiger 2nbear 2ngiraffe 4nlion 1nmonkey 3ntiger 1nzebra 2n') 'bear 1nelephant 1nlion 5ntiger 2nbear 2ngiraffe 4nlion 1nmonkey 3ntiger 1nzebra 2' pass","solution":"def merge_species_counts(test_cases): results = [] for case in test_cases: E = case[0] enclosures = case[1:] species_counts = {} for enclosure in enclosures: species_list = enclosure.split()[1:] # Skip the first element which is the number of species for i in range(0, len(species_list), 2): species = species_list[i] count = int(species_list[i + 1]) if species in species_counts: species_counts[species] += count else: species_counts[species] = count sorted_species_counts = sorted(species_counts.items()) results.append(\\"n\\".join(f\\"{species} {count}\\" for species, count in sorted_species_counts)) return \\"n\\".join(results) def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): E = int(lines[index]) enclosures = lines[index+1:index+1+E] test_cases.append((E, *enclosures)) index += E + 1 return test_cases def format_output(output_string): return output_string.strip() input_string = '''2 2 3 lion 3 tiger 2 bear 1 2 elephant 1 lion 2 3 2 giraffe 4 monkey 3 3 tiger 1 zebra 2 bear 2 1 lion 1 ''' expected_output = '''bear 1 elephant 1 lion 5 tiger 2 bear 2 giraffe 4 lion 1 monkey 3 tiger 1 zebra 2 ''' test_cases = parse_input(input_string) output = merge_species_counts(test_cases) formatted_output = format_output(output) print(formatted_output)"},{"question":"def allStudentsPassed(student_list: List[Dict[str, Union[str, int]]]) -> bool: Returns True if all students in the list have a score of 50 or above. >>> allStudentsPassed([{'name': 'Alice', 'age': 20, 'score': 55}, {'name': 'Bob', 'age': 22, 'score': 75}, {'name': 'Charlie', 'age': 23, 'score': 65}]) True >>> allStudentsPassed([{'name': 'Alice', 'age': 20, 'score': 55}, {'name': 'Bob', 'age': 22, 'score': 48}, {'name': 'Charlie', 'age': 23, 'score': 65}]) False >>> allStudentsPassed([{'name': 'Alice', 'age': 20, 'score': 45}, {'name': 'Bob', 'age': 22, 'score': 48}, {'name': 'Charlie', 'age': 23, 'score': 35}]) False >>> allStudentsPassed([]) True","solution":"def allStudentsPassed(student_list): Returns True if all students in the list have a score of 50 or above. return all(student['score'] >= 50 for student in student_list)"},{"question":"def symmetric_difference(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of integers representing the symmetric difference between the two sets derived from the input lists. >>> symmetric_difference([1, 2, 3], [3, 4, 5]) == [1, 2, 4, 5] >>> symmetric_difference([10, 20, 30], [30, 40, 50]) == [10, 20, 40, 50] >>> symmetric_difference([1, 1, 2, 3], [3, 4, 4, 5]) == [1, 2, 4, 5] >>> symmetric_difference([-1, -2, -3], [-3, -4, -5]) == [-5, -4, -2, -1] >>> symmetric_difference([], [1, 2, 3]) == [1, 2, 3] >>> symmetric_difference([1, 2, 3], []) == [1, 2, 3] >>> symmetric_difference([], []) == [] >>> symmetric_difference([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] pass","solution":"def symmetric_difference(list1, list2): Returns a sorted list of integers representing the symmetric difference between the two sets derived from the input lists. set1 = set(list1) set2 = set(list2) sym_diff = set1.symmetric_difference(set2) return sorted(sym_diff)"},{"question":"def sum_of_multiples(numbers): Returns the sum of all integers in the list that are multiples of either 3 or 5. >>> sum_of_multiples([1, 2, 3, 4, 5, 6]) 14 >>> sum_of_multiples([10, 11, 12, 13, 14, 15]) 37 >>> sum_of_multiples([1, 2, 4, 7]) 0","solution":"def sum_of_multiples(numbers): Returns the sum of all integers in the list that are multiples of either 3 or 5. return sum(num for num in numbers if num % 3 == 0 or num % 5 == 0)"},{"question":"def shift_string(input_string: str) -> str: Shifts each character in the input string to the right by one position in the ASCII table, with wrapping for alphabetic characters. Non-alphabetic characters remain unchanged. >>> shift_string(\\"abc\\") 'bcd' >>> shift_string(\\"xyz\\") 'yza' >>> shift_string(\\"XYZ\\") 'YZA' >>> shift_string(\\"Hello, World!\\") 'Ifmmp, Xpsme!' >>> shift_string(\\"\\") '' >>> shift_string(\\"1234!@#\\") '1234!@#'","solution":"def shift_char(c): Shifts a character to the right by one position in the ASCII table, wrapping around as necessary for alphabetic characters. if 'a' <= c <= 'z': return chr(((ord(c) - ord('a') + 1) % 26) + ord('a')) elif 'A' <= c <= 'Z': return chr(((ord(c) - ord('A') + 1) % 26) + ord('A')) else: return c def shift_string(input_string): Shifts each character in the input string to the right by one position in the ASCII table, with wrapping for alphabetic characters. return ''.join(shift_char(c) for c in input_string)"},{"question":"def find_min_additional_connections(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determines the minimum number of additional connections required to ensure the network is fully connected. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases, each containing n (number of devices), m (number of connections), and a list of m pairs of integers representing the existing connections. Returns: List[int]: A list of integers representing the minimum number of additional connections required for each test case. Examples: >>> find_min_additional_connections(3, [(4, 2, [(1, 2), (3, 4)]), (3, 1, [(1, 2)]), (5, 0, [])]) [1, 1, 4] pass def test_find_min_additional_connections(): test_cases = [ ( 3, [ (4, 2, [(1, 2), (3, 4)]), (3, 1, [(1, 2)]), (5, 0, []) ], [1, 1, 4] ) ] for t, cases, expected in test_cases: assert find_min_additional_connections(t, cases) == expected","solution":"def find_min_additional_connections(t, test_cases): def dfs(node, adj_list, visited): stack = [node] while stack: curr = stack.pop() for neighbor in adj_list[curr]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) results = [] for n, m, connections in test_cases: adj_list = {i: [] for i in range(1, n + 1)} for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) visited = set() num_components = 0 for device in range(1, n + 1): if device not in visited: visited.add(device) dfs(device, adj_list, visited) num_components += 1 results.append(num_components - 1) return results"},{"question":"def move_vowels_to_end(s: str) -> str: Moves all the vowels in the string 's' to the end while preserving the order of the consonants and vowels. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The resulting string after moving vowels to the end. >>> move_vowels_to_end(\\"programming\\") 'prgrmmngoai' >>> move_vowels_to_end(\\"aeiou\\") 'aeiou' >>> move_vowels_to_end(\\"bcdfgh\\") 'bcdfgh' >>> move_vowels_to_end(\\"abcdefghi\\") 'bcdfghaei' >>> move_vowels_to_end(\\"\\") '' >>> move_vowels_to_end(\\"a\\") 'a' >>> move_vowels_to_end(\\"z\\") 'z'","solution":"def move_vowels_to_end(s): Moves all the vowels in the string 's' to the end while preserving the order of the consonants and vowels. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The resulting string after moving vowels to the end. vowels = 'aeiou' consonants = [] vowel_list = [] for char in s: if char in vowels: vowel_list.append(char) else: consonants.append(char) return ''.join(consonants) + ''.join(vowel_list)"},{"question":"from typing import List def sum_array(arr: List[int]) -> int: Returns the sum of all integers in the given array. Parameters: arr (List[int]): A list of integers. Returns: int: The sum of all integers in the list. pass # Sample tests assert sum_array([1, 2, 3, 4, 5]) == 15 assert sum_array([-1, -2, -3, -4, -5]) == -15 assert sum_array([1, -2, 3, -4, 5]) == 3 assert sum_array([10]) == 10 assert sum_array([1000, -1000, 500, -500, 0]) == 0 assert sum_array([0, 0, 0, 0]) == 0","solution":"from typing import List def sum_array(arr: List[int]) -> int: Returns the sum of all integers in the given array. Parameters: arr (List[int]): A list of integers. Returns: int: The sum of all integers in the list. return sum(arr)"},{"question":"def max_subarray_with_indices(nums): Find the subarray with the maximum sum in the list of integers. Returns a tuple containing the starting index, ending index, and the sum of the subarray. >>> max_subarray_with_indices([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (3, 6, 6) >>> max_subarray_with_indices([1, 2, 3, 4]) (0, 3, 10) def find_max_sum_subarrays(testcases): Find the subarrays with the maximum sum for multiple test cases. Returns a list of tuples where each tuple contains the starting index, ending index, and the sum of the subarray. >>> find_max_sum_subarrays([ ... [-2, 1, -3, 4, -1, 2, 1, -5, 4], ... [1, 2, 3, 4] ... ]) [(3, 6, 6), (0, 3, 10)]","solution":"def max_subarray_with_indices(nums): Finds the subarray with the maximum sum in the list of integers. Returns a tuple containing the starting index, ending index, and the sum of the subarray. max_sum = -float('inf') # Initialize to negative infinity current_sum = 0 start = end = 0 temp_start = 0 for i, num in enumerate(nums): if current_sum <= 0: current_sum = num temp_start = i else: current_sum += num if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return start, end, max_sum def find_max_sum_subarrays(testcases): results = [] for array in testcases: start, end, max_sum = max_subarray_with_indices(array) results.append((start, end, max_sum)) return results"},{"question":"def is_prime(n: int) -> bool: Returns True if the number n is prime, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(9) False >>> is_prime(11) True >>> is_prime(-1) False >>> is_prime(0) False >>> is_prime(1) False def filter_primes(nums: List[int]) -> List[int]: Returns a list of prime numbers from the given list nums. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([1, 13, 15, 17, 19, 21]) [13, 17, 19] >>> filter_primes([]) [] >>> filter_primes([0, 1, -10, -7, -3, 4, 6]) [] >>> filter_primes([11, 13, 17, 19, 23, 29]) [11, 13, 17, 19, 23, 29]","solution":"def is_prime(n): Returns True if the number n is prime, else False. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # Exclude other even numbers for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(nums): Returns a list of prime numbers from the given list nums. return [num for num in nums if is_prime(num)]"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Madam, in Eden I'm Adam\\") True >>> is_palindrome(\\"Eva, can I see bees in a cave?\\") True pass","solution":"import re def is_palindrome(s): Returns True if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"import math from typing import List, Tuple def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points. >>> distance((0, 0), (3, 4)) 5.0 return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def perimeter(vertices: List[Tuple[int, int]]) -> float: Calculate the perimeter of a polygon given its vertices. vertices: List of tuples, where each tuple represents (x, y) coordinates of a vertex. Returns: Perimeter of the polygon as a float rounded to 2 decimal places. >>> perimeter([(0, 0), (0, 1), (1, 1), (1, 0)]) 4.00 >>> perimeter([(0, 0), (3, 4)]) 10.0 def test_perimeter_square(): vertices = [(0, 0), (0, 1), (1, 1), (1, 0)] assert perimeter(vertices) == 4.00 def test_perimeter_rectangle(): vertices = [(0, 0), (0, 2), (3, 2), (3, 0)] assert perimeter(vertices) == 10.00 def test_perimeter_triangle(): vertices = [(0, 0), (3, 0), (0, 4)] assert perimeter(vertices) == 12.00 def test_perimeter_pentagon(): vertices = [(0, 0), (1, 2), (3, 3), (4, 1), (2, -1)] expected_perimeter = round(distance((0, 0), (1, 2)) + distance((1, 2), (3, 3)) + distance((3, 3), (4, 1)) + distance((4, 1), (2, -1)) + distance((2, -1), (0, 0)), 2) assert perimeter(vertices) == expected_perimeter def test_perimeter_single_vertex(): vertices = [(0, 0)] assert perimeter(vertices) == 0.0 def test_perimeter_two_vertices(): vertices = [(0, 0), (3, 4)] expected_perimeter = round(2 * distance((0, 0), (3, 4)), 2) assert perimeter(vertices) == expected_perimeter","solution":"import math def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def perimeter(vertices): Calculate the perimeter of a polygon given its vertices. vertices: List of tuples, where each tuple represents (x, y) coordinates of a vertex. Returns: Perimeter of the polygon as a float rounded to 2 decimal places. n = len(vertices) total_perimeter = 0.0 for i in range(n): total_perimeter += distance(vertices[i], vertices[(i + 1) % n]) return round(total_perimeter, 2)"},{"question":"def process_operations(operations: List[str]) -> List[str]: Process a series of operations to track product ratings. >>> process_operations([\\"rate 101 4\\", \\"average 101\\"]) [\\"4.00\\"] >>> process_operations([\\"rate 101 4\\", \\"rate 101 2\\", \\"average 101\\"]) [\\"3.00\\"] >>> process_operations([\\"average 101\\"]) [\\"No ratings\\"] >>> process_operations([\\"rate 101 4\\", \\"rate 102 5\\", \\"average 101\\", \\"average 102\\"]) [\\"4.00\\", \\"5.00\\"] >>> process_operations([\\"rate 101 4\\", \\"rate 101 3\\", \\"rate 102 5\\"]) [] >>> process_operations([\\"rate 101 4\\", \\"rate 102 5\\", \\"rate 101 3\\", \\"rate 102 4\\", \\"average 101\\", \\"average 102\\", \\"average 103\\"]) [\\"3.50\\", \\"4.50\\", \\"No ratings\\"]","solution":"def process_operations(operations): product_ratings = {} results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"rate\\": product_id = int(parts[1]) rating = int(parts[2]) if product_id not in product_ratings: product_ratings[product_id] = [] product_ratings[product_id].append(rating) elif command == \\"average\\": product_id = int(parts[1]) if product_id in product_ratings and product_ratings[product_id]: average_rating = sum(product_ratings[product_id]) / len(product_ratings[product_id]) results.append(f\\"{average_rating:.2f}\\") else: results.append(\\"No ratings\\") return results"},{"question":"from typing import List def find_longest_balanced_substring(parentheses: str) -> int: Returns the length of the longest balanced substring of parentheses. >>> find_longest_balanced_substring('(()())') 6 >>> find_longest_balanced_substring(')()())()') 4 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each. >>> process_test_cases(['(()())', ')()())()']) [6, 4] >>> process_test_cases(['', '(((((((']) [0, 0] pass","solution":"def find_longest_balanced_substring(parentheses): Returns the length of the longest balanced substring of parentheses. max_len = 0 stack = [-1] for i, char in enumerate(parentheses): if char == '(': stack.append(i) else: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) return max_len def process_test_cases(test_cases): results = [] for parentheses in test_cases: results.append(find_longest_balanced_substring(parentheses)) return results"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the largest sum of a contiguous subarray within a list of integers. :param nums: List of integers :return: The largest sum of any contiguous subarray >>> max_subarray_sum([2, 3, 4, 1, 2, 9, 5]) 26 >>> max_subarray_sum([-2, -3, -4, -1]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([42]) 42 >>> max_subarray_sum([-42]) -42 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([0, 0, 0, 0]) 0","solution":"def max_subarray_sum(nums): Finds the largest sum of a contiguous subarray within a list of integers. :param nums: List of integers :return: The largest sum of any contiguous subarray if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_items_within_budget(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: You are given a list of integers representing the prices of different items in a store. You have a certain amount of money, and you want to buy as many items as possible without exceeding your budget. The items can be purchased in any order. Args: T - Integer, the number of test cases. test_cases - List of tuples (B, N, prices) where: B - Integer, the total budget. N - Integer, the number of items in the store. prices - List of integers representing the prices of the items. Returns: List of integers, each integer is the maximum number of items that can be purchased without exceeding the budget for each test case. >>> max_items_within_budget(2, [(50, 5, [10, 20, 30, 40, 50]), (100, 6, [10, 20, 30, 40, 50, 60])]) [2, 4] >>> max_items_within_budget(1, [(1, 4, [2, 2, 2, 2])]) [0] >>> max_items_within_budget(1, [(15, 5, [1, 2, 3, 4, 5])]) [5] >>> max_items_within_budget(1, [(15, 5, [10, 9, 8, 7, 6])]) [2] >>> max_items_within_budget(1, [(1000000000, 4, [1000000000, 1000000000, 1000000000, 1000000000])]) [1]","solution":"def max_items_within_budget(T, test_cases): results = [] for i in range(T): B = test_cases[i][0] N = test_cases[i][1] prices = test_cases[i][2] prices.sort() total_spent = 0 count = 0 for price in prices: if total_spent + price <= B: total_spent += price count += 1 else: break results.append(count) return results # Example usage: # T = 2 # test_cases = [ # (50, 5, [10, 20, 30, 40, 50]), # (100, 6, [10, 20, 30, 40, 50, 60]) # ] # print(max_items_within_budget(T, test_cases)) # Output should be [2, 4]"},{"question":"def calculate_worked_hours(logs): Calculates the total number of hours worked by each employee given their check-in and check-out times. Parameters: logs (list): A 2D list containing log entries in the format ['EmployeeID', 'Check-in time', 'Check-out time'] Returns: list: A 2D list where each sub-array contains the EmployeeID and the total hours worked, sorted by EmployeeID in ascending order.","solution":"def calculate_worked_hours(logs): Calculates the total number of hours worked by each employee given their check-in and check-out times. Parameters: logs (list): A 2D list containing log entries in the format ['EmployeeID', 'Check-in time', 'Check-out time'] Returns: list: A 2D list where each sub-array contains the EmployeeID and the total hours worked, sorted by EmployeeID in ascending order. worked_hours = [] for log in logs: employee_id, check_in, check_out = log check_in_hh, check_in_mm = map(int, check_in.split(':')) check_out_hh, check_out_mm = map(int, check_out.split(':')) total_hours = check_out_hh - check_in_hh total_minutes = check_out_mm - check_in_mm if total_minutes < 0: total_hours -= 1 total_minutes += 60 worked_hours.append([employee_id, f\\"{total_hours:02d}:{total_minutes:02d}\\"]) worked_hours.sort(key=lambda x: x[0]) return worked_hours"},{"question":"def min_divisions(n: int) -> int: Returns the minimum number of divisions needed to ensure that each resulting partition is colored either fully or divided further until the smallest size of a partition is 1 x 1. >>> min_divisions(1) 0 >>> min_divisions(2) 1 >>> min_divisions(4) 2 >>> min_divisions(8) 3","solution":"def min_divisions(n): Returns the minimum number of divisions needed to ensure that each resulting partition is colored either fully or divided further until the smallest size of a partition is 1 x 1. if n <= 1: return 0 divisions = 0 while n > 1: n = n // 2 divisions += 1 return divisions"},{"question":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(20) == 2432902008176640000 >>> factorial(50) == 30414093201713378043612608166064768844377641568960512000000000000","solution":"def factorial(n): Returns the factorial of a non-negative integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def max_water_collected(buckets: List[int]) -> int: Calculates the maximum amount of water that can be collected between the buckets. >>> max_water_collected([2, 0, 2]) 2 >>> max_water_collected([3, 0, 2, 0, 4]) 7 >>> max_water_collected([1, 1, 1, 1, 1]) 0","solution":"def max_water_collected(buckets): Calculates the maximum amount of water that can be collected between the buckets. if not buckets: return 0 n = len(buckets) left_max = [0] * n right_max = [0] * n left_max[0] = buckets[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], buckets[i]) right_max[n - 1] = buckets[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], buckets[i]) water_collected = 0 for i in range(n): water_collected += min(left_max[i], right_max[i]) - buckets[i] return water_collected"},{"question":"def find_shortest_word_length(s: str) -> int: Write a function that accepts a string which contains a sequence of words separated by spaces. The function should return the length of the shortest word(s) in the string. >>> find_shortest_word_length(\\"simple example of a coding question\\") # should return 1 >>> find_shortest_word_length(\\"another test with different words\\") # should return 4","solution":"def find_shortest_word_length(s): Returns the length of the shortest word(s) in the string. Args: s (str): A string containing a sequence of words separated by spaces. Returns: int: The length of the shortest word in the string. words = s.split() if not words: return 0 return min(len(word) for word in words)"},{"question":"def find_pairs_with_sum(numbers: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs in the list that add up to the target sum. Args: numbers: List of integers. target: Integer representing the target sum. Returns: A list of tuples, each containing a pair of integers that add up to the target sum. >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3], 10) [] >>> find_pairs_with_sum([2, 2, 2, 2], 4) [(2, 2)] >>> find_pairs_with_sum([-1, -2, 0, 3, 1, 2], 1) [(-2, 3), (-1, 2), (0, 1)] >>> find_pairs_with_sum([1000, -1000, 500, 1500, -500], 0) [(-1000, 1000), (-500, 500)] >>> find_pairs_with_sum([-5, -3, 0, 3, 5, 2], -3) [(-5, 2), (-3, 0)]","solution":"def find_pairs_with_sum(numbers, target): Finds all unique pairs in the list that add up to the target sum. Args: numbers: List of integers. target: Integer representing the target sum. Returns: A list of tuples, each containing a pair of integers that add up to the target sum. seen = set() pairs = set() for number in numbers: complement = target - number if complement in seen: pair = (min(number, complement), max(number, complement)) pairs.add(pair) seen.add(number) return sorted(pairs)"},{"question":"def compress(s: str) -> str: Compresses a string by replacing consecutive duplicate characters with the character followed by the count of duplicates. If the compressed string is not shorter, returns the original string. Args: s (str): The input string to be compressed. Returns: str: The compressed string or the original string if compression does not yield a shorter string. Examples: >>> compress(\\"aabbccc\\") 'a2b2c3' >>> compress(\\"abc\\") 'abc' >>> compress(\\"aaabbbcccdde\\") 'a3b3c3d2e1' >>> compress(\\"\\") '' >>> compress(\\"abcdef\\") 'abcdef' >>> compress(\\"aaaaa\\") 'a5' >>> compress(\\"aabbccaabbcc\\") 'aabbccaabbcc' >>> compress(\\"aaabbcccdd\\") 'a3b2c3d2'","solution":"def compress(s): Compresses a string by replacing consecutive duplicate characters with the character followed by the count of duplicates. If the compressed string is not shorter, returns the original string. Args: s (str): The input string to be compressed. Returns: str: The compressed string or the original string if compression does not yield a shorter string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(f\\"{s[i-1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def filter_strings_by_length(strings: List[str], n: int) -> List[str]: Returns a list of strings that are longer than n characters. Parameters: strings (list): A list of strings. n (int): A non-negative integer. Returns: list: A list containing strings from the input list that are longer than n characters. >>> filter_strings_by_length([\\"apple\\", \\"banana\\", \\"pear\\", \\"kiwi\\", \\"melon\\"], 4) ['apple', 'banana', 'melon'] >>> filter_strings_by_length([\\"cat\\", \\"dog\\", \\"bat\\"], 3) [] >>> filter_strings_by_length([\\"cat\\", \\"horse\\", \\"mouse\\"], 3) ['horse', 'mouse'] >>> filter_strings_by_length([\\"parrot\\", \\"elephant\\", \\"whale\\"], 2) ['parrot', 'elephant', 'whale'] >>> filter_strings_by_length([], 3) [] >>> filter_strings_by_length([\\"a\\", \\"ab\\", \\"abc\\"], 0) ['a', 'ab', 'abc']","solution":"def filter_strings_by_length(strings, n): Returns a list of strings that are longer than n characters. Parameters: strings (list): A list of strings. n (int): A non-negative integer. Returns: list: A list containing strings from the input list that are longer than n characters. return [string for string in strings if len(string) > n]"},{"question":"def is_prime(n: int) -> bool: Determine if the given positive integer n is a prime number. A prime number is a positive integer greater than 1 with no positive integer divisors other than 1 and itself. Parameters: n (int): A positive integer (1 <= n <= 1000) Returns: bool: True if n is a prime number, False otherwise Examples: >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(100) False","solution":"def is_prime(n): Determines if the given positive integer n is a prime number. Parameters: n (int): A positive integer (1 <= n <= 1000) Returns: bool: True if n is a prime number, False otherwise if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True"},{"question":"def sanitize_sentence(s: str, forbidden_words: set) -> str: Removes all occurrences of the forbidden words from the string 's'. Args: s : str : The input string containing words separated by spaces. forbidden_words : set : A set of words to be removed from the string. Returns: str : The sanitized string with forbidden words removed. >>> sanitize_sentence(\\"the quick brown fox jumps over the lazy dog\\", {\\"the\\", \\"jumps\\"}) \\"quick brown fox over lazy dog\\" >>> sanitize_sentence(\\"hello world!\\", {\\"world!\\"}) \\"hello\\" >>> sanitize_sentence(\\"The quick brown Fox\\", {\\"The\\", \\"Fox\\"}) \\"quick brown\\" >>> sanitize_sentence(\\"hi hi hi hi\\", {\\"hi\\"}) \\"\\" >>> sanitize_sentence(\\"hello hello world world\\", {\\"hello\\"}) \\"world world\\" >>> sanitize_sentence(\\"the the the\\", {\\"the\\"}) \\"\\" >>> sanitize_sentence(\\"hello world!\\", set()) \\"hello world!\\" >>> sanitize_sentence(\\"\\", {\\"anything\\"}) \\"\\" def test_basic_case(): s = \\"the quick brown fox jumps over the lazy dog\\" forbidden_words = {\\"the\\", \\"jumps\\"} assert sanitize_sentence(s, forbidden_words) == \\"quick brown fox over lazy dog\\" def test_no_forbidden_words(): s = \\"hello world\\" forbidden_words = set() assert sanitize_sentence(s, forbidden_words) == \\"hello world\\" def test_all_forbidden_words(): s = \\"hello world\\" forbidden_words = {\\"hello\\", \\"world\\"} assert sanitize_sentence(s, forbidden_words) == \\"\\" def test_mixed_case(): s = \\"The quick brown Fox\\" forbidden_words = {\\"The\\", \\"Fox\\"} assert sanitize_sentence(s, forbidden_words) == \\"quick brown\\" def test_repeating_word(): s = \\"hi hi hi hi\\" forbidden_words = {\\"hi\\"} assert sanitize_sentence(s, forbidden_words) == \\"\\" def test_repeated_forbidden_words(): s = \\"hello hello world world\\" forbidden_words = {\\"hello\\"} assert sanitize_sentence(s, forbidden_words) == \\"world world\\" def test_punctuation_in_words(): s = \\"hello world!\\" forbidden_words = {\\"world!\\"} assert sanitize_sentence(s, forbidden_words) == \\"hello\\" def test_large_input(): s = \\"the \\" * 250 + \\"end\\" forbidden_words = {\\"the\\"} assert sanitize_sentence(s, forbidden_words) == \\"end\\" def test_empty_string(): s = \\"\\" forbidden_words = {\\"anything\\"} assert sanitize_sentence(s, forbidden_words) == \\"\\" def test_empty_forbidden_set(): s = \\"the quick brown fox jumps over the lazy dog\\" forbidden_words = set() assert sanitize_sentence(s, forbidden_words) == \\"the quick brown fox jumps over the lazy dog\\"","solution":"def sanitize_sentence(s: str, forbidden_words: set) -> str: Removes all occurrences of the forbidden words from the string 's'. Args: s : str : The input string containing words separated by spaces. forbidden_words : set : A set of words to be removed from the string. Returns: str : The sanitized string with forbidden words removed. return ' '.join(word for word in s.split() if word not in forbidden_words)"},{"question":"def server_uptime(status: List[bool]) -> float: Returns the percentage of time the server was up during a 24-hour period. Parameters: status (list of bools): List of booleans representing the server status during each second of a day. Returns: float: Percentage of time the server was up. >>> server_uptime([True] * 86400) 100.0 >>> server_uptime([True] * 43200 + [False] * 43200) 50.0 >>> server_uptime([False] * 86400) 0.0 >>> server_uptime([True, False] * 43200) 50.0 >>> round(server_uptime([True] + [False] * 86399), 6) round((1 / 86400) * 100, 6)","solution":"def server_uptime(status): Returns the percentage of time the server was up during a 24-hour period. Parameters: status (list of bools): List of booleans representing the server status during each second of a day. Returns: float: Percentage of time the server was up. if len(status) != 86400: raise ValueError(\\"The status list must contain exactly 86,400 elements.\\") up_time = sum(status) uptime_percentage = (up_time / 86400) * 100 return uptime_percentage"},{"question":"def modified_fibonacci(a, b, c, N): Generates the first N numbers in a modified Fibonacci sequence starting with a, b, c. Parameters: a (int): The first number of the sequence. b (int): The second number of the sequence. c (int): The third number of the sequence. N (int): The number of terms to generate. Returns: list: The first N numbers of the modified Fibonacci sequence. >>> modified_fibonacci(1, 1, 1, 5) [1, 1, 1, 3, 5] >>> modified_fibonacci(0, 1, 2, 7) [0, 1, 2, 3, 6, 11, 20] >>> modified_fibonacci(2, 3, 5, 6) [2, 3, 5, 10, 18, 33] >>> modified_fibonacci(1, 2, 3, 1) [1] >>> modified_fibonacci(1, 2, 3, 2) [1, 2] >>> modified_fibonacci(1, 2, 3, 3) [1, 2, 3] >>> modified_fibonacci(1, 2, 3, 0) [] def run_test_cases(test_cases): Process the given test cases and print the results. Parameters: test_cases (list): A list of test case tuples, each containing four integers a, b, c, and N. >>> test_cases = [ ... (1, 1, 1, 5), ... (0, 1, 2, 7), ... (2, 3, 5, 6) ... ] >>> run_test_cases(test_cases) [[1, 1, 1, 3, 5], [0, 1, 2, 3, 6, 11, 20], [2, 3, 5, 10, 18, 33]]","solution":"def modified_fibonacci(a, b, c, N): Generates the first N numbers in a modified Fibonacci sequence starting with a, b, c. Parameters: a (int): The first number of the sequence. b (int): The second number of the sequence. c (int): The third number of the sequence. N (int): The number of terms to generate. Returns: list: The first N numbers of the modified Fibonacci sequence. if N <= 0: return [] elif N == 1: return [a] elif N == 2: return [a, b] elif N == 3: return [a, b, c] sequence = [a, b, c] for _ in range(3, N): next_val = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_val) return sequence def run_test_cases(test_cases): Process the given test cases and print the results. Parameters: test_cases (list): A list of test case tuples, each containing four integers a, b, c, and N. results = [] for case in test_cases: a, b, c, N = case result = modified_fibonacci(a, b, c, N) results.append(result) return results"},{"question":"def largest_adjacent_product(n: int) -> int: Returns the largest product of any two adjacent digits in the number n. >>> largest_adjacent_product(731674765) 42 >>> largest_adjacent_product(12345) 20 >>> largest_adjacent_product(5) 0","solution":"def largest_adjacent_product(n: int) -> int: Returns the largest product of any two adjacent digits in the number n. str_n = str(n) if len(str_n) < 2: return 0 max_product = 0 for i in range(len(str_n) - 1): product = int(str_n[i]) * int(str_n[i + 1]) if product > max_product: max_product = product return max_product"},{"question":"def is_pattern_in_substring(s: str, patterns: List[str], l: int, r: int) -> str: Determines if any of the patterns match the substring s[l:r]. >>> is_pattern_in_substring(\\"abcdefghijklmno\\", [\\"abc\\", \\"kmo\\"], 1, 5) \\"YES\\" >>> is_pattern_in_substring(\\"abcdefghijklmno\\", [\\"abc\\", \\"kmo\\"], 4, 8) \\"NO\\" >>> is_pattern_in_substring(\\"abcdefghijklmno\\", [\\"abc\\", \\"kmo\\"], 6, 10) \\"NO\\" >>> is_pattern_in_substring(\\"abcdefghijklmno\\", [\\"abc\\", \\"kmo\\"], 1, 15) \\"YES\\" pass def process_queries(n: int, q: int, s: str, p: int, patterns: List[str], queries: List[Tuple[int, int]]) -> List[str]: Processes multiple queries. >>> process_queries(15, 3, \\"abcdefghijklmno\\", 2, [\\"abc\\", \\"kmo\\"], [(1, 5), (4, 8), (6, 10)]) ['YES', 'NO', 'NO'] >>> process_queries(15, 4, \\"abcdefghijklmno\\", 2, [\\"abc\\", \\"kmo\\"], [(1, 3), (1, 4), (1, 15), (10, 15)]) ['YES', 'YES', 'YES', 'YES'] >>> process_queries(16, 3, \\"zzzzzzzzzzzzzzzz\\", 2, [\\"zzz\\", \\"zz\\"], [(1, 2), (1, 3), (5, 10)]) ['YES', 'YES', 'YES'] >>> process_queries(15, 3, \\"mnbvcxzpolkjhgf\\", 1, [\\"xyz\\"], [(1, 15), (1, 14), (2, 15)]) ['NO', 'NO', 'NO'] pass","solution":"def is_pattern_in_substring(s, patterns, l, r): Determines if any of the patterns match the substring s[l:r]. :param s: The original string :param patterns: List of patterns :param l: Start index (1-indexed) :param r: End index (1-indexed) :return: \\"YES\\" if any pattern matches the substring, \\"NO\\" otherwise substring = s[l-1:r] for pattern in patterns: idx = 0 for char in substring: if char == pattern[idx]: idx += 1 if idx == len(pattern): return \\"YES\\" return \\"NO\\" def process_queries(n, q, s, p, patterns, queries): Processes multiple queries. :param n: Length of the string :param q: Number of queries :param s: The original string :param p: Number of patterns :param patterns: List of patterns :param queries: List of queries, each query is a tuple (l, r) :return: List of results for each query results = [] for l, r in queries: results.append(is_pattern_in_substring(s, patterns, l, r)) return results"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. Time complexity: O(n log n) >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) 8 >>> longest_increasing_subsequence([8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([3, 2]) 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> arr = list(range(1000, 0, -1)) >>> longest_increasing_subsequence(arr) 1 >>> arr = list(range(1, 1001)) >>> longest_increasing_subsequence(arr) 1000","solution":"import bisect def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the array. Time complexity: O(n log n) if not arr: return 0 # create an array to store the smallest ending element of each increasing subsequence of length i+1 lis = [] for num in arr: # find the index where \`num\` can be placed to maintain the sorted order of \`lis\` pos = bisect.bisect_left(lis, num) # if pos is equal to the length of \`lis\`, it means \`num\` is greater than any element in \`lis\` if pos == len(lis): lis.append(num) else: lis[pos] = num # the length of \`lis\` will give the length of the longest increasing subsequence return len(lis)"},{"question":"def visible_buildings(heights: List[int]) -> List[int]: Returns the list of building heights that are visible from the left side. >>> visible_buildings([3, 7, 8, 3, 6, 1]) [3, 7, 8] >>> visible_buildings([1, 3, 2, 5, 4, 2, 6, 5, 7]) [1, 3, 5, 6, 7] # Test cases assert visible_buildings([3, 7, 8, 3, 6, 1]) == [3, 7, 8] assert visible_buildings([5]) == [5] assert visible_buildings([4, 4, 4, 4]) == [4] assert visible_buildings([1, 2, 3, 4]) == [1, 2, 3, 4] assert visible_buildings([4, 3, 2, 1]) == [4] assert visible_buildings([2, 5, 1, 8, 3, 4, 10]) == [2, 5, 8, 10] assert visible_buildings([1, 3, 2, 5, 4, 2, 6, 5, 7]) == [1, 3, 5, 6, 7] assert visible_buildings([1, 3, 1, 3, 1, 3]) == [1, 3]","solution":"def visible_buildings(heights): Returns the list of building heights that are visible from the left side. visible = [] max_height = 0 for height in heights: if height > max_height: visible.append(height) max_height = height return visible"},{"question":"def max_discount(prices: List[int], k: int) -> int: Determine the maximum discount a customer can receive if they buy the required number of items. The discount amount is the maximum difference between any two prices among the purchased items. Parameters: prices (List[int]): A list of integers where each integer represents the price of an item. k (int): The number of items a customer must buy to qualify for a discount. Returns: int: The maximum possible discount. >>> max_discount([10, 20, 30, 40, 50], 3) 40 >>> max_discount([50, 20, 1, 4, 60, 35], 4) 59 pass from solution import max_discount def test_discount_case_1(): prices = [10, 20, 30, 40, 50] k = 3 assert max_discount(prices, k) == 40 def test_discount_case_2(): prices = [50, 20, 1, 4, 60, 35] k = 4 assert max_discount(prices, k) == 59 def test_discount_with_two_items(): prices = [10, 15] k = 2 assert max_discount(prices, k) == 5 def test_discount_with_large_variation(): prices = [2, 7, 1, 8, 2, 8, 1, 8, 2, 8, 9] k = 5 assert max_discount(prices, k) == 8 def test_no_discount_insufficient_items(): prices = [100] k = 2 assert max_discount(prices, k) == 0 def test_discount_case_all_equal(): prices = [7, 7, 7, 7, 7] k = 3 assert max_discount(prices, k) == 0 def test_discount_with_minimum_k(): prices = [10, 90, 47, 50, 67] k = 2 assert max_discount(prices, k) == 80","solution":"def max_discount(prices, k): Returns the maximum possible discount a customer can receive by buying k items. The discount is the maximum difference between any two prices among the purchased items. if k < 2 or k > len(prices): return 0 # Not enough items to qualify for a discount # Find the minimum and maximum prices in the list min_price = min(prices) max_price = max(prices) # The discount is the difference between the maximum and minimum price discount = max_price - min_price return discount"},{"question":"def evaluate_passwords(T: int, passwords: List[str]) -> List[str]: Evaluate whether a list of passwords meet the specified requirements. Each password must contain at least one uppercase letter, one lowercase letter, and one digit. Additionally, it must be at least 8 characters long and no more than 20 characters long. :param T: int - Number of test cases :param passwords: list of strings - List of passwords to evaluate :return: list of strings - Each string is 'Valid' or 'Invalid' based on the evaluation >>> evaluate_passwords(4, [\\"Password123\\", \\"123\\", \\"abcdEfgh\\", \\"A1b2Cdef\\"]) [\\"Valid\\", \\"Invalid\\", \\"Invalid\\", \\"Valid\\"] >>> evaluate_passwords(3, [\\"abcdEFGH\\", \\"abcdefgh123\\", \\"ABCDEFGH1\\"]) [\\"Invalid\\", \\"Invalid\\", \\"Invalid\\"]","solution":"def evaluate_passwords(T, passwords): Evaluate whether a list of passwords meet the specified requirements. Requirements: - At least one uppercase letter - At least one lowercase letter - At least one digit - At least 8 characters long and no more than 20 characters long :param T: int - Number of test cases :param passwords: list of strings - List of passwords to evaluate :return: list of strings - Each string is 'Valid' or 'Invalid' based on the evaluation results = [] for password in passwords: if len(password) < 8 or len(password) > 20: results.append('Invalid') continue has_upper = any(char.isupper() for char in password) has_lower = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) if has_upper and has_lower and has_digit: results.append('Valid') else: results.append('Invalid') return results"},{"question":"def can_form_arithmetic_progression(input_list: List[int]) -> bool: Determines if the input list can be rearranged to form an arithmetic progression. Parameters: input_list (list): List of integers Returns: bool: True if the list can be rearranged to form an arithmetic progression, False otherwise Examples: >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 3, 5, 9]) False >>> can_form_arithmetic_progression([]) True >>> can_form_arithmetic_progression([5]) True >>> can_form_arithmetic_progression([0, -2, 2, -4, 4]) True","solution":"def can_form_arithmetic_progression(input_list): Determines if the input list can be rearranged to form an arithmetic progression. Parameters: input_list (list): List of integers Returns: bool: True if the list can be rearranged to form an arithmetic progression, False otherwise if len(input_list) < 2: return True input_list.sort() common_diff = input_list[1] - input_list[0] for i in range(2, len(input_list)): if input_list[i] - input_list[i - 1] != common_diff: return False return True"},{"question":"def analyze_rides(T: int, rides: List[Dict]) -> List[int]: Analyze the variations in speed between two timestamps of Joe's ride. :param T: The number of rides Joe wants to analyze. :param rides: A list of dictionaries, each containing: - 'N': The number of minutes the ride lasted. - 'S': Joe's speed recorded at the start of each minute. - 'Q': The number of queries Joe has for the ride. - 'queries': A list of tuples (L, R) describing each query. :return: A list of integers representing the number of speed variations for each query. >>> analyze_rides(2, [{'N': 5, 'S': [3, 5, 4, 2, 6], 'Q': 3, 'queries': [(1, 5), (2, 4), (3, 5)]}, {'N': 6, 'S': [1, 2, 3, 1, 2, 3], 'Q': 2, 'queries': [(1, 6), (4, 6)]}]) [4, 2, 2, 5, 2]","solution":"def analyze_rides(T, rides): results = [] for ride in rides: N = ride['N'] S = ride['S'] Q = ride['Q'] queries = ride['queries'] # Precompute number of speed variations for each minute speed_variations = [0] * N for i in range(1, N): speed_variations[i] = speed_variations[i-1] if S[i] != S[i-1]: speed_variations[i] += 1 # Answer each query using precomputed values for L, R in queries: if L == 1: results.append(speed_variations[R-1]) else: results.append(speed_variations[R-1] - speed_variations[L-1]) return results"},{"question":"def minimum_operations_to_sort_array(test_cases): Given an array of integers A of length N, determine the minimum number of operations required to sort the array in non-decreasing order. Each operation consists of choosing an index i (1 ≤ i < N) and swapping A[i] with A[i+1]. Parameters: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer N and a list of N integers representing the array A. Returns: List[int]: A list of integers where each integer corresponds to the minimum number of operations needed for each test case. Example: >>> test_cases = [(5, [2, 3, 1, 5, 4]), (4, [4, 3, 2, 1])] >>> minimum_operations_to_sort_array(test_cases) [3, 6] >>> test_cases = [(3, [1, 2, 3])] >>> minimum_operations_to_sort_array(test_cases) [0] def test_minimum_operations_to_sort_array(): # Test case from the example test_cases = [ (5, [2, 3, 1, 5, 4]), (4, [4, 3, 2, 1]) ] expected = [3, 6] assert minimum_operations_to_sort_array(test_cases) == expected # Test case where no swaps are needed (already sorted) test_cases = [ (3, [1, 2, 3]) ] expected = [0] assert minimum_operations_to_sort_array(test_cases) == expected # Test case where array has all duplicate values test_cases = [ (4, [1, 1, 1, 1]) ] expected = [0] assert minimum_operations_to_sort_array(test_cases) == expected # Test case with more elements test_cases = [ (5, [5, 4, 3, 2, 1]) ] expected = [10] assert minimum_operations_to_sort_array(test_cases) == expected # Test case with the minimum size array test_cases = [ (1, [1]) ] expected = [0] assert minimum_operations_to_sort_array(test_cases) == expected","solution":"def minimum_operations_to_sort_array(test_cases): results = [] for N, A in test_cases: swaps = 0 for i in range(N): for j in range(N - i - 1): if A[j] > A[j + 1]: A[j], A[j + 1] = A[j + 1], A[j] swaps += 1 results.append(swaps) return results"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Returns a new list containing only the unique elements from the original list, preserving the order of their first occurrence. >>> unique_elements([1, 2, 2, 3, 3, 4]) [1, 2, 3, 4] >>> unique_elements([1, 1, 1, 1]) [1] >>> unique_elements([]) [] >>> unique_elements([4, 5, 4, 6, 7, 5, 2, 6]) [4, 5, 6, 7, 2]","solution":"def unique_elements(lst): Returns the list of unique elements preserving their original order. seen = set() unique_lst = [] for num in lst: if num not in seen: seen.add(num) unique_lst.append(num) return unique_lst"},{"question":"def pivot_index(nums: List[int]) -> int: Returns the pivot index of the array where the sum of elements to the left is equal to the sum of elements to the right. If there is no such index, return -1. >>> pivot_index([1, 7, 3, 6, 5, 6]) == 3 >>> pivot_index([1, 2, 3]) == -1 >>> pivot_index([-1, -1, -1, 0, 1, 1]) == 0 >>> pivot_index([2, 1, -1]) == 0 >>> pivot_index([0, 0, 0, 0, 0, 0]) == 0 >>> pivot_index([100]) == 0 >>> pivot_index([]) == -1","solution":"def pivot_index(nums): Returns the pivot index of the array where the sum of elements to the left is equal to the sum of elements to the right. If there is no such index, return -1. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == total_sum - left_sum - num: return i left_sum += num return -1"},{"question":"def min_travel_distance(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Calculate the minimum travel distance required for Amanda to complete her trip in the Traveling Salesperson Problem. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): List of tuples where each tuple contains an integer N (number of cities) and a list of lists representing the distance matrix between cities. Returns: List[int]: A list containing the minimum travel distance for each test case. Examples: >>> min_travel_distance(2, [(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]), (3, [[0, 29, 20], [29, 0, 41], [20, 41, 0]])]) [80, 90] >>> min_travel_distance(1, [(2, [[0, 1], [1, 0]])]) [2]","solution":"import itertools def min_travel_distance(T, test_cases): results = [] for case in test_cases: N, distances = case cities = range(N) min_distance = float('inf') for permutation in itertools.permutations(cities[1:]): current_distance = 0 current_path = [0] + list(permutation) + [0] for i in range(len(current_path) - 1): current_distance += distances[current_path[i]][current_path[i + 1]] min_distance = min(min_distance, current_distance) results.append(min_distance) return results"},{"question":"def concatenate_with_hyphen(strings: List[str]) -> str: Concatenates all strings in the input array with a hyphen between each pair of adjacent strings. Parameters: strings (list): A list of strings to be concatenated. Returns: str: A single string formed by concatenating the input strings with hyphens. Example: >>> concatenate_with_hyphen([\\"this\\", \\"is\\", \\"a\\", \\"test\\"]) \\"this-is-a-test\\" >>> concatenate_with_hyphen([\\"hello\\", \\"world\\"]) \\"hello-world\\" >>> concatenate_with_hyphen([]) \\"\\" >>> concatenate_with_hyphen([\\"single\\"]) \\"single\\" >>> concatenate_with_hyphen([\\"repeat\\", \\"repeat\\", \\"repeat\\"]) \\"repeat-repeat-repeat\\"","solution":"def concatenate_with_hyphen(strings): Concatenates all strings in the input array with a hyphen between each pair of adjacent strings. Parameters: strings (list): A list of strings to be concatenated. Returns: str: A single string formed by concatenating the input strings with hyphens. return '-'.join(strings)"},{"question":"def factorial(n: int) -> int: Computes the factorial of a given number n. Args: n (int): non-negative integer to compute factorial of Returns: int: factorial of n Examples: >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(12) 479001600","solution":"def factorial(n): Computes the factorial of a given number n. Args: n (int): non-negative integer to compute factorial of Returns: int: factorial of n if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def is_palindrome(s: str) -> bool: Determines whether a given string is a palindrome. The function is case-insensitive and ignores all non-alphanumeric characters. >>> is_palindrome('A man, a plan, a canal: Panama') True >>> is_palindrome('racecar') True >>> is_palindrome('Hello') False >>> is_palindrome('No lemon, no melon') True >>> is_palindrome('Was it a car or a cat I saw?') True >>> is_palindrome('12321') True >>> is_palindrome('') True >>> is_palindrome('a') True >>> is_palindrome('Able was I ere I saw Elba') True >>> is_palindrome('MadamInEdenImAdam') True","solution":"def is_palindrome(s): Determines whether a given string is a palindrome. The function is case-insensitive and ignores all non-alphanumeric characters. # Remove non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered string is the same forward and backward return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a mapping of digits to letters (similar to the telephone buttons), and a digit string, return all possible letter combinations that the number could represent. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] pass def test_example1(): assert sorted(letter_combinations(\\"23\\")) == sorted([\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]) def test_example2(): assert letter_combinations(\\"\\") == [] def test_example3(): assert sorted(letter_combinations(\\"2\\")) == sorted([\\"a\\", \\"b\\", \\"c\\"]) def test_single_digit(): assert sorted(letter_combinations(\\"9\\")) == sorted([\\"w\\", \\"x\\", \\"y\\", \\"z\\"]) def test_duplicates(): assert sorted(letter_combinations(\\"22\\")) == sorted([\\"aa\\", \\"ab\\", \\"ac\\", \\"ba\\", \\"bb\\", \\"bc\\", \\"ca\\", \\"cb\\", \\"cc\\"]) def test_length_3(): assert sorted(letter_combinations(\\"234\\")) == sorted([\\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\"]) def test_length_4(): assert sorted(letter_combinations(\\"2345\\")) == sorted([ l1 + l2 + l3 + l4 for l1 in \\"abc\\" for l2 in \\"def\\" for l3 in \\"ghi\\" for l4 in \\"jkl\\" ])","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9, returns all possible letter combinations that the number could represent. if not digits: return [] digit_to_letters = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return for letter in digit_to_letters[digits[index]]: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def filter_and_sort_records(records, condition): Filters and sorts records based on the given condition and 'id' field. Parameters: - records (list of dict): A list of dictionaries where each dictionary represents a record with 'id' and 'value'. - condition (str): A string that contains a predicate for filtering records. Returns: - List[str]: A sorted list of 'value' fields from the records that satisfy the given condition. >>> records = [ >>> {'id': 3, 'value': 'apple'}, >>> {'id': 1, 'value': 'banana'}, >>> {'id': 4, 'value': 'cherry'}, >>> {'id': 2, 'value': 'date'} >>> ] >>> condition = \\"record['id'] % 2 != 0\\" >>> filter_and_sort_records(records, condition) ['banana', 'apple', 'cherry'] # Your code here from solution import filter_and_sort_records def test_records_with_odd_ids(): records = [ {'id': 3, 'value': 'apple'}, {'id': 1, 'value': 'banana'}, {'id': 4, 'value': 'cherry'}, {'id': 2, 'value': 'date'} ] condition = \\"record['id'] % 2 != 0\\" result = filter_and_sort_records(records, condition) assert result == ['banana', 'apple'] def test_records_with_even_ids(): records = [ {'id': 3, 'value': 'apple'}, {'id': 1, 'value': 'banana'}, {'id': 4, 'value': 'cherry'}, {'id': 2, 'value': 'date'} ] condition = \\"record['id'] % 2 == 0\\" result = filter_and_sort_records(records, condition) assert result == ['date', 'cherry'] def test_all_records(): records = [ {'id': 3, 'value': 'apple'}, {'id': 1, 'value': 'banana'}, {'id': 4, 'value': 'cherry'}, {'id': 2, 'value': 'date'} ] condition = \\"True\\" result = filter_and_sort_records(records, condition) assert result == ['banana', 'date', 'apple', 'cherry'] def test_no_records(): records = [ {'id': 3, 'value': 'apple'}, {'id': 1, 'value': 'banana'}, {'id': 4, 'value': 'cherry'}, {'id': 2, 'value': 'date'} ] condition = \\"False\\" result = filter_and_sort_records(records, condition) assert result == [] def test_greater_than_two_ids(): records = [ {'id': 3, 'value': 'apple'}, {'id': 1, 'value': 'banana'}, {'id': 4, 'value': 'cherry'}, {'id': 2, 'value': 'date'} ] condition = \\"record['id'] > 2\\" result = filter_and_sort_records(records, condition) assert result == ['apple', 'cherry']","solution":"def filter_and_sort_records(records, condition): Filters and sorts records based on the given condition and 'id' field. Parameters: - records (list of dict): A list of dictionaries where each dictionary represents a record with 'id' and 'value'. - condition (str): A string that contains a predicate for filtering records. Returns: - List[str]: A sorted list of 'value' fields from the records that satisfy the given condition. # Sorting records based on 'id' in ascending order sorted_records = sorted(records, key=lambda record: record['id']) # Filtering sorted records based on the condition filtered_values = [record['value'] for record in sorted_records if eval(condition)] return filtered_values"},{"question":"from typing import List def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the top k most frequent elements in the list. In case of ties, returns elements in decreasing order, and maintain order of first occurrence in case of same frequency and value. >>> top_k_frequent_elements([1,1,1,2,2,3], 2) [1, 2] >>> top_k_frequent_elements([1,1,2,2,3,3,4], 3) [1, 2, 3] >>> top_k_frequent_elements([1,2,2,3,3,3], 2) [3, 2] >>> top_k_frequent_elements([4,4,4,5,5,6,6,6,6,7], 1) [6]","solution":"from collections import Counter from typing import List def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the top k most frequent elements in the list. In case of ties, returns elements in decreasing order, and maintain order of first occurrence in case of same frequency and value. frequency = Counter(nums) sorted_elements = sorted(frequency, key=lambda x: (-frequency[x], nums.index(x))) return sorted_elements[:k]"},{"question":"def trap(height: List[int]) -> int: Calculate how much water it can trap after raining. :param height: List[int], list of non-negative integers representing the heights of the bars. :return: int, total amount of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([1, 1, 1, 1]) 0 >>> trap([2, 2, 2, 2]) 0 >>> trap([0,2,0,2]) 2 >>> trap([3, 0, 0, 0, 3]) 9 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Calculate how much water it can trap after raining. :param height: List[int], list of non-negative integers representing the heights of the bars. :return: int, total amount of trapped water. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from collections import defaultdict from typing import List, Dict def calculate_frequencies(arr: List[int]) -> Dict[int, int]: Calculate the frequency of each unique integer in the given list and return them in a sorted dictionary. Parameters: arr (List[int]): List of integers to count frequencies of. Returns: Dict[int, int]: Dictionary with integers as keys and their frequencies as values. >>> calculate_frequencies([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 4} >>> calculate_frequencies([4, 3, 2, 1]) {1: 1, 2: 1, 3: 1, 4: 1}","solution":"from collections import defaultdict from typing import List, Dict def calculate_frequencies(arr: List[int]) -> Dict[int, int]: Calculate the frequency of each unique integer in the given list. Parameters: arr (List[int]): List of integers to count frequencies of. Returns: Dict[int, int]: Dictionary with integers as keys and their frequencies as values. frequency_dict = defaultdict(int) for number in arr: frequency_dict[number] += 1 return dict(sorted(frequency_dict.items()))"},{"question":"from typing import List def count_non_increasing_days(temperatures: List[int]) -> int: Given a list of integers representing the temperatures of a city for the next 'n' days, this function will count the number of days where the temperature is not higher than the previous day's temperature. Examples: >>> count_non_increasing_days([30, 32, 31, 35, 34, 33, 36]) 3 >>> count_non_increasing_days([21, 21, 22, 20, 19, 18]) 4 >>> count_non_increasing_days([1, 2, 3, 4, 5]) 0 >>> count_non_increasing_days([30, 30, 30, 30]) 3 >>> count_non_increasing_days([25]) 0 >>> count_non_increasing_days([30, 29, 28, 27]) 3 >>> count_non_increasing_days([20, 20, 19, 22, 23, 22]) 3","solution":"from typing import List def count_non_increasing_days(temperatures: List[int]) -> int: Given a list of integers representing the temperatures of a city for the next 'n' days, this function will count the number of days where the temperature is not higher than the previous day's temperature. non_increasing_days = 0 for i in range(1, len(temperatures)): if temperatures[i] <= temperatures[i - 1]: non_increasing_days += 1 return non_increasing_days"},{"question":"from collections import deque def word_ladder(start: str, end: str, dictionary: set) -> int: Find the shortest transformation sequence from a start word to an end word, with all intermediate words being valid from the dictionary. Parameters: start (str): The start word end (str): The target word dictionary (set): A set containing all valid intermediate words Returns: int: The length of the shortest transformation sequence Examples: >>> start = \\"hit\\" >>> end = \\"cog\\" >>> dictionary = {\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\", \\"log\\"} >>> word_ladder(start, end, dictionary) 5 >>> start = \\"hit\\" >>> end = \\"cog\\" >>> dictionary = {\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"log\\"} >>> word_ladder(start, end, dictionary) 0 >>> start = \\"hit\\" >>> end = \\"hot\\" >>> dictionary = {\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\", \\"log\\"} >>> word_ladder(start, end, dictionary) 2 >>> start = \\"hit\\" >>> end = \\"cog\\" >>> dictionary = {\\"hit\\", \\"hat\\", \\"hut\\", \\"hog\\", \\"cog\\"} >>> word_ladder(start, end, dictionary) 0 >>> start = \\"hit\\" >>> end = \\"hit\\" >>> dictionary = {\\"hit\\"} >>> word_ladder(start, end, dictionary) 1","solution":"from collections import deque def word_ladder(start: str, end: str, dictionary: set) -> int: if end not in dictionary: return 0 if start == end: return 1 queue = deque([(start, 1)]) visited = set([start]) while queue: current_word, steps = queue.popleft() for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end: return steps + 1 if next_word in dictionary and next_word not in visited: visited.add(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"from datetime import datetime, timedelta def days_remaining_in_year(date_str: str) -> int: Returns the number of days remaining in the year from the given date in YYYY-MM-DD format. If the date is invalid, returns -1. Args: date_str (str): A string representing the date in YYYY-MM-DD format. Returns: int: Number of days remaining in the year, or -1 if the date is invalid. Examples: >>> days_remaining_in_year(\\"2023-01-01\\") 364 >>> days_remaining_in_year(\\"2020-12-31\\") 0 >>> days_remaining_in_year(\\"invalid-date\\") -1 pass def test_valid_dates(): assert days_remaining_in_year(\\"2023-01-01\\") == 364 assert days_remaining_in_year(\\"2020-12-31\\") == 0 assert days_remaining_in_year(\\"2020-01-01\\") == 365 assert days_remaining_in_year(\\"2021-11-19\\") == 42 assert days_remaining_in_year(\\"2022-07-07\\") == 177 assert days_remaining_in_year(\\"2019-02-28\\") == 306 def test_invalid_dates(): assert days_remaining_in_year(\\"invalid-date\\") == -1 assert days_remaining_in_year(\\"2023-02-30\\") == -1 assert days_remaining_in_year(\\"2022-13-01\\") == -1 assert days_remaining_in_year(\\"abcd-ef-gh\\") == -1 assert days_remaining_in_year(\\"2023-11-31\\") == -1","solution":"from datetime import datetime, timedelta def days_remaining_in_year(date_str): Returns the number of days remaining in the year from the given date in YYYY-MM-DD format. If the date is invalid, returns -1. try: given_date = datetime.strptime(date_str, \\"%Y-%m-%d\\") except ValueError: return -1 year_end = datetime(given_date.year, 12, 31) remaining_days = (year_end - given_date).days return remaining_days"},{"question":"def transform_string(s: str) -> str: Transforms the input string according to the following rules: 1. If the character is a lowercase letter (a-z), convert it to an uppercase letter (A-Z). 2. If the character is an uppercase letter (A-Z), convert it to a lowercase letter (a-z). 3. If the character is a digit (0-9), shift the digit by +1. If the digit is 9, it should become 0. >>> transform_string(\\"aBc123\\") \\"AbC234\\" >>> transform_string(\\"Z9a\\") \\"z0A\\" # Test cases def test_lowercase_to_uppercase(): assert transform_string(\\"abc\\") == \\"ABC\\" def test_uppercase_to_lowercase(): assert transform_string(\\"ABC\\") == \\"abc\\" def test_digits_shift(): assert transform_string(\\"123\\") == \\"234\\" assert transform_string(\\"789\\") == \\"890\\" assert transform_string(\\"9\\") == \\"0\\" def test_mixed_input(): assert transform_string(\\"aBc123\\") == \\"AbC234\\" assert transform_string(\\"Z9a\\") == \\"z0A\\" def test_empty_string(): assert transform_string(\\"\\") == \\"\\" def test_no_letters(): assert transform_string(\\"1234567890\\") == \\"2345678901\\" def test_no_digits(): assert transform_string(\\"aBcDeF\\") == \\"AbCdEf\\" def test_non_alphanumeric_chars(): assert transform_string(\\"a1!b2@C3#\\") == \\"A2!B3@c4#\\"","solution":"def transform_string(s: str) -> str: Transforms the input string according to the following rules: 1. If the character is a lowercase letter (a-z), convert it to an uppercase letter (A-Z). 2. If the character is an uppercase letter (A-Z), convert it to a lowercase letter (a-z). 3. If the character is a digit (0-9), shift the digit by +1. If the digit is 9, it should become 0. result = [] for char in s: if char.islower(): result.append(char.upper()) elif char.isupper(): result.append(char.lower()) elif char.isdigit(): result.append(str((int(char) + 1) % 10)) else: result.append(char) # Append non-alphanumeric characters unchanged return ''.join(result)"},{"question":"import re def find_unique_dates(n: int, test_cases: List[str]) -> List[int]: Identifies all unique dates in the format 'dd-mm-yyyy' from a given list of strings. Parameters: - n: An integer denoting the number of test cases. - test_cases: A list of strings, each containing Latin letters, digits, and punctuation marks. Returns: A list of integers, each representing the count of unique dates in 'dd-mm-yyyy' format in the corresponding input string. Examples: >>> find_unique_dates(1, [\\"On 12-05-2021 and on 15-05-2021 there are meetings.\\"]) [2] >>> find_unique_dates(1, [\\"Important dates: 01-01-2020, 02-02-2021, and 01-01-2020.\\"]) [2] results = [] date_pattern = re.compile(r'b(d{2}-d{2}-d{4})b') for case in test_cases: dates = set(re.findall(date_pattern, case)) results.append(len(dates)) return results def test_single_test_case(): assert find_unique_dates(1, [\\"On 12-05-2021 and on 15-05-2021 there are meetings.\\"]) == [2] def test_multiple_dates_single_test_case(): assert find_unique_dates(1, [\\"Important dates: 01-01-2020, 02-02-2021, and 01-01-2020.\\"]) == [2] def test_no_dates(): assert find_unique_dates(1, [\\"There are no dates in this string.\\"]) == [0] def test_mixed_content(): assert find_unique_dates(1, [\\"Meeting on 01-12-2020, conference on 12-01-2021, and again on 01-12-2020.\\"]) == [2] def test_multiple_test_cases(): assert find_unique_dates(2, [\\"On 12-05-2021 and on 15-05-2021 there are meetings.\\", \\"Important dates: 01-01-2020, 02-02-2021, and 01-01-2020.\\"]) == [2, 2] def test_empty_string(): assert find_unique_dates(1, [\\"\\"]) == [0] def test_edge_case_single_digit_in_dates(): assert find_unique_dates(1, [\\"In 05/07/2020 meetings will be hosted.\\"]) == [0] def test_same_date_different_formats(): assert find_unique_dates(1, [\\"Dates: 01-01-2020, 01-JAN-2020.\\"]) == [1]","solution":"import re def find_unique_dates(n, test_cases): This function takes in an integer n and a list of n strings (test_cases). It returns a list of integers where each integer is the number of unique dates in 'dd-mm-yyyy' format in the corresponding input string. results = [] date_pattern = re.compile(r'b(d{2}-d{2}-d{4})b') for case in test_cases: dates = set(re.findall(date_pattern, case)) results.append(len(dates)) return results"},{"question":"def compressString(s: str) -> str: Compress the string \`s\` by replacing sequences of repeated characters with the character followed by the count of consecutive occurrences. If the compressed string is not shorter than the original, return the original string. >>> compressString(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compressString(\\"abcdef\\") == \\"abcdef\\" >>> compressString(\\"\\") == \\"\\" >>> compressString(\\"a\\") == \\"a\\" >>> compressString(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" >>> compressString(\\"aabbccaa\\") == \\"aabbccaa\\" >>> compressString(\\"aaabbccddd\\") == \\"a3b2c2d3\\" >>> compressString(\\"aaaaaa\\") == \\"a6\\" >>> compressString(\\"ab\\") == \\"ab\\" >>> compressString(\\"aabb\\") == \\"aabb\\" >>> compressString(\\"aAaA\\") == \\"aAaA\\" >>> compressString(\\"aaaAAA\\") == \\"a3A3\\"","solution":"def compressString(s): Compresses the string by replacing sequences of repeated characters. If the compressed string is not shorter than the original, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed = ''.join(compressed) return compressed if len(compressed) < len(s) else s"},{"question":"def total_painting_time(T: int, test_cases: list) -> list: Computes the total time the painter will take to paint all boards including breaks. Arguments: T : int : Number of test cases test_cases : list : A list of tuples, each containing: - (N, B) : tuple : N is the number of boards, B is the break time in minutes - lengths : list : A list of integers representing the lengths of the boards Returns: list : Total time for each test case >>> total_painting_time(2, [((3, 5), [2, 3, 4]), ((2, 10), [6, 7])]) [19, 23] >>> total_painting_time(1, [((3, 0), [2, 3, 4])]) [9] >>> total_painting_time(1, [((1, 1), [1])]) [1]","solution":"def total_painting_time(T, test_cases): Computes the total time the painter will take to paint all boards including breaks. Arguments: T : int : Number of test cases test_cases : list : A list of tuples, each containing: - (N, B) : tuple : N is the number of boards, B is the break time in minutes - lengths : list : A list of integers representing the lengths of the boards Returns: list : Total time for each test case results = [] for i in range(T): (N, B), lengths = test_cases[i] total_time = sum(lengths) + (N - 1) * B results.append(total_time) return results"},{"question":"def traverse_grid(instructions: str) -> tuple: Returns the final coordinates after following the sequence of instructions. Args: instructions (str): sequence of 'U', 'D', 'L', 'R' representing moves on a 2D grid. Returns: tuple: final coordinates (x, y) after following all the instructions. Examples: >>> traverse_grid('UU') (0, 2) >>> traverse_grid('LR') (0, 0) >>> traverse_grid('UUDDLLRR') (0, 0) >>> traverse_grid('UURRDDLL') (0, 0) >>> traverse_grid('ULDR') (0, 0)","solution":"def traverse_grid(instructions): Returns the final coordinates after following the sequence of instructions. Args: instructions (str): sequence of 'U', 'D', 'L', 'R' representing moves on a 2D grid. Returns: tuple: final coordinates (x, y) after following all the instructions. x, y = 0, 0 for instr in instructions: if instr == 'U': y += 1 elif instr == 'D': y -= 1 elif instr == 'L': x -= 1 elif instr == 'R': x += 1 return (x, y)"},{"question":"def check_passphrase(passphrase: str) -> None: Checks if the passphrase adheres to the predefined rules for validation. The passphrase must follow these rules: 1. It must be at least 12 characters long. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must include at least one digit. 5. It must have at least one special character from this set: !@#%^&*()-+. # Your code here # Read input import sys input = sys.stdin.read().strip() # Validating the passphrase check_passphrase(input)","solution":"def check_passphrase(passphrase: str) -> None: Checks if the passphrase adheres to the predefined rules for validation. import re if len(passphrase) < 12: print(\\"Invalid\\") return if not re.search(r\\"[A-Z]\\", passphrase): print(\\"Invalid\\") return if not re.search(r\\"[a-z]\\", passphrase): print(\\"Invalid\\") return if not re.search(r\\"[0-9]\\", passphrase): print(\\"Invalid\\") return if not re.search(r\\"[!@#%^&*()-+]\\", passphrase): print(\\"Invalid\\") return print(\\"Valid\\")"},{"question":"def valley_points(arr): Returns the number of \\"valley\\" points in the array. A valley point is defined as an element which is strictly smaller than its immediate neighbors. >>> valley_points([2, 1, 2, 3, 1, 4]) 2 >>> valley_points([5, 3, 4, 3, 5, 1, 2, 1]) 3 >>> valley_points([1, 2]) 0 >>> valley_points([2, 1, 1, 2]) 0 >>> valley_points([3, 1, 3, 1, 3]) 2","solution":"def valley_points(arr): Returns the number of \\"valley\\" points in the array. A valley point is defined as an element which is strictly smaller than its immediate neighbors. if len(arr) < 3: return 0 valleys_count = 0 for i in range(1, len(arr) - 1): if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]: valleys_count += 1 return valleys_count"},{"question":"def find_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in a given string s. >>> find_longest_substring(\\"abrkaabcdefghijjxxx\\") 10 >>> find_longest_substring(\\"abcdef\\") 6 >>> find_longest_substring(\\"aaaaaa\\") 1 >>> find_longest_substring(\\"abcabcbb\\") 3 >>> find_longest_substring(\\"pwwkew\\") 3 >>> find_longest_substring(\\"\\") 0 >>> find_longest_substring(\\"a\\") 1","solution":"def find_longest_substring(s): Returns the length of the longest substring without repeating characters in a given string s. start = 0 max_length = 0 used_chars = {} for index, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, index - start + 1) used_chars[char] = index return max_length"},{"question":"def max_flowers(garden: List[List[int]], k: int) -> int: Returns the maximum sum of flowers in a 1 x k (horizontal) or k x 1 (vertical) segment. Parameters: garden (list of list of int): 2D grid of positive integers representing the garden. k (int): the length of the segment to select. Returns: int: the maximum sum of flowers in a valid segment. Examples: >>> max_flowers([ [1, 3, 1, 2], [2, 1, 2, 1], [1, 2, 3, 1] ], 2) 5 >>> max_flowers([ [1, 3, 1, 2], [2, 1, 2, 1], [1, 2, 3, 1] ], 3) 6","solution":"def max_flowers(garden, k): Returns the maximum sum of flowers in a 1 x k (horizontal) or k x 1 (vertical) segment. Parameters: garden (list of list of int): 2D grid of positive integers representing the garden. k (int): the length of the segment to select. Returns: int: the maximum sum of flowers in a valid segment. n = len(garden) m = len(garden[0]) if n > 0 else 0 max_sum = 0 # Check horizontal segments for i in range(n): for j in range(m - k + 1): current_sum = sum(garden[i][j:j + k]) if current_sum > max_sum: max_sum = current_sum # Check vertical segments for i in range(n - k + 1): for j in range(m): current_sum = sum(garden[i + l][j] for l in range(k)) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def daily_temperatures(N: int, temperatures: List[int]) -> List[int]: Given a list of daily temperatures, calculates the number of days until a warmer temperature for each day. Args: N: int - Number of days. temperatures: List[int] - List of daily temperatures. Returns: List[int] - List of days until a warmer temperature. pass # Example unit tests def test_example_case(): assert daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] def test_all_same_temperature(): assert daily_temperatures(5, [75, 75, 75, 75, 75]) == [0, 0, 0, 0, 0] def test_strictly_increasing(): assert daily_temperatures(5, [70, 71, 72, 73, 74]) == [1, 1, 1, 1, 0] def test_strictly_decreasing(): assert daily_temperatures(5, [74, 73, 72, 71, 70]) == [0, 0, 0, 0, 0] def test_single_day(): assert daily_temperatures(1, [75]) == [0] def test_random_temperatures(): assert daily_temperatures(6, [73, 74, 74, 71, 76, 75]) == [1, 3, 2, 1, 0, 0]","solution":"def daily_temperatures(N, temperatures): Given a list of daily temperatures, calculates the number of days until a warmer temperature for each day. Args: N: int - Number of days. temperatures: List[int] - List of daily temperatures. Returns: List[int] - List of days until a warmer temperature. result = [0] * N stack = [] for i in range(N): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def highest_depth_of_centroid_tree(n: int, edges: List[Tuple[int, int]]) -> int: Given a tree with \`N\` nodes and \`N-1\` edges, find the highest depth of the centroid tree created from the input tree. Depth of the centroid tree is defined as the maximum number of nodes from the root to any leaf in the centroid tree. Args: n: int - Number of nodes in the tree edges: List[Tuple[int, int]] - List of edges in the tree Returns: int: The highest depth of the centroid tree Examples: >>> highest_depth_of_centroid_tree(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> highest_depth_of_centroid_tree(1, []) 0 from solution import highest_depth_of_centroid_tree def test_highest_depth_small_tree(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] assert highest_depth_of_centroid_tree(n, edges) == 2 def test_highest_depth_large_tree(): n = 10 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (4, 9), (9, 10)] assert highest_depth_of_centroid_tree(n, edges) == 3 def test_balanced_tree(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] assert highest_depth_of_centroid_tree(n, edges) == 2 def test_single_node(): n = 1 edges = [] assert highest_depth_of_centroid_tree(n, edges) == 0 def test_linear_chain_tree(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] assert highest_depth_of_centroid_tree(n, edges) == 2","solution":"import sys sys.setrecursionlimit(200000) def get_subtree_sizes(tree, node, parent, subtree_sizes): subtree_sizes[node] = 1 for neighbor in tree[node]: if neighbor != parent: get_subtree_sizes(tree, neighbor, node, subtree_sizes) subtree_sizes[node] += subtree_sizes[neighbor] def find_centroid(tree, node, parent, subtree_sizes, n): for neighbor in tree[node]: if neighbor != parent and subtree_sizes[neighbor] > n // 2: return find_centroid(tree, neighbor, node, subtree_sizes, n) return node def decompose(tree, node, parent): centroid = find_centroid(tree, node, parent, subtree_sizes, subtree_sizes[node]) subtree_sizes[centroid] = 0 components_depth = [] for neighbor in tree[centroid]: if subtree_sizes[neighbor] > 0: components_depth.append(decompose(tree, neighbor, centroid)) if components_depth: return 1 + max(components_depth) else: return 0 def highest_depth_of_centroid_tree(n, edges): tree = [[] for _ in range(n + 1)] for u, v in edges: tree[u].append(v) tree[v].append(u) global subtree_sizes subtree_sizes = [0] * (n + 1) get_subtree_sizes(tree, 1, -1, subtree_sizes) return decompose(tree, 1, -1) # Example usage: n = 5 edges = [ (1, 2), (1, 3), (3, 4), (3, 5) ] print(highest_depth_of_centroid_tree(n, edges)) # Output: 2"},{"question":"from typing import List, Tuple def max_friends_scoring_points(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of friends who can score points based on the number sequence. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, where each tuple contains an integer N and a list of N integers. Returns: A list of integers where each integer represents the maximum number of friends who can score points for the corresponding test case. Examples: >>> max_friends_scoring_points(3, [(5, [4, 1, 3, 2, 5]), (4, [10, 20, 30, 25]), (2, [6, 7])]) [5, 4, 2] >>> max_friends_scoring_points(1, [(4, [1, 2, 3, 4])]) [4]","solution":"def max_friends_scoring_points(T, test_cases): results = [] for i in range(T): N, B = test_cases[i] # Sort the numbers and remove duplicates sorted_unique_B = sorted(set(B)) results.append(len(sorted_unique_B)) return results"},{"question":"MOD = 10**9 + 7 def compute_derangements(n: int) -> int: Compute the number of distinct derangements of a playlist of n songs. >>> compute_derangements(2) 1 >>> compute_derangements(3) 2 >>> compute_derangements(4) 9 >>> compute_derangements(0) 1 >>> compute_derangements(1) 0 >>> compute_derangements(5) 44 def number_of_derangements(test_cases: List[int]) -> List[int]: Compute the number of distinct derangements for a list of test cases. >>> number_of_derangements([2, 3, 4]) [1, 2, 9] >>> number_of_derangements([1, 5, 6]) [0, 44, 265] >>> number_of_derangements([10**6])[:10] [XXXXXXXXXX]","solution":"MOD = 10**9 + 7 def compute_derangements(n): if n == 0: return 1 elif n == 1: return 0 elif n == 2: return 1 # Initialize the first two values derangements = [0] * (n + 1) derangements[0] = 1 derangements[1] = 0 derangements[2] = 1 for i in range(3, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) % MOD return derangements[n] def number_of_derangements(test_cases): results = [] max_n = max(test_cases) derangements_up_to_max_n = [compute_derangements(i) for i in range(max_n + 1)] for n in test_cases: results.append(derangements_up_to_max_n[n]) return results"},{"question":"def alphabetical_order(s: str) -> str: Write a function that takes a string as input and returns the string with all of its characters rearranged in alphabetical order. >>> alphabetical_order(\\"hello\\") 'ehllo' >>> alphabetical_order(\\"apple\\") 'aelpp' >>> alphabetical_order(\\"python\\") 'hnopty' >>> alphabetical_order(\\"banana\\") 'aaabnn' >>> alphabetical_order(\\"xyz\\") 'xyz' >>> alphabetical_order(\\"a\\") 'a' >>> alphabetical_order(\\"\\") '' >>> alphabetical_order(\\"Hello\\") 'Hello' >>> alphabetical_order(\\"Apple\\") 'Aelpp' >>> alphabetical_order(\\"!hello\\") '!ehllo' >>> alphabetical_order(\\"123apple\\") '123aelpp' >>> alphabetical_order(\\"a1@b2#\\") '#12@ab'","solution":"def alphabetical_order(s): Returns a string with all of its characters rearranged in alphabetical order. Args: s (str): Input string. Returns: str: String with characters in alphabetical order. return ''.join(sorted(s))"},{"question":"def visible_buildings(skyline: List[int]) -> int: Returns the number of visible buildings in the skyline when viewed from the left side. Parameters: skyline (list): List of integers representing the heights of the buildings. Returns: int: Number of visible buildings. Example: >>> visible_buildings([3, 1, 4, 1, 5, 9, 2, 6, 5]) 4 >>> visible_buildings([1, 2, 3, 4, 5]) 5 >>> visible_buildings([9, 8, 7, 6, 5]) 1","solution":"def visible_buildings(skyline): Returns the number of visible buildings in the skyline when viewed from the left side. Parameters: skyline (list): List of integers representing the heights of the buildings. Returns: int: Number of visible buildings. if not skyline: return 0 visible_count = 1 current_max_height = skyline[0] for height in skyline[1:]: if height > current_max_height: visible_count += 1 current_max_height = height return visible_count"},{"question":"def can_be_palindrome(S: str) -> str: Determine if the string S can be reorganized to form a palindrome. :param S: The input string of uppercase English letters :return: \\"YES\\" if it can be rearranged to be a palindrome, otherwise \\"NO\\" >>> can_be_palindrome(\\"ABA\\") \\"YES\\" >>> can_be_palindrome(\\"ABCD\\") \\"NO\\" >>> can_be_palindrome(\\"MADAM\\") \\"YES\\" def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases and return the results. :param test_cases: List of tuples containing (N, S) for each test case :return: List of results for each test case, \\"YES\\" or \\"NO\\" >>> process_test_cases([(3, 'ABA'), (4, 'ABCD'), (5, 'MADAM')]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_be_palindrome(S): Determine if the string S can be reorganized to form a palindrome. :param S: The input string of uppercase English letters :return: \\"YES\\" if it can be rearranged to be a palindrome, otherwise \\"NO\\" from collections import Counter # Count the frequency of each character freq = Counter(S) # To form a palindrome, at most one character can have an odd count odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If there's more than one character with an odd frequency, return \\"NO\\" return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_test_cases(test_cases): Process multiple test cases and return the results. :param test_cases: List of tuples containing (N, S) for each test case :return: List of results for each test case, \\"YES\\" or \\"NO\\" results = [] for N, S in test_cases: results.append(can_be_palindrome(S)) return results"},{"question":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n. >>> sum_of_squares(3) 14 >>> sum_of_squares(4) 30","solution":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n. return sum(i ** 2 for i in range(1, n + 1)) # Example usage: # n = 3 # print(sum_of_squares(n)) # Output: 14"},{"question":"def count_ways(n: int) -> int: Calculate the number of unique ways to climb a staircase with 'n' steps, where one can climb 1, 2, or 3 steps at a time. >>> count_ways(4) 7 >>> count_ways(5) 13 def test_count_ways_1(): assert count_ways(1) == 1 def test_count_ways_2(): assert count_ways(2) == 2 def test_count_ways_3(): assert count_ways(3) == 4 def test_count_ways_4(): assert count_ways(4) == 7 def test_count_ways_5(): assert count_ways(5) == 13 def test_count_ways_10(): assert count_ways(10) == 274 def test_count_ways_15(): assert count_ways(15) == 5768 def test_count_ways_30(): assert count_ways(30) == 53798080","solution":"def count_ways(n: int) -> int: Calculate the number of unique ways to climb a staircase with 'n' steps, where one can climb 1, 2, or 3 steps at a time. # Base cases if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # DP array to store the number of ways to reach each step dp = [0] * (n + 1) # Base cases initialization dp[1], dp[2], dp[3] = 1, 2, 4 # Fill the dp array using the recurrence relation for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"def length_of_longest_subarray_with_2_distinct_integers(arr: List[int]) -> int: Given an array of integers, find the length of the longest contiguous subarray that contains at most 2 distinct integers. >>> length_of_longest_subarray_with_2_distinct_integers([1, 2, 1, 2, 3]) 4 >>> length_of_longest_subarray_with_2_distinct_integers([1, 2, 3, 4, 5]) 2 >>> length_of_longest_subarray_with_2_distinct_integers([1, 1, 1, 1]) 4 >>> length_of_longest_subarray_with_2_distinct_integers([1, 2, 1, 3, 4, 3, 2, 1]) 3 >>> length_of_longest_subarray_with_2_distinct_integers([1, 2, 1, 2, 1, 2, 1, 2]) 8 >>> length_of_longest_subarray_with_2_distinct_integers([1, 2]) 2 >>> length_of_longest_subarray_with_2_distinct_integers([1]) 1 >>> length_of_longest_subarray_with_2_distinct_integers([]) 0","solution":"def length_of_longest_subarray_with_2_distinct_integers(arr): from collections import defaultdict if len(arr) == 0: return 0 left = 0 right = 0 max_len = 0 num_count = defaultdict(int) while right < len(arr): num_count[arr[right]] += 1 while len(num_count) > 2: num_count[arr[left]] -= 1 if num_count[arr[left]] == 0: del num_count[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len # Example usage # arr = [1, 2, 1, 2, 3] # print(length_of_longest_subarray_with_2_distinct_integers(arr)) # should output 4"},{"question":"def factorial(n: int) -> int: Returns the factorial of a given number n. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(-5) == None","solution":"def factorial(n): Returns the factorial of a given number n. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. if n < 0: return None # Factorial is not defined for negative numbers elif n == 0 or n == 1: return 1 else: result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def highest_growth_trees(data): Determine which tree(s) has shown the highest growth over the recorded period. Parameters: data (list of list of int): Heights of each tree over a number of days Returns: list of int: 1-based index of the tree(s) with the highest growth pass from solution import highest_growth_trees def test_highest_growth_single_tree(): assert highest_growth_trees([[3, 4, 6, 8]]) == [1] def test_highest_growth_equal_growths(): assert highest_growth_trees([[3, 4, 6, 8], [2, 3, 5, 7]]) == [1, 2] def test_highest_growth_single_high_growth(): assert highest_growth_trees([[1, 3, 5], [2, 2, 5]]) == [1] def test_highest_growth_different_growths(): assert highest_growth_trees([[3, 5, 9], [1, 4, 7], [10, 20, 30]]) == [3] def test_highest_growth_multiple_trees_same_growth(): assert highest_growth_trees([[1, 2], [1, 2]]) == [1, 2] def test_multiple_days_varying_growth(): assert highest_growth_trees([[1, 3, 6, 10], [1, 2, 4, 7], [1, 5, 6, 12]]) == [3]","solution":"def highest_growth_trees(data): Determine which tree(s) has shown the highest growth over the recorded period. Parameters: data (list of list of int): Heights of each tree over a number of days Returns: list of int: 1-based index of the tree(s) with the highest growth growths = [] for i, tree in enumerate(data): growth = tree[-1] - tree[0] growths.append((i + 1, growth)) max_growth = max(growths, key=lambda x: x[1])[1] return [index for index, growth in growths if growth == max_growth]"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determine if there are two distinct indices i and j in the array nums such that nums[i] == nums[j] and the absolute difference between i and j is at most k. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False","solution":"def contains_nearby_duplicate(nums, k): Determine if there are two distinct indices i and j in the array nums such that nums[i] == nums[j] and the absolute difference between i and j is at most k. index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def sort_books_by_title(books): Sorts a list of book dictionaries alphabetically by title. Args: books (list): A list of dictionaries, each containing at least a 'title' key. Returns: list: A new list of dictionaries sorted by the 'title' key. Example usage: books = [ {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'}, {'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}, {'title': '1984', 'author': 'Another Author'} ] sorted_books = sort_books_by_title(books) # sorted_books should be: # [ # {'title': '1984', 'author': 'George Orwell'}, # {'title': '1984', 'author': 'Another Author'}, # {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, # {'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}, # {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'} # ] Test cases: def test_sort_books_by_title(): books = [ {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'}, {'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}, {'title': '1984', 'author': 'Another Author'} ] sorted_books = sort_books_by_title(books) expected_books = [ {'title': '1984', 'author': 'George Orwell'}, {'title': '1984', 'author': 'Another Author'}, {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, {'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'} ] assert sorted_books == expected_books def test_sort_books_with_same_title(): books = [ {'title': '1984', 'author': 'George Orwell'}, {'title': '1984', 'author': 'Another Author'}, {'title': '1984', 'author': 'An Unknown Author'} ] sorted_books = sort_books_by_title(books) expected_books = [ {'title': '1984', 'author': 'George Orwell'}, {'title': '1984', 'author': 'Another Author'}, {'title': '1984', 'author': 'An Unknown Author'} ] assert sorted_books == expected_books def test_sort_books_empty_list(): books = [] sorted_books = sort_books_by_title(books) expected_books = [] assert sorted_books == expected_books def test_sort_books_single_book(): books = [{'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}] sorted_books = sort_books_by_title(books) expected_books = [{'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}] assert sorted_books == expected_books def test_sort_books_various_titles(): books = [ {'title': 'A Tale of Two Cities', 'author': 'Charles Dickens'}, {'title': 'Moby-Dick', 'author': 'Herman Melville'}, {'title': 'Pride and Prejudice', 'author': 'Jane Austen'}, {'title': 'War and Peace', 'author': 'Leo Tolstoy'} ] sorted_books = sort_books_by_title(books) expected_books = [ {'title': 'A Tale of Two Cities', 'author': 'Charles Dickens'}, {'title': 'Moby-Dick', 'author': 'Herman Melville'}, {'title': 'Pride and Prejudice', 'author': 'Jane Austen'}, {'title': 'War and Peace', 'author': 'Leo Tolstoy'} ] assert sorted_books == expected_books","solution":"def sort_books_by_title(books): Sorts a list of book dictionaries alphabetically by title. Args: books (list): A list of dictionaries, each containing at least a 'title' key. Returns: list: A new list of dictionaries sorted by the 'title' key. return sorted(books, key=lambda book: book['title'])"},{"question":"from typing import List def findGroupLeader(arr: List[int]) -> int: Returns the count of the chosen leader. The leader must have a higher or equal count of elements than in any other group, but cannot belong to the group with the smallest count. If there are multiple possible leaders, the one with the smallest count among them should be chosen. >>> findGroupLeader([3, 4, 2, 5, 1]) 4 >>> findGroupLeader([5, 5, 5, 1]) 5 >>> findGroupLeader([5, 6, 7, 2, 3, 2]) 3 >>> findGroupLeader([1, 1, 1, 1, 2]) 2 >>> findGroupLeader([1, 1, 1, 1, 1]) -1 pass def test_case_1(): assert findGroupLeader([3, 4, 2, 5, 1]) == 4 def test_case_all_equal_except_one(): assert findGroupLeader([5, 5, 5, 1]) == 5 def test_case_multiple_minimums(): assert findGroupLeader([5, 6, 7, 2, 3, 2]) == 3 def test_case_all_elements_same(): assert findGroupLeader([1, 1, 1, 1, 2]) == 2 def test_case_no_possible_leader(): assert findGroupLeader([1, 1, 1, 1, 1]) == -1 def test_case_large_range(): assert findGroupLeader([1000, 999, 1000, 500, 999]) == 999 def test_case_single_group(): assert findGroupLeader([1, 2]) == 2 def test_case_last_element_leader(): assert findGroupLeader([3, 4, 5, 2]) == 3 # Run the tests if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"from typing import List def findGroupLeader(arr: List[int]) -> int: Returns the count of the chosen leader. # Find the minimum value in the array min_value = min(arr) # Filter out the minimum value possible_leaders = [val for val in arr if val != min_value] # If no possible leaders are left, return -1 if not possible_leaders: return -1 # Return the leader count, which is the smallest value among possible leaders return min(possible_leaders)"},{"question":"from typing import List def min_steps_to_reach_end(R: int, C: int, grid: List[str]) -> int: Determine the minimum number of steps needed to reach cell (R,C) from cell (1,1) in a grid. >>> min_steps_to_reach_end(4, 4, [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"]) == 6 >>> min_steps_to_reach_end(3, 3, [\\".#.\\", \\"#\\", \\"...\\"]) == -1 # Unit Test def test_min_steps_to_end_case1(): R = 4 C = 4 grid = [ \\"....\\", \\"..\\", \\".#..\\", \\"....\\" ] assert min_steps_to_reach_end(R, C, grid) == 6 def test_min_steps_no_possible_path(): R = 3 C = 3 grid = [ \\".#.\\", \\"#\\", \\"...\\", ] assert min_steps_to_reach_end(R, C, grid) == -1 def test_min_steps_direct_path(): R = 3 C = 3 grid = [ \\"...\\", \\"...\\", \\"...\\", ] assert min_steps_to_reach_end(R, C, grid) == 4 def test_min_steps_start_or_end_blocked(): R = 3 C = 3 grid = [ \\".#.\\", \\"...\\", \\".#.\\", ] assert min_steps_to_reach_end(R, C, grid) == 4 def test_min_steps_large_grid(): R = 5 C = 7 grid = [ \\".......\\", \\"..#..\\", \\"...#...\\", \\".#...\\", \\".......\\", ] assert min_steps_to_reach_end(R, C, grid) == 10","solution":"from collections import deque def min_steps_to_reach_end(R, C, grid): def is_valid(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (R-1, C-1) if grid[start[0]][start[1]] == '#' or grid[end[0]][end[1]] == '#': return -1 queue = deque([(start, 0)]) visited = set([start]) while queue: (x, y), steps = queue.popleft() if (x, y) == end: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), steps + 1)) return -1"},{"question":"def maximize_battery_energy(R: int, C: int, M: int, X: int, grid: List[List[int]]) -> int: Maximize the total energy of the battery grid after performing up to M recharging operations. Args: R (int): Number of rows in the battery grid. C (int): Number of columns in the battery grid. M (int): Maximum number of recharge operations. X (int): Power value increase per recharge operation. grid (List[List[int]]): Initial power values of the battery grid. Returns: int: The maximum possible total energy of the battery grid after performing up to M recharge operations. >>> maximize_battery_energy(3, 3, 5, 10, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 95 >>> maximize_battery_energy(2, 2, 4, 10, [ ... [0, 0], ... [0, 0] ... ]) == 40 >>> maximize_battery_energy(2, 3, 100, 1, [ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 122 >>> maximize_battery_energy(1, 1, 1, 1, [ ... [0] ... ]) == 1 >>> maximize_battery_energy(3, 3, 0, 10, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45","solution":"def maximize_battery_energy(R, C, M, X, grid): total_energy = sum(sum(row) for row in grid) # Flatten the grid to a list of cells cells = [grid[r][c] for r in range(R) for c in range(C)] # Sort cells based on their values in descending order cells.sort(reverse=True) # Add the additional energy using M operations each increasing energy by X for i in range(M): cells[i % (R * C)] += X return sum(cells)"},{"question":"def calculateTrappedWater(heights: List[int]) -> int: Calculate how much rainwater can be trapped between the walls after it rains. >>> calculateTrappedWater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> calculateTrappedWater([4,2,0,3,2,5]) 9","solution":"def calculateTrappedWater(heights): if not heights: return 0 left, right = 0, len(heights) - 1 max_left, max_right = heights[left], heights[right] trapped_water = 0 while left < right: if max_left <= max_right: left += 1 max_left = max(max_left, heights[left]) trapped_water += max(0, max_left - heights[left]) else: right -= 1 max_right = max(max_right, heights[right]) trapped_water += max(0, max_right - heights[right]) return trapped_water"},{"question":"def repeat_characters(s: str) -> str: Takes a string as input and returns a new string where each character in the original string is repeated once. >>> repeat_characters(\\"hello\\") 'hheelllloo' >>> repeat_characters(\\"\\") '' >>> repeat_characters(\\"a\\") 'aa' >>> repeat_characters(\\"!@#\\") '!!@@' >>> repeat_characters(\\"aA1!\\") 'aaAA11!!'","solution":"def repeat_characters(s): Takes a string as input and returns a new string where each character in the original string is repeated once. result = [] for char in s: result.append(char) result.append(char) return ''.join(result)"},{"question":"def find_magical_node(queries): Given the description of a tree, identify with the magical node for each query. The magical node is the centroid of the tree. If there are multiple centroids, choose the one with the smallest identifier. Args: queries: A list of tuples where each tuple contains an integer N (number of nodes) and a list of edges. Returns: A list of integers representing the magical node for each query. pass def process_input(input_data): Process the input data and return the results for each query. Args: input_data: A string containing the number of queries, followed by the tree descriptions. Returns: A list of integers where each integer is the result of the corresponding query. pass def test_example(): input_data = \\"2n6n1 2n2 3n3 4n4 5n2 6n4n1 2n1 3n1 4n\\" assert process_input(input_data) == [3, 1] def test_single_node(): input_data = \\"1n1n\\" assert process_input(input_data) == [1] def test_star_shaped_tree(): input_data = \\"1n5n1 2n1 3n1 4n1 5n\\" assert process_input(input_data) == [1] def test_line_tree(): input_data = \\"1n4n1 2n2 3n3 4n\\" assert process_input(input_data) == [2] def test_binary_tree(): input_data = \\"1n7n1 2n1 3n2 4n2 5n3 6n3 7n\\" assert process_input(input_data) == [1]","solution":"from collections import deque def find_centroids(tree_adj_list, N): if N == 1: return [0] # Find all leaves leaves = deque() degrees = [0] * N for i in range(N): degrees[i] = len(tree_adj_list[i]) if degrees[i] == 1: leaves.append(i) remaining_nodes = N while remaining_nodes > 2: leaves_count = len(leaves) remaining_nodes -= leaves_count for _ in range(leaves_count): leaf = leaves.popleft() for neighbor in tree_adj_list[leaf]: degrees[neighbor] -= 1 if degrees[neighbor] == 1: leaves.append(neighbor) return list(leaves) def find_magical_node(queries): results = [] for query in queries: N, edges = query tree_adj_list = [[] for _ in range(N)] for u, v in edges: tree_adj_list[u-1].append(v-1) tree_adj_list[v-1].append(u-1) centroids = find_centroids(tree_adj_list, N) results.append(centroids[0] + 1) return results # Define a function to read input and produce output def process_input(input_data): lines = input_data.strip().split() idx = 0 Q = int(lines[idx]) idx += 1 queries = [] for _ in range(Q): N = int(lines[idx]) idx += 1 edges = [] for _ in range(N - 1): u = int(lines[idx]) v = int(lines[idx + 1]) edges.append((u, v)) idx += 2 queries.append((N, edges)) return find_magical_node(queries)"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns an array where each element at index i is the product of all elements in the input array except the one at i. Args: nums (List[int]): The input list of integers. Returns: List[int]: A list of integers where each element is the product of all elements in the input list except the one at the same index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 0, 1]) [0, 0, 0, 0] >>> product_except_self([3, 4]) [4, 3]","solution":"def product_except_self(nums): Returns an array where each element at index i is the product of all elements in the input array except the one at i. n = len(nums) output = [1] * n left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def rearrange_flowers(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[List[Tuple[int, int, int, int]]]: Gemma is a passionate gardener who loves growing flowers. She has N flower beds in a line, and each bed initially contains a certain number of flowers. Each flower bed potentially has flowers of different types, and Gemma has M distinct flower types. Gemma wants to rearrange the flowers such that each flower bed contains only up to 2 different types of flowers. Your task is to help Gemma achieve this arrangement. It can be shown that there will always be at least one valid solution under given constraints. If there are multiple correct solutions, you may output any one of them. Parameters: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[List[int]]]]): A list of test cases where each test case is a tuple containing a tuple of (N, M) and a list of N beds each containing M integers representing the number of each flower type in the bed. Returns: List[List[Tuple[int, int, int, int]]]: For each test case, a list of N lines where each line contains 4 space-separated integers (c1, m1, c2, m2) representing that there are m1 flowers of type c1 and m2 flowers of type c2 in the i-th bed. Example: >>> rearrange_flowers(1, [((3, 3), [[3, 1, 2], [0, 4, 1], [5, 2, 3]])]) [[(0, 3, 2, 2), (1, 4, 2, 1), (0, 5, 2, 3)]] import pytest from solution import rearrange_flowers def test_example_case(): T = 1 test_cases = [ ( (3, 3), [ [3, 1, 2], [0, 4, 1], [5, 2, 3] ] ) ] expected = [ [ (0, 3, 2, 2), (1, 4, 2, 1), (0, 5, 2, 3) ] ] assert rearrange_flowers(T, test_cases) == expected def test_minimal_case(): T = 1 test_cases = [ ( (2, 2), [ [1, 2], [0, 3] ] ) ] expected = [ [ (1, 2, 0, 1), (1, 3, 0, 0) ] ] assert rearrange_flowers(T, test_cases) == expected def test_multiple_cases(): T = 2 test_cases = [ ( (2, 3), [ [2, 3, 1], [0, 2, 5] ] ), ( (2, 2), [ [2, 1], [3, 0] ] ) ] expected = [ [ (1, 3, 0, 2), (2, 5, 1, 2) ], [ (0, 2, 1, 1), (0, 3, 1, 0) ] ] assert rearrange_flowers(T, test_cases) == expected def test_edge_case_large(): T = 1 test_cases = [ ( (1000, 3), [ [i % 3, (i+1) % 3, (i+2) % 3] for i in range(1000) ] ) ] results = rearrange_flowers(T, test_cases) assert len(results) == 1 assert len(results[0]) == 1000 assert all(len(r) == 4 for r in results[0])","solution":"def rearrange_flowers(T, test_cases): results = [] for t in range(T): N, M = test_cases[t][0] beds = test_cases[t][1] result = [] for bed in beds: # Find the two types with the most flowers flower_types = [(count, ftype) for ftype, count in enumerate(bed)] flower_types.sort(reverse=True, key=lambda x: x[0]) c1, m1 = flower_types[0][1], flower_types[0][0] c2, m2 = flower_types[1][1], flower_types[1][0] result.append((c1, m1, c2, m2)) results.append(result) return results"},{"question":"def longest_consistent_performance(scores: List[List[int]]) -> List[int]: Given the scores of each student in multiple tests, returns a list of the lengths of the longest non-decreasing subarrays for each student. >>> longest_consistent_performance([[10, 20, 30, 25, 35]]) == [3] >>> longest_consistent_performance([ [5, 4, 3, 2, 1], [1, 2, 2, 3, 4], [8, 8, 8, 8, 8] ]) == [1, 5, 5] >>> longest_consistent_performance([[5, 4, 3, 2, 1]]) == [1] >>> longest_consistent_performance([[1, 2, 3, 4, 5]]) == [5] >>> longest_consistent_performance([[2, 2, 2, 2, 2]]) == [5] >>> longest_consistent_performance([[]]) == [0] >>> longest_consistent_performance([[10], [20], [30]]) == [1, 1, 1] >>> longest_consistent_performance([ [1, 3, 5, 4, 6], [2, 2, 2, 3, 1] ]) == [3, 4]","solution":"def longest_consistent_performance(scores): Given the scores of each student in multiple tests, returns a list of the lengths of the longest non-decreasing subarrays for each student. Parameters: scores (list of list of int): A list of lists of integers representing the scores of each student. Returns: list of int: A list of integers where each integer represents the length of the longest non-decreasing subarray for each respective student. def longest_non_decreasing_subarray_length(student_scores): if not student_scores: return 0 max_length = 1 current_length = 1 for i in range(1, len(student_scores)): if student_scores[i] >= student_scores[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length) return [longest_non_decreasing_subarray_length(student) for student in scores]"},{"question":"def deepReverse(arr): Reverses the order of all elements within an array, including any within inner-level arrays, while maintaining their original structure. :param arr: List of elements to be reversed, including nested lists. :return: List where all elements and nested elements are reversed. >>> deepReverse([1, 2, 3]) [3, 2, 1] >>> deepReverse([\\"x\\", \\"y\\", [\\"z\\"]]) [[\\"z\\"], \\"y\\", \\"x\\"] >>> deepReverse([1, 2, [3, 4, [5]]]) [[[5], 4, 3], 2, 1] >>> deepReverse([]) [] >>> deepReverse([1]) [1] >>> deepReverse([1, \\"a\\", [2, \\"b\\", [3, \\"c\\"]]]) [[[\\"c\\", 3], \\"b\\", 2], \\"a\\", 1] >>> deepReverse([[1, 2], [3, 4]]) [[4, 3], [2, 1]] >>> deepReverse([1, [], 2]) [2, [], 1] >>> deepReverse([[\\"a\\", \\"a\\"], \\"b\\", [\\"c\\", \\"c\\"]]) [[\\"c\\", \\"c\\"], \\"b\\", [\\"a\\", \\"a\\"]]","solution":"def deepReverse(arr): Reverses the order of all elements within an array, including any within inner-level arrays, while maintaining their original structure. :param arr: List of elements to be reversed, including nested lists. :return: List where all elements and nested elements are reversed. if not isinstance(arr, list): return arr return [deepReverse(item) for item in reversed(arr)]"},{"question":"def get_temperature_schedule(schedule: List[Tuple[int, int]]) -> List[int]: Given a schedule of temperature changes throughout the day, return the temperature for each hour of the day. :param schedule: List of tuples, each containing an hour (0-23) and the temperature for that hour. :return: List of 24 integers representing the temperature for each hour of the day. >>> get_temperature_schedule([]) [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] >>> get_temperature_schedule([(12, 18)]) [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18] >>> get_temperature_schedule([(5, 18), (9, 22), (15, 25), (22, 19)]) [20, 20, 20, 20, 20, 18, 18, 18, 18, 22, 22, 22, 22, 22, 22, 25, 25, 25, 25, 25, 25, 25, 19, 19] >>> get_temperature_schedule([(0, 18)]) [18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18] >>> get_temperature_schedule([(23, 18)]) [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 18]","solution":"def get_temperature_schedule(schedule): Given a schedule of temperature changes throughout the day, return the temperature for each hour of the day. :param schedule: List of tuples, each containing an hour (0-23) and the temperature for that hour. :return: List of 24 integers representing the temperature for each hour of the day. # Initialize the temperature list with the default temperature 20 temperatures = [20] * 24 # Sort the schedule by the hour to ensure the changes are applied in order schedule.sort() # Apply the temperature changes as specified in the schedule for hour, temp in schedule: for i in range(hour, 24): temperatures[i] = temp return temperatures"},{"question":"def min_time_to_collect(N: int, M: int, grid: List[List[int]]) -> int: Calculate the minimum time required for Catnip to collect all shiny objects from the top-left to the bottom-right corner. >>> min_time_to_collect(3, 3, [ ... [1, 2, 3], ... [4, 8, 2], ... [1, 5, 3] ... ]) 8 >>> min_time_to_collect(1, 1, [[5]]) 5","solution":"def min_time_to_collect(N, M, grid): dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Calculate the sum of the largest contiguous subarray within the array. >>> max_subarray_sum([1, -2, 3, 4, -5, 6]) 8 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7","solution":"def max_subarray_sum(arr): Returns the sum of the largest contiguous subarray within the array. Uses Kadane's Algorithm for O(n) time complexity. max_so_far = -float('inf') max_ending_here = 0 for num in arr: max_ending_here = max_ending_here + num if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far"},{"question":"def missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that does not appear in nums. >>> missing_positive([3, 4, -1, 1]) 2 >>> missing_positive([1, 2, 0]) 3 >>> missing_positive([7, 8, 9, 11, 12]) 1","solution":"def missing_positive(nums): Returns the smallest positive integer that does not appear in nums. :param nums: List[int] - A list of integers :return: int - The smallest positive integer not in nums n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap elements to their correct positions nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def reverse_words_in_sentence(sentence: str) -> str: Given a sentence, reverse the characters in each word while maintaining the order of words. :param sentence: str, an input sentence :return: str, the transformed sentence with each word's characters reversed pass def process_test_cases(test_cases: List[str]) -> List[str]: Given multiple test cases, process each to reverse words in the sentence. :param test_cases: list of str, an input list of sentences :return: list of str, the list of transformed sentences pass def test_reverse_words_in_sentence(): assert reverse_words_in_sentence(\\"Hello World\\") == \\"olleH dlroW\\" assert reverse_words_in_sentence(\\"Coding is fun\\") == \\"gnidoC si nuf\\" assert reverse_words_in_sentence(\\"OpenAI GPT\\") == \\"IAnepO TPG\\" assert reverse_words_in_sentence(\\"Python Programming\\") == \\"nohtyP gnimmargorP\\" assert reverse_words_in_sentence(\\"a ab abc abcd\\") == \\"a ba cba dcba\\" def test_process_test_cases(): assert process_test_cases([\\"Hello World\\", \\"Coding is fun\\", \\"OpenAI GPT\\"]) == [\\"olleH dlroW\\", \\"gnidoC si nuf\\", \\"IAnepO TPG\\"] assert process_test_cases([\\"Python Programming\\"]) == [\\"nohtyP gnimmargorP\\"] assert process_test_cases([\\"a ab abc abcd\\"]) == [\\"a ba cba dcba\\"] assert process_test_cases([\\"\\"]) == [\\"\\"] assert process_test_cases([\\"singleword\\"]) == [\\"drowelgnis\\"]","solution":"def reverse_words_in_sentence(sentence): Given a sentence, reverse the characters in each word while maintaining the order of words. :param sentence: str, an input sentence :return: str, the transformed sentence with each word's characters reversed return ' '.join(word[::-1] for word in sentence.split()) def process_test_cases(test_cases): Given multiple test cases, process each to reverse words in the sentence. :param test_cases: list of str, an input list of sentences :return: list of str, the list of transformed sentences return [reverse_words_in_sentence(sentence) for sentence in test_cases]"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Removes duplicates from the input list while preserving the order of first occurrence of each element. >>> remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) == [1] >>> remove_duplicates([]) == [] >>> remove_duplicates([1, -1, 2, 2, -1, 3, 3, -2]) == [1, -1, 2, 3, -2]","solution":"def remove_duplicates(lst): Removes duplicates from the input list while preserving the order of first occurrence of each element. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def perfect_number_check(n: int) -> bool: Check if a number is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. Parameters: n (int): The number to check. Returns: bool: True if n is a perfect number, False otherwise. Examples: >>> perfect_number_check(6) True >>> perfect_number_check(28) True >>> perfect_number_check(12) False >>> perfect_number_check(1) False from pytest import raises def test_perfect_number_check(): assert perfect_number_check(6) == True assert perfect_number_check(28) == True assert perfect_number_check(12) == False assert perfect_number_check(1) == False assert perfect_number_check(496) == True assert perfect_number_check(8128) == True assert perfect_number_check(33550336) == True def test_non_perfect_numbers(): assert perfect_number_check(2) == False assert perfect_number_check(3) == False assert perfect_number_check(4) == False assert perfect_number_check(5) == False assert perfect_number_check(31) == False def test_large_non_perfect_numbers(): assert perfect_number_check(10000) == False assert perfect_number_check(50000000) == False","solution":"def perfect_number_check(n): Check if a number is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. Parameters: n (int): The number to check. Returns: bool: True if n is a perfect number, False otherwise. if n <= 1: return False sum_divisors = 1 # start with 1 because 1 is a proper divisor for all n > 1 sqrt_n = int(n**0.5) # find the integer square root of n for i in range(2, sqrt_n + 1): if n % i == 0: sum_divisors += i if i != n // i: sum_divisors += n // i return sum_divisors == n"},{"question":"def is_valid_number(s: str) -> bool: Checks if a given string s is a valid number according to the specified criteria. A valid number includes: - An optional sign followed by digits. - Digits with optional decimal point. - Digits with optional exponent part. - Combination of digits with decimal point and exponent part. Invalid representations include: - Multiple signs, misplaced delimiters. - Trailing characters that aren't formatted correctly. :param s: Input string to be checked. :return: Boolean value indicating validity of the number. from typing import List def test_valid_numbers(): Unit tests for valid numbers. assert is_valid_number(\\"123\\") == True assert is_valid_number(\\"-456\\") == True assert is_valid_number(\\"+789\\") == True assert is_valid_number(\\"0.123\\") == True assert is_valid_number(\\"-3.14\\") == True assert is_valid_number(\\"+0.5\\") == True assert is_valid_number(\\"1e10\\") == True assert is_valid_number(\\"-3e-2\\") == True assert is_valid_number(\\"+4.5e+1\\") == True assert is_valid_number(\\"0.1e2\\") == True assert is_valid_number(\\"-3.14e-2\\") == True assert is_valid_number(\\"+6.022e23\\") == True assert is_valid_number(\\" +6.022e23 \\") == True def test_invalid_numbers(): Unit tests for invalid numbers. assert is_valid_number(\\"--1\\") == False assert is_valid_number(\\"123+\\") == False assert is_valid_number(\\"-.\\") == False assert is_valid_number(\\"e10\\") == False assert is_valid_number(\\"1.2.3\\") == False assert is_valid_number(\\"3-2\\") == False assert is_valid_number(\\".\\") == False assert is_valid_number(\\"12e+\\") == False assert is_valid_number(\\"7e\\") == False assert is_valid_number(\\"6.022e+ 23\\") == False assert is_valid_number(\\"\\") == False","solution":"def is_valid_number(s: str) -> bool: Checks if a given string s is a valid number according to the specified criteria. A valid number includes: - An optional sign followed by digits. - Digits with optional decimal point. - Digits with optional exponent part. - Combination of digits with decimal point and exponent part. Invalid representations include: - Multiple signs, misplaced delimiters. - Trailing characters that aren't formatted correctly. :param s: Input string to be checked. :return: Boolean value indicating validity of the number. import re s = s.strip() # Remove leading and trailing spaces pattern = re.compile( r'^[+-]?((d+(.d*)?)|(.d+))([eE][+-]?d+)?' ) return bool(pattern.match(s))"},{"question":"def is_palindrome(s: str) -> str: Determine if a given string is a palindrome. A palindrome is a word that reads the same backward as forward. >>> is_palindrome(\\"abccba\\") \\"YES\\" >>> is_palindrome(\\"abcde\\") \\"NO\\" >>> is_palindrome(\\"racecar\\") \\"YES\\" >>> is_palindrome(\\"abcdefg\\") \\"NO\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"\\") \\"YES\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the string s is a palindrome, otherwise returns \\"NO\\". if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(lst, parent_idx=0): Helper function to build a binary tree from a list. if parent_idx >= len(lst) or lst[parent_idx] is None: return None root = TreeNode(lst[parent_idx]) root.left = build_tree_from_list(lst, 2 * parent_idx + 1) root.right = build_tree_from_list(lst, 2 * parent_idx + 2) return root def lowest_common_ancestor(root, p, q): Finds the lowest common ancestor of two given nodes in a binary tree. >>> tree_list = [3, 5, 1, 6, 2, 0, 8, None, None, 7, 4] >>> root = build_tree_from_list(tree_list) >>> lowest_common_ancestor(root, 5, 1).val 3 >>> lowest_common_ancestor(root, 5, 4).val 5 >>> lowest_common_ancestor(root, 6, 4).val 5 >>> lowest_common_ancestor(root, 7, 4).val 2 >>> lowest_common_ancestor(root, 0, 8).val 1 >>> lowest_common_ancestor(root, 6, 8).val 3","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(lst, parent_idx=0): Helper function to build a binary tree from a list. if parent_idx >= len(lst) or lst[parent_idx] is None: return None root = TreeNode(lst[parent_idx]) root.left = build_tree_from_list(lst, 2 * parent_idx + 1) root.right = build_tree_from_list(lst, 2 * parent_idx + 2) return root def lowest_common_ancestor(root, p, q): Finds the lowest common ancestor of two given nodes in a binary tree. if not root or root.val == p or root.val == q: return root left = lowest_common_ancestor(root.left, p, q) right = lowest_common_ancestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"def longest_subarray_with_distinct_elements(arr: List[int]) -> int: Given an array of integers, find the length of the longest subarray that contains only distinct elements. If the array is empty or contains only one element, return the array's length. Example: >>> longest_subarray_with_distinct_elements([4, 2, 6, 4, 3, 2, 5, 6]) 5 >>> longest_subarray_with_distinct_elements([1, 2, 3, 1, 2, 3]) 3","solution":"def longest_subarray_with_distinct_elements(arr): Returns the length of the longest subarray with distinct elements. If the array is empty or contains only one element, returns the length of the array. if len(arr) < 2: return len(arr) # Dictionary to store the last positions of each element last_seen = {} max_length = 0 start = 0 for i, value in enumerate(arr): if value in last_seen: start = max(start, last_seen[value] + 1) last_seen[value] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def capitalize_words(sentence: str) -> str: Capitalizes the first letter of each word in the given sentence and converts the rest of the letters to lowercase. :param sentence: str, input string with one or more words :return: str, formatted string >>> capitalize_words(\\"hello\\") 'Hello' >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\"hElLo wOrLd\\") 'Hello World' >>> capitalize_words(\\"HELLO WORLD\\") 'Hello World' >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\" hello world \\") 'Hello World' >>> capitalize_words(\\" hELLo WorLD \\") 'Hello World'","solution":"def capitalize_words(sentence): Capitalizes the first letter of each word in the given sentence and converts the rest of the letters to lowercase. :param sentence: str, input string with one or more words :return: str, formatted string words = sentence.split() capitalized_words = [word.capitalize() for word in words] return ' '.join(capitalized_words)"},{"question":"def min_operations_to_make_equal(N: int, A: List[int]) -> int: Determines the minimum number of operations to make all elements in the array equal by incrementing or decrementing any element by 1. Parameters: N (int): The number of elements in the array. A (list of int): The array of integers. Returns: int: The minimum number of operations if possible or -1 if not possible. >>> min_operations_to_make_equal(5, [1, 2, 3, 4, 5]) == 6 >>> min_operations_to_make_equal(1, [5]) == 0 >>> min_operations_to_make_equal(2, [1, 2]) == 1 >>> min_operations_to_make_equal(3, [-1, -2, -3]) == 2 >>> min_operations_to_make_equal(5, [-10, -5, 0, 5, 10]) == 30 >>> min_operations_to_make_equal(3, [1000000000, 1000000000, 1000000000]) == 0 >>> min_operations_to_make_equal(3, [1, 3, 5]) == 4 >>> min_operations_to_make_equal(3, [-1000000000, 0, 1000000000]) == 2000000000","solution":"def min_operations_to_make_equal(N, A): Determines the minimum number of operations to make all elements in the array equal by incrementing or decrementing any element by 1. Parameters: N (int): The number of elements in the array. A (list of int): The array of integers. Returns: int: The minimum number of operations if possible or -1 if not possible. A.sort() median = A[N // 2] return sum(abs(x - median) for x in A)"},{"question":"class FileSystem: def __init__(self): self.folders = {'/': {'size': 0, 'subfolders': {}}} def create_folder(self, parent_path, folder_name): path = parent_path + '/' + folder_name if parent_path != '/' else '/' + folder_name if parent_path in self.folders: self.folders[path] = {'size': 0, 'subfolders': {}} self.folders[parent_path]['subfolders'][folder_name] = path def delete_folder(self, folder_path): if folder_path in self.folders: parent_path = '/'.join(folder_path.split('/')[:-1]) folder_name = folder_path.split('/')[-1] if parent_path == '': parent_path = '/' if folder_name in self.folders[parent_path]['subfolders']: del self.folders[parent_path]['subfolders'][folder_name] del self.folders[folder_path] def move_file(self, source_path, target_path, file_size): if source_path in self.folders and target_path in self.folders: self.folders[target_path]['size'] += file_size def query_size(self, folder_path): def get_total_size(path): total_size = self.folders[path]['size'] for sub_path in self.folders[path]['subfolders'].values(): total_size += get_total_size(sub_path) return total_size return get_total_size(folder_path) def process_operations(n, operations): Process a list of operations on the file system and returns the results of QUERY operations. >>> operations = [ ... \\"CREATE / folder1\\", ... \\"CREATE / folder2\\", ... \\"CREATE /folder1 folder3\\", ... \\"MOVE /folder1 /folder1/folder3 100\\", ... \\"MOVE / /folder1 200\\", ... \\"QUERY /\\", ... \\"QUERY /folder1\\" ... ] >>> file_system_monitor(7, operations) [300, 300] >>> operations = [ ... \\"CREATE / folder1\\", ... \\"QUERY /folder1\\" ... ] >>> file_system_monitor(2, operations) [0] fs = FileSystem() result = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == 'CREATE': parent_path = parts[1] folder_name = parts[2] fs.create_folder(parent_path, folder_name) elif cmd == 'DELETE': folder_path = parts[1] fs.delete_folder(folder_path) elif cmd == 'MOVE': source_path = parts[1] target_path = parts[2] file_size = int(parts[3]) fs.move_file(source_path, target_path, file_size) elif cmd == 'QUERY': folder_path = parts[1] result.append(fs.query_size(folder_path)) return result def file_system_monitor(n, operations): return process_operations(n, operations)","solution":"class FileSystem: def __init__(self): self.folders = {'/': {'size': 0, 'subfolders': {}}} def create_folder(self, parent_path, folder_name): path = parent_path + '/' + folder_name if parent_path != '/' else '/' + folder_name if parent_path in self.folders: self.folders[path] = {'size': 0, 'subfolders': {}} self.folders[parent_path]['subfolders'][folder_name] = path def delete_folder(self, folder_path): if folder_path in self.folders: parent_path = '/'.join(folder_path.split('/')[:-1]) folder_name = folder_path.split('/')[-1] if parent_path == '': parent_path = '/' if folder_name in self.folders[parent_path]['subfolders']: del self.folders[parent_path]['subfolders'][folder_name] del self.folders[folder_path] def move_file(self, source_path, target_path, file_size): if source_path in self.folders and target_path in self.folders: self.folders[target_path]['size'] += file_size def query_size(self, folder_path): def get_total_size(path): total_size = self.folders[path]['size'] for sub_path in self.folders[path]['subfolders'].values(): total_size += get_total_size(sub_path) return total_size return get_total_size(folder_path) # Reading input and simulating operations def process_operations(n, operations): fs = FileSystem() result = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == 'CREATE': parent_path = parts[1] folder_name = parts[2] fs.create_folder(parent_path, folder_name) elif cmd == 'DELETE': folder_path = parts[1] fs.delete_folder(folder_path) elif cmd == 'MOVE': source_path = parts[1] target_path = parts[2] file_size = int(parts[3]) fs.move_file(source_path, target_path, file_size) elif cmd == 'QUERY': folder_path = parts[1] result.append(fs.query_size(folder_path)) return result def file_system_monitor(n, operations): return process_operations(n, operations)"},{"question":"from typing import List, Tuple def earliest_medication(T: int, medications: List[Tuple[str, str, int]]) -> str: Returns the name of the medication with the earliest expiration date that has a quantity greater than zero. Parameters: T (int): The total number of medications. medications (list of tuples): A list containing T tuples, each tuple contains: - name (str): The name of the medication. - expiration_date (str): The expiration date in format 'YYYY-MM-DD'. - quantity (int): The quantity in stock. Returns: str: The name of the medication with the earliest expiration date that is still in stock. pass # Your implementation here # Unit Tests def test_earliest_medication(): T = 3 medications = [ ('Aspirin', '2023-08-01', 50), ('Ibuprofen', '2022-12-31', 0), ('Paracetamol', '2023-08-01', 20) ] assert earliest_medication(T, medications) == 'Paracetamol' def test_earliest_medication_all_zero_quantity(): T = 2 medications = [ ('Aspirin', '2023-08-01', 0), ('Ibuprofen', '2022-12-31', 0) ] assert earliest_medication(T, medications) is None def test_earliest_medication_single_medication(): T = 1 medications = [ ('Aspirin', '2023-08-01', 10) ] assert earliest_medication(T, medications) == 'Aspirin' def test_earliest_medication_mixed_quantities(): T = 4 medications = [ ('Aspirin', '2023-08-01', 50), ('Ibuprofen', '2022-12-31', 10), ('Paracetamol', '2021-12-31', 20), ('VitaminC', '2021-12-31', 15) ] assert earliest_medication(T, medications) == 'VitaminC' def test_earliest_medication_same_date_different_quantity(): T = 3 medications = [ ('Aspirin', '2023-08-01', 50), ('Paracetamol', '2023-08-01', 20), ('Ibuprofen', '2023-08-01', 10), ] assert earliest_medication(T, medications) == 'Ibuprofen' def test_earliest_medication_no_stock(): T = 2 medications = [ ('Aspirin', '2023-08-01', 0), ('Ibuprofen', '2024-05-12', 0) ] assert earliest_medication(T, medications) is None","solution":"import datetime def earliest_medication(T, medications): Returns the name of the medication with the earliest expiration date that has a quantity greater than zero. Parameters: T (int): The total number of medications. medications (list of tuples): A list containing T tuples, each tuple contains: - name (str): The name of the medication. - expiration_date (str): The expiration date in format 'YYYY-MM-DD'. - quantity (int): The quantity in stock. Returns: str: The name of the medication with the earliest expiration date that is still in stock. earliest_date = None earliest_med = None for medication in medications: name, expiration_date, quantity = medication if quantity > 0: date = datetime.datetime.strptime(expiration_date, '%Y-%m-%d') if earliest_date is None or date < earliest_date: earliest_date = date earliest_med = name elif date == earliest_date: earliest_med = name # If dates are the same, prefer the one appears last in input which is the current one. return earliest_med"},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequent character in the string s. If there are multiple characters with the same frequency, returns the lexicographically smallest one. >>> most_frequent_char(\\"abac\\") 'a' >>> most_frequent_char(\\"zxyyzz\\") 'z' >>> most_frequent_char(\\"kkkk\\") 'k'","solution":"def most_frequent_char(s): Returns the most frequent character in the string s. If there are multiple characters with the same frequency, returns the lexicographically smallest one. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Find the maximum frequency max_freq = max(freq.values()) # Find the lexicographically smallest character with the maximum frequency most_frequent = min(char for char in freq if freq[char] == max_freq) return most_frequent"},{"question":"def min_total_time(M: int, T: List[int]) -> int: Calculate the minimum total time required for all trucks to deliver their packages. Parameters: M (int): Number of warehouses/trucks/parking spots. T (List[int]): Time taken to move between adjacent parking spots. Returns: int: Minimum total time required for all trucks to deliver their packages. >>> min_total_time(5, [2, 3, 1, 4]) 2 >>> min_total_time(3, [1, 1]) 1","solution":"def min_total_time(M, T): Calculate the minimum total time required for all trucks to deliver their packages. Parameters: M (int): Number of warehouses/trucks/parking spots. T (List[int]): Time taken to move between adjacent parking spots. Returns: int: Minimum total time required for all trucks to deliver their packages. # The minimum total time required for all trucks to deliver their packages return T[0]"},{"question":"from typing import List, Union def flatten_array(nested_list: List[Union[int, list]]) -> List[int]: Flattens a nested list of integers into a single, flat list of integers. :param nested_list: List of integers or other lists :return: A single flat list of integers >>> flatten_array([[1, 2], [3, [4, 5]]]) [1, 2, 3, 4, 5] >>> flatten_array([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> flatten_array([]) [] >>> flatten_array([[[1, 2], 3], [4, [5, [6, 7]]]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_array([[1, 2, []], [3, [], [4, [5, []]]]]) [1, 2, 3, 4, 5] >>> flatten_array([[[[[1]]]]]) [1] >>> flatten_array([1, [2, 'a'], [3, [4, 5.0]]]) [1, 2, 'a', 3, 4, 5.0]","solution":"def flatten_array(nested_list): Flattens a nested list of integers into a single, flat list of integers. :param nested_list: List of integers or other lists :return: A single flat list of integers flat_list = [] def flatten(sublist): for element in sublist: if isinstance(element, list): flatten(element) else: flat_list.append(element) flatten(nested_list) return flat_list"},{"question":"def find_circle_num(M: List[List[int]]) -> int: Returns the number of friend circles in the given friendship matrix M. >>> find_circle_num([ [1, 1, 0], [1, 1, 0], [0, 0, 1] ]) 2 >>> find_circle_num([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 1 >>> find_circle_num([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) 3 >>> find_circle_num([ [1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1] ]) 2 >>> find_circle_num([ [1, 1, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1] ]) 1 >>> find_circle_num([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ]) 2 >>> find_circle_num([[1]]) == 1","solution":"def find_circle_num(M): Returns the number of friend circles in the given friendship matrix M. def dfs(student): for friend in range(n): if M[student][friend] == 1 and not visited[friend]: visited[friend] = True dfs(friend) n = len(M) visited = [False] * n circles = 0 for student in range(n): if not visited[student]: visited[student] = True dfs(student) circles += 1 return circles"},{"question":"def count_character_occurrences(string: str, character: str) -> int: Counts the number of times the character appears in the string. The function is case-sensitive. Args: string (str): The string in which to count the character. character (str): The character to count in the string. Returns: int: The number of times the character appears in the string. >>> count_character_occurrences(\\"Hello World\\", \\"o\\") 2 >>> count_character_occurrences(\\"Programming\\", \\"m\\") 2 >>> count_character_occurrences(\\"Data Science\\", \\"A\\") 0 from solution import count_character_occurrences def test_character_occurs_multiple_times(): assert count_character_occurrences(\\"Hello World\\", \\"o\\") == 2 assert count_character_occurrences(\\"Programming\\", \\"m\\") == 2 def test_character_occurs_once(): assert count_character_occurrences(\\"Hello World\\", \\"H\\") == 1 assert count_character_occurrences(\\"Programming\\", \\"P\\") == 1 def test_character_does_not_occur(): assert count_character_occurrences(\\"Data Science\\", \\"A\\") == 0 assert count_character_occurrences(\\"Data Science\\", \\"z\\") == 0 def test_empty_string(): assert count_character_occurrences(\\"\\", \\"a\\") == 0 def test_invalid_input(): try: count_character_occurrences(123, \\"a\\") except ValueError as e: assert str(e) == \\"Invalid input: 'string' must be a string and 'character' must be a single character string.\\" try: count_character_occurrences(\\"data\\", \\"abc\\") except ValueError as e: assert str(e) == \\"Invalid input: 'string' must be a string and 'character' must be a single character string.\\" try: count_character_occurrences(\\"data\\", 5) except ValueError as e: assert str(e) == \\"Invalid input: 'string' must be a string and 'character' must be a single character string.\\"","solution":"def count_character_occurrences(string, character): Counts the number of times the character appears in the string. The function is case-sensitive. Args: string (str): The string in which to count the character. character (str): The character to count in the string. Returns: int: The number of times the character appears in the string. if not isinstance(string, str) or not isinstance(character, str) or len(character) != 1: raise ValueError(\\"Invalid input: 'string' must be a string and 'character' must be a single character string.\\") return string.count(character)"},{"question":"def count_palindromic_substrings(s: str) -> int: Given a string s containing only lowercase letters, find the number of substrings that are palindromes. >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. def is_palindrome(sub): return sub == sub[::-1] count = 0 n = len(s) for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"from typing import List def maximalRectangle(matrix: List[List[int]]) -> int: Given a binary matrix, finds the largest rectangular sub-matrix that contains only 1s and returns its area. Args: matrix: List of List of integers (0s and 1s) Returns: int: The area of the largest rectangular sub-matrix containing only 1s >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0], ... ]) == 6 >>> maximalRectangle([ ... [1, 1, 0, 1], ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 0, 0, 0], ... ]) == 6 >>> maximalRectangle([ ... [0, 1, 1], ... [1, 1, 1], ... [0, 1, 1], ... ]) == 6 >>> maximalRectangle([]) == 0 >>> maximalRectangle([[1]]) == 1 >>> maximalRectangle([[0]]) == 0 >>> maximalRectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0], ... ]) == 0 >>> maximalRectangle([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1], ... ]) == 9 # Your implementation here","solution":"def maximalRectangle(matrix): Given a binary matrix, finds the largest rectangular sub-matrix that contains only 1s and returns its area. Args: matrix: List of List of integers (0s and 1s) Returns: int: The area of the largest rectangular sub-matrix containing only 1s if not matrix: return 0 def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) heights.pop() return max_area max_area = 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m for i in range(n): for j in range(m): if matrix[i][j] == 0: heights[j] = 0 else: heights[j] += 1 max_area = max(max_area, largestRectangleArea(heights)) return max_area"},{"question":"import math from typing import List, Tuple def largest_distance(points: List[Tuple[int, int]]) -> float: Given a list of points on a 2D plane, find the largest distance between any two points in the list. >>> math.isclose(largest_distance([(0,0), (1,1), (2,2)]), 2.8284271247461903) True >>> math.isclose(largest_distance([(0,0), (0,3), (4,0)]), 5.0) True","solution":"import math from typing import List, Tuple def largest_distance(points: List[Tuple[int, int]]) -> float: Returns the largest Euclidean distance between any two points in the list. max_dist = 0 for i in range(len(points)): for j in range(i + 1, len(points)): dist = math.sqrt( (points[j][0] - points[i][0]) ** 2 + (points[j][1] - points[i][1]) ** 2 ) if dist > max_dist: max_dist = dist return max_dist"},{"question":"def unique_prices(price_str: str) -> str: Given a space-separated string of prices, return a space-separated string of unique prices in ascending order. :param price_str: A string containing space-separated integers representing prices. :return: A string containing space-separated integers representing unique prices. pass def test_unique_prices_all_unique(): assert unique_prices(\\"10 20 30 40 50\\") == \\"10 20 30 40 50\\" def test_unique_prices_some_duplicates(): assert unique_prices(\\"10 20 20 30 40 50 50 50\\") == \\"10 20 30 40 50\\" assert unique_prices(\\"5 5 10 20 20 20 30\\") == \\"5 10 20 30\\" def test_unique_prices_single_element(): assert unique_prices(\\"1\\") == \\"1\\" def test_unique_prices_no_duplicates(): assert unique_prices(\\"1 2 3 4 5 6 7 8 9\\") == \\"1 2 3 4 5 6 7 8 9\\" def test_unique_prices_large_list(): large_input = \\" \\".join(map(str, range(1, 10001))) + \\" \\" + \\" \\".join(map(str, range(5000, 15001))) expected_output = \\" \\".join(map(str, range(1, 15001))) assert unique_prices(large_input) == expected_output","solution":"def unique_prices(price_str): Given a space-separated string of prices, return a space-separated string of unique prices in ascending order. :param price_str: A string containing space-separated integers representing prices. :return: A string containing space-separated integers representing unique prices. prices = price_str.split() unique_prices = sorted(set(prices), key=int) return ' '.join(unique_prices)"},{"question":"from typing import List def submatrix_sum(mat: List[List[int]], queries: List[List[int]]) -> List[int]: Given a matrix \`mat\` of integers with \`n\` rows and \`m\` columns, and a list \`queries\` where each query is a list \`[r1, c1, r2, c2]\` representing the top-left and bottom-right corners of a submatrix, return a list containing the sum of elements for each queried submatrix. >>> mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> queries = [[0, 0, 1, 1], [1, 1, 2, 2]] >>> submatrix_sum(mat, queries) [12, 28] >>> mat = [[1, 3], [5, 7]] >>> queries = [[0, 0, 0, 1], [1, 0, 1, 1], [0, 0, 1, 1]] >>> submatrix_sum(mat, queries) [4, 12, 16] # Unit tests def test_submatrix_sum_example1(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [[0, 0, 1, 1], [1, 1, 2, 2]] assert submatrix_sum(mat, queries) == [12, 28] def test_submatrix_sum_example2(): mat = [ [1, 3], [5, 7] ] queries = [[0, 0, 0, 1], [1, 0, 1, 1], [0, 0, 1, 1]] assert submatrix_sum(mat, queries) == [4, 12, 16] def test_submatrix_sum_single_element(): mat = [ [1] ] queries = [[0, 0, 0, 0]] assert submatrix_sum(mat, queries) == [1] def test_submatrix_sum_large_elements(): mat = [ [10000, 10000], [10000, -10000] ] queries = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]] assert submatrix_sum(mat, queries) == [20000, 10000, -10000] def test_submatrix_sum_negative_elements(): mat = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] queries = [[0, 0, 1, 1], [1, 1, 2, 2], [0, 0, 2, 2]] assert submatrix_sum(mat, queries) == [-12, -28, -45] def test_submatrix_sum_single_row(): mat = [ [1, 2, 3, 4] ] queries = [[0, 0, 0, 3], [0, 1, 0, 2]] assert submatrix_sum(mat, queries) == [10, 5] def test_submatrix_sum_single_column(): mat = [ [1], [2], [3], [4] ] queries = [[0, 0, 3, 0], [1, 0, 2, 0]] assert submatrix_sum(mat, queries) == [10, 5]","solution":"def submatrix_sum(mat, queries): def calculate_prefix_sum(matrix): rows = len(matrix) cols = len(matrix[0]) prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): prefix_sum[i][j] = (matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) return prefix_sum prefix_sum = calculate_prefix_sum(mat) result = [] for r1, c1, r2, c2 in queries: sum_value = (prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1]) result.append(sum_value) return result"},{"question":"import collections class LCAFinder: def __init__(self, graph, n): self.graph = graph self.n = n self.parent = [-1] * (n + 1) self.depth = [-1] * (n + 1) self.lca_prepared = False def dfs(self, node, par): self.parent[node] = par self.depth[node] = self.depth[par] + 1 if par != -1 else 0 for neighbor in self.graph[node]: if neighbor != par: self.dfs(neighbor, node) def prepare_lca(self): Prepare LCA calculations by performing a DFS self.dfs(1, -1) # Assume 1 is the root of the tree self.lca_prepared = True def find_lca(self, u, v): Find the lowest common ancestor of nodes u and v if not self.lca_prepared: self.prepare_lca() if self.depth[u] < self.depth[v]: u, v = v, u while self.depth[u] > self.depth[v]: u = self.parent[u] while u != v: u = self.parent[u] v = self.parent[v] return u def solve(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): N = int(data[idx]) idx += 1 graph = collections.defaultdict(list) for _ in range(N - 1): u = int(data[idx]) v = int(data[idx + 1]) graph[u].append(v) graph[v].append(u) idx += 2 lca_finder = LCAFinder(graph, N) Q = int(data[idx]) idx += 1 for _ in range(Q): a = int(data[idx]) b = int(data[idx + 1]) lca = lca_finder.find_lca(a, b) results.append(lca) idx += 2 for result in results: print(result)","solution":"import sys import collections sys.setrecursionlimit(200000) class LCAFinder: def __init__(self, graph, n): self.graph = graph self.n = n self.parent = [-1] * (n + 1) self.depth = [-1] * (n + 1) self.lca_prepared = False def dfs(self, node, par): self.parent[node] = par self.depth[node] = self.depth[par] + 1 if par != -1 else 0 for neighbor in self.graph[node]: if neighbor != par: self.dfs(neighbor, node) def prepare_lca(self): self.dfs(1, -1) # Assume 1 is the root of the tree self.lca_prepared = True def find_lca(self, u, v): if not self.lca_prepared: self.prepare_lca() if self.depth[u] < self.depth[v]: u, v = v, u while self.depth[u] > self.depth[v]: u = self.parent[u] while u != v: u = self.parent[u] v = self.parent[v] return u def solve(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): N = int(data[idx]) idx += 1 graph = collections.defaultdict(list) for _ in range(N - 1): u = int(data[idx]) v = int(data[idx + 1]) graph[u].append(v) graph[v].append(u) idx += 2 lca_finder = LCAFinder(graph, N) Q = int(data[idx]) idx += 1 for _ in range(Q): a = int(data[idx]) b = int(data[idx + 1]) lca = lca_finder.find_lca(a, b) results.append(lca) idx += 2 for result in results: print(result)"},{"question":"def is_anagram(s: str, t: str) -> bool: Determine if string t is an anagram of string s. :param s: str :param t: str :return: bool >>> is_anagram(\\"anagram\\", \\"nagaram\\") == True >>> is_anagram(\\"rat\\", \\"car\\") == False","solution":"def is_anagram(s, t): Determine if string t is an anagram of string s. :param s: str :param t: str :return: bool # Anagrams must be of the same length if len(s) != len(t): return False # Count characters in both strings and compare the counts from collections import Counter return Counter(s) == Counter(t)"},{"question":"from typing import List def can_form_palindrome(substring: str) -> bool: Determine if the given substring can be rearranged to form a palindrome. pass def is_palindrome_possible(s: str, queries: List[List[int]]) -> List[bool]: Given a string s and several queries, determine for each query if the substring can be turned into a palindrome by rearranging its characters. Args: s (str): The input string. queries (List[List[int]]): A list of queries, each represented as a pair of indices [left, right]. Returns: List[bool]: A list of boolean values indicating if the substring for each query can be rearranged to form a palindrome. Examples: >>> is_palindrome_possible(\\"abbaab\\", [[0, 3], [3, 5], [1, 4]]) [True, True, True] >>> is_palindrome_possible(\\"abcdef\\", [[0, 1], [1, 3], [2, 5]]) [False, False, False] >>> is_palindrome_possible(\\"aabbcc\\", [[0, 5], [1, 3], [2, 4]]) [True, True, True] pass","solution":"from collections import Counter def can_form_palindrome(substring): Determine if the given substring can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. count = Counter(substring) odd_count = sum(1 for c in count.values() if c % 2 != 0) return odd_count <= 1 def is_palindrome_possible(s, queries): For each query, determine if the corresponding substring can be rearranged to form a palindrome. results = [] for left, right in queries: substring = s[left:right+1] results.append(can_form_palindrome(substring)) return results"},{"question":"def calculate_total_yield(crop_data, crop_type): Calculate the total yield for a specified crop type. Parameters: crop_data (list of tuples): List containing tuples with crop type and yield. crop_type (str): The crop type to calculate the total yield for. Returns: int: The total yield for the specified crop type. >>> calculate_total_yield([(\\"Wheat\\", 500), (\\"Barley\\", 200), (\\"Wheat\\", 300), (\\"Corn\\", 400)], \\"Wheat\\") 800 >>> calculate_total_yield([(\\"Apple\\", 100), (\\"Orange\\", 150), (\\"Apple\\", 250), (\\"Orange\\", 200)], \\"Orange\\") 350 >>> calculate_total_yield([(\\"Barley\\", 300)], \\"Barley\\") 300 >>> calculate_total_yield([(\\"Corn\\", 400), (\\"Corn\\", 200), (\\"Corn\\", 600)], \\"Corn\\") 1200 >>> calculate_total_yield([(\\"Wheat\\", 500), (\\"Barley\\", 200), (\\"Wheat\\", 300)], \\"Corn\\") 0 >>> calculate_total_yield([(\\"wheat\\", 500), (\\"barley\\", 200), (\\"Wheat\\", 300), (\\"Corn\\", 400)], \\"Wheat\\") 300","solution":"def calculate_total_yield(crop_data, crop_type): Calculate the total yield for a specified crop type. Parameters: crop_data (list of tuples): List containing tuples with crop type and yield. crop_type (str): The crop type to calculate the total yield for. Returns: int: The total yield for the specified crop type. total_yield = 0 for crop, yield_ in crop_data: if crop == crop_type: total_yield += yield_ return total_yield"},{"question":"def rhythm_match(sequence: str, input: str) -> int: Returns the score of the player by counting the correctly matched ON beats. A beat is correctly matched if the sequence symbol is either \`.\`, \`-\`, \`~\` and the corresponding input is \`1\`. >>> rhythm_match(\\".-~.-\\", \\"101010\\") == 3 >>> rhythm_match(\\".~.-\\", \\"1100\\") == 2","solution":"def rhythm_match(sequence: str, input: str) -> int: Returns the score of the player by counting the correctly matched ON beats. A beat is correctly matched if the sequence symbol is either \`.\`, \`-\`, \`~\` and the corresponding input is \`1\`. score = 0 for seq_char, inp_char in zip(sequence, input): if inp_char == '1' and seq_char in {'.', '-', '~'}: score += 1 return score"},{"question":"def subarray_sum(A: List[int], K: int) -> int: Returns the number of contiguous subarrays which sum to K. >>> subarray_sum([1,1,1], 2) 2 >>> subarray_sum([1,2,3], 3) 2 >>> subarray_sum([3], 3) 1 >>> subarray_sum([1], 2) 0 >>> subarray_sum([1,1,1,1,1], 3) 3 >>> subarray_sum([1,2,1,2,1], 3) 4 >>> subarray_sum([1,2,1,2,1], 10) 0 >>> subarray_sum([3,3,3], 3) 3","solution":"def subarray_sum(A, K): Returns the number of contiguous subarrays which sum to K. sum_count = {0: 1} total_sum = 0 count = 0 for num in A: total_sum += num if (total_sum - K) in sum_count: count += sum_count[total_sum - K] sum_count[total_sum] = sum_count.get(total_sum, 0) + 1 return count"},{"question":"def intersect(list1, list2): Returns a list that is the intersection of list1 and list2. Each element in the result appears as many times as it appears in both lists. :param list1: First sorted list of integers :param list2: Second sorted list of integers :return: List representing the intersection of the two lists Examples: >>> intersect([1, 2, 2, 3], [2, 2, 4]) [2, 2] >>> intersect([4, 5, 6], [4, 4, 4, 6, 6]) [4, 6] >>> intersect([1, 1, 1, 1], []) [] >>> intersect([], [2, 3, 4]) [] >>> intersect([1, 1, 1, 3, 3, 3], [1, 3]) [1, 3] def test_intersect(): assert intersect([1, 2, 2, 3], [2, 2, 4]) == [2, 2] assert intersect([4, 5, 6], [4, 4, 4, 6, 6]) == [4, 6] assert intersect([1, 1, 1, 1], []) == [] assert intersect([], [2, 3, 4]) == [] assert intersect([1, 1, 1, 3, 3, 3], [1, 3]) == [1, 3] assert intersect([1, 2, 3], [4, 5, 6]) == [] assert intersect([1, 1, 1, 2, 2, 3], [1, 2, 4]) == [1, 2] assert intersect([], []) == [] def test_intersect_with_duplicates_in_both(): assert intersect([1, 2, 2, 2, 3], [2, 2, 2, 4]) == [2, 2, 2] assert intersect([1, 1, 3, 3, 3, 5], [1, 1, 1, 3, 3, 4]) == [1, 1, 3, 3] assert intersect([1, 4, 5, 6, 7], [1, 1, 1, 4, 4, 6]) == [1, 4, 6] assert intersect([1, 2, 2, 2, 3], [2, 2, 2, 3, 3, 4, 4]) == [2, 2, 2, 3] def test_edge_cases(): assert intersect([2], [2]) == [2] assert intersect([1], [2]) == [] assert intersect([1, 2, 3], [1, 2, 3]) == [1, 2, 3] assert intersect([1, 1, 1], [1, 1, 1, 1]) == [1, 1, 1]","solution":"def intersect(list1, list2): Returns a list that is the intersection of list1 and list2. Each element in the result appears as many times as it appears in both lists. :param list1: First sorted list of integers :param list2: Second sorted list of integers :return: List representing the intersection of the two lists result = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: result.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return result"},{"question":"def frequency_counter(lst): Returns a dictionary with the frequency of each unique integer in the list. :param lst: List of integers :return: Dictionary with integers as keys and their frequencies as values >>> frequency_counter([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 4} >>> frequency_counter([]) {} >>> frequency_counter([42]) {42: 1} >>> frequency_counter([1, -1, 1, -1, 1]) {1: 3, -1: 2} >>> frequency_counter([7, 7, 7, 7, 7]) {7: 5} >>> frequency_counter([1000000, 1000000, 999999, 999999, 999999]) {1000000: 2, 999999: 3} >>> frequency_counter([1, 2, 3, 4, 5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}","solution":"def frequency_counter(lst): Returns a dictionary with the frequency of each unique integer in the list. :param lst: List of integers :return: Dictionary with integers as keys and their frequencies as values freq_dict = {} for num in lst: if num in freq_dict: freq_dict[num] += 1 else: freq_dict[num] = 1 return freq_dict"},{"question":"def first_repeating_character(s: str) -> str: Returns the first character that repeats more than once in a given string. The comparison between characters is case-sensitive. If no character repeats, returns an empty string. >>> first_repeating_character(\\"abcdef\\") == \\"\\" >>> first_repeating_character(\\"AaBbCc\\") == \\"\\" >>> first_repeating_character(\\"aabcdefg\\") == \\"a\\" >>> first_repeating_character(\\"AaA\\") == \\"A\\" >>> first_repeating_character(\\"abcdefabcd\\") == \\"a\\" >>> first_repeating_character(\\"xyzxy\\") == \\"x\\" >>> first_repeating_character(\\"abcdea\\") == \\"a\\" >>> first_repeating_character(\\"xxyyz\\") == \\"x\\" >>> first_repeating_character(\\"aA\\") == \\"\\" >>> first_repeating_character(\\"AaAa\\") == \\"A\\"","solution":"def first_repeating_character(s: str) -> str: Returns the first character that repeats more than once in a given string. The comparison between characters is case-sensitive. If no character repeats, returns an empty string. seen = set() for char in s: if char in seen: return char seen.add(char) return \\"\\""},{"question":"def first_non_repeating_number(sequence): Finds the first non-repeating number in the given sequence. Parameters: sequence (list): A list of integers. Returns: int: The first non-repeating number, or -1 if all numbers are repeating. >>> first_non_repeating_number([4, 5, 1, 2, 0, 4, 1, 2]) == 5 >>> first_non_repeating_number([7, 7, 7, 7, 7]) == -1 >>> first_non_repeating_number([9, 2, 3, 2, 6, 6, 5, 5, 8, 9]) == 3 >>> first_non_repeating_number([1]) == 1 >>> first_non_repeating_number([5, 4, 3, 4, 5, 3, 7]) == 7 >>> first_non_repeating_number([-1, -2, -2, -3, -1, -3, -4]) == -4 >>> first_non_repeating_number([]) == -1 >>> first_non_repeating_number([5]) == 5 >>> first_non_repeating_number([2, 2, 2, 3]) == 3 >>> first_non_repeating_number([3, 2, 2]) == 3","solution":"def first_non_repeating_number(sequence): Finds the first non-repeating number in the given sequence. Parameters: sequence (list): A list of integers. Returns: int: The first non-repeating number, or -1 if all numbers are repeating. count = {} # Count occurrence of each number in the list for num in sequence: if num in count: count[num] += 1 else: count[num] = 1 # Find the first number with a count of 1 for num in sequence: if count[num] == 1: return num return -1"},{"question":"def word_lengths(s: str) -> dict: Returns a dictionary where the keys are words from the input string (in lowercase), and the values are their lengths. Parameters: - s: A string containing a space-separated sequence of words. Returns: - A dictionary with words as keys and their lengths as values. >>> word_lengths(\\"Hello world hello\\") {\\"hello\\": 5, \\"world\\": 5} >>> word_lengths(\\"a ab abc abcd\\") {\\"a\\": 1, \\"ab\\": 2, \\"abc\\": 3, \\"abcd\\": 4}","solution":"def word_lengths(s): Returns a dictionary where the keys are words from the input string (in lowercase), and the values are their lengths. Parameters: - s: A string containing a space-separated sequence of words. Returns: - A dictionary with words as keys and their lengths as values. words = s.split() result = {} for word in words: lower_word = word.lower() if lower_word not in result: result[lower_word] = len(lower_word) return result"},{"question":"class Inventory: Inventory management system. Methods: add_item(code: str, name: str, quantity: int) -> None Add the specified quantity of an item to the inventory. If the item already exists, increase the existing quantity. remove_item(code: str, quantity: int) -> None Removes the specified quantity of an item from the inventory. If the quantity to be removed is more than the current quantity, remove all instances of that item. Raise an error if the item does not exist. get_inventory() -> List[Tuple[str, str, int]] Returns a list of tuples containing the code, name, and quantity of each item in the inventory, sorted by code in ascending order. >>> inventory = Inventory() >>> inventory.add_item(\\"A001\\", \\"Apple\\", 10) >>> inventory.add_item(\\"B002\\", \\"Banana\\", 5) >>> inventory.add_item(\\"A001\\", \\"Apple\\", 5) >>> inventory.get_inventory() [(\\"A001\\", \\"Apple\\", 15), (\\"B002\\", \\"Banana\\", 5)] >>> inventory.remove_item(\\"A001\\", 3) >>> inventory.get_inventory() [(\\"A001\\", \\"Apple\\", 12), (\\"B002\\", \\"Banana\\", 5)] >>> inventory.remove_item(\\"B002\\", 6) >>> inventory.get_inventory() [(\\"A001\\", \\"Apple\\", 12)] def __init__(self): pass def add_item(self, code: str, name: str, quantity: int): pass def remove_item(self, code: str, quantity: int): pass def get_inventory(self): pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, code: str, name: str, quantity: int): if code in self.items: self.items[code]['quantity'] += quantity else: self.items[code] = {'name': name, 'quantity': quantity} def remove_item(self, code: str, quantity: int): if code not in self.items: raise ValueError(f\\"Item with code {code} does not exist.\\") if self.items[code]['quantity'] <= quantity: del self.items[code] else: self.items[code]['quantity'] -= quantity def get_inventory(self): return sorted( [(code, item['name'], item['quantity']) for code, item in self.items.items()], key=lambda x: x[0] )"},{"question":"def count_dice_sequences(n): Returns the number of ways to obtain a sum that equals n by rolling a six-sided die multiple times. >>> count_dice_sequences(5) == 16 >>> count_dice_sequences(2) == 2 >>> count_dice_sequences(7) == 63 # Your code here # Test cases assert count_dice_sequences(1) == 1 assert count_dice_sequences(2) == 2 assert count_dice_sequences(3) == 4 assert count_dice_sequences(4) == 8 assert count_dice_sequences(5) == 16 assert count_dice_sequences(6) == 32 assert count_dice_sequences(7) == 63 assert count_dice_sequences(10) == 492","solution":"def count_dice_sequences(n): Returns the number of ways to obtain a sum that equals n by rolling a six-sided die multiple times. MOD = 1000000007 dp = [0] * (n + 1) dp[0] = 1 # Base case for i in range(1, n + 1): for j in range(1, 7): if i >= j: dp[i] = (dp[i] + dp[i - j]) % MOD return dp[n]"},{"question":"from typing import List, Set def find_ladder(start: str, end: str, word_dict: Set[str]) -> List[str]: Find the shortest word ladder that transforms start to end. Parameters: start (str): the starting word end (str): the target word word_dict (Set[str]): a set of valid intermediate words Returns: List[str]: the shortest sequence of words from start to end, or an empty list if no such sequence exists Example: >>> find_ladder('hit', 'cog', {'hot', 'dot', 'dog', 'lot', 'log', 'cog'}) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> find_ladder('hit', 'cog', {'hot', 'dot', 'dog', 'lot', 'log'}) [] pass","solution":"from collections import deque from typing import List, Set def find_ladder(start: str, end: str, word_dict: Set[str]) -> List[str]: if start == end: return [start] if end not in word_dict: return [] word_dict.add(end) queue = deque([[start]]) visited = set([start]) while queue: current_path = queue.popleft() current_word = current_path[-1] if current_word == end: return current_path for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_dict and next_word not in visited: visited.add(next_word) new_path = current_path + [next_word] queue.append(new_path) return []"},{"question":"def shift_string(s: str, shift: int) -> str: Shifts each character in the string s by the given number of positions in the alphabet. Args: s (str): A string consisting of lowercase alphabets. shift (int): The number of positions to shift each character. Returns: str: The resulting string after shifting or \\"Invalid input\\" if the input is not valid. Examples: >>> shift_string(\\"abc\\", 1) 'bcd' >>> shift_string(\\"xyz\\", 2) 'zab' >>> shift_string(\\"hello\\", -1) 'gdkkn' >>> shift_string(\\"abc\\", -2) 'yza' >>> shift_string(\\"abc123\\", 1) 'Invalid input' >>> shift_string(\\"ABC\\", 1) 'Invalid input' >>> shift_string(\\"abc\\", \\"one\\") 'Invalid input' >>> shift_string(123, 1) 'Invalid input'","solution":"def shift_string(s, shift): Shifts each character in the string s by the given number of positions in the alphabet. Args: s (str): A string consisting of lowercase alphabets. shift (int): The number of positions to shift each character. Returns: str: The resulting string after shifting. if not isinstance(s, str) or not isinstance(shift, int): return \\"Invalid input\\" if not s.islower() or not s.isalpha(): return \\"Invalid input\\" shifted_string = [] for char in s: new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) shifted_string.append(new_char) return ''.join(shifted_string)"},{"question":"def compute_total_time(logs: list[str]) -> dict[str, int]: Computes the total time each employee spent in the building. Args: logs (list of str): A list of log entries. Returns: dict: A dictionary where keys are employee ids (str) and values are total times (int) spent in the building. >>> logs = [ ... \\"1:enter:3\\", ... \\"2:enter:5\\", ... \\"1:exit:8\\", ... \\"2:exit:12\\", ... \\"1:enter:10\\", ... \\"1:exit:15\\" ... ] >>> compute_total_time(logs) {'1': 10, '2': 7} from solution import compute_total_time def test_compute_total_time_example_one(): logs = [ \\"1:enter:3\\", \\"2:enter:5\\", \\"1:exit:8\\", \\"2:exit:12\\", \\"1:enter:10\\", \\"1:exit:15\\" ] expected_output = { \\"1\\": 10, \\"2\\": 7 } assert compute_total_time(logs) == expected_output def test_compute_total_time_single_entry_and_exit(): logs = [ \\"1:enter:1\\", \\"1:exit:5\\" ] expected_output = { \\"1\\": 4 } assert compute_total_time(logs) == expected_output def test_compute_total_time_multiple_employees(): logs = [ \\"1:enter:1\\", \\"2:enter:2\\", \\"1:exit:4\\", \\"2:exit:8\\" ] expected_output = { \\"1\\": 3, \\"2\\": 6 } assert compute_total_time(logs) == expected_output def test_compute_total_time_no_entry(): logs = [] expected_output = {} assert compute_total_time(logs) == expected_output def test_compute_total_time_complex_case(): logs = [ \\"1:enter:1\\", \\"2:enter:2\\", \\"1:exit:5\\", \\"2:exit:6\\", \\"1:enter:7\\", \\"2:enter:8\\", \\"1:exit:10\\", \\"2:exit:11\\" ] expected_output = { \\"1\\": 7, \\"2\\": 7 } assert compute_total_time(logs) == expected_output","solution":"def compute_total_time(logs): Computes the total time each employee spent in the building. Args: logs (list of str): A list of log entries. Returns: dict: A dictionary where keys are employee ids (str) and values are total times (int) spent in the building. time_spent = {} current_entries = {} # store the latest 'enter' timestamps for each employee for log in logs: employee_id, event, timestamp = log.split(\\":\\") if event == \\"enter\\": current_entries[employee_id] = int(timestamp) elif event == \\"exit\\": if employee_id in current_entries: time_spent[employee_id] = time_spent.get(employee_id, 0) + (int(timestamp) - current_entries[employee_id]) del current_entries[employee_id] return time_spent"},{"question":"def segment_consecutive_groups(num_cases: int, cases: List[Tuple[int, List[int]]]) -> List[List[List[int]]]: Segment a set of integers into groups of consecutive numbers. >>> segment_consecutive_groups(2, [(6, [1, 2, 3, 5, 6, 8]), (5, [10, 11, 12, 15, 16])]) [[[1, 2, 3], [5, 6], [8]], [[10, 11, 12], [15, 16]]] >>> segment_consecutive_groups(1, [(7, [100, 101, 104, 105, 106, 109, 110])]) [[[100, 101], [104, 105, 106], [109, 110]]] >>> segment_consecutive_groups(1, [(3, [-1000, -999, -998])]) [[[-1000, -999, -998]]] >>> segment_consecutive_groups(2, [(4, [1, 3, 5, 7]), (3, [20, 21, 22])]) [[[1], [3], [5], [7]], [[20, 21, 22]]] >>> segment_consecutive_groups(1, [(5, [1, 4, 5, 7, 8])]) [[[1], [4, 5], [7, 8]]]","solution":"def segment_consecutive_groups(num_cases, cases): result = [] for i in range(num_cases): n, numbers = cases[i] groups = [] group = [] for j in range(n): if not group or numbers[j] == group[-1] + 1: group.append(numbers[j]) else: groups.append(group) group = [numbers[j]] if group: groups.append(group) result.append(groups) return result"},{"question":"def rotate_matrix(matrix): Rotates the given matrix 90 degrees clockwise. Args: matrix (list of lists): The input matrix. Returns: list of lists: The rotated matrix. Example: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ... ]) [[5, 1], [6, 2], [7, 3], [8, 4]] >>> rotate_matrix([ ... [1, 2, 3] ... ]) [[1], [2], [3]] >>> rotate_matrix([ ... [1], ... [2], ... [3] ... ]) [[3, 2, 1]] >>> rotate_matrix([ ... [1] ... ]) [[1]]","solution":"def rotate_matrix(matrix): Rotates the given matrix 90 degrees clockwise. Args: matrix (list of lists): The input matrix. Returns: list of lists: The rotated matrix. # Get the number of rows and columns num_rows = len(matrix) num_cols = len(matrix[0]) # Initialize the rotated matrix rotated_matrix = [[0] * num_rows for _ in range(num_cols)] # Fill the rotated matrix with values from the original matrix for r in range(num_rows): for c in range(num_cols): rotated_matrix[c][num_rows - 1 - r] = matrix[r][c] return rotated_matrix"},{"question":"from typing import List, Tuple, Optional def find_zero_sum_pair(arr: List[int]) -> Optional[Tuple[int, int]]: Determine if there are two distinct elements in the list whose sum is zero. If such a pair exists, return those two elements as a tuple (smaller number, larger number). If no such pair exists, return None. Examples: >>> find_zero_sum_pair([-1, 2, 3, -3, 5, 1]) (-3, 3) >>> find_zero_sum_pair([4, -7, 9, -4, 5]) (-4, 4) >>> find_zero_sum_pair([7, 8, 3, 1, 9]) None pass def test_find_zero_sum_pair_with_pairs(): assert find_zero_sum_pair([-1, 2, 3, -3, 5, 1]) == (-3, 3) assert find_zero_sum_pair([4, -7, 9, -4, 5]) == (-4, 4) assert find_zero_sum_pair([10, -10, 5, 15, -5]) == (-10, 10) def test_find_zero_sum_pair_without_pairs(): assert find_zero_sum_pair([7, 8, 3, 1, 9]) == None assert find_zero_sum_pair([1, 2, 3, 4, 5]) == None def test_find_zero_sum_pair_with_multiples(): assert find_zero_sum_pair([4, -4, -4, 4]) == (-4, 4) assert find_zero_sum_pair([2, -3, 3, -3, 3, 5, -2]) == (-3, 3) assert find_zero_sum_pair([-1, 1, -1, 1]) == (-1, 1) def test_find_zero_sum_pair_empty(): assert find_zero_sum_pair([]) == None def test_find_zero_sum_pair_single_element(): assert find_zero_sum_pair([0]) == None assert find_zero_sum_pair([-1]) == None","solution":"def find_zero_sum_pair(arr): Determine if there are two distinct elements in the list whose sum is zero. If such a pair exists, return those two elements as a tuple (smaller number, larger number). If no such pair exists, return None. seen = set() for num in arr: if -num in seen: return (min(num, -num), max(num, -num)) seen.add(num) return None"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and then selling the stock on different days. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([2, 4, 1, 7, 5, 9]) 8 pass","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then selling the stock on different days. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price if price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def is_ascending_number(n: int) -> bool: Checks if a given number is an ascending number. A number is ascending if every digit from left to right is greater than or equal to the previous digit. Args: n (int): A non-negative integer. Returns: bool: Returns True if the number is ascending, otherwise returns False. Examples: >>> is_ascending_number(113579) == True >>> is_ascending_number(123450) == False >>> is_ascending_number(123344) == True >>> is_ascending_number(54321) == False >>> is_ascending_number(24678) == True >>> is_ascending_number(9) == True","solution":"def is_ascending_number(n: int) -> bool: Checks if a given number is an ascending number. A number is ascending if every digit from left to right is greater than or equal to the previous digit. Args: n (int): A non-negative integer. Returns: bool: Returns True if the number is ascending, otherwise returns False. n_str = str(n) for i in range(1, len(n_str)): if n_str[i] < n_str[i-1]: return False return True"},{"question":"def isPangram(s: str) -> bool: Returns True if the input string is a pangram, False otherwise. >>> isPangram(\\"The quick brown fox jumps over the lazy dog\\") True >>> isPangram(\\"The quick brown fox jumps\\") False >>> isPangram(\\"\\") False >>> isPangram(\\"The quick brown fox, jumps over the lazy dog!\\") True >>> isPangram(\\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\\") True >>> isPangram(\\"A quick movement of the enemy will jeopardize gunboats\\") False >>> isPangram(\\"Pack my box with five dozen liquor jugs 1234567890 !@#%^&*()\\") True","solution":"import string def isPangram(s): Returns True if the input string is a pangram, False otherwise. alphabet_set = set(string.ascii_lowercase) s_lower = s.lower() s_set = set([char for char in s_lower if char in alphabet_set]) return s_set == alphabet_set"},{"question":"def max_children_whose_wishes_can_be_fulfilled(n: int, m: int, a: List[int]) -> int: Calculate the maximum number of children whose wishes for toys can be fulfilled. Args: n (int): The number of toys Santa has. m (int): The number of children. a (List[int]): The number of toys each child wishes for. Returns: int: The maximum number of children whose wishes can be fulfilled. Examples: >>> max_children_whose_wishes_can_be_fulfilled(10, 3, [2, 3, 4]) 3 >>> max_children_whose_wishes_can_be_fulfilled(8, 4, [3, 3, 3, 3]) 2","solution":"def max_children_whose_wishes_can_be_fulfilled(n, m, a): Returns the maximum number of children whose wishes can be fulfilled. :param n: int The number of toys Santa has. :param m: int The number of children. :param a: List[int] The number of toys each child wishes for. :return: int The maximum number of children whose wishes can be fulfilled. a.sort() count = 0 for toys in a: if n >= toys: n -= toys count += 1 else: break return count"},{"question":"def josephus_position(n: int, k: int) -> int: Calculate the Josephus position. >>> josephus_position(7, 3) 4 >>> josephus_position(5, 2) 3 >>> josephus_position(6, 1) 6","solution":"def josephus_position(n: int, k: int) -> int: Returns the position of the last person standing in the Josephus problem. Parameters: n (int): The initial number of people standing in the circle. k (int): The fixed number at which people are counted off and removed. Returns: int: The position of the last person standing (1-based index). if n == 1: return 1 else: return (josephus_position(n - 1, k) + k - 1) % n + 1"},{"question":"def min_energy(n: int, m: int, grid: List[List[int]]) -> int: Calculate the minimum energy required for the robot to traverse from the top-left corner to the bottom-right corner of a grid. >>> min_energy(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_energy(2, 2, [[5, 9], [3, 4]]) == 12","solution":"def min_energy(n, m, grid): Calculate the minimum energy required to traverse from the top-left to the bottom-right corner of a grid. # Create a 2D DP table to store the minimum energy required to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the first cell dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is the value at the bottom-right corner of the DP table return dp[n-1][m-1]"},{"question":"def find_max_consecutive_sum(arr, k): Returns the maximum sum of any k consecutive elements in the array. If the array has fewer than k elements, returns None. >>> find_max_consecutive_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> find_max_consecutive_sum([2, 3], 3) None","solution":"def find_max_consecutive_sum(arr, k): Returns the maximum sum of any k consecutive elements in the array. If the array has fewer than k elements, returns None. if len(arr) < k: return None # Calculate the initial window sum window_sum = sum(arr[:k]) max_sum = window_sum # Slide the window over the array for i in range(k, len(arr)): window_sum += arr[i] - arr[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def count_valid_sequences(N: int) -> int: Returns the number of distinct ways to arrange traffic lights of three different colors (Red, Green, Blue) in a vertical sequence of length N such that no two lights of the same color are adjacent. >>> count_valid_sequences(1) 3 >>> count_valid_sequences(2) 6 >>> count_valid_sequences(3) 12 >>> count_valid_sequences(4) 24 >>> count_valid_sequences(100000) 3 * (2 ** 99999)","solution":"def count_valid_sequences(N): Returns the number of distinct ways to arrange traffic lights of three different colors (Red, Green, Blue) in a vertical sequence of length N such that no two lights of the same color are adjacent. if N == 1: return 3 # Only three distinct ways: R, G, B # For N > 1, We can use dynamic programming approach: total_ways = 3 * (2 ** (N - 1)) # Each position can have 2 options except the very first one return total_ways"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. Ignores spaces, punctuation, and capitalization. >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"Able was I ere I saw Elba\\") True >>> can_form_palindrome(\\"Hello, World!\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aaabbbbcc\\") True >>> can_form_palindrome(\\"abcde\\") False","solution":"from collections import Counter def can_form_palindrome(s): Determines if the characters of the given string can be rearranged to form a palindrome. Ignores spaces, punctuation, and capitalization. # Normalize the string by ignoring spaces, punctuation, and capitalization normalized_str = ''.join(filter(str.isalnum, s)).lower() # Count the frequency of each character char_count = Counter(normalized_str) # Check number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be permuted to form a palindrome: # There must be at most one character with an odd frequency count. return odd_count <= 1"},{"question":"def reverse_vowels(s: str) -> str: Returns a new string where only the vowels in s are reversed, and other characters remain in their original positions. >>> reverse_vowels(\\"hello\\") 'holle' >>> reverse_vowels(\\"leetcode\\") 'leotcede' >>> reverse_vowels(\\"aeiou\\") 'uoiea' >>> reverse_vowels(\\"bcd\\") 'bcd' >>> reverse_vowels(\\"Hello\\") 'Holle' >>> reverse_vowels(\\"AeiOu\\") 'uOieA' >>> reverse_vowels(\\"\\") '' >>> reverse_vowels(\\"bcdfg\\") 'bcdfg' >>> reverse_vowels(\\"a\\") 'a' >>> reverse_vowels(\\"b\\") 'b' >>> reverse_vowels(\\"aaaa\\") 'aaaa' >>> reverse_vowels(\\"EEEE\\") 'EEEE'","solution":"def reverse_vowels(s: str) -> str: Returns a new string where only the vowels in s are reversed, and other characters remain in their original positions. vowels = set('aeiouAEIOU') s = list(s) left, right = 0, len(s) - 1 while left < right: if s[left] in vowels and s[right] in vowels: s[left], s[right] = s[right], s[left] left += 1 right -= 1 elif s[left] not in vowels: left += 1 elif s[right] not in vowels: right -= 1 return ''.join(s)"},{"question":"def inventory_analysis(inventory: List[int], threshold: int) -> tuple: Analyzes the inventory and identifies the total number of items and the indices of items needing restock. Parameters: inventory (list): A list of integers representing the quantities of each item in stock. threshold (int): An integer representing the restock threshold. Returns: tuple: A tuple where the first element is the total number of items in inventory and the second is a list of indices of items that need to be restocked. >>> inventory_analysis([10, 5, 8, 12, 3, 15], 6) (53, [1, 4]) >>> inventory_analysis([10, 20, 30], 5) (60, []) >>> inventory_analysis([2, 3, 1], 4) (6, [0, 1, 2]) >>> inventory_analysis([7, 1, 4, 0, 9], 5) (21, [1, 2, 3]) >>> inventory_analysis([], 5) (0, []) >>> inventory_analysis([1, 2, 3, 4], 3) (10, [0, 1]) >>> inventory_analysis([0, 0, 0, 0], 1) (0, [0, 1, 2, 3])","solution":"def inventory_analysis(inventory, threshold): Analyzes the inventory and identifies the total number of items and the indices of items needing restock. Parameters: inventory (list): A list of integers representing the quantities of each item in stock. threshold (int): An integer representing the restock threshold. Returns: tuple: A tuple where the first element is the total number of items in inventory and the second is a list of indices of items that need to be restocked. # Calculate total number of items in the inventory total_items = sum(inventory) # Identify indices of items that need to be restocked restock_indices = [index for index, quantity in enumerate(inventory) if quantity < threshold] return (total_items, restock_indices)"},{"question":"def find_divisors(n: int) -> List[Union[int, str]]: Create a function that takes an integer \`n\` as input and returns a list of all the divisors of \`n\` excluding 1 and \`n\` itself. If \`n\` is less than 2, return \\"Input is invalid.\\" If \`n\` is a prime number, return \\"This number is prime.\\" For negative n, return the same divisors as for the positive counterpart. The list of divisors should be returned in ascending order. Examples: >>> find_divisors(15) [3, 5] >>> find_divisors(28) [2, 4, 7, 14] >>> find_divisors(13) \\"This number is prime.\\" >>> find_divisors(-28) [2, 4, 7, 14] >>> find_divisors(1) \\"Input is invalid.\\"","solution":"def find_divisors(n): Returns a list of all divisors of n excluding 1 and n itself. If n is less than 2, returns \\"Input is invalid.\\" If n is a prime number, returns \\"This number is prime.\\" For negative n, it returns the same divisors as for the positive counterpart. if abs(n) < 2: return \\"Input is invalid.\\" abs_n = abs(n) divisors = [i for i in range(2, abs_n) if abs_n % i == 0] if not divisors: return \\"This number is prime.\\" return divisors"},{"question":"def decode_string(encoded_str: str) -> str: Decodes the given encoded string. >>> decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" >>> decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\"","solution":"def decode_string(encoded_str: str) -> str: Decodes the given encoded string. stack = [] current_num = 0 current_str = \\"\\" for char in encoded_str: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_str, current_num)) current_str, current_num = \\"\\", 0 elif char == ']': prev_str, num = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"def recommendation(borrowed_books: List[Tuple[int, str]]) -> str: Provides a book recommendation based on the borrowing pattern. Parameters: borrowed_books (list of tuples): A list where each tuple contains a patron ID and a string representing the type of book borrowed ('fiction' or 'non-fiction'). Returns: str: 'fiction' or 'non-fiction' based on which type has been borrowed less often. Returns 'either' if both types are borrowed the same number of times. Examples: >>> recommendation([(1, 'fiction'), (2, 'non-fiction'), (3, 'non-fiction'), (4, 'fiction')]) 'either' >>> recommendation([(1, 'fiction'), (2, 'fiction'), (3, 'non-fiction')]) 'non-fiction' >>> recommendation([(1, 'fiction'), (2, 'fiction'), (3, 'fiction')]) 'non-fiction' def test_recommendation_equal_borrowing(): assert recommendation([(1, 'fiction'), (2, 'non-fiction'), (3, 'non-fiction'), (4, 'fiction')]) == 'either' def test_recommendation_more_fiction(): assert recommendation([(1, 'fiction'), (2, 'fiction'), (3, 'non-fiction')]) == 'non-fiction' def test_recommendation_more_non_fiction(): assert recommendation([(1, 'fiction'), (2, 'non-fiction'), (3, 'non-fiction'), (4, 'non-fiction')]) == 'fiction' def test_recommendation_all_fiction(): assert recommendation([(1, 'fiction'), (2, 'fiction'), (3, 'fiction')]) == 'non-fiction' def test_recommendation_all_non_fiction(): assert recommendation([(1, 'non-fiction'), (2, 'non-fiction'), (3, 'non-fiction')]) == 'fiction' def test_recommendation_no_borrowing(): assert recommendation([]) == 'either' def test_recommendation_mixed_large_equal(): books = [(i, 'fiction') for i in range(500)] + [(i, 'non-fiction') for i in range(500, 1000)] assert recommendation(books) == 'either' def test_recommendation_mixed_large_unequal(): books = [(i, 'fiction') for i in range(400)] + [(i, 'non-fiction') for i in range(500)] assert recommendation(books) == 'fiction'","solution":"def recommendation(borrowed_books): Provides a book recommendation based on the borrowing pattern. Parameters: borrowed_books (list of tuples): A list where each tuple contains a patron ID and a string representing the type of book borrowed ('fiction' or 'non-fiction'). Returns: str: 'fiction' or 'non-fiction' based on which type has been borrowed less often. Returns 'either' if both types are borrowed the same number of times. fiction_count = sum(1 for _, book_type in borrowed_books if book_type == 'fiction') non_fiction_count = sum(1 for _, book_type in borrowed_books if book_type == 'non-fiction') if fiction_count < non_fiction_count: return 'fiction' elif fiction_count > non_fiction_count: return 'non-fiction' else: return 'either'"},{"question":"def n_largest_elements(lst: List[int], n: int) -> List[int]: Write a function that takes a list \`lst\` of integers and an integer \`n\`, and returns a list of the \`n\` largest unique integers in descending order. If there are fewer than \`n\` unique integers in the input list, return all the unique integers sorted in descending order. >>> n_largest_elements([4, 1, 7, 1, 4, 8, 9, 3], 3) [9, 8, 7] >>> n_largest_elements([4, 1, 7, 2, 3], 7) [7, 4, 3, 2, 1] >>> n_largest_elements([4, 4, 4, 4], 2) [4] >>> n_largest_elements([1, 2, 3, 4, 5], 0) []","solution":"def n_largest_elements(lst, n): Returns a list of the n largest unique integers in descending order. If there are fewer than n unique integers, return all unique integers. # Get the unique integers from the list unique_integers = list(set(lst)) # Sort the unique integers in descending order unique_integers.sort(reverse=True) # Return the first n elements return unique_integers[:n]"},{"question":"def shortest_path(grid): Find the shortest path from the top-left corner of the grid to the bottom-right corner. You can move in four possible directions: up, down, left, and right. You cannot move through obstacles. Args: grid (List[List[str]]): 2D grid containing '.' for empty cells and '#' for obstacles. Returns: int: The length of the shortest path, or -1 if no path exists. Example: >>> shortest_path([['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.']]) 5 >>> shortest_path([['.', '#'], ['#', '.']]) -1 >>> shortest_path([['.']]) 1 >>> shortest_path([['#', '.'], ['.', '.']]) -1 >>> shortest_path([['.', '.'], ['.', '#']]) -1 >>> grid = [['#'] * 5 for _ in range(5)] >>> grid[0][0] = '.' >>> grid[4][4] = '.' >>> shortest_path(grid) -1 def process_test_cases(test_cases): Process a list of test cases and return the results for each one. Args: test_cases (List[List[List[str]]]): A list of test cases, where each test case is a grid. Returns: List[int]: The results for each test case. Example: >>> test_cases = [ >>> [['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.']], >>> [['.', '#'], ['#', '.']] >>> ] >>> process_test_cases(test_cases) [5, -1]","solution":"from collections import deque def shortest_path(grid): rows, cols = len(grid), len(grid[0]) if grid[0][0] == '#' or grid[rows-1][cols-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows-1 and c == cols-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 def process_test_cases(test_cases): results = [] for grid in test_cases: result = shortest_path(grid) results.append(result) return results"},{"question":"def longest_increasing_subarray(arr): Returns the length of the longest subarray of strictly increasing sea levels. >>> longest_increasing_subarray([1, 3, 5, 4, 7]) 3 >>> longest_increasing_subarray([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray([8, 9, 2, 3, 4, 5, 6, 2]) 5","solution":"def longest_increasing_subarray(arr): Returns the length of the longest subarray of strictly increasing sea levels. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def bulbSwitch(n: int) -> int: Determine the number of bulbs that are on after all toggles. >>> bulbSwitch(3) 1 >>> bulbSwitch(0) 0 >>> bulbSwitch(16) 4","solution":"def bulbSwitch(n: int) -> int: Returns the number of bulbs that remain on after all toggling. Only bulbs at positions which are perfect squares will remain on. return int(n**0.5)"},{"question":"def generate_dance_steps(N: int, steps_list: List[int]) -> List[str]: Generate dance steps sequences based on the number of steps in each test case. >>> generate_dance_steps(1, [1]) ['a'] >>> generate_dance_steps(1, [2]) ['ab'] >>> generate_dance_steps(1, [3]) ['abc'] >>> generate_dance_steps(1, [4]) ['abcd'] >>> generate_dance_steps(4, [1, 2, 3, 4]) ['a', 'ab', 'abc', 'abcd'] >>> generate_dance_steps(1, [26]) ['abcdefghijklmnopqrstuvwxyz'] >>> generate_dance_steps(50, [1]*50) ['a']*50","solution":"def generate_dance_steps(N, steps_list): Generate dance steps sequences based on the number of steps in each test case. :param N: Number of test cases. :param steps_list: List containing the number of steps for each test case. :return: List of dance step sequences. alphabet = 'abcdefghijklmnopqrstuvwxyz' results = [] for M in steps_list: results.append(alphabet[:M]) return results"},{"question":"def findMissingElement(arr: List[int]) -> int: Returns the missing element from the array containing unique integers from 0 to n inclusive. >>> findMissingElement([3, 0, 1]) 2 >>> findMissingElement([0, 1, 2, 4]) 3 >>> findMissingElement([1, 2, 3]) 0 >>> findMissingElement([1]) 0 >>> findMissingElement([0, 1, 3, 4, 5, 6, 2, 8, 9]) 7 >>> findMissingElement(list(range(1001))[:-1]) 500","solution":"def findMissingElement(arr): Returns the missing element from the array containing unique integers from 0 to n inclusive. n = len(arr) total_sum = n * (n + 1) // 2 actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"class FileSystem: Design a class FileSystem that supports creating and querying paths with associated values. - \`createPath(String path, int value)\`: * Creates a new path and associates a value to it if the path does not exist already. * Ensures the following are true for the path: - Consists of only lowercase alphabets, forward slashes \`/\`, and does not end with a \\"/\\". - Begins with a single forward slash \`/\`. - Will be created only if its parent path exists. - \`get(String path)\`: * Returns the value associated with a given path. * Returns -1 if the path does not exist. Example usage: >>> fs = FileSystem() >>> fs.createPath(\\"/a\\", 1) True >>> fs.createPath(\\"/a\\", 1) False >>> fs.createPath(\\"/a/b\\", 2) True >>> fs.createPath(\\"/a/b/c\\", 3) False >>> fs.get(\\"/a\\") 1 >>> fs.get(\\"/a/b\\") 2 >>> fs.get(\\"/a/b/c\\") -1 >>> fs.createPath(\\"/e/f\\", 3) False >>> fs.createPath(\\"/e\\", 3) True >>> fs.createPath(\\"/e/f\\", 4) True >>> fs.get(\\"/e\\") 3 >>> fs.get(\\"/e/f\\") 4 def __init__(self): self.paths = {\\"/\\": None} def createPath(self, path: str, value: int) -> bool: pass def get(self, path: str) -> int: pass import pytest def test_file_system(): fs = FileSystem() assert fs.createPath(\\"/a\\", 1) == True assert fs.createPath(\\"/a\\", 1) == False assert fs.createPath(\\"/a/b\\", 2) == True assert fs.createPath(\\"/a/b/c/d\\", 4) == False assert fs.get(\\"/a\\") == 1 assert fs.get(\\"/a/b\\") == 2 assert fs.get(\\"/a/c\\") == -1 assert fs.get(\\"/a/b/c\\") == -1 assert fs.createPath(\\"/e/f\\", 3) == False assert fs.get(\\"/a\\") == 1 assert fs.get(\\"/a/b\\") == 2 assert fs.createPath(\\"/e\\", 3) == True assert fs.createPath(\\"/e/f\\", 4) == True assert fs.get(\\"/e\\") == 3 assert fs.get(\\"/e/f\\") == 4","solution":"class FileSystem: def __init__(self): self.paths = {\\"/\\": None} def createPath(self, path: str, value: int) -> bool: if path in self.paths: return False parent_path = \\"/\\".join(path.split(\\"/\\")[:-1]) if parent_path == \\"\\": parent_path = \\"/\\" if parent_path not in self.paths: return False self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"def convert(s: str, numRows: int) -> str: Converts a string to a zig-zag pattern with the given number of rows. Args: s: The input string to be converted. numRows: The number of rows in the zig-zag pattern. Returns: The string read line by line from the zig-zag pattern. >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert(\\"PAYPALISHIRING\\", 1) \\"PAYPALISHIRING\\" >>> convert(\\"SHORT\\", 10) \\"SHORT\\" >>> convert(\\"AAAAA\\", 3) \\"AAAAA\\" >>> convert(\\"AB\\", 2) \\"AB\\"","solution":"def convert(s, numRows): Converts a string to a zig-zag pattern with the given number of rows. # Edge case where zig-zag pattern is not needed if numRows == 1 or numRows >= len(s): return s rows = [''] * min(numRows, len(s)) cur_row = 0 going_down = False for char in s: rows[cur_row] += char if cur_row == 0 or cur_row == numRows - 1: going_down = not going_down cur_row += 1 if going_down else -1 return ''.join(rows)"},{"question":"def factorial(n: int) -> int: Returns the factorial of n. >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(10) 3628800","solution":"def factorial(n): Returns the factorial of n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def min_blocks_for_residents(t: int, test_cases: List[Tuple[int, int, List[int], int]]) -> List[int]: Determine the minimum number of blocks needed to accommodate a specific number of residents. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], int]]): Each test case contains: - n (int): Number of building blocks. - L (int): Limit on the number of blocks that can be used. - capacities (List[int]): Resident capacity of each block. - R (int): Required number of residents to be accommodated. Returns: List[int]: Minimum number of blocks needed for each test case, or -1 if not possible. Examples: >>> min_blocks_for_residents(2, [(5, 3, [1, 3, 4, 5, 7], 10), (4, 2, [2, 3, 5, 9], 10)]) [2, -1] >>> min_blocks_for_residents(1, [(3, 2, [3, 5, 2], 5)]) [1] >>> min_blocks_for_residents(1, [(5, 3, [1, 3, 4, 5, 2], 6)]) [2] >>> min_blocks_for_residents(1, [(4, 2, [1, 2, 4, 8], 15)]) [-1] >>> min_blocks_for_residents(1, [(1, 1, [1000], 1000)]) [1]","solution":"def min_blocks_for_residents(t, test_cases): results = [] for test_case in test_cases: n, L, capacities, R = test_case dp = [float('inf')] * (R + 1) dp[0] = 0 # 0 residents require 0 blocks for capacity in capacities: for j in range(R, capacity - 1, -1): dp[j] = min(dp[j], dp[j - capacity] + 1) min_blocks = min(dp[R], L + 1) if min_blocks <= L: results.append(min_blocks) else: results.append(-1) return results"},{"question":"def distinct_morph_count(words: List[str]) -> int: Given an array of strings words, determine the number of distinct morphs that can be generated by rearranging the letters of each word. A morph is a distinct permutation of the letters in a single word. Return the total count of all distinct morphs for the given list of words. >>> distinct_morph_count([\\"aab\\", \\"abb\\", \\"cd\\"]) == 8 >>> distinct_morph_count([\\"abc\\", \\"def\\"]) == 12","solution":"from math import factorial from collections import Counter def distinct_morph_count(words): def morph_count(word): freq = Counter(word) word_length = len(word) count = factorial(word_length) for val in freq.values(): count //= factorial(val) return count total_morphs = 0 for word in words: total_morphs += morph_count(word) return total_morphs"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. :param num: int, an integer between 1 and 3999 inclusive :return: str, the Roman numeral representation of the input integer >>> int_to_roman(3) \\"III\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\"","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: int, an integer between 1 and 3999 inclusive :return: str, the Roman numeral representation of the input integer val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"def match_chocolates_boxes(chocolates, boxes): Matches each chocolate with a box such that the total empty space left is minimized. Arguments: chocolates -- list of positive integers representing the sizes of the chocolates. boxes -- list of positive integers representing the sizes of the boxes. Returns: total_minimized_empty_space -- total minimized empty space left after all chocolates have been placed in the boxes. Returns -1 if it's not possible to pair chocolates and boxes. Examples: >>> match_chocolates_boxes([3, 1, 2], [2, 3, 3]) 2 >>> match_chocolates_boxes([4, 2, 5], [4, 5, 6]) 4 >>> match_chocolates_boxes([3, 4], [2, 4]) -1 >>> match_chocolates_boxes([1, 2], [3, 4, 5]) -1","solution":"def match_chocolates_boxes(chocolates, boxes): Matches each chocolate with a box such that the total empty space left is minimized. Arguments: chocolates -- list of positive integers representing the sizes of the chocolates. boxes -- list of positive integers representing the sizes of the boxes. Returns: total_minimized_empty_space -- total minimized empty space left after all chocolates have been placed in the boxes. Returns -1 if it's not possible to pair chocolates and boxes. if len(chocolates) != len(boxes): return -1 chocolates.sort() boxes.sort() total_minimized_empty_space = 0 for chocolate, box in zip(chocolates, boxes): if box < chocolate: return -1 total_minimized_empty_space += (box - chocolate) return total_minimized_empty_space"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"carerac\\") == True >>> can_form_palindrome(\\"aabbcc\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"abccba\\") == True >>> can_form_palindrome(\\"aabbccc\\") == True >>> can_form_palindrome(\\"abcdef\\") == False","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd number of counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearranged into a palindrome, # it can have at most one character with an odd count return odd_count <= 1"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None self.visited = False def hasCycle(head): Detect if a linked list has a cycle. >>> head = ListNode(3) >>> second = ListNode(2) >>> third = ListNode(0) >>> fourth = ListNode(-4) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = second >>> hasCycle(head) True >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> hasCycle(head) False >>> head = None >>> hasCycle(head) False >>> head = ListNode(1) >>> hasCycle(head) False >>> head = ListNode(1) >>> head.next = head >>> hasCycle(head) True pass","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None self.visited = False def hasCycle(head): current = head while current is not None: if current.visited: return True current.visited = True current = current.next return False"},{"question":"def contains_nearby_almost_duplicate(nums: List[int], k: int, t: int) -> bool: Determine if there are two distinct indices in the array such that the absolute difference between nums[i] and nums[j] is less than or equal to t, and the absolute difference between i and j is less than or equal to k. >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 3, 0) True >>> contains_nearby_almost_duplicate([1, 0, 1, 1], 1, 2) True >>> contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2, 3) False # Your code here # Test cases def test_case_1(): assert contains_nearby_almost_duplicate([1, 2, 3, 1], 3, 0) == True def test_case_2(): assert contains_nearby_almost_duplicate([1, 0, 1, 1], 1, 2) == True def test_case_3(): assert contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2, 3) == False def test_case_4(): assert contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 1, 2) == True def test_case_5(): assert contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2, 0) == False def test_case_6(): assert contains_nearby_almost_duplicate([-1, -1], 1, -1) == False def test_case_7(): assert contains_nearby_almost_duplicate([1], 1, 1) == False def test_case_8(): assert contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 0, 0) == False def test_case_9(): assert contains_nearby_almost_duplicate([1, 0, 1, 1], 0, 2) == False def test_case_10(): assert contains_nearby_almost_duplicate([-5, -2, -3], 2, 1) == True","solution":"def contains_nearby_almost_duplicate(nums, k, t): if k < 0 or t < 0: return False num_dict = {} for i in range(len(nums)): bucket = nums[i] // (t + 1) if bucket in num_dict: return True if (bucket - 1) in num_dict and abs(nums[i] - num_dict[bucket - 1]) <= t: return True if (bucket + 1) in num_dict and abs(nums[i] - num_dict[bucket + 1]) <= t: return True num_dict[bucket] = nums[i] if i >= k: del num_dict[nums[i - k] // (t + 1)] return False"},{"question":"from typing import List def can_rearrange_to_contiguous_sequence(piles: List[int]) -> str: Determine whether it is possible to rearrange the stone piles into a contiguous sequence starting from 1. >>> can_rearrange_to_contiguous_sequence([1, 2, 3, 4, 5]) \\"YES\\" >>> can_rearrange_to_contiguous_sequence([5, 4, 2, 1]) \\"NO\\" >>> can_rearrange_to_contiguous_sequence([1, 3, 2, 5, 4]) \\"YES\\" >>> can_rearrange_to_contiguous_sequence([1, 2, 2, 3, 4]) \\"NO\\" def test_can_rearrange_to_contiguous_sequence(): assert can_rearrange_to_contiguous_sequence([1, 2, 3, 4, 5]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([5, 4, 2, 1]) == \\"NO\\" assert can_rearrange_to_contiguous_sequence([1, 3, 2, 5, 4]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([1, 2, 2, 3, 4]) == \\"NO\\" assert can_rearrange_to_contiguous_sequence([3, 1, 4, 2]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([1, 2]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([4]) == \\"NO\\" assert can_rearrange_to_contiguous_sequence([]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([2, 1, 3, 5, 4, 6]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([1]) == \\"YES\\" assert can_rearrange_to_contiguous_sequence([2, 3, 4, 5, 6]) == \\"NO\\" assert can_rearrange_to_contiguous_sequence([5, 4, 3, 2, 1, 6]) == \\"YES\\"","solution":"def can_rearrange_to_contiguous_sequence(piles): This function takes a list of integers representing the number of stone piles and returns 'YES' if it is possible to rearrange them into a contiguous sequence from 1 to the length of the list, otherwise 'NO'. n = len(piles) expected_set = set(range(1, n + 1)) if set(piles) == expected_set: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_avg_sales(transactions: dict) -> str: Finds the item with the highest average sales per hour and returns its name. If multiple items have the same highest average sales, return the item name that comes first lexicographically. pass # Test Cases def test_max_avg_sales_basic(): transactions = { \\"apple\\": [10, 20, 30], \\"banana\\": [15, 25, 35], \\"orange\\": [20, 10, 20] } assert max_avg_sales(transactions) == \\"banana\\" def test_max_avg_sales_tie(): transactions = { \\"apple\\": [20, 20, 20], \\"banana\\": [15, 25, 20], # Same average as apple \\"orange\\": [10, 20, 10] } assert max_avg_sales(transactions) == \\"apple\\" # Should return apple due to lexicographical order def test_max_avg_sales_single_item(): transactions = { \\"apple\\": [10, 20, 30] } assert max_avg_sales(transactions) == \\"apple\\" def test_max_avg_sales_same_avg_sales(): transactions = { \\"apple\\": [10, 20, 30], \\"banana\\": [10, 20, 30], \\"orange\\": [10, 20, 30] } assert max_avg_sales(transactions) == \\"apple\\" # Should return apple due to lexicographical order def test_max_avg_sales_empty_sales(): transactions = { \\"apple\\": [0, 0, 0], \\"banana\\": [0, 0, 0], \\"orange\\": [0, 0, 0] } assert max_avg_sales(transactions) == \\"apple\\" # Should return apple due to lexicographical order def test_max_avg_sales_variations(): transactions = { \\"apple\\": [5, 5, 5, 5, 5], \\"banana\\": [5, 5, 5, 5], \\"orange\\": [5, 5, 5, 5, 5, 5] } assert max_avg_sales(transactions) == \\"apple\\" # Should return first lexicographically with same average","solution":"def max_avg_sales(transactions: dict) -> str: Finds the item with the highest average sales per hour and returns its name. If multiple items have the same highest average sales, return the item name that comes first lexicographically. max_avg = float('-inf') result_item = \\"\\" for item, sales in transactions.items(): avg_sales = sum(sales) / len(sales) if avg_sales > max_avg or (avg_sales == max_avg and item < result_item): max_avg = avg_sales result_item = item return result_item"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root): Initializes the tree with the given root node. self.root = root def find_paths(self, target_sum): Returns a list of lists where each list represents a path that sums to the target_sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> tree = BinaryTree(root) >>> tree.find_paths(22) [[5, 4, 11, 2], [5, 8, 4, 5]] import pytest from solution import TreeNode, BinaryTree def test_single_path(): root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) tree = BinaryTree(root) paths = tree.find_paths(22) assert sorted(paths) == sorted([[5, 4, 11, 2], [5, 8, 4, 5]]) def test_multiple_paths(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.right.right = TreeNode(3) tree = BinaryTree(root) paths = tree.find_paths(6) assert sorted(paths) == sorted([[1, 2, 3], [1, 2, 3]]) def test_no_path(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) tree = BinaryTree(root) paths = tree.find_paths(10) assert paths == [] def test_single_node(): root = TreeNode(5) tree = BinaryTree(root) paths = tree.find_paths(5) assert paths == [[5]] if __name__ == '__main__': pytest.main()","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root): self.root = root def find_paths(self, target_sum): def dfs(node, current_path, remaining_sum): if not node: return current_path.append(node.val) remaining_sum -= node.val if not node.left and not node.right and remaining_sum == 0: result.append(list(current_path)) else: dfs(node.left, current_path, remaining_sum) dfs(node.right, current_path, remaining_sum) current_path.pop() result = [] dfs(self.root, [], target_sum) return result"},{"question":"def fibonacci(n: int) -> int: Returns the nth number in the Fibonacci sequence. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(10) 55 def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 def test_fibonacci_large_numbers(): assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(30) == 832040 def test_fibonacci_boundary_case(): assert fibonacci(100) == 354224848179261915075 def test_n_is_large(): # Testing when n is much larger to ensure performance result = fibonacci(100000) assert isinstance(result, int) # Just confirm it returns an integer","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: return 0 if n == 1: return 1 # Initialize base values a, b = 0, 1 # Compute Fibonacci sequence up to the nth number for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def longest_unique_substring(s: str) -> str: Finds and returns the longest substring without repeating characters. Examples: >>> longest_unique_substring('abcaabcdba') 'abcd' >>> longest_unique_substring('abcabcbb') 'abc' >>> longest_unique_substring('bbbbb') 'b' >>> longest_unique_substring('pwwkew') 'wke' >>> longest_unique_substring('') '' >>> longest_unique_substring(' ') ' ' >>> longest_unique_substring('dvdf') 'vdf'","solution":"def longest_unique_substring(s): Finds and returns the longest substring without repeating characters. if not isinstance(s, str) or s == \\"\\": return \\"\\" start = 0 max_length = 0 max_substring = \\"\\" char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:i+1] return max_substring"},{"question":"def findSubstring(string1: str, string2: str) -> int: Determines if 'string2' is a substring of 'string1'. Returns the starting index of the first occurrence of 'string2' in 'string1', otherwise returns -1. >>> findSubstring(\\"watermelon\\", \\"melon\\") 5 >>> findSubstring(\\"watermelon\\", \\"melonwater\\") -1 >>> findSubstring(\\"abcabcabc\\", \\"cab\\") 2 >>> findSubstring(\\"hello\\", \\"world\\") -1 >>> findSubstring(\\"hello\\", \\"ell\\") 1 >>> findSubstring(\\"abcdef\\", \\"\\") 0 >>> findSubstring(\\"short\\", \\"thisisverylong\\") -1 >>> findSubstring(\\"banana\\", \\"banana\\") 0 >>> findSubstring(\\"hello world!\\", \\"world!\\") 6 >>> findSubstring(\\"123 456 789\\", \\" 456 \\") 3 >>> findSubstring(\\"a!@#b\\", \\"!@#\\") 1 >>> findSubstring(\\"Hello\\", \\"hello\\") -1","solution":"def findSubstring(string1, string2): Determines if 'string2' is a substring of 'string1'. Returns the starting index of the first occurrence of 'string2' in 'string1', otherwise returns -1. if string2 == \\"\\": return 0 if len(string2) > len(string1): return -1 index = string1.find(string2) return index"},{"question":"from typing import List, Tuple def minimum_toys(K: int, top_colors: List[str], bottom_colors: List[str]) -> int: This function computes the minimum number of toys needed such that there are exactly K different toys with unique (top, bottom) color combinations. >>> minimum_toys(3, [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"], [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"]) 3 >>> minimum_toys(2, [\\"red\\", \\"blue\\"], [\\"green\\", \\"yellow\\"]) 2 pass def minimum_toys_for_all_cases(test_cases: List[Tuple[int, List[str], List[str]]]) -> List[int]: This function computes the minimum number of toys needed for multiple test cases, where each test case is represented by a tuple containing the number of unique toys K, a list of top colors, and a list of bottom colors. >>> test_cases = [ ... (3, [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"], [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"]), ... (2, [\\"red\\", \\"blue\\"], [\\"green\\", \\"yellow\\"]), ... (4, [\\"red\\", \\"blue\\", \\"green\\"], [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"]), ... (5, [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"], [\\"red\\", \\"blue\\", \\"green\\"]), ... (6, [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"], [\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\", \\"pink\\"]) ... ] >>> minimum_toys_for_all_cases(test_cases) [3, 2, 4, 5, 6] pass","solution":"def minimum_toys(K, top_colors, bottom_colors): This function computes the minimum number of toys needed such that there are exactly K different toys with unique (top, bottom) color combinations. distinct_tops = len(set(top_colors)) distinct_bottoms = len(set(bottom_colors)) min_toys = min(distinct_tops * distinct_bottoms, K) return min_toys def minimum_toys_for_all_cases(test_cases): results = [] for K, top_colors, bottom_colors in test_cases: results.append(minimum_toys(K, top_colors, bottom_colors)) return results"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root: Optional[TreeNode]) -> int: Create a function that computes the sum of all root-to-leaf paths, where each path’s value is interpreted as a number formed by concatenating the decimal values from root to leaf. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sum_root_to_leaf(root) 25 >>> root = TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0)) >>> sum_root_to_leaf(root) 1026","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root: Optional[TreeNode]) -> int: def dfs(node, current_num): if not node: return 0 current_num = current_num * 10 + node.val if not node.left and not node.right: return current_num return dfs(node.left, current_num) + dfs(node.right, current_num) return dfs(root, 0)"},{"question":"def find_single_number(nums: List[int]) -> int: Find the single number that does not appear twice in the list. >>> find_single_number([4, 1, 2, 1, 2]) # return 4 >>> find_single_number([2, 2, 1]) # return 1 >>> find_single_number([1, 3, 1, 2, 2]) # return 3","solution":"def find_single_number(nums): Returns the single number that does not appear twice in the list. single = 0 for num in nums: single ^= num return single"},{"question":"class TinyDBMS: def __init__(self, array): self.array = array def update(self, i, x): pass def range_sum(self, l, r): pass def perform_operations(N, Q1, Q2, initial_array, updates, range_queries): Perform a series of updates and range sum queries on an initial array. Args: - N (int): Number of elements in the initial array. - Q1 (int): Number of update queries. - Q2 (int): Number of range sum queries. - initial_array (List[int]): Initial values of the array. - updates (List[Tuple[int, int]]): List of update queries where each query is a tuple (index, new_value). - range_queries (List[Tuple[int, int]]): List of range sum queries where each query is a tuple (left_index, right_index). Returns: - List[int]: Results of each range sum query. >>> N, Q1, Q2 = 5, 2, 2 >>> initial_array = [1, 2, 3, 4, 5] >>> updates = [(1, 10), (3, -2)] >>> range_queries = [(0, 2), (1, 4)] >>> perform_operations(N, Q1, Q2, initial_array, updates, range_queries) [14, 16] >>> N, Q1, Q2 = 5, 0, 1 >>> initial_array = [1, 2, 3, 4, 5] >>> updates = [] >>> range_queries = [(1, 3)] >>> perform_operations(N, Q1, Q2, initial_array, updates, range_queries) [9] >>> N, Q1, Q2 = 5, 5, 2 >>> initial_array = [0] * 5 >>> updates = [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1)] >>> range_queries = [(0, 4), (2, 3)] >>> perform_operations(N, Q1, Q2, initial_array, updates, range_queries) [5, 2] pass","solution":"class TinyDBMS: def __init__(self, array): self.array = array def update(self, i, x): self.array[i] = x def range_sum(self, l, r): return sum(self.array[l:r+1]) # Function to be called for the operations def perform_operations(N, Q1, Q2, initial_array, updates, range_queries): dbms = TinyDBMS(initial_array) results = [] for i, x in updates: dbms.update(i, x) for l, r in range_queries: results.append(dbms.range_sum(l, r)) return results"},{"question":"def factorial(n): Returns the factorial of a non-negative integer n. If n is not a non-negative integer, returns None. >>> factorial(5) 120 >>> factorial(4) 24 >>> factorial(0) 1 >>> factorial(20) 2432902008176640000 >>> factorial(3.5) None >>> factorial(\\"5\\") None >>> factorial([1, 2, 3]) None >>> factorial(-5) None","solution":"def factorial(n): Returns the factorial of a non-negative integer n. If n is not a non-negative integer, returns None. if not isinstance(n, int) or n < 0: return None if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression containing non-negative integers and the operators \`+\` and \`-\`. >>> evaluate_expression(\\"3+5-2\\") 6 >>> evaluate_expression(\\"10-4+2\\") 8 def test_evaluate_expression_basic_addition(): assert evaluate_expression(\\"3+5\\") == 8 def test_evaluate_expression_basic_subtraction(): assert evaluate_expression(\\"10-3\\") == 7 def test_evaluate_expression_addition_and_subtraction(): assert evaluate_expression(\\"3+5-2\\") == 6 assert evaluate_expression(\\"10-4+2\\") == 8 def test_evaluate_expression_multiple_operations(): assert evaluate_expression(\\"10+20-5+3-2\\") == 26 assert evaluate_expression(\\"1+2+3-4-5\\") == -3 def test_evaluate_expression_single_number(): assert evaluate_expression(\\"42\\") == 42 assert evaluate_expression(\\"0\\") == 0","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing non-negative integers and the operators \`+\` and \`-\`. # Split the expression into tokens, separating by '+' and '-' tokens = [] num = '' for char in expression: if char in '+-': if num: tokens.append(int(num)) num = '' tokens.append(char) else: num += char if num: tokens.append(int(num)) # Initialize the result with the first number result = tokens[0] i = 1 # Iterate through the tokens and calculate the result while i < len(tokens): if tokens[i] == '+': result += tokens[i+1] elif tokens[i] == '-': result -= tokens[i+1] i += 2 return result"},{"question":"# Define the regular expression pattern for integers in the range from 100 to 999 inclusive regex_integer_in_range_3 = r\\"\\" # Define the regular expression pattern to ensure there are no duplicate digits regex_no_duplicate_digits = r\\"\\" # Test cases to validate the solution def test_valid_range(): assert bool(re.match(regex_integer_in_range_3, \\"100\\")) assert bool(re.match(regex_integer_in_range_3, \\"999\\")) assert bool(re.match(regex_integer_in_range_3, \\"456\\")) assert not bool(re.match(regex_integer_in_range_3, \\"099\\")) assert not bool(re.match(regex_integer_in_range_3, \\"1000\\")) assert not bool(re.match(regex_integer_in_range_3, \\"abc\\")) def test_no_duplicate_digits(): assert bool(re.match(regex_no_duplicate_digits, \\"123\\")) assert bool(re.match(regex_no_duplicate_digits, \\"456\\")) assert not bool(re.match(regex_no_duplicate_digits, \\"112\\")) assert not bool(re.match(regex_no_duplicate_digits, \\"101\\")) assert not bool(re.match(regex_no_duplicate_digits, \\"aaa\\")) assert not bool(re.match(regex_no_duplicate_digits, \\"12\\")) def test_valid_passcode(): assert bool(re.match(regex_integer_in_range_3, '123')) and bool(re.match(regex_no_duplicate_digits, '123')) assert bool(re.match(regex_integer_in_range_3, '789')) and bool(re.match(regex_no_duplicate_digits, '789')) assert not (bool(re.match(regex_integer_in_range_3, '112')) and bool(re.match(regex_no_duplicate_digits, '112'))) assert not (bool(re.match(regex_integer_in_range_3, '99')) and bool(re.match(regex_no_duplicate_digits, '99'))) assert not (bool(re.match(regex_integer_in_range_3, '999')) and bool(re.match(regex_no_duplicate_digits, '999')))","solution":"import re # Define the regular expression pattern for integers in the range from 100 to 999 inclusive regex_integer_in_range_3 = r\\"^(?:100|[1-9][0-9][0-9])\\" # Define the regular expression pattern to ensure there are no duplicate digits regex_no_duplicate_digits = r\\"^(?!.*(.).*1)[0-9]{3}\\""},{"question":"def count_unique_colors(N: int, M: int, pixels: List[List[Tuple[int, int, int]]]) -> int: Returns the number of unique colors in the given image represented by pixels. :param N: Number of rows in the image :param M: Number of columns in the image :param pixels: List of list of tuples, where each tuple represents an RGB value of a pixel :return: Integer representing the number of unique colors >>> pixels = [ ... [(255, 0, 0), (0, 255, 0), (0, 0, 255)], ... [(255, 0, 0), (0, 0, 255), (0, 255, 0)], ... [(0, 255, 0), (0, 0, 255), (255, 0, 0)] ... ] >>> count_unique_colors(3, 3, pixels) 3 >>> pixels = [ ... [(128, 128, 128), (128, 128, 128)], ... [(128, 128, 128), (128, 128, 128)] ... ] >>> count_unique_colors(2, 2, pixels) 1 >>> pixels = [ ... [(0, 0, 0), (255, 255, 255)], ... [(255, 0, 0), (0, 255, 0)], ... [(0, 0, 255), (255, 255, 0)] ... ] >>> count_unique_colors(3, 2, pixels) 6 >>> pixels = [ ... [(0, 0, 0)] ... ] >>> count_unique_colors(1, 1, pixels) 1 >>> pixels = [ ... [(12, 34, 56), (78, 90, 123)], ... [(12, 34, 56), (255, 0, 0)], ... [(255, 255, 255), (0, 0, 0)] ... ] >>> count_unique_colors(3, 2, pixels) 5 # Add your implementation here","solution":"def count_unique_colors(N, M, pixels): Returns the number of unique colors in the given image represented by pixels. :param N: Number of rows in the image :param M: Number of columns in the image :param pixels: List of list of tuples, where each tuple represents an RGB value of a pixel :return: Integer representing the number of unique colors unique_colors = set() for row in pixels: for pixel in row: unique_colors.add(pixel) return len(unique_colors) # Example usage: # pixels = [ # [(255, 0, 0), (0, 255, 0), (0, 0, 255)], # [(255, 0, 0), (0, 0, 255), (0, 255, 0)], # [(0, 255, 0), (0, 0, 255), (255, 0, 0)] # ] # N, M = 3, 3 # print(count_unique_colors(N, M, pixels)) # Output: 3"},{"question":"def max_gap(nums: List[int]) -> int: Develop a function called \`max_gap\` that takes a list of integers and returns the maximum gap between consecutive elements when the list is sorted. If the list has fewer than 2 elements, return 0. >>> max_gap([3, 6, 9, 1]) == 3 >>> max_gap([10]) == 0 >>> max_gap([9, 7, 3, 2, 4, 1]) == 3","solution":"def max_gap(nums): Returns the maximum gap between consecutive elements in the sorted list of integers. If the list has fewer than 2 elements, return 0. if len(nums) < 2: return 0 nums.sort() max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i] - nums[i - 1]) return max_gap"},{"question":"def word_compress(s: str) -> str: Compresses a given string by converting consecutive repeating characters into their respective counts followed by the character itself. Args: s (str): The input string to compress. Returns: str: The compressed version of the input string. Examples: >>> word_compress(\\"aaabbc\\") '3a2bc' >>> word_compress(\\"abcd\\") 'abcd' >>> word_compress(\\"aabbccdd\\") '2a2b2c2d' >>> word_compress(\\"aabbaa\\") '2a2b2a' >>> word_compress(\\"\\") '' >>> word_compress(\\"aaAA\\") '2a2A' >>> word_compress(\\"a1b2\\") 'a1b2'","solution":"def word_compress(s): Compresses a given string by converting consecutive repeating characters into their respective counts followed by the character itself. Args: s (str): The input string to compress. Returns: str: The compressed version of the input string. if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{count}{current_char}\\" if count > 1 else current_char) current_char = char count = 1 compressed.append(f\\"{count}{current_char}\\" if count > 1 else current_char) return ''.join(compressed)"},{"question":"def count_unobstructed_view(heights: List[int]) -> int: Returns the number of buildings that have an unobstructed view to the west. Example 1: >>> count_unobstructed_view([3, 7, 8, 3, 6, 1]) 3 Example 2: >>> count_unobstructed_view([1, 2, 3, 4]) 4","solution":"def count_unobstructed_view(heights): Returns the number of buildings that have an unobstructed view to the west. :param heights: List of integers representing the heights of the buildings. :return: Integer count of buildings with an unobstructed view to the west. max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"def find_largest_unique_substring(s: str) -> str: Returns the largest substring without repeating characters. If there are multiple substrings with the same length, the one which starts earliest in the string should be returned. >>> find_largest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> find_largest_unique_substring(\\"bbbbb\\") \\"b\\" >>> find_largest_unique_substring(\\"pwwkew\\") \\"wke\\"","solution":"def find_largest_unique_substring(s: str) -> str: Returns the largest substring without repeating characters. If there are multiple substrings with the same length, the one which starts earliest in the string should be returned. start = 0 max_length = 0 longest_substring = \\"\\" seen_chars = {} for end, char in enumerate(s): if char in seen_chars and seen_chars[char] >= start: start = seen_chars[char] + 1 seen_chars[char] = end if end - start + 1 > max_length: max_length = end - start + 1 longest_substring = s[start:end+1] return longest_substring"},{"question":"def mergeAlternately(list1, list2): Merges two lists alternately. If one list is longer, append the remaining elements. Args: list1, list2: Lists of strings to be merged. Returns: A single list with elements alternately taken from list1 and list2. >>> mergeAlternately(['a', 'b', 'c'], ['1', '2', '3']) ['a', '1', 'b', '2', 'c', '3'] >>> mergeAlternately(['a', 'b'], ['1', '2', '3', '4', '5']) ['a', '1', 'b', '2', '3', '4', '5'] >>> mergeAlternately(['a', 'b', 'c', 'd', 'e'], ['1', '2']) ['a', '1', 'b', '2', 'c', 'd', 'e'] >>> mergeAlternately([], ['1', '2', '3']) ['1', '2', '3'] >>> mergeAlternately(['a', 'b', 'c'], []) ['a', 'b', 'c'] >>> mergeAlternately([], []) [] >>> mergeAlternately(['a'], ['1']) ['a', '1']","solution":"def mergeAlternately(list1, list2): Merges two lists alternately. If one list is longer, append the remaining elements. Args: list1, list2: Lists of strings to be merged. Returns: A single list with elements alternately taken from list1 and list2. merged_list = [] len1, len2 = len(list1), len(list2) for i in range(max(len1, len2)): if i < len1: merged_list.append(list1[i]) if i < len2: merged_list.append(list2[i]) return merged_list"},{"question":"from typing import List def warmest_days(temperatures: List[int]) -> List[int]: You are given a list of integers representing the daily temperatures recorded over a week. Write a function \`warmest_days(temperatures)\` that returns a list where each element is the number of days you would have to wait after the current day to experience a warmer temperature. If there is no future day for which this is possible, put 0 in the respective position. >>> warmest_days([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> warmest_days([79, 78, 77, 76, 75, 74, 73, 72]) [0, 0, 0, 0, 0, 0, 0, 0] >>> warmest_days([70, 71, 72, 73, 74, 75, 76, 77]) [1, 1, 1, 1, 1, 1, 1, 0] >>> warmest_days([75]) [0] >>> warmest_days([73, 73, 73, 75, 70, 70, 75, 76]) [3, 2, 1, 4, 2, 1, 1, 0]","solution":"def warmest_days(temperatures): Returns a list of integers where each element is the number of days until a warmer temperature, or 0 if no warmer temperature exists in the future. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"from typing import List, Set def get_common_restrictions(guests: List[Set[str]]) -> Set[str]: You are planning to host a party and have invited several guests. Each guest can have one or more dietary restrictions such as \\"vegetarian,\\" \\"vegan,\\" \\"nut-free,\\" etc. You need to prepare the party menu accordingly. Write a function get_common_restrictions(guests) that takes a list of guests, where each guest is represented as a set of dietary restrictions, and returns a set of dietary restrictions that apply to all guests. Examples: >>> guests1 = [{\\"vegetarian\\", \\"nut-free\\"}, {\\"vegetarian\\", \\"gluten-free\\"}, {\\"vegetarian\\"}] >>> get_common_restrictions(guests1) {\\"vegetarian\\"} >>> guests2 = [{\\"vegan\\"}, {\\"vegetarian\\", \\"nut-free\\"}, {\\"gluten-free\\"}] >>> get_common_restrictions(guests2) set()","solution":"def get_common_restrictions(guests): if not guests: return set() # Find the common restrictions among all guests common_restrictions = guests[0] # Initialize with the first set of restrictions for restrictions in guests[1:]: common_restrictions &= restrictions # Perform intersection return common_restrictions"},{"question":"def min_changes_to_good(s: str) -> int: Returns the minimum number of character changes needed to make the string s a \\"good\\" string. A \\"good\\" string is defined as a string where no two adjacent characters are the same. >>> min_changes_to_good(\\"aab\\") 1 >>> min_changes_to_good(\\"aaaa\\") 3 >>> min_changes_to_good(\\"abcdef\\") 0","solution":"def min_changes_to_good(s): Returns the minimum number of character changes needed to make the string s a \\"good\\" string. A \\"good\\" string is defined as a string where no two adjacent characters are the same. changes = 0 for i in range(1, len(s)): if s[i] == s[i-1]: changes += 1 return changes"},{"question":"from typing import List def ways_to_reach_target(T: int) -> int: Determines the number of distinct ways to reach the sales target T using 5 loaves of bread and 1 cupcakes. :param T: int, sales target in dollars :return: int, the number of distinct ways to reach the sales target >>> ways_to_reach_target(10) 3 >>> ways_to_reach_target(8) 2 >>> ways_to_reach_target(0) 1","solution":"def ways_to_reach_target(T): Determines the number of distinct ways to reach the sales target T using 5 loaves of bread and 1 cupcakes. :param T: int, sales target in dollars :return: int, the number of distinct ways to reach the sales target ways = 0 for loaves in range(T // 5 + 1): remaining = T - loaves * 5 if remaining >= 0: ways += 1 return ways"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"racecar\\") \\"YES\\" pass def check_palindrome_possibilities(strings: List[str]) -> List[str]: For each string in the provided list, returns 'YES' if it can be rearranged to form a palindrome, otherwise 'NO'. >>> check_palindrome_possibilities([\\"civic\\", \\"ivicc\\", \\"hello\\", \\"racecar\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> check_palindrome_possibilities([\\"a\\", \\"bc\\", \\"deed\\", \\"noon\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> check_palindrome_possibilities([\\"xxyyzz\\", \\"xyz\\", \\"yyzzz\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_form_palindrome(s): Determines if the string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character char_counts = Counter(s) # To form a palindrome, at most one character can have an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindrome_possibilities(strings): For each string in the provided list, prints 'YES' if it can be rearranged to form a palindrome, otherwise 'NO'. results = [] for s in strings: results.append(can_form_palindrome(s)) return results"},{"question":"def can_form_consecutive_sequence(arr): Check if the given list of integers can be rearranged to form a sequence of consecutive integers without any gaps. :param arr: List of integers :return: Boolean, True if sequence without gaps is possible, otherwise False >>> can_form_consecutive_sequence([3, 2, 1, 4, 5]) == True >>> can_form_consecutive_sequence([1, 4, 3, 2, 6]) == False >>> can_form_consecutive_sequence([1]) == True >>> can_form_consecutive_sequence([3, 3, 2, 2, 1, 1, 4, 4, 5, 5]) == True >>> can_form_consecutive_sequence([1, 3, 3, 5, 6, 6, 7, 8, 8]) == False >>> can_form_consecutive_sequence([]) == False >>> can_form_consecutive_sequence([-3, -2, -1, 0, 1, 2, 3]) == True >>> can_form_consecutive_sequence([-2, -1, 0, 1, 2, 4]) == False","solution":"def can_form_consecutive_sequence(arr): Check if the given list of integers can be rearranged to form a sequence of consecutive integers without any gaps. :param arr: List of integers :return: Boolean, True if sequence without gaps is possible, otherwise False if not arr: return False min_val = min(arr) max_val = max(arr) expected_set = set(range(min_val, max_val + 1)) return set(arr) == expected_set"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are any two distinct elements in the array whose sum equals the target sum. :param arr: List of integers. :param target: Target sum. :return: True if there exists a pair with the target sum, otherwise False. >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([-1, 2, 5, -7, 9], 4) True","solution":"def has_pair_with_sum(arr, target): Determines if there are any two distinct elements in the array whose sum equals the target sum. :param arr: List of integers. :param target: Target sum. :return: True if there exists a pair with the target sum, otherwise False. seen = set() for number in arr: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def can_form_palindrome(sentence: str) -> bool: Checks if the given sentence can be rearranged to form a palindrome. Args: sentence (str): The input sentence to be checked. Returns: bool: True if the sentence can be rearranged to form a palindrome, False otherwise. # Your implementation here # Example tests def test_palindrome_sentences(): assert can_form_palindrome(\\"A man a plan a canal Panama\\") == True assert can_form_palindrome(\\"racecar\\") == True def test_non_palindrome_sentences(): assert can_form_palindrome(\\"hello\\") == False assert can_form_palindrome(\\"This is not a palindrome\\") == False def test_empty_and_single_char(): assert can_form_palindrome(\\"\\") == True # Empty string is a trivial case of palindrome assert can_form_palindrome(\\"a\\") == True # Single character is trivially a palindrome def test_mixed_cases_and_symbols(): assert can_form_palindrome(\\"No 'x' in Nixon\\") == True assert can_form_palindrome(\\"Madam, in Eden, I'm Adam\\") == True def test_complex_palindromic_phrases(): assert can_form_palindrome(\\"Able, was I, I saw Elba.\\") == True assert can_form_palindrome(\\"Eva, can I see bees in a cave?\\") == True","solution":"def can_form_palindrome(sentence: str) -> bool: Checks if the given sentence can be rearranged to form a palindrome. Args: sentence (str): The input sentence to be checked. Returns: bool: True if the sentence can be rearranged to form a palindrome, False otherwise. # Filter out non-alphabetic characters and convert to lower case filtered_sentence = ''.join(char.lower() for char in sentence if char.isalpha()) # Count the occurrences of each character char_counts = {} for char in filtered_sentence: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Check the palindrome condition: at most one character with an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def rob(nums: List[int]) -> int: Determines the maximum amount of money you can rob tonight without robbing two adjacent houses. >>> rob([2, 3, 2]) 4 >>> rob([1, 2, 3, 1]) 4","solution":"def rob(nums): Determines the maximum amount of money you can rob tonight without robbing two adjacent houses. :param nums: List of non-negative integers representing money in each house. :return: The maximum amount of money you can rob. if not nums: return 0 if len(nums) == 1: return nums[0] max_money = [0] * len(nums) max_money[0] = nums[0] max_money[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): max_money[i] = max(max_money[i-1], max_money[i-2] + nums[i]) return max_money[-1]"},{"question":"from typing import List, Tuple def can_partition(nums: List[int]) -> str: Determines if the list can be split into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) 'YES' >>> can_partition([1, 2, 5]) 'NO' >>> can_partition([1, 1, 1, 1, 1]) 'NO' pass def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases to determine if each list can be split into two subsets with equal sum. >>> solve(3, [(4, [1, 5, 11, 5]), (3, [1, 2, 5]), (5, [1, 1, 1, 1, 1])]) ['YES', 'NO', 'NO'] pass","solution":"def can_partition(nums): Determines if the list can be split into two subsets with equal sum. total = sum(nums) # If total sum is odd, it's not possible to partition it into two equal subsets if total % 2 != 0: return \\"NO\\" target = total // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\" def solve(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] nums = test_cases[i][1] result = can_partition(nums) results.append(result) return results"},{"question":"def is_balanced(s: str) -> bool: Returns True if the string s is balanced (all opening parentheses and brackets have matching closing parentheses and brackets in proper order), and False otherwise. >>> is_balanced(\\"([])[]\\") True >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"()()\\") True >>> is_balanced(\\"[]\\") True >>> is_balanced(\\"(()\\") False >>> is_balanced(\\"[[\\") False >>> is_balanced(\\"[([])]\\") True >>> is_balanced(\\"[(])\\") False","solution":"def is_balanced(s): Returns True if the string s is balanced (all opening parentheses and brackets have matching closing parentheses and brackets in proper order), and False otherwise. stack = [] matching_bracket = {')': '(', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if stack == [] or stack.pop() != matching_bracket[char]: return False return stack == []"},{"question":"from typing import List, Tuple, Union def find_pair_with_sum(numbers: List[int], target: int) -> Union[Tuple[int, int], str, None]: Write a function that takes a list of integers and a target integer as input and returns a tuple containing a pair of indices of two numbers in the list that add up to the target integer. If there are multiple pairs, return the first pair found. If no such pair exists, return \`None\`. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4, 5], 6) (1, 3) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([2, \\"7\\", 11, 15], 9) 'Please enter a valid list of integers' >>> find_pair_with_sum([2, 7, 11, 15], \\"9\\") 'Please enter a valid target integer'","solution":"def find_pair_with_sum(numbers, target): Returns a tuple containing a pair of indices of two numbers in the list that add up to the target integer. If no such pair exists, return None. If the input is not valid, return a respective error message. :param numbers: List of integers. :param target: Target integer. :return: Tuple of two indices or None. if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): return \\"Please enter a valid list of integers\\" if not isinstance(target, int): return \\"Please enter a valid target integer\\" num_map = {} for i, num in enumerate(numbers): difference = target - num if difference in num_map: return (num_map[difference], i) num_map[num] = i return None"},{"question":"def first_unique_char(s: str) -> str: Write a function that takes a string and returns the first character that appears only once. If no such character exists, return an empty string. Your solution should work efficiently even for long strings (up to 10^6 characters). >>> first_unique_char(\\"abracadabra\\") \\"c\\" # 'c' is the first character that appears only once >>> first_unique_char(\\"swiss\\") \\"w\\" # 'w' is the first character that appears only once >>> first_unique_char(\\"repeated\\") \\"r\\" # 'r' is the first character that appears only once >>> first_unique_char(\\"aardvark\\") \\"d\\" # 'd' is the first character that appears only once >>> first_unique_char(\\"aabbccdd\\") \\"\\" # No unique characters","solution":"def first_unique_char(s): Returns the first character in the string that appears only once. If no such character exists, returns an empty string. # Dictionary to store the count of each character char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no unique character exists return \\"\\""},{"question":"def is_anagram_palindrome(s: str) -> bool: Determines if any anagram of the input string can form a palindrome. :param s: input string :return: True if an anagram can form a palindrome, False otherwise >>> is_anagram_palindrome(\\"civic\\") == True >>> is_anagram_palindrome(\\"ivicc\\") == True >>> is_anagram_palindrome(\\"hello\\") == False >>> is_anagram_palindrome(\\"racecar\\") == True >>> is_anagram_palindrome(\\"A man, a plan, a canal, Panama!\\") == True","solution":"def is_anagram_palindrome(s): Determines if any anagram of the input string can form a palindrome. :param s: input string :return: True if an anagram can form a palindrome, False otherwise import re from collections import Counter # Remove non-alphanumeric characters and convert to lower case cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count the frequency of each character char_count = Counter(cleaned_s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd frequency return odd_count <= 1"},{"question":"def calculate_median(numbers: List[float]) -> float: Returns the median of a sequence of numbers. >>> calculate_median([1, 3, 3, 6, 7, 8, 9]) 6.0 >>> calculate_median([1, 2, 3, 4, 5, 6, 8, 9]) 4.5 >>> calculate_median([5]) 5.0 >>> calculate_median([1, 3]) 2.0 >>> calculate_median([10, 1, 5, 3, 2]) 3.0 >>> calculate_median([5, 1, 6, 3, 2, 4]) 3.5 >>> calculate_median([-5, -1, -6, -3, -2, -4]) -3.5 >>> calculate_median([-3, -1, 2, 4, 6]) 2.0 >>> calculate_median([7, -3, 4, -1, 5]) 4.0","solution":"def calculate_median(numbers): Returns the median of a sequence of numbers. n = len(numbers) sorted_numbers = sorted(numbers) mid = n // 2 if n % 2 == 1: # Odd case return float(sorted_numbers[mid]) else: # Even case return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2.0"},{"question":"from typing import List, Tuple def longest_mountain(arr: List[int]) -> int: Given a list of integers \`arr\`, this function returns the length of the longest subsequence that is a valid mountain array. If no valid mountain array exists, it returns 0. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 1]) == 5 >>> longest_mountain([2, 2, 2, 2, 2]) == 0 pass def solve_mountain_arrays(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function processes multiple test cases and returns the lengths of the longest subsequences that are valid mountain arrays for each test case. >>> solve_mountain_arrays(2, [(8, [2, 1, 4, 7, 3, 2, 5, 1]), (5, [2, 2, 2, 2, 2])]) == [5, 0] pass def test_single_mountain(): assert longest_mountain([2, 1, 4, 7, 3, 2, 5, 1]) == 5 def test_no_mountain(): assert longest_mountain([2, 2, 2, 2, 2]) == 0 def test_edge_case_minimum_length(): assert longest_mountain([1, 2, 3, 2, 1]) == 5 assert longest_mountain([1, 2, 1]) == 3 assert longest_mountain([2, 1, 2]) == 0 def test_multiple_mountains(): assert longest_mountain([0, 2, 0, 2, 0, 2, 0, 2]) == 3 def test_all_ascending(): assert longest_mountain([1, 2, 3, 4, 5]) == 0 def test_all_descending(): assert longest_mountain([5, 4, 3, 2, 1]) == 0 def test_solve_mountain_arrays_multiple_cases(): test_cases = [ (8, [2, 1, 4, 7, 3, 2, 5, 1]), (5, [2, 2, 2, 2, 2]), (10, [0, 1, 0, 1, 2, 3, 4, 2, 1, 0]) ] assert solve_mountain_arrays(3, test_cases) == [5, 0, 8] def test_solve_mountain_arrays_single_case(): test_cases = [ (5, [3, 5, 6, 4, 3]) ] assert solve_mountain_arrays(1, test_cases) == [5]","solution":"def longest_mountain(arr): Given a list of integers \`arr\`, this function returns the length of the longest subsequence that is a valid mountain array. If no valid mountain array exists, it returns 0. n = len(arr) if n < 3: return 0 max_length = 0 for i in range(1, n - 1): # Check if the current element is a peak if arr[i - 1] < arr[i] > arr[i + 1]: # Explore left to find the length of the increasing sequence left = i while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Explore right to find the length of the decreasing sequence right = i while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of the mountain array length = right - left + 1 max_length = max(max_length, length) return max_length def solve_mountain_arrays(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] result = longest_mountain(arr) results.append(result) return results"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Determines whether any two elements in the array sum up to the target value. >>> two_sum([1, 2, 3, 4], 5) True >>> two_sum([1, 2, 3, 4], 8) False >>> two_sum([-1, -2, -3, -4], -5) True >>> two_sum([0, 0, 0, 0], 0) True >>> two_sum([1], 2) False","solution":"def two_sum(nums, target): Determines whether any two elements in the array sum up to the target value. :param nums: List of integers. :param target: Target sum value. :return: True if such a pair exists, False otherwise. seen_numbers = set() for num in nums: complement = target - num if complement in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"def find_missing_number(nums: List[int]) -> int: Write a function, \`find_missing_number\`, that takes in a list of unique integers sorted in ascending order which represents a range of consecutive numbers, and returns the single missing integer in the range. Examples: >>> find_missing_number([1, 2, 3, 4, 6]) 5 >>> find_missing_number([10, 11, 12, 13, 15]) 14 >>> find_missing_number([100, 101, 103, 104]) 102","solution":"def find_missing_number(nums): Returns the missing number from a list of consecutive integers with one missing number. expected_sum = sum(range(nums[0], nums[-1] + 1)) actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"from typing import List def maximalSquare(matrix: List[str]) -> int: Returns the area of the largest square containing only '1's in a binary matrix. >>> maximalSquare([\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 4 >>> maximalSquare([\\"111\\", \\"111\\", \\"111\\"]) 9 >>> maximalSquare([\\"00\\", \\"00\\"]) 0 >>> maximalSquare([\\"0110\\", \\"1111\\", \\"1110\\"]) 4 def process_input_to_matrix(m: int, n: int, raw_matrix: List[str]) -> List[str]: Convert raw input lines into a matrix. >>> process_input_to_matrix(4, 5, [\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"]) [\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"] >>> process_input_to_matrix(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) [\\"111\\", \\"111\\", \\"111\\"] # Unit tests def test_maximalSquare_case1(): m, n = 4, 5 raw_matrix = [ \\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\" ] matrix = process_input_to_matrix(m, n, raw_matrix) assert maximalSquare(matrix) == 4 def test_maximalSquare_case2(): m, n = 3, 3 raw_matrix = [ \\"111\\", \\"111\\", \\"111\\" ] matrix = process_input_to_matrix(m, n, raw_matrix) assert maximalSquare(matrix) == 9 def test_maximalSquare_empty_matrix(): m, n = 0, 0 raw_matrix = [] matrix = process_input_to_matrix(m, n, raw_matrix) assert maximalSquare(matrix) == 0 def test_maximalSquare_all_zeros(): m, n = 2, 2 raw_matrix = [ \\"00\\", \\"00\\" ] matrix = process_input_to_matrix(m, n, raw_matrix) assert maximalSquare(matrix) == 0 def test_maximalSquare_mixed(): m, n = 3, 4 raw_matrix = [ \\"0110\\", \\"1111\\", \\"1110\\" ] matrix = process_input_to_matrix(m, n, raw_matrix) assert maximalSquare(matrix) == 4","solution":"def maximalSquare(matrix): Returns the area of the largest square containing only '1's in a binary matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side def process_input_to_matrix(m, n, raw_matrix): matrix = [] for line in raw_matrix: matrix.append(line.strip()) return matrix"},{"question":"def shorten(buildings: List[int]) -> int: This function takes a list of integers representing the heights of buildings and returns the minimum number of buildings that need to be reduced in height in order to ensure no three consecutive buildings have an increasing sequence of height. >>> shorten([3, 4, 5, 3, 2]) == 1 >>> shorten([1, 2, 3, 4, 5]) == 2 >>> shorten([5, 5, 5]) == 0 >>> shorten([5, 3, 4, 2, 6, 7, 5]) == 1","solution":"def shorten(buildings): This function takes a list of integers representing the heights of buildings and returns the minimum number of buildings that need to be reduced in height in order to ensure no three consecutive buildings have an increasing sequence of height. if len(buildings) < 3: return 0 count = 0 for i in range(2, len(buildings)): if buildings[i] > buildings[i-1] > buildings[i-2]: count += 1 if buildings[i] - buildings[i-1] < buildings[i-1] - buildings[i-2]: buildings[i] = buildings[i-1] else: buildings[i-1] = buildings[i-2] return count"},{"question":"def longest_palindrome_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. >>> longest_palindrome_subsequence(\\"abacaba\\") 7 >>> longest_palindrome_subsequence(\\"abcde\\") 1 >>> longest_palindrome_subsequence(\\"a\\") 1 >>> longest_palindrome_subsequence(\\"aa\\") 2 >>> longest_palindrome_subsequence(\\"ab\\") 1 >>> longest_palindrome_subsequence(\\"aabaa\\") 5 >>> longest_palindrome_subsequence(\\"aaaa\\") 4 >>> longest_palindrome_subsequence(\\"aedcb\\") 1","solution":"def longest_palindrome_subsequence(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) # Create a DP table to store the lengths of longest palindromic subsequences dp = [[0] * n for _ in range(n)] # All single characters are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Filling up the table for cl in range(2, n + 1): # cl is the length of the current substring for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of longest palindromic subseq will be in dp[0][n-1] return dp[0][n - 1]"},{"question":"def decode_string(s: str) -> str: Implement a function to decode a string with nested repetition patterns. The input string can contain alphabetic characters (A-Z, a-z), digits (0-9), and square brackets '[]'. An encoded pattern consists of a digit followed by a substring enclosed in square brackets, which means that the substring inside the brackets should appear the number of times specified by the digit. Nested encoded patterns need to be decoded from the innermost pattern first. Examples: >>> decode_string(\\"3[a]2[bc]\\") 'aaabcbc' >>> decode_string(\\"3[a2[c]]\\") 'accaccacc' >>> decode_string(\\"2[abc]3[cd]ef\\") 'abcabccdcdcdef' >>> decode_string(\\"abc3[cd]xyz\\") 'abccdcdcdxyz'","solution":"def decode_string(s: str) -> str: stack = [] current_number = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == '[': stack.append((current_string, current_number)) current_string = \\"\\" current_number = 0 elif char == ']': last_string, number = stack.pop() current_string = last_string + current_string * number else: current_string += char return current_string"},{"question":"def sum_of_evens_up_to_each_element(nums: List[int]) -> List[int]: Returns a new list where each element is the sum of all even numbers up to and including that element in the original list. Parameters: nums (list of int): Original list of integers. Returns: list of int: New list with sums of all even numbers up to each element. >>> sum_of_evens_up_to_each_element([1, 2, 3, 4, 5, 6]) [0, 2, 2, 6, 6, 12] >>> sum_of_evens_up_to_each_element([2, 4, 6, 8]) [2, 6, 12, 20] >>> sum_of_evens_up_to_each_element([1, 3, 5, 7]) [0, 0, 0, 0] >>> sum_of_evens_up_to_each_element([]) [] >>> sum_of_evens_up_to_each_element([0]) [0] >>> sum_of_evens_up_to_each_element([-2, -3, -4, -5]) [-2, -2, -6, -6] >>> sum_of_evens_up_to_each_element([-1, -2, -3, -4]) [0, -2, -2, -6] >>> sum_of_evens_up_to_each_element([0, 0, 0]) [0, 0, 0]","solution":"def sum_of_evens_up_to_each_element(nums): Returns a new list where each element is the sum of all even numbers up to and including that element in the original list. Parameters: nums (list of int): Original list of integers. Returns: list of int: New list with sums of all even numbers up to each element. result = [] current_sum = 0 for num in nums: if num % 2 == 0: current_sum += num result.append(current_sum) return result"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. Example usages: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"aabbcc\\") True","solution":"from collections import Counter def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1"},{"question":"def group_anagrams(strs): Groups the anagrams together from the given list of strings. Args: strs (List[str]): List of strings. Returns: List[List[str]]: List of groups of anagrams. pass # Unit Tests def test_group_anagrams_example(): input_data = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = group_anagrams(input_data) # Convert each sublist to a frozenset to ignore order within groups expected = [ frozenset([\\"ate\\", \\"eat\\", \\"tea\\"]), frozenset([\\"nat\\", \\"tan\\"]), frozenset([\\"bat\\"]) ] result_frozensets = [frozenset(group) for group in result] assert set(expected) == set(result_frozensets) def test_group_anagrams_single_word(): input_data = [\\"abcd\\"] result = group_anagrams(input_data) expected = [[\\"abcd\\"]] assert result == expected def test_group_anagrams_no_anagrams(): input_data = [\\"abc\\", \\"def\\", \\"ghi\\"] result = group_anagrams(input_data) expected = [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] result_sorted = [sorted(group) for group in result] expected_sorted = [sorted(group) for group in expected] assert result_sorted == expected_sorted def test_group_anagrams_all_anagrams(): input_data = [\\"abc\\", \\"bca\\", \\"cab\\"] result = group_anagrams(input_data) expected = [[\\"abc\\", \\"bca\\", \\"cab\\"]] result_sorted = [sorted(group) for group in result] expected_sorted = [sorted(group) for group in expected] assert result_sorted == expected_sorted def test_group_anagrams_empty_list(): input_data = [] result = group_anagrams(input_data) expected = [] assert result == expected def test_group_anagrams_multiple_words(): input_data = [\\"rac\\", \\"car\\", \\"arc\\", \\"rat\\", \\"tar\\", \\"art\\", \\"elbow\\", \\"below\\"] result = group_anagrams(input_data) expected = [ frozenset([\\"rac\\", \\"car\\", \\"arc\\"]), frozenset([\\"rat\\", \\"tar\\", \\"art\\"]), frozenset([\\"elbow\\", \\"below\\"]) ] result_frozensets = [frozenset(group) for group in result] assert set(expected) == set(result_frozensets)","solution":"from collections import defaultdict def group_anagrams(strs): Groups the anagrams together from the given list of strings. Args: strs (List[str]): List of strings. Returns: List[List[str]]: List of groups of anagrams. anagram_dict = defaultdict(list) for s in strs: # Sort the string and use it as a key sorted_str = ''.join(sorted(s)) anagram_dict[sorted_str].append(s) # Return the values of the dictionary return list(anagram_dict.values())"},{"question":"from typing import List def move_zeros(nums: List[int]) -> None: Moves all non-zero elements to the beginning of the array while maintaining the relative order of the non-zero elements. Additionally, moves all zero elements to the end of the array. Operates in-place without making a copy of the array. >>> nums = [0, 1, 0, 3, 12] >>> move_zeros(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 1] >>> move_zeros(nums) >>> nums [1, 0, 0] >>> nums = [2, 0, 1, 3, 0, 4] >>> move_zeros(nums) >>> nums [2, 1, 3, 4, 0, 0] >>> nums = [0, 0, 0] >>> move_zeros(nums) >>> nums [0, 0, 0]","solution":"def move_zeros(nums): Moves all non-zero elements to the beginning of the array while maintaining the relative order of the non-zero elements. Additionally, moves all zero elements to the end of the array. Operates in-place without making a copy of the array. insert_pos = 0 # Position to insert the next non-zero element # Move non-zero elements to the front for i in range(len(nums)): if nums[i] != 0: nums[insert_pos] = nums[i] insert_pos += 1 # Fill the rest with zeros for i in range(insert_pos, len(nums)): nums[i] = 0"},{"question":"def borough_of_nyc(taxi_rides): Takes a list of taxi rides and returns a dictionary mapping each borough to the number of taxi rides that either started or ended in that borough. Each ride is represented as a dictionary containing 'pickup_borough' and 'dropoff_borough'. >>> rides = [ ... {\\"pickup_borough\\": \\"Manhattan\\", \\"dropoff_borough\\": \\"Brooklyn\\"}, ... {\\"pickup_borough\\": \\"Brooklyn\\", \\"dropoff_borough\\": \\"Queens\\"}, ... {\\"pickup_borough\\": \\"Bronx\\", \\"dropoff_borough\\": \\"Manhattan\\"}, ... {\\"pickup_borough\\": \\"Queens\\", \\"dropoff_borough\\": \\"Manhattan\\"}, ... {\\"pickup_borough\\": \\"Manhattan\\", \\"dropoff_borough\\": \\"Staten Island\\"} ... ] >>> borough_of_nyc(rides) { \\"Manhattan\\": 4, \\"Brooklyn\\": 2, \\"Queens\\": 2, \\"Bronx\\": 1, \\"Staten Island\\": 1 } pass def test_borough_of_nyc(): rides = [ {\\"pickup_borough\\": \\"Manhattan\\", \\"dropoff_borough\\": \\"Brooklyn\\"}, {\\"pickup_borough\\": \\"Brooklyn\\", \\"dropoff_borough\\": \\"Queens\\"}, {\\"pickup_borough\\": \\"Bronx\\", \\"dropoff_borough\\": \\"Manhattan\\"}, {\\"pickup_borough\\": \\"Queens\\", \\"dropoff_borough\\": \\"Manhattan\\"}, {\\"pickup_borough\\": \\"Manhattan\\", \\"dropoff_borough\\": \\"Staten Island\\"} ] result = borough_of_nyc(rides) expected = { \\"Manhattan\\": 4, \\"Brooklyn\\": 2, \\"Queens\\": 2, \\"Bronx\\": 1, \\"Staten Island\\": 1 } assert result == expected def test_empty_rides(): rides = [] result = borough_of_nyc(rides) expected = { \\"Manhattan\\": 0, \\"Brooklyn\\": 0, \\"Queens\\": 0, \\"Bronx\\": 0, \\"Staten Island\\": 0 } assert result == expected def test_single_ride(): rides = [{\\"pickup_borough\\": \\"Manhattan\\", \\"dropoff_borough\\": \\"Bronx\\"}] result = borough_of_nyc(rides) expected = { \\"Manhattan\\": 1, \\"Brooklyn\\": 0, \\"Queens\\": 0, \\"Bronx\\": 1, \\"Staten Island\\": 0 } assert result == expected def test_same_pickup_and_dropoff(): rides = [ {\\"pickup_borough\\": \\"Manhattan\\", \\"dropoff_borough\\": \\"Manhattan\\"}, {\\"pickup_borough\\": \\"Brooklyn\\", \\"dropoff_borough\\": \\"Brooklyn\\"} ] result = borough_of_nyc(rides) expected = { \\"Manhattan\\": 2, \\"Brooklyn\\": 2, \\"Queens\\": 0, \\"Bronx\\": 0, \\"Staten Island\\": 0 } assert result == expected","solution":"def borough_of_nyc(taxi_rides): Takes a list of taxi rides and returns a dictionary mapping each borough to the number of taxi rides that either started or ended in that borough. Each ride is represented as a dictionary containing 'pickup_borough' and 'dropoff_borough'. # Initialize the dictionary with boroughs and their corresponding counts set to 0 borough_counts = { \\"Manhattan\\": 0, \\"Brooklyn\\": 0, \\"Queens\\": 0, \\"Bronx\\": 0, \\"Staten Island\\": 0 } # Loop through each ride and increment the count for the pickup and dropoff boroughs for ride in taxi_rides: borough_counts[ride[\\"pickup_borough\\"]] += 1 borough_counts[ride[\\"dropoff_borough\\"]] += 1 return borough_counts"},{"question":"def is_zig_zag_array(arr: List[int]) -> bool: Determine if the given array is a zig-zag array. A zig-zag array satisfies the condition that for all values of \`i\`: - Either \`arr[i-1] < arr[i] > arr[i+1]\` - Or \`arr[i-1] > arr[i] < arr[i+1]\` >>> is_zig_zag_array([1, 3, 2, 4, 3]) True >>> is_zig_zag_array([1, 3, 2, 2, 3]) False from typing import List def test_zig_zag_true_case(): assert is_zig_zag_array([1, 3, 2, 4, 3]) == True def test_zig_zag_false_case(): assert is_zig_zag_array([1, 3, 2, 2, 3]) == False def test_short_array(): assert is_zig_zag_array([1, 2]) == True assert is_zig_zag_array([2]) == True assert is_zig_zag_array([]) == True def test_single_peak(): assert is_zig_zag_array([5, 10, 5]) == True def test_non_zig_zag_array(): assert is_zig_zag_array([1, 2, 3, 4, 5]) == False def test_zig_zag_all_equal_elements(): assert is_zig_zag_array([3, 3, 3, 3, 3]) == False def test_zig_zag_with_negative_numbers(): assert is_zig_zag_array([-1, 0, -1, 0, -1]) == True assert is_zig_zag_array([-1, -3, -2, -5, -4]) == True","solution":"def is_zig_zag_array(arr): if len(arr) < 3: return True # Smaller arrays are trivially zig-zag for i in range(1, len(arr) - 1): if not (arr[i-1] < arr[i] > arr[i+1] or arr[i-1] > arr[i] < arr[i+1]): return False return True"},{"question":"def max_absolute_difference(n: int, power_values: List[int]) -> int: Returns the maximum absolute difference between any two power values in the given list. >>> max_absolute_difference(6, [10, 20, 30, 40, 50, 60]) 50 >>> max_absolute_difference(4, [1, 100, 1, 100]) 99","solution":"def max_absolute_difference(n, power_values): Returns the maximum absolute difference between any two power values in the given list. Parameters: n : int : number of stones (length of the list) power_values : list : list of integers representing the power values of stones Returns: int : maximum absolute difference between any two stones' power values max_power = max(power_values) min_power = min(power_values) return max_power - min_power"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Reverse nodes of a linked list in k-group blocks. Args: head (ListNode): The head of the linked list. k (int): The size of the groups to reverse. Returns: ListNode: The head of the modified linked list. Examples: >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> k = 2 >>> reversed_head = reverseKGroup(head, k) >>> linked_list_to_list(reversed_head) [2, 1, 4, 3, 5] >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> k = 3 >>> reversed_head = reverseKGroup(head, k) >>> linked_list_to_list(reversed_head) [3, 2, 1, 6, 5, 4, 7, 8] pass def list_to_linked_list(lst): dummy = ListNode() ptr = dummy for number in lst: ptr.next = ListNode(number) ptr = ptr.next return dummy.next def linked_list_to_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst import pytest def test_reverse_k_group_case1(): head = list_to_linked_list([1, 2, 3, 4, 5]) k = 2 expected_output = [2, 1, 4, 3, 5] reversed_head = reverseKGroup(head, k) assert linked_list_to_list(reversed_head) == expected_output def test_reverse_k_group_case2(): head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) k = 3 expected_output = [3, 2, 1, 6, 5, 4, 7, 8] reversed_head = reverseKGroup(head, k) assert linked_list_to_list(reversed_head) == expected_output def test_reverse_k_group_single_element(): head = list_to_linked_list([1]) k = 1 expected_output = [1] reversed_head = reverseKGroup(head, k) assert linked_list_to_list(reversed_head) == expected_output def test_reverse_k_group_less_than_k(): head = list_to_linked_list([1, 2, 3]) k = 4 expected_output = [1, 2, 3] reversed_head = reverseKGroup(head, k) assert linked_list_to_list(reversed_head) == expected_output def test_reverse_k_group_exact_k(): head = list_to_linked_list([1, 2, 3, 4]) k = 4 expected_output = [4, 3, 2, 1] reversed_head = reverseKGroup(head, k) assert linked_list_to_list(reversed_head) == expected_output","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): prev = None current = head while k > 0: temp = current.next current.next = prev prev = current current = temp k -= 1 return prev count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head def list_to_linked_list(lst): dummy = ListNode() ptr = dummy for number in lst: ptr.next = ListNode(number) ptr = ptr.next return dummy.next def linked_list_to_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst"},{"question":"from typing import List from math import gcd def gcd_transform(array: List[int]) -> List[int]: Given a list of integers, replace each element with the GCD of that element and the next element in the array. The last element remains unchanged. >>> gcd_transform([24, 36, 48, 72]) [12, 12, 24, 72] >>> gcd_transform([5, 10, 15, 20]) [5, 5, 5, 20]","solution":"from math import gcd def gcd_transform(array): Given a list of integers, replace each element with the GCD of that element and the next element in the array. The last element remains unchanged. n = len(array) for i in range(n - 1): array[i] = gcd(array[i], array[i+1]) return array"},{"question":"def count_unique_subsequences(n: int, genome: str, k: int) -> int: Determine the number of unique subsequences of length k in the given genome sequence. >>> count_unique_subsequences(5, \\"ATCGT\\", 2) 9 >>> count_unique_subsequences(4, \\"AAAA\\", 2) 1 pass def test_count_unique_subsequences_example(): assert count_unique_subsequences(5, \\"ATCGT\\", 2) == 9 def test_count_unique_subsequences_k_equals_n(): assert count_unique_subsequences(4, \\"ATCG\\", 4) == 1 def test_count_unique_subsequences_k_greater_than_n(): assert count_unique_subsequences(4, \\"ATCG\\", 5) == 0 def test_count_unique_subsequences_repeated_characters(): assert count_unique_subsequences(4, \\"AAAA\\", 2) == 1 def test_count_unique_subsequences_all_characters(): assert count_unique_subsequences(4, \\"ATCG\\", 2) == 6 def test_count_unique_subsequences_min_input(): assert count_unique_subsequences(1, \\"A\\", 1) == 1","solution":"def count_unique_subsequences(n, genome, k): Returns the number of unique subsequences of length k in the given genome sequence. if k > n: return 0 from itertools import combinations subsequences = set() for comb in combinations(range(n), k): subseq = ''.join(genome[i] for i in comb) subsequences.add(subseq) return len(subsequences)"},{"question":"def square_odd_numbers(lst: List[int]) -> List[int]: Returns a new list with each element squared, but only if the original element was an odd number. If the element was even, it is excluded from the new list. >>> square_odd_numbers([1, 2, 3, 4, 5]) [1, 9, 25] >>> square_odd_numbers([6, 7, 8, 9, 10]) [49, 81] >>> square_odd_numbers([12, 14, 15]) [225]","solution":"def square_odd_numbers(lst): Returns a new list with each element squared, but only if the original element was an odd number. If the element was even, it is excluded from the new list. return [x ** 2 for x in lst if x % 2 != 0]"},{"question":"from typing import List def min_operations_to_non_decreasing(sequence: List[int]) -> int: Given a sequence of integers, calculate the minimum number of operations needed to make the sequence non-decreasing. >>> min_operations_to_non_decreasing([4, 2, 3, 1, 5]) 6 >>> min_operations_to_non_decreasing([1, 2, 3]) 0 >>> min_operations_to_non_decreasing([10]) 0 >>> min_operations_to_non_decreasing([-100, -50, 0, 50, 100]) 0 >>> min_operations_to_non_decreasing([100000, -100000, 100000, -100000]) 400000 >>> min_operations_to_non_decreasing([1, 3, 2, 4, 3, 5]) 2","solution":"def min_operations_to_non_decreasing(sequence): Given a sequence of integers, calculate the minimum number of operations needed to make the sequence non-decreasing. min_operations = 0 n = len(sequence) for i in range(1, n): if sequence[i] < sequence[i-1]: min_operations += sequence[i-1] - sequence[i] sequence[i] = sequence[i-1] return min_operations"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Implement a function \`unique_elements\` which receives a list of integers \`[a1, a2, ..., an]\` and returns a new list of integers \`[b1, b2, ..., bk]\` such that each element in the output list is unique and the order of elements in the input list is preserved. For every element that appears multiple times in the input list, only the first occurrence is kept in the output list. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([10, 20, 10, 30, 20, 20, 30, 40, 50, 50]) [10, 20, 30, 40, 50] >>> unique_elements([7, 5, 9, 1, 5, 9, 7, 1]) [7, 5, 9, 1] >>> unique_elements([100]) [100] >>> unique_elements([]) []","solution":"def unique_elements(lst): Removes duplicates from the input list while preserving order of first occurrences. Args: lst (List[int]): A list of integers which may contain duplicates. Returns: List[int]: A list of integers with duplicates removed, maintaining the order of first occurrences. seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"from typing import List def findUnique(arr: List[int]) -> int: Returns the element that appears only once in an array where every other element appears exactly three times. >>> findUnique([2, 2, 3, 2]) 3 >>> findUnique([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def findUnique(arr): Returns the element that appears only once in an array where every other element appears exactly three times. ones, twos = 0, 0 for num in arr: # \\"ones ^ num\\" is XOR operation with the current number # \\"& ~twos\\" ensures that if the number is in 'twos', it will not be in 'ones' ones = (ones ^ num) & ~twos # \\"twos ^ num\\" is XOR operation with the current number # \\"& ~ones\\" ensures that if the number is in 'ones', it will not be in 'twos' twos = (twos ^ num) & ~ones return ones"},{"question":"from typing import List def max_apples(grid: List[List[str]]) -> int: Given a grid representing a field of apples ('A') and empty spaces ('E'), find the maximum number of apples that can be collected by moving from the top-left corner to the bottom-right corner. You can only move right or down at each step. Args: grid (List[List[str]]): 2D List of strings representing the grid Returns: int: Maximum number of apples that can be collected Example: >>> grid = [ ['A', 'E', 'A'], ['A', 'A', 'E'], ['E', 'A', 'A'] ] >>> max_apples(grid) 5 >>> grid = [ ['E', 'E', 'E'], ['E', 'E', 'E'], ['E', 'E', 'E'] ] >>> max_apples(grid) 0 pass def test_example_case(): grid = [ ['A', 'E', 'A'], ['A', 'A', 'E'], ['E', 'A', 'A'] ] assert max_apples(grid) == 5 def test_all_empty(): grid = [ ['E', 'E', 'E'], ['E', 'E', 'E'], ['E', 'E', 'E'] ] assert max_apples(grid) == 0 def test_single_apple(): grid = [ ['A', 'E', 'E'], ['E', 'E', 'E'], ['E', 'E', 'A'] ] assert max_apples(grid) == 2 def test_single_row(): grid = [['A', 'E', 'A', 'A', 'E']] assert max_apples(grid) == 3 def test_single_column(): grid = [['A'], ['E'], ['A'], ['A'], ['E']] assert max_apples(grid) == 3 def test_large_grid(): grid = [ ['A']*100 for _ in range(100) ] assert max_apples(grid) == 199 def test_no_apples_in_path(): grid = [ ['E', 'E', 'A'], ['A', 'E', 'A'], ['A', 'E', 'A'] ] assert max_apples(grid) == 3","solution":"from typing import List def max_apples(grid: List[List[str]]) -> int: n = len(grid) m = len(grid[0]) # Create a DP table to store the number of apples collected at each cell dp = [[0] * m for _ in range(n)] # Initialize the starting position dp[0][0] = 1 if grid[0][0] == 'A' else 0 # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + (1 if grid[0][j] == 'A' else 0) # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + (1 if grid[i][0] == 'A' else 0) # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + (1 if grid[i][j] == 'A' else 0) # The answer is at the bottom-right corner of the grid return dp[n - 1][m - 1]"},{"question":"def longestCommonSuffix(strings: List[str]) -> str: Returns the longest common suffix shared among all strings in the list. Inputs: - strings: List of non-empty strings to find the common suffix from. Output: - The longest common suffix as a string. If no common suffix exists, returns an empty string. Examples: >>> longestCommonSuffix([\\"walking\\", \\"running\\", \\"jogging\\"]) \\"ing\\" >>> longestCommonSuffix([\\"hello\\", \\"world\\", \\"python\\"]) \\"\\" >>> longestCommonSuffix([\\"sunflower\\", \\"tower\\", \\"power\\"]) \\"ower\\" >>> longestCommonSuffix([\\"abcde\\", \\"vwxyz\\", \\"12345\\"]) \\"\\"","solution":"def longestCommonSuffix(strings): Returns the longest common suffix shared among all strings in the list. if not strings: return \\"\\" # Reverse all strings to work from the end reversed_strings = [s[::-1] for s in strings] # Find the minimum length string to limit the comparison range min_length = min(len(s) for s in reversed_strings) common_suffix = [] for i in range(min_length): # Check if the current character in all reversed strings is the same current_char = reversed_strings[0][i] if all(s[i] == current_char for s in reversed_strings): common_suffix.append(current_char) else: break # Reverse to get the original order return ''.join(common_suffix)[::-1]"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. Examples: >>> group_anagrams(['listen', 'silent', 'enlist', 'google', 'gooogle']) [['listen', 'silent', 'enlist'], ['google'], ['gooogle']] >>> group_anagrams(['rat', 'art', 'tar', 'star', 'tars']) [['rat', 'art', 'tar'], ['star', 'tars']] >>> group_anagrams(['abc', 'def', 'ghi']) [['abc'], ['def'], ['ghi']] pass def test_group_anagrams_example_cases(): assert group_anagrams(['listen', 'silent', 'enlist', 'google', 'gooogle']) == [ ['listen', 'silent', 'enlist'], ['google'], ['gooogle'] ] assert group_anagrams(['rat', 'art', 'tar', 'star', 'tars']) == [ ['rat', 'art', 'tar'], ['star', 'tars'] ] assert group_anagrams(['abc', 'def', 'ghi']) == [ ['abc'], ['def'], ['ghi'] ] def test_group_anagrams_single_words(): assert group_anagrams(['a', 'b', 'c']) == [ ['a'], ['b'], ['c'] ] def test_group_anagrams_multiple_same_words(): assert group_anagrams(['a', 'a', 'a']) == [ ['a', 'a', 'a'] ] def test_group_anagrams_empty_list(): assert group_anagrams([]) == [] def test_group_anagrams_large_example(): words = ['abcdefghij'] * 1000 expected_result = [['abcdefghij'] * 1000] assert group_anagrams(words) == expected_result","solution":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. :param words: A list of words to be grouped into anagrams. :return: A list of lists where each list contains words that are anagrams of each other. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def is_valid_tree(n: int, edges: List[List[int]]) -> bool: Determines if the given pipeline structure forms a valid tree. A valid tree is an acyclic, connected graph with exactly \`n-1\` edges for \`n\` vertices. Args: n: An integer representing the number of vertices (junctions or fields). edges: A list of pairs where each pair represents an undirected edge between the vertices. Returns: True if the pipeline structure forms a valid tree, otherwise False. Examples: >>> is_valid_tree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]) True >>> is_valid_tree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]) False >>> is_valid_tree(4, [[0, 1], [2, 3]]) False","solution":"def is_valid_tree(n, edges): if len(edges) != n - 1: return False parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] for u, v in edges: root_u = find(u) root_v = find(v) if root_u == root_v: return False parent[root_u] = root_v return True"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): Perform level order traversal on a binary tree. Parameters ---------- root : TreeNode The root node of the binary tree. Returns ------- List[List[int]] A list of lists, where each list contains the node values at each level. Example ------- >>> root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> levelOrderTraversal(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> levelOrderTraversal(root) [[1]] >>> levelOrderTraversal(None) [] pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): Perform level order traversal on a binary tree. Parameters ---------- root : TreeNode The root node of the binary tree. Returns ------- List[List[int]] A list of lists, where each list contains the node values at each level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def longest_subarray(nums: List[int]) -> int: Determines the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to 1. Args: nums : list of int A list of positive integers. Returns: int The length of the longest contiguous subarray. >>> longest_subarray([1, 3, 2, 3, 4, 2, 3]) 4 >>> longest_subarray([1, 1, 1, 1, 1]) 5 >>> longest_subarray([1, 3, 5, 7, 9]) 1 >>> longest_subarray([1]) 1 >>> longest_subarray([]) 0 >>> longest_subarray([1, 2, 2, 3, 4, 6, 7, 7, 8, 9]) 5","solution":"def longest_subarray(nums): Determines the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to 1. Args: nums : list of int A list of positive integers. Returns: int The length of the longest contiguous subarray. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if abs(nums[i] - nums[i - 1]) <= 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def is_anagram_of_palindrome(s: str) -> bool: Determines if the given string is an anagram of a palindrome. >>> is_anagram_of_palindrome(\\"civic\\") True >>> is_anagram_of_palindrome(\\"ivicc\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(\\"aab\\") True >>> is_anagram_of_palindrome(\\"carerac\\") True","solution":"def is_anagram_of_palindrome(s): Determines if the given string is an anagram of a palindrome. Args: s (str): The input string. Returns: bool: True if the string is an anagram of a palindrome, False otherwise. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Determine the number of characters that appear an odd number of times odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be an anagram of a palindrome, there can be at most one character with an odd count return odd_count <= 1"},{"question":"def final_robot_position(commands): Determines the final position of the robot on the grid after processing valid commands. Parameters: commands (list of str): List of movement commands. Returns: tuple: The final position (x, y) of the robot on the grid. Examples: >>> final_robot_position([\\"N3\\", \\"E2\\", \\"S1\\", \\"W4\\"]) (-2, 2) >>> final_robot_position([\\"N10\\", \\"E5\\", \\"S5\\", \\"W15\\"]) (-10, 5) >>> final_robot_position([\\"N0\\", \\"E0\\", \\"S0\\", \\"W0\\"]) (0, 0) >>> final_robot_position([\\"N3\\", \\"A2\\", \\"S1\\", \\"W4\\"]) (0, 3) >>> final_robot_position([\\"Z5\\", \\"N1\\", \\"E1\\"]) (0, 0) >>> final_robot_position([\\"N-not-a-number\\", \\"E2\\"]) (0, 0) >>> final_robot_position([\\"N3\\", \\"E2\\", \\"G1\\", \\"S1\\", \\"W4\\"]) (2, 3) # Add your solution here","solution":"def final_robot_position(commands): Determines the final position of the robot on the grid after processing valid commands. Parameters: commands (list of str): List of movement commands. Returns: tuple: The final position (x, y) of the robot on the grid. x, y = 0, 0 for command in commands: if len(command) < 2 or not command[1:].isdigit(): break direction = command[0] distance = int(command[1:]) if direction == 'N': y += distance elif direction == 'S': y -= distance elif direction == 'E': x += distance elif direction == 'W': x -= distance else: break return x, y"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the array can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([0]) True >>> can_partition([2, 2]) True >>> can_partition([1, 1, 3, 4, 7]) True >>> can_partition([1, 2, 3, 8]) False","solution":"def can_partition(nums): Determine if the array can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, it cannot be partitioned into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array initialized to False dp = [False] * (target + 1) dp[0] = True # Base case: zero sum is always achieved for num in nums: # Traverse backwards to avoid using the same item multiple times for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def unique_substrings(S: str, L: int) -> int: Returns the number of unique substrings of length L from string S. >>> unique_substrings(\\"ababc\\", 2) 3 >>> unique_substrings(\\"aaaa\\", 1) 1 >>> unique_substrings(\\"abcde\\", 3) 3 from solution import unique_substrings def test_unique_substrings_basic_cases(): assert unique_substrings(\\"ababc\\", 2) == 3 # \\"ab\\", \\"ba\\", \\"bc\\" assert unique_substrings(\\"aaaa\\", 1) == 1 # \\"a\\" assert unique_substrings(\\"abcde\\", 3) == 3 # \\"abc\\", \\"bcd\\", \\"cde\\" def test_unique_substrings_single_character(): assert unique_substrings(\\"a\\", 1) == 1 # \\"a\\" assert unique_substrings(\\"b\\", 1) == 1 # \\"b\\" def test_unique_substrings_length_greater_than_string_length(): assert unique_substrings(\\"abc\\", 5) == 0 assert unique_substrings(\\"abcd\\", 10) == 0 def test_unique_substrings_length_equals_string_length(): assert unique_substrings(\\"abcd\\", 4) == 1 # \\"abcd\\" assert unique_substrings(\\"aaaa\\", 4) == 1 # \\"aaaa\\" def test_unique_substrings_all_different_characters(): assert unique_substrings(\\"abcdef\\", 2) == 5 # \\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\" assert unique_substrings(\\"abcdef\\", 3) == 4 # \\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\" def test_unique_substrings_repeating_patterns(): assert unique_substrings(\\"abababab\\", 2) == 2 # \\"ab\\", \\"ba\\" assert unique_substrings(\\"abcdabcd\\", 4) == 4 # \\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"","solution":"def unique_substrings(S, L): Returns the number of unique substrings of length L from string S. if L > len(S): return 0 substrings = set() for i in range(len(S) - L + 1): substrings.add(S[i:i+L]) return len(substrings)"},{"question":"def reconstruct_sequence(n: int, m: int, B: List[int]) -> List[int]: Reconstructs the original sequence A given the sequence B. Parameters: n (int): The length of the sequence A and B. m (int): The number of initial values which are the same between A and B. B (list): The sequence B which dictates the rest of the sequence. Returns: list: The original sequence A. >>> reconstruct_sequence(6, 2, [5, 3, 8, 10, 16, 22]) [5, 3, 8, 10, 16, 22] >>> reconstruct_sequence(5, 2, [2, 1, 3, 3, 4]) [2, 1, 3, 3, 4] >>> reconstruct_sequence(3, 2, [1, 5, 6]) [1, 5, 6] >>> reconstruct_sequence(4, 2, [7, 7, 14, 21]) [7, 7, 14, 21] >>> reconstruct_sequence(10, 3, [4, 2, 7, 11, 15, 18, 24, 28, 31, 35]) [4, 2, 7, 11, 15, 18, 24, 28, 31, 35]","solution":"def reconstruct_sequence(n, m, B): Reconstructs the original sequence A given the sequence B. Parameters: n (int): The length of the sequence A and B. m (int): The number of initial values which are the same between A and B. B (list): The sequence B which dictates the rest of the sequence. Returns: list: The original sequence A. # Initial values of A are the same as B A = B[:m] # Iterate over the rest of B to reconstruct A for i in range(m, n): min_val = min(A[i-m:i]) max_val = max(A[i-m:i]) A.append(B[i]) return A"},{"question":"from typing import List, Tuple, Union def statistics(numbers: List[int]) -> Tuple[float, Union[int, float], List[int]]: Calculates the mean, median, and mode(s) of a given list of integers. Parameters: numbers (List[int]): A list of integers to analyze. Returns: Tuple[float, Union[int, float], List[int]]: A tuple containing the mean (float), median (int or float), and mode(s) (list of integers). >>> statistics([1, 2, 2, 3, 4]) (2.4, 2, [2]) >>> statistics([1, 1, 2, 2, 3, 4]) (2.1666666666666665, 2, [1, 2])","solution":"from collections import Counter from typing import List, Tuple, Union def statistics(numbers: List[int]) -> Tuple[float, Union[int, float], List[int]]: Calculates the mean, median, and mode(s) of a given list of integers. Parameters: numbers (List[int]): A list of integers to analyze. Returns: Tuple[float, Union[int, float], List[int]]: A tuple containing the mean (float), median (int or float), and mode(s) (list of integers). # Calculate mean mean = sum(numbers) / len(numbers) # Calculate median sorted_numbers = sorted(numbers) n = len(sorted_numbers) if n % 2 == 1: median = sorted_numbers[n // 2] else: median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2 # Calculate mode counter = Counter(sorted_numbers) max_freq = max(counter.values()) modes = [num for num, freq in counter.items() if freq == max_freq] return (mean, median, modes)"},{"question":"def process_queries(N: int, Q: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes the given queries on the array A. Parameters: N (int): size of the array Q (int): number of queries A (list): initial array queries (list of tuples): list of queries Returns: list: results of the queries of type \\"2 L R\\" >>> process_queries(5, 3, [1, 3, 5, 7, 9], [(2, 2, 4), (1, 3, 2), (2, 1, 5)]) [3, 1] >>> process_queries(3, 3, [5, 5, 5], [(1, 1, 1), (1, 2, 2), (1, 3, 3)]) []","solution":"def process_queries(N, Q, A, queries): Processes the given queries on the array A. Parameters: N (int): size of the array Q (int): number of queries A (list): initial array queries (list of tuples): list of queries Returns: list: results of the queries of type \\"2 L R\\" results = [] for query in queries: if query[0] == 1: # Update operation _, X, V = query A[X-1] = V # Update the X-th element to V elif query[0] == 2: # Minimum in subarray operation _, L, R = query results.append(min(A[L-1:R])) # Append the minimum element from L to R subarray return results"},{"question":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Given an array of integers, find the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. You may assume k is always valid, 1 ≤ k ≤ array's length. Parameters: nums (List[int]): The list of integers. k (int): The order number of the element to find. Returns: int: The k-th largest element in the array. Examples: >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 1) 6","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums return heapq.nlargest(k, nums)[-1]"},{"question":"def count_divisors(arr: List[int]) -> List[int]: For each element in the list, returns how many other elements in the list can divide it without leaving a remainder. >>> count_divisors([1]) [1] >>> count_divisors([2, 2, 2]) [3, 3, 3] >>> count_divisors([4, 7, 9]) [1, 1, 1] >>> count_divisors([2, 3, 4, 6, 8]) [1, 1, 2, 3, 3] >>> count_divisors([10, 15, 20, 25]) [1, 1, 2, 1] >>> count_divisors([1000000, 500000, 250000]) [3, 2, 1] >>> count_divisors([1000000, 1000000, 1000000]) [3, 3, 3]","solution":"def count_divisors(arr): For each element in the list, returns how many other elements in the list can divide it without leaving a remainder. n = len(arr) result = [] for i in range(n): count = 0 for j in range(n): if arr[i] % arr[j] == 0: count += 1 result.append(count) return result # Example usage: # print(count_divisors([2, 3, 4, 6, 8])) # Output should be [1, 1, 2, 3, 3]"},{"question":"def sort_prime_and_nonprime(arr: List[int]) -> List[int]: Sorts an array such that all prime numbers appear at the beginning in ascending order, followed by non-prime numbers in ascending order. Args: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list with primes first followed by non-primes. >>> sort_prime_and_nonprime([3, 8, 4, 7, 6, 2]) [2, 3, 7, 4, 6, 8] >>> sort_prime_and_nonprime([10, 1, 11, 17, 20]) [11, 17, 1, 10, 20] from solution import sort_prime_and_nonprime def test_example_case_1(): assert sort_prime_and_nonprime([3, 8, 4, 7, 6, 2]) == [2, 3, 7, 4, 6, 8] def test_example_case_2(): assert sort_prime_and_nonprime([10, 1, 11, 17, 20]) == [11, 17, 1, 10, 20] def test_all_primes(): assert sort_prime_and_nonprime([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] def test_all_non_primes(): assert sort_prime_and_nonprime([1, 4, 6, 8, 9]) == [1, 4, 6, 8, 9] def test_mixed_primes_and_non_primes(): assert sort_prime_and_nonprime([29, 1, 18, 5, 15, 11]) == [5, 11, 29, 1, 15, 18] def test_single_element_prime(): assert sort_prime_and_nonprime([7]) == [7] def test_single_element_non_prime(): assert sort_prime_and_nonprime([4]) == [4] def test_empty_array(): assert sort_prime_and_nonprime([]) == [] def test_large_numbers(): assert sort_prime_and_nonprime([999983, 987654, 100003, 123456, 567890]) == [100003, 999983, 123456, 567890, 987654]","solution":"def is_prime(num): if num < 2: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def sort_prime_and_nonprime(arr): primes = [x for x in arr if is_prime(x)] non_primes = [x for x in arr if not is_prime(x)] primes.sort() non_primes.sort() return primes + non_primes"},{"question":"def min_jumps(arr: List[int]) -> int: Return the minimum number of jumps required to reach the last index, or -1 if it is not possible. Args: arr (List[int]): A list of non-negative integers where each element represents the maximum number of steps you can advance. Returns: int: The minimum number of jumps required to reach the last index, or -1 if it is not possible. Examples: >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([0]) 0 >>> min_jumps([1, 1]) 1 >>> min_jumps([0, 1]) -1","solution":"def min_jumps(arr): Returns the minimum number of jumps required to reach the last index of the array, or -1 if it's not possible. if len(arr) <= 1: return 0 if arr[0] == 0: return -1 max_reach = arr[0] step = arr[0] jump = 1 for i in range(1, len(arr)): if i == len(arr) - 1: return jump max_reach = max(max_reach, i + arr[i]) step -= 1 if step == 0: jump += 1 if i >= max_reach: return -1 step = max_reach - i return -1"},{"question":"import time from threading import Timer def debouncer(func, wait): Takes a function \`func\` and a delay time in milliseconds \`wait\`. Returns a new debounced version of \`func\`. >>> def log_message(message): >>> print(message) >>> debounced_log = debouncer(log_message, 2000) >>> debounced_log(\\"Hello, world!\\") >>> time.sleep(2.5) # Output: Hello, world! >>> debounced_log(\\"Message 1\\") >>> debounced_log(\\"Message 2\\") >>> time.sleep(2.5) # Output: Message 2","solution":"import time from threading import Timer def debouncer(func, wait): Takes a function \`func\` and a delay time in milliseconds \`wait\`. Returns a new debounced version of \`func\`. wait = wait / 1000.0 # Convert milliseconds to seconds timer = None last_args = None last_kwargs = None def debounced_function(*args, **kwargs): nonlocal timer, last_args, last_kwargs last_args = args last_kwargs = kwargs if timer is not None: timer.cancel() timer = Timer(wait, lambda: func(*last_args, **last_kwargs)) timer.start() return debounced_function # Example Usage (uncomment to test) # if __name__ == \\"__main__\\": # def log_message(message): # print(message) # debounced_log = debouncer(log_message, 2000) # debounced_log(\\"Hello, world!\\") # This will get executed after 2 seconds. # time.sleep(1) # debounced_log(\\"Message 1\\") # time.sleep(1) # debounced_log(\\"Message 2\\")"},{"question":"from typing import List def count_good_cells(n: int, m: int, grid: List[str]) -> int: Count the number of good cells in a grid. A cell is considered \\"good\\" if it contains '1' and all of its 8 neighboring cells (if they exist) also contain '1'. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings. Returns: int: The number of good cells in the grid. >>> count_good_cells(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 1 >>> count_good_cells(4, 5, [\\"11110\\", \\"11001\\", \\"01101\\", \\"11111\\"]) 0 >>> count_good_cells(1, 1, [\\"1\\"]) 0 pass def test_example1(): grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert count_good_cells(3, 3, grid) == 1 def test_example2(): grid = [ \\"11110\\", \\"11001\\", \\"01101\\", \\"11111\\" ] assert count_good_cells(4, 5, grid) == 0 def test_single_cell(): grid = [ \\"1\\" ] assert count_good_cells(1, 1, grid) == 0 def test_no_good_cells(): grid = [ \\"01010\\", \\"10101\\", \\"01010\\", \\"10101\\", \\"01010\\" ] assert count_good_cells(5, 5, grid) == 0 def test_all_ones(): grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert count_good_cells(3, 3, grid) == 1 def test_large_grid(): grid = [\\"1\\" * 50] * 50 assert count_good_cells(50, 50, grid) == (50-2) * (50-2)","solution":"def count_good_cells(n, m, grid): def is_good_cell(x, y): dx = [-1, -1, -1, 0, 0, 1, 1, 1] dy = [-1, 0, 1, -1, 1, -1, 0, 1] for i in range(8): nx, ny = x + dx[i], y + dy[i] if nx < 0 or nx >= n or ny < 0 or ny >= m or grid[nx][ny] != '1': return False return True count = 0 for r in range(1, n-1): for c in range(1, m-1): if grid[r][c] == '1' and is_good_cell(r, c): count += 1 return count"},{"question":"from typing import List from math import gcd from functools import reduce def smallest_common_multiple(arr: List[int]) -> int: Returns the smallest common multiple (SCM) of the integers in the array. >>> smallest_common_multiple([1, 2, 3, 4, 5]) 60 >>> smallest_common_multiple([1, 2, 3]) 6 >>> smallest_common_multiple([5, 10]) 10 >>> smallest_common_multiple([-2, 3, 4]) 12 >>> smallest_common_multiple([0, 4, 6]) 12 >>> smallest_common_multiple([0, 0, 0]) None >>> smallest_common_multiple([]) None","solution":"from math import gcd from functools import reduce def lcm(a, b): return abs(a * b) // gcd(a, b) def smallest_common_multiple(arr): Returns the smallest common multiple (SCM) of the integers in the array. if not arr: return None # Remove zeros from the array since LCM with zero is undefined arr = [x for x in arr if x != 0] if not arr: return None return reduce(lcm, arr)"},{"question":"def convert_to_24_hour_format(time_12_hour: str) -> str: This function receives a time string in 12-hour format and converts it to a 24-hour format. >>> convert_to_24_hour_format(\\"07:05:45PM\\") \\"19:05:45\\" >>> convert_to_24_hour_format(\\"12:00:00AM\\") \\"00:00:00\\" >>> convert_to_24_hour_format(\\"12:00:00PM\\") \\"12:00:00\\"","solution":"def convert_to_24_hour_format(time_12_hour): This function receives a time string in 12-hour format and converts it to a 24-hour format. if time_12_hour[-2:] == \\"AM\\": if time_12_hour[:2] == \\"12\\": return \\"00\\" + time_12_hour[2:-2] else: return time_12_hour[:-2] else: if time_12_hour[:2] == \\"12\\": return time_12_hour[:-2] else: return str(int(time_12_hour[:2]) + 12) + time_12_hour[2:-2]"},{"question":"def check_password_strength(t: int, passwords: List[str]) -> List[str]: Coder's Guild is planning a new version release of their software which computes the strength of passwords. The software rates the strength of a password based on several rules: 1. Passwords must be at least 8 characters long. 2. Passwords must contain at least one uppercase letter. 3. Passwords must contain at least one lowercase letter. 4. Passwords must contain at least one digit. 5. Passwords must contain at least one special character from the set { !, @, #, , %, ^, &, *, (, ) }. Write a program to check the strength of a given password based on the above rules. If the password meets all the requirements, it is \\"Strong\\". If it does not meet even one of the above requirements, it is \\"Weak\\". -----Input:----- First line will contain a positive integer T, the number of test cases. Next T lines follow, each containing a string P, the password to be checked. -----Output:----- For each password P, print \\"Strong\\" without quotes if the password meets all the criteria, otherwise print \\"Weak\\" without quotes. -----Constraints----- - 1 leq T leq 10 - 1 leq length(P) leq 100 -----Sample Input:----- 3 Coding@123 helloworld! StrongPass1@ Weak -----Sample Output:----- Strong Weak Strong Weak >>> check_password_strength(3, [\\"Coding@123\\", \\"helloworld!\\", \\"StrongPass1@\\", \\"Weak\\"]) ['Strong', 'Weak', 'Strong', 'Weak']","solution":"def check_password_strength(t, passwords): special_characters = set(\\"!@#%^&*()\\") results = [] for password in passwords: if len(password) < 8: results.append(\\"Weak\\") continue has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in special_characters for c in password) if has_upper and has_lower and has_digit and has_special: results.append(\\"Strong\\") else: results.append(\\"Weak\\") return results"},{"question":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): # Initialize result result = 0 # Step 1: Sort all the edges in non-decreasing order of their cost edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(n): parent.append(node) rank.append(0) e = 0 # Initialize number of edges in MST for edge in edges: if e == n - 1: break u, v, w = edge x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result += w union(parent, rank, x, y) # Check if MST includes all vertices if e != n - 1: return -1 return result def minimum_transportation_cost(T, test_cases): Determines the total minimum cost to connect all cities in the kingdom using the Minimum Spanning Tree (MST) algorithm. >>> minimum_transportation_cost(2, [ (4, 5, [(1, 2, 10), (1, 3, 15), (2, 3, 5), (2, 4, 20), (3, 4, 25)]), (3, 3, [(1, 2, 6), (1, 3, 8), (2, 3, 10)]) ]) [35, 14] >>> minimum_transportation_cost(1, [(4, 2, [(1, 2, 10), (2, 3, 15)])]) [-1] def test_single_case_all_connected(): T = 1 test_cases = [ (4, 5, [ (0, 1, 10), (0, 2, 15), (1, 2, 5), (1, 3, 20), (2, 3, 25) ]) ] assert minimum_transportation_cost(T, test_cases) == [35] def test_multiple_cases(): T = 2 test_cases = [ (4, 5, [ (0, 1, 10), (0, 2, 15), (1, 2, 5), (1, 3, 20), (2, 3, 25) ]), (3, 3, [ (0, 1, 6), (0, 2, 8), (1, 2, 10) ]) ] assert minimum_transportation_cost(T, test_cases) == [35, 14] def test_not_all_connected(): T = 1 test_cases = [ (4, 2, [ (0, 1, 10), (1, 2, 15) ]) ] assert minimum_transportation_cost(T, test_cases) == [-1] def test_minimal_case(): T = 1 test_cases = [ (1, 0, []) ] assert minimum_transportation_cost(T, test_cases) == [0] def test_two_cities_one_road(): T = 1 test_cases = [ (2, 1, [ (0, 1, 10) ]) ] assert minimum_transportation_cost(T, test_cases) == [10]","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): # Initialize result result = 0 # Step 1: Sort all the edges in non-decreasing order of their cost edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(n): parent.append(node) rank.append(0) e = 0 # Initialize number of edges in MST for edge in edges: if e == n - 1: break u, v, w = edge x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result += w union(parent, rank, x, y) # Check if MST includes all vertices if e != n - 1: return -1 return result def minimum_transportation_cost(T, test_cases): results = [] for test_case in test_cases: n, m, edges = test_case result = kruskal_mst(n, edges) results.append(result) return results"},{"question":"def getPrimes(n: int) -> List[int]: Write a function that takes an integer n and returns a list containing the prime numbers less than n. The numbers in the list should be in ascending order. Examples: >>> getPrimes(10) [2, 3, 5, 7] >>> getPrimes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> getPrimes(2) []","solution":"def getPrimes(n): Returns a list of prime numbers less than n. :param n: Integer :return: List of prime numbers less than n if n <= 2: return [] primes = [] is_prime = [True] * n is_prime[0] = is_prime[1] = False for i in range(2, n): if is_prime[i]: primes.append(i) for j in range(i*i, n, i): is_prime[j] = False return primes"},{"question":"from typing import List, Tuple def is_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the graph formed by 'n' nodes and 'm' edges is a tree. Arguments: n : int : Number of planets (nodes) m : int : Number of wormholes (edges) edges : List[Tuple[int, int]] : List of edges where each edge is represented by a tuple (u, v) Returns: str : \\"YES\\" if the graph forms a tree, otherwise \\"NO\\" >>> is_tree(3, 2, [(1, 2), (1, 3)]) \\"YES\\" >>> is_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"NO\\" pass def galaxies_test(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: results = [] for case in test_cases: n, m, edges = case results.append(is_tree(n, m, edges)) return results def test_is_tree(): test_cases = [ (3, 2, [(1, 2), (1, 3)]), # Test case 1 (4, 3, [(1, 2), (2, 3), (3, 4)]), # Test case 2 (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), # Test case 3 (2, 1, [(1, 2)]), # Edge case with minimum nodes and edges (2, 2, [(1, 2), (2, 1)]) # Not a tree since it forms cycle (1-2-1) ] expected_outputs = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] results = galaxies_test(len(test_cases), test_cases) assert results == expected_outputs def test_is_tree_with_isolated_nodes(): # A graph with isolated nodes is not a tree test_cases = [ (4, 2, [(1, 2), (3, 4)]), # Two separate components (5, 3, [(1, 2), (1, 3), (4, 5)]) # Two separate components ] expected_outputs = [\\"NO\\", \\"NO\\"] results = galaxies_test(len(test_cases), test_cases) assert results == expected_outputs def test_is_tree_with_complete_graph(): # A graph that forms a complete graph is not a tree test_cases = [ (4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]), # Complete graph K4 (5, 10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) # Complete graph K5 ] expected_outputs = [\\"NO\\", \\"NO\\"] results = galaxies_test(len(test_cases), test_cases) assert results == expected_outputs def test_is_tree_special_case_linear(): # A linear graph is always a tree test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), # Linear graph (3, 2, [(1, 2), (2, 3)]) # Linear graph with three nodes ] expected_outputs = [\\"YES\\", \\"YES\\"] results = galaxies_test(len(test_cases), test_cases) assert results == expected_outputs","solution":"def is_tree(n, m, edges): Determines if the graph formed by 'n' nodes and 'm' edges is a tree. if m != n - 1: # For a graph to be a tree, it must have exactly n-1 edges return \\"NO\\" from collections import defaultdict, deque # Build adjacency list adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Check if the graph is connected using BFS/DFS visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in adj[node]: if neighbor not in visited: queue.append(neighbor) bfs(1) # Start BFS from node 1 (1-based index) # If all nodes are reachable and no cycle is present (handled by edge count above) return \\"YES\\" if len(visited) == n else \\"NO\\" def galaxies_test(t, test_cases): results = [] for case in test_cases: n, m, edges = case results.append(is_tree(n, m, edges)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: input string consisting of lowercase letters :type s: str :return: length of the longest substring without repeating characters :rtype: int >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 pass # Complete the implementation # Test Cases def test_length_of_longest_substring(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 assert length_of_longest_substring(\\"bbbbb\\") == 1 assert length_of_longest_substring(\\"pwwkew\\") == 3 assert length_of_longest_substring(\\"\\") == 0 assert length_of_longest_substring(\\"abcdef\\") == 6 assert length_of_longest_substring(\\"aab\\") == 2 assert length_of_longest_substring(\\"dvdf\\") == 3 assert length_of_longest_substring(\\"anviaj\\") == 5 def test_length_of_longest_substring_edge_cases(): assert length_of_longest_substring(\\" \\") == 1 assert length_of_longest_substring(\\"a\\") == 1 assert length_of_longest_substring(\\"aa\\") == 1 assert length_of_longest_substring(\\"ab\\") == 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: input string consisting of lowercase letters :type s: str :return: length of the longest substring without repeating characters :rtype: int if not s: return 0 char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def sum_evens(arr: List[int]) -> int: Write a function named \`sum_evens\` that takes an array of integers and returns the sum of all the even numbers in the array. If there are no even numbers, the function should return 0. >>> sum_evens([2, 4, 6, 8]) 20 >>> sum_evens([1, 3, 5, 7, 9]) 0 >>> sum_evens([1, 2, 3, 4, 5, 6]) 12 >>> sum_evens([]) 0 >>> sum_evens([4]) 4 >>> sum_evens([5]) 0 >>> sum_evens([-2, -4, -6, -8]) -20 >>> sum_evens([-2, -4, 3, 7, 8]) 2","solution":"def sum_evens(arr): Returns the sum of all even numbers in the array. If there are no even numbers, returns 0. Parameters: arr (list of int): The input array of integers. Returns: int: Sum of all even numbers in the array. return sum(num for num in arr if num % 2 == 0)"},{"question":"def edit_distance(str1: str, str2: str) -> int: Calculate and return the edit distance between two strings. The edit distance is the minimum number of operations required to transform one string into another, where an operation is defined as inserting a character, deleting a character, or replacing a character. >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def edit_distance(str1, str2): Returns the edit distance between str1 and str2. m, n = len(str1), len(str2) # Create a table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp array bottom-up for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to # insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to # remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore the last char # and recur for the remaining substring elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # If last character is different, consider all # possibilities (insert, remove, replace) and find # the minimum cost else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def sum_of_divisibles(n: int) -> int: Returns the sum of all the numbers up to and including n which are divisible by either 3 or 5. >>> sum_of_divisibles(10) 33 >>> sum_of_divisibles(15) 60","solution":"def sum_of_divisibles(n): Returns the sum of all the numbers up to and including n which are divisible by either 3 or 5. return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0) # Examples: # sum_of_divisibles(10) returns 33 (3 + 5 + 6 + 9 + 10) # sum_of_divisibles(15) returns 60 (3 + 5 + 6 + 9 + 10 + 12 + 15)"},{"question":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word in the string s. A word is defined as a sequence of characters that are not spaces. Examples: >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> length_of_shortest_word(\\" Hello there world \\") 5 >>> length_of_shortest_word(\\"Single\\") 6","solution":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word in the string s. A word is defined as a sequence of characters that are not spaces. words = s.split() if not words: return 0 shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def rotate(matrix): Rotates the input n x n 2D matrix 90 degrees clockwise in place. >>> matrix = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> rotate(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ >>> [5, 1, 9,11], >>> [2, 4, 8,10], >>> [13, 3, 6, 7], >>> [15,14,12,16] >>> ] >>> rotate(matrix) >>> matrix [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_4x4_matrix(): matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ] rotate(matrix) assert matrix == [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate(matrix) assert matrix == [ [1] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_empty_matrix(): matrix = [] rotate(matrix) assert matrix == [] # Empty matrix remains empty","solution":"def rotate(matrix): Rotates the input n x n 2D matrix 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def num_islands(grid: List[List[int]]) -> int: Determine the number of distinct islands in the matrix. An island is formed by a group of connected 1's, connected horizontally or vertically. Each island is surrounded by water represented by 0's. Parameters: grid (List[List[int]]): The binary matrix representing the grid. Returns: int: The number of distinct islands. >>> num_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ]) 2 >>> num_islands([ ... [1, 0, 0, 1], ... [1, 0, 0, 1], ... [0, 0, 1, 1], ... [1, 1, 0, 0] ... ]) 3","solution":"def num_islands(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) if not grid: return 0 island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) island_count += 1 return island_count"},{"question":"def ticket_sales(events): Calculates the total number of tickets sold for each ticket type. Args: events (list of lists): A list of ticket sales events, where each event is a list [ticket_type, quantity]. Returns: dict: A dictionary with ticket types as keys and total quantities as values. >>> ticket_sales([['adult', 5], ['child', 3], ['senior', 2], ['child', 7], ['student', 4]]) {'adult': 5, 'child': 10, 'senior': 2, 'student': 4} >>> ticket_sales([['vip', 3], ['adult', 4], ['unknown', 2]]) {'vip': 3, 'adult': 4, 'other': 2}","solution":"def ticket_sales(events): Calculates the total number of tickets sold for each ticket type. Args: events (list of lists): A list of ticket sales events, where each event is a list [ticket_type, quantity]. Returns: dict: A dictionary with ticket types as keys and total quantities as values. ticket_summary = {} for event in events: ticket_type, quantity = event if ticket_type not in ['adult', 'child', 'senior', 'student', 'vip']: ticket_type = 'other' if ticket_type in ticket_summary: ticket_summary[ticket_type] += quantity else: ticket_summary[ticket_type] = quantity return ticket_summary"},{"question":"class CarRental: Manages a fleet of rental cars, tracks availability, and handles bookings and returns. def __init__(self): self.available_cars = {} self.rented_cars = {} def initialize_fleet(self, n: int, car_list: List[Tuple[int, str]]): Initializes the fleet with n cars. Parameters: n (int): Number of cars. car_list (List[Tuple[int, str]]): List of tuples with car ID and car type. >>> fleet = CarRental() >>> fleet.initialize_fleet(2, [(1001, \\"Sedan\\"), (1002, \\"Truck\\")]) pass def book_car(self, car_type: str) -> Union[int, str]: Books a car of the requested type. Parameters: car_type (str): The type of car to book. Returns: Union[int, str]: Car ID if booking is successful, otherwise \\"No car available\\". >>> fleet = CarRental() >>> fleet.initialize_fleet(1, [(1001, \\"Sedan\\")]) >>> fleet.book_car(\\"Sedan\\") 1001 >>> fleet.book_car(\\"SUV\\") 'No car available' pass def return_car(self, car_id: int) -> str: Returns a car by its ID. Parameters: car_id (int): The ID of the car to return. Returns: str: \\"Car returned\\" if successful, otherwise \\"Car not found\\". >>> fleet = CarRental() >>> fleet.initialize_fleet(1, [(1001, \\"Sedan\\")]) >>> fleet.book_car(\\"Sedan\\") 1001 >>> fleet.return_car(1001) 'Car returned' >>> fleet.return_car(2000) 'Car not found' pass import pytest def test_car_rental(): car_rental = CarRental() # Initialize fleet car_rental.initialize_fleet(5, [ (1001, \\"Sedan\\"), (1002, \\"SUV\\"), (1003, \\"Truck\\"), (1004, \\"Sedan\\"), (1005, \\"SUV\\") ]) # Test booking Sedan assert car_rental.book_car(\\"Sedan\\") == 1001 assert car_rental.book_car(\\"Sedan\\") == 1004 assert car_rental.book_car(\\"Sedan\\") == \\"No car available\\" # Test booking Truck assert car_rental.book_car(\\"Truck\\") == 1003 assert car_rental.book_car(\\"Truck\\") == \\"No car available\\" # Test booking SUV assert car_rental.book_car(\\"SUV\\") == 1002 assert car_rental.book_car(\\"SUV\\") == 1005 assert car_rental.book_car(\\"SUV\\") == \\"No car available\\" # Returning cars assert car_rental.return_car(1003) == \\"Car returned\\" assert car_rental.book_car(\\"Truck\\") == 1003 assert car_rental.return_car(2000) == \\"Car not found\\" # Non-existent car if __name__ == \\"__main__\\": pytest.main()","solution":"class CarRental: def __init__(self): self.available_cars = {} self.rented_cars = {} def initialize_fleet(self, n, car_list): for i in range(n): car_id, car_type = car_list[i] if car_type not in self.available_cars: self.available_cars[car_type] = [] self.available_cars[car_type].append(car_id) for car_type in self.available_cars: self.available_cars[car_type].sort() def book_car(self, car_type): if car_type in self.available_cars and self.available_cars[car_type]: car_id = self.available_cars[car_type].pop(0) self.rented_cars[car_id] = car_type return car_id else: return \\"No car available\\" def return_car(self, car_id): if car_id in self.rented_cars: car_type = self.rented_cars.pop(car_id) self.available_cars[car_type].append(car_id) self.available_cars[car_type].sort() return \\"Car returned\\" else: return \\"Car not found\\""},{"question":"def sieve_of_eratosthenes(n): is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0] = is_prime[1] = False return is_prime def is_twin_prime_in_range(L, R, x): Determine if a number x is part of any twin prime pair within the range [L, R]. >>> is_twin_prime_in_range(1, 20, 17) 'Yes' >>> is_twin_prime_in_range(10, 30, 23) 'No' pass def twin_prime_check(input_data): Check multiple test cases for whether a number is part of any twin prime pair. >>> twin_prime_check(\\"2n1 20 17n10 30 23\\") ['Yes', 'No'] >>> twin_prime_check(\\"3n1 10 5n3 30 25n3 30 29\\") ['Yes', 'No', 'Yes'] pass","solution":"def sieve_of_eratosthenes(n): is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0] = is_prime[1] = False return is_prime def is_twin_prime_in_range(L, R, x): primes = sieve_of_eratosthenes(max(R, x + 2)) if not primes[x]: return \\"No\\" twin_primes_within_range = [(p, p+2) for p in range(L, min(R, max(R, x+2)-1)) if primes[p] and primes[p+2]] for p1, p2 in twin_primes_within_range: if x == p1 or x == p2: return \\"Yes\\" return \\"No\\" def twin_prime_check(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) results = [] for i in range(1, T + 1): L, R, x = map(int, lines[i].split()) results.append(is_twin_prime_in_range(L, R, x)) return results"},{"question":"def rearrangeArray(nums: List[int]) -> List[int]: Rearranges the array such that all even numbers appear before all odd numbers, while maintaining the relative order of both even and odd numbers as they appear in the original array. Parameters: nums (List[int]): The input array of non-negative integers. Returns: List[int]: The rearranged array with all even numbers first, followed by odd numbers. Examples: >>> rearrangeArray([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrangeArray([6, 3, 4, 1, 5, 2]) [6, 4, 2, 3, 1, 5] >>> rearrangeArray([1, 1, 1, 1]) [1, 1, 1, 1] >>> rearrangeArray([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"def rearrangeArray(nums): Rearranges the array such that all even numbers appear before all odd numbers, while maintaining the relative order of both even and odd numbers as they appear in the original array. Parameters: nums (List[int]): The input array of non-negative integers. Returns: List[int]: The rearranged array with all even numbers first, followed by odd numbers. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] return evens + odds"},{"question":"from typing import List, Tuple, Dict def manage_servers(actions: List[Tuple[str, int, int]], capacities: Dict[int, int]) -> Dict[int, List[int]]: Simulates the activities of players joining and leaving servers and checks the status of the servers. The input is a list of tuples representing the actions performed on the servers. Each tuple contains three elements: (action, server_id, player_id) where 'action' can either be 'join' or 'leave', 'server_id' is an integer representing the server to which the action applies, and 'player_id' is a unique identifier for the player performing the action. Args: actions (List[Tuple[str, int, int]]): List of tuples representing actions with action type, server ID, and player ID. capacities (Dict[int, int]): A dictionary representing the capacity of each server. Returns: Dict[int, List[int]]: Dictionary where keys are server IDs and values are lists of players currently in each server. >>> actions = [('join', 1, 100), ('join', 1, 101), ('leave', 1, 100), ('join', 2, 202)] >>> capacities = {1: 2, 2: 3} >>> manage_servers(actions, capacities) {1: [101], 2: [202]} >>> actions = [('join', 1, 100), ('join', 1, 101), ('join', 1, 102)] >>> capacities = {1: 2} >>> manage_servers(actions, capacities) {1: [100, 101]}","solution":"from typing import List, Tuple, Dict def manage_servers(actions: List[Tuple[str, int, int]], capacities: Dict[int, int]) -> Dict[int, List[int]]: servers = {} for action, server_id, player_id in actions: if server_id not in servers: servers[server_id] = [] if action == 'join': if len(servers[server_id]) < capacities.get(server_id, 0) and player_id not in servers[server_id]: servers[server_id].append(player_id) servers[server_id].sort() elif action == 'leave': if player_id in servers[server_id]: servers[server_id].remove(player_id) return servers"},{"question":"from typing import List def max_product_subarray(nums: List[int]) -> int: Implement a function that takes a list of integers and returns the largest product of a contiguous subarray. Examples: >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0 >>> max_product_subarray([-2, 3, -4]) 24","solution":"from typing import List def max_product_subarray(nums: List[int]) -> int: if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for i in range(1, len(nums)): if nums[i] < 0: max_product, min_product = min_product, max_product max_product = max(nums[i], max_product * nums[i]) min_product = min(nums[i], min_product * nums[i]) result = max(result, max_product) return result"},{"question":"def warmer_days(temperatures): Given a list of daily temperatures, returns a list indicating how many days one would have to wait to encounter a warmer temperature. If no warmer temperature is available in the future, the day's count will be 0. >>> warmer_days([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> warmer_days([80, 75, 73, 70]) [0, 0, 0, 0] >>> warmer_days([73, 73, 73, 73]) [0, 0, 0, 0] >>> warmer_days([70, 72, 73, 75]) [1, 1, 1, 0] >>> warmer_days([70]) [0] >>> warmer_days([]) []","solution":"def warmer_days(temperatures): Given a list of daily temperatures, returns a list indicating how many days one would have to wait to encounter a warmer temperature. If no warmer temperature is available in the future, the day's count will be 0. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"def optimal_game_score(n: int, sequence: List[int]) -> int: Determine the final score of the game if both players play optimally. Args: n (int): The number of integers in the sequence. sequence (list): A list of integers either 1 or -1. Returns: int: The final score of the game. pass def compute_scores(test_cases: List[Tuple[int, List[int]]]) -> List[int]: results = [] for n, sequence in test_cases: results.append(optimal_game_score(n, sequence)) return results # Unit tests def test_compute_scores(): assert compute_scores([(5, [1, -1, 1, -1, 1])]) == [1] assert compute_scores([(5, [1, -1, 1, -1, 1]), (4, [1, -1, -1, 1]), (3, [1, 1, -1])]) == [1, 0, 1] assert compute_scores([(4, [1, 1, 1, 1])]) == [4] assert compute_scores([(4, [-1, -1, -1, -1])]) == [-4] assert compute_scores([(4, [1, -1, 1, -1])]) == [0]","solution":"def optimal_game_score(n, sequence): Determine the final score of the game if both players play optimally. Args: n (int): The number of integers in the sequence. sequence (list): A list of integers either 1 or -1. Returns: int: The final score of the game. # Number of 1s in the sequence positives = sequence.count(1) # Number of -1s in the sequence negatives = sequence.count(-1) # If the number of elements is odd, Alice plays one more turn than Bob if n % 2 != 0: return max(positives - negatives, (positives - 1) - (negatives + 1)) else: return positives - negatives def compute_scores(test_cases): results = [] for n, sequence in test_cases: results.append(optimal_game_score(n, sequence)) return results"},{"question":"def maxWaterContainer(heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped between two lines. >>> maxWaterContainer([1,8,6,2,5,4,8,3,7]) 49 >>> maxWaterContainer([1, 1]) 1 # Example Unit Tests def test_example_1(): assert maxWaterContainer([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 def test_example_2(): assert maxWaterContainer([1, 1]) == 1 def test_increasing_heights(): assert maxWaterContainer([1, 2, 3, 4, 5]) == 6 def test_decreasing_heights(): assert maxWaterContainer([5, 4, 3, 2, 1]) == 6 def test_same_heights_large(): assert maxWaterContainer([4, 4, 4, 4, 4, 4, 4, 4]) == 28 def test_large_heights(): assert maxWaterContainer([10000, 10000, 1, 10000, 10000]) == 40000 def test_two_elements(): assert maxWaterContainer([1, 2]) == 1 def test_variety_of_heights(): assert maxWaterContainer([2, 3, 4, 5, 18, 17, 6]) == 17 def test_complex_case(): assert maxWaterContainer([1, 3, 2, 5, 25, 24, 5]) == 24","solution":"from typing import List def maxWaterContainer(heights: List[int]) -> int: left, right = 0, len(heights) - 1 max_water = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) # Move the pointer of the shorter line inward if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to an integer. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. | Symbol | Value | |--------|-------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | Example 1: Input: \\"III\\" Output: 3 Example 2: Input: \\"IV\\" Output: 4 Example 3: Input: \\"IX\\" Output: 9 Example 4: Input: \\"LVIII\\" Output: 58 Example 5: Input: \\"MCMXCIV\\" Output: 1994","solution":"def roman_to_int(s): Convert a Roman numeral to an integer. :param s: A string representing a Roman numeral :return: An integer representation of the Roman numeral roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"def vending_machine(items: list, money: float, selection: str) -> tuple: Simulates a vending machine transaction. :param items: List of tuples representing items (name, price, quantity) :param money: The amount of money inserted by the user :param selection: The name of the item the user wants to purchase :return: Tuple containing result message, remaining money, and updated items list >>> items = [(\\"Soda\\", 1.25, 10), (\\"Chips\\", 0.99, 5), (\\"Candy\\", 0.75, 12)] >>> money = 5.00 >>> vending_machine(items, money, \\"Soda\\") ('Dispensed Soda', 3.75, [('Soda', 1.25, 9), ('Chips', 0.99, 5), ('Candy', 0.75, 12)]) >>> money = 0.50 >>> vending_machine(items, money, \\"Candy\\") ('Not enough money', 0.50, [('Soda', 1.25, 10), ('Chips', 0.99, 5), ('Candy', 0.75, 12)])","solution":"def vending_machine(items: list, money: float, selection: str) -> tuple: Simulates a vending machine transaction. :param items: List of tuples representing items (name, price, quantity) :param money: The amount of money inserted by the user :param selection: The name of the item the user wants to purchase :return: Tuple containing result message, remaining money, and updated items list for index, (name, price, quantity) in enumerate(items): if name == selection: if quantity == 0: return (\\"Out of stock\\", money, items) elif money < price: return (\\"Not enough money\\", money, items) else: items[index] = (name, price, quantity - 1) return (f\\"Dispensed {name}\\", money - price, items) return (\\"Item not found\\", money, items)"},{"question":"def track_movements(log): Determines the final location of each animal from a movement log. Parameters: log (list of str): List of strings representing animal movements. Returns: dict: Dictionary with the final locations of each animal. Example: >>> movements = [ \\"Lion -> Savannah\\", \\"Tiger -> Jungle\\", \\"Bear -> Mountain\\", \\"Lion -> Den\\", \\"Elephant -> Field\\", \\"Tiger -> Rest Area\\", \\"Elephant -> Out of Zoo\\", \\"Monkey -> Tree\\", \\"Bear -> River\\" ] >>> track_movements(movements) { \\"Lion\\": \\"Den\\", \\"Tiger\\": \\"Rest Area\\", \\"Bear\\": \\"River\\", \\"Monkey\\": \\"Tree\\" } # Your code here","solution":"def track_movements(log): Determines the final location of each animal from a movement log. Parameters: log (list of str): List of strings representing animal movements. Returns: dict: Dictionary with the final locations of each animal. movements = {} for entry in log: animal, destination = entry.split(\\" -> \\") if destination != \\"Out of Zoo\\": movements[animal] = destination else: movements.pop(animal, None) # Remove animal if its destination is \\"Out of Zoo\\" return movements"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the sum of the contiguous subarray with the largest sum. Example: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def most_frequent_character(s: str): Returns the most frequently occurring character in the string s. If there is a tie, returns the character that appears first in the string. >>> most_frequent_character(\\"aabbbcc\\") 'b' >>> most_frequent_character(\\"abccba\\") 'a' >>> most_frequent_character(\\"abcabc\\") 'a' >>> most_frequent_character(\\"aabbcc\\") 'a' >>> most_frequent_character(\\"a\\") 'a' >>> most_frequent_character(\\"\\") None","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string s. If there is a tie, returns the character that appears first in the string. from collections import Counter if not s: return None counter = Counter(s) max_count = max(counter.values()) for char in s: if counter[char] == max_count: return char"},{"question":"def get_common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of common elements between two input lists. >>> get_common_elements([1, 3, 4, 6], [2, 3, 6, 8]) [3, 6] >>> get_common_elements([7, 8, 10], [5, 8, 9, 10, 11]) [8, 10]","solution":"def get_common_elements(list1, list2): Returns a sorted list of common elements between two input lists. # Convert lists to sets to handle duplicates and perform set intersection set1 = set(list1) set2 = set(list2) # Find the intersection of both sets common_elements = set1.intersection(set2) # Return the sorted list of common elements return sorted(common_elements)"},{"question":"def max_product_of_two(arr): Given an array of integers, find the maximum possible product of two different elements in the array. >>> max_product_of_two([1, 2, 3, 4, 5]) 20 >>> max_product_of_two([-10, -20, 5, 7, 3]) 200 pass import pytest def test_positive_numbers(): assert max_product_of_two([1, 2, 3, 4, 5]) == 20 def test_negative_and_positive_numbers(): assert max_product_of_two([-10, -20, 5, 7, 3]) == 200 def test_small_array(): assert max_product_of_two([1, 2]) == 2 def test_large_negative_numbers(): assert max_product_of_two([-1000000000, -999999999]) == 999999999000000000 def test_mixed_sign_large_array(): large_array = [-10, 20] * 50000 # array with 100000 elements assert max_product_of_two(large_array) == 400 def test_no_elements_raises_exception(): with pytest.raises(ValueError): max_product_of_two([]) def test_single_element_raises_exception(): with pytest.raises(ValueError): max_product_of_two([1])","solution":"def max_product_of_two(arr): Returns the maximum possible product of two different elements in the array. if len(arr) < 2: raise ValueError(\\"Array must contain at least 2 elements\\") # Initialize the largest and second largest values to the smallest possible largest = float('-inf') second_largest = float('-inf') # Initialize the smallest and second smallest values to the largest possible smallest = float('inf') second_smallest = float('inf') # Traverse the array and find the largest, second largest, and smallest, second smallest for num in arr: if num > largest: second_largest = largest largest = num elif num > second_largest: second_largest = num if num < smallest: second_smallest = smallest smallest = num elif num < second_smallest: second_smallest = num # The maximum product could be either from the two largest or the two smallest (if they are both negative) return max(largest * second_largest, smallest * second_smallest)"},{"question":"import re def isValidHexColor(s: str) -> bool: Returns True if the input string is a valid hexadecimal color code, else False. A valid hexadecimal color code must start with a '#' symbol followed by exactly six hexadecimal characters (0-9, a-f, or A-F). >>> isValidHexColor(\\"#FFFFFF\\") True >>> isValidHexColor(\\"#abc123\\") True >>> isValidHexColor(\\"123456\\") False >>> isValidHexColor(\\"#1G3456\\") False >>> isValidHexColor(\\"#FFFFF\\") False pass","solution":"import re def isValidHexColor(s): Returns True if the input string is a valid hexadecimal color code, else False. A valid hexadecimal color code must start with a '#' symbol followed by exactly six hexadecimal characters (0-9, a-f, or A-F). return bool(re.fullmatch(r\\"#([0-9a-fA-F]{6})\\", s))"},{"question":"def remove_consecutive_duplicate_words(sentence: str) -> str: Remove consecutive duplicate words from a given sentence. Args: sentence (str): The input sentence composed of words separated by spaces. Returns: str: The sentence after removing consecutive duplicate words. Examples: >>> remove_consecutive_duplicate_words(\\"this is is a test test\\") \\"this is a test\\" >>> remove_consecutive_duplicate_words(\\"hello hello world\\") \\"hello world\\" >>> remove_consecutive_duplicate_words(\\"this this this is is a a test test test\\") \\"this is a test\\" >>> remove_consecutive_duplicate_words(\\"no duplicates here\\") \\"no duplicates here\\" >>> remove_consecutive_duplicate_words(\\"singleword\\") \\"singleword\\" pass","solution":"def remove_consecutive_duplicate_words(sentence): Returns a string with all consecutive duplicate words removed. if not sentence: return sentence words = sentence.split() result = [words[0]] for i in range(1, len(words)): if words[i] != words[i - 1]: result.append(words[i]) return ' '.join(result)"},{"question":"weather_data = [ [ # temperature [25.0, 24.5], # location 0 [26.1, 25.2] # location 1 ], [ # humidity [60.5, 62.1], # location 0 [65.2, 63.3] # location 1 ] ] def average_by_parameter(location_index: int, parameter_index: int) -> float: Computes the average value of a specific weather parameter for a given location over all the days. >>> average_by_parameter(0, 0) 24.75 >>> average_by_parameter(1, 1) 64.25 pass def max_by_day(location_index: int) -> list: Retrieves the maximum value for each parameter of a specific location for every day. >>> max_by_day(0) [25.0, 62.1] >>> max_by_day(1) [26.1, 65.2] pass def min_by_parameter(parameter_index: int) -> float: Finds the minimum value of a specific weather parameter across all locations and all days. >>> min_by_parameter(0) 24.5 >>> min_by_parameter(1) 60.5 pass","solution":"# Define weather_data as a global variable for testing purposes weather_data = [ [ # temperature [25.0, 24.5], # location 0 [26.1, 25.2] # location 1 ], [ # humidity [60.5, 62.1], # location 0 [65.2, 63.3] # location 1 ] ] def average_by_parameter(location_index: int, parameter_index: int) -> float: Computes the average value of a specific weather parameter for a given location over all the days. sum_values = sum(weather_data[parameter_index][location_index]) count_days = len(weather_data[parameter_index][location_index]) return sum_values / count_days def max_by_day(location_index: int) -> list: Retrieves the maximum value for each parameter of a specific location for every day. max_values = [] for parameter in weather_data: max_values.append(max(parameter[location_index])) return max_values def min_by_parameter(parameter_index: int) -> float: Finds the minimum value of a specific weather parameter across all locations and all days. min_value = float('inf') for location in weather_data[parameter_index]: min_value = min(min_value, min(location)) return min_value"},{"question":"def findSecondLargest(nums: List[int]) -> Optional[int]: Write a function \`findSecondLargest\` that takes a list of integers and returns the second largest number in the list. If the list has fewer than 2 unique numbers, the function should return \`None\`. >>> findSecondLargest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 6 >>> findSecondLargest([1, 1, 1, 1]) == None import pytest from solution import findSecondLargest def test_findSecondLargest_varied_numbers(): assert findSecondLargest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 6 def test_findSecondLargest_all_equal(): assert findSecondLargest([1, 1, 1, 1]) == None def test_findSecondLargest_less_than_two_unique(): assert findSecondLargest([1]) == None assert findSecondLargest([2, 2]) == None def test_findSecondLargest_negative(): assert findSecondLargest([-1, -2, -3, -4, -5]) == -2 def test_findSecondLargest_mixed_numbers(): assert findSecondLargest([10, 5, 9, -10, 100, 100, 5]) == 10 def test_findSecondLargest_with_zero(): assert findSecondLargest([0, 1, 2, 3, 4, 5]) == 4","solution":"def findSecondLargest(nums): Returns the second largest number in the list of integers. If the list has fewer than 2 unique numbers, returns None. if len(nums) < 2: return None # Use a set to get unique values and then sort them unique_nums = sorted(set(nums)) if len(unique_nums) < 2: return None return unique_nums[-2]"},{"question":"def evaluate(expression: str) -> int: Evaluates a simple arithmetic expression. >>> evaluate(\\"3+5*2\\") 13 >>> evaluate(\\"10+2*6\\") 22 >>> evaluate(\\"100*2+12\\") 212 >>> evaluate(\\"100*(2+12)\\") 1400 >>> evaluate(\\"100*(2+12)/14\\") 100","solution":"def evaluate(expression): Evaluates a simple arithmetic expression. import re import operator def parse_expression(expr): tokens = re.findall(r'd+|[-+*/()]', expr) return tokens def shunting_yard(tokens): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] operators = [] for token in tokens: if token.isdigit(): output.append(token) elif token in precedence: while (operators and operators[-1] in precedence and precedence[token] <= precedence[operators[-1]]): output.append(operators.pop()) operators.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() # Pop '(' while operators: output.append(operators.pop()) return output def evaluate_rpn(tokens): stack = [] operators = { '+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.floordiv, } for token in tokens: if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() stack.append(operators[token](a, b)) return stack[0] tokens = parse_expression(expression) rpn = shunting_yard(tokens) return evaluate_rpn(rpn)"},{"question":"def process_delivery_logs(logs): Processes a list of delivery logs and returns a dictionary indicating which packages each driver delivered in the order of delivery. :param logs: List of strings where each string is formatted as \\"driverID:trackingCode\\" :return: Dictionary where keys are driver IDs and values are lists of tracking codes delivery_dict = {} for log in logs: driver_id, tracking_code = log.split(':') if driver_id not in delivery_dict: delivery_dict[driver_id] = [] delivery_dict[driver_id].append(tracking_code) return delivery_dict # Test cases def test_single_log_entry(): assert process_delivery_logs([\\"123:abc\\"]) == {\\"123\\": [\\"abc\\"]} def test_multiple_logs_single_driver(): assert process_delivery_logs([\\"123:abc\\", \\"123:def\\", \\"123:ghi\\"]) == {\\"123\\": [\\"abc\\", \\"def\\", \\"ghi\\"]} def test_multiple_logs_multiple_drivers(): assert process_delivery_logs([\\"123:abc\\", \\"124:def\\", \\"123:ghi\\", \\"124:jkl\\"]) == {\\"123\\": [\\"abc\\", \\"ghi\\"], \\"124\\": [\\"def\\", \\"jkl\\"]} def test_no_logs(): assert process_delivery_logs([]) == {} def test_logs_with_multiple_drivers_and_out_of_order(): assert process_delivery_logs([\\"123:abc\\", \\"124:def\\", \\"124:ghi\\", \\"123:jkl\\", \\"124:mno\\"]) == {\\"123\\": [\\"abc\\", \\"jkl\\"], \\"124\\": [\\"def\\", \\"ghi\\", \\"mno\\"]} def test_logs_with_one_driver_multiple_packages(): assert process_delivery_logs([\\"123:a\\", \\"123:b\\", \\"123:c\\", \\"123:d\\"]) == {\\"123\\": [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]} def test_logs_with_multiple_drivers_multiple_packages(): assert process_delivery_logs([\\"101:z\\", \\"102:y\\", \\"103:x\\", \\"104:w\\"]) == {\\"101\\": [\\"z\\"], \\"102\\": [\\"y\\"], \\"103\\": [\\"x\\"], \\"104\\": [\\"w\\"]}","solution":"def process_delivery_logs(logs): Processes a list of delivery logs and returns a dictionary indicating which packages each driver delivered in the order of delivery. :param logs: List of strings where each string is formatted as \\"driverID:trackingCode\\" :return: Dictionary where keys are driver IDs and values are lists of tracking codes delivery_dict = {} for log in logs: driver_id, tracking_code = log.split(':') if driver_id not in delivery_dict: delivery_dict[driver_id] = [] delivery_dict[driver_id].append(tracking_code) return delivery_dict"},{"question":"[Completion Task in Python] def fibonacci(n: int) -> int: Returns the nth Fibonacci number using recursion. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55","solution":"def fibonacci(n): Returns the nth Fibonacci number using recursion. if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2)"},{"question":"def max_non_consecutive_sum(nums: List[int]) -> int: Returns the maximum possible sum of elements in a subarray that does not contain any two consecutive elements from the original array. Args: nums (list): List of positive integers. Returns: int: The maximum possible sum. Example: >>> max_non_consecutive_sum([3, 2, 5, 10, 7]) 15 >>> max_non_consecutive_sum([1, 2, 3, 4, 5]) 9 >>> max_non_consecutive_sum([5, 1, 1, 5]) 10 pass","solution":"def max_non_consecutive_sum(nums): Returns the maximum possible sum of elements in a subarray that does not contain any two consecutive elements from the original array. Args: nums (list): List of positive integers. Returns: int: The maximum possible sum. if not nums: return 0 n = len(nums) if n == 1: return nums[0] inclusive = nums[0] exclusive = 0 for i in range(1, n): new_exclusive = max(inclusive, exclusive) inclusive = exclusive + nums[i] exclusive = new_exclusive return max(inclusive, exclusive)"},{"question":"def run_length_encoding(s: str) -> str: Encodes the input string using Run-Length Encoding (RLE). Args: s (str): Input string consisting of lowercase letters. Returns: str: Run-length encoded string. Examples: >>> run_length_encoding(\\"aaabbc\\") \\"a3b2c1\\" >>> run_length_encoding(\\"abcd\\") \\"a1b1c1d1\\"","solution":"def run_length_encoding(s): Encodes the input string using Run-Length Encoding (RLE). if not s: return \\"\\" encoded_string = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: encoded_string.append(f\\"{previous_char}{count}\\") count = 1 previous_char = char encoded_string.append(f\\"{previous_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"def max_people_in_house(n, intervals): Determine the maximum number of people in the house at any given time. Args: - n (int): Number of people. - intervals (List[Tuple[int, int]]): List of tuples, where each tuple contains entry and exit times. Returns: - int: Maximum number of people present at any given time. pass # Example test cases def test_example_case(): assert max_people_in_house(3, [(1, 4), (2, 6), (5, 8)]) == 2 def test_no_overlap(): assert max_people_in_house(3, [(1, 2), (3, 4), (5, 6)]) == 1 def test_all_overlap(): assert max_people_in_house(3, [(1, 5), (2, 6), (3, 7)]) == 3 def test_nested_intervals(): assert max_people_in_house(3, [(1, 10), (2, 5), (6, 9)]) == 2 def test_multiple_entries_and_exits(): assert max_people_in_house(5, [(1, 10), (2, 6), (3, 9), (4, 8), (5, 7)]) == 5 def test_single_person(): assert max_people_in_house(1, [(0, 86400)]) == 1","solution":"def max_people_in_house(n, intervals): Determine the maximum number of people in the house at any given time. Args: - n (int): Number of people. - intervals (List[Tuple[int, int]]): List of tuples, where each tuple contains entry and exit times. Returns: - int: Maximum number of people present at any given time. events = [] for entry, exit in intervals: events.append((entry, 1)) # 1 indicates entering events.append((exit, -1)) # -1 indicates exiting events.sort() # Sort events by time, if times are same, exits come before entries current_people = 0 max_people = 0 for time, event in events: current_people += event if current_people > max_people: max_people = current_people return max_people"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Determines if a string can be segmented into one or more dictionary words. Args: s: str, the input string. wordDict: list of str, the dictionary of words. Returns: bool, True if the string can be segmented, False otherwise. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"applepie\\", [\\"apple\\", \\"pear\\", \\"pie\\"]) True >>> word_break(\\"\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"abcd\\", [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"]) True >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) True >>> word_break(\\"b\\", [\\"a\\"]) False >>> word_break(\\"a\\", [\\"a\\"]) True","solution":"def word_break(s, wordDict): Determines if a string can be segmented into one or more dictionary words. Args: s: str, the input string. wordDict: list of str, the dictionary of words. Returns: bool, True if the string can be segmented, False otherwise. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def theater_ticket_booking(N: int, Q: int, operations: List[str]) -> str: Simulates the ticket booking system for a theater. Args: N: int - Number of seats in the theater. Q: int - Number of booking and cancellation operations. operations: List of str - List of operations in 'BOOK seat_number' or 'CANCEL seat_number' format. Returns: str - Space-separated list of booked seat numbers in ascending order or \\"No seats booked\\" if no seats are booked. >>> theater_ticket_booking(10, 5, [\\"BOOK 3\\", \\"BOOK 1\\", \\"CANCEL 3\\", \\"BOOK 2\\", \\"BOOK 10\\"]) == \\"1 2 10\\" >>> theater_ticket_booking(10, 4, [\\"BOOK 1\\", \\"BOOK 2\\", \\"CANCEL 1\\", \\"CANCEL 2\\"]) == \\"No seats booked\\" >>> theater_ticket_booking(10, 0, []) == \\"No seats booked\\" >>> theater_ticket_booking(10, 5, [\\"BOOK 1\\", \\"BOOK 1\\", \\"BOOK 1\\", \\"CANCEL 1\\", \\"BOOK 1\\"]) == \\"1\\" >>> theater_ticket_booking(15, 7, [\\"BOOK 5\\", \\"BOOK 3\\", \\"CANCEL 5\\", \\"BOOK 12\\", \\"CANCEL 12\\", \\"BOOK 7\\", \\"BOOK 3\\"]) == \\"3 7\\"","solution":"def theater_ticket_booking(N, Q, operations): Simulates the ticket booking system for a theater. Args: N: int - Number of seats in the theater. Q: int - Number of booking and cancellation operations. operations: List of str - List of operations in 'BOOK seat_number' or 'CANCEL seat_number' format. Returns: str - Space-separated list of booked seat numbers in ascending order or \\"No seats booked\\" if no seats are booked. booked_seats = set() for operation in operations: action, seat_number = operation.split() seat_number = int(seat_number) if action == \\"BOOK\\": booked_seats.add(seat_number) elif action == \\"CANCEL\\": booked_seats.discard(seat_number) # discard does not raise an error if the element is not present if booked_seats: return ' '.join(map(str, sorted(booked_seats))) else: return \\"No seats booked\\""},{"question":"def suggest_username(taken_usernames: List[str], new_first_name: str) -> str: Suggest a unique username based on the new user's first name. Parameters: - taken_usernames: List of strings representing already taken usernames. - new_first_name: String representing the new user's first name. Returns: - A string representing the suggested unique username. # Write your code here def process_test_cases(T: int, cases: List[Tuple[int, List[str], str]]) -> List[str]: Process multiple test cases to suggest unique usernames. Parameters: - T: Integer representing the number of test cases. - cases: List of tuples, each containing: - An integer representing the number of taken usernames - A list of taken usernames - A string representing the new user's first name Returns: - A list of strings representing the suggested unique usernames for each test case # Write your code here # Example Unit Tests def test_suggest_username_no_conflict(): assert suggest_username(['john1', 'john2'], 'john') == 'john' def test_suggest_username_single_conflict(): assert suggest_username(['john', 'john2'], 'john') == 'john1' def test_suggest_username_multiple_conflicts(): assert suggest_username(['john', 'john1', 'john2'], 'john') == 'john3' def test_process_test_cases(): T = 2 cases = [ (3, ['john', 'john1', 'john2'], 'john'), (2, ['alice', 'alice1'], 'alice') ] expected = ['john3', 'alice2'] assert process_test_cases(T, cases) == expected def test_suggest_username_no_taken_names(): assert suggest_username([], 'alex') == 'alex' def test_suggest_username_large_list(): taken_usernames = ['name' + str(i) for i in range(1, 1001)] assert suggest_username(taken_usernames, 'name') == 'name' def test_suggest_username_middle_conflict(): taken_usernames = ['name', 'name2', 'name1'] assert suggest_username(taken_usernames, 'name') == 'name3'","solution":"def suggest_username(taken_usernames, new_first_name): Suggest a unique username based on the new user's first name. Parameters: - taken_usernames: List of strings representing already taken usernames. - new_first_name: String representing the new user's first name. Returns: - A string representing the suggested unique username. if new_first_name not in taken_usernames: return new_first_name i = 1 while f\\"{new_first_name}{i}\\" in taken_usernames: i += 1 return f\\"{new_first_name}{i}\\" def process_test_cases(T, cases): results = [] for case in cases: N, taken, new_name = case result = suggest_username(taken, new_name) results.append(result) return results"},{"question":"def find_longest_unique_substring(s: str) -> tuple[int, int]: Returns the start and end indices (inclusive) of the longest substring consisting of unique characters. >>> find_longest_unique_substring(\\"abcabcbb\\") == (0, 2) >>> find_longest_unique_substring(\\"bbbbb\\") == (0, 0) >>> find_longest_unique_substring(\\"pwwkew\\") == (2, 4) >>> find_longest_unique_substring(\\"aab\\") == (1, 2)","solution":"def find_longest_unique_substring(s: str) -> tuple[int, int]: Returns the start and end indices (inclusive) of the longest substring consisting of unique characters. # Tracking the last seen index of each character last_seen = {} start = 0 max_len = 0 max_start = 0 max_end = 0 for end in range(len(s)): if s[end] in last_seen and last_seen[s[end]] >= start: start = last_seen[s[end]] + 1 last_seen[s[end]] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_start = start max_end = end return (max_start, max_end)"},{"question":"def filterPrimes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list of integers. >>> filterPrimes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filterPrimes([15, 23, 37, 42, 51, 63, 71]) [23, 37, 71] >>> filterPrimes([0, 1, 2, 3, 4, 5]) [2, 3, 5] >>> filterPrimes([1, 4, 6, 8, 10, 12, 14]) [] >>> filterPrimes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filterPrimes([]) []","solution":"def is_prime(number): Helper function to check if a number is prime. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number ** 0.5) + 1, 2): if number % i == 0: return False return True def filterPrimes(numbers): Returns a list of prime numbers from the input list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def is_subsequence(s: str, t: str) -> bool: Given two strings, s and t, check if s is a subsequence of t. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"\\", \\"ahbgdc\\") True >>> is_subsequence(\\"a\\", \\"\\") False >>> is_subsequence(\\"\\", \\"\\") True >>> is_subsequence(\\"a\\", \\"a\\") True >>> is_subsequence(\\"a\\", \\"b\\") False >>> is_subsequence(\\"ab\\", \\"ab\\") True >>> is_subsequence(\\"abcd\\", \\"abc\\") False","solution":"def is_subsequence(s, t): Checks if s is a subsequence of t. s_index, t_index = 0, 0 while s_index < len(s) and t_index < len(t): if s[s_index] == t[t_index]: s_index += 1 t_index += 1 return s_index == len(s)"},{"question":"def countSteps(n: int) -> int: Given an integer n, returns the minimum number of steps required to reduce n to 1 by performing the following operations: 1. If n is even, divide it by 2. 2. If n is odd, either subtract 1 from n or add 1 to n. Examples: >>> countSteps(8) == 3 # 8 -> 4 -> 2 -> 1 >>> countSteps(7) == 4 # 7 -> 8 -> 4 -> 2 -> 1 >>> countSteps(10) == 4 # 10 -> 5 -> 4 -> 2 -> 1 >>> countSteps(1) == 0 # n is already 1 pass # your implementation here # Unit test def test_countSteps_even(): assert countSteps(8) == 3 # 8 -> 4 -> 2 -> 1 def test_countSteps_odd(): assert countSteps(7) == 4 # 7 -> 8 -> 4 -> 2 -> 1 def test_countSteps_mixed(): assert countSteps(10) == 4 # 10 -> 5 -> 4 -> 2 -> 1 def test_countSteps_one(): assert countSteps(1) == 0 # n is already 1 def test_countSteps_large_even(): assert countSteps(16) == 4 # 16 -> 8 -> 4 -> 2 -> 1 def test_countSteps_large_odd(): assert countSteps(15) == 5 # 15 -> 16 -> 8 -> 4 -> 2 -> 1 def test_countSteps_complex(): assert countSteps(9) == 4 # 9 -> 8 -> 4 -> 2 -> 1 assert countSteps(23) == 6 # 23 -> 24 -> 12 -> 6 -> 3 -> 4 -> 2 -> 1","solution":"def countSteps(n): Returns the minimum number of steps required to reduce n to 1. steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: # Instead of simply subtracting 1, check the neighboring even numbers to minimize steps if n == 3 or n % 4 == 1: n -= 1 else: n += 1 steps += 1 return steps"},{"question":"def product_except_self(lst): Given a list of integers, return a new list where each integer is substituted by the product of all other integers in the list except itself. >>> product_except_self([2]) [1] >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([0, 4, 6, 0]) [0, 0, 0, 0] >>> product_except_self([9, 3, 2]) [6, 18, 27] pass # Your solution here # Unit Tests def test_single_element(): assert product_except_self([2]) == [1] def test_all_positive(): assert product_except_self([1, 2, 3]) == [6, 3, 2] def test_with_zeros(): assert product_except_self([0, 4, 6, 0]) == [0, 0, 0, 0] def test_mixed_numbers(): assert product_except_self([9, 3, 2]) == [6, 18, 27] def test_empty_list(): assert product_except_self([]) == [] def test_two_elements(): assert product_except_self([3, 4]) == [4, 3] def test_with_negative_numbers(): assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] def test_large_numbers(): assert product_except_self([1000000, 1000, 100, 10]) == [1000000000, 100000000, 10000000, 1000000000] if __name__ == \\"__main__\\": test_single_element() test_all_positive() test_with_zeros() test_mixed_numbers() test_empty_list() test_two_elements() test_with_negative_numbers() test_large_numbers() print(\\"All tests passed.\\")","solution":"def product_except_self(lst): Returns a new list where each integer is substituted by the product of all other integers in the list except itself. n = len(lst) if n == 0: return [] elif n == 1: return [1] left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * lst[i - 1] for j in range(n - 2, -1, -1): right_products[j] = right_products[j + 1] * lst[j + 1] result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"def swap_case(s: str) -> str: Takes a string as input and returns a new string where every uppercase letter has been replaced with its lowercase counterpart, and every lowercase letter with its uppercase counterpart. All other characters remain unchanged. >>> swap_case(\\"HELLO WORLD!\\") == \\"hello world!\\" >>> swap_case(\\"hello world!\\") == \\"HELLO WORLD!\\" >>> swap_case(\\"HeLLo WoRLd!\\") == \\"hEllO wOrlD!\\" >>> swap_case(\\"Python3.8\\") == \\"pYTHON3.8\\" >>> swap_case(\\"12345%\\") == \\"12345%\\" >>> swap_case(\\"\\") == \\"\\" >>> swap_case(\\"a\\") == \\"A\\" >>> swap_case(\\"A\\") == \\"a\\" >>> swap_case(\\"1\\") == \\"1\\" # Your code here","solution":"def swap_case(s): Returns a new string where every uppercase letter has been replaced with its lowercase counterpart, and every lowercase letter with its uppercase counterpart. All other characters remain unchanged. return s.swapcase()"},{"question":"def extract_numbers(s: str) -> int: Extracts all numbers from the given string, concatenates them together, and returns the resulting number as an integer. If there are no numbers in the string, returns 0. >>> extract_numbers(\\"abc123xyz\\") 123 >>> extract_numbers(\\"a1b2c3\\") 123 >>> extract_numbers(\\"hello\\") 0 pass # Test cases def test_extract_numbers_single_number(): assert extract_numbers(\\"abc123xyz\\") == 123 def test_extract_numbers_multiple_numbers(): assert extract_numbers(\\"a1b2c3\\") == 123 def test_extract_numbers_no_numbers(): assert extract_numbers(\\"hello\\") == 0 def test_extract_numbers_numbers_and_letters(): assert extract_numbers(\\"abc4d5ef6g\\") == 456 def test_extract_numbers_only_numbers(): assert extract_numbers(\\"123456\\") == 123456 def test_extract_numbers_empty_string(): assert extract_numbers(\\"\\") == 0 def test_extract_numbers_only_letters(): assert extract_numbers(\\"abcdef\\") == 0 def test_extract_numbers_special_characters(): assert extract_numbers(\\"a1!2@3#\\") == 123 def test_extract_numbers_whitespace_included(): assert extract_numbers(\\"a 1b 2 c3\\") == 123","solution":"def extract_numbers(s): Extracts all numbers from the given string, concatenates them together, and returns the resulting number as an integer. If there are no numbers in the string, returns 0. num_str = ''.join([char for char in s if char.isdigit()]) return int(num_str) if num_str else 0"},{"question":"def is_anagram(str1, str2): Check if two strings are anagrams of each other. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. Examples: >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"world\\") False def find_anagrams(word, words_list): Find all anagrams of a given word from a list of words. Parameters: word (str): The word to find anagrams for. words_list (list): The list of words to search in. Returns: list: A list of anagrams found in the words_list. Examples: >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"]) ['enlist', 'inlets'] >>> find_anagrams(\\"listen\\", [\\"apple\\", \\"google\\", \\"banana\\"]) []","solution":"def is_anagram(str1, str2): Check if two strings are anagrams of each other. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. return sorted(str1) == sorted(str2) def find_anagrams(word, words_list): Find all anagrams of a given word from a list of words. Parameters: word (str): The word to find anagrams for. words_list (list): The list of words to search in. Returns: list: A list of anagrams found in the words_list. return [w for w in words_list if is_anagram(word, w)]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines whether it is possible to rearrange the characters of the string s to form a palindrome. >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"aab\\") True def analyze_strings(t: int, strings: List[str]) -> List[str]: Analyzes multiple strings to determine if each can form a palindrome. >>> analyze_strings(3, [\\"aabbcc\\", \\"abc\\", \\"aab\\"]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> analyze_strings(2, [\\"aabbccdd\\", \\"abcdefg\\"]) [\\"Yes\\", \\"No\\"]","solution":"def can_form_palindrome(s): Determines whether it is possible to rearrange the characters of the string s to form a palindrome. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # A string can be rearranged to form a palindrome if at most one character has an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def analyze_strings(t, strings): Analyzes multiple strings to determine if each can form a palindrome. results = [] for s in strings: if can_form_palindrome(s): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def find_missing_codes(n: int, book_codes: List[int]) -> List[Union[int, str]]: Returns a list of missing codes to complete the connected sequence of book codes. If no codes are missing, returns [\\"None\\"]. >>> find_missing_codes(5, [1, 2, 4, 5, 7]) [3, 6] >>> find_missing_codes(4, [3, 4, 5, 7]) [6] >>> find_missing_codes(3, [1, 2, 3]) [\\"None\\"]","solution":"def find_missing_codes(n, book_codes): Returns a list of missing codes to complete the connected sequence of book codes. If no codes are missing, returns [\\"None\\"]. missing_codes = [] for i in range(1, n): current_code = book_codes[i-1] next_code = book_codes[i] # Check if there is a gap between current and next code if next_code - current_code > 1: # Add all missing codes between current_code and next_code missing_codes.extend(range(current_code + 1, next_code)) if not missing_codes: return [\\"None\\"] return missing_codes"},{"question":"def can_attend_all_meetings(intervals: List[int]) -> bool: Determine if a person could attend all meetings without any overlaps. :param intervals: List of start and end times [start1, end1, start2, end2, ...] :return: Boolean, True if a person can attend all meetings else False. >>> can_attend_all_meetings([]) True >>> can_attend_all_meetings([5, 10]) True >>> can_attend_all_meetings([7, 10, 2, 4]) True >>> can_attend_all_meetings([0, 30, 5, 10, 15, 20]) False >>> can_attend_all_meetings([1, 2, 2, 3, 3, 4]) True >>> can_attend_all_meetings([1, 3, 3, 5, 5, 7, 7, 9]) True >>> can_attend_all_meetings([1, 4, 2, 5, 6, 8]) False >>> can_attend_all_meetings([1, 3, 3, 4, 4, 5, 5, 6]) True","solution":"def can_attend_all_meetings(intervals): Determine if a person could attend all meetings without any overlaps. :param intervals: List of start and end times [start1, end1, start2, end2, ...] :return: Boolean, True if a person can attend all meetings else False if not intervals or len(intervals) < 4: return True # Create a list of tuples (start, end) meetings = [(intervals[i], intervals[i + 1]) for i in range(0, len(intervals), 2)] # Sort the meetings by the start times meetings.sort() # Compare end time of current meeting with start time of the next meeting for i in range(1, len(meetings)): if meetings[i - 1][1] > meetings[i][0]: return False return True"},{"question":"def solve_problem(N, M, edge_list): Given an undirected graph with N nodes and M edges, where each edge has a non-negative weight, find the minimum possible sum of weights of the edges in the graph after removing as many edges as possible while ensuring that the remaining graph is connected. -----Input----- - The first line of the input contains two integers N and M denoting the number of nodes and edges, respectively. - Each of the next M lines contains three integers u, v and w representing an edge between nodes u and v with weight w. -----Output----- Output a single integer representing the minimum possible sum of weights of the edges in the graph. -----Example Input----- 5 6 1 2 3 1 3 4 1 4 2 2 3 1 2 5 5 3 5 7 -----Example Output----- 11 >>> solve_problem(5, 6, [(1, 2, 3), (1, 3, 4), (1, 4, 2), (2, 3, 1), (2, 5, 5), (3, 5, 7)]) 11 >>> solve_problem(4, 5, [(1, 2, 1), (1, 3, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1)]) 3 >>> solve_problem(6, 5, [(1, 2, 4), (2, 3, 2), (3, 4, 8), (4, 5, 3), (5, 6, 1)]) 18 >>> solve_problem(3, 1, [(1, 2, 10)]) 10 >>> solve_problem(4, 4, [(1, 2, 10**9), (2, 3, 10**9), (3, 4, 10**9), (1, 4, 10**9)]) 3000000000 import pytest def test_simple_case(): N = 5 M = 6 edges = [ (1, 2, 3), (1, 3, 4), (1, 4, 2), (2, 3, 1), (2, 5, 5), (3, 5, 7) ] assert solve_problem(N, M, edges) == 11 def test_all_edges_same_weight(): N = 4 M = 5 edges = [(1, 2, 1), (1, 3, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1)] assert solve_problem(N, M, edges) == 3 def test_sparse_graph(): N = 6 M = 5 edges = [(1, 2, 4), (2, 3, 2), (3, 4, 8), (4, 5, 3), (5, 6, 1)] assert solve_problem(N, M, edges) == 18 def test_disconnected_graph(): N = 3 M = 1 edges = [(1, 2, 10)] assert solve_problem(N, M, edges) == 10 def test_large_weights(): N = 4 M = 4 edges = [(1, 2, 10**9), (2, 3, 10**9), (3, 4, 10**9), (1, 4, 10**9)] assert solve_problem(N, M, edges) == 3 * 10**9 pytest.main()","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree_sum(n, edges): edges.sort(key=lambda x: x[2]) uf = UnionFind(n) min_weight_sum = 0 for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) min_weight_sum += w return min_weight_sum def solve_problem(N, M, edge_list): # Transform the edge list to be 0-indexed edges = [(u-1, v-1, w) for u, v, w in edge_list] # Find the MST weight sum return minimum_spanning_tree_sum(N, edges)"},{"question":"def process_numbers(nums: List[int]) -> Tuple[List[int], List[int]]: Returns a tuple containing a list of even numbers and a list of indices of odd numbers from the input list. :param nums: List of integers. :return: A tuple (list of even numbers, list of indices of odd numbers) >>> process_numbers([3, 4, 7, 10, 1, 3, 9, 6]) ([4, 10, 6], [0, 2, 4, 5, 6]) >>> process_numbers([2, 8, 6]) ([2, 8, 6], []) >>> process_numbers([1, 3, 5]) ([], [0, 1, 2]) >>> process_numbers([4]) ([4], []) >>> process_numbers([7]) ([], [0]) >>> process_numbers([1, 2, 3, 4, 5, 6]) ([2, 4, 6], [0, 2, 4])","solution":"def process_numbers(nums): Returns a tuple containing a list of even numbers and a list of indices of odd numbers from the input list. :param nums: List of integers. :return: A tuple (list of even numbers, list of indices of odd numbers) evens = [num for num in nums if num % 2 == 0] odd_indices = [i for i, num in enumerate(nums) if num % 2 != 0] return (evens, odd_indices)"},{"question":"def find_S(N: int) -> int: Finds the value of S[N] according to the given sequence definition. >>> find_S(1) 1 >>> find_S(7) 4 >>> find_S(10) 3 from typing import List, Dict import unittest class TestFindS(unittest.TestCase): def test_find_S_minimum(self): self.assertEqual(find_S(1), 1) def test_find_S_even_index(self): self.assertEqual(find_S(2), 1) self.assertEqual(find_S(4), 1) def test_find_S_odd_index(self): self.assertEqual(find_S(3), 2) self.assertEqual(find_S(5), 3) def test_find_S_various(self): self.assertEqual(find_S(6), 2) self.assertEqual(find_S(7), 3) self.assertEqual(find_S(10), 3) def test_find_S_large_input(self): self.assertGreater(find_S(1000000), 0) # We're not checking the precise value here for speed if __name__ == \\"__main__\\": unittest.main()","solution":"def find_S(N): Finds the value of S[N] according to the given sequence definition. if N == 1: return 1 # Using a dictionary to store computed values memo = {1: 1} # Helper function to calculate S(i) using memoization def S(i): if i in memo: return memo[i] if i % 2 == 0: memo[i] = S(i // 2) else: k = (i - 1) // 2 memo[i] = S(k) + S(k + 1) return memo[i] return S(N)"},{"question":"def most_frequent(lst): Returns the most frequent element in the list. If there are multiple elements with the same highest frequency, it returns any one of them. >>> most_frequent([1, 3, 1, 3, 2, 1]) # Output: 1 >>> most_frequent([3, 3, 3, 8, 8, 8]) # Output: 3 or 8 >>> most_frequent(['apple', 'banana', 'apple']) # Output: 'apple' >>> most_frequent([10]) # Output: 10 >>> most_frequent([]) # Output: None >>> most_frequent([1, 2, 2, 3, 3]) # Output: 2 or 3","solution":"def most_frequent(lst): Returns the most frequent element in the list. If there are multiple elements with the same highest frequency, it returns any one of them. if not lst: return None freq_dict = {} for item in lst: freq_dict[item] = freq_dict.get(item, 0) + 1 max_freq = max(freq_dict.values()) for item in lst: if freq_dict[item] == max_freq: return item"},{"question":"import os from typing import List def list_all_files(directory_path: str) -> List[str]: Lists all files within the given directory, including files in subdirectories. :param directory_path: The path of the directory. :return: A list of all file paths contained within the directory and subdirectories. Example 1: >>> list_all_files('/user/local/') ['/user/local/bin/bash', '/user/local/bin/cfg/example.cfg', '/user/local/lib/lib1.so', '/user/local/lib/lib2.so', '/user/local/share/doc/readme.md', '/user/local/file1.txt', '/user/local/file2.txt'] Example 2: >>> list_all_files('/root/') ['/root/home/user1/file1.txt', '/root/home/user2/docs/doc1.txt', '/root/etc/passwd']","solution":"import os def list_all_files(directory_path): Lists all files within the given directory, including files in subdirectories. :param directory_path: The path of the directory. :return: A list of all file paths contained within the directory and subdirectories. file_paths = [] # Helper function to recursively collect file paths def collect_files(current_path): for entry in os.listdir(current_path): full_path = os.path.join(current_path, entry) if os.path.isdir(full_path): collect_files(full_path) else: file_paths.append(full_path) # Start collecting from the given directory path collect_files(directory_path.rstrip('/')) # Sort the file paths lexicographically before returning file_paths.sort() return file_paths"},{"question":"def max_building_area(T: int, test_cases: List[List[int]]) -> List[int]: Calculate the maximum area of buildings that can be formed by selecting two building heights. >>> max_building_area(2, [[1, 3, 2, 5, 4], [10, 9, 8, 7, 6, 5]]) [9, 25] >>> max_building_area(1, [[1, 1, 1, 1, 1]]) [4]","solution":"def max_building_area(T, test_cases): def max_area_for_case(building_heights): n = len(building_heights) max_area = 0 left, right = 0, n - 1 while left < right: height = min(building_heights[left], building_heights[right]) width = right - left max_area = max(max_area, height * width) if building_heights[left] < building_heights[right]: left += 1 else: right -= 1 return max_area results = [] for case in test_cases: results.append(max_area_for_case(case)) return results # Note: The function takes T and test_cases as input # T is the number of test cases # test_cases is a list of lists, where each list contains the heights of the buildings for a test case"},{"question":"def largestRectangleArea(heights): Given a list of heights representing the heights of bars in a histogram, compute the area of the largest rectangle that can be formed using consecutive bars. :param heights: List[int] - A list of non-negative integers representing the heights of columns in a histogram. :returns: int - The area of the largest rectangle that can be formed from consecutive bars. Example 1: >>> largestRectangleArea([2,1,5,6,2,3]) 10 Example 2: >>> largestRectangleArea([2,4]) 4 Follow up: Can you solve this problem in O(n) time complexity using a stack-based approach?","solution":"def largestRectangleArea(heights): Given a list of heights representing the heights of bars in a histogram, it computes the area of the largest rectangle that can be formed using consecutive bars. :param heights: List[int] - A list of non-negative integers representing the heights of columns in a histogram. :returns: int - The area of the largest rectangle that can be formed from consecutive bars. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_univalue_substring(s: str) -> int: Returns the length of the longest substring containing only 'a's or only 'b's. Parameters: s (str): The input string containing only 'a' and 'b'. Returns: int: The length of the longest univalue substring. Examples: >>> longest_univalue_substring(\\"aabbbba\\") 4 >>> longest_univalue_substring(\\"abba\\") 2 >>> longest_univalue_substring(\\"aaaa\\") 4 >>> longest_univalue_substring(\\"bbaaaabba\\") 4","solution":"def longest_univalue_substring(s): Returns the length of the longest substring containing only 'a's or only 'b's. Parameters: s (str): The input string containing only 'a' and 'b'. Returns: int: The length of the longest univalue substring. max_length = 0 current_char = \\"\\" current_length = 0 for char in s: if char == current_char: current_length += 1 else: current_char = char current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def manage_salaries(n, salaries, m, events): Processes a sequence of salary modification events and returns final salaries. :param int n: Number of employees :param list salaries: Initial salaries of the employees :param int m: Number of events :param list events: List of events (either \\"inc a b c\\" or \\"set d e\\") :return: Final salaries of all employees :rtype: list >>> manage_salaries(3, [4000, 3000, 2000], 4, ['inc 1 2 500', 'set 3 3500', 'inc 2 3 1000', 'set 1 4000']) [4000, 4500, 4500] >>> manage_salaries(5, [1000, 2000, 3000, 4000, 5000], 3, ['inc 2 4 1000', 'set 5 6000', 'inc 1 5 500']) [1500, 3500, 4500, 5500, 6500] pass","solution":"def manage_salaries(n, salaries, m, events): Processes a sequence of salary modification events and returns final salaries. :param int n: Number of employees :param list salaries: Initial salaries of the employees :param int m: Number of events :param list events: List of events (either \\"inc a b c\\" or \\"set d e\\") :return: Final salaries of all employees :rtype: list for event in events: details = event.split() if details[0] == 'inc': a, b, c = int(details[1]), int(details[2]), int(details[3]) for i in range(a - 1, b): salaries[i] += c elif details[0] == 'set': d, e = int(details[1]), int(details[2]) salaries[d - 1] = e return salaries"},{"question":"def min_watering_nodes(test_cases: List[List[int]]) -> List[int]: Given the water requirements of plant groups in multiple test cases, return the minimum number of watering nodes required for each test case. >>> min_watering_nodes([[2, 3, 2, 3], [1, 4, 1, 4, 2], [1, 1, 1]]) == [2, 3, 1] def parse_input(input_data: str) -> List[List[int]]: Parse the input string and return a list of test cases, where each test case is a list of water requirements. >>> parse_input(\\"3n4n2 3 2 3n5n1 4 1 4 2n3n1 1 1\\") == [[2, 3, 2, 3], [1, 4, 1, 4, 2], [1, 1, 1]] def format_output(results: List[int]) -> str: Format the list of results as a string, with each result on a new line. >>> format_output([2, 3, 1]) == \\"2n3n1\\" def main(input_data: str) -> str: Process the input, compute the results, and format the output. >>> main(\\"3n4n2 3 2 3n5n1 4 1 4 2n3n1 1 1\\") == \\"2n3n1\\"","solution":"def min_watering_nodes(test_cases): results = [] for groups in test_cases: # Using a set to find unique water requirements unique_requirements = set(groups) # The number of unique water requirements will be the number of nodes needed results.append(len(unique_requirements)) return results def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) groups = list(map(int, input_lines[index + 1].split())) test_cases.append(groups) index += 2 return test_cases def format_output(results): return 'n'.join(map(str, results)) def main(input_data): test_cases = parse_input(input_data) results = min_watering_nodes(test_cases) return format_output(results)"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Find the largest rectangle containing only 1's and returns its area. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 6 >>> maximalRectangle([ ... [0, 1], ... [1, 0] ... ]) == 1 >>> maximalRectangle([ ... [0] ... ]) == 0","solution":"def maximalRectangle(matrix): Find the largest rectangle containing only 1's and returns its area. if not matrix or not matrix[0]: return 0 max_area = 0 heights = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): heights[i] = heights[i] + 1 if row[i] == 1 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Helper function to find the largest rectangle in histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def has_pair_with_sum(arr, queries): Determines if there exists a pair of integers in the array whose sum equals each query value. Parameters: arr (list of int): Array of integers. queries (list of int): List of query values. Returns: list of str: List of \\"YES\\" or \\"NO\\" for each query. pass def test_has_pair_with_sum(): assert has_pair_with_sum([1, 2, 3, 4, 5], [5, 10, 7]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert has_pair_with_sum([1, 2, 3], [4, 5, 6]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert has_pair_with_sum([2, -1, 0, 1], [1, 0, -1, 2]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] assert has_pair_with_sum([1, 1], [2, 3, 1]) == [\\"YES\\", \\"NO\\", \\"NO\\"] assert has_pair_with_sum([-1, -2, -3], [-4, -5, -6]) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([1], [2, 1, 0]) == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_has_pair_with_sum_empty_array(): assert has_pair_with_sum([], [1, 2, 3]) == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_has_pair_with_sum_large_numbers(): assert has_pair_with_sum([1000000000, -1000000000], [0, 2000000000, -2000000000]) == [\\"YES\\", \\"NO\\", \\"NO\\"] def test_has_pair_with_sum_duplicate_elements(): assert has_pair_with_sum([2, 2, 2], [4, 2, 6]) == [\\"YES\\", \\"NO\\", \\"NO\\"] assert has_pair_with_sum([3, 3, 3, 3], [6, 5, 9]) == [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def has_pair_with_sum(arr, queries): Determines if there exists a pair of integers in the array whose sum equals each query value. Parameters: arr (list of int): Array of integers. queries (list of int): List of query values. Returns: list of str: List of \\"YES\\" or \\"NO\\" for each query. results = [] num_set = set(arr) for k in queries: found = False for num in arr: if (k - num) in num_set and (k - num) != num: found = True break elif (k - num) == num and arr.count(num) > 1: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"import re def is_valid_password(password: str) -> bool: Validates the given password string according to the specified criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Contains at least one special character - Ignores leading or trailing whitespace Returns True if the password is valid, False otherwise. >>> is_valid_password(\\"P@ssw0rd\\") == True >>> is_valid_password(\\"password\\") == False","solution":"import re def is_valid_password(password): Validates the given password string according to the specified criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Contains at least one special character - Ignores leading or trailing whitespace Returns True if the password is valid, False otherwise. # Remove leading/trailing whitespace password = password.strip() # Check if the password meets all the criteria if (len(password) >= 8 and re.search(r'[a-z]', password) and re.search(r'[A-Z]', password) and re.search(r'd', password) and re.search(r'[!@#%^&*]', password)): return True else: return False"},{"question":"def MatrixRotation(matrix): Rotates the given square matrix by 90 degrees clockwise in-place. Test cases: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> MatrixRotation(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> MatrixRotation(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1] ... ] >>> MatrixRotation(matrix) >>> matrix [[1]]","solution":"def MatrixRotation(matrix): Rotates the given square matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def is_subsequence(str1: str, str2: str) -> bool: Checks if str2 is a subsequence of str1. Parameters: str1 (str): The original string. str2 (str): The string to check as a subsequence. Returns: bool: True if str2 is a subsequence of str1, False otherwise. Examples: >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False pass # Unit tests def test_is_subsequence_true_cases(): assert is_subsequence(\\"abcde\\", \\"ace\\") == True assert is_subsequence(\\"abc\\", \\"abc\\") == True assert is_subsequence(\\"abcdefg\\", \\"bdg\\") == True assert is_subsequence(\\"a\\", \\"a\\") == True assert is_subsequence(\\"ab\\", \\"a\\") == True assert is_subsequence(\\"ab\\", \\"b\\") == True def test_is_subsequence_false_cases(): assert is_subsequence(\\"abcde\\", \\"aec\\") == False assert is_subsequence(\\"abc\\", \\"abcd\\") == False assert is_subsequence(\\"abcdefg\\", \\"ah\\") == False assert is_subsequence(\\"a\\", \\"b\\") == False assert is_subsequence(\\"ab\\", \\"ba\\") == False assert is_subsequence(\\"\\", \\"a\\") == False def test_is_subsequence_edge_cases(): assert is_subsequence(\\"\\", \\"\\") == True assert is_subsequence(\\"a\\", \\"\\") == True assert is_subsequence(\\"abc\\", \\"\\") == True assert is_subsequence(\\"\\", \\"abc\\") == False","solution":"def is_subsequence(str1: str, str2: str) -> bool: Checks if str2 is a subsequence of str1. Parameters: str1 (str): The original string. str2 (str): The string to check as a subsequence. Returns: bool: True if str2 is a subsequence of str1, False otherwise. iter_str1 = iter(str1) return all(char in iter_str1 for char in str2)"},{"question":"def marta_and_niko_game(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines the winner (Marta or Niko) of the game based on the final integer's parity. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list where each element is a tuple containing an integer N (length of the array) and a list of N integers. Returns: List[str]: A list of strings where each string is either \\"Marta\\" or \\"Niko\\" depending on the winner of the corresponding test case. >>> marta_and_niko_game(3, [(3, [1, 2, 3]), (4, [3, -1, 4, 5]), (2, [7, 9])]) ['Marta', 'Niko', 'Marta'] >>> marta_and_niko_game(1, [(2, [1, 1])]) ['Marta'] >>> marta_and_niko_game(1, [(3, [1, 1, 1])]) ['Niko'] >>> marta_and_niko_game(1, [(2, [2, 4])]) ['Marta'] >>> marta_and_niko_game(1, [(5, [1, 2, 3, 4, 5])]) ['Niko'] >>> marta_and_niko_game(1, [(2, [-1, -1])]) ['Marta'] >>> marta_and_niko_game(1, [(3, [-1, -1, -1])]) ['Niko'] >>> marta_and_niko_game(1, [(2, [1000000, 1000000])]) ['Marta'] >>> marta_and_niko_game(1, [(2, [1000001, 1000000])]) ['Niko']","solution":"def determine_winner(numbers): final_sum = sum(numbers) if final_sum % 2 == 0: return \\"Marta\\" else: return \\"Niko\\" def marta_and_niko_game(t, test_cases): results = [] for i in range(t): n, numbers = test_cases[i] results.append(determine_winner(numbers)) return results"},{"question":"def find_missing_ticket(N: int, tickets: List[int]) -> int: Find the missing ticket number from the given list of ticket numbers. Args: N (int): The total number of expected attendees (including the missing one). tickets (list): The list of ticket numbers in ascending order. Returns: int: The missing ticket number. Example: >>> find_missing_ticket(5, [1, 2, 4, 5]) 3 >>> find_missing_ticket(5, [2, 3, 4, 5]) 1 >>> find_missing_ticket(5, [1, 2, 3, 4]) 5 >>> find_missing_ticket(10, [1, 2, 3, 4, 5, 6, 7, 8, 10]) 9 >>> find_missing_ticket(2, [1]) 2 >>> find_missing_ticket(2, [2]) 1","solution":"def find_missing_ticket(N, tickets): Find the missing ticket number from the given list of ticket numbers. Args: N (int): The total number of expected attendees (including the missing one). tickets (list): The list of ticket numbers in ascending order. Returns: int: The missing ticket number. total_sum = N * (N + 1) // 2 sum_of_tickets = sum(tickets) return total_sum - sum_of_tickets # Example usage: # N = 5 # tickets = [1, 2, 4, 5] # print(find_missing_ticket(N, tickets)) # Should print 3"},{"question":"def longest_continuous_period(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Identify the longest continuous period during which the user was active on any website. >>> longest_continuous_period([(5, [1, 2, 4, 5, 7])]) [2] >>> longest_continuous_period([(4, [10, 15, 20, 25])]) [5] >>> longest_continuous_period([(3, [5, 6, 7])]) [1] result = [] for case in test_cases: N, timestamps = case max_period = 0 for i in range(1, N): current_period = timestamps[i] - timestamps[i-1] max_period = max(max_period, current_period) result.append(max_period) return result from typing import List, Tuple def test_case_1(): assert longest_continuous_period([(5, [1, 2, 4, 5, 7])]) == [2] def test_case_2(): assert longest_continuous_period([(4, [10, 15, 20, 25])]) == [5] def test_case_3(): assert longest_continuous_period([(3, [5, 6, 7])]) == [1] def test_multiple_cases(): assert longest_continuous_period([(5, [1, 2, 4, 5, 7]), (4, [10, 15, 20, 25]), (3, [5, 6, 7])]) == [2, 5, 1] def test_edge_case_min_timestamps(): assert longest_continuous_period([(2, [1, 2])]) == [1] def test_edge_case_max_timestamps(): assert longest_continuous_period([(1000, list(range(1000)))]) == [1]","solution":"def longest_continuous_period(test_cases): result = [] for case in test_cases: N, timestamps = case max_period = 0 for i in range(1, N): current_period = timestamps[i] - timestamps[i-1] max_period = max(max_period, current_period) result.append(max_period) return result # Function to parse the input and print the output def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) timestamps = list(map(int, data[index + 1:index + 1 + N])) test_cases.append((N, timestamps)) index += N + 1 results = longest_continuous_period(test_cases) for res in results: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def solution(input_str: str) -> list: Determines the maximum number of non-overlapping sessions the artist can schedule for each test case. The input is provided as a single string with test cases and session intervals. The function returns a list of integers, each representing the maximum number of non-overlapping sessions for a test case. >>> input_str = \\"2n3n1 2n2 3n3 4n4n1 3n2 5n4 6n7 8n\\" >>> solution(input_str) [2, 3] >>> input_str = \\"1n2n1 4n2 3n\\" >>> solution(input_str) [1] >>> input_str = \\"1n5n1 2n3 4n5 6n7 8n9 10n\\" >>> solution(input_str) [5] >>> input_str = \\"1n4n1 5n2 6n3 7n4 8n\\" >>> solution(input_str) [1] >>> input_str = \\"1n5n1 2n1 3n1 4n1 5n1 6n\\" >>> solution(input_str) [1]","solution":"def max_non_overlapping_sessions(test_cases): results = [] for sessions in test_cases: sessions.sort(key=lambda x: x[1]) last_end = 0 count = 0 for start, end in sessions: if start > last_end: last_end = end count += 1 results.append(count) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) sessions = [] index += 1 for _ in range(N): start, end = map(int, input_lines[index].strip().split()) sessions.append((start, end)) index += 1 test_cases.append(sessions) return test_cases def solution(input_str): test_cases = parse_input(input_str) return max_non_overlapping_sessions(test_cases)"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. :param s: The input string :return: True if the string can be rearranged to form a palindrome, False otherwise >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if the characters of a given string can be rearranged to form a palindrome. :param s: The input string :return: True if the string can be rearranged to form a palindrome, False otherwise if not s: return False char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def sum_of_primes(n: int) -> int: Returns the sum of the first n prime numbers. >>> sum_of_primes(5) # 2 + 3 + 5 + 7 + 11 = 28 28 >>> sum_of_primes(10) # First 10 primes sum to 129 129 def test_sum_of_primes_example1(): assert sum_of_primes(5) == 28 # 2 + 3 + 5 + 7 + 11 = 28 def test_sum_of_primes_example2(): assert sum_of_primes(10) == 129 # First 10 primes sum to 129 def test_sum_of_primes_single_prime(): assert sum_of_primes(1) == 2 # Only the first prime 2 def test_sum_of_primes_two_primes(): assert sum_of_primes(2) == 5 # 2 + 3 = 5 def test_sum_of_primes_large_n(): assert sum_of_primes(20) == 639 # Sum of the first 20 primes","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_of_primes(n: int) -> int: Returns the sum of the first n prime numbers. count = 0 sum_primes = 0 num = 2 while count < n: if is_prime(num): sum_primes += num count += 1 num += 1 return sum_primes"},{"question":"def total_calories(data: str) -> int: Returns the total calories from a formatted string. Parameters: data (str): A string in the format \\"item1:calories1,item2:calories2,...\\" Returns: int: Total calorie count Examples: >>> total_calories(\\"apple:95,banana:105,orange:62\\") 262 >>> total_calories(\\"sandwich:300,juice:120,cookie:200\\") 620","solution":"def total_calories(data: str) -> int: Returns the total calories from a formatted string. Parameters: data (str): A string in the format \\"item1:calories1,item2:calories2,...\\" Returns: int: Total calorie count items = data.split(',') total = 0 for item in items: _, calories = item.split(':') total += int(calories) return total"},{"question":"def count_special_numbers(n: int, d: int, numbers: List[int]) -> int: Returns the count of special numbers containing the digit d. Parameters: n (int): Number of numbers in the list. d (int): The favorite digit. numbers (list): List of integers. Returns: int: Count of special numbers. >>> count_special_numbers(5, 3, [123, 456, 789, 333, 531]) == 3 >>> count_special_numbers(3, 2, [123, 345, 678]) == 1 >>> count_special_numbers(4, 5, [512, 145, 352, 555]) == 4 >>> count_special_numbers(3, 1, [1000000000000000000, 2222222222222222222, 1111111111111111111]) == 2 >>> count_special_numbers(1, 0, [0]) == 1 >>> count_special_numbers(1, 4, [1234]) == 1 >>> count_special_numbers(1, 5, [123]) == 0","solution":"def count_special_numbers(n, d, numbers): Returns the count of special numbers containing the digit d. Parameters: n (int): Number of numbers in the list. d (int): The favorite digit. numbers (list): List of integers. Returns: int: Count of special numbers. favorite_digit = str(d) count = 0 for number in numbers: if favorite_digit in str(number): count += 1 return count # Example usage: # n, d = 5, 3 # numbers = [123, 456, 789, 333, 531] # print(count_special_numbers(n, d, numbers)) # Output: 3"},{"question":"def longest_balanced_parentheses(s: str) -> int: Returns the length of the longest balanced parentheses substring. >>> longest_balanced_parentheses(\\"(()\\") 2 >>> longest_balanced_parentheses(\\")()())\\") 4 >>> longest_balanced_parentheses(\\"\\") 0 >>> longest_balanced_parentheses(\\"(((((((((\\") 0 >>> longest_balanced_parentheses(\\")))))))))\\") 0 >>> longest_balanced_parentheses(\\"()(()\\") 2 >>> longest_balanced_parentheses(\\"()(())\\") 6 >>> longest_balanced_parentheses(\\"(()())()\\") 8","solution":"def longest_balanced_parentheses(s: str) -> int: Returns the length of the longest balanced parentheses substring. stack = [-1] max_length = 0 for i, char in enumerate(s): if char == '(': stack.append(i) else: # char == ')' stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"def find_max_dancer(k: int, preferences: List[int]) -> int: Returns the 1-based position of the dancer who can perform on the maximum number of beats consecutively, starting from the k-th dancer and moving clockwise. :param k: int - starting position (1-based index) :param preferences: list of int - list representing beat preferences of each dancer :return: int - position of the dancer with maximum beats consecutively (1-based index) >>> find_max_dancer(1, [2, 4, 3, 6, 1]) 4 >>> find_max_dancer(3, [2, 4, 3, 6, 1]) 4 >>> find_max_dancer(5, [2, 4, 3, 6, 1]) 4 ...","solution":"def find_max_dancer(k, preferences): Returns the 1-based position of the dancer who can perform on the maximum number of beats consecutively, starting from the k-th dancer and moving clockwise. :param k: int - starting position (1-based index) :param preferences: list of int - list representing beat preferences of each dancer :return: int - position of the dancer with maximum beats consecutively (1-based index) n = len(preferences) max_beats = -1 max_position = -1 # Iterate over the dancers in cyclic order starting from k for i in range(n): current_position = (k - 1 + i) % n if preferences[current_position] > max_beats: max_beats = preferences[current_position] max_position = current_position + 1 # converting 0-based index to 1-based return max_position"},{"question":"def nextPermutation(nums: List[int]) -> None: Generate the next lexicographical permutation of the list of integers nums. If such an arrangement is not possible, it rearranges it as the lowest possible order. Examples: >>> nums = [1, 2, 3] >>> nextPermutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> nextPermutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> nextPermutation(nums) >>> nums [1, 5, 1] >>> nums = [1, 3, 2] >>> nextPermutation(nums) >>> nums [2, 1, 3] >>> nums = [2, 3, 1] >>> nextPermutation(nums) >>> nums [3, 1, 2] >>> nums = [1, 5, 1, 3] >>> nextPermutation(nums) >>> nums [1, 5, 3, 1] >>> nums = [1, 1, 1, 1] >>> nextPermutation(nums) >>> nums [1, 1, 1, 1] >>> nums = [1] >>> nextPermutation(nums) >>> nums [1] >>> nums = [2, 3] >>> nextPermutation(nums) >>> nums [3, 2] >>> nums = [3, 2] >>> nextPermutation(nums) >>> nums [2, 3]","solution":"def nextPermutation(nums): Modify nums to its next permutation in place; rearrange it to the lowest possible order if no next permutation exists. if len(nums) <= 1: return # Find the largest index k such that nums[k] < nums[k + 1] k = len(nums) - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k >= 0: # Find the largest index l greater than k such that nums[k] < nums[l] l = len(nums) - 1 while nums[k] >= nums[l]: l -= 1 # Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Reverse the sequence from nums[k + 1] up to and including the final element nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"def largest_balanced_substring(s: str) -> int: Write a function called \`largest_balanced_substring\` that takes a string \`s\` as input. The string \`s\` consists of only the characters 'a' and 'b'. A balanced substring is one in which the number of 'a's is equal to the number of 'b's. The function should find and return the length of the largest balanced substring. Examples: >>> largest_balanced_substring(\\"ababab\\") 6 >>> largest_balanced_substring(\\"aaabbb\\") 6 >>> largest_balanced_substring(\\"abba\\") 4 >>> largest_balanced_substring(\\"abb\\") 2","solution":"def largest_balanced_substring(s): Finds and returns the length of the largest balanced substring. A balanced substring is one in which the number of 'a's is equal to the number of 'b's. Parameters: s (str): The input string consisting of 'a's and 'b's. Returns: int: The length of the largest balanced substring. longest = 0 balance = 0 balance_dict = {0: -1} for i, char in enumerate(s): if char == 'a': balance += 1 else: balance -= 1 if balance in balance_dict: longest = max(longest, i - balance_dict[balance]) else: balance_dict[balance] = i return longest"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, finds the longest substring without repeating characters and returns its length. If the string is empty or None, return 0. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0","solution":"def length_of_longest_substring(s): Finds the length of the longest substring without repeating characters in a given string. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. if s is None or s == \\"\\": return 0 n = len(s) max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def generate_spiral_matrix(N: int) -> List[List[int]]: Generates an N x N matrix filled with values from 1 to N^2 in a spiral order. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] pass def process_test_cases(T: int, cases: List[int]) -> List[List[List[int]]]: Processes T test cases for N x N spiral matrix generation. >>> process_test_cases(2, [3, 4]) [[[1, 2, 3], [8, 9, 4], [7, 6, 5]], [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]] pass # Example unit tests from typing import List def test_generate_spiral_matrix_3x3(): expected = [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] assert generate_spiral_matrix(3) == expected def test_generate_spiral_matrix_4x4(): expected = [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] assert generate_spiral_matrix(4) == expected def test_generate_spiral_matrix_2x2(): expected = [ [1, 2], [4, 3] ] assert generate_spiral_matrix(2) == expected def test_generate_spiral_matrix_1x1(): expected = [ [1] ] assert generate_spiral_matrix(1) == expected def test_process_test_cases(): T = 2 cases = [3, 4] expected = [ [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ], [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] ] assert process_test_cases(T, cases) == expected","solution":"def generate_spiral_matrix(N): Generates an N x N matrix filled with values from 1 to N^2 in a spiral order. matrix = [[0] * N for _ in range(N)] num = 1 layers = (N + 1) // 2 for layer in range(layers): # From left to right for i in range(layer, N - layer): matrix[layer][i] = num num += 1 # From top to bottom for i in range(layer + 1, N - layer): matrix[i][N - layer - 1] = num num += 1 # From right to left if N - layer - 1 > layer: # Check to avoid overwriting for odd N size for i in range(N - layer - 2, layer - 1, -1): matrix[N - layer - 1][i] = num num += 1 # From bottom to top if N - layer - 1 > layer: # Check to avoid overwriting for odd N size for i in range(N - layer - 2, layer, -1): matrix[i][layer] = num num += 1 return matrix def process_test_cases(T, cases): Processes T test cases for N x N spiral matrix generation. results = [] for N in cases: matrix = generate_spiral_matrix(N) results.append(matrix) return results"},{"question":"def linear_search(nums, target): Performs a linear search to find the target in the list. Args: nums: List[int]: List of integers to search through. target: int: The integer value to find. Returns: int: The index of the target in the list if found, otherwise -1. pass def solve(test_cases): For each test case, performs a linear search and returns the results. Args: test_cases: List[Tuple[int, int, List[int]]]: List of test cases where each test case is a tuple containing the length of the list, the target integer, and the list of integers. Returns: List[int]: List of results for each test case where the result is the index of the target if found, otherwise -1. pass # Unit tests def test_linear_search_found(): assert linear_search([1, 5, 3, 7, 9], 3) == 2 assert linear_search([1, -2, 3, 4], -2) == 1 def test_linear_search_not_found(): assert linear_search([1, 2, 3, 4, 5], 6) == -1 assert linear_search([10, 20, 30, 40], 25) == -1 def test_linear_search_empty_list(): assert linear_search([], 1) == -1 def test_solve_single_case(): assert solve([(5, 3, [1, 5, 3, 7, 9])]) == [2] def test_solve_multiple_cases(): test_cases = [ (5, 3, [1, 5, 3, 7, 9]), (4, -2, [1, -2, 3, 4]) ] assert solve(test_cases) == [2, 1] def test_solve_no_matches(): test_cases = [ (5, 6, [1, 5, 3, 7, 9]), (4, 10, [1, -2, 3, 4]) ] assert solve(test_cases) == [-1, -1] def test_solve_empty_lists(): test_cases = [ (0, 1, []), (0, -1, []) ] assert solve(test_cases) == [-1, -1]","solution":"def linear_search(nums, target): Performs a linear search to find the target in the list. Args: nums: List[int]: List of integers to search through. target: int: The integer value to find. Returns: int: The index of the target in the list if found, otherwise -1. for index, value in enumerate(nums): if value == target: return index return -1 def solve(test_cases): results = [] for (n, target, nums) in test_cases: results.append(linear_search(nums, target)) return results"},{"question":"import math from typing import Tuple def gear_system_steps(n: int, speed: float, angle: float, speed_factor: float, angle_factor: float) -> Tuple[float, float]: Simulates a sequence of movements in a robotic gear system and computes the final position after \`n\` steps. Parameters: n (int): The number of steps the robot takes. speed (float): The initial speed of the robot. angle (float): The initial angle (in degrees) at which the robot is moving. speed_factor (float): The factor by which the robot's speed increases after each step. angle_factor (float): The factor by which the robot's angle changes after each step. Returns: Tuple[float, float]: The final coordinates (x, y) of the robot. Example: >>> gear_system_steps(1, 1.0, 45, 1.1, 1.5) (0.7071067811865475, 0.7071067811865475) >>> gear_system_steps(3, 1.0, 45, 1.1, 1.5) (1.2462625860489064, 2.4562468909142947) def test_gear_system_steps_1(): x, y = gear_system_steps(1, 1.0, 45, 1.1, 1.5) expected_x = 1.0 * math.cos(math.radians(45)) expected_y = 1.0 * math.sin(math.radians(45)) assert math.isclose(x, expected_x, rel_tol=1e-9) assert math.isclose(y, expected_y, rel_tol=1e-9) def test_gear_system_steps_3(): x, y = gear_system_steps(3, 1.0, 45, 1.1, 1.5) expected_x = (1.0 * math.cos(math.radians(45))) + (1.1 * math.cos(math.radians(45 * 1.5))) + (1.1 * 1.1 * math.cos(math.radians(45 * 1.5 * 1.5))) expected_y = (1.0 * math.sin(math.radians(45))) + (1.1 * math.sin(math.radians(45 * 1.5))) + (1.1 * 1.1 * math.sin(math.radians(45 * 1.5 * 1.5))) assert math.isclose(x, expected_x, rel_tol=1e-9) assert math.isclose(y, expected_y, rel_tol=1e-9) def test_gear_system_steps_no_movement(): x, y = gear_system_steps(0, 1.0, 45, 1.1, 1.5) assert x == 0.0 assert y == 0.0 def test_gear_system_steps_increase_factors(): x, y = gear_system_steps(2, 2.0, 90, 2.0, 2.0) expected_x = 2.0 * math.cos(math.radians(90)) + 4.0 * math.cos(math.radians(180)) expected_y = 2.0 * math.sin(math.radians(90)) + 4.0 * math.sin(math.radians(180)) assert math.isclose(x, expected_x, rel_tol=1e-9) assert math.isclose(y, expected_y, rel_tol=1e-9)","solution":"import math def gear_system_steps(n, speed, angle, speed_factor, angle_factor): x, y = 0.0, 0.0 angle = math.radians(angle) for _ in range(n): x += speed * math.cos(angle) y += speed * math.sin(angle) speed *= speed_factor angle = math.radians(math.degrees(angle)*angle_factor) return x, y"},{"question":"def max_power_value(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Compute the maximum sum of power values of cards that is less than or equal to the target power value P. >>> T = 2 >>> test_cases = [((5, 50), [10, 20, 30, 40, 50]), ((4, 60), [15, 25, 35, 45])] >>> max_power_value(T, test_cases) [50, 60]","solution":"def max_power_value(T, test_cases): results = [] for i in range(T): N, P = test_cases[i][0] cards = test_cases[i][1] dp = [0] * (P + 1) for card in cards: for j in range(P, card - 1, -1): dp[j] = max(dp[j], dp[j - card] + card) results.append(dp[P]) return results # Example usage: # T = 2 # test_cases = [ # ((5, 50), [10, 20, 30, 40, 50]), # ((4, 60), [15, 25, 35, 45]) # ] # print(max_power_value(T, test_cases)) # Output: [50, 60]"},{"question":"def sum_of_even_primes(lst: List[int]) -> int: Returns the sum of all even prime numbers in the given list. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. The only even prime number is 2. >>> sum_of_even_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> sum_of_even_primes([11, 13, 17, 19, 23]) 0 >>> sum_of_even_primes([2, 4, 6, 8, 10, 12, 14, 16]) 2 >>> sum_of_even_primes([2, 3, 5, 7]) 2 >>> sum_of_even_primes([4, 6, 8, 10, 12]) 0 >>> sum_of_even_primes([999999937, 1000000000, 2, 999999991]) 2 >>> sum_of_even_primes(list(range(1, 1000001))) 2","solution":"def sum_of_even_primes(lst): Returns the sum of all even prime numbers in the given list. # The only even prime number is 2 return 2 if 2 in lst else 0"},{"question":"from typing import List def max_histogram_area(heights: List[int]) -> int: Returns the maximum area of a rectangle formed by consecutive bars in the histogram. >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_histogram_area([2, 4]) 4 >>> max_histogram_area([3, 3, 3, 3]) 12 >>> max_histogram_area([4, 3, 2, 1]) 6 >>> max_histogram_area([1, 2, 3, 4]) 6 >>> max_histogram_area([2, 1, 4, 5, 1, 3, 3]) 8","solution":"def max_histogram_area(heights): Returns the maximum area of a rectangle formed by consecutive bars in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_shelves(M: int) -> int: Returns the maximum number of shelves that can be completely filled with M books. >>> max_shelves(3) 2 >>> max_shelves(6) 3 >>> max_shelves(10) 4 def find_max_shelves_for_cases(test_cases: List[int]) -> List[int]: For a given list of integer M (number of books for each test case), return a list of the maximum number of shelves that can be filled for each case. >>> find_max_shelves_for_cases([3, 6, 10]) [2, 3, 4] >>> find_max_shelves_for_cases([1, 0, 55, 100]) [1, 0, 10, 13]","solution":"def max_shelves(M): Returns the maximum number of shelves that can be completely filled with M books. K = 0 total_books = 0 while total_books <= M: K += 1 total_books += K # K will be incremented one time extra in the last iteration, so subtract 1 return K - 1 def find_max_shelves_for_cases(test_cases): For a given list of integer M (number of books for each test case), return a list of the maximum number of shelves that can be filled for each case. results = [] for M in test_cases: results.append(max_shelves(M)) return results"},{"question":"def calculate_total_cost(room_type: str, number_of_nights: int) -> float: Returns the total cost for a customer's stay including any discounts and taxes. >>> calculate_total_cost(\\"standard\\", 5) 540.00 >>> calculate_total_cost(\\"standard\\", 10) 972.00 >>> calculate_total_cost(\\"deluxe\\", 3) 486.00 >>> calculate_total_cost(\\"deluxe\\", 8) 1166.40 >>> calculate_total_cost(\\"penthouse\\", 2) 648.00 >>> calculate_total_cost(\\"penthouse\\", 10) 2916.00 >>> calculate_total_cost(\\"invalid\\", 5) Traceback (most recent call last): ... ValueError: Invalid room type","solution":"def calculate_total_cost(room_type, number_of_nights): Returns the total cost for a customer's stay including any discounts and taxes. Parameters: - room_type (str): Type of room, can be \\"standard\\", \\"deluxe\\", or \\"penthouse\\" - number_of_nights (int): Number of nights for the stay Returns: - float: Total cost formatted to two decimal places rates = { \\"standard\\": 100, \\"deluxe\\": 150, \\"penthouse\\": 300 } if room_type not in rates: raise ValueError(\\"Invalid room type\\") # Calculate base cost before any discounts/taxes base_cost = rates[room_type] * number_of_nights # Apply discount if applicable if number_of_nights > 7: base_cost *= 0.90 # 10% discount # Apply tax total_cost = base_cost * 1.08 # 8% tax return round(total_cost, 2)"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Given a string s and an integer k, return the length of the longest substring that contains at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) 2 pass from solution import length_of_longest_substring_k_distinct def test_example_1(): assert length_of_longest_substring_k_distinct(\\"eceba\\", 2) == 3 def test_example_2(): assert length_of_longest_substring_k_distinct(\\"aa\\", 1) == 2 def test_no_distinct_allowed(): assert length_of_longest_substring_k_distinct(\\"abcdef\\", 0) == 0 def test_all_distinct_characters(): assert length_of_longest_substring_k_distinct(\\"abcdef\\", 6) == 6 def test_long_substring(): assert length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) == 4 def test_k_greater_than_distinct_characters(): assert length_of_longest_substring_k_distinct(\\"abc\\", 5) == 3 def test_empty_string(): assert length_of_longest_substring_k_distinct(\\"\\", 2) == 0 def test_single_character_repeated(): assert length_of_longest_substring_k_distinct(\\"aaaa\\", 1) == 4","solution":"def length_of_longest_substring_k_distinct(s, k): if k == 0: return 0 n = len(s) if n == 0: return 0 char_count = {} left = 0 max_len = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def clean_string(s: str) -> str: Given a string \`s\` composed of lowercase letters and \`#\` characters, processes the string based on the following rules: 1. Every \`#\` character in the string represents a backspace operation (deleting the character that immediately precedes it). 2. Consecutive \`#\` characters represent consecutive backspace operations. Args: s (str): The input string. Returns: str: The processed string after applying all backspace operations. Examples: >>> clean_string(\\"abc#dc\\") \\"ac\\" >>> clean_string(\\"abcd\\") \\"\\" >>> clean_string(\\"#\\") \\"\\" >>> clean_string(\\"a#ac\\") \\"c\\" pass from solution import clean_string def test_clean_string_no_backspace(): assert clean_string(\\"abc\\") == \\"abc\\" def test_clean_string_single_backspace(): assert clean_string(\\"a#\\") == \\"\\" assert clean_string(\\"#a\\") == \\"a\\" def test_clean_string_multiple_backspaces(): assert clean_string(\\"abc#dc\\") == \\"ac\\" assert clean_string(\\"abcd\\") == \\"\\" assert clean_string(\\"#\\") == \\"\\" assert clean_string(\\"a#ac\\") == \\"c\\" def test_clean_string_edge_cases(): assert clean_string(\\"\\") == \\"\\" assert clean_string(\\"a#\\") == \\"\\" assert clean_string(\\"ab#c#\\") == \\"\\" assert clean_string(\\"\\") == \\"\\" def test_clean_string_backspaces_at_start(): assert clean_string(\\"#abc\\") == \\"abc\\" assert clean_string(\\"a#bc\\") == \\"bc\\"","solution":"def clean_string(s: str) -> str: Processes the string s by simulating backspace operations denoted by '#'. Args: s (str): The input string containing lowercase letters and '#' characters. Returns: str: The processed string after applying all backspace operations. stack = [] for char in s: if char == '#': if stack: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"class WordDictionary: A class to represent a word dictionary that supports adding new words and searching for words with wildcard support. Methods ------- addWord(word): Adds a word into the data structure. search(word): Returns true if there is any string in the data structure that matches word or false otherwise. The word may contain dots '.' which can represent any letter. def __init__(self): pass def addWord(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def test_add_and_search_exact_words(): wd = WordDictionary() wd.addWord(\\"hello\\") wd.addWord(\\"world\\") assert not wd.search(\\"helloo\\") assert wd.search(\\"hello\\") assert not wd.search(\\"hell\\") def test_search_with_wildcard(): wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") assert wd.search(\\".ad\\") assert wd.search(\\"b..\\") assert not wd.search(\\"..d.\\") assert not wd.search(\\"b...\\") def test_add_then_search(): wd = WordDictionary() assert not wd.search(\\"a\\") wd.addWord(\\"a\\") assert wd.search(\\"a\\") def test_mixed_search(): wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True","solution":"import collections class WordDictionary: def __init__(self): self.trie = {} def addWord(self, word): node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node['#'] = True def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char not in node: if char == '.': for x in node: if x != '#' and search_in_node(word[i + 1:], node[x]): return True return False else: node = node[char] return '#' in node return search_in_node(word, self.trie)"},{"question":"def sort_students_by_grade_then_name(students): Takes a list of student records and returns a list of student names sorted primarily by grade in descending order and secondarily by name in ascending order. Args: students (list of dict): List of student records, each record is a dictionary with keys 'name', 'age', and 'grade'. Returns: list of str: List of student names sorted as per the criteria. Example: >>> sort_students_by_grade_then_name([{\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 90}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grade\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grade\\": 85}]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> sort_students_by_grade_then_name([]) [] >>> sort_students_by_grade_then_name([{\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 90}]) [\\"Alice\\"] >>> sort_students_by_grade_then_name([{\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grade\\": 90}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grade\\": 90}]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> sort_students_by_grade_then_name([{\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grade\\": 95}, {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grade\\": 75}]) [\\"Bob\\", \\"Alice\\", \\"Charlie\\"] >>> sort_students_by_grade_then_name([{\\"name\\": \\"Ellen\\", \\"age\\": 24, \\"grade\\": 85}, {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grade\\": 85}]) [\\"Alice\\", \\"Bob\\", \\"Ellen\\"]","solution":"def sort_students_by_grade_then_name(students): Takes a list of student records and returns a list of student names sorted primarily by grade in descending order and secondarily by name in ascending order. Args: students (list of dict): List of student records, each record is a dictionary with keys 'name', 'age', and 'grade'. Returns: list of str: List of student names sorted as per the criteria. sorted_students = sorted(students, key=lambda x: (-x['grade'], x['name'])) return [student['name'] for student in sorted_students] # Example usage: # students = [ # {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 90}, # {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grade\\": 90}, # {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grade\\": 85} # ] # print(sort_students_by_grade_then_name(students)) # Output should be: [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]"},{"question":"def max_magic_power(n: int, k: int, T: int, powers: List[int]) -> int: Determine the maximum possible magic power of any valid segment of k contiguous trees without exceeding the malfunction threshold T. :param n: int - number of trees :param k: int - number of contiguous trees needed for the ritual :param T: int - the malfunction threshold :param powers: list of int - magic power of each tree :return: int - the maximum possible total magic power or -1 if no valid segment exists >>> max_magic_power(6, 3, 15, [1, 3, 5, 7, 9, 2]) 15 >>> max_magic_power(5, 3, 5, [6, 6, 6, 6, 6]) -1 >>> max_magic_power(5, 3, 5, [0, 0, 0, 0, 0]) 0 >>> max_magic_power(1, 1, 10, [10]) 10 >>> max_magic_power(4, 2, 10, [6, 4, 5, 5]) 10 >>> max_magic_power(5, 2, 20, [5, 1, 3, 2, 0]) 6 >>> max_magic_power(3, 3, 10, [3, 2, 3]) 8 pass","solution":"def max_magic_power(n, k, T, powers): Determine the maximum possible magic power of any valid segment of k contiguous trees without exceeding the malfunction threshold T. :param n: int - number of trees :param k: int - number of contiguous trees needed for the ritual :param T: int - the malfunction threshold :param powers: list of int - magic power of each tree :return: int - the maximum possible total magic power or -1 if no valid segment exists max_power = -1 current_sum = sum(powers[:k]) if current_sum <= T: max_power = current_sum for i in range(1, n - k + 1): current_sum = current_sum - powers[i - 1] + powers[i + k - 1] if current_sum <= T: max_power = max(max_power, current_sum) return max_power"},{"question":"from typing import Dict import math def find_missing_side(rectangle: Dict[str, float]) -> Dict[str, float]: Calculate the missing side of a rectangle given its other sides. >>> find_missing_side({'length': 3, 'width': 4}) {'length': 3, 'width': 4, 'diagonal': 5.0} >>> find_missing_side({'length': 6, 'diagonal': 10}) {'length': 6, 'width': 8.0, 'diagonal': 10.0} >>> find_missing_side({'width': 2, 'diagonal': 5}) {'length': 4.58257569495584, 'width': 2.0, 'diagonal': 5.0} >>> find_missing_side({'length': 3}) {'length': 3} >>> find_missing_side({'length': 7, 'width': 5, 'diagonal': 8.6}) {'length': 7, 'width': 5, 'diagonal': 8.6}","solution":"import math def find_missing_side(rectangle): Returns a rectangle dictionary with the missing side calculated. If more than one side is missing, returns the dictionary unchanged. length = rectangle.get('length') width = rectangle.get('width') diagonal = rectangle.get('diagonal') if length and width and not diagonal: rectangle['diagonal'] = math.sqrt(length ** 2 + width ** 2) elif length and diagonal and not width: rectangle['width'] = math.sqrt(diagonal ** 2 - length ** 2) elif width and diagonal and not length: rectangle['length'] = math.sqrt(diagonal ** 2 - width ** 2) # If more than one side is missing or all sides are present do nothing return rectangle"},{"question":"def word_value(word): Calculate the value of a word which is the sum of the ASCII values of its characters squared. def find_highest_value_word(words): Given a list of words, return the word with the highest value. if not words: return None # Test cases def test_word_value(): assert word_value(\\"A\\") == 65**2 assert word_value(\\"B\\") == 66**2 assert word_value(\\"AB\\") == 65**2 + 66**2 def test_find_highest_value_word(): assert find_highest_value_word([\\"SKY\\", \\"BUZZ\\", \\"XENON\\"]) == \\"XENON\\" assert find_highest_value_word([\\"A\\", \\"B\\"]) == \\"B\\" assert find_highest_value_word([\\"HELLO\\", \\"WORLD\\"]) == \\"WORLD\\" assert find_highest_value_word([\\"abc\\", \\"def\\"]) == \\"def\\" def test_edge_cases(): assert find_highest_value_word([]) == None assert find_highest_value_word([\\"\\"]) == \\"\\" assert find_highest_value_word([\\"SAME\\", \\"AME\\", \\"SME\\"]) == \\"SAME\\"","solution":"def word_value(word): Calculate the value of a word which is the sum of the ASCII values of its characters squared. return sum(ord(char)**2 for char in word) def find_highest_value_word(words): Given a list of words, return the word with the highest value. if not words: return None return max(words, key=word_value)"},{"question":"def max_total_score(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum total score for each test case. Parameters: - T: int, number of test cases - test_cases: list of tuples, each consisting of (N, array) where N is the number of elements in the array and array is the list of integers Returns: - list of int, maximum total score for each test case >>> max_total_score(2, [(5, [1, 3, 2, 4, 5]), (3, [10, 20, 30])]) [10, 20] >>> max_total_score(1, [(4, [10, 10, 10, 10])]) [0] >>> max_total_score(1, [(3, [1, 2, 3])]) [2] >>> max_total_score(1, [(3, [100000, 99999, 99998])]) [2] >>> max_total_score(1, [(4, [5, 1, 3, 2])]) [4]","solution":"def max_total_score(T, test_cases): Calculate the maximum total score for each test case. Parameters: - T: int, number of test cases - test_cases: list of tuples, each consisting of (N, array) where N is the number of elements in the array and array is the list of integers. Returns: - list of int, maximum total score for each test case results = [] for t in range(T): N, array = test_cases[t] array.sort() total_score = 0 for i in range(1, N): total_score += array[i] - array[i - 1] results.append(total_score) return results"},{"question":"from typing import List def find_missing_number(lst: List[int]) -> int: Determine the first missing positive integer in a list of integers. >>> find_missing_number([3, 4, -1, 1]) 2 >>> find_missing_number([1, 2, 0]) 3 >>> find_missing_number([-1, -2, -3]) 1 >>> find_missing_number([7, 8, 9, 11, 12]) 1","solution":"from typing import List def find_missing_number(lst: List[int]) -> int: n = len(lst) for i in range(n): while 1 <= lst[i] <= n and lst[lst[i] - 1] != lst[i]: lst[lst[i] - 1], lst[i] = lst[i], lst[lst[i] - 1] for i in range(n): if lst[i] != i + 1: return i + 1 return n + 1"},{"question":"def reverse_words(sentence: str) -> str: Returns the words in the sentence in reverse order, without leading, trailing, and multiple spaces between words. >>> reverse_words(\\"Hello world!\\") == \\"world! Hello\\" >>> reverse_words(\\" Hello world! \\") == \\"world! Hello\\" >>> reverse_words(\\" This is a test case \\") == \\"case test a is This\\" >>> reverse_words(\\"Moon \\") == \\"Moon\\" >>> reverse_words(\\"Word\\") == \\"Word\\" >>> reverse_words(\\" Word \\") == \\"Word\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\"","solution":"def reverse_words(sentence): Returns the words in the sentence in reverse order, without leading, trailing, and multiple spaces between words. # Split the sentence into words words = sentence.strip().split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a single string with single spaces between words return ' '.join(reversed_words)"},{"question":"from datetime import datetime from typing import List, Tuple, Dict, Any def marathon_info(participants: List[Tuple[str, str]]) -> Dict[str, Any]: Develop a function that takes a list of participants who wish to join a marathon and their registration times. Each participant is represented as a tuple (name, timestamp), where the name is a string and the timestamp is a string in the format \\"YYYY-MM-DD HH:MM:SS\\". The function should determine the earliest and latest registration times, the total number of participants, and a sorted list of participants based on their registration times in ascending order. >>> participants = [ ... (\\"John Doe\\", \\"2023-01-15 10:09:45\\"), ... (\\"Jane Smith\\", \\"2023-01-15 09:45:21\\"), ... (\\"Emily Davis\\", \\"2023-01-16 08:30:00\\"), ... (\\"Michael Brown\\", \\"2023-01-14 12:01:33\\"), ... (\\"Chris Johnson\\", \\"2023-01-15 11:35:20\\"), ... ] >>> marathon_info(participants) { \\"total_participants\\": 5, \\"earliest_registration\\": (\\"Michael Brown\\", \\"2023-01-14 12:01:33\\"), \\"latest_registration\\": (\\"Emily Davis\\", \\"2023-01-16 08:30:00\\"), \\"sorted_participants\\": [ (\\"Michael Brown\\", \\"2023-01-14 12:01:33\\"), (\\"Jane Smith\\", \\"2023-01-15 09:45:21\\"), (\\"John Doe\\", \\"2023-01-15 10:09:45\\"), (\\"Chris Johnson\\", \\"2023-01-15 11:35:20\\"), (\\"Emily Davis\\", \\"2023-01-16 08:30:00\\"), ] }","solution":"from datetime import datetime def marathon_info(participants): participants_sorted = sorted(participants, key=lambda x: datetime.strptime(x[1], \\"%Y-%m-%d %H:%M:%S\\")) earliest_registration = participants_sorted[0] latest_registration = participants_sorted[-1] total_participants = len(participants) return { \\"total_participants\\": total_participants, \\"earliest_registration\\": earliest_registration, \\"latest_registration\\": latest_registration, \\"sorted_participants\\": participants_sorted }"},{"question":"def remove_vowels(input_string: str) -> str: Removes all vowels from the input string and returns the result. Vowels include: 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. Examples: >>> remove_vowels(\\"Hello World\\") \\"Hll Wrld\\" >>> remove_vowels(\\"AEIOUaeiou\\") \\"\\" >>> remove_vowels(\\"Python\\") \\"Pythn\\" >>> remove_vowels(\\"\\") \\"\\"","solution":"def remove_vowels(input_string): Removes all vowels from the input string and returns the result. Vowels include: 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels])"},{"question":"def followersAndDifference(followers): Finds the user with the maximum number of followers and the user with the minimum number of followers. Calculates the absolute difference in the number of followers between these two users. Parameters: followers (dict): A dictionary where keys are usernames and values are follower counts. Returns: tuple: A tuple containing the user with maximum followers, user with minimum followers, and the absolute difference in follower counts. pass def test_followers_and_difference(): followers = { 'alice': 120, 'bob': 95, 'carol': 75, 'dave': 120, 'eve': 50 } assert followersAndDifference(followers) == ('alice', 'eve', 70) def test_single_followers(): followers = { 'alice': 100 } assert followersAndDifference(followers) == ('alice', 'alice', 0) def test_mixed_followers(): followers = { 'alice': 50, 'bob': 150, 'carol': 100, 'dave': 50, 'eve': 150 } assert followersAndDifference(followers) == ('bob', 'alice', 100) def test_large_numbers(): followers = { 'alice': 999999, 'bob': 0 } assert followersAndDifference(followers) == ('alice', 'bob', 999999) def test_zero_followers(): followers = { 'alice': 0, 'bob': 0, 'carol': 0 } assert followersAndDifference(followers) == ('alice', 'alice', 0)","solution":"def followersAndDifference(followers): Finds the user with the maximum number of followers and the user with the minimum number of followers. Calculates the absolute difference in the number of followers between these two users. Parameters: followers (dict): A dictionary where keys are usernames and values are follower counts. Returns: tuple: A tuple containing the user with maximum followers, user with minimum followers, and the absolute difference in follower counts. max_user = max(followers, key=followers.get) min_user = min(followers, key=followers.get) difference = abs(followers[max_user] - followers[min_user]) return (max_user, min_user, difference)"},{"question":"import numpy as np def print_identity_and_eye(N: int): Given an integer N, print an NxN identity matrix and a NxN matrix with 1's on the first lower diagonal and 0's elsewhere. Args: N (int): Size of the NxN matrices to be printed. Example: >>> print_identity_and_eye(3) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] [[0. 0. 0.] [1. 0. 0.] [0. 1. 0.]]","solution":"import numpy as np def print_identity_and_eye(N): Given an integer N, print an NxN identity matrix and a NxN matrix with 1's on the first lower diagonal and 0's elsewhere. # Identity matrix of size NxN identity_matrix = np.identity(N) print(identity_matrix) # 2-D array with 1's on the first lower diagonal eye_matrix = np.eye(N, k=-1) print(eye_matrix)"},{"question":"def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> Union[List[List[int]], str]: Write a function that takes two matrices as input and returns their product. Each matrix will be represented as a list of lists, where each inner list represents a row of the matrix. Ensure that the function checks for the appropriate dimensions that make matrix multiplication possible. If multiplication isn't possible due to dimension mismatch, the function should return an appropriate message. >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiply([[1, 2, 3]], [[4, 5], [6, 7]]) 'Multiplication not possible due to dimension mismatch'","solution":"def matrix_multiply(matrix1, matrix2): n = len(matrix1) m = len(matrix1[0]) p = len(matrix2) q = len(matrix2[0]) if m != p: return \\"Multiplication not possible due to dimension mismatch\\" result = [[0 for _ in range(q)] for _ in range(n)] for i in range(n): for j in range(q): for k in range(m): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"def decrypt(encrypted_message: str, shift: int) -> str: Decrypts the given message by shifting each letter back by the given shift value. >>> decrypt('KHOOR', 3) 'HELLO' >>> decrypt('ZAB', 1) 'YZA'","solution":"def decrypt(encrypted_message, shift): Decrypts the given message by shifting each letter back by the given shift value. decrypted_message = [] for char in encrypted_message: if char.isalpha(): shifted = ord(char) - shift if char.isupper(): decrypted_message.append(chr((shifted - 65) % 26 + 65)) else: decrypted_message.append(chr((shifted - 97) % 26 + 97)) else: decrypted_message.append(char) return ''.join(decrypted_message)"},{"question":"from typing import List def generate_primes(n: int, S: int) -> List[int]: Generate a list of the first n prime numbers in ascending order such that their sum does not exceed S. >>> generate_primes(5, 28) [2, 3, 5, 7, 11] >>> generate_primes(5, 15) [] def test_generate_primes_simple_case(): assert generate_primes(5, 28) == [2, 3, 5, 7, 11] def test_generate_primes_not_possible(): assert generate_primes(5, 15) == [] def test_generate_primes_large_value(): result = generate_primes(10, 1000) assert result == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert sum(result) == 129 def test_generate_primes_single_prime(): assert generate_primes(1, 10) == [2] def test_generate_primes_multiple_primes(): assert generate_primes(3, 10) == [2, 3, 5] def test_generate_primes_no_primes_possible(): assert generate_primes(2, 1) == [] def test_generate_primes_exactly_one_solution(): assert generate_primes(4, 17) == [2, 3, 5, 7]","solution":"from typing import List def is_prime(x: int) -> bool: if x <= 1: return False if x == 2: return True if x % 2 == 0: return False for i in range(3, int(x**0.5) + 1, 2): if x % i == 0: return False return True def generate_primes(n: int, S: int) -> List[int]: primes = [] num = 2 current_sum = 0 while len(primes) < n: if is_prime(num): if current_sum + num > S: return [] primes.append(num) current_sum += num num += 1 return primes"},{"question":"from typing import List, Tuple def find_missing_positive(arr: List[int]) -> int: Finds the smallest positive integer that is missing from the array. >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0, 3]) 4 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes a list of test cases to find the smallest missing positive integer for each. >>> process_test_cases([(5, [3, 4, -1, 1]), (4, [1, 2, 0, 3]), (5, [7, 8, 9, 10, 12]), (5, [1, 2, 3, 4, 5]), (5, [-5, -4, -3, -2, -1])]) [2, 4, 1, 6, 1]","solution":"def find_missing_positive(arr): Finds the smallest positive integer that is missing from the array \`arr\`. arr = [num for num in arr if num > 0] arr = set(arr) smallest_missing = 1 while smallest_missing in arr: smallest_missing += 1 return smallest_missing def process_test_cases(test_cases): Processes a list of test cases to find the smallest missing positive integer for each. results = [] for case in test_cases: N, arr = case result = find_missing_positive(arr) results.append(result) return results"},{"question":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list of integers. >>> longest_increasing_subsequence([10, 20, 10, 30, 20, 50]) 4 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([3, 2]) 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> longest_increasing_subsequence([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([5, 1, 6, 2, 7, 3, 8, 4]) 4 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list of integers. Uses a dynamic programming approach with binary search for efficiency. if not arr: return 0 import bisect # This will store the increasing subsequence formed so far lis = [] for num in arr: pos = bisect.bisect_left(lis, num) # If num is greater than any element in lis if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def winner(sequence_length: int) -> str: Determines the winner of the game with the given sequence length if both play optimally. Parameters: sequence_length (int): The length of the sequence of natural numbers. Returns: str: The name of the player who wins (\\"Alice\\" or \\"Bob\\"). >>> winner(3) 'Alice' >>> winner(5) 'Alice' >>> winner(2) 'Bob' >>> winner(4) 'Bob'","solution":"def winner(sequence_length): Determines the winner of the game with the given sequence length if both play optimally. Parameters: sequence_length (int): The length of the sequence of natural numbers. Returns: str: The name of the player who wins (\\"Alice\\" or \\"Bob\\"). if sequence_length % 2 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def gridland_defense(n: int) -> list: Generates an n x n grid for Gridland defense with 'X' on the border cells and '.' inside. >>> gridland_defense(3) ['XXX', 'X.X', 'XXX'] >>> gridland_defense(5) ['XXXXX', 'X...X', 'X...X', 'X...X', 'XXXXX'] >>> gridland_defense(1) ['X'] >>> gridland_defense(2) ['XX', 'XX']","solution":"def gridland_defense(n): Generates an n x n grid for Gridland defense with 'X' on the border cells and '.' inside. Args: n (int): size of the grid Returns: list: a list of strings representing the grid grid = [] for i in range(n): if i == 0 or i == n - 1: grid.append('X' * n) else: grid.append('X' + '.' * (n - 2) + 'X') return grid"},{"question":"def longest_repeated_substring(s: str) -> str: Given a string, return the longest substring which occurs more than once in that string. If there are multiple substrings with the same maximum length, return the one that appears first. The comparison should be case-sensitive. >>> longest_repeated_substring(\\"banana\\") \\"ana\\" >>> longest_repeated_substring(\\"ababc\\") \\"ab\\" >>> longest_repeated_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_repeated_substring(\\"abcdef\\") \\"\\" >>> longest_repeated_substring(\\"aAaA\\") \\"aA\\" >>> longest_repeated_substring(\\"\\") \\"\\" >>> longest_repeated_substring(\\"a\\") \\"\\" >>> longest_repeated_substring(\\"aa\\") \\"a\\" >>> longest_repeated_substring(\\"abracadabra\\") \\"abra\\"","solution":"def longest_repeated_substring(s): Returns the longest substring which occurs more than once in the string s. If there are multiple substrings with the same maximum length, return the one that appears first. The comparison is case-sensitive. n = len(s) longest_substring = \\"\\" for length in range(1, n): seen = {} for i in range(n - length + 1): substring = s[i:i+length] if substring in seen: seen[substring] += 1 else: seen[substring] = 1 if seen[substring] > 1 and len(substring) > len(longest_substring): longest_substring = substring return longest_substring"},{"question":"from typing import List def solve(lst: List[int], k: int) -> bool: Returns true if there exists a pair of integers in the list that sum up to k, else false. >>> solve([1, 2, 3, 4, 5], 9) True >>> solve([1, 2, 3, 4, 5], 10) False >>> solve([0, -1, 2, -3, 1], -1) True >>> solve([3, 5, 7, 1], 8) True pass","solution":"def solve(lst, k): Returns true if there exists a pair of integers in the list that sum up to k, else false. seen = set() for number in lst: if k - number in seen: return True seen.add(number) return False"},{"question":"def is_pangram(sentence: str) -> bool: Determines whether the input sentence is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Parameters: sentence (str): The input string containing a series of words. Returns: bool: True if the sentence is a pangram, False otherwise. Examples: >>> is_pangram(\\"the quick brown fox jumps over the lazy dog\\") == True >>> is_pangram(\\"hello world\\") == False pass def test_pangram(): assert is_pangram(\\"the quick brown fox jumps over the lazy dog\\") == True assert is_pangram(\\"sphinx of black quartz, judge my vow\\") == True assert is_pangram(\\"pack my box with five dozen liquor jugs\\") == True def test_not_pangram(): assert is_pangram(\\"hello world\\") == False assert is_pangram(\\"this is not a pangram\\") == False def test_empty_string(): assert is_pangram(\\"\\") == False def test_sentence_with_non_alpha_characters(): assert is_pangram(\\"the quick brown fox jumps over... the lazy dog!!!\\") == True assert is_pangram(\\"1234567890-=!@#%^&*()_+[];'./,<>?:\\"{}|\`~ the quick brown fox jumps over the lazy dog\\") == True def test_mixed_case_input(): assert is_pangram(\\"The Quick Brown Fox Jumps Over The Lazy Dog\\") == True assert is_pangram(\\"tHe QuIcK bRoWn FoX jUmPs OvEr ThE lAzY dOg\\") == True def test_minimum_pangram(): assert is_pangram(\\"abcdefghijklmnopqrstuvwxyz\\") == True assert is_pangram(\\"abc defghijklmnopqrstuvwxyz\\") == True","solution":"def is_pangram(sentence): Determines whether the input sentence is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Parameters: sentence (str): The input string containing a series of words. Returns: bool: True if the sentence is a pangram, False otherwise. # Define the set of all alphabet letters alphabet_set = set('abcdefghijklmnopqrstuvwxyz') # Convert sentence to lowercase and remove non-alphabet characters cleaned_sentence = ''.join([char for char in sentence.lower() if char.isalpha()]) # Create a set of characters in the cleaned sentence sentence_set = set(cleaned_sentence) # Check if the alphabet set is a subset of the sentence set return alphabet_set.issubset(sentence_set)"},{"question":"def extractPhoneNumbers(text: str) -> list[str]: Extract all valid phone numbers from the given text. Valid phone numbers follow the format (XXX) XXX-XXXX. >>> extractPhoneNumbers(\\"Call me at (123) 456-7890 or at (987) 654-3210.\\") [\\"(123) 456-7890\\", \\"(987) 654-3210\\"] >>> extractPhoneNumbers(\\"Let's meet at noon. My number is (555) 123-4567.\\") [\\"(555) 123-4567\\"] >>> extractPhoneNumbers(\\"No phone numbers here!\\") [] >>> extractPhoneNumbers(\\"Reach out anytime: (000) 111-2222 work, (333) 444-5555 cell.\\") [\\"(000) 111-2222\\", \\"(333) 444-5555\\"]","solution":"import re def extractPhoneNumbers(text): Extracts all valid phone numbers from the given text. Parameters: text (str): Input text containing potential phone numbers. Returns: list: A list containing valid phone numbers in the format (XXX) XXX-XXXX. pattern = r'(d{3}) d{3}-d{4}' return re.findall(pattern, text)"},{"question":"def isValidIPv4(s: str) -> bool: Returns true if the string s contains a valid IPv4 address, and false otherwise. >>> isValidIPv4(\\"192.168.1.1\\") True >>> isValidIPv4(\\"255.255.255.255\\") True >>> isValidIPv4(\\"0.0.0.0\\") True >>> isValidIPv4(\\"192.168.01.1\\") False >>> isValidIPv4(\\"256.256.256.256\\") False >>> isValidIPv4(\\"192.168@1.1\\") False from solution import isValidIPv4 def test_valid_ip_addresses(): assert isValidIPv4(\\"192.168.1.1\\") == True assert isValidIPv4(\\"255.255.255.255\\") == True assert isValidIPv4(\\"0.0.0.0\\") == True def test_invalid_ip_addresses(): assert isValidIPv4(\\"192.168.01.1\\") == False assert isValidIPv4(\\"256.256.256.256\\") == False assert isValidIPv4(\\"192.168@1.1\\") == False def test_invalid_format(): assert isValidIPv4(\\"192.168.1\\") == False assert isValidIPv4(\\"192.168.1.1.1\\") == False assert isValidIPv4(\\"192.168..1.1\\") == False def test_invalid_numbers(): assert isValidIPv4(\\"192.168.1.256\\") == False assert isValidIPv4(\\"192.168.-1.1\\") == False assert isValidIPv4(\\"192.168.abc.1\\") == False def test_leading_zeros(): assert isValidIPv4(\\"192.168.01.1\\") == False assert isValidIPv4(\\"192.168.00.1\\") == False","solution":"def isValidIPv4(s): Returns true if the string s contains a valid IPv4 address, and false otherwise. parts = s.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False if (part[0] == '0' and len(part) > 1) or not (0 <= int(part) <= 255): return False return True"},{"question":"from typing import List def max_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three numbers in the given list of integers. >>> max_product_of_three([1, 2, 3, 4]) 24 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([-1, -2, -3, -4]) -6 >>> max_product_of_three([-10, -10, 1, 3, 2]) 300 >>> max_product_of_three([1000, 200, 300, 10, -100, -200, -300]) 60000000 >>> max_product_of_three([1, 0, 100]) 0 >>> max_product_of_three([1, 1, 1, 1, 1]) 1 >>> max_product_of_three([0, 0, 0, 0, 0]) 0","solution":"from typing import List def max_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three numbers in the given list of integers. nums.sort() # The maximum product is either from the three largest numbers # or from the two smallest numbers (negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"from typing import List def max_product(nums: List[int]) -> int: Given an integer array nums, find a contiguous subarray that has the largest product, and return the product. Example 1: >>> max_product([2,3,-2,4]) 6 Example 2: >>> max_product([-2,0,-1]) 0 Example 3: >>> max_product([-2,3,-4]) 24 Example 4: >>> max_product([-1,-3,-10,0,60]) 60 Constraints: 1 <= nums.length <= 2 * 10^4 -10 <= nums[i] <= 10 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. pass def test_max_product_example1(): assert max_product([2,3,-2,4]) == 6 def test_max_product_example2(): assert max_product([-2,0,-1]) == 0 def test_max_product_example3(): assert max_product([-2,3,-4]) == 24 def test_max_product_example4(): assert max_product([-1,-3,-10,0,60]) == 60 def test_max_product_single_element(): assert max_product([5]) == 5 def test_max_product_all_negative(): assert max_product([-1,-3,-5,-6]) == 90 def test_max_product_mix_of_pos_and_neg(): assert max_product([1, -2, -3, 0, 7, -8, -2]) == 112 def test_max_product_multiple_zeros(): assert max_product([0, 2, 0, 3, 0, -2, 4, 0]) == 4 def test_max_product_start_with_negative(): assert max_product([-3, 4, 3]) == 12","solution":"def max_product(nums): Returns the maximum product of a contiguous subarray. if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"def longest_subarray_with_limit(nums: List[int], k: int) -> int: Given an array of integers, find the length of the longest contiguous subarray where the difference between the maximum and minimum elements in that subarray is less than or equal to a given integer k. >>> longest_subarray_with_limit([1, 3, 2, 4, 3, 5], 2) 4 >>> longest_subarray_with_limit([10, 5, 6, 8, 3], 3) 3 >>> longest_subarray_with_limit([1], 0) 1 >>> longest_subarray_with_limit([2, 2, 2, 2], 0) 4 >>> longest_subarray_with_limit([1, 3, 2, -1, 4, 5], 10) 6 >>> longest_subarray_with_limit([1, 10, 1, 10], 0) 1 >>> longest_subarray_with_limit([1, 2, 3, 4, 5], 1) 2","solution":"def longest_subarray_with_limit(nums, k): max_length = 0 start = 0 max_elem = min_elem = nums[0] for end in range(len(nums)): max_elem = max(max_elem, nums[end]) min_elem = min(min_elem, nums[end]) while max_elem - min_elem > k: start += 1 max_elem = max(nums[start:end+1]) min_elem = min(nums[start:end+1]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"import re from collections import Counter from typing import List def most_frequent_word(paragraph: str) -> str: Given a string that represents a paragraph, write a function that identifies and returns the word with the highest frequency. If there are multiple words with the same highest frequency, return the word that appears first in the paragraph. The function should ignore punctuation and be case-insensitive. >>> most_frequent_word(\\"Hello world! This is a test. Hello everyone. This test is simple.\\") 'hello' >>> most_frequent_word(\\"One fish two fish red fish blue fish.\\") 'fish' >>> most_frequent_word(\\"To be or not to be that is the question.\\") 'to' >>> most_frequent_word(\\"This! This, THIS. this?\\") 'this' >>> most_frequent_word(\\"Each word in this sentence is unique.\\") >>> result = most_frequent_word(\\"Each word in this sentence is unique.\\") >>> result in [\\"each\\", \\"word\\", \\"in\\", \\"this\\", \\"sentence\\", \\"is\\", \\"unique.\\"] True","solution":"import re from collections import Counter def most_frequent_word(paragraph): Returns the word with the highest frequency in the given paragraph. If there are multiple words with the same highest frequency, returns the word that appears first in the paragraph. # Normalize the paragraph: lowercase and remove punctuation cleaned_paragraph = re.sub(r'[^ws]', '', paragraph.lower()) # Split the paragraph into words words = cleaned_paragraph.split() # Count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency max_frequency = max(word_counts.values()) for word in words: if word_counts[word] == max_frequency: return word"},{"question":"def calculate_commission(sales_amount: float, sales_type: str) -> float: Calculate the commission based on the sales amount and type. The function accepts the total sales amount and the type of sales (\\"hardware\\" or \\"software\\"). Returns the commission amount based on the sales type: - For hardware sales, the commission is 10% of the sales amount. - For software sales, the commission is 15% of the sales amount. - No commission is calculated for an invalid or unspecified sales type, and the function should return 0 in such cases. >>> calculate_commission(1000, 'hardware') == 100.0 >>> calculate_commission(1000, 'software') == 150.0 >>> calculate_commission(2000, 'hardware') == 200.0 >>> calculate_commission(2000, 'software') == 300.0 >>> calculate_commission(1000, 'accessories') == 0 >>> calculate_commission(1000, 'food') == 0 >>> calculate_commission(1000, '') == 0 >>> calculate_commission(1000, None) == 0 >>> calculate_commission(0, 'hardware') == 0 >>> calculate_commission(0, 'software') == 0","solution":"def calculate_commission(sales_amount, sales_type): Calculate the commission based on the sales amount and type. Parameters: sales_amount (float): The total sales amount. sales_type (str): The type of sales (\\"hardware\\" or \\"software\\"). Returns: float: The commission amount. if sales_type == 'hardware': return sales_amount * 0.10 elif sales_type == 'software': return sales_amount * 0.15 else: return 0"},{"question":"def max_happiness(t, test_cases): Returns the maximum possible sum of happiness for any contiguous subarray of days for given test cases. Uses Kadane's Algorithm to solve the problem efficiently. pass # Unit Test def test_example_cases(): test_cases = [ (9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (5, [1, 2, 3, 4, 5]), (4, [-1, -2, -3, -4]) ] results = max_happiness(3, test_cases) assert results[0] == 6 assert results[1] == 15 assert results[2] == -1 def test_single_element_cases(): test_cases = [ (1, [5]), (1, [-5]) ] results = max_happiness(2, test_cases) assert results[0] == 5 assert results[1] == -5 def test_all_negative_cases(): test_cases = [ (3, [-5, -1, -8]) ] results = max_happiness(1, test_cases) assert results[0] == -1 def test_mixed_sign_cases(): test_cases = [ (5, [3, -2, 5, -1, 2]), (6, [8, -19, 5, -4, 20, -7]) ] results = max_happiness(2, test_cases) assert results[0] == 7 assert results[1] == 21 def test_all_positive_cases(): test_cases = [ (4, [1, 2, 3, 4]) ] results = max_happiness(1, test_cases) assert results[0] == 10 def test_large_input_size(): test_cases = [ (1000, [i for i in range(1000)]) ] results = max_happiness(1, test_cases) assert results[0] == sum(range(1000))","solution":"def max_happiness(t, test_cases): Returns the maximum possible sum of happiness for any contiguous subarray of days for given test cases. Uses Kadane's Algorithm to solve the problem efficiently. results = [] for i in range(t): n = test_cases[i][0] h = test_cases[i][1] max_current = max_global = h[0] for j in range(1, n): max_current = max(h[j], max_current + h[j]) if max_current > max_global: max_global = max_current results.append(max_global) return results"},{"question":"def longest_increasing_subsequence_length(arr): Determines the length of the longest contiguous subsequence with strictly increasing values. >>> longest_increasing_subsequence_length([]) == 0 >>> longest_increasing_subsequence_length([1]) == 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence_length([1, 3, 2, 3, 4, 1, 2]) == 3 >>> longest_increasing_subsequence_length([1, 2, 2, 3, 4]) == 3 >>> longest_increasing_subsequence_length([1, 2, 1, 2, 3, 1]) == 3","solution":"def longest_increasing_subsequence_length(arr): Determines the length of the longest contiguous subsequence with strictly increasing values. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> int: Returns the maximum possible sum of any subarray in arr. >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, output the maximum sum of any subarray for the given array. >>> solve(3, [(5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4]), (6, [-2, -3, 4, -1, -2, 1, 5, -3])]) [9, -1, 7]","solution":"def max_subarray_sum(arr): Returns the maximum possible sum of any subarray in arr. max_so_far = arr[0] current_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) max_so_far = max(max_so_far, current_max) return max_so_far def solve(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] results.append(max_subarray_sum(array)) return results"},{"question":"def lexicographically_smallest_string(t: int, strings: List[str]) -> List[str]: Returns the lexicographically smallest string possible after performing any number of the described operations on the given strings. >>> lexicographically_smallest_string(3, [\\"cba\\", \\"acbd\\", \\"abc\\"]) ['a', 'a', 'a'] >>> lexicographically_smallest_string(2, [\\"b\\", \\"dcb\\"]) ['b', 'b'] >>> lexicographically_smallest_string(1, [\\"fghijklmnopqrstuvwxyz\\"]) ['f']","solution":"def lexicographically_smallest_string(t, strings): Returns the lexicographically smallest string possible after performing any number of the described operations on the given strings. :param t: Number of test cases :param strings: List of test case strings :return: List of lexicographically smallest strings for each test case # The result for each string will always be 'a' if there's at least one 'a', # otherwise, it will be the smallest character in the string. results = [] for s in strings: smallest_char = min(s) results.append(smallest_char) return results"},{"question":"def min_operations_to_transform(arr1: List[int], arr2: List[int]) -> int: Returns the minimum number of subarray reversals required to transform arr1 into arr2. Returns -1 if it's not possible. >>> min_operations_to_transform([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 1 >>> min_operations_to_transform([1, 3, 2], [2, 1, 3]) 2 >>> min_operations_to_transform([1, 2, 3], [1, 2, 3]) 0 >>> min_operations_to_transform([1, 2, 3], [3, 2, 1]) 1 >>> min_operations_to_transform([1, 2, 3], [3, 2, 4]) -1 pass def solve(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: For each test case, determine the minimum number of operations required to transform arr1 into arr2. If it is not possible, return -1. >>> solve(2, [(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]), (3, [1, 3, 2], [2, 1, 3])]) [1, 2] pass","solution":"def min_operations_to_transform(arr1, arr2): Returns the minimum number of subarray reversals required to transform arr1 into arr2. Returns -1 if it's not possible. if sorted(arr1) != sorted(arr2): return -1 n = len(arr1) operations = 0 i = 0 while i < n: if arr1[i] != arr2[i]: j = i while j < n and arr1[j] != arr2[i]: j += 1 if j < n: arr1[i:j+1] = reversed(arr1[i:j+1]) operations += 1 i += 1 return operations def solve(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] arr1 = test_cases[t][1] arr2 = test_cases[t][2] results.append(min_operations_to_transform(arr1, arr2)) return results"},{"question":"def longest_subarray_with_sum(nums: List[int], k: int) -> int: Returns the length of the longest subarray whose sum is equal to k. >>> longest_subarray_with_sum([10, 5, 2, 7, 1], 15) 4 >>> longest_subarray_with_sum([-1, 1, 2, -3, 3, -1], 0) 3 >>> longest_subarray_with_sum([1, 2, 3], 7) 0 >>> longest_subarray_with_sum([7], 7) 1 >>> longest_subarray_with_sum([7], 0) 0 >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_with_sum([1000] * 100000, 1000) 1 >>> longest_subarray_with_sum([1000] * 100000, 1000000) 1000","solution":"def longest_subarray_with_sum(nums, k): Returns the length of the longest subarray whose sum is equal to k. prefix_sum_map = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == k: max_length = i + 1 if (current_sum - k) in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[current_sum - k]) if current_sum not in prefix_sum_map: prefix_sum_map[current_sum] = i return max_length"},{"question":"def can_win_game(n: int) -> bool: Determine if the starting player can always win the game given \`n\` stones. >>> can_win_game(1) True >>> can_win_game(2) True >>> can_win_game(3) True >>> can_win_game(4) False >>> can_win_game(5) True >>> can_win_game(6) True >>> can_win_game(7) True >>> can_win_game(8) False >>> can_win_game(9999) True >>> can_win_game(10000) False","solution":"def can_win_game(n): Determine if the starting player can always win the game given \`n\` stones. return n % 4 != 0"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1, l2): Merges two sorted linked lists and returns it as a new sorted list. pass def list_to_linked_list(lst): Converts a list to a linked list. dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linked_list_to_list(node): Converts a linked list to a list. lst = [] while node: lst.append(node.val) node = node.next return lst def merge_two_lists_list(l1, l2): Helper function to merge two lists instead of linked lists for easier testing. linked_list_1 = list_to_linked_list(l1) linked_list_2 = list_to_linked_list(l2) merged_linked_list = merge_two_lists(linked_list_1, linked_list_2) return linked_list_to_list(merged_linked_list) # Test cases def test_merge_two_lists_example_1(): assert merge_two_lists_list([1, 2, 4], [1, 3, 4]) == [1, 1, 2, 3, 4, 4] def test_merge_two_lists_example_2(): assert merge_two_lists_list([2, 6, 8], [1, 3, 4]) == [1, 2, 3, 4, 6, 8] def test_merge_two_lists_example_3(): assert merge_two_lists_list([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_two_lists_example_4(): assert merge_two_lists_list([], [0]) == [0] def test_merge_two_lists_empty_lists(): assert merge_two_lists_list([], []) == [] def test_merge_two_lists_first_empty(): assert merge_two_lists_list([], [1, 2, 3]) == [1, 2, 3] def test_merge_two_lists_second_empty(): assert merge_two_lists_list([1, 2, 3], []) == [1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1, l2): Merges two sorted linked lists and returns it as a new sorted list. dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next def list_to_linked_list(lst): Converts a list to a linked list. dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linked_list_to_list(node): Converts a linked list to a list. lst = [] while node: lst.append(node.val) node = node.next return lst def merge_two_lists_list(l1, l2): Helper function to merge two lists instead of linked lists for easier testing. linked_list_1 = list_to_linked_list(l1) linked_list_2 = list_to_linked_list(l2) merged_linked_list = merge_two_lists(linked_list_1, linked_list_2) return linked_list_to_list(merged_linked_list)"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Given an array of integers, return true if the array contains a pair of elements that sum up to a specific target number, and false otherwise. You can assume that each input will have at most one such pair. >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True pass def test_has_pair_with_sum_true(): assert has_pair_with_sum([1, 2, 4, 4], 8) == True def test_has_pair_with_sum_false(): assert has_pair_with_sum([1, 2, 3, 9], 8) == False def test_has_pair_with_sum_single_pair(): assert has_pair_with_sum([5, 1, 3, 7], 10) == True def test_has_pair_with_sum_zero_target(): assert has_pair_with_sum([-3, 1, 3, 4], 0) == True def test_has_pair_with_sum_negative_numbers(): assert has_pair_with_sum([-2, 3, 7, 4], 1) == True def test_has_pair_with_sum_multiple_pairs(): assert has_pair_with_sum([1, 2, 2, 4, 7], 9) == True def test_has_pair_with_sum_empty_list(): assert has_pair_with_sum([], 5) == False def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([5], 5) == False def test_has_pair_with_sum_duplicates(): assert has_pair_with_sum([1, 2, 4, 4, 2], 6) == True","solution":"def has_pair_with_sum(arr, target): Returns true if there exists a pair of numbers in the array that add up to the target sum. Otherwise, returns false. :param arr: List[int] - A list of integers representing the array. :param target: int - An integer representing the target sum. :return: bool seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def max_non_overlapping_events(events, queries): Determine the maximum number of non-overlapping events that can be attended excluding the busy interval. Args: events: List of tuples, where each tuple contains two integers representing the start and end times of an event. queries: List of tuples, where each tuple contains two integers representing the start and end times of the busy interval. Returns: List of integers representing the maximum number of non-overlapping events for each query. Examples: >>> max_non_overlapping_events([(1, 3), (2, 6), (8, 10), (3, 5), (7, 9)], [(1, 3)]) [2] >>> max_non_overlapping_events([(1, 3), (2, 6), (8, 10), (3, 5), (7, 9)], [(2, 8)]) [1] def test_single_event_no_overlap(): assert max_non_overlapping_events([(1, 2)], [(0, 1)]) == [1] def test_single_event_total_overlap(): assert max_non_overlapping_events([(1, 2)], [(1, 2)]) == [0] def test_multiple_events_with_small_interval(): assert max_non_overlapping_events([(1, 3), (2, 6), (8, 10), (3, 5), (7, 9)], [(1, 3)]) == [2] def test_multiple_events_with_large_interval(): assert max_non_overlapping_events([(1, 3), (2, 6), (8, 10), (3, 5), (7, 9)], [(2, 8)]) == [1] def test_no_events(): assert max_non_overlapping_events([], [(1, 3)]) == [0] def test_multiple_queries(): events = [(1, 3), (2, 6), (8, 10), (3, 5), (7, 9)] queries = [(1, 3), (2, 8)] assert max_non_overlapping_events(events, queries) == [2, 1]","solution":"def max_non_overlapping_events(events, queries): def filter_events(events, busy_start, busy_end): return [(start, end) for start, end in events if end <= busy_start or start >= busy_end] def max_non_overlapping(filtered_events): filtered_events.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in filtered_events: if start >= last_end_time: count += 1 last_end_time = end return count results = [] for busy_start, busy_end in queries: filtered_events = filter_events(events, busy_start, busy_end) results.append(max_non_overlapping(filtered_events)) return results"},{"question":"def filter_primes(lst: List[int]) -> List[int]: Returns a new list containing only the elements that are prime numbers. >>> filter_primes([3, 4, 7, 10, 11]) [3, 7, 11] >>> filter_primes([1, 4, 6, 8, 9, 10, 12, 14]) [] >>> filter_primes([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_primes(lst): Returns a new list containing only the elements of lst that are prime numbers. return [x for x in lst if is_prime(x)]"},{"question":"[Completion Task in Python] def remove_vowels(input_string: str) -> str: Write a function that takes a string as input and returns the string with all the vowels (a, e, i, o, u) removed. >>> remove_vowels(\\"hello world\\") \\"hll wrld\\" >>> remove_vowels(\\"bcdfgh\\") \\"bcdfgh\\" >>> remove_vowels(\\"aeiou\\") \\"\\" >>> remove_vowels(\\"HeLLo WoRLd\\") \\"HLL WRLd\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"143#@\\") \\"143#@\\"","solution":"def remove_vowels(input_string): Returns the input_string with all vowels (a, e, i, o, u) removed. vowels = \\"aeiouAEIOU\\" return ''.join(char for char in input_string if char not in vowels)"},{"question":"import random from typing import List def reverse_with_typo(s: str) -> str: Simulates Yuki's typing by reversing each word in the string and swapping one adjacent pair of characters within one word. >>> reverse_with_typo(\\"hello\\") 'ehllo' >>> reverse_with_typo(\\"hello world\\") 'olleh wlrod' def test_reverse_with_typo_single_word(): result = reverse_with_typo(\\"hello\\") assert result != \\"hello\\" and result != \\"olleh\\" def test_reverse_with_typo_multi_words(): result = reverse_with_typo(\\"hello world\\") words = result.split() assert len(words) == 2 assert words[0] != \\"hello\\" and words[1] != \\"world\\" assert words[0] == \\"olleh\\" or \\"world\\" assert words[1] == \\"dlrow\\" or \\"hello\\" def test_reverse_with_typo_known_output(): input_str = \\"abcd efgh\\" result = reverse_with_typo(input_str) assert 'dcab' in result or 'ghfe' in result def test_reverse_with_typo_length_check(): result = reverse_with_typo(\\"abcdef ghijkl\\") words = result.split() assert len(words[0]) == 6 and len(words[1]) == 6","solution":"import random def reverse_with_typo(s): words = s.split() reversed_words = [word[::-1] for word in words] # Choose one word randomly word_index = random.randint(0, len(reversed_words) - 1) typo_word = list(reversed_words[word_index]) # If the word has more than one character, swap a random adjacent pair of characters if len(typo_word) > 1: char_index = random.randint(0, len(typo_word) - 2) typo_word[char_index], typo_word[char_index + 1] = typo_word[char_index + 1], typo_word[char_index] reversed_words[word_index] = ''.join(typo_word) return ' '.join(reversed_words)"},{"question":"def cook_dish(steps: List[str]) -> str: Simulate a simplified cooking procedure in a kitchen. The function processes a list of cooking steps in order and determines the final state of the dish being cooked. Cooking steps can be: 1. \\"add <ingredient>\\" - adds the specified ingredient to the dish. 2. \\"cook <time>\\" - cooks the dish for the specified time in minutes. 3. \\"serve\\" - serves the dish, outputting the final state. Args: steps (List[str]): A list of cooking steps to interpret. Returns: str: A string representing the final state of the dish after all commands have been processed. Examples: >>> cook_dish(['add tomato', 'add pasta', 'cook 10', 'add cheese', 'cook 5', 'serve']) 'tomato, pasta, cheese (cooked for 15 minutes)' >>> cook_dish(['add potato', 'add salt', 'cook 20', 'cook 10', 'serve']) 'potato, salt (cooked for 30 minutes)' >>> cook_dish(['cook 10', 'add chicken', 'serve']) 'chicken (cooked for 10 minutes)' from typing import List def test_no_steps(): assert cook_dish([]) == \\"No steps provided\\" def test_no_serve(): assert cook_dish(['add tomato', 'cook 10', 'add cheese']) == \\"Cooking not complete\\" def test_serve_without_adding_ingredients(): assert cook_dish(['cook 5', 'serve']) == \\" (cooked for 5 minutes)\\" def test_basic_cooking(): assert cook_dish(['add tomato', 'cook 10', 'add cheese', 'serve']) == \\"tomato, cheese (cooked for 10 minutes)\\" def test_multiple_cook_steps(): assert cook_dish(['add tomato', 'cook 10', 'add cheese', 'cook 5', 'serve']) == \\"tomato, cheese (cooked for 15 minutes)\\" def test_ingredients_after_cooking(): assert cook_dish(['cook 10', 'add tomato', 'serve']) == \\"tomato (cooked for 10 minutes)\\" def test_example_1(): steps = ['add tomato', 'add pasta', 'cook 10', 'add cheese', 'cook 5', 'serve'] assert cook_dish(steps) == \\"tomato, pasta, cheese (cooked for 15 minutes)\\" def test_example_2(): steps = ['add potato', 'add salt', 'cook 20', 'cook 10', 'serve'] assert cook_dish(steps) == \\"potato, salt (cooked for 30 minutes)\\" def test_example_3(): steps = ['cook 10', 'add chicken', 'serve'] assert cook_dish(steps) == \\"chicken (cooked for 10 minutes)\\"","solution":"def cook_dish(steps): if not steps: return \\"No steps provided\\" ingredients = [] total_cooking_time = 0 serve = False for step in steps: if step.startswith(\\"add \\"): ingredient = step[4:] ingredients.append(ingredient) elif step.startswith(\\"cook \\"): cook_time = int(step[5:]) total_cooking_time += cook_time elif step == \\"serve\\": serve = True if not serve: return \\"Cooking not complete\\" ingredients_str = \\", \\".join(ingredients) return f\\"{ingredients_str} (cooked for {total_cooking_time} minutes)\\""},{"question":"def reorder_even_before_odd(nums: List[int]) -> List[int]: Reorders the list such that all even integers come before all odd integers while maintaining the relative order of the even and odd integers. :param nums: List of integers :return: List of integers with all even numbers first and odd numbers last, preserving their relative order. >>> reorder_even_before_odd([3, 1, 2, 4]) [2, 4, 3, 1] >>> reorder_even_before_odd([0, 1, 2]) [0, 2, 1] >>> reorder_even_before_odd([7, 8, 5, 6, 4, 3]) [8, 6, 4, 7, 5, 3] >>> reorder_even_before_odd([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> reorder_even_before_odd([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> reorder_even_before_odd([-1, -2, 3, 4]) [-2, 4, -1, 3] >>> reorder_even_before_odd([]) [] >>> reorder_even_before_odd([1]) [1] >>> reorder_even_before_odd([2]) [2] >>> reorder_even_before_odd([10**6, 10**6+1, -10**6, -10**6+1]) [1000000, -1000000, 1000001, -1000001]","solution":"def reorder_even_before_odd(nums): Reorders the list such that all even integers come before all odd integers while maintaining the relative order of the even and odd integers. :param nums: List of integers :return: List of integers with all even numbers first and odd numbers last, preserving their relative order. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def wordBreak(s, wordDict): Check if the input string can be segmented into a space-separated sequence of one or more dictionary words. >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) \\"true\\" >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) \\"true\\" >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) \\"false\\"","solution":"def wordBreak(s, wordDict): Check if the input string can be segmented into space-separated sequence of one or more dictionary words. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"true\\" if dp[-1] else \\"false\\""},{"question":"def max_non_adjacent_sum(lst): Given a list of integers, returns the maximum sum of a non-empty subsequence such that no two elements in the subsequence are adjacent in the original list. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) == 13 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 >>> max_non_adjacent_sum([1, 2, 3]) == 4 >>> max_non_adjacent_sum([1, 20, 3]) == 20 # Your implementation here pass","solution":"def max_non_adjacent_sum(lst): if not lst: return 0 prev_max = 0 curr_max = 0 for num in lst: new_max = max(curr_max, prev_max + num) prev_max = curr_max curr_max = new_max return curr_max"},{"question":"from typing import List def find_most_stable_item(prices: List[List[int]]) -> int: Takes a nested list where each list contains prices of an item over several days. Returns the 1-based index of the item with the minimum standard deviation in its recorded prices. >>> find_most_stable_item([[10, 15, 10, 20], [5, 4, 5, 6], [10, 10, 10, 10]]) == 3 >>> find_most_stable_item([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 1 >>> find_most_stable_item([[1, 2, 1, 2], [100, 100, 100, 100, 100, 100], [50, 50, 50, 50]]) == 2 >>> find_most_stable_item([[20, 20, 20, 20]]) == 1 >>> find_most_stable_item([[3, 3, 3, 3], [5, 5, 5, 5], [7, 7, 7, 7]]) == 1","solution":"import math def find_most_stable_item(prices): Takes a nested list where each list contains prices of an item over several days. Returns the 1-based index of the item with the minimum standard deviation in its recorded prices. def standard_deviation(price_list): mean = sum(price_list) / len(price_list) variance = sum((x - mean) ** 2 for x in price_list) / len(price_list) return math.sqrt(variance) min_sd = float('inf') min_index = -1 for i, price_list in enumerate(prices): sd = standard_deviation(price_list) if sd < min_sd: min_sd = sd min_index = i return min_index + 1 # 1-based index"},{"question":"def unique_elements(lst: List[int]) -> List[int]: Filters out unique elements from a list based on their first and last appearance, preserving the order. If an element appears more than once, it is not included in the result. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A new list containing only the unique elements. >>> unique_elements([1, 3, 2, 3, 4, 1, 5, 6, 2]) [4, 5, 6] >>> unique_elements([1, 1, 2, 2]) []","solution":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Filters out unique elements in the list preserving the order of their first appearance. If an element appears more than once, it is not included in the result. count_dict = {} for num in lst: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 result = [num for num in lst if count_dict[num] == 1] return result"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. >>> unique_paths_with_obstacles([ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ]) == 2 >>> unique_paths_with_obstacles([ >>> [0, 1], >>> [0, 0] >>> ]) == 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. m, n = len(grid), len(grid[0]) # If the starting or ending cell is blocked, return 0 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a 2D dp array with 0's dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill dp array for i in range(m): for j in range(n): if grid[i][j] == 1: # If it's an obstacle, continue continue if i > 0: # Check from top dp[i][j] += dp[i-1][j] if j > 0: # Check from left dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_sum_subarray(nums, k): Finds the maximum possible sum of a subarray with at most k distinct elements. Parameters: nums (list of int): The input array of integers. k (int): The maximum number of distinct elements allowed in the subarray. Returns: int: The maximum possible sum of the subarray. Example: >>> max_sum_subarray([1, 2, 1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([], 2) 0 >>> max_sum_subarray([1, 2, 1, 2, 3, 4, 5], 0) 0 >>> max_sum_subarray([10], 1) 10 >>> max_sum_subarray([4, 4, 4, 4, 4], 1) 20 >>> max_sum_subarray([5, 1, 5, 1], 2) 12 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([3, 1, 4, 1, 5, 9], 3) 15","solution":"from collections import defaultdict def max_sum_subarray(nums, k): Finds the maximum possible sum of a subarray with at most k distinct elements. Parameters: nums (list of int): The input array of integers. k (int): The maximum number of distinct elements allowed in the subarray. Returns: int: The maximum possible sum of the subarray. n = len(nums) if n == 0 or k == 0: return 0 left = 0 right = 0 max_sum = 0 current_sum = 0 count = defaultdict(int) while right < n: count[nums[right]] += 1 current_sum += nums[right] while len(count) > k: count[nums[left]] -= 1 current_sum -= nums[left] if count[nums[left]] == 0: del count[nums[left]] left += 1 max_sum = max(max_sum, current_sum) right += 1 return max_sum"},{"question":"def compress_string(s: str) -> str: Compress the given string by representing consecutive repeating characters using their count followed by the character. >>> compress_string(\\"aabbccc\\") == \\"2a2b3c\\" >>> compress_string(\\"abcd\\") == \\"abcd\\" >>> compress_string(\\"aaabbbccc\\") == \\"3a3b3c\\" >>> compress_string(\\"aaabbccaaaaa\\") == \\"3a2b2c5a\\" pass # Please write your implementation here def compress_strings(strings: List[str]) -> List[str]: Takes a list of strings and returns a list of their compressed versions. >>> compress_strings([\\"aabbccc\\", \\"abcd\\"]) == [\\"2a2b3c\\", \\"abcd\\"] >>> compress_strings([\\"aaaa\\", \\"bbbbb\\", \\"cccccc\\"]) == [\\"4a\\", \\"5b\\", \\"6c\\"] >>> compress_strings([\\"a\\", \\"bb\\", \\"ccc\\"]) == [\\"a\\", \\"2b\\", \\"3c\\"] >>> compress_strings([\\"aabbccc\\", \\"abcd\\", \\"aaaa\\", \\"bbbb\\"]) == [\\"2a2b3c\\", \\"abcd\\", \\"4a\\", \\"4b\\"] pass # Please write your implementation here","solution":"def compress_string(s): Compress the given string by representing consecutive repeating characters using their count followed by the character. compressed = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 if count > 1: compressed.append(f\\"{count}{s[i]}\\") else: compressed.append(s[i]) i += 1 return ''.join(compressed) def compress_strings(strings): Takes a list of strings and returns a list of their compressed versions. return [compress_string(s) for s in strings]"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Find the minimum path sum from the top-left to the bottom-right corner of the grid. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([ ... [1], ... [2], ... [3] ... ]) 6 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> min_path_sum([[0]]) 0","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: rows = len(grid) cols = len(grid[0]) # Initialize the DP table with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] # Base case: the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column (can only come from above) for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the DP table for row in range(1, rows): for col in range(1, cols): dp[row][col] = min(dp[row - 1][col], dp[row][col - 1]) + grid[row][col] # The bottom right corner will contain the minimum path sum return dp[rows - 1][cols - 1]"},{"question":"def merge_events(events_log): Merges all the events from multiple users into a single chronological list. :param events_log: List of dictionaries containing userId and their events. :return: List of merged events in chronological order. >>> merge_events([ ... {\\"userId\\": \\"user1\\", \\"events\\": [\\"play:1000\\", \\"pause:5000\\", \\"play:8000\\"]} ... ]) [\\"user1:play:1000\\", \\"user1:pause:5000\\", \\"user1:play:8000\\"] >>> merge_events([ ... {\\"userId\\": \\"user1\\", \\"events\\": [\\"play:1000\\", \\"pause:5000\\", \\"play:8000\\"]}, ... {\\"userId\\": \\"user2\\", \\"events\\": [\\"play:2000\\", \\"pause:9000\\", \\"stop:10000\\"]} ... ]) [\\"user1:play:1000\\", \\"user2:play:2000\\", \\"user1:pause:5000\\", \\"user1:play:8000\\", \\"user2:pause:9000\\", \\"user2:stop:10000\\"] >>> merge_events([]) [] >>> merge_events([ ... {\\"userId\\": \\"user1\\", \\"events\\": [\\"pause:1000\\"]}, ... {\\"userId\\": \\"user2\\", \\"events\\": [\\"play:1000\\"]} ... ]) [\\"user1:pause:1000\\", \\"user2:play:1000\\"]","solution":"def merge_events(events_log): Merges all the events from multiple users into a single chronological list. :param events_log: List of dictionaries containing userId and their events. :return: List of merged events in chronological order. merged_events = [] for user in events_log: user_id = user['userId'] for event in user['events']: event_name, timestamp = event.split(':') merged_events.append((int(timestamp), f\\"{user_id}:{event_name}:{timestamp}\\")) # Sort events based on their timestamp (first element of the tuple) merged_events.sort(key=lambda x: x[0]) # Return the sorted event strings return [event[1] for event in merged_events]"},{"question":"def isValid(brackets: str) -> bool: Determine if all the brackets in the string form a valid combination (balanced parentheses). >>> isValid(\\"()\\") == True >>> isValid(\\"(()(()))\\") == True >>> isValid(\\"(()\\") == False >>> isValid(\\"())(\\") == False","solution":"def isValid(brackets): Returns True if the input string brackets consists of balanced and correctly ordered parentheses. # Initialize a counter to keep track of open brackets balance = 0 for char in brackets: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance goes negative, we have more closing than opening if balance < 0: return False # If balance is zero, all opening brackets have matching closing brackets return balance == 0"},{"question":"def movePlayer(currentRoom, direction): Move player to a new room based on the current room and direction. :param currentRoom: int, the current room ID :param direction: str, direction to move (\\"north\\", \\"south\\", \\"east\\", or \\"west\\") :return: int, new room ID or str, \\"Move not possible\\" if the move can't be made Examples: >>> movePlayer(1, \\"north\\") 2 >>> movePlayer(1, \\"south\\") \\"Move not possible\\"","solution":"def movePlayer(currentRoom, direction): Move player to a new room based on the current room and direction. :param currentRoom: int, the current room ID :param direction: str, direction to move (\\"north\\", \\"south\\", \\"east\\", or \\"west\\") :return: int, new room ID or str, \\"Move not possible\\" if the move can't be made rooms = { 1: {\\"north\\": 2, \\"east\\": 3}, 2: {\\"south\\": 1}, 3: {\\"west\\": 1} } if currentRoom in rooms and direction in rooms[currentRoom]: return rooms[currentRoom][direction] else: return \\"Move not possible\\""},{"question":"def sum_even_numbers(num: int) -> int: Returns the sum of all even numbers between 1 and num (inclusive). >>> sum_even_numbers(10) 30 >>> sum_even_numbers(1) 0 >>> sum_even_numbers(2) 2 >>> sum_even_numbers(1000) 250500 >>> sum_even_numbers(15) 56 >>> sum_even_numbers(20) 110 >>> sum_even_numbers(25) 156","solution":"def sum_even_numbers(num): Returns the sum of all even numbers between 1 and num (inclusive). return sum(i for i in range(1, num + 1) if i % 2 == 0)"},{"question":"from typing import List, Tuple def find_pairs(lst: List[int], n: int) -> List[Tuple[int, int]]: Write a function that takes a list of integers and an integer \`n\` as its parameters. The function should find all pairs of integers in the list that add up to \`n\` and return them as a list of tuples. Each pair should be sorted in ascending order, and the resulting list of tuples should not contain duplicates. >>> find_pairs([1, 2, 3, 4, 3, 5], 6) [(1, 5), (2, 4), (3, 3)] >>> find_pairs([1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs([1, 2, 3, 4], 8) [] >>> find_pairs([1, 3, 2, 2, 4, 4], 6) [(2, 4)] >>> find_pairs([1, -2, 3, -4, 2, 3], 1) [(-2, 3)] def test_find_pairs(): assert find_pairs([1, 2, 3, 4, 3, 5], 6) == [(1, 5), (2, 4), (3, 3)] assert find_pairs([1, 1, 1, 1], 2) == [(1, 1)] assert find_pairs([1, 2, 3, 4], 8) == [] assert find_pairs([1, 3, 2, 2, 4, 4], 6) == [(2, 4)] assert find_pairs([1, -2, 3, -4, 2, 3], 1) == [(-2, 3)] def test_find_pairs_empty(): assert find_pairs([], 5) == [] def test_find_pairs_no_pairs(): assert find_pairs([1, 2, 3, 9], 15) == []","solution":"from typing import List, Tuple def find_pairs(lst: List[int], n: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for number in lst: target = n - number if target in seen: pairs.add(tuple(sorted((number, target)))) seen.add(number) return sorted(list(pairs))"},{"question":"def is_valid_dna(sequence: str) -> str: Determines if the given DNA sequence is valid. A valid DNA sequence has equal number of 'A' and 'T' characters as well as equal number of 'C' and 'G' characters. >>> is_valid_dna(\\"ATCG\\") == \\"valid\\" >>> is_valid_dna(\\"AATTCCGG\\") == \\"valid\\" >>> is_valid_dna(\\"AACCGGTT\\") == \\"valid\\" >>> is_valid_dna(\\"ATC\\") == \\"invalid\\" >>> is_valid_dna(\\"AATTCGG\\") == \\"invalid\\" >>> is_valid_dna(\\"AACCGGT\\") == \\"invalid\\" >>> is_valid_dna(\\"CGAT\\") == \\"valid\\" >>> is_valid_dna(\\"CAGTACGT\\") == \\"valid\\" >>> is_valid_dna(\\"CGGTAAC\\") == \\"invalid\\" >>> is_valid_dna(\\"AT\\") == \\"valid\\" >>> is_valid_dna(\\"CG\\") == \\"valid\\" >>> is_valid_dna(\\"A\\") == \\"invalid\\" >>> is_valid_dna(\\"C\\") == \\"invalid\\"","solution":"def is_valid_dna(sequence): Determines if the given DNA sequence is valid. A valid DNA sequence has equal number of 'A' and 'T' characters as well as equal number of 'C' and 'G' characters. Parameters: sequence (str): The DNA sequence to check. Returns: str: \\"valid\\" if the DNA sequence is valid, otherwise \\"invalid\\". a_count = sequence.count('A') t_count = sequence.count('T') c_count = sequence.count('C') g_count = sequence.count('G') if a_count == t_count and c_count == g_count: return \\"valid\\" else: return \\"invalid\\""},{"question":"def count_consecutive(s: str) -> list: Returns a list of tuples where each tuple contains a character and the number of times it appears consecutively in the string. >>> count_consecutive(\\"aabbcc\\") [('a', 2), ('b', 2), ('c', 2)] >>> count_consecutive(\\"aaabbccaa\\") [('a', 3), ('b', 2), ('c', 2), ('a', 2)] >>> count_consecutive(\\"abc\\") [('a', 1), ('b', 1), ('c', 1)] >>> count_consecutive(\\"aaaa\\") [('a', 4)] >>> count_consecutive(\\"\\") []","solution":"def count_consecutive(s): Returns a list of tuples where each tuple contains a character and the number of times it appears consecutively in the string. :param s: string comprised of lowercase letters :type s: str :return: list of tuples :rtype: list if not s: return [] result = [] prev_char = s[0] count = 1 for char in s[1:]: if char == prev_char: count += 1 else: result.append((prev_char, count)) prev_char = char count = 1 result.append((prev_char, count)) return result"},{"question":"def nth_prime(n: int) -> int: Returns the nth prime number. Note: Returns -1 if n is less than 1 since there is no zeroth or negative prime number. >>> nth_prime(1) == 2 >>> nth_prime(2) == 3 >>> nth_prime(3) == 5 >>> nth_prime(4) == 7 >>> nth_prime(5) == 11 >>> nth_prime(6) == 13 >>> nth_prime(7) == 17 >>> nth_prime(8) == 19 >>> nth_prime(9) == 23 >>> nth_prime(10) == 29 >>> nth_prime(1000) == 7919 >>> nth_prime(10000) == 104729 >>> nth_prime(0) == -1 >>> nth_prime(-1) == -1 >>> nth_prime(-10) == -1","solution":"def nth_prime(n: int) -> int: Returns the nth prime number. Note: Returns -1 if n is less than 1 since there is no zeroth or negative prime number. if n < 1: return -1 primes = [] candidate = 2 while len(primes) < n: is_prime = True for p in primes: if p * p > candidate: break if candidate % p == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes[-1]"},{"question":"def max_profit(n: int, fruit_profits: List[Tuple[int, int]]) -> int: Calculate the maximum profit for selling fruits for n days given the profit and available days for each fruit type. :param n: integer - the number of days you can sell fruits :param fruit_profits: list of tuples [(days, profit), ...] representing the days you can sell each fruit type and the profit per day for that fruit :return: integer - the maximum profit you can achieve >>> max_profit(5, [(2, 5), (3, 10), (1, 7)]) 30 >>> max_profit(5, [(3, 25), (2, 10), (2, 15)]) 75","solution":"def max_profit(n, fruit_profits): Calculate the maximum profit for selling fruits for n days given the profit and available days for each fruit type. :param n: int - the number of days you can sell fruits :param fruit_profits: list of tuples [(days, profit), ...] representing the days you can sell each fruit type and the profit per day for that fruit :return: int - the maximum profit you can achieve max_profit = 0 # Iterate through each fruit option and calculate potential profit for days, profit_per_day in fruit_profits: # Calculate profit for this fruit if days <= n: potential_profit = days * profit_per_day else: potential_profit = n * profit_per_day # Keep track of the maximum profit found max_profit = max(max_profit, potential_profit) return max_profit"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, -1, 1, 2, -2, 3, 4]) 7 >>> longest_consecutive([1, 2, 0, 1]) 3 >>> longest_consecutive([]) 0 from typing import List def test_longest_consecutive_basic(): assert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 def test_longest_consecutive_with_negatives(): assert longest_consecutive([0, -1, 1, 2, -2, 3, 4]) == 7 def test_longest_consecutive_with_duplicates(): assert longest_consecutive([1, 2, 0, 1]) == 3 def test_longest_consecutive_empty(): assert longest_consecutive([]) == 0 def test_longest_consecutive_single_element(): assert longest_consecutive([1]) == 1 def test_longest_consecutive_two_elements(): assert longest_consecutive([7, 9]) == 1 def test_longest_consecutive_large_range(): assert longest_consecutive(list(range(100))) == 100","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. :param nums: List[int] - List of integers :return: int - Length of the longest consecutive sequence if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # Only start counting if \`num\` is the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def summarize(blog_post): Generates a summary of a blog post according to the specified rules. >>> summarize('This is an example blog post meant to test the summary feature. The goal is to determine if it truncates at the correct point and handles word boundaries gracefully. <strong>HTML should be ignored</strong>.') 'This is an example blog post meant to test the summary feature. The goal is to determine if it truncates at the correct point and handles word boundaries gracefully.' >>> summarize('Short post.') 'Short post.' >>> summarize(12345) ''","solution":"import re def summarize(blog_post): Generates a summary of a blog post according to the specified rules. if not isinstance(blog_post, str): return '' # Remove HTML tags clean_text = re.sub(r'<[^>]*>', '', blog_post) if len(clean_text) <= 200: return clean_text # Truncate to 200 characters truncated_text = clean_text[:200] # Check if the 200th character is in the middle of a word if clean_text[200] not in (' ', ',', '.', '!', '?'): # Extend to the end of the word end_of_word_index = re.search(r'b', clean_text[200:]) if end_of_word_index: truncated_text += clean_text[200:end_of_word_index.end() + 200] return truncated_text"},{"question":"def convert_emoticons(s: str) -> str: Convert emoticons in the string \`s\` to their text descriptions. - \\":)\\" becomes \\"smiley\\" - \\":(\\" becomes \\"sad\\" - \\":P\\" becomes \\"playful\\" >>> convert_emoticons('Hello :)') 'Hello smiley' >>> convert_emoticons('Bad day :(') 'Bad day sad' >>> convert_emoticons('Feeling :P!') 'Feeling playful!' >>> convert_emoticons('A smiley face :) in a sentence') 'A smiley face smiley in a sentence' >>> convert_emoticons(':)good:(') 'smileygoodsad' from solution import convert_emoticons def test_convert_single_smiley(): assert convert_emoticons('Hello :)') == 'Hello smiley' def test_convert_single_sad(): assert convert_emoticons('Bad day :(') == 'Bad day sad' def test_convert_single_playful(): assert convert_emoticons('Feeling :P!') == 'Feeling playful!' def test_convert_smiley_in_sentence(): assert convert_emoticons('A smiley face :) in a sentence') == 'A smiley face smiley in a sentence' def test_convert_smiley_and_sad_together(): assert convert_emoticons(':)good:(') == 'smileygoodsad' def test_multiple_emoticons(): assert convert_emoticons('Happy :) but also sad :(') == 'Happy smiley but also sad sad' def test_convert_with_multiple_of_same(): assert convert_emoticons(':):):)') == 'smileysmileysmiley' def test_no_emoticons(): assert convert_emoticons('Just a regular sentence') == 'Just a regular sentence' def test_case_sensitivity(): assert convert_emoticons(':p should not change') == ':p should not change'","solution":"def convert_emoticons(s): Convert emoticons in the string \`s\` to their text descriptions. - \\":)\\" becomes \\"smiley\\" - \\":(\\" becomes \\"sad\\" - \\":P\\" becomes \\"playful\\" emoticon_map = {\\":)\\": \\"smiley\\", \\":(\\": \\"sad\\", \\":P\\": \\"playful\\"} for emoticon, text in emoticon_map.items(): s = s.replace(emoticon, text) return s"},{"question":"def find_starting_index(arr): Determine the starting index in a circular array such that the sum of all visited elements is always non-negative. >>> find_starting_index([5]) == 0 >>> find_starting_index([-5]) == -1 >>> find_starting_index([1, 2, 3, 4]) == 0 >>> find_starting_index([-1, -2, -3, -4]) == -1 >>> find_starting_index([2, -1, 2]) == 0 >>> find_starting_index([2, -5, 2, -1]) == -1 >>> find_starting_index([-1, 2, 3, -2, -3, 4, -1]) == 1 >>> find_starting_index([1] * 10**5) == 0","solution":"def find_starting_index(arr): n = len(arr) total_sum = sum(arr) if total_sum < 0: return -1 current_sum = 0 start_index = 0 for i in range(n): current_sum += arr[i] if current_sum < 0: start_index = i + 1 current_sum = 0 return start_index"},{"question":"def are_anagrams(a: str, b: str) -> int: Check if two strings are anagrams of each other. Returns 1 if they are anagrams, 0 otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") 1 >>> are_anagrams(\\"triangle\\", \\"integral\\") 1 >>> are_anagrams(\\"apple\\", \\"appele\\") 0 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Process multiple test cases to check for anagrams. Returns a list with the results for each test case. >>> test_cases = [(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"appele\\")] >>> process_test_cases(test_cases) [1, 1, 0] pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [(data[i*2+1], data[i*2+2]) for i in range(T)] results = process_test_cases(test_cases) for result in results: print(result)","solution":"def are_anagrams(a, b): Check if two strings are anagrams of each other. Returns 1 if they are anagrams, 0 otherwise. return 1 if sorted(a) == sorted(b) else 0 def process_test_cases(test_cases): Process multiple test cases to check for anagrams. Returns a list with the results for each test case. results = [] for a, b in test_cases: results.append(are_anagrams(a, b)) return results # Assuming the input is provided in a structured format (e.g., a list of tuples for test cases) # Here's how we would call the process for sample input: # test_cases = [(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"appele\\")] # print(process_test_cases(test_cases))"},{"question":"from typing import List, Tuple, Dict def active_time_per_employee(timestamps: List[Tuple[str, str, str]]) -> Dict[str, int]: Calculate the total active time in minutes for each employee based on login and logout timestamps. Args: timestamps (List[Tuple[str, str, str]]): List of tuples where each tuple contains employeeId (str), action (str), and time (str in \\"HH:MM\\" format). Returns: Dict[str, int]: A dictionary where the keys are employee IDs and the values are the total active time in minutes for each employee. # Your implementation here def test_active_time_single_employee(): timestamps = [ (\\"123\\", \\"login\\", \\"09:00\\"), (\\"123\\", \\"logout\\", \\"10:30\\"), ] assert active_time_per_employee(timestamps) == {\\"123\\": 90} def test_active_time_multiple_sessions_single_employee(): timestamps = [ (\\"123\\", \\"login\\", \\"09:00\\"), (\\"123\\", \\"logout\\", \\"10:30\\"), (\\"123\\", \\"login\\", \\"12:00\\"), (\\"123\\", \\"logout\\", \\"12:45\\") ] assert active_time_per_employee(timestamps) == {\\"123\\": 135} def test_active_time_multiple_employees(): timestamps = [ (\\"123\\", \\"login\\", \\"09:00\\"), (\\"123\\", \\"logout\\", \\"10:30\\"), (\\"456\\", \\"login\\", \\"09:15\\"), (\\"456\\", \\"logout\\", \\"11:00\\"), (\\"123\\", \\"login\\", \\"12:00\\"), (\\"123\\", \\"logout\\", \\"12:45\\") ] assert active_time_per_employee(timestamps) == {\\"123\\": 135, \\"456\\": 105} def test_active_time_single_employee_multiple_sessions(): timestamps = [ (\\"789\\", \\"login\\", \\"08:00\\"), (\\"789\\", \\"logout\\", \\"08:30\\"), (\\"789\\", \\"login\\", \\"08:45\\"), (\\"789\\", \\"logout\\", \\"09:15\\"), (\\"789\\", \\"login\\", \\"10:00\\"), (\\"789\\", \\"logout\\", \\"11:00\\") ] assert active_time_per_employee(timestamps) == {\\"789\\": 120} def test_edge_case_single_entry(): timestamps = [(\\"321\\", \\"login\\", \\"13:00\\"), (\\"321\\", \\"logout\\", \\"13:01\\")] assert active_time_per_employee(timestamps) == {\\"321\\": 1}","solution":"from datetime import datetime def active_time_per_employee(timestamps): Returns the total active time in minutes for each employee. Args: timestamps (list of tuples): Each tuple contains employeeId (str), action (str), and time (str). Returns: dict: A dictionary where keys are employee IDs and values are the total active time in minutes. def time_diff(start, end): Returns the difference in minutes between two HH:MM time strings. start_time = datetime.strptime(start, '%H:%M') end_time = datetime.strptime(end, '%H:%M') return int((end_time - start_time).total_seconds() // 60) active_times = {} last_login = {} for employee_id, action, time in timestamps: if action == \\"login\\": last_login[employee_id] = time elif action == \\"logout\\": if employee_id in last_login: if employee_id not in active_times: active_times[employee_id] = 0 active_times[employee_id] += time_diff(last_login[employee_id], time) del last_login[employee_id] return active_times"},{"question":"def max_subarray_sum_less_than_k(nums, k): Given an array of integers \`nums\` and an integer \`k\`, return the maximum sum of a non-empty subarray of \`nums\` such that the sum of the subarray is less than \`k\`. If no such subarray exists, return \`-1\`. :param nums: List of integers (both positive and negative) :param k: An integer :return: Maximum sum of the subarray less than \`k\` or -1 if no such subarray exists Examples: >>> max_subarray_sum_less_than_k([2, 1, -1, 3, 4], 8) 7 >>> max_subarray_sum_less_than_k([1, 2, 3], 1) -1","solution":"def max_subarray_sum_less_than_k(nums, k): Finds the maximum sum of a non-empty subarray of \`nums\` such that the sum is less than \`k\`. If no such subarray exists, returns \`-1\`. :param nums: List of integers (both positive and negative) :param k: An integer :return: Maximum sum of the subarray less than \`k\` or -1 if no such subarray exists max_sum = float('-inf') for i in range(len(nums)): current_sum = 0 for j in range(i, len(nums)): current_sum += nums[j] if current_sum < k: max_sum = max(max_sum, current_sum) else: break return max_sum if max_sum != float('-inf') else -1"},{"question":"def sum_of_squares(lst: List[int]) -> int: Write a method that takes a list of integers and returns the sum of the squares of all the even numbers in the list. Consider edge cases such as an empty list or a list without any even numbers. >>> sum_of_squares([1, 2, 3, 4, 5]) 20 >>> sum_of_squares([10, 14, 3, 7]) 296 >>> sum_of_squares([1, 3, 5, 7]) 0 >>> sum_of_squares([]) 0 pass def test_sum_of_squares_mixed_numbers(): assert sum_of_squares([1, 2, 3, 4, 5]) == 20 def test_sum_of_squares_all_even(): assert sum_of_squares([10, 14, 3, 7]) == 296 def test_sum_of_squares_no_even(): assert sum_of_squares([1, 3, 5, 7]) == 0 def test_sum_of_squares_empty(): assert sum_of_squares([]) == 0 def test_sum_of_squares_all_positive_even(): assert sum_of_squares([2, 4, 6]) == 56 def test_sum_of_squares_negative_and_positive_even(): assert sum_of_squares([-2, 2, -4, 4]) == 40","solution":"def sum_of_squares(lst): Returns the sum of the squares of all the even numbers in the list. :param lst: List of integers :return: Sum of the squares of all even numbers in the list return sum(x ** 2 for x in lst if x % 2 == 0)"},{"question":"import heapq from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the array. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array. return heapq.nlargest(k, nums)[-1]"},{"question":"def min_operations_to_unify(s: str) -> int: Returns the minimal number of operations required to make all characters of the string the same. >>> min_operations_to_unify(\\"aaab\\") 1 >>> min_operations_to_unify(\\"aabbaa\\") 2 >>> min_operations_to_unify(\\"abc\\") 2 pass def solve(test_cases: List[str]) -> List[int]: Given a list of test cases, returns a list of minimal number of operations required to make all characters of the strings the same. >>> solve([\\"aaab\\", \\"aabbaa\\", \\"abc\\"]) [1, 2, 2] >>> solve([\\"aaa\\", \\"bbbb\\", \\"abababab\\"]) [0, 0, 4] pass","solution":"def min_operations_to_unify(s): Returns the minimal number of operations required to make all characters of the string the same. from collections import Counter char_count = Counter(s) most_common_char_count = max(char_count.values()) return len(s) - most_common_char_count def solve(test_cases): results = [] for s in test_cases: results.append(min_operations_to_unify(s)) return results"},{"question":"from typing import List, Dict def can_meet_requirements(feeds: List[Dict[str, int]], required_nutrients: Dict[str, int]) -> str: Determine if a combination of feeds will meet the minimum nutrient requirements. Args: feeds (List[Dict[str, int]]): List of dictionaries representing feeds and their nutrient contents. required_nutrients (Dict[str, int]): Dictionary representing the minimum required nutrients. Returns: str: \\"Sufficient\\" if the combination of feeds meets or exceeds the minimum required nutrients, otherwise \\"Insufficient\\". >>> feeds = [ ... {'protein': 10, 'fiber': 5, 'fat': 2}, ... {'protein': 8, 'fiber': 7, 'fat': 4}, ... {'protein': 7, 'fiber': 3, 'fat': 6} ... ] >>> required_nutrients = {'protein': 20, 'fiber': 10, 'fat': 10} >>> can_meet_requirements(feeds, required_nutrients) 'Sufficient' >>> feeds = [ ... {'protein': 5, 'fiber': 5, 'fat': 2}, ... {'protein': 5, 'fiber': 7, 'fat': 4} ... ] >>> required_nutrients = {'protein': 20, 'fiber': 10, 'fat': 5} >>> can_meet_requirements(feeds, required_nutrients) 'Insufficient'","solution":"from typing import List, Dict def can_meet_requirements(feeds: List[Dict[str, int]], required_nutrients: Dict[str, int]) -> str: # Initialize nutrient sum dictionary with all zeros nutrient_sums = {nutrient: 0 for nutrient in required_nutrients} # Sum up the nutrient contents from all feeds for feed in feeds: for nutrient, amount in feed.items(): if nutrient in nutrient_sums: nutrient_sums[nutrient] += amount # Check if all required nutrients are met or exceeded for nutrient, required_amount in required_nutrients.items(): if nutrient_sums[nutrient] < required_amount: return \\"Insufficient\\" return \\"Sufficient\\""},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def linked_list_cycle_length(head): Detects the cycle in a linked list using Floyd’s Tortoise and Hare algorithm, and returns the length of the cycle if it exists, otherwise returns 0. :param head: ListNode, the head of the singly linked list. :return: int, the length of the cycle or 0 if there's no cycle. pass # Unit tests def test_no_cycle(): node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node1.next = node2 node2.next = node3 assert linked_list_cycle_length(node1) == 0 def test_simple_cycle(): node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node1.next = node2 node2.next = node3 node3.next = node2 # cycle here assert linked_list_cycle_length(node1) == 2 def test_cycle_length_3(): node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node3 # cycle here assert linked_list_cycle_length(node1) == 3 def test_single_node_no_cycle(): node1 = ListNode(1) assert linked_list_cycle_length(node1) == 0 def test_single_node_with_cycle(): node1 = ListNode(1) node1.next = node1 # cycle here assert linked_list_cycle_length(node1) == 1 def test_large_cycle(): nodes = [ListNode(i) for i in range(1, 101)] for i in range(99): nodes[i].next = nodes[i + 1] nodes[99].next = nodes[50] # cycle here starting from node 51 assert linked_list_cycle_length(nodes[0]) == 50 def test_edge_case_two_nodes_cycle(): node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = node1 # cycle here assert linked_list_cycle_length(node1) == 2","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def linked_list_cycle_length(head): Detects the cycle in a linked list using Floyd’s Tortoise and Hare algorithm, and returns the length of the cycle if it exists, otherwise returns 0. :param head: ListNode, the head of the singly linked list. :return: int, the length of the cycle or 0 if there's no cycle. slow = fast = head # Step 1: Determine if there is a cycle using Tortoise and Hare approach. while fast and fast.next: slow = slow.next fast = fast.next.next # Cycle detected if slow == fast: # Step 2: Determine the length of the cycle current = slow cycle_length = 0 while True: current = current.next cycle_length += 1 if current == slow: return cycle_length # No cycle found return 0"},{"question":"from collections import defaultdict from typing import List, Tuple def find_max_parade_length(n: int, roads: List[Tuple[int, int, int]]) -> int: Find the maximum possible total length of a parade route from the capital to a leaf city. >>> find_max_parade_length(7, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (2, 5, 1), (3, 6, 8), (6, 7, 3)]) 13 >>> find_max_parade_length(4, [(1, 2, 3), (2, 3, 4), (2, 4, 5)]) 9 >>> find_max_parade_length(2, [(1, 2, 1)]) 1 >>> find_max_parade_length(5, [(1, 2, 1), (1, 3, 2), (3, 4, 2), (4, 5, 2)]) 6 >>> find_max_parade_length(5, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10)]) 40","solution":"from collections import defaultdict def find_max_parade_length(n, roads): def dfs(node, parent): max_length = 0 for neighbor, weight in adj[node]: if neighbor != parent: max_length = max(max_length, dfs(neighbor, node) + weight) return max_length # Read input data adj = defaultdict(list) for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) # Start DFS from the capital city (1) max_parade_length = dfs(1, -1) return max_parade_length # This helper function is just to encapsulate input parsing/formatting logic def parse_input_and_find_max_parade_length(input_str): lines = input_str.strip().split('n') n = int(lines[0]) roads = [list(map(int, line.split())) for line in lines[1:]] return find_max_parade_length(n, roads)"},{"question":"def can_form_palindrome(s: str) -> bool: Check if a given string can be rearranged to form a palindrome. :param s: Input string :return: Boolean indicating whether the string can be rearranged to form a palindrome >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s: str) -> bool: Check if a given string can be rearranged to form a palindrome. :param s: Input string :return: Boolean indicating whether the string can be rearranged to form a palindrome from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def next_greater_element(nums: List[int]) -> List[int]: Returns a list where each integer from the input list is replaced by the next greatest integer to its right. If there is no greater integer to the right, it is replaced with -1. :param nums: List of integers :return: New list with each integer replaced by the next greatest integer to its right >>> next_greater_element([2, 7, 3, 5, 4, 6, 8]) [7, 8, 5, 6, 6, 8, -1] >>> next_greater_element([5, 4, 3, 2, 1]) [-1, -1, -1, -1, -1] >>> next_greater_element([1, 2, 3, 4, 5]) [2, 3, 4, 5, -1] >>> next_greater_element([1, 3, 2, 4, 3, 5]) [3, 4, 4, 5, 5, -1] >>> next_greater_element([1]) [-1] >>> next_greater_element([]) [] >>> next_greater_element([3, 3, 3, 3]) [-1, -1, -1, -1]","solution":"def next_greater_element(nums): Returns a list where each integer from the input list is replaced by the next greatest integer to its right. If there is no greater integer to the right, it is replaced with -1. :param nums: List of integers :return: New list with each integer replaced by the next greatest integer to its right n = len(nums) if n == 0: return [] result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and stack[-1] <= nums[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(nums[i]) return result"},{"question":"def shortestPath(grid: List[List[str]]) -> int: Find the shortest path from the top-left corner (0, 0) to the bottom-right corner (R-1, C-1) of a grid. You can move up, down, left, or right, but not diagonally and cannot pass through cells containing asteroids ('#'). Returns the length of the shortest path. If there is no valid path, return -1. >>> grid1 = [ ... ['.', '.', '#', '.'], ... ['#', '.', '#', '.'], ... ['.', '.', '.', '#'], ... ['.', '#', '.', '.'] ... ] >>> shortestPath(grid1) 7 >>> grid2 = [ ... ['.', '#', '.'], ... ['#', '.', '.'], ... ['.', '#', '.'] ... ] >>> shortestPath(grid2) -1 >>> grid3 = [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ] >>> shortestPath(grid3) 5","solution":"from collections import deque from typing import List def shortestPath(grid: List[List[str]]) -> int: if not grid or not grid[0]: return -1 R, C = len(grid), len(grid[0]) if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set([(0, 0)]) while queue: r, c, dist = queue.popleft() if r == R-1 and c == C-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def longest_subarray_with_sum_k(arr, N, K): Returns the length of the longest subarray with sum equal to K. >>> longest_subarray_with_sum_k([1, -1, 5, -2, 3], 5, 5) 4 >>> longest_subarray_with_sum_k([1, 2, 3], 3, 7) 0 >>> longest_subarray_with_sum_k([5, 5, 5, 5], 4, 20) 4 >>> longest_subarray_with_sum_k([-2, -1, 2, 1], 4, 1) 2 >>> longest_subarray_with_sum_k([-1, -1, -1, -1], 4, -3) 3 >>> longest_subarray_with_sum_k([3, 4, 7, 2, -3, 1, 4, 2], 8, 7) 4","solution":"def longest_subarray_with_sum_k(arr, N, K): Returns the length of the longest subarray with sum equal to K. sum_map = {} # to store the cumulative sum and its index current_sum = 0 max_length = 0 for i in range(N): current_sum += arr[i] # Check if all of the subarray has sum exactly K if current_sum == K: max_length = i + 1 # Check if there is a subarray which adds up to K, by checking current_sum - K if (current_sum - K) in sum_map: max_length = max(max_length, i - sum_map[current_sum - K]) # Only add current_sum to map if it is not already present if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"from typing import List def longest_palindrome_length(s: str) -> int: Determines if the given string can be rearranged to form a palindrome and returns the length of the longest possible palindrome. If the string cannot be rearranged to form a palindrome, returns -1. >>> longest_palindrome_length(\\"racecar\\") == 7 >>> longest_palindrome_length(\\"carrace\\") == 7 >>> longest_palindrome_length(\\"daily\\") == -1 >>> longest_palindrome_length(\\"aaaabbbcc\\") == 9 >>> longest_palindrome_length(\\"abcd\\") == -1 >>> longest_palindrome_length(\\"a\\") == 1 >>> longest_palindrome_length(\\"\\") == 0","solution":"def longest_palindrome_length(s): Determines if the given string can be rearranged to form a palindrome and returns the length of the longest possible palindrome. If the string cannot be rearranged to form a palindrome, returns -1. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: return -1 else: return len(s)"},{"question":"def capitalize_words(s): Returns a new string with the first letter of each word capitalized >>> capitalize_words('hello world') 'Hello World' >>> capitalize_words('') '' # Your code here def count_vowels(s): Returns the number of vowels in the string >>> count_vowels('hello') 2 >>> count_vowels('') 0 # Your code here","solution":"def capitalize_words(s): Returns a new string with the first letter of each word capitalized >>> capitalize_words('hello world') 'Hello World' >>> capitalize_words('') '' return ' '.join(word.capitalize() for word in s.split()) def count_vowels(s): Returns the number of vowels in the string >>> count_vowels('hello') 2 >>> count_vowels('') 0 vowels = \\"aeiouAEIOU\\" return sum(1 for char in s if char in vowels)"},{"question":"from typing import List def find_unique_element(n: int, a: List[int]) -> int: Given the count of pairs and the list, returns the unique element that appears only once. Args: n (int): The number of pairs of elements. a (List[int]): The list containing 2n + 1 integers. Returns: int: The unique element that appears only once. Examples: >>> find_unique_element(3, [2, 3, 2, 4, 3, 5, 4]) 5 >>> find_unique_element(0, [7]) 7 >>> find_unique_element(2, [-1, -1, -2, -2, -3, -3, -4]) -4 >>> find_unique_element(4, [7, -3, 7, 3, -2, 3, -2, -3, 1]) 1","solution":"def find_unique_element(n, a): Given the count of pairs and the list, returns the unique element that appears only once. unique_element = 0 for num in a: unique_element ^= num return unique_element"},{"question":"from typing import List def wood_collected(heights: List[int], k: int) -> int: Returns the total amount of wood collected by cutting all trees taller than \`k\` down to the height of \`k\`. Parameters: heights (List[int]): A list of integers representing the heights of the trees. k (int): The height to cut trees down to if they are taller than this height. Returns: int: The total amount of wood collected. >>> wood_collected([20, 15, 10, 17], 15) == 7 >>> wood_collected([10, 5, 8], 12) == 0 >>> wood_collected([25, 30, 35], 20) == 30 >>> wood_collected([12, 18, 20, 22], 18) == 6 >>> wood_collected([15, 15, 15, 16, 30], 15) == 16 >>> wood_collected([], 10) == 0 >>> wood_collected([1, 2, 3, 4, 5], 0) == 15","solution":"from typing import List def wood_collected(heights: List[int], k: int) -> int: Returns the total amount of wood collected by cutting all trees taller than \`k\` down to the height of \`k\`. Parameters: heights (List[int]): A list of integers representing the heights of the trees. k (int): The height to cut trees down to if they are taller than this height. Returns: int: The total amount of wood collected. total_wood = 0 for height in heights: if height > k: total_wood += (height - k) return total_wood"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit from buying and selling a single stock. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit from buying and selling a single stock. If no profit is possible, returns 0. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_reward(n: int, m: int, s: int, deliveries: [(int, int, int, int)]) -> int: Determine the maximum reward that can be collected by completing the deliveries optimally. >>> max_reward(10, 2, 3, [(1, 5, 100, 10), (6, 10, 200, 15)]) 300 >>> max_reward(15, 3, 2, [(3, 8, 500, 10), (5, 12, 1000, 20), (9, 15, 700, 30)]) 2200 >>> max_reward(10, 0, 3, []) 0 >>> max_reward(5, 1, 1, [(1, 3, 150, 5)]) 150 >>> max_reward(5, 2, 2, [(1, 3, 100, 5), (2, 4, 200, 5)]) 200 >>> max_reward(5, 1, 1, [(1, 5, 100, 1)]) 100","solution":"def max_reward(n, m, s, deliveries): # Sort deliveries by delivery time deliveries.sort(key=lambda x: x[3]) # dp[i] means the maximum reward up to the i-th delivery dp = [0] * (m + 1) # Precompute travel time between any two stations def travel_time(a, b): return abs(a - b) // s + (1 if abs(a - b) % s != 0 else 0) for i in range(1, m + 1): pickup, dropoff, reward, time = deliveries[i-1] # Start from any point at time 1 dp[i] = max(dp[i], reward) for j in range(i): prev_pickup, prev_dropoff, prev_reward, prev_time = deliveries[j-1] if j > 0 else (0, 0, 0, 0) move_time = travel_time(prev_dropoff if j > 0 else dropoff, pickup) if prev_time + move_time <= time: dp[i] = max(dp[i], dp[j] + reward) return max(dp) # Test cases for the solution if __name__ == \\"__main__\\": n, m, s = 10, 2, 3 deliveries = [(1, 5, 100, 10), (6, 10, 200, 15)] print(max_reward(n, m, s, deliveries)) # Output: 300 n, m, s = 15, 3, 2 deliveries = [(3, 8, 500, 10), (5, 12, 1000, 20), (9, 15, 700, 30)] print(max_reward(n, m, s, deliveries)) # Output: 2200"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def max_subtree_sum(node): Calculate the maximum sum obtainable from any subtree of the binary tree. >>> tree = TreeNode(1) >>> tree.children = [TreeNode(2), TreeNode(3)] >>> tree.children[0].children = [TreeNode(-2), TreeNode(4)] >>> max_subtree_sum(tree) 8 def build_tree(nodes, edges): Build the tree from given node values and edges. >>> build_tree([1, 2, 3, -2, 4], [(1, 2), (1, 3), (2, 4), (2, 5)]) Node structure with correct parent-child relationships. def solve(T, test_cases): Process the test cases and return the maximum sum of any subtree for each case. >>> solve(1, [(5, [1, 2, 3, -2, 4], [(1, 2), (1, 3), (2, 4), (2, 5)])]) [8] def main(input_str): Read input, process it and return the results. >>> input_data = \\"1n5n1 2 3 -2 4n1 2n1 3n2 4n2 5n\\" >>> main(input_data) \\"8\\"","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def max_subtree_sum(node): if not node: return 0, float('-inf') current_sum = node.value max_sum = node.value for child in node.children: child_sum, child_max_sum = max_subtree_sum(child) current_sum += child_sum max_sum = max(max_sum, child_max_sum) return current_sum, max(max_sum, current_sum) def build_tree(nodes, edges): node_dict = {i + 1: TreeNode(value) for i, value in enumerate(nodes)} for u, v in edges: node_dict[u].children.append(node_dict[v]) return node_dict def solve(T, test_cases): results = [] for i in range(T): N, node_values, edges = test_cases[i] tree = build_tree(node_values, edges) _, max_sum = max_subtree_sum(tree[1]) results.append(max_sum) return results # Function used to read input and output results def main(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) node_values = list(map(int, input_lines[index + 1].split())) edges = [tuple(map(int, input_lines[index + 2 + i].split())) for i in range(N - 1)] test_cases.append((N, node_values, edges)) index += 2 + (N - 1) results = solve(T, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def longest_common_sequence(str1: str, str2: str) -> int: Determines the length of the longest common subsequence between two strings. >>> longest_common_sequence('abcdef', 'acbcf') 4 >>> longest_common_sequence('xyz', 'xyxz') 3 >>> longest_common_sequence('abcd', 'efgh') 0","solution":"def longest_common_sequence(str1, str2): Determines the length of the longest common subsequence between two strings. # Initializing the DP table dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)] # Filling the DP table for i in range(1, len(str1) + 1): for j in range(1, len(str2) + 1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[len(str1)][len(str2)]"},{"question":"from typing import List def max_coins(grid: List[List[str]], max_moves: int) -> int: Calculate the maximum number of coins the player can collect given the grid and the maximum number of moves allowed. Args: grid (List[List[str]]): A 2D list representing the game grid, where 'C' represents a coin and '.' represents an empty space. max_moves (int): The maximum number of moves the player can make. Returns: int: The maximum number of coins that can be collected within the given number of moves. Examples: >>> grid = [ ... ['.', 'C', '.'], ... ['.', '.', 'C'], ... ['C', 'C', '.'] ... ] >>> max_moves = 4 >>> max_coins(grid, max_moves) 3 >>> grid = [ ... ['.', '.', '.'], ... ['.', 'C', '.'], ... ['.', '.', '.'] ... ] >>> max_moves = 2 >>> max_coins(grid, max_moves) 1 >>> grid = [ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ] >>> max_moves = 2 >>> max_coins(grid, max_moves) 0 >>> grid = [ ... ['C', 'C', 'C'], ... ['C', 'C', 'C'], ... ['C', 'C', 'C'] ... ] >>> max_moves = 3 >>> max_coins(grid, max_moves) 4 >>> grid = [ ... ['C', '.', '.', 'C'], ... ['.', 'C', 'C', '.'], ... ['.', '.', '.', '.'], ... ['C', '.', '.', 'C'] ... ] >>> max_moves = 5 >>> max_coins(grid, max_moves) 4 >>> grid = [ ... ['C', '.', '.', 'C'], ... ['.', 'C', 'C', '.'], ... ['.', '.', '.', '.'], ... ['C', '.', '.', 'C'] ... ] >>> max_moves = 0 >>> max_coins(grid, max_moves) 1","solution":"from typing import List def max_coins(grid: List[List[str]], max_moves: int) -> int: n = len(grid) m = len(grid[0]) # Helper function for the DFS traversal def dfs(x, y, moves_left, collected_coins, visited): if moves_left < 0 or x < 0 or y < 0 or x >= n or y >= m or visited[x][y]: return collected_coins visited[x][y] = True collected_coins += 1 if grid[x][y] == 'C' else 0 # Search in all four possible directions (up, down, left, right) max_coins_collected = collected_coins max_coins_collected = max(max_coins_collected, dfs(x + 1, y, moves_left - 1, collected_coins, visited)) max_coins_collected = max(max_coins_collected, dfs(x - 1, y, moves_left - 1, collected_coins, visited)) max_coins_collected = max(max_coins_collected, dfs(x, y + 1, moves_left - 1, collected_coins, visited)) max_coins_collected = max(max_coins_collected, dfs(x, y - 1, moves_left - 1, collected_coins, visited)) # Backtrack visited[x][y] = False collected_coins -= 1 if grid[x][y] == 'C' else 0 return max_coins_collected # Start the DFS traversal from (0, 0) with given max_moves return dfs(0, 0, max_moves, 0, [[False] * m for _ in range(n)])"},{"question":"from typing import List, Tuple, Dict def match_summary(matches: List[Tuple[str, int, float]]) -> Dict[str, int or float]: You are responsible for organizing a tournament where players compete in either singles or doubles matches. Each match can be in one of two categories: 'singles' or 'doubles'. The input is a list of tuples, where each tuple contains three elements: a string representing the category of the match ('singles' or 'doubles'), an integer representing the player's seed ranking, and a floating-point number representing the score of the match. Write a function match_summary that takes as input this list of tuples and returns a dictionary with the following keys: - 'total_singles': The total number of singles matches. - 'total_doubles': The total number of doubles matches. - 'highest_seed': The highest seed ranking among all players. - 'average_score': The average score of all matches. Returns: A dictionary with the statistics as described. Examples: >>> match_summary([('singles', 1, 7.5), ('doubles', 2, 8.2), ('singles', 3, 6.3), ('doubles', 1, 9.1), ('singles', 2, 10.0)]) {'total_singles': 3, 'total_doubles': 2, 'highest_seed': 3, 'average_score': 8.22} >>> match_summary([('doubles', 5, 8.2), ('doubles', 10, 7.4), ('singles', 6, 9.0)]) {'total_singles': 1, 'total_doubles': 2, 'highest_seed': 10, 'average_score': 8.2}","solution":"def match_summary(matches): total_singles = 0 total_doubles = 0 highest_seed = float('-inf') total_score = 0 num_matches = len(matches) for match in matches: category, seed, score = match if category == 'singles': total_singles += 1 elif category == 'doubles': total_doubles += 1 if seed > highest_seed: highest_seed = seed total_score += score average_score = total_score / num_matches if num_matches > 0 else 0 return { 'total_singles': total_singles, 'total_doubles': total_doubles, 'highest_seed': highest_seed, 'average_score': round(average_score, 2) }"},{"question":"def smallest_number(n: str) -> str: Given a string representation of a positive integer, returns the smallest possible number that can be formed using its digits. Trailing zeros after any rearrangement are moved to the end of the number. >>> smallest_number(\\"210\\") '102' >>> smallest_number(\\"30210\\") '10023'","solution":"def smallest_number(n: str) -> str: Given a string representation of a positive integer, returns the smallest possible number that can be formed using its digits. Trailing zeros after any rearrangement are moved to the end of the number. digits = sorted(n) if digits[0] == '0': # Check if there's a leading zero for i in range(len(digits)): if digits[i] != '0': # Find the first non-zero digit # Swap the first non-zero digit with the first digit (which is '0') digits[0], digits[i] = digits[i], '0' break return ''.join(digits)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list such that each element at index i of the new list is the product of all the numbers in the original array except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 0, 3, 4]) [0, 24, 0, 0] >>> product_except_self([0, 0, 3, 4]) [0, 0, 0, 0] >>> product_except_self([5]) [1] >>> product_except_self([]) []","solution":"def product_except_self(nums): Given a list of integers, return a new list such that each element at index i of the new list is the product of all the numbers in the original array except the one at i. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = left_products[i-1] * nums[i-1] for i in range(length-2, -1, -1): right_products[i] = right_products[i+1] * nums[i+1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def all_elements_same_frequency(arr): Determines if all elements in an array have the same frequency of occurrences. :param arr: List of integers :return: Boolean value indicating whether all elements have the same frequency >>> all_elements_same_frequency([1, 2, 2, 1, 1, 2]) True >>> all_elements_same_frequency([4, 4, 4, 3, 3, 2]) False >>> all_elements_same_frequency([3, 3, 3, 3]) True >>> all_elements_same_frequency([1, 1, 1, 2, 2, 3]) False >>> all_elements_same_frequency([5]) True >>> all_elements_same_frequency([1, 1, 2, 2, 3, 3]) True >>> all_elements_same_frequency([]) True from solution import all_elements_same_frequency def test_all_elements_same_frequency(): assert all_elements_same_frequency([1, 2, 2, 1, 1, 2]) == True assert all_elements_same_frequency([3, 3, 3, 3]) == True assert all_elements_same_frequency([4, 4, 4, 3, 3, 2]) == False assert all_elements_same_frequency([1, 1, 1, 2, 2, 3]) == False assert all_elements_same_frequency([5]) == True assert all_elements_same_frequency([1, 1, 2, 2, 3, 3]) == True assert all_elements_same_frequency([]) == True","solution":"def all_elements_same_frequency(arr): Determines if all elements in an array have the same frequency of occurrences. :param arr: List of integers :return: Boolean value indicating whether all elements have the same frequency if not arr: return True from collections import Counter frequency_counter = Counter(arr) frequencies = list(frequency_counter.values()) # Check if all frequencies are the same return all(f == frequencies[0] for f in frequencies)"},{"question":"from typing import List def sort_words(words: List[str]) -> List[str]: Sort the words by frequency of occurrence and then alphabetically in case of a tie in frequencies. >>> sort_words([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) ['cherry', 'banana', 'banana', 'apple', 'apple', 'apple'] >>> sort_words([\\"dog\\", \\"cat\\", \\"mouse\\"]) ['cat', 'dog', 'mouse'] >>> sort_words([\\"banana\\", \\"apple\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) ['date', 'apple', 'apple', 'banana', 'banana', 'cherry', 'cherry'] >>> sort_words([\\"apple\\", \\"apple\\", \\"apple\\"]) ['apple', 'apple', 'apple'] >>> sort_words([\\"dog\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"elephant\\", \\"elephant\\", \\"dog\\"]) ['cat', 'cat', 'elephant', 'elephant', 'dog', 'dog', 'dog']","solution":"from collections import Counter def sort_words(words): Sort the words by frequency of occurrence and then alphabetically in case of a tie in frequencies. # Count the frequency of each word frequency = Counter(words) # Create a sorted list based on the defined criteria: # 1. Frequency (ascending) # 2. Alphabetically in case of a tie sorted_words = sorted(words, key=lambda word: (frequency[word], word)) return sorted_words"},{"question":"from typing import List def sort_by_weight(strings: List[str]) -> List[str]: Sort an array of strings based on the sum of the ASCII values of their characters. If two strings have the same weight, they are returned in the order they appeared in the input array. >>> sort_by_weight([\\"a\\", \\"c\\", \\"b\\"]) ['a', 'b', 'c'] >>> sort_by_weight([\\"abc\\", \\"a\\", \\"b\\", \\"aa\\"]) ['a', 'b', 'aa', 'abc'] >>> sort_by_weight([\\"abc\\", \\"bca\\", \\"xyz\\"]) ['abc', 'bca', 'xyz'] >>> sort_by_weight([]) [] >>> sort_by_weight([\\"hello\\"]) ['hello'] >>> sort_by_weight([\\"abcd\\", \\"xyz\\", \\"a\\", \\"bc\\", \\"def\\"]) ['a', 'bc', 'def', 'xyz', 'abcd'] >>> sort_by_weight([\\"a\\", \\"c\\", \\"b\\", \\"aa\\", \\"bb\\", \\"cc\\"]) ['a', 'b', 'c', 'aa', 'bb', 'cc'] >>> sort_by_weight([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) ['aaa', 'aaa', 'aaa']","solution":"from typing import List def sort_by_weight(strings: List[str]) -> List[str]: Sort an array of strings based on the sum of the ASCII values of their characters. If two strings have the same weight, they are returned in the order they appeared in the input array. # Calculate the weight of each string and sort the strings based on these weights return sorted(strings, key=lambda s: sum(ord(char) for char in s))"},{"question":"def validate_paintings(wall_width: int, wall_height: int, paintings: List[Tuple[int, int, int, int]]) -> bool: Validates if the paintings can be placed on the wall without overlapping and within the wall boundaries. Args: wall_width (int): The width of the wall. wall_height (int): The height of the wall. paintings (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers (x, y, width, height) representing the top-left corner (x, y) of a painting and its dimensions width and height. Returns: bool: True if all paintings are non-overlapping and within the wall boundaries, False otherwise. Examples: >>> validate_paintings(10, 10, [(1, 1, 3, 3), (5, 5, 2, 2), (1, 5, 4, 4)]) True >>> validate_paintings(10, 10, [(1, 1, 3, 3), (2, 2, 3, 3), (1, 5, 4, 4)]) False","solution":"def validate_paintings(wall_width, wall_height, paintings): Validates if the paintings can be placed on the wall without overlapping and within the wall boundaries. n = len(paintings) for i in range(n): x1, y1, w1, h1 = paintings[i] # Check if the current painting fits within the wall boundaries if x1 < 0 or y1 < 0 or x1 + w1 > wall_width or y1 + h1 > wall_height: return False for j in range(i + 1, n): x2, y2, w2, h2 = paintings[j] # Check for overlap with any other painting if not (x1 + w1 <= x2 or x2 + w2 <= x1 or y1 + h1 <= y2 or y2 + h2 <= y1): return False return True"},{"question":"def largest_rectangle_area(rectangles): Given a 2-dimensional list where each sublist contains two integers representing the length and width of rectangles, find the area of the largest rectangle. Arguments: rectangles -- 2D list where each sublist contains two integers [length, width] Returns: Integer -- the maximum area >>> largest_rectangle_area([[2, 3], [4, 5], [1, 6]]) 20 >>> largest_rectangle_area([[3, 4]]) 12 >>> largest_rectangle_area([[2, 3], [3, 2], [1, 6]]) 6 >>> largest_rectangle_area([[2, 2], [2, 2], [2, 2]]) 4 >>> largest_rectangle_area([[1000, 1000], [999, 999], [100, 100]]) 1000000 >>> largest_rectangle_area([[1, 999], [998, 1], [1, 1]]) 999","solution":"def largest_rectangle_area(rectangles): Returns the area of the largest rectangle from a list of rectangles. Each rectangle is represented as a list of two integers: [length, width]. Arguments: rectangles -- 2D list where each sublist contains two integers [length, width] Returns: Integer -- the maximum area areas = map(lambda x: x[0] * x[1], rectangles) return max(areas)"},{"question":"from typing import List, Dict, Union def add_flight(flights: List[Dict], flight: Dict) -> List[Dict]: Adds or updates the provided flight in the list of flights. Args: flights (List[Dict]): List of existing flights. flight (Dict): Flight information to add or update. Returns: List[Dict]: Updated list of flights after adding or updating the flight. pass def remove_flight(flights: List[Dict], flight_number: str) -> List[Dict]: Removes the flight with the given flight number from the list of flights. Args: flights (List[Dict]): List of existing flights. flight_number (str): Flight number to remove. Returns: List[Dict]: Updated list of flights after removing the flight. pass def get_flight_details(flights: List[Dict], flight_number: str) -> Union[Dict, None]: Retrieves and returns the details of the flight with the given flight number. Args: flights (List[Dict]): List of existing flights. flight_number (str): Flight number to retrieve details for. Returns: Union[Dict, None]: Details of the flight or None if the flight number does not exist. pass def list_flights(flights: List[Dict], start_time: str, end_time: str) -> List[Dict]: Lists all flights with departure times within the inclusive time range specified by start_time and end_time. Args: flights (List[Dict]): List of existing flights. start_time (str): Start time of the range in \\"HH:MM\\" format. end_time (str): End time of the range in \\"HH:MM\\" format. Returns: List[Dict]: List of flights within the specified time range. pass # Test cases def test_add_flight(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150} ] flight = {\\"flight_number\\": \\"B456\\", \\"departure_time\\": \\"12:00\\", \\"destination\\": \\"Los Angeles\\", \\"duration\\": 180} updated_flights = add_flight(flights, flight) assert len(updated_flights) == 2 assert updated_flights[1][\\"flight_number\\"] == \\"B456\\" def test_add_existing_flight(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150} ] flight = {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"11:00\\", \\"destination\\": \\"Boston\\", \\"duration\\": 100} updated_flights = add_flight(flights, flight) assert len(updated_flights) == 1 assert updated_flights[0][\\"departure_time\\"] == \\"11:00\\" assert updated_flights[0][\\"destination\\"] == \\"Boston\\" def test_remove_flight(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150}, {\\"flight_number\\": \\"B456\\", \\"departure_time\\": \\"12:00\\", \\"destination\\": \\"Los Angeles\\", \\"duration\\": 180} ] updated_flights = remove_flight(flights, \\"A123\\") assert len(updated_flights) == 1 assert updated_flights[0][\\"flight_number\\"] == \\"B456\\" def test_remove_non_existent_flight(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150} ] updated_flights = remove_flight(flights, \\"Z999\\") assert len(updated_flights) == 1 def test_get_flight_details(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150} ] flight_details = get_flight_details(flights, \\"A123\\") assert flight_details is not None assert flight_details[\\"departure_time\\"] == \\"10:30\\" def test_get_non_existent_flight_details(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150} ] flight_details = get_flight_details(flights, \\"B456\\") assert flight_details is None def test_list_flights(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150}, {\\"flight_number\\": \\"B456\\", \\"departure_time\\": \\"12:00\\", \\"destination\\": \\"Los Angeles\\", \\"duration\\": 180}, {\\"flight_number\\": \\"C789\\", \\"departure_time\\": \\"15:00\\", \\"destination\\": \\"Chicago\\", \\"duration\\": 120}, ] flights_list = list_flights(flights, \\"10:00\\", \\"12:30\\") assert len(flights_list) == 2 assert flights_list[0][\\"flight_number\\"] == \\"A123\\" assert flights_list[1][\\"flight_number\\"] == \\"B456\\" def test_list_flights_no_match(): flights = [ {\\"flight_number\\": \\"A123\\", \\"departure_time\\": \\"10:30\\", \\"destination\\": \\"New York\\", \\"duration\\": 150}, {\\"flight_number\\": \\"B456\\", \\"departure_time\\": \\"12:00\\", \\"destination\\": \\"Los Angeles\\", \\"duration\\": 180} ] flights_list = list_flights(flights, \\"13:00\\", \\"14:00\\") assert len(flights_list) == 0","solution":"from typing import List, Dict, Union def add_flight(flights: List[Dict], flight: Dict) -> List[Dict]: Adds or updates the provided flight in the list of flights. for i, existing_flight in enumerate(flights): if existing_flight[\\"flight_number\\"] == flight[\\"flight_number\\"]: flights[i] = flight return flights flights.append(flight) return flights def remove_flight(flights: List[Dict], flight_number: str) -> List[Dict]: Removes the flight with the given flight number from the list of flights. flights = [flight for flight in flights if flight[\\"flight_number\\"] != flight_number] return flights def get_flight_details(flights: List[Dict], flight_number: str) -> Union[Dict, None]: Retrieves and returns the details of the flight with the given flight number. for flight in flights: if flight[\\"flight_number\\"] == flight_number: return flight return None def list_flights(flights: List[Dict], start_time: str, end_time: str) -> List[Dict]: Lists all flights with departure times within the inclusive time range specified by start_time and end_time. def time_to_minutes(time_str): hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes start_minutes = time_to_minutes(start_time) end_minutes = time_to_minutes(end_time) filtered_flights = [ flight for flight in flights if start_minutes <= time_to_minutes(flight[\\"departure_time\\"]) <= end_minutes ] return filtered_flights"},{"question":"from typing import List def generate_diamond(N: int) -> List[str]: Generates a diamond pattern with N rows in the upper half (including middle row) and N rows in the lower half (excluding middle row). Args: - N: int : Number of rows in the upper half of the diamond (including middle row). Returns: - List[str] : A list of strings representing the diamond pattern def diamond_patterns(T: int, Ns: List[int]) -> List[List[str]]: Generates diamond patterns for each test case based on the list of Ns. Args: - T: int : Number of test cases - Ns: List[int] : List of integer values where each integer denotes the number of rows in the upper half of the diamond for that test case. Returns: - List[List[str]] : A list where each element is a list of strings representing the diamond pattern for each test case. def test_generate_diamond(): assert generate_diamond(2) == [ ' *', '* *', ' *', ] assert generate_diamond(3) == [ ' *', ' * *', '* *', ' * *', ' *', ] def test_diamond_patterns(): assert diamond_patterns(2, [2, 3]) == [ [ ' *', '* *', ' *', ], [ ' *', ' * *', '* *', ' * *', ' *', ] ] def test_diamond_patterns_single_case(): assert diamond_patterns(1, [1]) == [['*']] assert diamond_patterns(1, [10]) == [ [ ' *', ' * *', ' * *', ' * *', ' * *', ' * *', ' * *', ' * *', ' * *', '* *', ' * *', ' * *', ' * *', ' * *', ' * *', ' * *', ' * *', ' * *', ' *', ] ]","solution":"def generate_diamond(N): Generates a diamond pattern with N rows in the upper half (including middle row) and N rows in the lower half (excluding middle row). diamond_pattern = [] for i in range(N): spaces = ' ' * (N - i - 1) if i == 0: stars = '*' else: stars = '*' + ' ' * (2 * i - 1) + '*' diamond_pattern.append(spaces + stars) for i in range(N - 1): spaces = ' ' * (i + 1) if N - i - 2 == 0: stars = '*' else: stars = '*' + ' ' * (2 * (N - i - 2) - 1) + '*' diamond_pattern.append(spaces + stars) return diamond_pattern def diamond_patterns(T, Ns): Generates diamond patterns for each test case based on the list of Ns. results = [] for N in Ns: results.append(generate_diamond(N)) return results"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Returns the maximum area of a rectangle that can be formed with the given buildings. :param heights: List[int] :return: int >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4, 6, 3, 5]) 12 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([2, 2, 2, 2, 2]) 10 >>> largest_rectangle_area([]) 0","solution":"def largest_rectangle_area(heights): Returns the maximum area of a rectangle that can be formed with the given buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def is_palindrome_sentence(s: str) -> bool: Check if the given string is a palindrome sentence, ignoring cases and spaces. >>> is_palindrome_sentence(\\"A man a plan a canal Panama\\") True >>> is_palindrome_sentence(\\"Hello World\\") False >>> is_palindrome_sentence(\\"Was it a car or a cat I saw\\") True >>> is_palindrome_sentence(\\"No lemon no melon\\") True >>> is_palindrome_sentence(\\"Not a palindrome\\") False >>> is_palindrome_sentence(\\"Race car\\") True >>> is_palindrome_sentence(\\" \\") True >>> is_palindrome_sentence(\\"\\") True","solution":"def is_palindrome_sentence(s): Check if the given string is a palindrome sentence, ignoring cases and spaces. :param s: input string :return: True if the sentence is a palindrome, False otherwise # Normalize the string: remove spaces and convert to lowercase normalized_s = ''.join(c.lower() for c in s if c.isalpha()) # Check if the normalized string is equal to its reverse return normalized_s == normalized_s[::-1]"},{"question":"def is_palindrome(num: str) -> bool: Write a function to determine if a given large integer is a palindrome. In this problem, your input is a string representation of this large integer, and you must return true if it is palindromic, otherwise return false. Parameters: num (str): A string representation of a large integer, where 1 ≤ num.length ≤ 100000 Returns: bool: True if the number is a palindrome, False otherwise. >>> is_palindrome(\\"12345678987654321\\") == True >>> is_palindrome(\\"1234567890987654321\\") == False # Implementation here","solution":"def is_palindrome(num): Determines if a given large integer (as a string) is a palindrome. Parameters: num (str): A string representation of a large integer, where 1 ≤ num.length ≤ 100000 Returns: bool: True if the number is a palindrome, False otherwise. return num == num[::-1]"},{"question":"def count_distributions(N: int) -> int: Calculate the number of ways to distribute candies to N guests such that no two adjacent guests receive the same number of candies. >>> count_distributions(1) 3 >>> count_distributions(2) 6 >>> count_distributions(3) 12 >>> count_distributions(4) 24 def calculate_distributions(test_cases: List[int]) -> List[int]: Calculate the number of valid distributions for a list of test cases. >>> calculate_distributions([3, 4]) [12, 24] >>> calculate_distributions([1, 2, 3]) [3, 6, 12] >>> calculate_distributions([5, 6]) [48, 96] from solution import count_distributions, calculate_distributions def test_count_distributions(): assert count_distributions(1) == 3 assert count_distributions(2) == 6 assert count_distributions(3) == 12 assert count_distributions(4) == 24 assert count_distributions(5) == 48 def test_calculate_distributions(): assert calculate_distributions([3, 4]) == [12, 24] assert calculate_distributions([1, 2, 3]) == [3, 6, 12] assert calculate_distributions([5, 6]) == [48, 96]","solution":"def count_distributions(N): if N == 1: return 3 elif N == 2: return 6 dp = [0] * (N + 1) dp[1] = 3 # Only 3 ways for the first guest: 1, 2, 3 dp[2] = 6 # Only 6 ways for two guests: [1,2], [1,3], [2,1], [2,3], [3,1], [3,2] for i in range(3, N + 1): dp[i] = dp[i-1] * 2 return dp[N] def calculate_distributions(test_cases): results = [] for case in test_cases: results.append(count_distributions(case)) return results"},{"question":"def canConstruct(s: str, wordDict: List[str]) -> bool: Determines whether the string s can be constructed by concatenating one or more words from a given list. Args: s (str): string to be constructed wordDict (List[str]): list of words Returns: bool: \`True\` if s can be constructed by concatenating one or more words from wordDict, \`False\` otherwise. >>> canConstruct(\\"applepie\\", [\\"apple\\", \\"pie\\"]) True >>> canConstruct(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> canConstruct(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> canConstruct(\\"\\", [\\"apple\\", \\"pie\\"]) True >>> canConstruct(\\"banana\\", [\\"apple\\", \\"pie\\", \\"banana\\"]) True >>> canConstruct(\\"applex\\", [\\"apple\\", \\"pie\\", \\"app\\"]) False >>> canConstruct(\\"pineapplepenapple\\", [\\"pine\\", \\"apple\\", \\"pen\\", \\"applepen\\", \\"pineapple\\"]) True >>> canConstruct(\\"a\\", [\\"a\\"]) True >>> canConstruct(\\"a\\", [\\"b\\"]) False >>> canConstruct(\\"aaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) True >>> canConstruct(\\"ab\\", [\\"a\\", \\"c\\"]) False","solution":"def canConstruct(s, wordDict): Determines if the string s can be constructed by concatenating one or more words from the provided list of words. :param s: A string to be constructed :param wordDict: A list of strings (words) :return: Boolean indicating if s can be fully constructed from wordDict word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)] # Example usage: # print(canConstruct(\\"applepie\\", [\\"apple\\", \\"pie\\"])) # Should return True # print(canConstruct(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"])) # Should return False"},{"question":"def trap_water(heights: List[int]) -> int: Calculate the total amount of trapped water given the heights of blocks. >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9 >>> trap_water([2,1,0,2]) 3","solution":"def trap_water(heights): Calculate the total amount of trapped water given heights of blocks. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left <= right: if left_max < right_max: if heights[left] < left_max: water_trapped += left_max - heights[left] else: left_max = heights[left] left += 1 else: if heights[right] < right_max: water_trapped += right_max - heights[right] else: right_max = heights[right] right -= 1 return water_trapped"},{"question":"def is_match(s: str, p: str) -> bool: Checks if string s matches the pattern p. '.' Matches any single character. '*' Matches zero or more of the preceding element. >>> is_match(\\"aab\\", \\"aab\\") == True >>> is_match(\\"abc\\", \\"a.c\\") == True >>> is_match(\\"aa\\", \\"a*\\") == True >>> is_match(\\"aab\\", \\"c*a*b\\") == True >>> is_match(\\"\\", \\"\\") == True >>> is_match(\\"\\", \\"c*\\") == True >>> is_match(\\"aab\\", \\"\\") == False >>> is_match(\\"mississippi\\", \\"mis*is*p*.\\") == False >>> is_match(\\"aaa\\", \\"a*a\\") == True >>> is_match(\\"ab\\", \\".*\\") == True","solution":"def is_match(s: str, p: str) -> bool: Checks if string s matches the pattern p. '.' Matches any single character. '*' Matches zero or more of the preceding element. # dp[i][j] will be True if the first i characters in s match # the first j characters in p dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # An empty string matches with an empty pattern dp[0][0] = True # Only '*' can match with an empty string, and it must be valid for j in range(1, len(p) + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == '.': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == '*': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.')) return dp[len(s)][len(p)]"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list in ascending order. >>> merge_sorted_lists([], []) == [] >>> merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 2], [2, 3, 4]) == [1, 2, 2, 2, 3, 4] >>> list1 = list(range(500)) >>> list2 = list(range(500, 1000)) >>> merge_sorted_lists(list1, list2) == list(range(1000)) >>> merge_sorted_lists([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list in ascending order. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements of list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def find_longest_palindrome(s: str) -> str: Create a function that takes a string \`s\` as an input and returns the longest palindromic substring. If there are multiple substrings of the same length, return the first one that appears. >>> find_longest_palindrome(\\"babad\\") 'bab' >>> find_longest_palindrome(\\"cbbd\\") 'bb' >>> find_longest_palindrome(\\"a\\") 'a' >>> find_longest_palindrome(\\"abc\\") 'a' >>> find_longest_palindrome(\\"babad\\") 'bab' >>> find_longest_palindrome(\\"cbbd\\") 'bb' >>> find_longest_palindrome(\\"racecar\\") 'racecar' >>> find_longest_palindrome(\\"aacabdkacaa\\") 'aca' >>> find_longest_palindrome(\\"\\") '' >>> find_longest_palindrome(\\"forgeeksskeegfor\\") 'geeksskeeg'","solution":"def find_longest_palindrome(s): def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if len(s) == 0: return \\"\\" longest_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes palindrome_odd = expand_around_center(i, i) # Even length palindromes palindrome_even = expand_around_center(i, i + 1) # Update the longest palindrome found if len(palindrome_odd) > len(longest_palindrome): longest_palindrome = palindrome_odd if len(palindrome_even) > len(longest_palindrome): longest_palindrome = palindrome_even return longest_palindrome"},{"question":"def validate_rentals(rentals, toy_limits): Validates rentals against toy_limits and returns a list of invalid rentals. Parameters: rentals (list of tuples): List of rental records with each record as (customer_id, toy_id, days_rented) toy_limits (list of tuples): List of toy limits with each limit as (toy_id, max_days) Returns: list of tuples: List of invalid rental records Examples: >>> validate_rentals([(1, 101, 3), (2, 102, 5), (3, 101, 2)], [(101, 3), (102, 4)]) [(2, 102, 5)] >>> validate_rentals([(1, 101, 3), (2, 102, 4), (3, 101, 2)], [(101, 3), (102, 4)]) [] >>> validate_rentals([(1, 101, 4), (2, 103, 2)], [(101, 3), (102, 4)]) [(1, 101, 4)] pass","solution":"def validate_rentals(rentals, toy_limits): Validates rentals against toy_limits and returns a list of invalid rentals. Parameters: rentals (list of tuples): List of rental records with each record as (customer_id, toy_id, days_rented) toy_limits (list of tuples): List of toy limits with each limit as (toy_id, max_days) Returns: list of tuples: List of invalid rental records # Create a dictionary from toy_limits for quick lookup toy_limit_dict = {toy_id: max_days for toy_id, max_days in toy_limits} # Check each rental record invalid_rentals = [ (customer_id, toy_id, days_rented) for customer_id, toy_id, days_rented in rentals if days_rented > toy_limit_dict.get(toy_id, 0) ] return invalid_rentals"},{"question":"def min_path_length(matrix): Determines the minimum path length in a binary matrix from (0,0) to (N-1, M-1) :param matrix: List[List[int]] A binary matrix with obstacles :return: int The length of the shortest path, or -1 if no path exists","solution":"from collections import deque def min_path_length(matrix): Determines the minimum path length in a binary matrix from (0,0) to (N-1, M-1) :param matrix: List[List[int]] A binary matrix with obstacles :return: int The length of the shortest path, or -1 if no path exists N = len(matrix) M = len(matrix[0]) # Check if the start or end is blocked if matrix[0][0] == 1 or matrix[N-1][M-1] == 1: return -1 # Directions vectors for moving up, down, left, or right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we reached the bottom-right cell if r == N-1 and c == M-1: return dist # Explore all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc # Check if the new position is within bounds and not visited and not an obstacle if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited and matrix[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) # If we exhaust the queue without finding the path return -1"},{"question":"def extract_consecutive_duplicates(lst: List[int]) -> List[int]: Removes all consecutive duplicates from the list and returns the modified list. >>> extract_consecutive_duplicates([1, 1, 2, 3, 3, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> extract_consecutive_duplicates([1, 2, 2, 3, 1, 1, 2]) [1, 2, 3, 1, 2]","solution":"def extract_consecutive_duplicates(lst): Removes all consecutive duplicates from the list and returns the modified list. if not lst: return [] result = [lst[0]] for item in lst[1:]: if item != result[-1]: result.append(item) return result"},{"question":"def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: Find the median of two sorted arrays. Args: nums1: List of integers sorted in ascending order. nums2: List of integers sorted in ascending order. Returns: The median of the combined sorted array, or None if both arrays are empty. >>> findMedianSortedArrays([1, 3], [2]) -> 2.0 >>> findMedianSortedArrays([1, 2], [3, 4]) -> 2.5 If both arrays are empty, return None. pass","solution":"def findMedianSortedArrays(nums1, nums2): Find the median of two sorted arrays. Args: nums1: List of integers sorted in ascending order. nums2: List of integers sorted in ascending order. Returns: The median of the combined sorted array. if not nums1 and not nums2: return None merged = sorted(nums1 + nums2) n = len(merged) if n % 2 == 1: return float(merged[n // 2]) else: return (merged[(n // 2) - 1] + merged[n // 2]) / 2.0"},{"question":"def detectLanguage(message: str) -> str: This function detects whether the input string is in English, French, or Spanish based on predefined unique words for each language. >>> detectLanguage(\\"Hello, how are you today?\\") 'English' >>> detectLanguage(\\"Bonjour, comment ça va aujourd'hui?\\") 'French' >>> detectLanguage(\\"Hola, ¿cómo estás hoy?\\") 'Spanish'","solution":"def detectLanguage(message): This function detects whether the input string is in English, French, or Spanish based on predefined unique words for each language. english_words = {\\"hello\\", \\"how\\", \\"are\\", \\"you\\", \\"today\\"} french_words = {\\"bonjour\\", \\"comment\\", \\"ça\\", \\"va\\", \\"aujourd'hui\\"} spanish_words = {\\"hola\\", \\"cómo\\", \\"estás\\", \\"hoy\\"} message = message.lower() words = set(message.split()) english_count = len(words.intersection(english_words)) french_count = len(words.intersection(french_words)) spanish_count = len(words.intersection(spanish_words)) if english_count >= french_count and english_count >= spanish_count: return 'English' elif french_count >= english_count and french_count >= spanish_count: return 'French' else: return 'Spanish'"},{"question":"def basic_calculator(expression: str) -> [int, float]: Simulates a basic calculator to perform arithmetic operations. Parameters: expression (str): A string representing a mathematical expression (e.g., \\"3 + 5\\"). Returns: int/float: The result of the arithmetic operation. >>> basic_calculator(\\"3 + 5\\") 8 >>> basic_calculator(\\"10 - 4\\") 6 >>> basic_calculator(\\"6 * 7\\") 42 >>> basic_calculator(\\"8 / 2\\") 4.0 >>> basic_calculator(\\"9 / 2\\") 4.5","solution":"def basic_calculator(expression): Simulates a basic calculator to perform arithmetic operations. Parameters: expression (str): A string representing a mathematical expression (e.g., \\"3 + 5\\"). Returns: int/float: The result of the arithmetic operation. # Split the expression into components num1, operator, num2 = expression.split() # Convert the numbers from strings to integers num1 = int(num1) num2 = int(num2) # Perform the appropriate arithmetic operation if operator == '+': return num1 + num2 elif operator == '-': return num1 - num2 elif operator == '*': return num1 * num2 elif operator == '/': return num1 / num2 # Note that division always returns a float"},{"question":"def longest_consecutive_sequence(nums): Given an input list of integers, return the length of the longest consecutive elements sequence in the given list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 >>> longest_consecutive_sequence([9, 1, 3, 5, 7]) == 1 >>> longest_consecutive_sequence([5]) == 1 >>> longest_consecutive_sequence([]) == 0 >>> longest_consecutive_sequence([1, 3]) == 1 >>> longest_consecutive_sequence([2, 1]) == 2 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) == 4 >>> longest_consecutive_sequence(list(range(10000))) == 10000 >>> longest_consecutive_sequence([10, 5, 2, 9, 6, 7, 8, 1, 3, 4, 0, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 21","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in the given list. num_set = set(nums) longest_length = 0 for num in nums: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def max_even_sum_subarray_length(N: int, cards: List[int]) -> int: Determine the maximum length of a contiguous subarray with an even sum. Args: N (int): The number of cards. cards (List[int]): The list of card values. Returns: int: The maximum length of such a subarray. >>> max_even_sum_subarray_length(6, [1, 2, 3, 4, 5, 6]) 5 >>> max_even_sum_subarray_length(4, [2, 4, 6, 8]) 4 >>> max_even_sum_subarray_length(5, [1, 3, 5, 7, 9]) 4 >>> max_even_sum_subarray_length(5, [1, 2, 3, 4, 5]) 4 >>> max_even_sum_subarray_length(1, [2]) 1 >>> max_even_sum_subarray_length(1, [1]) 0 >>> max_even_sum_subarray_length(3, [1, 1, 1]) 2","solution":"def max_even_sum_subarray_length(N, cards): This function returns the maximum length of a contiguous subarray with even sum. total_sum = sum(cards) if total_sum % 2 == 0: return N first_odd_index = -1 last_odd_index = -1 for i in range(N): if cards[i] % 2 != 0: if first_odd_index == -1: first_odd_index = i last_odd_index = i if first_odd_index == -1: return 0 max_length_excluding_first_odd = N - first_odd_index - 1 max_length_excluding_last_odd = last_odd_index return max(max_length_excluding_first_odd, max_length_excluding_last_odd)"},{"question":"def permutations(string): Generates all permutations of a given string. :param string: The string to permute. :return: A list of all possible permutations of the given string. >>> permutations(\\"A\\") [\\"A\\"] >>> permutations(\\"AB\\") [\\"AB\\", \\"BA\\"] >>> permutations(\\"ABC\\") [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] >>> permutations(\\"ABCD\\") a list containing 24 permutations >>> permutations(\\"AAB\\") [\\"AAB\\", \\"ABA\\", \\"BAA\\"]","solution":"def permutations(string): Generates all permutations of a given string. :param string: The string to permute. :return: A list of all possible permutations of the given string. # Base case: if the string is empty, return an empty list if len(string) == 0: return [''] perm_list = [] # result list to hold all the permutations for i in range(len(string)): # Extract the current character char = string[i] # Get the remaining substring after excluding the current character remaining_string = string[:i] + string[i+1:] # Recursively generate permutations of the remaining substring for sub_perm in permutations(remaining_string): perm_list.append(char + sub_perm) return perm_list"},{"question":"def can_be_palindromic(n: int, pattern: str) -> str: Determines if the binary string pattern can be shifted to form a palindrome. Parameters: n (int): Length of the pattern pattern (str): Binary string representing the initial pattern of the lights Returns: str: \\"YES\\" if a palindromic pattern can be formed by shifting, \\"NO\\" otherwise Examples: >>> can_be_palindromic(7, \\"1011001\\") 'YES' >>> can_be_palindromic(5, \\"11011\\") 'YES' >>> can_be_palindromic(4, \\"1010\\") 'NO'","solution":"def can_be_palindromic(n, pattern): Determines if the binary string pattern can be shifted to form a palindrome. Parameters: n (int): Length of the pattern pattern (str): Binary string representing the initial pattern of the lights Returns: str: \\"YES\\" if a palindromic pattern can be formed by shifting, \\"NO\\" otherwise def is_palindrome(s): return s == s[::-1] for k in range(n): if is_palindrome(pattern[k:] + pattern[:k]): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def smallest_permutation_with_substrings(s: str, a: str, b: str) -> str: Finds the lexicographically smallest permutation of s that contains substrings a and b at least once. pass def solve(t: int, cases: List[Tuple[str, str, str]]) -> List[str]: For each test case, find the lexicographically smallest permutation of s which contains at least one instance of both substrings a and b as substrings. If no such permutation exists, return \\"IMPOSSIBLE\\". pass # Sample test cases if __name__ == \\"__main__\\": print(solve(3, [(\\"abcd\\", \\"ab\\", \\"cd\\"), (\\"abcdefg\\", \\"abc\\", \\"efg\\"), (\\"abc\\", \\"def\\", \\"ghi\\")])) # Expected output: [\\"abcd\\", \\"abcdefg\\", \\"IMPOSSIBLE\\"]","solution":"from itertools import permutations def smallest_permutation_with_substrings(s, a, b): Finds the lexicographically smallest permutation of s that contains substrings a and b at least once. sorted_s = sorted(s) for perm in permutations(sorted_s): perm_str = ''.join(perm) if a in perm_str and b in perm_str: return perm_str return \\"IMPOSSIBLE\\" def solve(t, cases): results = [] for i in range(t): s, a, b = cases[i] results.append(smallest_permutation_with_substrings(s, a, b)) return results"},{"question":"import re def replace_abbreviations(input_string: str) -> str: Replace certain abbreviations with their corresponding full phrases. - 'kg' becomes 'kilograms' - 'cm' becomes 'centimeters' - 'mL' becomes 'milliliters' - 'km' becomes 'kilometers' - 'hr' becomes 'hours' - 'ft' becomes 'feet' - 'lb' becomes 'pounds' The function ensures numerical values are preserved and sentences start with capital letters. >>> replace_abbreviations(\\"The package weighs 5kg and it has a length of 3ft.\\") \\"The package weighs 5 kilograms and it has a length of 3 feet.\\" >>> replace_abbreviations(\\"She ran 10km in 2hr and drank 500mL of water.\\") \\"She ran 10 kilometers in 2 hours and drank 500 milliliters of water.\\" >>> replace_abbreviations(\\"John lifted 50kg and lost 5lb in the process.\\") \\"John lifted 50 kilograms and lost 5 pounds in the process.\\" >>> replace_abbreviations(\\"The speed was 5mph.\\") \\"The speed was 5mph.\\" >>> replace_abbreviations(\\"He lifted 20kg yesterday. then he ran 5km.\\") \\"He lifted 20 kilograms yesterday. Then he ran 5 kilometers.\\"","solution":"import re def replace_abbreviations(input_string): replacements = { 'kg': 'kilograms', 'cm': 'centimeters', 'mL': 'milliliters', 'km': 'kilometers', 'hr': 'hours', 'ft': 'feet', 'lb': 'pounds' } def replace_match(match): value = match.group(1) unit = match.group(2) return f\\"{value} {replacements[unit]}\\" pattern = re.compile(r'(d+)(kg|cm|mL|km|hr|ft|lb)') result = re.sub(pattern, replace_match, input_string) # Ensure sentences still start correctly with capital letters result = '. '.join(sentence.capitalize() for sentence in result.split('. ')) return result"},{"question":"def unique_elements(lst: List[int]) -> List[int]: Returns a list of unique elements from the given list, maintaining their original order of first appearance. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] >>> unique_elements([4, 5, 4, 5, 4, 6]) == [6] >>> unique_elements([1, 2, 3]) == [1, 2, 3] >>> unique_elements([1, 1, 1, 1, 1]) == [] >>> unique_elements([]) == [] >>> unique_elements([100]) == [100] >>> unique_elements([-1, 2, 2, -3, -1, 4]) == [-3, 4]","solution":"def unique_elements(lst): Returns a list of unique elements from the given list, maintaining their original order of first appearance. result = [] for ele in lst: if lst.count(ele) == 1: result.append(ele) return result"},{"question":"def collect_magic_potions(items: List[str], known_ingredients: List[str]) -> str: Returns a message indicating whether any known magic potion ingredients are found in the items list. >>> collect_magic_potions(['Eye_of_Newt', 'Wormwood', 'Pixie_Dust'], ['Eye_of_Newt', 'Dragon_Scale', 'Unicorn_Hair', 'Phoenix_Feather', 'Bloodroot', 'Mandrake_Root', 'Bat_Wing', 'Mistletoe_Berry']) \\"A potion is brewing! Eye_of_Newt\\" >>> collect_magic_potions(['Stardust', 'Fairy_Wing'], ['Eye_of_Newt', 'Dragon_Scale', 'Unicorn_Hair', 'Phoenix_Feather', 'Bloodroot', 'Mandrake_Root', 'Bat_Wing', 'Mistletoe_Berry']) \\"No potion today\\" >>> collect_magic_potions(['Eye_of_Newt', 'Dragon_Scale', 'Phoenix_Feather', 'Mandrake_Root'], ['Eye_of_Newt', 'Dragon_Scale', 'Unicorn_Hair', 'Phoenix_Feather', 'Bloodroot', 'Mandrake_Root', 'Bat_Wing', 'Mistletoe_Berry']) \\"A potion is brewing! Eye_of_Newt, Dragon_Scale, Phoenix_Feather, Mandrake_Root\\" >>> collect_magic_potions([], ['Eye_of_Newt', 'Dragon_Scale', 'Unicorn_Hair', 'Phoenix_Feather', 'Bloodroot', 'Mandrake_Root', 'Bat_Wing', 'Mistletoe_Berry']) \\"No potion today\\" >>> collect_magic_potions(['Eye_of_Newt', 'Wormwood', 'Bloodroot'], ['Eye_of_Newt', 'Dragon_Scale', 'Unicorn_Hair', 'Phoenix_Feather', 'Bloodroot', 'Mandrake_Root', 'Bat_Wing', 'Mistletoe_Berry']) \\"A potion is brewing! Eye_of_Newt, Bloodroot\\"","solution":"def collect_magic_potions(items, known_ingredients): Returns a message indicating whether any known magic potion ingredients are found in the items list. found_ingredients = [item for item in items if item in known_ingredients] if found_ingredients: return f\\"A potion is brewing! {', '.join(found_ingredients)}\\" else: return \\"No potion today\\""},{"question":"def min_cost_path(n, m, a, b, node_values, edges): Returns the minimum cost path between two nodes in a graph with N nodes and M edges, where each node has a value representing the cost to visit that node. :param n: Number of nodes :param m: Number of edges :param a: Starting node :param b: Ending node :param node_values: List of integers representing the value of each node :param edges: List of tuples where each tuple contains two integers (u, v) representing an edge between nodes u and v :return: Minimum cost path value between nodes A and B, or -1 if no such path exists >>> min_cost_path(5, 6, 1, 5, [2, 5, 1, 3, 4], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5)]) 4 >>> min_cost_path(5, 4, 1, 5, [2, 5, 1, 3, 4], [(1, 2), (1, 3), (2, 4), (3, 4)]) -1 >>> min_cost_path(1, 0, 1, 1, [10], []) 10 >>> min_cost_path(3, 2, 1, 3, [1, 2, 3], [(1, 2), (2, 3)]) 3 >>> min_cost_path(4, 4, 1, 4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (1, 4)]) 4 >>> min_cost_path(4, 3, 2, 2, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) 2 pass","solution":"import heapq def min_cost_path(n, m, a, b, node_values, edges): Returns the minimum cost path between two nodes in a graph with N nodes and M edges, where each node has a value representing the cost to visit that node. :param n: Number of nodes :param m: Number of edges :param a: Starting node :param b: Ending node :param node_values: List of integers representing the value of each node :param edges: List of tuples where each tuple contains two integers (u, v) representing an edge between nodes u and v :return: Minimum cost path value between nodes A and B, or -1 if no such path exists graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) # Priority queue to store (cost, node) pq = [(node_values[a-1], a-1)] visited = [False] * n while pq: cost, node = heapq.heappop(pq) if visited[node]: continue visited[node] = True if node == b-1: return cost for neighbor in graph[node]: if not visited[neighbor]: heapq.heappush(pq, (max(cost, node_values[neighbor]), neighbor)) return -1"},{"question":"def minimum_subarray_reversals(n, initial, target): Returns the minimum number of subarray reversals needed to transform the initial array into the target array, or -1 if it's not possible. Parameters: n (int): the number of elements in the array initial (list of int): the initial array target (list of int): the target array Returns: int: the minimum number of subarray reversals required or -1 if not possible Example: >>> minimum_subarray_reversals(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 1 >>> minimum_subarray_reversals(3, [1, 3, 2], [2, 1, 4]) -1 pass","solution":"def minimum_subarray_reversals(n, initial, target): Returns the minimum number of subarray reversals needed to transform the initial array into the target array, or -1 if it's not possible. Parameters: n (int): the number of elements in the array initial (list of int): the initial array target (list of int): the target array Returns: int: the minimum number of subarray reversals required or -1 if not possible if sorted(initial) != sorted(target): return -1 operations = 0 i = 0 while i < n: if initial[i] != target[i]: j = i while initial[j] != target[i]: j += 1 initial[i:j+1] = reversed(initial[i:j+1]) operations += 1 i += 1 return operations"},{"question":"def calcWaterTrap(heights): Calculate the total units of water trapped between buildings after it rains. Parameters: heights (list of int): A list of non-negative integers representing the height of buildings. Returns: int: Total units of water trapped. >>> calcWaterTrap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> calcWaterTrap([]) == 0 >>> calcWaterTrap([3]) == 0 >>> calcWaterTrap([3, 3, 3, 3]) == 0 >>> calcWaterTrap([4, 3, 2, 1]) == 0 >>> calcWaterTrap([3, 0, 2, 0, 4]) == 7 >>> calcWaterTrap([0, 0, 0, 0, 0]) == 0","solution":"def calcWaterTrap(heights): Calculate the total units of water trapped between buildings after it rains. Parameters: heights (list of int): A list of non-negative integers representing the height of buildings. Returns: int: Total units of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the water that can be trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def find_pair_with_sum(nums, target): Write a function \`find_pair_with_sum(nums, target)\` that takes a list of integers \`nums\` and an integer \`target\`, and returns a boolean indicating whether there exist two distinct elements in the list that add up to \`target\`. >>> find_pair_with_sum([2, 7, 11, 15], 9) True >>> find_pair_with_sum([1, 2, 3, 9], 8) False >>> find_pair_with_sum([1, 2, 4, 4], 8) True from solution import find_pair_with_sum def test_example_1(): nums = [2, 7, 11, 15] target = 9 assert find_pair_with_sum(nums, target) == True def test_example_2(): nums = [1, 2, 3, 9] target = 8 assert find_pair_with_sum(nums, target) == False def test_example_3(): nums = [1, 2, 4, 4] target = 8 assert find_pair_with_sum(nums, target) == True def test_empty_list(): nums = [] target = 1 assert find_pair_with_sum(nums, target) == False def test_single_element_list(): nums = [5] target = 5 assert find_pair_with_sum(nums, target) == False def test_negative_numbers(): nums = [-2, -1, 1, 2] target = 0 assert find_pair_with_sum(nums, target) == True def test_zero_elements(): nums = [0, 0, 3, 4] target = 0 assert find_pair_with_sum(nums, target) == True def test_large_numbers(): nums = [1000000, 500000, -1000000, -500000] target = 0 assert find_pair_with_sum(nums, target) == True def test_duplicates(): nums = [5, 5, 5, 5] target = 10 assert find_pair_with_sum(nums, target) == True def test_no_duplicates_needed(): nums = [1, 1, 1, 1] target = 2 assert find_pair_with_sum(nums, target) == True def test_no_pair_found(): nums = [1, 3, 5, 7] target = 2 assert find_pair_with_sum(nums, target) == False","solution":"def find_pair_with_sum(nums, target): Returns True if there are two distinct elements in nums that add up to target. Otherwise, returns False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def process_tasks(tasks: List[Tuple[str, int]]) -> List[str]: Processes tasks in FIFO order and returns a list of task identifiers in the order they finished processing. Parameters: tasks (list of tuples): Each tuple contains a string identifier and an integer processing time. Returns: list: A list of task identifiers in the order they finished processing. Example: >>> process_tasks([(\\"task1\\", 3), (\\"task2\\", 2), (\\"task3\\", 1)]) [\\"task1\\", \\"task2\\", \\"task3\\"] >>> process_tasks([(\\"A\\", 1), (\\"B\\", 1), (\\"C\\", 1)]) [\\"A\\", \\"B\\", \\"C\\"]","solution":"def process_tasks(tasks): Processes tasks in FIFO order and returns a list of task identifiers in the order they finished processing. Parameters: tasks (list of tuples): Each tuple contains a string identifier and an integer processing time. Returns: list: A list of task identifiers in the order they finished processing. finished_tasks = [] for task in tasks: identifier, processing_time = task finished_tasks.append(identifier) return finished_tasks"},{"question":"def decrypt_message(message: str, key: str) -> str: Decrypts a message encrypted with a simple substitution cipher using the provided key. >>> decrypt_message(\\"ifmmp\\", \\"bcdefghijklmnopqrstuvwxyza\\") \\"hello\\" >>> decrypt_message(\\"bcd\\", \\"bcdefghijklmnopqrstuvwxyza\\") \\"abc\\" >>> decrypt_message(\\"zyx\\", \\"zyxwvutsrqponmlkjihgfedcba\\") \\"abc\\" >>> decrypt_message(\\"hello\\", \\"abcdefghijklmnopqrstuvwxyz\\") \\"hello\\" >>> decrypt_message(\\"ifmmpxpsme\\", \\"bcdefghijklmnopqrstuvwxyza\\") \\"helloworld\\"","solution":"def decrypt_message(message, key): Decrypts a message encrypted with a simple substitution cipher using the key. # Create a dictionary for the substitution key mapping key_map = {key[i]: chr(97 + i) for i in range(26)} # Decrypt the message decrypted_message = ''.join(key_map[char] for char in message) return decrypted_message"},{"question":"def rotate_matrix(matrix): Rotates a given NxN matrix 90 degrees clockwise. Args: matrix (list of list of int): The NxN matrix to be rotated. Returns: list of list of int: The rotated NxN matrix. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) [[3, 1], [4, 2]] # Your implementation here # Test cases def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = rotate_matrix(matrix) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotated == expected def test_rotate_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] rotated = rotate_matrix(matrix) expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotated == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] rotated = rotate_matrix(matrix) expected = [ [1] ] assert rotated == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotated = rotate_matrix(matrix) expected = [ [3, 1], [4, 2] ] assert rotated == expected def test_rotate_empty_matrix(): matrix = [] rotated = rotate_matrix(matrix) expected = [] assert rotated == expected","solution":"def rotate_matrix(matrix): Rotates a given NxN matrix 90 degrees clockwise. Args: matrix (list of list of int): The NxN matrix to be rotated. Returns: list of list of int: The rotated NxN matrix. if not matrix: return [] n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"}]`),F={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:C,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},E={class:"card-container"},j={key:0,class:"empty-state"},D=["disabled"],P={key:0},I={key:1};function z(n,e,l,m,i,a){const f=p("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):u("",!0)]),t("div",E,[(s(!0),r(y,null,v(a.displayedPoems,(o,h)=>(s(),w(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",j,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",I,"Loading...")):(s(),r("span",P,"See more"))],8,D)):u("",!0)])}const M=c(F,[["render",z],["__scopeId","data-v-f44b73fc"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/59.md","filePath":"grok/59.md"}'),B={name:"grok/59.md"},G=Object.assign(B,{setup(n){return(e,l)=>(s(),r("div",null,[x(M)]))}});export{Y as __pageData,G as default};
