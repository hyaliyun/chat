import{_,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function S(i,e,u,m,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const A=_(q,[["render",S],["__scopeId","data-v-6c988f50"]]),R=JSON.parse(`[{"question":"def largest_same_animal_area(n: int, m: int, grid: List[str]) -> int: Find the largest rectangular area on the grid such that all animals in that rectangular area are of the same type. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[str] : grid representing the farm with animals and empty cells Returns: int : the area of the largest rectangle that contains only one type of animal Examples: >>> largest_same_animal_area(4, 5, [\\"aabba\\", \\"abbba\\", \\"aabba\\", \\"bbbaa\\"]) 6 >>> largest_same_animal_area(3, 3, [\\"ccc\\", \\"c.c\\", \\"ccc\\"]) 3","solution":"def largest_same_animal_area(n, m, grid): def calculate_max_histogram_area(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_area = 0 for animal in 'abcdefghijklmnopqrstuvwxyz': height = [0] * m for i in range(n): for j in range(m): if grid[i][j] == animal: height[j] += 1 else: height[j] = 0 max_area = max(max_area, calculate_max_histogram_area(height)) return max_area"},{"question":"def isSquareFree(n: int) -> bool: Returns True if n is a square-free number, False otherwise. >>> isSquareFree(15) True >>> isSquareFree(18) False >>> isSquareFree(31) True >>> isSquareFree(45) False >>> isSquareFree(1) True >>> isSquareFree(1000000000) False >>> isSquareFree(2) True >>> isSquareFree(4) False >>> isSquareFree(1000003) True","solution":"def isSquareFree(n): Returns True if n is a square-free number, False otherwise. # The largest integer k such that k^2 <= n k = int(n**0.5) # Check divisibility by squares of all integers from 2 to k for i in range(2, k + 1): if n % (i * i) == 0: return False return True"},{"question":"def minimum_bombs_to_destroy_ring(t: int, test_cases: List[int]) -> List[int]: Determine the minimum number of bombs required to destroy all cells in the ring. Args: t : int : The number of test cases. test_cases : List[int] : A list of integers representing the size of each circular ring. Returns: List[int] : A list of integers representing the minimum number of bombs required for each test case. >>> minimum_bombs_to_destroy_ring(3, [4, 7, 6]) [2, 3, 2] >>> minimum_bombs_to_destroy_ring(1, [3]) [1] >>> minimum_bombs_to_destroy_ring(1, [10]) [4]","solution":"def minimum_bombs_to_destroy_ring(t, test_cases): results = [] for n in test_cases: # Calculate the minimum number of bombs if n % 3 == 0: min_bombs = n // 3 else: min_bombs = (n // 3) + 1 results.append(min_bombs) return results"},{"question":"def longest_palindrome(s: str) -> str: Find the longest palindromic substring in the given string s. If the length of s is 0, return an empty string. >>> longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome(\\"cbbd\\") == \\"bb\\" True >>> longest_palindrome(\\"a\\") == \\"a\\" True >>> longest_palindrome(\\"ac\\") in [\\"a\\", \\"c\\"] True","solution":"def longest_palindrome(s): This function returns the longest palindromic substring in the given string s. If the length of s is 0, the function returns an empty string. if len(s) == 0: return \\"\\" def expand_from_center(left, right): Helper function to expand from the center and find the longest palindrome while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest_palindromic_substring = \\"\\" for i in range(len(s)): # Odd length palindromes substring1 = expand_from_center(i, i) if len(substring1) > len(longest_palindromic_substring): longest_palindromic_substring = substring1 # Even length palindromes substring2 = expand_from_center(i, i + 1) if len(substring2) > len(longest_palindromic_substring): longest_palindromic_substring = substring2 return longest_palindromic_substring"},{"question":"def can_form_palindromic_permutation(s: str) -> str: Determine if any permutation of the string can form a palindrome. >>> can_form_palindromic_permutation(\\"aabb\\") == \\"YES\\" >>> can_form_palindromic_permutation(\\"aaab\\") == \\"NO\\" >>> can_form_palindromic_permutation(\\"civic\\") == \\"YES\\"","solution":"def can_form_palindromic_permutation(s): Determine if any permutation of the string s can form a palindrome. # Create a dictionary to count occurrences of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count how many characters have an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be able to form a palindrome: # If its length is even, all characters must have an even count # If its length is odd, one character can have an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"from typing import List class WordFilter: Implements a class WordFilter that supports the following methods: - \`WordFilter(words: List[str])\` initializes the object with the \`words\` containing a list of lowercase words. - \`f(prefix: str, suffix: str) -> int\` returns the index of the word in the initialized words that has the given \`prefix\` and \`suffix\`. If there is more than one valid index, return the largest of them. If there is no such word in the list, return -1. Example: >>> wf = WordFilter([\\"apple\\", \\"banana\\", \\"apricot\\"]) >>> wf.f(\\"ap\\", \\"e\\") 0 >>> wf.f(\\"ba\\", \\"a\\") 1 >>> wf.f(\\"ap\\", \\"ot\\") 2 >>> wf.f(\\"ap\\", \\"p\\") -1 def __init__(self, words: List[str]): # Initialize the WordFilter object with the list of words def f(self, prefix: str, suffix: str) -> int: # Return the index of the word with given prefix and suffix","solution":"from typing import List class WordFilter: def __init__(self, words: List[str]): self.word_map = {} for i, word in enumerate(words): self.word_map[word] = i def f(self, prefix: str, suffix: str) -> int: max_index = -1 for word in self.word_map: if word.startswith(prefix) and word.endswith(suffix): if self.word_map[word] > max_index: max_index = self.word_map[word] return max_index"},{"question":"def minimal_steps_to_determine_fault(n, E, J, moves, safety): Determine the minimal number of steps required to conclusively identify the actual starting position of Emma and Jack. Parameters: n (int): The number of sections. E (int): The section index where Emma thinks they are. J (int): The section index where Jack thinks they are. moves (List[List[int]]): The list of move options from each section. safety (List[int]): The list indicating whether each section is safe (1) or contains a trap (0). Returns: int or str: The minimal number of steps to determine the wrong starting point, or \\"undecidable\\" if it cannot be concluded. >>> n = 4 >>> E = 0 >>> J = 1 >>> moves = [[1, 2, -1, -1], [-1, -1, 2, 3], [0, -1, -1, -1], [-1, -1, -1, -1]] >>> safety = [1, 1, 1, 0] >>> minimal_steps_to_determine_fault(n, E, J, moves, safety) 2 >>> n = 3 >>> E = 0 >>> J = 2 >>> moves = [[1, 2, -1, -1], [-1, -1, 0, 2], [-1, -1, 1, -1]] >>> safety = [1, 1, 1] >>> minimal_steps_to_determine_fault(n, E, J, moves, safety) 'undecidable'","solution":"from collections import deque def minimal_steps_to_determine_fault(n, E, J, moves, safety): def get_neighbors(position): u, d, l, r = moves[position] neighbors = [] if u != -1: neighbors.append(u) if d != -1: neighbors.append(d) if l != -1: neighbors.append(l) if r != -1: neighbors.append(r) return neighbors queue = deque([(E, J, 0)]) visited = set((E, J)) while queue: e_curr, j_curr, steps = queue.popleft() if safety[e_curr] == 0: return steps + 1 # Emma stepped into a trap elif safety[j_curr] == 0: return steps + 1 # Jack stepped into a trap e_neighbors = get_neighbors(e_curr) j_neighbors = get_neighbors(j_curr) for en in e_neighbors: for jn in j_neighbors: if (en, jn) not in visited: queue.append((en, jn, steps + 1)) visited.add((en, jn)) return \\"undecidable\\""},{"question":"def min_new_roads(m, n, grid): Determine the minimum number of new roads needed to make all road cells directly reachable from the main bus station located at the top-left corner of the grid. A road is represented by '0' and a building by '1'. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid grid (List[List[int]]): the MxN grid with cells marked as 0 or 1 Returns: int: the minimum number of new roads to be constructed or -1 if it's not possible. Examples: >>> min_new_roads(3, 4, [ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 1] ... ]) 2 >>> min_new_roads(3, 3, [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 1, 0] ... ]) 3 pass def test_min_new_roads_example1(): grid = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 0, 1] ] assert min_new_roads(3, 4, grid) == 2 def test_min_new_roads_example2(): grid = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert min_new_roads(3, 3, grid) == 3 def test_min_new_roads_no_additional_needed(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_new_roads(3, 3, grid) == 0 def test_min_new_roads_impossible(): grid = [ [1, 1], [1, 1] ] assert min_new_roads(2, 2, grid) == -1 def test_min_new_roads_single_island(): grid = [ [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 0] ] assert min_new_roads(3, 4, grid) == 3","solution":"def min_new_roads(m, n, grid): from heapq import heappop, heappush from collections import deque if grid[0][0] != 0: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 visited = [[False] * n for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) additional_roads = [] for i in range(m): for j in range(n): if grid[i][j] == 0 and not visited[i][j]: additional_roads.append((i, j)) if not additional_roads: return 0 def bfs_additional_roads(): steps = 0 queue = [(i, j, steps) for i, j in additional_roads] heap = [] for item in queue: heappush(heap, item) while heap: i, j, steps = heappop(heap) if visited[i][j]: continue visited[i][j] = True steps += 1 for dx, dy in directions: ni, nj = i + dx, j + dy if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]: if grid[ni][nj] == 1: heappush(heap, (ni, nj, steps + 1)) else: heappush(heap, (ni, nj, steps)) for i in range(m): for j in range(n): if grid[i][j] == 0 and not visited[i][j]: return -1 return steps return bfs_additional_roads()"},{"question":"def process_inventory_changes(n, changes): Processes a series of inventory changes and outputs the current inventory levels. :param n: Number of inventory changes :param changes: List of tuples with (ID, change) :return: Dictionary with current inventory levels of each book ID with non-zero inventory >>> process_inventory_changes(5, [(1001, 5), (1002, -2), (1001, 3), (1003, 4), (1002, 3)]) == {1001: 8, 1002: 1, 1003: 4} >>> process_inventory_changes(4, [(1001, 5), (1002, -5), (1001, -5), (1002, 5)]) == {}","solution":"def process_inventory_changes(n, changes): Processes a series of inventory changes and outputs the current inventory levels. :param n: Number of inventory changes :param changes: List of tuples with (ID, change) :return: Dictionary with current inventory levels of each book ID with non-zero inventory inventory = {} for ID, change in changes: if ID in inventory: inventory[ID] += change else: inventory[ID] = change if inventory[ID] == 0: del inventory[ID] return dict(sorted(inventory.items())) # Sample Input # n = 5 # changes = [ # (1001, 5), # (1002, -2), # (1001, 3), # (1003, 4), # (1002, 3) # ] # process_inventory_changes(n, changes) # Expected Output # { # 1001: 8, # 1002: 1, # 1003: 4 # }"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes T test cases and returns the results for each one. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"abcdef\\", \\"\\"]) [6, 0] >>> process_test_cases(1, [\\"a\\"]) [1]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_index = {} max_length = start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i max_length = max(max_length, i - start + 1) return max_length def process_test_cases(T, test_cases): Processes T test cases and returns the results for each one. results = [] for i in range(T): results.append(length_of_longest_substring(test_cases[i])) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing positive integers and the operators +, -, * with standard operator precedence. Args: expression (str): A string containing the mathematical expression to be evaluated. Returns: int: The evaluated result of the expression. Examples: >>> evaluate_expression('3 + 5 * 2') 13 >>> evaluate_expression('10 - 2 * 5') 0 >>> evaluate_expression('7 * 4 - 3 + 2') 27","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing positive integers and the operators +, -, * with standard operator precedence. Args: expression (str): A string containing the mathematical expression to be evaluated. Returns: int: The evaluated result of the expression. tokens = expression.split() i = 0 # Handle multiplication first intermediate = [] while i < len(tokens): if tokens[i] == '*': left = int(intermediate.pop()) right = int(tokens[i + 1]) intermediate.append(left * right) i += 2 else: intermediate.append(tokens[i]) i += 1 # Now handle addition and subtraction from left to right result = int(intermediate[0]) i = 1 while i < len(intermediate): if intermediate[i] == '+': result += int(intermediate[i + 1]) elif intermediate[i] == '-': result -= int(intermediate[i + 1]) i += 2 return result"},{"question":"from typing import List, Tuple def overdue_books(current_date: str, borrowed_books: List[Tuple[str, str]]) -> List[str]: Returns a list of book titles that are overdue based on the current date. Parameters: - current_date (str): The current date in 'YYYY-MM-DD' format. - borrowed_books (List[Tuple[str, str]]): A list of tuples where each tuple contains a book title and its return date in 'YYYY-MM-DD' format. Returns: - List[str]: A list of book titles that are overdue. >>> overdue_books('2023-10-25', [('The Catcher in the Rye', '2023-10-20'), ('1984', '2023-10-24')]) ['The Catcher in the Rye', '1984'] >>> overdue_books('2023-10-25', [('To Kill a Mockingbird', '2023-10-25'), ('Pride and Prejudice', '2023-10-26')]) []","solution":"from typing import List, Tuple from datetime import datetime def overdue_books(current_date: str, borrowed_books: List[Tuple[str, str]]) -> List[str]: Returns a list of book titles that are overdue based on the current date. Parameters: - current_date (str): The current date in 'YYYY-MM-DD' format. - borrowed_books (List[Tuple[str, str]]): A list of tuples where each tuple contains a book title and its return date in 'YYYY-MM-DD' format. Returns: - List[str]: A list of book titles that are overdue. overdue = [] current_date_object = datetime.strptime(current_date, '%Y-%m-%d') for title, return_date in borrowed_books: return_date_object = datetime.strptime(return_date, '%Y-%m-%d') if return_date_object < current_date_object: overdue.append(title) return overdue"},{"question":"def can_hackerman_reach_treasure(grid, start, end): Determine if HackerMan can reach the treasure. Args: - grid: List[List[str]], the grid representing the map. - start: Tuple[int, int], the starting coordinates of HackerMan. - end: Tuple[int, int], the coordinates of the treasure. Returns: - bool, True if HackerMan can reach the treasure, otherwise False. def solve(test_cases): Process multiple test cases to see if HackerMan can reach the treasure. Args: - test_cases: List[Tuple[List[List[str]], Tuple[int, int], Tuple[int, int]]], a list of test cases each containing the grid, starting coordinates, and treasure coordinates. Returns: - List[str], List containing \\"YES\\" or \\"NO\\" for each test case result. def parse_input(input_string): Parse the input string into test cases. Args: - input_string: str, the input string containing the number of test cases, and the grid information for each test case. Returns: - List[Tuple[List[List[str]], Tuple[int, int], Tuple[int, int]]], a list of test cases each containing the grid, starting coordinates, and treasure coordinates. # Example Unit Test def test_solution(): input_str = \\"2n5 5nS....n.#.n..#..n.#.n....Tn4 6nS...n.#..#.n.#..#Tn..\\" test_cases = parse_input(input_str) results = solve(test_cases) assert results == [\\"YES\\", \\"NO\\"] def test_edge_cases(): input_str = \\"1n3 3nS..n.#.n..T\\" test_cases = parse_input(input_str) results = solve(test_cases) assert results == [\\"YES\\"] input_str = \\"1n3 3nS..n#n..T\\" test_cases = parse_input(input_str) results = solve(test_cases) assert results == [\\"NO\\"] def test_no_path(): input_str = \\"1n5 5nS....n#n#.#.#n#n....T\\" test_cases = parse_input(input_str) results = solve(test_cases) assert results == [\\"NO\\"]","solution":"def can_hackerman_reach_treasure(grid, start, end): # Helper function for checking neighbors def is_safe(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != '#' from collections import deque M, N = len(grid), len(grid[0]) queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_safe(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False def solve(test_cases): results = [] for grid, start, end in test_cases: if can_hackerman_reach_treasure(grid, start, end): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Input Parsing Function def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): M, N = map(int, lines[index].split()) index += 1 grid = [] for _ in range(M): grid.append(list(lines[index])) index += 1 start = end = None for i in range(M): for j in range(N): if grid[i][j] == 'S': start = (i, j) if grid[i][j] == 'T': end = (i, j) test_cases.append((grid, start, end)) return test_cases"},{"question":"from typing import List def max_subarray_sum(array: List[int]) -> int: Write a function that returns the maximum sum of the contiguous subarray from an array of numbers. The array can contain both positive and negative numbers. If the array is empty or contains only negative numbers, return 0. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) 0 >>> max_subarray_sum([]) 0","solution":"from typing import List def max_subarray_sum(array: List[int]) -> int: if not array: return 0 max_sum = 0 current_sum = 0 for num in array: current_sum = max(0, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def distribute_gold(total_coins: int, pirates: int) -> List[List[int]]: Returns all possible distributions of gold coins to pirates. Each pirate must receive at least one coin and all received amounts must be unique. >>> distribute_gold(10, 4) [[1, 2, 3, 4]] >>> distribute_gold(5, 3) [] >>> distribute_gold(6, 3) [[1, 2, 3]] >>> distribute_gold(15, 5) [[1, 2, 3, 4, 5], ...] >>> distribute_gold(3, 1) [[1]]","solution":"from itertools import permutations from typing import List def distribute_gold(total_coins: int, pirates: int) -> List[List[int]]: Returns all possible distributions of gold coins to pirates. Each pirate must receive at least one coin and all received amounts must be unique. result = [] min_required_coins = sum(range(1, pirates + 1)) if total_coins < min_required_coins: return result # Not enough coins to satisfy the minimum requirement def backtrack(start, remaining_coins, current_distribution): if len(current_distribution) == pirates: if remaining_coins == 0: result.append(current_distribution[:]) return for i in range(start, total_coins + 1): if i > remaining_coins: break current_distribution.append(i) backtrack(i + 1, remaining_coins - i, current_distribution) current_distribution.pop() backtrack(1, total_coins, []) return result"},{"question":"def fastest_delivery_times(n, m, q, facilities, roads, queries): Determine the fastest delivery times for multiple deliveries between given intersections in a city with the condition that at least one intersection with a facility is visited along the path. If no such path exists, return -1. Parameters: n (int): The number of intersections. m (int): The number of roads. q (int): The number of queries. facilities (List[int]): A list indicating the presence (1) or absence (0) of facilities at each intersection. roads (List[Tuple[int, int, int]]): A list of tuples defining the roads in the format (source, target, travel_time). queries (List[Tuple[int, int]]): A list of queries in the format (start, target). Returns: List[int]: A list of integers representing the minimum delivery time for each query. Example: >>> n, m, q = 6, 7, 2 >>> facilities = [1, 0, 1, 0, 0, 1] >>> roads = [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 5, 3), (4, 6, 8), (5, 6, 1)] >>> queries = [(1, 6), (4, 6)] >>> fastest_delivery_times(n, m, q, facilities, roads, queries) [6, 8]","solution":"import heapq def fastest_delivery_times(n, m, q, facilities, roads, queries): graph = [[] for _ in range(n + 1)] for x, y, d in roads: graph[x].append((y, d)) def dijkstra(source, target): pq = [(0, source, False)] dist = {i: float('inf') for i in range(n + 1)} dist[source] = 0 while pq: time, node, has_facility = heapq.heappop(pq) if node == target: if has_facility or facilities[node - 1] == 1: return time for neighbor, d in graph[node]: new_dist = time + d if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor, has_facility or facilities[neighbor - 1] == 1)) return -1 results = [] for u, v in queries: result = dijkstra(u, v) results.append(result) return results"},{"question":"def check_bench_seating(T: int, test_cases: list) -> list: Determine if all benches in a series of test cases adhere to the seating constraints. Each test case consists of a number of benches, their capacities, and their current number of occupants. Args: T : int : Number of test cases test_cases : list : List of test cases, where each test case is a tuple containing: - N : int : Number of benches - capacities : list : List of maximum capacities of the benches - current_people : list : List of current number of people on the benches Returns: list : A list of strings, \\"YES\\" if all benches are within capacity, \\"NO\\" if any bench is over-occupied. >>> check_bench_seating(3, [(3, [4, 5, 2], [3, 5, 2]), (4, [3, 3, 4, 5], [3, 4, 2, 5]), (5, [2, 4, 3, 6, 5], [2, 5, 3, 6, 4])]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> check_bench_seating(1, [(2, [5, 6], [7, 5])]) [\\"NO\\"] >>> check_bench_seating(2, [(1, [3], [2]), (2, [3, 4], [3, 5])]) [\\"YES\\", \\"NO\\"]","solution":"def check_bench_seating(T, test_cases): results = [] for case in test_cases: N = case[0] capacities = case[1] current_people = case[2] is_valid = True for i in range(N): if current_people[i] > capacities[i]: is_valid = False break if is_valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the input string s. >>> count_vowels(\\"hello\\") == 2 >>> count_vowels(\\"AEIOU\\") == 5 >>> count_vowels(\\"bcdfg\\") == 0 >>> count_vowels(\\"hElLo\\") == 2 >>> count_vowels(\\"\\") == 0 >>> count_vowels(\\"1a2e3i4o5u\\") == 5","solution":"def count_vowels(s): Returns the number of vowels in the input string s. vowels = \\"aeiouAEIOU\\" return sum(1 for char in s if char in vowels)"},{"question":"def is_palindrome_possible(k: int, s: str) -> bool: Determine if it's possible to make the string a palindrome by changing at most k characters. >>> is_palindrome_possible(1, \\"abcd\\") False >>> is_palindrome_possible(2, \\"abcca\\") True >>> is_palindrome_possible(0, \\"racecar\\") True pass def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases to determine if each string can be turned into a palindrome. >>> process_test_cases(3, [(1, \\"abcd\\"), (2, \\"abcca\\"), (0, \\"racecar\\")]) [\\"NO\\", \\"YES\\", \\"YES\\"] pass","solution":"def is_palindrome_possible(k, s): n = len(s) mismatch_count = 0 # Calculate the number of mismatched character pairs for i in range(n // 2): if s[i] != s[n - 1 - i]: mismatch_count += 1 return mismatch_count <= k def process_test_cases(t, test_cases): results = [] for i in range(t): k, s = test_cases[i] if is_palindrome_possible(k, s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def max_meal_time_conflicts(n: int, meal_times: List[int]) -> int: Returns the maximum number of meal-time conflicts to resolve. Each rabbit has exactly two preferred meal times in the list. Parameters: n (int): The number of rabbits. meal_times (List[int]): List of integers representing the preferred meal times. Returns: int: The maximum number of meal-time conflicts. >>> max_meal_time_conflicts(2, [5, 8, 8, 5]) 2 >>> max_meal_time_conflicts(3, [1, 2, 3, 1, 2, 3]) 1","solution":"from collections import Counter def max_meal_time_conflicts(n, meal_times): Returns the maximum number of meal-time conflicts to resolve. Parameters: n (int): The number of rabbits. meal_times (list): List of integers representing the preferred meal times. Returns: int: The maximum number of meal-time conflicts. time_counts = Counter(meal_times) return max(time_counts.values())"},{"question":"from typing import List def is_path(grid: List[List[str]]) -> bool: Determine if there is a path of 'O's from the top-left corner to the bottom-right corner of the grid. Args: grid (List[List[str]]): A list of lists of strings where each string is either 'O' or 'X', representing the grid. Returns: bool: True if there is a path of 'O's from the top-left corner to the bottom-right corner, otherwise False. Examples: >>> is_path([ ... ['O', 'X', 'O', 'O'], ... ['O', 'O', 'X', 'O'], ... ['X', 'O', 'X', 'O'], ... ['O', 'O', 'O', 'O'] ... ]) True >>> is_path([ ... ['O', 'X', 'O', 'O'], ... ['X', 'X', 'X', 'O'], ... ['X', 'O', 'X', 'O'], ... ['O', 'O', 'O', 'O'] ... ]) False >>> is_path([]) # Empty grid False >>> is_path([ ... ['X', 'O', 'O'], ... ['O', 'O', 'X'], ... ['O', 'O', 'X'] ... ]) False >>> is_path([ ... ['O', 'O', 'O'], ... ['O', 'O', 'O'], ... ['O', 'O', 'O'] ... ]) True >>> is_path([ ... ['X', 'X', 'X'], ... ['X', 'X', 'X'], ... ['X', 'X', 'X'] ... ]) False >>> is_path([['O']]) True >>> is_path([['X']]) False","solution":"from typing import List def is_path(grid: List[List[str]]) -> bool: if not grid or not grid[0] or grid[0][0] == 'X' or grid[-1][-1] == 'X': return False rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(row, col): if row == rows - 1 and col == cols - 1: return True if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 'X' or visited[row][col]: return False visited[row][col] = True # Move in four possible directions if (dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1)): return True return False return dfs(0, 0)"},{"question":"def can_form_pyramid(n: int) -> str: Determines if it is possible to form a pyramid with n blocks. If possible, return \\"YES\\" followed by the levels of the pyramid. Otherwise, return \\"NO\\". >>> can_form_pyramid(3) 'YESn1n2 3' >>> can_form_pyramid(6) 'YESn1n2 3n4 5 6' >>> can_form_pyramid(10) 'NO' def process_test_cases(test_cases: list) -> list: Processes multiple test cases to determine if each number of blocks can form the pyramid. Takes a list of integers as input and returns a list of results in the format from can_form_pyramid function. >>> process_test_cases([3, 6, 5]) ['YESn1n2 3', 'YESn1n2 3n4 5 6', 'NO'] >>> process_test_cases([1, 2, 3]) ['YESn1', 'NO', 'YESn1n2 3'] return results","solution":"def can_form_pyramid(n): Determines if it is possible to form a pyramid with n blocks. If possible, return \\"YES\\" followed by the levels of the pyramid. Otherwise, return \\"NO\\". level = 1 blocks_needed = 0 result = [] while blocks_needed + level <= n: blocks_needed += level level += 1 if blocks_needed == n: result.append(\\"YES\\") block_number = 1 for l in range(1, level): result.append(\\" \\".join(str(block_number + i) for i in range(l))) block_number += l return \\"n\\".join(result) else: return \\"NO\\" def process_test_cases(test_cases): results = [] for n in test_cases: results.append(can_form_pyramid(n)) return results"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the array can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if the array can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, we can't split it equally into two parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a boolean array to store whether a certain sum can be achieved dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def calculate_ways(V): Given V sections, calculate the number of ways to assign terrain types such that no two consecutive sections have the same type. Each section can have one of three terrains: flat, uphill, or downhill. >>> calculate_ways(2) 6 >>> calculate_ways(3) 12 def solve(testcases): results = [] for V in testcases: results.append(calculate_ways(V)) return results # Unit Test def test_single_section(): assert solve([1]) == [3] def test_two_sections(): assert solve([2]) == [6] def test_three_sections(): assert solve([3]) == [12] def test_multiple_cases(): assert solve([1, 2, 3]) == [3, 6, 12] assert solve([2, 3, 4]) == [6, 12, 24] def test_large_case(): assert solve([100]) == [3 * (2 ** 99)]","solution":"def calculate_ways(V): Given V sections, calculate the number of ways to assign terrain types such that no two consecutive sections have the same type. Each section can have one of three terrains: flat, uphill, or downhill. if V == 1: return 3 # dp[i] holds the number of ways to arrange terrains for the first i sections dp = [0] * (V + 1) # If there's only one section, there are 3 possibilities dp[1] = 3 # If there are two sections, you have 3 choices for the first section and 2 choices for the second, for each choice of the first section dp[2] = 3 * 2 # For more than two sections, we follow the recurrence relation: for i in range(3, V + 1): dp[i] = dp[i-1] * 2 return dp[V] def solve(testcases): results = [] for V in testcases: results.append(calculate_ways(V)) return results"},{"question":"def min_abs_diff(n: int, a: List[int]) -> int: Given a list of n integers, split this list into two sub-lists, each containing n/2 integers, such that the absolute difference between the sums of the integers in the two sub-lists is minimized. >>> min_abs_diff(4, [1, 2, 3, 4]) 0 >>> min_abs_diff(6, [-5, -3, 2, 1, 4, 6]) 1","solution":"def min_abs_diff(n, a): def subset_sum_closest(a, target): sums = {0} for num in a: new_sums = set() for s in sums: new_sums.add(s + num) sums.update(new_sums) closest_sum = min(sums, key=lambda x: abs(x - target)) return closest_sum total_sum = sum(a) target = total_sum // 2 half_n = n // 2 closest_sum = subset_sum_closest(a, target) another_sum = total_sum - closest_sum return abs(closest_sum - another_sum)"},{"question":"def optimal_array_sequence(n: int, array: List[int]) -> List[int]: Given an array of positive integers, determine the sequence of integers that Alice and Bob will remove in order to maximize Alice's score, assuming both players play optimally. Args: n (int): the length of the array. array (List[int]): the elements of the array. Returns: List[int]: the sequence of integers that will be removed in order. >>> optimal_array_sequence(5, [3, 1, 4, 1, 5]) [5, 4, 3, 1, 1] >>> optimal_array_sequence(1, [10]) [10]","solution":"def optimal_array_sequence(n, array): Given an array of positive integers, determine the sequence of integers that Alice and Bob will remove in order to maximize Alice's score, assuming both players play optimally. # Sort the array in descending order sorted_array = sorted(array, reverse=True) return sorted_array"},{"question":"def arrange_paintings(n: int, k: int, importance_levels: List[int]) -> Union[List[int], int]: Determine an arrangement of paintings such that the sum of the importance levels of any two adjacent paintings is not a multiple of k. If it's not possible, return -1. Args: n (int): Number of paintings. k (int): The integer k. importance_levels (list): List of importance levels of the paintings. Returns: list: A list of integers representing the arrangement of paintings or -1 if not possible. >>> arrange_paintings(5, 3, [5, 7, 9, 12, 14]) [5, 9, 7, 12, 14] >>> arrange_paintings(3, 4, [8, 8, 8]) -1","solution":"from itertools import permutations def arrange_paintings(n, k, importance_levels): Determine an arrangement of paintings such that the sum of the importance levels of any two adjacent paintings is not a multiple of k. If it's not possible, return -1. Args: n (int): Number of paintings. k (int): The integer k. importance_levels (list): List of importance levels of the paintings. Returns: list: A list of integers representing the arrangement of paintings or -1 if not possible. # Check all permutations of the importance levels for perm in permutations(importance_levels): is_valid = True # Check if the sum of any two adjacent paintings is not a multiple of k for i in range(n - 1): if (perm[i] + perm[i+1]) % k == 0: is_valid = False break if is_valid: return list(perm) return -1"},{"question":"def pacificAtlantic(matrix: List[List[int]]) -> List[Tuple[int, int]]: Find the cells where water can flow to both the Pacific and Atlantic ocean. >>> pacificAtlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacificAtlantic([[1]]) [(0, 0)] import pytest def test_example_case(): matrix = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] expected = [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] result = pacificAtlantic(matrix) for cell in expected: assert cell in result def test_single_element(): matrix = [ [1] ] expected = [(0, 0)] result = pacificAtlantic(matrix) assert result == expected def test_single_row(): matrix = [ [1, 2, 2, 3, 5] ] expected = [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)] result = pacificAtlantic(matrix) for cell in expected: assert cell in result def test_single_column(): matrix = [ [1], [2], [2], [3], [5] ] expected = [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)] result = pacificAtlantic(matrix) for cell in expected: assert cell in result def test_larger_case(): matrix = [ [10, 10, 10], [10, 1, 10], [10, 10, 10] ] expected = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)] result = pacificAtlantic(matrix) for cell in expected: assert cell in result","solution":"def pacificAtlantic(matrix): if not matrix or not matrix[0]: return [] def dfs(matrix, visited, i, j): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for d in directions: x, y = i + d[0], j + d[1] if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (x, y) not in visited and matrix[x][y] >= matrix[i][j]: visited.add((x, y)) dfs(matrix, visited, x, y) pacific_reachable = set() atlantic_reachable = set() rows, cols = len(matrix), len(matrix[0]) for i in range(rows): pacific_reachable.add((i, 0)) atlantic_reachable.add((i, cols - 1)) dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, cols - 1) for j in range(cols): pacific_reachable.add((0, j)) atlantic_reachable.add((rows - 1, j)) dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, rows - 1, j) return list(pacific_reachable & atlantic_reachable)"},{"question":"def minimum_additional_connections(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Determine the minimum number of additional connections required to make the network fully connected. >>> minimum_additional_connections(5, 3, [(1, 2), (1, 3), (4, 5)]) == 1 >>> minimum_additional_connections(3, 2, [(1, 2), (2, 3)]) == 0 >>> minimum_additional_connections(4, 0, []) == 3 >>> minimum_additional_connections(4, 1, [(1, 2)]) == 2 >>> minimum_additional_connections(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 0 pass def solve(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Process multiple test cases for minimum_additional_connections function. >>> solve(2, [(5, 3, [(1, 2), (1, 3), (4, 5)]), (3, 2, [(1, 2), (2, 3)])]) == [1, 0] pass def test_minimum_additional_connections(): assert minimum_additional_connections(5, 3, [(1, 2), (1, 3), (4, 5)]) == 1 assert minimum_additional_connections(3, 2, [(1, 2), (2, 3)]) == 0 assert minimum_additional_connections(4, 0, []) == 3 assert minimum_additional_connections(4, 1, [(1, 2)]) == 2 assert minimum_additional_connections(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 0 def test_solve(): test_cases = [ (5, 3, [(1, 2), (1, 3), (4, 5)]), (3, 2, [(1, 2), (2, 3)]), (4, 0, []), (4, 1, [(1, 2)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) ] expected = [1, 0, 3, 2, 0] assert solve(5, test_cases) == expected","solution":"def find_parent(parent, i): A utility function to find the parent of an element i. Utilizes path compression for efficiency. if parent[i] == i: return i else: parent[i] = find_parent(parent, parent[i]) return parent[i] def union(parent, rank, x, y): A function that does union of two sets of x and y using rank. xroot = find_parent(parent, x) yroot = find_parent(parent, y) if xroot != yroot: if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_additional_connections(n, m, friendships): parent = [] rank = [] for i in range(n): parent.append(i) rank.append(0) for u, v in friendships: union(parent, rank, u - 1, v - 1) unique_parents = len(set(find_parent(parent, i) for i in range(n))) return unique_parents - 1 def solve(T, test_cases): results = [] for case in test_cases: n, m, friendships = case results.append(minimum_additional_connections(n, m, friendships)) return results"},{"question":"def count_successful_free_throws(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the number of successful free throws for each player given their results. >>> count_successful_free_throws(3, [(5, [1, 0, 1, 1, 0]), (4, [1, 1, 1, 1]), (6, [0, 0, 0, 0, 0, 0])]) [3, 4, 0] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parse the input format into the required format for testing. >>> parse_input(\\"3n5n1 0 1 1 0n4n1 1 1 1n6n0 0 0 0 0 0\\") (3, [(5, [1, 0, 1, 1, 0]), (4, [1, 1, 1, 1]), (6, [0, 0, 0, 0, 0, 0])]) from solution import count_successful_free_throws, parse_input def test_single_case(): T, test_cases = parse_input(\\"1n5n1 0 1 1 0\\") assert count_successful_free_throws(T, test_cases) == [3] def test_multiple_cases(): T, test_cases = parse_input(\\"3n5n1 0 1 1 0n4n1 1 1 1n6n0 0 0 0 0 0\\") assert count_successful_free_throws(T, test_cases) == [3, 4, 0] def test_all_successful(): T, test_cases = parse_input(\\"2n3n1 1 1n2n1 1\\") assert count_successful_free_throws(T, test_cases) == [3, 2] def test_all_missed(): T, test_cases = parse_input(\\"2n3n0 0 0n4n0 0 0 0\\") assert count_successful_free_throws(T, test_cases) == [0, 0] def test_mixed_results(): T, test_cases = parse_input(\\"2n5n1 1 0 0 1n4n0 1 0 1\\") assert count_successful_free_throws(T, test_cases) == [3, 2]","solution":"def count_successful_free_throws(T, test_cases): results = [] for case in test_cases: N, throws = case # Count the number of successful free throws successful_throws = sum(throws) results.append(successful_throws) return results # Function to parse the input format def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) throws = list(map(int, lines[idx + 1].split())) test_cases.append((N, throws)) idx += 2 return T, test_cases"},{"question":"def solve_palindromic_subsequences(T: int, cases: List[Tuple[int, str]]) -> List[int]: Given the number of test cases and a list of tuples containing the length of the string and the string itself, determine the number of distinct palindromic subsequences for each case. Args: T : int : number of test cases cases : List[Tuple[int, str]] : list of tuples where each tuple contains an int denoting the length of the string and the string itself. Returns: List[int] : list of results for each test case, where each result is the number of distinct palindromic subsequences modulo 10^9+7 >>> solve_palindromic_subsequences(2, [(3, \\"aab\\"), (4, \\"aaaa\\")]) [4, 15] >>> solve_palindromic_subsequences(1, [(1, \\"a\\")]) [1]","solution":"MOD = 10**9 + 7 def count_palindromic_subsequences(S): N = len(S) dp = [[0] * N for _ in range(N)] for i in range(N): dp[i][i] = 1 for length in range(2, N+1): for i in range(N-length+1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD else: dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % MOD if dp[i][j] < 0: dp[i][j] += MOD return dp[0][N-1] def solve_palindromic_subsequences(T, cases): results = [] for case in cases: N, S = case result = count_palindromic_subsequences(S) results.append(result) return results"},{"question":"def isUniformPath(N: int, M: int, mat: List[List[int]]) -> bool: Determines if there exists a path from the top-left corner to the bottom-right corner such that all cells in the path have the same value. You can move right or down from a given cell. Parameters: - N (int): number of rows in the matrix - M (int): number of columns in the matrix - mat (list of list of int): the matrix of integers Returns: - bool: True if such a path exists, False otherwise Examples: >>> isUniformPath(3, 3, [[1, 1, 1], [2, 1, 2], [2, 1, 1]]) True >>> isUniformPath(2, 2, [[1, 2], [2, 1]]) False def test_isUniformPath_true(): assert isUniformPath(3, 3, [[1, 1, 1], [2, 1, 2], [2, 1, 1]]) == True def test_isUniformPath_false(): assert isUniformPath(2, 2, [[1, 2], [2, 1]]) == False def test_isUniformPath_single_row(): assert isUniformPath(1, 4, [[1, 1, 1, 1]]) == True def test_isUniformPath_single_column(): assert isUniformPath(4, 1, [[1], [1], [1], [1]]) == True def test_isUniformPath_no_path(): assert isUniformPath(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False def test_isUniformPath_all_same_values(): assert isUniformPath(2, 2, [[1, 1], [1, 1]]) == True","solution":"def isUniformPath(N, M, mat): Determines if there exists a path from the top-left corner to the bottom-right corner such that all cells in the path have the same value. You can move right or down from a given cell. Parameters: - N (int): number of rows in the matrix - M (int): number of columns in the matrix - mat (list of list of int): the matrix of integers Returns: - bool: True if such a path exists, False otherwise target_value = mat[0][0] target_row = N - 1 target_col = M - 1 def dfs(r, c): if r == target_row and c == target_col: return True if r < 0 or r >= N or c < 0 or c >= M or mat[r][c] != target_value: return False temp = mat[r][c] mat[r][c] = None # Mark as visited found_path = dfs(r+1, c) or dfs(r, c+1) mat[r][c] = temp return found_path return dfs(0, 0)"},{"question":"def generate_prime_sequences_from_input(input_lines: str) -> list: Generate the first N prime numbers followed by their sum for multiple test cases. :param input_lines: Input as a string, where the first line is T, the number of test cases, and the subsequent lines contain the values of N for each test case. :return: A list of strings, each string containing the sequence of the first N prime numbers followed by their sum. >>> generate_prime_sequences_from_input(\\"3n2n3n5n\\") ['2 3 5', '2 3 5 10', '2 3 5 7 11 28'] >>> generate_prime_sequences_from_input(\\"1n1n\\") ['2 2']","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def generate_primes_sequence(N): Generate the first N prime numbers and their sum. primes = [] current_number = 2 while len(primes) < N: if is_prime(current_number): primes.append(current_number) current_number += 1 primes_sum = sum(primes) return primes + [primes_sum] def process_test_cases(T, test_cases): Process multiple test cases to generate desired sequences of primes. results = [] for N in test_cases: result = generate_primes_sequence(N) results.append(\\" \\".join(map(str, result))) return results # Function to read input and produce output def generate_prime_sequences_from_input(input_lines): input_data = input_lines.strip().split('n') T = int(input_data[0]) test_cases = [int(input_data[i]) for i in range(1, T+1)] return process_test_cases(T, test_cases)"},{"question":"def min_food_items(t: int, cases: List[Tuple[int, int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of food items required to meet the dietary needs of pets. The cases parameter is a list of tuples, each containing the dietary requirements (protein and carbohydrate) for each pet and the nutritional content of available food items. Args: t (int): The number of test cases. cases (List[Tuple[int, int, int, List[Tuple[int, int]]]]): A list of tuples, where each tuple contains: - Two integers representing the amount of protein and carbohydrates required by the pet. - An integer representing the number of food items available. - A list of tuples, each representing the nutritional content (protein and carbohydrates) of a food item. Returns: List[int]: The minimum number of food items required to meet the exact dietary needs for each test case. If not possible, return -1. >>> min_food_items(2, [(8, 12, 2, [(4, 6), (2, 3)]), (7, 10, 2, [(5, 5), (3, 2)])]) [2, -1] >>> min_food_items(1, [(10, 10, 2, [(7, 8), (6, 9)])]) [-1] >>> min_food_items(1, [(5, 5, 1, [(5, 5)])]) [1] >>> min_food_items(1, [(3, 3, 2, [(1, 1), (1, 1)])]) [3] def main(input_data: str) -> None: Parse the input data, execute the min_food_items function, and print the output for each test case. Args: input_data (str): The raw input data as a single string. pass","solution":"def min_food_items(t, cases): from collections import deque results = [] for case in cases: p, c, k, items = case dp = {} queue = deque([(0, 0, 0)]) found = False while queue: pi, ci, count = queue.popleft() if (pi, ci) in dp and dp[(pi, ci)] <= count: continue dp[(pi, ci)] = count if pi > p or ci > c: continue if pi == p and ci == c: results.append(count) found = True break for item in items: new_pi = pi + item[0] new_ci = ci + item[1] queue.append((new_pi, new_ci, count + 1)) if not found: results.append(-1) return results def main(input_data): data = input_data.strip().split('n') t = int(data[0]) cases = [] index = 1 for _ in range(t): p, c = map(int, data[index].split()) k = int(data[index + 1]) items = [] for i in range(k): items.append(tuple(map(int, data[index + 2 + i].split()))) cases.append((p, c, k, items)) index += 2 + k results = min_food_items(t, cases) for res in results: print(res)"},{"question":"def count_unique_athletes(M: int, events: List[List[str]]) -> int: This function returns the number of unique athletes. Parameters: M (int): The number of events. events (list of lists): A list of M lists, each containing athlete IDs. Returns: int: The number of unique athletes. >>> count_unique_athletes(4, [['A1', 'B2', 'C3'], ['A1', 'C3', 'D4'], ['B2'], ['E5']]) 5 >>> count_unique_athletes(2, [['A1', 'A1'], ['A1']]) 1 >>> count_unique_athletes(3, [['A1', 'B2'], ['B2', 'C3'], ['C3', 'D4']]) 4 >>> count_unique_athletes(1, [['A1', 'B2', 'C3', 'D4', 'E5']]) 5 >>> count_unique_athletes(0, []) 0 >>> count_unique_athletes(2, [['A1'], ['B2']]) 2 >>> count_unique_athletes(2, [['A1', 'A2', 'A3', 'A4'], ['A3', 'A4', 'A5', 'A6']]) 6","solution":"def count_unique_athletes(M, events): This function returns the number of unique athletes. Parameters: M (int): The number of events. events (list of lists): A list of M lists, each containing athlete IDs. Returns: int: The number of unique athletes. unique_athletes = set() for event in events: for athlete in event: unique_athletes.add(athlete) return len(unique_athletes)"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Find the shortest path from computer s to computer t in a network of n computers and m directed edges. Returns the shortest amount of time required for data to travel from computer s to computer t. If there is no path, returns -1. >>> shortest_path(5, 6, [(1, 2, 2), (2, 3, 3), (3, 5, 1), (4, 3, 4), (1, 4, 8), (5, 4, 2)], 1, 5) 6 >>> shortest_path(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], 2, 4) 2 >>> shortest_path(3, 2, [(1, 2, 4), (2, 3, 1)], 3, 1) -1 >>> shortest_path(2, 1, [(1, 2, 5)], 1, 2) 5 >>> shortest_path(4, 5, [(1, 2, 1), (2, 3, 1), (1, 3, 2), (3, 4, 1), (2, 4, 2)], 1, 4) 3","solution":"import heapq def shortest_path(n, m, edges, s, t): Find the shortest path from computer s to computer t in a network of n computers and m directed edges. graph = {i: [] for i in range(1, n + 1)} for u, v, d in edges: graph[u].append((v, d)) return dijkstra(graph, s, t) def dijkstra(graph, start, end): Dijkstra's algorithm to find the shortest path in a graph. heap = [(0, start)] # (cost, node) dist = {i: float('inf') for i in graph} dist[start] = 0 visited = set() while heap: curr_dist, node = heapq.heappop(heap) if node in visited: continue visited.add(node) for neighbor, weight in graph[node]: if neighbor in visited: continue new_dist = curr_dist + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(heap, (new_dist, neighbor)) return dist[end] if dist[end] != float('inf') else -1"},{"question":"def calculate_ranks(N: int, scores: List[int]) -> List[int]: Calculate the ranks of players based on their scores. Args: N: An integer representing the number of players scores: A list of integers where each integer represents the score of the player with that ID. Returns: A list of integers where the i-th integer represents the rank of the player with ID i. >>> calculate_ranks(5, [10, 20, 20, 10, 30]) [4, 2, 2, 4, 1] >>> calculate_ranks(4, [15, 15, 15, 15]) [1, 1, 1, 1] pass","solution":"def calculate_ranks(N, scores): Calculate ranks for players based on their scores. Args: N: Number of players scores: List containing scores of the players Returns: List of ranks corresponding to each player's score # Create a list of tuples (score, original_index) indexed_scores = [(score, index) for index, score in enumerate(scores)] # Sort the scores in descending order (and maintain index information) sorted_scores = sorted(indexed_scores, key=lambda x: x[0], reverse=True) # Initialize ranks ranks = [0] * N current_rank = 1 for i in range(N): if i == 0: # First element ranks[sorted_scores[i][1]] = current_rank else: # Check if the current score is the same as the previous score if sorted_scores[i][0] == sorted_scores[i-1][0]: ranks[sorted_scores[i][1]] = current_rank else: current_rank = i + 1 ranks[sorted_scores[i][1]] = current_rank return ranks # Example usage # N = 5 # scores = [10, 20, 20, 10, 30] # print(calculate_ranks(N, scores)) # Output: [4, 2, 2, 4, 1]"},{"question":"from typing import List def is_palindrome(num: int) -> bool: Checks if the given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(12321) True pass def next_palindrome(n: int) -> int: Finds the smallest palindrome number greater than n. >>> next_palindrome(123) 131 >>> next_palindrome(808) 818 >>> next_palindrome(999) 1001 >>> next_palindrome(1) 2 >>> next_palindrome(11) 22 pass def find_next_palindromes(test_cases: List[int]) -> List[int]: Given a list of numbers, finds the smallest palindrome number strictly greater than each number. >>> find_next_palindromes([123, 808, 999]) [131, 818, 1001] >>> find_next_palindromes([1, 11, 22]) [2, 22, 33] >>> find_next_palindromes([50, 101, 202]) [55, 111, 212] pass","solution":"def is_palindrome(num): Checks if the given number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(n): Finds the smallest palindrome number greater than n. n += 1 # Start checking the next number while not is_palindrome(n): n += 1 return n def find_next_palindromes(test_cases): Given a list of numbers, finds the smallest palindrome number strictly greater than each number. results = [] for n in test_cases: results.append(next_palindrome(n)) return results"},{"question":"from typing import List def k_most_frequent(nums: List[int], k: int) -> List[int]: Write a function that accepts a list of integers and an integer k, and returns the k most frequent elements in the list. The order of the elements in the output does not matter. >>> k_most_frequent([1,1,1,2,2,3], 2) [1, 2] >>> k_most_frequent([4,1,-1,2,-1,2,3], 2) [-1, 2] # Your implementation here def test_example_cases(): assert set(k_most_frequent([1,1,1,2,2,3], 2)) == set([1, 2]) assert set(k_most_frequent([4,1,-1,2,-1,2,3], 2)) == set([-1, 2]) def test_empty_list(): assert k_most_frequent([], 3) == [] def test_k_greater_than_list_length(): assert set(k_most_frequent([1, 1, 2, 3], 10)) == set([1, 2, 3]) def test_k_equals_zero(): assert k_most_frequent([1, 1, 2, 3], 0) == [] def test_all_elements_unique(): assert set(k_most_frequent([1, 2, 3, 4], 2)) == set([1, 2]) or set(k_most_frequent([1, 2, 3, 4], 2)) == set([3, 4]) def test_multiple_valid_answers(): assert set(k_most_frequent([1,2,3,1,2,3], 2)) == set([1, 2]) or set(k_most_frequent([1,2,3,1,2,3], 2)) == set([1, 3]) or set(k_most_frequent([1,2,3,1,2,3], 2)) == set([2, 3]) def test_all_elements_same_frequency(): assert set(k_most_frequent([1, 2, 3, 4, 5], 3)) == set([1, 2, 3]) or set(k_most_frequent([1, 2, 3, 4, 5], 3)) == set([2, 3, 4]) or set(k_most_frequent([1, 2, 3, 4, 5], 3)) == set([3, 4, 5]) def test_large_input(): assert k_most_frequent([1]*1000000 + [2]*100000 + [3]*100, 1) == [1]","solution":"from collections import Counter from heapq import nlargest def k_most_frequent(nums, k): Returns the k most frequent elements in the list nums. Parameters: - nums: List[int], a list of integers - k: int, number of most frequent elements to return Returns: - List[int]: k most frequent elements, order does not matter if not nums or k <= 0: return [] frequency = Counter(nums) return [element for element, _ in nlargest(k, frequency.items(), key=lambda x: x[1])]"},{"question":"def reverseWords(s: str) -> str: Reverses the order of words in a given string where words are separated by dots. Args: s: A string with words separated by dots. Returns: A string with the word order reversed. Examples: >>> reverseWords(\\"i.like.this.program.very.much\\") \\"much.very.program.this.like.i\\" >>> reverseWords(\\"hello.world\\") \\"world.hello\\"","solution":"def reverseWords(s: str) -> str: Reverses the order of words in a given string where words are separated by dots. Args: s: A string with words separated by dots. Returns: A string with the word order reversed. if not s: return s words = s.split('.') reversed_words = words[::-1] return '.'.join(reversed_words)"},{"question":"def largestEmptySquare(N: int, M: int, garden: List[str]) -> int: Determine the size of the largest square area of the garden that does not contain any trees. >>> largestEmptySquare(4, 5, [\\"10010\\", \\"00000\\", \\"11110\\", \\"01001\\"]) 4 >>> largestEmptySquare(3, 4, [\\"0000\\", \\"0000\\", \\"0000\\"]) 9 >>> largestEmptySquare(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 0","solution":"def largestEmptySquare(N, M, garden): # Create a 2D DP array initialized to 0 dp = [[0] * M for _ in range(N)] # Initialize max side length of the square max_side = 0 # Iterate over the garden matrix for i in range(N): for j in range(M): # If we are on a tree cell, continue if garden[i][j] == '1': dp[i][j] = 0 else: # If we are at the first row or first column, take the value from the garden if i == 0 or j == 0: dp[i][j] = 1 if garden[i][j] == '0' else 0 else: # Update the DP value based on the minimum of three neighbors dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # Update the maximum side length max_side = max(max_side, dp[i][j]) # The area of the largest square return max_side * max_side"},{"question":"def longest_prime_subsequence(arr: List[int]) -> List[int]: Determine the longest subsequence where every element is a prime number. If there are multiple subsequences of the same maximum length, choose the one with the smallest sum. If there is still a tie, choose the lexicographically smallest subsequence. >>> longest_prime_subsequence([1, 3, 5, 4, 9, 11, 13, 6, 7, 17]) [3, 5, 11, 13, 7, 17] >>> longest_prime_subsequence([4, 6, 8, 10, 12, 14]) []","solution":"import math def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def longest_prime_subsequence(arr): # Filter out prime numbers from the array primes = [num for num in arr if is_prime(num)] # Return the primes as the required subsequence return primes"},{"question":"def pascals_triangle_row_sum(n: int) -> int: Returns the sum of the elements in the n-th row of Pascal's Triangle. >>> pascals_triangle_row_sum(0) 1 >>> pascals_triangle_row_sum(4) 16 >>> pascals_triangle_row_sum(6) 64","solution":"def pascals_triangle_row_sum(n): Returns the sum of the elements in the n-th row of Pascal's Triangle. # The sum of the n-th row in Pascal's Triangle is given by 2^n return 2**n"},{"question":"from typing import List def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array arr. The elements are returned in descending order of their frequency. If multiple elements have the same frequency, they are sorted in ascending order. >>> k_most_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> k_most_frequent_elements([4, 4, 4, 1, 1, 2, 2, 3], 3) [4, 1, 2]","solution":"from collections import Counter def k_most_frequent_elements(arr, k): Returns the k most frequent elements in the array arr. The elements are returned in descending order of their frequency. If multiple elements have the same frequency, they are sorted in ascending order. frequency_counter = Counter(arr) sorted_elements = sorted(frequency_counter.items(), key=lambda x: (-x[1], x[0])) return [element for element, freq in sorted_elements[:k]] # Example usage: # arr = [4, 4, 4, 1, 1, 2, 2, 3] # k = 3 # print(k_most_frequent_elements(arr, k)) # Output: [4, 1, 2]"},{"question":"def water_status(water_list, min_threshold, max_threshold): Calculate the total amount of water received over a period of days and determine if it is within the required thresholds. Args: water_list (List[int]): List of integers representing the amount of water provided each day. min_threshold (int): Minimum threshold of water needed. max_threshold (int): Maximum threshold of water acceptable. Returns: str: \\"Just right\\" if the total water is within thresholds, \\"Needs more water\\" if below the minimum threshold, and \\"Overwatered\\" if above the maximum threshold. >>> water_status([5, 3, 2, 4], 10, 20) 'Just right' >>> water_status([1, 2, 3], 10, 15) 'Needs more water' >>> water_status([6, 7, 8], 10, 20) 'Overwatered'","solution":"def water_status(water_list, min_threshold, max_threshold): total_water = sum(water_list) if total_water < min_threshold: return \\"Needs more water\\" elif total_water > max_threshold: return \\"Overwatered\\" else: return \\"Just right\\""},{"question":"def min_cost_to_determine_ranks(N: int, K: int, queries: List[Tuple[int, int, int]]) -> int: Returns the minimum cost required to determine the rank of candies in all jars. Arguments: N -- int, number of jars K -- int, number of conditions queries -- list of tuples representing conditions (A_i, B_i, C_i) Example: >>> min_cost_to_determine_ranks(4, 2, [(1, 2, 1), (3, 4, 2)]) 2 >>> min_cost_to_determine_ranks(5, 1, [(1, 2, 3)]) 2","solution":"def min_cost_to_determine_ranks(N, K, queries): Returns the minimum cost required to determine the rank of candies in all jars. Arguments: N -- int, number of jars K -- int, number of conditions queries -- list of tuples representing conditions (A_i, B_i, C_i) import heapq # Create adjacency list for the undirected graph graph = [[] for _ in range(N + 1)] for A, B, C in queries: graph[A].append((B, C)) graph[B].append((A, C)) # Use a Priority Queue (Min Heap) for Prim's Algorithm pq = [] heapq.heappush(pq, (0, 1)) # Start with Jar 1, it does not matter where to start visited = [False] * (N + 1) min_cost = 0 count_visits = 0 while pq and count_visits < N: cost, node = heapq.heappop(pq) if visited[node]: continue visited[node] = True min_cost += 1 # We checked the rank of this jar count_visits += 1 for neighbor, differ in graph[node]: if not visited[neighbor]: heapq.heappush(pq, (differ, neighbor)) return min_cost"},{"question":"def sort_and_format_numbers(input_string: str) -> str: Receives a string containing a list of comma-separated integers and returns a string with the integers sorted in non-decreasing order and separated by dashes. >>> sort_and_format_numbers(\\"5,3,8,6,2\\") # \\"2-3-5-6-8\\" >>> sort_and_format_numbers(\\"1,4,3,2,5\\") # \\"1-2-3-4-5\\" >>> sort_and_format_numbers(\\"7,7,7,7,7\\") # \\"7-7-7-7-7\\" >>> sort_and_format_numbers(\\"3,1,-2,0,2\\") # \\"-2-0-1-2-3\\" >>> sort_and_format_numbers(\\"1000,2000,500,1500\\") # \\"500-1000-1500-2000\\" >>> sort_and_format_numbers(\\"7,1\\") # \\"1-7\\" >>> input_string = ','.join(map(str, range(10000, 0, -1))) >>> output_string = '-'.join(map(str, range(1, 10001))) >>> sort_and_format_numbers(input_string) # output_string","solution":"def sort_and_format_numbers(input_string): Receives a string containing a list of comma-separated integers and returns a string with the integers sorted in non-decreasing order and separated by dashes. :param input_string: A comma-separated string of integers :return: A string with sorted integers separated by dashes # Split the input string by commas to get a list of integer strings str_numbers = input_string.split(',') # Convert the list of strings to a list of integers int_numbers = [int(num) for num in str_numbers] # Sort the list of integers sorted_numbers = sorted(int_numbers) # Convert the sorted list of integers back to a list of strings sorted_str_numbers = [str(num) for num in sorted_numbers] # Join the list of sorted strings with dashes result_string = '-'.join(sorted_str_numbers) return result_string"},{"question":"import re from typing import List def find_longest_word(s: str) -> str: In a given string, find the longest word defined as a continuous sequence of alphabetic characters, separated by non-alphabetic characters or the start/end of the string. If there are multiple words of the same length, return the word that appears first. Examples: >>> find_longest_word(\\"The quick brown fox jumped over the lazy dog\\") == \\"jumped\\" >>> find_longest_word(\\"A journey of a thousand miles begins with a single step\\") == \\"thousand\\" >>> find_longest_word(\\"May the force be with you\\") == \\"force\\" pass","solution":"import re def find_longest_word(s): # Use a regular expression to split the string into words words = re.findall(r\\"[a-zA-Z]+\\", s) # Find the longest word longest_word = max(words, key=len) return longest_word"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression and return the result. Supports +, -, *, / operators and parentheses. >>> evaluate_expression(\\"2+(3*(4-1))/3\\") == 5 >>> evaluate_expression(\\"((2+3)*4)-(3*(1+1))\\") == 14 >>> evaluate_expression(\\"(2+3)*(4-1)\\") == 15 pass from solution import evaluate_expression def test_single_number(): assert evaluate_expression(\\"5\\") == 5 def test_addition(): assert evaluate_expression(\\"2+3\\") == 5 def test_subtraction(): assert evaluate_expression(\\"10-4\\") == 6 def test_multiplication(): assert evaluate_expression(\\"3*4\\") == 12 def test_division(): assert evaluate_expression(\\"20/5\\") == 4 def test_parentheses(): assert evaluate_expression(\\"(2+3)*(4-1)\\") == 15 def test_complex_expression(): assert evaluate_expression(\\"2+(3*(4-1))/3\\") == 5 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*4)-(3*(1+1))\\") == 14 def test_all_operations(): assert evaluate_expression(\\"2*3+5/2-1\\") == 7 def test_trailing_operator(): assert evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") == 21","solution":"def evaluate_expression(expression): Evaluate the given mathematical expression and return the result. Supports +, -, *, / operators and parentheses. def helper(expression, index): stack = [] num = 0 operator = '+' while index < len(expression): char = expression[index] if char.isdigit(): num = num * 10 + int(char) if char == '(': num, index = helper(expression, index + 1) if char in '+-*/)' or index == len(expression) - 1: if operator == '+': stack.append(num) elif operator == '-': stack.append(-num) elif operator == '*': stack.append(stack.pop() * num) elif operator == '/': stack.append(int(stack.pop() / num)) if char == ')': return sum(stack), index operator = char num = 0 index += 1 return sum(stack), index result, _ = helper(expression, 0) return result"},{"question":"def transform_array(arr): Transforms the array inplace such that each element at index i is the sum of itself and all previous elements in the array. Parameters: arr (list of int): The input list of positive integers. Returns: None: The function modifies the input list in place. Example: >>> arr = [1, 2, 3, 4, 5] >>> transform_array(arr) >>> arr [1, 3, 6, 10, 15] >>> arr = [10, 20, 30, 40] >>> transform_array(arr) >>> arr [10, 30, 60, 100]","solution":"def transform_array(arr): Transforms the array inplace such that each element at index i is the sum of itself and all previous elements in the array. Parameters: arr (list of int): The input list of positive integers. Returns: None: The function modifies the input list in place. for i in range(1, len(arr)): arr[i] += arr[i - 1]"},{"question":"def nth_prime(n): Returns the nth prime number. Args: n: A positive integer which represents the nth prime to find. Returns: The nth prime number. >>> nth_prime(1) == 2 True >>> nth_prime(2) == 3 True >>> nth_prime(3) == 5 True >>> nth_prime(4) == 7 True >>> nth_prime(6) == 13 True >>> nth_prime(10) == 29 True >>> nth_prime(100) == 541 True","solution":"def nth_prime(n): Returns the nth prime number. Args: n: A positive integer which represents the nth prime to find. Returns: The nth prime number. if n == 1: return 2 primes = [2] candidate = 3 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > candidate: break if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 2 return primes[-1]"},{"question":"def sort_cart(items): Sorts the items in the cart based on their priority from highest to lowest. If two items have the same priority, they retain their original order. Parameters: items (list): A list of dictionaries where each dictionary contains 'name' and 'priority' keys Returns: list: A new list of dictionaries sorted by the priority levels from highest to lowest def test_sort_cart(): input_data1 = [ {\\"name\\": \\"apple\\", \\"priority\\": 2}, {\\"name\\": \\"banana\\", \\"priority\\": 1}, {\\"name\\": \\"carrot\\", \\"priority\\": 5}, {\\"name\\": \\"date\\", \\"priority\\": 3}, {\\"name\\": \\"eggplant\\", \\"priority\\": 1} ] expected_output1 = [ {\\"name\\": \\"carrot\\", \\"priority\\": 5}, {\\"name\\": \\"date\\", \\"priority\\": 3}, {\\"name\\": \\"apple\\", \\"priority\\": 2}, {\\"name\\": \\"banana\\", \\"priority\\": 1}, {\\"name\\": \\"eggplant\\", \\"priority\\": 1} ] assert sort_cart(input_data1) == expected_output1 input_data2 = [ {\\"name\\": \\"pasta\\", \\"priority\\": 0}, {\\"name\\": \\"broccoli\\", \\"priority\\": -1}, {\\"name\\": \\"chocolate\\", \\"priority\\": 1}, {\\"name\\": \\"bread\\", \\"priority\\": 2} ] expected_output2 = [ {\\"name\\": \\"bread\\", \\"priority\\": 2}, {\\"name\\": \\"chocolate\\", \\"priority\\": 1}, {\\"name\\": \\"pasta\\", \\"priority\\": 0}, {\\"name\\": \\"broccoli\\", \\"priority\\": -1} ] assert sort_cart(input_data2) == expected_output2 input_data3 = [ {\\"name\\": \\"book\\", \\"priority\\": 3}, {\\"name\\": \\"pen\\", \\"priority\\": 3}, {\\"name\\": \\"notebook\\", \\"priority\\": 2}, {\\"name\\": \\"pencil\\", \\"priority\\": 2}, {\\"name\\": \\"eraser\\", \\"priority\\": 1} ] expected_output3 = [ {\\"name\\": \\"book\\", \\"priority\\": 3}, {\\"name\\": \\"pen\\", \\"priority\\": 3}, {\\"name\\": \\"notebook\\", \\"priority\\": 2}, {\\"name\\": \\"pencil\\", \\"priority\\": 2}, {\\"name\\": \\"eraser\\", \\"priority\\": 1} ] assert sort_cart(input_data3) == expected_output3 input_data4 = [ {\\"name\\": \\"x\\", \\"priority\\": 3}, {\\"name\\": \\"y\\", \\"priority\\": 3}, {\\"name\\": \\"z\\", \\"priority\\": 3} ] expected_output4 = [ {\\"name\\": \\"x\\", \\"priority\\": 3}, {\\"name\\": \\"y\\", \\"priority\\": 3}, {\\"name\\": \\"z\\", \\"priority\\": 3} ] assert sort_cart(input_data4) == expected_output4 input_data5 = [ {\\"name\\": \\"item1\\", \\"priority\\": 10}, {\\"name\\": \\"item2\\", \\"priority\\": -1}, {\\"name\\": \\"item3\\", \\"priority\\": 0}, {\\"name\\": \\"item4\\", \\"priority\\": 5}, {\\"name\\": \\"item5\\", \\"priority\\": 5} ] expected_output5 = [ {\\"name\\": \\"item1\\", \\"priority\\": 10}, {\\"name\\": \\"item4\\", \\"priority\\": 5}, {\\"name\\": \\"item5\\", \\"priority\\": 5}, {\\"name\\": \\"item3\\", \\"priority\\": 0}, {\\"name\\": \\"item2\\", \\"priority\\": -1} ] assert sort_cart(input_data5) == expected_output5","solution":"def sort_cart(items): Sorts the items in the cart based on their priority from highest to lowest. If two items have the same priority, they retain their original order. Parameters: items (list): A list of dictionaries where each dictionary contains 'name' and 'priority' keys Returns: list: A new list of dictionaries sorted by the priority levels from highest to lowest return sorted(items, key=lambda x: x['priority'], reverse=True)"},{"question":"def find_min_sum_to_disconnect_graph(n, m, values, edges): Find the smallest sum of values to remove a subset of nodes such that no two remaining nodes are connected. Args: n: int. The number of nodes. m: int. The number of edges. values: List[int]. The values associated with the nodes. edges: List[Tuple[int, int]]. The edges connecting the nodes. Returns: int. The smallest sum of values needed to disconnect the graph. >>> find_min_sum_to_disconnect_graph(5, 4, [5, 1, 3, 4, 2], [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 >>> find_min_sum_to_disconnect_graph(3, 3, [10, 20, 30], [(1, 2), (2, 3), (1, 3)]) == 10 >>> find_min_sum_to_disconnect_graph(6, 3, [7, 5, 2, 10, 3, 8], [(1, 2), (3, 4), (5, 6)]) == 2 >>> find_min_sum_to_disconnect_graph(4, 0, [3, 1, 4, 2], []) == 1","solution":"def find_min_sum_to_disconnect_graph(n, m, values, edges): from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) component = [] while queue: current = queue.popleft() if not visited[current]: visited[current] = True component.append(current) for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) return component # Create adjacency list for the graph graph = defaultdict(list) for u, w in edges: graph[u].append(w) graph[w].append(u) visited = [False] * (n + 1) components = [] # Find all connected components for i in range(1, n + 1): if not visited[i]: component_nodes = bfs(i, visited, graph) components.append(component_nodes) # Calculate the minimum value node in each component min_values = [] for component in components: min_values.append(min(values[node-1] for node in component)) # The result is the minimum value from all minimum values of components return min(min_values)"},{"question":"from collections import deque from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_trees_to_visit(root: Optional[TreeNode], target_fruits: int) -> int: Find the minimum number of trees needed to collect at least the desired number of fruits. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> root.left.left.left = TreeNode(1) >>> root.left.left.right = TreeNode(6) >>> min_trees_to_visit(root, 19) 3 >>> min_trees_to_visit(root, 25) -1","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_trees_to_visit(root: TreeNode, target_fruits: int) -> int: if not root: return -1 if target_fruits <= 0: return 0 # Perform a BFS to find the minimum number of nodes to sum to at least target_fruits queue = deque([(root, root.value)]) # Start with the root node visited = set() visited.add(root) nodes_visited = 1 if root.value >= target_fruits: return nodes_visited while queue: nodes_visited += 1 for _ in range(len(queue)): node, curr_sum = queue.popleft() for child in [node.left, node.right]: if child and child not in visited: new_sum = curr_sum + child.value if new_sum >= target_fruits: return nodes_visited queue.append((child, new_sum)) visited.add(child) return -1"},{"question":"def min_packages(target_weight: int, packages: List[int]) -> int: This function determines the minimum number of packages needed to reach exactly the target_weight. If it's not possible to reach the target_weight using the provided packages, it returns -1. >>> min_packages(10, [1, 3, 4, 5]) 2 >>> min_packages(7, [2, 3, 5]) 2 >>> min_packages(11, [1, 5, 6]) 2 >>> min_packages(6, [1, 4, 5]) 2 >>> min_packages(6, [7, 8, 9]) -1","solution":"def min_packages(target_weight, packages): This function determines the minimum number of packages needed to reach exactly the target_weight. If it's not possible to reach the target_weight using the provided packages, it returns -1. max_weight = target_weight + 1 dp = [max_weight] * (target_weight + 1) dp[0] = 0 for weight in range(1, target_weight + 1): for package in packages: if package <= weight: dp[weight] = min(dp[weight], dp[weight - package] + 1) return dp[target_weight] if dp[target_weight] != max_weight else -1 def solve(test_cases): results = [] for case in test_cases: target_weight, packages = case result = min_packages(target_weight, packages) results.append(result) return results"},{"question":"def find_kth_largest(arr: List[int], k: int) -> int: Return the k-th largest element in the array. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([3, 1, 2, 4], 2) 3","solution":"def find_kth_largest(arr, k): Returns the k-th largest element in the array \`arr\`. arr.sort(reverse=True) return arr[k - 1]"},{"question":"def subarray_sums(N: int, Q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, find the sum of elements in the subarray from index L to R (1-based indexing). Args: - N (int): Number of elements in the array. - Q (int): Number of queries. - A (list of int): The array of integers. - queries (list of tuples): Each tuple contains two integers L and R. Returns: - list of int: The results of each query. >>> subarray_sums(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> subarray_sums(1, 1, [10], [(1, 1)]) [10] >>> subarray_sums(4, 1, [1, 2, 3, 4], [(1, 4)]) [10] >>> subarray_sums(6, 3, [3, 2, 1, 6, 5, 4], [(1, 3), (2, 5), (4, 6)]) [6, 14, 15] >>> subarray_sums(5, 2, [1000000, 1000000, 1000000, 1000000, 1000000], [(1, 3), (2, 5)]) [3000000, 4000000] >>> subarray_sums(4, 2, [0, 0, 0, 0], [(1, 2), (3, 4)]) [0, 0]","solution":"def subarray_sums(N, Q, A, queries): For each query, find the sum of elements in the subarray from index L to R (1-based indexing). Args: - N (int): Number of elements in the array. - Q (int): Number of queries. - A (list of int): The array of integers. - queries (list of tuples): Each tuple contains two integers L and R. Returns: - list of int: The results of each query. # Create a prefix sum array prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + A[i - 1] results = [] for L, R in queries: sum_subarray = prefix_sum[R] - prefix_sum[L - 1] results.append(sum_subarray) return results"},{"question":"from typing import List def dailyTemperatures(T: List[int]) -> List[int]: Determines the number of days one has to wait after a given day for a higher temperature. If there is no future day with a higher temperature, the output for that day should be 0. Args: T (List[int]): An array of daily temperatures. Returns: List[int]: A list of integers representing the number of days to wait for a higher temperature. Examples: >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dailyTemperatures([30, 60, 90]) [1, 1, 0] >>> dailyTemperatures([20, 30, 40, 50, 60, 10, 5]) [1, 1, 1, 1, 0, 0, 0]","solution":"from typing import List def dailyTemperatures(T: List[int]) -> List[int]: For each day in the given list of temperatures, calculates the number of days one has to wait until a warmer temperature. If no future day is warmer, returns 0 for that day. n = len(T) result = [0] * n stack = [] for i in range(n): while stack and T[i] > T[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"def rearrange(arr): Rearranges an array such that positive and negative elements are placed alternately. Any extra elements (when there are uneven numbers of positive and negative elements) should be appended at the end in their original relative order. >>> rearrange([2, -1, -3, 4, 5]) [2, -1, 4, -3, 5] >>> rearrange([-5, -2, 3, 7]) [3, -5, 7, -2]","solution":"def rearrange(arr): Rearranges an array such that positive and negative elements are placed alternately. Any extra elements (when there are uneven numbers of positive and negative elements) should be appended at the end in their original relative order. n = len(arr) pos_idx = 0 neg_idx = 1 while True: while pos_idx < n and arr[pos_idx] >= 0: pos_idx += 2 while neg_idx < n and arr[neg_idx] < 0: neg_idx += 2 if pos_idx < n and neg_idx < n: arr[pos_idx], arr[neg_idx] = arr[neg_idx], arr[pos_idx] else: break return arr"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest path from the source vertex to the target vertex for each query. Args: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int, int]]): A list where each element is a tuple (u, v, w) representing an edge from vertex u to vertex v with weight w. queries (List[Tuple[int, int]]): A list where each element is a tuple (s, t) representing a query to find the shortest path from vertex s to vertex t. Returns: List[int]: A list of lengths of the shortest paths for each query. If there is no path from s to t, the corresponding value should be -1. >>> shortest_path(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10)], [(4, 3), (1, 3)]) [-1, 7] >>> shortest_path(3, 2, [(1, 2, 2), (2, 3, 2)], [(1, 3), (3, 1)]) [4, -1]","solution":"import heapq def dijkstra(n, adj_list, source): Dijkstra's algorithm implementation. Returns the shortest distance from the source to all other nodes. dist = [float('inf')] * n dist[source] = 0 pq = [(0, source)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for weight, v in adj_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def shortest_path(n, m, edges, queries): Main function to find shortest paths for each query. # Create adjacency list adj_list = [[] for _ in range(n)] for u, v, w in edges: adj_list[u-1].append((w, v-1)) results = [] # Answer each query using Dijkstra for s, t in queries: dist = dijkstra(n, adj_list, s-1) result = dist[t-1] if dist[t-1] != float('inf') else -1 results.append(result) return results"},{"question":"def shortest_path_in_grid(N, M, grid, start, end): Finds the shortest path from start to end in a grid avoiding blocked cells using BFS. Parameters: N (int): Number of rows M (int): Number of columns grid (list of list of int): The grid itself, a matrix of 0s and 1s start (tuple of int): Starting coordinates (x_s, y_s) end (tuple of int): Ending coordinates (x_e, y_e) Returns: int: Length of the shortest path or -1 if no path exists. >>> N, M = 4, 4 >>> grid = [ >>> [0, 0, 1, 0], >>> [1, 0, 1, 0], >>> [0, 0, 0, 0], >>> [0, 1, 1, 0] >>> ] >>> start = (0, 0) >>> end = (3, 3) >>> shortest_path_in_grid(N, M, grid, start, end) 6 >>> N, M = 3, 3 >>> grid = [ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path_in_grid(N, M, grid, start, end) 4 >>> N, M = 3, 3 >>> grid = [ >>> [0, 1, 0], >>> [1, 1, 0], >>> [0, 0, 0] >>> ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path_in_grid(N, M, grid, start, end) -1","solution":"from collections import deque def shortest_path_in_grid(N, M, grid, start, end): Finds the shortest path from start to end in a grid avoiding blocked cells using BFS. Parameters: N (int): Number of rows M (int): Number of columns grid (list of list of int): The grid itself, a matrix of 0s and 1s start (tuple of int): Starting coordinates (x_s, y_s) end (tuple of int): Ending coordinates (x_e, y_e) Returns: int: Length of the shortest path or -1 if no path exists. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set([(start[0], start[1])]) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def largest_uniform_subgrid(grid: List[str]) -> int: Identify the largest rectangular subgrid where all characters are the same. >>> largest_uniform_subgrid([ ... \\"aaaa\\", ... \\"aabb\\", ... \\"aabb\\" ... ]) == 4 >>> largest_uniform_subgrid([ ... \\"abcde\\", ... \\"fghij\\", ... \\"klmno\\", ... \\"pqrst\\" ... ]) == 1 >>> largest_uniform_subgrid([ ... \\"aaaaa\\", ... \\"aaaaa\\", ... \\"aaaaa\\", ... \\"aaaaa\\", ... \\"aaaaa\\" ... ]) == 25","solution":"def largest_uniform_subgrid(grid): n = len(grid) m = len(grid[0]) if n == 0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] max_area = 0 for i in range(n): for j in range(m): if i == 0: dp[i][j] = 1 if j == 0 or grid[i][j] == grid[i][j - 1] else 1 else: if j == 0: dp[i][j] = 1 if grid[i][j] == grid[i - 1][j] else 1 else: if grid[i][j] == grid[i - 1][j] and grid[i][j] == grid[i][j - 1] and grid[i][j] == grid[i - 1][j - 1]: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 else: dp[i][j] = 1 max_area = max(max_area, dp[i][j]**2) return max_area"},{"question":"def can_allocate_notebooks(K: int, N: int, P: List[int], Q: List[int]) -> str: Determines if it's possible to allocate each participant a notebook with at least the number of pages they request. :param K: Number of notebooks. :param N: Number of participants. :param P: List of integers representing the number of pages in each notebook. :param Q: List of integers representing the number of pages requested by each participant. :return: \\"Yes\\" if it's possible to allocate notebooks as required, otherwise \\"No\\". >>> can_allocate_notebooks(5, 4, [300, 500, 200, 400, 600], [250, 450, 100, 500]) \\"Yes\\" >>> can_allocate_notebooks(3, 3, [300, 400, 500], [100, 200, 600]) \\"No\\" >>> can_allocate_notebooks(4, 4, [300, 500, 400, 200], [200, 300, 400, 500]) \\"Yes\\" >>> can_allocate_notebooks(2, 3, [300, 400], [200, 300, 500]) \\"No\\" >>> can_allocate_notebooks(3, 3, [1000, 1000, 1000], [999, 999, 999]) \\"Yes\\" pass","solution":"def can_allocate_notebooks(K, N, P, Q): Determines if it's possible to allocate each participant a notebook with at least the number of pages they request. :param K: Number of notebooks. :param N: Number of participants. :param P: List of integers representing the number of pages in each notebook. :param Q: List of integers representing the number of pages requested by each participant. :return: \\"Yes\\" if it's possible to allocate notebooks as required, otherwise \\"No\\". P.sort() Q.sort() if K < N: return \\"No\\" for i in range(N): if P[-(i + 1)] < Q[-(i + 1)]: return \\"No\\" return \\"Yes\\""},{"question":"def is_eulerian_cycle_possible(M: int, N: int, edges: List[Tuple[int, int]]) -> List[str]: For each trail formed, determine if an Eulerian cycle is possible starting and ending at the base camp. >>> is_eulerian_cycle_possible(4, 4, [(1, 2), (2, 3), (3, 1), (1, 4)]) ['No', 'No', 'Yes', 'No'] >>> is_eulerian_cycle_possible(5, 5, [(1, 3), (3, 4), (2, 3), (4, 5), (1, 2)]) ['No', 'No', 'No', 'No', 'No'] pass def parse_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the input string into the number of waypoints, number of trails, and the list of edges. >>> parse_input(\\"4 4n1 2n2 3n3 1n1 4\\") (4, 4, [(1, 2), (2, 3), (3, 1), (1, 4)]) >>> parse_input(\\"5 5n1 3n3 4n2 3n4 5n1 2\\") (5, 5, [(1, 3), (3, 4), (2, 3), (4, 5), (1, 2)]) pass","solution":"def is_eulerian_cycle_possible(M, N, edges): from collections import defaultdict, deque def is_connected_and_eulerian(): if not graph[1]: # If no edges at the base camp, it's not possible return False, False visited = set() def bfs(start): queue = deque([start]) while queue: u = queue.popleft() for v in graph[u]: if v not in visited: visited.add(v) queue.append(v) # Check for single component starting from any node with a degree > 0 starting_node = None for node in range(1, M + 1): if len(graph[node]) > 0: starting_node = node break if starting_node is None: return False, False visited.add(starting_node) bfs(starting_node) for node in range(1, M + 1): if len(graph[node]) > 0 and node not in visited: return False, False # Check all vertices with non-zero degree have even degree for i in range(1, M + 1): if len(graph[i]) % 2 != 0: return True, False return True, True graph = defaultdict(set) results = [] for u, v in edges: graph[u].add(v) graph[v].add(u) connected, eulerian = is_connected_and_eulerian() if connected and eulerian: results.append(\\"Yes\\") else: results.append(\\"No\\") return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") M, N = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:]] return M, N, edges"},{"question":"def find_consecutive_segments(s: str) -> list[str]: Finds all segments of the string containing 3 or more consecutive digits. Parameters: s (str): The input string. Returns: list: A list of matched segments or -1 if no such segment is found. Examples: >>> find_consecutive_segments('hello1234world5670abc890123') ['1234', '5670', '890123'] >>> find_consecutive_segments('helloworldabc') [-1] >>> find_consecutive_segments('abc123xyz456') ['123', '456'] >>> find_consecutive_segments('12abc34def56789gh0') ['56789'] >>> find_consecutive_segments('123abc4567def') ['123', '4567'] >>> find_consecutive_segments('abc1234') ['1234']","solution":"import re def find_consecutive_segments(s): Finds all segments of the string containing 3 or more consecutive digits. Parameters: s (str): The input string. Returns: list: A list of matched segments or -1 if no such segment is found. segments = re.findall(r'd{3,}', s) return segments if segments else [-1]"},{"question":"def count_ways_to_balance(target_balance: int, min_transaction: int, max_transaction: int) -> int: Given a target balance, a minimum transaction amount, and a maximum transaction amount, return the number of ways to achieve the target balance using any number of transactions. This function should use dynamic programming to find the number of ways. >>> count_ways_to_balance(5, -2, 3) > 0 >>> count_ways_to_balance(1, 1, 1) == 1 >>> count_ways_to_balance(5, 6, 10) == 0 >>> count_ways_to_balance(0, -1, 1) > 0 >>> count_ways_to_balance(5, -5, 10) > 0 >>> count_ways_to_balance(50, -5, 5) > 0 >>> count_ways_to_balance(0, -1, 1) == 1 >>> count_ways_to_balance(3, 4, 5) == 0 >>> count_ways_to_balance(5, 5, 5) == 1","solution":"def count_ways_to_balance(target_balance, min_transaction, max_transaction): Given a target balance, a minimum transaction amount, and a maximum transaction amount, return the number of ways to achieve the target balance using any number of transactions. This function uses dynamic programming to find the number of ways. if min_transaction > max_transaction: return 0 dp = {0: 1} # Base case: one way to achieve balance 0 (by doing nothing) for current_balance in range(1, target_balance + 1): dp[current_balance] = 0 for transaction in range(min_transaction, max_transaction + 1): if current_balance - transaction in dp: dp[current_balance] += dp[current_balance - transaction] return dp.get(target_balance, 0)"},{"question":"def reverseList(arr): Reverses a list of integers without using looping or built-in reverse functions. >>> reverseList([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverseList([10, 20, 30, 40]) [40, 30, 20, 10] >>> reverseList([1]) [1] >>> reverseList([]) [] >>> reverseList([5, 5, 5, 5]) [5, 5, 5, 5] >>> reverseList([1000, 2000, 3000, 4000]) [4000, 3000, 2000, 1000] >>> reverseList([-1, -2, -3, -4, -5]) [-5, -4, -3, -2, -1]","solution":"def reverseList(arr): Reverses a list of integers without using looping or built-in reverse functions. if len(arr) == 0: return arr return reverseList(arr[1:]) + [arr[0]]"},{"question":"def max_submatrix_sum(grid): Find the maximum sum of a submatrix in a given grid. Each element in the grid is a non-negative integer. >>> max_submatrix_sum([ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ]) 29 >>> max_submatrix_sum([ [1, 2, 3], [-1, -2, -3] ]) 6 pass def process_test_cases(test_cases): Process multiple test cases and return their results. Each case consists of finding the maximum sum of a submatrix. >>> test_cases = [ [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ], [ [1, 2, 3], [-1, -2, -3] ] ] >>> process_test_cases(test_cases) [29, 6] pass def parse_input(input_string): Parse input string to extract test cases with grids. >>> input_string = \\"4 5n1 2 -1 -4 -20n-8 -3 4 2 1n3 8 10 1 3n-4 -1 1 7 -6n2 3n1 2 3n-1 -2 -3n0 0n\\" >>> parse_input(input_string) [ [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ], [ [1, 2, 3], [-1, -2, -3] ] ] pass def main(input_string): Main function to run the entire process. >>> input_string = \\"4 5n1 2 -1 -4 -20n-8 -3 4 2 1n3 8 10 1 3n-4 -1 1 7 -6n2 3n1 2 3n-1 -2 -3n0 0n\\" >>> main(input_string) 29 6 pass","solution":"def max_submatrix_sum(grid): def calculate_prefix_sum(matrix): prefix_sum = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)] for i in range(1, len(prefix_sum)): for j in range(1, len(prefix_sum[0])): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def find_max_sum(prefix_sum, rows, cols): max_sum = float('-inf') for i1 in range(1, rows + 1): for i2 in range(i1, rows + 1): for j1 in range(1, cols + 1): for j2 in range(j1, cols + 1): total = prefix_sum[i2][j2] - prefix_sum[i1-1][j2] - prefix_sum[i2][j1-1] + prefix_sum[i1-1][j1-1] max_sum = max(max_sum, total) return max_sum if not grid: return 0 N, M = len(grid), len(grid[0]) prefix_sum = calculate_prefix_sum(grid) return find_max_sum(prefix_sum, N, M) def process_test_cases(test_cases): results = [] for grid in test_cases: results.append(max_submatrix_sum(grid)) return results def parse_input(input_string): lines = input_string.strip().split('n') idx = 0 test_cases = [] while idx < len(lines): N, M = map(int, lines[idx].strip().split()) if N == 0 and M == 0: break grid = [] for i in range(N): row = list(map(int, lines[idx + 1 + i].strip().split())) grid.append(row) test_cases.append(grid) idx += N + 1 return test_cases def main(input_string): test_cases = parse_input(input_string) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def find_optimal_capital(n: int, roads: List[Tuple[int, int, int]]) -> int: In a kingdom far far away, there are n provinces connected by bidirectional roads. Each road connects two distinct provinces and has a certain length. The king wants to establish a new capital in one of these provinces so that the maximum distance from the capital to any other province is minimized. Your task is to help the king find this optimal capital. Args: n (int): The number of provinces. roads (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, w which denote that province u and province v are connected by a road of length w. Returns: int: The province number that should be chosen as the capital. Example: >>> find_optimal_capital(3, [(1, 2, 3), (2, 3, 4)]) 2","solution":"def find_optimal_capital(n, roads): from collections import defaultdict, deque def bfs(start_node): max_dist = [0] * (n + 1) visited = [False] * (n + 1) queue = deque([(start_node, 0)]) visited[start_node] = True farthest_node = start_node max_distance = 0 while queue: node, dist = queue.popleft() if dist > max_distance: max_distance = dist farthest_node = node for neighbor, weight in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, dist + weight)) max_dist[neighbor] = dist + weight return farthest_node, max_distance, max_dist # Step 1: Build the graph graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Step 2: Use BFS from any node to find the farthest node farthest_node_from_start, _, _ = bfs(1) # Step 3: Use BFS from the farthest node found opposite_farthest_node, _, dist_from_first_extreme = bfs(farthest_node_from_start) # Step 4: Use BFS from the opposite farthest node found _, _, dist_from_second_extreme = bfs(opposite_farthest_node) # Step 5: Determine the optimal capital optimal_distance = min( max(dist_from_first_extreme[i], dist_from_second_extreme[i]) for i in range(1, n + 1) ) optimal_capital = min( i for i in range(1, n + 1) if max(dist_from_first_extreme[i], dist_from_second_extreme[i]) == optimal_distance ) return optimal_capital # Example and testing n = 3 roads = [(1, 2, 3), (2, 3, 4)] print(find_optimal_capital(n, roads)) # Output should be 2"},{"question":"def check_trivia_answers(test_cases): Write a program that replicates the gameplay of a simple trivia quiz. Given a question and its possible answers, determine if the provided answer is correct or incorrect. Args: test_cases (List[Tuple[str, str, str, str, str, str, str]]): List of tuples where each tuple contains: - A string containing the trivia question. - Four strings representing the possible answers, labeled from A to D. - A character (A, B, C, or D) representing the correct answer. - A character (A, B, C, or D) representing the provided answer. Returns: List[str]: For each test case, returns \\"Correct\\" if the provided answer matches the correct answer, otherwise returns \\"Incorrect\\". >>> test_cases = [(\\"What is the capital of France?\\", \\"Paris\\", \\"London\\", \\"Berlin\\", \\"Madrid\\", \\"A\\", \\"A\\")] >>> check_trivia_answers(test_cases) [\\"Correct\\"] >>> test_cases = [(\\"What is the capital of France?\\", \\"Paris\\", \\"London\\", \\"Berlin\\", \\"Madrid\\", \\"A\\", \\"B\\")] >>> check_trivia_answers(test_cases) [\\"Incorrect\\"] >>> test_cases = [(\\"What is the capital of France?\\", \\"Paris\\", \\"London\\", \\"Berlin\\", \\"Madrid\\", \\"A\\", \\"A\\"), >>> (\\"Name the largest planet in our solar system.\\", \\"Earth\\", \\"Mars\\", \\"Jupiter\\", \\"Saturn\\", \\"C\\", \\"C\\")] >>> check_trivia_answers(test_cases) [\\"Correct\\", \\"Correct\\"]","solution":"def check_trivia_answers(test_cases): results = [] for case in test_cases: question, A, B, C, D, correct_letter, provided_letter = case if correct_letter == provided_letter: results.append(\\"Correct\\") else: results.append(\\"Incorrect\\") return results"},{"question":"def can_reorder_consecutively(t, test_cases): Determine whether it is possible to reorder the array such that each number appears exactly once, and the absolute difference between each pair of consecutive elements is exactly one. Args: t (int): the number of test cases test_cases (list of tuples): each tuple contains an integer n and a list of n integers Returns: list of str: [\\"YES\\" or \\"NO\\"] for each test case >>> can_reorder_consecutively(3, [(3, [1, 3, 2]), (5, [4, 2, 9, 6, 3]), (4, [7, 8, 6, 10])]) ['YES', 'NO', 'NO'] >>> can_reorder_consecutively(2, [(4, [1, 2, 3, 4]), (3, [1, 2, 4])]) ['YES', 'NO'] >>> can_reorder_consecutively(1, [(2, [5, 6])]) ['YES']","solution":"def can_reorder_consecutively(t, test_cases): results = [] for case in test_cases: n, arr = case arr.sort() possible = all(arr[i] - arr[i-1] == 1 for i in range(1, n)) results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def rotateMatrixAntiClockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given MxN matrix 90 degrees anti-clockwise. >>> rotateMatrixAntiClockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [3, 6, 9], ... [2, 5, 8], ... [1, 4, 7] ... ] >>> rotateMatrixAntiClockwise([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) == [ ... [2, 4, 6], ... [1, 3, 5] ... ]","solution":"def rotateMatrixAntiClockwise(matrix): Rotates a given MxN matrix 90 degrees anti-clockwise. :param matrix: List[List[int]], the input matrix :return: Rotated matrix if not matrix or not matrix[0]: return [] M = len(matrix) N = len(matrix[0]) rotated_matrix = [[0] * M for _ in range(N)] for i in range(M): for j in range(N): rotated_matrix[N - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"def max_brightness(n: int, brightness: List[int]) -> int: Determine the maximum sum of brightness values subject to the condition that no two adjacent lamps can be lit. Args: n: The number of lamps. brightness: A list of integers representing the brightness of each lamp. Returns: An integer representing the maximum sum of brightness achievable. >>> max_brightness(4, [3, 2, 5, 10]) 13 >>> max_brightness(3, [1, 2, 3]) 4 >>> max_brightness(1, [4]) 4 >>> max_brightness(0, []) 0 >>> max_brightness(3, [-1, -2, -3]) 0 >>> max_brightness(5, [-1, 3, 5, -2, 6]) 11 >>> max_brightness(2, [7, 10]) 10 >>> max_brightness(100000, [1] * 100000) 50000","solution":"def max_brightness(n, brightness): if n == 0: return 0 if n == 1: return max(0, brightness[0]) # Initialize DP array dp = [0] * n dp[0] = max(0, brightness[0]) dp[1] = max(dp[0], brightness[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + brightness[i]) return dp[n - 1]"},{"question":"def longest_distinct_substring_length(s: str) -> int: Returns the length of the longest substring with distinct characters. Args: s (str): Input string containing only lowercase alphabetical characters. Returns: int: The length of the longest substring with distinct characters. >>> longest_distinct_substring_length(\\"abcabcbb\\") 3 >>> longest_distinct_substring_length(\\"bbbbb\\") 1 >>> longest_distinct_substring_length(\\"pwwkew\\") 3 >>> longest_distinct_substring_length(\\"a\\") 1 >>> longest_distinct_substring_length(\\"ab\\") 2 >>> longest_distinct_substring_length(\\"aa\\") 1 >>> longest_distinct_substring_length(\\"abcdefgh\\") 8 >>> longest_distinct_substring_length(\\"a\\" * 1000) 1 >>> longest_distinct_substring_length(\\"abcdefghij\\" * 100) 10","solution":"def longest_distinct_substring_length(s): Returns the length of the longest substring with distinct characters. Args: s (str): Input string containing only lowercase alphabetical characters. Returns: int: The length of the longest substring with distinct characters. n = len(s) start = 0 max_length = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(char_index_map[s[end]] + 1, start) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def merge_sort(guests): Sort the guests by their names using Merge Sort algorithm in a case insensitive manner. >>> merge_sort([\\"Charlie\\", \\"alice\\", \\"Bob\\"]) [\\"alice\\", \\"Bob\\", \\"Charlie\\"] >>> merge_sort([\\"Alice\\"]) [\\"Alice\\"] pass def merge(left, right): Merge two sorted lists into one sorted list in a case insensitive manner. >>> merge([\\"Alice\\", \\"charlie\\"], [\\"Bob\\", \\"dave\\"]) [\\"Alice\\", \\"Bob\\", \\"charlie\\", \\"dave\\"] pass def quick_sort(guests): Sort the guests by their names using Quick Sort algorithm in a case insensitive manner. >>> quick_sort([\\"Charlie\\", \\"alice\\", \\"Bob\\"]) [\\"alice\\", \\"Bob\\", \\"Charlie\\"] >>> quick_sort([\\"Alice\\"]) [\\"Alice\\"] pass def wedding_seating_arrangement(guest_list): Print the guests sorted by Merge Sort and Quick Sort algorithms. >>> guest_list = [\\"Charlie\\", \\"Alice\\", \\"Bob\\"] >>> wedding_seating_arrangement(guest_list) Alice Bob Charlie Alice Bob Charlie merge_sorted_guests = merge_sort(guest_list) quick_sorted_guests = quick_sort(guest_list) print(' '.join(merge_sorted_guests)) print(' '.join(quick_sorted_guests))","solution":"def merge_sort(guests): if len(guests) <= 1: return guests mid = len(guests) // 2 left = merge_sort(guests[:mid]) right = merge_sort(guests[mid:]) return merge(left, right) def merge(left, right): result = [] while left and right: if left[0].lower() <= right[0].lower(): result.append(left.pop(0)) else: result.append(right.pop(0)) result.extend(left) result.extend(right) return result def quick_sort(guests): if len(guests) <= 1: return guests pivot = guests[len(guests) // 2] less = [x for x in guests if x.lower() < pivot.lower()] equal = [x for x in guests if x.lower() == pivot.lower()] greater = [x for x in guests if x.lower() > pivot.lower()] return quick_sort(less) + equal + quick_sort(greater) def wedding_seating_arrangement(guest_list): merge_sorted_guests = merge_sort(guest_list) quick_sorted_guests = quick_sort(guest_list) print(' '.join(merge_sorted_guests)) print(' '.join(quick_sorted_guests))"},{"question":"def longest_subarray_with_zero_sum(n, arr): Returns the length of the longest contiguous subarray with a sum of zero. Parameters: n (int): the number of elements in the array arr (list of int): the array of integers Returns: int: the length of the longest contiguous subarray with a sum of zero >>> longest_subarray_with_zero_sum(8, [1, 2, -2, 4, -4, 2, -2, 1]) 6 >>> longest_subarray_with_zero_sum(1, [0]) 1 >>> longest_subarray_with_zero_sum(4, [1, 2, 3, 4]) 0 >>> longest_subarray_with_zero_sum(5, [0, 0, 0, 0, 0]) 5 >>> longest_subarray_with_zero_sum(6, [1, -1, 1, -1, 1, -1]) 6 >>> longest_subarray_with_zero_sum(7, [1, -1, 2, -2, 3, -3, 4]) 6 >>> longest_subarray_with_zero_sum(n=10000, arr=[0]*10000) 10000","solution":"def longest_subarray_with_zero_sum(n, arr): Returns the length of the longest contiguous subarray with a sum of zero. Parameters: n (int): the number of elements in the array arr (list of int): the array of integers Returns: int: the length of the longest contiguous subarray with a sum of zero prefix_sum = {} curr_sum = 0 max_length = 0 for i in range(n): curr_sum += arr[i] if curr_sum == 0: max_length = i + 1 if curr_sum in prefix_sum: max_length = max(max_length, i - prefix_sum[curr_sum]) else: prefix_sum[curr_sum] = i return max_length"},{"question":"def rearrange_words_by_length(sentence: str) -> str: Rearrange the words in a sentence by their length in ascending order. If two words have the same length, their relative order in the input is preserved. >>> rearrange_words_by_length(\\"The quick brown fox jumps over the lazy dog\\") \\"The fox the dog over lazy quick brown jumps\\" >>> rearrange_words_by_length(\\"I love solving programming challenges\\") \\"I love solving challenges programming\\" # Unit Tests: from solution import rearrange_words_by_length def test_simple_sentence(): assert rearrange_words_by_length(\\"The quick brown fox jumps over the lazy dog\\") == \\"The fox the dog over lazy quick brown jumps\\" def test_programming_related_sentence(): assert rearrange_words_by_length(\\"I love solving programming challenges\\") == \\"I love solving challenges programming\\" def test_single_word(): assert rearrange_words_by_length(\\"Supercalifragilisticexpialidocious\\") == \\"Supercalifragilisticexpialidocious\\" def test_different_lengths(): assert rearrange_words_by_length(\\"A ab abc abcd abcde\\") == \\"A ab abc abcd abcde\\" def test_same_length_words(): assert rearrange_words_by_length(\\"ant bat cat dog\\") == \\"ant bat cat dog\\"","solution":"def rearrange_words_by_length(sentence): Rearranges the words in a sentence by their length in ascending order. If two words have the same length, their relative order in the input is preserved. words = sentence.split() sorted_words = sorted(words, key=len) return ' '.join(sorted_words)"},{"question":"def lcs_length(A: str, B: str) -> int: Helper function to find the length of the Longest Common Subsequence (LCS) of A and B. >>> lcs_length(\\"abc\\", \\"ac\\") == 2 >>> lcs_length(\\"horizon\\", \\"noz\\") == 2 def smallest_supersequence_length(A: str, B: str) -> int: Function to find the length of the smallest string that contains both A and B as subsequences. >>> smallest_supersequence_length(\\"abc\\", \\"ac\\") == 3 >>> smallest_supersequence_length(\\"horizon\\", \\"noz\\") == 8 def smallest_supersequence_lengths(test_cases: List[Tuple[str, str]]) -> List[int]: Function to process multiple test cases and return the results. >>> test_cases = [(\\"abc\\", \\"ac\\"), (\\"horizon\\", \\"noz\\")] >>> smallest_supersequence_lengths(test_cases) == [3, 8]","solution":"def lcs_length(A, B): Helper function to find the length of the Longest Common Subsequence (LCS) of A and B. m = len(A) n = len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def smallest_supersequence_length(A, B): Function to find the length of the smallest string that contains both A and B as subsequences. lcs_len = lcs_length(A, B) return len(A) + len(B) - lcs_len def smallest_supersequence_lengths(test_cases): Function to process multiple test cases and return the results. results = [] for A, B in test_cases: results.append(smallest_supersequence_length(A, B)) return results"},{"question":"def minimum_reverse_operations(n: int, array: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Determine the minimum number of operations required to sort the list in non-decreasing order by reversing the order of some contiguous subarray. >>> minimum_reverse_operations(3, [3, 1, 2]) (2, [(1, 3), (1, 2)]) >>> minimum_reverse_operations(5, [5, 4, 3, 2, 1]) (1, [(1, 5)]) >>> minimum_reverse_operations(4, [1, 3, 2, 4]) (1, [(2, 3)]) >>> minimum_reverse_operations(1, [1]) (0, []) >>> minimum_reverse_operations(3, [1, 2, 3]) (0, [])","solution":"def minimum_reverse_operations(n, array): Determine the minimum number of operations required to sort the list in non-decreasing order by reversing the order of some contiguous subarray. sorted_array = sorted(array) if array == sorted_array: return 0, [] result = [] left = 0 # Find the first mismatching pair from the beginning while array[left] == sorted_array[left]: left += 1 right = n - 1 # Find the first mismatching pair from the end while array[right] == sorted_array[right]: right -= 1 while left < right: result.append((left + 1, right + 1)) array[left:right + 1] = array[left:right + 1][::-1] while left < n and array[left] == sorted_array[left]: left += 1 while right >= 0 and array[right] == sorted_array[right]: right -= 1 if left < right: result.append((left + 1, right + 1)) array[left:right + 1] = array[left:right + 1][::-1] if array == sorted_array: break if array != sorted_array: return -1, [] return len(result), result"},{"question":"def encrypt_message(message: str, shift: int) -> str: Encrypt the given message by shifting each letter in the message by the given shift value. >>> encrypt_message('hello', 3) 'khoor' >>> encrypt_message('xyz', 3) 'abc'","solution":"def encrypt_message(message, shift): Encrypt the given message by shifting each letter in the message by the given shift value. Parameters: message (str): A string consisting of lowercase letters shift (int): The number of positions to shift each letter down the alphabet Returns: str: The encrypted message encrypted_message = [] for char in message: # Calculate the new character and handle wrap-around using modulo operation new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) encrypted_message.append(new_char) return ''.join(encrypted_message)"},{"question":"def max_score(r, problem_counts, scores): Given the number of rounds, problems in each round, and their corresponding scores, find the maximum score a participant can achieve by selecting a subset of problems such that at least one problem is selected from each round. >>> max_score(3, [2, 3, 2], [4, 2, 3, 8, -1, 0, 7]) 19 >>> max_score(1, [1], [5]) 5 >>> max_score(3, [1, 1, 1], [10, 20, 30]) 60 >>> max_score(2, [2, 2], [-5, -3, -8, -2]) -5 >>> max_score(2, [3, 2], [1, -1, 3, -2, 4]) 7","solution":"def max_score(r, problem_counts, scores): Given the number of rounds, problems in each round, and their corresponding scores, find the maximum score a participant can achieve by selecting a subset of problems such that at least one problem is selected from each round. max_scores = [] index = 0 for count in problem_counts: round_scores = scores[index:index + count] max_scores.append(max(round_scores)) index += count return sum(max_scores) # Example input r = 3 problem_counts = [2, 3, 2] scores = [4, 2, 3, 8, -1, 0, 7] print(max_score(r, problem_counts, scores)) # Output should be 19"},{"question":"class Inventory: def __init__(self, stocks): self.stocks = stocks def update_stock(self, product_id, quantity): self.stocks[product_id - 1] += quantity def query_stock(self, product_id): return self.stocks[product_id - 1] def process_queries(n, q, initial_stocks, queries): Process a series of queries to update and retrieve product stock levels. Args: n (int): The number of different products. q (int): The number of queries. initial_stocks (List[int]): Initial stock levels of each product. queries (List[Tuple[str, int, int]]): A list of queries where each query is either of the form (\\"update\\", p, x) or (\\"query\\", p). Returns: List[int]: The results of the queries of the form \\"query p\\". Example: >>> process_queries(5, 7, [20, 10, 5, 0, 15], [(\\"query\\", 3), (\\"update\\", 1, 5), (\\"query\\", 1), (\\"update\\", 5, 10), (\\"query\\", 5), (\\"update\\", 2, 20), (\\"query\\", 2)]) [5, 25, 25, 30] >>> process_queries(3, 4, [100, 200, 300], [(\\"update\\", 2, 50), (\\"query\\", 2), (\\"update\\", 3, 25), (\\"query\\", 3)]) [250, 325]","solution":"class Inventory: def __init__(self, stocks): self.stocks = stocks def update_stock(self, product_id, quantity): self.stocks[product_id - 1] += quantity def query_stock(self, product_id): return self.stocks[product_id - 1] def process_queries(n, q, initial_stocks, queries): inventory = Inventory(initial_stocks) results = [] for query in queries: if query[0] == \\"update\\": _, product_id, quantity = query inventory.update_stock(product_id, quantity) elif query[0] == \\"query\\": _, product_id = query result = inventory.query_stock(product_id) results.append(result) return results"},{"question":"def is_palindrome(n): return str(n) == str(n)[::-1] def reverse_number(n): return int(str(n)[::-1]) def find_lychrel(n: int, m: int) -> int: Generate and validate a sequence of Lychrel numbers starting from a given integer n up to the maximum number of iterations m. Args: n (int): The starting number. m (int): The maximum number of iterations. Returns: int or str: The palindrome number found within the given number of iterations, or \\"LYCHREL\\" if no palindrome is found. >>> find_lychrel(56, 3) 121 >>> find_lychrel(196, 10) \\"LYCHREL\\" >>> find_lychrel(47, 1) 121 >>> find_lychrel(349, 3) 7337 >>> find_lychrel(295, 50) \\"LYCHREL\\" >>> find_lychrel(1, 1) 2 >>> find_lychrel(0, 1) 0","solution":"def is_palindrome(n): return str(n) == str(n)[::-1] def reverse_number(n): return int(str(n)[::-1]) def find_lychrel(n, m): for _ in range(m): reversed_n = reverse_number(n) n += reversed_n if is_palindrome(n): return n return \\"LYCHREL\\" # Example usage: if __name__ == \\"__main__\\": n = int(input().strip()) m = int(input().strip()) print(find_lychrel(n, m))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode: Constructs a binary tree from preorder and inorder traversal lists. Parameters: preorder (List[int]): List of integers representing the preorder traversal of the tree. inorder (List[int]): List of integers representing the inorder traversal of the tree. Returns: TreeNode: The root of the constructed binary tree. Example: >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> root = buildTree(preorder, inorder)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): if not preorder or not inorder: return None # The first element in preorder traversal is the root root_val = preorder[0] root = TreeNode(root_val) # Find the index of the root in inorder traversal mid = inorder.index(root_val) # Recursively build the left and right subtrees root.left = buildTree(preorder[1:mid+1], inorder[:mid]) root.right = buildTree(preorder[mid+1:], inorder[mid+1:]) return root"},{"question":"from typing import List, Dict def can_prepare_recipes(recipes: List[Dict[str, int]], available_ingredients: Dict[str, int]) -> List[int]: Determines which recipes can be prepared with the available ingredients. Args: recipes (List[Dict[str, int]]): A list of dictionaries where each dictionary contains the ingredients and their quantities for a specific recipe. available_ingredients (Dict[str, int]): A dictionary where the keys are ingredient names and the values are the quantities available in the kitchen. Returns: List[int]: A list of indices representing the recipes that can be fully prepared with the available ingredients. >>> recipes = [ ... {\\"flour\\": 200, \\"sugar\\": 100, \\"eggs\\": 2}, ... {\\"flour\\": 300, \\"sugar\\": 150, \\"butter\\": 100}, ... {\\"flour\\": 100, \\"sugar\\": 200, \\"eggs\\": 1, \\"butter\\": 50} ... ] >>> available_ingredients = { ... \\"flour\\": 400, ... \\"sugar\\": 300, ... \\"eggs\\": 3, ... \\"butter\\": 100 ... } >>> can_prepare_recipes(recipes, available_ingredients) [0, 2] pass","solution":"def can_prepare_recipes(recipes, available_ingredients): Determines which recipes can be prepared with the available ingredients. Args: recipes (List[Dict[str, int]]): A list of dictionaries where each dictionary contains the ingredients and their quantities for a specific recipe. available_ingredients (Dict[str, int]): A dictionary where the keys are ingredient names and the values are the quantities available in the kitchen. Returns: List[int]: A list of indices representing the recipes that can be fully prepared with the available ingredients. can_prepare = [] for idx, recipe in enumerate(recipes): can_prepare_this = True for ingredient, required_qty in recipe.items(): if available_ingredients.get(ingredient, 0) < required_qty: can_prepare_this = False break if can_prepare_this: can_prepare.append(idx) return can_prepare"},{"question":"from typing import List def alien_dictionary(words: List[str]) -> str: Determines the order of characters in an alien language given a list of words in that language. Args: words (List[str]): A list of words from the alien language's dictionary. Returns: str: A string representing the smallest lexicographical order of characters from the alien dictionary. Examples: >>> alien_dictionary([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) 'wertf' >>> alien_dictionary([\\"z\\", \\"x\\"]) 'zx' >>> alien_dictionary([\\"z\\", \\"x\\", \\"z\\"]) '' >>> alien_dictionary([\\"abc\\", \\"ab\\"]) '' >>> alien_dictionary([\\"z\\", \\"x\\", \\"a\\", \\"b\\"]) 'abzx'","solution":"from collections import defaultdict, deque def alien_dictionary(words): Determines the order of characters in an alien language given a list of words in that language. # Create a graph graph = defaultdict(set) in_degree = {char: 0 for word in words for char in word} # Build the graph for i in range(len(words) - 1): first_word, second_word = words[i], words[i + 1] min_length = min(len(first_word), len(second_word)) # Check for invalid order like [\\"abc\\", \\"ab\\"] if len(first_word) > len(second_word) and first_word[:min_length] == second_word[:min_length]: return \\"\\" for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in graph[first_word[j]]: graph[first_word[j]].add(second_word[j]) in_degree[second_word[j]] += 1 break # Topological Sort (Kahn's algorithm) queue = deque([char for char in in_degree if in_degree[char] == 0]) result = [] while queue: current_char = queue.popleft() result.append(current_char) for neighbor in graph[current_char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(result) != len(in_degree): return \\"\\" return \\"\\".join(result)"},{"question":"from typing import List def sort_marbles(marbles: List[str]) -> List[str]: Sorts a list of marbles such that all 'red' marbles come first, followed by all 'blue' marbles, and finally all 'green' marbles. Uses a single-pass algorithm to achieve this. >>> sort_marbles([\\"green\\", \\"blue\\", \\"red\\", \\"green\\", \\"blue\\", \\"red\\"]) [\\"red\\", \\"red\\", \\"blue\\", \\"blue\\", \\"green\\", \\"green\\"] >>> sort_marbles([\\"blue\\", \\"blue\\", \\"red\\", \\"red\\", \\"green\\", \\"green\\"]) [\\"red\\", \\"red\\", \\"blue\\", \\"blue\\", \\"green\\", \\"green\\"] >>> sort_marbles([\\"red\\", \\"red\\", \\"red\\"]) [\\"red\\", \\"red\\", \\"red\\"] >>> sort_marbles([\\"blue\\", \\"blue\\", \\"blue\\"]) [\\"blue\\", \\"blue\\", \\"blue\\"] >>> sort_marbles([]) [] >>> sort_marbles([\\"red\\", \\"blue\\", \\"red\\", \\"blue\\"]) [\\"red\\", \\"red\\", \\"blue\\", \\"blue\\"] >>> sort_marbles([\\"green\\", \\"blue\\", \\"green\\", \\"blue\\"]) [\\"blue\\", \\"blue\\", \\"green\\", \\"green\\"] >>> sort_marbles([\\"green\\", \\"red\\", \\"red\\", \\"green\\", \\"blue\\", \\"blue\\"]) [\\"red\\", \\"red\\", \\"blue\\", \\"blue\\", \\"green\\", \\"green\\"] >>> sort_marbles([\\"red\\", \\"green\\", \\"blue\\", \\"red\\", \\"green\\", \\"blue\\"]) [\\"red\\", \\"red\\", \\"blue\\", \\"blue\\", \\"green\\", \\"green\\"] >>> sort_marbles([\\"red\\"]*100000 + [\\"blue\\"]*100000 + [\\"green\\"]*100000) [\\"red\\"]*100000 + [\\"blue\\"]*100000 + [\\"green\\"]*100000","solution":"def sort_marbles(marbles): Sorts a list of marbles such that all 'red' marbles come first, followed by all 'blue' marbles, and finally all 'green' marbles. Uses a single-pass algorithm to achieve this. red_ptr, green_ptr = 0, len(marbles) - 1 current = 0 while current <= green_ptr: if marbles[current] == \\"red\\": marbles[red_ptr], marbles[current] = marbles[current], marbles[red_ptr] red_ptr += 1 current += 1 elif marbles[current] == \\"blue\\": current += 1 else: # marbles[current] == \\"green\\" marbles[green_ptr], marbles[current] = marbles[current], marbles[green_ptr] green_ptr -= 1 return marbles"},{"question":"def has_subarray_with_sum(arr, k, target): Determines if there exists a contiguous subarray of length exactly k that has a sum equal to target. >>> has_subarray_with_sum([1, 2, 3, 4, 5, 6], 3, 6) \\"YES\\" >>> has_subarray_with_sum([1, -1, 1, -1, 1], 2, 0) \\"YES\\" >>> has_subarray_with_sum([1, 2, 3, 4], 2, 10) \\"NO\\" from typing import List def has_subarray_with_sum(arr: List[int], k: int, target: int) -> str: pass","solution":"def has_subarray_with_sum(arr, k, target): Determines if there exists a contiguous subarray of length exactly k that has a sum equal to target. n = len(arr) if k > n: return \\"NO\\" current_sum = sum(arr[:k]) if current_sum == target: return \\"YES\\" for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum == target: return \\"YES\\" return \\"NO\\""},{"question":"def get_top_k_posts(n: int, k: int, posts: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Returns the top k most liked posts based on the number of likes received. Parameters: n (int): The number of posts. k (int): The number of top posts to return. posts (list of tuples): A list of tuples where each tuple contains a user identifier (str) and the number of likes (int). Returns: list of tuples: A list of top k posts sorted by the number of likes in non-increasing order. If two posts have the same number of likes, they are sorted by the user identifier in alphabetical order. >>> get_top_k_posts(5, 3, [(\\"alice\\", 100), (\\"bob\\", 150), (\\"carol\\", 100), (\\"dave\\", 200), (\\"eve\\", 150)]) [('dave', 200), ('bob', 150), ('eve', 150)] >>> get_top_k_posts(5, 2, [(\\"alice\\", 100), (\\"bob\\", 100), (\\"carol\\", 100), (\\"dave\\", 200), (\\"eve\\", 50)]) [('dave', 200), ('alice', 100)]","solution":"def get_top_k_posts(n, k, posts): Returns the top k most liked posts based on the number of likes received. Parameters: n (int): The number of posts. k (int): The number of top posts to return. posts (list of tuples): A list of tuples where each tuple contains a user identifier (str) and the number of likes (int). Returns: list of tuples: A list of top k posts sorted by the number of likes in non-increasing order. If two posts have the same number of likes, they are sorted by the user identifier in alphabetical order. posts.sort(key=lambda x: (-x[1], x[0])) return posts[:k]"},{"question":"def smallestDifference(N: int, arr: List[int]) -> int: Returns the smallest absolute difference between any two elements in the array. >>> smallestDifference(5, [3, 8, 15, 17, 9]) 1 >>> smallestDifference(3, [10, 24, 40]) 14","solution":"def smallestDifference(N, arr): Returns the smallest absolute difference between any two elements in the array. if N < 2: return None # When there are less than 2 elements, return None arr.sort() # Sort the array to find the smallest differences efficiently smallest_diff = float('inf') # Iterate through the array to find the minimum difference between consecutive pairs for i in range(N - 1): diff = abs(arr[i] - arr[i + 1]) if diff < smallest_diff: smallest_diff = diff return smallest_diff"},{"question":"def count_pairs_with_difference_k(arr: List[int], k: int) -> int: Returns the number of unique pairs in array \`arr\` with a difference of \`k\`. >>> count_pairs_with_difference_k([1, 7, 5, 9, 2, 12, 3], 2) 4 >>> count_pairs_with_difference_k([1, 5, 3, 4, 2], 3) 2 >>> count_pairs_with_difference_k([1, 1, 1, 1], 0) 1 >>> count_pairs_with_difference_k([1, 5, 3, 4, 2], 10) 0 >>> count_pairs_with_difference_k([1, 2, 3, 4, 5], 0) 0 >>> count_pairs_with_difference_k(list(range(1, 100001)), 1) 99999 from typing import List","solution":"def count_pairs_with_difference_k(arr, k): Returns the number of unique pairs in array \`arr\` with a difference of \`k\`. if k < 0: return 0 unique_elements = set(arr) count = 0 if k == 0: seen = set() for num in arr: if num in seen: continue if arr.count(num) > 1: count += 1 seen.add(num) return count for num in unique_elements: if num + k in unique_elements: count += 1 return count # Example usage # Example Input: 7 2 # 1 7 5 9 2 12 3 arr = [1, 7, 5, 9, 2, 12, 3] k = 2 print(count_pairs_with_difference_k(arr, k)) # Output should be 4"},{"question":"def longest_increasing_sequence(grid: List[List[int]]) -> int: Find the length of the longest monotonically increasing sequence present in any row, column, or diagonal of the grid. >>> longest_increasing_sequence([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 3 >>> longest_increasing_sequence([ ... [1, 5, 3, 4], ... [6, 7, 8, 2], ... [9, 1, 2, 4], ... [0, 3, 4, 1] ... ]) 3 >>> longest_increasing_sequence([ ... [10] ... ]) 1 >>> longest_increasing_sequence([ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) 1 >>> longest_increasing_sequence([ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ]) 4","solution":"def longest_increasing_sequence(grid): n = len(grid) def longest_increasing_in_line(line): max_length = 1 current_length = 1 for i in range(1, len(line)): if line[i] > line[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length max_length = 1 # Check rows and columns for i in range(n): max_length = max(max_length, longest_increasing_in_line(grid[i])) column = [grid[j][i] for j in range(n)] max_length = max(max_length, longest_increasing_in_line(column)) # Check diagonals for d in range(-n + 1, n): diag1 = [grid[i][i - d] for i in range(max(d, 0), min(n, n + d))] diag2 = [grid[i][d + i] for i in range(max(-d, 0), min(n, n - d))] if diag1: max_length = max(max_length, longest_increasing_in_line(diag1)) if diag2: max_length = max(max_length, longest_increasing_in_line(diag2)) return max_length"},{"question":"def determine_winner(s: str) -> str: Determines the winner of the game between Isabella and Jasper. Parameters: s (str): The initial string at the beginning of the game. Returns: str: \\"Isabella\\" if Isabella wins, \\"Jasper\\" if Jasper wins. Examples: >>> determine_winner(\\"hello\\") 'Jasper' >>> determine_winner(\\"aei\\") 'Isabella'","solution":"def determine_winner(s): Determines the winner of the game between Isabella and Jasper. Parameters: s (str): The initial string at the beginning of the game. Returns: str: \\"Isabella\\" if Isabella wins, \\"Jasper\\" if Jasper wins. vowels = set(\\"aeiou\\") vowel_count = sum(1 for char in s if char in vowels) consonant_count = len(s) - vowel_count # If the vowel count is 0 or the consonant count is 0, the game ends immediately. if vowel_count == 0: return \\"Jasper\\" if consonant_count == 0: return \\"Isabella\\" # The winning strategy depends on the parity of the counts if vowel_count > consonant_count: return \\"Isabella\\" return \\"Jasper\\""},{"question":"from typing import List, Tuple def number_of_passes(N: int, K: int) -> int: Determines the number of passes for the ball to return to the starting person. Parameters: N (int): Total number of friends. K (int): Number of steps to pass the ball to the right. Returns: int: Number of passes made in one complete round. pass # Implement the function here def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases to determine the number of passes for each case. Parameters: test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains: N (int): Total number of friends. K (int): Number of steps to pass the ball to the right. Returns: List[int]: List of number of passes made in one complete round for each test case. pass # Implement the function here def test_number_of_passes(): assert number_of_passes(5, 2) == 5 assert number_of_passes(6, 1) == 6 assert number_of_passes(10, 3) == 10 assert number_of_passes(7, 2) == 7 assert number_of_passes(8, 3) == 8 def test_process_test_cases(): test_cases = [(5, 2), (6, 1), (10, 3)] assert process_test_cases(test_cases) == [5, 6, 10] # Run tests with pytest if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def number_of_passes(N, K): Determines the number of passes for the ball to return to the starting person. Parameters: N (int): Total number of friends. K (int): Number of steps to pass the ball to the right. Returns: int: Number of passes made in one complete round. # Calculate the number of passes needed for the ball to return to the starting person passes = 1 current_position = K % N while current_position != 0: passes += 1 current_position = (current_position + K) % N return passes # Function to handle multiple test cases def process_test_cases(test_cases): results = [] for N, K in test_cases: results.append(number_of_passes(N, K)) return results"},{"question":"def construct_matrix(N): Given an integer N, this function constructs a matrix NxN where each element of the matrix follows these rules: 1. The sum of elements in each row should be equal. 2. The sum of elements in each column should be equal. 3. Each element in the matrix should be an integer greater than or equal to 0. If it's not possible to generate such a matrix, return -1. >>> construct_matrix(2) [[1, 1], [1, 1]] >>> construct_matrix(3) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> construct_matrix(4) [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] pass def process_input(T, cases): This function processes \`T\` test cases, where each test case contains a single integer N. It returns a list of results for each test case by calling the \`construct_matrix\` function. >>> T = 3 >>> cases = [2, 3, 4] >>> process_input(T, cases) [[[1, 1], [1, 1]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]] pass","solution":"def construct_matrix(N): if N <= 0: return -1 matrix = [[1]*N for _ in range(N)] return matrix def process_input(T, cases): results = [] for case in cases: results.append(construct_matrix(case)) return results"},{"question":"from typing import List, Tuple def num_islands(grid: List[List[str]]) -> int: Find the number of islands in the given grid. >>> num_islands([[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"1\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"]]) 2 >>> num_islands([[\\"1\\",\\"1\\",\\"1\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"0\\"],[\\"1\\",\\"0\\",\\"0\\",\\"1\\"],[\\"0\\",\\"0\\",\\"1\\",\\"1\\"]]) 2 def number_of_islands(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Process the input and find the number of islands for each test case. >>> number_of_islands(2, [((4, 5), [[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0]]), ((4, 4), [[1, 1, 1, 0], [1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1]])]) [2, 2] >>> number_of_islands(1, [((1, 7), [[1, 0, 1, 1, 0, 1, 1]])]) [3] def process_input(input_list: List[str]) -> List[int]: Parse the input and return the number of islands for each test case. >>> process_input([\\"2\\", \\"4 5\\", \\"1 1 0 0 0\\", \\"1 1 0 0 1\\", \\"0 0 0 1 1\\", \\"0 0 0 1 0\\", \\"4 4\\", \\"1 1 1 0\\", \\"1 1 0 0\\", \\"1 0 0 1\\", \\"0 0 1 1\\"]) [2, 2] >>> process_input([\\"1\\", \\"1 7\\", \\"1 0 1 1 0 1 1\\"]) [3]","solution":"def num_islands(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == '0': return grid[x][y] = '0' # Mark the land as visited dfs(x - 1, y) dfs(x + 1, y) dfs(x, y - 1) dfs(x, y + 1) islands_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': islands_count += 1 dfs(i, j) return islands_count def number_of_islands(T, test_cases): result = [] for case in test_cases: m, n = case[0] grid = [list(map(str, row)) for row in case[1]] result.append(num_islands(grid)) return result # Input for the number of test cases def process_input(input_list): T = int(input_list[0]) idx = 1 test_cases = [] for _ in range(T): m, n = map(int, input_list[idx].split()) grid = [] for i in range(1, m + 1): grid.append(list(map(int, input_list[idx + i].split()))) test_cases.append(((m, n), grid)) idx += m + 1 return number_of_islands(T, test_cases)"},{"question":"def validate_ids(ids): Validates a list of IDs and returns the results indicating if they are valid or invalid. An ID is considered \\"valid\\" if it has at least one uppercase letter and at least one digit. :param ids: List of IDs to validate :return: List of results (\\"Valid\\" or \\"Invalid\\") Example: >>> validate_ids([\\"A1\\", \\"abc\\", \\"XYZ123\\"]) [\\"Valid\\", \\"Invalid\\", \\"Valid\\"]","solution":"def validate_ids(ids): Validates a list of IDs and returns the results indicating if they are valid or invalid. An ID is considered \\"valid\\" if it has at least one uppercase letter and at least one digit. :param ids: List of IDs to validate :return: List of results (\\"Valid\\" or \\"Invalid\\") results = [] for id in ids: has_upper = any(char.isupper() for char in id) has_digit = any(char.isdigit() for char in id) if has_upper and has_digit: results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results"},{"question":"import math def minimum_drone_trips(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of drone trips required for each test case. Parameters: - T (int): The number of test cases. - test_cases (List[Tuple[int, int]]): Each tuple contains two integers, N and C, where N is the total number of packages and C is the drone capacity. Returns: - List[int]: A list containing the minimum number of trips for each test case. Examples: >>> minimum_drone_trips(4, [(10, 3), (25, 5), (50, 50), (7, 1)]) [4, 5, 1, 7] >>> minimum_drone_trips(2, [(100, 10), (200, 50)]) [10, 4] from typing import List, Tuple def test_minimum_drone_trips(): assert minimum_drone_trips(4, [(10, 3), (25, 5), (50, 50), (7, 1)]) == [4, 5, 1, 7] assert minimum_drone_trips(2, [(100, 10), (200, 50)]) == [10, 4] assert minimum_drone_trips(3, [(1, 1), (1000000, 1), (100, 33)]) == [1, 1000000, 4] assert minimum_drone_trips(1, [(1, 1000000)]) == [1] assert minimum_drone_trips(5, [(0, 3), (10, 2), (17, 5), (50, 49), (1000000, 1000000)]) == [0, 5, 4, 2, 1] def test_minimum_drone_trips_edge_cases(): assert minimum_drone_trips(1, [(1000000, 1)]) == [1000000] assert minimum_drone_trips(1, [(10, 1000000)]) == [1] assert minimum_drone_trips(1, [(1000000, 1000000)]) == [1] assert minimum_drone_trips(3, [(1, 2), (2, 3), (3, 1000000)]) == [1, 1, 1]","solution":"import math def minimum_drone_trips(T, test_cases): Determines the minimum number of drone trips required for each test case. Parameters: T : int The number of test cases. test_cases : list of tuples Each tuple contains two integers, N and C, where N is the total number of packages and C is the drone capacity. Returns: result : list of int A list containing the minimum number of trips for each test case. result = [] for i in range(T): N, C = test_cases[i] result.append(math.ceil(N / C)) return result"},{"question":"def custom_fibonacci(n, a, b): Returns the n-th term of a Fibonacci-like sequence where the first term is \`a\` and the second term is \`b\`. >>> custom_fibonacci(1, 4, 7) 4 >>> custom_fibonacci(2, 4, 7) 7 >>> custom_fibonacci(3, 4, 7) 11 >>> custom_fibonacci(5, 4, 7) 29","solution":"def custom_fibonacci(n, a, b): Returns the n-th term of a Fibonacci-like sequence where the first term is \`a\` and the second term is \`b\`. if n == 1: return a elif n == 2: return b first, second = a, b for _ in range(3, n + 1): next_term = first + second first, second = second, next_term return second"},{"question":"def find_path_with_exact_weight(N: int, M: int, K: int, edges: List[Tuple[int, int, int]], S: int, T: int) -> str: Given an undirected graph consisting of N nodes and M edges, each edge M_i having an integer weight W_i, determine if a path exists from node S to node T such that the total weight of the path is exactly equal to K. If such a path exists, return \\"YES\\". Otherwise, return \\"NO\\". >>> find_path_with_exact_weight(4, 4, 7, [(1, 2, 3), (1, 3, 4), (2, 4, 4), (3, 4, 3)], 1, 4) \\"YES\\" >>> find_path_with_exact_weight(4, 4, 10, [(1, 2, 3), (1, 3, 4), (2, 4, 4), (3, 4, 3)], 1, 4) \\"NO\\" # Unit tests def test_find_path_with_exact_weight(): # Sample Test Case N, M, K = 4, 4, 7 edges = [ (1, 2, 3), (1, 3, 4), (2, 4, 4), (3, 4, 3) ] S, T = 1, 4 assert find_path_with_exact_weight(N, M, K, edges, S, T) == \\"YES\\" # Test Case where path does not exist N, M, K = 4, 4, 10 edges = [ (1, 2, 3), (1, 3, 4), (2, 4, 4), (3, 4, 3) ] S, T = 1, 4 assert find_path_with_exact_weight(N, M, K, edges, S, T) == \\"NO\\" # Test Case with cycle in the graph N, M, K = 5, 6, 8 edges = [ (1, 2, 1), (1, 3, 2), (2, 4, 3), (3, 4, 1), (3, 5, 6), (4, 5, 2) ] S, T = 1, 5 assert find_path_with_exact_weight(N, M, K, edges, S, T) == \\"YES\\" # Test Case with no available path N, M, K = 5, 3, 5 edges = [ (1, 2, 1), (2, 3, 1), (3, 4, 1) ] S, T = 1, 5 assert find_path_with_exact_weight(N, M, K, edges, S, T) == \\"NO\\" # Valid Path exists with exact weight N, M, K = 5, 5, 16 edges = [ (1, 2, 4), (2, 3, 4), (3, 4, 4), (4, 5, 4), (1, 5, 20) ] S, T = 1, 5 assert find_path_with_exact_weight(N, M, K, edges, S, T) == \\"YES\\"","solution":"def find_path_with_exact_weight(N, M, K, edges, S, T): from collections import defaultdict, deque graph = defaultdict(list) for U, V, W in edges: graph[U].append((V, W)) graph[V].append((U, W)) # Since the graph is undirected def bfs(start, target, target_weight): queue = deque([(start, 0)]) # (current node, current weight) visited = set() while queue: node, current_weight = queue.popleft() if (node, current_weight) in visited: continue visited.add((node, current_weight)) if node == target and current_weight == target_weight: return \\"YES\\" for neighbor, weight in graph[node]: if (neighbor, current_weight + weight) not in visited: if current_weight + weight <= target_weight: queue.append((neighbor, current_weight + weight)) return \\"NO\\" return bfs(S, T, K)"},{"question":"def generate_sales_report(input_data: str) -> str: Generate a report showing the top N best-selling books for a given genre. >>> input_data = '''2 ... 1 ... Fantasy ... 3 ... 1,The Hobbit,J.R.R. Tolkien,100 ... 2,Harry Potter,J.K. Rowling,50 ... 3,The Witcher,Andrzej Sapkowski,20 ... 5 ... 1,10 ... 2,20 ... 3,10 ... 2,3 ... 1,5 ... 1 ... Science Fiction ... 3 ... 4,Dune,Frank Herbert,60 ... 5,Neuromancer,William Gibson,40 ... 6,Foundation,Isaac Asimov,30 ... 4 ... 5,15 ... 4,40 ... 6,12 ... 5,10''' >>> generate_sales_report(input_data).strip() Fantasy Harry Potter, 23 The Hobbit, 15 The Witcher, 10 Science Fiction Dune, 40 Neuromancer, 25 Foundation, 12 def test_generate_sales_report(): input_data = '''2 1 Fantasy 3 1,The Hobbit,J.R.R. Tolkien,100 2,Harry Potter,J.K. Rowling,50 3,The Witcher,Andrzej Sapkowski,20 5 1,10 2,20 3,10 2,3 1,5 1 Science Fiction 3 4,Dune,Frank Herbert,60 5,Neuromancer,William Gibson,40 6,Foundation,Isaac Asimov,30 4 5,15 4,40 6,12 5,10''' expected_output = '''Fantasy Harry Potter, 23 The Hobbit, 15 The Witcher, 10 Science Fiction Dune, 40 Neuromancer, 25 Foundation, 12''' assert generate_sales_report(input_data).strip() == expected_output def test_no_sales(): input_data = '''1 1 Fantasy 3 1,The Hobbit,J.R.R. Tolkien,100 2,Harry Potter,J.K. Rowling,50 3,The Witcher,Andrzej Sapkowski,20 0''' expected_output = '''Fantasy''' assert generate_sales_report(input_data).strip() == expected_output def test_tied_sales(): input_data = '''1 1 Fantasy 3 1,The Hobbit,J.R.R. Tolkien,100 2,Harry Potter,J.K. Rowling,50 3,The Witcher,Andrzej Sapkowski,20 3 1,10 2,10 3,10''' expected_output = '''Fantasy Harry Potter, 10 The Hobbit, 10 The Witcher, 10''' assert generate_sales_report(input_data).strip() == expected_output def test_empty_genre(): input_data = '''1 1 Fantasy 0 0''' expected_output = '''Fantasy''' assert generate_sales_report(input_data).strip() == expected_output def test_multiple_genres(): input_data = '''1 2 Fantasy 3 1,The Hobbit,J.R.R. Tolkien,100 2,Harry Potter,J.K. Rowling,50 3,The Witcher,Andrzej Sapkowski,20 2 1,5 2,10 Science Fiction 2 4,Dune,Frank Herbert,50 5,Neuromancer,William Gibson,30 1 5,20''' expected_output = '''Fantasy Harry Potter, 10 The Hobbit, 5 Science Fiction Neuromancer, 20''' assert generate_sales_report(input_data).strip() == expected_output","solution":"def generate_sales_report(input_data): input_lines = input_data.split('n') current_line = 0 T = int(input_lines[current_line]) current_line += 1 result = [] for _ in range(T): G = int(input_lines[current_line]) current_line += 1 genre_sales = {} for _ in range(G): genre_name = input_lines[current_line].strip() current_line += 1 B = int(input_lines[current_line]) current_line += 1 inventory = {} # Reading inventory for _ in range(B): book_data = input_lines[current_line].split(',') book_id = book_data[0].strip() title = book_data[1].strip() author = book_data[2].strip() copies_available = int(book_data[3].strip()) inventory[book_id] = { 'title': title, 'author': author, 'copies_available': copies_available, 'copies_sold': 0 } current_line += 1 S = int(input_lines[current_line]) current_line += 1 # Update sales for _ in range(S): transaction_data = input_lines[current_line].split(',') book_id = transaction_data[0].strip() copies_sold = int(transaction_data[1].strip()) if book_id in inventory: inventory[book_id]['copies_sold'] += copies_sold current_line += 1 genre_sales[genre_name] = list(inventory.values()) for genre_name, books in genre_sales.items(): sorted_books = sorted(books, key=lambda x: (-x['copies_sold'], x['title'])) result.append(genre_name) for book in sorted_books: if book['copies_sold'] > 0: result.append(f\\"{book['title']}, {book['copies_sold']}\\") return 'n'.join(result)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by any number of swaps. >>> lexicographically_smallest_string(\\"dcba\\") \\"abcd\\" >>> lexicographically_smallest_string(\\"hello\\") \\"ehllo\\" >>> lexicographically_smallest_string(\\"leetcode\\") \\"cdeeelot\\" pass def smallest_strings_from_cases(t: int, test_cases: List[str]) -> List[str]: Given T and a list of test cases, return a list of lexicographically smallest strings. >>> smallest_strings_from_cases(3, [\\"dcba\\", \\"hello\\", \\"leetcode\\"]) [\\"abcd\\", \\"ehllo\\", \\"cdeeelot\\"] >>> smallest_strings_from_cases(2, [\\"a\\", \\"zyx\\"]) [\\"a\\", \\"xyz\\"] pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:] result = smallest_strings_from_cases(T, test_cases) for res in result: print(res)","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by any number of swaps return ''.join(sorted(s)) def smallest_strings_from_cases(t, test_cases): Given T and a list of test cases, return a list of lexicographically smallest strings result = [] for s in test_cases: result.append(lexicographically_smallest_string(s)) return result"},{"question":"def longest_streak(n, sales_data): Analyze the sales data and finds the longest streak for each product where sales consistently increase or decrease day by day. Args: n (int): The number of products. sales_data (list of tuples): Each tuple contains an integer m (number of days) and a list of m integers representing the sales numbers on each day. Returns: list: A list containing the length of the longest streak for each product. >>> longest_streak(2, [(6, [3, 5, 2, 8, 11, 6]), (4, [1, 2, 4, 3])]) [3, 3] >>> longest_streak(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> longest_streak(1, [(5, [5, 4, 3, 2, 1])]) [5] >>> longest_streak(1, [(5, [1, 3, 2, 4, 3])]) [2] >>> longest_streak(1, [(4, [5, 5, 5, 5])]) [1] >>> longest_streak(1, [(1, [7])]) [1]","solution":"def longest_streak(n, sales_data): results = [] for i in range(n): m = sales_data[i][0] sales = sales_data[i][1] max_length = 1 current_increase_length = 1 current_decrease_length = 1 for j in range(1, m): if sales[j] > sales[j - 1]: current_increase_length += 1 current_decrease_length = 1 elif sales[j] < sales[j - 1]: current_decrease_length += 1 current_increase_length = 1 else: current_increase_length = 1 current_decrease_length = 1 max_length = max(max_length, current_increase_length, current_decrease_length) results.append(max_length) return results # Sample input from question description for testing purpose n = 2 sales_data = [ (6, [3, 5, 2, 8, 11, 6]), (4, [1, 2, 4, 3]) ] print(longest_streak(n, sales_data)) # Output should be [3, 3]"},{"question":"from typing import List, Tuple def kruskal_min_cost_to_connect_departments(N: int, edges: List[Tuple[int, int, int]]) -> int: Determines the minimum cost to connect all departments using Kruskal's algorithm. Parameters: N (int): The number of departments. edges (List[Tuple[int, int, int]]): List of possible cable connections formatted as (u, v, w). Returns: int: The minimum cost to connect all departments or -1 if not possible. >>> kruskal_min_cost_to_connect_departments(4, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)]) 6 >>> kruskal_min_cost_to_connect_departments(3, [(1, 2, 3), (2, 3, 1), (1, 3, 1)]) 2 >>> kruskal_min_cost_to_connect_departments(4, [(1, 2, 1), (3, 4, 1)]) -1 >>> kruskal_min_cost_to_connect_departments(2, [(1, 2, 3)]) 3 >>> kruskal_min_cost_to_connect_departments(1, []) 0 pass def minimum_cost_to_connect_all_departments(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: For each test case, computes the minimum cost to connect all departments or returns -1 if not possible. Parameters: T (int): Number of test cases. test_cases (List[List[Tuple[int, int]]]): List of test cases. Each test case is formatted as [(N, M), (u_1, v_1, w_1), ...]. Returns: List[int]: List of minimum costs for each test case or -1 if not possible. >>> T = 2 >>> test_cases = [[(4, 5), (1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)], [(3, 3), (1, 2, 3), (2, 3, 1) , (1, 3, 1)]] >>> minimum_cost_to_connect_all_departments(T, test_cases) [6, 2] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_min_cost_to_connect_departments(N, edges): # Sort edges based on weight edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(N): parent.append(node) rank.append(0) mst_cost = 0 mst_edges = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_cost += w mst_edges += 1 if mst_edges == N-1: break return mst_cost if mst_edges == N-1 else -1 def minimum_cost_to_connect_all_departments(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] edges = test_cases[i][1:] result = kruskal_min_cost_to_connect_departments(N, edges) results.append(result) return results"},{"question":"def can_prepare_baskets(n, m, k): Determine if it's possible to prepare n food baskets, each containing at least one loaf of bread and one bottle of water. Parameters: n (int): Number of families. m (int): Number of loaves of bread. k (int): Number of bottles of water. Returns: str: \\"Possible\\" if it is feasible to prepare the required number of food baskets, otherwise \\"Impossible\\". >>> can_prepare_baskets(4, 10, 8) \\"Possible\\" >>> can_prepare_baskets(6, 14, 6) \\"Impossible\\" >>> can_prepare_baskets(7, 7, 10) \\"Possible\\" from solution import can_prepare_baskets def test_can_prepare_baskets_enough_supply(): assert can_prepare_baskets(4, 10, 8) == \\"Possible\\" assert can_prepare_baskets(7, 7, 10) == \\"Possible\\" assert can_prepare_baskets(1, 1, 1) == \\"Possible\\" def test_can_prepare_baskets_insufficient_bread(): assert can_prepare_baskets(6, 5, 10) == \\"Impossible\\" def test_can_prepare_baskets_insufficient_water(): assert can_prepare_baskets(6, 14, 5) == \\"Impossible\\" def test_can_prepare_baskets_just_enough_supply(): assert can_prepare_baskets(5, 5, 5) == \\"Possible\\" def test_can_prepare_baskets_not_enough_both(): assert can_prepare_baskets(10, 8, 7) == \\"Impossible\\"","solution":"def can_prepare_baskets(n, m, k): Determine if it's possible to prepare n food baskets, each containing at least one loaf of bread and one bottle of water. Parameters: n (int): Number of families. m (int): Number of loaves of bread. k (int): Number of bottles of water. Returns: str: \\"Possible\\" if it is feasible to prepare the required number of food baskets, otherwise \\"Impossible\\". if m >= n and k >= n: return \\"Possible\\" else: return \\"Impossible\\""},{"question":"def min_operations_to_make_equal(n: int, sequence: List[int]) -> int: Returns the minimum number of operations needed to make all elements of the sequence equal. In one operation, you can select any subsequence of the sequence and increase each element by one. Args: n: The number of elements in the sequence sequence: A list of integers representing the sequence Returns: An integer representing the minimum number of operations to make all elements equal >>> min_operations_to_make_equal(4, [2, 4, 4, 6]) 4 >>> min_operations_to_make_equal(3, [5, 5, 5]) 0 >>> min_operations_to_make_equal(1, [10]) 0 >>> min_operations_to_make_equal(2, [1, 1000000]) 999999 >>> min_operations_to_make_equal(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 9 >>> min_operations_to_make_equal(5, [100, 100, 100, 100, 100]) 0","solution":"def min_operations_to_make_equal(n, sequence): Returns the minimum number of operations needed to make all elements of the sequence equal. In one operation, you can select any subsequence of the sequence and increase each element by one. max_element = max(sequence) min_element = min(sequence) return max_element - min_element"},{"question":"def farthest_point(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the farthest point the hero can reach without stopping for each test case. >>> farthest_point(3, [((5, 3), [1, 2, 3, 4, 5]), ((6, 1), [1, 1, 1, 1, 2, 2]), ((4, 4), [1, 3, 4, 2])]) [3, 4, 4] >>> farthest_point(2, [((5, 5), [1, 2, 3, 4, 5]), ((3, 3), [1, 2, 3])]) [5, 3] >>> farthest_point(2, [((3, 1), [2, 3, 4]), ((4, 2), [3, 4, 5, 6])]) [0, 0] >>> farthest_point(2, [((5, 2), [1, 2, 3, 2, 1]), ((4, 4), [4, 2, 5, 3])]) [2, 2] >>> farthest_point(2, [((1, 2), [3]), ((1, 3), [3])]) [0, 1] pass","solution":"def farthest_point(t, test_cases): result = [] for i in range(t): n, k = test_cases[i][0] heights = test_cases[i][1] reached = 0 while reached < n and heights[reached] <= k: reached += 1 result.append(reached) return result"},{"question":"def compress_string(s: str) -> str: Compresses a string using the rule described in the problem statement. >>> compress_string(\\"aabcccaaa\\") 'a2bc3a3' >>> compress_string(\\"abc\\") 'abc' >>> compress_string(\\"aaabbbaa\\") 'a3b3a2' >>> compress_string(\\"\\") '' >>> compress_string(\\"xxyyzzzz\\") 'x2y2z4' >>> compress_string(\\"p\\") 'p'","solution":"def compress_string(s): Compresses a string using the rule described in the problem statement. Parameters: s (str): The input string Returns: str: The compressed string if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: compressed.append(f\\"{s[i-1]}{count}\\") else: compressed.append(s[i-1]) count = 1 if count > 1: compressed.append(f\\"{s[-1]}{count}\\") else: compressed.append(s[-1]) return \\"\\".join(compressed)"},{"question":"def minimize_absolute_differences(test_cases): Given multiple test cases of arrays, sort each array such that the sum of the absolute differences between consecutive elements is minimized and return the lexicographically smallest sorted array. results = [] for case in test_cases: array = case[1:] sorted_array = sorted(array) results.append(sorted_array) return results def format_output(results): Given the results of sorted arrays, format them into strings for output. return [' '.join(map(str, result)) for result in results] def solve_problem(input_data): Process the input data, sort the arrays as required, and format the output. >>> solve_problem(\\"2n3 1 5 3n4 8 3 6 1\\") '1 3 5n1 3 6 8' lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [list(map(int, line.split())) for line in lines[1:T+1]] sorted_arrays = minimize_absolute_differences(test_cases) return \\"n\\".join(format_output(sorted_arrays)) def test_minimize_absolute_differences(): assert minimize_absolute_differences([[3, 1, 5, 3]]) == [[1, 3, 5]] assert minimize_absolute_differences([[4, 8, 3, 6, 1]]) == [[1, 3, 6, 8]] def test_format_output(): assert format_output([[1, 3, 5]]) == [\\"1 3 5\\"] assert format_output([[1, 3, 6, 8]]) == [\\"1 3 6 8\\"] def test_solve_problem(): input_data = \\"2n3 1 5 3n4 8 3 6 1\\" expected_output = \\"1 3 5n1 3 6 8\\" assert solve_problem(input_data) == expected_output def test_solve_problem_edge_case(): input_data = \\"1n1 10\\" expected_output = \\"10\\" assert solve_problem(input_data) == expected_output def test_large_input(): input_data = \\"1n10 10 9 8 7 6 5 4 3 2 1\\" expected_output = \\"1 2 3 4 5 6 7 8 9 10\\" assert solve_problem(input_data) == expected_output","solution":"def minimize_absolute_differences(test_cases): results = [] for case in test_cases: array = case[1:] sorted_array = sorted(array) results.append(sorted_array) return results def format_output(results): return [' '.join(map(str, result)) for result in results] def solve_problem(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [list(map(int, line.split())) for line in lines[1:T+1]] sorted_arrays = minimize_absolute_differences(test_cases) return \\"n\\".join(format_output(sorted_arrays))"},{"question":"def rotate_array(nums, k): Rotate the array nums to the right by k steps in-place with O(1) extra space. >>> nums = [1, 2, 3, 4, 5, 6] >>> rotate_array(nums, 2) >>> print(nums) [5, 6, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5, 6] >>> rotate_array(nums, 0) >>> print(nums) [1, 2, 3, 4, 5, 6] >>> nums = [1, 2, 3, 4, 5, 6] >>> rotate_array(nums, 6) >>> print(nums) [1, 2, 3, 4, 5, 6] >>> nums = [1, 2, 3, 4, 5, 6] >>> rotate_array(nums, 8) # Equivalent to rotating by 2 >>> print(nums) [5, 6, 1, 2, 3, 4] >>> nums = [1] >>> rotate_array(nums, 3) >>> print(nums) [1] >>> nums = [1, 2] >>> rotate_array(nums, 1) >>> print(nums) [2, 1] >>> nums = [-1, -2, -3, -4, -5, -6] >>> rotate_array(nums, 3) >>> print(nums) [-4, -5, -6, -1, -2, -3]","solution":"def rotate_array(nums, k): Rotates the array nums to the right by k steps. :param nums: List[int], the array to be rotated :param k: int, the number of steps to rotate :return: None, rotates in-place n = len(nums) k = k % n # Normalize k to ensure it's within the bounds of the array length # Define a helper function to reverse a portion of the array def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Reverse the entire array reverse(0, n - 1) # Reverse the first part reverse(0, k - 1) # Reverse the second part reverse(k, n - 1) # Example usage: nums_example = [1, 2, 3, 4, 5, 6] rotate_array(nums_example, 2) print(nums_example)"},{"question":"def evaluate_expressions(expressions): Given a list of arithmetic expressions, evaluate each expression according to the basic arithmetic rules. Ensure the division operator '/' performs integer division (like floor division). Parameters: expressions -- List of string expressions consisting of single-digit integers and operators '+', '-', '*', '/'. Returns: List of integer results for each expression. Example: >>> evaluate_expressions(['1+2*3']) [7] >>> evaluate_expressions(['1+2*3', '4/2+6*2', '7-4/2']) [7, 14, 5] >>> evaluate_expressions(['8/3']) [2]","solution":"def evaluate_expressions(expressions): Evaluates a list of arithmetic expressions. Parameters: expressions (list of str): List of string expressions to be evaluated. Returns: list of int: List of results for each expression. results = [] for expr in expressions: result = eval(expr.replace('/', '//')) results.append(result) return results"},{"question":"def max_steepness(n, altitudes): Determines the maximum steepness of the trail given the sequence of altitudes. Parameters: n (int): the number of altitude points altitudes (list): list of integers representing the altitudes at each point Returns: int: the maximum steepness of the trail >>> max_steepness(5, [1, 3, 6, 2, 8]) 6 >>> max_steepness(4, [5, 5, 5, 5]) 0","solution":"def max_steepness(n, altitudes): Determines the maximum steepness of the trail given the sequence of altitudes. Parameters: n (int): the number of altitude points altitudes (list): list of integers representing the altitudes at each point Returns: int: the maximum steepness of the trail max_diff = 0 for i in range(1, n): max_diff = max(max_diff, abs(altitudes[i] - altitudes[i - 1])) return max_diff"},{"question":"def reverse_words(sentence: str) -> str: Takes a string of words and returns a new string where each word is reversed but the order of words remains the same. >>> reverse_words(\\"Pirates are cunning and ferocious\\") 'setariP era gninnuc dna suoicoref' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"Hello, world!\\") ',olleH !dlrow' >>> reverse_words(\\" Leading and trailing spaces \\") 'gnidaeL dna gniliart secaps' # Assuming to ignore leading/trailing spaces >>> reverse_words(\\"Mixed CASE words\\") 'dexiM ESAC sdrow'","solution":"def reverse_words(sentence): Takes a string of words and returns a new string where each word is reversed but the order of words remains the same. reversed_sentence = ' '.join(word[::-1] for word in sentence.split()) return reversed_sentence"},{"question":"def first_missing_positive(arr, N): Returns the first missing positive integer in the array. >>> first_missing_positive([3, 4, -1, 1, 2], 5) 5 >>> first_missing_positive([1, 2, 0, -1, -2, 6], 6) 3 >>> first_missing_positive([-3, -2, -1], 3) 1 >>> first_missing_positive([1, 2, 3, 4, 5], 5) 6 >>> first_missing_positive([0, 1, 2, 3, 5, 7, 8, -1, -3], 9) 4 >>> first_missing_positive([1], 1) 2 >>> first_missing_positive([-1], 1) 1 >>> first_missing_positive([1000000, 999999, 1], 3) 2 >>> first_missing_positive([3, 7, 4, 1, 5, 6, 2], 7) 8","solution":"def first_missing_positive(arr, N): Returns the first missing positive integer in the array. for i in range(N): while 1 <= arr[i] <= N and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(N): if arr[i] != i + 1: return i + 1 return N + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if a binary tree is height-balanced. A height-balanced binary tree is one in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / 9 20 / 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / 2 2 / 3 3 / 4 4 Return false. >>> is_balanced(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) True >>> is_balanced(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)), TreeNode(2))) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"from typing import List def unique_user_ids(events: List[int]) -> List[int]: Returns a list of unique user IDs in the order of their first appearance, excluding -1 events. >>> unique_user_ids([3, 5, 3, -1, 2, 5, -1, 3, 7]) [3, 5, 2, 7] >>> unique_user_ids([1, -1, 2, 2, 4, 3, -1, 4]) [1, 2, 4, 3] pass","solution":"from typing import List def unique_user_ids(events: List[int]) -> List[int]: Returns a list of unique user IDs in the order of their first appearance, excluding -1 events. user_set = set() unique_users = [] for event in events: if event == -1: continue if event not in user_set: user_set.add(event) unique_users.append(event) return unique_users"},{"question":"def max_subgrid_sum(n: int, k: int, grid: List[List[int]]) -> int: Returns the maximum popularity score that can be achieved by visiting a k x k subgrid. Parameters: n (int): Size of the grid (n x n) k (int): Size of the subgrid (k x k) grid (list): 2D list representing the n x n grid with popularity scores Returns: int: Maximum popularity score of a k x k subgrid >>> max_subgrid_sum(4, 2, [ ... [1, 3, 5, 2], ... [7, 1, 8, 6], ... [3, 4, 2, 0], ... [8, 7, 6, 5], ... ]) == 22 >>> max_subgrid_sum(2, 1, [ ... [1, 2], ... [3, 4], ... ]) == 4 >>> max_subgrid_sum(2, 2, [ ... [1, 2], ... [3, 4], ... ]) == 10 >>> max_subgrid_sum(1, 1, [ ... [7], ... ]) == 7 >>> max_subgrid_sum(3, 2, [ ... [1000000, 999999, 5], ... [999998, 1000000, 4], ... [5, 4, 999997], ... ]) == 3999997 pass","solution":"def max_subgrid_sum(n, k, grid): Returns the maximum popularity score that can be achieved by visiting a k x k subgrid. Parameters: n (int): Size of the grid (n x n) k (int): Size of the subgrid (k x k) grid (list): 2D list representing the n x n grid with popularity scores Returns: int: Maximum popularity score of a k x k subgrid # Initialize the maximum sum to a very small number max_sum = -float('inf') for i in range(n - k + 1): for j in range(n - k + 1): # Calculate sum of k x k subgrid starting at (i, j) current_sum = 0 for p in range(k): for q in range(k): current_sum += grid[i + p][j + q] # Update max_sum if we found a new max if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in arr. If there is a tie in frequency, the elements are sorted in ascending order. >>> k_most_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> k_most_frequent_elements([4, 4, 4, 2, 2, 3, 3, 3], 2) [3, 4] >>> k_most_frequent_elements([1], 1) [1]","solution":"from collections import Counter def k_most_frequent_elements(arr, k): Returns the k most frequent elements in arr. If there is a tie in frequency, the elements are sorted in ascending order. if not arr: return [] # Count the frequency of each element frequency_map = Counter(arr) # Create a sorted list of elements based on their frequencies (highest first) # and their values (ascending order in case of tie) sorted_elements = sorted(frequency_map.keys(), key=lambda x: (-frequency_map[x], x)) # Return the top k elements return sorted_elements[:k]"},{"question":"from typing import List def permute(S: str) -> List[str]: Given a string S, generate all possible permutations of the characters of the string in lexicographically sorted order. >>> permute(\\"ABC\\") [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] >>> permute(\\"XY\\") [\\"XY\\", \\"YX\\"]","solution":"from itertools import permutations def permute(S): Returns all permutations of the string S in lexicographically sorted order. perms = sorted([''.join(p) for p in permutations(S)]) return perms"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Reorder the string 's' based on the given 'indices' array. Parameters: s (str): The input string. indices (List[int]): The list of indices indicating where each character in the input string should be placed. Returns: str: The reordered string. Example: >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) 'leetcode' >>> restore_string(\\"abc\\", [0,1,2]) 'abc' >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) 'nihao'","solution":"def restore_string(s, indices): Reorder the string 's' based on the given 'indices' array. Parameters: s (str): The input string. indices (List[int]): The list of indices indicating where each character in the input string should be placed. Returns: str: The reordered string. n = len(s) result = [''] * n for i, index in enumerate(indices): result[index] = s[i] return ''.join(result)"},{"question":"def has_all_unique_characters(s: str) -> str: Determine if a string has all unique characters. Args: s (str): Input string Returns: str: \\"Yes\\" if all characters in the string are unique, \\"No\\" otherwise Examples: >>> has_all_unique_characters(\\"abcdefg\\") \\"Yes\\" >>> has_all_unique_characters(\\"abac\\") \\"No\\" from solution import has_all_unique_characters def test_all_unique_characters(): assert has_all_unique_characters(\\"abcdefg\\") == \\"Yes\\" def test_duplicate_characters(): assert has_all_unique_characters(\\"abac\\") == \\"No\\" def test_single_character(): assert has_all_unique_characters(\\"a\\") == \\"Yes\\" def test_all_same_characters(): assert has_all_unique_characters(\\"aaaaa\\") == \\"No\\" def test_mixed_characters(): assert has_all_unique_characters(\\"a1b2c3\\") == \\"Yes\\" def test_non_alphabet_characters(): assert has_all_unique_characters(\\"abc!@#\\") == \\"Yes\\" def test_mixed_duplicate_characters(): assert has_all_unique_characters(\\"a1b2c3a\\") == \\"No\\" def test_long_string_unique_characters(): assert has_all_unique_characters(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\\") == \\"Yes\\" def test_long_string_with_duplicates(): assert has_all_unique_characters(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890a\\") == \\"No\\"","solution":"def has_all_unique_characters(s): Returns 'Yes' if the string s has all unique characters, otherwise 'No'. if len(set(s)) == len(s): return \\"Yes\\" else: return \\"No\\" # Alternative, more optimized solution # def has_all_unique_characters(s): # # Returns 'Yes' if the string s has all unique characters, otherwise 'No'. # # char_set = set() # for char in s: # if char in char_set: # return 'No' # char_set.add(char) # return 'Yes'"},{"question":"def calculate_balanced_substrings(s: str) -> int: Returns the maximum number of balanced substrings in the given string. A balanced substring is one with an equal number of 'L' and 'R' characters. >>> calculate_balanced_substrings(\\"RLRRLLRLRL\\") 4 >>> calculate_balanced_substrings(\\"RL\\") 1 >>> calculate_balanced_substrings(\\"RLRLRLRLRL\\") 5 >>> calculate_balanced_substrings(\\"LLLLL\\") 0 >>> calculate_balanced_substrings(\\"RRRRR\\") 0 >>> calculate_balanced_substrings(\\"\\") 0","solution":"def calculate_balanced_substrings(s: str) -> int: Returns the maximum number of balanced substrings in the given string. A balanced substring is one with an equal number of 'L' and 'R' characters. balanced_count = 0 balance = 0 for char in s: if char == 'L': balance += 1 elif char == 'R': balance -= 1 if balance == 0: balanced_count += 1 return balanced_count"},{"question":"from typing import List def process_transactions(t: int, transactions: List[str]) -> List[str]: Processes a list of bank transaction logs and computes the final balance for each user. >>> process_transactions( ... 6, ... [\\"09:00 userA 1000 deposit\\", \\"09:30 userB 1500 deposit\\", \\"10:00 userA 200 withdraw\\", ... \\"10:15 userB 500 deposit\\", \\"11:00 userC 700 deposit\\", \\"11:30 userC 300 withdraw\\"] ... ) ['userA 800', 'userB 2000', 'userC 400'] >>> process_transactions( ... 5, ... [\\"08:00 user1 300 deposit\\", \\"08:15 user2 150 deposit\\", \\"08:30 user3 200 deposit\\", ... \\"09:00 user2 50 withdraw\\", \\"09:15 user1 100 deposit\\"] ... ) ['user1 400', 'user2 100', 'user3 200']","solution":"def process_transactions(t, transactions): user_balances = {} for transaction in transactions: time, user, amount, trans_type = transaction.split() amount = int(amount) if user not in user_balances: user_balances[user] = 0 if trans_type == 'deposit': user_balances[user] += amount elif trans_type == 'withdraw': user_balances[user] -= amount sorted_users = sorted(user_balances.keys()) result = [] for user in sorted_users: result.append(f\\"{user} {user_balances[user]}\\") return result"},{"question":"def findPatternIndices(S: str, P: str) -> List[int]: Returns the starting indices of all occurrences of the pattern P in the string S. >>> findPatternIndices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> findPatternIndices(\\"aaaa\\", \\"aa\\") [0, 1, 2] >>> findPatternIndices(\\"ABRaCADaBRA\\", \\"abra\\") [] >>> findPatternIndices(\\"xyzwxyz\\", \\"abc\\") [] >>> findPatternIndices(\\"aaaaa\\", \\"a\\") [0, 1, 2, 3, 4] >>> findPatternIndices(\\"abcdefg\\", \\"hij\\") [] >>> findPatternIndices(\\"abcdefgh\\", \\"abcdefgh\\") [0]","solution":"def findPatternIndices(S, P): Returns the starting indices of all occurrences of the pattern P in the string S. result = [] len_s = len(S) len_p = len(P) # Edge case where the pattern is longer than the string if len_p > len_s: return result # Precompute the longest prefix suffix array for the KMP algorithm lps = [0] * len_p j = 0 # length of previous longest prefix suffix i = 1 while i < len_p: if P[i] == P[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j-1] else: lps[i] = 0 i += 1 i = 0 # index for S j = 0 # index for P while i < len_s: if P[j] == S[i]: i += 1 j += 1 if j == len_p: result.append(i - j) j = lps[j-1] elif i < len_s and P[j] != S[i]: if j != 0: j = lps[j-1] else: i += 1 return result"},{"question":"def find_peaks(test_cases): Returns a list of peaks for each test case. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples containing N (number of elements) and the list of elements. Returns: List[str]: A list containing the peaks for each test case. >>> find_peaks([(5, [1, 3, 2, 5, 4]), (3, [10, 20, 15])]) == [\\"3 5\\", \\"20\\"] >>> find_peaks([(1, [5])]) == [\\"5\\"] >>> find_peaks([(3, [1, 2, 3])]) == [\\"3\\"] >>> find_peaks([(2, [3, 3])]) == [\\"3 3\\"]","solution":"def find_peaks(test_cases): Returns a list of peaks for each test case. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples containing N (number of elements) and the list of elements. Returns: List[str]: A list containing the peaks for each test case. result = [] for N, array in test_cases: peaks = [] if N == 1: peaks.append(array[0]) else: if array[0] >= array[1]: peaks.append(array[0]) for i in range(1, N-1): if array[i] >= array[i-1] and array[i] >= array[i+1]: peaks.append(array[i]) if array[N-1] >= array[N-2]: peaks.append(array[N-1]) if peaks: result.append(\\" \\".join(map(str, peaks))) else: result.append(\\"NONE\\") return result # Example usage: def main(): T = int(input().strip()) test_cases = [] for _ in range(T): N = int(input().strip()) array = list(map(int, input().strip().split())) test_cases.append((N, array)) results = find_peaks(test_cases) for res in results: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def reverse_letters(s: str) -> str: Reverse only the letters in a string, keeping digits at their original positions. >>> reverse_letters(\\"ab12cd34ef\\") 'fe12dc34ba' >>> reverse_letters(\\"abcdef\\") 'fedcba' >>> reverse_letters(\\"123456\\") '123456' >>> reverse_letters(\\"aB12Cd34Ef\\") 'fE12dC34Ba' >>> reverse_letters(\\"a\\") 'a' >>> reverse_letters(\\"1\\") '1' >>> reverse_letters(\\"1a2b3c\\") '1c2b3a' >>> reverse_letters(\\"123abc\\") '123cba' >>> reverse_letters(\\"abc123\\") 'cba123' # Write your code here.","solution":"def reverse_letters(s: str) -> str: Reverse only the letters in a string, keeping digits at their original positions. # Extract letters from the string letters = [char for char in s if char.isalpha()] # Reverse the list of letters letters.reverse() # To form the new string with digits at original positions and reversed letters result = [] letter_index = 0 for char in s: if char.isalpha(): result.append(letters[letter_index]) letter_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def average_waiting_time(M, segments): Returns the average waiting time of cars on the road. :param M: integer, number of road segments :param segments: list of integers where each integer represents the number of cars at the i-th segment :return: float, average waiting time of cars on the road >>> average_waiting_time(4, [5, 10, 15, 20]) 12.500000 >>> average_waiting_time(3, [0, 0, 30]) 10.000000","solution":"def average_waiting_time(M, segments): Returns the average waiting time of cars on the road. :param M: integer, number of road segments :param segments: list of integers where each integer represents the number of cars at the i-th segment :return: float, average waiting time of cars on the road total_cars = sum(segments) average_time = total_cars / M return round(average_time, 6)"},{"question":"def custom_sort(words: str) -> str: Takes a string of words separated by spaces and sorts them according to the rule that uppercase letters come before lowercase letters if they are the same letter. >>> custom_sort(\\"apple Banana apple orange ORANGE\\") 'Banana ORANGE apple apple orange' >>> custom_sort(\\"apple banana cherry\\") 'apple banana cherry' >>> custom_sort(\\"Apple apple\\") 'Apple apple' >>> custom_sort(\\"Banana apple Apple ORANGE orange\\") 'Apple Banana ORANGE apple orange' >>> custom_sort(\\"\\") '' >>> custom_sort(\\"apple\\") 'apple' >>> custom_sort(\\"apple Apple\\") 'Apple apple' pass","solution":"def custom_sort(words: str) -> str: Takes a string of words separated by spaces and sorts them according to the rule that uppercase letters come before lowercase letters if they are the same letter. word_list = words.split() word_list.sort(key=lambda word: list(map(lambda c: (c.islower(), c), word))) return ' '.join(word_list)"},{"question":"def find_unique_subarrays(arr): Given an array of integers, returns a list of all unique subarrays of the array. Parameters: arr (List[int]): A list of integers representing the array. Returns: List[List[int]]: A list of unique subarrays. Examples: >>> find_unique_subarrays([1]) [[1]] >>> find_unique_subarrays([1, 2]) [[1], [1, 2], [2]] >>> find_unique_subarrays([1, 2, 1]) [[1], [2], [1, 2], [2, 1], [1, 2, 1]] >>> find_unique_subarrays([1, 1, 1]) [[1], [1, 1], [1, 1, 1]] >>> find_unique_subarrays([4, 6, 4]) [[4], [6], [4, 6], [6, 4], [4, 6, 4]]","solution":"def find_unique_subarrays(arr): Returns a list of all unique subarrays of the given array. unique_subarrays = set() # Use a set to store unique subarrays n = len(arr) for i in range(n): for j in range(i, n): subarray = tuple(arr[i:j+1]) unique_subarrays.add(subarray) # Convert the set of tuples back to a list of lists return [list(subarray) for subarray in unique_subarrays]"},{"question":"def length_of_lis(nums): Implement a function that finds the length of the longest increasing subsequence in a list of integers. Args: nums: List[int] - A list of integers Returns: int: The length of the longest increasing subsequence Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([3, 10, 2]) 2 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([2, 2, 2, 2, 2]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in a list of integers. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def minimize_balance(N: int, K: int, skills: List[int]) -> int: Returns the minimized balance of the contest. Args: N (int): The number of participants. K (int): The number of participants per room. skills (List[int]): The skill levels of the participants. Returns: int: The minimized balance of the contest. >>> minimize_balance(6, 3, [7, 2, 5, 10, 8, 6]) 4 >>> minimize_balance(5, 5, [10, 20, 30, 40, 50]) 40 >>> minimize_balance(4, 2, [1, 3, 5, 7]) 2 >>> minimize_balance(6, 3, [1, 2, 3, 4, 5, 6]) 2 >>> minimize_balance(6, 2, [100, 200, 300, 400, 500, 600]) 100 >>> minimize_balance(8, 2, [4, 1, 7, 8, 6, 5, 3, 2]) 1 from typing import List","solution":"def minimize_balance(N, K, skills): Returns the minimized balance of the contest. skills.sort() balance = 0 for i in range(0, N, K): current_balance = skills[i + K - 1] - skills[i] balance = max(balance, current_balance) return balance"},{"question":"def count_diagonal_intersections(m: int, n: int) -> int: Returns the number of distinct intersection points where the diagonals of the rectangles within an m x n grid intersect. >>> count_diagonal_intersections(2, 2) 1 >>> count_diagonal_intersections(3, 3) 4 >>> count_diagonal_intersections(1, 2) 0 >>> count_diagonal_intersections(4, 5) 12 >>> count_diagonal_intersections(1000, 1000) 999 * 999","solution":"def count_diagonal_intersections(m, n): Returns the number of distinct intersection points where the diagonals of the rectangles within an m x n grid intersect. # The number of distinct intersection points is (m-1) * (n-1) return (m - 1) * (n - 1)"},{"question":"def min_abs_difference(n, arr): Splits the array into two non-empty contiguous subarrays to minimize the absolute difference between their sums. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. Returns: int: The minimum absolute difference between the sums of the two subarrays. Example: >>> min_abs_difference(5, [1, 3, 3, 2, 4]) 1 >>> min_abs_difference(4, [10, 20, 30, 40]) 20 >>> min_abs_difference(3, [5, 5, 5]) 5","solution":"def min_abs_difference(n, arr): Splits the array into two non-empty contiguous subarrays to minimize the absolute difference between their sums. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. Returns: int: The minimum absolute difference between the sums of the two subarrays. total_sum = sum(arr) left_sum = 0 min_difference = float('inf') for i in range(n - 1): left_sum += arr[i] right_sum = total_sum - left_sum min_difference = min(min_difference, abs(left_sum - right_sum)) return min_difference"},{"question":"def sum_of_squares_of_digits(n): Helper function to calculate the sum of the squares of the digits of a number. pass def is_happy_number(n): Determine if the number 'n' is a Happy Number. pass def happy_number_test_cases(test_cases): Determine if the numbers in the test cases are Happy Numbers or not. :param test_cases: List of integers representing the test cases. :returns: List of strings \\"HAPPY\\" or \\"UNHAPPY\\" for each test case. pass # Unit Test def test_happy_number_test_cases(): assert happy_number_test_cases([19]) == [\\"HAPPY\\"] assert happy_number_test_cases([2]) == [\\"UNHAPPY\\"] assert happy_number_test_cases([7]) == [\\"HAPPY\\"] assert happy_number_test_cases([1]) == [\\"HAPPY\\"] assert happy_number_test_cases([10]) == [\\"HAPPY\\"] assert happy_number_test_cases([4, 20, 37]) == [\\"UNHAPPY\\", \\"UNHAPPY\\", \\"UNHAPPY\\"] assert happy_number_test_cases([49, 97, 130]) == [\\"HAPPY\\", \\"HAPPY\\", \\"HAPPY\\"] assert happy_number_test_cases([1000000]) == [\\"HAPPY\\"] assert happy_number_test_cases([1000001]) == [\\"UNHAPPY\\"] def test_edge_cases(): assert happy_number_test_cases([999999]) == [\\"UNHAPPY\\"] def test_various_numbers(): assert happy_number_test_cases([3, 5, 6, 8]) == [\\"UNHAPPY\\", \\"UNHAPPY\\", \\"UNHAPPY\\", \\"UNHAPPY\\"] assert happy_number_test_cases([100, 101, 1000, 10000]) == [\\"HAPPY\\", \\"UNHAPPY\\", \\"HAPPY\\", \\"HAPPY\\"]","solution":"def sum_of_squares_of_digits(n): Helper function to calculate the sum of the squares of the digits of a number. return sum(int(digit) ** 2 for digit in str(n)) def is_happy_number(n): Determine if the number 'n' is a Happy Number. seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares_of_digits(n) return n == 1 def happy_number_test_cases(test_cases): Determine if the numbers in the test cases are Happy Numbers or not. :param test_cases: List of integers representing the test cases. :returns: List of strings \\"HAPPY\\" or \\"UNHAPPY\\" for each test case. results = [] for n in test_cases: if is_happy_number(n): results.append(\\"HAPPY\\") else: results.append(\\"UNHAPPY\\") return results"},{"question":"def generate_special_number(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Generate the special number sequence based on the conditions. >>> generate_special_number(3, [(4, [1, 2, 3, 4]), (5, [5, 6, 7, 8, 9]), (3, [11, 22, 33])]) ['X2X4', 'X6X8X', 'X22X']","solution":"def generate_special_number(t, test_cases): results = [] for i in range(t): _, sequence = test_cases[i] # unpacking each test case special_number = \\"\\" for num in sequence: if num % 2 == 0: special_number += str(num) else: special_number += \\"X\\" results.append(special_number) return results # Example Usage: # t = 3 # test_cases = [(4, [1, 2, 3, 4]), (5, [5, 6, 7, 8, 9]), (3, [11, 22, 33])] # print(generate_special_number(t, test_cases))"},{"question":"def can_form_arithmetic_progression(n, sequence): Determine whether you can reorder the sequence to form an arithmetic progression. Args: n (int): length of the sequence sequence (List[int]): list of integers representing the sequence Returns: str: \\"YES\\" if you can reorder the sequence to form an arithmetic progression, \\"NO\\" otherwise >>> can_form_arithmetic_progression(4, [3, 5, 1, 7]) \\"YES\\" >>> can_form_arithmetic_progression(5, [2, 4, 6, 8, 1]) \\"NO\\" >>> can_form_arithmetic_progression(3, [3, 6, 9]) \\"YES\\" pass def process_test_cases(t, test_cases): Process multiple test cases to determine if each sequence can be rearranged into an arithmetic progression. Args: t (int): number of test cases test_cases (List[Tuple[int, List[int]]]): list of tuples, each containing the length of sequence and the sequence itself Returns: List[str]: list of \\"YES\\" or \\"NO\\" for each test case >>> process_test_cases(3, [(4, [3, 5, 1, 7]), (5, [2, 4, 6, 8, 1]), (3, [3, 6, 9])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [(2, [1, 1]), (2, [1, 2])]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(1, [(3, [1, 2, 4])]) [\\"NO\\"] pass","solution":"def can_form_arithmetic_progression(n, sequence): sequence.sort() common_difference = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i - 1] != common_difference: return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sequence = test_cases[i][1] results.append(can_form_arithmetic_progression(n, sequence)) return results"},{"question":"def process_queries(N: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of queries on an initial array. There are two types of queries: 1 K V: Update the K-th element of the array to V. 2 L R: Compute the sum of all integers from the L-th to the R-th element (inclusive). Args: N (int): The number of elements in the array. A (List[int]): The initial array of integers. queries (List[Tuple[int, int, int]]): List of queries represented as tuples. Returns: List[int]: Results of each sum query. >>> process_queries(5, [1, 2, 3, 4, 5], [(2, 2, 4), (1, 3, 10), (2, 1, 5)]) [9, 22] >>> process_queries(3, [1, 1, 1], [(1, 1, 2), (1, 3, 2), (2, 1, 3)]) [5] >>> process_queries(4, [1, 2, 3, 4], [(2, 1, 4), (1, 2, 10), (1, 3, 20), (2, 1, 3)]) [10, 31] >>> process_queries(1, [10], [(2, 1, 1), (1, 1, 5), (2, 1, 1)]) [10, 5] >>> process_queries(1, [100], []) []","solution":"class SegmentTree: def __init__(self, n): self.n = n self.tree = [0] * (2 * n) def build(self, arr): # Build the tree, initially copy the array elements into the tree leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the rest of the tree by combining child nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, idx, value): # Update the value at index idx idx += self.n self.tree[idx] = value # Update the rest of the tree accordingly while idx > 1: idx //= 2 self.tree[idx] = self.tree[2 * idx] + self.tree[2 * idx + 1] def range_sum(self, left, right): # Get the sum from range left to right (inclusive) left += self.n right += self.n + 1 total = 0 while left < right: if left % 2: total += self.tree[left] left += 1 if right % 2: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def process_queries(N, A, queries): seg_tree = SegmentTree(N) seg_tree.build(A) result = [] for query in queries: q_type, x, y = query if q_type == 1: seg_tree.update(x - 1, y) elif q_type == 2: result.append(seg_tree.range_sum(x - 1, y - 1)) return result"},{"question":"def countPaths(grid): Computes the number of distinct paths from the top-left to the bottom-right corner of the grid. :param grid: 2D list representing the park, where 0 is an open path and 1 is an obstacle. :return: Number of distinct paths avoiding obstacles. def test_countPaths_example1(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert countPaths(grid) == 2 def test_countPaths_example2(): grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] assert countPaths(grid) == 1 def test_countPaths_example3(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert countPaths(grid) == 0 def test_countPaths_singleCell(): grid = [ [0] ] assert countPaths(grid) == 1 def test_countPaths_startBlocked(): grid = [ [1, 0], [0, 0] ] assert countPaths(grid) == 0 def test_countPaths_endBlocked(): grid = [ [0, 0], [0, 1] ] assert countPaths(grid) == 0 def test_countPaths_allOpen(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert countPaths(grid) == 6 def test_countPaths_allBlocked(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert countPaths(grid) == 0","solution":"def countPaths(grid): Computes the number of distinct paths from the top-left to the bottom-right corner of the grid. :param grid: 2D list representing the park, where 0 is an open path and 1 is an obstacle. :return: Number of distinct paths avoiding obstacles. R, C = len(grid), len(grid[0]) # If start or end cell is an obstacle, return 0 if grid[0][0] == 1 or grid[R-1][C-1] == 1: return 0 # Initialize a 2D list for storing the number of paths to each cell dp = [[0] * C for _ in range(R)] # Start point has 1 way to be reached dp[0][0] = 1 # Fill the dp array for i in range(R): for j in range(C): if grid[i][j] == 1: # Obstacle found, cannot travel to this cell dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] # Path from top if j > 0: dp[i][j] += dp[i][j-1] # Path from left return dp[R-1][C-1]"},{"question":"def has_pair_with_nonzero_bitwise_and(n, A, B): Determines if there is a pair of integers (one from each array) such that their bitwise AND operation results in at least one '1' bit in its binary representation. :param n: int, number of elements in each array :param A: list of int, array A of n integers :param B: list of int, array B of n integers :return: str, 'YES' if there exists at least one pair (A[i], B[j]) such that (A[i] & B[j]) != 0, else 'NO' >>> has_pair_with_nonzero_bitwise_and(3, [1, 2, 3], [4, 5, 6]) 'YES' >>> has_pair_with_nonzero_bitwise_and(3, [8, 8, 8], [1, 1, 1]) 'NO'","solution":"def has_pair_with_nonzero_bitwise_and(n, A, B): Determines if there is a pair of integers (one from each array) such that their bitwise AND operation results in at least one '1' bit in its binary representation. :param n: int, number of elements in each array :param A: list of int, array A of n integers :param B: list of int, array B of n integers :return: str, 'YES' if there exists at least one pair (A[i], B[j]) such that (A[i] & B[j]) != 0, else 'NO' for i in A: for j in B: if i & j != 0: return \\"YES\\" return \\"NO\\""},{"question":"def generateSequence(n: int) -> str: Generates a sequence going from 1 to n and back to 1. For example, n=3 results in \\"1 2 3 2 1\\". >>> generateSequence(5) == \\"1 2 3 4 5 4 3 2 1\\" >>> generateSequence(3) == \\"1 2 3 2 1\\"","solution":"def generateSequence(n): Generates a sequence going from 1 to n and back to 1. For example, n=3 results in \\"1 2 3 2 1\\". sequence = list(range(1, n + 1)) + list(range(n - 1, 0, -1)) return \\" \\".join(map(str, sequence))"},{"question":"def max_sum_after_operations(n, k, arr): Determine the maximum possible sum of the array after k operations. Parameters: n (int): Number of elements in the array. k (int): Number of operations to perform. arr (list of ints): The array of integers. Returns: int: The maximum possible value of the sum of the array after k operations. >>> max_sum_after_operations(4, 2, [1, 2, 3, 4]) 16 >>> max_sum_after_operations(5, 0, [1, 2, 3, 4, 5]) 15 >>> max_sum_after_operations(5, 3, [5, 5, 5, 5, 5]) 25 >>> max_sum_after_operations(3, 1, [1, 2, 3]) 9 >>> max_sum_after_operations(4, 2, [4, 3, 2, 1]) 16 >>> max_sum_after_operations(6, 4, [2, 3, 1, 5, 2, 4]) 30 >>> max_sum_after_operations(3, 2, [1000000000, 999999999, 888888888]) 3000000000","solution":"def max_sum_after_operations(n, k, arr): Determine the maximum possible sum of the array after k operations. Parameters: n (int): Number of elements in the array. k (int): Number of operations to perform. arr (list of ints): The array of integers. Returns: int: The maximum possible value of the sum of the array after k operations. if k == 0: return sum(arr) max_value = max(arr) return max_value * n"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the number of palindromic substrings in the given string S. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6","solution":"def count_palindromic_substrings(S): Returns the number of palindromic substrings in the given string S. n = len(S) count = 0 # A 2D array to store whether substring S[i:j+1] is palindrome dp = [[False] * n for _ in range(n)] for length in range(1, n+1): # length of the substring for start in range(n-length+1): # start index of the substring end = start + length - 1 # end index of the substring if length == 1: dp[start][end] = True elif length == 2: dp[start][end] = (S[start] == S[end]) else: dp[start][end] = (S[start] == S[end]) and dp[start+1][end-1] if dp[start][end]: count += 1 return count"},{"question":"def distribute_services(D: int, B: List[int], S: int) -> Tuple[int, List[int]]: Distributes the available services among the districts such that the maximum number of districts receive exactly one service. Parameters: D (int): Number of districts. B (list): List of integers representing the number of residential buildings in each district. S (int): Number of services available. Returns: tuple: A tuple containing: - An integer representing the maximum number of districts that receive exactly one service. - A list of integers representing the number of services assigned to each district. pass # Example usage: # D = 5 # B = [10, 20, 30, 40, 50] # S = 7 # print(distribute_services(D, B, S)) # (5, [1, 1, 1, 1, 1]) # Unit tests def test_distribute_services_max_services(): D = 5 B = [10, 20, 30, 40, 50] S = 7 result = distribute_services(D, B, S) assert result == (5, [1, 1, 1, 1, 1]) def test_distribute_services_less_services(): D = 6 B = [8, 12, 3, 7, 15, 5] S = 5 result = distribute_services(D, B, S) assert result == (5, [1, 1, 1, 1, 1, 0]) def test_distribute_services_equal_services(): D = 5 B = [3, 4, 2, 1, 5] S = 5 result = distribute_services(D, B, S) assert result == (5, [1, 1, 1, 1, 1]) def test_distribute_services_insufficient_services(): D = 4 B = [7, 9, 12, 6] S = 2 result = distribute_services(D, B, S) assert result == (2, [1, 1, 0, 0]) def test_distribute_services_single_district(): D = 1 B = [10] S = 1 result = distribute_services(D, B, S) assert result == (1, [1])","solution":"def distribute_services(D, B, S): Distributes the available services among the districts such that the maximum number of districts receive exactly one service. Parameters: D (int): Number of districts. B (list): List of integers representing the number of residential buildings in each district. S (int): Number of services available. Returns: tuple: A tuple containing: - An integer representing the maximum number of districts that receive exactly one service. - A list of integers representing the number of services assigned to each district. services = [0] * D max_one_service = min(D, S) for i in range(max_one_service): services[i] = 1 return max_one_service, services"},{"question":"from typing import List def reorderString(s: str, d: int) -> str: Reorder the string s so that same characters are at least distance d apart. Returns the reordered string or an empty string if it's not possible. >>> reorderString(\\"aabbcc\\", 3) \\"abacbc\\" # or any other valid reordering >>> reorderString(\\"aaabc\\", 3) \\"\\"","solution":"from collections import Counter import heapq def reorderString(s, d): Reorder the string s so that same characters are at least distance d apart. Returns the reordered string or an empty string if it's not possible. if d == 0: return s # Count the frequency of each character freq = Counter(s) # Max-heap to store character and its frequency (negated to use Python's min-heap as max-heap) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: count, char = heapq.heappop(max_heap) # Get the most frequent character result.append(char) # Place it in the result # Queue to track characters that wait for at least d distances to be pushed back to the heap queue.append((char, count + 1)) # Increment count because it was a negative value # Maintain the distance by popping from queue if its length is greater than or equals to d if len(queue) >= d: prev_char, prev_count = queue.pop(0) if prev_count < 0: # If more occurrences are left, add it back to heap heapq.heappush(max_heap, (prev_count, prev_char)) if len(result) != len(s): # If we couldn't place all characters return \\"\\" else: return \\"\\".join(result)"},{"question":"def wordPattern(pattern: str, s: str) -> bool: Determine if the string s follows the same pattern as given in pattern. >>> wordPattern(\\"abba\\", \\"dog cat cat dog\\") True >>> wordPattern(\\"abba\\", \\"dog cat cat fish\\") False >>> wordPattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> wordPattern(\\"abba\\", \\"dog dog dog dog\\") False >>> wordPattern(\\"ab\\", \\"dog dog\\") False >>> wordPattern(\\"a\\", \\"dog\\") True >>> wordPattern(\\"abc\\", \\"dog cat fish\\") True >>> wordPattern(\\"abcd\\", \\"dog cat\\") False >>> wordPattern(\\"\\", \\"\\") True >>> wordPattern(\\"a\\", \\"dog cat\\") False >>> wordPattern(\\"abc\\", \\"dog dog dog\\") False >>> wordPattern(\\"abba\\", \\"dog fish fish fish\\") False","solution":"def wordPattern(pattern, s): Returns whether the string s follows the given pattern. Parameters: pattern (str): The pattern string consisting of characters. s (str): The string of words, separated by spaces. Returns: bool: True if s follows the pattern, False otherwise. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"def min_meeting_rooms(events): Returns the minimum number of rooms required to accommodate all events. >>> min_meeting_rooms([(100, 120), (150, 200), (210, 220)]) == 1 >>> min_meeting_rooms([(60, 150), (30, 120), (200, 220), (100, 200), (140, 180), (180, 210)]) == 3 >>> min_meeting_rooms([(0, 30), (10, 40), (20, 50)]) == 3 >>> min_meeting_rooms([(0, 30)]) == 1 pass def min_rooms_for_employees(n, schedules): Given the number of employees and their schedules, return the minimum number of rooms required to accommodate all events. >>> min_rooms_for_employees(3, [[(60, 150), (30, 120), (200, 220)], [(100, 200), (140, 180)], [(180, 210)]]) == 3 >>> min_rooms_for_employees(2, [[(100, 120), (150, 200)], [(210, 220), (300, 330)]]) == 1 pass # Example input schedules = [ [(60, 150), (30, 120), (200, 220)], [(100, 200), (140, 180)], [(180, 210)] ] # Example usage print(min_rooms_for_employees(3, schedules)) # Should output 3","solution":"def min_meeting_rooms(events): Returns the minimum number of rooms required to accommodate all events. if not events: return 0 start_times = sorted([start for start, end in events]) end_times = sorted([end for start, end in events]) start_ptr, end_ptr = 0, 0 num_rooms, max_rooms = 0, 0 while start_ptr < len(start_times): if start_times[start_ptr] < end_times[end_ptr]: num_rooms += 1 start_ptr += 1 else: num_rooms -= 1 end_ptr += 1 max_rooms = max(max_rooms, num_rooms) return max_rooms def min_rooms_for_employees(n, schedules): Given the number of employees and their schedules, return the minimum number of rooms required to accommodate all events. events = [] for schedule in schedules: events.extend(schedule) return min_meeting_rooms(events) # Example input, parsing, and calculation: n = 3 schedules = [ [(60, 150), (30, 120), (200, 220)], [(100, 200), (140, 180)], [(180, 210)] ] print(min_rooms_for_employees(n, schedules)) # Should output 3"},{"question":"def is_palindrome(number: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(22) True def is_prime(number: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(13) True >>> is_prime(15) False def smallest_prime_palindrome_greater_than(n: int) -> int: Find the smallest prime palindrome greater than a given number N. >>> smallest_prime_palindrome_greater_than(13) 101 >>> smallest_prime_palindrome_greater_than(31) 101 >>> smallest_prime_palindrome_greater_than(100) 101 >>> smallest_prime_palindrome_greater_than(130) 131 >>> smallest_prime_palindrome_greater_than(1030) 10301 def main(test_cases: list[int]) -> list[int]: Process multiple test cases to find smallest prime palindromes greater than given numbers. >>> main([13, 31, 100]) [101, 101, 101]","solution":"def is_palindrome(number): return str(number) == str(number)[::-1] def is_prime(number): if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def smallest_prime_palindrome_greater_than(n): number = n + 1 while True: if is_palindrome(number) and is_prime(number): return number number += 1 def main(test_cases): results = [] for n in test_cases: results.append(smallest_prime_palindrome_greater_than(n)) return results"},{"question":"def is_prime(num): Check if a number is prime. ... def longest_prime_row(n): Calculate the longest row of books with consecutive prime differences. >>> longest_prime_row(10) (3, [1, 2, 3]) >>> longest_prime_row(15) (5, [1, 2, 3, 5, 7]) >>> longest_prime_row(1) (1, [1]) >>> longest_prime_row(5) (3, [1, 2, 3]) ... from solution import longest_prime_row def test_example_1(): n = 10 k, sequence = longest_prime_row(n) assert k >= 3 and set(sequence).issubset(set(range(1, n+1))) def test_example_2(): n = 15 k, sequence = longest_prime_row(n) assert k >= 5 and set(sequence).issubset(set(range(1, n+1))) def test_single_book(): n = 1 k, sequence = longest_prime_row(n) assert k == 1 and sequence == [1] def test_small_collection(): n = 5 k, sequence = longest_prime_row(n) assert k >= 3 and set(sequence).issubset(set(range(1, n+1))) def test_max_collection(): n = 100 k, sequence = longest_prime_row(n) assert k > 1 and set(sequence).issubset(set(range(1, n+1)))","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def longest_prime_row(n): Calculate the longest row of books with consecutive prime differences. primes = [i for i in range(n+1) if is_prime(i)] seq = [1] for i in range(2, n+1): found = False for prime in primes: if prime > n: break if seq[-1] + prime <= n and (seq[-1] + prime) not in seq: seq.append(seq[-1] + prime) found = True break if not found: break return len(seq), seq # Sample usage: n = 10 k, sequence = longest_prime_row(n) print(k) print(' '.join(map(str, sequence)))"},{"question":"def maxCoins(N: int, M: int, grid: List[List[int]]) -> int: Calculates the maximum number of coins collected by navigating from the top-left corner to the bottom-right corner by only moving right or down. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (list of list of ints): The NxM grid containing non-negative integers representing coins. Returns: int: The maximum number of coins that can be collected. >>> maxCoins(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> maxCoins(2, 2, [ ... [1, 2], ... [3, 4] ... ]) == 8","solution":"def maxCoins(N, M, grid): Calculates the maximum number of coins collected by navigating from the top-left corner to the bottom-right corner by only moving right or down. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (list of list of ints): The NxM grid containing non-negative integers representing coins. Returns: int: The maximum number of coins that can be collected. # Create a 2D dp array to store the maximum coins collected up to each cell dp = [[0] * M for _ in range(N)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the maximum coins that can be collected return dp[N - 1][M - 1]"},{"question":"class CardOrderingSystem: def __init__(self, initial_orders): Initialize the system with the initial number of cards ordered by each client. def add_cards(self, client_index, num_cards): Add a specific amount to the number of cards ordered by a particular client. Args: client_index (int): The index of the client. num_cards (int): The number of cards to add to the client's order. def query_total_cards(self, left_index, right_index): Query the total number of cards ordered by clients within a specified range. Args: left_index (int): The starting index of the range (inclusive). right_index (int): The ending index of the range (inclusive). Returns: int: The sum of the cards ordered by the clients in the specified range. >>> system = CardOrderingSystem([10, 20, 30, 40, 50]) >>> system.query_total_cards(2, 4) 90 >>> system.add_cards(3, 10) >>> system.query_total_cards(1, 5) 160 >>> system.add_cards(5, 20) >>> system.query_total_cards(4, 5) 110","solution":"class CardOrderingSystem: def __init__(self, initial_orders): self.orders = initial_orders self.prefix_sums = self._compute_prefix_sums() def _compute_prefix_sums(self): prefix_sums = [0] * (len(self.orders) + 1) for i in range(len(self.orders)): prefix_sums[i + 1] = prefix_sums[i] + self.orders[i] return prefix_sums def add_cards(self, client_index, num_cards): self.orders[client_index - 1] += num_cards self.prefix_sums = self._compute_prefix_sums() def query_total_cards(self, left_index, right_index): return self.prefix_sums[right_index] - self.prefix_sums[left_index - 1]"},{"question":"from typing import List def longest_repeated_substring(s: str) -> str: Returns the longest substring that appears at least twice in the given string. If no such substring exists, returns an empty string. >>> longest_repeated_substring(\\"banana\\") 'ana' >>> longest_repeated_substring(\\"abcd\\") '' >>> longest_repeated_substring(\\"aaaa\\") 'aaa' >>> longest_repeated_substring(\\"ababcababc\\") 'ababc' >>> longest_repeated_substring(\\"abcde\\") '' >>> longest_repeated_substring(\\"abcabcabcxyzxyz\\") 'abcabc' >>> longest_repeated_substring(\\"aa\\") 'a'","solution":"def longest_repeated_substring(s): Returns the longest substring that appears at least twice in the given string. If no such substring exists, returns an empty string. def is_repeated(sub): count = 0 start = 0 while True: start = s.find(sub, start) + 1 if start > 0: count += 1 else: break if count > 1: return True return False n = len(s) for length in range(n-1, 0, -1): for i in range(n - length): sub = s[i:i + length] if is_repeated(sub): return sub return \\"\\""},{"question":"from typing import List, Tuple def max_unique_cities(N: int, M: int, cities: List[int], trains: List[Tuple[int, int, int]]) -> int: Calculate the maximum number of unique cities a passenger can visit starting from any city and respecting the train distance constraint. Parameters: N (int): Number of cities M (int): Number of direct train connections cities (List[int]): List of city coordinates in a 1-dimensional coordinate system trains (List[Tuple[int, int, int]]): List of tuples representing direct train connections where each tuple contains two city indices and a distance Returns: int: Maximum number of unique cities a passenger can visit >>> max_unique_cities(4, 4, [1, 3, 6, 10], [(1, 2, 2), (2, 3, 3), (3, 4, 4), (2, 4, 7)]) 4 >>> max_unique_cities(3, 3, [2, 5, 8], [(1, 2, 3), (2, 3, 5), (1, 3, 6)]) 3 >>> max_unique_cities(3, 0, [1, 2, 3], []) 1 >>> max_unique_cities(4, 3, [1, 2, 3, 4], [(1, 2, 1), (2, 3, 2), (3, 4, 3)]) 4 >>> max_unique_cities(4, 5, [1, 3, 6, 10], [(1, 2, 2), (2, 3, 3), (3, 4, 4), (1, 3, 5), (2, 4, 7)]) 4","solution":"from collections import defaultdict def max_unique_cities(N, M, cities, trains): graph = defaultdict(list) for u, v, d in trains: graph[u].append((v, d)) graph[v].append((u, d)) # Function to perform DFS with distance constraints def dfs(city, last_dist, visited): visited.add(city) max_visited = len(visited) for neighbor, dist in sorted(graph[city], key=lambda x: -x[1]): if neighbor not in visited and dist <= last_dist: max_visited = max(max_visited, dfs(neighbor, dist, visited)) visited.remove(city) return max_visited max_cities = 0 for city in range(1, N+1): max_cities = max(max_cities, dfs(city, float('inf'), set())) return max_cities"},{"question":"def reverse_words_in_string(s: str) -> str: This function takes a string as input and returns a new string with each word reversed but with the words in the original order. Any characters that are not part of a word (e.g., punctuation, spaces) remain in their original locations. >>> reverse_words_in_string(\\"This is a test!\\") == \\"sihT si a tset!\\" >>> reverse_words_in_string(\\"Hello, world!\\") == \\"olleH, dlrow!\\" >>> reverse_words_in_string(\\"A B\\") == \\"A B\\" >>> reverse_words_in_string(\\"123 ABC 456\\") == \\"123 CBA 456\\" >>> reverse_words_in_string(\\"Palindrome\\") == \\"emordnilaP\\" >>> reverse_words_in_string(\\"It's a Test.\\") == \\"tI's a tseT.\\" >>> reverse_words_in_string(\\"\\") == \\"\\" >>> reverse_words_in_string(\\" \\") == \\" \\" pass","solution":"def reverse_words_in_string(s): This function takes a string as input and returns a new string with each word reversed but with the words in the original order. Any characters that are not part of a word (e.g., punctuation, spaces) remain in their original locations. def reverse_word(word): result = '' for char in word: result = char + result return result new_string = [] word = [] for char in s: if char.isalpha(): word.append(char) else: if word: new_string.append(reverse_word(''.join(word))) word = [] new_string.append(char) if word: new_string.append(reverse_word(''.join(word))) return ''.join(new_string)"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Given an array of integers \`arr\` of size \`n\`, find the maximum sum of any contiguous subarray of size \`k\`. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) == 9 >>> max_sum_subarray([4, 2, -1, 5, 3, 8], 2) == 11 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) == -3","solution":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Returns the maximum sum of any contiguous subarray of size k. Parameters: arr (List[int]): The input list of integers. k (int): The size of the subarray. Returns: int: The maximum sum of any contiguous subarray of size k. # Initialize the maximum sum as the sum of the first 'k' elements max_sum = current_sum = sum(arr[:k]) # Use sliding window to find maximum sum of subarray of size k for i in range(k, len(arr)): # Slide the window: remove the element going out and add the new element coming in current_sum += arr[i] - arr[i - k] # Update max_sum if the current window sum is greater if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def are_anagrams(str1: str, str2: str) -> str: Check if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"triangle\\", \\"integral\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"peach\\") \\"NO\\" pass def process_test_cases(test_cases: [(str, str)]) -> [str]: Process multiple test cases and return results. >>> process_test_cases([(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"peach\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases([(\\"abc\\", \\"cab\\"), (\\"abcd\\", \\"dcba\\"), (\\"monkey\\", \\"donkey\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def are_anagrams(str1, str2): Check if two strings are anagrams of each other. if sorted(str1) == sorted(str2): return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): Process multiple test cases and return results. results = [] for str1, str2 in test_cases: results.append(are_anagrams(str1, str2)) return results"},{"question":"from typing import List def longest_even_palindrome(T: int, cases: List[str]) -> List[str]: Find the length of the longest even-length palindrome that can be formed by rearranging its characters. >>> longest_even_palindrome(1, [\\"aabbcc\\"]) [\\"6\\"] >>> longest_even_palindrome(1, [\\"abcde\\"]) [\\"0\\"] >>> longest_even_palindrome(1, [\\"aaaabbbb\\"]) [\\"8\\"]","solution":"from collections import Counter def longest_even_palindrome(T, cases): if not (1 <= T <= 20): return [\\"Invalid Input\\"] result = [] for S in cases: if not (1 <= len(S) <= 200) or not S.islower(): result.append(\\"Invalid Input\\") continue char_count = Counter(S) length = 0 for count in char_count.values(): length += (count // 2) * 2 result.append(str(length)) return result"},{"question":"def first_unique_char(s: str) -> int: Returns the index of the first unique character in the string \`s\`. If there are no unique characters, returns -1. The function is case-sensitive. >>> first_unique_char(\\"leetcode\\") == 0 >>> first_unique_char(\\"loveleetcode\\") == 2 >>> first_unique_char(\\"aabb\\") == -1 >>> first_unique_char(\\"aAbBcC\\") == 0","solution":"def first_unique_char(s): Returns the index of the first unique character in the string \`s\`. If there are no unique characters, returns -1. The function is case-sensitive. # Dictionary to store frequency of each character char_count = {} # Traverse the string to fill the char_count for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Traverse the string again to find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index # If no unique character is found return -1"},{"question":"def max_subarray_sum(array): Returns the largest sum of the contiguous subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1","solution":"def max_subarray_sum(array): Returns the largest sum of the contiguous subarray. if not array: return 0 current_sum = max_sum = array[0] for num in array[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Find the number of unique paths in a grid with obstacles. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid starting from the top-left corner. Args: obstacleGrid (List[List[int]]): 2D grid where 0 represents an empty space and 1 represents an obstacle. Returns: int: The number of unique paths to the bottom-right corner, or 0 if no valid path exists. Examples: >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([[0, 1], [0, 0]]) 1 >>> uniquePathsWithObstacles([[1, 0]]) 0 >>> uniquePathsWithObstacles([[0]]) 1","solution":"def uniquePathsWithObstacles(obstacleGrid): m, n = len(obstacleGrid), len(obstacleGrid[0]) # If the starting point has an obstacle, then there are no paths. if obstacleGrid[0][0] == 1: return 0 # Initialize the starting point obstacleGrid[0][0] = 1 # Initialize the first row for i in range(1, n): obstacleGrid[0][i] = int(obstacleGrid[0][i] == 0 and obstacleGrid[0][i-1] == 1) # Initialize the first column for i in range(1, m): obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1) # Populate the rest of the grid for i in range(1, m): for j in range(1, n): if obstacleGrid[i][j] == 0: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1] else: obstacleGrid[i][j] = 0 return obstacleGrid[m-1][n-1]"},{"question":"def max_productivity(n: int, a: List[int]) -> int: This function calculates the maximum possible productivity after removing exactly one element from the array. :param n: int - the number of elements in the array :param a: list of int - the elements of the array :return: int - maximum possible productivity >>> max_productivity(4, [1, 2, 3, 4]) 24 >>> max_productivity(3, [3, 6, 9]) 54","solution":"def max_productivity(n, a): This function calculates the maximum possible productivity after removing exactly one element from the array. :param n: int - the number of elements in the array :param a: list of int - the elements of the array :return: int - maximum possible productivity total_product = 1 for num in a: total_product *= num max_prod = 0 for num in a: productivity = total_product // num max_prod = max(max_prod, productivity) return max_prod"},{"question":"def max_gold(N, M, grid): Returns the maximum number of gold coins that can be collected along the path from the top-left cell (0, 0) to the bottom-right cell (N-1, M-1) moving only right or down. >>> max_gold(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_gold(1, 4, [ ... [1, 2, 3, 4] ... ]) == 10 >>> max_gold(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) == 10","solution":"def max_gold(N, M, grid): Returns the maximum number of gold coins that can be collected along the path from the top-left cell (0, 0) to the bottom-right cell (N-1, M-1) moving only right or down. # Create a 2D dp array to store the maximum gold that can be collected up to that cell dp = [[0] * M for _ in range(N)] # Initialize the top-left cell with the value of the gold coins in the starting cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, M): # The value in the current cell will be the maximum gold collected # from either the cell above it or the cell to the left of it dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer will be in the bottom-right cell return dp[N-1][M-1]"},{"question":"def calculate_depths(N, edges, queries): Calculate the depth of multiple nodes in a rooted tree. Args: N (int): the number of nodes in the tree. edges (List[Tuple[int, int]]): the edges of the tree. queries (List[int]): the nodes for which to calculate depth. Returns: List[int]: the depth for each query node. Example: >>> calculate_depths(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [4, 5, 6]) [2, 2, 2]","solution":"def calculate_depths(N, edges, queries): from collections import deque, defaultdict # Graph construction tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Depth calculation depth = [-1] * (N + 1) depth[1] = 0 queue = deque([1]) while queue: node = queue.popleft() current_depth = depth[node] for neighbor in tree[node]: if depth[neighbor] == -1: # Unvisited depth[neighbor] = current_depth + 1 queue.append(neighbor) return [depth[q] for q in queries]"},{"question":"def highest_grade_student(N, students): Returns the name of the student with the highest grade. :param N: Integer, the number of students :param students: List of tuples, each containing the student name and grade :return: String, the name of the student with the highest grade >>> highest_grade_student(1, [(\\"Alice\\", 85)]) 'Alice' >>> highest_grade_student(5, [(\\"Alice\\", 85), (\\"Bob\\", 92), (\\"Charlie\\", 87), (\\"David\\", 92), (\\"Eva\\", 90)]) 'Bob' >>> highest_grade_student(3, [(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Charlie\\", 90)]) 'Alice' >>> highest_grade_student(4, [(\\"Alice\\", 85), (\\"Bob\\", 88), (\\"Charlie\\", 82), (\\"David\\", 95)]) 'David' >>> highest_grade_student(3, [(\\"Alice\\", 100), (\\"Bob\\", 95), (\\"Charlie\\", 99)]) 'Alice'","solution":"def highest_grade_student(N, students): Returns the name of the student with the highest grade. :param N: Integer, the number of students :param students: List of tuples, each containing the student name and grade :return: String, the name of the student with the highest grade max_grade = -1 top_student = '' for student in students: name, grade = student if grade > max_grade: max_grade = grade top_student = name return top_student"},{"question":"def maxSumNonAdjacent(nums: List[int]) -> int: Returns the maximum sum of non-adjacent elements in the list. >>> maxSumNonAdjacent([3, 2, 7, 10]) 13 >>> maxSumNonAdjacent([3, 2, 5, 10, 7]) 15 >>> maxSumNonAdjacent([]) 0 >>> maxSumNonAdjacent([5]) 5 >>> maxSumNonAdjacent([4, 5]) 5 >>> maxSumNonAdjacent([10**4, 0, 10**4, 0, 10**4]) 30000 >>> maxSumNonAdjacent([1, 100, 1, 100, 1]) 200 >>> maxSumNonAdjacent([0, 0, 0, 0]) 0","solution":"def maxSumNonAdjacent(nums): Returns the maximum sum of non-adjacent elements in the list. if not nums: # If the list is empty return 0 incl = 0 # Sum including the previous element excl = 0 # Sum excluding the previous element for num in nums: new_excl = max(incl, excl) # max sum excluding the current element incl = excl + num # max sum including the current element excl = new_excl # Update excl to the max sum without the current element return max(incl, excl) # Return the maximum of incl and excl"},{"question":"from typing import List def removeDuplicates(nums: List[int]) -> int: Given an integer array \`nums\` sorted in non-decreasing order, remove the duplicates in-place such that each element appears only once. The relative order of the elements should be kept the same and you should not use extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. Args: nums(List[int]): List of integers sorted in non-decreasing order. Returns: int: New length of the array after duplicates have been removed. Examples: >>> nums = [0, 0, 1, 1, 2, 2] >>> removeDuplicates(nums) 3 >>> nums[:3] [0, 1, 2] >>> nums = [1, 1, 2] >>> removeDuplicates(nums) 2 >>> nums[:2] [1, 2]","solution":"from typing import List def removeDuplicates(nums: List[int]) -> int: if not nums: return 0 i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of the squares of the first n positive integers. If n is less than 1, returns 0. >>> sum_of_squares(5) 55 >>> sum_of_squares(3) 14 >>> sum_of_squares(0) 0 >>> sum_of_squares(-4) 0 >>> sum_of_squares(1) 1 >>> sum_of_squares(10) 385","solution":"def sum_of_squares(n): Returns the sum of the squares of the first n positive integers. If n is less than 1, returns 0. if n < 1: return 0 return sum(i ** 2 for i in range(1, n + 1))"},{"question":"def max_difference_with_condition(weights: List[int]) -> int: Finds the maximum difference between any two elements in the array such that the chosen two elements have at least one other element between them. Args: weights (list): A list of integers representing the weights of the marbles. Returns: int: The maximum difference satisfying the condition. >>> max_difference_with_condition([1, 5, 9, 3, 8]) 8 >>> max_difference_with_condition([1, 3, 2]) 1 >>> max_difference_with_condition([7, 7, 7, 7, 7]) 0 >>> max_difference_with_condition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 9 >>> max_difference_with_condition([1, 100, 1, 100, 1, 100, 1, 100]) 99 >>> max_difference_with_condition([1, 1000, 1, 1000, 1, 1000]) 999","solution":"def max_difference_with_condition(weights): Finds the maximum difference between any two elements in the array such that the chosen two elements have at least one other element between them. Args: weights (list): A list of integers representing the weights of the marbles. Returns: int: The maximum difference satisfying the condition. max_diff = float('-inf') n = len(weights) for i in range(n - 2): for j in range(i + 2, n): diff = abs(weights[j] - weights[i]) if diff > max_diff: max_diff = diff return max_diff # Example usage if __name__ == \\"__main__\\": M = 5 weights = [1, 5, 9, 3, 8] print(max_difference_with_condition(weights)) # Output: 8"},{"question":"from typing import List def min_max_pages(chapters: List[int], days: int) -> int: Find the minimum possible maximum number of pages to read in a day such that the book can be completed in the given number of days. The reading workload should be as balanced as possible across the days. >>> min_max_pages([10, 20, 30, 40, 50], 2) 90 >>> min_max_pages([10, 30, 40, 20], 3) 40 >>> min_max_pages([5, 5, 5, 5, 5], 5) 5 >>> min_max_pages([7, 2, 5, 10, 8], 2) 18 >>> min_max_pages([1, 2, 3, 4, 5], 5) 5","solution":"def can_split(chapters, days, max_pages_per_day): current_sum = 0 days_needed = 1 for pages in chapters: if current_sum + pages > max_pages_per_day: days_needed += 1 current_sum = pages if days_needed > days: return False else: current_sum += pages return True def min_max_pages(chapters, days): left, right = max(chapters), sum(chapters) while left < right: mid = (left + right) // 2 if can_split(chapters, days, mid): right = mid else: left = mid + 1 return left"},{"question":"import math def min_candies(a, b): Returns the minimal number of candies 't' such that 't' is divisible by both 'a' and 'b'. >>> min_candies(6, 8) 24 >>> min_candies(15, 25) 75","solution":"import math def min_candies(a, b): Returns the minimal number of candies 't' such that 't' is divisible by both 'a' and 'b'. return abs(a * b) // math.gcd(a, b)"},{"question":"from typing import List def minimum_employees(tasks: List[int], k: int) -> int: Determine the minimum number of employees required to handle all tasks without exceeding any employees weight capacity. >>> minimum_employees([4, 8, 6, 1, 2, 3], 10) 3 >>> minimum_employees([5], 5) 1 >>> minimum_employees([2, 2, 2, 2, 2], 5) 3 >>> minimum_employees([1, 2, 3, 4, 5], 15) 1 >>> minimum_employees([5, 5, 5, 5], 10) 2 >>> minimum_employees([1, 1, 1, 1, 1], 1) 5","solution":"from typing import List def minimum_employees(tasks: List[int], k: int) -> int: # Sort the tasks in non-increasing order tasks.sort(reverse=True) employees = 0 while tasks: total = 0 # Try to fill one employee's capacity as much as possible for i in range(len(tasks)): if total + tasks[i] <= k: total += tasks[i] tasks[i] = 0 # Remove the tasks that have been assigned (marked as 0) tasks = [task for task in tasks if task != 0] employees += 1 return employees"},{"question":"def count_minimum_coins_and_ways(N: int) -> tuple: Compute the minimum number of coins required to make up a given amount of money and the number of different ways to combine the coins to form the exact amount. :param N: An integer representing the amount of money where 1 <= N <= 10^18. :return: A tuple (min_coins, num_ways) with the first integer representing the minimum number of coins required to make up the amount N, and the second integer representing the number of different ways to combine the coins to form the exact amount. >>> count_minimum_coins_and_ways(10) (2, 1) >>> count_minimum_coins_and_ways(15) (4, 1)","solution":"def count_minimum_coins_and_ways(N): Returns a tuple (min_coins, num_ways) where: - min_coins is the minimal number of coins required to make the amount N. - num_ways is the number of different ways the exact amount can be formed using the coins. # Logarithm base 2 will help us find the highest power of 2 less than or equal to N def log2(x): return x.bit_length() - 1 min_coins = bin(N).count('1') # Number of 1s in binary representation gives minimum coins num_ways = 1 # Since each way of presenting can be unique only due to the coin's nature of being powers of 2 return min_coins, num_ways # Example usage: # print(count_minimum_coins_and_ways(10)) # Output should be (2, 1) # print(count_minimum_coins_and_ways(15)) # Output should be (4, 1)"},{"question":"def is_pangram(sentence: str) -> bool: Returns True if the sentence is a pangram, otherwise False. A pangram is a sentence that contains every single letter of the alphabet at least once. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True >>> is_pangram(\\"Hello World\\") == False >>> is_pangram(\\"Sphinx of black quartz, judge my vow\\") == True","solution":"def is_pangram(sentence): Returns True if the sentence is a pangram, otherwise False. A pangram is a sentence that contains every single letter of the alphabet at least once. alphabet = set(\\"abcdefghijklmnopqrstuvwxyz\\") sentence_letters = set(sentence.lower()) return alphabet.issubset(sentence_letters)"},{"question":"def compress_string(s: str) -> str: Compress the string using the following rules: Consecutive identical characters or digits are replaced by one instance of the character or digit followed by the count of its occurrences. If compressing the string does not reduce its length, return the original string. >>> compress_string(\\"aaabbbccc\\") 'a3b3c3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"aaabbbbcccccdddddeee\\") 'a3b4c5d5e3' >>> compress_string(\\"aabbcc\\") 'aabbcc'","solution":"def compress_string(s): if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"from typing import List def max_sum_subgrid(test_cases: List[List[List[int]]]) -> List[int]: Find the maximum sum of a sub-grid for a given list of test cases. Each test case is represented as a list of lists, where the first list contains the number of rows and columns, and the following lists represent the grid values. >>> test_cases = [[(3, 3), [1, 2, 3], [4, 5, 6], [7, 8, 9]], [(2, 4), [1, 2, 3, 4], [5, 6, 7, 8]]] >>> max_sum_subgrid(test_cases) [45, 36] >>> test_cases = [[(1, 1), [5]]] >>> max_sum_subgrid(test_cases) [5] >>> test_cases = [[(2, 2), [0, 0], [0, 0]]] >>> max_sum_subgrid(test_cases) [0] >>> test_cases = [[(3, 3), [1, 1, 1], [1, 1, 1], [1, 1, 1]]] >>> max_sum_subgrid(test_cases) [9] >>> test_cases = [[(3, 3), [1, 2, -1], [4, -2, 3], [2, 1, -4]]] >>> max_sum_subgrid(test_cases) [8] pass def parse_input(input_lines: List[str]) -> List[List[List[int]]]: Parse input lines and return a list of test cases suitable for processing by max_sum_subgrid function. >>> input_lines = [ ... \\"2\\", ... \\"3 3\\", ... \\"1 2 3\\", ... \\"4 5 6\\", ... \\"7 8 9\\", ... \\"2 4\\", ... \\"1 2 3 4\\", ... \\"5 6 7 8\\", ... ] >>> parse_input(input_lines) [[(3, 3), [1, 2, 3], [4, 5, 6], [7, 8, 9]], [(2, 4), [1, 2, 3, 4], [5, 6, 7, 8]]] pass","solution":"def max_sum_subgrid(test_cases): results = [] for grid in test_cases: R, C = grid[0] matrix = grid[1:] max_sum = float('-inf') # We use Kadane's algorithm extended to 2D for left in range(C): temp = [0] * R for right in range(left, C): for i in range(R): temp[i] += matrix[i][right] current_max = max_subarray_sum(temp) max_sum = max(max_sum, current_max) results.append(max_sum) return results def max_subarray_sum(array): max_so_far = float('-inf') max_ending_here = 0 for x in array: max_ending_here += x if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far def parse_input(input_lines): index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): R, C = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(R): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append([(R, C)] + grid) return test_cases"},{"question":"def user_activity_summary(events): Given a list of events where each event is represented by a triplet [userName, eventType, timestamp], return a summary of user activity. The summary should list each user and under each user, list the event types they engaged in along with the count of occurrences of each event type for that user. >>> user_activity_summary([[\\"Alice\\", \\"login\\", 5], [\\"Bob\\", \\"play\\", 10], [\\"Alice\\", \\"play\\", 15], [\\"Alice\\", \\"logout\\", 20], [\\"Bob\\", \\"login\\", 30], [\\"Alice\\", \\"login\\", 35]]) [[\\"Alice\\", \\"login\\", 2, \\"logout\\", 1, \\"play\\", 1], [\\"Bob\\", \\"login\\", 1, \\"play\\", 1]] >>> user_activity_summary([[\\"Carl\\", \\"view\\", 1], [\\"Carl\\", \\"click\\", 2], [\\"Carl\\", \\"click\\", 10], [\\"Carl\\", \\"view\\", 15]]) [[\\"Carl\\", \\"click\\", 2, \\"view\\", 2]] >>> user_activity_summary([[\\"Dave\\", \\"watch\\", 5], [\\"Eve\\", \\"listen\\", 7], [\\"Dave\\", \\"listen\\", 14], [\\"Eve\\", \\"watch\\", 20], [\\"Eve\\", \\"listen\\", 25]]) [[\\"Dave\\", \\"listen\\", 1, \\"watch\\", 1], [\\"Eve\\", \\"listen\\", 2, \\"watch\\", 1]] >>> user_activity_summary([]) [] >>> user_activity_summary([[\\"Alice\\", \\"login\\", 5]]) [[\\"Alice\\", \\"login\\", 1]] >>> user_activity_summary([[\\"Bob\\", \\"play\\", 10], [\\"Alice\\", \\"login\\", 5], [\\"Charlie\\", \\"login\\", 15], [\\"Alice\\", \\"play\\", 20], [\\"Bob\\", \\"login\\", 25]]) [[\\"Alice\\", \\"login\\", 1, \\"play\\", 1], [\\"Bob\\", \\"login\\", 1, \\"play\\", 1], [\\"Charlie\\", \\"login\\", 1]] >>> user_activity_summary([[\\"Alice\\", \\"play\\", 15], [\\"Alice\\", \\"login\\", 5], [\\"Alice\\", \\"login\\", 10], [\\"Alice\\", \\"logout\\", 20]]) [[\\"Alice\\", \\"login\\", 2, \\"logout\\", 1, \\"play\\", 1]]","solution":"def user_activity_summary(events): from collections import defaultdict user_events = defaultdict(lambda: defaultdict(int)) for user, event, timestamp in events: user_events[user][event] += 1 result = [] for user in sorted(user_events.keys()): user_summary = [user] for event in sorted(user_events[user].keys()): user_summary.append(event) user_summary.append(user_events[user][event]) result.append(user_summary) return result"},{"question":"from typing import List, Tuple def count_substring_occurrences(s: str, queries: List[Tuple[int, int, str]]) -> List[int]: Given a string s and a list of queries, each defined by a tuple (l, r, sub), return the number of occurrences of sub in the substring of s from l to r (inclusive, 1-based index). Args: s (str): The input string. queries (List[Tuple[int, int, str]]): A list of queries where each query is a tuple (l, r, sub). Returns: List[int]: A list of integers where each integer corresponds to the number of occurrences of sub in the specified range for each query. Examples: >>> count_substring_occurrences(\\"abcabcabc\\", [(1, 3, \\"abc\\"), (1, 6, \\"abc\\"), (2, 9, \\"bc\\")]) [1, 2, 3] >>> count_substring_occurrences(\\"abcdefgh\\", [(1, 8, \\"xyz\\"), (1, 4, \\"efg\\")]) [0, 0] pass def test_single_occurrence(): s = \\"abcdefgh\\" queries = [(1, 3, \\"abc\\")] assert count_substring_occurrences(s, queries) == [1] def test_multiple_occurrences(): s = \\"aabbaabbaabb\\" queries = [(1, 12, \\"aabb\\"), (1, 8, \\"aabb\\"), (5, 12, \\"aabb\\")] assert count_substring_occurrences(s, queries) == [3, 2, 2] def test_edge_cases(): s = \\"abcd\\" queries = [(1, 4, \\"abcd\\"), (1, 1, \\"a\\"), (4, 4, \\"d\\")] assert count_substring_occurrences(s, queries) == [1, 1, 1] def test_no_occurrences(): s = \\"abcdefgh\\" queries = [(1, 8, \\"xyz\\"), (1, 4, \\"efg\\")] assert count_substring_occurrences(s, queries) == [0, 0] def test_overlapping_occurrences(): s = \\"aaa\\" queries = [(1, 3, \\"aa\\"), (1, 3, \\"a\\")] assert count_substring_occurrences(s, queries) == [2, 3] def test_full_string(): s = \\"repeatrepeat\\" queries = [(1, 12, \\"repeat\\")] assert count_substring_occurrences(s, queries) == [2]","solution":"def count_substring_occurrences(s, queries): Given a string s and a list of queries, each defined by a tuple (l, r, sub), return the number of occurrences of sub in the substring of s from l to r (inclusive, 1-based index). results = [] for l, r, sub in queries: substring = s[l-1:r] # extract the substring from l to r count = 0 index = substring.find(sub) while index != -1: count += 1 index = substring.find(sub, index + 1) results.append(count) return results # Example function usage s = \\"abcabcabc\\" queries = [(1, 3, \\"abc\\"), (1, 6, \\"abc\\"), (2, 9, \\"bc\\")] output = count_substring_occurrences(s, queries) # Expected output: [1, 2, 3] print(output) # [1, 2, 3]"},{"question":"def has_non_decreasing_subsequence(nums): Returns True if there exists a non-decreasing subsequence of length at least 3, otherwise False. >>> has_non_decreasing_subsequence([1, 2, 3, 4, 5]) True >>> has_non_decreasing_subsequence([5, 4, 3, 2, 1]) False >>> has_non_decreasing_subsequence([2, 4, 3, 1, 5]) True","solution":"def has_non_decreasing_subsequence(nums): Returns True if there exists a non-decreasing subsequence of length at least 3, otherwise False. n = len(nums) if n < 3: return False first_min = float('inf') second_min = float('inf') for num in nums: if num <= first_min: first_min = num elif num <= second_min: second_min = num else: return True return False"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list of integers representing the number of days to wait for a warmer temperature. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 60, 90]) [1, 1, 0]","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list of integers representing the number of days to wait for a warmer temperature. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"def is_palindrome(word: str) -> bool: Returns True if the provided word is a palindrome, False otherwise. >>> is_palindrome(\\"aba\\") True >>> is_palindrome(\\"abba\\") True >>> is_palindrome(\\"abc\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True def process_operations(s: str, operations: List[Tuple[str, int]]) -> List[str]: Processes the given operations on the string s and checks if the resulting string is a palindrome after each operation. Parameters: s (str): The initial string. operations (List[Tuple[str, int]]): A list of (character, position) operations. Returns: List[str]: A list of \\"YES\\"/\\"NO\\" answers for each operation. >>> process_operations(\\"aba\\", [('b', 2), ('a', 1), ('c', 3)]) ['NO', 'NO', 'NO'] >>> process_operations(\\"a\\", [('a', 1)]) ['YES'] >>> process_operations(\\"ab\\", [('b', 3)]) ['NO'] >>> process_operations(\\"abc\\", [('a', 2), ('b', 4)]) ['NO', 'NO']","solution":"def is_palindrome(word): Returns True if the provided word is a palindrome, False otherwise. return word == word[::-1] def process_operations(s, operations): Processes the given operations on the string s and checks if the resulting string is a palindrome after each operation. Parameters: s (str): The initial string. operations (List[Tuple[str, int]]): A list of (character, position) operations. Returns: List[str]: A list of \\"YES\\"/\\"NO\\" answers for each operation. result = [] word = list(s) # Work with a list for efficient insertion for char, pos in operations: word.insert(pos - 1, char) if is_palindrome(word): result.append(\\"YES\\") else: result.append(\\"NO\\") return result # Read the input from standard input (example) def main(): import sys input = sys.stdin.read data = input().split() s = data[0] q = int(data[1]) operations = [(data[2 + 2*i], int(data[3 + 2*i])) for i in range(q)] results = process_operations(s, operations) for res in results: print(res)"},{"question":"def find_median_of_merged_lists(N: int, list_A: List[int], list_B: List[int]) -> float: Merges two sorted lists and finds the median of the merged list. Parameters: - N : int : length of the input lists - list_A : list of int : first sorted list of integers - list_B : list of int : second sorted list of integers Returns: - float : median of the merged list >>> find_median_of_merged_lists(3, [1, 3, 5], [2, 4, 6]) 3.5 >>> find_median_of_merged_lists(3, [1, 2, 3], [1, 2, 3]) 2.0 >>> find_median_of_merged_lists(4, [10, 20, 30, 40], [5, 15, 25, 35]) 22.5 >>> find_median_of_merged_lists(2, [-4, -3], [-2, -1]) -2.5 >>> find_median_of_merged_lists(1, [1], [2]) 1.5","solution":"def find_median_of_merged_lists(N, list_A, list_B): Merges two sorted lists and finds the median of the merged list. Parameters: - N : int : length of the input lists - list_A : list of int : first sorted list of integers - list_B : list of int : second sorted list of integers Returns: - float : median of the merged list # Merging the two sorted lists merged_list = [] i, j = 0, 0 while i < N and j < N: if list_A[i] < list_B[j]: merged_list.append(list_A[i]) i += 1 else: merged_list.append(list_B[j]) j += 1 # Append the remaining elements while i < N: merged_list.append(list_A[i]) i += 1 while j < N: merged_list.append(list_B[j]) j += 1 # Finding the Median total_length = 2 * N if total_length % 2 == 0: return (merged_list[total_length // 2 - 1] + merged_list[total_length // 2]) / 2 else: return merged_list[total_length // 2]"},{"question":"class LibraryInventory: Class to simulate an inventory management system for a small library. Each book is identified by a unique identifier (integer) and has a title (string). def __init__(self): Initialize an empty library collection self.books = {} def add(self, identifier: int, title: str): Add a new book with identifier \`identifier\` and title \`title\` to the collection. Parameters: identifier (int): Unique identifier for the book title (str): Title of the book >>> library = LibraryInventory() >>> library.add(1001, \\"Pride and Prejudice\\") >>> library.find(1001) == \\"Pride and Prejudice\\" True pass def remove(self, identifier: int): Remove the book with identifier \`identifier\` from the collection. Parameters: identifier (int): Unique identifier for the book to be removed >>> library = LibraryInventory() >>> library.add(1001, \\"Pride and Prejudice\\") >>> library.remove(1001) >>> library.find(1001) \\"Not found\\" pass def find(self, identifier: int) -> str: Find the title of the book with identifier \`identifier\`. Parameters: identifier (int): Unique identifier for the book to find Returns: str: Title of the book if found, otherwise \\"Not found\\" >>> library = LibraryInventory() >>> library.add(1001, \\"Pride and Prejudice\\") >>> library.find(1001) \\"Pride and Prejudice\\" >>> library.find(1002) \\"Not found\\" pass def process_queries(queries): Process a list of queries to manage a library inventory. Parameters: queries (List[str]): List of queries in the format: \\"0 x title\\" to add a book, \\"1 x\\" to remove a book, \\"2 x\\" to find a book Returns: List[str]: Results of each find operation >>> queries = [ ... \\"0 1001 \\"Pride and Prejudice\\"\\", ... \\"0 1002 \\"War and Peace\\"\\", ... \\"0 1003 \\"1984\\"\\", ... \\"2 1002\\", ... \\"1 1003\\", ... \\"2 1003\\" ... ] >>> process_queries(queries) [\\"War and Peace\\", \\"Not found\\"] pass","solution":"class LibraryInventory: def __init__(self): self.books = {} def add(self, identifier: int, title: str): self.books[identifier] = title def remove(self, identifier: int): if identifier in self.books: del self.books[identifier] def find(self, identifier: int) -> str: return self.books.get(identifier, \\"Not found\\") def process_queries(queries): library = LibraryInventory() results = [] for query in queries: parts = query.split() op = int(parts[0]) x = int(parts[1]) if op == 0: title = \\" \\".join(parts[2:])[1:-1] library.add(x, title) elif op == 1: library.remove(x) elif op == 2: results.append(library.find(x)) return results"},{"question":"def has_pair_with_sum(n: int, arr: List[int], target: int) -> bool: Returns True if there are two distinct elements in the array that sum up to the target. Otherwise, returns False. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. target (int): The target sum. Returns: bool: True if a pair exists that sums to the target, False otherwise. >>> has_pair_with_sum(5, [1, 2, 3, 4, 5], 8) True >>> has_pair_with_sum(4, [1, 1, 1, 1], 3) False >>> has_pair_with_sum(6, [-1, -2, -3, -4, -5, -6], -8) True","solution":"def has_pair_with_sum(n, arr, target): Returns True if there are two distinct elements in the array that sum up to the target. Otherwise, returns False. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. target (int): The target sum. Returns: bool: True if a pair exists that sums to the target, False otherwise. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Write a function that returns the length of the longest common subsequence between two strings. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguously. For example, \\"ace\\" is a subsequence of \\"abcde\\", but \\"aec\\" is not. Examples: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") # returns 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") # returns 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") # returns 0 >>> longest_common_subsequence(\\"abcdef\\", \\"acef\\") # returns 4 >>> longest_common_subsequence(\\"oxcpqrsvwf\\", \\"shmtulqrypy\\") # returns 2 :param str1: A string consisting of lower-case English letters. :param str2: Another string consisting of lower-case English letters. :return: Integer representing the length of the longest common subsequence of the two strings. # Implement your solution using dynamic programming for optimal performance. pass","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Function to return the length of longest common subsequence between two strings. # Initialize the DP table with dimensions (len(str1) + 1) x (len(str2) + 1) dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)] # Iterate over both strings to fill the DP table for i in range(1, len(str1) + 1): for j in range(1, len(str2) + 1): if str1[i - 1] == str2[j - 1]: # If characters match, increment from the previous indices dp[i][j] = dp[i - 1][j - 1] + 1 else: # If characters don't match, take the max between the previous ones dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The last element in the dp table will have the length of the longest common subsequence return dp[len(str1)][len(str2)]"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing only digits, return all possible letter combinations that the number could represent. >>> letter_combinations(\\"23\\") ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") ['a', 'b', 'c']","solution":"from itertools import product def letter_combinations(digits): Returns all possible letter combinations that the number could represent. if not digits: return [] mapping = { '2': \\"abc\\", '3': \\"def\\", '4': \\"ghi\\", '5': \\"jkl\\", '6': \\"mno\\", '7': \\"pqrs\\", '8': \\"tuv\\", '9': \\"wxyz\\" } # Create a list of lists for the mapped characters groups = [mapping[digit] for digit in digits] # Compute Cartesian product of these groups combinations = [''.join(combination) for combination in product(*groups)] return combinations"},{"question":"def are_anagrams(s1, s2): Given two strings, check if they are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. Input Format: The first string s1. The second string s2. Output Format: Output \\"YES\\" if the strings are anagrams of each other, otherwise output \\"NO\\". Constraints: 1  length of s1, s2  1000000 s1 and s2 will contain only lowercase alphabetical characters. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"pale\\") \\"NO\\"","solution":"def are_anagrams(s1, s2): Returns \\"YES\\" if s1 and s2 are anagrams, otherwise \\"NO\\". from collections import Counter # An early return if lengths differ as they cannot be anagrams if len(s1) != len(s2): return \\"NO\\" # Count frequencies of each character in both strings if Counter(s1) == Counter(s2): return \\"YES\\" else: return \\"NO\\""},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string such that all the alphabets appear before the digits, while maintaining their original relative order. Parameters: s (str): The input string containing lowercase alphabets and digits. Returns: str: The rearranged string with alphabets first, followed by digits. Examples: >>> rearrange_string(\\"3a2b5c1\\") \\"abc3251\\" >>> rearrange_string(\\"a1b2c3d4\\") \\"abcd1234\\" pass def main(): import sys input = sys.stdin.read().strip() print(rearrange_string(input))","solution":"def rearrange_string(s: str) -> str: Rearranges the input string such that all the alphabets appear before the digits, while maintaining their original relative order. Parameters: s (str): The input string containing lowercase alphabets and digits. Returns: str: The rearranged string with alphabets first, followed by digits. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters + digits) def main(): import sys input = sys.stdin.read().strip() print(rearrange_string(input))"},{"question":"def product_array(arr: List[int], n: int) -> List[int]: Construct a new array such that each element at index i of the new array is equal to the product of all the elements in the original array except the one at index i. >>> product_array([1, 2, 3, 4], 4) [24, 12, 8, 6] >>> product_array([5, 3, 4, 2], 4) [24, 40, 30, 60]","solution":"def product_array(arr, n): # Initialize arrays for left and right products left = [1] * n right = [1] * n prod = [1] * n # Create the left products array left[0] = 1 for i in range(1, n): left[i] = arr[i - 1] * left[i - 1] # Create the right products array right[n - 1] = 1 for j in range(n - 2, -1, -1): right[j] = arr[j + 1] * right[j + 1] # Construct the result array for i in range(n): prod[i] = left[i] * right[i] return prod"},{"question":"from math import gcd from functools import reduce def lcm(a, b): Helper function to compute the Least Common Multiple (LCM) of two integers. return a * b // gcd(a, b) def smallest_multiple(arr): Returns the smallest multiple (Least Common Multiple) of all the unique positive integers in the given array. >>> smallest_multiple([5, 7, 11]) == 385 >>> smallest_multiple([2, 3, 4, 5]) == 60 >>> smallest_multiple([12, 15, 18, 20]) == 180 >>> smallest_multiple([10]) == 10 >>> smallest_multiple([7, 9]) == 63 >>> smallest_multiple([2, 3, 5, 7, 11]) == 2310 >>> smallest_multiple([3, 5, 7, 9]) == 315","solution":"from math import gcd from functools import reduce def lcm(a, b): Helper function to compute the Least Common Multiple (LCM) of two integers. return a * b // gcd(a, b) def smallest_multiple(arr): Returns the smallest multiple (Least Common Multiple) of all the unique positive integers in the given array. return reduce(lcm, arr)"},{"question":"def minimal_remaining_token(n: int, m: int, grid: List[List[int]]) -> int: Given dimensions n, m and grid of tokens, returns the minimal value of any remaining token if both Vova and Lesha play optimally. >>> minimal_remaining_token(3, 3, [ [3, 1, 4], [1, 5, 9], [2, 6, 5]]) 1 >>> minimal_remaining_token(2, 2, [ [7, 3], [2, 5]]) 2","solution":"def minimal_remaining_token(n, m, grid): Given dimensions n, m and grid of tokens, returns the minimal value of any remaining token if both Vova and Lesha play optimally. # Flatten the grid to a single list of tokens tokens = [grid[i][j] for i in range(n) for j in range(m)] # Sort tokens in ascending order tokens.sort() total_picks = n * m // 2 # Each player picks half the tokens (or one less for odd total number) # Vova and Lesha take turns picking tokens starting from the largest # Since both start from largest, we need to find the remaining tokens after they pick # Alternately, this means ignoring the largest total_picks * 2 tokens remaining_tokens = tokens[:len(tokens) - total_picks * 2] if remaining_tokens: return min(remaining_tokens) else: return tokens[-total_picks*2] # Example usage: # n, m = 3, 3 # grid = [ # [3, 1, 4], # [1, 5, 9], # [2, 6, 5] # ] # print(minimal_remaining_token(n, m, grid)) # Expected Output: 1"},{"question":"def list_book_pairs(N: int): Returns a list of tuples representing all possible pairs of neighboring books that can be picked from a shelf with N books. :param N: Total number of books :type N: int :return: List of tuples with neighboring book pairs :rtype: list of tuples >>> list_book_pairs(5) [(1, 2), (2, 3), (3, 4), (4, 5)] >>> list_book_pairs(3) [(1, 2), (2, 3)] >>> list_book_pairs(2) [(1, 2)] >>> list_book_pairs(1) [] >>> list_book_pairs(0) []","solution":"def list_book_pairs(N): Returns a list of tuples representing all possible pairs of neighboring books that can be picked from a shelf with N books. :param N: Total number of books :type N: int :return: List of tuples with neighboring book pairs :rtype: list of tuples if N < 2: return [] pairs = [] for i in range(1, N): pairs.append((i, i + 1)) return pairs"},{"question":"def rotateGrid(n, grid): Rotates the n x n grid 90 degrees clockwise. Parameters: n (int): The dimension of the grid. grid (list of list of int): The 2D list representing the grid. Returns: list of list of int: The rotated grid. pass def test_rotateGrid_3x3(): assert rotateGrid(3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotateGrid_4x4(): assert rotateGrid(4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotateGrid_2x2(): assert rotateGrid(2, [ [1, 2], [3, 4] ]) == [ [3, 1], [4, 2] ] def test_rotateGrid_5x5(): assert rotateGrid(5, [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ]) == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotateGrid(n, grid): Rotates the n x n grid 90 degrees clockwise. Parameters: n (int): The dimension of the grid. grid (list of list of int): The 2D list representing the grid. Returns: list of list of int: The rotated grid. rotated_grid = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_grid[j][n-i-1] = grid[i][j] return rotated_grid"},{"question":"def construct_even_sum_array(N): Given an integer N, construct an integer array of length N such that the sum of its elements is even. The array should contain unique positive integers where each integer is between 1 and N inclusive. Args: N (int): the length of the array. Returns: list: the constructed array, or -1 if it's not possible to create such an array. Examples: >>> construct_even_sum_array(1) -1 >>> construct_even_sum_array(2) [1, 2] >>> construct_even_sum_array(3) [1, 2, 4] pass def process_test_cases(T, test_cases): Process multiple test cases for constructing integer arrays with even sums. Args: T (int): the number of test cases. test_cases (list): list of integers representing the length of arrays for each test case. Returns: list: list of resulting arrays or -1 for each test case. Examples: >>> process_test_cases(3, [1, 2, 3]) [-1, [1, 2], [1, 2, 4]] pass","solution":"def construct_even_sum_array(N): if N == 1: return -1 if N % 2 == 0: # Sum of first N even length array will be even return list(range(1, N + 1)) else: # Replace the last number with N+1 to make sum even return list(range(1, N)) + [N + 1] def process_test_cases(T, test_cases): results = [] for N in test_cases: results.append(construct_even_sum_array(N)) return results"},{"question":"def can_accommodate_all_books(G: int, genres: List[Tuple[int, int]]) -> bool: Checks if the library can accommodate all the books based on shelf space constraints. Parameters: G (int): Number of genres. genres (list of tuples): List of (Ni, Si) pairs where: Ni (int): Number of books in genre i. Si (int): Shelf space capacity for genre i. Returns: bool: True if all genres can accommodate their books, else False. >>> can_accommodate_all_books(3, [(10, 15), (25, 20), (5, 5)]) False >>> can_accommodate_all_books(3, [(10, 15), (5, 10), (8, 9)]) True","solution":"def can_accommodate_all_books(G, genres): Checks if the library can accommodate all the books based on shelf space constraints. Parameters: G (int): Number of genres. genres (list of tuples): List of (Ni, Si) pairs where: Ni (int): Number of books in genre i. Si (int): Shelf space capacity for genre i. Returns: bool: True if all genres can accommodate their books, else False. for Ni, Si in genres: if Ni > Si: return False return True"},{"question":"def count_special_sequences(nums: List[int]) -> int: Given a non-empty array of positive integers nums, find the number of special sequences. A special sequence is defined as a contiguous subarray whose elements can be rearranged to form a strictly increasing sequence. >>> count_special_sequences([1, 2, 3]) 6 >>> count_special_sequences([2, 2, 2]) 3 >>> count_special_sequences([1, 3, 2, 4]) 10","solution":"def count_special_sequences(nums): def is_special(subarray): return len(subarray) == len(set(subarray)) n = len(nums) count = 0 for start in range(n): unique_elements = set() for end in range(start, n): if nums[end] in unique_elements: break unique_elements.add(nums[end]) count += 1 return count"},{"question":"def number_of_steps(n: int) -> int: Given a non-negative integer \`n\`, this function determines the number of steps required to reduce the number to zero using the following operations: 1. If the number is even, divide it by 2. 2. If the number is odd, subtract 1 from it. >>> number_of_steps(14) 6 >>> number_of_steps(8) 4 >>> number_of_steps(123) 12 pass from solution import number_of_steps def test_number_of_steps_zero(): assert number_of_steps(0) == 0 def test_number_of_steps_one(): assert number_of_steps(1) == 1 def test_number_of_steps_even(): assert number_of_steps(8) == 4 def test_number_of_steps_odd(): assert number_of_steps(7) == 5 def test_number_of_steps_mixed(): assert number_of_steps(14) == 6 assert number_of_steps(123) == 12 def test_number_of_steps_large_number(): assert number_of_steps(1000000) == 26","solution":"def number_of_steps(n: int) -> int: Returns the number of steps required to reduce the number n to zero. steps = 0 while n > 0: if n % 2 == 0: n //= 2 else: n -= 1 steps += 1 return steps"},{"question":"def count_taller_students(heights: List[int]) -> int: Given a list of heights of students standing in a line, find how many students are taller than the tallest student standing immediately in front of them. Example usage: >>> count_taller_students([140, 150, 145, 160, 155]) 2 >>> count_taller_students([170, 165, 180]) 1 >>> count_taller_students([110, 120, 130, 140]) 3 pass","solution":"def count_taller_students(heights): Given a list of student heights, returns the number of students who are taller than the tallest student standing immediately in front of them. count = 0 n = len(heights) # Iterate through the list starting from the second student for i in range(1, n): # Check if current student i is taller than the student i-1 if heights[i] > heights[i - 1]: count += 1 return count # Read input values from Standard Input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) heights = list(map(int, data[1:n + 1])) result = count_taller_students(heights) print(result)"},{"question":"def max_books(test_cases): Determine the maximum number of books Mina can purchase. Input: List of tuples where each tuple contains a tuple (N, B) and a list of prices of N books. Output: List of integers, each representing the maximum number of books that can be purchased for each test case. pass def parse_input(input_string): Parse the input string to extract test cases. Input: A single string containing multiple lines of test case information. Output: A list of test cases as parsed from the input string. pass def format_output(results): Format the results to a string for output. Input: A list of integers, each representing the result of a test case. Output: A single string formatted for output. pass","solution":"def max_books(test_cases): results = [] for case in test_cases: N, B = case[0] prices = sorted(case[1]) count = 0 total_cost = 0 for price in prices: if total_cost + price <= B: total_cost += price count += 1 else: break results.append(count) return results def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N, B = map(int, input_lines[index].split()) prices = list(map(int, input_lines[index + 1].split())) test_cases.append(((N, B), prices)) index += 2 return test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def max_energy_boost(T: int, test_cases: list) -> list: Determine the maximum total energy boost Lina can collect by following the rules. >>> max_energy_boost(1, [(4, [3, 2, 5, 10])]) == [13] >>> max_energy_boost(2, [(4, [3, 2, 5, 10]), (3, [1, 3, 2])]) == [13, 3] >>> max_energy_boost(1, [(0, [])]) == [0] >>> max_energy_boost(1, [(1, [5])]) == [5] >>> max_energy_boost(1, [(2, [15, 30])]) == [30] >>> max_energy_boost(1, [(4, [1000000000, 0, 1000000000, 0])]) == [2000000000] >>> max_energy_boost(1, [(3, [1000000000, 900000000, 1000000000])]) == [2000000000]","solution":"def max_energy_boost(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] boosts = test_cases[i][1] if N == 0: results.append(0) continue if N == 1: results.append(boosts[0]) continue # DP array to store the maximum energy boost up to the i-th checkpoint dp = [0] * N dp[0] = boosts[0] if N > 1: dp[1] = max(boosts[0], boosts[1]) for j in range(2, N): dp[j] = max(dp[j-1], dp[j-2] + boosts[j]) results.append(dp[-1]) return results"},{"question":"def maxLuxurySum(N: int, lux: List[int]) -> int: Returns the maximum sum of luxury levels that can be obtained by selecting a subarray of rooms. Parameters: N (int): Number of rooms. lux (list): List of luxury levels of the rooms. Returns: int: Maximum sum of luxury levels. Example: >>> maxLuxurySum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxLuxurySum(4, [-1, -2, -3, -4]) 0","solution":"def maxLuxurySum(N, lux): Returns the maximum sum of luxury levels that can be obtained by selecting a subarray of rooms. Parameters: N (int): Number of rooms. lux (list): List of luxury levels of the rooms. Returns: int: Maximum sum of luxury levels. max_sum = 0 # Initialize maximum sum as 0, to handle all non-positive lux levels current_sum = 0 for level in lux: current_sum = max(0, current_sum + level) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> int: Return the maximum sum of any continuous subarray of size k. Args: nums (List[int]): a list of integers k (int): size of the subarray Returns: int: the maximum sum of any continuous subarray of size k, or 0 if no subarray of size k exists Example: >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([2, 1, 5, 10, 3], 3) 18 >>> max_sum_subarray([1, 2, 3], 5) 0","solution":"def max_sum_subarray(nums, k): if len(nums) < k: return 0 # Initial sum of first subarray of size k max_sum = curr_sum = sum(nums[:k]) # Use sliding window to find max subarray sum for i in range(k, len(nums)): curr_sum += nums[i] - nums[i - k] if curr_sum > max_sum: max_sum = curr_sum return max_sum"},{"question":"def minimum_packs_needed(p, c): Given the number of participants \`p\` and the number of colored pencils each participant should receive \`c\`, computes the minimum number of packs needed if each pack contains 6 pencils. :param p: int - number of participants (1  p  1000) :param c: int - number of colored pencils each participant should receive (1  c  1000) :return: int - minimum number of packs needed >>> minimum_packs_needed(10, 15) 25 >>> minimum_packs_needed(1, 1) 1 >>> minimum_packs_needed(12, 6) 12 >>> minimum_packs_needed(1000, 1000) 166667 >>> minimum_packs_needed(4, 6) 4 >>> minimum_packs_needed(1, 1) 1 >>> minimum_packs_needed(1000, 1000) 166667","solution":"def minimum_packs_needed(p, c): Given the number of participants \`p\` and the number of colored pencils each participant should receive \`c\`, computes the minimum number of packs needed if each pack contains 6 pencils. :param p: int - number of participants (1  p  1000) :param c: int - number of colored pencils each participant should receive (1  c  1000) :return: int - minimum number of packs needed total_pencils_needed = p * c packs_needed = (total_pencils_needed + 5) // 6 # Ceiling division by 6 return packs_needed"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def find_furthest_lake(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the furthest lake from the main river, based on the number of waterfalls water has to pass through. >>> find_furthest_lake(6, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6)]) 6 >>> find_furthest_lake(5, 4, [(1, 2), (1, 3), (2, 4), (2, 5)]) 4 >>> find_furthest_lake(4, 3, [(1, 2), (1, 3), (3, 4)]) 4 >>> find_furthest_lake(3, 2, [(1, 2), (2, 3)]) 3 >>> find_furthest_lake(7, 6, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6), (6, 7)]) 7","solution":"from collections import deque, defaultdict def find_furthest_lake(n, m, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Performing BFS to find the furthest node queue = deque([(1, 0)]) # (current_node, current_distance) max_distance = -1 furthest_node = -1 while queue: node, distance = queue.popleft() if distance > max_distance: max_distance = distance furthest_node = node elif distance == max_distance: furthest_node = min(furthest_node, node) for neighbor in graph[node]: queue.append((neighbor, distance + 1)) return furthest_node"},{"question":"import re from collections import Counter from typing import List, Tuple def word_frequency(document: str) -> List[Tuple[str, int]]: Counts the frequency of each word in a document and returns a sorted list of tuples containing words and their frequencies in descending order, and words with same frequency in ascending lexicographical order. >>> word_frequency(\\"Hello, world! World is great. Hello again, world.\\") [('world', 3), ('hello', 2), ('again', 1), ('great', 1), ('is', 1)] >>> word_frequency(\\"The quick brown fox jumps over the lazy dog. The dog barks.\\") [('the', 3), ('dog', 2), ('barks', 1), ('brown', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1)]","solution":"import re from collections import Counter def word_frequency(document): Counts the frequency of each word in a document and returns a sorted list of tuples containing words and their frequencies in descending order, and words with same frequency in ascending lexicographical order. # Remove punctuation and convert to lower case cleaned_document = re.sub(r'[^ws]', '', document).lower() # Split the document into words words = cleaned_document.split() # Count the frequency of each word word_counts = Counter(words) # Sort the words first by frequency (descending) then lexicographically (ascending) sorted_word_counts = sorted(word_counts.items(), key=lambda item: (-item[1], item[0])) return sorted_word_counts"},{"question":"class MatrixProcessor: Processes a 2D integer matrix and executes queries like updating a cell or summing submatrices. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... ] >>> processor = MatrixProcessor(matrix) >>> processor.query_sum(1, 1, 3, 3) 45 >>> processor.update(2, 2, 10) >>> processor.query_sum(1, 1, 3, 3) 50 >>> processor.query_sum(2, 2, 3, 3) 33 def __init__(self, matrix): self.matrix = matrix self.n = len(matrix) self.m = len(matrix[0]) def update(self, x, y, v): Updates the value of the element at position (x, y) to v. Args: x (int): The row index of the element (1-based). y (int): The column index of the element (1-based). v (int): The value to set. pass def query_sum(self, x1, y1, x2, y2): Returns the sum of all elements in the submatrix from (x1, y1) to (x2, y2), inclusive. Args: x1 (int): The starting row index of the submatrix (1-based). y1 (int): The starting column index of the submatrix (1-based). x2 (int): The ending row index of the submatrix (1-based). y2 (int): The ending column index of the submatrix (1-based). Returns: int: The sum of elements in the specified submatrix. pass","solution":"class MatrixProcessor: def __init__(self, matrix): self.matrix = matrix self.n = len(matrix) self.m = len(matrix[0]) def update(self, x, y, v): self.matrix[x-1][y-1] = v def query_sum(self, x1, y1, x2, y2): total_sum = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): total_sum += self.matrix[i][j] return total_sum"},{"question":"def cumulative_sum(lst: List[int]) -> List[int]: Returns a list where each element is the sum of itself and all previous elements in the list. Example: >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([1, -1, 3, -3]) [1, 0, 3, 0] >>> cumulative_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> cumulative_sum([5]) [5] >>> cumulative_sum([]) [] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10]","solution":"def cumulative_sum(lst): Returns a list where each element is the sum of itself and all previous elements in the list. if not lst: return [] result = [] current_sum = 0 for num in lst: current_sum += num result.append(current_sum) return result"},{"question":"def largest_rectangle_area_under_threshold(grid, n, m, k): Determine the area of the largest rectangle in a grid where the height of each cell does not exceed a given threshold. Parameters: grid (List[List[int]]): A 2D list representing the grid. n (int): The number of rows in the grid. m (int): The number of columns in the grid. k (int): The height threshold. Returns: int: The area of the largest rectangle under the described condition. >>> grid = [ ... [1, 3, 2, 1], ... [4, 6, 5, 3], ... [3, 2, 1, 7], ... [4, 5, 3, 2] ... ] >>> n, m, k = 4, 4, 5 >>> largest_rectangle_area_under_threshold(grid, n, m, k) 6 >>> grid = [ ... [1, 2, 3, 4, 5] ... ] >>> n, m, k = 1, 5, 3 >>> largest_rectangle_area_under_threshold(grid, n, m, k) 3 pass","solution":"def largest_rectangle_area_under_threshold(grid, n, m, k): def max_histogram_area(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area height = [0] * m max_area = 0 for i in range(n): for j in range(m): if grid[i][j] <= k: height[j] += 1 else: height[j] = 0 max_area = max(max_area, max_histogram_area(height)) return max_area"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines whether the linked list has a cycle or not. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise pass","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if a linked list has a cycle. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def canFormPalindrome(s: str) -> str: Determine if a given string can be rearranged to form a palindrome. :param s: The input string :return: \\"Yes\\" if the string can be rearranged to form a palindrome, else \\"No\\" Example: >>> canFormPalindrome(\\"civic\\") \\"Yes\\" >>> canFormPalindrome(\\"ivicc\\") \\"Yes\\" >>> canFormPalindrome(\\"hello\\") \\"No\\"","solution":"def canFormPalindrome(s): Determine if a given string can be rearranged to form a palindrome. :param s: The input string :return: \\"Yes\\" if the string can be rearranged to form a palindrome, else \\"No\\" from collections import Counter # Count the occurrences of each character char_count = Counter(s) # A string can be rearranged into a palindrome if at most one character # has an odd count (for the middle of the palindrome) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return \\"Yes\\" if odd_count <= 1 else \\"No\\""},{"question":"def max_subarray_sum_circular(arr: List[int]) -> int: Function to find the maximum possible sum of a subset of consecutive stones in circular arrangement. Parameters: arr (list): List of integers representing weights of stones. Returns: int: Maximum possible sum of a subset of consecutive stones. >>> max_subarray_sum_circular([1, -2, 3, 4, -1]) 7 >>> max_subarray_sum_circular([-5, -1, -8, 9, 14, -3]) 23 >>> max_subarray_sum_circular([-3, -2, -1]) -1","solution":"def max_subarray_sum_circular(arr): Function to find the maximum possible sum of a subset of consecutive stones in circular arrangement. Parameters: arr (list): List of integers representing weights of stones. Returns: int: Maximum possible sum of a subset of consecutive stones. def kadane(nums): max_ending_here = max_so_far = nums[0] for x in nums[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far N = len(arr) max_kadane = kadane(arr) max_wrap = sum(arr) + kadane([-x for x in arr]) if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"def highest_score_first_index(scores): Returns the 1-based index of the friend with the highest score, considering the friend who reached that score first in case of a tie. >>> highest_score_first_index([100, 200, 200, 150, 100]) -> 2 >>> highest_score_first_index([100]) -> 1 >>> highest_score_first_index([200, 200, 200, 200, 200]) -> 1 >>> highest_score_first_index([100, 100, 100, 100, 200]) -> 5 >>> highest_score_first_index([0, 0, 0, 0, 0]) -> 1 >>> highest_score_first_index([100, 150, 200, 150, 100]) -> 3","solution":"def highest_score_first_index(scores): Returns the 1-based index of the friend with the highest score, considering the friend who reached that score first in case of a tie. highest_score = -1 highest_index = -1 for i in range(len(scores)): if scores[i] > highest_score: highest_score = scores[i] highest_index = i return highest_index + 1"},{"question":"def is_mean_greater_than_a(n: int, k: int, a: int, S: List[int]) -> bool: Determines if it is possible to select a sequence of length k from the multiset S such that its arithmetic mean is greater than a. >>> is_mean_greater_than_a(5, 3, 5, [1, 2, 3, 7, 9]) True >>> is_mean_greater_than_a(6, 2, 8, [5, 9, 12, 1, 1, 2]) True >>> is_mean_greater_than_a(4, 1, 0, [-1, -2, -3, -4]) False def process_test_cases(test_cases: List[dict]) -> List[str]: Processes multiple test cases to determine if a sequence can be selected from the multiset S such that its arithmetic mean is greater than a. >>> test_cases = [ {'n': 5, 'k': 3, 'a': 5, 'S': [1, 2, 3, 7, 9]}, {'n': 6, 'k': 2, 'a': 8, 'S': [5, 9, 12, 1, 1, 2]}, {'n': 4, 'k': 1, 'a': 0, 'S': [-1, -2, -3, -4]} ] >>> process_test_cases(test_cases) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_mean_greater_than_a(n, k, a, S): Determines if it is possible to select a sequence of length k from the multiset S such that its arithmetic mean is greater than a. S.sort(reverse=True) selected_sequence = S[:k] mean_of_sequence = sum(selected_sequence) / k return mean_of_sequence > a def process_test_cases(test_cases): results = [] for t in test_cases: n, k, a = t['n'], t['k'], t['a'] S = t['S'] if is_mean_greater_than_a(n, k, a, S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def normalize(lst): Normalizes a list of integers such that the values fall within the range [0, 1]. >>> normalize([5, 10, 15, 20]) [0.0, 0.33, 0.67, 1.0] >>> normalize([2, 8, 10, 3, 5]) [0.0, 0.75, 1.0, 0.12, 0.38] >>> normalize([10]) [0.0] >>> normalize([3, 3, 3]) [0.0, 0.0, 0.0] >>> normalize([]) [] >>> normalize([-5, 0, 5, 10]) [0.0, 0.33, 0.67, 1.0] >>> normalize([-10, -5, 0, 5, 10]) [0.0, 0.25, 0.5, 0.75, 1.0]","solution":"def normalize(lst): Normalizes a list of integers such that the values fall within the range [0, 1]. if not lst: return [] min_val = min(lst) max_val = max(lst) if min_val == max_val: # If all elements are the same, return 0 for each element return [0.00] * len(lst) range_val = max_val - min_val normalized_lst = [(x - min_val) / range_val for x in lst] rounded_lst = [round(num, 2) for num in normalized_lst] return rounded_lst"},{"question":"def find_words_to_form_target(words: List[str], target: str) -> Union[str, Tuple[str, str]]: Determine if you can form the target string by concatenating two different words from the list in any order. >>> find_words_to_form_target([\\"cat\\", \\"dog\\", \\"mouse\\", \\"catdog\\", \\"mou\\", \\"dogcat\\"], \\"catdog\\") (\\"cat\\", \\"dog\\") >>> find_words_to_form_target([\\"hello\\", \\"world\\", \\"owor\\", \\"do\\"], \\"owor\\") \\"NO\\" >>> find_words_to_form_target([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") \\"NO\\" >>> find_words_to_form_target([\\"a\\", \\"ab\\", \\"aa\\", \\"b\\"], \\"ab\\") (\\"a\\", \\"b\\") >>> find_words_to_form_target([\\"ab\\", \\"cd\\", \\"abcd\\"], \\"abcd\\") (\\"ab\\", \\"cd\\") >>> find_words_to_form_target([chr(97+i) for i in range(26)], \\"ab\\") (\\"a\\", \\"b\\")","solution":"def find_words_to_form_target(words, target): word_set = set(words) lexicographical_pairs = [] for word in words: if target.startswith(word): remainder = target[len(word):] if remainder in word_set and remainder != word: lexicographical_pairs.append((word, remainder)) if target.endswith(word): start = target[:-len(word)] if start in word_set and start != word: lexicographical_pairs.append((start, word)) if lexicographical_pairs: lexicographical_pairs.sort() return lexicographical_pairs[0] return \\"NO\\" # Example usage if __name__ == \\"__main__\\": n = int(input()) words = [input().strip() for _ in range(n)] target = input().strip() result = find_words_to_form_target(words, target) if result == \\"NO\\": print(result) else: print(result[0], result[1])"},{"question":"def count_distinct_items(n, items): Returns the number of distinct items after normalizing case and trimming spaces. :param n: Integer, the number of items. :param items: List of strings, names of the items. :return: Integer, the number of distinct normalized items. >>> count_distinct_items(5, [\\"Apple \\", \\" apple\\", \\"Orange\\", \\"Banana\\", \\" BANANA \\"]) 3 >>> count_distinct_items(4, [\\"Milk\\", \\"milk \\", \\"MILK \\", \\" Milk \\"]) 1 >>> count_distinct_items(3, [\\"bread\\", \\"BREAD \\", \\"bread\\"]) 1 from solution import count_distinct_items def test_example_1(): assert count_distinct_items(5, [\\"Apple \\", \\" apple\\", \\"Orange\\", \\"Banana\\", \\" BANANA \\"]) == 3 def test_example_2(): assert count_distinct_items(4, [\\"Milk\\", \\"milk \\", \\"MILK \\", \\" Milk \\"]) == 1 def test_example_3(): assert count_distinct_items(3, [\\"bread\\", \\"BREAD \\", \\"bread\\"]) == 1 def test_distinct_items(): assert count_distinct_items(4, [\\"Apple\\", \\"Orange\\", \\"Banana\\", \\"Grapes\\"]) == 4 def test_all_case_variations(): assert count_distinct_items(3, [\\"Case\\", \\"case\\", \\"CASE\\"]) == 1 def test_trailing_leading_spaces(): assert count_distinct_items(3, [\\" Space\\", \\"Space \\", \\" Space \\"]) == 1","solution":"def count_distinct_items(n, items): Returns the number of distinct items after normalizing case and trimming spaces. :param n: Integer, the number of items. :param items: List of strings, names of the items. :return: Integer, the number of distinct normalized items. normalized_items = set() for item in items: normalized_item = item.strip().lower() normalized_items.add(normalized_item) return len(normalized_items)"},{"question":"def is_nice_array(arr: List[int]) -> bool: Given an array of integers, determine if it is a Nice Array or not. Args: - arr (List[int]): The array of integers. Returns: - bool: True if the array is a Nice Array, otherwise False. >>> is_nice_array([1, -2, 1]) True >>> is_nice_array([3, 1, -4, 0, 2]) True >>> is_nice_array([-1, 1, -1, 1]) False >>> is_nice_array([0, 0, 0]) True >>> is_nice_array([1, 2, 3]) False # your code here def nice_arrays(test_cases: List[List[int]]) -> List[str]: Determine if each array in the list of test cases is a Nice Array or not. Args: - test_cases (List[List[int]]): A list of lists, where each inner list represents test case. Returns: - List[str]: List of strings \\"YES\\" or \\"NO\\" for each respective test case. >>> nice_arrays([[3, 1, -4, 0, 2], [1, -1], [1, -2, 1], [-1, 1, -1, 1]]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] # your code here","solution":"def is_nice_array(arr): Given an array of integers, determine if it is a Nice Array or not. n = len(arr) if n < 3: return False # Check every combination of triplets in the array for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[i] + arr[j] + arr[k] == 0: return True return False def nice_arrays(test_cases): Determine if each array in the list of test cases is a Nice Array or not. Args: - test_cases (list): A list of lists, where each inner list represents test case. Returns: - list: List of strings \\"YES\\" or \\"NO\\" for each respective test case. results = [] for case in test_cases: if is_nice_array(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_balanced(expr: str) -> str: Checks if the given string of parentheses is balanced. :param expr: String containing '(', ')', '{', '}', '[' and ']' :return: \\"YES\\" if the parentheses are balanced, otherwise \\"NO\\" >>> is_balanced(\\"([]{})\\") \\"YES\\" >>> is_balanced(\\"([)]\\") \\"NO\\" >>> is_balanced(\\"((()))\\") \\"YES\\" >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"{[(])}\\") \\"NO\\" >>> is_balanced(\\"{{[[(())]]}}\\") \\"YES\\" >>> is_balanced(\\"}\\") \\"NO\\" >>> is_balanced(\\"{\\") \\"NO\\" def check_parentheses(T: int, expressions: List[str]) -> List[str]: Checks if the given strings of parentheses are balanced. :param T: Number of test cases :param expressions: List of strings containing '(', ')', '{', '}', '[' and ']' :return: List of strings \\"YES\\" or \\"NO\\" for each test case >>> check_parentheses(3, [\\"([]{})\\", \\"([)]\\", \\"((()))\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_parentheses(2, [\\"{[()]}\\", \\"{[(])}\\"]) [\\"YES\\", \\"NO\\"] >>> check_parentheses(1, [\\"{{[[(())]]}}\\"]) [\\"YES\\"]","solution":"def is_balanced(expr): Checks if the given string of parentheses is balanced. :param expr: String containing '(', ')', '{', '}', '[' and ']' :return: \\"YES\\" if the parentheses are balanced, otherwise \\"NO\\" stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in expr: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or stack.pop() != matching_parentheses[char]: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\" def check_parentheses(T, expressions): results = [] for expr in expressions: results.append(is_balanced(expr)) return results"},{"question":"def categorize_strength(word: str) -> str: Categorizes the strength of a string based on the sum of the position values of its characters. Arguments: word -- the input string consisting of lowercase English letters Returns: A string categorizing the strength: \\"Weak\\", \\"Moderate\\", or \\"Strong\\" # Your code here from solution import categorize_strength def test_categorize_strength_weak(): assert categorize_strength(\\"cat\\") == \\"Weak\\" assert categorize_strength(\\"dog\\") == \\"Weak\\" assert categorize_strength(\\"hi\\") == \\"Weak\\" def test_categorize_strength_moderate(): assert categorize_strength(\\"love\\") == \\"Moderate\\" assert categorize_strength(\\"house\\") == \\"Moderate\\" assert categorize_strength(\\"moderate\\") == \\"Moderate\\" def test_categorize_strength_strong(): assert categorize_strength(\\"friendship\\") == \\"Strong\\" assert categorize_strength(\\"strength\\") == \\"Strong\\" assert categorize_strength(\\"calculation\\") == \\"Strong\\"","solution":"def categorize_strength(word: str) -> str: Categorizes the strength of a string based on the sum of the position values of its characters. Arguments: word -- the input string consisting of lowercase English letters Returns: A string categorizing the strength: \\"Weak\\", \\"Moderate\\", or \\"Strong\\" # Calculate the strength based on the position values of characters strength = sum((ord(char) - ord('a') + 1) for char in word) # Categorize the strength if strength < 50: return \\"Weak\\" elif 50 <= strength <= 100: return \\"Moderate\\" else: return \\"Strong\\""},{"question":"def max_coins(grid): Calculate the maximum number of coins collected on the way from the top-left to the bottom-right cell of a grid. >>> max_coins([ >>> [0, 3, 1, 1], >>> [2, 0, 0, 4], >>> [1, 5, 3, 1] >>> ]) == 12 >>> max_coins([ >>> [0, 2, 3, 4] >>> ]) == 9 >>> max_coins([ >>> [1], >>> [2], >>> [3], >>> [4] >>> ]) == 10 >>> max_coins([ >>> [5] >>> ]) == 5 >>> max_coins([ >>> [1, 2, 3, 4], >>> [1, 1, 1, 1], >>> [2, 2, 2, 2], >>> [1, 1, 1, 1] >>> ]) == 14","solution":"def max_coins(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def maxDownwardPath(N: int, A: List[int]) -> int: Given an array of n integers where each value represents the height of a bridge segment, find the maximum number of contiguous bridge segments you can walk across while maintaining a downward or flat path. You should never step onto a bridge segment that is higher than the previous one. >>> maxDownwardPath(7, [5, 3, 3, 2, 4, 2, 1]) 4 >>> maxDownwardPath(5, [1, 2, 3, 4, 5]) 1 # Your implementation here pass","solution":"def maxDownwardPath(N, A): Returns the maximum number of contiguous downward or flat bridge segments. if N == 0: return 0 max_length = 1 current_length = 1 for i in range(1, N): if A[i] <= A[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def fib_even_sum(n): Returns the sum of the even-valued terms in the Fibonacci sequence whose values do not exceed the given integer n. >>> fib_even_sum(10) 10 >>> fib_even_sum(34) 44 >>> fib_even_sum(0) 0 >>> fib_even_sum(1) 0 >>> fib_even_sum(2) 2 >>> fib_even_sum(8) 10 >>> fib_even_sum(33) 10 >>> fib_even_sum(4000000) 4613732 >>> fib_even_sum(100) 44 pass","solution":"def fib_even_sum(n): Returns the sum of the even-valued terms in the Fibonacci sequence whose values do not exceed the given integer n. a, b = 0, 1 sum_even = 0 while a <= n: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even"},{"question":"def is_special_sequence(n: int, sequence: List[int]) -> str: Determines if the given sequence is a \\"Special Sequence\\" as per the defined criteria. A \\"Special Sequence\\" satisfies the following: 1. The sequence is strictly increasing. 2. The sequence can be divided into exactly two non-empty subsequences such that one subsequence contains only even numbers and the other subsequence contains only odd numbers. :param n: int - The number of elements in the sequence :param sequence: list of int - The elements of the sequence :return: str - \\"YES\\" if the sequence is a \\"Special Sequence\\", otherwise \\"NO\\" >>> is_special_sequence(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_special_sequence(4, [1, 3, 5, 7]) \\"NO\\" import pytest def test_special_sequence_case1(): assert is_special_sequence(5, [1, 2, 3, 4, 5]) == \\"YES\\" def test_special_sequence_case2(): assert is_special_sequence(4, [1, 3, 5, 7]) == \\"NO\\" def test_special_sequence_single_element(): assert is_special_sequence(1, [2]) == \\"NO\\" def test_special_sequence_not_increasing(): assert is_special_sequence(5, [1, 3, 2, 4, 5]) == \\"NO\\" def test_special_sequence_all_even(): assert is_special_sequence(4, [2, 4, 6, 8]) == \\"NO\\" def test_special_sequence_all_odd(): assert is_special_sequence(4, [1, 3, 5, 7]) == \\"NO\\" def test_special_sequence_mixed_even_odd(): assert is_special_sequence(6, [2, 4, 6, 1, 3, 5]) == \\"NO\\" def test_special_sequence_with_gaps(): assert is_special_sequence(5, [2, 4, 6, 10, 15]) == \\"YES\\"","solution":"def is_special_sequence(n, sequence): Determines if the given sequence is a \\"Special Sequence\\" as per the defined criteria. :param n: int - The number of elements in the sequence :param sequence: list of int - The elements of the sequence :return: str - \\"YES\\" if the sequence is a \\"Special Sequence\\", otherwise \\"NO\\" if n < 2: return \\"NO\\" even_numbers = [x for x in sequence if x % 2 == 0] odd_numbers = [x for x in sequence if x % 2 != 0] if len(even_numbers) == 0 or len(odd_numbers) == 0: return \\"NO\\" prev = -1 for num in sequence: if num <= prev: return \\"NO\\" prev = num return \\"YES\\""},{"question":"def largest_square_subgrid(t, test_cases): Determine the largest size of a square sub-grid where all the cells are filled with 1s. Args: t (int): the number of test cases test_cases (List[Tuple[int, int, List[str]]]): a list of test cases, where each test case is a tuple containing the number of rows (n), the number of columns (m), and a list of strings representing the grid of 1s and 0s. Returns: List[int]: a list of integers representing the size of the largest square sub-grid where all the cells are filled with 1s for each test case. Examples: >>> largest_square_subgrid(3, [ (5, 6, ['101111', '111111', '111111', '111111', '011111']), (4, 4, ['0110', '1111', '1111', '0110']), (3, 4, ['1111', '1111', '1111']) ]) [4, 2, 3] >>> largest_square_subgrid(1, [ (2, 2, ['01', '11']) ]) [1] pass","solution":"def largest_square_subgrid(t, test_cases): results = [] for test in test_cases: n, m, grid = test dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) results.append(max_side_length) return results"},{"question":"def max_sequence_length(A: int, B: int, D: int) -> int: Returns the maximum possible length of the sequence, where each sequence of points P satisfies the conditions: - P consists of integers between A and B (inclusive). - For each 1  i  |P|-1, P_{i+1} - P_i = D and P_{i+1} > P_i > 0. >>> max_sequence_length(5, 20, 3) 6 >>> max_sequence_length(1, 1, 2) 1 >>> max_sequence_length(1, 10, 2) 5 >>> max_sequence_length(1, 1000000000, 1) 1000000000 >>> max_sequence_length(1, 1000000000, 1000000) 1000 >>> max_sequence_length(10000, 1000000000, 999999999) 1 >>> max_sequence_length(100, 100, 1) 1","solution":"def max_sequence_length(A, B, D): Returns the maximum possible length of the sequence. # Find the first term in the sequence that is >= A and is in the form of a + kD k = 0 while A + k * D < A: k += 1 start = A + k * D if start > B: return 0 # last term in the range [A...B] that is in the form of A + kD end = B - (B - start) % D # find the length of the series from start to end with a common difference D length = (end - start) // D + 1 return length"},{"question":"def binary_search(arr, target): Performs binary search to find the target in the sorted array. Returns the index of the target if found, otherwise returns -1. >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) 6 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1","solution":"def binary_search(arr, target): Performs binary search to find the target in the sorted array. Returns the index of the target if found, otherwise returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def longest_periodic_substring(S: str) -> int: Given a string S, returns the length of the longest periodic substring. A substring is periodic if there exists a positive integer k such that the substring is obtained by repeating a smaller string of length k multiple times (k > 1). If no periodic substring exists, returns 0. Args: S: A string consisting of lowercase English letters. Returns: An integer representing the length of the longest periodic substring. Example: >>> longest_periodic_substring(\\"ababa\\") 4 >>> longest_periodic_substring(\\"aaaaaa\\") 6 >>> longest_periodic_substring(\\"abcdef\\") 0","solution":"def longest_periodic_substring(S): Returns the length of the longest periodic substring. If no periodic substring exists, returns 0. n = len(S) # Function to check if the given substring is periodic def is_periodic(sub): length = len(sub) for k in range(1, length // 2 + 1): if length % k == 0: if sub[:k] * (length // k) == sub: return True return False max_len = 0 for i in range(n): for j in range(i + 1, n + 1): if is_periodic(S[i:j]): max_len = max(max_len, j - i) return max_len"},{"question":"class Playlist: def __init__(self, songs): Initialize the Playlist with a list of song lengths. songs: List[int] - List of song lengths in seconds. def add(self, length): Add a song to the playlist. length: int - Length of the song in seconds. >>> pl = Playlist([]) >>> pl.add(300) >>> pl.duration() == 300 def remove(self, index): Remove a song from the playlist by its index. index: int - 0-based index of the song to be removed. >>> pl = Playlist([100, 200, 300]) >>> pl.remove(1) >>> pl.duration() == 400 def duration(self): Calculate the total duration of the playlist. Returns: int - Total length in seconds of all songs in the playlist. >>> pl = Playlist([120, 150, 180]) >>> pl.duration() == 450 # Unit Tests def test_playlist_operations(): pl = Playlist([120, 150, 180, 210, 240]) assert pl.duration() == 900 pl.add(300) assert pl.duration() == 1200 pl.remove(2) assert pl.duration() == 1020 pl.remove(0) assert pl.duration() == 900 def test_addition(): pl = Playlist([]) pl.add(100) assert pl.duration() == 100 pl.add(200) assert pl.duration() == 300 def test_removal(): pl = Playlist([100, 200, 300, 400]) pl.remove(1) # Removing 200 assert pl.duration() == 800 pl.remove(10) # Invalid index assert pl.duration() == 800 pl.remove(0) # Removing 100 assert pl.duration() == 700","solution":"class Playlist: def __init__(self, songs): self.songs = songs def add(self, length): self.songs.append(length) def remove(self, index): if 0 <= index < len(self.songs): self.songs.pop(index) def duration(self): return sum(self.songs)"},{"question":"def decrypt_caesar(encoded: str) -> str: Decrypts the given encoded string using a Caesar cipher with a shift of 3. :param encoded: String of digits encrypted with a shift of 3 :return: Decrypted original string of digits >>> decrypt_caesar(\\"67890\\") == \\"34567\\" >>> decrypt_caesar(\\"123\\") == \\"890\\"","solution":"def decrypt_caesar(encoded): Decrypts the given encoded string using a Caesar cipher with a shift of 3. :param encoded: String of digits encrypted with a shift of 3 :return: Decrypted original string of digits shift = 3 original = '' for char in encoded: original += str((int(char) - shift) % 10) return original"},{"question":"def sort_by_frequency(nums): Sorts the given list of numbers based on their frequency in ascending order. If two numbers have the same frequency, the smaller number comes first. >>> sort_by_frequency([4, 5, 6, 5, 4, 3]) == [3, 6, 4, 4, 5, 5] >>> sort_by_frequency([1]) == [1] >>> sort_by_frequency([2, 2, 2, 2]) == [2, 2, 2, 2] >>> sort_by_frequency([1, 1, 2, 2, 2, 3]) == [3, 1, 1, 2, 2, 2] >>> sort_by_frequency([10, 9, 8, 8, 9, 10, 10]) == [8, 8, 9, 9, 10, 10, 10] >>> sort_by_frequency([4, 6, 5, 5, 6, 4, 3, 7, 7, 7]) == [3, 4, 4, 5, 5, 6, 6, 7, 7, 7]","solution":"def sort_by_frequency(nums): Sorts the given list of numbers based on their frequency in ascending order. If two numbers have the same frequency, the smaller number comes first. # Dictionary to store the frequency of each number frequency_dict = {} for num in nums: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 # Sort the numbers primarily by their frequency and secondarily by their value sorted_nums = sorted(nums, key=lambda x: (frequency_dict[x], x)) return sorted_nums # Example usage # N = 6 # nums = [4, 5, 6, 5, 4, 3] # print(sort_by_frequency(nums)) # Output: [3, 6, 4, 4, 5, 5]"},{"question":"def lexicographically_smallest_string(n: int) -> str: Returns the lexicographically smallest string that contains exactly n distinct characters. The characters are lowercase English letters ('a' - 'z') and n is between 1 and 26 inclusive. >>> lexicographically_smallest_string(1) 'a' >>> lexicographically_smallest_string(3) 'abc' >>> lexicographically_smallest_string(5) 'abcde'","solution":"def lexicographically_smallest_string(n): Returns the lexicographically smallest string that contains exactly n distinct characters. The characters are lowercase English letters ('a' - 'z') and n is between 1 and 26 inclusive. return ''.join(chr(i) for i in range(ord('a'), ord('a') + n))"},{"question":"def next_week_difficulty(W: str) -> str: Given this week's wind strength W, return the event's difficulty level next week. >>> next_week_difficulty(\\"Low\\") == \\"Medium\\" >>> next_week_difficulty(\\"Medium\\") == \\"High\\" >>> next_week_difficulty(\\"High\\") == \\"Low\\"","solution":"def next_week_difficulty(W): Given this week's wind strength W, return the event's difficulty level next week. wind_strength = [\\"Low\\", \\"Medium\\", \\"High\\"] next_index = (wind_strength.index(W) + 1) % 3 return wind_strength[next_index]"},{"question":"def trailing_zeroes_in_factorial(n: int) -> int: Returns the number of trailing zeroes in the factorial of n. >>> trailing_zeroes_in_factorial(10) 2 >>> trailing_zeroes_in_factorial(25) 6 >>> trailing_zeroes_in_factorial(0) 0 >>> trailing_zeroes_in_factorial(1) 0 >>> trailing_zeroes_in_factorial(100) 24","solution":"def trailing_zeroes_in_factorial(n): Returns the number of trailing zeroes in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def count_unique_characters(n: int, s: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string of length n and m queries, determine the number of unique characters in the substring for each query. Args: n: Length of the string. s: The string consisting of lowercase English letters. queries: A list of tuples, each containing two integers (li, ri). Returns: List of integers where each integer corresponds to the number of unique characters in the substring for the given queries. >>> count_unique_characters(10, \\"abcabcabcx\\", [(1, 3), (2, 6), (1, 10)]) [3, 3, 4] >>> count_unique_characters(5, \\"aaaaa\\", [(1, 5), (2, 3)]) [1, 1]","solution":"def count_unique_characters(n, s, queries): results = [] for li, ri in queries: substring = s[li-1:ri] unique_characters = set(substring) results.append(len(unique_characters)) return results # Example usage: n = 10 s = \\"abcabcabcx\\" queries = [(1, 3), (2, 6), (1, 10)] print(count_unique_characters(n, s, queries))"},{"question":"def is_valid_preorder(preorder: List[int]) -> bool: Given an array of integers, determine whether the array represents a valid preorder traversal of a binary search tree (BST). A valid BST ensures that for every node, its left subtree contains only nodes with values less than the node's value, and its right subtree contains only nodes with values greater than the node's value. Examples: >>> is_valid_preorder([5, 2, 1, 3, 6]) True >>> is_valid_preorder([5, 2, 6, 1, 3]) False","solution":"def is_valid_preorder(preorder): Determine whether the array represents a valid preorder traversal of a BST. stack = [] lower_bound = float('-inf') for value in preorder: if value < lower_bound: return False while stack and value > stack[-1]: lower_bound = stack.pop() stack.append(value) return True"},{"question":"def count_common_unique_elements(arr1, arr2): Returns the count of unique elements that are present in both arrays. >>> count_common_unique_elements([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 5 >>> count_common_unique_elements([1, 1, 2, 2], [2, 3, 4, 5]) 1 >>> count_common_unique_elements([9, 8, 7], [7, 6, 5]) 1 >>> count_common_unique_elements([1, 2, 3], [4, 5, 6]) 0 >>> count_common_unique_elements([1, 1, 1, 1], [1, 1]) 1 >>> count_common_unique_elements([10, 20, 30, 40, 50], [20, 30, 60, 70]) 2 def count_common_elements_in_test_cases(t, test_cases): Processes multiple test cases and returns a list of results. >>> test_cases = [(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]), (4, [1, 1, 2, 2], [2, 3, 4, 5]), (3, [9, 8, 7], [7, 6, 5])] >>> count_common_elements_in_test_cases(3, test_cases) [5, 1, 1]","solution":"def count_common_unique_elements(arr1, arr2): Returns the count of unique elements that are present in both arrays. set1 = set(arr1) set2 = set(arr2) common_elements = set1.intersection(set2) return len(common_elements) def count_common_elements_in_test_cases(t, test_cases): Processes multiple test cases and returns a list of results. results = [] for case in test_cases: n, arr1, arr2 = case result = count_common_unique_elements(arr1, arr2) results.append(result) return results"},{"question":"def four_sum(nums, target): Find all unique quadruplets in the array which gives the sum of target. Args: nums: List[int] - List of integers. target: int - The target sum for quadruplets. Returns: List[List[int]] - List of unique quadruplets that add up to the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]]","solution":"def four_sum(nums, target): Find all unique quadruplets in the array which gives the sum of target. Args: nums: List[int] - List of integers. target: int - The target sum for quadruplets. Returns: List[List[int]] - List of unique quadruplets that add up to the target. nums.sort() # Sort the array to help with skipping duplicates quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates for i for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue # Skip duplicates for j left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def rotateArray(arr, k, dir): Rotate the array \`arr\` \`k\` times to the direction specified by \`dir\`. Parameters: arr (list): The array to rotate. k (int): The number of times to rotate. dir (str): The direction of rotation, either \\"left\\" or \\"right\\". Returns: list: The rotated array. Examples: >>> rotateArray([1, 2, 3, 4, 5, 6, 7, 8], 3, \\"left\\") [4, 5, 6, 7, 8, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5, 6, 7, 8], 2, \\"right\\") [7, 8, 1, 2, 3, 4, 5, 6] >>> rotateArray([], 5, \\"left\\") [] >>> rotateArray([1], 1000, \\"right\\") [1] >>> rotateArray([1, 2, 3, 4], 0, \\"right\\") [1, 2, 3, 4]","solution":"def rotateArray(arr, k, dir): Rotate the array \`arr\` \`k\` times to the direction specified by \`dir\`. Parameters: arr (list): The array to rotate. k (int): The number of times to rotate. dir (str): The direction of rotation, either \\"left\\" or \\"right\\". Returns: list: The rotated array. n = len(arr) if n == 0 or k == 0: return arr k = k % n # Optimize k if it's larger than n if dir == \\"left\\": return arr[k:] + arr[:k] elif dir == \\"right\\": return arr[-k:] + arr[:-k] else: raise ValueError(\\"Direction must be either 'left' or 'right'\\")"},{"question":"def shortest_palindrome_length(s: str) -> int: Returns the length of the shortest palindrome that can be obtained by adding the minimum number of characters at the beginning or end of the string. >>> shortest_palindrome_length(\\"abc\\") 5 >>> shortest_palindrome_length(\\"aabb\\") 6 pass def solve_palindrome_case(n: int, s: str) -> int: Given the length of the string and the string itself, returns the length of the shortest palindrome that can be obtained by adding the minimum number of characters. >>> solve_palindrome_case(3, \\"abc\\") 5 >>> solve_palindrome_case(4, \\"aabb\\") 6 return shortest_palindrome_length(s) def solve(t: int, testcases: list) -> list: Given the number of testcases and list of testcases where each testcase is a tuple of length of the string and the string itself, returns a list of results where each result is the length of the shortest palindrome that can be obtained. >>> solve(2, [(3, \\"abc\\"), (4, \\"aabb\\")]) [5, 6] results = [] for i in range(t): n, s = testcases[i] results.append(solve_palindrome_case(n, s)) return results","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be obtained by adding the minimum number of characters at the beginning or end of the string. n = len(s) # Check if the string is already a palindrome if s == s[::-1]: return n rev_s = s[::-1] # Find the longest prefix which is also suffix for i in range(n): if s[i:] == rev_s[:n-i]: return 2 * n - (n - i) # All characters are different, we need to attach the whole reverse of the string return 2 * n def solve_palindrome_case(n, s): return shortest_palindrome_length(s) def solve(t, testcases): results = [] for i in range(t): n, s = testcases[i] results.append(solve_palindrome_case(n, s)) return results"},{"question":"def generate_sequence(m: int) -> list: Generates a sequence of integers from 1 to m with substitutions: - \\"Fizz\\" for numbers divisible by 3, - \\"Buzz\\" for numbers divisible by 5, - \\"FizzBuzz\\" for numbers divisible by both 3 and 5. Args: m: An integer representing the end of the sequence (inclusive). Returns: A list with the generated sequence of integers with the respective substitutions. Examples: >>> generate_sequence(5) ['1', '2', 'Fizz', '4', 'Buzz'] >>> generate_sequence(15) ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']","solution":"def generate_sequence(m): Generates a sequence of integers from 1 to m with substitutions: - \\"Fizz\\" for numbers divisible by 3, - \\"Buzz\\" for numbers divisible by 5, - \\"FizzBuzz\\" for numbers divisible by both 3 and 5. Params: m (int): The end of the sequence (inclusive). Returns: list: The generated list with substitutions. result = [] for i in range(1, m + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def alternateOrder(arr): This function takes an array of integers representing heights and arranges them in an alternating increasing-decreasing order fashion. Parameters: arr (list[int]): The array of integers representing heights. Returns: list[int]: The array reordered to alternate between increasing and decreasing heights. Example: >>> alternateOrder([5, 1, 3, 2, 4]) [1, 5, 2, 4, 3] >>> alternateOrder([8, 6, 4, 2, 10]) [2, 10, 4, 8, 6]","solution":"def alternateOrder(arr): This function takes an array of integers representing heights and arranges them in an alternating increasing-decreasing order fashion. Parameters: arr (list[int]): The array of integers representing heights. Returns: list[int]: The array reordered to alternate between increasing and decreasing heights. arr.sort() result = [] left, right = 0, len(arr) - 1 while left <= right: if left != right: result.append(arr[left]) result.append(arr[right]) else: result.append(arr[left]) left += 1 right -= 1 return result"},{"question":"def running_statistics(n, distances): Returns the total distance run by Jason, the maximum distance run in a single day, and the one-based index of the first day Jason ran the maximum distance. >>> running_statistics(5, [3, 7, 2, 7, 5]) (24, 7, 2) >>> running_statistics(4, [5, 5, 5, 5]) (20, 5, 1)","solution":"def running_statistics(n, distances): Returns the total distance run by Jason, the maximum distance run in a single day, and the one-based index of the first day Jason ran the maximum distance. Parameters: n (int): the number of days distances (list of int): the distances run each day Returns: tuple: total distance, max distance, first day of max distance total_distance = sum(distances) max_distance = max(distances) first_max_index = distances.index(max_distance) + 1 # converting to one-based index return total_distance, max_distance, first_max_index"},{"question":"def build_supplier_dict(n: int, supplier_data: list) -> dict: Build a dictionary where each key is a supplier code and each value is another dictionary with product codes as keys and prices as values. pass def query_prices(n: int, q: int, supplier_data: list, queries: list) -> list: Answer multiple queries about the availability and pricing of products from suppliers. For each query, return the price at which the supplier provides the product or \\"NOT AVAILABLE\\" if the supplier does not provide the product. >>> supplier_data = [ 1, 2, 1002, 150, 1003, 200, 2, 3, 1001, 300, 1002, 250, 1003, 350 ] >>> queries = [ (1002, 1), (1003, 1), (1001, 2) ] >>> query_prices(2, 3, supplier_data, queries) [150, 200, 300] >>> queries = [ (1004, 1), (1001, 3), (1002, 2) ] >>> query_prices(2, 3, supplier_data, queries) [\\"NOT AVAILABLE\\", \\"NOT AVAILABLE\\", 250] pass","solution":"def build_supplier_dict(n, supplier_data): supplier_dict = {} index = 0 for i in range(n): supplier_code = supplier_data[index] index += 1 m = supplier_data[index] index += 1 products = {} for _ in range(m): product_code, price = supplier_data[index], supplier_data[index + 1] products[product_code] = price index += 2 supplier_dict[supplier_code] = products return supplier_dict def query_prices(n, q, supplier_data, queries): supplier_dict = build_supplier_dict(n, supplier_data) results = [] for product_code, supplier_code in queries: if supplier_code in supplier_dict and product_code in supplier_dict[supplier_code]: results.append(supplier_dict[supplier_code][product_code]) else: results.append(\\"NOT AVAILABLE\\") return results"},{"question":"def find_k_dominators(nums: list[int], k: int) -> list[int]: Returns a sorted list of k-dominators from the input list nums. An integer x in nums is called a \\"k-dominator\\" if there are at most k elements in nums greater than x. Args: nums: list of integers k: integer specifying the maximum number of elements that can be greater than the dominator Returns: list of k-dominators in increasing order. Examples: >>> find_k_dominators([3, 1, 4, 1, 5, 9, 2, 6, 5, 3], 2) [5, 6, 9] >>> find_k_dominators([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 0) [100] >>> find_k_dominators([1, 2, 3, 4, 5], 4) [1, 2, 3, 4, 5] >>> find_k_dominators([-10, -20, -30, -40, -50, -60, -70, -80, -90, -100], 2) [-30, -20, -10] >>> find_k_dominators([-1, 0, 1, 2, -2], 1) [1, 2]","solution":"def find_k_dominators(nums, k): Returns a sorted list of k-dominators from the input list nums. Args: nums: List[int] - list of integers. k: int - integer specifying the maximum number of elements that can be greater than the dominator. Returns: List[int] - sorted list of k-dominators. nums.sort() n = len(nums) result = [nums[i] for i in range(n - k - 1, n)] return result"},{"question":"def min_operations_to_all_ones(N: int, A: List[int]) -> int: Determines the minimum number of operations required to make all elements in the array equal to 1, or returns -1 if impossible. >>> min_operations_to_all_ones(4, [0, 1, 0, 1]) 2 >>> min_operations_to_all_ones(3, [0, 0, 0]) -1","solution":"def min_operations_to_all_ones(N, A): Determines the minimum number of operations required to make all elements in the array equal to 1, or returns -1 if impossible. Parameters: N (int): The number of elements in the array. A (list of int): The list of elements in the array, where each element is 0 or 1. Returns: int: The minimum number of operations required, or -1 if impossible. # If there are no \`1\`s in the array, it is impossible to make all elements 1 if all(a == 0 for a in A): return -1 # Count the number of 0s in the array count_zeros = A.count(0) # If there are no zeros, no operations are required if count_zeros == 0: return 0 # The minimum number of operations needed is equal to the number of 0s return count_zeros"},{"question":"def is_even_sum_path_exists(grid): Determine if there's a path from the top-left to the bottom-right corner of the grid with an even sum. >>> is_even_sum_path_exists([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"NO\\" >>> is_even_sum_path_exists([[2, 3], [4, 5]]) \\"YES\\" >>> is_even_sum_path_exists([[1]]) \\"NO\\" >>> is_even_sum_path_exists([[2]]) \\"YES\\" >>> is_even_sum_path_exists([[1, 1], [2, 2]]) \\"YES\\" >>> is_even_sum_path_exists([[0, 0], [0, 0]]) \\"YES\\"","solution":"def is_even_sum_path_exists(grid): n = len(grid) m = len(grid[0]) # A DP table to store the parity of the sum of numbers from (0,0) to (i,j) even_dp = [[False]*m for _ in range(n)] odd_dp = [[False]*m for _ in range(n)] if grid[0][0] % 2 == 0: even_dp[0][0] = True else: odd_dp[0][0] = True for i in range(n): for j in range(m): if i > 0: if even_dp[i-1][j]: if grid[i][j] % 2 == 0: even_dp[i][j] = True else: odd_dp[i][j] = True if odd_dp[i-1][j]: if grid[i][j] % 2 == 0: odd_dp[i][j] = True else: even_dp[i][j] = True if j > 0: if even_dp[i][j-1]: if grid[i][j] % 2 == 0: even_dp[i][j] = True else: odd_dp[i][j] = True if odd_dp[i][j-1]: if grid[i][j] % 2 == 0: odd_dp[i][j] = True else: even_dp[i][j] = True return \\"YES\\" if even_dp[n-1][m-1] else \\"NO\\""},{"question":"def can_partition(nums): Determine if it is possible to divide the list into two non-empty subsequences such that the sum of the elements in each subsequence is the same. >>> can_partition([1, 5, 11, 5]) == \\"YES\\" >>> can_partition([1, 2, 3, 5]) == \\"NO\\" pass def process_test_cases(test_cases): Processes multiple test cases and determines if each case can be partitioned into two subsequences with equal sum. >>> test_cases = [(5, 1, 5, 11, 5), (4, 1, 2, 3, 5)] >>> results = process_test_cases(test_cases) >>> results == [\\"YES\\", \\"NO\\"] pass def main(T, cases): Reads the number of test cases and the cases themselves, and prints the results for each case. >>> T = 2 >>> cases = [(5, 1, 5, 11, 5), (4, 1, 2, 3, 5)] >>> main(T, cases) YES NO pass def test_can_partition(): assert can_partition([1, 5, 11, 5]) == \\"YES\\" assert can_partition([1, 2, 3, 5]) == \\"NO\\" assert can_partition([1, 1, 1, 1, 2, 2]) == \\"YES\\" assert can_partition([2, 3, 5, 8]) == \\"NO\\" assert can_partition([3, 3, 3, 3]) == \\"YES\\" assert can_partition([1]) == \\"NO\\" assert can_partition([1000000, 1000000]) == \\"YES\\" assert can_partition([1, 2, 4, 8, 16]) == \\"NO\\" def test_process_test_cases(): test_cases = [ (5, 1, 5, 11, 5), (4, 1, 2, 3, 5), ] results = process_test_cases(test_cases) assert results == [\\"YES\\", \\"NO\\"] def test_main(capsys): T = 2 cases = [ (5, 1, 5, 11, 5), (4, 1, 2, 3, 5), ] main(T, cases) captured = capsys.readouterr() output = captured.out.split('n')[:-1] # Remove trailing empty string split by the last newline assert output == [\\"YES\\", \\"NO\\"]","solution":"def can_partition(nums): total_sum = sum(nums) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return \\"YES\\" if dp[target] else \\"NO\\" def process_test_cases(test_cases): results = [] for case in test_cases: N, *nums = case results.append(can_partition(nums)) return results def main(T, cases): results = process_test_cases(cases) for result in results: print(result)"},{"question":"def longest_even_length_palindrome(S: str) -> int: Returns the length of the longest even-length palindromic substring in the input string S. Args: S (str): The input string. Returns: int: The length of the longest even-length palindromic substring. >>> longest_even_length_palindrome(\\"abbaacc\\") 4 >>> longest_even_length_palindrome(\\"abcd\\") 0","solution":"def longest_even_length_palindrome(S: str) -> int: Returns the length of the longest even-length palindromic substring in the input string S. def is_palindrome(sub): Check if a substring is a palindrome. return sub == sub[::-1] max_len = 0 L = len(S) for i in range(L): for j in range(i + 1, L + 1): sub = S[i:j] if len(sub) % 2 == 0 and is_palindrome(sub): max_len = max(max_len, len(sub)) return max_len"},{"question":"def generate_pattern(n: int) -> str: Generates the pattern for the given integer N. >>> generate_pattern(1) \\"123456\\" >>> generate_pattern(2) \\"123456 654321\\" >>> generate_pattern(3) \\"123456 654321 123456\\" def exhibition_patterns(test_cases: List[int]) -> List[str]: Processes the patterns for multiple test cases. >>> exhibition_patterns([1]) [\\"123456\\"] >>> exhibition_patterns([2]) [\\"123456 654321\\"] >>> exhibition_patterns([3]) [\\"123456 654321 123456\\"] >>> exhibition_patterns([1, 2, 3]) [\\"123456\\", \\"123456 654321\\", \\"123456 654321 123456\\"] >>> exhibition_patterns([4]) [\\"123456 654321 123456 654321\\"]","solution":"def generate_pattern(n): Generates the pattern for the given integer N. pattern1 = \\"123456\\" pattern2 = \\"654321\\" pattern_list = [] for i in range(n): if i % 2 == 0: pattern_list.append(pattern1) else: pattern_list.append(pattern2) return \\" \\".join(pattern_list) def exhibition_patterns(test_cases): Processes the patterns for multiple test cases. results = [] for n in test_cases: result = generate_pattern(n) results.append(result) return results"},{"question":"class ArrayManipulator: def __init__(self, arr): self.arr = arr def increment(self, l, r, x): Increment each element in the subarray from index l to index r (inclusive) by x. for i in range(l - 1, r): self.arr[i] += x def max_in_subarray(self, l, r): Return the maximum value in the subarray from index l to index r (inclusive). return max(self.arr[l - 1:r]) def process_operations(n, q, array, operations): Process a series of operations on an array. Args: n : int : size of the array q : int : number of operations array : List[int] : initial values of the array operations : List[List[int]]: list of operations Returns: List[int] : results of the maximum value queries >>> process_operations(5, 4, [1, 2, 3, 4, 5], [[1, 1, 3, 2], [2, 2, 4], [1, 2, 5, 3], [2, 1, 5]]) [5, 8] >>> process_operations(5, 0, [1, 2, 3, 4, 5], []) []","solution":"class ArrayManipulator: def __init__(self, arr): self.arr = arr def increment(self, l, r, x): for i in range(l - 1, r): self.arr[i] += x def max_in_subarray(self, l, r): return max(self.arr[l - 1:r]) def process_operations(n, q, array, operations): am = ArrayManipulator(array) results = [] for op in operations: if op[0] == 1: _, l, r, x = op am.increment(l, r, x) elif op[0] == 2: _, l, r = op results.append(am.max_in_subarray(l, r)) return results"},{"question":"def findAnagrams(words: List[str], target: str) -> List[str]: Returns a list of words from the input list that are anagrams of the target word. >>> findAnagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"golem\\"], \\"tinsel\\") [\\"listen\\", \\"silent\\", \\"enlist\\"] >>> findAnagrams([\\"rat\\", \\"tar\\", \\"art\\", \\"car\\"], \\"star\\") [] >>> findAnagrams([], \\"star\\") []","solution":"def findAnagrams(words, target): Returns a list of words from the input list that are anagrams of the target word. Parameters: words (list of str): The list of words to search through. target (str): The target word to find anagrams of. Returns: list of str: A list of anagrams of the target word from the input list. sorted_target = sorted(target) anagrams = [word for word in words if sorted(word) == sorted_target] return anagrams"},{"question":"def count_mountain_segments(N: int, heights: List[int]) -> int: Determine the number of mountain segments in the given array of heights. A \\"mountain segment\\" is defined as a contiguous subarray of heights where a segment first strictly increases to a peak and then strictly decreases thereafter. Args: N (int): The number of elements in the array heights. heights (List[int]): The array of integers representing the heights of the mountains. Returns: int: The number of valid mountain segments. >>> count_mountain_segments(10, [2, 1, 4, 7, 3, 2, 5, 6, 4, 3]) 2 >>> count_mountain_segments(5, [2, 2, 2, 2, 2]) 0","solution":"def count_mountain_segments(N, heights): count = 0 i = 1 while i < N - 1: # Check if heights[i] is a peak if heights[i - 1] < heights[i] and heights[i] > heights[i + 1]: # At this point, we found a peak, now traverse back to find the start of the segment left = i - 1 while left > 0 and heights[left - 1] < heights[left]: left -= 1 # Traverse ahead to find the end of the segment right = i + 1 while right < N - 1 and heights[right] > heights[right + 1]: right += 1 # This segment from left to right is a mountain segment count += 1 i = right # Move \`i\` to the end of the current mountain segment else: i += 1 return count"},{"question":"def can_arrange_paintings(datasets: List[str]) -> List[str]: Determine whether the paintings can be arranged on the walls without exceeding the height of the walls. Each dataset is a string in the following format: H W p1_w p1_h p2_w p2_h ... pn_w pn_h - H (1  H  100) is the height of the walls. - W (1  W  10^5) is the maximum sum of the widths of the paintings that can fit on the walls. - pi_w (1  pi_w  1000) and pi_h (1  pi_h  1000) represent the width and height of each painting. >>> can_arrange_paintings([\\"70 2000 100 50 300 70 150 60\\", \\"80 1500 600 70 300 80 400 90\\", \\"90 1000 500 100 600 80\\", \\"100 2500 500 90 900 70 800 100\\"]) [\\"Possible\\", \\"Impossible\\", \\"Impossible\\", \\"Possible\\"] >>> can_arrange_paintings([\\"70 2000 100 50 300 70 150 80\\", \\"90 1000 500 100 600 90\\"]) [\\"Impossible\\", \\"Impossible\\"] >>> can_arrange_paintings([\\"80 1500 600 70 300 80 700 70 600 70\\", \\"90 500 300 80 300 80\\"]) [\\"Impossible\\", \\"Impossible\\"] >>> can_arrange_paintings([\\"1 10000 1000 1 1000 1 1000 1 1000 1 1000 1 1000 1 1000 1\\", \\"100 1 100 90\\"]) [\\"Possible\\", \\"Impossible\\"]","solution":"def can_arrange_paintings(datasets): results = [] for dataset in datasets: # Parse the input data = dataset.split() wall_height = int(data[0]) max_total_width = int(data[1]) paintings = list(zip(map(int, data[2::2]), map(int, data[3::2]))) total_width = 0 possible = True # Check if each painting can fit in the wall height for width, height in paintings: if height > wall_height: possible = False break total_width += width if possible and total_width <= max_total_width: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"from typing import List def process_transactions(transactions: List[str]) -> int: Processes a list of transactions and returns the final account balance. Initially, the account balance is zero. The function takes a list of transactions as input. Each transaction is a string either representing a deposit or a withdrawal. A deposit is written as \\"D <amount>\\" where <amount> is a positive integer. A withdrawal is written as \\"W <amount>\\" where <amount> is a positive integer. The function should return the final balance after processing all transactions in the list. If at any point a withdrawal causes the balance to become negative, the transaction should be ignored and the balance remains unchanged. >>> process_transactions([\\"D 300\\", \\"W 200\\", \\"D 100\\", \\"W 500\\"]) 200 >>> process_transactions([\\"D 100\\", \\"W 100\\"]) 0 >>> process_transactions([\\"D 100\\", \\"W 200\\"]) 100","solution":"from typing import List def process_transactions(transactions: List[str]) -> int: Processes a list of transactions and returns the final account balance. balance = 0 for transaction in transactions: action, amount = transaction.split() amount = int(amount) if action == \\"D\\": balance += amount elif action == \\"W\\": if balance >= amount: balance -= amount return balance"},{"question":"def largest_palindromic_product(n: int) -> int: Finds the largest palindromic number made from the product of two n-digit numbers. >>> largest_palindromic_product(1) 9 >>> largest_palindromic_product(2) 9009 >>> largest_palindromic_product(3) 906609 >>> largest_palindromic_product(4) 99000099","solution":"def largest_palindromic_product(n: int) -> int: Finds the largest palindromic number made from the product of two n-digit numbers. def is_palindrome(x): s = str(x) return s == s[::-1] max_product = 0 lower_limit = 10**(n-1) upper_limit = 10**n - 1 for i in range(upper_limit, lower_limit - 1, -1): for j in range(i, lower_limit - 1, -1): product = i * j if product <= max_product: break if is_palindrome(product): max_product = product return max_product"},{"question":"def max_points(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum number of points collectable from any contiguous subsegment for each test case. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of slots and the list of points for those slots. Returns: List[int]: A list containing the maximum points collectable from any contiguous subsegment for each test case. Example: >>> t = 3 >>> test_cases = [ ... (8, [1, -2, 3, 4, -1, 2, 1, -5]), ... (5, [-2, -3, -4, -1, -2]), ... (6, [-1, 2, 3, -2, 3, 4]) ... ] >>> max_points(t, test_cases) [9, -1, 10]","solution":"def max_points(t, test_cases): Returns the maximum number of points collectable from any contiguous subsegment for each test case. results = [] for n, points in test_cases: # Function to find the maximum subarray sum using Kadane's algorithm def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for point in arr[1:]: max_ending_here = max(point, max_ending_here + point) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Apply Kadane's algorithm to find the maximum subarray sum results.append(max_subarray_sum(points)) return results"},{"question":"def is_prime(n: int) -> bool: Determine if a given non-negative integer is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True"},{"question":"def library_management(books, action, book_title): Manages the borrowing and return of books in a library. Parameters: books (list): A list of dictionaries each with 'title' and 'status' keys. action (str): The action to be performed, either 'borrow' or 'return'. book_title (str): The title of the book on which action is to be performed. Returns: list, str: The updated list of books after performing the action, or a message if the action cannot be fulfilled. Example: >>> library_management( ... [{'title': '1984', 'status': 'available'}, ... {'title': 'Brave New World', 'status': 'borrowed'}], 'borrow', '1984') [{'title': '1984', 'status': 'borrowed'}, {'title': 'Brave New World', 'status': 'borrowed'}] >>> library_management( ... [{'title': '1984', 'status': 'available'}, ... {'title': 'Brave New World', 'status': 'borrowed'}], 'return', 'Brave New World') [{'title': '1984', 'status': 'available'}, {'title': 'Brave New World', 'status': 'available'}] >>> library_management( ... [{'title': '1984', 'status': 'available'}, ... {'title': 'Brave New World', 'status': 'available'}], 'borrow', 'To Kill a Mockingbird') 'The book \\"To Kill a Mockingbird\\" does not exist in the library.'","solution":"def library_management(books, action, book_title): Manages the borrowing and return of books in a library. Parameters: books (list): A list of dictionaries each with 'title' and 'status' keys. action (str): The action to be performed, either 'borrow' or 'return'. book_title (str): The title of the book on which action is to be performed. Returns: list, str: The updated list of books after performing the action, or a message if the action cannot be fulfilled. for book in books: if book['title'] == book_title: if action == 'borrow': if book['status'] == 'available': book['status'] = 'borrowed' return books else: return f'The book \\"{book_title}\\" is already borrowed.' elif action == 'return': if book['status'] == 'borrowed': book['status'] = 'available' return books else: return f'The book \\"{book_title}\\" is already available.' return f'The book \\"{book_title}\\" does not exist in the library.'"},{"question":"def is_balanced(s: str) -> bool: Helper function that checks if a single string s is properly nested and balanced. def check_brackets(n: int, strings: List[str]) -> List[str]: Determine whether each string in the list is properly nested and balanced. Args: n : int : The number of test cases strings : List[str] : A list of strings containing brackets Returns: List[str] : A list of \\"YES\\" or \\"NO\\" for each string, indicating if the string is properly nested and balanced. >>> check_brackets(3, [\\"([]{})\\", \\"([)]\\", \\"({}[()])\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_brackets(1, [\\"([)]\\"]) [\\"NO\\"] from solution import check_brackets def test_check_brackets_single_valid_case(): assert check_brackets(1, [\\"([]{})\\"]) == [\\"YES\\"] def test_check_brackets_single_invalid_case(): assert check_brackets(1, [\\"([)]\\"]) == [\\"NO\\"] def test_check_brackets_multiple_cases(): assert check_brackets(3, [\\"([]{})\\", \\"([)]\\", \\"({}[()])\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_check_brackets_empty_string(): assert check_brackets(1, [\\"\\"]) == [\\"YES\\"] def test_check_brackets_single_type_of_bracket(): assert check_brackets(2, [\\"()\\", \\"((()))\\"]) == [\\"YES\\", \\"YES\\"] def test_check_brackets_unbalanced_open_brackets(): assert check_brackets(1, [\\"(((((\\"]) == [\\"NO\\"] def test_check_brackets_unbalanced_close_brackets(): assert check_brackets(1, [\\")))))\\"]) == [\\"NO\\"] def test_check_brackets_interleaved_brackets(): assert check_brackets(1, [\\"({[)]}\\"]) == [\\"NO\\"] def test_check_brackets_large_input(): long_balanced_string = \\"()\\" * (10**5 // 2) long_unbalanced_string = \\"(\\" * (10**5 // 2) assert check_brackets(2, [long_balanced_string, long_unbalanced_string]) == [\\"YES\\", \\"NO\\"]","solution":"def is_balanced(s): Helper function that checks if a single string s is properly nested and balanced. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in '({[': stack.append(char) elif char in ')}]': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack def check_brackets(n, strings): Returns a list of \\"YES\\" or \\"NO\\" for each string, indicating if the string is properly nested and balanced. results = [] for string in strings: if is_balanced(string): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from buying and selling one book. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling one book. :param prices: List of integers representing the price of a book on each day. :return: Integer representing the maximum profit. If no profit is possible, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price if price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def browser_history(operations: List[str]) -> List[str]: Simulates a simplified web browser history. :param operations: List of operations as provided in the problem statement. :return: List of results for \\"current\\" operations. pass # Example usage: # browser_history([\\"visit google.com\\", \\"visit youtube.com\\", \\"back 1\\", \\"current\\", \\"current\\"]) # Should return: [\\"google.com\\", \\"google.com\\"] # Unit Tests def test_browser_history_case_1(): operations = [ \\"visit google.com\\", \\"visit youtube.com\\", \\"back 1\\", \\"current\\", \\"current\\" ] assert browser_history(operations) == [\\"google.com\\", \\"google.com\\"] def test_browser_history_case_2(): operations = [ \\"visit leetcode.com\\", \\"visit github.com\\", \\"visit stackoverflow.com\\", \\"back 2\\", \\"visit gfg.com\\", \\"current\\" ] assert browser_history(operations) == [\\"gfg.com\\"] def test_browser_history_initial(): operations = [ \\"current\\" ] assert browser_history(operations) == [\\"homepage\\"] def test_browser_history_back_more_than_available(): operations = [ \\"visit a.com\\", \\"visit b.com\\", \\"back 10\\", \\"current\\" ] assert browser_history(operations) == [\\"homepage\\"] def test_browser_history_mixed_operations(): operations = [ \\"visit e.com\\", \\"visit f.com\\", \\"back 1\\", \\"visit g.com\\", \\"current\\", \\"back 2\\", \\"current\\", \\"visit h.com\\", \\"current\\" ] assert browser_history(operations) == [\\"g.com\\", \\"homepage\\", \\"h.com\\"]","solution":"def browser_history(operations): Simulates a simplified web browser history. :param operations: List of operations as provided in the problem statement. :return: List of results for \\"current\\" operations. history = [\\"homepage\\"] current = 0 output = [] for op in operations: if op.startswith(\\"visit\\"): url = op.split(\\" \\")[1] history = history[:current + 1] history.append(url) current += 1 elif op.startswith(\\"back\\"): steps = int(op.split(\\" \\")[1]) current = max(0, current - steps) elif op.startswith(\\"current\\"): output.append(history[current]) return output"},{"question":"def validate_ticket_serial(serial: str) -> str: Validates a ticket serial number based on the given criteria. - It must contain exactly one upper-case English letter ('A'-'Z'). - It must contain at least one digit ('0'-'9'). - It must contain only alphanumeric characters (letters and digits). >>> validate_ticket_serial(\\"A1b2c3\\") \\"VALID\\" >>> validate_ticket_serial(\\"A12345\\") \\"VALID\\" >>> validate_ticket_serial(\\"abc123\\") \\"INVALID\\" >>> validate_ticket_serial(\\"XYZ1234\\") \\"INVALID\\" >>> validate_ticket_serial(\\"A1b2!@\\") \\"INVALID\\" >>> validate_ticket_serial(\\"\\") \\"INVALID\\" >>> validate_ticket_serial(\\"A\\" * 101) \\"INVALID\\" >>> validate_ticket_serial(\\"A0\\") \\"VALID\\" >>> validate_ticket_serial(\\"A\\" * 100) \\"INVALID\\"","solution":"def validate_ticket_serial(serial): Validates a ticket serial number based on the given criteria. - It must contain exactly one upper-case English letter ('A'-'Z'). - It must contain at least one digit ('0'-'9'). - It must contain only alphanumeric characters (letters and digits). if not (1 <= len(serial) <= 100): return \\"INVALID\\" num_upper = sum(1 for c in serial if c.isupper()) contains_digit = any(c.isdigit() for c in serial) is_alphanumeric = serial.isalnum() if num_upper == 1 and contains_digit and is_alphanumeric: return \\"VALID\\" else: return \\"INVALID\\""},{"question":"def sum_of_unique_elements(arr): Returns the sum of all unique elements in the array. A unique element is an element that appears exactly once in the array. >>> sum_of_unique_elements([1, 2, 3, 4, 5]) 15 >>> sum_of_unique_elements([1, 2, 2, 3, 4]) 8 >>> sum_of_unique_elements([2, 2, 3, 3, 4, 4]) 0 >>> sum_of_unique_elements([10, 20, 30, 40, 50]) 150 >>> sum_of_unique_elements([-1, -2, -2, -3, -4]) -8 >>> sum_of_unique_elements([-1, -2, -2, 3, 4]) 6 >>> sum_of_unique_elements([1]) 1 >>> sum_of_unique_elements([0]) 0 >>> sum_of_unique_elements([-1]) -1","solution":"def sum_of_unique_elements(arr): Returns the sum of all unique elements in the array. from collections import Counter # Count the frequency of each element in the array element_counts = Counter(arr) # Compute the sum of elements that appear exactly once unique_sum = sum(el for el, count in element_counts.items() if count == 1) return unique_sum"},{"question":"def generate_diagonal_matrix(n: int, diag_values: List[int]) -> List[List[int]]: Generates an n x n diagonal matrix with given diagonal values. Args: n (int): The order of the matrix. diag_values (list of int): The values to place on the diagonal. Returns: list of list of int: The n x n diagonal matrix. >>> generate_diagonal_matrix(3, [2, 5, 7]) [[2, 0, 0], [0, 5, 0], [0, 0, 7]] >>> generate_diagonal_matrix(1, [9]) [[9]]","solution":"def generate_diagonal_matrix(n, diag_values): Generates an n x n diagonal matrix with given diagonal values. Args: n (int): The order of the matrix. diag_values (list of int): The values to place on the diagonal. Returns: list of list of int: The n x n diagonal matrix. # Initialize the matrix with zeros matrix = [[0] * n for _ in range(n)] # Place the diagonal values in the matrix for i in range(n): matrix[i][i] = diag_values[i] return matrix"},{"question":"def transform_string(k: int, s: str) -> str: Transforms the string s by shifting each character k lexicographical positions. >>> transform_string(3, 'abc') 'def' >>> transform_string(1, 'xyz') 'yza' import string from typing import List, Tuple def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases and returns the results. >>> process_test_cases(2, [(3, 'abc'), (1, 'xyz')]) ['def', 'yza'] >>> process_test_cases(2, [(26, 'abc'), (0, 'abc')]) ['abc', 'abc'] def test_transform_string(): assert transform_string(3, 'abc') == 'def' assert transform_string(1, 'xyz') == 'yza' assert transform_string(26, 'abc') == 'abc' assert transform_string(0, 'abc') == 'abc' assert transform_string(27, 'abc') == 'bcd' def test_process_test_cases(): test_cases = [(3, 'abc'), (1, 'xyz')] expected_results = ['def', 'yza'] assert process_test_cases(2, test_cases) == expected_results test_cases = [(26, 'abc'), (0, 'abc')] expected_results = ['abc', 'abc'] assert process_test_cases(2, test_cases) == expected_results test_cases = [(27, 'abc'), (52, 'xyz')] expected_results = ['bcd', 'xyz'] assert process_test_cases(2, test_cases) == expected_results","solution":"def transform_string(k, s): Transforms the string s by shifting each character k lexicographical positions. k = k % 26 # To handle large values of K and keep it within the alphabet range result = [] for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) result.append(new_char) return \\"\\".join(result) def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. results = [] for k, s in test_cases: result = transform_string(k, s) results.append(result) return results"},{"question":"from typing import List, Tuple def minimum_difference_group_wealth(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: You are given a list of integers representing the amount of money people have and you need to divide them into groups such that the difference between the wealthiest and the poorest person in each group is minimized. Each group must contain exactly \`k\` people. If it is not possible to form such groups, output -1. Returns a list of the smallest possible difference between the wealthiest and the poorest person in any group of \`k\` people for each test case. >>> minimum_difference_group_wealth([(5, 3, [1, 9, 6, 4, 3])]) [3] >>> minimum_difference_group_wealth([(7, 4, [1, 2, 3, 4, 5, 6, 7])]) [3] >>> minimum_difference_group_wealth([(3, 4, [1, 2, 3])]) [-1] >>> minimum_difference_group_wealth([(10, 10, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100])]) [90] >>> minimum_difference_group_wealth([(6, 2, [3, 3, 4, 5, 7, 8])]) [0] >>> minimum_difference_group_wealth([(5, 3, [5, 5, 5, 5, 5])]) [0]","solution":"def minimum_difference_group_wealth(test_cases): results = [] for n, k, wealth in test_cases: if k > n: results.append(-1) continue wealth.sort() min_difference = float('inf') for i in range(n - k + 1): current_difference = wealth[i + k - 1] - wealth[i] if current_difference < min_difference: min_difference = current_difference results.append(min_difference) return results"},{"question":"from typing import List def min_coins_needed(n: int, coin_values: List[int], target_amount: int) -> int: Determines the minimum number of coins needed to make the exact target amount. Returns -1 if it's not possible. >>> min_coins_needed(3, [1, 2, 5], 11) 3 >>> min_coins_needed(2, [2, 4], 7) -1","solution":"def min_coins_needed(n, coin_values, target_amount): Determines the minimum number of coins needed to make the exact target amount. Returns -1 if it's not possible. # Create an array to store the minimum number of coins for each amount # Initialize with a value higher than the maximum (target_amount + 1) dp = [float('inf')] * (target_amount + 1) dp[0] = 0 # It takes 0 coins to make amount 0 # Update the dp array using the coin_values for coin in coin_values: for x in range(coin, target_amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[target_amount] if dp[target_amount] != float('inf') else -1"},{"question":"def find_pairs(n: int, b: int, batteries: List[int]) -> List[Tuple[int, int]]: Finds all unique pairs of drones whose combined battery size equals the required capacity. Args: n: An integer representing the number of drones. b: An integer representing the required battery capacity of the storage compartment. batteries: A list of integers representing the battery sizes of the drones. Returns: A list of tuples, where each tuple contains battery sizes of the two drones in lexicographical order. Examples: >>> find_pairs(5, 10, [2, 4, 6, 8, 10]) [(2, 8), (4, 6)] >>> find_pairs(4, 7, [3, 5, 7, 4]) [(3, 4)] >>> find_pairs(3, 12, [4, 4, 4]) []","solution":"def find_pairs(n, b, batteries): Finds all unique pairs of drones whose combined battery size equals the required capacity. Returns a list of tuples, where each tuple contains battery sizes of the two drones in lexicographical order. from collections import defaultdict # Dictionary to store the number of occurrences of each battery size battery_count = defaultdict(int) for battery in batteries: battery_count[battery] += 1 # List to store the resulting pairs result = [] # Iterate through each battery size to find pairs for battery in sorted(batteries): complement = b - battery if complement in battery_count: if battery == complement and battery_count[battery] > 1: result.append((battery, complement)) battery_count[battery] -= 2 elif battery != complement and battery_count[battery] > 0 and battery_count[complement] > 0: result.append((battery, complement)) battery_count[battery] -= 1 battery_count[complement] -= 1 # Sort the result pairs lexicographically result = sorted(set(result)) return result"},{"question":"def is_hamiltonian_cycle(n: int, edges: List[Tuple[int, int]]) -> str: Check if it is possible to create a sequence such that every student can pass the baton exactly once to one of their friends. >>> is_hamiltonian_cycle(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"possible\\" >>> is_hamiltonian_cycle(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"impossible\\" from typing import List, Tuple def test_case_1(): assert is_hamiltonian_cycle(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"possible\\" def test_case_2(): assert is_hamiltonian_cycle(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"impossible\\" def test_case_3(): assert is_hamiltonian_cycle(3, [(1, 2), (2, 3), (3, 1)]) == \\"possible\\" def test_case_4(): assert is_hamiltonian_cycle(4, [(1, 2), (2, 3), (3, 1)]) == \\"impossible\\" def test_case_5(): assert is_hamiltonian_cycle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"possible\\" def test_case_6(): assert is_hamiltonian_cycle(7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1)]) == \\"possible\\" def test_case_7(): assert is_hamiltonian_cycle(2, [(1, 2)]) == \\"possible\\" def test_case_8(): assert is_hamiltonian_cycle(2, []) == \\"impossible\\"","solution":"def is_hamiltonian_cycle(n, edges): from collections import defaultdict def dfs(current, start, visited, count): if count == n: return start in graph[current] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True if dfs(neighbor, start, visited, count + 1): return True visited[neighbor] = False return False graph = defaultdict(list) for p, q in edges: graph[p].append(q) graph[q].append(p) for i in range(1, n + 1): visited = {j: False for j in range(1, n + 1)} visited[i] = True if dfs(i, i, visited, 1): return \\"possible\\" return \\"impossible\\" # This part reads input from the user or a file def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): p = int(data[index]) q = int(data[index + 1]) edges.append((p, q)) index += 2 result = is_hamiltonian_cycle(n, edges) print(result)"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Args: s1 (str): First string s2 (str): Second string Returns: bool: True if s1 and s2 are anagrams, False otherwise Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Args: s1 (str): First string s2 (str): Second string Returns: bool: True if s1 and s2 are anagrams, False otherwise from collections import Counter if len(s1) != len(s2): return False return Counter(s1) == Counter(s2)"},{"question":"def shortest_palindrome_length(s: str) -> int: Given a string s, returns the length of the shortest possible palindrome that can be formed by appending characters to the end of the string. >>> shortest_palindrome_length(\\"abab\\") 5 >>> shortest_palindrome_length(\\"race\\") 7 >>> shortest_palindrome_length(\\"aaa\\") 3","solution":"def shortest_palindrome_length(s): Given a string s, returns the length of the shortest possible palindrome that can be formed by appending characters to the end of the string. n = len(s) reverse_s = s[::-1] for i in range(n): if s.startswith(reverse_s[i:]): return n + i return 2 * n # Fallback, should never actually be this length due to the above logic. # Additional Examples # Input: abc # Output: 5 (we append \\"cba\\" to \\"abc\\" to get \\"abccba\\") # Input: aacecaaa # Output: 7 (the string is already a palindrome: \\"aaacecaaa\\")"},{"question":"def is_odd_subset_exists(t: int, test_cases: list) -> list: Determine if there exists any subset of given length k such that the sum of the subset is odd. Parameters: t : int : The number of test cases. test_cases : list : List of tuples, each containing n (int), k (int), and a list of n positive integers. Returns: list : List of \\"YES\\" or \\"NO\\" strings for each test case. Example: >>> is_odd_subset_exists(3, [(5, 3, [1, 2, 3, 4, 5]), (4, 2, [2, 4, 6, 8]), (7, 4, [1, 1, 1, 1, 1, 1, 1])]) ['YES', 'NO', 'YES']","solution":"def is_odd_subset_exists(t, test_cases): This function checks if there exists any subset of specific length k such that the sum of the subset is odd. Parameters: t (int) : Number of test cases. test_cases (list) : List of test cases where each test case is a tuple containing n, k and the array of integers. Returns: list : List of \\"YES\\" or \\"NO\\" strings for each test case. results = [] for test in test_cases: n, k, arr = test odd_count = sum(1 for num in arr if num % 2 != 0) even_count = n - odd_count if odd_count >= k: results.append(\\"YES\\") elif odd_count % 2 == 1 and even_count >= k - odd_count: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def validate_ip(ip: str) -> bool: Validates whether a given string is a valid IPv4 address. An IPv4 address is represented as four decimal numbers separated by dots, where each decimal number (called an octet) can have a value between 0 and 255, inclusive. Parameters: ip (str): The input string representing the IP address. Returns: bool: True if the input string is a valid IPv4 address, otherwise False. Examples: >>> validate_ip(\\"192.168.0.1\\") True >>> validate_ip(\\"256.300.789.0\\") False >>> validate_ip(\\"192.168.oops.1\\") False >>> validate_ip(\\"192.168.0\\") False >>> validate_ip(\\"192.168.0.01\\") False","solution":"def validate_ip(ip: str) -> bool: Validates whether a given string is a valid IPv4 address. Parameters: ip (str): The input string representing the IP address. Returns: bool: True if the input string is a valid IPv4 address, otherwise False. # Split the input string by dots parts = ip.split('.') # Check if there are exactly four parts if len(parts) != 4: return False for part in parts: # Check if part is a digit if not part.isdigit(): return False # Check if the part is in the range 0 to 255 if not (0 <= int(part) <= 255): return False # Check for leading zeros in non-zero numbers if part != '0' and part.startswith('0'): return False return True"},{"question":"def manage_inventory(N: int, quantities: List[int], operations: List[str]) -> List[int]: Manage an inventory system for a retail store. Args: N (int): The number of different products. quantities (List[int]): The initial quantities of each product from product code 0 to N-1. operations (List[str]): The list of operations to be performed. Returns: List[int]: The result of each \\"STOCK\\" operation. Example: >>> manage_inventory(5, [10, 20, 30, 40, 50], [\\"ADD 2 10\\", \\"REMOVE 3 50\\", \\"STOCK 2\\", \\"REMOVE 4 10\\", \\"STOCK 4\\", \\"STOCK 1\\"]) [40, 40, 20]","solution":"def manage_inventory(N, quantities, operations): results = [] for operation in operations: parts = operation.split() command = parts[0] X = int(parts[1]) if command == \\"ADD\\": Y = int(parts[2]) quantities[X] += Y elif command == \\"REMOVE\\": Y = int(parts[2]) quantities[X] = max(0, quantities[X] - Y) elif command == \\"STOCK\\": results.append(quantities[X]) return results"},{"question":"def max_temperature_difference(temperatures): Returns the maximum difference in temperature between any two days (where the later day's temperature is higher than the earlier day's temperature). @param temperatures: List[int] - an array of integers where each integer represents the temperature of a day. 1  n  1000. Each temperature is between -100 and 100 inclusive. @return: int - the maximum difference in temperature between any two days (where the later day's temperature is higher than the earlier day's temperature). Examples: >>> max_temperature_difference([30, 40, 20, 50, 25]) 30 >>> max_temperature_difference([10, 8, 6, 4, 2]) 0","solution":"def max_temperature_difference(temperatures): Returns the maximum difference in temperature between any two days (where the later day's temperature is higher than the earlier day's temperature). if not temperatures or len(temperatures) < 2: return 0 min_temp_so_far = temperatures[0] max_diff = 0 for temp in temperatures[1:]: if temp > min_temp_so_far: max_diff = max(max_diff, temp - min_temp_so_far) min_temp_so_far = min(min_temp_so_far, temp) return max_diff"},{"question":"from typing import List, Tuple def max_requests(N: int, T: int, servers: List[Tuple[int, int]]) -> int: Determines the maximum number of requests per second that can be handled by the servers without exceeding the average response time threshold. Parameters: - N (int): Number of servers - T (int): Threshold average response time in milliseconds - servers (List[Tuple[int, int]]): List of tuples where each tuple contains (R_i, A_i), the maximum requests per second and average response time for the i-th server. Returns: - int: Maximum number of requests per second that can be handled pass import pytest def test_example_case(): assert max_requests(3, 300, [(500, 200), (300, 100), (400, 500)]) == 800 def test_single_server_within_threshold(): assert max_requests(1, 200, [(500, 150)]) == 500 def test_single_server_exceeding_threshold(): assert max_requests(1, 100, [(500, 150)]) == 0 def test_all_servers_within_threshold(): assert max_requests(3, 300, [(200, 100), (300, 100), (250, 200)]) == 750 def test_mixed_servers(): assert max_requests(5, 250, [(200, 100), (300, 300), (250, 200), (400, 500), (150, 150)]) == 600 def test_no_servers(): assert max_requests(0, 100, []) == 0 def test_multiple_servers_optimal(): assert max_requests(4, 200, [(100, 100), (200, 150), (50, 50), (150, 200)]) == 500 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_requests(N, T, servers): Determines the maximum number of requests per second that can be handled by the servers without exceeding the average response time threshold. Parameters: - N (int): Number of servers - T (int): Threshold average response time in milliseconds - servers (List[Tuple[int, int]]): List of tuples where each tuple contains (R_i, A_i), the maximum requests per second and average response time for the i-th server. Returns: - int: Maximum number of requests per second that can be handled # Filter out servers that exceed average response time threshold individually viable_servers = [srv for srv in servers if srv[1] <= T] # Sort servers based on average response time in ascending order viable_servers.sort(key=lambda x: x[1]) total_requests = 0 total_response_time = 0 total_servers = 0 # Accumulate requests such that the total average response time does not exceed T for R_i, A_i in viable_servers: if (total_response_time + A_i) / (total_servers + 1) <= T: total_requests += R_i total_response_time += A_i total_servers += 1 return total_requests"},{"question":"def is_beautiful(s: str) -> str: Determines if the given string s is beautiful. A string is beautiful if all its characters are distinct and the absolute difference between the ASCII values of any two consecutive characters is equal to 1. Args: s (str): The input string. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". pass # Unit tests def test_is_beautiful(): assert is_beautiful(\\"abcdef\\") == \\"YES\\" assert is_beautiful(\\"bace\\") == \\"NO\\" assert is_beautiful(\\"xyz\\") == \\"YES\\" assert is_beautiful(\\"a\\") == \\"YES\\" assert is_beautiful(\\"abcdfe\\") == \\"NO\\" assert is_beautiful(\\"z\\") == \\"YES\\" assert is_beautiful(\\"aabbcc\\") == \\"NO\\" assert is_beautiful(\\"aceg\\") == \\"NO\\" assert is_beautiful(\\"yxwvutsr\\") == \\"YES\\" assert is_beautiful(\\"abacadae\\") == \\"NO\\" assert is_beautiful(\\"edcba\\") == \\"YES\\" def test_is_beautiful_empty_string(): assert is_beautiful(\\"\\") == \\"YES\\" # Empty string should be considered beautiful def test_is_beautiful_single_char(): assert is_beautiful(\\"a\\") == \\"YES\\" # Single character string is trivially beautiful","solution":"def is_beautiful(s): Determines if the given string s is beautiful. A string is beautiful if all its characters are distinct and the absolute difference between the ASCII values of any two consecutive characters is equal to 1. Args: s (str): The input string. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". # Check if all characters are distinct if len(set(s)) != len(s): return \\"NO\\" # Check the absolute difference between ASCII values of consecutive characters for i in range(len(s) - 1): if abs(ord(s[i]) - ord(s[i + 1])) != 1: return \\"NO\\" return \\"YES\\""},{"question":"def reorderInventory(inventory): Reorders the inventory in-place based on the item_price in descending order. If two items have the same price, their order remains the same. Args: inventory (list): List of tuples, where each tuple contains (item_id, item_price). Returns: None: Modifies the inventory list in-place. Example: >>> inventory = [(1001, 50), (1002, 40), (1003, 50), (1004, 60)] >>> reorderInventory(inventory) >>> inventory [(1004, 60), (1001, 50), (1003, 50), (1002, 40)] >>> inventory = [(1001, 30), (1002, 20)] >>> reorderInventory(inventory) >>> inventory [(1001, 30), (1002, 20)]","solution":"def reorderInventory(inventory): Reorders the inventory in-place based on the item_price in descending order. If two items have the same price, their order remains the same. Args: inventory (list): List of tuples, where each tuple contains (item_id, item_price). Returns: None: Modifies the inventory list in-place. # Sort the list in-place by the item_price in descending order inventory.sort(key=lambda x: x[1], reverse=True)"},{"question":"def rearrange_array(n: int, arr: List[int]) -> List[int]: Rearrange the array such that all negative integers appear before all positive integers while maintaining the relative order of negative and positive integers as in the original array. Parameters: n (int): Size of the array. arr (list): List of n integers which can be both negative and positive. Returns: list: A new list with negative integers appearing before all positive integers. >>> rearrange_array(6, [-1, 2, -3, 4, 5, -6]) == [-1, -3, -6, 2, 4, 5] >>> rearrange_array(4, [1, -2, 3, -4]) == [-2, -4, 1, 3]","solution":"def rearrange_array(n, arr): Rearrange the array such that all negative integers appear before all positive integers while maintaining the relative order of negative and positive integers as in the original array. Parameters: n (int): Size of the array. arr (list): List of n integers which can be both negative and positive. Returns: list: A new list with negative integers appearing before all positive integers. negatives = [x for x in arr if x < 0] positives = [x for x in arr if x >= 0] return negatives + positives"},{"question":"def count_special_integers(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Count the number of special integers in each test case. A special integer x is an element that equals the sum of some contiguous subarray. >>> count_special_integers(2, [(4, [1, 2, 3, 4]), (5, [1, 2, 1, 3, 1])]) == [4, 5] results = [] # Complete the implementation here return results def test_count_special_integers(): # Sample test cases T = 2 test_cases = [ (4, [1, 2, 3, 4]), (5, [1, 2, 1, 3, 1]) ] expected = [4, 5] assert count_special_integers(T, test_cases) == expected # Additional test cases T = 1 test_cases = [ (3, [-1, -2, -3]) ] expected = [3] assert count_special_integers(T, test_cases) == expected T = 1 test_cases = [ (4, [3, 3, 3, 3]) ] expected = [4] assert count_special_integers(T, test_cases) == expected T = 1 test_cases = [ (5, [0, 0, 0, 0, 0]) ] expected = [5] assert count_special_integers(T, test_cases) == expected T = 1 test_cases = [ (6, [1, -1, 1, -1, 1, -1]) ] expected = [6] assert count_special_integers(T, test_cases) == expected","solution":"def count_special_integers(T, test_cases): results = [] for case in test_cases: N, A = case special_integers = set() # Compute the sum of all possible subarrays and check if they appear in the array for i in range(N): current_sum = 0 for j in range(i, N): current_sum += A[j] special_integers.add(current_sum) special_count = sum(1 for x in A if x in special_integers) results.append(special_count) return results"},{"question":"def process_inputs_and_find_operations(t: int, input_data: List[Union[int, List[int]]]) -> List[int]: Given a number of test cases and corresponding building heights, determine the minimum number of operations needed to make all buildings in each test case the same height. >>> process_inputs_and_find_operations(3, [4, [1, 2, 3, 4], 3, [10, 10, 10], 5, [3, 4, 2, 5, 3]]) == [4, 0, 4] >>> process_inputs_and_find_operations(1, [5, [7, 7, 7, 7, 7]]) == [0] >>> process_inputs_and_find_operations(1, [3, [10, 9, 8]]) == [2] >>> process_inputs_and_find_operations(1, [4, [1, 2, 3, 4]]) == [4] >>> process_inputs_and_find_operations(1, [1, [10]]) == [0] >>> process_inputs_and_find_operations(1, [3, [1000, 500, 250]]) == [750] # Your implementation here","solution":"def min_operations_to_equal_height(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] median_height = sorted(heights)[n//2] operations = sum(abs(h - median_height) for h in heights) results.append(operations) return results #Wrapper function to extract input and process it def process_inputs_and_find_operations(t, input_data): test_cases = [] input_line = 0 for _ in range(t): n = input_data[input_line] heights = input_data[input_line+1] test_cases.append((n, heights)) input_line += 2 return min_operations_to_equal_height(t, test_cases)"},{"question":"def max_dishes(n: int, t: int, dish_ids: List[int]) -> int: Determine the maximum number of dishes that can be included in a single order without exceeding the threshold t. Parameters: n (int): The number of dish IDs. t (int): The maximum threshold value. dish_ids (List[int]): List of dish IDs. Returns: int: The maximum number of dishes. >>> max_dishes(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_dishes(5, 5, [5, 4, 3, 2, 1]) 2 >>> max_dishes(1, 10, [5]) 1 >>> max_dishes(3, 2, [5, 6, 7]) 0 >>> max_dishes(4, 15, [7, 8, 4, 3]) 3 >>> max_dishes(10, 50, [1, 2, 8, 9, 10, 12, 15, 18, 19, 20]) 6 >>> max_dishes(0, 10, []) 0 >>> max_dishes(5, 10, [2, 2, 2, 2, 2]) 5 >>> max_dishes(5, 10, [10, 9, 8, 7, 6]) 1","solution":"def max_dishes(n, t, dish_ids): Determine the maximum number of dishes that can be included in a single order without exceeding the threshold t. Parameters: n (int): The number of dish IDs. t (int): The maximum threshold value. dish_ids (List[int]): List of dish IDs. Returns: int: The maximum number of dishes. # Sort the dish IDs to try to include smallest IDs first dish_ids.sort() count = 0 total = 0 for dish_id in dish_ids: if total + dish_id <= t: total += dish_id count += 1 else: break return count"},{"question":"def max_profit(prices): Returns the maximum possible profit obtainable from a contiguous subarray of stock prices. >>> max_profit([-10, 1, 3, -2, 4, -1]) 6 >>> max_profit([1, -2, 3, 10, -4]) 13 >>> max_profit([5]) 5 >>> max_profit([-1, -3, -2, -5, -7]) -1 >>> max_profit([2, 1, -3, 4, -2, 2, 3, -5, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 15","solution":"def max_profit(prices): Returns the maximum possible profit obtainable from a contiguous subarray of stock prices. max_current = max_global = prices[0] for price in prices[1:]: max_current = max(price, max_current + price) if max_current > max_global: max_global = max_current return max_global"},{"question":"def simulate_task_assignment(n, m, q, skills, tasks, queries): Simulates the task assignment, processing ASSIGN, COMPLETE, and STATUS requests. Args: n (int): Number of team members. m (int): Number of tasks. q (int): Number of queries. skills (List[int]): Skill levels of team members. tasks (List[int]): Minimum skill requirements of tasks. queries (List[str]): List of queries to be processed. Returns: List[str]: Current assignments of each team member after each STATUS query, in the format 'member_number: task_number' or 'member_number: NONE'. Example: input_data = [ 3, 2, 5, # N, M, Q [20, 35, 15], # Skills [10, 30], # Tasks [\\"ASSIGN 1\\", \\"ASSIGN 2\\", \\"STATUS\\", \\"COMPLETE 1\\", \\"STATUS\\"] # Queries ] expected_output = [ \\"1: NONE\\", \\"2: 2\\", \\"3: 1\\", \\"1: NONE\\", \\"2: 2\\", \\"3: NONE\\" ] n, m, q = input_data[:3] skills = input_data[3] tasks = input_data[4] queries = input_data[5] result = simulate_task_assignment(n, m, q, skills, tasks, queries) assert result == expected_output, f\\"Expected {expected_output}, but got {result}\\"","solution":"def simulate_task_assignment(n, m, q, skills, tasks, queries): # Initialize status of each team member as None member_status = ['NONE'] * n task_assigned = [-1] * m # -1 means task is not yet assigned def available_member_for_task(task_min_skill): available_members = [(i, skills[i]) for i in range(n) if member_status[i] == 'NONE' and skills[i] >= task_min_skill] if not available_members: return None return min(available_members, key=lambda x: x[1])[0] output = [] for query in queries: if query.startswith(\\"ASSIGN\\"): _, t = query.split() t = int(t) - 1 suitable_member = available_member_for_task(tasks[t]) if suitable_member is not None: member_status[suitable_member] = t + 1 task_assigned[t] = suitable_member elif query.startswith(\\"COMPLETE\\"): _, t = query.split() t = int(t) - 1 if task_assigned[t] != -1: member_status[task_assigned[t]] = 'NONE' task_assigned[t] = -1 elif query == \\"STATUS\\": current_status = [f\\"{i+1}: {member_status[i]}\\" for i in range(n)] output.extend(current_status) return output # Example usage: input_data = [ 3, 2, 5, # N, M, Q [20, 35, 15], # Skills [10, 30], # Tasks [\\"ASSIGN 1\\", \\"ASSIGN 2\\", \\"STATUS\\", \\"COMPLETE 1\\", \\"STATUS\\"] # Queries ] n, m, q = input_data[:3] skills = input_data[3] tasks = input_data[4] queries = input_data[5] result = simulate_task_assignment(n, m, q, skills, tasks, queries) print(\\"n\\".join(result))"},{"question":"def can_place_patch(grid, pr, pc): Determines if a pr x pc patch can be placed in an empty grid. >>> can_place_patch([\\".....\\", \\".PPPP\\", \\".....\\", \\".....\\", \\".....\\"], 2, 2) True >>> can_place_patch([\\"PPPP\\", \\"PPPP\\", \\"PPPP\\", \\"PPPP\\"], 2, 2) False def plant_arrangement(input_data): Determines if each patch can be placed in the respective grids. >>> input_data = [ ... {'grid_size': (5, 5), 'grid': [\\".....\\", \\".PPPP\\", \\".....\\", \\".....\\", \\".....\\"], 'patch_size': (2, 2)}, ... {'grid_size': (4, 4), 'grid': [\\"PPPP\\", \\"PPPP\\", \\"PPPP\\", \\"PPPP\\"], 'patch_size': (2, 2)} ... ] >>> plant_arrangement(input_data) ['Case 1: Yes', 'Case 2: No']","solution":"def can_place_patch(grid, pr, pc): Determines if a pr x pc patch can be placed in an empty grid. rows = len(grid) cols = len(grid[0]) # Iterate through each possible starting position in the grid for i in range(rows - pr + 1): for j in range(cols - pc + 1): # Check if the patch can fit in the grid starting at (i, j) can_place = True for r in range(pr): for c in range(pc): if grid[i + r][j + c] == 'P': can_place = False break if not can_place: break if can_place: return True return False def plant_arrangement(input_data): result = [] case_number = 1 for test_case in input_data: R, C = test_case['grid_size'] grid = test_case['grid'] pr, pc = test_case['patch_size'] if can_place_patch(grid, pr, pc): result.append(f\\"Case {case_number}: Yes\\") else: result.append(f\\"Case {case_number}: No\\") case_number += 1 return result"},{"question":"from typing import List, Tuple def matrix_multiply(N: int, M: int, K: int, A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A (N x M) and B (M x K) to get a result matrix C (N x K). Args: N: Number of rows in matrix A. M: Number of columns in matrix A (and rows in matrix B). K: Number of columns in matrix B. A: Matrix A represented as a list of lists. B: Matrix B represented as a list of lists. Returns: Resultant matrix C after multiplying A and B. def read_matrices(input_str: str) -> Tuple[int, int, int, List[List[int]], List[List[int]]]: Parses input strings to extract matrix dimensions and matrices A and B. Args: input_str: Input string containing dimensions and matrix values. Returns: A tuple containing dimensions N, M, K and matrices A, B. def main(input_str: str) -> str: Main function to read input, multiply matrices and format the output. Args: input_str: Input string containing dimensions and matrix values. Returns: Formatted string of the resultant matrix C. # Unit tests def test_matrix_multiply(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] expected_output = [ [58, 64], [139, 154] ] assert matrix_multiply(2, 3, 2, A, B) == expected_output def test_matrix_multiply_single_element(): A = [ [2] ] B = [ [3] ] expected_output = [ [6] ] assert matrix_multiply(1, 1, 1, A, B) == expected_output def test_matrix_multiply_different_sizes(): A = [ [1, 4], [2, 5], [3, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] expected_output = [ [47, 52, 57], [64, 71, 78], [81, 90, 99] ] assert matrix_multiply(3, 2, 3, A, B) == expected_output def test_read_matrices(): input_str = \\"2 3 2n1 2 3n4 5 6n7 8n9 10n11 12\\" expected_output_N = 2 expected_output_M = 3 expected_output_K = 2 expected_output_A = [[1, 2, 3], [4, 5, 6]] expected_output_B = [[7, 8], [9, 10], [11, 12]] N, M, K, A, B = read_matrices(input_str) assert N == expected_output_N assert M == expected_output_M assert K == expected_output_K assert A == expected_output_A assert B == expected_output_B def test_main(): input_str = \\"2 3 2n1 2 3n4 5 6n7 8n9 10n11 12\\" expected_output = \\"58 64n139 154\\" assert main(input_str) == expected_output","solution":"def matrix_multiply(N, M, K, A, B): Multiplies two matrices A (N x M) and B (M x K) to get a result matrix C (N x K). # Initialize the result matrix C with zeros C = [[0 for _ in range(K)] for _ in range(N)] # Matrix multiplication logic for i in range(N): for j in range(K): for k in range(M): C[i][j] += A[i][k] * B[k][j] return C # Function to read input def read_matrices(input_str): input_list = input_str.strip().split('n') N, M, K = map(int, input_list[0].split()) A = [] for i in range(1, N + 1): A.append(list(map(int, input_list[i].split()))) B = [] for i in range(N + 1, N + M + 1): B.append(list(map(int, input_list[i].split()))) return N, M, K, A, B def main(input_str): N, M, K, A, B = read_matrices(input_str) C = matrix_multiply(N, M, K, A, B) return \\"n\\".join(\\" \\".join(map(str, row)) for row in C)"},{"question":"def product_except_self(nums): Given an array of integers, return an array of the products of all elements except the element at each index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 4, 3]) [12, 0, 0] >>> product_except_self([5]) [1] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1, -1, 2, -2]) [4, -4, 2, -2] pass","solution":"def product_except_self(nums): Returns an array where each element is the product of all elements in the input array except the element at that index. length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def calculate_final_prices(discount_rules, items): Calculate final prices for items after applying the highest applicable discount. Args: discount_rules (List[Tuple[int, float]]): List of tuples containing threshold and discount percentage. items (List[Tuple[str, int]]): List of tuples containing item name and quantity. Returns: List[Tuple[str, float]]: List of tuples containing item name and final price. pass # Test cases discount_rules = [ (5, 20.0), (10, 30.0), (15, 50.0) ] items = [ (\\"bananas\\", 12), (\\"apples\\", 5), (\\"oranges\\", 20), (\\"grapes\\", 3) ] print(calculate_final_prices(discount_rules, items)) # Expected Output: [('bananas', 8.4), ('apples', 4.0), ('oranges', 10.0), ('grapes', 3.0)] discount_rules = [ (100, 20.0) ] items = [ (\\"item1\\", 1), (\\"item2\\", 2), (\\"item3\\", 3) ] print(calculate_final_prices(discount_rules, items)) # Expected Output: [('item1', 1.0), ('item2', 2.0), ('item3', 3.0)] discount_rules = [ (1, 10.0), (2, 20.0) ] items = [ (\\"item1\\", 1), (\\"item2\\", 2), (\\"item3\\", 3) ] print(calculate_final_prices(discount_rules, items)) # Expected Output: [('item1', 0.9), ('item2', 1.6), ('item3', 2.4)] discount_rules = [ (1, 10.0), (5, 50.0), (10, 90.0) ] items = [ (\\"item1\\", 1), (\\"item2\\", 5), (\\"item3\\", 10) ] print(calculate_final_prices(discount_rules, items)) # Expected Output: [('item1', 0.9), ('item2', 2.5), ('item3', 1.0)]","solution":"def calculate_final_prices(discount_rules, items): Calculate final prices for items after applying the highest applicable discount. Args: discount_rules (List[Tuple[int, float]]): List of tuples containing threshold and discount percentage. items (List[Tuple[str, int]]): List of tuples containing item name and quantity. Returns: List[Tuple[str, float]]: List of tuples containing item name and final price. final_prices = [] for item_name, quantity in items: applicable_discount = 0 for threshold, discount_percentage in discount_rules: if quantity >= threshold: applicable_discount = max(applicable_discount, discount_percentage) final_price = quantity * (1 - applicable_discount / 100) final_prices.append((item_name, round(final_price, 2))) return final_prices"},{"question":"def is_prime(num: int) -> bool: Determine if a given number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(19) True >>> is_prime(1) False >>> is_prime(-5) False def sum_of_primes(lst: List[int]) -> int: Returns the sum of all prime numbers in the given list. >>> sum_of_primes([3, 4, 7, 6, 11, 13]) 34 >>> sum_of_primes([2, 3, 5, 7, 11]) 28 >>> sum_of_primes([1, 4, 6, 8]) 0 >>> sum_of_primes([29, 31, 37, 41]) 138 >>> sum_of_primes([]) 0 >>> sum_of_primes([2, 2, 2, 2]) 8 >>> sum_of_primes([14, 15, 16]) 0","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def sum_of_primes(lst): Returns the sum of all prime numbers in the given list. return sum(num for num in lst if is_prime(num))"},{"question":"def find_median_score(scores: List[int]) -> float: Returns the median score from a list of scores. >>> find_median_score([3, 1, 4, 1, 5]) 3 >>> find_median_score([50, 20, 70, 10]) 35.0 >>> find_median_score([42]) 42 >>> find_median_score([10, 20]) 15.0 >>> find_median_score([1000000, 500000, 750000]) 750000 >>> find_median_score([1, 1, 1, 1, 1, 1]) 1","solution":"def find_median_score(scores): Returns the median score from a list of scores. scores.sort() n = len(scores) if n % 2 == 1: return scores[n // 2] else: return (scores[n // 2 - 1] + scores[n // 2]) / 2"},{"question":"def can_make_zero(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to make all elements of an array zero by using a specific set of moves >>> can_make_zero(5, [(4, [1, 2, 3, 4]), (2, [-1, 1]), (6, [1, -1, 2, -2, 3, -3]), (6, [10, 20, -10, -20, 30, -30]), (2, [1000000000, -1000000000])]) ['NO', 'YES', 'YES', 'YES', 'YES'] >>> can_make_zero(1, [(4, [1, 1, -1, -1])]) ['YES'] >>> can_make_zero(1, [(2, [0, 0])]) ['YES'] >>> can_make_zero(1, [(2, [1, 1])]) ['NO'] >>> can_make_zero(3, [(6, [1, 1, -1, -1, 2, -2]), (4, [2, 2, -2, -3]), (8, [3, -3, 2, -2, 1, -1, -1, 1])]) ['YES', 'NO', 'YES']","solution":"def can_make_zero(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] if sum(arr) == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_melody_length(M: int, K: int) -> int: Given the total number of different notes M and the maximum allowed number of changes K, returns the minimum length of the melody that can be played without exceeding the allowed number of changes. Examples: >>> min_melody_length(5, 2) 3 >>> min_melody_length(7, 3) 4 >>> min_melody_length(4, 0) 1 def solve_hexaphone(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Solves the Hexaphone problem for multiple test cases. Arguments: T -- The number of test cases. test_cases -- A list of tuples where each tuple contains two integers: the total number of different notes M and the maximum allowed number of changes K. Returns a list of integers where each integer is the minimum length of the melody for the corresponding test case. Examples: >>> solve_hexaphone(3, [(5, 2), (7, 3), (4, 0)]) [3, 4, 1] >>> solve_hexaphone(3, [(10, 0), (1, 0), (5, 5)]) [1, 1, 5] >>> solve_hexaphone(4, [(2, 1), (2, 2), (10, 1), (8, 7)]) [2, 2, 2, 8]","solution":"def min_melody_length(M, K): Given the total number of different notes M and the maximum allowed number of changes K, returns the minimum length of the melody that can be played without exceeding the allowed number of changes. if K == 0: return 1 return min(M, K + 1) def solve_hexaphone(T, test_cases): results = [] for M, K in test_cases: results.append(min_melody_length(M, K)) return results"},{"question":"def largestRectangleArea(heights): Computes the maximum area of a rectangle that can be formed by any set of consecutive buildings. :param heights: List[int] - List of integers representing heights of buildings :return: int - Maximum rectangular area Examples: >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2]) 2 >>> largestRectangleArea([4, 4, 4, 4]) 16 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([1, 100]) 100","solution":"def largestRectangleArea(heights): Computes the maximum area of a rectangle that can be formed by any set of consecutive buildings. :param heights: List[int] - List of integers representing heights of buildings :return: int - Maximum rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def isSpecialNumber(num: int) -> bool: Determines if a given number is a special number. A number is considered special if the digits of the number alternate between odd and even. >>> isSpecialNumber(2957) == True >>> isSpecialNumber(1234) == False # Implementation goes here","solution":"def isSpecialNumber(num): Determines if a number is a special number. A number is considered special if the digits of the number alternate between odd and even. num_str = str(num) for i in range(len(num_str) - 1): current_digit = int(num_str[i]) next_digit = int(num_str[i + 1]) if (current_digit % 2) == (next_digit % 2): return False return True"},{"question":"from typing import List, Tuple def find_pairs(numbers: List[int], targetSum: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers in the list that sum up to the targetSum. Each pair is sorted in increasing order, and the result list is sorted lexicographically. >>> find_pairs([1, 2, 3, 4, 5, -1, -2, -3], 4) [(-1, 5), (1, 3)] >>> find_pairs([1, 1, 2, 2, 3, 3, 4, 4], 5) [(1, 4), (2, 3)]","solution":"from typing import List, Tuple def find_pairs(numbers: List[int], targetSum: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers in the list that sum up to the targetSum. Each pair is sorted in increasing order, and the result list is sorted lexicographically. seen = {} pairs = set() for number in numbers: complement = targetSum - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen[number] = 1 # mark the number as seen return sorted(pairs)"},{"question":"import math from typing import List, Tuple def number_of_paths(N: int, M: int) -> int: Returns the number of different possible single paths from (1, 1) to (N, M) in an N x M grid. >>> number_of_paths(2, 2) 2 >>> number_of_paths(3, 2) 3 >>> number_of_paths(3, 3) 6 >>> number_of_paths(1, 1) 1 >>> number_of_paths(4, 4) 20 pass def single_path_planting(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: For each test case, returns the number of different possible single paths to plant trees from (1, 1) to (N, M). >>> single_path_planting(3, [(2, 2), (3, 2), (3, 3)]) [2, 3, 6] >>> single_path_planting(2, [(1, 1), (4, 4)]) [1, 20] >>> single_path_planting(1, [(5, 5)]) [70] pass","solution":"import math def number_of_paths(N, M): Returns the number of different possible single paths from (1, 1) to (N, M) in an N x M grid. # Calculating the number of combinations C(N-1 + M-1, N-1) return math.comb(N + M - 2, N - 1) def single_path_planting(t, test_cases): results = [] for N, M in test_cases: results.append(number_of_paths(N, M)) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string s, find the longest palindromic substring. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\" >>> longest_palindromic_substring(\\"abc\\") \\"a\\" or \\"b\\" or \\"c\\" >>> longest_palindromic_substring(\\"abccba\\") \\"abccba\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" or \\"cdc\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\"","solution":"def longest_palindromic_substring(s): Given a string s, find the longest palindromic substring. n = len(s) if n == 0: return \\"\\" # Initialize the DP table dp = [[False] * n for _ in range(n)] # Every single character is a palindrome start = 0 max_length = 1 for i in range(n): dp[i][i] = True # Check for two-character palindromes for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for palindromes longer than two characters for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 # Check if the current substring is a palindrome if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True start = i max_length = length return s[start:start+max_length]"},{"question":"def calculate_scores(t: int, test_cases: list) -> list: Determine the final scores of John and Jane. :param t: Integer, the number of test cases. :param test_cases: List of tuples, each containing an integer N (number of integers in the sequence) and a list of N integers. :return: List of strings, each containing two space-separated integers  the final scores of John and Jane respectively. Example: >>> calculate_scores(1, [(5, [1, 2, 3, 4, 5])]) [\\"9 6\\"] >>> calculate_scores(2, [(5, [1, 2, 3, 4, 5]), (4, [4, 3, 4, 3])]) [\\"9 6\\", \\"8 6\\"] def process_input(input_data: str) -> tuple: Process the input data to extract number of test cases and the test cases themselves. :param input_data: String, the input data containing number of test cases, number of integers in each test case, and the sequences of integers. :return: Tuple containing integer t (number of test cases) and a list of tuples, each containing an integer N and a list of N integers. Example: >>> process_input(\\"1n5n1 2 3 4 5n\\") (1, [(5, [1, 2, 3, 4, 5])])","solution":"def calculate_scores(t, test_cases): results = [] for case in test_cases: n, sequence = case john, jane = 0, 0 left, right = 0, n - 1 turn = 0 # 0 for John, 1 for Jane while left <= right: if sequence[left] > sequence[right]: if turn == 0: john += sequence[left] else: jane += sequence[left] left += 1 else: if turn == 0: john += sequence[right] else: jane += sequence[right] right -= 1 turn = 1 - turn results.append(f\\"{john} {jane}\\") return results def process_input(input_data): lines = input_data.strip().split() index = 0 t = int(lines[index]) index += 1 test_cases = [] for _ in range(t): n = int(lines[index]) index += 1 sequence = list(map(int, lines[index:index + n])) index += n test_cases.append((n, sequence)) return t, test_cases # Add this main function to handle the input and output when running the script if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read() t, test_cases = process_input(input_data) results = calculate_scores(t, test_cases) for result in results: print(result)"},{"question":"def findSecondLargest(nums: List[int]) -> Optional[int]: Returns the second largest integer in the list. If the list has fewer than 2 unique integers, return None. >>> findSecondLargest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) -> 6 >>> findSecondLargest([1, 2, 3, 4, 5]) -> 4 >>> findSecondLargest([5, 5, 5]) -> None","solution":"def findSecondLargest(nums): Returns the second largest integer in the list. If the list has fewer than 2 unique integers, return None. if len(nums) < 2: return None first = second = float('-inf') seen = set() for num in nums: if num not in seen: seen.add(num) if num > first: first, second = num, first elif num > second: second = num return second if second != float('-inf') else None"},{"question":"def longestIncreasingSubsequenceLength(numbers): Returns the length of the longest strictly increasing subsequence in a list of numbers. Examples: >>> longestIncreasingSubsequenceLength([]) 0 >>> longestIncreasingSubsequenceLength([3]) 1 >>> longestIncreasingSubsequenceLength([3, 10, 2, 11]) 3 >>> longestIncreasingSubsequenceLength([3, 2]) 1 >>> longestIncreasingSubsequenceLength([50, 3, 10, 7, 40, 80]) 4 >>> longestIncreasingSubsequenceLength([1, 2, 3, 4, 5]) 5 def test_longest_increasing_subsequence_length(): assert longestIncreasingSubsequenceLength([]) == 0 assert longestIncreasingSubsequenceLength([3]) == 1 assert longestIncreasingSubsequenceLength([3, 10, 2, 11]) == 3 assert longestIncreasingSubsequenceLength([3, 2]) == 1 assert longestIncreasingSubsequenceLength([50, 3, 10, 7, 40, 80]) == 4 assert longestIncreasingSubsequenceLength([1, 2, 3, 4, 5]) == 5 assert longestIncreasingSubsequenceLength([3, 4, 2, 8, 10, 5, 1]) == 4 assert longestIncreasingSubsequenceLength([3,10,2,1,20]) == 3 assert longestIncreasingSubsequenceLength([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longestIncreasingSubsequenceLength([7, 6, 1, 4, 10, 9, 0, 12, 13]) == 5","solution":"def longestIncreasingSubsequenceLength(numbers): Returns the length of the longest strictly increasing subsequence in a list of numbers. if not numbers: return 0 # This will store the smallest ending value of the increasing subsequences of each length tails = [] for num in numbers: left, right = 0, len(tails) # Binary search for the smallest element in tails that is greater than or equal to num while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid # If left is equal to length of tails, num is greater than any element in tails if left == len(tails): tails.append(num) else: tails[left] = num return len(tails)"},{"question":"from typing import List def findWaterBodies(grid: List[List[str]]) -> int: Count the number of distinct water bodies in the lake grid. >>> findWaterBodies([[\\"L\\", \\"W\\", \\"L\\", \\"L\\", \\"W\\"], [\\"L\\", \\"W\\", \\"L\\", \\"W\\", \\"W\\"], [\\"L\\", \\"L\\", \\"L\\", \\"W\\", \\"L\\"], [\\"W\\", \\"W\\", \\"L\\", \\"L\\", \\"L\\"]]) 3 >>> findWaterBodies([[\\"L\\", \\"W\\", \\"L\\"], [\\"L\\", \\"W\\", \\"L\\"], [\\"L\\", \\"W\\", \\"L\\"]]) 1 >>> findWaterBodies([[\\"L\\", \\"L\\", \\"L\\"], [\\"L\\", \\"L\\", \\"L\\"], [\\"L\\", \\"L\\", \\"L\\"]]) 0 >>> findWaterBodies([]) 0 >>> findWaterBodies([[\\"W\\", \\"W\\", \\"W\\"], [\\"W\\", \\"W\\", \\"W\\"], [\\"W\\", \\"W\\", \\"W\\"]]) 1 >>> findWaterBodies([[\\"W\\" if (i+j) % 2 == 0 else \\"L\\" for j in range(10)] for i in range(10)]) 50","solution":"def findWaterBodies(grid): if not grid: return 0 rows = len(grid) cols = len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 'L': return grid[r][c] = 'L' # Mark as visited directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: dfs(r + dr, c + dc) water_bodies = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 'W': water_bodies += 1 dfs(r, c) return water_bodies"},{"question":"from typing import List def maxDistanceToBuilding(grid: List[List[int]]) -> int: Given a city represented as a grid of size m x n, each cell can either be empty (represented by 0) or a building (represented by 1). We want to add a new building such that the new building is as far as possible from all existing buildings. The distance used for this calculation is the Manhattan Distance, which is the distance between two points (x1, y1) and (x2, y2) defined as |x1 - x2| + |y1 - y2|. Returns an integer representing the maximum distance from the empty cell to the nearest building. If there is no available place to build or if there are no buildings, return -1. >>> maxDistanceToBuilding([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) 2 >>> maxDistanceToBuilding([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 4 >>> maxDistanceToBuilding([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) -1","solution":"from typing import List from collections import deque def maxDistanceToBuilding(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) buildings = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1] if not buildings: return -1 queue = deque(buildings) visited = set(buildings) distance = -1 while queue: distance += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) max_dist = max(distance, 0) return max_dist if max_dist > 0 else -1"},{"question":"class TreeNode: def __init__(self, data=0, left=None, right=None): self.data = data self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if the binary tree is balanced. >>> tree = TreeNode(1); tree.left = TreeNode(2); tree.right = TreeNode(3) >>> tree.left.left = TreeNode(4); tree.left.right = TreeNode(5); tree.right.right = TreeNode(6) >>> tree.left.left.left = TreeNode(7); tree.left.left.right = TreeNode(8) >>> is_balanced(tree) True >>> tree = TreeNode(1); tree.left = TreeNode(2); tree.left.left = TreeNode(3) >>> is_balanced(tree) False >>> is_balanced(None) True >>> is_balanced(TreeNode(1)) True # your code here","solution":"class TreeNode: def __init__(self, data=0, left=None, right=None): self.data = data self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, current_balanced _, balanced = height_and_balance(root) return balanced"},{"question":"def solve_sudoku(board): Complete a 9x9 Sudoku board where each number from 1 to 9 appears exactly once in each row, column, and 3x3 sub-grid. Input: A 99 grid containing integers and dots where integers denote filled cells and dots ('.') denote empty cells. Output: A 99 grid completely filled with integers from 1 to 9. Example: >>> board = [ ['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9'] ] >>> solve_sudoku(board) >>> expected = [ ['5', '3', '4', '6', '7', '8', '9', '1', '2'], ['6', '7', '2', '1', '9', '5', '3', '4', '8'], ['1', '9', '8', '3', '4', '2', '5', '6', '7'], ['8', '5', '9', '7', '6', '1', '4', '2', '3'], ['4', '2', '6', '8', '5', '3', '7', '9', '1'], ['7', '1', '3', '9', '2', '4', '8', '5', '6'], ['9', '6', '1', '5', '3', '7', '2', '8', '4'], ['2', '8', '7', '4', '1', '9', '6', '3', '5'], ['3', '4', '5', '2', '8', '6', '1', '7', '9'] ] >>> assert board == expected","solution":"def solve_sudoku(board): def is_valid(board, row, col, num): # Check if num is not in the current row, column and the 3x3 subgrid for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[row // 3 * 3 + i // 3][col // 3 * 3 + i % 3] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == '.': for num in '123456789': if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = '.' return False return True solve(board) # Example usage board = [ ['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9'] ] solve_sudoku(board) for row in board: print(' '.join(row))"},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: Given a list of daily temperatures, returns a list of the number of days you would have to wait until a warmer temperature. Parameters: n (int): The number of days. temperatures (List[int]): A list of integers representing the daily temperatures. Returns: List[int]: A list where each element denotes the number of days until a warmer temperature is encountered. >>> daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures(5, [30, 40, 50, 60, 70]) [1, 1, 1, 1, 0] >>> daily_temperatures(3, [75, 72, 70]) [0, 0, 0] >>> daily_temperatures(4, [50, 50, 50, 50]) [0, 0, 0, 0] >>> daily_temperatures(5, [80, 70, 60, 50, 40]) [0, 0, 0, 0, 0] >>> daily_temperatures(7, [60, 62, 64, 66, 64, 62, 60]) [1, 1, 1, 0, 0, 0, 0] >>> daily_temperatures(1, [50]) [0]","solution":"def daily_temperatures(n, temperatures): Given a list of daily temperatures, returns a list of the number of days you would have to wait until a warmer temperature. Parameters: n (int): The number of days. temperatures (list of int): A list of integers representing the daily temperatures. Returns: list of int: A list where each element denotes the number of days until a warmer temperature is encountered. answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def minimal_energy(tasks: List[int], priority_index: int) -> int: Calculate the minimal total energy required to complete the tasks in the required order. Parameters: tasks (list): The list of energy for each task. priority_index (int): The index of the high priority task. Returns: int: The minimal total energy required. >>> minimal_energy([50, 30, 20, 10, 40], 2) 150 >>> minimal_energy([100, 50, 30, 20], 1) 200 >>> minimal_energy([60, 30, 10], 0) 100 pass from typing import List def test_minimal_energy_example1(): assert minimal_energy([50, 30, 20, 10, 40], 2) == 150 def test_minimal_energy_example2(): assert minimal_energy([100, 50, 30, 20], 1) == 200 def test_minimal_energy_example3(): assert minimal_energy([60, 30, 10], 0) == 100 def test_minimal_energy_single_priority(): assert minimal_energy([40, 20, 10, 30, 50], 4) == 150 def test_minimal_energy_descending_order(): assert minimal_energy([5, 4, 3, 2, 1], 0) == 15 def test_minimal_energy_random_order(): assert minimal_energy([15, 5, 30, 10], 3) == 60","solution":"def minimal_energy(tasks, priority_index): Calculate the minimal total energy required to complete the tasks in the required order. Parameters: tasks (list): The list of energy for each task. priority_index (int): The index of the high priority task. Returns: int: The minimal total energy required. # Extract the high priority task priority_task = tasks[priority_index] # Get the remaining tasks by excluding the high priority task remaining_tasks = tasks[:priority_index] + tasks[priority_index+1:] # Sort the remaining tasks in ascending order to minimize cumulative energy remaining_tasks.sort() # Calculate the total minimal energy required total_energy = priority_task + sum(remaining_tasks) return total_energy # Example usage print(minimal_energy([50, 30, 20, 10, 40], 2)) # Output: 150 print(minimal_energy([100, 50, 30, 20], 1)) # Output: 200 print(minimal_energy([60, 30, 10], 0)) # Output: 100"},{"question":"def transform_string(s: str) -> (int, str): Transform the given string such that no two adjacent characters are the same. Return the minimum number of operations required to achieve the desired state and an example of the resulting string. >>> transform_string(\\"ab\\") (0, \\"ab\\") >>> transform_string(\\"aa\\") (1, \\"ab\\") >>> transform_string(\\"aaaa\\") (2, \\"abab\\") >>> transform_string(\\"abcabc\\") (0, \\"abcabc\\") >>> transform_string(\\"bbb\\") (1, \\"bab\\") pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process the given number of test cases, apply the transform_string function on each test case, and return the results as a list of strings. >>> process_test_cases(2, [\\"ab\\", \\"aa\\"]) [\\"0nab\\", \\"1nab\\"] >>> process_test_cases(3, [\\"aaa\\", \\"abc\\", \\"a\\"]) [\\"1naba\\", \\"0nabc\\", \\"0na\\"] >>> process_test_cases(1, [\\"a\\"]) [\\"0na\\"] pass","solution":"def transform_string(s): n = len(s) if n == 1: return 0, s # Minimum operations and resulting string min_operations = 0 result = list(s) for i in range(1, n): if result[i] == result[i - 1]: # Change current character to a different one (any of 'a', 'b', 'c' that is different from the previous) for char in 'abc': if char != result[i - 1] and (i == n - 1 or char != result[i + 1]): result[i] = char break min_operations += 1 return min_operations, ''.join(result) def process_test_cases(t, test_cases): results = [] for s in test_cases: min_operations, transformed_string = transform_string(s) results.append(f\\"{min_operations}n{transformed_string}\\") return results"},{"question":"from typing import List def smallest_subarray_with_sum(arr: List[int], k: int) -> int: Determine the length of the smallest subarray with a sum greater than or equal to k. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) 3 >>> smallest_subarray_with_sum([2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subarray_with_sum([1, 4, 4], 8) 2 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"from typing import List def smallest_subarray_with_sum(arr: List[int], k: int) -> int: n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0"},{"question":"def minimum_total_cost(N: int, heights: List[int]) -> int: Determines the minimum total cost required to make the heights of the flowers non-decreasing. Parameters: N (int): The number of flowers. heights (list of int): The initial heights of the flowers. Returns: int: The minimum total cost. >>> minimum_total_cost(5, [4, 2, 3, 1, 5]) 6 >>> minimum_total_cost(1, [5]) 0 >>> minimum_total_cost(5, [1, 2, 3, 4, 5]) 0 >>> minimum_total_cost(5, [3, 3, 3, 3, 3]) 0 >>> minimum_total_cost(3, [3, 2, 4]) 1","solution":"def minimum_total_cost(N, heights): Determines the minimum total cost required to make the heights of the flowers non-decreasing. Parameters: N (int): The number of flowers. heights (list of int): The initial heights of the flowers. Returns: int: The minimum total cost. total_cost = 0 for i in range(1, N): if heights[i] < heights[i - 1]: total_cost += (heights[i - 1] - heights[i]) heights[i] = heights[i - 1] return total_cost"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str], S_x: int, S_y: int, T_x: int, T_y: int) -> int: Compute the shortest path for the robot to move from a starting position (S_x, S_y) to a target position (T_x, T_y) in a lab represented as a grid with obstacles. Return the length of the shortest path (number of steps) or -1 if it is not possible to reach the target. >>> shortest_path(5, 5, [\\".....\\", \\".#.\\", \\"..#..\\", \\".#...\\", \\".....\\"], 0, 0, 4, 4) 8 >>> shortest_path(5, 5, [\\"#\\", \\"#\\", \\"#\\", \\"#\\", \\"#\\"], 0, 0, 4, 4) -1","solution":"from collections import deque def shortest_path(n, m, grid, S_x, S_y, T_x, T_y): # Check if start or end positions are on obstacles if grid[S_x][S_y] == '#' or grid[T_x][T_y] == '#': return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS with starting position queue = deque([(S_x, S_y, 0)]) # (current_x, current_y, current_distance) visited = set((S_x, S_y)) while queue: x, y, dist = queue.popleft() # Check if we reached the target position if (x, y) == (T_x, T_y): return dist # Explore all four possible directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check if new position is within bounds and not an obstacle and not visited if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If queue is empty and we did not reach the target, it's not possible to reach the target return -1"},{"question":"def optimize_warehouse(T, test_cases): Optimizes the arrangement of items in a warehouse to eliminate empty spaces. :param T: Number of test cases. :param test_cases: List of tuples, each containing: - N: Number of positions in the warehouse. - heights: List of integers representing the heights of stacks. :return: List of lists, each representing the final configuration of the warehouse. Unit Test: from solution import optimize_warehouse def test_multiple_cases(): assert optimize_warehouse(3, [(5, [1, 0, 3, 0, 2]), (4, [0, 0, 7, 0]), (6, [1, 2, 0, 0, 4, 0])]) == [ [1, 3, 2, 0, 0], [7, 0, 0, 0], [1, 2, 4, 0, 0, 0] ] def test_single_no_empty(): assert optimize_warehouse(1, [(3, [1, 2, 3])]) == [[1, 2, 3]] def test_single_all_empty(): assert optimize_warehouse(1, [(3, [0, 0, 0])]) == [[0, 0, 0]] def test_single_mixed(): assert optimize_warehouse(1, [(4, [0, 1, 0, 2])]) == [[1, 2, 0, 0]] def test_edge_case_minimum_values(): assert optimize_warehouse(1, [(1, [0])]) == [[0]] assert optimize_warehouse(1, [(1, [1])]) == [[1]] def test_edge_case_larger_values(): assert optimize_warehouse(1, [(5, [100000, 0, 0, 100000, 0])]) == [[100000, 100000, 0, 0, 0]]","solution":"def optimize_warehouse(T, test_cases): Optimizes the arrangement of items in a warehouse to eliminate empty spaces. :param T: Number of test cases. :param test_cases: List of tuples, each containing: - N: Number of positions in the warehouse. - heights: List of integers representing the heights of stacks. :return: List of lists, each representing the final configuration of the warehouse. results = [] for N, heights in test_cases: non_zero_items = [height for height in heights if height != 0] # Collect non-zero heights non_zero_items.extend([0] * (N - len(non_zero_items))) # Fill the remaining positions with zeroes results.append(non_zero_items) return results"},{"question":"from typing import List def sort_characters_by_frequency(s: str) -> str: Sorts characters in a string based on their frequency in descending order. If two characters have the same frequency, they should appear in ascending order in the final result. :param s: Input string :return: Sorted string based on character frequency and then lexicographical order. >>> sort_characters_by_frequency(\\"tree\\") in [\\"eert\\", \\"eetr\\"] True >>> sort_characters_by_frequency(\\"cccaaa\\") == \\"aaaccc\\" True >>> sort_characters_by_frequency(\\"Aabb\\") in [\\"bbAa\\", \\"bbaA\\"] True >>> sort_characters_by_frequency(\\"\\") == \\"\\" True >>> sort_characters_by_frequency(\\"a\\") == \\"a\\" True >>> sort_characters_by_frequency(\\"abcd\\") == \\"abcd\\" True","solution":"from collections import Counter def sort_characters_by_frequency(s): Sorts characters in a string based on their frequency in descending order. If two characters have the same frequency, they will appear in ascending order. :param s: Input string :return: Sorted string based on character frequency and then lexicographical order # Create a counter to count the frequency of each character freq = Counter(s) # Sort the characters first by frequency in descending order, then by character in ascending order sorted_chars = sorted(freq.items(), key=lambda item: (-item[1], item[0])) # Construct the result based on sorted characters and their frequencies result = ''.join(char * count for char, count in sorted_chars) return result"},{"question":"def longestConsecutiveSequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence. >>> longestConsecutiveSequence([100, 4, 200, 1, 3, 2]) 4 >>> longestConsecutiveSequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longestConsecutiveSequence([]) 0 >>> longestConsecutiveSequence([10]) 1 >>> longestConsecutiveSequence([10, 20, 30, 40, 50]) 1 >>> longestConsecutiveSequence([1, 2, 2, 3, 4, 4, 5, 6, 7, 8, 9]) 9","solution":"def longestConsecutiveSequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # check if it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def can_transform(source: str, target: str) -> str: Determines if source can be transformed into target by deleting some characters from source. >>> can_transform(\\"abcde\\", \\"abc\\") 'YES' >>> can_transform(\\"abcdef\\", \\"azc\\") 'NO'","solution":"def can_transform(source, target): Determines if source can be transformed into target by deleting some characters from source. it = iter(source) return \\"YES\\" if all(char in it for char in target) else \\"NO\\""},{"question":"def max_sublists_with_distinct_integers(n: int, arr: List[int]) -> int: Returns the maximum number of contiguous sublists such that each sublist contains only distinct integers. >>> max_sublists_with_distinct_integers(5, [1, 2, 3, 1, 2]) 3 >>> max_sublists_with_distinct_integers(7, [4, 4, 4, 4, 4, 4, 4]) 7 from max_sublists_with_distinct_integers import longest_common_prefix def test_example_1(): assert max_sublists_with_distinct_integers(5, [1, 2, 3, 1, 2]) == 3 def test_example_2(): assert max_sublists_with_distinct_integers(7, [4, 4, 4, 4, 4, 4, 4]) == 7 def test_no_repeat_elements(): assert max_sublists_with_distinct_integers(5, [1, 2, 3, 4, 5]) == 1 def test_all_elements_same(): assert max_sublists_with_distinct_integers(4, [1, 1, 1, 1]) == 4 def test_single_element(): assert max_sublists_with_distinct_integers(1, [5]) == 1 def test_some_repeats(): assert max_sublists_with_distinct_integers(5, [1, 2, 1, 3, 4]) == 2 def test_large_numbers(): assert max_sublists_with_distinct_integers(4, [1000000000, -1000000000, 1000000000, -1000000000]) == 3","solution":"def max_sublists_with_distinct_integers(n, arr): Returns the maximum number of contiguous sublists such that each sublist contains only distinct integers. last_seen = {} count = 0 start_idx = 0 for i in range(n): if arr[i] in last_seen and last_seen[arr[i]] >= start_idx: start_idx = last_seen[arr[i]] + 1 count += 1 last_seen[arr[i]] = i return count + 1"},{"question":"def max_interviews(n: int, m: int, intervals: List[Tuple[int, int]]) -> int: A Hiring Manager needs to assign n interviews to m interviewers. Each interview i is characterized by a start time start_{i} and an end time end_{i} (start_{i}  end_{i}). Each interviewer can conduct at most one interview at any given time. Given the time slots for each interview, what is the maximum number of interviews that can be conducted simultaneously by the m interviewers? Args: n : int : The number of interviews m : int : The number of interviewers intervals : List[Tuple[int, int]] : Each tuple contains the start and end time of an interview Returns: int : The maximum number of interviews that can be conducted simultaneously by the m interviewers >>> max_interviews(3, 2, [(1, 5), (2, 6), (6, 10)]) 2 >>> max_interviews(4, 3, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3 >>> max_interviews(5, 2, [(1, 3), (2, 4), (3, 5), (1, 2), (4, 6)]) 2 pass","solution":"from heapq import heappop, heappush def max_interviews(n, m, intervals): # sort intervals by their end times intervals.sort(key=lambda x: x[1]) # min heap to keep track of end times of ongoing interviews end_times = [] count = 0 for interval in intervals: start, end = interval if len(end_times) < m: heappush(end_times, end) count += 1 else: if end_times[0] <= start: heappop(end_times) heappush(end_times, end) count += 1 return min(count, m)"},{"question":"def largest_square_submatrix(n, matrix): Finds the size of the largest square submatrix that consists entirely of the same integer. Args: n (int): Dimension of the matrix (n x n) matrix (List[List[int]]): The n x n matrix filled with integers. Returns: int: The size of the largest square submatrix. Examples: >>> largest_square_submatrix(4, [ [1, 2, 3, 4], [5, 5, 5, 5], [5, 5, 5, 5], [7, 8, 9, 0] ]) 2 >>> largest_square_submatrix(3, [ [1, 1, 1], [1, 2, 2], [1, 2, 2] ]) 2 >>> largest_square_submatrix(5, [ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1] ]) 5 pass # Implement the function here","solution":"def largest_square_submatrix(n, matrix): if n == 0: return 0 dp = [[1] * n for _ in range(n)] max_size = 1 for i in range(1, n): for j in range(1, n): if matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"from typing import List def multiples(n: int, m: int) -> List[int]: Write a function that takes two integers \`n\` and \`m\`, and returns a list containing the first \`n\` multiples of \`m\`. If \`n\` is 5 and \`m\` is 3, the function should return [3, 6, 9, 12, 15]. If \`n\` is negative or zero, return an empty list. >>> multiples(5, 3) [3, 6, 9, 12, 15] >>> multiples(4, 2) [2, 4, 6, 8] >>> multiples(1, 7) [7] >>> multiples(5, -3) [-3, -6, -9, -12, -15] >>> multiples(0, 5) [] >>> multiples(-5, 3) [] pass","solution":"from typing import List def multiples(n: int, m: int) -> List[int]: Returns a list containing the first \`n\` multiples of \`m\`. if n <= 0: return [] return [i * m for i in range(1, n + 1)]"},{"question":"def caesar_cipher_rotation(n: int, s: str) -> str: Apply a right rotation (Caesar Cipher) to the string s by n positions. >>> caesar_cipher_rotation(3, 'abcdef') 'defabc' >>> caesar_cipher_rotation(2, 'hello') 'lohel' >>> caesar_cipher_rotation(6, 'rotate') 'rotate' >>> caesar_cipher_rotation(0, 'example') 'example'","solution":"def caesar_cipher_rotation(n, s): Apply a right rotation (Caesar Cipher) to the string s by n positions. n = n % len(s) # Ensure n is within the range of the string's length return s[-n:] + s[:-n]"},{"question":"def has_2x2_subgrid_with_two_trees(n, m, k, tree_positions): Determine if a 2x2 subgrid contains at least two trees. >>> has_2x2_subgrid_with_two_trees(5, 5, 4, [(1, 1), (2, 2), (3, 3), (1, 3)]) == \\"NO\\" >>> has_2x2_subgrid_with_two_trees(4, 4, 5, [(1, 1), (1, 2), (2, 1), (2, 2), (3, 3)]) == \\"YES\\"","solution":"def has_2x2_subgrid_with_two_trees(n, m, k, tree_positions): from collections import defaultdict # Create a set to store the position of trees tree_set = set() for r, c in tree_positions: tree_set.add((r, c)) # Check each 2x2 subgrid for at least two trees for r, c in tree_positions: if (r + 1, c) in tree_set and (r, c + 1) in tree_set: return \\"YES\\" if (r + 1, c) in tree_set and (r + 1, c + 1) in tree_set: return \\"YES\\" if (r, c + 1) in tree_set and (r + 1, c + 1) in tree_set: return \\"YES\\" return \\"NO\\""},{"question":"def max_product_partition(arr: List[int]) -> int: Given an array of integers, partition the array into two non-empty contiguous subarrays such that the sum of the elements in the first subarray multiplied by the sum of the elements in the second subarray is maximized. :param arr: List of integers :return: Maximum product that can be obtained >>> max_product_partition([1, 2, 3, 4, 5]) 54 >>> max_product_partition([1, 1, 1]) 2 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return the maximum products for each case. :param test_cases: List of tuples where each tuple consists of an integer N and a list of N integers :return: List of integers representing the maximum product for each test case >>> process_test_cases([(5, [1, 2, 3, 4, 5]), (3, [1, 1, 1])]) [54, 2] pass","solution":"def max_product_partition(arr): n = len(arr) prefix_sum = [0] * n total_sum = sum(arr) max_product = 0 prefix_sum[0] = arr[0] for i in range(1, n): prefix_sum[i] = prefix_sum[i - 1] + arr[i] for i in range(n - 1): sum1 = prefix_sum[i] sum2 = total_sum - sum1 max_product = max(max_product, sum1 * sum2) return max_product def process_test_cases(test_cases): results = [] for tc in test_cases: n = tc[0] arr = tc[1] results.append(max_product_partition(arr)) return results"},{"question":"def compress_path(path: str) -> str: Compress a file path by replacing sequences of identical sub-directory names with the name followed by the number of occurrences. :param path: The input file path :type path: str :return: The compressed file path :rtype: str pass # Test cases def test_basic_example(): assert compress_path(\\"path/compression/compression/compression/test\\") == \\"path/compression3/test\\" def test_multiple_sequences(): assert compress_path(\\"a/b/b/b/b/c/c/d/d/d/d/d\\") == \\"a/b4/c2/d5\\" def test_no_compression_needed(): assert compress_path(\\"folder/subfolder/file.txt\\") == \\"folder/subfolder/file.txt\\" def test_single_element(): assert compress_path(\\"folder\\") == \\"folder\\" def test_empty_string(): assert compress_path(\\"\\") == \\"\\" def test_single_repeated_element(): assert compress_path(\\"a/a/a/a/a/a\\") == \\"a6\\" def test_mixed_repetitions(): assert compress_path(\\"x/x/x/y/y/z/z/z/z\\") == \\"x3/y2/z4\\"","solution":"def compress_path(path: str) -> str: Compress a file path by replacing sequences of identical sub-directory names with the name followed by the number of occurrences. :param path: The input file path :type path: str :return: The compressed file path :rtype: str if not path: return \\"\\" parts = path.split('/') compressed_parts = [] current = parts[0] count = 1 for part in parts[1:]: if part == current: count += 1 else: if count > 1: compressed_parts.append(f\\"{current}{count}\\") else: compressed_parts.append(current) current = part count = 1 if count > 1: compressed_parts.append(f\\"{current}{count}\\") else: compressed_parts.append(current) return \\"/\\".join(compressed_parts)"},{"question":"def find_peak_element(grid): Given a 2D grid of integers, find one peak element in the grid. A peak element is an element which is greater than or equal to its directly adjacent neighbors. >>> find_peak_element([ ... [10, 20, 15], ... [21, 30, 14], ... [7, 16, 32] ... ]) in {30, 32} >>> find_peak_element([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 9 >>> find_peak_element([[1]]) == 1 >>> find_peak_element([ ... [10, 10], ... [10, 10] ... ]) == 10 >>> find_peak_element([ ... [-10, -20, -30], ... [-5, 0, -25], ... [-15, -30, -10] ... ]) == 0 >>> find_peak_element([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 16 pass","solution":"def find_peak_element(grid): Given a 2D grid of integers, find one peak element in the grid. A peak element is an element which is greater than or equal to its directly adjacent neighbors. n = len(grid) def is_peak(i, j): current = grid[i][j] if i > 0 and current < grid[i-1][j]: return False if i < n-1 and current < grid[i+1][j]: return False if j > 0 and current < grid[i][j-1]: return False if j < n-1 and current < grid[i][j+1]: return False return True for i in range(n): for j in range(n): if is_peak(i, j): return grid[i][j] return None # if no peak is found (though there should always be at least one peak)"},{"question":"def calculate_final_scores(num_participants, num_problems, scores, flawed_problem_index): Calculate the final scores of each participant after excluding the flawed problem scores. Parameters: num_participants (int): The number of participants. num_problems (int): The number of problems. scores (list of list of int): The scores of each participant for each problem. flawed_problem_index (int): The index of the flawed problem to be excluded (1-based index). Returns: list of int: Final scores of each participant after excluding the flawed problem scores. Example: >>> calculate_final_scores(4, 5, [[10, 20, 30, 40, 50], [15, 25, 5, 35, 45], [0, 10, 20, 30, 40], [5, 15, 25, 35, 45]], 3) [120, 120, 80, 100] >>> calculate_final_scores(1, 1, [[99]], 1) [0]","solution":"def calculate_final_scores(num_participants, num_problems, scores, flawed_problem_index): Calculate the final scores of each participant after excluding the flawed problem scores. Parameters: num_participants (int): The number of participants. num_problems (int): The number of problems. scores (list of list of int): The scores of each participant for each problem. flawed_problem_index (int): The index of the flawed problem to be excluded (1-based index). Returns: list of int: Final scores of each participant after excluding the flawed problem scores. final_scores = [] flawed_problem_index -= 1 # Convert to 0-based index for i in range(num_participants): # Calculate the sum of scores excluding the flawed problem final_score = sum(scores[i][j] for j in range(num_problems) if j != flawed_problem_index) final_scores.append(final_score) return final_scores"},{"question":"def num_islands(grid): Returns the number of islands in the given grid. >>> num_islands([['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '1', '1'], ['0', '0', '0', '1', '1']]) 2 >>> num_islands([['1', '1', '0', '0', '0'], ['1', '0', '0', '1', '1'], ['0', '0', '1', '1', '0'], ['0', '0', '0', '0', '0'], ['1', '1', '0', '0', '1']]) 4 >>> num_islands([['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0']]) 0 >>> num_islands([['1']]) 1 >>> num_islands([['0']]) 0 def count_islands(test_cases): Returns a list with the number of islands in each grid from the given test cases. >>> count_islands([ [['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '1', '1'], ['0', '0', '0', '1', '1']], [['1', '1', '0', '0', '0'], ['1', '0', '0', '1', '1'], ['0', '0', '1', '1', '0'], ['0', '0', '0', '0', '0'], ['1', '1', '0', '0', '1']] ]) [2, 4]","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '0': return grid[x][y] = '0' # Mark it as visited # Recursively visit all adjacent lands dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) n = len(grid) m = len(grid[0]) count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': count += 1 dfs(i, j) return count def count_islands(test_cases): results = [] for grid in test_cases: results.append(num_islands(grid)) return results"},{"question":"def balance_reactions(T: int, reactions: List[str]) -> List[str]: Determines if the given chemical reactions are balanced. >>> balance_reactions(3, [\\"H2 + O2 -> H2O\\", \\"C6H12O6 + O2 -> CO2 + H2O\\", \\"CH4 + 2O2 -> CO2 + 2H2O\\"]) [\\"Unbalanced\\", \\"Unbalanced\\", \\"Balanced\\"] >>> balance_reactions(1, [\\"Na2CO3 + 2HCl -> 2NaCl + H2O + CO2\\"]) [\\"Balanced\\"] from solution import balance_reactions def test_single_atomic_element(): reactions = [\\"H2 -> H2\\"] assert balance_reactions(1, reactions) == [\\"Balanced\\"] def test_simple(): reactions = [\\"H2 + O2 -> H2O\\"] assert balance_reactions(1, reactions) == [\\"Unbalanced\\"] def test_glucose_reaction(): reactions = [\\"C6H12O6 + 6O2 -> 6CO2 + 6H2O\\"] assert balance_reactions(1, reactions) == [\\"Balanced\\"] def test_methane_combustion(): reactions = [\\"CH4 + 2O2 -> CO2 + 2H2O\\"] assert balance_reactions(1, reactions) == [\\"Balanced\\"] def test_multiple_reactions(): reactions = [ \\"H2 + O2 -> H2O\\", \\"C6H12O6 + 6O2 -> 6CO2 + 6H2O\\", \\"CH4 + 2O2 -> CO2 + 2H2O\\" ] assert balance_reactions(3, reactions) == [\\"Unbalanced\\", \\"Balanced\\", \\"Balanced\\"] def test_complex_case(): reactions = [\\"Na2CO3 + 2HCl -> 2NaCl + H2O + CO2\\"] assert balance_reactions(1, reactions) == [\\"Balanced\\"]","solution":"import re from collections import defaultdict def parse_formula(formula): element_counts = defaultdict(int) elements = re.findall(r'([A-Z][a-z]?)(d*)', formula) for element, count in elements: count = int(count) if count else 1 element_counts[element] += count return element_counts def parse_side(side): total_counts = defaultdict(int) single_formulas = side.split('+') for formula in single_formulas: # Remove leading/trailing whitespace formula = formula.strip() # Parse coefficient if exists coeff_match = re.match(r'(d+)([A-Z])', formula) if coeff_match: coeff = int(coeff_match.group(1)) actual_formula = formula[len(str(coeff)):] parsed = parse_formula(actual_formula) for element, count in parsed.items(): total_counts[element] += coeff * count else: parsed = parse_formula(formula) for element, count in parsed.items(): total_counts[element] += count return total_counts def is_balanced_reaction(reaction): reactants, products = reaction.split('->') reactants = parse_side(reactants) products = parse_side(products) return reactants == products def balance_reactions(T, reactions): results = [] for reaction in reactions: if is_balanced_reaction(reaction): results.append(\\"Balanced\\") else: results.append(\\"Unbalanced\\") return results"},{"question":"def can_prepare_cookies(N: int, M: int) -> str: Determine if it is possible to prepare exactly N different types of cookies using M available ingredients in unique combinations. :param N: int - Number of different types of cookies needed :param M: int - Number of available ingredients :return: str - \\"Possible\\" if it is possible to prepare exactly N different types, otherwise \\"Impossible\\" >>> can_prepare_cookies(5, 3) 'Possible' >>> can_prepare_cookies(10, 3) 'Impossible'","solution":"def can_prepare_cookies(N, M): Determine if it is possible to prepare exactly N different types of cookies using M available ingredients in unique combinations. :param N: int - Number of different types of cookies needed :param M: int - Number of available ingredients :return: str - \\"Possible\\" if it is possible to prepare exactly N different types, otherwise \\"Impossible\\" # Calculate the maximum number of unique combinations using M ingredients max_combinations = 2 ** M - 1 # 2^M produces all subsets, subtract 1 to exclude the empty set if N <= max_combinations: return \\"Possible\\" else: return \\"Impossible\\""},{"question":"def min_cost_to_connect_all_trees(N, M, power_levels, pathways): Determines the minimum cost to connect all mystical trees in the forest such that all trees have the same power level in the end. If its not possible, returns -1. >>> min_cost_to_connect_all_trees(4, 5, [10, 20, 30, 40], [(1, 2, 5), (1, 3, 10), (2, 3, 6), (2, 4, 8), (3, 4, 3)]) 14 >>> min_cost_to_connect_all_trees(3, 3, [1, 2, 3], [(1, 2, 1), (2, 3, 1), (1, 3, 1)]) 2 >>> min_cost_to_connect_all_trees(2, 1, [1000000000, 1000000000], [(1, 2, 100)]) 100 >>> min_cost_to_connect_all_trees(5, 0, [10, 20, 30, 40, 50], []) -1 >>> min_cost_to_connect_all_trees(4, 6, [10, 20, 30, 40], [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 3), (3, 4, 5), (1, 4, 7)]) 6 # Write your code here","solution":"def min_cost_to_connect_all_trees(N, M, power_levels, pathways): parent = list(range(N)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX pathways.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for u, v, cost in pathways: if find(u - 1) != find(v - 1): union(u - 1, v - 1) total_cost += cost edges_used += 1 if edges_used == N - 1: break if edges_used == N - 1: return total_cost else: return -1"},{"question":"def unique_words_count(sentence: str) -> int: Implement a function \`unique_words_count(sentence)\` that takes a string sentence as input and returns the number of unique words in it. The words in the sentence are separated by spaces and can contain only alphabetic characters (both lowercase and uppercase). The words are case-insensitive, meaning 'Apple' and 'apple' should be considered the same word. Example: >>> unique_words_count(\\"Hello world\\") 2 >>> unique_words_count(\\"The quick brown fox jumps over the lazy dog\\") 8 >>> unique_words_count(\\"apple Apple aPPle\\") 1","solution":"def unique_words_count(sentence): Returns the number of unique words in the input sentence. The words are case-insensitive. words = sentence.lower().split() unique_words = set(words) return len(unique_words)"},{"question":"def count_unique_books(book_ids: list) -> int: Returns the count of unique book IDs in the list. Parameters: book_ids (list): List of integers representing book IDs. Returns: int: Count of unique book IDs. >>> count_unique_books([4, 5, 2, 2, 8, 4, 7, 5]) 5 >>> count_unique_books([1, 1, 1, 1, 1, 1]) 1","solution":"def count_unique_books(book_ids): Returns the count of unique book IDs in the list. Parameters: book_ids (list): List of integers representing book IDs. Returns: int: Count of unique book IDs. return len(set(book_ids))"},{"question":"from typing import List, Tuple def binary_tree_paths(N: int, edges: List[Tuple[int, int]]) -> Tuple[int, int]: Given a binary tree with N nodes and a list of edges, find the maximum Z-path length and the maximum O-path length. >>> binary_tree_paths(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) (3, 3) >>> binary_tree_paths(4, [(1, 2), (2, 3), (3, 4)]) (3, 3) >>> binary_tree_paths(1, []) (0, 0)","solution":"import sys from collections import defaultdict, deque sys.setrecursionlimit(200000) def find_diameter(tree, N): def bfs(node): visited = [-1] * (N + 1) queue = deque([node]) visited[node] = 0 max_dist, farthest_node = 0, node while queue: cur = queue.popleft() current_dist = visited[cur] if current_dist > max_dist: max_dist = current_dist farthest_node = cur for neighbor in tree[cur]: if visited[neighbor] == -1: visited[neighbor] = current_dist + 1 queue.append(neighbor) return farthest_node, max_dist # Find the farthest node from an arbitrary node (usually start with node 1) farthest_node, _ = bfs(1) # Then, find the farthest node from the previously found node, which gives the diameter farthest_node, diameter = bfs(farthest_node) return diameter def binary_tree_paths(N, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Maximum O-path length is the diameter of the tree max_opath = find_diameter(tree, N) # For maximum Z-path (between leaf nodes), is also measured by diameter max_zpath = max_opath return max_zpath, max_opath # Example to gather output for provided test case if __name__ == \\"__main__\\": sample_input = '''5 1 2 1 3 2 4 2 5''' lines = sample_input.split('n') N = int(lines[0]) edges = [tuple(map(int, line.split())) for line in lines[1:]] result = binary_tree_paths(N, edges) print(result) # For demonstration printing the result"},{"question":"def is_leap_year(year): Determines if a given year is a leap year. Returns \\"Yes\\" if the year is a leap year, otherwise \\"No\\". pass def process_years(years): Process a list of years and return a list of results for each year. Each result is either \\"Yes\\" or \\"No\\", until a year 0 which signifies the end. pass def test_is_leap_year(): assert is_leap_year(2000) == \\"Yes\\" assert is_leap_year(1996) == \\"Yes\\" assert is_leap_year(1900) == \\"No\\" assert is_leap_year(2001) == \\"No\\" assert is_leap_year(0) == None def test_process_years(): assert process_years([2000, 1996, 1900, 2001, 0]) == [\\"Yes\\", \\"Yes\\", \\"No\\", \\"No\\"] assert process_years([2004, 1800, 1700, 1600, 0]) == [\\"Yes\\", \\"No\\", \\"No\\", \\"Yes\\"] assert process_years([2020, 2019, 2018, 0]) == [\\"Yes\\", \\"No\\", \\"No\\"] if __name__ == \\"__main__\\": test_is_leap_year() test_process_years() print(\\"All tests passed.\\")","solution":"def is_leap_year(year): Determines if a given year is a leap year. Returns \\"Yes\\" if the year is a leap year, otherwise \\"No\\". if year == 0: return None # Special case for input ending if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Yes\\" else: return \\"No\\" def process_years(years): Process a list of years and return a list of results for each year. Each result is either \\"Yes\\" or \\"No\\", until a year 0 which signifies the end. results = [] for year in years: if year == 0: break result = is_leap_year(year) results.append(result) return results"},{"question":"def can_form_palindrome(T, strings): Determine if each string can be rearranged to form a palindrome by deleting any number of characters. Parameters: T (int): Number of test cases. strings (List[str]): List of strings to be checked. Returns: List[str]: \\"YES\\" or \\"NO\\" for each string.","solution":"def can_form_palindrome(T, strings): Determine if each string can be rearranged to form a palindrome by deleting any number of characters. Parameters: T (int): Number of test cases. strings (List[str]): List of strings to be checked. Returns: List[str]: \\"YES\\" or \\"NO\\" for each string. results = [] for s in strings: from collections import Counter char_counts = Counter(s) # Count characters with odd occurrences odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd count results.append(\\"YES\\" if odd_count <= 1 else \\"NO\\") return results"},{"question":"def min_blocks_to_remove(n: int, heights: List[int]) -> int: Given an array of integers which represents the heights of stable building blocks where each element in the array represents the height of a block, this function returns the minimum number of blocks to be removed so that no two adjacent blocks are of the same height. Parameters: n (int): Number of blocks heights (list of int): List of heights of the blocks Returns: int: Minimum number of blocks to be removed >>> min_blocks_to_remove(8, [3, 3, 2, 1, 3, 3, 2, 1]) 2 >>> min_blocks_to_remove(5, [1, 2, 3, 4, 5]) 0 >>> min_blocks_to_remove(4, [2, 2, 2, 2]) 3 >>> min_blocks_to_remove(1, [2]) 0 >>> min_blocks_to_remove(6, [1, 2, 1, 2, 1, 2]) 0 >>> min_blocks_to_remove(5, [1, 2, 3, 4, 5]) 0 >>> min_blocks_to_remove(5, [1, 1, 1, 1, 1]) 4","solution":"def min_blocks_to_remove(n, heights): This function computes the minimum number of blocks to be removed so that no two adjacent blocks have the same height. Parameters: n (int): Number of blocks heights (list of int): List of heights of the blocks Returns: int: Minimum number of blocks to be removed if n == 1: return 0 remove_count = 0 for i in range(1, n): if heights[i] == heights[i - 1]: remove_count += 1 return remove_count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def spiralOrderTraversal(root): Given a binary tree, return the spiral order traversal of its nodes' values. Spiral order traversal or zigzag traversal is where the nodes are visited in an alternating left-to-right and right-to-left pattern for each level. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> spiralOrderTraversal(root) [1, 3, 2, 4, 5, 6, 7] >>> root = TreeNode(10) >>> root.left = TreeNode(20) >>> root.right = TreeNode(30) >>> root.left.left = TreeNode(40) >>> root.left.right = TreeNode(60) >>> spiralOrderTraversal(root) [10, 30, 20, 40, 60]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def spiralOrderTraversal(root): if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [node.val for node in current_level] if not left_to_right: level_values.reverse() result.extend(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return result"},{"question":"from typing import List def can_reach_bottom_right(m: int, n: int, grid: List[str]) -> str: Determine if it's possible for the player to reach the bottom-right corner from the top-left corner. The grid contains 'H' for habitable cells and 'I' for inhabitable cells. >>> can_reach_bottom_right(3, 3, [\\"HHH\\", \\"HIH\\", \\"HHH\\"]) 'YES' >>> can_reach_bottom_right(3, 3, [\\"HHH\\", \\"IHH\\", \\"HHI\\"]) 'NO' >>> can_reach_bottom_right(1, 1, [\\"H\\"]) 'YES' >>> can_reach_bottom_right(1, 1, [\\"I\\"]) 'NO' Returns: 'YES' if the player can reach the bottom-right corner, otherwise 'NO'.","solution":"def can_reach_bottom_right(m, n, grid): from collections import deque if grid[0][0] == 'I' or grid[m-1][n-1] == 'I': return \\"NO\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m-1 and y == n-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 'H': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def move_evens_to_beginning(nums): This function takes a list of integers and returns a new list with all even numbers moved to the beginning, followed by all the odd numbers. The relative order of the even and odd numbers is preserved. :param nums: List[int] - a list of integers. :return: List[int] - a rearranged list with evens at the beginning and odds at the end. >>> move_evens_to_beginning([1, 2, 3, 4]) [2, 4, 1, 3] >>> move_evens_to_beginning([3, 1, 2, 4, 5]) [2, 4, 3, 1, 5] >>> move_evens_to_beginning([4, 2, 3, 1]) [4, 2, 3, 1] >>> move_evens_to_beginning([1, 3, 5, 7]) [1, 3, 5, 7] >>> move_evens_to_beginning([2, 4, 6, 8]) [2, 4, 6, 8] >>> move_evens_to_beginning([]) [] def process_test_cases(T, test_cases): This function processes multiple test cases and returns results for each case. :param T: The number of test cases. :param test_cases: A list of tuples, each containing: - An integer N, the number of elements in the array. - A list of N integers (the array \`nums\`). :return: A list of arrays, each rearranged according to the problem statement. >>> process_test_cases(2, [(4, [1, 2, 3, 4]), (5, [3, 1, 2, 4, 5])]) [[2, 4, 1, 3], [2, 4, 3, 1, 5]] >>> process_test_cases(1, [(3, [3, 3, 3])]) [[3, 3, 3]] >>> process_test_cases(1, [(3, [2, 4, 6])]) [[2, 4, 6]] >>> process_test_cases(1, [(6, [10, 3, 5, 7, 8, 2])]) [[10, 8, 2, 3, 5, 7]]","solution":"def move_evens_to_beginning(nums): This function takes a list of integers and returns a new list with all even numbers moved to the beginning, followed by all the odd numbers. The relative order of the even and odd numbers is preserved. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds def process_test_cases(T, test_cases): This function processes multiple test cases and returns results for each case. :param T: The number of test cases. :param test_cases: A list of tuples, each containing: - An integer N, the number of elements in the array. - A list of N integers (the array \`nums\`). :return: A list of arrays, each rearranged according to the problem statement. results = [] for i in range(T): N, nums = test_cases[i] result = move_evens_to_beginning(nums) results.append(result) return results"},{"question":"def find_pair(arr: List[int], target: int) -> bool: Determines if there are two distinct elements in the array whose sum is equal to the target sum. >>> find_pair([1, 2, 3, 9], 8) => False >>> find_pair([1, 2, 4, 4], 8) => True >>> find_pair([-1, 3, 2, 5], 1) => True >>> find_pair([5, 7, 1, 2, 8, 4, 3], 10) => True","solution":"def find_pair(arr, target): Determines if there are two distinct elements in the array whose sum is equal to the target sum. seen = set() for number in arr: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def maxProduct(arr): Returns the maximum product that can be obtained by multiplying two different elements of the array. >>> maxProduct([1, 20, 30, 4]) 600 >>> maxProduct([-10, -3, 5]) 30 >>> maxProduct([1, 2, 3, 4]) 12 >>> maxProduct([0, -1, -2, -3]) 6 >>> maxProduct([1000, -1000]) -1000000 def process_test_cases(input_data): Processes multiple test cases for finding maximum products of arrays. >>> input_data = [\\"2\\", \\"4\\", \\"1 20 30 4\\", \\"3\\", \\"-10 -3 5\\"] >>> process_test_cases(input_data) [600, 30] >>> input_data = [\\"3\\", \\"3\\", \\"1 2 3\\", \\"4\\", \\"-1 -2 -3 0\\", \\"2\\", \\"1000 -1000\\"] >>> process_test_cases(input_data) [6, 6, -1000000]","solution":"def maxProduct(arr): Returns the maximum product that can be obtained by multiplying two different elements of the array. if len(arr) < 2: return None # Initialize the maximum and second maximum element for positive numbers max1 = max2 = float('-inf') # Initialize the minimum and second minimum element for negative numbers min1 = min2 = float('inf') for num in arr: if num > max1: max1, max2 = num, max1 elif num > max2: max2 = num if num < min1: min1, min2 = num, min1 elif num < min2: min2 = num # Maximum product is either the product of the two largest numbers # or the product of the two smallest numbers (in case they are negative) return max(max1 * max2, min1 * min2) def process_test_cases(input_data): index = 0 T = int(input_data[index]) index += 1 results = [] for _ in range(T): N = int(input_data[index]) index += 1 arr = list(map(int, input_data[index].split())) index += 1 results.append(maxProduct(arr)) return results"},{"question":"def maxSumContinuousSubarray(arr: List[int]) -> int: Returns the maximum sum of any continuous subarray. If the array contains only negative numbers, returns 0. >>> maxSumContinuousSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSumContinuousSubarray([-5, -2, -3]) 0 >>> maxSumContinuousSubarray([5]) 5 >>> maxSumContinuousSubarray([-5]) 0 >>> maxSumContinuousSubarray([1, 2, 3, -2, 5]) 9 >>> maxSumContinuousSubarray([0, 0, 0, 0, 0]) 0 >>> maxSumContinuousSubarray([4, -1, 2, 1]) 6 >>> maxSumContinuousSubarray([-1, 2, 3, -6, 4, 5, -2]) 9 >>> maxSumContinuousSubarray([1, 2, 3, 4, 5]) 15 >>> maxSumContinuousSubarray([-100, -200, -300]) 0","solution":"def maxSumContinuousSubarray(arr): Returns the maximum sum of any continuous subarray. If the array contains only negative numbers, returns 0. # Initialize variables max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current # If array contains only negative numbers, consider the empty subarray if max_global < 0: return 0 return max_global"},{"question":"def minimum_teams(n, skill_levels): Determines the minimum number of teams from participants with distinct skill levels. Each team consists of exactly three participants with consecutive integers. # Implement your solution here. # You can use the following test cases to validate your solution: from solution import minimum_teams def test_minimum_teams_example1(): assert minimum_teams(6, [1, 3, 2, 5, 6, 4]) == 2 def test_minimum_teams_example2(): assert minimum_teams(7, [10, 14, 13, 12, 11, 15, 16]) == 2 def test_minimum_teams_example3(): assert minimum_teams(5, [8, 6, 7, 5, 11]) == 1 def test_minimum_teams_no_team_possible(): assert minimum_teams(4, [1, 2, 4, 5]) == 0 def test_minimum_teams_large_input(): assert minimum_teams(10, [1000000, 999999, 999998, 3, 2, 1, 6, 5, 4, 7]) == 3 def test_minimum_teams_one_possible_team(): assert minimum_teams(3, [10, 11, 12]) == 1 def test_minimum_teams_no_teams_when_less_than_minimum_participants(): assert minimum_teams(2, [1, 2]) == 0 def test_minimum_teams_disconnected_teams(): assert minimum_teams(7, [1, 2, 3, 10, 11, 12, 4]) == 2","solution":"def minimum_teams(n, skill_levels): Determines the minimum number of teams from participants with distinct skill levels. Each team consists of exactly three participants with consecutive integers. skill_levels.sort() teams_formed = 0 i = 0 while i <= n - 3: if skill_levels[i] + 1 == skill_levels[i + 1] and skill_levels[i + 1] + 1 == skill_levels[i + 2]: teams_formed += 1 i += 3 else: i += 1 return teams_formed"},{"question":"def minMeetingRooms(intervals): Given a list of meeting time intervals consisting of start and end times, determine the minimum number of conference rooms required. :param intervals: List of tuples [(start, end), ...] :return: Minimum number of conference rooms required >>> minMeetingRooms([(1, 4), (2, 5), (7, 9)]) == 2 >>> minMeetingRooms([(0, 1), (2, 3), (4, 5), (6, 7)]) == 1 >>> minMeetingRooms([(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)]) == 2 >>> minMeetingRooms([(6, 7)]) == 1 >>> minMeetingRooms([(1, 4), (1, 4), (1, 4)]) == 3 >>> minMeetingRooms([]) == 0 >>> minMeetingRooms([(1, 10), (2, 3), (4, 5), (6, 7), (8, 9)]) == 2 >>> minMeetingRooms([(1, 3), (1, 3), (1, 3)]) == 3","solution":"def minMeetingRooms(intervals): Given a list of meeting time intervals consisting of start and end times, determine the minimum number of conference rooms required. :param intervals: List of tuples [(start, end), ...] :return: Minimum number of conference rooms required if not intervals: return 0 # Separate out the start and end times start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) s_ptr, e_ptr = 0, 0 used_rooms = 0 max_rooms = 0 while s_ptr < len(start_times): if start_times[s_ptr] < end_times[e_ptr]: used_rooms += 1 s_ptr += 1 else: used_rooms -= 1 e_ptr += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def number_of_books_in_sections(n, books, q, queries): Determines the number of books in the given sections based on the queries. :param n: Number of sections in the library :param books: List containing the number of books in each section :param q: Number of queries :param queries: List of queries where each query is a section number :return: List containing the number of books in the queried sections Example: >>> number_of_books_in_sections(5, [12, 7, 22, 15, 9], 3, [1, 3, 5]) == [12, 22, 9] >>> number_of_books_in_sections(3, [5, 10, 20], 2, [1, 2]) == [5, 10] >>> number_of_books_in_sections(4, [8, 16, 24, 32], 4, [4, 3, 2, 1]) == [32, 24, 16, 8]","solution":"def number_of_books_in_sections(n, books, q, queries): Determines the number of books in the given sections based on the queries. :param n: Number of sections in the library :param books: List containing the number of books in each section :param q: Number of queries :param queries: List of queries where each query is a section number :return: List containing the number of books in the queried sections result = [] for query in queries: result.append(books[query - 1]) return result"},{"question":"def detect_cycle(n: int) -> str: Determine if the sequence starting with a given number will get stuck in a cycle. >>> detect_cycle(19) == \\"No Cycle\\" >>> detect_cycle(116) == \\"Cycle\\" pass # Unit Tests def test_no_cycle(): assert detect_cycle(19) == \\"No Cycle\\" def test_cycle(): assert detect_cycle(116) == \\"Cycle\\" assert detect_cycle(4) == \\"Cycle\\" def test_no_cycle_for_1(): assert detect_cycle(1) == \\"No Cycle\\" def test_large_number(): assert detect_cycle(1234567) == \\"Cycle\\" def test_known_cycle(): assert detect_cycle(145) == \\"Cycle\\"","solution":"def sum_of_squares_of_digits(n): return sum(int(digit) ** 2 for digit in str(n)) def detect_cycle(n): seen_numbers = set() while n not in seen_numbers: if n == 1: return \\"No Cycle\\" seen_numbers.add(n) n = sum_of_squares_of_digits(n) return \\"Cycle\\""},{"question":"def normalize_path(path: str) -> str: Normalizes the given file path by removing \\".\\", \\"..\\", and reducing multiple \\"/\\" to a single \\"/\\". >>> normalize_path(\\"/home/\\") '/home' >>> normalize_path(\\"/a/./b/../../c/\\") '/c' >>> normalize_path(\\"/a/../../b/../c//.//\\") '/c' >>> normalize_path(\\"/a//b////c/d//././/..\\") '/a/b/c'","solution":"def normalize_path(path: str) -> str: Normalizes the given file path by removing \\".\\", \\"..\\", and reducing multiple \\"/\\" to a single \\"/\\". if not path: return '/' stack = [] parts = path.split('/') for part in parts: if part == \\"..\\": if stack and stack[-1] != '': stack.pop() elif part == \\".\\" or part == \\"\\": continue else: stack.append(part) if not stack: return '/' if path[0] == '/': return '/' + '/'.join(stack) else: return '/'.join(stack)"},{"question":"from scipy.optimize import linear_sum_assignment from typing import List, Dict def maximum_happiness(grid: List[List[int]], N: int, M: int) -> int: Calculate the maximum total happiness Sarah can achieve by placing one stamp in each row and each column. >>> maximum_happiness([ [1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) 15 >>> maximum_happiness([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4, 4) 34 cost_matrix = [[-grid[row][col] for col in range(M)] for row in range(N)] row_ind, col_ind = linear_sum_assignment(cost_matrix) max_happiness = -sum(cost_matrix[row][col] for row, col in zip(row_ind, col_ind)) return max_happiness def solve(T: int, test_cases: List[Dict]) -> List[int]: For each test case, find the maximum total happiness Sarah can achieve. >>> solve(2, [ {'N': 3, 'M': 3, 'grid': [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]}, {'N': 4, 'M': 4, 'grid': [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]} ]) [15, 34] results = [] for case in test_cases: N, M, grid = case['N'], case['M'], case['grid'] result = maximum_happiness(grid, N, M) results.append(result) return results","solution":"from scipy.optimize import linear_sum_assignment def maximum_happiness(grid, N, M): cost_matrix = [[-grid[row][col] for col in range(M)] for row in range(N)] row_ind, col_ind = linear_sum_assignment(cost_matrix) max_happiness = -sum(cost_matrix[row][col] for row, col in zip(row_ind, col_ind)) return max_happiness def solve(T, test_cases): results = [] for case in test_cases: N, M, grid = case['N'], case['M'], case['grid'] result = maximum_happiness(grid, N, M) results.append(result) return results"},{"question":"from typing import List, Tuple def can_build_houses(m: int, n: int, plots: List[Tuple[int, int]]) -> str: Determine if it is possible to build houses in the given plots without violating the conditions. Parameters: m (int): the number of rows in the grid n (int): the number of columns in the grid plots (List[Tuple[int, int]]): a list of tuples where each tuple represents the row and column indices of the plots where the houses need to be built Returns: str: \\"Yes\\" if it is possible to build all the houses without violating the condition, \\"No\\" otherwise Examples: >>> can_build_houses(5, 5, [(1, 1), (2, 2), (3, 3)]) 'Yes' >>> can_build_houses(3, 3, [(1, 1), (1, 2), (2, 2), (3, 3)]) 'No'","solution":"def can_build_houses(m, n, plots): # Create a grid to represent the house presence grid = [[0] * n for _ in range(m)] for (ri, ci) in plots: # Check if any of the 4 possible adjacent cells already have a house if ((ri > 1 and grid[ri-2][ci-1]) or (ri < m and grid[ri][ci-1]) or (ci > 1 and grid[ri-1][ci-2]) or (ci < n and grid[ri-1][ci])): return \\"No\\" # Mark the current cell as having a house grid[ri-1][ci-1] = 1 return \\"Yes\\""},{"question":"def count_single_occurrences(s: str) -> int: Given a string \`s\`, return the number of distinct characters that appear exactly once in the string. Example: >>> count_single_occurrences(\\"programming\\") 5 >>> count_single_occurrences(\\"abcdabcdabcd\\") 0 >>> count_single_occurrences(\\"hello\\") 3","solution":"def count_single_occurrences(s): Returns the number of distinct characters that appear exactly once in the string \`s\`. from collections import Counter # Count occurrences of each character char_count = Counter(s) # Find characters that appear exactly once single_occurrences = [char for char in char_count if char_count[char] == 1] return len(single_occurrences)"},{"question":"from typing import List from collections import Counter def canFormPalindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character occurs an odd number of times, and all other characters occur an even number of times. The function is case insensitive. :param s: Input string containing a mix of upper and lower case letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"AaBb\\") True","solution":"from collections import Counter def canFormPalindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. :param s: Input string containing a mix of upper and lower case letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. # Normalize the string to lower case to handle case insensitivity s = s.lower() # Create a frequency count of each character in the string char_count = Counter(s) # Number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def smallest_impossible_total(n: int, button_values: List[int]) -> int: Determine the smallest total T that cannot be obtained by pressing any combination of the machine's buttons. >>> smallest_impossible_total(3, [1, 2, 3]) 7 >>> smallest_impossible_total(2, [10, 12]) 1","solution":"def smallest_impossible_total(n, button_values): possible_totals = {0} for value in button_values: new_totals = set() for total in possible_totals: new_totals.add(total + value) possible_totals.update(new_totals) T = 1 while T in possible_totals: T += 1 return T"},{"question":"def count_passing_widgets(widgets): Returns the number of widgets that pass the quality check. A widget passes the quality check if at most one of its quality metrics is under 50. :param widgets: A list of lists. Each inner list contains the quality metrics of a widget. :return: Number of widgets that pass the quality check. pass def process_input(input_data): Process the input data and converts it into a list of widget metrics. :param input_data: A string representing the input data :return: A list of list of integers, each list represents the quality metrics of a widget. pass import pytest def test_count_passing_widgets(): widgets = [ [False, False, True, False, False], [True, False, False], [True, True, False, False] ] assert count_passing_widgets(widgets) == 2 widgets = [ [False, False], [True, True] ] assert count_passing_widgets(widgets) == 1 widgets = [ [False, False, False], [False], [True, False] ] assert count_passing_widgets(widgets) == 3 def test_process_input(): input_data = \\"3n5 55 60 47 72 88n3 49 51 52n4 49 48 50 50\\" widgets = process_input(input_data) expected = [ [False, False, True, False, False], [True, False, False], [True, True, False, False] ] assert widgets == expected input_data = \\"2n2 100 100n2 45 30\\" widgets = process_input(input_data) expected = [ [False, False], [True, True] ] assert widgets == expected @pytest.mark.parametrize(\\"input_data, expected\\", [ (\\"3n5 55 60 47 72 88n3 49 51 52n4 49 48 50 50\\", 2), (\\"2n2 100 100n2 45 30\\", 1), (\\"1n3 45 45 45\\", 0), (\\"4n1 60n1 49n1 50n1 51\\", 4) ]) def test_integration(input_data, expected): widgets = process_input(input_data) assert count_passing_widgets(widgets) == expected","solution":"def count_passing_widgets(widgets): Returns the number of widgets that pass the quality check. A widget passes the quality check if at most one of its quality metrics is under 50. :param widgets: A list of lists. Each inner list contains the quality metrics of a widget. :return: Number of widgets that pass the quality check. count = 0 for metrics in widgets: if metrics.count(True) <= 1: count += 1 return count def process_input(input_data): Process the input data and converts it into a list of widget metrics. :param input_data: A string representing the input data :return: A list of list of integers, each list represents the quality metrics of a widget. lines = input_data.strip().split('n') m = int(lines[0]) widgets = [] for i in range(1, m + 1): metrics = list(map(int, lines[i].split()[1:])) check = [metric < 50 for metric in metrics] widgets.append(check) return widgets"},{"question":"def group_anagrams(words): Groups anagrams from the list of words. Args: words (list of str): The list of words to be grouped. Returns: dict: A dictionary where keys are sorted tuples of characters and values are lists of anagrams. Examples: >>> group_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"]) {('a', 'b', 't'): ['bat', 'tab', 'bat'], ('a', 'e', 't'): ['eat', 'tea'], ('a', 'n', 't'): ['tan', 'nat']} >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) {('e', 'i', 'l', 'n', 's', 't'): ['listen', 'silent', 'enlist'], ('e', 'g', 'g', 'l', 'o', 'o'): ['google', 'gogole']} pass # Implementation goes here","solution":"def group_anagrams(words): Groups anagrams from the list of words. Args: words (list of str): The list of words to be grouped. Returns: dict: A dictionary where keys are sorted tuples of characters and values are lists of anagrams. anagrams = {} for word in words: key = tuple(sorted(word)) if key not in anagrams: anagrams[key] = [] anagrams[key].append(word) return anagrams"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array without using any built-in sorting functions. Example: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([10, 20], [15, 30]) [10, 15, 20, 30]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. result = [] i = j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 # Append remaining elements, if any while i < len(arr1): result.append(arr1[i]) i += 1 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"def can_rearrange_with_k_distinct_characters(t: int, test_cases: List[Tuple[str, int]]) -> List[str]: Determine if you can rearrange the string such that there are exactly k distinct characters in the string. Args: t (int): The number of test cases. test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string s and an integer k. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case based on the possibility of rearrangement. Examples: >>> can_rearrange_with_k_distinct_characters(3, [(\\"abc\\", 2), (\\"aaa\\", 1), (\\"abcd\\", 5)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_rearrange_with_k_distinct_characters(1, [(\\"a\\", 1)]) [\\"YES\\"] >>> can_rearrange_with_k_distinct_characters(1, [(\\"a\\", 2)]) [\\"NO\\"]","solution":"def can_rearrange_with_k_distinct_characters(t, test_cases): results = [] for s, k in test_cases: unique_chars = len(set(s)) if unique_chars >= k: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def canPartition(s: str, k: int) -> bool: Determines if the string s can be partitioned into k non-empty, distinct substrings. >>> canPartition(\\"abcdak\\", 4) True >>> canPartition(\\"aaaa\\", 2) False >>> canPartition(\\"a\\", 1) True >>> canPartition(\\"abcdef\\", 6) True >>> canPartition(\\"abcdef\\", 7) False >>> canPartition(\\"abab\\", 2) True >>> canPartition(\\"abab\\", 3) False >>> large_string = \\"abcde\\" * 20000 >>> canPartition(large_string, 5) True >>> canPartition(large_string, 100001) False","solution":"def canPartition(s, k): Determines if the string s can be partitioned into k non-empty, distinct substrings. if len(set(s)) < k: # If the number of distinct characters is less than k, it's not possible return False # General approach: If there are at least k unique characters in the string, # it is possible to create k unique partitions. return k <= len(s)"},{"question":"def validate_document_transitions(test_cases): Determine if the sequences of state transitions for the documents are valid according to the rules mentioned. >>> validate_document_transitions([(5, [\\"Created\\", \\"Opened\\", \\"Modified\\", \\"Saved\\", \\"Closed\\"]), ... (5, [\\"Created\\", \\"Opened\\", \\"Saved\\", \\"Archived\\", \\"Modified\\"]), ... (3, [\\"Created\\", \\"Saved\\", \\"Closed\\"]), ... (6, [\\"Created\\", \\"Opened\\", \\"Modified\\", \\"Saved\\", \\"Archived\\", \\"Closed\\"])]) [\\"Valid\\", \\"Invalid\\", \\"Invalid\\", \\"Invalid\\"] pass import pytest def test_example_cases(): test_cases = [ (5, [\\"Created\\", \\"Opened\\", \\"Modified\\", \\"Saved\\", \\"Closed\\"]), (5, [\\"Created\\", \\"Opened\\", \\"Saved\\", \\"Archived\\", \\"Modified\\"]), (3, [\\"Created\\", \\"Saved\\", \\"Closed\\"]), (6, [\\"Created\\", \\"Opened\\", \\"Modified\\", \\"Saved\\", \\"Archived\\", \\"Closed\\"]) ] expected = [\\"Valid\\", \\"Invalid\\", \\"Invalid\\", \\"Invalid\\"] assert validate_document_transitions(test_cases) == expected def test_single_transition(): test_cases = [ (1, [\\"Created\\"]), (1, [\\"Opened\\"]), (1, [\\"Saved\\"]), (1, [\\"Closed\\"]), ] expected = [\\"Valid\\", \\"Invalid\\", \\"Invalid\\", \\"Invalid\\"] assert validate_document_transitions(test_cases) == expected def test_multiple_valid_transitions(): test_cases = [ (4, [\\"Created\\", \\"Opened\\", \\"Saved\\", \\"Closed\\"]), (4, [\\"Created\\", \\"Opened\\", \\"Saved\\", \\"Archived\\"]), (6, [\\"Created\\", \\"Opened\\", \\"Modified\\", \\"Saved\\", \\"Archived\\"]), ] expected = [\\"Valid\\", \\"Valid\\", \\"Valid\\"] assert validate_document_transitions(test_cases) == expected def test_invalid_transitions(): test_cases = [ (5, [\\"Created\\", \\"Modified\\", \\"Opened\\", \\"Saved\\", \\"Closed\\"]), (4, [\\"Created\\", \\"Saved\\", \\"Opened\\", \\"Closed\\"]), (5, [\\"Created\\", \\"Opened\\", \\"Saved\\", \\"Closed\\", \\"Modified\\"]), (4, [\\"Created\\", \\"Opened\\", \\"Closed\\"]), ] expected = [\\"Invalid\\", \\"Invalid\\", \\"Invalid\\", \\"Invalid\\"] assert validate_document_transitions(test_cases) == expected","solution":"def validate_document_transitions(test_cases): valid_transitions = { 'Created': ['Opened'], 'Opened': ['Modified', 'Saved'], 'Modified': ['Saved'], 'Saved': ['Closed', 'Archived'], 'Closed': [], 'Archived': [], } def is_valid_sequence(sequence): current_state = None for state in sequence: if current_state is None: if state != 'Created': return False else: if state not in valid_transitions[current_state]: return False current_state = state if current_state in ['Closed', 'Archived']: if state != current_state: return False return True results = [] for case in test_cases: n, transitions = case if is_valid_sequence(transitions): results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results"},{"question":"def range_update_operations_and_queries(n, m, A, operations, q, queries): Performs range update operations on array A and answers queries. :param n: int - size of the array :param m: int - number of operations :param A: list - initial array of size n :param operations: list of tuples - each tuple contains (l, r, x) :param q: int - number of queries :param queries: list of ints - indices to be queried :return: list of results for each query Example: >>> n = 5 >>> m = 3 >>> A = [1, 2, 3, 4, 5] >>> operations = [(1, 3, 2), (2, 5, 3), (1, 2, -1)] >>> q = 4 >>> queries = [1, 2, 3, 5] >>> range_update_operations_and_queries(n, m, A, operations, q, queries) [2, 6, 8, 8] from solution import range_update_operations_and_queries def test_example_case(): n = 5 m = 3 A = [1, 2, 3, 4, 5] operations = [(1, 3, 2), (2, 5, 3), (1, 2, -1)] q = 4 queries = [1, 2, 3, 5] expected_output = [2, 6, 8, 8] assert range_update_operations_and_queries(n, m, A, operations, q, queries) == expected_output def test_no_operation(): n = 5 m = 0 A = [1, 2, 3, 4, 5] operations = [] q = 3 queries = [1, 3, 5] expected_output = [1, 3, 5] assert range_update_operations_and_queries(n, m, A, operations, q, queries) == expected_output def test_all_range_single_update(): n = 8 m = 1 A = [2, 4, 6, 8, 10, 12, 14, 16] operations = [(1, 8, 5)] q = 4 queries = [1, 3, 5, 8] expected_output = [7, 11, 15, 21] assert range_update_operations_and_queries(n, m, A, operations, q, queries) == expected_output def test_large_values(): n = 3 m = 2 A = [1000000, 2000000, 3000000] operations = [(1, 1, 1000000), (2, 3, -1000000)] q = 3 queries = [1, 2, 3] expected_output = [2000000, 1000000, 2000000] assert range_update_operations_and_queries(n, m, A, operations, q, queries) == expected_output","solution":"def range_update_operations_and_queries(n, m, A, operations, q, queries): Performs range update operations on array A and answers queries. :param n: int - size of the array :param m: int - number of operations :param A: list - initial array of size n :param operations: list of tuples - each tuple contains (l, r, x) :param q: int - number of queries :param queries: list of ints - indices to be queried :return: list of results for each query # Initialize difference array diff = [0] * (n + 1) # Apply the range updates using difference array for l, r, x in operations: diff[l-1] += x if r < n: diff[r] -= x # Apply the difference array to the original array to get the final values for i in range(n): if i > 0: diff[i] += diff[i-1] A[i] += diff[i] # Answer the queries result = [] for k in queries: result.append(A[k-1]) return result"},{"question":"def max_subarray(arr): Finds the subarray with the maximum sum in an input list of integers. Parameters: arr (list): List of integers Returns: tuple: Maximum sum and the subarray with the maximum sum >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [4, -1, 2, 1]) >>> max_subarray([-1, -2, -3, -4]) (-1, [-1]) >>> max_subarray([1, 2, 3, 4]) (10, [1, 2, 3, 4]) >>> max_subarray([0, -1, 2, 3, -2, 3, -10, 3]) (6, [2, 3, -2, 3]) >>> max_subarray([]) (0, []) >>> max_subarray([5]) (5, [5]) >>> max_subarray([-5]) (-5, [-5])","solution":"def max_subarray(arr): Finds the subarray with the maximum sum in an input list of integers. Parameters: arr (list): List of integers Returns: tuple: Maximum sum and the subarray with the maximum sum if not arr: return (0, []) max_sum = current_sum = arr[0] start = end = s = 0 for i in range(1, len(arr)): if arr[i] > current_sum + arr[i]: current_sum = arr[i] s = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return (max_sum, arr[start:end + 1])"},{"question":"def judge_cakes(T: int, test_cases: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> List[str]: Determines whether each cake should be judged or disqualified based on its dimensions. INPUT: T : int : the number of test cases. test_cases : List[Tuple[Tuple[int, int], Tuple[int, int]]] : a list of tuples where each tuple contains: - original dimensions of the cake (length, width) - presented dimensions of the cake (length, width) OUTPUT: List[str] : a list of results for each test case, either \\"Judged\\" or \\"Disqualified\\" Example: >>> judge_cakes(3, [([10, 12], [10, 12]), ([8, 6], [7, 6]), ([9, 9], [9, 8])]) [\\"Judged\\", \\"Disqualified\\", \\"Disqualified\\"]","solution":"def judge_cakes(T, test_cases): results = [] for i in range(T): original_length, original_width = test_cases[i][0] presented_length, presented_width = test_cases[i][1] if presented_length >= original_length and presented_width >= original_width: results.append(\\"Judged\\") else: results.append(\\"Disqualified\\") return results"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. :param grid: List of List of int (0 for empty cell, 1 for obstacle) :return: int, number of unique paths >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [1, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. :param grid: List of List of int (0 for empty cell, 1 for obstacle) :return: int, number of unique paths # Get the dimensions of the grid m = len(grid) n = len(grid[0]) # Edge case: start or end is an obstacle if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a dp array with 0s dp = [[0] * n for _ in range(m)] # Set the start point dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # Obstacle cells else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] # Example usage grid1 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] print(unique_paths_with_obstacles(grid1)) # Output: 2 grid2 = [ [0, 1, 0], [1, 0, 0], [0, 0, 0] ] print(unique_paths_with_obstacles(grid2)) # Output: 0"},{"question":"import heapq from typing import List, Tuple def find_shortest_paths(n: int, m: int, k: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest path between nodes in a weighted undirected graph using Dijkstra's algorithm. If no path exists between the nodes, return -1. >>> find_shortest_paths(5, 6, 2, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], [(1, 5), (4, 5)]) [6, 1] >>> find_shortest_paths(4, 4, 1, [(1, 2, 3), (1, 3, 1), (3, 4, 2), (2, 4, 5)], [(1, 4)]) [3] >>> find_shortest_paths(3, 2, 1, [(1, 2, 5), (2, 3, 10)], [(1, 3)]) [15] >>> find_shortest_paths(2, 1, 1, [(1, 2, 8)], [(1, 1)]) [0] pass","solution":"import heapq def dijkstra(graph, start, end): Function to find the shortest path between start and end using Dijkstra's algorithm. If no path exists, returns -1. n = len(graph) distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def find_shortest_paths(n, m, k, edges, queries): Function to handle multiple path queries on the given network. Returns list of shortest path distances for each query. graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for a, b in queries: result = dijkstra(graph, a, b) results.append(result) return results"},{"question":"def minimum_groups(n: int, d: int, t: List[int]) -> int: Given n trails, each with a distance specified in list t, and a maximum allowed distance d, returns the minimum number of groups required such that the total distance of each group does not exceed d. Parameters: n (int): The number of trails. d (int): The maximum allowed distance of each group. t (List[int]): A list containing the distances of the trails. Returns: int: The minimum number of groups required. Examples: >>> minimum_groups(5, 10, [1, 2, 3, 4, 5]) 2 >>> minimum_groups(6, 15, [5, 6, 7, 8, 9, 10]) 4 >>> minimum_groups(3, 5, [2, 2, 2]) 2","solution":"def minimum_groups(n, d, t): Given n trails, each with a distance specified in list t, and a maximum allowed distance d, returns the minimum number of groups required such that the total distance of each group does not exceed d. num_groups = 0 current_distance = 0 for distance in t: if current_distance + distance > d: num_groups += 1 current_distance = distance else: current_distance += distance # If there's any distance left ungrouped, it forms the final group if current_distance > 0: num_groups += 1 return num_groups"},{"question":"def min_non_overlapping_intervals(events: List[Tuple[int, int]]) -> int: Determine the minimum number of non-overlapping intervals needed to cover all the events. >>> min_non_overlapping_intervals([(1, 3), (2, 5), (4, 7), (6, 8), (8, 10)]) 3 >>> min_non_overlapping_intervals([(1, 2), (3, 4), (5, 6)]) 3 >>> min_non_overlapping_intervals([(1, 10), (2, 9), (3, 8), (4, 7)]) 1 >>> min_non_overlapping_intervals([(1, 4), (3, 5), (0, 6), (8, 10), (9, 12)]) 2 >>> min_non_overlapping_intervals([(0, 100)]) 1","solution":"def min_non_overlapping_intervals(events): # Sort events by their end times primarily and start times secondarily events.sort(key=lambda x: (x[1], x[0])) count = 0 previous_end = -1 for start, end in events: if start >= previous_end: count += 1 previous_end = end return count # Example of usage: # events = [(1, 3), (2, 5), (4, 7), (6, 8), (8, 10)] # print(min_non_overlapping_intervals(events)) # Output should be 3"},{"question":"def can_place_wells(N: int, M: int, D: int, houses: List[int]) -> str: Determines if it is possible to place M wells such that every house is within the range of at least one well. Parameters: N (int): Number of houses M (int): Number of wells D (int): Range of each well (distance to the left and right) houses (List[int]): Coordinates of the houses Returns: str: \\"YES\\" if it is possible to place all M wells such that every house is within the range of at least one well, otherwise \\"NO\\" >>> can_place_wells(5, 2, 3, [1, 2, 5, 8, 12]) 'YES' >>> can_place_wells(4, 1, 2, [1, 4, 7, 10]) 'NO' >>> can_place_wells(1, 1, 1, [1]) 'YES' >>> can_place_wells(3, 0, 2, [1, 5, 9]) 'NO' >>> can_place_wells(5, 1, 10, [1, 2, 5, 8, 12]) 'YES' >>> can_place_wells(5, 2, 2, [1, 3, 5, 7, 9]) 'YES' >>> can_place_wells(7, 2, 1, [1, 3, 4, 6, 8, 10, 12]) 'NO'","solution":"def can_place_wells(N, M, D, houses): Determines if it is possible to place M wells such that every house is within the range of at least one well. Parameters: N (int): Number of houses M (int): Number of wells D (int): Range of each well (distance to the left and right) houses (list of int): Coordinates of the houses Returns: str: \\"YES\\" if it is possible to place all M wells such that every house is within the range of at least one well, otherwise \\"NO\\" # Total length the well can cover total_range = 2 * D + 1 # Required number of wells based on maximum distance between houses required_wells = 0 i = 0 while i < N: required_wells += 1 # Place a well at the furthest house within current range well_position = houses[i] + D # Move to the rightmost house covered by this well while i < N and houses[i] <= well_position + D: i += 1 if required_wells > M: return \\"NO\\" return \\"YES\\" if required_wells <= M else \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def solve(input_string: str) -> str: Given an integer array with distinct values as a space-separated string, construct the maximum binary tree and output the preorder traversal of the tree. >>> solve(\\"3 2 1 6 0 5\\") \\"6 3 2 1 5 0\\" >>> solve(\\"10 9 8 7 6\\") \\"10 9 8 7 6\\"","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_maximum_binary_tree(nums): if not nums: return None # Find the maximum number and its index max_index = nums.index(max(nums)) max_value = nums[max_index] # Create the root node with the maximum number root = TreeNode(val=max_value) # Recursively construct the left and right subtrees root.left = construct_maximum_binary_tree(nums[:max_index]) root.right = construct_maximum_binary_tree(nums[max_index + 1:]) return root def preorder_traversal(root): if not root: return [] return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right) def maximum_binary_tree_preorder(nums): tree = construct_maximum_binary_tree(nums) return preorder_traversal(tree) # Function to handle the input and output def solve(input_string): nums = list(map(int, input_string.split())) preorder_result = maximum_binary_tree_preorder(nums) return ' '.join(map(str, preorder_result))"},{"question":"def max_books_on_shelves(T: int, test_cases: list) -> list: Calculate the maximum number of books that can be placed on the shelves. >>> max_books_on_shelves(2, [(5, 3, [2, 3, 4, 5, 6], [10, 10, 10]), (4, 2, [1, 2, 2, 3], [3, 5])]) [5, 4] >>> max_books_on_shelves(1, [(3, 1, [2, 4, 6], [100])]) [3] >>> max_books_on_shelves(1, [(1, 1, [2], [5])]) [1] >>> max_books_on_shelves(1, [(3, 1, [4, 5, 6], [1])]) [0]","solution":"def max_books_on_shelves(T, test_cases): results = [] for case in test_cases: N, M, book_thicknesses, shelf_capacities = case book_thicknesses.sort() shelf_capacities.sort(reverse=True) book_index = 0 books_placed = 0 for capacity in shelf_capacities: current_thickness = 0 while book_index < N and current_thickness + book_thicknesses[book_index] <= capacity: current_thickness += book_thicknesses[book_index] book_index += 1 books_placed += 1 if book_index >= N: break results.append(books_placed) return results"},{"question":"def calculate_genre_totals(datasets): Calculate the total number of copies available for each genre across all datasets. Args: datasets (List[List[str]]): A list of datasets, where each dataset is a list of inventory records formatted as \\"ISBN_NUMBER GENRE COPIES\\". Returns: List[Dict[str, int]]: A list of dictionaries, where each dictionary represents the total number of copies available for each genre in the corresponding dataset. Example: >>> calculate_genre_totals([ [\\"12345 Fiction 5\\", \\"67890 Fiction 3\\", \\"54321 Thriller 2\\"], [\\"11223 Mystery 7\\", \\"33445 Fiction 10\\", \\"55667 Mystery 3\\", \\"77889 SciFi 6\\"] ]) [{'Fiction': 8, 'Thriller': 2}, {'Mystery': 10, 'Fiction': 10, 'SciFi': 6}]","solution":"def calculate_genre_totals(datasets): results = [] for dataset in datasets: genre_totals = {} for record in dataset: isbn, genre, copies = record.split() copies = int(copies) if genre in genre_totals: genre_totals[genre] += copies else: genre_totals[genre] = copies results.append(genre_totals) return results"},{"question":"import math from typing import List, Tuple def min_hours_to_produce_parts(n: int, m: int, x: int, y: int, k: int) -> int: Calculate the minimum number of hours required to produce exactly k parts using n type A machines and m type B machines. >>> min_hours_to_produce_parts(3, 2, 5, 4, 100) 5 >>> min_hours_to_produce_parts(1, 1, 10, 10, 50) 3 >>> min_hours_to_produce_parts(10, 5, 2, 3, 60) 2 def process_test_cases(t: int, test_cases: List[Tuple[int, int, int, int, int]]) -> List[int]: Process multiple test cases to determine the minimum number of hours required for each to produce the required parts. >>> process_test_cases(3, [(3, 2, 5, 4, 100), (1, 1, 10, 10, 50), (10, 5, 2, 3, 60)]) [5, 3, 2] >>> process_test_cases(2, [(1, 1, 1, 1, 10), (5, 5, 2, 4, 200)]) [5, 7]","solution":"import math def min_hours_to_produce_parts(n, m, x, y, k): # Calculate total production rate total_rate = n * x + m * y # Calculate the minimum number of hours required to produce exactly k parts return math.ceil(k / total_rate) def process_test_cases(t, test_cases): results = [] for case in test_cases: n, m, x, y, k = case results.append(min_hours_to_produce_parts(n, m, x, y, k)) return results"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines if a linked list has a cycle in it. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise def create_linked_list_with_cycle(values, pos): if not values: return None head = ListNode(values[0]) current = head cycle_entry = None if pos == 0: cycle_entry = head for i in range(1, len(values)): current.next = ListNode(values[i]) current = current.next if i == pos: cycle_entry = current if cycle_entry: current.next = cycle_entry return head def test_has_cycle(): head = create_linked_list_with_cycle([3,2,0,-4], 1) assert hasCycle(head) == True def test_has_cycle2(): head = create_linked_list_with_cycle([1,2], 0) assert hasCycle(head) == True def test_no_cycle(): head = create_linked_list_with_cycle([1], -1) assert hasCycle(head) == False def test_empty_list(): head = create_linked_list_with_cycle([], -1) assert hasCycle(head) == False def test_single_element_no_cycle(): head = create_linked_list_with_cycle([1], -1) assert hasCycle(head) == False def test_single_element_with_cycle(): head = create_linked_list_with_cycle([1], 0) assert hasCycle(head) == True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines if a linked list has a cycle in it. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def min_integers_to_sum(n: int) -> int: Compute the minimum number of 1s, 2s, and 5s required to sum up to the given target number \`n\`. If it is not possible to achieve this exact sum, return -1. -----Examples----- >>> min_integers_to_sum(7) 2 >>> min_integers_to_sum(11) 3 >>> min_integers_to_sum(3) 2","solution":"def min_integers_to_sum(n): Returns the minimum number of 1s, 2s, and 5s required to sum up to \`n\`. If it is not possible to form \`n\`, return -1. if n % 5 == 0: return n // 5 min_count = float('inf') for fives in range(n // 5 + 1): remaining = n - 5 * fives if remaining % 2 == 0: twos = remaining // 2 min_count = min(min_count, fives + twos) for fives in range(n // 5 + 1): for twos in range((n - 5 * fives) // 2 + 1): remaining = n - 5 * fives - 2 * twos ones = remaining min_count = min(min_count, fives + twos + ones) return min_count if min_count != float('inf') else -1"},{"question":"def can_partition_equal_sum(n: int, k: int, nums: List[int]) -> str: Determine whether it is possible to divide the set of integers into two subsets with equal sum. >>> can_partition_equal_sum(5, 10, [1, 2, 3, 4, 6]) 'YES' >>> can_partition_equal_sum(4, 15, [5, 7, 9, 4]) 'NO'","solution":"def can_partition_equal_sum(n, k, nums): total_sum = sum(nums) # If total_sum is odd, then it is not possible to split them into two equal sum subsets if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def max_effectiveness(N: int, K: int, herbs: List[int]) -> int: Returns the maximum possible effectiveness of the potion by summing any K consecutive herbs. :param N: int - The number of herbs :param K: int - The number of consecutive herbs to be used :param herbs: list[int] - The list of herbs properties :return: int - The maximum possible effectiveness >>> max_effectiveness(5, 3, [1, -2, 3, 4, -1]) 6 >>> max_effectiveness(4, 2, [-1, -2, -3, -4]) -3","solution":"def max_effectiveness(N, K, herbs): Returns the maximum possible effectiveness of the potion by summing any K consecutive herbs. :param N: int - The number of herbs :param K: int - The number of consecutive herbs to be used :param herbs: list[int] - The list of herbs properties :return: int - The maximum possible effectiveness max_sum = float('-inf') for i in range(N - K + 1): current_sum = sum(herbs[i:i+K]) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most 2 distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"abc\\") 2 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aab\\") 3 >>> length_of_longest_substring_two_distinct(\\"ababffzzeee\\") 5 pass","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most 2 distinct characters. from collections import defaultdict n = len(s) if n < 3: return n # Dictionary to store the index of the characters. hashmap = defaultdict(int) left = 0 max_len = 2 for right in range(n): hashmap[s[right]] = right # If there are more than 2 distinct characters in the window if len(hashmap) == 3: # Delete the leftmost character del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def create_matrix(rows, cols): Creates a matrix with given number of rows and columns initialized to 0. >>> create_matrix(2, 3) [[0, 0, 0], [0, 0, 0]] >>> create_matrix(1, 4) [[0, 0, 0, 0]] pass def transpose_matrix(matrix): Transposes the given matrix. >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[0, 0], [0, 0]]) [[0, 0], [0, 0]] pass def flatten_matrix(matrix): Flattens the given matrix into a single list. >>> flatten_matrix([[1, 2, 3], [4, 5, 6]]) [1, 2, 3, 4, 5, 6] >>> flatten_matrix([[0, 0], [0, 0]]) [0, 0, 0, 0] pass","solution":"def create_matrix(rows, cols): Creates a matrix with given number of rows and columns initialized to 0. >>> create_matrix(2, 3) [[0, 0, 0], [0, 0, 0]] >>> create_matrix(1, 4) [[0, 0, 0, 0]] return [[0 for _ in range(cols)] for _ in range(rows)] def transpose_matrix(matrix): Transposes the given matrix. >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[0, 0], [0, 0]]) [[0, 0], [0, 0]] return list(map(list, zip(*matrix))) def flatten_matrix(matrix): Flattens the given matrix into a single list. >>> flatten_matrix([[1, 2, 3], [4, 5, 6]]) [1, 2, 3, 4, 5, 6] >>> flatten_matrix([[0, 0], [0, 0]]) [0, 0, 0, 0] return [elem for row in matrix for elem in row]"},{"question":"def letter_frequencies(S: str) -> str: Given a string S consisting of lowercase English letters, print the frequency of each letter in the string in alphabetical order of the letters. Args: - S (str): input string comprised of lowercase English letters Returns: - str: letter frequencies in formatted string as described Examples: >>> letter_frequencies(\\"apple\\") == \\"a1e1l1p2\\" >>> letter_frequencies(\\"banana\\") == \\"a3b1n2\\" >>> letter_frequencies(\\"zzzzz\\") == \\"z5\\" from solution import letter_frequencies def test_single_occurrence_each_letter(): assert letter_frequencies(\\"abcdefg\\") == \\"a1b1c1d1e1f1g1\\" def test_multiple_occurrences(): assert letter_frequencies(\\"apple\\") == \\"a1e1l1p2\\" def test_all_same_letter(): assert letter_frequencies(\\"zzzzz\\") == \\"z5\\" def test_mixed_frequencies(): assert letter_frequencies(\\"banana\\") == \\"a3b1n2\\" def test_ordered_output(): assert letter_frequencies(\\"abcdefgh\\") == \\"a1b1c1d1e1f1g1h1\\" def test_empty_string(): assert letter_frequencies(\\"\\") == \\"\\"","solution":"def letter_frequencies(S): Given a string S consisting of lowercase English letters, print the frequency of each letter in the string in alphabetical order of the letters. Args: - S (str): input string comprised of lowercase English letters Returns: - str: letter frequencies in formatted string as described from collections import Counter # Calculate the frequency of each letter in the string frequency = Counter(S) # Sort letters and create the resulting string in the desired order result = ''.join(f\\"{char}{frequency[char]}\\" for char in sorted(frequency.keys())) return result"},{"question":"def max_communication_towers(towers): Determine the maximum number of towers that can simultaneously communicate with each other. >>> max_communication_towers([(1, 2), (2, 1), (5, 1), (10, 2)]) 2 >>> max_communication_towers([(0, 1), (1, 1), (2, 0)]) 3","solution":"def max_communication_towers(towers): towers.sort() # Sort the towers based on position n = len(towers) # Dynamic Programming approach to find the maximum subset of towers that can communicate dp = [1] * n # Initialize dp array where each tower can communicate with itself for i in range(1, n): for j in range(i): if towers[j][0] + towers[j][1] >= towers[i][0] - towers[i][1]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # result = max_communication_towers([(1, 2), (2, 1), (5, 1), (10, 2)]) # print(result)"},{"question":"def find_min_travel_cost(n: int, d: int, cities: List[int], m: int, ticket_fares: List[Tuple[int, int, str, int]]) -> int: Determine the minimal total cost David needs to spend on tickets to complete the tour. :param n: Total number of cities :param d: Number of concerts :param cities: Sequence of cities for the concerts (1-indexed) :param m: Number of train fares :param ticket_fares: List of tuples with (u, v, w, q) where u and v are cities, w is ticket type (O for one-way, R for round-trip), q is the ticket price :returns: Minimum amount of money David needs to purchase the required tickets for the entire tour. >>> find_min_travel_cost(3, 4, [1, 2, 3, 1], 5, [(1, 2, 'O', 7), (2, 3, 'O', 5), (3, 1, 'O', 8), (2, 3, 'R', 9), (1, 2, 'R', 12)]) 20 >>> find_min_travel_cost(4, 5, [1, 2, 3, 4, 1], 6, [(1, 2, 'O', 5), (2, 3, 'O', 6), (3, 4, 'O', 7), (4, 1, 'O', 8), (1, 3, 'R', 15), (2, 4, 'R', 18)]) 26 >>> find_min_travel_cost(2, 3, [1, 2, 1], 3, [(1, 2, 'O', 10), (2, 1, 'O', 10), (1, 2, 'R', 15)]) 20 >>> find_min_travel_cost(5, 6, [1, 2, 3, 4, 5, 1], 8, [(1, 2, 'O', 3), (2, 3, 'O', 4), (3, 4, 'O', 5), (4, 5, 'O', 6), (5, 1, 'O', 7), (1, 3, 'R', 8), (2, 4, 'R', 12), (3, 5, 'R', 15)]) 25 pass","solution":"def find_min_travel_cost(n, d, cities, m, ticket_fares): from collections import defaultdict import heapq graph = defaultdict(list) min_distance = defaultdict(lambda: float('inf')) for u, v, w, q in ticket_fares: if w == 'O': graph[u].append((v, q)) elif w == 'R': graph[u].append((v, q)) graph[v].append((u, q)) def dijkstra(start): pq = [(0, start)] min_distance[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > min_distance[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < min_distance[neighbor]: min_distance[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) total_cost = 0 for i in range(len(cities) - 1): min_distance = defaultdict(lambda: float('inf')) dijkstra(cities[i]) total_cost += min_distance[cities[i + 1]] return total_cost # Example usage: n, d = 3, 4 cities = [1, 2, 3, 1] m = 5 ticket_fares = [ (1, 2, 'O', 7), (2, 3, 'O', 5), (3, 1, 'O', 8), (2, 3, 'R', 9), (1, 2, 'R', 12) ] print(find_min_travel_cost(n, d, cities, m, ticket_fares)) # Output should be 20"},{"question":"def rotating_quick_sort(A, K): Implements the Rotating Quick Sort algorithm on the given array A with rotation by K positions. # Helper function to rotate array to the right by K positions def rotate_right(arr, K): pass # Helper function to rotate array to the left by K positions def rotate_left(arr, K): pass # Quick Sort function with rotating mechanism def quick_sort(A, K): pass return quick_sort(A, K) def rotating_quick_sort_tests(T, cases): results = [] for i in range(T): # Unpack each test case and apply rotating_quick_sort pass return results # Unit tests def test_rotating_quick_sort_single_case(): T = 1 cases = [ ((5, 2), [4, 1, 3, 9, 7]) ] expected_output = [ [1, 3, 4, 7, 9] ] assert rotating_quick_sort_tests(T, cases) == expected_output def test_rotating_quick_sort_multiple_cases(): T = 2 cases = [ ((5, 2), [4, 1, 3, 9, 7]), ((6, 3), [8, 4, 6, 5, 3, 2]) ] expected_output = [ [1, 3, 4, 7, 9], [2, 3, 4, 5, 6, 8] ] assert rotating_quick_sort_tests(T, cases) == expected_output def test_rotating_quick_sort_no_rotation_needed(): T = 1 cases = [ ((4, 0), [3, 1, 4, 2]) ] expected_output = [ [1, 2, 3, 4] ] assert rotating_quick_sort_tests(T, cases) == expected_output def test_rotating_quick_sort_single_element(): T = 1 cases = [ ((1, 0), [1]) ] expected_output = [ [1] ] assert rotating_quick_sort_tests(T, cases) == expected_output def test_rotating_quick_sort_identical_elements(): T = 1 cases = [ ((5, 3), [7, 7, 7, 7, 7]) ] expected_output = [ [7, 7, 7, 7, 7] ] assert rotating_quick_sort_tests(T, cases) == expected_output","solution":"def rotating_quick_sort(A, K): def rotate_right(arr, K): if len(arr) == 0: return arr K = K % len(arr) return arr[-K:] + arr[:-K] def rotate_left(arr, K): if len(arr) == 0: return arr K = K % len(arr) return arr[K:] + arr[:K] def quick_sort(A, K): if len(A) <= 1: return A pivot = A[len(A) // 2] left = [x for x in A if x < pivot] middle = [x for x in A if x == pivot] right = [x for x in A if x > pivot] left_rotated = rotate_right(left, K) right_rotated = rotate_left(right, K) return quick_sort(left_rotated, K) + middle + quick_sort(right_rotated, K) return quick_sort(A, K) def rotating_quick_sort_tests(T, cases): results = [] for i in range(T): N, K = cases[i][0] A = cases[i][1] sorted_array = rotating_quick_sort(A, K) results.append(sorted_array) return results"},{"question":"def decode_message(encoded_message: str, shift: int) -> str: Decodes a given encoded message using the specified shift value. >>> decode_message('ifmmp', 1) == 'hello' >>> decode_message('jgnnq', 2) == 'hello' >>> decode_message('lipps', 4) == 'hello' >>> decode_message('a', 1) == 'z' >>> decode_message('abc', 1) == 'zab' >>> decode_message('xyz', 2) == 'vwx' # Your code here def decode_messages(test_cases: List[Tuple[str, int]]) -> List[str]: Decodes multiple test cases of encoded messages. >>> decode_messages([('ifmmp', 1), ('jgnnq', 2), ('lipps', 4)]) == ['hello', 'hello', 'hello'] >>> decode_messages([('a', 1), ('bcd', 1), ('xyz', 2)]) == ['z', 'abc', 'vwx'] # Your code here","solution":"def decode_message(encoded_message, shift): Decodes a given encoded message using the specified shift value. :param encoded_message: The encoded string message :param shift: The shift value used in the encoding :return: The original decoded message decoded_message = [] for char in encoded_message: # Calculate the original character position with the circular shift original_char = chr(((ord(char) - ord('a') - shift) % 26) + ord('a')) decoded_message.append(original_char) return ''.join(decoded_message) def decode_messages(test_cases): Decodes multiple test cases of encoded messages. :param test_cases: List of tuples where each tuple contains the encoded message and the shift value :return: List of decoded messages results = [] for encoded_message, shift in test_cases: results.append(decode_message(encoded_message, shift)) return results"},{"question":"def canPartition(nums: List[int]) -> bool: Given an integer array nums, return true if there exists a partition of this array into two subsets such that the sum of elements in both subsets is equal. Otherwise, return false. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False from solution import canPartition def test_case_1(): assert canPartition([1, 5, 11, 5]) == True def test_case_2(): assert canPartition([1, 2, 3, 5]) == False def test_single_element(): assert canPartition([1]) == False def test_all_zeros(): assert canPartition([0, 0, 0, 0]) == True def test_two_elements_equal(): assert canPartition([2, 2]) == True def test_no_partition_possible(): assert canPartition([2, 3, 4, 6]) == False def test_large_elements(): assert canPartition([100, 100, 100, 100, 100, 100, 100, 100, 100, 100]) == True def test_two_elements_not_equal(): assert canPartition([1, 2]) == False def test_equal_partition_with_multiple_elements(): assert canPartition([3, 3, 3, 3, 6, 6, 6, 6]) == True","solution":"def canPartition(nums): total_sum = sum(nums) # If the total sum is odd, we cannot partition it into two subsets with equal sum if total_sum % 2 != 0: return False target = total_sum // 2 # DP approach to see if there's a subset with sum equal to target dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"from typing import List, Tuple def minimum_buses(k: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Determine the minimum number of buses required to accommodate all students and teachers. >>> minimum_buses(4, [(40, 5, 50), (35, 6, 10), (100, 20, 30), (50, 2, 18)]) [1, 5, 4, 3] >>> minimum_buses(2, [(40, 10, 25), (10, 20, 10)]) [2, 3]","solution":"import math def minimum_buses(k, test_cases): results = [] for i in range(k): M, T, S = test_cases[i] total_people = M + T buses_needed = math.ceil(total_people / S) results.append(buses_needed) return results"},{"question":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the array arr. >>> length_of_lis([5, 8, 3, 7, 9, 1]) 3 >>> length_of_lis([2, 2, 2, 2]) 1 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 def process_test_cases(t, test_cases): Processes the given test cases and returns a list with the length of the longest increasing subsequence for each test case. >>> process_test_cases(2, [(6, [5, 8, 3, 7, 9, 1]), (4, [2, 2, 2, 2])]) [3, 1] >>> process_test_cases(3, [(9, [10, 22, 9, 33, 21, 50, 41, 60, 80]), (1, [1]), (0, [])]) [6, 1, 0] from solution import length_of_lis, process_test_cases def test_length_of_lis(): assert length_of_lis([5, 8, 3, 7, 9, 1]) == 3 assert length_of_lis([2, 2, 2, 2]) == 1 assert length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 assert length_of_lis([1]) == 1 assert length_of_lis([]) == 0 assert length_of_lis([3, 4, 2, 8, 10, 5, 1]) == 4 def test_process_test_cases(): test_cases = [ (6, [5, 8, 3, 7, 9, 1]), (4, [2, 2, 2, 2]) ] assert process_test_cases(2, test_cases) == [3, 1] test_cases = [ (9, [10, 22, 9, 33, 21, 50, 41, 60, 80]), (1, [1]), (0, []) ] assert process_test_cases(3, test_cases) == [6, 1, 0]","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the array arr. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) def process_test_cases(t, test_cases): Processes the given test cases and returns a list with the length of the longest increasing subsequence for each test case. results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(length_of_lis(arr)) return results"},{"question":"def maxProductSubarray(matrix, n, m): Find the maximum product of elements in any contiguous subarray of the matrix. >>> maxProductSubarray([[1, -2, 3], [4, -1, 2], [-1, -3, 0]], 3, 3) == 48 >>> maxProductSubarray([[-10]], 1, 1) == -10 >>> maxProductSubarray([[2, 3], [4, 5]], 2, 2) == 120 >>> maxProductSubarray([[-1, -2], [-3, -4]], 2, 2) == 24 >>> maxProductSubarray([[0, -2, -3], [4, 3, -2], [1, -1, 0]], 3, 3) == 12","solution":"def maxProductSubarray(matrix, n, m): max_product = float('-inf') for i in range(n): for j in range(m): for k in range(i, n): for l in range(j, m): product = 1 for x in range(i, k+1): for y in range(j, l+1): product *= matrix[x][y] max_product = max(max_product, product) return max_product"},{"question":"def remaining_segments(L, V): Determines the number of segments left over when Alice cuts the remaining ribbon into equal segments of the largest possible integer length. Args: L (int): Initial length of the ribbon. V (int): Length of the ribbon cut for the gift. Returns: int: The number of segments left over. >>> remaining_segments(20, 7) 13 >>> remaining_segments(10, 5) 5 >>> remaining_segments(100, 50) 50 >>> remaining_segments(7, 7) 0 >>> remaining_segments(2, 1) 1","solution":"def remaining_segments(L, V): Determines the number of segments left over when Alice cuts the remaining ribbon into equal segments of the largest possible integer length. remaining_length = L - V if remaining_length == 0: return 0 return remaining_length # Example Usage: # L, V = map(int, input().strip().split()) # print(remaining_segments(L, V))"},{"question":"def fibonacci(n: int) -> int: Returns the n-th term of the Fibonacci sequence. The sequence starts with 0, 1, and each subsequent term is the sum of the previous two terms. >>> fibonacci(7) == 13 >>> fibonacci(10) == 55 >>> fibonacci(50) == 12586269025","solution":"def fibonacci(n): Returns the n-th term of the Fibonacci sequence. The sequence starts with 0, 1, and each subsequent term is the sum of the previous two terms. if n == 0: return 0 elif n == 1: return 1 # Use two variables to store the last two Fibonacci numbers a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def find_swap_indices(n, sequence): Finds the indices (i, j) to swap which make the sequence strictly increasing. Parameters: n (int): The length of the sequence. sequence (list): The sequence of integers. Returns: tuple: Indices (i, j) if possible to make sequence strictly increasing by one swap; otherwise -1. >>> find_swap_indices(5, [1, 5, 3, 4, 2]) (2, 5) >>> find_swap_indices(4, [4, 3, 2, 1]) -1 >>> find_swap_indices(3, [1, 5, 4]) (2, 3)","solution":"def find_swap_indices(n, sequence): Finds the indices (i, j) to swap which make the sequence strictly increasing. Parameters: n (int): The length of the sequence. sequence (list): The sequence of integers. Returns: tuple: Indices (i, j) if possible to make sequence strictly increasing by one swap; otherwise -1. def is_increasing(seq): # Helper function to check if a given sequence is strictly increasing for k in range(1, len(seq)): if seq[k] <= seq[k-1]: return False return True for i in range(n - 1): for j in range(i + 1, n): # Swap the elements at i and j new_sequence = sequence[:] new_sequence[i], new_sequence[j] = new_sequence[j], new_sequence[i] # Check if the new sequence is strictly increasing if is_increasing(new_sequence): return i + 1, j + 1 return -1"},{"question":"def minimum_waiting_time(n: int, m: int, vehicles: List[Tuple[int, int, int, int]]) -> int: Calculate the minimum total waiting time required for all vehicles to move through the intersection without collisions. Args: n (int): size of the grid (n x n) m (int): number of vehicles vehicles (List[Tuple[int, int, int, int]]): list of vehicles with their starting and ending positions Returns: int: the minimum total waiting time Examples: >>> minimum_waiting_time(4, 2, [(1, 1, 1, 4), (2, 1, 2, 4)]) 0 >>> minimum_waiting_time(5, 3, [(1, 1, 1, 5), (2, 1, 2, 5), (1, 5, 5, 5)]) 2 pass from solution import minimum_waiting_time def test_example_1(): n = 4 m = 2 vehicles = [ (1, 1, 1, 4), (2, 1, 2, 4) ] assert minimum_waiting_time(n, m, vehicles) == 0 def test_example_2(): n = 5 m = 3 vehicles = [ (1, 1, 1, 5), (2, 1, 2, 5), (1, 5, 5, 5) ] assert minimum_waiting_time(n, m, vehicles) == 2 def test_no_collision(): n = 4 m = 2 vehicles = [ (1, 1, 4, 1), (1, 2, 4, 2) ] assert minimum_waiting_time(n, m, vehicles) == 0 def test_all_collide(): n = 4 m = 4 vehicles = [ (1, 1, 4, 1), (1, 1, 1, 4), (2, 2, 4, 2), (2, 2, 2, 4) ] assert minimum_waiting_time(n, m, vehicles) == 2 def test_large_grid_no_collision(): n = 100000 m = 2 vehicles = [ (1, 1, 1, 100000), (100000, 1, 100000, 100000) ] assert minimum_waiting_time(n, m, vehicles) == 0","solution":"def minimum_waiting_time(n, m, vehicles): Calculate the minimum total waiting time for all vehicles to avoid collisions. # The main strategy is to ensure any vehicle on a collision course is delayed to avoid overlap. # We'll simulate the traffic in time-based increments. from collections import defaultdict # Create a map of all paths paths = defaultdict(list) # Fill the paths map for x1, y1, x2, y2 in vehicles: if x1 == x2: # Horizontal vehicle (left to right) for y in range(y1, y2 + 1): paths[(x1, y)].append((x1, y1, x2, y2)) elif y1 == y2: # Vertical vehicle (top to bottom) for x in range(x1, x2 + 1): paths[(x, y1)].append((x1, y1, x2, y2)) # If paths have multiple vehicles, we need to compute waiting times total_waiting_time = 0 for path, vehicles_on_path in paths.items(): if len(vehicles_on_path) > 1: # Calculate required waiting time total_waiting_time += (len(vehicles_on_path) - 1) return total_waiting_time"},{"question":"def extract_integers(n: int, json_strings: List[str]) -> None: Extract and print all integers found within the JSON strings in order. Args: n (int): The number of lines in the JSON string. json_strings (List[str]): List containing the JSON string lines. Examples: >>> extract_integers(3, [\\"{\\", \\" \\"name\\": \\"Sarah\\",\\", \\" \\"age\\": 28,\\", \\" \\"scores\\": [100, 98, 85],\\", \\" \\"details\\": {\\"height\\": 175, \\"weight\\": 70}\\", \\"}\\"]) 28 100 98 85 175 70 >>> extract_integers(2, [\\"[\\"first_number\\": 123, \\"second_number\\": 456, \\"third_number\\": 789]\\"]) 123 456 789 >>> extract_integers(4, [\\"{\\", \\" \\"array\\": [1, 2, 3],\\", \\" \\"number\\": 42,\\", \\" \\"nested\\": {\\", \\" \\"data\\": [5, 6]\\", \\" }\\", \\"}\\"]) 1 2 3 42 5 6","solution":"import re def extract_integers(n, json_strings): Extracts and prints all integers found within the JSON strings in order. :param int n: The number of lines in the JSON string :param list json_strings: List containing the JSON string lines json_combined = ' '.join(json_strings) integers = re.findall(r'[-+]?bd+b', json_combined) print(' '.join(integers))"},{"question":"def can_distribute_equally(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if Emma can read an equal number of books from each genre every month. Args: T: Number of test cases. test_cases: A list of tuples where each tuple contains an integer N (total number of books) and a list of integers where each integer Gi represents the genre of the i-th book. Returns: A list of strings \\"Possible\\" or \\"Not Possible\\" for each test case. >>> can_distribute_equally(1, [(6, [1, 2, 2, 1, 1, 2])]) [\\"Possible\\"] >>> can_distribute_equally(1, [(6, [1, 2, 2, 1, 1, 3])]) [\\"Not Possible\\"] >>> can_distribute_equally(1, [(3, [1, 1, 1])]) [\\"Possible\\"]","solution":"def can_distribute_equally(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] genres = test_cases[i][1] genre_count = {} for genre in genres: if genre in genre_count: genre_count[genre] += 1 else: genre_count[genre] = 1 counts = list(genre_count.values()) if len(set(counts)) == 1: results.append(\\"Possible\\") else: results.append(\\"Not Possible\\") return results"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Given an unsorted array of integers, find the length of the longest subsequence such that elements in the subsequence are consecutive integers, regardless of the order. Args: nums (List[int]): The input list of integers. Returns: int: The length of the longest consecutive elements sequence. Example: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 20]) 4 >>> longest_consecutive_sequence([0]) 1","solution":"def longest_consecutive_sequence(nums): Given an unsorted array of integers, find the length of the longest subsequence such that elements in the subsequence are consecutive integers, regardless of the order. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only attempt to build sequences from the start of the sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import heapq import sys from typing import List, Tuple def dijkstra(graph, start, end, n): Uses Dijkstra's algorithm to find the minimum total risk level path from start to end. # Initialize distances as infinity distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 # Priority queue to manage visiting nodes priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[end] == float('inf') else distances[end] def minimum_risk_levels(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum total risk level for navigating from a starting junction to a destination junction. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]], int, List[Tuple[int, int]]]]): List containing each test case details. Returns: List[int]: List containing the minimum risk levels for each query in all test cases. If there's no path, the result should be -1. Example: >>> T = 1 >>> test_cases = [ >>> (4, 5, >>> [(1, 2, 10), (2, 3, 10), (3, 4, 15), (1, 3, 20), (2, 4, 25)], >>> 2, >>> [(1, 4), (3, 1)] >>> ) >>> ] >>> minimum_risk_levels(T, test_cases) [35, -1] results = [] for i in range(T): N, M, edges, Q, queries = test_cases[i] # Construct graph graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Answer queries for a, b in queries: result = dijkstra(graph, a, b, N) results.append(result) return results # Define test cases to verify the solution def test_case1(): T = 1 test_cases = [ (4, 5, [(1, 2, 10), (2, 3, 10), (3, 4, 15), (1, 3, 20), (2, 4, 25)], 2, [(1, 4), (3, 1)] ) ] assert minimum_risk_levels(T, test_cases) == [35, -1] def test_no_path(): T = 1 test_cases = [ (3, 2, [(1, 2, 5), (2, 3, 5)], 1, [(3, 1)] ) ] assert minimum_risk_levels(T, test_cases) == [-1] def test_direct_path(): T = 1 test_cases = [ (3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 20)], 1, [(1, 3)] ) ] assert minimum_risk_levels(T, test_cases) == [10] def test_same_start_end(): T = 1 test_cases = [ (3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 20)], 1, [(1, 1)] ) ] assert minimum_risk_levels(T, test_cases) == [0] def test_large_risk_values(): T = 1 test_cases = [ (3, 3, [(1, 2, 100), (2, 3, 100), (1, 3, 50)], 1, [(1, 3)] ) ] assert minimum_risk_levels(T, test_cases) == [50] # Run the defined test cases def run_tests(): test_case1() test_no_path() test_direct_path() test_same_start_end() test_large_risk_values() print(\\"All tests passed!\\") run_tests()","solution":"import heapq import sys def dijkstra(graph, start, end, n): Uses Dijkstra's algorithm to find the minimum total risk level path from start to end. # Initialize distances as infinity distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 # Priority queue to manage visiting nodes priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[end] == float('inf') else distances[end] def minimum_risk_levels(T, test_cases): results = [] for i in range(T): N, M, edges, Q, queries = test_cases[i] # Construct graph graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Answer queries for a, b in queries: result = dijkstra(graph, a, b, N) results.append(result) return results"},{"question":"def num_distinct_islands(grid: List[str]) -> int: Determine the number of distinct islands in an NxN grid. An island is considered distinct if it has a unique shape. >>> num_distinct_islands([ ... \\"1100\\", ... \\"1100\\", ... \\"0010\\", ... \\"0000\\"]) 2 >>> num_distinct_islands([ ... \\"11110\\", ... \\"11010\\", ... \\"11000\\", ... \\"00000\\"]) 1 >>> num_distinct_islands([ ... \\"111\\", ... \\"010\\", ... \\"111\\"]) 1 >>> num_distinct_islands([ ... \\"100\\", ... \\"100\\", ... \\"100\\"]) 1 >>> num_distinct_islands([ ... \\"000\\", ... \\"000\\", ... \\"000\\"]) 0","solution":"def num_distinct_islands(grid): n = len(grid) visited = [[False for _ in range(n)] for _ in range(n)] def dfs(x, y, origin, shape): if x < 0 or y < 0 or x >= n or y >= n or visited[x][y] or grid[x][y] == '0': return visited[x][y] = True shape.append((x - origin[0], y - origin[1])) dfs(x + 1, y, origin, shape) dfs(x - 1, y, origin, shape) dfs(x, y + 1, origin, shape) dfs(x, y - 1, origin, shape) distinct_islands = set() for i in range(n): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: shape = [] dfs(i, j, (i, j), shape) distinct_islands.add(frozenset(shape)) return len(distinct_islands) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) grid = data[1:] print(num_distinct_islands(grid))"},{"question":"def is_score_constant(n: int, a: List[int]) -> str: Determines if the score of the sequence remains constant no matter the non-negative integer k added to each element. :param n: Length of the sequence :param a: List of integers representing the sequence. :return: 'YES' if the score is constant; 'NO' otherwise. >>> is_score_constant(3, [1, 3, 5]) 'YES' >>> is_score_constant(4, [10, 20, 10, 20]) 'NO'","solution":"def is_score_constant(n, a): Determines if the score of the sequence remains constant no matter the non-negative integer k added to each element. :param n: Length of the sequence :param a: List of integers representing the sequence. :return: 'YES' if the score is constant; 'NO' otherwise. for i in range(1, n - 1): if (a[i] - a[i-1]) != (a[i+1] - a[i]): return \\"NO\\" return \\"YES\\" # Example usage if __name__ == \\"__main__\\": n = int(input().strip()) a = list(map(int, input().strip().split())) print(is_score_constant(n, a))"},{"question":"from collections import defaultdict class FrequencyTracker: Design a class FrequencyTracker that allows you to add numbers, remove numbers, and check if there is any number with a specific frequency. Methods: - add(int number): Adds the number to the data structure. - remove(int number): Removes the number from the data structure if it is present. - hasFrequency(int frequency): Returns true if there is at least one number in the data structure that occurs with the frequency, otherwise returns false. Example: >>> tracker = FrequencyTracker() >>> tracker.add(3) >>> tracker.add(3) >>> tracker.hasFrequency(2) True >>> tracker.remove(3) >>> tracker.hasFrequency(2) False def __init__(self): pass def add(self, number: int): pass def remove(self, number: int): pass def hasFrequency(self, frequency: int) -> bool: pass def test_add(): tracker = FrequencyTracker() tracker.add(3) assert tracker.hasFrequency(1) tracker.add(3) assert tracker.hasFrequency(2) tracker.add(5) assert tracker.hasFrequency(1) tracker.add(5) assert tracker.hasFrequency(2) def test_remove(): tracker = FrequencyTracker() tracker.add(3) tracker.add(3) tracker.add(3) assert tracker.hasFrequency(3) tracker.remove(3) assert not tracker.hasFrequency(3) assert tracker.hasFrequency(2) tracker.remove(3) tracker.remove(3) assert not tracker.hasFrequency(2) assert not tracker.hasFrequency(1) def test_hasFrequency(): tracker = FrequencyTracker() tracker.add(3) assert tracker.hasFrequency(1) tracker.add(3) assert tracker.hasFrequency(2) assert not tracker.hasFrequency(1) tracker.add(3) assert tracker.hasFrequency(3) assert not tracker.hasFrequency(1) assert not tracker.hasFrequency(2)","solution":"from collections import defaultdict class FrequencyTracker: def __init__(self): self.num_count = defaultdict(int) self.freq_count = defaultdict(int) def add(self, number: int): if self.num_count[number] > 0: self.freq_count[self.num_count[number]] -= 1 self.num_count[number] += 1 self.freq_count[self.num_count[number]] += 1 def remove(self, number: int): if self.num_count[number] > 0: self.freq_count[self.num_count[number]] -= 1 self.num_count[number] -= 1 if self.num_count[number] > 0: self.freq_count[self.num_count[number]] += 1 def hasFrequency(self, frequency: int) -> bool: return self.freq_count[frequency] > 0"},{"question":"def can_form_palindrome(s: str) -> str: Returns 'YES' if the string can be rearranged to form a palindrome, otherwise returns 'NO'. >>> can_form_palindrome(\\"civic\\") == \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") == \\"YES\\" >>> can_form_palindrome(\\"hello\\") == \\"NO\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to find if they can be rearranged to form a palindrome. >>> process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"aabbcc\\", \\"aabbc\\"]) == [\\"YES\\", \\"YES\\"] >>> process_test_cases(1, [\\"abc\\"]) == [\\"NO\\"]","solution":"def can_form_palindrome(s): Returns \\"YES\\" if the string can be rearranged to form a palindrome, otherwise returns \\"NO\\". from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_test_cases(t, test_cases): return [can_form_palindrome(tc) for tc in test_cases]"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the input list. >>> max_subarray_sum([1, -3, 2, 1, -1]) # Returns 3 (2 + 1) >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) # Returns 6 (4 + (-1) + 2 + 1) >>> max_subarray_sum([5, 4, -1, 7, 8]) # Returns 23 (5 + 4 + (-1) + 7 + 8)","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the input list using Kadane's algorithm. max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"import sys from collections import defaultdict import heapq from typing import List, Tuple def find_minimum_maximum_travel_time(N: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum possible maximum travel time from the selected city to the farthest city in the kingdom. >>> find_minimum_maximum_travel_time(4, [(1, 2, 4), (2, 3, 2), (2, 4, 3)]) 4 >>> find_minimum_maximum_travel_time(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) 2 >>> find_minimum_maximum_travel_time(5, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1)]) 1 >>> find_minimum_maximum_travel_time(5, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 5, 2)]) 4","solution":"import sys from collections import defaultdict import heapq def find_minimum_maximum_travel_time(N, roads): def dijkstra(source): dist = [float('inf')] * (N + 1) dist[source] = 0 PQ = [(0, source)] while PQ: d, node = heapq.heappop(PQ) if d > dist[node]: continue for neighbor, length in graph[node]: distance = d + length if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(PQ, (distance, neighbor)) return max(dist[1:]) graph = defaultdict(list) for u, v, length in roads: graph[u].append((v, length)) graph[v].append((u, length)) min_max_travel_time = float('inf') for city in range(1, N + 1): max_travel_time = dijkstra(city) min_max_travel_time = min(min_max_travel_time, max_travel_time) return min_max_travel_time # Sample input reading def main(): input = sys.stdin.read().strip().split() N = int(input[0]) roads = [(int(input[i]), int(input[i + 1]), int(input[i + 2])) for i in range(1, len(input), 3)] print(find_minimum_maximum_travel_time(N, roads)) if __name__ == '__main__': main()"},{"question":"def dfs(N: int, graph: List[List[int]], start: int) -> List[int]: Perform Depth-First Search starting from a given node. Args: N : int : Number of nodes in the graph graph : list : Adjacency list representation of the graph start : int : Starting node for DFS Returns: list : List of nodes visited in DFS order Examples: >>> dfs(4, [[1, 2], [0, 3], [0], [1]], 0) [0, 1, 3, 2] >>> dfs(3, [[1], [0, 2], [1]], 2) [2, 1, 0] # Your code here","solution":"def dfs(N, graph, start): Perform Depth-First Search starting from a given node. Args: N : int : Number of nodes in the graph graph : list : Adjacency list representation of the graph start : int : Starting node for DFS Returns: list : List of nodes visited in DFS order visited = [False] * N result = [] def dfs_util(v): visited[v] = True result.append(v) for neighbor in graph[v]: if not visited[neighbor]: dfs_util(neighbor) dfs_util(start) return result"},{"question":"import math from typing import List, Tuple import itertools def euclidean_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: Calculates the Euclidean distance between two points. >>> round(euclidean_distance((0, 0), (3, 4)), 2) == 5.00 >>> round(euclidean_distance((1, 1), (1, 1)), 2) == 0.00 >>> round(euclidean_distance((0, 0), (0, 0)), 2) == 0.00 >>> round(euclidean_distance((-1, -1), (2, 3)), 2) == 5.00 pass def minimum_rope_length(pegs: List[Tuple[int, int]]) -> float: Computes the minimum length of rope required to connect all pegs in a closed loop. >>> minimum_rope_length([(0, 0), (2, 0), (2, 2), (0, 2)]) == 8.00 >>> minimum_rope_length([(0, 0), (2, 0), (1, 1)]) == 4.83 >>> minimum_rope_length([(0, 0), (4, 0), (4, 3), (0, 3)]) == 14.00 >>> minimum_rope_length([(1, 1), (2, 2), (3, 1)]) == 4.83 >>> minimum_rope_length([(0, 0), (1, 1), (1, 0), (0, 1)]) == 4.00 pass","solution":"import itertools import math def euclidean_distance(point1, point2): Calculates the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def minimum_rope_length(pegs): Computes the minimum length of rope required to connect all pegs in a closed loop. n = len(pegs) min_length = float('inf') permutations = itertools.permutations(pegs) for perm in permutations: length = 0 for i in range(n): length += euclidean_distance(perm[i], perm[(i + 1) % n]) min_length = min(min_length, length) return round(min_length, 2) def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) pegs = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(n)] return pegs if __name__ == \\"__main__\\": pegs = read_input() print(minimum_rope_length(pegs))"},{"question":"def min_operations(N: int) -> int: Returns the minimum number of operations required to reduce N to 1. An operation can be one of the following: 1. If \`N\` is divisible by 2, divide it by 2. 2. If \`N\` is divisible by 3, divide it by 3. 3. Subtract 1 from \`N\`. Example: >>> min_operations(10) 3 >>> min_operations(7) 3 >>> min_operations(1) 0 >>> min_operations(2) 1 >>> min_operations(3) 1 >>> min_operations(100) 7 >>> min_operations(15) 4 >>> min_operations(81) 4 >>> min_operations(999999) 19 # Complete the function here. def test_min_operations(): assert min_operations(10) == 3, \\"Test case 1 failed\\" assert min_operations(7) == 3, \\"Test case 2 failed\\" assert min_operations(1) == 0, \\"Test case 3 failed\\" assert min_operations(2) == 1, \\"Test case 4 failed\\" assert min_operations(3) == 1, \\"Test case 5 failed\\" assert min_operations(100) == 7, \\"Test case 6 failed\\" assert min_operations(15) == 4, \\"Test case 7 failed\\" assert min_operations(81) == 4, \\"Test case 8 failed\\" assert min_operations(999999) == 19, \\"Test case 9 failed\\"","solution":"def min_operations(N): Returns the minimum number of operations required to reduce N to 1. if N <= 1: return 0 dp = [0] * (N + 1) for i in range(2, N + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[N]"},{"question":"def count_passing_products(N, product_tests): Returns the number of products passing the overall quality control. Parameters: N (int): The number of products product_tests (list of str): The test results for each product Returns: int: The number of products that pass the quality control pass from solution import count_passing_products def test_given_sample(): assert count_passing_products(5, ['110', '101', '000', '111', '011']) == 4 def test_all_passing(): assert count_passing_products(3, ['111', '110', '101']) == 3 def test_none_passing(): assert count_passing_products(3, ['000', '000', '000']) == 0 def test_mixed_results(): assert count_passing_products(4, ['100', '010', '001', '111']) == 1 def test_single_product_passing(): assert count_passing_products(1, ['110']) == 1 def test_single_product_failing(): assert count_passing_products(1, ['000']) == 0","solution":"def count_passing_products(N, product_tests): Returns the number of products passing the overall quality control. Parameters: N (int): The number of products product_tests (list of str): The test results for each product Returns: int: The number of products that pass the quality control pass_count = 0 for test in product_tests: # Count the number of '1's in the string if test.count('1') >= 2: pass_count += 1 return pass_count"},{"question":"def min_coins_for_candy(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of coins needed to buy the candy. If it's not possible to pay exactly C units with the available denominations, return -1. >>> min_coins_for_candy(3, [((3, 11), [1, 5, 6]), ((3, 9), [2, 3, 5]), ((2, 7), [2, 4])]) [2, 3, -1] >>> min_coins_for_candy(1, [((2, 7), [5, 3])]) [-1] >>> min_coins_for_candy(2, [((1, 5), [5]), ((1, 6), [4])]) [1, -1] >>> min_coins_for_candy(1, [((3, 10), [1, 5, 10])]) [1]","solution":"def min_coins_for_candy(T, test_cases): def min_coins(coins, C): dp = [float('inf')] * (C + 1) dp[0] = 0 for coin in coins: for x in range(coin, C + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[C] if dp[C] != float('inf') else -1 results = [] for i in range(T): N, C = test_cases[i][0] coins = test_cases[i][1] results.append(min_coins(coins, C)) return results"},{"question":"def sort_and_filter(numbers, threshold): Sort a given list of integers in ascending order and remove any integers that are below a provided threshold. >>> sort_and_filter([5, 3, 8, 1, 4], 4) [4, 5, 8] >>> sort_and_filter([0, 2, 9, -1, 4], 2) [2, 4, 9] >>> sort_and_filter([1, 1, 1, 1], 1) [1, 1, 1, 1] >>> sort_and_filter([10, 5, 8, 3], 11) [] >>> sort_and_filter(\\"not a list\\", 4) \\"Invalid input\\" >>> sort_and_filter([1, 2, \\"three\\", 4], 3) \\"Invalid input\\" >>> sort_and_filter([1, 2, 3, 4], \\"3\\") \\"Invalid input\\" >>> sort_and_filter(1234, 4) \\"Invalid input\\" >>> sort_and_filter([], 3) [] >>> sort_and_filter([1, 2, 3, 4], 5) [] >>> sort_and_filter([4, 5, 6], 6) [6]","solution":"def sort_and_filter(numbers, threshold): # Check for invalid input if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers) or not isinstance(threshold, int): return \\"Invalid input\\" # Sort the numbers sorted_numbers = sorted(numbers) # Filter out numbers below the threshold filtered_numbers = [number for number in sorted_numbers if number >= threshold] return filtered_numbers"},{"question":"def max_run_lengths(test_cases): Find the maximum length of any run in each array test case. >>> max_run_lengths([(6, [1, 1, 2, 2, 2, 3]), (5, [4, 4, 4, 4, 4])]) [3, 5] def parse_input(input_str): Parse the input string into a list of test cases. >>> parse_input('2n6n1 1 2 2 2 3n5n4 4 4 4 4n') [(6, [1, 1, 2, 2, 2, 3]), (5, [4, 4, 4, 4, 4])] from solution import max_run_lengths, parse_input def test_single_case_multi_run(): input_str = '1n6n1 1 2 2 2 3n' test_cases = parse_input(input_str) assert max_run_lengths(test_cases) == [3] def test_single_case_single_run(): input_str = '1n5n4 4 4 4 4n' test_cases = parse_input(input_str) assert max_run_lengths(test_cases) == [5] def test_multiple_cases(): input_str = '2n6n1 1 2 2 2 3n5n4 4 4 4 4n' test_cases = parse_input(input_str) assert max_run_lengths(test_cases) == [3, 5] def test_edge_case_single_element(): input_str = '1n1n7n' test_cases = parse_input(input_str) assert max_run_lengths(test_cases) == [1] def test_edge_case_all_unique(): input_str = '1n5n1 2 3 4 5n' test_cases = parse_input(input_str) assert max_run_lengths(test_cases) == [1] def test_edge_case_long_single_run(): input_str = '1n10n3 3 3 3 3 3 3 3 3 3n' test_cases = parse_input(input_str) assert max_run_lengths(test_cases) == [10]","solution":"def max_run_lengths(test_cases): results = [] for case in test_cases: n, array = case max_run = 1 current_run = 1 for i in range(1, n): if array[i] == array[i - 1]: current_run += 1 else: max_run = max(max_run, current_run) current_run = 1 max_run = max(max_run, current_run) results.append(max_run) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): n = int(lines[idx]) array = list(map(int, lines[idx + 1].strip().split())) test_cases.append((n, array)) idx += 2 return test_cases"},{"question":"import math from typing import List, Tuple def calculate_cylinder_volumes(datasets: List[Tuple[int, int]]) -> List[str]: Calculate the volumes of cylindrical containers given a list of (height, radius) tuples. The volume is printed with two decimal places. Args: datasets (List[Tuple[int, int]]): A list of tuples where each tuple consists of height \`h\` and radius \`r\` of the cylinder. Returns: List[str]: A list of formatted volume strings with two decimal places. >>> calculate_cylinder_volumes([(10, 5), (7, 2), (0, 0)]) [\\"785.40\\", \\"87.96\\"] result = [] for h, r in datasets: if h == 0 and r == 0: break volume = math.pi * r**2 * h result.append(f\\"{volume:.2f}\\") return result def parse_input(input_lines: str) -> List[Tuple[int, int]]: Parse the input string to extract the height and radius datasets. Args: input_lines (str): The input string containing height and radius pairs separated by space. Returns: List[Tuple[int, int]]: A list of tuples where each tuple consists of height \`h\` and radius \`r\` of the cylinder. >>> parse_input(\\"10 5n7 2n0 0n\\") [(10, 5), (7, 2), (0, 0)] datasets = [] for line in input_lines.strip().split('n'): h, r = map(int, line.split()) datasets.append((h, r)) return datasets def main(input_string: str): Main function to read datasets, calculate volumes, and print the results. Args: input_string (str): The input string containing height and radius pairs separated by space. >>> main(\\"10 5n7 2n0 0n\\") 785.40 87.96 datasets = parse_input(input_string) volumes = calculate_cylinder_volumes(datasets) for volume in volumes: print(volume) if __name__ == \\"__main__\\": import sys input_string = sys.stdin.read() main(input_string)","solution":"import math def calculate_cylinder_volumes(datasets): result = [] for h, r in datasets: if h == 0 and r == 0: break volume = math.pi * r**2 * h result.append(f\\"{volume:.2f}\\") return result # Parsing input for the function def parse_input(input_lines): datasets = [] for line in input_lines.strip().split('n'): h, r = map(int, line.split()) datasets.append((h, r)) return datasets # Example use of the function def main(input_string): datasets = parse_input(input_string) volumes = calculate_cylinder_volumes(datasets) for volume in volumes: print(volume)"},{"question":"def min_steps_to_markers(n: int, k: int, markers: List[int]) -> List[int]: Given the length of the track n and the maximum distance k that can be covered in a single step, this function computes the minimum number of steps required to reach each marker. Parameters: n (int): The length of the track. k (int): The maximum distance Molly can cover in a single step. markers (list): A list of integers indicating the positions of the markers. Returns: list: A list of integers representing the minimum number of steps to each marker position. >>> min_steps_to_markers(10, 3, [1, 5, 10]) [1, 2, 4] >>> min_steps_to_markers(100, 10, [100]) [10] >>> min_steps_to_markers(50, 5, [5, 10, 15, 20, 25]) [1, 2, 3, 4, 5] >>> min_steps_to_markers(15, 3, [3, 9, 15]) [1, 3, 5] >>> min_steps_to_markers(100000, 1, [100000]) [100000] >>> min_steps_to_markers(100000, 100000, [100000]) [1] >>> min_steps_to_markers(10, 2, [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5] >>> min_steps_to_markers(10, 3, []) []","solution":"def min_steps_to_markers(n, k, markers): Given the length of the track n and the maximum distance k that can be covered in a single step, this function computes the minimum number of steps required to reach each marker. Parameters: n (int): The length of the track. k (int): The maximum distance Molly can cover in a single step. markers (list): A list of integers indicating the positions of the markers. Returns: list: A list of integers representing the minimum number of steps to each marker position. results = [] for marker in markers: results.append((marker + k - 1) // k) return results"},{"question":"def lexicographically_smallest_string(n: int, s: str) -> str: Return the lexicographically smallest string that can be achieved by any number of adjacent swaps. :param n: Length of the string :param s: Input string consisting of lowercase English letters :return: Lexicographically smallest string >>> lexicographically_smallest_string(5, 'dcba') 'abcd' >>> lexicographically_smallest_string(6, 'abcdef') 'abcdef' >>> lexicographically_smallest_string(7, 'zyxwvut') 'tuvwxyz'","solution":"def lexicographically_smallest_string(n, s): Return the lexicographically smallest string by sorting the input string. :param n: Length of the string :param s: Input string consisting of lowercase English letters :return: Lexicographically smallest string return ''.join(sorted(s))"},{"question":"def filter_primes(numbers: List[int]) -> List[int]: Returns a list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 4, 5, 28, 29, 30]) [2, 3, 5, 29] >>> filter_primes([4, 6, 8, 10, 12, 14]) [] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes(list(range(2, 50))) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> filter_primes([2]) [2] >>> filter_primes([4]) []","solution":"def is_prime(n): Helper function to check if a given number n is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(numbers): Returns a list containing only the prime numbers from the original list. Args: numbers (list of int): The list of integers to filter primes from. Returns: list of int: A list containing only the prime numbers. return [num for num in numbers if is_prime(num)]"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with unique characters. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest substring with unique characters. Examples: >>> longest_unique_substring_length(\\"abcdabca\\") 4 >>> longest_unique_substring_length(\\"bbbb\\") 1 import unittest class TestLongestUniqueSubstringLength(unittest.TestCase): def test_example1(self): s = \\"abcdabca\\" self.assertEqual(longest_unique_substring_length(s), 4) def test_example2(self): s = \\"bbbb\\" self.assertEqual(longest_unique_substring_length(s), 1) def test_all_unique(self): s = \\"abcdef\\" self.assertEqual(longest_unique_substring_length(s), 6) def test_repeated(self): s = \\"abcabcbb\\" self.assertEqual(longest_unique_substring_length(s), 3) def test_single_character(self): s = \\"a\\" self.assertEqual(longest_unique_substring_length(s), 1) def test_alternating_characters(self): s = \\"abababab\\" self.assertEqual(longest_unique_substring_length(s), 2) def test_long_string(self): s = \\"abcdefghijklmnopqrstuvwxyzaabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\\" self.assertEqual(longest_unique_substring_length(s), 26) if __name__ == \\"__main__\\": unittest.main()","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with unique characters. s: str, the input string consisting of lowercase English letters char_index_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def max_non_consecutive_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases, each representing a list of participants' skill levels, find the maximum sum of skills where no two selected participants have consecutive skill levels. :param t: Number of test cases :param test_cases: A list of tuples where each tuple contains an integer N (number of participants) and a list of N integers representing the skill levels. :return: A list of integers, where each integer is the maximum sum of skills for a test case. Examples: --------- >>> max_non_consecutive_sum(2, [(5, [3, 2, 5, 10, 7]), (4, [3, 2, 7, 10])]) [15, 13] >>> max_non_consecutive_sum(1, [(1, [10])]) [10] >>> max_non_consecutive_sum(1, [(0, [])]) [0]","solution":"def max_non_consecutive_sum(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] skills = test_cases[i][1] if n == 0: results.append(0) continue if n == 1: results.append(skills[0]) continue dp = [0] * n dp[0] = skills[0] dp[1] = max(skills[0], skills[1]) for j in range(2, n): dp[j] = max(dp[j-1], dp[j-2] + skills[j]) results.append(dp[-1]) return results"},{"question":"def find_unique_odd_occurrence(n: int, arr: List[int]) -> int: Determine if there is a unique element in the array that occurs an odd number of times. Args: n: int - the length of the array. arr: List[int] - the array of integers. Returns: int: the unique element that occurs an odd number of times, or -1 if no such element exists. >>> find_unique_odd_occurrence(5, [1, 2, 2, 1, 3]) 3 >>> find_unique_odd_occurrence(7, [1, 1, 2, 2, 3, 3, 4]) 4 >>> find_unique_odd_occurrence(6, [1, 2, 2, 1, 3, 3]) -1","solution":"def find_unique_odd_occurrence(n, arr): from collections import Counter counts = Counter(arr) unique_odd_occurrences = [num for num, count in counts.items() if count % 2 == 1] if len(unique_odd_occurrences) == 1: return unique_odd_occurrences[0] else: return -1"},{"question":"def min_children(k: int, candies: List[int]) -> int: Given an integer k representing the number of different types of candies, and an array candies of length k representing the number of candies of each type, this function returns the minimum number of children required to distribute all the candies. >>> min_children(3, [10, 20, 30]) 3 >>> min_children(5, [5, 10, 15, 20, 25]) 5 >>> min_children(2, [1, 2]) 2 >>> min_children(4, [1000, 2000, 3000, 4000]) 4 >>> min_children(1000, [1] * 1000) 1000 >>> min_children(2, [10000, 10000]) 2","solution":"def min_children(k, candies): Given an integer k representing the number of different types of candies, and an array candies of length k representing the number of candies of each type, this function returns the minimum number of children required to distribute all the candies. return k"},{"question":"from typing import List def can_hike_up_and_down(hills: List[int], d: int) -> bool: Determines if the sequence of hills can be hiked with each downhill elevation drop not exceeding the given limit d. Parameters: hills (List[int]): A list of integers representing the heights of the hills. d (int): The maximum allowed elevation drop between consecutive hills. Returns: bool: True if the hike is valid, False otherwise. Examples: >>> can_hike_up_and_down([10, 20, 15, 25, 10], 10) False >>> can_hike_up_and_down([5, 10, 8], 3) True >>> can_hike_up_and_down([1, 3, 1, 3, 1], 2) True def test_can_hike_up_and_down_example1(): assert can_hike_up_and_down([10, 20, 15, 25, 10], 10) == False def test_can_hike_up_and_down_example2(): assert can_hike_up_and_down([5, 10, 8], 3) == True def test_can_hike_up_and_down_example3(): assert can_hike_up_and_down([1, 3, 1, 3, 1], 2) == True def test_can_hike_up_and_down_edge_case_min_hills(): assert can_hike_up_and_down([100], 1) == True def test_can_hike_up_and_down_edge_case_min_drop(): assert can_hike_up_and_down([10, 11, 9], 1) == False def test_can_hike_up_and_down_large_drop(): assert can_hike_up_and_down([10, 5, 20], 15) == True def test_can_hike_up_and_down_same_hills(): assert can_hike_up_and_down([3, 3, 3, 3], 1) == True def test_can_hike_up_and_down_increasing_hills(): assert can_hike_up_and_down([1, 2, 3, 4, 5], 1) == True def test_can_hike_up_and_down_decreasing_hills_within_limit(): assert can_hike_up_and_down([10, 8, 6, 5], 5) == True def test_can_hike_up_and_down_decreasing_hills_exceeding_limit(): assert can_hike_up_and_down([10, 8, 3], 4) == False","solution":"def can_hike_up_and_down(hills, d): Determines if the sequence of hills can be hiked with each downhill elevation drop not exceeding the given limit d. Parameters: hills (List[int]): A list of integers representing the heights of the hills. d (int): The maximum allowed elevation drop between consecutive hills. Returns: bool: True if the hike is valid, False otherwise. for i in range(1, len(hills)): if hills[i-1] > hills[i] and (hills[i-1] - hills[i] > d): return False return True"},{"question":"def shift_cipher(text: str, shift: int) -> str: Shifts each letter in the text by the given number in the alphabet, wrapping around to the beginning if necessary. Numbers and non-alphabet characters remain unchanged. The returned string is in all lowercase. Parameters: text (str): the input string of alphanumeric characters. shift (int): the number of positions to shift each letter. Returns: str: the shifted string in all lowercase. EXAMPLES >>> shift_cipher('Hello, World!', 3) 'khoor, zruog!' >>> shift_cipher('Python 3.8', 5) 'udymts 3.8' >>> shift_cipher('abcdefg', 2) 'cdefghi'","solution":"def shift_cipher(text, shift): Shifts each letter in the text by the given number in the alphabet, wrapping around to the beginning if necessary. Numbers and non-alphabet characters remain unchanged. The returned string is in all lowercase. Parameters: text (str): the input string of alphanumeric characters. shift (int): the number of positions to shift each letter. Returns: str: the shifted string in all lowercase. result = [] for char in text: if char.isalpha(): # Perform the shift for alphabetical characters shifted = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a')) result.append(shifted) else: # Non-alphabetical characters remain unchanged result.append(char) return ''.join(result)"},{"question":"def count_successful_escape_rooms(test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Calculate how many escape rooms the team successfully completes based on the recorded steps and thresholds. >>> count_successful_escape_rooms([(5, [10, 20, 30, 40, 50], 150)]) [1] >>> count_successful_escape_rooms([(4, [15, 25, 35, 45], 100)]) [0] >>> count_successful_escape_rooms([ ... (5, [10, 20, 30, 40, 50], 150), ... (4, [15, 25, 35, 45], 100), ... (6, [10, 30, 10, 20, 40, 50], 200) ... ]) [1, 0, 1] >>> count_successful_escape_rooms([ ... (3, [10, 20, 10], 50), ... (2, [30, 40], 100) ... ]) [1, 1] >>> count_successful_escape_rooms([ ... (3, [50, 60, 70], 100), ... (2, [90, 20], 100) ... ]) [0, 0]","solution":"def count_successful_escape_rooms(test_cases): results = [] for test_case in test_cases: n, steps, threshold = test_case total_steps = sum(steps) if total_steps <= threshold: results.append(1) else: results.append(0) return results"},{"question":"from collections import deque from typing import List def maxSlidingWindow(nums: List[int], k: int) -> List[int]: Returns the maximum value of each subarray of size k in the given integer array nums. >>> maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) [3, 3, 5, 5, 6, 7] >>> maxSlidingWindow([9, 11], 2) [11] >>> maxSlidingWindow([4, -2], 1) [4, -2] q = deque() result = [] for i in range(len(nums)): if q and q[0] == i - k: q.popleft() while q and nums[q[-1]] <= nums[i]: q.pop() q.append(i) if i >= k - 1: result.append(nums[q[0]]) return result","solution":"from collections import deque def maxSlidingWindow(nums, k): Returns the maximum value of each subarray of size k in the given integer array nums. :param nums: List[int] - List of integers :param k: int - Size of the subarray :return: List[int] - List of the maximum values of each subarray of size k q = deque() result = [] for i in range(len(nums)): # Remove elements not within the sliding window if q and q[0] == i - k: q.popleft() # Remove elements smaller than the current element from the right while q and nums[q[-1]] <= nums[i]: q.pop() # Add current element at the end of the deque q.append(i) # Append the max of the window to the result list if i >= k - 1: result.append(nums[q[0]]) return result"},{"question":"def find_island_sizes(matrix): You are given a large binary matrix where \`1\` represents land and \`0\` represents water. An island is a group of connected \`1\`s forming a contiguous block by connecting adjacent 1's horizontally or vertically (not diagonally). Your task is to find the sizes of all islands in the matrix. Write a function that takes the binary matrix as input and returns a list of the sizes of all islands. The order of sizes in the returned list does not matter. Args: matrix (List[List[int]]): binary 2D list where 1 represents land and 0 represents water Returns: List[int]: list with the sizes of all islands found in the matrix Examples: >>> find_island_sizes([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ]) [4, 3] >>> find_island_sizes([ ... [1, 1, 0], ... [1, 0, 0], ... [0, 0, 1] ... ]) [3, 1] >>> find_island_sizes([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) []","solution":"def find_island_sizes(matrix): m = len(matrix) n = len(matrix[0]) if m > 0 else 0 def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] == 0: return 0 matrix[i][j] = 0 # Mark as visited size = 1 # Search in 4 possible directions (up, down, left, right) size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size island_sizes = [] for i in range(m): for j in range(n): if matrix[i][j] == 1: island_size = dfs(i, j) island_sizes.append(island_size) return island_sizes"},{"question":"def can_create_gift_bags(N: int, K: int, M: int) -> str: Determines whether it is possible to distribute the items into K gift bags, each containing exactly N items. If it is possible, the program should output \\"YES\\", otherwise it should output \\"NO\\". Parameters: N (int) : number of items per gift bag. K (int) : number of gift bags. M (int) : total number of items available. Returns: str : \\"YES\\" if it's possible, \\"NO\\" otherwise. >>> can_create_gift_bags(5, 3, 15) \\"YES\\" >>> can_create_gift_bags(4, 5, 20) \\"YES\\" >>> can_create_gift_bags(6, 3, 15) \\"NO\\"","solution":"def can_create_gift_bags(N, K, M): Determines if it's possible to create K gift bags with N items each from a total of M items. Parameters: N (int) : number of items per gift bag. K (int) : number of gift bags. M (int) : total number of items available. Returns: str : \\"YES\\" if it's possible, \\"NO\\" otherwise. if K * N <= M: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_operations(S: str, T: str) -> int: Returns the minimum number of subsequence operations to transform S into T. >>> min_operations(\\"abc\\", \\"abcbc\\") 2 >>> min_operations(\\"abc\\", \\"abcabc\\") 2 >>> min_operations(\\"xyz\\", \\"xyzxyzxyz\\") 3 >>> min_operations(\\"a\\", \\"aaaaa\\") 5 >>> min_operations(\\"abc\\", \\"acbac\\") 3 >>> min_operations(\\"abc\\", \\"def\\") -1 >>> min_operations(\\"a\\", \\"a\\") 1 >>> min_operations(\\"abc\\", \\"cbaabc\\") 4 >>> min_operations(\\"abcd\\", \\"abcdabcdabcd\\") 3 >>> min_operations(\\"ab\\", \\"ababab\\") 3","solution":"def min_operations(S, T): Returns the minimum number of subsequence operations to transform S into T. m, n = len(S), len(T) index_in_T = 0 operations = 0 while index_in_T < n: index = 0 while index_in_T < n and index < m: if S[index] == T[index_in_T]: index_in_T += 1 index += 1 if index_in_T == 0: # If no progress is made in T return -1 # It's impossible to form T from S operations += 1 return operations"},{"question":"def remainingElement(n: int, k: int, arr: List[int]) -> int: Remove every k-th element from the array arr until only one element remains, and return that element. Args: n (int): The length of the array. k (int): The 1-based index step to remove elements. arr (List[int]): The integer array from which to remove elements. Returns: int: The remaining element after repeatedly removing every k-th element. Examples: >>> remainingElement(7, 3, [1, 2, 3, 4, 5, 6, 7]) 4 >>> remainingElement(1, 1, [1]) 1","solution":"def remainingElement(n, k, arr): Remove every k-th element from the array arr until only one element remains, and return that element. index = 0 while len(arr) > 1: index = (index + k - 1) % len(arr) arr.pop(index) return arr[0]"},{"question":"def feeding_sequences(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Determines the sequence of animals fed each day up to day N. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains N (number of days) and P (initial sequence type). Returns: list of str: The corresponding daily feeding sequences for each test case. Sample Usage: >>> feeding_sequences(1, [(1, 'A')]) ['lion, tiger, bear'] >>> feeding_sequences(3, [ (2, 'A'), (3, 'B'), (1, 'C') ]) ['lion, tiger, bear; tiger, bear, lion', 'tiger, bear, lion; bear, lion, tiger; lion, tiger, bear', 'bear, lion, tiger'] pass","solution":"def feeding_sequences(t, test_cases): Determines the sequence of animals fed each day up to day N. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains N (number of days) and P (initial sequence type). Returns: list of str: The corresponding daily feeding sequences for each test case. sequences = { 'A': ['lion, tiger, bear', 'tiger, bear, lion', 'bear, lion, tiger'], 'B': ['tiger, bear, lion', 'bear, lion, tiger', 'lion, tiger, bear'], 'C': ['bear, lion, tiger', 'lion, tiger, bear', 'tiger, bear, lion'] } results = [] for N, P in test_cases: initial_seq = sequences[P][0] result_str = initial_seq last_index = 0 for day in range(1, N): next_index = (last_index + 1) % 3 result_str += '; ' + sequences[P][next_index] last_index = next_index results.append(result_str) return results"},{"question":"def find_missing_positive(arr): Returns the smallest positive integer that is missing from the array. >>> find_missing_positive([1, 2, 3, 4, 5, 6]) == 7 >>> find_missing_positive([1, 3, 6, 4, 1, 2, 5]) == 7 >>> find_missing_positive([1]) == 2 >>> find_missing_positive([2]) == 1 >>> find_missing_positive([2, 3, 4, 5, 6, 7, 8]) == 1 >>> find_missing_positive([3, 9, 6, 7, 5, 1, 1000000]) == 2 >>> find_missing_positive([1, 1, 1, 1]) == 2 >>> find_missing_positive(list(range(1, 1001))) == 1001","solution":"def find_missing_positive(arr): Returns the smallest positive integer that is missing from the array. n = len(arr) # Step 1: Mark elements and check presence of \`1\` contains_one = False for i in range(n): if arr[i] == 1: contains_one = True elif arr[i] <= 0 or arr[i] > n: arr[i] = 1 if not contains_one: return 1 # Step 2: Use index as a hash to record frequency of each number for i in range(n): index = abs(arr[i]) - 1 arr[index] = -abs(arr[index]) # Step 3: Find first positive value's index for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"def clean_book_borrow_log(N, book_ids): Cleans the book borrow log by removing duplicates and retaining the first occurrences in the order they appeared. Args: - N (int): Number of book IDs in the log. - book_ids (list): List of book IDs as they appeared in the log. Returns: - list: Cleaned list of book IDs with duplicates removed. >>> clean_book_borrow_log(10, [1, 2, 2, 3, 1, 4, 3, 5, 6, 4]) [1, 2, 3, 4, 5, 6] >>> clean_book_borrow_log(6, [1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> clean_book_borrow_log(0, []) [] >>> clean_book_borrow_log(1, [7]) [7] >>> clean_book_borrow_log(4, [8, 8, 8, 8]) [8] >>> clean_book_borrow_log(10, [5, 5, 5, 1, 8, 2, 2, 3, 3, 0]) [5, 1, 8, 2, 3, 0]","solution":"def clean_book_borrow_log(N, book_ids): Cleans the book borrow log by removing duplicates and retaining the first occurrences in the order they appeared. Args: - N (int): Number of book IDs in the log. - book_ids (list): List of book IDs as they appeared in the log. Returns: - list: Cleaned list of book IDs with duplicates removed. seen = set() cleaned_log = [] for book_id in book_ids: if book_id not in seen: seen.add(book_id) cleaned_log.append(book_id) return cleaned_log"},{"question":"def rankingParticipants(submissions): Nina is running a contest with some participants, and she wants to implement a ranking system. Each participant will give several submissions, and each submission has a score. Nina wants to rank the participants based on their highest scores. If two participants have the same highest score, they should be ranked based on the lowest submission time of their highest score. The ranking should be 1-based. Participants who have no submissions will not be on the ranking list. :param submissions: a list of dictionaries where each dictionary contains three keys: 'id' (an integer representing the participant ID), 'score' (an integer representing the score of the submission), and 'time' (an integer representing the submission time). :return: list of integers: the participant IDs in the ranked order. Example: >>> rankingParticipants([ {'id': 1, 'score': 50, 'time': 5}, {'id': 2, 'score': 80, 'time': 1}, {'id': 1, 'score': 80, 'time': 2}, {'id': 3, 'score': 90, 'time': 10}, {'id': 2, 'score': 85, 'time': 3}, {'id': 4, 'score': 70, 'time': 4} ]) [3, 2, 1, 4] >>> rankingParticipants([ {'id': 5, 'score': 90, 'time': 5}, {'id': 6, 'score': 90, 'time': 3}, {'id': 5, 'score': 70, 'time': 8}, {'id': 6, 'score': 80, 'time': 2}, {'id': 7, 'score': 60, 'time': 1} ]) [6, 5, 7]","solution":"def rankingParticipants(submissions): participant_best_scores = {} # Collect the highest score with the earliest time for each participant for sub in submissions: participant_id, score, time = sub['id'], sub['score'], sub['time'] if participant_id not in participant_best_scores: participant_best_scores[participant_id] = (score, time) else: current_score, current_time = participant_best_scores[participant_id] if (score > current_score) or (score == current_score and time < current_time): participant_best_scores[participant_id] = (score, time) # Sort the participants first by score descending, then by time ascending sorted_participants = sorted(participant_best_scores.keys(), key=lambda pid: (-participant_best_scores[pid][0], participant_best_scores[pid][1])) return sorted_participants"},{"question":"def min_moves_to_balance(s: str) -> int: Returns the minimum number of moves required to make the string balanced. A string is considered balanced if every opening bracket has a corresponding closing bracket of the same type and brackets close in the correct order. >>> min_moves_to_balance(\\"([])\\") 0 >>> min_moves_to_balance(\\"([)]\\") 2 >>> min_moves_to_balance(\\"([\\") 2 >>> min_moves_to_balance(\\"])\\") 2 >>> min_moves_to_balance(\\"\\") 0 >>> min_moves_to_balance(\\"(([[\\") 4 >>> min_moves_to_balance(\\"))]]\\") 4 >>> min_moves_to_balance(\\"[[([])]]\\") 0 >>> min_moves_to_balance(\\"[(])()[]\\") 2","solution":"def min_moves_to_balance(s): Returns the minimum number of moves required to make the string balanced. stack = [] moves = 0 for char in s: if char in '([': stack.append(char) elif char == ')' and stack and stack[-1] == '(': stack.pop() elif char == ']' and stack and stack[-1] == '[': stack.pop() else: moves += 1 # unmatched closing bracket moves += len(stack) # remaining unmatched opening brackets return moves"},{"question":"def is_path_possible(n, m, chocolate): Determine if there exists a path from the top-left piece to the bottom-right piece that only traverses through sweet pieces ('S') and avoids bitter pieces ('B'). Parameters: n (int): Number of rows. m (int): Number of columns. chocolate (List[str]): The n x m grid representing the chocolate bar. Returns: str: \\"YES\\" if a valid path exists, \\"NO\\" otherwise. >>> is_path_possible(3, 3, [\\"SSS\\", \\"SBS\\", \\"SSS\\"]) \\"YES\\" >>> is_path_possible(3, 3, [\\"SSS\\", \\"BBB\\", \\"SSS\\"]) \\"NO\\"","solution":"def is_path_possible(n, m, chocolate): Determine if there exists a path from the top-left piece to the bottom-right piece that only traverses through sweet pieces ('S') and avoids bitter pieces ('B'). Parameters: n (int): Number of rows. m (int): Number of columns. chocolate (List[str]): The n x m grid representing the chocolate bar. Returns: str: \\"YES\\" if a valid path exists, \\"NO\\" otherwise. from collections import deque if chocolate[0][0] == 'B' or chocolate[n-1][m-1] == 'B': return \\"NO\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and chocolate[nx][ny] == 'S': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def find_max_difference(nums): Returns the maximum difference between any two elements in the list such that the larger element comes after the smaller one. If no such pair exists, return -1. >>> find_max_difference([7, 1, 5, 3, 6, 4]) 5 >>> find_max_difference([5, 4, 3, 2, 1]) -1 >>> find_max_difference([]) -1 >>> find_max_difference([10]) -1 >>> find_max_difference([3, 3, 3, 3]) -1 >>> find_max_difference([1, 2, 3, 4, 5]) 4 >>> find_max_difference([7, 6, 4, 3, 1, 8, 10]) 9 >>> find_max_difference([5, 10, 1, 8]) 7","solution":"def find_max_difference(nums): Returns the maximum difference between any two elements in the list such that the larger element comes after the smaller one. If no such pair exists, return -1. if len(nums) < 2: return -1 min_element = nums[0] max_difference = -1 for num in nums[1:]: if num > min_element: max_difference = max(max_difference, num - min_element) else: min_element = min(min_element, num) return max_difference"},{"question":"def can_be_non_decreasing(n: int, sequence: List[int]) -> str: Determines if the sequence can be transformed into a non-decreasing sequence by changing no more than one element. Parameters: n (int): the number of elements in the sequence sequence (list of int): the sequence of integers Returns: str: \\"YES\\" if it can be transformed, otherwise \\"NO\\" >>> can_be_non_decreasing(4, [4, 2, 3, 4]) \\"YES\\" >>> can_be_non_decreasing(5, [3, 4, 2, 3, 5]) \\"NO\\" >>> can_be_non_decreasing(3, [5, 4, 3]) \\"NO\\" >>> can_be_non_decreasing(1, [1]) \\"YES\\" >>> can_be_non_decreasing(2, [2, 1]) \\"YES\\" >>> can_be_non_decreasing(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_be_non_decreasing(4, [10, 5, 7, 8]) \\"YES\\" >>> can_be_non_decreasing(6, [1, 5, 3, 4, 6, 7]) \\"YES\\"","solution":"def can_be_non_decreasing(n, sequence): Determines if the sequence can be transformed into a non-decreasing sequence by changing no more than one element. Parameters: n (int): the number of elements in the sequence sequence (list of int): the sequence of integers Returns: str: \\"YES\\" if it can be transformed, otherwise \\"NO\\" modified = False for i in range(n - 1): if sequence[i] > sequence[i + 1]: if modified: return \\"NO\\" modified = True # Check if modifying current element or next element can resolve the issue if i == 0 or sequence[i - 1] <= sequence[i + 1]: sequence[i] = sequence[i + 1] # modify sequence[i] else: sequence[i + 1] = sequence[i] # otherwise modify sequence[i + 1] return \\"YES\\""},{"question":"def total_cost(T: int, cases: List[int]) -> List[int]: Calculate the total cost to be paid for each test case based on the number of candies bought. Args: T (int): The number of test cases. cases (List[int]): A list containing the number of candies bought in each test case. Returns: List[int]: A list containing the total cost for each test case. >>> total_cost(4, [10, 25, 55, 50]) [150, 325, 550, 650] >>> total_cost(1, [1]) [15] >>> total_cost(1, [1000]) [10000]","solution":"def total_cost(T, cases): results = [] for N in cases: if N > 50: cost_per_candy = 15 - 5 elif N > 20: cost_per_candy = 15 - 2 else: cost_per_candy = 15 total = N * cost_per_candy results.append(total) return results"},{"question":"import math def translate_point(point, distance, angle): Translates a point by a given distance in a specified direction. Args: - point: a list or tuple of two floats [x, y] representing original coordinates. - distance: a float, the distance to move the point. - angle: a float, the direction in degrees from the positive x-axis. Returns: - A list containing the new coordinates of the point [x_new, y_new], rounded to four decimal places. >>> translate_point([1.0, 1.0], 5.0, 90) [1.0, 6.0] >>> translate_point([-2.0, -3.0], 7.0, 45) [2.9497, 1.9497] >>> translate_point([0.0, 0.0], 10.0, 180) [-10.0, 0.0]","solution":"import math def translate_point(point, distance, angle): Translates a point by a given distance in a specified direction. Args: - point: a list or tuple of two floats [x, y] representing original coordinates. - distance: a float, the distance to move the point. - angle: a float, the direction in degrees from the positive x-axis. Returns: - A list containing the new coordinates of the point [x_new, y_new], rounded to four decimal places. x, y = point angle_rad = math.radians(angle) x_new = x + distance * math.cos(angle_rad) y_new = y + distance * math.sin(angle_rad) return [round(x_new, 4), round(y_new, 4)]"},{"question":"def min_changes_for_unique_ranks(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: A gaming company wants to implement a new ranking system for their competitive games. Each player is assigned a rank based on their performance. Given the total number of players and the rank of each player, the company wants to enforce a rule that says: for every player, their rank must be unique and between 1 and n (inclusive), where n is the total number of players. Write a program that reads the rank assigned to each player and outputs the minimum number of changes required to make all the ranks unique and valid according to the rule described. If it is not possible to create such unique ranking, output -1. >>> min_changes_for_unique_ranks(2, [(5, [4, 4, 4, 4, 4]), (3, [3, 2, 1])]) [4, 0] >>> min_changes_for_unique_ranks(1, [(3, [1, 2, 3])]) [0] >>> min_changes_for_unique_ranks(1, [(4, [1, 1, 1, 1])]) [3]","solution":"def min_changes_for_unique_ranks(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] ranks = test_cases[i][1] rank_counter = {} for rank in ranks: if rank in rank_counter: rank_counter[rank] += 1 else: rank_counter[rank] = 1 # Count of duplicates and their respective transformations: changes_needed = 0 unique_ranks = set() for rank, count in rank_counter.items(): if count > 1: changes_needed += count - 1 unique_ranks.add(rank) # Check if the number of changes can fit into the valid range if len(unique_ranks) + changes_needed > n: results.append(-1) else: results.append(changes_needed) return results"},{"question":"def is_multiple(A: int, B: int) -> str: Determines whether B is a multiple of A. Args: A (int): The first integer. B (int): The second integer. Returns: str: \\"Yes\\" if B is a multiple of A, otherwise \\"No\\". >>> is_multiple(3, 9) 'Yes' >>> is_multiple(2, 10) 'No' >>> is_multiple(5, 25) 'Yes' >>> is_multiple(7, 50) 'No' >>> is_multiple(1, 10000) 'Yes' # Your implementation here","solution":"def is_multiple(A, B): Determines whether B is a multiple of A. Args: A (int): The first integer. B (int): The second integer. Returns: str: \\"Yes\\" if B is a multiple of A, otherwise \\"No\\". if B % A == 0: return \\"Yes\\" return \\"No\\""},{"question":"def reconstruct_array(nums: List[int]) -> List[int]: Reconstruct the original array based on the frequency mentioned and return it in non-decreasing order. Args: nums (List[int]): List of integers where the value at each index represents the frequency of (index + 1) Returns: List[int]: The reconstructed array in non-decreasing order. >>> reconstruct_array([2, 1, 1]) [1, 1, 2, 3] >>> reconstruct_array([1, 3, 2]) [1, 2, 2, 2, 3, 3]","solution":"def reconstruct_array(nums): Reconstruct the original array based on the frequency mentioned. Args: nums (List[int]): List of integers where the value at each index represents the frequency of (index + 1) Returns: List[int]: The reconstructed array in non-decreasing order. reconstructed_array = [] for index, frequency in enumerate(nums): element = index + 1 reconstructed_array.extend([element] * frequency) return reconstructed_array"},{"question":"import math from typing import List, Tuple def gcd_of_pairs(test_cases: List[Tuple[int, int]]) -> List[int]: Returns the GCD for each pair of integers provided in the test cases. Parameters: test_cases (list): A list containing T tuples, each with a pair of integers (a, b). Returns: list: A list containing the GCD for each pair. >>> gcd_of_pairs([(14, 21), (35, 10), (100, 25)]) [7, 5, 25] >>> gcd_of_pairs([(12, 15)]) [3] >>> gcd_of_pairs([(13, 17), (11, 19)]) [1, 1] >>> gcd_of_pairs([(100, 100), (999, 999)]) [100, 999] >>> gcd_of_pairs([(8, 16), (18, 54)]) [8, 18] >>> gcd_of_pairs([(10**9, 2 * 10**9), (3 * 10**8, 9 * 10**8)]) [1000000000, 300000000]","solution":"import math def gcd_of_pairs(test_cases): Returns the GCD for each pair of integers provided in the test cases. Parameters: test_cases (list): A list containing T tuples, each with a pair of integers (a, b). Returns: list: A list containing the GCD for each pair. results = [] for a, b in test_cases: results.append(math.gcd(a, b)) return results"},{"question":"def normalize_scores(target: int, n: int, scores: List[int]) -> List[float]: Normalize the scores such that their sum is equal to the target value. Parameters: target: The target sum to normalize to. n: The number of players. scores: The original scores of the players. Returns: The normalized scores, rounded to two decimal places. pass # Example usage: # >>> normalize_scores(100, 4, [10, 20, 30, 40]) # [10.0, 20.0, 30.0, 40.0] from solution import normalize_scores def test_normalize_scores_basic(): assert normalize_scores(100, 4, [10, 20, 30, 40]) == [10.0, 20.0, 30.0, 40.0] def test_normalize_scores_target_50(): normalized = normalize_scores(50, 4, [10, 20, 30, 40]) assert len(normalized) == 4 assert sum(normalized) == 50 assert all(isinstance(score, float) for score in normalized) def test_normalize_scores_with_rounding(): normalized = normalize_scores(100, 3, [1, 2, 3]) assert len(normalized) == 3 assert sum(normalized) == 100 assert all(isinstance(score, float) for score in normalized) def test_normalize_scores_large_value(): normalized = normalize_scores(1000000, 2, [5000, 15000]) assert len(normalized) == 2 assert sum(normalized) == 1000000 assert all(isinstance(score, float) for score in normalized) def test_normalize_scores_single_score(): assert normalize_scores(100, 1, [40]) == [100.0] def test_normalize_scores_mixed_scores(): normalized = normalize_scores(97, 3, [13, 27, 57]) assert len(normalized) == 3 assert sum(normalized) == 97 assert all(isinstance(score, float) for score in normalized)","solution":"def normalize_scores(target, n, scores): Normalize the scores such that their sum is equal to the target value. Parameters: target (int): The target sum to normalize to. n (int): The number of players. scores (list of int): The original scores of the players. Returns: list of float: The normalized scores, rounded to two decimal places. total_score = sum(scores) normalized_scores = [(score * target / total_score) for score in scores] normalized_scores = [round(score, 2) for score in normalized_scores] # To handle rounding issues ensuring the sum is exactly the target value difference = target - sum(normalized_scores) increments = difference / len(scores) adjusted_normalized_scores = [score + increments for score in normalized_scores] return adjusted_normalized_scores"},{"question":"from typing import List, Tuple def can_deplete_laser(L: int, D: int, N: int) -> bool: Determine if Perry can totally deplete the laser's energy to zero given the constraints. >>> can_deplete_laser(15, 5, 1) True >>> can_deplete_laser(10, 3, 0) False >>> can_deplete_laser(21, 6, 0) True >>> can_deplete_laser(10, 4, 1) True >>> can_deplete_laser(50, 10, 1) True pass def process_test_cases(T: int, cases: List[Tuple[int, int, int]]) -> List[str]: Process multiple test cases and determine the results for each. >>> T = 2 >>> cases = [(15, 5, 1), (10, 3, 0)] >>> process_test_cases(T, cases) ['YES', 'NO'] >>> T = 3 >>> cases = [(21, 6, 0), (10, 4, 1), (50, 10, 1)] >>> process_test_cases(T, cases) ['YES', 'YES', 'YES'] pass","solution":"def can_deplete_laser(L, D, N): # Calculate sum of first D natural numbers max_sum = D * (D + 1) // 2 # With N resets, Perry can apply the decrement sequence (N + 1) times total_energy_depleted = max_sum * (N + 1) return total_energy_depleted >= L def process_test_cases(T, cases): results = [] for L, D, N in cases: if can_deplete_laser(L, D, N): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_leap_years(start_year: int, end_year: int) -> List[int]: Returns a list of all leap years between start_year and end_year (inclusive). A leap year is exactly divisible by 4, except for end-of-century years like 1900, which are not leap years unless divisible by 400. >>> find_leap_years(2000, 2020) == [2000, 2004, 2008, 2012, 2016, 2020] >>> find_leap_years(2001, 2001) == [] >>> find_leap_years(2000, 2000) == [2000] >>> find_leap_years(1900, 1900) == [] >>> find_leap_years(1896, 1904) == [1896, 1904] >>> find_leap_years(2019, 2021) == [2020] leap_years = [] # Traverse through each year in the range for year in range(start_year, end_year + 1): # Check if the year is a leap year if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): leap_years.append(year) return leap_years","solution":"def find_leap_years(start_year, end_year): Returns a list of all leap years between start_year and end_year (inclusive). A leap year is exactly divisible by 4, except for end-of-century years like 1900, which are not leap years unless divisible by 400. leap_years = [] for year in range(start_year, end_year + 1): if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): leap_years.append(year) return leap_years"},{"question":"def shortest_loop_sum(array: List[int], target: int) -> List[int]: Finds the shortest contiguous subarray whose sum equals the given target. Parameters: array (list): A list of integers, both positive and negative. target (int): An integer representing the target sum. Returns: list: The shortest contiguous subarray whose sum equals the target. If no such subarray exists, returns an empty list. Examples: >>> shortest_loop_sum([1, 2, 3, 4, -2, -1, 7, 5], 7) [2, 3, 2] >>> shortest_loop_sum([1, -1, 2, -2, 3, -3, 4], 3) [3] >>> shortest_loop_sum([1, 2, 3, 4, 5], 20) []","solution":"def shortest_loop_sum(array, target): Finds the shortest contiguous subarray whose sum equals the given target. Parameters: array (list): A list of integers, both positive and negative. target (int): An integer representing the target sum. Returns: list: The shortest contiguous subarray whose sum equals the target. If no such subarray exists, returns an empty list. n = len(array) min_length = float('inf') result = [] current_sum = 0 start_index = 0 hash_map = {0: -1} for end_index in range(n): current_sum += array[end_index] if (current_sum - target) in hash_map: start_index_candidate = hash_map[current_sum - target] + 1 subarray_length = end_index - start_index_candidate + 1 if subarray_length < min_length: min_length = subarray_length start_index = start_index_candidate result = array[start_index:end_index + 1] hash_map[current_sum] = end_index return result"},{"question":"class SegmentTree: def __init__(self, data): ... def build(self): ... def update(self, idx, value): ... def query(self, l, r): ... def process_queries(n, q, arr, queries): Given an integer array \`arr\` of length \`n\`, perform a series of \`q\` queries on the array. Each query is defined as either an update to the array or a retrieval of the current maximum value in a given subarray. Args: n (int): Length of the array. q (int): Number of queries. arr (List[int]): The initial values of the array. queries (List[List[Union[str, int]]]): A list of queries to perform on the array. Returns: List[int]: Results of the 'Q' queries. >>> process_queries(5, 5, [1, 2, 3, 4, 5], [['Q', 1, 3], ['U', 2, 10], ['Q', 1, 3], ['U', 3, 7], ['Q', 2, 5]]) [3, 10, 10] >>> process_queries(3, 4, [1, 2, 3], [['Q', 1, 2], ['U', 1, 5], ['Q', 1, 3], ['Q', 2, 3]]) [2, 5, 3] >>> process_queries(1, 2, [5], [['Q', 1, 1], ['U', 1, 10]]) [5] >>> process_queries(4, 5, [2, 4, 6, 8], [['U', 1, 10], ['U', 2, 10], ['U', 3, 10], ['U', 4, 10], ['Q', 1, 4]]) [10] >>> process_queries(6, 6, [3, 1, 4, 1, 5, 9], [['Q', 1, 3], ['Q', 2, 5], ['Q', 3, 6], ['U', 4, 10], ['Q', 2, 5], ['Q', 1, 6]]) [4, 5, 9, 10, 10]","solution":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.data = data self.tree = [0] * (2 * n) self.build() def build(self): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.data[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = max(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, l, r): res = float('-inf') l += self.n r += self.n while l < r: if l % 2 == 1: res = max(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = max(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(n, q, arr, queries): st = SegmentTree(arr) results = [] for query in queries: if query[0] == 'U': _, x, y = query st.update(x - 1, y) elif query[0] == 'Q': _, l, r = query results.append(st.query(l - 1, r)) return results"},{"question":"def team_ranking(wins: int, draws: int, losses: int) -> str: Determines the ranking of a sports team based on its performance. Args: wins (int): Number of matches won. draws (int): Number of matches drawn. losses (int): Number of matches lost. Returns: str: The team's rank. >>> team_ranking(22, 3, 2) 'Champion' >>> team_ranking(16, 0, 0) 'Top Team' >>> team_ranking(12, 4, 8) 'Average Team' >>> team_ranking(8, 6, 7) 'Average Team' >>> team_ranking(10, 2, 9) 'Underperformer'","solution":"def team_ranking(wins, draws, losses): Determines the ranking of a sports team based on its performance. Args: wins (int): Number of matches won. draws (int): Number of matches drawn. losses (int): Number of matches lost. Returns: str: The team's rank. if wins > 20: return \\"Champion\\" elif wins > 15 and losses == 0: return \\"Top Team\\" elif wins > 10 or draws >= 5: return \\"Average Team\\" else: return \\"Underperformer\\""},{"question":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given array. def max_people_picked(n, hat_numbers): Returns the maximum number of people that can be picked such that each successive person in the sub-sequence has a strictly greater hat number than the previous person. def test_longest_increasing_subsequence(): assert max_people_picked(5, [1, 3, 2, 5, 4]) == 3 assert max_people_picked(6, [10, 20, 10, 30, 20, 50]) == 4 assert max_people_picked(1, [1]) == 1 assert max_people_picked(2, [5, 5]) == 1 assert max_people_picked(8, [1, 2, 1, 3, 2, 4, 3, 5]) == 5 assert max_people_picked(9, [9, 1, 2, 3, 10, 11, 4, 5, 6]) == 6 def test_edge_cases(): assert max_people_picked(0, []) == 0 assert max_people_picked(3, [3, 2, 1]) == 1 assert max_people_picked(4, [7, 6, 5, 8]) == 2","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will be the length of the LIS ending at index i for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def max_people_picked(n, hat_numbers): Returns the maximum number of people that can be picked such that each successive person in the sub-sequence has a strictly greater hat number than the previous person. return longest_increasing_subsequence(hat_numbers)"},{"question":"def can_balance(weights): Returns \\"YES\\" if the weights can be perfectly balanced on a scale, \\"NO\\" otherwise. >>> can_balance([1, 2, 3]) == \\"YES\\" >>> can_balance([2, 2, 2, 2]) == \\"YES\\" >>> can_balance([10, 5]) == \\"NO\\" pass def process_input(input_data): Process the input data and return the results for multiple test cases. >>> process_input(\\"3n1 2 3n4n2 2 2 2n2n10 5n0n\\") == [\\"YES\\", \\"YES\\", \\"NO\\"] pass # Example usage def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def can_balance(weights): Returns \\"YES\\" if the weights can be perfectly balanced on a scale, \\"NO\\" otherwise. total_weight = sum(weights) if total_weight % 2 != 0: return \\"NO\\" target_weight = total_weight // 2 n = len(weights) # Use dynamic programming to check if there's a subset with sum equal to target_weight dp = [False] * (target_weight + 1) dp[0] = True for weight in weights: for j in range(target_weight, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return \\"YES\\" if dp[target_weight] else \\"NO\\" def process_input(input_data): input_lines = input_data.strip().split('n') results = [] i = 0 while i < len(input_lines): N = int(input_lines[i]) if N == 0: break weights = list(map(int, input_lines[i + 1].split())) i += 2 results.append(can_balance(weights)) return results # Example usage def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def maxSumNonAdjacent(N: int, arr: List[int]) -> int: Determine the maximum sum of prices of items that can be selected such that no two selected items have adjacent indexes in the original list. >>> maxSumNonAdjacent(5, [3, 2, 5, 10, 7]) 15 >>> maxSumNonAdjacent(4, [3, 2, 7, 10]) 13 >>> maxSumNonAdjacent(1, [5]) 5 >>> maxSumNonAdjacent(2, [5, 10]) 10 >>> maxSumNonAdjacent(5, [10, 10, 10, 10, 10]) 30 >>> maxSumNonAdjacent(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30 >>> maxSumNonAdjacent(0, []) 0 pass","solution":"def maxSumNonAdjacent(N, arr): if N == 0: return 0 if N == 1: return arr[0] prev1 = max(0, arr[0]) prev2 = 0 for i in range(1, N): current = max(prev1, prev2 + arr[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def min_scarecrows_to_guard_trees(T: int, test_cases: List[int]) -> List[int]: Calculate the minimum number of scarecrows needed to guard all the trees in each test case. Parameters: T (int): Number of test cases. test_cases (List[int]): List of integers where each integer denotes the number of trees in a test case. Returns: List[int]: List where each element corresponds to the minimum number of scarecrows needed for each test case. >>> min_scarecrows_to_guard_trees(3, [5, 8, 1]) [2, 3, 1] >>> min_scarecrows_to_guard_trees(3, [1, 2, 3]) [1, 1, 1] >>> min_scarecrows_to_guard_trees(3, [4, 7, 10]) [2, 3, 4] >>> min_scarecrows_to_guard_trees(3, [100000, 100000, 100000]) [33334, 33334, 33334] from typing import List","solution":"def min_scarecrows_to_guard_trees(T, test_cases): This function calculates the number of scarecrows required to guard all the trees for each test case. Parameters: T (int): Number of test cases test_cases (list of int): List of values where each value denotes the number of trees. Returns: list of int: List where each element corresponds to the minimum number of scarecrows needed for each test case. results = [] for N in test_cases: # If there is only one tree, one scarecrow is enough if N == 1: results.append(1) continue # Minimum number of scarecrows required count = (N + 2) // 3 results.append(count) return results"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns indices of two numbers in the list whose sum equals the target. If such pair exists, a tuple (i, j) is returned where i < j. If no such pair exists, returns an empty tuple. pass # Test cases def test_pair_exists_first_example(): assert find_pair_with_sum([2, 7, 11, 15], 9) == (0, 1) def test_pair_exists_second_example(): assert find_pair_with_sum([1, 2, 3, 4, 6], 6) == (1, 3) def test_pair_exists_third_example(): assert find_pair_with_sum([3, 2, 4], 6) == (1, 2) def test_pair_does_not_exist(): assert find_pair_with_sum([1, 2, 3], 7) == () def test_multiple_pairs(): assert find_pair_with_sum([1, 2, 3, 4, 5], 5) in [(0, 3), (1, 2)] def test_single_element_appears_twice(): assert find_pair_with_sum([1, 2, 2, 3], 4) == (1, 2) def test_pair_with_negative_elements(): assert find_pair_with_sum([-1, -2, -3, -4, -5], -8) == (2, 4) def test_long_list(): nums = list(range(1, 10001)) target = 19999 assert find_pair_with_sum(nums, target) == (9998, 9999)","solution":"from typing import List, Tuple def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns indices of two numbers in the list whose sum equals the target. If such pair exists, a tuple (i, j) is returned where i < j. If no such pair exists, returns an empty tuple. num_index_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_index_map: return (num_index_map[complement], i) num_index_map[num] = i return ()"},{"question":"from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Write a function that takes a non-empty array of non-negative integers and an integer k, and returns the k-th largest element in the array. The input array may contain duplicate values, and the elements within the array are not sorted. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1, 1, 1, 1, 1], 2) 1","solution":"def find_kth_largest(arr, k): Returns the k-th largest element in the array. arr.sort(reverse=True) return arr[k-1]"},{"question":"def find_longest_word(sentence: str) -> str: Returns the longest word in the given sentence. If there are multiple words with the same maximum length, returns the first one that appears. :param sentence: A string containing a list of words separated by spaces. :return: The longest word in the sentence. >>> find_longest_word(\\"the quick brown fox jumped over the lazy dog\\") 'jumped' >>> find_longest_word(\\"a quick movement of the enemy will jeopardize five gunboats\\") 'jeopardize' >>> find_longest_word(\\"hello world\\") 'hello' >>> find_longest_word(\\"test the longest string in this sentence\\") 'sentence' >>> find_longest_word(\\"python is awesome\\") 'awesome'","solution":"def find_longest_word(sentence): Returns the longest word in the given sentence. If there are multiple words with the same maximum length, returns the first one that appears. :param sentence: A string containing a list of words separated by spaces. :return: The longest word in the sentence. words = sentence.split() longest_word = \\"\\" for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"class SubarraySum: Class to process multiple queries on an array to find the sum of elements in a subarray defined by two indices. >>> array = [3, 7, 2, 6, 5, 8, 1, 9] >>> subarray_sum = SubarraySum(array) >>> subarray_sum.query_sum(1, 4) 18 >>> subarray_sum.query_sum(2, 6) 28 def __init__(self, array: List[int]): Initializes the SubarraySum with the given array and prepares a prefix sum array for efficient querying. :param array: List[int] - the input array of integers pass def query_sum(self, L: int, R: int) -> int: Returns the sum of the elements in the subarray from index L to R inclusive. :param L: int - the starting index of the subarray (1-based) :param R: int - the ending index of the subarray (1-based) :return: int - the sum of the subarray pass","solution":"class SubarraySum: def __init__(self, array): Initializes the SubarraySum with the given array and prepares a prefix sum array for efficient querying. :param array: List[int] - the input array of integers self.array = array self.prefix_sum = [0] * (len(array) + 1) # Build the prefix sum array for i in range(1, len(array) + 1): self.prefix_sum[i] = self.prefix_sum[i - 1] + array[i - 1] def query_sum(self, L, R): Returns the sum of the elements in the subarray from index L to R inclusive. :param L: int - the starting index of the subarray (1-based) :param R: int - the ending index of the subarray (1-based) :return: int - the sum of the subarray return self.prefix_sum[R] - self.prefix_sum[L - 1]"},{"question":"from typing import List, Tuple def shortest_paths(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determine the shortest travel time from the central station (node 1) to each intersection. Args: n: The number of intersections. m: The number of roads. roads: A list of tuples, where each tuple contains three integers u, v, and t, representing that there is a road connecting intersection u and intersection v with travel time t. Returns: A list of integers where each integer represents the shortest travel time from the central station to intersections from 2 to n. If an intersection is unreachable, the travel time should be -1. Examples: >>> shortest_paths(4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1)]) [4, 2, 3] >>> shortest_paths(3, 2, [(1, 2, 3), (2, 3, 1)]) [3, 4] >>> shortest_paths(5, 3, [(1, 2, 2), (1, 3, 3), (4, 5, 1)]) [2, 3, -1, -1] pass","solution":"import heapq from collections import defaultdict def shortest_paths(n, m, roads): graph = defaultdict(list) for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) def dijkstra(start, n): distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances result = dijkstra(1, n) output = [] for i in range(2, n+1): if result[i] != float('inf'): output.append(result[i]) else: output.append(-1) return output"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Given a string \`s\` consisting of lowercase alphabets, and an integer \`k\` representing a number of distinct characters allowed, find the longest substring of \`s\` that contains at most \`k\` distinct characters. If \`k\` is greater than the number of distinct characters in \`s\`, return the length of \`s\`. Args: s (str): input string of lowercase alphabets. k (int): number of distinct characters allowed in the substring. Returns: int: length of the longest substring with at most \`k\` distinct characters. Examples: >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"aa\\", 1) 2 >>> longest_substring_k_distinct(\\"abcabcabc\\", 3) 9 >>> longest_substring_k_distinct(\\"aac\\", 2) 3 >>> longest_substring_k_distinct(\\"aaa\\", 4) 3 import pytest def test_example_cases(): assert longest_substring_k_distinct(\\"eceba\\", 2) == 3 assert longest_substring_k_distinct(\\"aa\\", 1) == 2 assert longest_substring_k_distinct(\\"abcabcabc\\", 3) == 9 assert longest_substring_k_distinct(\\"aac\\", 2) == 3 assert longest_substring_k_distinct(\\"aaa\\", 4) == 3 def test_empty_string(): assert longest_substring_k_distinct(\\"\\", 2) == 0 def test_zero_distinct_characters_allowed(): assert longest_substring_k_distinct(\\"abc\\", 0) == 0 def test_k_greater_than_string_length(): assert longest_substring_k_distinct(\\"abcdef\\", 10) == 6 def test_single_character_string(): assert longest_substring_k_distinct(\\"aaaa\\", 1) == 4 def test_string_with_multiple_distinct_characters(): assert longest_substring_k_distinct(\\"aabacbebebe\\", 3) == 7 # \\"cbebebe\\" def test_string_with_no_repeats(): assert longest_substring_k_distinct(\\"abcdef\\", 3) == 3 # \\"abc\\", \\"bcd\\", etc. @pytest.mark.parametrize(\\"s, k, expected_length\\", [ (\\"abaccc\\", 2, 4), # \\"abac\\" or \\"accc\\" (\\"aaabbcc\\", 1, 3), # \\"aaa\\" or \\"bbb\\" or \\"ccc\\" (\\"abcde\\", 5, 5), # \\"abcde\\" (\\"ababababababa\\", 2, 13), # \\"ababababababa\\" ]) def test_parametrized_cases(s, k, expected_length): assert longest_substring_k_distinct(s, k) == expected_length","solution":"def longest_substring_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0: # If no distinct characters are allowed, return 0 return 0 n = len(s) if n == 0: return 0 if k >= n: # If k is greater than or equal to the number of characters in s, return the length of s return n left = 0 right = 0 max_length = 0 char_frequency = {} while right < n: # Add the right character to the frequency dictionary if s[right] in char_frequency: char_frequency[s[right]] += 1 else: char_frequency[s[right]] = 1 # If window contains more than k distinct characters, remove from the left while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 # Update the maximum length max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def alphabet_position(s: str) -> str: Takes a string s consisting of lowercase letters and returns a new string where each letter is replaced by its corresponding position in the alphabet. >>> alphabet_position(\\"abc\\") # \\"123\\" >>> alphabet_position(\\"zzz\\") # \\"262626\\"","solution":"def alphabet_position(s): Takes a string s consisting of lowercase letters and returns a new string where each letter is replaced by its corresponding position in the alphabet. return ''.join(str(ord(char) - ord('a') + 1) for char in s)"},{"question":"def reduction_length(n): Computes the reduction lengths of integers from 1 to n where the transformation rules are as follows: 1. If the integer is even, divide it by 2. 2. If the integer is odd, multiply it by 3 and add 1. Args: n (int): The upper limit integer. Returns: dict: A dictionary where keys are integers from 1 to n and values are their corresponding reduction lengths. Example: >>> reduction_length(5) {1: 0, 2: 1, 3: 7, 4: 2, 5: 5} from solution import reduction_length def test_reduction_length_small_number(): assert reduction_length(5) == {1: 0, 2: 1, 3: 7, 4: 2, 5: 5} def test_reduction_length_only_1(): assert reduction_length(1) == {1: 0} def test_reduction_length_up_to_10(): assert reduction_length(10) == {1: 0, 2: 1, 3: 7, 4: 2, 5: 5, 6: 8, 7: 16, 8: 3, 9: 19, 10: 6} def test_reduction_length_up_to_15(): expected = { 1: 0, 2: 1, 3: 7, 4: 2, 5: 5, 6: 8, 7: 16, 8: 3, 9: 19, 10: 6, 11: 14, 12: 9, 13: 9, 14: 17, 15: 17 } assert reduction_length(15) == expected def test_reduction_length_up_to_20(): expected = { 1: 0, 2: 1, 3: 7, 4: 2, 5: 5, 6: 8, 7: 16, 8: 3, 9: 19, 10: 6, 11: 14, 12: 9, 13: 9, 14: 17, 15: 17, 16: 4, 17: 12, 18: 20, 19: 20, 20: 7 } assert reduction_length(20) == expected","solution":"def reduction_length(n): Computes the reduction lengths of integers from 1 to n. def compute_length(x): Computes the reduction length for a single integer x. steps = 0 while x != 1: if x % 2 == 0: x //= 2 else: x = 3 * x + 1 steps += 1 return steps result = {} for i in range(1, n + 1): result[i] = compute_length(i) return result"},{"question":"from typing import List def process_queries(queries: List[str]) -> List[List[int]]: Processes a series of transactions and queries to determine the top k customers with the highest total transaction amounts. Args: queries (List[str]): A list of strings representing transactions and queries. \\"T X C\\" adds a transaction of X amount for customer C. \\"Q L\\" asks for the top L customers by transaction amount. Returns: List[List[int]]: A list of lists containing the results of each \\"Q L\\" query. Example: >>> process_queries([ \\"T 500 1\\", \\"T 300 2\\", \\"T 200 1\\", \\"Q 2\\", \\"T 400 3\\", \\"Q 1\\", \\"Q 3\\" ]) [[1, 2], [1], [1, 3, 2]]","solution":"from collections import defaultdict import heapq class TransactionManager: def __init__(self): self.transactions = defaultdict(int) def add_transaction(self, amount, customer_id): self.transactions[customer_id] += amount def top_customers(self, k): if not self.transactions: return [] # Building a max-heap sorted by the total amount, then by customer_id max_heap = [(-total, customer_id) for customer_id, total in self.transactions.items()] heapq.heapify(max_heap) top_k = [] for _ in range(min(k, len(max_heap))): total, customer_id = heapq.heappop(max_heap) top_k.append(customer_id) return top_k def process_queries(queries): transaction_manager = TransactionManager() results = [] for query in queries: parts = query.split() if parts[0] == 'T': amount, customer_id = int(parts[1]), int(parts[2]) transaction_manager.add_transaction(amount, customer_id) elif parts[0] == 'Q': k = int(parts[1]) results.append(transaction_manager.top_customers(k)) return results"},{"question":"def min_venues(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of venues required to host all events for each test case. >>> min_venues(2, [(3, [(1, 4), (2, 5), (4, 7)]), (4, [(1, 3), (2, 4), (3, 5), (5, 6)])]) [2, 2] >>> min_venues(1, [(3, [(1, 2), (3, 4), (5, 6)])]) [1] import pytest def test_min_venues(): T = 2 test_cases = [ (3, [(1, 4), (2, 5), (4, 7)]), (4, [(1, 3), (2, 4), (3, 5), (5, 6)]) ] expected = [2, 2] assert min_venues(T, test_cases) == expected def test_single_event(): T = 1 test_cases = [ (1, [(1, 5)]) ] expected = [1] assert min_venues(T, test_cases) == expected def test_non_overlapping_events(): T = 1 test_cases = [ (3, [(1, 2), (3, 4), (5, 6)]) ] expected = [1] assert min_venues(T, test_cases) == expected def test_all_overlapping_events(): T = 1 test_cases = [ (3, [(1, 4), (2, 5), (3, 6)]) ] expected = [3] assert min_venues(T, test_cases) == expected def test_large_input(): T = 1 N = 10000 events = [(i, i+1) for i in range(0, 20000, 2)] test_cases = [(N, events)] expected = [1] assert min_venues(T, test_cases) == expected","solution":"def min_venues(T, test_cases): results = [] for test_case in test_cases: N, events = test_case times = [] for start, end in events: times.append((start, 'start')) times.append((end, 'end')) times.sort() max_venues = 0 current_venues = 0 for time in times: if time[1] == 'start': current_venues += 1 if current_venues > max_venues: max_venues = current_venues else: current_venues -= 1 results.append(max_venues) return results"},{"question":"def min_teams_required(N: int, projects: List[Tuple[int, int]]) -> int: Finds the minimum number of teams required to handle all the projects without overlap. Parameters: N (int): Number of projects projects (list of tuples): Each tuple contains two elements, the start and end dates of a project Returns: int: Minimum number of teams required >>> min_teams_required(3, [(1, 4), (2, 5), (4, 6)]) 2 >>> min_teams_required(4, [(1, 3), (3, 5), (5, 6), (6, 8)]) 1","solution":"def min_teams_required(N, projects): Finds the minimum number of teams required to handle all the projects without overlap. Parameters: N (int): Number of projects projects (list of tuples): Each tuple contains two elements, the start and end dates of a project Returns: int: Minimum number of teams required # Extract start and end times as separate events events = [] for start, end in projects: events.append((start, 'start')) events.append((end, 'end')) # Sort events. If two events have the same time, 'end' event comes before 'start' events.sort(key=lambda x: (x[0], x[1] == 'start')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == 'start': current_overlap += 1 if current_overlap > max_overlap: max_overlap = current_overlap else: current_overlap -= 1 return max_overlap"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the tree self._build(data) def _build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize inner nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): Update the x-th element of the array to y. pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): Compute the sum of elements from index l to index r (inclusive). left += self.n right += self.n + 1 # make right inclusive sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_queries(N: int, Q: int, data: List[int], queries: List[str]) -> List[int]: Process Q queries on an array of N integers. Args: N (int): the size of the array. Q (int): the number of queries. data (List[int]): the array of integers. queries (List[str]): the list of queries. Returns: List[int]: the result of sum queries. result = [] return result # Example usage: if __name__ == \\"__main__\\": N = 5 Q = 4 data = [1, 2, 3, 4, 5] queries = [ \\"sum 1 3\\", \\"update 2 6\\", \\"sum 2 4\\", \\"sum 0 4\\" ] print(process_queries(N, Q, data, queries)) # Outputs: [9, 15, 18] from solution import process_queries def test_example_case(): N = 5 Q = 4 data = [1, 2, 3, 4, 5] queries = [\\"sum 1 3\\", \\"update 2 6\\", \\"sum 2 4\\", \\"sum 0 4\\"] expected_output = [9, 15, 18] assert process_queries(N, Q, data, queries) == expected_output def test_single_element(): N = 1 Q = 2 data = [10] queries = [\\"sum 0 0\\", \\"update 0 20\\", \\"sum 0 0\\"] expected_output = [10, 20] assert process_queries(N, Q, data, queries) == expected_output def test_all_elements_update_then_sum(): N = 3 Q = 4 data = [5, 5, 5] queries = [\\"update 0 2\\", \\"update 1 3\\", \\"update 2 4\\", \\"sum 0 2\\"] expected_output = [9] assert process_queries(N, Q, data, queries) == expected_output def test_sum_full_range(): N = 4 Q = 2 data = [4, 2, 7, 3] queries = [\\"sum 0 3\\", \\"update 1 5\\", \\"sum 0 3\\"] expected_output = [16, 19] assert process_queries(N, Q, data, queries) == expected_output","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the tree self._build(data) def _build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize inner nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): left += self.n right += self.n + 1 # make right inclusive sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_queries(N, Q, data, queries): seg_tree = SegmentTree(data) result = [] for query in queries: parts = query.split() if parts[0] == 'update': x = int(parts[1]) y = int(parts[2]) seg_tree.update(x, y) elif parts[0] == 'sum': l = int(parts[1]) r = int(parts[2]) result.append(seg_tree.range_sum(l, r)) return result # Example usage: N = 5 Q = 4 data = [1, 2, 3, 4, 5] queries = [ \\"sum 1 3\\", \\"update 2 6\\", \\"sum 2 4\\", \\"sum 0 4\\" ] print(process_queries(N, Q, data, queries)) # Outputs: [9, 15, 18]"},{"question":"def can_split(nums, n, k, max_sum): Helper function to check if the array can be split into k or fewer subarrays with maximum sum max_sum. pass def minimize_max_sum(n, k, nums): Minimize the maximum sum among the k non-empty contiguous subarrays. Args: n: int - The size of the array. k: int - The number of subarrays. nums: List[int] - The elements of the array. Returns: int: The minimized maximum sum among the k subarrays. >>> minimize_max_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> minimize_max_sum(3, 1, [1, 2, 3]) 6 >>> minimize_max_sum(3, 3, [1, 2, 3]) 3 pass def process_input(T, test_cases): Process multiple test cases. Args: T: int - The number of test cases. test_cases: List[Tuple[Tuple[int, int], List[int]]] - The test cases where each test case consists of a tuple containing two integers (n, k) and a list of integers. Returns: List[int]: A list of results for each test case. >>> process_input(2, [((5, 2), [1, 2, 3, 4, 5]), ((3, 1), [1, 2, 3])]) [9, 6] >>> process_input(1, [((3, 3), [1, 2, 3])]) [3] pass","solution":"def can_split(nums, n, k, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True def minimize_max_sum(n, k, nums): left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_split(nums, n, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result def process_input(T, test_cases): results = [] for i in range(T): n, k = test_cases[i][0] nums = test_cases[i][1] result = minimize_max_sum(n, k, nums) results.append(result) return results"},{"question":"def calculate_final_difficulty(n: int, stages: List[Tuple[int, int]]) -> int: Calculate the final difficulty of levels after applying n stages. >>> calculate_final_difficulty(3, [(1, 3), (2, 2), (1, 5)]) 13 >>> calculate_final_difficulty(2, [(1, 3), (2, 2)]) 8 from typing import List, Tuple def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) stages = [] index = 1 for i in range(n): type = int(data[index]) value = int(data[index+1]) stages.append((type, value)) index += 2 print(calculate_final_difficulty(n, stages)) if __name__ == \\"__main__\\": main()","solution":"def calculate_final_difficulty(n, stages): difficulty = 1 for stage in stages: if stage[0] == 1: difficulty += stage[1] elif stage[0] == 2: difficulty *= stage[1] return difficulty"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"level\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A big Cat\\") False >>> can_form_palindrome(\\"wow!!\\") True >>> can_form_palindrome(\\"No lemon, No melon\\") True >>> can_form_palindrome(\\"Was it a car or a cat I saw?\\") True >>> can_form_palindrome(\\"\\") True # Empty string, trivially a palindrome >>> can_form_palindrome(\\"a\\") True # Single character, trivially a palindrome >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aabbccd\\") True >>> can_form_palindrome(\\"AaBbCcDd\\") True >>> can_form_palindrome(\\"abcd\\") False","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): the input string Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False # Filter out non-alphabetic characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalpha()] # Count the occurrences of each character char_count = {} for char in filtered_chars: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count the number of characters that have an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # At most one character with an odd count is allowed return odd_count <= 1"},{"question":"def reverse_list(n: int, elements: List[int]) -> List[int]: Reverse a list of n integers. >>> reverse_list(5, [1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_list(4, [-1, 0, 2, -3]) [-3, 2, 0, -1]","solution":"def reverse_list(n, elements): Reverses the given list of n elements. :param n: Integer, number of elements in the list. :param elements: List of integers to be reversed. :return: List of integers in reversed order. return elements[::-1]"},{"question":"def minimize_maximum_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the integer X that minimizes the maximum difference between X and any element of the array. Args: - T: int, number of test cases - test_cases: list of tuples (N, arr), where N is the size of the array and arr is the list of integers Returns: - List of integers, each indicating the minimum possible value of the maximum difference for each test case >>> minimize_maximum_difference(2, [(5, [1, 5, 9, 12, 15]), (3, [4, 6, 7])]) # [9, 6] >>> minimize_maximum_difference(1, [(4, [1, 3, 7, 9])]) # [5] >>> minimize_maximum_difference(1, [(5, [1, 3, 7, 9, 11])]) # [7]","solution":"def minimize_maximum_difference(T, test_cases): Finds the integer X that minimizes the maximum difference between X and any element of the array. Args: - T: int, number of test cases - test_cases: list of tuples (N, arr), where N is the size of the array and arr is the list of integers Returns: - List of integers, each indicating the minimum possible value of the maximum difference for each test case results = [] for N, arr in test_cases: arr.sort() median_index = N // 2 if N % 2 == 0: # For even length arrays, choose the middle value for minimizing max difference best_X = (arr[median_index - 1] + arr[median_index]) // 2 else: best_X = arr[median_index] results.append(best_X) return results"},{"question":"def calculate_max_difference(n: int, B: list, queries: list) -> list: Calculates the maximum difference in the number of issues reported for given ranges. Parameters: n (int): Number of projects. B (list of int): List of number of issues reported for each project. queries (list of tuples): List of queries, where each query is a tuple (L, R). Returns: list of int: List of maximum differences for each query. Example: >>> calculate_max_difference(6, [5, 3, 8, 6, 7, 2], [(1, 6), (2, 4), (3, 5), (1, 3)]) [6, 5, 2, 5] >>> calculate_max_difference(1, [4], [(1, 1)]) [0] >>> calculate_max_difference(5, [7, 7, 7, 7, 7], [(1, 5), (1, 3), (2, 4)]) [0, 0, 0] >>> calculate_max_difference(7, [1, 3, 5, 7, 9, 11, 13], [(1, 7), (2, 5)]) [12, 6] >>> calculate_max_difference(5, [1, 2, 3, 4, 1000000], [(1, 5), (3, 5), (4, 5)]) [999999, 999997, 999996] >>> calculate_max_difference(10, [9, 2, 5, 8, 1, 4, 7, 3, 6, 0], [(1, 10), (5, 10), (3, 6), (2, 5), (8, 10)]) [9, 7, 7, 7, 6]","solution":"def calculate_max_difference(n, B, queries): Calculates the maximum difference in the number of issues reported for given ranges. Parameters: n (int): Number of projects. B (list of int): List of number of issues reported for each project. queries (list of tuples): List of queries, where each query is a tuple (L, R). Returns: list of int: List of maximum differences for each query. differences = [] for L, R in queries: max_issues = max(B[L-1:R]) min_issues = min(B[L-1:R]) differences.append(max_issues - min_issues) return differences"},{"question":"from collections import defaultdict, deque def num_reachable_nodes(n: int, m: int, edges: List[Tuple[int, int]], start: int) -> int: Determine the number of nodes in the graph that are reachable from a given starting node. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): The edges in the graph. start (int): The starting node. Returns: int: The number of nodes that are reachable from the starting node. Examples: >>> num_reachable_nodes(6, 7, [(1, 2), (2, 3), (3, 4), (3, 5), (2, 6), (6, 5), (5, 4)], 1) 6 >>> num_reachable_nodes(1, 0, [], 1) 1 >>> num_reachable_nodes(4, 2, [(1, 2), (3, 4)], 1) 2 >>> num_reachable_nodes(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1) 4 >>> num_reachable_nodes(3, 2, [(1, 2), (1, 3)], 2) 1 pass","solution":"from collections import defaultdict, deque def num_reachable_nodes(n, m, edges, start): # Building the adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Using BFS to find all reachable nodes from the starting node visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited)"},{"question":"def remove_small_strings(string_list: List[str], n: int) -> List[str]: Returns a new list containing only the strings from the original list that have a length greater than n. >>> remove_small_strings([\\"apple\\", \\"pear\\", \\"banana\\", \\"kiwi\\", \\"strawberry\\"], 5) [\\"banana\\", \\"strawberry\\"] >>> remove_small_strings([\\"hello\\", \\"world\\", \\"sun\\", \\"moon\\", \\"stars\\"], 3) [\\"hello\\", \\"world\\", \\"moon\\", \\"stars\\"] >>> remove_small_strings([\\"one\\", \\"three\\", \\"seven\\", \\"nine\\"], 4) [\\"three\\", \\"seven\\"] >>> remove_small_strings([\\"short\\", \\"tiny\\"], 5) [] >>> remove_small_strings([], 3) [] >>> remove_small_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"], 3) [\\"abcd\\", \\"abcde\\"] >>> remove_small_strings([\\"negative\\", \\"length\\", \\"test\\"], -1) [\\"negative\\", \\"length\\", \\"test\\"]","solution":"def remove_small_strings(string_list, n): Returns a new list containing only the strings from the original list that have a length greater than n. :param string_list: List of strings :param n: Integer, the length threshold :return: List of strings with length greater than n return [s for s in string_list if len(s) > n]"},{"question":"def can_divide_with_max_time(time, N, K, max_time): Helper function to decide if it is possible to divide the segments such that no runner has to cover more than max_time. pass def minimize_max_time(T, test_cases): Determine the minimal maximum segment time that any runner will need to cover if the workload is distributed optimally. pass def process_input(input_data): Process input data for the relay race problem. pass def main(input_data): T, test_cases = process_input(input_data) results = minimize_max_time(T, test_cases) for result in results: print(result) # Sample usage input_data = '''2 5 2 1 2 3 4 5 4 3 2 1 4 2''' main(input_data) from solution import minimize_max_time, process_input def test_minimize_max_time(): # Test Case 1 input_data = '''2 5 2 1 2 3 4 5 4 3 2 1 4 2''' T, test_cases = process_input(input_data) results = minimize_max_time(T, test_cases) assert results == [9, 4] # Test Case 2 input_data = '''1 8 4 10 10 10 10 10 10 10 10''' T, test_cases = process_input(input_data) results = minimize_max_time(T, test_cases) assert results == [20] # Test Case 3 input_data = '''1 3 1 1 2 3''' T, test_cases = process_input(input_data) results = minimize_max_time(T, test_cases) assert results == [6] def test_process_input(): input_data = '''2 5 2 1 2 3 4 5 4 3 2 1 4 2''' T, test_cases = process_input(input_data) assert T == 2 assert test_cases == [((5, 2), [1, 2, 3, 4, 5]), ((4, 3), [2, 1, 4, 2])]","solution":"def can_divide_with_max_time(time, N, K, max_time): Helper function to decide if it is possible to divide the segments such that no runner has to cover more than max_time. current_sum = 0 required_runners = 1 for t in time: if current_sum + t > max_time: required_runners += 1 current_sum = t if required_runners > K: return False else: current_sum += t return True def minimize_max_time(T, test_cases): results = [] for case in test_cases: N, K = case[0] time = case[1] left = max(time) # Minimum possible value for max_time right = sum(time) # Maximum possible value for max_time while left < right: mid = (left + right) // 2 if can_divide_with_max_time(time, N, K, mid): right = mid else: left = mid + 1 results.append(left) return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, K = map(int, lines[index].split()) time = list(map(int, lines[index + 1].split())) test_cases.append(((N, K), time)) index += 2 return T, test_cases def main(input_data): T, test_cases = process_input(input_data) results = minimize_max_time(T, test_cases) for result in results: print(result) # Sample usage input_data = '''2 5 2 1 2 3 4 5 4 3 2 1 4 2''' main(input_data)"},{"question":"def max_sum_alice_can_achieve(N, A): Determine the maximum sum Alice can achieve by the end of the game with an array of N integers. Each player tries to maximize the sum of their picked elements. Both players play optimally. Alice always goes first. >>> max_sum_alice_can_achieve(4, [4, 7, 2, 9]) 16 >>> max_sum_alice_can_achieve(1, [5]) 5 >>> max_sum_alice_can_achieve(2, [1, 100]) 100 >>> max_sum_alice_can_achieve(3, [10, 10, 10]) 20 >>> max_sum_alice_can_achieve(6, [1, 2, 3, 4, 5, 6]) 12","solution":"def max_sum_alice_can_achieve(N, A): # Dynamic programming approach to solve the game def dp(i, j): if i > j: return 0 if memo[i][j] is not None: return memo[i][j] # Alice picks the element from the left end pick_left = A[i] + min(dp(i + 2, j), dp(i + 1, j - 1)) # Alice picks the element from the right end pick_right = A[j] + min(dp(i + 1, j - 1), dp(i, j - 2)) memo[i][j] = max(pick_left, pick_right) return memo[i][j] memo = [[None] * N for _ in range(N)] return dp(0, N - 1) # Example usage N = 4 A = [4, 7, 2, 9] print(max_sum_alice_can_achieve(N, A)) # Should output 16"},{"question":"def custom_sort(numbers): Sorts the provided list of numbers in ascending order, but moves all the negative numbers to the end. >>> custom_sort([3, -2, 5, -1, 7, 4, -3]) [3, 4, 5, 7, -1, -2, -3] >>> custom_sort([5, 2, 7, 3]) [2, 3, 5, 7] >>> custom_sort([-1, -5, -3, -2]) [-1, -2, -3, -5] >>> custom_sort([3, -2, 3, 5, -2, -1]) [3, 3, 5, -1, -2, -2] >>> custom_sort([1]) [1] >>> custom_sort([-1]) [-1] >>> custom_sort([0, 3, -1, 0, -3, 5]) [0, 0, 3, 5, -1, -3] >>> custom_sort([]) []","solution":"def custom_sort(numbers): Sorts the provided list of numbers in ascending order, but moves all the negative numbers to the end. positive_numbers = [num for num in numbers if num >= 0] negative_numbers = [num for num in numbers if num < 0] sorted_positive_numbers = sorted(positive_numbers) sorted_negative_numbers = sorted(negative_numbers, reverse=True) return sorted_positive_numbers + sorted_negative_numbers"},{"question":"def num_baggage_groups(n: int, tags: List[str]) -> int: Determines the number of distinct groups of baggage tags based on the criteria. :param n: Number of baggage tags. :param tags: List of baggage tag strings. :return: Number of distinct groups of baggage tags. >>> num_baggage_groups(5, [\\"ABC\\", \\"BCA\\", \\"CAB\\", \\"AB\\", \\"BA\\"]) == 2 >>> num_baggage_groups(1, [\\"A\\"]) == 1 >>> num_baggage_groups(3, [\\"ABC\\", \\"ABC\\", \\"ABC\\"]) == 1 >>> num_baggage_groups(3, [\\"ABC\\", \\"DEF\\", \\"GHI\\"]) == 3","solution":"def num_baggage_groups(n, tags): Determines the number of distinct groups of baggage tags based on the criteria. :param n: Number of baggage tags. :param tags: List of baggage tag strings. :return: Number of distinct groups of baggage tags. def normalize(tag): rotated_versions = [tag[i:] + tag[:i] for i in range(len(tag))] reversed_tag = tag[::-1] rotated_reversed_versions = [reversed_tag[i:] + reversed_tag[:i] for i in range(len(tag))] all_versions = rotated_versions + rotated_reversed_versions return min(all_versions) distinct_groups = set(normalize(tag) for tag in tags) return len(distinct_groups)"},{"question":"def count_earthquakes_leq_median(earthquake_data): Returns a list of counts of earthquakes with magnitude less than or equal to the median for each dataset. earthquake_data: A list of tuples where each tuple contains an integer n and a list of n earthquake magnitudes. pass def process_input(input_data): Processes the input data and returns the required results as specified in the prompt. input_data: A string containing multiple datasets, each in the following format n m1 m2 ... mn where n is the number of recorded earthquakes and mi are the magnitudes of the earthquakes. Returns a list of counts of earthquakes with magnitude less than or equal to the median for each dataset. Example: >>> input_data = \\"5n2.1 2.3 3.6 4.1 4.8n6n1.0 2.5 3.0 3.5 4.0 5.0n4n2.9 3.1 2.8 3.6n0\\" >>> process_input(input_data) [3, 3, 2] pass def test_example_case(): input_data = 5 2.1 2.3 3.6 4.1 4.8 6 1.0 2.5 3.0 3.5 4.0 5.0 4 2.9 3.1 2.8 3.6 0 expected_output = [3, 3, 2] assert process_input(input_data) == expected_output def test_single_earthquake(): input_data = 1 3.2 0 expected_output = [1] assert process_input(input_data) == expected_output def test_even_earthquakes(): input_data = 4 2.0 3.0 3.0 4.0 0 expected_output = [3] assert process_input(input_data) == expected_output def test_all_same_magnitudes(): input_data = 4 3.0 3.0 3.0 3.0 0 expected_output = [4] assert process_input(input_data) == expected_output def test_large_set(): input_data = 10 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 0 expected_output = [5] assert process_input(input_data) == expected_output","solution":"def count_earthquakes_leq_median(earthquake_data): Returns a list of counts of earthquakes with magnitude less than or equal to the median for each dataset. earthquake_data: A list of tuples where each tuple contains an integer n and a list of n earthquake magnitudes. results = [] for n, magnitudes in earthquake_data: sorted_magnitudes = sorted(magnitudes) if n % 2 == 1: median = sorted_magnitudes[n // 2] else: median = (sorted_magnitudes[(n // 2) - 1] + sorted_magnitudes[n // 2]) / 2 count = sum(magnitude <= median for magnitude in magnitudes) results.append(count) return results def process_input(input_data): lines = iter(input_data.split('n')) earthquake_data = [] while True: n = int(next(lines)) if n == 0: break magnitudes = list(map(float, next(lines).split())) earthquake_data.append((n, magnitudes)) return count_earthquakes_leq_median(earthquake_data)"},{"question":"def max_possible_value(arr): Returns the maximum possible value of the greatest element in the array after performing any number of operations. >>> max_possible_value([10, 20, 30, 40]) 10 >>> max_possible_value([5, 10, 15]) 5 >>> max_possible_value([1, 2, 3, 4, 5]) 1 >>> max_possible_value([100, 90, 80, 70, 60]) 60 >>> max_possible_value([7, 7, 7, 7]) 7 >>> max_possible_value([]) 0 def max_value_for_test_cases(test_cases): Computes the maximum possible values for each test case. >>> test_cases = [(4, [10, 20, 30, 40]), (3, [5, 10, 15]), (2, [1, 2]), (5, [50, 20, 30, 40, 10])] >>> max_value_for_test_cases(test_cases) [10, 5, 1, 10]","solution":"def max_possible_value(arr): Returns the maximum possible value of the greatest element in the array after performing any number of operations. if len(arr) == 0: return 0 return min(arr) def max_value_for_test_cases(test_cases): results = [] for test_case in test_cases: M, arr = test_case max_value = max_possible_value(arr) results.append(max_value) return results"},{"question":"def min_moves_to_rearrange(n: int, initial: List[int], target: List[int]) -> int: Returns the minimum number of moves required to transform the initial arrangement of blocks into the target arrangement by reversing contiguous subarrays. Args: n (int): The number of blocks. initial (List[int]): The initial arrangement of the blocks. target (List[int]): The target arrangement of the blocks. Returns: int: The minimum number of moves required. Examples: >>> min_moves_to_rearrange(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 1 >>> min_moves_to_rearrange(4, [1, 3, 2, 4], [1, 2, 3, 4]) 1 >>> min_moves_to_rearrange(7, [1, 2, 3, 4, 5, 6, 7], [3, 2, 1, 7, 6, 5, 4]) 2","solution":"def min_moves_to_rearrange(n, initial, target): Returns the minimum number of moves to transform the initial arrangement into the target arrangement. # The logic here checks for contiguous segments already matching in target start = 0 while start < n and initial[start] == target[start]: start += 1 end = n - 1 while end >= 0 and initial[end] == target[end]: end -= 1 if start > end: return 0 # Check if reversing the segment from start to end in initial matches the target if initial[start:end+1][::-1] == target[start:end+1]: return 1 return 2"},{"question":"def longest_subarray_with_limit(arr: List[int], limit: int) -> int: Determines the length of the longest subarray in which the absolute difference between the maximum and minimum values is less than or equal to the given limit. >>> longest_subarray_with_limit([8, 2, 4, 7, 10, 6, 5], 5) 4 >>> longest_subarray_with_limit([10], 0) 1 >>> longest_subarray_with_limit([1, 2, 3, 4, 5], 10) 5 >>> longest_subarray_with_limit([10, 20, 30, 40, 50], 0) 1 >>> longest_subarray_with_limit([10, 10, 10, 10, 10, 10, 10, 10, 10, 10], 0) 10 >>> longest_subarray_with_limit([10, 1, 2, 3, 4, 5, 6, 10], 4) 5 pass","solution":"def longest_subarray_with_limit(arr, limit): Determines the length of the longest subarray in which the absolute difference between the maximum and minimum values is less than or equal to the given limit. from collections import deque max_deque, min_deque = deque(), deque() left = 0 longest = 0 for right in range(len(arr)): while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > limit: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() longest = max(longest, right - left + 1) return longest # Test cases def longest_subarray_with_limit_from_input(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) arr = list(map(int, input_lines[1].split())) limit = int(input_lines[2]) return longest_subarray_with_limit(arr, limit)"},{"question":"def can_make_equal(s1: str, s2: str) -> str: Determines if two strings can be made equal by swapping any two characters in each. Returns \\"YES\\" if possible, otherwise \\"NO\\". >>> can_make_equal(\\"abc\\", \\"bca\\") == \\"YES\\" >>> can_make_equal(\\"aabbcc\\", \\"abcabc\\") == \\"YES\\" >>> can_make_equal(\\"abcd\\", \\"abdc\\") == \\"NO\\" def test_example1(): assert can_make_equal(\\"abc\\", \\"bca\\") == \\"YES\\" def test_example2(): assert can_make_equal(\\"aabbcc\\", \\"abcabc\\") == \\"YES\\" def test_example3(): assert can_make_equal(\\"abcd\\", \\"abdc\\") == \\"YES\\" def test_example4(): assert can_make_equal(\\"a\\", \\"a\\") == \\"YES\\" def test_example5(): assert can_make_equal(\\"abcd\\", \\"abcf\\") == \\"NO\\" def test_example6(): assert can_make_equal(\\"xyz\\", \\"zyx\\") == \\"YES\\" def test_example7(): assert can_make_equal(\\"abcdefgh\\", \\"hgfedcba\\") == \\"YES\\" def test_example8(): assert can_make_equal(\\"abc\\", \\"abcd\\") == \\"NO\\" def test_example9(): assert can_make_equal(\\"aaaa\\", \\"aaab\\") == \\"NO\\" def test_example10(): assert can_make_equal(\\"zzzz\\", \\"zzzz\\") == \\"YES\\"","solution":"def can_make_equal(s1, s2): Determines if two strings can be made equal by swapping any two characters in each. Returns \\"YES\\" if possible, otherwise \\"NO\\". if sorted(s1) == sorted(s2): return \\"YES\\" else: return \\"NO\\""},{"question":"def days_between_dates(date1, date2): Calculate the number of days between two dates in a unique calendar system where every month has exactly 30 days. Each date is given in the form \\"Day-Month-Year\\". Args: date1 (str): The first date in \\"Day-Month-Year\\" format. date2 (str): The second date in \\"Day-Month-Year\\" format. Returns: int: The number of days between the two dates. Examples: >>> days_between_dates('1-january-1', '30-january-1') 29 >>> days_between_dates('1-january-1', '1-february-1') 30 def process_input(T, test_cases): Process the input for multiple test cases and return the results. Args: T (int): The number of test cases. test_cases (List[str]): A list of test cases where each test case contains two space-separated dates. Returns: List[int]: A list of results for each test case indicating the number of days between the provided dates. Examples: >>> process_input(2, ['1-january-1 30-january-1', '1-january-1 1-february-1']) [29, 30]","solution":"def days_between_dates(date1, date2): def date_to_days(date): day, month, year = date.split('-') day = int(day) year = int(year) months_to_days = { 'january': 0, 'february': 30, 'march': 60, 'april': 90, 'may': 120, 'june': 150, 'july': 180, 'august': 210, 'september': 240, 'october': 270, 'november': 300, 'december': 330 } return day + months_to_days[month] + (year - 1) * 360 days1 = date_to_days(date1) days2 = date_to_days(date2) return abs(days1 - days2) def process_input(T, test_cases): results = [] for i in range(T): date1, date2 = test_cases[i].split() results.append(days_between_dates(date1, date2)) return results"},{"question":"def knapsack(n, W, stones): Determine the maximum total value of stones Mark can carry. :param n: Number of stones :param W: Maximum weight Mark can carry :param stones: List of tuples [(wi, vi), ...] where wi is weight and vi is value of the i-th stone :return: Maximum total value of the stones Mark can carry Examples: >>> knapsack(4, 5, [(2, 3), (1, 2), (3, 4), (2, 2)]) 7 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220","solution":"def knapsack(n, W, stones): Determine the maximum total value of stones Mark can carry. :param n: Number of stones :param W: Maximum weight Mark can carry :param stones: List of tuples [(wi, vi), ...] where wi is weight and vi is value of the i-th stone :return: Maximum total value of the stones Mark can carry dp = [[0 for x in range(W + 1)] for x in range(n + 1)] for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: dp[i][w] = 0 elif stones[i-1][0] <= w: dp[i][w] = max(stones[i-1][1] + dp[i-1][w-stones[i-1][0]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][W] # Example Usage if __name__ == \\"__main__\\": n = 4 W = 5 stones = [(2, 3), (1, 2), (3, 4), (2, 2)] print(knapsack(n, W, stones)) # Output: 7"},{"question":"def can_split_array(a: List[int]) -> str: Determines if it's possible to split array a into two non-empty subsequences with equal sum. Args: a (List[int]): The array of integers. Returns: str: \\"YES\\" if the split is possible, otherwise \\"NO\\". >>> can_split_array([1, 2, 3, 4]) == \\"YES\\" >>> can_split_array([1, 1, 1]) == \\"NO\\" pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases for the can_split_array function. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the length of array and the array itself. Returns: List[str]: List of results for each test case, \\"YES\\" or \\"NO\\". >>> test_cases = [(4, [1, 2, 3, 4]), (3, [1, 1, 1]), (5, [1, 2, 3, 6]), (6, [1, -1, 2, -2, 3, -3])] >>> process_test_cases(4, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass # Unit Tests def test_can_split_array(): assert can_split_array([1, 2, 3, 4]) == \\"YES\\" assert can_split_array([1, 1, 1]) == \\"NO\\" assert can_split_array([1, 2, 3, 6]) == \\"YES\\" assert can_split_array([1, -1, 2, -2, 3, -3]) == \\"YES\\" assert can_split_array([2, 2, 2, 2]) == \\"YES\\" assert can_split_array([1, 5, 11, 5]) == \\"YES\\" assert can_split_array([1, 2, 5]) == \\"NO\\" assert can_split_array([10, 10]) == \\"YES\\" assert can_split_array([-5, -5, 10]) == \\"YES\\" def test_process_test_cases(): test_cases = [ (4, [1, 2, 3, 4]), (3, [1, 1, 1]), (5, [1, 2, 3, 6]), (6, [1, -1, 2, -2, 3, -3]) ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert process_test_cases(4, test_cases) == expected_output test_cases = [ (4, [2, 2, 2, 2]), (4, [1, 5, 11, 5]), (3, [1, 2, 5]), (2, [10, 10]), (3, [-5, -5, 10]) ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert process_test_cases(5, test_cases) == expected_output","solution":"def can_split_array(a): Determines if it's possible to split array a into two non-empty subsequences with equal sum. total_sum = sum(a) # If total sum is odd, it's not possible to split it into two equal parts if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 n = len(a) # Initialize a set to store possible sums we can form dp = set() dp.add(0) for num in a: # Iterate in reverse to avoid using the same element multiple times for sub_sum in list(dp): if sub_sum + num == target_sum: return \\"YES\\" dp.add(sub_sum + num) return \\"NO\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: n, a = case results.append(can_split_array(a)) return results"},{"question":"from typing import List, Tuple, Union def find_task_order(num_tasks: int, task_dependencies: List[Tuple[int, List[int]]]) -> Union[List[int], str]: Determine the order of tasks based on their dependencies. :param num_tasks: Integer, number of tasks. :param task_dependencies: List of tuples, each containing task id and the list of its dependencies. :return: List of tasks in possible order, or \\"IMPOSSIBLE\\" if no valid ordering exists. Example: >>> find_task_order(4, [(1, [2]), (2, []), (3, [2]), (4, [3])]) [2, 3, 1, 4] >>> find_task_order(3, [(1, [2, 3]), (2, [3]), (3, [1])]) \\"IMPOSSIBLE\\"","solution":"from collections import defaultdict, deque def find_task_order(num_tasks, task_dependencies): Determine the order of tasks based on their dependencies. :param num_tasks: Integer, number of tasks. :param task_dependencies: List of tuples, each containing task id and the list of its dependencies. :return: List of tasks in possible order, or \\"IMPOSSIBLE\\" if no valid ordering exists. graph = defaultdict(list) in_degree = {i: 0 for i in range(1, num_tasks + 1)} # Build the graph and in-degree count for task_id, dependencies in task_dependencies: for dep in dependencies: graph[dep].append(task_id) in_degree[task_id] += 1 # Find all nodes with zero in-degree zero_in_degree = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while zero_in_degree: current = zero_in_degree.popleft() topological_order.append(current) # Decrease the in-degree of each neighbor for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree.append(neighbor) if len(topological_order) == num_tasks: return topological_order else: return \\"IMPOSSIBLE\\""},{"question":"def max_coins(grid: List[List[int]]) -> int: Returns the maximum number of coins either player can collect if they play optimally. >>> max_coins([ ... [1, 0, 0], ... [0, 2, 0], ... [3, 0, 1] ... ]) == 7 >>> max_coins([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> max_coins([ ... [5] ... ]) == 5 >>> max_coins([ ... [1, 2, 3, 4, 5] ... ]) == 15 >>> max_coins([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) == 15 >>> max_coins([ ... [10000, 10000], ... [10000, 10000] ... ]) == 40000","solution":"def max_coins(grid): Returns the maximum number of coins either player can collect if they play optimally. return sum(sum(row) for row in grid)"},{"question":"def listPrimes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. >>> listPrimes(10) [2, 3, 5, 7] >>> listPrimes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def listPrimes(n): Returns a list of all prime numbers less than or equal to n. if n < 2: return [] primes = [] for num in range(2, n + 1): is_prime = True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"from typing import List, Tuple def min_moves(n: int, m: int, k: int, test_cases: List[Tuple[int, int, int, int, List[str]]]) -> List[int]: Determines the minimum number of moves Jack needs to reach the destination for each test case. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of test cases. test_cases (List[Tuple[int, int, int, int, List[str]]]): List of test cases. Each test case includes the starting row (sr), starting column (sc), destination row (dr), destination column (dc), and the grid. Returns: List[int]: List of results for each test case. The result is the minimum number of moves to reach the destination, or -1 if it is not possible. Example: >>> min_moves(4, 4, 2, [ ... (1, 1, 4, 4, [ ... \\".#..\\", ... \\"..\\", ... \\"..#.\\", ... \\"...#\\" ... ]), ... (1, 1, 2, 2, [ ... \\"..\\", ... \\"..\\", ... \\"..\\", ... \\"....\\" ... ]), ... ]) [-1, 2]","solution":"from collections import deque def min_moves(n, m, k, test_cases): Determines the minimum number of moves Jack needs to reach the destination for each test case. Returns the results as a list. def is_valid(x, y, grid, visited): if 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and (x, y) not in visited: return True return False def bfs(sr, sc, dr, dc, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sr, sc, 0)]) # (current_row, current_col, current_distance) visited = set() visited.add((sr, sc)) while queue: x, y, dist = queue.popleft() if (x, y) == (dr, dc): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, grid, visited): visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 result = [] for case in test_cases: sr, sc, dr, dc, grid = case res = bfs(sr - 1, sc - 1, dr - 1, dc - 1, grid) result.append(res) return result"},{"question":"def is_happy_number(n): Determines if the given number is a Happy Number and returns the sequence. Args: n (int): The number to check. Returns: tuple: A tuple containing a string \\"Happy\\" or \\"Unhappy\\" and a list of numbers representing the sequence. Examples: >>> is_happy_number(19) (\\"Happy\\", [19, 82, 68, 100, 1]) >>> is_happy_number(4) (\\"Unhappy\\", [4, 16, 37, 58, 89, 145, 42, 20, 4]) pass","solution":"def is_happy_number(n): Determines if the given number is a Happy Number and returns the sequence. Args: n (int): The number to check. Returns: tuple: A tuple containing a string \\"Happy\\" or \\"Unhappy\\" and a list of numbers representing the sequence. def get_next_number(num): return sum(int(digit) ** 2 for digit in str(num)) seen_numbers = set() sequence = [] while n != 1 and n not in seen_numbers: seen_numbers.add(n) sequence.append(n) n = get_next_number(n) sequence.append(n) if n == 1: return \\"Happy\\", sequence else: return \\"Unhappy\\", sequence"},{"question":"def min_operations(S: str, T: str) -> int: Determines the minimum number of operations required to convert string S into string T. The operations allowed are insert a character, remove a character, or replace a character. >>> min_operations(\\"abc\\", \\"yabd\\") == 2 >>> min_operations(\\"intention\\", \\"execution\\") == 5 >>> min_operations(\\"kitten\\", \\"sitting\\") == 3","solution":"def min_operations(S, T): Determines the minimum number of operations required to convert string S into string T. The operations allowed are insert a character, remove a character, or replace a character. m, n = len(S), len(T) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # S is empty, all characters of T need to be inserted elif j == 0: dp[i][j] = i # T is empty, all characters of S need to be removed elif S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # remove operation dp[i][j - 1], # insert operation dp[i - 1][j - 1]) # replace operation return dp[m][n]"},{"question":"from typing import List, Tuple def josephus(n: int, k: int) -> int: Given the number of players n and the step rate k, this function returns the position of the winning player. >>> josephus(5, 2) 3 >>> josephus(7, 3) 4 >>> josephus(10, 4) 5 def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases, this function returns a list of results corresponding to the winner's position for each test case. >>> solve([(5, 2), (7, 3), (10, 4)]) [3, 4, 5] def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int]]]: Parses the input string according to the format specified in the task. Returns a tuple (T, test_cases), where T is the number of test cases and test_cases is a list of tuples (N, K). >>> parse_input(\\"3n5 2n7 3n10 4\\") (3, [(5, 2), (7, 3), (10, 4)]) def format_output(results: List[int]) -> str: Formats the output results into a single string with each result on a new line. >>> format_output([3, 4, 5]) \\"3n4n5\\"","solution":"def josephus(n, k): Given the number of players n and the step rate k, this function returns the position of the winning player. if n == 1: return 1 else: return (josephus(n - 1, k) + k - 1) % n + 1 def solve(test_cases): Given a list of test cases, this function returns a list of results corresponding to the winner's position for each test case. results = [] for n, k in test_cases: results.append(josephus(n, k)) return results def parse_input(input_string): Parses the input string according to the format specified in the task. Returns a tuple (T, test_cases), where T is the number of test cases and test_cases is a list of tuples (N, K). lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:T+1]] return T, test_cases def format_output(results): Formats the output results into a single string with each result on a new line. return 'n'.join(map(str, results))"},{"question":"def analyze_communication_patterns(n: int, messages: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Given a log of messages, where each message record consists of a sender, a receiver, and a message ID, determine for each employee how many unique individuals have sent them messages. Args: n (int): The number of message records. messages (List[Tuple[int, int, int]]): A list of tuples, where each tuple contains three integers: sender ID, receiver ID, and message ID. Returns: List[Tuple[int, int]]: A list of tuples containing the employee ID and the number of unique individuals who have sent them messages. >>> analyze_communication_patterns(5, [(10, 20, 1), (11, 20, 2), (10, 21, 3), (10, 20, 4), (12, 21, 5)]) [(20, 2), (21, 2)] >>> analyze_communication_patterns(1, [(1, 2, 1)]) [(2, 1)] >>> analyze_communication_patterns(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) [(2, 1), (3, 1), (4, 1), (5, 1)] >>> analyze_communication_patterns(0, []) [] >>> analyze_communication_patterns(4, [(1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 2, 4)]) [(2, 1)] >>> analyze_communication_patterns(4, [(1, 2, 1), (2, 2, 2), (3, 2, 3), (4, 2, 4)]) [(2, 4)]","solution":"def analyze_communication_patterns(n, messages): receiver_dict = {} for message in messages: sender, receiver, msg_id = message if receiver not in receiver_dict: receiver_dict[receiver] = set() receiver_dict[receiver].add(sender) result = [] for receiver in sorted(receiver_dict): result.append((receiver, len(receiver_dict[receiver]))) return result"},{"question":"def findIntersection(arr1, arr2): Given two arrays, returns a sorted list of their intersection without duplicates. >>> findIntersection([1, 2, 3, 4, 5], [4, 3, 2, 1, 0]) [1, 2, 3, 4] >>> findIntersection([10, 20, 10, 40], [30, 50, 10, 20]) [10, 20]","solution":"def findIntersection(arr1, arr2): Given two arrays, returns a sorted list of their intersection without duplicates. # Convert the lists to sets to find the intersection set1 = set(arr1) set2 = set(arr2) intersection = set1.intersection(set2) # Return the sorted list of the intersection return sorted(list(intersection))"},{"question":"def buildPyramid(fruits): Given an array of integers 'fruits' representing sweetness levels, returns the largest pyramid possible such that no two adjacent fruits at the same level have the same sweetness level. >>> buildPyramid([3, 3, 1, 1, 2, 2]) [3, 2, 1] >>> buildPyramid([5, 4, 4, 4, 2, 2]) [5, 4, 2] >>> buildPyramid([1, 1, 1, 1]) [1] >>> buildPyramid([3, 2, 1]) [3, 2, 1] >>> buildPyramid([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] >>> buildPyramid([1, 2, 3, 1, 2, 3, 2, 1]) [3, 2, 1]","solution":"def buildPyramid(fruits): Given an array of integers 'fruits' representing sweetness levels, returns the largest pyramid possible such that no two adjacent fruits at the same level have the same sweetness level. # First, sort the fruits array to work with unique sweetness levels. sorted_fruits = sorted(set(fruits), reverse=True) # Initialize the pyramid structure. pyramid = [] for fruit in sorted_fruits: # Check if the current sweetest fruit can be added to the pyramid if len(pyramid) == 0 or pyramid[-1] > fruit: pyramid.append(fruit) return pyramid"},{"question":"def calculate_statistics(scores, K): Calculate the top K scores, bottom K scores, and the average score excluding the top and bottom K scores. Parameters: scores (list of int): List of student scores. K (int): Number of top and bottom scores to exclude. Returns: dict: A dictionary with keys \\"top_K\\", \\"bottom_K\\", and \\"average\\". Examples: >>> calculate_statistics([90, 70, 85, 65, 80, 95, 60, 100, 75], 2) {'top_K': [100, 95], 'bottom_K': [60, 65], 'average': 80.0} >>> calculate_statistics([50, 40, 55, 30, 60, 45, 35, 70, 65], 3) {'top_K': [70, 65, 60], 'bottom_K': [30, 35, 40], 'average': 50.0}","solution":"def calculate_statistics(scores, K): Calculate the top K scores, bottom K scores, and the average score excluding the top and bottom K scores. Parameters: scores (list of int): List of student scores. K (int): Number of top and bottom scores to exclude. Returns: dict: A dictionary with keys \\"top_K\\", \\"bottom_K\\", and \\"average\\". if len(scores) <= 2 * K: return {\\"top_K\\": [], \\"bottom_K\\": [], \\"average\\": 0.0} sorted_scores = sorted(scores) top_K = sorted_scores[-K:][::-1] bottom_K = sorted_scores[:K] remaining_scores = sorted_scores[K:-K] if remaining_scores: average = round(sum(remaining_scores) / len(remaining_scores), 2) else: average = 0.0 return {\\"top_K\\": top_K, \\"bottom_K\\": bottom_K, \\"average\\": average}"},{"question":"def max_water_flow(n, roads): Compute the maximum water flow that can be delivered to each town. >>> n = 5 >>> roads = [ ... (1, 2, 10), ... (1, 3, 5), ... (2, 4, 7), ... (3, 5, 4) ... ] >>> max_water_flow(n, roads) [10, 5, 7, 4] >>> n = 3 >>> roads = [ ... (1, 2, 15), ... (2, 3, 10) ... ] >>> max_water_flow(n, roads) [15, 10] >>> n = 1 >>> roads = [] >>> max_water_flow(n, roads) [] >>> n = 4 >>> roads = [ ... (1, 2, 30), ... (2, 3, 20), ... (3, 4, 10) ... ] >>> max_water_flow(n, roads) [30, 20, 10] >>> n = 7 >>> roads = [ ... (1, 2, 50), ... (1, 3, 40), ... (2, 4, 30), ... (2, 5, 20), ... (3, 6, 25), ... (3, 7, 10) ... ] >>> max_water_flow(n, roads) [50, 40, 30, 20, 25, 10]","solution":"def max_water_flow(n, roads): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v, c in roads: graph[u].append((v, c)) graph[v].append((u, c)) # BFS to find the maximum capacity on the path from capital to every town max_flow = [0] * (n + 1) visited = [False] * (n + 1) visited[1] = True queue = deque([(1, float('inf'))]) # (current_town, min_capacity_so_far) while queue: cur, min_capacity = queue.popleft() for neighbor, capacity in graph[cur]: if not visited[neighbor]: visited[neighbor] = True max_flow[neighbor] = min(min_capacity, capacity) queue.append((neighbor, max_flow[neighbor])) return max_flow[2:] # to only return results from town 2 to n # Example usage: # n = 5 # roads = [ # (1, 2, 10), # (1, 3, 5), # (2, 4, 7), # (3, 5, 4) # ] # print(max_water_flow(n, roads)) # Output: [10, 5, 7, 4]"},{"question":"def num_knight_attacks(position: str) -> int: Determine the number of valid positions from which a knight can attack the given position. The parameter \`position\` is a string representing a valid chessboard position. The function returns an integer representing the number of valid attacking positions. >>> num_knight_attacks(\\"e4\\") 8 >>> num_knight_attacks(\\"a1\\") 2","solution":"def num_knight_attacks(position): Determine the number of valid positions from which a knight can attack the given position. col = ord(position[0]) - ord('a') + 1 row = int(position[1]) # Possible moves for a knight knight_moves = [ (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1) ] # Count valid moves count = 0 for move in knight_moves: new_col = col + move[0] new_row = row + move[1] if 1 <= new_col <= 8 and 1 <= new_row <= 8: count += 1 return count"},{"question":"def longest_increasing_path(N: int, heights: List[int]) -> int: Determines the length of the longest clear path of strictly increasing heights. >>> longest_increasing_path(5, [10, 20, 10, 30, 20]) 3 >>> longest_increasing_path(6, [4, 5, 6, 3, 4, 5]) 3 >>> longest_increasing_path(9, [9, 1, 3, 7, 2, 5, 6, 8, 7]) 5","solution":"def longest_increasing_path(N, heights): Determines the length of the longest clear path of strictly increasing heights. Parameters: N (int): The number of trees. heights (list): A list of heights of the trees. Returns: int: The length of the longest clear path. if N == 0: return 0 l = [heights[0]] for height in heights[1:]: if height > l[-1]: l.append(height) else: # Find the first element in l which is not less than height left, right = 0, len(l) - 1 while left < right: mid = (left + right) // 2 if l[mid] < height: left = mid + 1 else: right = mid l[left] = height return len(l) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) heights = list(map(int, data[1:])) print(longest_increasing_path(N, heights))"},{"question":"import collections def can_reorder_no_adjacent_duplicates(s: str) -> bool: Determines if it is possible to reorder the string s such that no two adjacent characters are the same. Args: s (str): The input string consisting of lowercase English letters. Returns: bool: True if it is possible to reorder the string as described, False otherwise. Examples: >>> can_reorder_no_adjacent_duplicates(\\"aab\\") True >>> can_reorder_no_adjacent_duplicates(\\"aaab\\") False","solution":"import collections def can_reorder_no_adjacent_duplicates(s): Determines if it is possible to reorder the string s such that no two adjacent characters are the same. Args: s (str): The input string consisting of lowercase English letters. Returns: bool: True if it is possible to reorder the string as described, False otherwise. # Count the frequency of each character freq = collections.Counter(s) # Find the maximum frequency max_freq = max(freq.values()) # Determine if the most frequent character can be placed such that no two are adjacent if max_freq > (len(s) + 1) // 2: return False return True"},{"question":"def shortestCommonSupersequence(str1: str, str2: str) -> int: Finds the length of the shortest string that has both str1 and str2 as subsequences. >>> shortestCommonSupersequence(\\"geek\\", \\"eke\\") 5 >>> shortestCommonSupersequence(\\"AGGTAB\\", \\"GXTXAYB\\") 9","solution":"def shortestCommonSupersequence(str1, str2): Finds the length of the shortest string that has both str1 and str2 as subsequences. :param str1: string :param str2: string :return: int m = len(str1) n = len(str2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array using bottom-up method. for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # Length of the shortest common supersequence is calculated by: lcs_length = dp[m][n] scs_length = m + n - lcs_length return scs_length"},{"question":"def unique_employees_for_subtasks(projects): Determine the minimum number of unique employees required to handle all the subtasks for each project. Args: projects (List[int]): A list where each element represents the number of subtasks for a project. Returns: List[int]: A list where each element represents the minimum number of unique employees required for the corresponding project. >>> unique_employees_for_subtasks([12, 7]) == [12, 7] >>> unique_employees_for_subtasks([10, 15, 20]) == [10, 15, 20] >>> unique_employees_for_subtasks([1]) == [1]","solution":"def unique_employees_for_subtasks(projects): This function takes a list of integers where each integer represents the number of subtasks for a project and returns a list of integers where each integer represents the minimum number of unique employees required for the corresponding project. return projects"},{"question":"def total_weight_over_5(weights): Returns the total weight of packages that weigh more than 5 kilograms. :param weights: List of integers representing the weights of the packages. :return: The total weight of the packages that weigh more than 5 kilograms. >> total_weight_over_5([3, 2, 8, 15, 5, 6, 12, 3, 1, 10]) == 51 >> total_weight_over_5([6, 7, 5, 4, 3, 8, 2, 11, 0, 10]) == 42","solution":"def total_weight_over_5(weights): Returns the total weight of packages that weigh more than 5 kilograms. :param weights: List of integers representing the weights of the packages. :return: The total weight of the packages that weigh more than 5 kilograms. return sum(weight for weight in weights if weight > 5)"},{"question":"def process_queries(n, q, initial_values, queries): Process the list of integers based on the given queries and output the results. Parameters: n (int): Number of elements in the list. q (int): Number of queries. initial_values (list of int): The initial values in the list. queries (list of list of int): The queries to process. Returns: list: Result of all sum queries. >>> process_queries(5, 4, [1, 2, 3, 4, 5], [[0, 1, 3, 10], [1, 0, 4], [0, 2, 4, 5], [1, 1, 3]]) [45, 49] >>> process_queries(3, 3, [10, 20, 30], [[0, 0, 2, 5], [1, 0, 1], [0, 1, 1, 10]]) [40] >>> process_queries(4, 3, [5, 10, 15, 20], [[0, 0, 1, 5], [1, 2, 3], [0, 0, 3, 5]]) [35]","solution":"def process_queries(n, q, initial_values, queries): Process the list of integers based on the given queries and output the results. Parameters: n (int): Number of elements in the list. q (int): Number of queries. initial_values (list of int): The initial values in the list. queries (list of list of int): The queries to process. Returns: list: Result of all sum queries. results = [] for query in queries: if query[0] == 0: # Add value to elements from index A to B inclusive _, A, B, V = query for i in range(A, B + 1): initial_values[i] += V elif query[0] == 1: # Sum elements from index A to B inclusive _, A, B = query results.append(sum(initial_values[A:B + 1])) return results"},{"question":"def max_sequence_length(T, test_cases): Determine the maximum length of a sequence of cages with the same type of pets next to each other after performing any number of swaps. Args: T : int : the number of test cases test_cases : list : list of test case data, each test case contains: - N : int : the number of cages - P : str : a string representing the type of pet in each cage - M : int : the number of sections - sections : list : each section is defined by two integers Li and Ri (1  Li  Ri  N) Returns: list : containing the maximum sequence length of the same type of pets for each test case Example: >>> max_sequence_length(2, [{'N': 6, 'P': 'abacca', 'M': 2, 'sections': [(1, 3), (4, 6)]}, {'N': 5, 'P': 'abcab', 'M': 3, 'sections': [(1, 2), (3, 3), (4, 5)]}]) [3, 2] >>> max_sequence_length(1, [{'N': 7, 'P': 'abcdefg', 'M': 1, 'sections': [(1, 7)]}]) [1] pass # Entry function to handle multiple test cases def handle_input(num_cases, raw_test_cases): Helper function to convert raw test case input to structured format pass # Unit Tests def test_max_sequence_length(): raw_test_cases_1 = [ '6', 'abacca', '2', '1 3', '4 6' ] raw_test_cases_2 = [ '5', 'abcab', '3', '1 2', '3 3', '4 5' ] result = handle_input(2, raw_test_cases_1 + raw_test_cases_2) assert result == [3, 2] def test_max_sequence_length_single_case(): raw_test_cases = [ '7', 'abcdefg', '1', '1 7' ] result = handle_input(1, raw_test_cases) assert result == [1] def test_max_sequence_length_multiple_types(): raw_test_cases = [ '8', 'aabbccdd', '2', '1 4', '5 8' ] result = handle_input(1, raw_test_cases) assert result == [2] def test_max_sequence_length_same_pet(): raw_test_cases = [ '5', 'aaaaa', '1', '1 5' ] result = handle_input(1, raw_test_cases) assert result == [5] def test_max_sequence_length_spread_out(): raw_test_cases = [ '10', 'ababababaa', '2', '1 5', '6 10' ] result = handle_input(1, raw_test_cases) assert result == [6]","solution":"def max_sequence_length(T, test_cases): results = [] for case in test_cases: N = case['N'] P = case['P'] M = case['M'] sections = case['sections'] pet_counts = {} # Count occurrences of each pet type in each section for l, r in sections: for i in range(l - 1, r): pet_type = P[i] if pet_type not in pet_counts: pet_counts[pet_type] = 0 pet_counts[pet_type] += 1 # Find the maximum count of any pet type max_length = max(pet_counts.values()) results.append(max_length) return results # Entry function to handle multiple test cases def handle_input(num_cases, raw_test_cases): test_cases = [] index = 0 for _ in range(num_cases): N = int(raw_test_cases[index]) P = raw_test_cases[index + 1] M = int(raw_test_cases[index + 2]) sections = [] for j in range(index + 3, index + 3 + M): L, R = map(int, raw_test_cases[j].split()) sections.append((L, R)) test_cases.append({'N': N, 'P': P, 'M': M, 'sections': sections}) index = index + 3 + M return max_sequence_length(num_cases, test_cases)"},{"question":"def count_balanced_bst(h: int) -> int: Determine the number of balanced binary trees with height \`h\`. >>> count_balanced_bst(0) == 1 >>> count_balanced_bst(1) == 1 >>> count_balanced_bst(2) == 3 >>> count_balanced_bst(3) == 15 >>> count_balanced_bst(4) == 315 >>> count_balanced_bst(25) > 0","solution":"def count_balanced_bst(h): if h == -1: return 1 if h == 0: return 1 dp = [0] * (h + 1) dp[0] = 1 dp[1] = 1 for i in range(2, h + 1): dp[i] = dp[i - 1] * dp[i - 1] + 2 * dp[i - 1] * dp[i - 2] return dp[h]"},{"question":"def longest_substring_length(s: str, queries: list) -> list: Given a string and a list of queries, returns the length of the longest substring that contains only the specified character for each query. Parameters: s (str): The input string consisting of lowercase Latin letters. queries (list): A list of single characters for which to find the longest substring of \`s\` that consists solely of each character. Returns: list: A list of integers, where each integer is the result for the corresponding query in the \`queries\` list. pass from solution import longest_substring_length def test_example_case(): s = \\"abaaaabbcc\\" queries = ['a', 'b', 'c', 'd'] assert longest_substring_length(s, queries) == [4, 2, 2, 0] def test_single_character_string(): s = \\"aaaaa\\" queries = ['a', 'b'] assert longest_substring_length(s, queries) == [5, 0] def test_no_repeated_characters(): s = \\"abcdef\\" queries = ['a', 'b', 'c', 'd', 'e', 'f'] assert longest_substring_length(s, queries) == [1, 1, 1, 1, 1, 1] def test_empty_queries(): s = \\"zzz\\" queries = [] assert longest_substring_length(s, queries) == [] def test_all_same_characters(): s = \\"bbbbbb\\" queries = ['b', 'a'] assert longest_substring_length(s, queries) == [6, 0] def test_repeated_longest_substrings(): s = \\"aaabbbaaa\\" queries = ['a', 'b'] assert longest_substring_length(s, queries) == [3, 3]","solution":"def longest_substring_length(s, queries): Given a string and a list of queries, returns the length of the longest substring that contains only the specified character for each query. Parameters: s (str): The input string consisting of lowercase Latin letters. queries (list): A list of single characters for which to find the longest substring of \`s\` that consists solely of each character. Returns: list: A list of integers, where each integer is the result for the corresponding query in the \`queries\` list. # Dictionary to store the max substring length for each character max_lengths = {} # Traverse the string and keep track of the current character streak current_char = None current_length = 0 for char in s: if char == current_char: current_length += 1 else: if current_char is not None: if current_char not in max_lengths or current_length > max_lengths[current_char]: max_lengths[current_char] = current_length current_char = char current_length = 1 # Final update for the last streak if current_char is not None: if current_char not in max_lengths or current_length > max_lengths[current_char]: max_lengths[current_char] = current_length # Process each query and return the results result = [] for query in queries: result.append(max_lengths.get(query, 0)) return result"},{"question":"from typing import List def min_length_after_operations(arr: List[int]) -> int: Given an integer array, determines the minimum possible length of the array after performing the operation any number of times. The operation is choosing a consecutive subarray that sums up to a non-zero even number and deleting it. Args: arr (List[int]): The integer array. Returns: int: The minimum possible length of the array. Examples: >>> min_length_after_operations([1, 2, 3, 4, 5]) 1 >>> min_length_after_operations([2, 4, -6, 8]) 1 >>> min_length_after_operations([0, 0, 0]) 3 >>> min_length_after_operations([-2, 1, -1, 2, -3, 3]) 1 pass","solution":"from typing import List def min_length_after_operations(arr: List[int]) -> int: Function to determine the minimum possible length of the array after removing consecutive subarrays that sum up to a non-zero even number. n = len(arr) for i in range(n): # Step 1: Find any non-zero even number if arr[i] % 2 == 0 and arr[i] != 0: # Step 2: return 1 if any non-zero even number is found return 1 # Return original length if no non-zero even sum can be formed return n"},{"question":"from typing import List, Tuple def compute_net_balances(n: int, m: int, transactions: List[Tuple[int, int, int]]) -> List[int]: Compute the net balances of each person after all transactions. >>> compute_net_balances(4, 3, [(1, 2, 10), (2, 3, 5), (3, 4, 2)]) [-10, 5, 3, 2] >>> compute_net_balances(3, 2, [(1, 2, 7), (1, 3, 3)]) [-10, 7, 3] >>> compute_net_balances(2, 1, [(1, 2, 100)]) [-100, 100] >>> compute_net_balances(3, 0, []) [0, 0, 0] >>> compute_net_balances(3, 3, [(1, 2, 5), (2, 3, 5), (3, 1, 5)]) [0, 0, 0] >>> compute_net_balances(5, 5, [(1, 2, 50), (2, 3, 25), (3, 4, 10), (4, 5, 5), (5, 1, 20)]) [-30, 25, 15, 5, -15]","solution":"def compute_net_balances(n, m, transactions): balances = [0] * n for u, v, w in transactions: balances[u - 1] -= w balances[v - 1] += w return balances"},{"question":"def distribute_books(test_cases): You are given a list of integers representing a collection of books and the number of pages in each book. Your task is to determine whether it is possible to allocate all books to M students such that each student gets at least one book and the maximum number of pages assigned to a student is minimized. Args: test_cases: List[Tuple[Tuple[int, int], List[int]]]: A list of tuples where each tuple contains (N, M) - the number of books and the number of students, followed by a list of integers representing the pages in each book. Returns: List[int]: A list of integers where each integer is the minimum possible maximum number of pages a student has to read for the corresponding test case. Example: >>> distribute_books([((4, 2), [12, 34, 67, 90])]) [113] >>> distribute_books([((5, 3), [10, 20, 30, 40, 50])]) [60] pass","solution":"def is_possible(books, n, m, curr_min): students_required = 1 curr_sum = 0 for i in range(n): if books[i] > curr_min: return False if curr_sum + books[i] > curr_min: students_required += 1 curr_sum = books[i] if students_required > m: return False else: curr_sum += books[i] return True def find_minimum_pages(books, n, m): if n < m: return -1 total_pages = sum(books) max_pages = max(books) start, end = max_pages, total_pages result = total_pages while start <= end: mid = (start + end) // 2 if is_possible(books, n, m, mid): result = mid end = mid - 1 else: start = mid + 1 return result def distribute_books(test_cases): results = [] for test_case in test_cases: (n, m), books = test_case result = find_minimum_pages(books, n, m) results.append(result) return results"},{"question":"def longest_even_subarray_length(n, array): Given an array of integers, find the length of the longest continuous subarray that consists of only even numbers. Parameters: n (int): the size of the array array (list of int): the elements of the array Returns: int: the length of the longest continuous subarray that consists of only even numbers Examples: >>> longest_even_subarray_length(10, [1, 2, 4, 6, 1, 2, 4, 6, 8, 10]) 5 >>> longest_even_subarray_length(5, [1, 3, 5, 7, 9]) 0","solution":"def longest_even_subarray_length(n, array): Given an array of integers, find the length of the longest continuous subarray that consists of only even numbers. Parameters: n (int): the size of the array array (list of int): the elements of the array Returns: int: the length of the longest continuous subarray that consists of only even numbers max_length = 0 current_length = 0 for num in array: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def infix_to_postfix(expression: str) -> str: Convert an infix expression to a postfix expression. >>> infix_to_postfix(\\"A+B*(C^D-E)^(F+G*H)-I\\") 'ABCD^E-FGH*+^*+I-' >>> infix_to_postfix(\\"(A+B)^C\\") 'AB+C^' pass # Test cases def test_example_1(): assert infix_to_postfix(\\"A+B*(C^D-E)^(F+G*H)-I\\") == \\"ABCD^E-FGH*+^*+I-\\" def test_example_2(): assert infix_to_postfix(\\"(A+B)^C\\") == \\"AB+C^\\" def test_single_operand(): assert infix_to_postfix(\\"A\\") == \\"A\\" def test_no_parentheses(): assert infix_to_postfix(\\"A+B-C\\") == \\"AB+C-\\" def test_associativity(): assert infix_to_postfix(\\"A^B^C\\") == \\"ABC^^\\" def test_all_operators(): assert infix_to_postfix(\\"A+B*C/D-E\\") == \\"ABC*D/+E-\\" def test_nested_parentheses(): assert infix_to_postfix(\\"((A+B)*C-(D-E))^(F+G)\\") == \\"AB+C*DE--FG+^\\"","solution":"def infix_to_postfix(expression): Convert an infix expression to a postfix expression. precedence = {'^': 3, '*': 2, '/': 2, '+': 1, '-': 1} is_right_associative = {'^': True, '+': False, '-': False, '*': False, '/': False} def has_higher_precedence(op1, op2): if (op1 in precedence and op2 in precedence): if is_right_associative[op1]: return precedence[op1] > precedence[op2] else: return precedence[op1] >= precedence[op2] return False output = [] stack = [] for char in expression: if char.isalpha(): # Operand output.append(char) elif char == '(': # Left Parenthesis stack.append(char) elif char == ')': # Right Parenthesis while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Remove '(' from stack else: # Operator while stack and has_higher_precedence(stack[-1], char): output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return ''.join(output)"},{"question":"def min_window(s: str, t: str) -> str: Write a function that finds the smallest window (substring) in a given string S that contains all the characters of another string T, including duplicates. If there is no such window, return an empty string. If there are multiple windows of the same length, return the one that appears first. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> min_window(\\"a\\", \\"a\\") 'a' >>> min_window(\\"a\\", \\"b\\") '' >>> min_window(\\"AA\\", \\"AA\\") 'AA' >>> min_window(\\"AAB\\", \\"AA\\") 'AA' pass","solution":"def min_window(s, t): from collections import Counter, defaultdict if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(s): char = s[r] window_counts[char] += 1 if char in dict_t and window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in dict_t and window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed within the histogram. >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([6,2,5,4,5,1,6]) 12 from solution import largestRectangleArea def test_example_1(): assert largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 def test_example_2(): assert largestRectangleArea([2, 4]) == 4 def test_example_3(): assert largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 def test_single_element(): assert largestRectangleArea([5]) == 5 def test_increasing_heights(): assert largestRectangleArea([1, 2, 3, 4, 5]) == 9 def test_decreasing_heights(): assert largestRectangleArea([5, 4, 3, 2, 1]) == 9 def test_all_same_heights(): assert largestRectangleArea([4, 4, 4, 4]) == 16 def test_zero_heights(): assert largestRectangleArea([0, 0, 0, 0]) == 0 def test_random_heights(): assert largestRectangleArea([2, 3, 2, 1, 4, 5]) == 8","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations required to make all the elements of the array equal. In one operation, you can select any two elements of the array and increase both of them by one. >>> min_operations_to_equal_elements([1, 2, 3]) 3 >>> min_operations_to_equal_elements([4, 4, 4, 4]) 0","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations required to make all the elements of the array equal. In one operation, you can select any two elements of the array and increase both of them by one. # Find the minimum value in the array min_value = min(arr) # Calculate the total number of operations needed operations = sum(num - min_value for num in arr) return operations"},{"question":"def longest_non_repeating_substring(s: str) -> int: Determine the length of the longest substring that consists of non-repeating characters. Args: s (str): input string Returns: int: the length of the longest substring with all unique characters Example: >>> longest_non_repeating_substring(\\"abcabcbb\\") 3 >>> longest_non_repeating_substring(\\"bbbbb\\") 1 >>> longest_non_repeating_substring(\\"pwwkew\\") 3","solution":"def longest_non_repeating_substring(s: str) -> int: Returns the length of the longest substring of s that consists of non-repeating characters. char_index_map = {} max_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def productExceptSelf(nums: List[int]) -> List[int]: Returns a list where each element is replaced by the product of all other elements in the input list. Example 1: >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] Example 2: >>> productExceptSelf([5, 6, 2]) [12, 10, 30]","solution":"def productExceptSelf(nums): Returns a list where each element is replaced by the product of all other elements in the input list. n = len(nums) # Initialize left and right products as 1 left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for each element for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for each element for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the result by multiplying left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def min_operations_to_increasing_sequence(N: int, K: int, sequence: List[int]) -> int: Determine the minimum number of operations required to make the sequence strictly increasing. >>> min_operations_to_increasing_sequence(4, 2, [1, 2, 3, 2]) 2 >>> min_operations_to_increasing_sequence(5, 3, [5, 5, 5, 5, 5]) 10 >>> min_operations_to_increasing_sequence(3, 1, [1, 2, 3]) 0 >>> min_operations_to_increasing_sequence(4, 4, [1, 1, 1, 1]) 6 >>> min_operations_to_increasing_sequence(2, 2, [1, 1]) 1 pass def solve(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solve multiple test cases for the problem of making the sequence strictly increasing. >>> solve([(4, 2, [1, 2, 3, 2])]) [2] >>> solve([(5, 3, [5, 5, 5, 5, 5])]) [10] >>> solve([(3, 1, [1, 2, 3])]) [0] >>> solve([(4, 4, [1, 1, 1, 1])]) [6] >>> solve([(2, 2, [1, 1])]) [1] pass def test_min_operations_to_increasing_sequence(): assert min_operations_to_increasing_sequence(4, 2, [1, 2, 3, 2]) == 2 assert min_operations_to_increasing_sequence(5, 3, [5, 5, 5, 5, 5]) == 10 assert min_operations_to_increasing_sequence(3, 1, [1, 2, 3]) == 0 assert min_operations_to_increasing_sequence(4, 4, [1, 1, 1, 1]) == 6 assert min_operations_to_increasing_sequence(2, 2, [1, 1]) == 1 def test_solve(): assert solve([(4, 2, [1, 2, 3, 2])]) == [2] assert solve([(5, 3, [5, 5, 5, 5, 5])]) == [10] assert solve([(3, 1, [1, 2, 3])]) == [0] assert solve([(4, 4, [1, 1, 1, 1])]) == [6] assert solve([(2, 2, [1, 1])]) == [1] if __name__ == \\"__main__\\": test_min_operations_to_increasing_sequence() test_solve()","solution":"def min_operations_to_increasing_sequence(N, K, sequence): operations = 0 for i in range(1, N): if sequence[i] <= sequence[i - 1]: required_increment = (sequence[i - 1] - sequence[i]) + 1 sequence[i] += required_increment operations += required_increment return operations def solve(test_cases): results = [] for N, K, sequence in test_cases: result = min_operations_to_increasing_sequence(N, K, sequence) results.append(result) return results"},{"question":"def probability_of_winning(n: int, cards: List[int]) -> float: Returns the probability of drawing the highest value card. >>> probability_of_winning(5, [1, 2, 3, 4, 5]) 0.200000 >>> probability_of_winning(3, [10, 20, 30]) 0.333333 >>> probability_of_winning(4, [5, 7, 3, 1]) 0.250000 >>> probability_of_winning(1, [999]) 1.000000 >>> probability_of_winning(3, [100000000, 99999999, 100000001]) 0.333333","solution":"def probability_of_winning(n, cards): Returns the probability of drawing the highest value card. max_value = max(cards) probability = 1 / n return round(probability, 6)"},{"question":"def maximizeSouvenirValue(weights, values, W): Determines the maximum value of souvenirs that can be carried in a backpack without exceeding the weight limit. Parameters: weights (list of int): Weights of the souvenirs. values (list of int): Values of the souvenirs. W (int): Maximum weight the backpack can carry. Returns: int: Maximum value of souvenirs that can be carried. >>> maximizeSouvenirValue([2, 3, 4, 5], [3, 4, 5, 6], 5) 7 >>> maximizeSouvenirValue([1, 2, 3], [6, 10, 12], 5) 22 >>> maximizeSouvenirValue([1, 2, 3], [6, 10, 12], 6) 28 >>> maximizeSouvenirValue([3, 4, 5], [6, 7, 20], 5) 20 def test_maximizeSouvenirValue(): weights = [2, 3, 4, 5] values = [3, 4, 5, 6] W = 5 assert maximizeSouvenirValue(weights, values, W) == 7 weights = [1, 2, 3] values = [6, 10, 12] W = 5 assert maximizeSouvenirValue(weights, values, W) == 22 weights = [] values = [] W = 10 assert maximizeSouvenirValue(weights, values, W) == 0 weights = [1, 2, 3] values = [6, 10, 12] W = 0 assert maximizeSouvenirValue(weights, values, W) == 0 weights = [5] values = [10] W = 10 assert maximizeSouvenirValue(weights, values, W) == 10 weights = [15] values = [10] W = 10 assert maximizeSouvenirValue(weights, values, W) == 0 weights = [1, 2, 3] values = [6, 10, 12] W = 6 assert maximizeSouvenirValue(weights, values, W) == 28 weights = [3, 4, 5] values = [6, 7, 20] W = 5 assert maximizeSouvenirValue(weights, values, W) == 20","solution":"def maximizeSouvenirValue(weights, values, W): Determines the maximum value of souvenirs that can be carried in a backpack without exceeding the weight limit. Parameters: weights (list of int): Weights of the souvenirs. values (list of int): Values of the souvenirs. W (int): Maximum weight the backpack can carry. Returns: int: Maximum value of souvenirs that can be carried. n = len(weights) # Create a DP table to store the maximum value at each weight capacity dp = [[0] * (W + 1) for _ in range(n + 1)] # Build the DP table for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]) else: dp[i][w] = dp[i - 1][w] # The answer will be in the bottom-right cell of the matrix return dp[n][W]"},{"question":"def calculate_points(visitors): Returns a list of visitors with their corresponding points based on height, sorted by points in descending order and by name alphabetically in case of ties. >>> visitors = [ >>> {'name': 'Anna', 'height': 62}, >>> {'name': 'Bella', 'height': 55}, >>> {'name': 'Chris', 'height': 72}, >>> {'name': 'Daniel', 'height': 49}, >>> ] >>> calculate_points(visitors) [ {'name': 'Chris', 'points': 15}, {'name': 'Anna', 'points': 10}, {'name': 'Bella', 'points': 5}, {'name': 'Daniel', 'points': 0}, ] >>> visitors = [ >>> {'name': 'Anna', 'height': 72}, >>> {'name': 'Bella', 'height': 72}, >>> {'name': 'Chris', 'height': 62}, >>> {'name': 'Daniel', 'height': 49}, >>> {'name': 'Eve', 'height': 60}, >>> ] >>> calculate_points(visitors) [ {'name': 'Anna', 'points': 15}, {'name': 'Bella', 'points': 15}, {'name': 'Chris', 'points': 10}, {'name': 'Eve', 'points': 5}, {'name': 'Daniel', 'points': 0}, ] >>> visitors = [ >>> {'name': 'Shorty', 'height': 45}, >>> {'name': 'Mid', 'height': 55}, >>> {'name': 'Tall', 'height': 65}, >>> {'name': 'Giant', 'height': 75}, >>> ] >>> calculate_points(visitors) [ {'name': 'Giant', 'points': 15}, {'name': 'Tall', 'points': 10}, {'name': 'Mid', 'points': 5}, {'name': 'Shorty', 'points': 0}, ] >>> visitors = [] >>> calculate_points(visitors) []","solution":"def calculate_points(visitors): Returns a list of visitors with their corresponding points based on height, sorted by points in descending order and by name alphabetically in case of ties. result = [] for visitor in visitors: if visitor['height'] < 50: points = 0 elif 50 <= visitor['height'] <= 60: points = 5 elif 61 <= visitor['height'] <= 70: points = 10 else: points = 15 result.append({'name': visitor['name'], 'points': points}) result.sort(key=lambda x: (-x['points'], x['name'])) return result"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression involving addition (+), subtraction (-), multiplication (*), and division (/), respecting the standard operator precedence and returns the result as a float. >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"10 + 2 * 6 / 3 - 4\\") 10.0 >>> evaluate_expression(\\"12 + 3 / 2 * 2 - 2 * 4\\") 7.0 >>> evaluate_expression(\\" 5 + 4 / 2 \\") 7.0","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression involving addition (+), subtraction (-), multiplication (*), and division (/), respecting the standard operator precedence and returns the result as a float. import re # Remove spaces expression = expression.replace(' ', '') # Define helper function for basic arithmetic operations def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) # Define operator precedence precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): # Extract the number num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(float(num)) # Decrement i because it will be incremented in the next iteration of the loop i -= 1 elif expression[i] in precedence: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[expression[i]]): apply_operator(operators, values) operators.append(expression[i]) i += 1 # Apply the remaining operators to the remaining values while operators: apply_operator(operators, values) return values[0]"},{"question":"def can_enroll_students(n: int, m: int, course_info: List[Tuple[int, int, str]]) -> str: Determines if students can be enrolled in their desired courses without schedule conflicts. Args: n -- Number of students m -- Number of courses course_info -- List of tuples containing course number, time slot and enrolled students Returns: \\"Yes\\" if all students can be enrolled without conflicts, otherwise \\"No\\" >>> can_enroll_students(3, 2, [(1, 1, \\"Alice,Bob\\"), (2, 2, \\"Alice,Charlie\\")]) 'Yes' >>> can_enroll_students(3, 2, [(1, 1, \\"Alice,Bob\\"), (2, 1, \\"Alice,Charlie\\")]) 'No'","solution":"def can_enroll_students(n, m, course_info): Determines if students can be enrolled in their desired courses without schedule conflicts. Arguments: n -- Number of students m -- Number of courses course_info -- List of tuples containing course number, time slot and enrolled students Returns: \\"Yes\\" if all students can be enrolled without conflicts, otherwise \\"No\\" student_schedule = {} for course in course_info: course_number, time_slot, students = course student_list = students.split(',') for student in student_list: if student not in student_schedule: student_schedule[student] = set() if time_slot in student_schedule[student]: return \\"No\\" student_schedule[student].add(time_slot) return \\"Yes\\""},{"question":"def num_paths_in_grid_with_obstacles(grids): Given multiple grid configurations marked with 0s (free cells) and 1s (blocked cells), this function returns the number of different paths from (1,1) to (n,m) for each grid. pass def process_input(t, test_cases): Process the input for the number of test cases and their corresponding grids. pass # Unit Tests def test_num_paths_in_grid_with_obstacles(): grids = [ [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ], [ [0, 1], [0, 0] ] ] expected_outputs = [2, 1] assert num_paths_in_grid_with_obstacles(grids) == expected_outputs def test_paths_with_no_paths(): grids = [ [ [0, 1], [1, 0] ], [ [1, 0], [0, 0] ] ] expected_outputs = [0, 0] assert num_paths_in_grid_with_obstacles(grids) == expected_outputs def test_paths_with_single_cell(): grids = [ [ [0] ], [ [1] ] ] expected_outputs = [1, 0] assert num_paths_in_grid_with_obstacles(grids) == expected_outputs def test_process_input(): t = 2 test_cases = [ (3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]), (2, 2, [ [0, 1], [0, 0] ]) ] expected_outputs = [2, 1] assert process_input(t, test_cases) == expected_outputs","solution":"def num_paths_in_grid_with_obstacles(grids): Given multiple grid configurations marked with 0s (free cells) and 1s (blocked cells), this function returns the number of different paths from (1,1) to (n,m) for each grid. def count_paths(grid): n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] results = [] for grid in grids: results.append(count_paths(grid)) return results def process_input(t, test_cases): results = [] for case in test_cases: n = case[0] m = case[1] grid = case[2] paths = num_paths_in_grid_with_obstacles([grid]) results.append(paths[0]) return results"},{"question":"def common_elements_count(set1, set2): Returns the count of common elements in two sets. pass def parse_input(input_str): Parses the input string to extract the two sets of integers. pass def main(input_str): Main function to compute the count of common elements from input string. pass # Test cases if __name__ == \\"__main__\\": input_str = \\"8n1 2 3 4 5 6 7 8n6n5 6 7 8 9 10\\" assert main(input_str) == 4 input_str = \\"5n1 2 3 4 5n5n6 7 8 9 10\\" assert main(input_str) == 0 input_str = \\"3n1 2 3n3n1 2 3\\" assert main(input_str) == 3","solution":"def common_elements_count(set1, set2): Returns the count of common elements in two sets. return len(set1.intersection(set2)) def parse_input(input_str): Parses the input string to extract the two sets of integers. lines = input_str.strip().split('n') set1 = set(map(int, lines[1].split())) set2 = set(map(int, lines[3].split())) return set1, set2 def main(input_str): set1, set2 = parse_input(input_str) return common_elements_count(set1, set2)"},{"question":"def balance_seesaw(weights: List[int]) -> Tuple[str, List[int]]: Given a set of unique integer weights, determine if it is possible to place the weights on a seesaw such that it remains perfectly balanced. If it is possible, provide one possible configuration. >>> balance_seesaw([1, 2, 3]) ('YES', [1, -2, 1]) >>> balance_seesaw([4, 6]) ('NO', [])","solution":"def balance_seesaw(weights): from itertools import product n = len(weights) positions = list(range(-n, 0)) + list(range(1, n + 1)) for config in product(positions, repeat=n): if len(set(config)) == n: # Ensure all positions are unique moment_sum = sum(w * p for w, p in zip(weights, config)) if moment_sum == 0: return \\"YES\\", config return \\"NO\\", [] def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) weights = list(map(int, data[1:])) result, config = balance_seesaw(weights) if result == \\"YES\\": print(result) print(' '.join(map(str, config))) else: print(result)"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the total amount of rainwater trapped between bars. Args: height: List[int] - an array of integers representing the elevation map where the width of each bar is 1 unit. Returns: int - the total units of water trapped. Example: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 from solution import trap def test_example_1(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_example_2(): assert trap([4,2,0,3,2,5]) == 9 def test_empty(): assert trap([]) == 0 def test_no_trapping(): assert trap([1,2,3,4,5]) == 0 def test_constant_elevation(): assert trap([2,2,2,2,2]) == 0 def test_single_bar(): assert trap([1]) == 0 def test_two_bars(): assert trap([1, 2]) == 0 def test_valley(): assert trap([2, 0, 2]) == 2 def test_multiple_valleys(): assert trap([3, 0, 2, 0, 4]) == 7","solution":"def trap(height): if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"def findMaxAverage(nums: List[int], k: int) -> float: Finds the maximum average subarray of length k and returns the average value. Args: nums: List[int] - the array of integers k: int - the length of the subarray to consider Returns: float - the highest average value of any k-length subarray >>> findMaxAverage([1, 12, -5, -6, 50, 3], 4) 12.75 >>> findMaxAverage([5, 5, 5, 5, 5], 3) 5.0","solution":"def findMaxAverage(nums, k): Finds the maximum average subarray of length k and returns the average value. Args: nums: List[int] - the array of integers k: int - the length of the subarray to consider Returns: float - the highest average value of any k-length subarray # Initial sum of first k elements max_sum = current_sum = sum(nums[:k]) # Iterate over the array starting from the k-th element for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) # The highest average value return max_sum / k"},{"question":"def max_value_in_grid(n: int, m: int, operations: List[Tuple[int, int, int, int]]) -> int: Determine the maximum value in a grid after a series of increment operations on various subgrids. Args: n: Number of rows in the grid. m: Number of columns in the grid. operations: A list of operations, each represented as a tuple (r1, c1, r2, c2) describing the top-left and bottom-right corners of the subgrid to increment. Returns: The maximum value in the grid after performing all the operations. Examples: >>> max_value_in_grid(3, 3, [(0, 0, 2, 2), (0, 0, 2, 2)]) 2 >>> max_value_in_grid(3, 3, [(0, 0, 0, 0), (1, 1, 1, 1)]) 1","solution":"def max_value_in_grid(n, m, operations): # Step 1: Create the initial grid grid = [[0] * m for _ in range(n)] # Step 2: Apply the operations to the grid for r1, c1, r2, c2 in operations: for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): grid[i][j] += 1 # Step 3: Find the maximum value in the grid max_value = max(max(row) for row in grid) return max_value"},{"question":"def distribute_liquid(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Distribute the liquid from the tank into the containers in such a way that the total amount of liquid distributed is maximized without exceeding any container's capacity. Input: - T: The number of test cases. - test_cases: A list of tuples where each tuple contains: - V: The total volume of liquid in the tank. - N: The number of containers. - capacities: A list of integers representing the maximum capacities of the containers. Output: - A list of integers where each integer represents the maximum total volume of liquid that can be distributed into the containers for each test case. Example: >>> distribute_liquid(2, [(100, 5, [20, 30, 10, 40, 50]), (150, 4, [25, 50, 75, 100])]) [100, 150] >>> distribute_liquid(1, [(60, 3, [20, 20, 20])]) [60] >>> distribute_liquid(1, [(30, 3, [50, 50, 50])]) [30] >>> distribute_liquid(1, [(0, 4, [100, 200, 300, 400])]) [0] >>> distribute_liquid(1, [(100, 0, [])]) [0]","solution":"def distribute_liquid(T, test_cases): results = [] for case in test_cases: V, N, capacities = case capacities.sort(reverse=True) total_distributed = 0 for capacity in capacities: if V > 0: to_add = min(V, capacity) total_distributed += to_add V -= to_add results.append(total_distributed) return results"},{"question":"def find_tree_diameter(n: int, edges: List[Tuple[int, int]]) -> Tuple[int, int, int]: Determine the diameter of a tree (maximum distance between any two nodes) and the two nodes that define this distance. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): A list of n-1 edges in the tree. Returns: Tuple[int, int, int]: The length of the longest path in the tree, and the two nodes that define this path. Example: >>> find_tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) (3, 2, 4) >>> find_tree_diameter(4, [(1, 2), (2, 3), (2, 4)]) (2, 3, 4) pass # to be implemented def parse_input(input_data: str) -> Tuple[int, List[Tuple[int, int]]]: Parse the input data and return the number of nodes and list of edges. Parameters: input_data (str): The input data as a string. Returns: Tuple[int, List[Tuple[int, int]]]: The number of nodes and list of edges. Example: >>> parse_input(\\"5n1 2n1 3n3 4n3 5n\\") (5, [(1, 2), (1, 3), (3, 4), (3, 5)]) >>> parse_input(\\"4n1 2n2 3n2 4n\\") (4, [(1, 2), (2, 3), (2, 4)]) pass # to be implemented def main(input_data: str) -> str: Main function to process the input data and return the result as a formatted string. Parameters: input_data (str): The input data as a string. Returns: str: The length of the longest path and the two nodes that define this path, separated by spaces. Example: >>> main(\\"5n1 2n1 3n3 4n3 5n\\") \\"3 2 4\\" >>> main(\\"4n1 2n2 3n2 4n\\") \\"2 3 4\\" pass # to be implemented","solution":"def find_tree_diameter(n, edges): from collections import deque, defaultdict def bfs(start_node): distance = [-1] * n q = deque([start_node]) distance[start_node] = 0 farthest_node = start_node while q: current = q.popleft() for neighbor in tree[current]: if distance[neighbor] == -1: distance[neighbor] = distance[current] + 1 q.append(neighbor) if distance[neighbor] > distance[farthest_node]: farthest_node = neighbor return farthest_node, distance[farthest_node] tree = defaultdict(list) for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) start_node = 0 farthest_node, _ = bfs(start_node) other_end, max_distance = bfs(farthest_node) # find all nodes at maximum distance from the farthest node again final_node, final_distance = bfs(other_end) return final_distance, farthest_node + 1, other_end + 1 def parse_input(input_data): data = input_data.split('n') n = int(data[0]) edges = [list(map(int, line.split())) for line in data[1:] if line] return n, edges def main(input_data): n, edges = parse_input(input_data) result = find_tree_diameter(n, edges) return f\\"{result[0]} {result[1]} {result[2]}\\""},{"question":"def marathon_notification(t: int) -> str: Returns a notification message based on the hours passed since the marathon started. Parameters: t (int): The number of hours since the marathon started (0  t  23). Returns: str: The notification message. Examples: >>> marathon_notification(0) 'When the marathon has been running for 0 hours' >>> marathon_notification(1) 'When the marathon has been running for 1 hour' >>> marathon_notification(5) 'When the marathon has been running for 5 hours' >>> marathon_notification(23) 'When the marathon has been running for 23 hours'","solution":"def marathon_notification(t): Returns a notification message based on the hours passed since the marathon started. Parameters: t (int): The number of hours since the marathon started (0  t  23). Returns: str: The notification message. if t == 1: return f\\"When the marathon has been running for {t} hour\\" else: return f\\"When the marathon has been running for {t} hours\\" # Example usage # t = int(input().strip()) # print(marathon_notification(t))"},{"question":"def process_operations(test_cases): Process a sequence of operations on an initially empty viewing list and return the final state of the viewing list. Each test case contains a list of operations such as \\"ADD x\\", \\"REMOVE x\\", \\"REVERSE\\", \\"ROTATE n\\". >>> input_text = \\"2n5nADD inceptionnADD matrixnREMOVE inceptionnADD avatarnREVERSEn3nADD starwarsnROTATE 1nREVERSE\\" >>> test_cases = parse_input(input_text) >>> output_list = process_operations(test_cases) >>> formatted_output(output_list) 'avatar matrixnstarwars' def parse_input(input_text): Parse the input text into a format suitable for process_operations function. >>> input_text = \\"2n5nADD inceptionnADD matrixnREMOVE inceptionnADD avatarnREVERSEn3nADD starwarsnROTATE 1nREVERSE\\" >>> test_cases = parse_input(input_text) >>> test_cases [['ADD inception', 'ADD matrix', 'REMOVE inception', 'ADD avatar', 'REVERSE'], ['ADD starwars', 'ROTATE 1', 'REVERSE']] def formatted_output(output_list): Format the output list into a single string with each test case's result separated by a newline. >>> output_list = ['avatar matrix', 'starwars'] >>> formatted_output(output_list) 'avatar matrixnstarwars' def test_process_operations(): input_text = \\"2n5nADD inceptionnADD matrixnREMOVE inceptionnADD avatarnREVERSEn3nADD starwarsnROTATE 1nREVERSE\\" expected_output = \\"avatar matrixnstarwars\\" test_cases = parse_input(input_text) output_list = process_operations(test_cases) output_text = formatted_output(output_list) assert output_text == expected_output def test_add_and_remove(): input_text = \\"1n3nADD movie1nADD movie2nREMOVE movie1\\" expected_output = \\"movie2\\" test_cases = parse_input(input_text) output_list = process_operations(test_cases) output_text = formatted_output(output_list) assert output_text == expected_output def test_reverse(): input_text = \\"1n4nADD movie1nADD movie2nADD movie3nREVERSE\\" expected_output = \\"movie3 movie2 movie1\\" test_cases = parse_input(input_text) output_list = process_operations(test_cases) output_text = formatted_output(output_list) assert output_text == expected_output def test_rotate(): input_text = \\"1n4nADD movie1nADD movie2nADD movie3nROTATE 1\\" expected_output = \\"movie3 movie1 movie2\\" test_cases = parse_input(input_text) output_list = process_operations(test_cases) output_text = formatted_output(output_list) assert output_text == expected_output def test_empty_list(): input_text = \\"1n2nADD movie1nREMOVE movie1\\" expected_output = \\"EMPTY\\" test_cases = parse_input(input_text) output_list = process_operations(test_cases) output_text = formatted_output(output_list) assert output_text == expected_output","solution":"def process_operations(test_cases): result = [] for operations in test_cases: viewing_list = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"ADD\\": movie = parts[1] viewing_list.append(movie) elif cmd == \\"REMOVE\\": movie = parts[1] if movie in viewing_list: viewing_list.remove(movie) elif cmd == \\"REVERSE\\": viewing_list.reverse() elif cmd == \\"ROTATE\\": n = int(parts[1]) if viewing_list: n %= len(viewing_list) viewing_list = viewing_list[-n:] + viewing_list[:-n] if viewing_list: result.append(\\" \\".join(viewing_list)) else: result.append(\\"EMPTY\\") return result # Example test cases def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) operations = lines[idx+1:idx+1+N] test_cases.append(operations) idx += N + 1 return test_cases def formatted_output(output_list): return \\"n\\".join(output_list) input_text = 2 5 ADD inception ADD matrix REMOVE inception ADD avatar REVERSE 3 ADD starwars ROTATE 1 REVERSE test_cases = parse_input(input_text) output_list = process_operations(test_cases) output_text = formatted_output(output_list) print(output_text)"},{"question":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None def maxDepth(root): Return the maximum depth of the binary tree. >>> root = Node(10) >>> root.left = Node(20) >>> root.right = Node(30) >>> maxDepth(root) 2 >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> maxDepth(root) 2 >>> maxDepth(None) 0 >>> root = Node(10) >>> maxDepth(root) 1","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None def maxDepth(root): Return the maximum depth of the binary tree. if root is None: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def subsets(nums): Returns all possible subsets (the power set) of the given list nums. Example: >>> subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]","solution":"def subsets(nums): Returns all possible subsets (the power set) of the given list nums. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"def compute_ranks(N: int, scores: List[int]) -> List[int]: Returns the rank of each participant based on their scores. >>> compute_ranks(5, [10, 20, 20, 5, 15]) [4, 1, 1, 5, 3] >>> compute_ranks(6, [3, 3, 3, 3, 3, 3]) [1, 1, 1, 1, 1, 1]","solution":"def compute_ranks(N, scores): Returns the rank of each participant based on their scores. sorted_scores = sorted(enumerate(scores), key=lambda x: (-x[1], x[0])) ranks = [0] * N current_rank = 1 for i in range(N): if i > 0 and sorted_scores[i][1] != sorted_scores[i-1][1]: current_rank = i + 1 ranks[sorted_scores[i][0]] = current_rank return ranks"},{"question":"def find_max_scenic_value(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[int]: Calculate the highest possible total scenic value of lakes that the tourists can visit while respecting all the given preferences. Args: T: Number of test cases. test_cases: A list of tuples, each containing N (number of lakes), M (number of preferences), a list of scenic values, and a list of preferences (tuples indicating which lakes must be visited together). Returns: List of integers representing the highest possible total scenic value for each test case while respecting all preferences. Example: >>> find_max_scenic_value(2, [(4, 3, [1, 4, 5, 3], [(1, 2), (2, 3), (3, 4)]), (4, 1, [10, 20, 30, 40], [(1, 4)])]) [13, 90]","solution":"def find_max_scenic_value(T, test_cases): def dfs(node, adj_list, visited, S): stack = [node] total_value = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True total_value += S[current] for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) return total_value results = [] for case in test_cases: N, M, S, preferences = case # Convert scenic value list to 0-based indexing S = [0] + S # Create adjacency list from preferences adj_list = [[] for _ in range(N + 1)] for a, b in preferences: adj_list[a].append(b) adj_list[b].append(a) visited = [False] * (N + 1) max_scenic_value = 0 for i in range(1, N + 1): if not visited[i]: scenic_value = dfs(i, adj_list, visited, S) max_scenic_value += scenic_value results.append(max_scenic_value) return results # Example Usage if __name__ == '__main__': T = 2 test_cases = [ (4, 3, [1, 4, 5, 3], [(1, 2), (2, 3), (3, 4)]), (4, 1, [10, 20, 30, 40], [(1, 4)]) ] print(find_max_scenic_value(T, test_cases)) # Outputs: [13, 100]"},{"question":"def first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the array. This function runs in O(n) time complexity. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the array. This function runs in O(n) time complexity. n = len(nums) # First pass: place each number in its right place (1 should be at index 0, 2 at index 1, etc.) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] to its correct position correct_index = nums[i] - 1 nums[i], nums[correct_index] = nums[correct_index], nums[i] # Second pass: find the first index where the number is not correct for i in range(n): if nums[i] != i + 1: return i + 1 # If all positions are correct, the missing number is n + 1 return n + 1"},{"question":"def find_prime_gaps(N: int) -> List[int]: Find all unique prime gaps for prime numbers less than a given number \`N\`. The gap between two successive prime numbers is defined as the difference between the latter prime and the former prime. Arguments: N -- The upper limit (exclusive) for the range within which we need to find prime gaps (2 <= N <= 200,000). Returns: A list of unique prime gaps found between all successive prime numbers less than \`N\`, displayed in ascending order. >>> find_prime_gaps(20) [1, 2, 4] >>> find_prime_gaps(50) [1, 2, 4, 6] def format_prime_gaps(N: int) -> str: Format the unique prime gaps for prime numbers less than a given number \`N\` into a string, each gap on a new line. Arguments: N -- The upper limit (exclusive) for the range within which we need to find prime gaps (2 <= N <= 200,000). Returns: A string of unique prime gaps found between all successive prime numbers less than \`N\`, each on a new line. >>> format_prime_gaps(20) '1n2n4' >>> format_prime_gaps(50) '1n2n4n6'","solution":"def find_prime_gaps(N): def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True primes = [i for i in range(2, N) if is_prime(i)] gaps = set() for i in range(1, len(primes)): gaps.add(primes[i] - primes[i - 1]) return sorted(gaps) def format_prime_gaps(N): gaps = find_prime_gaps(N) return \\"n\\".join(map(str, gaps))"},{"question":"def calculate_game_resources(n: int, k: int) -> tuple: Calculates the total number of cards and tokens needed for the entire game night. Parameters: n (int): The initial number of players. k (int): The number of cards used in each round. Returns: tuple: Total number of cards and total number of tokens needed (total_cards, total_tokens) >>> calculate_game_resources(4, 3) (9, 7) >>> calculate_game_resources(6, 5) (25, 11) >>> calculate_game_resources(2, 1) (1, 3) >>> calculate_game_resources(10, 4) (36, 19) >>> calculate_game_resources(1000, 1000) (999000, 1999) >>> calculate_game_resources(500, 10) (4990, 999)","solution":"def calculate_game_resources(n, k): Calculates the total number of cards and tokens needed for the entire game night. Parameters: n (int): The initial number of players. k (int): The number of cards used in each round. Returns: tuple: Total number of cards and total number of tokens needed (total_cards, total_tokens) total_matches = n - 1 total_cards = total_matches * k total_tokens = n + total_matches return total_cards, total_tokens"},{"question":"def sum_of_two_largest_unique_elements(arr): Returns the sum of the two largest unique elements in the array. If the array has less than two unique elements, the sum is the largest unique element. >>> sum_of_two_largest_unique_elements([3, 2, 3, 4, 8, 8]) 12 >>> sum_of_two_largest_unique_elements([1, 1, 1, 1, 1]) 1 >>> sum_of_two_largest_unique_elements([5, 3, 9, 1, 9, 8]) 17 >>> sum_of_two_largest_unique_elements([0, 0, 0, 0, 0, 0]) 0 >>> sum_of_two_largest_unique_elements([10]) 10 >>> sum_of_two_largest_unique_elements([]) 0","solution":"def sum_of_two_largest_unique_elements(arr): Returns the sum of the two largest unique elements in the array. If the array has less than two unique elements, the sum is the largest unique element. unique_elements = list(set(arr)) unique_elements.sort(reverse=True) if len(unique_elements) >= 2: return unique_elements[0] + unique_elements[1] elif len(unique_elements) == 1: return unique_elements[0] else: return 0"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two given strings are anagrams of each other. Ignore spaces and capitalization when determining if the strings are anagrams. >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Hello\\", \\"Olelh\\") True >>> are_anagrams(\\"Apple\\", \\"Pepal\\") False >>> are_anagrams(\\"A gentleman\\", \\"Elegant man\\") True >>> are_anagrams(\\"William Shakespeare\\", \\"I am a weakish speller\\") True >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\" \\", \\" \\") True >>> are_anagrams(\\"a\\", \\"a\\") True >>> are_anagrams(\\"a\\", \\"b\\") False >>> are_anagrams(\\"a\\", \\"A\\") True","solution":"def are_anagrams(str1, str2): Returns True if the two strings are anagrams of each other, False otherwise. # Remove spaces and convert to lowercase str1 = str1.replace(\\" \\", \\"\\").lower() str2 = str2.replace(\\" \\", \\"\\").lower() # Compare sorted characters return sorted(str1) == sorted(str2)"},{"question":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there are two integers in the array whose sum is equal to the target value. Args: nums: List[int] - A list of integers. target: int - The target sum value. Returns: bool - True if there are two distinct integers whose sum equals the target, otherwise False. pass def test_has_pair_with_sum_case_1(): assert has_pair_with_sum([2, 7, 11, 15], 9) == True def test_has_pair_with_sum_case_2(): assert has_pair_with_sum([1, 2, 3, 9], 8) == False def test_has_pair_with_sum_case_3(): assert has_pair_with_sum([3, 3], 6) == True def test_has_pair_with_sum_with_negative_numbers(): assert has_pair_with_sum([-1, -2, -3, -4], -6) == True def test_has_pair_with_sum_large_numbers(): assert has_pair_with_sum([10**9, -10**9, 100, 200], 0) == True def test_has_pair_with_sum_no_pairs(): assert has_pair_with_sum([1, 4, 7, 12], 10) == False def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([5], 5) == False def test_has_pair_with_sum_empty_array(): assert has_pair_with_sum([], 10) == False","solution":"def has_pair_with_sum(nums, target): Determines if there are two integers in the array whose sum is equal to the target value. Args: nums: List[int] - A list of integers. target: int - The target sum value. Returns: bool - True if there are two distinct integers whose sum equals the target, otherwise False. seen = set() for number in nums: if target - number in seen: return True seen.add(number) return False"},{"question":"def filter_files_by_extension(file_paths, extension): Returns a list of unique file paths that have the specified extension. :param file_paths: List of file path strings. :param extension: The file extension to filter by. :return: List of unique file paths matching the extension. >>> filter_files_by_extension([\\"/home/user/file1.txt\\", \\"/var/log/file2.log\\", \\"/home/user/docs/report.pdf\\", \\"/home/user/file1.txt\\"], \\".txt\\") [\\"/home/user/file1.txt\\"] >>> filter_files_by_extension([\\"/home/user/file1.txt\\", \\"/var/log/file2.log\\", \\"/home/user/file2.txt\\"], \\".log\\") [\\"/var/log/file2.log\\"] >>> filter_files_by_extension([\\"/home/user/file1.txt\\", \\"/var/log/file2.log\\", \\"/home/user/docs/report.pdf\\"], \\".csv\\") [] >>> filter_files_by_extension([\\"/home/user/file1.txt\\", \\"/var/log/file1.txt\\", \\"/home/user/docs/report.txt\\", \\"/home/user/file1.txt\\"], \\".txt\\") [\\"/home/user/file1.txt\\", \\"/var/log/file1.txt\\", \\"/home/user/docs/report.txt\\"] >>> filter_files_by_extension([\\"/home/user/file1.Txt\\", \\"/var/log/file2.log\\", \\"/home/user/file1.txt\\"], \\".txt\\") [\\"/home/user/file1.txt\\"]","solution":"def filter_files_by_extension(file_paths, extension): Returns a list of unique file paths that have the specified extension. :param file_paths: List of file path strings. :param extension: The file extension to filter by. :return: List of unique file paths matching the extension. seen = set() result = [] for path in file_paths: if path.endswith(extension) and path not in seen: seen.add(path) result.append(path) return result"},{"question":"def is_valid_password(password: str) -> bool: Check if the password meets all security criteria: at least 8 characters long, include at least one lowercase and one uppercase letter, contain at least one digit, and have at least one special character from the set {!, @, #, , %, ^, &, *, (, ), _, +}. >>> is_valid_password(\\"Password1@\\") True >>> is_valid_password(\\"short1!\\") False >>> is_valid_password(\\"NoSpecialChar123\\") False pass def password_checker(t: int, passwords: List[str]) -> List[str]: For each password, check if it is valid and return \\"Valid\\" or \\"Invalid\\" based on the criteria. >>> password_checker(3, [\\"Password1@\\", \\"short1!\\", \\"NoSpecialChar123\\"]) [\\"Valid\\", \\"Invalid\\", \\"Invalid\\"] pass # Unit tests from solution import password_checker def test_valid_passwords(): assert password_checker(3, [\\"Password1@\\", \\"GoodPaword123!\\", \\"V4l!d*Pwd\\"]) == [\\"Valid\\", \\"Valid\\", \\"Valid\\"] def test_invalid_passwords(): assert password_checker(3, [\\"short1!\\", \\"NoSpecialChar123\\", \\"lowercase123!\\"]) == [\\"Invalid\\", \\"Invalid\\", \\"Invalid\\"] def test_mixed_passwords(): assert password_checker(4, [\\"ValidPass1!\\", \\"inv@lid\\", \\"Another1\\", \\"badpass\\"]) == [\\"Valid\\", \\"Invalid\\", \\"Valid\\", \\"Invalid\\"] def test_edge_cases(): assert password_checker(4, [\\"\\", \\"aB1!\\", \\"a\\" * 8, \\"A1b\\" * 25]) == [\\"Invalid\\", \\"Invalid\\", \\"Invalid\\", \\"Valid\\"]","solution":"def is_valid_password(password): if len(password) < 8: return False has_lower = has_upper = has_digit = has_special = False special_characters = set(\\"!@#%^&*()_+\\") for char in password: if char.islower(): has_lower = True elif char.isupper(): has_upper = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_lower and has_upper and has_digit and has_special def password_checker(t, passwords): results = [] for password in passwords: if is_valid_password(password): results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results"},{"question":"def is_complete_binary_tree(n, nodes): Given a binary tree, determine if it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Args: n: int - the number of nodes in the binary tree. nodes: List[int] - a list of integers representing the level-order traversal of the binary tree (use -1 to represent null nodes). Returns: int - \\"1\\" if the binary tree is complete, otherwise \\"0\\". Example: >>> is_complete_binary_tree(6, [1, 2, 3, 4, 5, -1]) 1 >>> is_complete_binary_tree(6, [1, 2, 3, 4, -1, 5]) 0 pass def evaluate_test_cases(T, cases): Evaluate multiple test cases for completeness of binary trees. Args: T: int - the number of test cases. cases: List[Tuple[int, List[int]]] - a list of tuples, where each tuple contains an integer N and a list representing the binary tree. Returns: List[int] - a list of results for each test case. pass def format_output(results): Format the output for the results. Args: results: List[int] - a list of results for each test case. Returns: str - formatted string of results. pass from is_complete_binary_tree import is_complete_binary_tree, evaluate_test_cases, format_output def test_is_complete_binary_tree(): assert is_complete_binary_tree(6, [1, 2, 3, 4, 5, -1]) == 1 assert is_complete_binary_tree(6, [1, 2, 3, 4, -1, 5]) == 0 assert is_complete_binary_tree(3, [1, 2, 3]) == 1 assert is_complete_binary_tree(5, [1, 2, -1, 4, 5]) == 0 assert is_complete_binary_tree(7, [1, 2, 3, 4, 5, 6, -1]) == 1 def test_evaluate_test_cases(): cases = [ (6, [1, 2, 3, 4, 5, -1]), (6, [1, 2, 3, 4, -1, 5]), (3, [1, 2, 3]), ] results = evaluate_test_cases(3, cases) assert results == [1, 0, 1] def test_format_output(): results = [1, 0, 1] output = format_output(results) assert output == \\"1n0n1\\"","solution":"def is_complete_binary_tree(n, nodes): if n == 0: return 1 i = 0 while i < n: if nodes[i] == -1: break i += 1 for j in range(i, n): if nodes[j] != -1: return 0 return 1 def evaluate_test_cases(T, cases): results = [] for i in range(T): n, nodes = cases[i] result = is_complete_binary_tree(n, nodes) results.append(result) return results def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def max_effect_subset(N: int, K: int, identifiers: List[int]) -> List[int]: Returns the subset of K bottles that yields the maximum combined magical effect. If there are multiple subsets with the same sum, returns the lexicographically smallest subset. >>> max_effect_subset(5, 3, [1, 3, -2, 5, 4]) [3, 4, 5] >>> max_effect_subset(6, 2, [10, 20, 30, -10, -20, 40]) [30, 40] >>> max_effect_subset(4, 4, [-1, -2, -3, -4]) [-4, -3, -2, -1] >>> max_effect_subset(7, 3, [4, 4, 4, 1, 1, 1, 5]) [4, 4, 5] >>> max_effect_subset(5, 2, [-10, -5, -1, 0, 2]) [0, 2] >>> max_effect_subset(10, 5, [10, -10, 9, -9, 8, -8, 7, -7, 6, -6]) [6, 7, 8, 9, 10] pass","solution":"def max_effect_subset(N, K, identifiers): Returns the subset of K bottles that yields the maximum combined magical effect. If there are multiple subsets with the same sum, returns the lexicographically smallest subset. # Sort the identifiers in descending order to get possible largest sums quickly identifiers.sort(reverse=True) # Pick the top K identifiers top_k_identifiers = identifiers[:K] # Sort the top K identifiers to make the result lexicographically smallest top_k_identifiers.sort() return top_k_identifiers # Example usage if __name__ == \\"__main__\\": N, K = 5, 3 identifiers = [1, 3, -2, 5, 4] result = max_effect_subset(N, K, identifiers) print(result) # Output should be [3, 4, 5]"},{"question":"def encrypt(s: str, k: int) -> str: Encrypt the input string s by shifting each character k positions forward in the alphabet. >>> encrypt('hello', 3) 'khoor' >>> encrypt('abcd', 1) 'bcde' >>> encrypt('xyz', 3) 'abc' pass # Please write your implementation here def decrypt(s: str, k: int) -> str: Decrypt the input string s by shifting each character k positions backward in the alphabet. >>> decrypt('khoor', 3) 'hello' >>> decrypt('bcde', 1) 'abcd' >>> decrypt('abc', 3) 'xyz' pass # Please write your implementation here from solution import encrypt, decrypt def test_encrypt(): assert encrypt('hello', 3) == 'khoor' assert encrypt('abcd', 1) == 'bcde' assert encrypt('xyz', 3) == 'abc' assert encrypt('abc', 26) == 'abc' assert encrypt('abcdef', 25) == 'zabcde' def test_decrypt(): assert decrypt('khoor', 3) == 'hello' assert decrypt('bcde', 1) == 'abcd' assert decrypt('abc', 3) == 'xyz' assert decrypt('abc', 26) == 'abc' assert decrypt('zabcde', 25) == 'abcdef' def test_encrypt_and_decrypt(): original_string = 'testingciphers' shift = 5 encrypted = encrypt(original_string, shift) decrypted = decrypt(encrypted, shift) assert decrypted == original_string","solution":"def encrypt(s, k): Encrypt the input string s by shifting each character k positions forward in the alphabet. encrypted = [] for char in s: shifted = (ord(char) - ord('a') + k) % 26 + ord('a') encrypted.append(chr(shifted)) return ''.join(encrypted) def decrypt(s, k): Decrypt the input string s by shifting each character k positions backward in the alphabet. decrypted = [] for char in s: shifted = (ord(char) - ord('a') - k) % 26 + ord('a') decrypted.append(chr(shifted)) return ''.join(decrypted)"},{"question":"def is_super_full_binary_tree(N, edges): Determine if a given tree is a super full binary tree. A tree is a super full binary tree if: 1. It is non-empty and all leaves are at the same level. 2. Every non-leaf node has exactly three children. Args: N: int - Number of nodes in the tree edges: List[str] - List of edges in the format of parent-child relationships Returns: bool: True if the tree is a super full binary tree, False otherwise Example: >>> is_super_full_binary_tree(7, [\\"1 2 3 4\\", \\"2 -1\\", \\"3 -1\\", \\"4 -1\\", \\"5 6 7 8\\", \\"6 -1\\", \\"7 -1\\", \\"8 -1\\"]) True >>> is_super_full_binary_tree(6, [\\"1 2 3 4\\", \\"2 -1\\", \\"3 -1\\", \\"4 5 6\\"]) False from collections import defaultdict, deque children = defaultdict(list) for edge in edges: parent, *childs = map(int, edge.split()) if childs != [-1]: children[parent] = childs def bfs(root): queue = deque([(root, 0)]) leaf_level = -1 while queue: node, level = queue.popleft() if node in children: if len(children[node]) != 3: return False for child in children[node]: queue.append((child, level + 1)) else: if leaf_level == -1: leaf_level = level elif leaf_level != level: return False return True return bfs(1) # Example Usage N = 7 edges = [\\"1 2 3 4\\", \\"2 -1\\", \\"3 -1\\", \\"4 -1\\", \\"5 6 7 8\\", \\"6 -1\\", \\"7 -1\\", \\"8 -1\\"] print(is_super_full_binary_tree(N, edges)) # Output should be True","solution":"from collections import defaultdict, deque def is_super_full_binary_tree(N, edges): # Building the tree from given edges. Using default dict for easier management of children nodes. children = defaultdict(list) for edge in edges: parent, *childs = map(int, edge.split()) if childs != [-1]: children[parent] = childs def bfs(root): # Using BFS to traverse the tree and check the conditions queue = deque([(root, 0)]) leaf_level = -1 while queue: node, level = queue.popleft() if node in children: if len(children[node]) != 3: return False for child in children[node]: queue.append((child, level + 1)) else: if leaf_level == -1: leaf_level = level elif leaf_level != level: return False return True return bfs(1) # Example Usage N = 7 edges = [\\"1 2 3 4\\", \\"2 -1\\", \\"3 -1\\", \\"4 -1\\", \\"5 6 7 8\\", \\"6 -1\\", \\"7 -1\\", \\"8 -1\\"] print(is_super_full_binary_tree(N, edges))"},{"question":"def evaluate_rpn(expression: str) -> int: Evaluates a postfix expression (Reverse Polish Notation) and returns the result as an integer. >>> evaluate_rpn(\\"3 4 +\\") == 7 >>> evaluate_rpn(\\"3 4 + 2 * 7 /\\") == 2 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") == 14 >>> evaluate_rpn(\\"10 2 /\\") == 5 >>> evaluate_rpn(\\"10 2 * 3 -\\") == 17 >>> evaluate_rpn(\\"2 3 1 * + 9 -\\") == -4","solution":"def evaluate_rpn(expression): Evaluates a postfix expression (Reverse Polish Notation) and returns the result as an integer. stack = [] tokens = expression.split() for token in tokens: if token in '+-*/': b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # Perform integer division stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"def CountBuildingsWithSunlight(N, A): Function to determine the number of buildings receiving direct sunlight. Parameters: N (int): Number of buildings. A (list): Heights of the buildings. Returns: int: The count of buildings receiving direct sunlight. Example: >>> CountBuildingsWithSunlight(6, [3, 7, 8, 3, 6, 1]) 3 >>> CountBuildingsWithSunlight(5, [1, 4, 3, 2, 5]) 3 pass","solution":"def CountBuildingsWithSunlight(N, A): Function to determine the number of buildings receiving direct sunlight. Parameters: N (int): Number of buildings. A (list): Heights of the buildings. Returns: int: The count of buildings receiving direct sunlight. # If there are no buildings if N == 0: return 0 count = 1 # The first building always receives sunlight max_height = A[0] # Initialize the max_height with the height of the first building for i in range(1, N): if A[i] > max_height: count += 1 max_height = A[i] return count"},{"question":"def max_cars_in_city(test_cases): The city of Metropolis has a new surveillance system that keeps track of all the cars entering and leaving the city. The system records the license plate number and the type of action (enter or leave) for every car. Determine the moment at which the maximum number of cars are present in the city as the records are processed in chronological order. Arguments: test_cases -- List of lists, where each inner list contains strings representing the records for a single test case. Returns: A list of integers where each integer is the maximum number of cars present in the city at any given moment for corresponding test case. Example: >>> max_cars_in_city([ [ \\"ABC123 enter\\", \\"XYZ789 enter\\", \\"ABC123 leave\\", \\"DEF456 enter\\", \\"XYZ789 leave\\", \\"DEF456 leave\\", \\"GHI012 enter\\" ] ]) [2] >>> max_cars_in_city([ [ \\"ABC123 enter\\", \\"XYZ789 enter\\", \\"DEF456 enter\\" ] ]) [3] from solution import max_cars_in_city def test_single_test_case(): test_cases = [ [ \\"ABC123 enter\\", \\"XYZ789 enter\\", \\"ABC123 leave\\", \\"DEF456 enter\\", \\"XYZ789 leave\\", \\"DEF456 leave\\", \\"GHI012 enter\\" ] ] assert max_cars_in_city(test_cases) == [2] def test_no_car_leaves(): test_cases = [ [ \\"ABC123 enter\\", \\"XYZ789 enter\\", \\"DEF456 enter\\" ] ] assert max_cars_in_city(test_cases) == [3] def test_all_cars_leave(): test_cases = [ [ \\"ABC123 enter\\", \\"XYZ789 enter\\", \\"ABC123 leave\\", \\"XYZ789 leave\\", \\"DEF456 enter\\", \\"DEF456 leave\\" ] ] assert max_cars_in_city(test_cases) == [2] def test_multiple_test_cases(): test_cases = [ [ \\"ABC123 enter\\", \\"XYZ789 enter\\", \\"ABC123 leave\\" ], [ \\"DEF456 enter\\", \\"DEF456 leave\\", \\"XYZ789 enter\\", \\"XYZ789 leave\\" ] ] assert max_cars_in_city(test_cases) == [2, 1] def test_large_number_of_records(): test_cases = [ [ \\"car{} enter\\".format(i) for i in range(1, 100001) ] + [ \\"car{} leave\\".format(i) for i in range(1, 100001) ] ] assert max_cars_in_city(test_cases) == [100000]","solution":"def max_cars_in_city(test_cases): results = [] for records in test_cases: current_cars = 0 max_cars = 0 for record in records: license_plate, action = record.split() if action == \\"enter\\": current_cars += 1 elif action == \\"leave\\": current_cars -= 1 if current_cars > max_cars: max_cars = current_cars results.append(max_cars) return results"},{"question":"class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right def construct_bst_from_preorder(preorder): if not preorder: return None def build_bst(preorder, index, bound): if index[0] == len(preorder) or preorder[index[0]] > bound: return None root_val = preorder[index[0]] index[0] += 1 root = TreeNode(root_val) root.left = build_bst(preorder, index, root_val) root.right = build_bst(preorder, index, bound) return root index = [0] return build_bst(preorder, index, float('inf')) def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.key] + inorder_traversal(root.right) def inorder_from_preorder(n, preorder): Constructs a BST from given preorder traversal and returns its inorder traversal. >>> inorder_from_preorder(5, [8, 5, 1, 7, 10]) [1, 5, 7, 8, 10] >>> inorder_from_preorder(1, [5]) [5] >>> inorder_from_preorder(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> inorder_from_preorder(5, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> inorder_from_preorder(6, [10, 5, 1, 7, 40, 50]) [1, 5, 7, 10, 40, 50]","solution":"class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right def construct_bst_from_preorder(preorder): if not preorder: return None def build_bst(preorder, index, bound): if index[0] == len(preorder) or preorder[index[0]] > bound: return None root_val = preorder[index[0]] index[0] += 1 root = TreeNode(root_val) root.left = build_bst(preorder, index, root_val) root.right = build_bst(preorder, index, bound) return root index = [0] return build_bst(preorder, index, float('inf')) def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.key] + inorder_traversal(root.right) def inorder_from_preorder(n, preorder): root = construct_bst_from_preorder(preorder) return inorder_traversal(root)"},{"question":"def genre_sum(n, book_ids, genres, q, queries): Returns a list of sums of book IDs for each queried genre. Args: n (int): Number of books. book_ids (list of int): List of book IDs. genres (list of str): List of genres corresponding to the book IDs. q (int): Number of queries. queries (list of str): List of genres for the queries. Returns: list of int: List of sums of book IDs for each queried genre. # Example usage: # n = 5 # book_ids = [10, 20, 30, 40, 50] # genres = ['a', 'b', 'a', 'b', 'c'] # q = 3 # queries = ['a', 'b', 'c'] # print(genre_sum(n, book_ids, genres, q, queries)) # Output: [40, 60, 50] def test_genre_sum(): assert genre_sum(5, [10, 20, 30, 40, 50], ['a', 'b', 'a', 'b', 'c'], 3, ['a', 'b', 'c']) == [40, 60, 50] assert genre_sum(5, [10, 20, 30, 40, 50], ['a', 'b', 'a', 'b', 'c'], 4, ['a', 'b', 'c', 'd']) == [40, 60, 50, 0] assert genre_sum(3, [15, 25, 35], ['x', 'y', 'x'], 2, ['x', 'y']) == [50, 25] assert genre_sum(3, [15, 25, 35], ['x', 'y', 'x'], 1, ['z']) == [0] assert genre_sum(6, [5, 5, 5, 5, 5, 5], ['x', 'x', 'y', 'y', 'z', 'z'], 3, ['x', 'y', 'z']) == [10, 10, 10] # Running the test using pytest if __name__ == '__main__': import pytest pytest.main([__file__])","solution":"def genre_sum(n, book_ids, genres, q, queries): Returns a list of sums of book IDs for each queried genre. Args: n (int): Number of books. book_ids (list of int): List of book IDs. genres (list of str): List of genres corresponding to the book IDs. q (int): Number of queries. queries (list of str): List of genres for the queries. Returns: list of int: List of sums of book IDs for each queried genre. from collections import defaultdict genre_to_sum = defaultdict(int) # Calculate the sum of book IDs for each genre for i in range(n): genre_to_sum[genres[i]] += book_ids[i] # Answer queries result = [] for query in queries: result.append(genre_to_sum[query]) return result # Example usage: # n = 5 # book_ids = [10, 20, 30, 40, 50] # genres = ['a', 'b', 'a', 'b', 'c'] # q = 3 # queries = ['a', 'b', 'c'] # print(genre_sum(n, book_ids, genres, q, queries)) # Output: [40, 60, 50]"},{"question":"from typing import List, Tuple def find_most_and_least_frequent_error_codes(n: int, error_logs: List[str]) -> Tuple[str, str]: Process the error logs for one day and find the most frequent and least frequent error codes. Args: n (int): the number of error logs for the day. error_logs (List[str]): a list of strings representing the error logs in the format \\"timestamp error_code\\". Returns: Tuple[str, str]: the most frequent and least frequent error codes separated by a space. In case of ties, return the lexicographically smallest error code among them. >>> find_most_and_least_frequent_error_codes(6, [ ... \\"2021-10-15 08:23:45 E001\\", ... \\"2021-10-15 09:47:21 E001\\", ... \\"2021-10-15 10:15:00 E002\\", ... \\"2021-10-15 11:05:34 E003\\", ... \\"2021-10-15 14:31:12 E002\\", ... \\"2021-10-15 16:18:40 E003\\"]) == (\\"E001\\", \\"E001\\") >>> find_most_and_least_frequent_error_codes(6, [ ... \\"2021-10-15 08:23:45 E004\\", ... \\"2021-10-15 09:47:21 E003\\", ... \\"2021-10-15 10:15:00 E002\\", ... \\"2021-10-15 11:05:34 E003\\", ... \\"2021-10-15 14:31:12 E002\\", ... \\"2021-10-15 16:18:40 E001\\"]) == (\\"E002\\", \\"E001\\") >>> find_most_and_least_frequent_error_codes(3, [ ... \\"2021-10-15 08:23:45 A\\", ... \\"2021-10-15 09:47:21 B\\", ... \\"2021-10-15 10:15:00 C\\"]) == (\\"A\\", \\"A\\") >>> find_most_and_least_frequent_error_codes(3, [ ... \\"2021-10-15 08:23:45 E005\\", ... \\"2021-10-15 09:47:21 E005\\", ... \\"2021-10-15 09:47:21 E005\\"]) == (\\"E005\\", \\"E005\\") >>> find_most_and_least_frequent_error_codes(1, [ ... \\"2021-10-15 08:23:45 E005\\"]) == (\\"E005\\", \\"E005\\")","solution":"def find_most_and_least_frequent_error_codes(n, error_logs): from collections import Counter error_counts = Counter() for log in error_logs: _, error_code = log.rsplit(' ', 1) error_counts[error_code] += 1 if not error_counts: return (\\"\\", \\"\\") most_frequent = min(error_code for error_code, count in error_counts.items() if count == max(error_counts.values())) least_frequent = min(error_code for error_code, count in error_counts.items() if count == min(error_counts.values())) return most_frequent, least_frequent"},{"question":"def solve_chessboard(n, m, blocked_cells): Determine if Rosa can move a knight from the top-left cell to the bottom-right cell on an n x n chessboard while Charley blocks cells to make it difficult. Parameters: n (int): Size of the chessboard (n x n). m (int): Number of initially blocked cells. blocked_cells (set): Set of tuples representing the initially blocked cells. Returns: str: \\"Rosa\\" if Rosa wins, otherwise \\"Charley\\". Examples: >>> solve_chessboard(5, 3, {(1, 2), (2, 3), (4, 5)}) 'Rosa' >>> solve_chessboard(5, 1, {(1, 1)}) 'Charley' import doctest doctest.testmod()","solution":"def solve_chessboard(n, m, blocked_cells): def get_neighbors(x, y, n): # Define knight moves move_offsets = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] neighbors = [] for dx, dy in move_offsets: nx, ny = x + dx, y + dy if 1 <= nx <= n and 1 <= ny <= n: neighbors.append((nx, ny)) return neighbors from collections import deque # BFS to check if there's a path from (1, 1) to (n, n) start = (1, 1) end = (n, n) queue = deque([start]) visited = set(start) if start in blocked_cells: return \\"Charley\\" while queue: x, y = queue.popleft() if (x, y) == end: return \\"Rosa\\" for nx, ny in get_neighbors(x, y, n): if (nx, ny) not in blocked_cells and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"Charley\\" # Example to run the function manually if __name__ == \\"__main__\\": n = 5 m = 3 blocked_cells = set([(1, 2), (2, 3), (4, 5)]) result = solve_chessboard(n, m, blocked_cells) print(result) # Output should be \\"Rosa\\""},{"question":"from typing import List, Tuple def find_path(grid: List[List[int]]) -> List[Tuple[int, int]]: Finds and returns a list of coordinates representing the path from (0,0) to (n-1,m-1) in a given grid. If no path exists, returns an empty list. >>> find_path([[0, 1], [0, 0]]) [(0, 0), (1, 0), (1, 1)] >>> find_path([[0, 1], [1, 0]]) [] pass # Example test cases def test_case1(): grid = [ [0, 1], [0, 0] ] assert find_path(grid) == [(0, 0), (1, 0), (1, 1)] def test_case2(): grid = [ [0, 1], [1, 0] ] assert find_path(grid) == [] def test_case3(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 1, 1, 0] ] path = find_path(grid) assert path == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (3, 3), (3, 4), (4, 4)] def test_case4(): grid = [ [1, 0], [0, 0] ] assert find_path(grid) == [] def test_case5(): grid = [ [0, 0], [0, 1] ] assert find_path(grid) == [] def test_case6(): grid = [ [0] ] assert find_path(grid) == [(0, 0)] def test_case7(): grid = [ [0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0] ] assert find_path(grid) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (1, 6), (2, 6)]","solution":"from collections import deque def find_path(grid): Finds and returns a list of coordinates representing the path from (0,0) to (n-1,m-1) in a given grid. If no path exists, returns an empty list. n, m = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return [] def is_valid(r, c): return 0 <= r < n and 0 <= c < m and grid[r][c] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) path = {(0, 0): None} while queue: r, c = queue.popleft() if (r, c) == (n-1, m-1): break for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in path: queue.append((nr, nc)) path[(nr, nc)] = (r, c) if (n-1, m-1) not in path: return [] # Reconstruct the path result_path = [] curr = (n-1, m-1) while curr: result_path.append(curr) curr = path[curr] result_path.reverse() return result_path"},{"question":"def largest_fertile_rectangle(n: int, m: int, grid: List[str]) -> int: Given a grid where '1' represents fertile land and '0' represents barren land, find the area of the largest contiguous rectangular sub-grid of fertile land. Args: n : int : Number of rows in the grid m : int : Number of columns in the grid grid : List[str] : The grid itself, represented as a list of strings Returns: int : The area of the largest rectangle consisting entirely of '1's Examples: >>> largest_fertile_rectangle(4, 5, [\\"10100\\",\\"10111\\",\\"11111\\",\\"10010\\"]) 6 >>> largest_fertile_rectangle(3, 3, [\\"111\\",\\"111\\",\\"111\\"]) 9 >>> largest_fertile_rectangle(3, 3, [\\"000\\",\\"000\\",\\"000\\"]) 0 >>> largest_fertile_rectangle(2, 2, [\\"10\\",\\"01\\"]) 1","solution":"def max_histogram_area(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 histogram = [0] * m for i in range(n): for j in range(m): histogram[j] = histogram[j] + 1 if matrix[i][j] == '1' else 0 max_area = max(max_area, max_histogram_area(histogram)) return max_area def largest_fertile_rectangle(n, m, grid): return max_rectangle(grid)"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given string s. A palindrome is a string that reads the same backward as forward. If there are multiple substrings of the same maximum length, the one that appears first should be returned. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindromic_substring(\\"a\\") == \\"a\\" True >>> longest_palindromic_substring(\\"\\") == \\"\\" True >>> longest_palindromic_substring(\\"aa\\") == \\"aa\\" True >>> longest_palindromic_substring(\\"ab\\") == \\"a\\" True >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" True >>> longest_palindromic_substring(\\"abcbabcbabcba\\") == \\"abcbabcbabcba\\" True >>> longest_palindromic_substring(\\"aaaaa\\") == \\"aaaaa\\" True >>> longest_palindromic_substring(\\"abcdddcba\\") == \\"abcdddcba\\" True >>> longest_palindromic_substring(\\"abcdefgh\\") == \\"a\\" True","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" # Initialize a table to store the palindrome state dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for substrings of length greater than 2 for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return s[start:start + max_length]"},{"question":"def find_task_durations(D: int) -> list: Returns the combination of tasks that add up to the total duration D, where each task takes a distinct positive integer amount of time. >>> find_task_durations(6) [1, 2, 3] >>> find_task_durations(10) [1, 2, 3, 4] >>> find_task_durations(1) [1]","solution":"def find_task_durations(D): Returns the number of tasks and their durations such that the total time taken to complete all tasks equals D. # The approach is to use the smallest distinct positive integers i.e., 1, 2, 3, ... tasks = [] current_sum = 0 task_duration = 1 while current_sum + task_duration <= D: tasks.append(task_duration) current_sum += task_duration task_duration += 1 # After exiting the loop, if there's any remaining time to be added, increment the last task if current_sum < D: tasks[-1] += (D - current_sum) return tasks"},{"question":"def max_subarray_sum(T, test_cases): Given T test cases of sequences, returns the maximum sum of any continuous subarray. :param T: int - number of test cases :param test_cases: list of tuples - each tuple contains an integer N (length of the sequence) followed by the sequence of integers :return: list of integers - maximum subarray sum for each test case # Your code here # Example usage: # T = 2 # test_cases = [ # (9, -2, 1, -3, 4, -1, 2, 1, -5, 4), # (4, -1, -2, -3, -4) # ] # print(max_subarray_sum(T, test_cases)) # Output: [6, -1] from solution import max_subarray_sum def test_multiple_cases(): T = 2 test_cases = [ (9, -2, 1, -3, 4, -1, 2, 1, -5, 4), (4, -1, -2, -3, -4) ] assert max_subarray_sum(T, test_cases) == [6, -1] def test_single_case(): T = 1 test_cases = [ (5, -1, -2, -3, -4, 0) ] assert max_subarray_sum(T, test_cases) == [0] def test_all_negative_numbers(): T = 1 test_cases = [ (5, -5, -1, -8, -9, -10) ] assert max_subarray_sum(T, test_cases) == [-1] def test_all_positive_numbers(): T = 1 test_cases = [ (5, 1, 2, 3, 4, 5) ] assert max_subarray_sum(T, test_cases) == [15] def test_empty_subarray(): T = 1 test_cases = [ (0,) ] assert max_subarray_sum(T, test_cases) == [0]","solution":"def max_subarray_sum(T, test_cases): Given T test cases of sequences, returns the maximum sum of any continuous subarray. :param T: int - number of test cases :param test_cases: list of tuples - each tuple contains an integer N (length of the sequence) followed by the sequence of integers :return: list of integers - maximum subarray sum for each test case results = [] for case in test_cases: N = case[0] array = case[1:] if N == 0: results.append(0) continue # Implementing Kadane's Algorithm max_current = max_global = array[0] for i in range(1, N): max_current = max(array[i], max_current + array[i]) if max_current > max_global: max_global = max_current results.append(max_global) return results # Example usage: # T = 2 # test_cases = [ # (9, -2, 1, -3, 4, -1, 2, 1, -5, 4), # (4, -1, -2, -3, -4) # ] # print(max_subarray_sum(T, test_cases)) # Output: [6, -1]"},{"question":"def shortest_unique_substring_length(s: str) -> int: Returns the length of the shortest substring that contains all unique characters of the input string. >>> shortest_unique_substring_length(\\"abcabcbb\\") 3 >>> shortest_unique_substring_length(\\"aabcbcdbca\\") 4 >>> shortest_unique_substring_length(\\"a\\") 1 >>> shortest_unique_substring_length(\\"aaaaaa\\") 1 >>> shortest_unique_substring_length(\\"\\") 0 >>> shortest_unique_substring_length(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> shortest_unique_substring_length(\\"abac\\") 3","solution":"def shortest_unique_substring_length(s): Returns the length of the shortest substring that contains all unique characters of the input string. if not s: return 0 unique_chars = set(s) num_unique_chars = len(unique_chars) min_length = float('inf') left = 0 char_count = {} for right in range(len(s)): char = s[right] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) == num_unique_chars: min_length = min(min_length, right - left + 1) left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 return min_length"},{"question":"def countSubsets(arr, target): Returns the number of subsets that add up exactly to the target sum. >>> countSubsets([2, 3, 5, 6, 8, 10], 10) 3 >>> countSubsets([1, 2, 3, 4, 5], 5) 3 >>> countSubsets([1, 2, 3], 7) 0 >>> countSubsets([5], 5) 1 >>> countSubsets([1, 1, 1, 1], 2) 6 >>> countSubsets([i for i in range(1, 21)], 210) 1 >>> countSubsets([1, 1, 1, 1], 4) 1 >>> import itertools >>> arr = list(itertools.repeat(1, 20)) >>> countSubsets(arr, 10) 184756","solution":"def countSubsets(arr, target): Returns the number of subsets that add up exactly to the target sum. def countSubsetsRecursive(arr, n, target): # Base cases if target == 0: return 1 if n == 0: return 0 # If the last element is greater than target, it can't contribute to any subset if arr[n - 1] > target: return countSubsetsRecursive(arr, n - 1, target) # Otherwise, we count the subsets including the last element and excluding the last element return countSubsetsRecursive(arr, n - 1, target - arr[n - 1]) + countSubsetsRecursive(arr, n - 1, target) return countSubsetsRecursive(arr, len(arr), target)"},{"question":"def eggDrop(n: int) -> int: Function to calculate the minimum number of attempts needed to find the highest floor from which an egg can be dropped without breaking in the worst-case scenario with two eggs and n floors. :param n: int - the total number of floors :return: int - the minimum number of attempts needed >>> eggDrop(10) 4 >>> eggDrop(100) 14","solution":"def eggDrop(n): Function to calculate the minimum number of attempts needed to find the highest floor from which an egg can be dropped without breaking in the worst-case scenario with two eggs and n floors. :param n: int - the total number of floors :return: int - the minimum number of attempts needed # Base case if n == 1: return 1 if n == 0: return 0 # Function to calculate the minimum attempts needed when # we have two eggs and x floors using the closed form formula def calculate_min_attempts(floors): attempts = 0 interval = 1 sum = 0 while sum < floors: attempts += 1 sum += attempts return attempts return calculate_min_attempts(n)"},{"question":"def maxSublistSum(arr): Returns the maximum sum of any non-empty sublist of the given list of integers. >>> maxSublistSum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> maxSublistSum([1]) == 1 >>> maxSublistSum([-1]) == -1 >>> maxSublistSum([-2, -3, -1, -5]) == -1 >>> maxSublistSum([1, 2, 3, 4, 5]) == 15 >>> maxSublistSum([3, -2, 5, -1]) == 6 >>> maxSublistSum([-1, 2, 3, -4, 5, 10]) == 16 >>> maxSublistSum([]) == 0","solution":"def maxSublistSum(arr): Returns the maximum sum of any non-empty sublist of the given list of integers. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def minimum_cost_to_buy_k_diff_priced_candies(n: int, k: int, prices: List[int]) -> int: Determine the minimum cost to buy k different priced candies from a list of candies with given prices. If it's not possible to buy k candies with different prices, return -1. >>> minimum_cost_to_buy_k_diff_priced_candies(7, 3, [5, 1, 3, 3, 2, 4, 1]) 6 >>> minimum_cost_to_buy_k_diff_priced_candies(5, 4, [1, 1, 1, 1, 1]) -1","solution":"def minimum_cost_to_buy_k_diff_priced_candies(n, k, prices): # Get unique prices unique_prices = list(set(prices)) # Check if it's possible to buy k different priced candies if len(unique_prices) < k: return -1 # Sort unique prices to get the minimum k prices unique_prices.sort() # Calculate the sum of the minimum k prices return sum(unique_prices[:k])"},{"question":"from typing import List, Tuple def can_organize_photo_album(t: int, test_cases: List[Tuple[int, int, int, List[int]]]) -> List[str]: Determines if John can organize the photos as described for each test case. Parameters: t (int): number of test cases test_cases (list): list of test cases, each containing n, k, s, and the list of tags Returns: list: results of each test case, \\"YES\\" or \\"NO\\" >>> can_organize_photo_album(2, [(9, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]), (6, 2, 3, [1, 1, 2, 2, 3, 3])]) ['YES', 'NO'] # Unit tests def test_case_1(): t = 2 test_cases = [ (9, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]), (6, 2, 3, [1, 1, 2, 2, 3, 3]) ] assert can_organize_photo_album(t, test_cases) == ['YES', 'NO'] def test_case_2(): t = 1 test_cases = [ (10, 5, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ] assert can_organize_photo_album(t, test_cases) == ['YES'] def test_case_3(): t = 1 test_cases = [ (5, 1, 5, [1, 2, 3, 4, 5]) ] assert can_organize_photo_album(t, test_cases) == ['YES'] def test_case_4(): t = 1 test_cases = [ (4, 2, 3, [1, 2, 1, 2]) ] assert can_organize_photo_album(t, test_cases) == ['NO'] def test_case_5(): t = 1 test_cases = [ (10, 2, 5, [1, 2, 1, 2, 1, 2, 3, 3, 4, 5]) ] assert can_organize_photo_album(t, test_cases) == ['NO']","solution":"def can_organize_photo_album(t, test_cases): Determines if John can organize the photos as described for each test case. Parameters: t (int): number of test cases test_cases (list): list of test cases, each containing n, k, s, and the list of tags Returns: list: results of each test case, \\"YES\\" or \\"NO\\" results = [] for n, k, s, tags in test_cases: if len(set(tags)) >= k * s: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # t = 2 # test_cases = [ # (9, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]), # (6, 2, 3, [1, 1, 2, 2, 3, 3]) # ] # print(can_organize_photo_album(t, test_cases)) # Output: ['YES', 'NO']"},{"question":"from typing import List def shortest_path(grid: List[List[str]]) -> int: Compute the shortest path from top-left to bottom-right corner in the grid avoiding water ('W') and tree ('T') cells. >>> grid1 = [ ... ['L', 'L', 'L', 'W'], ... ['W', 'T', 'L', 'W'], ... ['L', 'L', 'L', 'W'], ... ['W', 'L', 'L', 'L'] ... ] >>> shortest_path(grid1) 6 >>> grid2 = [ ... ['L', 'W'], ... ['W', 'L'] ... ] >>> shortest_path(grid2) -1 >>> grid3 = [ ... ['L'] ... ] >>> shortest_path(grid3) 0 >>> grid4 = [ ... ['L', 'L'], ... ['L', 'L'] ... ] >>> shortest_path(grid4) 2 >>> grid5 = [ ... ['L', 'T', 'L'], ... ['L', 'T', 'L'], ... ['L', 'L', 'L'] ... ] >>> shortest_path(grid5) 4","solution":"from collections import deque def shortest_path(grid): Compute the shortest path from top-left to bottom-right corner in the grid avoiding water ('W') and tree ('T') cells. R, C = len(grid), len(grid[0]) if R == 1 and C == 1: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in visited: if grid[rr][cc] == 'L': if rr == R-1 and cc == C-1: return dist + 1 queue.append((rr, cc, dist + 1)) visited.add((rr, cc)) return -1"},{"question":"class Queue: def __init__(self): Initialize your data structure here. self.in_stack = [] self.out_stack = [] def enqueue(self, element): Add an element to the end of the queue. pass def dequeue(self): Remove and return the element from the front of the queue. If the queue is empty, return None. pass def peek(self): Return the element at the front of the queue without removing it. If the queue is empty, return None. pass def is_empty(self): Return True if the queue is empty, otherwise return False. pass def size(self): Return the number of elements in the queue. pass Unit Test: from solution import Queue def test_enqueue_and_dequeue(): q = Queue() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.dequeue() is None def test_peek(): q = Queue() assert q.peek() is None q.enqueue(1) assert q.peek() == 1 q.enqueue(2) assert q.peek() == 1 q.dequeue() assert q.peek() == 2 def test_is_empty(): q = Queue() assert q.is_empty() is True q.enqueue(1) assert q.is_empty() is False q.dequeue() assert q.is_empty() is True def test_size(): q = Queue() assert q.size() == 0 q.enqueue(1) assert q.size() == 1 q.enqueue(2) assert q.size() == 2 q.dequeue() assert q.size() == 1 q.dequeue() assert q.size() == 0 def test_mix_operations(): q = Queue() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 q.enqueue(4) assert q.peek() == 2 assert q.size() == 3 assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.dequeue() == 4 assert q.dequeue() is None assert q.is_empty() is True assert q.size() == 0","solution":"class Queue: def __init__(self): self.in_stack = [] self.out_stack = [] def enqueue(self, element): Add an element to the end of the queue. self.in_stack.append(element) def dequeue(self): Remove and return the element from the front of the queue. If the queue is empty, return None. if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack.pop() return None def peek(self): Return the element at the front of the queue without removing it. If the queue is empty, return None. if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack[-1] return None def is_empty(self): Return True if the queue is empty, otherwise return False. return not self.in_stack and not self.out_stack def size(self): Return the number of elements in the queue. return len(self.in_stack) + len(self.out_stack)"},{"question":"def generateBinaryStrings(N): Given an integer N, generate all possible binary strings of length N that do not contain consecutive 1s. Return these strings in sorted order. Args: N (int): Length of binary strings Returns: List[str]: List of valid binary strings in sorted order Example: >>> generateBinaryStrings(2) ['00', '01', '10'] >>> generateBinaryStrings(3) ['000', '001', '010', '100', '101'] pass # Unit Test def test_generateBinaryStrings_length_2(): result = generateBinaryStrings(2) expected = ['00', '01', '10'] assert result == expected def test_generateBinaryStrings_length_3(): result = generateBinaryStrings(3) expected = ['000', '001', '010', '100', '101'] assert result == expected def test_generateBinaryStrings_length_1(): result = generateBinaryStrings(1) expected = ['0', '1'] assert result == expected def test_generateBinaryStrings_length_4(): result = generateBinaryStrings(4) expected = ['0000', '0001', '0010', '0100', '0101', '1000', '1001', '1010'] assert result == expected def test_generateBinaryStrings_length_0(): result = generateBinaryStrings(0) expected = [''] assert result == expected def test_generateBinaryStrings_edge_case(): result = generateBinaryStrings(5) expected = [ '00000', '00001', '00010', '00100', '00101', '01000', '01001', '01010', '10000', '10001', '10010', '10100', '10101' ] assert result == expected","solution":"def generateBinaryStrings(N): def isValidBinaryString(binary_string): return '11' not in binary_string def generateAllBinaryStrings(N): if N == 0: return [''] if N == 1: return ['0', '1'] smaller = generateAllBinaryStrings(N - 1) result = [] for binary_str in smaller: result.append(binary_str + '0') if not binary_str.endswith('1'): result.append(binary_str + '1') return sorted(result) return [bs for bs in generateAllBinaryStrings(N) if isValidBinaryString(bs)]"},{"question":"def product_of_others(nums: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list where each integer is replaced with the product of every other integer in the original list. It should be done without using division. >>> product_of_others([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_others([2]) [1] >>> product_of_others([2, 3]) [3, 2] >>> product_of_others([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_of_others([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_of_others([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_of_others([2] * 100000) [2**99999] * 100000","solution":"def product_of_others(nums): Returns a list where each element is the product of all other elements except itself. n = len(nums) if n == 0: return [] # Initialize the result list with 1s result = [1] * n # Multiply elements from the left left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Multiply elements from the right right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def generatePascalTriangle(n): Generates Pascal's Triangle with 'n' number of rows. >>> generatePascalTriangle(5) 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1","solution":"def generatePascalTriangle(n): Generates Pascal's Triangle with 'n' number of rows. triangle = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] triangle.append(row) for row in triangle: print(' '.join(map(str, row)))"},{"question":"def longest_path(grid: List[List[int]]) -> int: Finds the longest path from the top-left to the bottom-right corner of the maze, moving only through cells containing \`1\` and without revisiting any cell. >>> longest_path([ ... [1, 1, 0, 1], ... [0, 1, 1, 0], ... [1, 0, 1, 1], ... [1, 1, 1, 1] ... ]) 7 >>> longest_path([ ... [1, 0, 1], ... [1, 1, 0], ... [0, 1, 1] ... ]) 5 >>> longest_path([ ... [1, 0, 0], ... [0, 0, 1], ... [1, 1, 1] ... ]) -1 >>> longest_path([ ... [0, 1, 0], ... [0, 1, 0], ... [1, 1, 1] ... ]) -1 >>> longest_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) -1 >>> longest_path([ ... [1] ... ]) 1 >>> longest_path([ ... [1, 1], ... [1, 1] ... ]) 3","solution":"def longest_path(grid): Finds the longest path from the top-left to the bottom-right corner of the maze, moving only through cells containing \`1\` and without revisiting any cell. n = len(grid) m = len(grid[0]) if grid[0][0] == 0 or grid[n-1][m-1] == 0: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def dfs(x, y, visited): if x == n - 1 and y == m - 1: return 1 max_length = 0 visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1 and (nx, ny) not in visited: path_length = dfs(nx, ny, visited) if path_length != -1: max_length = max(max_length, path_length + 1) visited.remove((x, y)) return max_length if max_length != 0 else -1 result = dfs(0, 0, set()) return result # Function signature adapted to match the outputs of the example inputs"},{"question":"def max_sum_of_three_consecutive(heights: List[int]) -> int: Given a list of integers representing the heights of people standing in a line, this function calculates the maximum sum of heights of any three consecutive people in the line. In case there are fewer than three people, the function returns the sum of all their heights. >>> max_sum_of_three_consecutive([1, 2, 3, 4, 5]) == 12 >>> max_sum_of_three_consecutive([10, 20]) == 30","solution":"def max_sum_of_three_consecutive(heights): Returns the maximum sum of heights of any three consecutive people in the list, or the sum of all heights if the list has fewer than three elements. n = len(heights) if n < 3: return sum(heights) max_sum = 0 for i in range(n - 2): current_sum = sum(heights[i:i + 3]) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def extract_vowels_consonants(s: str) -> (str, str): Extracts and returns the vowels and consonants from a given string separately. Args: s (str): The input string which may contain letters, spaces, and punctuation. Returns: (str, str): A tuple containing two strings, the first with vowels and the second with consonants. Examples: >>> extract_vowels_consonants(\\"Hello, World!\\") == (\\"eoo\\", \\"HllWrld\\") >>> extract_vowels_consonants(\\"Programming\\") == (\\"oai\\", \\"Prgrmmng\\") >>> extract_vowels_consonants(\\"bcdfg\\") == (\\"\\", \\"bcdfg\\") >>> extract_vowels_consonants(\\"aeiou\\") == (\\"aeiou\\", \\"\\") >>> extract_vowels_consonants(\\"a.e.i.o.u!\\") == (\\"aeiou\\", \\"\\") >>> extract_vowels_consonants(\\"HELLO\\") == (\\"EO\\", \\"HLL\\") >>> extract_vowels_consonants(\\" \\") == (\\"\\", \\"\\") >>> extract_vowels_consonants(\\"\\") == (\\"\\", \\"\\") >>> extract_vowels_consonants(\\"123!@#\\") == (\\"\\", \\"\\")","solution":"def extract_vowels_consonants(s: str) -> (str, str): Extracts and returns the vowels and consonants from a given string separately. Args: s (str): The input string which may contain letters, spaces, and punctuation. Returns: (str, str): A tuple containing two strings, the first with vowels and the second with consonants. vowels = \\"aeiouAEIOU\\" vowel_str = \\"\\" consonant_str = \\"\\" for char in s: if char.isalpha(): if char in vowels: vowel_str += char else: consonant_str += char return (vowel_str, consonant_str)"},{"question":"def vacuum_position(commands): Processes a list of commands to control a robotic vacuum cleaner and returns its final position. Args: commands (list of str): A list of commands where each command is one of 'UP', 'DOWN', 'LEFT', 'RIGHT'. Returns: tuple: A tuple (x, y) representing the final position of the vacuum cleaner. >>> vacuum_position([]) == (0, 0) >>> vacuum_position(['UP']) == (0, 1) >>> vacuum_position(['DOWN']) == (0, -1) >>> vacuum_position(['LEFT']) == (-1, 0) >>> vacuum_position(['RIGHT']) == (1, 0) >>> vacuum_position(['UP', 'UP', 'LEFT', 'DOWN', 'RIGHT']) == (0, 1) >>> vacuum_position(['RIGHT', 'RIGHT', 'UP', 'UP', 'LEFT']) == (1, 2)","solution":"def vacuum_position(commands): Processes a list of commands to control a robotic vacuum cleaner and returns its final position. Args: commands (list of str): A list of commands where each command is one of 'UP', 'DOWN', 'LEFT', 'RIGHT'. Returns: tuple: A tuple (x, y) representing the final position of the vacuum cleaner. x, y = 0, 0 for command in commands: if command == 'UP': y += 1 elif command == 'DOWN': y -= 1 elif command == 'LEFT': x -= 1 elif command == 'RIGHT': x += 1 return (x, y)"},{"question":"from typing import List, Tuple MOD = 10**9 + 7 def count_topological_sorts(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the number of valid topological sorting of tasks in a DAG. Args: n (int): The number of tasks (nodes). edges (List[Tuple[int, int]]): A list of directed edges, where each edge is represented as a tuple (u, v). Returns: int: The number of valid topological orderings of the nodes, modulo 10^9+7. >>> count_topological_sorts(3, [(1, 2), (1, 3)]) 2 >>> count_topological_sorts(4, [(1, 2), (2, 3), (3, 4)]) 1 def solve_topological_sort_cases(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Solve multiple test cases for counting topological sorts. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int,int]]]]): A list of test cases, where each test case is represented as a tuple containing the number of tasks, the number of edges, and the list of edges. Returns: List[int]: A list of results for each test case, representing the number of valid topological orderings modulo 10^9+7. >>> T = 2 >>> test_cases = [ ... (3, 2, [(1, 2), (1, 3)]), ... (4, 3, [(1, 2), (2, 3), (3, 4)]) ... ] >>> solve_topological_sort_cases(T, test_cases) [2, 1] def test_count_topological_sorts_case_1(): edges = [(1, 2), (1, 3)] assert count_topological_sorts(3, edges) == 2 def test_count_topological_sorts_case_2(): edges = [(1, 2), (2, 3), (3, 4)] assert count_topological_sorts(4, edges) == 1 def test_count_topological_sorts_case_3(): edges = [] assert count_topological_sorts(3, edges) == 6 # 3! = 6 def test_solve_topological_sort_cases_sample(): T = 2 test_cases = [ (3, 2, [(1, 2), (1, 3)]), (4, 3, [(1, 2), (2, 3), (3, 4)]) ] assert solve_topological_sort_cases(T, test_cases) == [2, 1] def test_no_dependencies_given(): T = 1 test_cases = [ (2, 0, []) ] assert solve_topological_sort_cases(T, test_cases) == [2] def test_single_node(): T = 1 test_cases = [ (1, 0, []) ] assert solve_topological_sort_cases(T, test_cases) == [1] def test_two_nodes_one_dependency(): T = 1 test_cases = [ (2, 1, [(1, 2)]) ] assert solve_topological_sort_cases(T, test_cases) == [1]","solution":"def count_topological_sorts(n, edges): MOD = 10**9 + 7 from itertools import permutations def is_valid_topo_sort(order): pos = {order[i]: i for i in range(n)} for u, v in edges: if pos[u] >= pos[v]: return False return True nodes = list(range(1, n + 1)) valid_sorts = 0 for perm in permutations(nodes): if is_valid_topo_sort(perm): valid_sorts += 1 return valid_sorts % MOD def solve_topological_sort_cases(T, test_cases): results = [] for n, m, edges in test_cases: result = count_topological_sorts(n, edges) results.append(result) return results"},{"question":"def valid_ipv4_address(ip: str) -> str: Determines whether an input string is a valid IPv4 address. >>> valid_ipv4_address(\\"192.168.0.1\\") \\"Valid\\" >>> valid_ipv4_address(\\"255.255.255.255\\") \\"Valid\\" >>> valid_ipv4_address(\\"256.100.100.100\\") \\"Invalid\\" >>> valid_ipv4_address(\\"192.168.1\\") \\"Invalid\\" >>> valid_ipv4_address(\\"192.168.0.256\\") \\"Invalid\\" >>> valid_ipv4_address(\\"192.168.0.-1\\") \\"Invalid\\" >>> valid_ipv4_address(\\"192.168.0.01\\") \\"Valid\\" # Leading zeros are allowed def process_ip_addresses(T: int, ip_list: List[str]) -> List[str]: Processes a list of IP addresses. Args: T: int : Number of test cases ip_list: list of str : List of IP addresses Returns: list of str : List of results indicating whether each IP address is valid or invalid. >>> process_ip_addresses(3, [\\"192.168.0.1\\", \\"255.255.255.255\\", \\"256.100.100.100\\"]) [\\"Valid\\", \\"Valid\\", \\"Invalid\\"] >>> process_ip_addresses(1, [\\"192.168.1.\\"]) [\\"Invalid\\"] >>> process_ip_addresses(2, [\\"192.168.0.256\\", \\"0.0.0.0\\"]) [\\"Invalid\\", \\"Valid\\"]","solution":"def valid_ipv4_address(ip): Determines whether an input string is a valid IPv4 address. parts = ip.split(\\".\\") if len(parts) != 4: return \\"Invalid\\" for part in parts: if not part.isdigit() or not 0 <= int(part) <= 255: return \\"Invalid\\" return \\"Valid\\" def process_ip_addresses(T, ip_list): Processes a list of IP addresses. T: int : Number of test cases ip_list: list of str : List of IP addresses results = [] for ip in ip_list: results.append(valid_ipv4_address(ip)) return results"},{"question":"def generate_activation_codes(number_of_codes: int) -> List[str]: Generates a list of unique alpha-numeric activation codes in lexicographical order. The codes consist of two capital letters followed by two digits (e.g., AA00). Parameters: number_of_codes (int): The number of unique activation codes to generate Returns: list: A list of unique activation codes >>> generate_activation_codes(5) [\\"AA00\\", \\"AA01\\", \\"AA02\\", \\"AA03\\", \\"AA04\\"]","solution":"def generate_activation_codes(number_of_codes): Generates a list of unique alpha-numeric activation codes in lexicographical order. The codes consist of two capital letters followed by two digits (e.g., AA00). Parameters: number_of_codes (int): The number of unique activation codes to generate Returns: list: A list of unique activation codes codes = [] letters = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" for i in range(26): for j in range(26): for k in range(100): if len(codes) < number_of_codes: code = f\\"{letters[i]}{letters[j]}{k:02d}\\" codes.append(code) else: return codes return codes"},{"question":"def max_subarray_sum(nums): Find the contiguous subarray (containing at least one number) which has the largest sum and return that sum. >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. :param nums: List of integers :return: Integer representing the largest sum of contiguous subarray if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Function to read input from standard input, useful for competitive programming def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:n+1])) print(max_subarray_sum(nums)) # To allow for testing and local execution if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def most_frequent_sequence(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Identify the most frequently played unique sequence of k consecutive tracks within each users listening history. >>> most_frequent_sequence(1, [(2, 'ababcabcab')]) ['ab'] >>> most_frequent_sequence(1, [(3, 'zzzaaabbbcccaaazzzo')]) ['aaa'] >>> most_frequent_sequence(1, [(4, 'aaaaaaa')]) ['aaaa']","solution":"from collections import defaultdict def most_frequent_sequence(t, test_cases): results = [] for k, tracks in test_cases: sequence_count = defaultdict(int) # Calculate frequencies of each k-length sequence for i in range(len(tracks) - k + 1): sequence = tracks[i:i+k] sequence_count[sequence] += 1 # Find the sequence with the highest frequency and lexicographically smallest max_frequency = 0 result_sequence = \\"\\" for sequence, count in sequence_count.items(): if count > max_frequency or (count == max_frequency and sequence < result_sequence): max_frequency = count result_sequence = sequence results.append(result_sequence) return results # Example usage: # test_cases = [(2, 'ababcabcab'), (3, 'zzzaaabbbcccaaazzzo'), (4, 'aaaaaaa')] # print(most_frequent_sequence(3, test_cases))"},{"question":"from typing import List def max_moves(grid: List[List[int]]) -> int: Determines the maximum number of moves Alice can make to reach from the top-left corner to the bottom-right corner of the grid. If it's impossible to reach the destination, returns -1. Args: grid (List[List[int]]): 2D grid where 0 represents free cell and 1 represents blocked cell. Returns: int: Maximum number of moves to reach from (0, 0) to (n-1, m-1) or -1 if impossible. >>> max_moves([[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0]]) 6 >>> max_moves([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1","solution":"from collections import deque def max_moves(grid): Returns the maximum number of moves Alice can make to reach from the top-left corner to the bottom-right corner of the grid. If it's impossible to reach the destination, returns -1. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == n - 1 and c == m - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"from typing import List def can_form_arithmetic_progression(arr: List[int]) -> str: Determine if it is possible to form a valid arithmetic progression subset from the array. >>> can_form_arithmetic_progression([4, 8, 6, 2, 10, 4]) 'YES' >>> can_form_arithmetic_progression([10, 5, 20, 15]) 'YES' >>> can_form_arithmetic_progression([10, 12, 15]) 'NO'","solution":"def can_form_arithmetic_progression(arr): # Turn the list into a set to remove duplicates and then sort it arr = sorted(set(arr)) # If the length of the set is less than 2, we cannot form an arithmetic progression if len(arr) < 2: return \\"NO\\" # Check for any common difference d for i in range(len(arr) - 1): d = arr[i+1] - arr[i] # Form a new list based on the first element and difference d ap_set = set(arr[i] + j*d for j in range(len(arr))) # If the entire set is a subset of the original set, it's an AP if ap_set.issubset(set(arr)): return \\"YES\\" return \\"NO\\" # Read input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) array = list(map(int, data[1:N+1])) result = can_form_arithmetic_progression(array) print(result)"},{"question":"def longest_arithmetic_progression(n: int) -> int: Returns the length of the longest arithmetic progression that can be formed using integers from 1 to n inclusive. >>> longest_arithmetic_progression(9) == 9 >>> longest_arithmetic_progression(7) == 7 >>> longest_arithmetic_progression(14) == 14 >>> longest_arithmetic_progression(1) == 1 >>> longest_arithmetic_progression(100000) == 100000","solution":"def longest_arithmetic_progression(n): Returns the length of the longest arithmetic progression that can be formed using integers from 1 to n inclusive. return n"},{"question":"def find_equilibrium_points(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the first (leftmost) equilibrium point in the array for each test case. The equilibrium point in an array is a position such that the sum of elements before it is equal to the sum of elements after it. If no such point exists, return -1 for that test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple consists of an integer n (number of elements in the array) and a list of n integers representing the array. Returns: List[int]: A list containing the position of the first equilibrium point for each test case (1-indexed). If no such point exists, return -1. >>> find_equilibrium_points(2, [(5, [1, 3, 5, 2, 2]), (4, [1, 2, 3, 4])]) [3, -1] >>> find_equilibrium_points(1, [(1, [1])]) [1]","solution":"def find_equilibrium_points(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] arr = test_cases[i][1] total_sum = sum(arr) left_sum = 0 found = False for j in range(n): total_sum -= arr[j] if left_sum == total_sum: results.append(j + 1) found = True break left_sum += arr[j] if not found: results.append(-1) return results"},{"question":"def count_filled_cells(m, n, operations): Determines the number of cells filled with 1 after performing all the operations. Each operation is represented by a pair (x, y) that fills all rows up to x and columns up to y. Args: m (int): Number of rows in the grid n (int): Number of columns in the grid operations (List[Tuple[int, int]]): List of operations Returns: int: Number of filled cells after performing all the operations >>> count_filled_cells(3, 3, [(2, 2)]) 4 >>> count_filled_cells(3, 3, [(2, 2), (3, 1)]) 2 >>> count_filled_cells(3, 3, [(3, 3)]) 9 >>> count_filled_cells(5, 6, [(4, 3), (2, 6), (5, 1)]) 2 >>> count_filled_cells(1, 1, [(1, 1)]) 1 >>> count_filled_cells(3, 3, [(1, 1), (3, 3)]) 1","solution":"def count_filled_cells(m, n, operations): Returns the number of cells filled with 1 after performing all the operations. Each operation is represented by a pair (x, y) that fills all rows up to x and columns up to y. if not operations: return 0 min_x = m min_y = n for x, y in operations: min_x = min(min_x, x) min_y = min(min_y, y) return min_x * min_y"},{"question":"def final_height_of_plants(N: int, M: int, plants: list) -> list: Returns the final height of each plant after M months. :param N: Number of plants in the garden :param M: Number of months :param plants: List of tuples where each tuple contains the initial height (H) and growth rate (G) of a plant :return: List of final heights of each plant after M months pass # Unit tests def test_sample_input_1(): N = 3 M = 2 plants = [(10, 5), (15, 3), (20, 2)] assert final_height_of_plants(N, M, plants) == [20, 21, 24] def test_sample_input_2(): N = 2 M = 3 plants = [(30, 4), (50, 1)] assert final_height_of_plants(N, M, plants) == [42, 53] def test_single_plant(): N = 1 M = 5 plants = [(5, 2)] assert final_height_of_plants(N, M, plants) == [15] def test_no_growth(): N = 2 M = 3 plants = [(7, 0), (12, 0)] assert final_height_of_plants(N, M, plants) == [7, 12] def test_maximum_growth(): N = 1 M = 100 plants = [(1000, 100)] assert final_height_of_plants(N, M, plants) == [11000] def test_maximum_input_ranges(): N = 100 M = 100 plants = [(i + 1, 100) for i in range(100)] assert final_height_of_plants(N, M, plants) == [(i + 1) + 10000 for i in range(100)]","solution":"def final_height_of_plants(N, M, plants): Returns the final height of each plant after M months. :param N: Number of plants in the garden :param M: Number of months :param plants: List of tuples where each tuple contains the initial height (H) and growth rate (G) of a plant :return: List of final heights of each plant after M months final_heights = [] for H, G in plants: final_height = H + M * G final_heights.append(final_height) return final_heights # Function to read input and produce output as mentioned in the problem statement def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) plants = [(int(data[2 + i * 2]), int(data[3 + i * 2])) for i in range(N)] results = final_height_of_plants(N, M, plants) for result in results: print(result)"},{"question":"def max_consecutive_plants(n: int, plants: List[Tuple[str, str]]) -> int: Determine the largest number of consecutive plants that grow in the same season. >>> max_consecutive_plants(5, [('Rose', 'spring'), ('Tulip', 'spring'), ('Sunflower', 'summer'), ('Daisy', 'spring'), ('Lily', 'spring')]) 2 >>> max_consecutive_plants(4, [('Fern', 'winter'), ('Pine', 'winter'), ('Cactus', 'summer'), ('Oak', 'winter')]) 2 >>> max_consecutive_plants(6, [('Peony', 'summer'), ('Daffodil', 'spring'), ('Carnation', 'spring'), ('Geranium', 'summer'), ('Marigold', 'summer'), ('Lavender', 'summer')]) 3","solution":"from typing import List, Tuple def max_consecutive_plants(n: int, plants: List[Tuple[str, str]]) -> int: # Handle edge case where no plants exist if n == 0: return 0 max_count = 1 current_count = 1 prev_season = plants[0][1] for i in range(1, n): species, season = plants[i] if season == prev_season: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 prev_season = season return max_count"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given non-negative integer. :param n: A non-negative integer :return: Sum of the digits of the given number >>> sum_of_digits(1234) 10 >>> sum_of_digits(0) 0 >>> sum_of_digits(5) 5 >>> sum_of_digits(9876) 30 >>> sum_of_digits(1111) 4","solution":"def sum_of_digits(n): Returns the sum of the digits of a given non-negative integer. :param n: A non-negative integer :return: Sum of the digits of the given number return sum(int(digit) for digit in str(n))"},{"question":"from typing import List, Tuple def is_k_diverse(n: int, k: int, arr: List[int]) -> bool: Determines if the given array is k-diverse. :param n: int - Number of elements in the array :param k: int - The value for k-diversity :param arr: List[int] - The array of integers :return: bool - True if the array is k-diverse, False otherwise >>> is_k_diverse(3, 3, [1, 4, 3]) True >>> is_k_diverse(4, 2, [7, 12, 10, 8]) False >>> is_k_diverse(5, 0, [5, 5, 5, 5, 5]) True def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases to determine if arrays are k-diverse. :param t: int - Number of test cases :param test_cases: List[Tuple[int, int, List[int]]] - List of test case parameters :return: List[str] - List containing \\"YES\\" or \\"NO\\" for each test case >>> process_test_cases(3, [(3, 3, [1, 4, 3]), (4, 2, [7, 12, 10, 8]), (5, 0, [5, 5, 5, 5, 5])]) ['YES', 'NO', 'YES'] >>> process_test_cases(2, [(2, 1, [5, 6]), (2, 0, [1, 1])]) ['YES', 'YES']","solution":"def is_k_diverse(n, k, arr): Returns whether the array is k-diverse or not min_val = min(arr) max_val = max(arr) return max_val - min_val <= k def process_test_cases(t, test_cases): results = [] for tc in test_cases: n, k, arr = tc if is_k_diverse(n, k, arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def reverse_spells(spell_string: str) -> str: Takes a string of space-separated spell names and returns them in reverse order. Parameters: spell_string (str): A string containing spell names separated by spaces. Returns: str: A string containing spell names in reverse order. Examples: >>> reverse_spells(\\"lightning fireball frost nova\\") 'nova frost fireball lightning' >>> reverse_spells(\\"fireball frost\\") 'frost fireball' >>> reverse_spells(\\"abracadabra alakazam hocuspocus\\") 'hocuspocus alakazam abracadabra'","solution":"def reverse_spells(spell_string): Takes a string of space-separated spell names and returns them in reverse order. Parameters: spell_string (str): A string containing spell names separated by spaces. Returns: str: A string containing spell names in reverse order. spells = spell_string.split() reversed_spells = spells[::-1] return ' '.join(reversed_spells)"},{"question":"from typing import List, Tuple def process_updates(n: int, updates: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Returns the current state of the database showing the user ID and their most recent activity timestamp. :param n: int: Number of updates :param updates: list of tuples: Each tuple contains a user ID (integer) and a timestamp (string) :return: list of tuples: Each tuple contains a user ID and their most recent activity timestamp >>> process_updates(5, [(123, \\"2023-02-15 08:45:00\\"), (456, \\"2023-02-15 09:00:00\\"), (123, \\"2023-02-15 09:30:00\\"), (789, \\"2023-02-15 10:00:00\\"), (456, \\"2023-02-15 09:15:00\\")]) [(123, \\"2023-02-15 09:30:00\\"), (456, \\"2023-02-15 09:15:00\\"), (789, \\"2023-02-15 10:00:00\\")] >>> process_updates(4, [(1000, \\"2021-12-31 23:59:59\\"), (999, \\"2022-01-01 00:00:00\\"), (1000, \\"2022-01-01 01:00:00\\"), (500, \\"2022-01-01 02:00:00\\")]) [(500, \\"2022-01-01 02:00:00\\"), (999, \\"2022-01-01 00:00:00\\"), (1000, \\"2022-01-01 01:00:00\\")]","solution":"def process_updates(n, updates): Returns the current state of the database showing the user ID and their most recent activity timestamp. :param n: int: Number of updates :param updates: list of tuples: Each tuple contains a user ID (integer) and a timestamp (string) :return: list of tuples: Each tuple contains a user ID and their most recent activity timestamp # Initialize a dictionary to hold the latest timestamp for each user ID user_activity = {} for user_id, timestamp in updates: if user_id not in user_activity or user_activity[user_id] < timestamp: user_activity[user_id] = timestamp # Convert the dictionary to a sorted list of tuples sorted_activity = sorted(user_activity.items()) return sorted_activity # Example usage updates = [ (123, \\"2023-02-15 08:45:00\\"), (456, \\"2023-02-15 09:00:00\\"), (123, \\"2023-02-15 09:30:00\\"), (789, \\"2023-02-15 10:00:00\\"), (456, \\"2023-02-15 09:15:00\\") ] print(process_updates(5, updates))"},{"question":"from typing import List, Tuple def is_path_exists(n: int, m: int, q: int, grid: List[str], operations: List[Tuple[int, int]]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner of the maze after applying the operations. >>> is_path_exists(4, 4, 2, [\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"], [(1, 3), (3, 4)]) == \\"YES\\" >>> is_path_exists(3, 3, 1, [\\".#.\\", \\".#.\\", \\"..#\\"], [(2, 3)]) == \\"NO\\" def test_is_path_exists_sample_1(): n, m, q = 4, 4, 2 grid = [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ] operations = [(1, 3), (3, 4)] assert is_path_exists(n, m, q, grid, operations) == \\"YES\\" def test_is_path_exists_sample_2(): n, m, q = 3, 3, 1 grid = [ \\".#.\\", \\".#.\\", \\"..#\\" ] operations = [(2, 3)] assert is_path_exists(n, m, q, grid, operations) == \\"NO\\" def test_empty_path(): n, m, q = 3, 3, 0 grid = [ \\"...\\", \\"...\\", \\"...\\" ] operations = [] assert is_path_exists(n, m, q, grid, operations) == \\"YES\\" def test_no_path_possible(): n, m, q = 3, 3, 0 grid = [ \\".#.\\", \\"#.#\\", \\"#..\\" ] operations = [] assert is_path_exists(n, m, q, grid, operations) == \\"NO\\" def test_single_swap_leads_to_path(): n, m, q = 5, 5, 1 grid = [ \\".....\\", \\"#.#.#\\", \\"#.#.#\\", \\"#.#.#\\", \\".....\\" ] operations = [(1, 5)] assert is_path_exists(n, m, q, grid, operations) == \\"YES\\" def test_multiple_operations(): n, m, q = 4, 4, 3 grid = [ \\".#..\\", \\"...#\\", \\"#...\\", \\"..#.\\" ] operations = [(1, 3), (2, 4), (1, 4)] assert is_path_exists(n, m, q, grid, operations) == \\"NO\\"","solution":"from collections import deque def can_escape(grid, n, m): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) # Start from the top-left corner while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: # Reach the bottom-right corner return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return False def is_path_exists(n, m, q, grid, operations): for x, y in operations: grid[x-1], grid[y-1] = grid[y-1], grid[x-1] # Adjust for 0-indexing return \\"YES\\" if can_escape(grid, n, m) else \\"NO\\""},{"question":"def max_sum_of_k_books(pages, k): Calculates the maximum sum of k continuous books' pages from the given list of pages. pass # Implementation here def process_queries(n, q, pages, queries): Given the number of books, number of queries, pages list of books and a list of queries, returns the results for each query. pass # Implementation here # Test cases def test_max_sum_of_k_books_single(): assert max_sum_of_k_books([1, 2, 3, 4, 5], 1) == 5 assert max_sum_of_k_books([5, 2, 3, 7, 9], 1) == 9 def test_max_sum_of_k_books_multiple(): assert max_sum_of_k_books([1, 2, 3, 4, 5], 3) == 12 assert max_sum_of_k_books([5, 2, 3, 7, 9], 3) == 19 def test_max_sum_of_k_books_all(): assert max_sum_of_k_books([1, 2, 3, 4, 5], 5) == 15 assert max_sum_of_k_books([5, 2, 3, 7, 9], 5) == 26 def test_process_queries(): assert process_queries(5, 3, [1, 2, 3, 4, 5], [1, 3, 5]) == [5, 12, 15] assert process_queries(5, 2, [5, 2, 3, 7, 9], [2, 5]) == [16, 26] assert process_queries(3, 1, [10, 20, 30], [2]) == [50] def test_edge_cases(): assert process_queries(1, 1, [10], [1]) == [10] assert process_queries(2, 2, [1, 10], [1, 2]) == [10, 11]","solution":"def max_sum_of_k_books(pages, k): Calculates the maximum sum of k continuous books' pages from the given list of pages. n = len(pages) # Initial window sum of the first 'k' elements curr_sum = sum(pages[:k]) max_sum = curr_sum # Sliding window approach to find the maximum sum of 'k' continuous books for i in range(k, n): curr_sum += pages[i] - pages[i - k] max_sum = max(max_sum, curr_sum) return max_sum def process_queries(n, q, pages, queries): Given the number of books, number of queries, pages list of books and a list of queries, returns the results for each query. results = [] for k in queries: results.append(max_sum_of_k_books(pages, k)) return results"},{"question":"def next_customer(ticket_numbers): Given a list of ticket numbers representing the queue order, this function returns the ticket number of the customer who will be served next. If all tickets are cancelled, returns -1. >>> next_customer([1, 2, -1, 4, 5]) 1 >>> next_customer([-1, 2, 3, -1]) 2 >>> next_customer([-1, -1, -1]) -1 >>> next_customer([1, -1, -1, -1, 5, 6]) 1","solution":"def next_customer(ticket_numbers): Given a list of ticket numbers representing the queue order, this function returns the ticket number of the customer who will be served next. If all tickets are cancelled, returns -1. for ticket in ticket_numbers: if ticket != -1: return ticket return -1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Partitions the linked list around value x, such that all nodes less than x come first, followed by nodes with value x, followed by nodes greater than x. pass # Unit tests import pytest def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(elements): dummy = ListNode() current = dummy for el in elements: current.next = ListNode(el) current = current.next return dummy.next def test_partition(): head = list_to_linked_list([1, 4, 3, 2, 5, 2]) x = 3 new_head = partition(head, x) assert linked_list_to_list(new_head) == [1, 2, 2, 3, 4, 5] def test_partition_single_element(): head = list_to_linked_list([1]) x = 0 new_head = partition(head, x) assert linked_list_to_list(new_head) == [1] def test_partition_all_less(): head = list_to_linked_list([1, 2, 3, 0, 2]) x = 4 new_head = partition(head, x) assert linked_list_to_list(new_head) == [1, 2, 3, 0, 2] def test_partition_all_greater(): head = list_to_linked_list([6, 5, 7, 8, 9]) x = 4 new_head = partition(head, x) assert linked_list_to_list(new_head) == [6, 5, 7, 8, 9] def test_partition_mixed(): head = list_to_linked_list([6, 5, 2, 3, 4]) x = 4 new_head = partition(head, x) assert linked_list_to_list(new_head) == [2, 3, 4, 6, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Partitions the linked list around value x, such that all nodes less than x come first, followed by nodes with value x, followed by nodes greater than x. # Create dummy heads for three lists: less, equal, and greater less_head = ListNode(0) equal_head = ListNode(0) greater_head = ListNode(0) # Pointers to build the new lists less = less_head equal = equal_head greater = greater_head # Traverse the original list current = head while current: if current.val < x: less.next = current less = less.next elif current.val == x: equal.next = current equal = equal.next else: greater.next = current greater = greater.next current = current.next # Connect the three lists greater.next = None # Terminate the greater list equal.next = greater_head.next # Connect equal to greater list less.next = equal_head.next # Connect less to equal list return less_head.next # The head of the partitioned list"},{"question":"def can_split_into_equal_sum_subarrays(n, arr): Determines if the array can be split into two non-empty subarrays with equal sums. :param n: The size of the array. :param arr: List of integers, the elements of the array. :return: 'YES' if the array can be split into two non-empty subarrays with equal sums, 'NO' otherwise. >>> can_split_into_equal_sum_subarrays(6, [1, 2, 3, 4, 5, 5]) \\"YES\\" >>> can_split_into_equal_sum_subarrays(4, [1, 2, 3, 5]) \\"NO\\"","solution":"def can_split_into_equal_sum_subarrays(n, arr): Determines if the array can be split into two non-empty subarrays with equal sums. :param n: The size of the array. :param arr: List of integers, the elements of the array. :return: 'YES' if the array can be split into two non-empty subarrays with equal sums, 'NO' otherwise. total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" half_sum = total_sum // 2 current_sum = 0 for x in arr: current_sum += x if current_sum == half_sum: return \\"YES\\" return \\"NO\\" # Example usage: # print(can_split_into_equal_sum_subarrays(6, [1, 2, 3, 4, 5, 5])) # Output: \\"YES\\" # print(can_split_into_equal_sum_subarrays(4, [1, 2, 3, 5])) # Output: \\"NO\\""},{"question":"def generate_primes(n: int) -> list: Return a list of the first 'n' prime numbers. >>> generate_primes(1) [2] >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> generate_primes(0) [] >>> generate_primes(-5) [] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]","solution":"def generate_primes(n: int) -> list: Return a list of the first 'n' prime numbers. if n <= 0: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for prime in primes: if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes"},{"question":"def max_sum_path(matrix: List[List[int]]) -> int: Find the maximum sum of values you can collect by starting at the top-left corner of the matrix and reaching the bottom-right corner, only moving right or down. >>> max_sum_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_sum_path([ ... [1, 2], ... [1, 1] ... ]) == 4 >>> max_sum_path([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 73 pass","solution":"def max_sum_path(matrix): n = len(matrix) dp = [[0] * n for _ in range(n)] dp[0][0] = matrix[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] dp[0][i] = dp[0][i-1] + matrix[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[n-1][n-1]"},{"question":"import heapq from typing import List, Tuple def min_cost_path(n: int, m: int, grid: List[List[int]], sx: int, sy: int, tx: int, ty: int) -> int: Computes the minimum cost to travel from (sx, sy) to (tx, ty) in a grid. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[List[int]]): The grid where each cell contains a positive integer representing the elevation. sx (int): The starting row (1-based index). sy (int): The starting column (1-based index). tx (int): The target row (1-based index). ty (int): The target column (1-based index). Returns: int: The minimum cost to travel from (sx, sy) to (tx, ty). Examples: >>> grid = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> min_cost_path(3, 3, grid, 1, 1, 3, 3) 4 >>> grid = [ ... [1, 1000], ... [1000, 1] ... ] >>> min_cost_path(2, 2, grid, 1, 1, 2, 2) 1998 pass # A wrapper function to help with input format for testing convenience. def solve(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: n = len(grid) m = len(grid[0]) sx, sy = start tx, ty = end return min_cost_path(n, m, grid, sx, sy, tx, ty) # Unit tests def test_example_1(): grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] start = (1, 1) end = (3, 3) assert solve(grid, start, end) == 4 def test_example_2(): grid = [ [1, 1000], [1000, 1] ] start = (1, 1) end = (2, 2) assert solve(grid, start, end) == 1998 def test_with_same_start_and_end(): grid = [ [1, 2], [3, 4] ] start = (1, 1) end = (1, 1) assert solve(grid, start, end) == 0 def test_larger_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] start = (1, 1) end = (3, 3) assert solve(grid, start, end) == 8 def test_grid_with_identical_elevations(): grid = [ [2, 2], [2, 2] ] start = (1, 1) end = (2, 2) assert solve(grid, start, end) == 0","solution":"import heapq def min_cost_path(n, m, grid, sx, sy, tx, ty): Computes the minimum cost to travel from (sx, sy) to (tx, ty) in a grid. directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] cost = [[float('inf')] * m for _ in range(n)] cost[sx-1][sy-1] = 0 pq = [(0, sx-1, sy-1)] while pq: current_cost, x, y = heapq.heappop(pq) if x == tx-1 and y == ty-1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = current_cost + abs(grid[nx][ny] - grid[x][y]) if new_cost < cost[nx][ny]: cost[nx][ny] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) return cost[tx-1][ty-1] # A wrapper function to help with input format for testing convenience. def solve(grid_data, start, end): n = len(grid_data) m = len(grid_data[0]) sx, sy = start tx, ty = end return min_cost_path(n, m, grid_data, sx, sy, tx, ty)"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def maxPathSum(root): Calculate the maximum path sum for a binary tree where the path can start and end at any node. >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(3) >>> node4 = TreeNode(4) >>> node5 = TreeNode(-1) >>> node1.left = node2 >>> node1.right = node3 >>> node3.left = node4 >>> node3.right = node5 >>> maxPathSum(node1) # Example 1 10 >>> node1 = TreeNode(-2) >>> node2 = TreeNode(-3) >>> node3 = TreeNode(4) >>> node1.left = node2 >>> node1.right = node3 >>> maxPathSum(node1) # Example 2 4","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def maxPathSum(root): def dfs(node): nonlocal max_sum if node is None: return 0 # Maximum sum on the left and right subtrees of node, considering non-negative sums left_max = max(dfs(node.left), 0) right_max = max(dfs(node.right), 0) # Path sum that passes through the node current_path_sum = node.val + left_max + right_max # Update the global max_sum if the current_path_sum is greater max_sum = max(max_sum, current_path_sum) # Return the maximum sum of a path that can include the current node return node.val + max(left_max, right_max) max_sum = float('-inf') dfs(root) return max_sum"},{"question":"def transformString(s: str) -> str: Transforms the string such that each character is followed by its frequency. >>> transformString(\\"aabbcc\\") == \\"a2b2c2\\" >>> transformString(\\"abbccc\\") == \\"a1b2c3\\" >>> transformString(\\"abc\\") == \\"a1b1c1\\" >>> transformString(\\"aaaa\\") == \\"a4\\" >>> transformString(\\"a\\") == \\"a1\\" >>> transformString(\\"abcabc\\") == \\"a2b2c2\\" >>> transformString(\\"aabbcccc\\") == \\"a2b2c4\\"","solution":"def transformString(s): Transforms the string such that each character is followed by its frequency. from collections import Counter frequency = Counter(s) result = [] for char in s: if char not in result: result.append(char) result.append(str(frequency[char])) return ''.join(result)"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the string \`s\` to the right \`n\` times. >>> rotate_string(\\"hello\\", 2) \\"lohel\\" >>> rotate_string(\\"abcdef\\", 4) \\"cdefab\\" >>> rotate_string(\\"abcdef\\", 6) \\"abcdef\\"","solution":"def rotate_string(s, n): Rotates string s to the right by n times. If n is greater than the length of the string, it will be reduced to n % len(s). if not s: return s length = len(s) n = n % length return s[-n:] + s[:-n]"},{"question":"def maxProfit(prices: List[int]) -> int: Returns the maximum profit achievable with the given prices, considering the cooldown period after each sell operation. >>> maxProfit([1, 2, 3, 0, 2]) == 3 >>> maxProfit([1, 2, 3, 4, 5]) == 4 >>> maxProfit([5, 4, 3, 2, 1]) == 0 >>> maxProfit([1, 2, 1, 2, 1]) == 1 >>> maxProfit([1]) == 0 >>> maxProfit([]) == 0 >>> maxProfit([3, 3, 3, 3, 3]) == 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit achievable with the given prices, considering the cooldown period after each sell operation. if not prices: return 0 n = len(prices) sell = [0] * n buy = [0] * n cooldown = [0] * n buy[0] = -prices[0] sell[0] = 0 cooldown[0] = 0 for i in range(1, n): buy[i] = max(buy[i-1], cooldown[i-1] - prices[i]) sell[i] = buy[i-1] + prices[i] cooldown[i] = max(cooldown[i-1], sell[i-1]) return max(sell[-1], cooldown[-1])"},{"question":"def sum_unique_subsequences(s: str) -> int: Returns the sum of all possible unique subsequences of length 3 formed by the digits in the string \`s\`. >>> sum_unique_subsequences(\\"124\\") 124 >>> sum_unique_subsequences(\\"113\\") 113","solution":"from itertools import combinations def sum_unique_subsequences(s): Returns the sum of all possible unique subsequences of length 3 formed by the digits in the string \`s\`. unique_subsequences = set() for comb in combinations(s, 3): unique_subsequences.add(''.join(comb)) return sum(int(subseq) for subseq in unique_subsequences)"},{"question":"def generate_magic_square(n): Generates an n x n magic square matrix if n is an odd integer between 3 and 9 inclusive. >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> generate_magic_square(5) [[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]] pass def format_magic_square(matrix): Formats the given matrix as a string with each number right-aligned and separated by spaces. >>> format_magic_square([[8, 1, 6], [3, 5, 7], [4, 9, 2]]) ' 8 1 6n 3 5 7n 4 9 2' >>> format_magic_square([[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]]) '17 24 1 8 15n23 5 7 14 16n 4 6 13 20 22n10 12 19 21 3n11 18 25 2 9' pass def magic_square(n): Generates an n x n magic square matrix and formats it as a string. >>> magic_square(3) ' 8 1 6n 3 5 7n 4 9 2' >>> magic_square(5) '17 24 1 8 15n23 5 7 14 16n 4 6 13 20 22n10 12 19 21 3n11 18 25 2 9' pass","solution":"def generate_magic_square(n): if n < 3 or n > 9 or n % 2 == 0: raise ValueError(\\"n must be an odd integer between 3 and 9 inclusive.\\") magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 new_i, new_j = (i - 1) % n, (j + 1) % n if magic_square[new_i][new_j] != 0: i = (i + 1) % n else: i, j = new_i, new_j return magic_square def format_magic_square(matrix): size = len(matrix) width = len(str(size * size)) formatted_output = [] for row in matrix: formatted_row = \\" \\".join(f\\"{num:{width}}\\" for num in row) formatted_output.append(formatted_row) return \\"n\\".join(formatted_output) def magic_square(n): matrix = generate_magic_square(n) return format_magic_square(matrix)"},{"question":"def is_valid_bank_account(account_str: str) -> str: Determines if the given bank account number is valid. The bank account number is considered valid if it: - Contains exactly 10 digits - Does not have any leading zeros - Contains only digits >>> is_valid_bank_account(\\"1234567890\\") 'Valid' >>> is_valid_bank_account(\\"12345678901\\") 'Invalid' >>> is_valid_bank_account(\\"0123456789\\") 'Invalid' >>> is_valid_bank_account(\\"12345a7890\\") 'Invalid'","solution":"def is_valid_bank_account(account_str): Checks if the bank account number is valid. # Check if the length is exactly 10 if len(account_str) != 10: return \\"Invalid\\" # Check if all characters are digits if not account_str.isdigit(): return \\"Invalid\\" # Check if there are leading zeros if account_str[0] == '0': return \\"Invalid\\" return \\"Valid\\""},{"question":"def run_length_encoding(s: str) -> str: Returns the run-length encoded version of the input string s. Examples: >>> run_length_encoding(\\"aaabbcccc\\") 'a3b2c4' >>> run_length_encoding(\\"abcd\\") 'a1b1c1d1' >>> run_length_encoding(\\"aabbccddeeff\\") 'a2b2c2d2e2f2' >>> run_length_encoding(\\"a\\") 'a1' >>> run_length_encoding(\\"aaaaaa\\") 'a6' >>> run_length_encoding(\\"\\") '' >>> run_length_encoding(\\"aabbaaaac\\") 'a2b2a4c1'","solution":"def run_length_encoding(s): Returns the run-length encoded version of the input string s. if not s: return \\"\\" encoded_str = [] prev_char = s[0] count = 1 for char in s[1:]: if char == prev_char: count += 1 else: encoded_str.append(prev_char + str(count)) prev_char = char count = 1 encoded_str.append(prev_char + str(count)) # Handle the last set of characters return ''.join(encoded_str)"},{"question":"def nearest_prime(n: int) -> int: Create a function nearest_prime that takes a positive integer n as an argument and returns the nearest prime number to n. If there is a tie (i.e., two prime numbers are equidistant from n), return the smaller prime number. >>> nearest_prime(10) 11 >>> nearest_prime(14) 13 >>> nearest_prime(21) 19 >>> nearest_prime(20) 19 def test_nearest_prime(): assert nearest_prime(10) == 11 assert nearest_prime(14) == 13 assert nearest_prime(21) == 19 assert nearest_prime(20) == 19 assert nearest_prime(1) == 2 assert nearest_prime(2) == 2 assert nearest_prime(3) == 3 assert nearest_prime(4) == 3 assert nearest_prime(23) == 23 assert nearest_prime(27) == 29 def test_nearest_prime_tiebreak(): assert nearest_prime(15) == 13 # Tie between 13 and 17, return the smaller one assert nearest_prime(8) == 7 # Tie between 7 and","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nearest_prime(n): if is_prime(n): return n lower = n - 1 higher = n + 1 while True: if is_prime(lower): return lower if is_prime(higher): return higher lower -= 1 higher += 1"},{"question":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_rearrangement(arr): Write a function \`prime_rearrangement()\` that takes an integer array as input and returns a new array where all the prime numbers are at the beginning and the rest of the numbers follow in the same order they appeared in the original array. Maintain the order of the prime numbers as they were in the input list. >>> prime_rearrangement([11, 4, 7, 10, 2, 9]) [11, 7, 2, 4, 10, 9] >>> prime_rearrangement([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> prime_rearrangement([4, 6, 8, 9, 10, 15]) [4, 6, 8, 9, 10, 15] >>> prime_rearrangement([]) [] >>> prime_rearrangement([4, 3, 2, 9, 11, 8]) [3, 2, 11, 4, 9, 8] >>> prime_rearrangement([19, 22, 31, 44, 7]) [19, 31, 7, 22, 44]","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_rearrangement(arr): primes = [x for x in arr if is_prime(x)] non_primes = [x for x in arr if not is_prime(x)] return primes + non_primes"},{"question":"def common_characters(s1: str, s2: str) -> List[str]: Returns a sorted list of unique characters that appear in both s1 and s2, case insensitive. >>> common_characters(\\"abc\\", \\"cab\\") ['a', 'b', 'c'] >>> common_characters(\\"abcdef\\", \\"defgh\\") ['d', 'e', 'f'] >>> common_characters(\\"abc\\", \\"xyz\\") [] >>> common_characters(\\"aBc\\", \\"ABC\\") ['a', 'b', 'c'] >>> common_characters(\\"hello, world!\\", \\"world\\") ['d', 'l', 'o', 'r', 'w'] >>> common_characters(\\"\\", \\"abc\\") [] >>> common_characters(\\"\\", \\"\\") [] >>> common_characters(\\"abc123\\", \\"123xyz\\") ['1', '2', '3']","solution":"def common_characters(s1, s2): Returns a sorted list of unique characters that appear in both s1 and s2, case insensitive. s1_lower = set(s1.lower()) s2_lower = set(s2.lower()) common_chars = s1_lower.intersection(s2_lower) return sorted(common_chars)"},{"question":"def isMirroredSequence(N: int, A: List[int]) -> str: Returns \\"Yes\\" if the sequence A of length N is a mirrored sequence, otherwise returns \\"No\\". >>> isMirroredSequence(5, [1, 2, 3, 2, 1]) \\"Yes\\" >>> isMirroredSequence(4, [7, 8, 8, 9]) \\"No\\" from isMirroredSequence import test_mirrored_sequence_odd_length, test_mirrored_sequence_even_length, test_non_mirrored_sequence_odd_length, test_non_mirrored_sequence_even_length, test_mirrored_sequence_single_element, test_mirrored_sequence_two_elements, test_non_mirrored_sequence_two_elements, test_large_mirrored_sequence, test_large_non_mirrored_sequence # Test Suit def main(): test_mirrored_sequence_odd_length() test_mirrored_sequence_even_length() test_non_mirrored_sequence_odd_length() test_non_mirrored_sequence_even_length() test_mirrored_sequence_single_element() test_mirrored_sequence_two_elements() test_non_mirrored_sequence_two_elements() test_large_mirrored_sequence() test_large_non_mirrored_sequence() if __name__ == \\"__main__\\": main()","solution":"def isMirroredSequence(N, A): Returns \\"Yes\\" if the sequence A of length N is a mirrored sequence, otherwise returns \\"No\\". # Calculate \`mid\` index mid = N // 2 # Compare the first half and the reversed second half of the sequence for i in range(mid): if A[i] != A[N - i - 1]: return \\"No\\" return \\"Yes\\""},{"question":"def longest_arithmetic_subsequence_length(sequence): Given a sequence of numbers, finds the length of the longest subsequence such that the subsequence is increasing and the differences between adjacent numbers in the subsequence are all the same. Args: sequence (List[int]): A list of integers representing the sequence. Returns: int: The length of the longest arithmetic subsequence. >>> longest_arithmetic_subsequence_length([10, 7, 4, 6, 8, 10, 11]) 4 >>> longest_arithmetic_subsequence_length([1, 7, 3, 5, 9, 11]) 3 pass def solve(T, test_cases): Solves multiple test cases for finding the longest arithmetic subsequence. Args: T (int): The number of test cases. test_cases (List[List[int]]): A list of sequences for which we need to find the longest arithmetic subsequence length. Returns: List[int]: A list of results for each test case. >>> solve(2, [ ... [10, 7, 4, 6, 8, 10, 11], ... [1, 7, 3, 5, 9, 11] ... ]) [4, 3] pass","solution":"def longest_arithmetic_subsequence_length(sequence): This function takes a list of integers and returns the length of the longest subsequence where the differences between adjacent numbers are all the same. if not sequence: return 0 n = len(sequence) if n == 1: return 1 longest_length = 1 for i in range(n): for j in range(i + 1, n): diff = sequence[j] - sequence[i] current_length = 2 prev = sequence[j] for k in range(j + 1, n): if sequence[k] - prev == diff: current_length += 1 prev = sequence[k] longest_length = max(longest_length, current_length) return longest_length def solve(T, test_cases): results = [] for sequence in test_cases: results.append(longest_arithmetic_subsequence_length(sequence)) return results"},{"question":"def can_arrange_balloons(r: int, b: int) -> str: Determines if it is possible to arrange red and blue balloons such that no two adjacent balloons have the same color. Args: r (int): The number of red balloons. b (int): The number of blue balloons. Returns: str: \\"YES\\" if such an arrangement is possible, otherwise \\"NO\\". Example: >>> can_arrange_balloons(3, 3) \\"YES\\" >>> can_arrange_balloons(5, 3) \\"YES\\" >>> can_arrange_balloons(4, 1) \\"NO\\" from solution import can_arrange_balloons def test_equal_numbers(): assert can_arrange_balloons(3, 3) == \\"YES\\" assert can_arrange_balloons(0, 0) == \\"YES\\" def test_one_more_balloon(): assert can_arrange_balloons(5, 4) == \\"YES\\" assert can_arrange_balloons(4, 5) == \\"YES\\" assert can_arrange_balloons(1, 0) == \\"YES\\" def test_more_than_one_difference(): assert can_arrange_balloons(4, 1) == \\"NO\\" assert can_arrange_balloons(1, 4) == \\"NO\\" assert can_arrange_balloons(10, 0) == \\"NO\\" assert can_arrange_balloons(0, 3) == \\"NO\\" def test_large_numbers(): assert can_arrange_balloons(1000000, 999999) == \\"YES\\" assert can_arrange_balloons(999999, 1000000) == \\"YES\\" assert can_arrange_balloons(1000000, 998998) == \\"NO\\" assert can_arrange_balloons(998998, 1000000) == \\"NO\\"","solution":"def can_arrange_balloons(r, b): Determines if it is possible to arrange red and blue balloons such that no two adjacent balloons have the same color. Args: r (int): The number of red balloons. b (int): The number of blue balloons. Returns: str: \\"YES\\" if such an arrangement is possible, otherwise \\"NO\\". if abs(r - b) <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_even_fibonacci(X): Returns the sum of all even Fibonacci numbers up to a given number X. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(8) 10 >>> sum_even_fibonacci(1) 0 >>> sum_even_fibonacci(34) 44 >>> sum_even_fibonacci(100) 44","solution":"def sum_even_fibonacci(X): Returns the sum of all even Fibonacci numbers up to a given number X. if X < 2: return 0 a, b = 0, 1 even_sum = 0 while a <= X: if a % 2 == 0: even_sum += a a, b = b, a + b return even_sum"},{"question":"def is_possible_to_sort_boxes(test_cases): Determines if it is possible to sort the boxes such that the sum of any three consecutive box numbers is always a multiple of a given integer, K. :param test_cases: List of test cases, where each test case is represented by a tuple (K, boxes) where K is the integer multiple and boxes is the list of box labels. :return: List of strings \\"YES\\" or \\"NO\\" for each test case. >>> test_cases = [ ... (3, [3, 6, 9, 12]), ... (5, [1, 5, -2, 4, -1]) ... ] >>> is_possible_to_sort_boxes(test_cases) [\\"YES\\", \\"NO\\"]","solution":"def is_possible_to_sort_boxes(test_cases): Determines if it is possible to sort the boxes such that the sum of any three consecutive box numbers is always a multiple of K. :param test_cases: List of test cases, where each test case is represented by a tuple (K, boxes) where K is the integer multiple and boxes is the list of box labels. :return: List of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for K, boxes in test_cases: N = len(boxes) # Check if for every triplet (i-2, i-1, i), their sum is divisible by K is_good = True for i in range(2, N): if (boxes[i] + boxes[i-1] + boxes[i-2]) % K != 0: is_good = False break results.append(\\"YES\\" if is_good else \\"NO\\") return results # Example usage test_cases = [ (3, [3, 6, 9, 12]), (5, [1, 5, -2, 4, -1]) ] print(is_possible_to_sort_boxes(test_cases))"},{"question":"def is_one_swap_fixable(n: int, ids: List[int]) -> str: Returns \\"YES\\" if the sequence can be fixed by a single swap, \\"NO\\" otherwise. >>> is_one_swap_fixable(5, [1, 3, 2, 4, 5]) \\"YES\\" >>> is_one_swap_fixable(4, [1, 4, 3, 2]) \\"NO\\" >>> is_one_swap_fixable(3, [3, 1, 2]) \\"YES\\"","solution":"def is_one_swap_fixable(n, ids): Returns \\"YES\\" if the sequence can be fixed by a single swap, \\"NO\\" otherwise. # Find the positions where the sequence is out of order out_of_order_positions = [i for i in range(n - 1) if ids[i] > ids[i + 1]] # If none are found, the list is already sorted if not out_of_order_positions: return \\"YES\\" # If more than two adjacent elements are out of order, the sequence cannot be fixed by one swap if len(out_of_order_positions) > 1: return \\"NO\\" # Identify the problematic indices i = out_of_order_positions[0] # Single swap to fix either adjacent or non-adjacent elements: # - Swap i and i+1 # - Swap i with i+2 (checking out of bounds) # - Swap i-1 with i+1 if ( i == n - 2 or (ids[i] > ids[i+2] if i + 2 < n else True) or (ids[i-1] <= ids[i+1] if i > 0 else True) ): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_possible_taste(N, flavors): Returns the maximum possible taste Fumiko can achieve by choosing the best pair of ingredients. Parameters: N (int): The number of ingredients. flavors (list of int): The flavor values of the ingredients. Returns: int: The maximum possible taste. >>> max_possible_taste(5, [1, 6, 3, 10, 15]) 14 >>> max_possible_taste(5, [5, 5, 5, 5, 5]) 0 >>> max_possible_taste(2, [0, 0]) 0 >>> max_possible_taste(5, [1000, 2500, 5000, 7500, 10000]) 9000 >>> max_possible_taste(3, [-10, -20, -30]) 20 >>> max_possible_taste(1000, list(range(1000))) 999","solution":"def max_possible_taste(N, flavors): Returns the maximum possible taste Fumiko can achieve by choosing the best pair of ingredients. Parameters: N (int): The number of ingredients. flavors (list of int): The flavor values of the ingredients. Returns: int: The maximum possible taste. max_flavor = max(flavors) min_flavor = min(flavors) return abs(max_flavor - min_flavor)"},{"question":"def sum_digits(n: int) -> int: Returns the sum of the digits of the non-negative integer n. >>> sum_digits(123) 6 >>> sum_digits(4567) 22 >>> sum_digits(0) 0 >>> sum_digits(98765) 35","solution":"def sum_digits(n): Returns the sum of the digits of the non-negative integer n. Parameters: n (int): A non-negative integer. Returns: int: Sum of the digits of n. return sum(int(digit) for digit in str(n))"},{"question":"def form_teams(n, k): Determines the maximum number of teams that can be formed and the number of reserve members. Parameters: n (int): The total number of employees. k (int): The required size of each team. Returns: tuple: A tuple containing two integers: - The maximum number of teams that can be formed. - The number of reserve members. Examples: >>> form_teams(10, 3) (3, 1) >>> form_teams(15, 5) (3, 0) >>> form_teams(20, 6) (3, 2)","solution":"def form_teams(n, k): Determines the maximum number of teams that can be formed and the number of reserve members. Parameters: n (int): The total number of employees. k (int): The required size of each team. Returns: tuple: A tuple containing two integers: - The maximum number of teams that can be formed. - The number of reserve members. max_teams = n // k reserves = n % k return max_teams, reserves"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a 2D grid with obstacles. Example: >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> unique_paths_with_obstacles(grid) 2","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a 2D grid with obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def count_integer_points_in_rectangle(x1: int, y1: int, x2: int, y2: int) -> int: Given a rectangle with corners at (x1, y1), (x1, y2), (x2, y1), and (x2, y2), where x1 < x2 and y1 < y2, determine the number of integer points (i, j) such that the point (i, j) lies inside or on the border of the rectangle. Args: tx1 (int): x-coordinate of the left side. ty1 (int): y-coordinate of the bottom side. tx2 (int): x-coordinate of the right side. ty2 (int): y-coordinate of the top side. Returns: tint: The number of integer points inside or on the border of the rectangle. Examples: >>> count_integer_points_in_rectangle(1, 1, 3, 3) 9 >>> count_integer_points_in_rectangle(1, 1, 1, 3) 3 >>> count_integer_points_in_rectangle(2, 2, 2, 2) 1 >>> count_integer_points_in_rectangle(100, 200, 500, 600) 160801 >>> count_integer_points_in_rectangle(1, 1, 2, 2) 4 >>> count_integer_points_in_rectangle(1, 1, 1000, 1000) 1000000","solution":"def count_integer_points_in_rectangle(x1, y1, x2, y2): Returns the number of integer points inside or on the border of the given rectangle. return (x2 - x1 + 1) * (y2 - y1 + 1)"},{"question":"def can_create_potions(D: int, U: int, E: int, F: int, P: int) -> str: Determine if it's possible to create P potions with the given essence requirements. Args: D (int): Total units of Dragon essence available. U (int): Total units of Unicorn essence available. E (int): Units of Dragon essence required per potion. F (int): Units of Unicorn essence required per potion. P (int): Number of potions to create. Returns: str: \\"POSSIBLE\\" if it's possible to create all potions, otherwise \\"IMPOSSIBLE\\". >>> can_create_potions(10, 15, 2, 3, 4) \\"POSSIBLE\\" >>> can_create_potions(10, 15, 3, 4, 5) \\"IMPOSSIBLE\\"","solution":"def can_create_potions(D, U, E, F, P): Determine if it's possible to create P potions with the given essence requirements. Args: D (int): Total units of Dragon essence available. U (int): Total units of Unicorn essence available. E (int): Units of Dragon essence required per potion. F (int): Units of Unicorn essence required per potion. P (int): Number of potions to create. Returns: str: \\"POSSIBLE\\" if it's possible to create all potions, otherwise \\"IMPOSSIBLE\\". total_dragon_needed = E * P total_unicorn_needed = F * P if D >= total_dragon_needed and U >= total_unicorn_needed: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def add_to_nested_dict(d: dict, keys: list, value): Adds a value into a nested dictionary structure. Parameters: - d (dict): The dictionary to modify. - keys (list): List of keys representing the path to insert value. - value: The value to insert. Returns: - dict: The modified dictionary. Examples: >>> d = {'level1': {'level2': {'level3': 'value'}}} >>> add_to_nested_dict(d, ['level1', 'level2', 'level4'], 'new_value') {'level1': {'level2': {'level3': 'value', 'level4': 'new_value'}}} >>> d = {} >>> add_to_nested_dict(d, ['a', 'b', 'c'], 1) {'a': {'b': {'c': 1}}} >>> d = {'a': {}} >>> add_to_nested_dict(d, ['a', 'b', 'c'], 2) {'a': {'b': {'c': 2}}} >>> d = {'existing_key': {'inner_key': 'inner_value'}} >>> add_to_nested_dict(d, ['existing_key', 'new_inner_key'], 'new_inner_value') {'existing_key': {'inner_key': 'inner_value', 'new_inner_key': 'new_inner_value'}}","solution":"def add_to_nested_dict(d, keys, value): Adds a value into a nested dictionary structure. Parameters: - d (dict): The dictionary to modify. - keys (list): List of keys representing the path to insert value. - value: The value to insert. Returns: - dict: The modified dictionary. current = d for key in keys[:-1]: if key not in current: current[key] = {} current = current[key] current[keys[-1]] = value return d"},{"question":"def sunlight_buildings(test_cases): Determine how many buildings receive sunlight for each sequence of building heights. >>> sunlight_buildings([(5, [3, 5, 4, 6, 2])]) [3] >>> sunlight_buildings([(4, [2, 3, 4, 5])]) [4] >>> sunlight_buildings([(3, [1, 2, 2])]) [2]","solution":"def sunlight_buildings(test_cases): results = [] for case in test_cases: n = case[0] heights = case[1] count = 0 max_height = 0 for height in heights: if height > max_height: count += 1 max_height = height results.append(count) return results # Example usage: # test_cases = [(5, [3, 5, 4, 6, 2]), (4, [2, 3, 4, 5]), (3, [1, 2, 2])] # print(sunlight_buildings(test_cases)) # Output: [3, 4, 2]"},{"question":"from typing import List, Tuple def rearrange_blocks(n: int, heights: List[int]) -> Tuple[str, List[int]]: Rearranges the blocks so that no two adjacent blocks have the same height. Arguments: n : int -- number of blocks heights : list of int -- heights of the blocks Returns: (str, list of int) -- \\"YES\\" and the rearranged heights if possible, \\"NO\\" otherwise >>> rearrange_blocks(5, [1, 2, 3, 4, 5]) (\\"YES\\", [1, 3, 2, 4, 5]) >>> rearrange_blocks(4, [1, 1, 1, 1]) (\\"NO\\", []) >>> rearrange_blocks(1, [1]) (\\"YES\\", [1]) >>> rearrange_blocks(2, [1, 1]) (\\"NO\\", []) >>> rearrange_blocks(3, [1, 2, 2]) (\\"YES\\", [1, 2, 1]) >>> rearrange_blocks(6, [1, 1, 1, 2, 3, 4]) (\\"YES\\", [1, 2, 1, 3, 1, 4])","solution":"from collections import Counter import heapq def rearrange_blocks(n, heights): Rearranges the blocks so that no two adjacent blocks have the same height. Arguments: n : int -- number of blocks heights : list of int -- heights of the blocks Returns: (str, list of int) -- \\"YES\\" and the rearranged heights if possible, \\"NO\\" otherwise if not heights: return \\"NO\\", [] # Count the frequency of each height counter = Counter(heights) # Check if the most frequent height's count is more than half of total blocks max_height_count = counter.most_common(1)[0][1] if max_height_count > (n + 1) // 2: return \\"NO\\", [] # Create a max heap heap = [(-count, height) for height, count in counter.items()] heapq.heapify(heap) result = [] while heap: # Pop the most frequent element count1, height1 = heapq.heappop(heap) if result and result[-1] == height1: if not heap: return \\"NO\\", [] # Pop the second most frequent element count2, height2 = heapq.heappop(heap) result.append(height2) count2 += 1 if count2 < 0: heapq.heappush(heap, (count2, height2)) # Since we temporarily skipped an element, re-push it heapq.heappush(heap, (count1, height1)) else: result.append(height1) count1 += 1 if count1 < 0: heapq.heappush(heap, (count1, height1)) return \\"YES\\", result"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def is_symmetric_tree(root): if not root: return True def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root.left, root.right) def construct_tree_from_level_order(values): if not values or values[0] == -1: return None root = TreeNode(values[0]) queue = [root] i = 1 while i < len(values) and queue: current = queue.pop(0) if i < len(values) and values[i] != -1: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] != -1: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def isSymmetric(N, values): Check whether the given binary tree is symmetric. Args: N : int : Number of nodes in the binary tree values : List[int] : Level order traversal of the binary tree (-1 indicates a NULL node) Returns: str : \\"Yes\\" if the binary tree is symmetric, otherwise \\"No\\" >>> isSymmetric(7, [1, 2, 2, 3, 4, 4, 3]) \\"Yes\\" >>> isSymmetric(5, [1, 2, 2, -1, 3, -1, 3]) \\"No\\"","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def is_symmetric_tree(root): if not root: return True def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root.left, root.right) def construct_tree_from_level_order(values): if not values or values[0] == -1: return None root = TreeNode(values[0]) queue = [root] i = 1 while i < len(values) and queue: current = queue.pop(0) if i < len(values) and values[i] != -1: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] != -1: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def isSymmetric(N, values): root = construct_tree_from_level_order(values) return \\"Yes\\" if is_symmetric_tree(root) else \\"No\\""},{"question":"from typing import List def most_frequent_word(words: List[str]) -> str: Returns the word that appears the maximum number of times in the list of words. If there are multiple words with the same highest frequency, return the one which comes first lexicographically. >>> most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"]) 'banana' >>> most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"apple\\"]) 'apple'","solution":"from typing import List def most_frequent_word(words: List[str]) -> str: Returns the word that appears the maximum number of times in the list of words. If there are multiple words with the same highest frequency, return the one which comes first lexicographically. from collections import Counter word_count = Counter(words) max_frequency = max(word_count.values()) max_words = [word for word, count in word_count.items() if count == max_frequency] return min(max_words)"},{"question":"def min_moves_to_form_string(target: str) -> int: Returns the minimum number of moves required to transform the primary string to the target string. Since we can only insert characters in order or remove from the end, the minimum moves are simply the length of the target string. >>> min_moves_to_form_string(\\"abc\\") 3 >>> min_moves_to_form_string(\\"aaa\\") 3 def solve_game(t: int, targets: List[str]) -> List[int]: Given the number of test cases t and the list of target strings, this function returns a list of the minimum number of moves for each test case. >>> solve_game(2, [\\"abc\\", \\"aaa\\"]) [3, 3] >>> solve_game(3, [\\"a\\", \\"ab\\", \\"abc\\"]) [1, 2, 3] # Unit Tests def test_min_moves_to_form_string(): assert min_moves_to_form_string(\\"abc\\") == 3 assert min_moves_to_form_string(\\"aaa\\") == 3 assert min_moves_to_form_string(\\"abcdef\\") == 6 assert min_moves_to_form_string(\\"a\\") == 1 assert min_moves_to_form_string(\\"\\") == 0 def test_solve_game(): assert solve_game(2, [\\"abc\\", \\"aaa\\"]) == [3, 3] assert solve_game(3, [\\"a\\", \\"ab\\", \\"abc\\"]) == [1, 2, 3] assert solve_game(1, [\\"\\"]) == [0] assert solve_game(4, [\\"x\\", \\"y\\", \\"z\\", \\"xy\\"]) == [1, 1, 1, 2] def run_tests(): test_min_moves_to_form_string() test_solve_game() print(\\"All tests passed!\\") run_tests()","solution":"def min_moves_to_form_string(target): This function returns the minimum number of moves required to transform the primary string to the target string. Since we can only insert characters in order or remove from the end, the minimum moves are simply the length of the target string. return len(target) def solve_game(t, targets): Given the number of test cases t and the list of target strings, this function returns a list of the minimum number of moves for each test case. results = [] for target in targets: results.append(min_moves_to_form_string(target)) return results"},{"question":"def can_robot_navigate(input_data: str) -> str: Determine if there is a path for the robot to reach the bottom-right corner of the grid. >>> input_data = '''4 4 . . . # . # . . . # # . . . . .''' >>> can_robot_navigate(input_data) 'YES' >>> input_data = '''4 4 . # # # # # # . # # # # . . . #''' >>> can_robot_navigate(input_data) 'NO' >>> input_data = '''1 1 .''' >>> can_robot_navigate(input_data) 'YES' >>> input_data = '''1 1 #''' >>> can_robot_navigate(input_data) 'NO' >>> input_data = '''2 2 # . . .''' >>> can_robot_navigate(input_data) 'NO' >>> input_data = '''2 2 . . . #''' >>> can_robot_navigate(input_data) 'NO' >>> input_data = '''5 5 . . . . . # # # # . . . . . . . # # # # . . . . .''' >>> can_robot_navigate(input_data) 'YES' >>> input_data = '''3 3 . # . # # # . . .''' >>> can_robot_navigate(input_data) 'NO'","solution":"def can_reach_goal(n, m, grid): from collections import deque start = (0, 0) goal = (n-1, m-1) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" queue = deque([start]) visited = set([start]) while queue: current = queue.popleft() if current == goal: return \\"YES\\" for d in directions: next_cell = (current[0] + d[0], current[1] + d[1]) if 0 <= next_cell[0] < n and 0 <= next_cell[1] < m and next_cell not in visited and grid[next_cell[0]][next_cell[1]] == '.': visited.add(next_cell) queue.append(next_cell) return \\"NO\\" # Function to convert input into the required format and execute the algorithm def can_robot_navigate(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) grid = [line.split() for line in lines[1:]] return can_reach_goal(n, m, grid)"},{"question":"def score_hand(cards): Calculate the total score for a hand of cards. Each card has a point value associated with it: - Cards 2 through 10 score points equal to their face value (2 to 10). - Jacks, Queens, and Kings each score 10 points. - Aces score 11 points. :param cards: List of cards as strings. :return: Total score as an integer. >>> score_hand(['10', 'J', 'Q', '9', 'A']) == 50 >>> score_hand(['9', '8', '3', '2', 'K']) == 32 >>> score_hand(['A', 'A', 'A', '5', '5']) == 43 pass def score_players_hands(players_hands): Compute the total score for each player's hand. :param players_hands: List of strings, where each string represents the cards of one player. :return: List of total scores for each player. >>> score_players_hands(['10 J Q 9 A', '9 8 3 2 K', 'A A A 5 5']) == [50, 32, 43] >>> score_players_hands(['K Q J J A', '7 8 9 10 J', '2 3 4 5 6']) == [51, 44, 20] pass","solution":"def score_hand(cards): Calculate the total score for a hand of cards. :param cards: List of cards as strings. :return: Total score as an integer. card_values = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11 } return sum(card_values[card] for card in cards) def score_players_hands(players_hands): Compute the total score for each player's hand. :param players_hands: List of strings, where each string represents the cards of one player. :return: List of total scores for each player. return [score_hand(hand.split()) for hand in players_hands]"},{"question":"from typing import List def min_moves_to_reach_end(R: int, C: int, grid: List[str]) -> int: Calculate the minimum number of moves the robot needs to reach the bottom-right corner or determine that it is impossible. Parameters: R (int): number of rows C (int): number of columns grid (list of str): the grid representation containing '.' and '*' Returns: int: minimum number of moves, or -1 if impossible >>> R, C = 5, 5 >>> grid = [ ... \\".....\\", ... \\".*...\\", ... \\".*.*.\\", ... \\"....*\\", ... \\".....\\" ... ] >>> min_moves_to_reach_end(R, C, grid) 8 >>> R, C = 5, 5 >>> grid = [ ... \\"*....\\", ... \\".....\\", ... \\".*...\\", ... \\"..*..\\", ... \\".....\\" ... ] >>> min_moves_to_reach_end(R, C, grid) -1 pass import pytest def test_example_1(): R, C = 5, 5 grid = [ \\".....\\", \\".*...\\", \\".*.*.\\", \\"....*\\", \\".....\\" ] assert min_moves_to_reach_end(R, C, grid) == 8 def test_example_2(): R, C = 5, 5 grid = [ \\"*....\\", \\".....\\", \\".*...\\", \\"..*..\\", \\".....\\" ] assert min_moves_to_reach_end(R, C, grid) == -1 def test_start_is_obstacle(): R, C = 2, 2 grid = [ \\"*.\\", \\"..\\" ] assert min_moves_to_reach_end(R, C, grid) == -1 def test_end_is_obstacle(): R, C = 2, 2 grid = [ \\"..\\", \\".*\\" ] assert min_moves_to_reach_end(R, C, grid) == -1 def test_small_grid_with_no_obstacles(): R, C = 1, 1 grid = [ \\".\\" ] assert min_moves_to_reach_end(R, C, grid) == 0 def test_2x2_grid_with_clear_path(): R, C = 2, 2 grid = [ \\"..\\", \\"..\\" ] assert min_moves_to_reach_end(R, C, grid) == 2 def test_larger_grid_with_obstacles(): R, C = 3, 3 grid = [ \\"...\\", \\".*.\\", \\"...\\" ] assert min_moves_to_reach_end(R, C, grid) == 4 if __name__ == '__main__': pytest.main()","solution":"from collections import deque def min_moves_to_reach_end(R, C, grid): Calculate the minimum number of moves the robot needs to reach the bottom-right corner or determine that it is impossible. Parameters: R (int): number of rows C (int): number of columns grid (list of str): the grid representation containing '.' and '*' Returns: int: minimum number of moves, or -1 if impossible # Directions for moving in 4 possible ways: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize the start and end positions start = (0, 0) end = (R-1, C-1) # Early exit if start or end is an obstacle if grid[0][0] == '*' or grid[R-1][C-1] == '*': return -1 # Initialize the queue with the starting position and the visited set queue = deque([(start, 0)]) visited = set([start]) while queue: (current_r, current_c), moves = queue.popleft() if (current_r, current_c) == end: return moves # Explore all possible directions for dr, dc in directions: new_r, new_c = current_r + dr, current_c + dc if 0 <= new_r < R and 0 <= new_c < C and grid[new_r][new_c] == '.' and (new_r, new_c) not in visited: queue.append(((new_r, new_c), moves + 1)) visited.add((new_r, new_c)) return -1"},{"question":"def check_sorted(n, lst): Returns \\"Sorted\\" if the list is in non-decreasing order, otherwise \\"Unsorted\\". :param n: The number of integers in the list :param lst: The list of integers :return: String \\"Sorted\\" or \\"Unsorted\\" >>> check_sorted(4, [2, 3, 5, 7]) \\"Sorted\\" >>> check_sorted(5, [1, 3, 2, 4, 6]) \\"Unsorted\\" >>> check_sorted(1, [1]) \\"Sorted\\" >>> check_sorted(3, [5, 5, 5]) \\"Sorted\\" >>> check_sorted(4, [4, 3, 2, 1]) \\"Unsorted\\" >>> check_sorted(5, [-2, -1, 0, 1, 2]) \\"Sorted\\" >>> check_sorted(5, [-2, 0, -1, 1, 2]) \\"Unsorted\\"","solution":"def check_sorted(n, lst): Returns \\"Sorted\\" if the list is in non-decreasing order, otherwise \\"Unsorted\\". :param n: The number of integers in the list :param lst: The list of integers :return: String \\"Sorted\\" or \\"Unsorted\\" for i in range(n - 1): if lst[i] > lst[i + 1]: return \\"Unsorted\\" return \\"Sorted\\""},{"question":"from typing import List, Tuple def sort_books(N: int, books: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sorts the books in ascending order based on their identifiers. If two books have the same identifier, they retain their original order. >>> sort_books(5, [(123, \\"The Art of Computer Programming\\"), (456, \\"Clean Code\\"), (123, \\"Introduction to Algorithms\\"), (789, \\"Design Patterns\\"), (456, \\"The Pragmatic Programmer\\")]) [(123, \\"The Art of Computer Programming\\"), (123, \\"Introduction to Algorithms\\"), (456, \\"Clean Code\\"), (456, \\"The Pragmatic Programmer\\"), (789, \\"Design Patterns\\")] >>> sort_books(3, [(100, \\"A\\"), (100, \\"B\\"), (100, \\"C\\")]) [(100, \\"A\\"), (100, \\"B\\"), (100, \\"C\\")]","solution":"from typing import List, Tuple def sort_books(N: int, books: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sorts the books in ascending order based on their identifiers. If two books have the same identifier, they retain their original order. return sorted(books, key=lambda book: book[0])"},{"question":"from typing import List, Tuple def smallest_team_cover_all_skills(N: int, M: int, required_skills: List[int], employees: List[List[int]]) -> int: Determine the minimum number of employees that need to be included in the team to cover all required skills. :param N: Integer, number of employees. :param M: Integer, number of required skills. :param required_skills: List of integers, required skill IDs. :param employees: List of lists where each sublist contains the skills of an employee. :return: Integer, size of the smallest team that covers all required skills, or -1 if not possible. >>> smallest_team_cover_all_skills(4, 3, [1, 2, 3], [[2, 1, 2], [1, 3], [1, 2], [2, 2, 3]]) 2 >>> smallest_team_cover_all_skills(3, 3, [1, 2, 3], [[3, 1, 2, 3], [2, 1, 2], [1, 3]]) 1 >>> smallest_team_cover_all_skills(3, 3, [1, 2, 3], [[1, 1], [1, 2], [1, 3]]) 3 >>> smallest_team_cover_all_skills(3, 3, [1, 2, 3], [[1, 1], [1, 2], [1, 4]]) -1 >>> smallest_team_cover_all_skills(4, 3, [1, 2, 3], [[2, 1, 2], [2, 2, 3], [2, 1, 3], [3, 1, 2, 3]]) 1","solution":"from itertools import combinations def smallest_team_cover_all_skills(N, M, required_skills, employees): required_skills_set = set(required_skills) # Convert each employee's skill set to set for easy comparison employees_skills = [set(emp) for num_skills, *emp in employees] # Try all combinations from size 1 to N to find the smallest team for team_size in range(1, N+1): for team_indices in combinations(range(N), team_size): team_skills = set() for index in team_indices: team_skills.update(employees_skills[index]) if required_skills_set.issubset(team_skills): return team_size return -1"},{"question":"def find_ways_to_plant_flowers(n): Returns the number of ways to plant flowers in n spots without planting in adjacent spots. Args: n (int): The number of spots. Returns: int: The number of ways to plant flowers. pass def process_test_cases(test_cases): Processes a list of test cases and returns the number of ways to plant flowers for each case. Args: test_cases (List[int]): A list of integers representing the number of spots in different test cases. Returns: List[int]: A list of results for each test case. pass # Unit Test: import pytest def test_find_ways_to_plant_flowers(): assert find_ways_to_plant_flowers(0) == 1 assert find_ways_to_plant_flowers(1) == 1 assert find_ways_to_plant_flowers(3) == 3 assert find_ways_to_plant_flowers(4) == 5 assert find_ways_to_plant_flowers(5) == 8 assert find_ways_to_plant_flowers(10) == 89 def test_process_test_cases(): test_cases = [3, 4, 5] expected_output = [3, 5, 8] assert process_test_cases(test_cases) == expected_output test_cases = [2, 6, 0] expected_output = [2, 13, 1] assert process_test_cases(test_cases) == expected_output","solution":"def find_ways_to_plant_flowers(n): Returns the number of ways to plant flowers in n spots without planting in adjacent spots. if n == 0: return 1 if n == 1: return 1 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def process_test_cases(test_cases): results = [] for n in test_cases: results.append(find_ways_to_plant_flowers(n)) return results"},{"question":"def solve(input_data: str) -> str: You are given an array of integers, and you must check if there exists a subsequence such that the subsequence is a permutation of a palindrome. A palindrome is a string that reads the same forward and backward, and a permutation of a palindrome is a re-arrangement of letters to form a palindrome. >>> solve(\\"2n3n1 2 2n4n1 2 2 3\\") \\"YESnNO\\" >>> solve(\\"1n1n1\\") \\"YES\\" >>> solve(\\"2n3n1 2 3n4n1 1 2 3\\") \\"NOnNO\\" >>> solve(\\"1n5n1 2 2 3 3\\") \\"YES\\" >>> solve(\\"1n6n10 1000 10 10 1000 10\\") \\"YES\\" >>> solve(\\"1n4n5 5 5 5\\") \\"YES\\"","solution":"def is_permutation_of_palindrome(arr): Checks if any subsequence of the array can be rearranged to form a palindrome. from collections import Counter # Count frequencies of each number freq = Counter(arr) # Count how many numbers have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 == 1) # For a sequence to be able to form a palindrome, # there must at most one number with an odd frequency return odd_count <= 1 def check_permutation_of_palindrome(test_cases): Takes in a list of test cases and returns whether each test case contains a subsequence that is a permutation of a palindrome. results = [] for n, arr in test_cases: if is_permutation_of_palindrome(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def solve(input_data): lines = input_data.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return \\"n\\".join(check_permutation_of_palindrome(test_cases))"},{"question":"def unique_paths_with_obstacles(n: int, grid: List[List[str]]) -> int: Given a grid of size n x n, each cell can either be empty ('.') or contain an obstacle ('#'). Find the number of unique paths from the top-left corner to the bottom-right corner, where you can only move right or down and cannot pass through obstacles. The answer should be returned modulo 10^9 + 7. Example: >>> unique_paths_with_obstacles(3, [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 2 >>> unique_paths_with_obstacles(2, [ ... ['.', '#'], ... ['.', '.'] ... ]) 1 >>> unique_paths_with_obstacles(1, [ ... ['.'] ... ]) 1","solution":"def unique_paths_with_obstacles(n, grid): MOD = 10**9 + 7 # Create a dp array to store the number of paths dp = [[0] * n for _ in range(n)] # Initialize the start point if grid[0][0] == '.': dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] % MOD if j > 0: dp[i][j] += dp[i][j-1] % MOD dp[i][j] %= MOD return dp[n-1][n-1]"},{"question":"def count_paths(n: int, m: int, maze: List[List[int]]) -> int: Counts the number of distinct paths from the top-left to the bottom-right corner of a maze, avoiding obstacles. Parameters: n (int): number of rows in the maze. m (int): number of columns in the maze. maze (list of list of int): 2D list representing the maze where 0 indicates an empty cell and 1 indicates an obstacle. Returns: int: Number of distinct paths. >>> count_paths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> count_paths(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 >>> count_paths(3, 3, [[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> count_paths(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == 0 >>> count_paths(2, 2, [[0, 1], [0, 0]]) == 1 >>> count_paths(4, 4, [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0]]) == 4","solution":"def count_paths(n, m, maze): Counts the number of distinct paths from the top-left to the bottom-right corner of a maze, avoiding obstacles. Parameters: n (int): number of rows in the maze. m (int): number of columns in the maze. maze (list of list of int): 2D list representing the maze where 0 indicates an empty cell and 1 indicates an obstacle. Returns: int: Number of distinct paths. if maze[0][0] == 1 or maze[n-1][m-1] == 1: return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if maze[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"from typing import List def get_min_operations(S: str) -> int: Returns the minimum number of operations required to completely remove the periodic substring p from S. >>> get_min_operations(\\"abababab\\") 4 >>> get_min_operations(\\"aaaa\\") 4 >>> get_min_operations(\\"ababa\\") 1 def solve(test_cases: List[str]) -> List[int]: Solves each test case and returns the results in an array. >>> solve([\\"abababab\\", \\"aaaa\\", \\"ababa\\"]) [4, 4, 1] >>> solve([\\"abcabcabc\\", \\"abcd\\"]) [3, 1]","solution":"def get_min_operations(S): Returns the minimum number of operations required to completely remove the periodic substring p from S. # Determine the smallest period p of the string S by finding the smallest k such that S is made of k repetitions n = len(S) for k in range(1, n + 1): if n % k == 0: p = S[:k] if p * (n // k) == S: return n // k def solve(test_cases): Solves each test case and returns the results in an array. results = [] for S in test_cases: results.append(get_min_operations(S)) return results"},{"question":"import random def partition(arr, low, high): pass # Implement the partitioning logic def quickselect(arr, low, high, k): pass # Implement the Quickselect algorithm def kthSmallest(arr: List[int], k: int) -> int: Given an array arr[] of integers and a positive integer k, find the k-th smallest element in the array using Quickselect algorithm. >>> kthSmallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kthSmallest([7, 10, 4, 3, 20, 15], 4) 10 pass # Implement the kthSmallest function from solution import kthSmallest def test_kth_smallest_example1(): assert kthSmallest([7, 10, 4, 3, 20, 15], 3) == 7 def test_kth_smallest_example2(): assert kthSmallest([7, 10, 4, 3, 20, 15], 4) == 10 def test_kth_smallest_single_element(): assert kthSmallest([25], 1) == 25 def test_kth_smallest_sorted_array(): assert kthSmallest([1, 2, 3, 4, 5], 2) == 2 def test_kth_smallest_reverse_sorted_array(): assert kthSmallest([5, 4, 3, 2, 1], 3) == 3 def test_kth_smallest_duplicates(): assert kthSmallest([3, 3, 1, 2, 2], 4) == 3 def test_kth_smallest_large_k(): assert kthSmallest([7, 10, 4, 3, 20, 15], 6) == 20 def test_kth_smallest_repeated_elements(): assert kthSmallest([1, 1, 1, 2, 3], 2) == 1","solution":"import random def partition(arr, low, high): pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low <= high: pi = partition(arr, low, high) if pi == k: return arr[pi] elif pi < k: return quickselect(arr, pi + 1, high, k) else: return quickselect(arr, low, pi - 1, k) return None def kthSmallest(arr, k): return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"def is_palindrome(n: int) -> bool: Determines whether a given non-negative integer is a palindrome. A palindrome is a number that reads the same backwards as forwards. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(0) True >>> is_palindrome(12321) True >>> is_palindrome(1001) True >>> is_palindrome(1000021) False","solution":"def is_palindrome(n): Determines whether a given non-negative integer is a palindrome. :param n: A non-negative integer :return: True if the integer is a palindrome, False otherwise str_n = str(n) return str_n == str_n[::-1]"},{"question":"from typing import List def can_form_peak_sequence(n: int, arr: List[int]) -> str: This function checks if a given array can be rearranged to form a Peak Sequence. Parameters: n (int): Length of the array. arr (list of ints): The array of integers. Returns: str: \\"YES\\" if the array can be rearranged to form a Peak Sequence, otherwise \\"NO\\". pass def process_input(input_lines: List[str]) -> List[str]: Processes multiple test cases and returns the output for each case. Parameters: input_lines (list of strs): List of input lines representing multiple test cases. Returns: list of strs: List of results for each test case (\\"YES\\" or \\"NO\\"). pass # Unit Tests def test_can_form_peak_sequence(): assert can_form_peak_sequence(5, [1, 3, 2, 4, 5]) == \\"YES\\" assert can_form_peak_sequence(4, [5, 5, 5, 5]) == \\"NO\\" assert can_form_peak_sequence(6, [9, 8, 7, 6, 5, 4]) == \\"YES\\" assert can_form_peak_sequence(3, [1, 2, 3]) == \\"YES\\" assert can_form_peak_sequence(3, [3, 3, 3]) == \\"NO\\" assert can_form_peak_sequence(1, [1]) == \\"NO\\" assert can_form_peak_sequence(2, [1, 2]) == \\"NO\\" def test_process_input(): input_lines = [ \\"3\\", \\"5 1 3 2 4 5\\", \\"4 5 5 5 5\\", \\"6 9 8 7 6 5 4\\" ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_input(input_lines) == expected_output def test_handles_minimum_input(): assert can_form_peak_sequence(1, [1]) == \\"NO\\" assert can_form_peak_sequence(2, [1, 2]) == \\"NO\\" def test_handles_maximum_input(): max_input = list(range(1, 1001)) assert can_form_peak_sequence(1000, max_input) == \\"YES\\" max_equal_input = [10000] * 1000 assert can_form_peak_sequence(1000, max_equal_input) == \\"NO\\"","solution":"def can_form_peak_sequence(n, arr): This function checks if a given array can be rearranged to form a Peak Sequence. Parameters: n (int): Length of the array. arr (list of ints): The array of integers. Returns: str: \\"YES\\" if the array can be rearranged to form a Peak Sequence, otherwise \\"NO\\". if n < 3: return \\"NO\\" sorted_arr = sorted(arr) # Simple check if all elements are the same. if sorted_arr[0] == sorted_arr[-1]: return \\"NO\\" # The array can be rearranged to form a Peak Sequence if it contains distinct elements. return \\"YES\\" def process_input(input_lines): Processes multiple test cases and returns the output for each case. Parameters: input_lines (list of strs): List of input lines representing multiple test cases. Returns: list of strs: List of results for each test case (\\"YES\\" or \\"NO\\"). T = int(input_lines[0]) results = [] index = 1 for _ in range(T): line = list(map(int, input_lines[index].split())) n = line[0] arr = line[1:] result = can_form_peak_sequence(n, arr) results.append(result) index += 1 return results"},{"question":"def smallest_number_with_n_fives(n: int) -> str: Returns the smallest number that contains exactly n number of digit fives. Parameters: n (int): The number of digit fives Returns: str: The smallest number containing exactly n digit fives >>> smallest_number_with_n_fives(1) == '5' >>> smallest_number_with_n_fives(3) == '555' >>> smallest_number_with_n_fives(5) == '55555' >>> smallest_number_with_n_fives(10) == '5555555555' >>> smallest_number_with_n_fives(100) == '5' * 100 >>> smallest_number_with_n_fives(1000) == '5' * 1000","solution":"def smallest_number_with_n_fives(n): Returns the smallest number that contains exactly n number of digit fives. Parameters: n (int): The number of digit fives Returns: str: The smallest number containing exactly n digit fives return '5' * n"},{"question":"def longestSubsequenceLength(strings: List[str]) -> int: Create a function that takes a list of strings and returns the length of the longest subsequence where each string is a subsequence of the next string. >>> longestSubsequenceLength([\\"a\\", \\"abc\\", \\"ab\\", \\"abcd\\", \\"b\\"]) 4 >>> longestSubsequenceLength([\\"x\\", \\"xyz\\", \\"xy\\", \\"zxy\\", \\"a\\"]) 3 >>> longestSubsequenceLength([\\"car\\", \\"cat\\", \\"cart\\", \\"cot\\", \\"bat\\"]) 2 >>> longestSubsequenceLength([\\"dog\\", \\"dot\\", \\"dogt\\", \\"top\\", \\"dop\\"]) 2 >>> longestSubsequenceLength([\\"a\\", \\"b\\"]) 1 >>> longestSubsequenceLength([\\"aaaa\\", \\"aaa\\", \\"aa\\", \\"a\\"]) 4 from solution import longestSubsequenceLength def test_example_1(): assert longestSubsequenceLength([\\"a\\", \\"abc\\", \\"ab\\", \\"abcd\\", \\"b\\"]) == 4 def test_example_2(): assert longestSubsequenceLength([\\"x\\", \\"xyz\\", \\"xy\\", \\"zxy\\", \\"a\\"]) == 3 def test_example_3(): assert longestSubsequenceLength([\\"car\\", \\"cat\\", \\"cart\\", \\"cot\\", \\"bat\\"]) == 2 def test_example_4(): assert longestSubsequenceLength([\\"dog\\", \\"dot\\", \\"dogt\\", \\"top\\", \\"dop\\"]) == 2 def test_example_5(): assert longestSubsequenceLength([\\"a\\", \\"b\\"]) == 1 def test_example_6(): assert longestSubsequenceLength([\\"aaaa\\", \\"aaa\\", \\"aa\\", \\"a\\"]) == 4 def test_empty_list(): assert longestSubsequenceLength([]) == 0 def test_single_element_list(): assert longestSubsequenceLength([\\"a\\"]) == 1 def test_strings_of_same_length(): assert longestSubsequenceLength([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == 1","solution":"def is_subsequence(s1, s2): Checks if s1 is a subsequence of s2. it = iter(s2) return all(char in it for char in s1) def longestSubsequenceLength(strings): Returns the length of the longest subsequence where each string is a subsequence of the next string. n = len(strings) if n == 0: return 0 # Sort strings based on their lengths strings.sort(key=len) # dp[i] will store the length of the longest valid subsequence ending with strings[i] dp = [1] * n # Find the longest subsequence for i in range(n): for j in range(i): if is_subsequence(strings[j], strings[i]): dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Examples: # print(longestSubsequenceLength([\\"a\\", \\"abc\\", \\"ab\\", \\"abcd\\", \\"b\\"])) # Returns 4 # print(longestSubsequenceLength([\\"x\\", \\"xyz\\", \\"xy\\", \\"zxy\\", \\"a\\"])) # Returns 3"},{"question":"def generate_pattern(n: int) -> str: Generates a pattern of consecutive integers from 1 to \`n\` formatted in alternating lines of numbers separated by spaces and commas. Each line ends with a newline character except the last line. >>> generate_pattern(1) '1n1' >>> generate_pattern(3) '1 2 3n1,2,3' >>> generate_pattern(5) '1 2 3 4 5n1,2,3,4,5' >>> generate_pattern(0) '' >>> generate_pattern(-5) ''","solution":"def generate_pattern(n): Generates a pattern of consecutive integers from 1 to \`n\` formatted in alternating lines of numbers separated by spaces and commas. Each line ends with a newline character except the last line. if n < 1: return \\"\\" nums = \\" \\".join(str(i) for i in range(1, n + 1)) commas = \\",\\".join(str(i) for i in range(1, n + 1)) return f\\"{nums}n{commas}\\""},{"question":"class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a given capacity. pass def get(self, key: int) -> int: Retrieve the value of the key if the key exists in the cache. Otherwise, return -1. >>> lru = LRUCache(3) >>> lru.put(1, 10) >>> lru.get(1) 10 >>> lru.get(2) -1 pass def put(self, key: int, value: int) -> None: Insert/update the value of the key. If the number of keys exceeds the capacity, remove the least recently used key. >>> lru = LRUCache(2) >>> lru.put(1, 10) >>> lru.put(2, 20) >>> lru.put(3, 30) >>> lru.get(1) -1 >>> lru.get(2) 20 pass def process_queries(n: int, m: int, queries: List[List[int]]) -> List[int]: Process a list of queries on an LRUCache. >>> process_queries(3, 7, [[1, 1, 10], [1, 2, 20], [2, 1], [1, 3, 30], [2, 2], [1, 4, 40], [2, 1]]) [10, 20, -1] >>> process_queries(2, 5, [[1, 1, 10], [1, 2, 20], [1, 3, 30], [2, 1], [2, 2], [2, 3]]) [-1, 20, 30] >>> process_queries(3, 5, [[1, 1, 10], [1, 1, 15], [2, 1], [1, 2, 20], [1, 3, 30]]) [15] >>> process_queries(3, 3, [[1, 1, 10], [2, 2], [2, 3]]) [-1, -1] >>> process_queries(1, 4, [[1, 1, 10], [2, 1], [1, 2, 20], [2, 1]]) [10, -1] pass","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.use_order = [] def get(self, key: int) -> int: if key in self.cache: self.use_order.remove(key) self.use_order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.use_order.remove(key) elif len(self.cache) >= self.capacity: lru_key = self.use_order.pop(0) del self.cache[lru_key] self.cache[key] = value self.use_order.append(key) def process_queries(n, m, queries): lru = LRUCache(n) results = [] for query in queries: if query[0] == 1: lru.put(query[1], query[2]) elif query[0] == 2: results.append(lru.get(query[1])) return results"},{"question":"def check_sum_exists(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. Args: arr (List[int]): The array of integers. k (int): The target sum. Returns: int: 1 if such a pair exists, otherwise 0. Examples: >>> check_sum_exists([1, 2, 3, 4, 5], 9) 1 >>> check_sum_exists([1, 2, 3, 4], 8) 0 >>> check_sum_exists([-1, -2, -3, -4, -5], -8) 1 >>> check_sum_exists([-1, 4, 1, -6], 3) 1 >>> check_sum_exists([1, 2, 5, 6, 8], 20) 0 >>> check_sum_exists([100000, 99999, -100000, -99999], 0) 1 >>> check_sum_exists([1, 1, 1, 1], 2) 1 >>> check_sum_exists([0, 0, 0, 0], 0) 1 >>> check_sum_exists([1, -1], 0) 1","solution":"def check_sum_exists(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k seen = set() for num in arr: if k - num in seen: return 1 seen.add(num) return 0"},{"question":"def smallest_integer_with_digit_sum(N: int) -> int: Finds the smallest positive integer M such that: - Sum of the digits of M is equal to N - Digits of M are non-zero and in non-decreasing order If no such M exists, returns -1. >>> smallest_integer_with_digit_sum(5) 5 >>> smallest_integer_with_digit_sum(10) 19 >>> smallest_integer_with_digit_sum(15) 69 >>> smallest_integer_with_digit_sum(1) 1 >>> smallest_integer_with_digit_sum(50) -1 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Processes a number of test cases and finds the smallest number M that satisfies the problem constraints for each case. >>> process_test_cases(5, [5, 10, 15, 1, 61]) [5, 19, 69, 1, -1] pass","solution":"def smallest_integer_with_digit_sum(N): if N > 45: # The maximum sum we can achieve with digits 1 to 9 (which is 1+2+3+...+9) return -1 digits = [] for digit in range(9, 0, -1): if N >= digit: digits.append(digit) N -= digit digits.sort() return int(''.join(map(str, digits))) def process_test_cases(T, test_cases): results = [] for N in test_cases: results.append(smallest_integer_with_digit_sum(N)) return results"},{"question":"from typing import List, Tuple def max_books(books: List[Tuple[str, int]], capacity: int) -> int: Determine the maximum number of books that can be placed on the shelf without exceeding the weight capacity and ensuring no two consecutive books have the same genre. >>> max_books([(\\"fiction\\", 2), (\\"mystery\\", 3), (\\"fiction\\", 4), (\\"non-fiction\\", 1)], 7) 3 >>> max_books([(\\"horror\\", 5), (\\"horror\\", 4), (\\"horror\\", 3), (\\"horror\\", 2)], 6) 1 >>> max_books([(\\"tech\\", 4), (\\"science\\", 2), (\\"tech\\", 1)], 5) 2","solution":"from typing import List, Tuple def max_books(books: List[Tuple[str, int]], capacity: int) -> int: # Sort books by weight to consider lighter books first books.sort(key=lambda x: x[1]) def backtrack(index, current_weight, count, last_genre): if index == len(books): return count max_count = count # Try to add the current book if it fits, and genre is not the same as the last one if current_weight + books[index][1] <= capacity and (last_genre is None or books[index][0] != last_genre): max_count = max(max_count, backtrack(index + 1, current_weight + books[index][1], count + 1, books[index][0])) # Skip the current book max_count = max(max_count, backtrack(index + 1, current_weight, count, last_genre)) return max_count return backtrack(0, 0, 0, None)"},{"question":"def perform_operations(n: int, q: int, array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Perform a series of operations on the array and return the final state of the array. Each operation specifies a subarray and a value to add to each element within that subarray. Args: n (int): The size of the array. q (int): The number of operations. array (List[int]): The initial array. operations (List[Tuple[int, int, int]]): A list of operations. Each operation is specified as a tuple (l, r, k), where l and r specify the range of the subarray (inclusive), and k is the value to add. Returns: List[int]: The final state of the array after all operations. Examples: >>> perform_operations(5, 3, [1, 2, 3, 4, 5], [(1, 3, 1), (2, 5, -2), (3, 3, 5)]) [2, 1, 7, 2, 3] >>> perform_operations(4, 2, [4, 5, 6, 7], [(1, 4, 2), (1, 3, -3)]) [3, 4, 5, 9]","solution":"def perform_operations(n, q, array, operations): # Convert operations indices to zero-based for easier processing for l, r, k in operations: for i in range(l-1, r): array[i] += k return array"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): Builds a binary tree from a list of tuples. >>> build_tree([(1, 2, 3), (2, 4, -1), (3, -1, 5), (4, -1, -1), (5, -1, -1)]).val == 1 True >>> build_tree([(1, 2, 3), (2, 4, 5), (3, -1, -1), (4, -1, -1), (5, -1, -1)]).left.val == 2 True if not nodes: return None tree_nodes = {i: TreeNode(i) for i in range(1, len(nodes) + 1)} for i in range(len(nodes)): value, left, right = nodes[i] if left != -1: tree_nodes[value].left = tree_nodes[left] if right != -1: tree_nodes[value].right = tree_nodes[right] return tree_nodes[1] def diameter_of_binary_tree(root): Returns the diameter of the given binary tree. >>> root = build_tree([(1, 2, 3), (2, 4, -1), (3, -1, 5), (4, -1, -1), (5, -1, -1)]) >>> diameter_of_binary_tree(root) == 4 True >>> root = build_tree([(1, 2, 3), (2, 4, 5), (3, -1, -1), (4, -1, -1), (5, -1, -1)]) >>> diameter_of_binary_tree(root) == 3 True def longest_path(node): if not node: return (0, 0) left_length, left_diameter = longest_path(node.left) right_length, right_diameter = longest_path(node.right) max_diameter = max(left_diameter, right_diameter, left_length + right_length) return (max(left_length, right_length) + 1, max_diameter) return longest_path(root)[1] def main(): import sys input = sys.stdin.read data = input().strip().split('n') n = int(data[0]) nodes = [] for i in range(1, n + 1): x, l, r = map(int, data[i].split()) nodes.append((x, l, r)) root = build_tree(nodes) print(diameter_of_binary_tree(root)) if __name__ == \\"__main__\\": main()","solution":"import sys sys.setrecursionlimit(200000) class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): if not nodes: return None tree_nodes = {i: TreeNode(i) for i in range(1, len(nodes) + 1)} for i in range(len(nodes)): value, left, right = nodes[i] if left != -1: tree_nodes[value].left = tree_nodes[left] if right != -1: tree_nodes[value].right = tree_nodes[right] return tree_nodes[1] def diameter_of_binary_tree(root): def longest_path(node): if not node: return (0, 0) left_length, left_diameter = longest_path(node.left) right_length, right_diameter = longest_path(node.right) max_diameter = max(left_diameter, right_diameter, left_length + right_length) return (max(left_length, right_length) + 1, max_diameter) return longest_path(root)[1] def main(): import sys input = sys.stdin.read data = input().strip().split('n') n = int(data[0]) nodes = [] for i in range(1, n + 1): x, l, r = map(int, data[i].split()) nodes.append((x, l, r)) root = build_tree(nodes) print(diameter_of_binary_tree(root)) if __name__ == \\"__main__\\": main()"},{"question":"def rearrangeArray(arr): Rearranges the array such that the difference between any two consecutive elements is minimized. If there are multiple possible arrangements, return the lexicographically smallest arrangement. Examples: >>> rearrangeArray([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> rearrangeArray([10, 7, 5, 3, 8, 2]) [2, 3, 5, 7, 8, 10] from solution import rearrangeArray def test_rearrangeArray_example1(): assert rearrangeArray([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] def test_rearrangeArray_example2(): assert rearrangeArray([10, 7, 5, 3, 8, 2]) == [2, 3, 5, 7, 8, 10] def test_rearrangeArray_all_positive(): assert rearrangeArray([20, 50, 30, 10, 40]) == [10, 20, 30, 40, 50] def test_rearrangeArray_all_negative(): assert rearrangeArray([-5, -10, -3, -1, -7]) == [-10, -7, -5, -3, -1] def test_rearrangeArray_mixed_sign(): assert rearrangeArray([-1, 3, -4, 2, 0]) == [-4, -1, 0, 2, 3] def test_rearrangeArray_single_element(): assert rearrangeArray([5]) == [5] def test_rearrangeArray_two_elements(): assert rearrangeArray([5, 1]) == [1, 5] def test_rearrangeArray_duplicates(): assert rearrangeArray([1, 2, 2, 1, 3, 3, 3]) == [1, 1, 2, 2, 3, 3, 3]","solution":"def rearrangeArray(arr): Rearranges the array such that the difference between any two consecutive elements is minimized. If there are multiple possible arrangements, returns the lexicographically smallest arrangement. return sorted(arr)"},{"question":"def can_pack_all_products(C_l: int, C_w: int, product_dimensions: List[Tuple[int, int]]) -> str: Determines if it is possible to pack all rectangular products into the shipping container without overlapping, with possible rotation by 90 degrees. >>> can_pack_all_products(10, 10, [(4, 6), (5, 5), (3, 3)]) == \\"YES\\" >>> can_pack_all_products(8, 8, [(7, 4), (5, 5)]) == \\"NO\\" def test_can_pack_all_products(): assert can_pack_all_products(10, 10, [(4, 6), (5, 5), (3, 3)]) == \\"YES\\" assert can_pack_all_products(8, 8, [(7, 4), (5, 5)]) == \\"NO\\" assert can_pack_all_products(5, 5, [(5, 5)]) == \\"YES\\" assert can_pack_all_products(5, 5, [(5, 6)]) == \\"NO\\" assert can_pack_all_products(10, 10, [(5, 5), (5, 5), (5, 5), (5, 5)]) == \\"YES\\" assert can_pack_all_products(20, 20, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == \\"YES\\" def test_edge_cases(): assert can_pack_all_products(1, 1, [(1, 1)]) == \\"YES\\" assert can_pack_all_products(1, 1, [(2, 1)]) == \\"NO\\" assert can_pack_all_products(1, 1, [(1, 2)]) == \\"NO\\" if __name__ == \\"__main__\\": test_can_pack_all_products() test_edge_cases() print(\\"All tests passed!\\")","solution":"def can_pack_all_products(C_l, C_w, product_dimensions): product_dimensions.sort(key=lambda x: max(x), reverse=True) positions = [] def is_overlap(rec1, rec2): if (rec1[0] >= rec2[0] + rec2[2] or rec2[0] >= rec1[0] + rec1[2] or rec1[1] >= rec2[1] + rec2[3] or rec2[1] >= rec1[1] + rec1[3]): return False return True def can_place(position, dimensions): l, w = dimensions if position[0] + l > C_l or position[1] + w > C_w: return False for pos in positions: if is_overlap(pos, (position[0], position[1], l, w)): return False return True def backtracking(index): if index == len(product_dimensions): return True l, w = product_dimensions[index] for x in range(C_l): for y in range(C_w): if can_place((x, y), (l, w)): positions.append((x, y, l, w)) if backtracking(index + 1): return True positions.pop() if can_place((x, y), (w, l)): positions.append((x, y, w, l)) if backtracking(index + 1): return True positions.pop() return False if backtracking(0): return \\"YES\\" else: return \\"NO\\" # read and prepare input def main(): import sys input = sys.stdin.read data = input().split() C_l, C_w = int(data[0]), int(data[1]) n = int(data[2]) product_dimensions = [] for i in range(n): P_l, P_w = int(data[3 + 2*i]), int(data[4 + 2*i]) product_dimensions.append((P_l, P_w)) print(can_pack_all_products(C_l, C_w, product_dimensions)) # if this script is run directly, we will call the \`main\` function. if __name__ == \\"__main__\\": main()"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression string containing non-negative integers and operators '+', '-', '*', and '/'. The function respects standard operator precedence and uses integer division for '/'. :param expression: A string representing the mathematical expression :return: The result of the expression as an integer >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10+2*6/4-3\\") == 10 >>> evaluate_expression(\\"10+2-1*5/5\\") == 11 >>> evaluate_expression(\\"100-5*20/4\\") == 75 >>> evaluate_expression(\\"(2+3)*2\\") == 10 >>> evaluate_expression(\\"10+(2*5)-3\\") == 17 pass def test_evaluate_expression_simple(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_evaluate_expression_with_division(): assert evaluate_expression(\\"10+2*6/4-3\\") == 10 def test_evaluate_expression_with_multiple_operations(): assert evaluate_expression(\\"10+2-1*5/5\\") == 11 def test_evaluate_expression_with_multiple_digits(): assert evaluate_expression(\\"100-5*20/4\\") == 75 def test_evaluate_expression_with_parentheses(): assert evaluate_expression(\\"(2+3)*2\\") == 10 def test_evaluate_expression_with_parentheses_and_multiple_operations(): assert evaluate_expression(\\"10+(2*5)-3\\") == 17","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression string containing non-negative integers and operators '+', '-', '*', and '/'. The function respects the standard operator precedence and uses integer division for '/'. :param expression: A string representing the mathematical expression :return: The result of the expression as an integer def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left // right) # integer division def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"def canFormNote(magazine: str, note: str) -> int: Determines if the note can be formed using the words from the magazine. Args: magazine (str): The string containing words from magazine. note (str): The string containing words from note. Returns: int: 1 if note can be formed, otherwise 0. Examples: >>> canFormNote(\\"hello world this is a test\\", \\"this is a test\\") 1 >>> canFormNote(\\"hello world this is a test\\", \\"this is not a test\\") 0","solution":"def canFormNote(magazine, note): Determines if the note can be formed using the words from the magazine. Args: magazine (str): The string containing words from magazine. note (str): The string containing words from note. Returns: int: 1 if note can be formed, otherwise 0. from collections import Counter magazine_words = magazine.split() note_words = note.split() magazine_count = Counter(magazine_words) note_count = Counter(note_words) for word, count in note_count.items(): if magazine_count[word] < count: return 0 return 1"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to transform the given string s into a palindrome. >>> min_operations_to_palindrome(\\"abba\\") == 0 >>> min_operations_to_palindrome(\\"ab\\") == 1 >>> min_operations_to_palindrome(\\"aaa\\") == 0 def solve(test_cases: List[str]) -> List[int]: For each test case, determine the minimum number of operations required to transform the given string into a palindrome. >>> solve([\\"abba\\", \\"ab\\", \\"aaa\\"]) == [0, 1, 0] >>> solve([\\"a\\", \\"b\\", \\"abab\\", \\"abcd\\"]) == [0, 0, 2, 2] from typing import List def test_min_operations_to_palindrome(): assert min_operations_to_palindrome(\\"abba\\") == 0 assert min_operations_to_palindrome(\\"ab\\") == 1 assert min_operations_to_palindrome(\\"aaa\\") == 0 assert min_operations_to_palindrome(\\"a\\") == 0 assert min_operations_to_palindrome(\\"abcba\\") == 0 assert min_operations_to_palindrome(\\"abcca\\") == 1 def test_solve(): assert solve([\\"abba\\", \\"ab\\", \\"aaa\\"]) == [0, 1, 0] assert solve([\\"a\\", \\"b\\", \\"abab\\", \\"abcd\\"]) == [0, 0, 2, 2] assert solve([\\"\\", \\"abba\\"]) == [0, 0]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform the given string s into a palindrome. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations def solve(test_cases): results = [] for s in test_cases: results.append(min_operations_to_palindrome(s)) return results"},{"question":"def game_outcome(N, M): Determines the outcome of the game for the given grid dimensions NxM. Args: N (int): Number of rows of the grid. M (int): Number of columns of the grid. Returns: str: The outcome of the game (\\"Robin\\", \\"Marian\\", or \\"Tie\\"). >>> game_outcome(2, 3) \\"Tie\\" >>> game_outcome(4, 4) \\"Tie\\" >>> game_outcome(5, 5) \\"Robin\\" >>> game_outcome(1, 1) \\"Robin\\" >>> game_outcome(1000000, 1000000) \\"Tie\\" >>> game_outcome(1000001, 1000001) \\"Robin\\" # Implement your code here def determine_outcomes(test_cases): Determines the game outcomes for multiple test cases. Args: test_cases (list of tuples): List containing tuples of (N, M). Returns: list of str: The outcomes of the game for each test case. >>> determine_outcomes([(2, 3), (4, 4), (5, 5)]) [\\"Tie\\", \\"Tie\\", \\"Robin\\"] >>> determine_outcomes([(1, 1), (1000000, 1000000), (1000001, 1000001)]) [\\"Robin\\", \\"Tie\\", \\"Robin\\"] # Implement your code here","solution":"def game_outcome(N, M): Determines the outcome of the game for the given grid dimensions NxM. Args: N (int): Number of rows of the grid. M (int): Number of columns of the grid. Returns: str: The outcome of the game (\\"Robin\\", \\"Marian\\", or \\"Tie\\"). total_cells = N * M if total_cells % 2 == 0: return \\"Tie\\" else: return \\"Robin\\" def determine_outcomes(test_cases): Determines the game outcomes for multiple test cases. Args: test_cases (list of tuples): List containing tuples of (N, M). Returns: list of str: The outcomes of the game for each test case. results = [] for N, M in test_cases: results.append(game_outcome(N, M)) return results"},{"question":"def calculate_total_magical_energy(m: int, e: int, energies: List[int], pathways: List[Tuple[int, int]]) -> int: Calculate the sum of magical energies for all the connected pairs in the forest. Parameters: m (int): Number of mystical animals in the forest. e (int): Number of magical pathways. energies (List[int]): List of integers representing the magical energy levels of the animals. pathways (List[Tuple[int, int]]): List of tuples where each tuple represents a magical pathway between two animals. Returns: int: The total sum of the absolute differences of magical energy levels for all connected pairs. Examples: >>> calculate_total_magical_energy(4, 3, [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4)]) 30 >>> calculate_total_magical_energy(5, 4, [5, 15, 25, 35, 45], [(1, 2), (2, 3), (3, 4), (4, 5)]) 40","solution":"def calculate_total_magical_energy(m, e, energies, pathways): total_energy = 0 for u, v in pathways: total_energy += abs(energies[u - 1] - energies[v - 1]) return total_energy"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string \`s\`. If all characters are repeating, returns an empty string. >>> first_non_repeating_character(\\"leetcode\\") 'l' >>> first_non_repeating_character(\\"aabbcc\\") '' >>> first_non_repeating_character(\\"aabbc\\") 'c' >>> first_non_repeating_character(\\"abcabcde\\") 'd' >>> first_non_repeating_character(\\"aabbdccd\\") '' >>> first_non_repeating_character(\\"abacabad\\") 'c'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string \`s\`. If all characters are repeating, returns an empty string. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that occurs only once for char in s: if char_count[char] == 1: return char return ''"},{"question":"def has_duplicates(s: str) -> str: Returns \\"YES\\" if the string s has any duplicate characters, otherwise \\"NO\\". >>> has_duplicates(\\"abc\\") \\"NO\\" >>> has_duplicates(\\"hello\\") \\"YES\\" >>> has_duplicates(\\"world\\") \\"NO\\" >>> has_duplicates(\\"a\\") \\"NO\\" >>> has_duplicates(\\"aa\\") \\"YES\\" >>> has_duplicates(\\"abac\\") \\"YES\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases and returns the results for each case. >>> process_test_cases(3, [\\"abc\\", \\"hello\\", \\"world\\"]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"a\\", \\"aa\\"]) [\\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"ab\\", \\"bb\\"]) [\\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"abcd\\"]) [\\"NO\\"] >>> process_test_cases(4, [\\"abcd\\", \\"abb\\", \\"aacc\\", \\"xyz\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def has_duplicates(s): Returns \\"YES\\" if the string s has any duplicate characters, otherwise \\"NO\\". return \\"YES\\" if len(set(s)) < len(s) else \\"NO\\" def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(has_duplicates(s)) return results"},{"question":"def recommend_products(product_info: List[str], n: int, k: int) -> Dict[str, List[str]]: Determine the daily recommended products for each category based on popularity scores and constraints. This function returns a dictionary where keys are category names and values are lists of recommended products. Args: product_info (List[str]): List of product information, where each element is a string containing product name, popularity score, and categories. n (int): Number of products. k (int): Number of recommendations per category. Returns: Dict[str, List[str]]: Dictionary containing the recommended products for each category. def main(input_data: str) -> str: Read the input data, process the recommendations, and return the output as a string. Args: input_data (str): Raw input data with product information and categories. Returns: str: Output string showing the top k recommended products for each category. >>> input_data = \\"6 3nproduct1 500 electronics childrennproduct2 800 electronicsnproduct3 600 sportsnproduct4 700 sports electronicsnproduct5 750 childrennproduct6 650 children sportsnend\\" >>> main(input_data) \\"children: product5 product6 product1nelectronics: product2 product4 product1nsports: product4 product6 product3\\" >>> input_data = \\"4 2nitem1 100 toysnitem2 200 toys toolsnitem3 150 toolsnitem4 250 tools toysnend\\" >>> main(input_data) \\"tools: item4 item2ntoys: item4 item2\\"","solution":"def recommend_products(product_info, n, k): from collections import defaultdict, Counter # Parse input category_map = defaultdict(list) products = [] for info in product_info: parts = info.split() product_name = parts[0] score = int(parts[1]) categories = parts[2:] products.append((product_name, score)) for category in categories: category_map[category].append((product_name, score)) # Determine recommendations recommendations = defaultdict(list) total_count = Counter() for category in category_map: # Sort products in each category by score, breaking ties by input order sorted_products = sorted(category_map[category], key=lambda x: (-x[1], products.index(x))) cur_rec = [] for product, score in sorted_products: if total_count[product] < 2: cur_rec.append(product) total_count[product] += 1 if len(cur_rec) == k: break recommendations[category] = cur_rec return recommendations # Read input def main(input_data): lines = input_data.strip().split(\\"n\\") n, k = map(int, lines[0].split()) product_info = lines[1:-1] recommendations = recommend_products(product_info, n, k) result = [] for category in sorted(recommendations): res_line = f\\"{category}: {' '.join(recommendations[category])}\\" result.append(res_line) return \\"n\\".join(result)"},{"question":"def max_boxes(weight_limit: int, num_boxes: int, box_weights: List[int]) -> int: Determines the maximum number of boxes that can be shipped in a single trip without exceeding the weight limit. :param weight_limit: int, weight limit for a single trip :param num_boxes: int, number of boxes :param box_weights: list of int, weights of the boxes :return: int, maximum number of boxes that can be shipped in a single trip >>> max_boxes(50, 5, [10, 20, 30, 40, 50]) 2 >>> max_boxes(100, 6, [20, 30, 10, 50, 40, 15]) 4 >>> max_boxes(15, 3, [5, 5, 5]) 3 >>> max_boxes(5, 3, [10, 10, 10]) 0 >>> max_boxes(10, 1, [10]) 1 >>> max_boxes(5, 1, [10]) 0 >>> max_boxes(100, 3, [20, 30, 40]) 3","solution":"def max_boxes(weight_limit, num_boxes, box_weights): Determines the maximum number of boxes that can be shipped in a single trip without exceeding the weight limit. :param weight_limit: int, weight limit for a single trip :param num_boxes: int, number of boxes :param box_weights: list of int, weights of the boxes :return: int, maximum number of boxes that can be shipped in a single trip box_weights.sort() current_weight = 0 count = 0 for weight in box_weights: if current_weight + weight <= weight_limit: current_weight += weight count += 1 else: break return count"},{"question":"from typing import List, Tuple def sieve_of_eratosthenes(n: int) -> List[bool]: Creates a list of boolean values, where True denotes that the index is a prime number. Uses the Sieve of Eratosthenes algorithm. # Implementation goes here def count_primes_in_ranges(T: int, ranges: List[Tuple[int, int]]) -> List[int]: For each range [L, R], count the prime numbers in that range. Args: T - Number of test cases ranges - List of tuples containing the range (L, R) for each test case Returns: A list of integers where each integer is the count of prime numbers within the corresponding range. Example: >>> count_primes_in_ranges(2, [(1, 10), (11, 20)]) == [4, 4] >>> count_primes_in_ranges(1, [(8, 10)]) == [0] # Implementation goes here # Unit Test def test_count_primes_in_ranges(): assert count_primes_in_ranges(2, [(1, 10), (11, 20)]) == [4, 4] assert count_primes_in_ranges(2, [(2, 2), (19, 19)]) == [1, 1] assert count_primes_in_ranges(2, [(4, 4), (20, 20)]) == [0, 0] assert count_primes_in_ranges(1, [(8, 10)]) == [0] assert count_primes_in_ranges(1, [(1, 100000)]) == [9592] assert count_primes_in_ranges(3, [(1, 10), (11, 30), (100, 200)]) == [4, 6, 21]","solution":"def sieve_of_eratosthenes(n): Creates a list of boolean values, where True denotes that the index is a prime number. Uses the Sieve of Eratosthenes algorithm. sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers p = 2 while (p * p <= n): if sieve[p] == True: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 return sieve def count_primes_in_ranges(T, ranges): For each range [L, R], count the prime numbers in that range. max_range = max(r for _, r in ranges) primes = sieve_of_eratosthenes(max_range) results = [] for L, R in ranges: count = sum(primes[L:R + 1]) results.append(count) return results"},{"question":"def find_top_k_incidents(n, severity_levels, k): Finds the top k most severe incidents from a list of severity levels. Parameters: n (int): Number of incidents. severity_levels (list of int): A list of severity levels. k (int): Number of top incidents to identify. Returns: List of int: The severity levels of the top k incidents in descending order. pass # Test cases def test_top_3_incidents(): assert find_top_k_incidents(10, [1, 23, 5, 76, 8, 45, 9, 4, 12, 15], 3) == [76, 45, 23] def test_all_same_severity(): assert find_top_k_incidents(5, [20, 20, 20, 20, 20], 3) == [20, 20, 20] def test_k_equals_n(): assert find_top_k_incidents(5, [12, 15, 7, 3, 19], 5) == [19, 15, 12, 7, 3] def test_k_is_zero(): assert find_top_k_incidents(5, [12, 15, 7, 3, 19], 0) == [] def test_large_numbers(): assert find_top_k_incidents(6, [1000000, 999999, 1, 2, 3, 10], 2) == [1000000, 999999] def test_small_inputs(): assert find_top_k_incidents(2, [7, 14], 1) == [14] def test_ties_in_severity_levels(): assert find_top_k_incidents(5, [50, 40, 50, 40, 30], 3) == [50, 50, 40]","solution":"def find_top_k_incidents(n, severity_levels, k): Finds the top k most severe incidents from a list of severity levels. Parameters: n (int): Number of incidents. severity_levels (list of int): A list of severity levels. k (int): Number of top incidents to identify. Returns: List of int: The severity levels of the top k incidents in descending order. if k == 0: return [] # Sort the severity_levels in descending order and return the k most severe incidents top_k_incidents = sorted(severity_levels, reverse=True)[:k] return top_k_incidents # Usage example (would be commented out in a module file): # n = int(input()) # severity_levels = list(map(int, input().split())) # k = int(input()) # print(*find_top_k_incidents(n, severity_levels, k))"},{"question":"def encode_string(s: str) -> str: Encode the string so that each sequence of the same character is represented by the character followed by the count of its occurrence. Return the encoded string if it is shorter than the original, otherwise return the original string. >>> encode_string(\\"aaabbcccc\\") \\"a3b2c4\\" >>> encode_string(\\"abc\\") \\"abc\\" >>> encode_string(\\"AABBBCCCCDDD\\") \\"A2B3C4D3\\" >>> encode_string(\\"A1A1A1B2B2B2\\") \\"A1A1A1B2B2B2\\" >>> encode_string(\\"a\\") \\"a\\" >>> encode_string(\\"abababab\\") \\"abababab\\" >>> encode_string(\\"aaabbbccccdddde\\") \\"a3b3c4d4e1\\" >>> encode_string(\\"aaaaaaaaaaaaaaaa\\") \\"a16\\" pass","solution":"def encode_string(s: str) -> str: Encode the string so that each sequence of the same character is represented by the character followed by the count of its occurrence. Return the encoded string if it is shorter than the original, otherwise return the original string. if not s: return s encoded = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{current_char}{count}\\") current_char = char count = 1 # append the last processed character and count encoded.append(f\\"{current_char}{count}\\") encoded_string = ''.join(encoded) return encoded_string if len(encoded_string) < len(s) else s"},{"question":"def process_game(N: int, Q: int, players: List[Tuple[int, int]], queries: List[str]) -> List[int]: A game involves N players numbered from 1 to N, each with a unique skill rating S_i. The players are divided into M teams, numbered from 1 to M. Each player i is initially assigned to a team T_i. The game organizer asks you to perform Q queries, where a query can either move a player from one team to another or request the maximum sum of skill ratings of two different players from the same team. For each move, you will update the player's team assignment, and for each query for the maximum sum, you will return the result. Parameters: N (int): Number of players. Q (int): Number of queries. players (List[Tuple[int, int]]): List of tuples, each containing skill and initial team of each player. queries (List[str]): List of queries to process. Returns: List[int]: Results of queries of the type '2 t', where we return the maximum sum of skill ratings of two different players from team t. Example: >>> N = 5 >>> Q = 6 >>> players = [(10, 1), (20, 1), (30, 2), (40, 3), (50, 3)] >>> queries = [ ... \\"1 1 3\\", ... \\"2 1\\", ... \\"2 2\\", ... \\"1 4 1\\", ... \\"2 1\\", ... \\"2 3\\" ... ] >>> process_game(N, Q, players, queries) [0, 0, 60, 60] pass # Sample unit tests import pytest def test_sample_case(): N = 5 Q = 6 players = [(10, 1), (20, 1), (30, 2), (40, 3), (50, 3)] queries = [ \\"1 1 3\\", \\"2 1\\", \\"2 2\\", \\"1 4 1\\", \\"2 1\\", \\"2 3\\" ] assert process_game(N, Q, players, queries) == [0, 0, 60, 60] def test_single_player_case(): N = 1 Q = 2 players = [(10, 1)] queries = [ \\"1 1 1\\", \\"2 1\\" ] assert process_game(N, Q, players, queries) == [0] def test_no_players_in_team(): N = 2 Q = 1 players = [(10, 1), (20, 2)] queries = [\\"2 3\\"] assert process_game(N, Q, players, queries) == [0] def test_all_players_same_team(): N = 3 Q = 1 players = [(10, 1), (20, 1), (30, 1)] queries = [\\"2 1\\"] assert process_game(N, Q, players, queries) == [50] def test_change_team_then_query(): N = 3 Q = 2 players = [(10, 1), (20, 1), (30, 2)] queries = [\\"1 3 1\\", \\"2 1\\"] assert process_game(N, Q, players, queries) == [50]","solution":"import heapq def process_game(N, Q, players, queries): # Create an initial team map team_map = {} # Create skill and team lookup dictionaries skill_dict = {} team_dict = {} for i in range(1, N + 1): skill, team = players[i - 1] skill_dict[i] = skill team_dict[i] = team if team not in team_map: team_map[team] = [] # We use negative values because heapq is a min-heap by default in Python heapq.heappush(team_map[team], -skill) result = [] def max_sum_team(team): if not team in team_map or len(team_map[team]) < 2: return 0 # Get the top two elements (largest skills) first = -heapq.heappop(team_map[team]) second = -heapq.heappop(team_map[team]) # Always push them back as we only need to look at them heapq.heappush(team_map[team], -first) heapq.heappush(team_map[team], -second) return first + second for query in queries: parts = query.split() if parts[0] == '1': player = int(parts[1]) new_team = int(parts[2]) old_team = team_dict[player] skill = skill_dict[player] # Remove skill from old team's heap team_map[old_team].remove(-skill) heapq.heapify(team_map[old_team]) # Add the skill to the new team's heap if new_team not in team_map: team_map[new_team] = [] heapq.heappush(team_map[new_team], -skill) # Update team dict team_dict[player] = new_team elif parts[0] == '2': team = int(parts[1]) result.append(max_sum_team(team)) return result"},{"question":"def longestIncreasingContiguousSubarray(sizes): Returns the length of the longest increasing contiguous subarray. # Implement function logic here def process_cases(t, cases): Process multiple test cases and return the results. # Implement function logic here # Tests def test_basic_case(): assert longestIncreasingContiguousSubarray([1, 2, 2, 3, 4, 1]) == 3 def test_all_decreasing(): assert longestIncreasingContiguousSubarray([5, 4, 3, 2, 1]) == 1 def test_all_increasing(): assert longestIncreasingContiguousSubarray([1, 2, 3, 4, 5]) == 5 def test_mixed_sequence(): assert longestIncreasingContiguousSubarray([1, 3, 5, 4, 6, 7]) == 3 def test_single_element(): assert longestIncreasingContiguousSubarray([10]) == 1 def test_repeated_same_size(): assert longestIncreasingContiguousSubarray([2, 2, 2, 2, 2]) == 1 def test_variable_cases(): test_cases = [ (6, [1, 2, 2, 3, 4, 1]), (5, [5, 4, 3, 2, 1]), (4, [4, 5, 1, 2]), (3, [1, 2, 3]), (7, [10, 20, 10, 20, 30, 40, 50]) ] results = process_cases(5, test_cases) assert results == [3, 1, 2, 3, 5]","solution":"def longestIncreasingContiguousSubarray(sizes): Returns the length of the longest increasing contiguous subarray. n = len(sizes) if n == 0: return 0 longest = 1 current_length = 1 for i in range(1, n): if sizes[i] > sizes[i - 1]: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest def process_cases(t, cases): results = [] for i in range(t): n = cases[i][0] sizes = cases[i][1] result = longestIncreasingContiguousSubarray(sizes) results.append(result) return results"},{"question":"def count_valid_sequences(n: int, k: int, target: int) -> int: This function returns the number of valid sequences of length n where each number is between 1 and k and the sum of the numbers is exactly target. >>> count_valid_sequences(3, 2, 4) 3 >>> count_valid_sequences(2, 3, 5) 2 >>> count_valid_sequences(4, 1, 4) 1 >>> count_valid_sequences(1, 5, 5) 1 >>> count_valid_sequences(2, 2, 5) 0 def solve(test_cases: List[Tuple[int, int, int]]) -> List[int]: This function processes multiple test cases and returns a list of results. Args: test_cases: A list of tuples where each tuple contains three integers n, k, and target. >>> solve([(3, 2, 4), (2, 3, 5)]) [3, 2] >>> solve([(4, 1, 4), (1, 5, 5), (2, 2, 5)]) [1, 1, 0]","solution":"def count_valid_sequences(n, k, target): This function returns the number of valid sequences of length n where each number is between 1 and k and the sum of the numbers is exactly target. # Initialize DP table dp = [[0] * (target + 1) for _ in range(n + 1)] # Base case: There's one way to make a sum of 0 with 0 numbers dp[0][0] = 1 # Fill the DP table for i in range(1, n + 1): for current_sum in range(target + 1): for number in range(1, k + 1): if current_sum >= number: dp[i][current_sum] += dp[i - 1][current_sum - number] return dp[n][target] def solve(test_cases): result = [] for n, k, target in test_cases: result.append(count_valid_sequences(n, k, target)) return result"},{"question":"def maximalRectangle(matrix: List[List[str]]) -> int: Given a binary matrix, determine the area of the largest rectangle containing only '1's and return its area. >>> maximalRectangle([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\"] ... ]) == 4 >>> maximalRectangle([ ... [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) == 6 >>> maximalRectangle([ ... [\\"0\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"0\\"] ... ]) == 2 >>> maximalRectangle([ ... [\\"1\\"] ... ]) == 1 >>> maximalRectangle([ ... [\\"0\\"] ... ]) == 0 >>> maximalRectangle([ ... [\\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\"] ... ]) == 1 def convert_input_to_matrix(input_list: List[str]) -> List[List[str]]: Convert input list of lists from string representation to a matrix. >>> convert_input_to_matrix([ ... \\"1 0\\", ... \\"0 1\\" ... ]) == [ ... [\\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\"] ... ]","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 dp = [0] * len(matrix[0]) for i in range(len(matrix)): for j in range(len(matrix[0])): dp[j] = dp[j] + 1 if matrix[i][j] == '1' else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [-1] max_area = 0 for i in range(len(heights)): while stack[-1] != -1 and heights[stack[-1]] >= heights[i]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack[-1] != -1: h = heights[stack.pop()] w = len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area # Helper function to convert input list of lists from string representation def convert_input_to_matrix(input_list): return [line.split() for line in input_list]"},{"question":"def calculate_total_time(d1, s1, t1, d2, s2, t2, d3, s3, t3, d4, s4, t4): Calculates the total time each friend spends including walking away, walking back, and additional crowd navigation time. The input parameters are: d1, s1, t1: Distance, speed, and additional navigation time for the first friend. d2, s2, t2: Distance, speed, and additional navigation time for the second friend. d3, s3, t3: Distance, speed, and additional navigation time for the third friend. d4, s4, t4: Distance, speed, and additional navigation time for the fourth friend. The function will print the total time for each friend on a new line. def test_calculate_total_time(capsys): import builtins original_input = builtins.input builtins.input = lambda: \\"500 10 30n300 5 20n700 14 50n200 4 10\\" calculate_total_time(500, 10, 30, 300, 5, 20, 700, 14, 50, 200, 4, 10) builtins.input = original_input captured = capsys.readouterr() assert captured.out == \\"130n140n150n110n\\" def test_calculate_total_time_different_values(capsys): import builtins original_input = builtins.input builtins.input = lambda: \\"1000 20 100n800 10 80n600 15 60n400 8 40\\" calculate_total_time(1000, 20, 100, 800, 10, 80, 600, 15, 60, 400, 8, 40) builtins.input = original_input captured = capsys.readouterr() assert captured.out == \\"200n240n140n140n\\" def test_calculate_total_time_min_values(capsys): import builtins original_input = builtins.input builtins.input = lambda: \\"1 1 1n1 1 1n1 1 1n1 1 1\\" calculate_total_time(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) builtins.input = original_input captured = capsys.readouterr() assert captured.out == \\"3n3n3n3n\\" def test_calculate_total_time_max_values(capsys): import builtins original_input = builtins.input builtins.input = lambda: \\"1000 20 500n1000 20 500n1000 20 500n1000 20 500\\" calculate_total_time(1000, 20, 500, 1000, 20, 500, 1000, 20, 500, 1000, 20, 500) builtins.input = original_input captured = capsys.readouterr() assert captured.out == \\"600n600n600n600n\\"","solution":"def calculate_total_time(d1, s1, t1, d2, s2, t2, d3, s3, t3, d4, s4, t4): Calculates the total time each friend spends including walking away, walking back, and additional crowd navigation time. def total_time(d, s, t): # One way time walk_away_time = d / s # Return time walk_back_time = d / s # Total time return walk_away_time + walk_back_time + t # Calculate total times for all friends total_time1 = total_time(d1, s1, t1) total_time2 = total_time(d2, s2, t2) total_time3 = total_time(d3, s3, t3) total_time4 = total_time(d4, s4, t4) # Printing the results as required print(int(total_time1)) print(int(total_time2)) print(int(total_time3)) print(int(total_time4))"},{"question":"def findSecondLargest(arr): Finds the second largest element in an array. If no such element exists, returns -1. >>> findSecondLargest([10, 5, 20, 4, 8]) 10 >>> findSecondLargest([7, 7, 7, 7]) -1 >>> findSecondLargest([10]) -1 >>> findSecondLargest([10, 20]) 10 >>> findSecondLargest([10, 5, 10, 4, 8]) 8 >>> findSecondLargest([20, 19, 18, 17, 16]) 19 >>> findSecondLargest([-1, -5, -3, 0, 2, 4, 3]) 3 >>> findSecondLargest(list(range(10000))) 9998","solution":"def findSecondLargest(arr): Finds the second largest element in an array. If no such element exists, returns -1. if len(arr) < 2: return -1 first = second = -1 for num in arr: if num > first: second = first first = num elif first > num > second: second = num return second"},{"question":"def min_cost_difference(costs): Given a series of numbers representing the cost to build different sections of a road, divide these sections into two groups such that the difference between the total costs of the two groups is minimized. >>> min_cost_difference([3, 1, 4, 2, 2]) [6, 6] >>> min_cost_difference([10, 20, 15, 5, 5]) [25, 30] >>> min_cost_difference([1, 2, 3, 4, 5]) [7, 8] >>> min_cost_difference([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [27, 28] def process_input(data): Process the input data to read the number of test cases and each test case costs, then compute and return the minimal cost differences for all test cases. >>> process_input([\\"2\\", \\"3 1 4 2 2\\", \\"10 20 15 5 5\\"]) [[6, 6], [25, 30]] >>> process_input([\\"1\\", \\"1 1 1 1\\"]) [[2, 2]]","solution":"def min_cost_difference(costs): This function returns the two minimal cost groups with the closest possible difference. total_cost = sum(costs) n = len(costs) dp = [[False] * (total_cost // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_cost // 2 + 1): dp[i][j] = dp[i - 1][j] or (j >= costs[i - 1] and dp[i - 1][j - costs[i - 1]]) for j in range(total_cost // 2, -1, -1): if dp[n][j]: group1 = j break group2 = total_cost - group1 return sorted([group1, group2]) def process_input(data): results = [] T = int(data[0]) for i in range(1, T + 1): costs = list(map(int, data[i].split())) results.append(min_cost_difference(costs)) return results"},{"question":"def longest_substr_distinct_char(s: str) -> int: Finds the length of the longest substring with all distinct characters. >>> longest_substr_distinct_char(\\"abcabcbb\\") 3 >>> longest_substr_distinct_char(\\"bbbbb\\") 1 >>> longest_substr_distinct_char(\\"pwwkew\\") 3 def process_input(input_strings: List[str]) -> List[int]: Processes multiple input strings and computes the longest substring of distinct characters for each. >>> process_input([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\", \\"END\\"]) [3, 1, 3] >>> process_input([\\"a\\", \\"abcdefg\\", \\"\\", \\"END\\"]) [1, 7, 0] >>> process_input([\\"aaaaaa\\", \\"abcdabcdabcd\\", \\"ababc\\", \\"END\\"]) [1, 4, 3]","solution":"def longest_substr_distinct_char(s): Finds the length of the longest substring with all distinct characters. n = len(s) if n == 0: return 0 char_index = {} longest = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end longest = max(longest, end - start + 1) return longest def process_input(input_strings): Processes multiple input strings and computes the longest substring of distinct characters for each. results = [] for s in input_strings: if s == \\"END\\": break results.append(longest_substr_distinct_char(s)) return results"},{"question":"def can_assign_tasks(n: int, m: int, skill_levels: List[int], tasks: List[Tuple[int, int]]) -> str: Determine whether it's possible to assign each task to a student such that every student's skill level matches the task requirements. :param n: Integer, number of students :param m: Integer, number of tasks :param skill_levels: List of integers, skill levels of the students :param tasks: List of tuples, each containing two integers representing the min and max skill requirements of a task :return: \\"YES\\" if it's possible to assign each task to exactly one student who meets the skill level requirements, otherwise \\"NO\\" >>> can_assign_tasks(6, 6, [3, 7, 5, 6, 9, 8], [(1, 4), (3, 5), (5, 7), (7, 9), (5, 9), (6, 8)]) \\"YES\\" >>> can_assign_tasks(5, 6, [3, 8, 2, 9, 7], [(1, 4), (3, 5), (5, 7), (7, 9), (5, 9), (6, 8)]) \\"NO\\"","solution":"def can_assign_tasks(n, m, skill_levels, tasks): Determine whether it's possible to assign each task to a student such that every student's skill level matches the task requirements. :param n: Integer, number of students :param m: Integer, number of tasks :param skill_levels: List of integers, skill levels of the students :param tasks: List of tuples, each containing two integers representing the min and max skill requirements of a task :return: \\"YES\\" if it's possible to assign each task to exactly one student who meets the skill level requirements, otherwise \\"NO\\" assigned = [False] * m # Sort skill levels and tasks by min requirement skill_levels.sort() tasks = sorted(tasks, key=lambda x: x[0]) task_index = 0 for skill in skill_levels: while task_index < m and (tasks[task_index][1] < skill): task_index += 1 if task_index < m and (tasks[task_index][0] <= skill <= tasks[task_index][1]): assigned[task_index] = True task_index += 1 return \\"YES\\" if all(assigned) else \\"NO\\""},{"question":"def manage_inventory(n: int, q: int, stock_levels: List[int], operations: List[str]) -> List[int]: Given initial stock levels and a series of operations, manage the inventory and respond to queries. Args: n (int): Number of items. q (int): Number of operations or queries. stock_levels (list): Initial stock levels of the items. operations (list): List of operations and queries. Returns: list: List of results for each query. >>> n = 5 >>> q = 6 >>> stock_levels = [10, 20, 30, 40, 50] >>> operations = [\\"DELIVERY 2 10\\", \\"SALE 3 5\\", \\"QUERY 2\\", \\"SALE 5 10\\", \\"DELIVERY 1 5\\", \\"QUERY 5\\"] >>> manage_inventory(n, q, stock_levels, operations) [30, 40] >>> n = 3 >>> q = 3 >>> stock_levels = [5, 10, 15] >>> operations = [\\"QUERY 1\\", \\"QUERY 2\\", \\"QUERY 3\\"] >>> manage_inventory(n, q, stock_levels, operations) [5, 10, 15] >>> n = 4 >>> q = 5 >>> stock_levels = [8, 16, 32, 64] >>> operations = [\\"DELIVERY 1 7\\", \\"SALE 4 10\\", \\"QUERY 1\\", \\"QUERY 4\\", \\"SALE 2 6\\"] >>> manage_inventory(n, q, stock_levels, operations) [15, 54] >>> n = 2 >>> q = 2 >>> stock_levels = [100, 200] >>> operations = [\\"QUERY 1\\", \\"QUERY 2\\"] >>> manage_inventory(n, q, stock_levels, operations) [100, 200]","solution":"def manage_inventory(n, q, stock_levels, operations): Given initial stock levels and a series of operations, manage the inventory and respond to queries. Args: n (int): Number of items. q (int): Number of operations or queries. stock_levels (list): Initial stock levels of the items. operations (list): List of operations and queries. Returns: list: List of results for each query. results = [] for operation in operations: op_details = operation.split() op_type = op_details[0] item_id = int(op_details[1]) - 1 if op_type == \\"DELIVERY\\": quantity = int(op_details[2]) stock_levels[item_id] += quantity elif op_type == \\"SALE\\": quantity = int(op_details[2]) stock_levels[item_id] -= quantity elif op_type == \\"QUERY\\": results.append(stock_levels[item_id]) return results"},{"question":"def calculate_max_bonus(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, calculate the maximum bonus an employee can achieve by summing up their productivity points in contiguous subarrays. If the employee's productivity points array has all elements negative, the employee receives a bonus of 0. Args: T (int): number of test cases test_cases (List[Tuple[int, List[int]]]): each tuple contains (N, productivity points list) Returns: List[int]: maximum possible bonus for each test case >>> calculate_max_bonus(1, [(4, [-1, 2, 3, -4])]) [5] >>> calculate_max_bonus(1, [(5, [-3, -2, -1, -4, -5])]) [0] >>> calculate_max_bonus(1, [(6, [1, -2, 3, 5, -1, 2])]) [9] >>> calculate_max_bonus(3, [ (4, [-1, 2, 3, -4]), (5, [-3, -2, -1, -4, -5]), (6, [1, -2, 3, 5, -1, 2]) ]) [5, 0, 9] >>> calculate_max_bonus(1, [(1, [5])]) [5] >>> calculate_max_bonus(1, [(1, [-5])]) [0]","solution":"def calculate_max_bonus(T, test_cases): For each test case, calculate the maximum bonus an employee can achieve. Args: T: int: number of test cases test_cases: list of tuples: each tuple contains (N, productivity points list) Returns: list of int: maximum possible bonus for each test case def max_subarray_sum(arr): max_so_far = current_max = float('-inf') all_negative = True for num in arr: if num >= 0: all_negative = False current_max = max(num, current_max + num) max_so_far = max(max_so_far, current_max) return 0 if all_negative else max(max_so_far, 0) results = [] for i in range(T): N, productivity_points = test_cases[i] results.append(max_subarray_sum(productivity_points)) return results"},{"question":"def longestConsecutive(nums): Returns the length of the longest consecutive elements sequence in the list nums. Args: nums (List[int]): List of integers. Returns: int: The length of the longest consecutive sequence. Example: >>> longestConsecutive([100, 4, 200, 1, 3, 2]) 4 >>> longestConsecutive([0, -1, 2, -3, 1, -2, 3]) 7 >>> longestConsecutive([]) 0 >>> longestConsecutive([1]) 1 >>> longestConsecutive([1, 2]) 2 >>> longestConsecutive([1, 3]) 1 >>> longestConsecutive([1, 1, 1, 1]) 1 >>> longestConsecutive([10, 5, 12, 4, 1, 2, 3, 11]) 5 >>> longestConsecutive([-1, -2, -3, -4]) 4","solution":"def longestConsecutive(nums): Returns the length of the longest consecutive elements sequence in the list nums. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # only start counting from the beginning of a sequence current_num = num current_streak = 1 while (current_num + 1) in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def countPairs(n: int, arr: List[int], x: int) -> int: Given a list of n integers and a target integer x, find out how many pairs of integers from the list add up to x. Each integer from the list can only be used once in a pair. >>> countPairs(5, [1, 5, 7, -1, 5], 6) 2 >>> countPairs(4, [1, 1, 1, 1], 2) 2 >>> countPairs(3, [1, 2, 3], 10) 0 >>> countPairs(4, [-1, -2, -3, -4], -5) 2 >>> countPairs(6, [1, -1, 2, -2, 3, -3], 0) 3 >>> countPairs(6, [1000000000, -1000000000, 999999999, -999999999, 1, -1], 0) 3","solution":"def countPairs(n, arr, x): count = 0 freq = {} for num in arr: complement = x - num if complement in freq and freq[complement] > 0: count += 1 freq[complement] -= 1 else: if num in freq: freq[num] += 1 else: freq[num] = 1 return count"},{"question":"def largest_island_area(n: int, m: int, grid: List[List[str]]) -> int: Given an n x m grid representing a village, return the area of the largest island present in the grid. An island is formed by a group of horizontally or vertically adjacent land cells ('L'). Water cells are represented by 'W'. >>> largest_island_area(4, 5, [['L', 'W', 'L', 'W', 'L'], ['L', 'L', 'L', 'L', 'W'], ['W', 'L', 'W', 'W', 'W'], ['W', 'W', 'L', 'L', 'L']]) 7 >>> largest_island_area(3, 3, [['W', 'W', 'W'], ['W', 'L', 'W'], ['W', 'W', 'W']]) 1 >>> largest_island_area(2, 2, [['W', 'W'], ['W', 'W']]) 0 from typing import List def test_largest_island_area_example1(): n, m = 4, 5 grid = [ ['L', 'W', 'L', 'W', 'L'], ['L', 'L', 'L', 'L', 'W'], ['W', 'L', 'W', 'W', 'W'], ['W', 'W', 'L', 'L', 'L'] ] assert largest_island_area(n, m, grid) == 7 def test_largest_island_area_example2(): n, m = 3, 3 grid = [ ['W', 'W', 'W'], ['W', 'L', 'W'], ['W', 'W', 'W'] ] assert largest_island_area(n, m, grid) == 1 def test_largest_island_area_example3(): n, m = 2, 2 grid = [ ['W', 'W'], ['W', 'W'] ] assert largest_island_area(n, m, grid) == 0 def test_largest_island_area_large_single_island(): n, m = 3, 3 grid = [ ['L', 'L', 'L'], ['L', 'L', 'L'], ['L', 'L', 'L'] ] assert largest_island_area(n, m, grid) == 9 def test_largest_island_area_separate_islands(): n, m = 4, 4 grid = [ ['L', 'W', 'L', 'W'], ['L', 'W', 'L', 'W'], ['W', 'W', 'W', 'W'], ['L', 'L', 'W', 'L'] ] assert largest_island_area(n, m, grid) == 2","solution":"def largest_island_area(n, m, grid): Returns the area of the largest island in the grid. def dfs(x, y): # Check if we're within the grid and on land if 0 <= x < n and 0 <= y < m and grid[x][y] == 'L': grid[x][y] = 'W' # Mark as visited by converting 'L' to 'W' return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) return 0 max_area = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Given an array arr and a non-negative integer k, rotate the array to the right by k steps. Parameters: arr (List[int]): A list of integers. k (int): A non-negative integer representing the number of steps to rotate the array. Returns: List[int]: The rotated array. Examples: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1], 3) [1] >>> rotate_array([1, 2, 3], 4) [3, 1, 2]","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. if not arr: # If the array is empty, return it as is return arr n = len(arr) k = k % n # Reduce k to be within the bounds of the array length return arr[-k:] + arr[:-k] if k else arr # Rotate the array"},{"question":"def find_cycle(n, m, edges): Determine whether there is a cycle in a directed graph and output one if found. >>> find_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 2 3 4 2 >>> find_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) No cycle >>> find_cycle(5, 5, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5)]) 1 2 3 1 pass","solution":"def find_cycle(n, m, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [0] * (n + 1) # 0 = not visited, 1 = visiting, 2 = visited stack = [] parent = [-1] * (n + 1) def dfs(v): visited[v] = 1 stack.append(v) for neighbour in graph[v]: if visited[neighbour] == 0: parent[neighbour] = v if dfs(neighbour): return True elif visited[neighbour] == 1: cycle = [] u = v while u != neighbour: cycle.append(u) u = parent[u] cycle.append(neighbour) cycle.append(v) cycle.reverse() print(\\" \\".join(map(str, cycle))) return True visited[v] = 2 stack.pop() return False for i in range(1, n + 1): if visited[i] == 0: if dfs(i): return print(\\"No cycle\\") # You can call this function with specific inputs to test the output."},{"question":"def longestEvenSubsequence(s: str) -> int: Determine the length of the longest subsequence of a given string where every character appears an even number of times. >>> longestEvenSubsequence(\\"aabbccdd\\") 8 >>> longestEvenSubsequence(\\"aabcbcbd\\") 6 # Write your code here # Unit tests def test_example_1(): assert longestEvenSubsequence(\\"aabbccdd\\") == 8 def test_example_2(): assert longestEvenSubsequence(\\"aabcbcbd\\") == 6 def test_all_characters_odd(): assert longestEvenSubsequence(\\"abc\\") == 0 def test_mixed_even_odd_characters(): assert longestEvenSubsequence(\\"aabbc\\") == 4 def test_single_character(): assert longestEvenSubsequence(\\"a\\") == 0 def test_empty_string(): assert longestEvenSubsequence(\\"\\") == 0 def test_large_input(): assert longestEvenSubsequence(\\"a\\" * 10**6) == 1000000 def test_large_input_mixed(): input_str = \\"ab\\" * 500000 assert longestEvenSubsequence(input_str) == 1000000","solution":"def longestEvenSubsequence(s: str) -> int: from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Initialize the length of the longest subsequence subseq_length = 0 # Traverse each character frequency for char, count in freq.items(): # Only add the even part of the frequency to the subsequence subseq_length += (count // 2) * 2 return subseq_length"},{"question":"from typing import List, Tuple def largest_number(nums: List[int]) -> str: Returns the largest number formed by concatenating the given list of integers. >>> largest_number([1, 2, 3, 4, 5]) \\"54321\\" >>> largest_number([10, 2, 9]) \\"9210\\" >>> largest_number([54, 546, 548, 60]) \\"6054854654\\" >>> largest_number([0, 0, 0]) \\"0\\" >>> largest_number([0, 1, 10]) \\"1100\\" pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases and returns the results. >>> process_test_cases([(3, [10, 2, 9])]) [\\"9210\\"] >>> process_test_cases([(3, [10, 2, 9]), (4, [54, 546, 548, 60])]) [\\"9210\\", \\"6054854654\\"] pass","solution":"from functools import cmp_to_key def largest_number(nums): Returns the largest number formed by concatenating the given list of integers. # Convert numbers to strings for comparison strs = list(map(str, nums)) # Define custom comparator def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the array with the custom comparator sorted_strs = sorted(strs, key=cmp_to_key(compare)) # Concatenate and return the largest number largest_num = ''.join(sorted_strs) # In case all numbers are zero if largest_num[0] == '0': return '0' return largest_num def process_test_cases(test_cases): results = [] for case in test_cases: n, nums = case results.append(largest_number(nums)) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. Args: head: ListNode - head of the singly linked list. k: int - group size to reverse. Returns: ListNode - the head of the modified list. Example: >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> reverseKGroup(head, 2) 2 -> 1 -> 4 -> 3 -> 5 >>> reverseKGroup(head, 3) 3 -> 2 -> 1 -> 4 -> 5 from solution import reverseKGroup, ListNode def list_to_linkedlist(lst): dummy = ListNode(0) current = dummy for num in lst: current.next = ListNode(num) current = current.next return dummy.next def linkedlist_to_list(node): result = [] while node: result.append(node.val) node = node.next return result def test_reverseKGroup(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 2 new_head = reverseKGroup(head, k) assert linkedlist_to_list(new_head) == [2, 1, 4, 3, 5] head = list_to_linkedlist([1, 2, 3, 4, 5, 6, 7, 8]) k = 3 new_head = reverseKGroup(head, k) assert linkedlist_to_list(new_head) == [3, 2, 1, 6, 5, 4, 7, 8] head = list_to_linkedlist([1]) k = 1 new_head = reverseKGroup(head, k) assert linkedlist_to_list(new_head) == [1] head = list_to_linkedlist([1, 2, 3]) k = 4 new_head = reverseKGroup(head, k) assert linkedlist_to_list(new_head) == [1, 2, 3] head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 5 new_head = reverseKGroup(head, k) assert linkedlist_to_list(new_head) == [5, 4, 3, 2, 1] def run_tests(): test_reverseKGroup() print(\\"All tests passed!\\") run_tests()","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Reverses the linked list in groups of size k. dummy = ListNode(0) dummy.next = head prev = dummy tail = dummy while True: count = 0 while tail and count < k: tail = tail.next count += 1 if not tail: # If the number of nodes is not a multiple of k break head_next = prev.next while prev.next != tail: tmp = prev.next prev.next = tmp.next tmp.next = tail.next tail.next = tmp tail = head_next prev = tail return dummy.next"},{"question":"def solve(test_cases): Determine if there exists a path that passes through exactly K empty cells on a board game. Args: test_cases (List[Tuple[int, int, int, List[str]]]): A list of test cases, where each test case is a tuple containing the number of rows, columns, required number of empty cells in the path, and the board representation. Returns: List[str]: A list of results for each test case (\\"YES\\" or \\"NO\\"). >>> solve([( 4, 4, 4, [ \\"...#\\", \\".#..\\", \\"....\\", \\"#.\\" ] )]) ['YES'] >>> solve([ (3, 3, 6, [ \\".\\", \\".#.\\", \\".\\" ]) ]) ['NO']","solution":"def exists_path_with_k_empty_cells(N, M, K, board): def is_within_bounds(x, y): return 0 <= x < N and 0 <= y < M def dfs(x, y, visited, count): if count == K: return True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and not visited[nx][ny] and board[nx][ny] == '.': visited[nx][ny] = True if dfs(nx, ny, visited, count + 1): return True visited[nx][ny] = False return False for i in range(N): for j in range(M): if board[i][j] == '.': visited = [[False] * M for _ in range(N)] visited[i][j] = True if dfs(i, j, visited, 1): return \\"YES\\" return \\"NO\\" def solve(test_cases): results = [] for N, M, K, board in test_cases: result = exists_path_with_k_empty_cells(N, M, K, board) results.append(result) return results"},{"question":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers in the list such that they add up to the target integer. Examples: >>> find_indices([2, 7, 11, 15], 9) (0, 1) >>> find_indices([3, 2, 4], 6) (1, 2) >>> find_indices([3, 3], 6) (0, 1)","solution":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers in the list such that they add up to the target integer. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index raise ValueError(\\"No two sum solution exists\\")"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between two strings s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"aaaa\\", \\"aa\\") 2 >>> longest_common_subsequence(\\"abcabc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abcdefgh\\", \\"aceg\\") 4 >>> longest_common_subsequence(\\"abcdefg\\", \\"bzf\\") 2","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence between two strings s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) return dp[m][n]"},{"question":"def total_cable_length(n: int, distances: List[int]) -> int: Given the number of computer stations \`n\` and a list of distances between adjacent stations in circular order, this function returns the total length of cables required to connect all stations optimally in a cyclic network. :param n: Integer, number of computer stations (3  n  100) :param distances: List of integers, distances between consecutive stations (1  d_i  1000) :return: Integer, total length of cables required to connect all stations # Example Tests def test_total_cable_length_example(): assert total_cable_length(5, [3, 2, 5, 4, 1]) == 15 def test_total_cable_length_min_values(): assert total_cable_length(3, [1, 1, 1]) == 3 def test_total_cable_length_max_values(): assert total_cable_length(100, [1000] * 100) == 1000 * 100 def test_total_cable_length_varied_values(): assert total_cable_length(4, [10, 20, 30, 40]) == 100 def test_total_cable_length_single_large_value(): assert total_cable_length(3, [1, 1000, 999]) == 2000","solution":"def total_cable_length(n, distances): Given the number of computer stations \`n\` and a list of distances between adjacent stations in circular order, this function returns the total length of cables required to connect all stations optimally in a cyclic network. :param n: Integer, number of computer stations (3  n  100) :param distances: List of integers, distances between consecutive stations (1  d_i  1000) :return: Integer, total length of cables required to connect all stations return sum(distances)"},{"question":"def unique_groups_of_chains(test_cases): Given a list of power levels of chains, determine the number of unique groups that can be formed. Args: test_cases (List[Tuple[int, List[int]]]): List where each element is a tuple containing the number of chains and a list of their power levels. Returns: List[int]: List containing the number of unique groups for each test case. >>> unique_groups_of_chains([(5, [3, 1, 2, 3, 2])]) [3] >>> unique_groups_of_chains([(4, [4, 4, 4, 4])]) [1] >>> unique_groups_of_chains([(5, [3, 1, 2, 3, 2]), (4, [4, 4, 4, 4])]) [3, 1] >>> unique_groups_of_chains([(1, [1])]) [1] >>> unique_groups_of_chains([(0, [])]) [0] >>> unique_groups_of_chains([(100, [i for i in range(1, 101)])]) [100] >>> unique_groups_of_chains([(6, [2, 2, 2, 3, 3, 1])]) [3]","solution":"def unique_groups_of_chains(test_cases): results = [] for case in test_cases: M, power_levels = case unique_group_count = len(set(power_levels)) results.append(unique_group_count) return results"},{"question":"def most_frequent_price(stock_data: List[str]) -> int: You are given a list of strings that represent stock symbols. Each stock symbol is associated with its corresponding price at the end of the day. Your task is to find the most frequently occurring price. If there are multiple prices with the same frequency, return the highest one among them. >>> most_frequent_price([\\"AAPL 150\\"]) 150 >>> most_frequent_price([\\"AAPL 150\\", \\"GOOG 80\\", \\"MSFT 80\\", \\"AMZN 150\\", \\"TSLA 80\\", \\"FB 150\\"]) 150 >>> most_frequent_price([\\"AAPL 150\\", \\"GOOG 80\\", \\"MSFT 90\\", \\"AMZN 100\\", \\"TSLA 70\\", \\"FB 110\\"]) 150 >>> most_frequent_price([\\"AAPL 150\\", \\"GOOG 80\\", \\"MSFT 90\\", \\"AMZN 80\\", \\"TSLA 150\\", \\"FB 90\\"]) 150 >>> most_frequent_price([\\"AAPL 150\\", \\"GOOG 150\\", \\"MSFT 150\\", \\"AMZN 150\\"]) 150 >>> most_frequent_price([\\"AAPL 150\\"] * 50000 + [\\"GOOG 200\\"] * 50000) 200","solution":"def most_frequent_price(stock_data): from collections import Counter # Extract prices from stock_data prices = [int(data.split()[1]) for data in stock_data] # Count the frequency of each price price_counts = Counter(prices) # Find the highest frequency max_frequency = max(price_counts.values()) # Find the prices with the highest frequency frequent_prices = [price for price, count in price_counts.items() if count == max_frequency] # Return the highest price among the most frequent ones return max(frequent_prices)"},{"question":"from typing import List class ConveyorBeltSystem: def __init__(self): self.shipments = deque() self.package_count = {} self.processed_count = {} def add_shipment(self, shipment_id: int, num_packages: int): pass def process_packages(self, num_packages: int): pass def query_shipment(self, shipment_id: int) -> str: pass def process_commands(commands: List[str]) -> List[str]: Processes a list of commands related to shipments on a conveyor belt. Args: commands: A list of string commands including 'Add', 'Process', and 'Query'. Returns: A list of strings representing the results of 'Query' operations. >>> process_commands([ ... \\"Add 1 5\\", ... \\"Add 2 3\\", ... \\"Process 4\\", ... \\"Query 1\\", ... \\"Process 4\\", ... \\"Query 1\\" ... ]) ['Incomplete', 'Complete'] cbs = ConveyorBeltSystem() results = [] for command in commands: parts = command.split() if parts[0] == \\"Add\\": cbs.add_shipment(int(parts[1]), int(parts[2])) elif parts[0] == \\"Process\\": cbs.process_packages(int(parts[1])) elif parts[0] == \\"Query\\": result = cbs.query_shipment(int(parts[1])) results.append(result) return results","solution":"from collections import deque class ConveyorBeltSystem: def __init__(self): self.shipments = deque() self.package_count = {} self.processed_count = {} def add_shipment(self, shipment_id, num_packages): if shipment_id not in self.package_count: self.package_count[shipment_id] = 0 self.processed_count[shipment_id] = 0 self.package_count[shipment_id] += num_packages self.shipments.append((shipment_id, num_packages)) def process_packages(self, num_packages): while num_packages > 0 and self.shipments: shipment_id, packages_left = self.shipments.popleft() if packages_left <= num_packages: num_packages -= packages_left self.processed_count[shipment_id] += packages_left else: self.processed_count[shipment_id] += num_packages self.shipments.appendleft((shipment_id, packages_left - num_packages)) num_packages = 0 def query_shipment(self, shipment_id): if self.processed_count[shipment_id] == self.package_count[shipment_id]: return \\"Complete\\" else: return \\"Incomplete\\" def process_commands(commands): cbs = ConveyorBeltSystem() results = [] for command in commands: parts = command.split() if parts[0] == \\"Add\\": cbs.add_shipment(int(parts[1]), int(parts[2])) elif parts[0] == \\"Process\\": cbs.process_packages(int(parts[1])) elif parts[0] == \\"Query\\": result = cbs.query_shipment(int(parts[1])) results.append(result) return results"},{"question":"def process_queries(n, records, q, queries): Implement a system to monitor and control the temperature of a data center. This system should maintain a log of temperature readings and perform several types of queries on the recorded data. Args: n (int): Number of temperature records. records (List[Tuple[int, int]]): Each tuple contains a timestamp and the temperature reading. q (int): Number of queries. queries (List[Tuple[int, int, int]]): Queries to perform on the data. Each tuple starts with a query type (1, 2, or 3) followed by the timestamp range [l, r]. Returns: List[int]: Results of the queries in the order they were received. The queries are: - \\"1 l r\\": Retrieve the highest temperature recorded between timestamps \`l\` and \`r\` inclusive. - \\"2 l r\\": Retrieve the lowest temperature recorded between timestamps \`l\` and \`r\` inclusive. - \\"3 l r\\": Retrieve the average temperature recorded between timestamps \`l\` and \`r\` inclusive. Example: >>> n = 5 >>> records = [(1, 10), (2, -5), (3, 20), (4, 15), (5, -10)] >>> q = 3 >>> queries = [(1, 2, 4), (2, 1, 3), (3, 1, 5)] >>> process_queries(n, records, q, queries) [20, -5, 6] pass from solution import process_queries def test_process_queries(): n = 5 records = [ (1, 10), (2, -5), (3, 20), (4, 15), (5, -10) ] q = 3 queries = [ (1, 2, 4), (2, 1, 3), (3, 1, 5) ] expected_output = [20, -5, 6] assert process_queries(n, records, q, queries) == expected_output def test_process_queries_single_entry(): n = 1 records = [ (1, 100) ] q = 1 queries = [ (1, 1, 1) ] expected_output = [100] assert process_queries(n, records, q, queries) == expected_output def test_process_queries_all_same_temps(): n = 4 records = [ (1, 0), (2, 0), (3, 0), (4, 0) ] q = 3 queries = [ (1, 1, 4), (2, 1, 4), (3, 1, 4) ] expected_output = [0, 0, 0] assert process_queries(n, records, q, queries) == expected_output def test_process_queries_mixed_temps(): n = 4 records = [ (1, 10), (2, -10), (3, 5), (4, -5) ] q = 3 queries = [ (1, 1, 4), (2, 2, 3), (3, 1, 3) ] expected_output = [10, -10, 2] assert process_queries(n, records, q, queries) == expected_output","solution":"from collections import defaultdict from bisect import bisect_left, bisect_right class TemperatureMonitor: def __init__(self): self.timestamps = [] self.temperatures = [] self.temperature_dict = defaultdict(list) def record(self, ti, vi): self.timestamps.append(ti) self.temperatures.append(vi) self.temperature_dict[ti] = vi def prepare(self): self.timestamps.sort() self.sorted_temperatures = [self.temperature_dict[ts] for ts in self.timestamps] def highest_temperature(self, l, r): l_idx = bisect_left(self.timestamps, l) r_idx = bisect_right(self.timestamps, r) - 1 return max(self.sorted_temperatures[l_idx:r_idx+1]) def lowest_temperature(self, l, r): l_idx = bisect_left(self.timestamps, l) r_idx = bisect_right(self.timestamps, r) - 1 return min(self.sorted_temperatures[l_idx:r_idx+1]) def average_temperature(self, l, r): l_idx = bisect_left(self.timestamps, l) r_idx = bisect_right(self.timestamps, r) - 1 total_temp = sum(self.sorted_temperatures[l_idx:r_idx+1]) count = r_idx - l_idx + 1 return round(total_temp / count) def process_queries(n, records, q, queries): monitor = TemperatureMonitor() for ti, vi in records: monitor.record(ti, vi) monitor.prepare() results = [] for query in queries: qtype, l, r = query if qtype == 1: results.append(monitor.highest_temperature(l, r)) elif qtype == 2: results.append(monitor.lowest_temperature(l, r)) elif qtype == 3: results.append(monitor.average_temperature(l, r)) return results"},{"question":"def fullJustify(words: List[str], maxWidth: int) -> List[str]: Given a string \`s\` and a maximum line width \`k\`, format the text such that each line has exactly \`k\` characters and is fully (left and right) justified. If you can't fit a whole word on the current line, move it to the next line. The last line should be left-justified and no extra space is inserted between words. >>> fullJustify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) [\\"This is an\\", \\"example of text\\", \\"justification. \\"] >>> fullJustify([\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\",\\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"], 20) [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"] from solution import fullJustify def test_example_1(): words = [\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"] maxWidth = 16 expected = [ \\"This is an\\", \\"example of text\\", \\"justification. \\" ] assert fullJustify(words, maxWidth) == expected def test_example_2(): words = [\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\",\\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"] maxWidth = 20 expected = [ \\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\" ] assert fullJustify(words, maxWidth) == expected def test_single_word(): words = [\\"Hello\\"] maxWidth = 10 expected = [\\"Hello \\"] assert fullJustify(words, maxWidth) == expected def test_last_line(): words = [\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"] maxWidth = 16 expected = [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] assert fullJustify(words, maxWidth) == expected def test_multiple_spaces(): words = [\\"Listen\\",\\"to\\",\\"many,\\",\\"speak\\",\\"to\\",\\"a\\",\\"few.\\"] maxWidth = 6 expected = [ \\"Listen\\", \\"to \\", \\"many, \\", \\"speak \\", \\"to a\\", \\"few. \\" ] assert fullJustify(words, maxWidth) == expected","solution":"def fullJustify(words, maxWidth): def justify_line(line_words, maxWidth, is_last): if len(line_words) == 1 or is_last: return ' '.join(line_words).ljust(maxWidth) total_words_length = sum(len(word) for word in line_words) total_spaces = maxWidth - total_words_length gaps = len(line_words) - 1 spaces = [total_spaces // gaps + (1 if i < total_spaces % gaps else 0) for i in range(gaps)] justified_line = '' for i in range(gaps): justified_line += line_words[i] + ' ' * spaces[i] justified_line += line_words[-1] return justified_line result = [] current_words = [] current_length = 0 for word in words: if current_length + len(word) + len(current_words) > maxWidth: result.append(justify_line(current_words, maxWidth, False)) current_words = [] current_length = 0 current_words.append(word) current_length += len(word) result.append(justify_line(current_words, maxWidth, True)) return result"},{"question":"def sum_of_largest_and_smallest(numbers: List[int]) -> int: Returns the sum of the largest and smallest numbers in the list. >>> sum_of_largest_and_smallest([1, 2, 3, 4, 5]) == 6 >>> sum_of_largest_and_smallest([10, -2, 50, 23, 7]) == 48 >>> sum_of_largest_and_smallest([-3, -7, -1, -15]) == -16 >>> sum_of_largest_and_smallest([5, 5, 5, 5]) == 10 >>> sum_of_largest_and_smallest([-5, 5, 0, 10, -10]) == 0 pass","solution":"def sum_of_largest_and_smallest(numbers): Returns the sum of the largest and smallest numbers in the list. if not numbers: raise ValueError(\\"The list cannot be empty\\") smallest = min(numbers) largest = max(numbers) return smallest + largest"},{"question":"def can_swap_to_equal(S: str, T: str) -> str: Determines if S can be made equal to T with exactly one swap operation. :param S: str - The original string S :param T: str - The target string T :return: str - \\"YES\\" if one swap operation can make S equal to T, \\"NO\\" otherwise. >>> can_swap_to_equal(\\"abcd\\", \\"abdc\\") \\"YES\\" >>> can_swap_to_equal(\\"abcd\\", \\"abcd\\") \\"NO\\" >>> can_swap_to_equal(\\"abcde\\", \\"abdec\\") \\"NO\\" >>> can_swap_to_equal(\\"abc\\", \\"abd\\") \\"NO\\" >>> can_swap_to_equal(\\"a\\", \\"a\\") \\"NO\\" >>> can_swap_to_equal(\\"ab\\", \\"ba\\") \\"YES\\" >>> S = \\"a\\" * 98 + \\"bc\\" >>> T = \\"a\\" * 98 + \\"cb\\" >>> can_swap_to_equal(S, T) \\"YES\\" >>> S = \\"a\\" * 100 >>> T = \\"a\\" * 99 + \\"b\\" >>> can_swap_to_equal(S, T) \\"NO\\"","solution":"def can_swap_to_equal(S, T): Determines if S can be made equal to T with exactly one swap operation. :param S: str - The original string S :param T: str - The target string T :return: str - \\"YES\\" if one swap operation can make S equal to T, \\"NO\\" otherwise. if len(S) != len(T): return \\"NO\\" # Find positions where S and T differ diff = [(s, t) for s, t in zip(S, T) if s != t] # We must have exactly 2 positions where S and T differ to perform one swap if len(diff) != 2: return \\"NO\\" # Check if swapping the differing characters in S would make it equal to T return \\"YES\\" if diff[0] == diff[1][::-1] else \\"NO\\""},{"question":"class Vehicle: Represents a vehicle in an autonomous fleet def __init__(self, id, state, x, y): Initialize the vehicle with a unique identifier \`id\`, its current state \`state\`, and its initial position \`(x, y)\`. >>> v = Vehicle(1, 'idle', 0, 0) >>> v.current_state() 'idle' >>> v.current_position() (0, 0) def update_position(self, x, y): Update the vehicle's position to \`(x, y)\`. >>> v = Vehicle(1, 'idle', 0, 0) >>> v.update_position(5, 10) >>> v.current_position() (5, 10) def update_state(self, state): Update the vehicle's state. >>> v = Vehicle(1, 'idle', 0, 0) >>> v.update_state('moving') >>> v.current_state() 'moving' def current_position(self): Return the current position of the vehicle as a tuple \`(x, y)\`. >>> v = Vehicle(1, 'idle', 0, 0) >>> v.current_position() (0, 0) def current_state(self): Return the current state of the vehicle. >>> v = Vehicle(1, 'idle', 0, 0) >>> v.current_state() 'idle' def fleet_status(fleet): Takes a list of \`Vehicle\` objects and returns a dictionary where the keys are the vehicle states and the values are lists of vehicle ids in those states. >>> v1 = Vehicle(1, 'idle', 0, 0) >>> v2 = Vehicle(2, 'moving', 5, 10) >>> v3 = Vehicle(3, 'delivering', 7, 8) >>> v1.update_state('moving') >>> v2.update_position(6, 12) >>> fleet = [v1, v2, v3] >>> fleet_status(fleet) {'moving': [1, 2], 'delivering': [3], 'idle': []}","solution":"class Vehicle: def __init__(self, id, state, x, y): self.id = id self.state = state self.x = x self.y = y def update_position(self, x, y): self.x = x self.y = y def update_state(self, state): self.state = state def current_position(self): return (self.x, self.y) def current_state(self): return self.state def fleet_status(fleet): status = {'idle': [], 'moving': [], 'delivering': []} for vehicle in fleet: status[vehicle.current_state()].append(vehicle.id) return status"},{"question":"def can_balance_weights(test_cases): Check if the weights can be balanced with the given counterweight. Args: test_cases (list): A list of test cases, where each test case is represented by a tuple (n, x, weights). n (int): The number of distinct weights. x (int): The counterweight. weights (list): A list of n distinct weights. Returns: list: A list of strings where each string is either \\"YES\\" or \\"NO\\" indicating if the weight can be balanced. >>> can_balance_weights([(5, 5, [10, 15, 20, 25, 30])]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> can_balance_weights([(3, 3, [4, 6, 9])]) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def can_balance_weights(test_cases): results = [] for n, x, weights in test_cases: for weight in weights: if weight % x == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_age_groups(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of distinct age groups needed so that the difference between the oldest and youngest person in each group is at most K years. Parameters: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of tuples where each tuple contains: - A tuple with two integers N (number of people) and K (maximum allowed difference in each group). - A list of N space-separated integers representing the ages of the people. Returns: List[int]: The minimum number of distinct age groups required for each test case. >>> min_age_groups(2, [((6, 5), [2, 3, 10, 7, 13, 8]), ((5, 10), [1, 12, 23, 34, 45])]) [2, 5] >>> min_age_groups(1, [((1, 5), [20])]) [1] >>> min_age_groups(1, [((5, 3), [10, 10, 10, 10, 10])]) [1] >>> min_age_groups(1, [((4, 1), [1, 3, 5, 7])]) [4] >>> min_age_groups(1, [((6, 2), [1, 3, 5, 7, 9, 11])]) [3]","solution":"def min_age_groups(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] ages = sorted(test_cases[i][1]) group_count = 1 min_age = ages[0] for age in ages: if age - min_age > K: group_count += 1 min_age = age results.append(group_count) return results"},{"question":"from typing import List def find_max_difference(arr: List[int]) -> int: Given an array \`arr\` of integers, this function finds and returns the maximum difference (arr[j] - arr[i]) where 0  i < j < len(arr) and arr[j] > arr[i]. If no such pair exists, returns -1. >>> find_max_difference([1, 2, 90, 10, 110]) == 109 >>> find_max_difference([15, 12, 10, 5]) == -1 pass def process_test_cases(test_cases: List[List[int]]) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases([[1, 2, 90, 10, 110], [15, 12, 10, 5], [1, 2, 3, 4, 5], [1, 1, 1, 1]]) == [109, -1, 4, -1] pass def test_find_max_difference(): assert find_max_difference([1, 2, 90, 10, 110]) == 109 assert find_max_difference([15, 12, 10, 5]) == -1 assert find_max_difference([1, 2, 3, 4, 5]) == 4 assert find_max_difference([5, 4, 3, 2, 1]) == -1 assert find_max_difference([-1, -2, -3, -4, -5]) == -1 assert find_max_difference([-5, -4, -3, -2, -1]) == 4 assert find_max_difference([7]) == -1 assert find_max_difference([1, 1, 1, 1]) == -1 assert find_max_difference([]) == -1 def test_process_test_cases(): input_data = [ [1, 2, 90, 10, 110], [15, 12, 10, 5], [1, 2, 3, 4, 5], [1, 1, 1, 1] ] expected_output = [109, -1, 4, -1] assert process_test_cases(input_data) == expected_output","solution":"def find_max_difference(arr): Given an array \`arr\`, this function finds and returns the maximum difference (arr[j] - arr[i]) where 0  i < j < len(arr) and arr[j] > arr[i]. If no such pair exists, returns -1. n = len(arr) if n < 2: return -1 max_diff = -1 min_so_far = arr[0] for j in range(1, n): if arr[j] > min_so_far: max_diff = max(max_diff, arr[j] - min_so_far) min_so_far = min(min_so_far, arr[j]) return max_diff def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for arr in test_cases: results.append(find_max_difference(arr)) return results"},{"question":"def max_total_productivity(T, test_cases) -> List[int]: Find the maximum total productivity by selecting exactly X teams out of K teams. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of test cases where each test case contains: - K (int): Number of teams - X (int): Number of teams to select - skill_levels (List[int]): List of integers representing the sum of skill levels of each team Returns: List[int]: A list of integers representing the maximum total productivity for each test case. Examples: >>> max_total_productivity(2, [(3, 2, [10, 20, 30]), (4, 2, [40, 10, 20, 30])]) [50, 70] >>> max_total_productivity(1, [(5, 3, [10, 15, 20, 25, 30])]) [75]","solution":"def max_total_productivity(T, test_cases): results = [] for case in test_cases: K, X, skill_levels = case skill_levels.sort(reverse=True) max_productivity = sum(skill_levels[:X]) results.append(max_productivity) return results"},{"question":"def sequence_length(x: int) -> int: Returns the length of the sequence for a given integer x where the sequence is defined as: - if the current number is even, the next number is half of it. - if the current number is odd, the next number is 3 times the current number plus 1. The sequence ends when it reaches 1. >>> sequence_length(6) 9 >>> sequence_length(7) 17 >>> sequence_length(15) 18 pass def solve_sequence_lengths(test_cases: List[int]) -> List[int]: For each test case, outputs a single integer representing the length of the sequence for the given input. >>> solve_sequence_lengths([6, 7, 15]) [9, 17, 18] >>> solve_sequence_lengths([1, 2, 3, 4, 5]) [1, 2, 8, 3, 6] >>> solve_sequence_lengths([10**6]) [153] pass","solution":"def sequence_length(x): Returns the length of the sequence for a given integer x where the sequence is defined as: - if the current number is even, the next number is half of it. - if the current number is odd, the next number is 3 times the current number plus 1. The sequence ends when it reaches 1. length = 1 while x != 1: if x % 2 == 0: x //= 2 else: x = 3 * x + 1 length += 1 return length def solve_sequence_lengths(test_cases): results = [] for x in test_cases: results.append(sequence_length(x)) return results"},{"question":"def max_crystals(N: int, M: int, grid: List[List[int]]) -> int: Returns the maximum number of crystals that can be collected from the top-left cell to the bottom-right cell of a grid. Parameters: N (int): number of rows M (int): number of columns grid (List[List[int]]): the grid containing the number of crystals in each cell Returns: int: The maximum number of crystals collectible. Example: >>> max_crystals(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 12 >>> max_crystals(2, 2, [ [1, 2], [0, 3] ]) 6","solution":"def max_crystals(N, M, grid): Returns the maximum number of crystals that can be collected from the top-left cell to the bottom-right cell of a grid. Parameters: N (int): number of rows M (int): number of columns grid (list of lists of int): the grid containing the number of crystals in each cell Returns: int: The maximum number of crystals collectible. # Initialize a 2D dp array with the same dimensions as the grid dp = [[0] * M for _ in range(N)] # Fill up the dp array with the maximum crystals collectible at each cell for i in range(N): for j in range(M): if i == 0 and j == 0: dp[i][j] = grid[i][j] elif i == 0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum crystals collectible return dp[N-1][M-1]"},{"question":"def can_schedule_meeting(n: int, availabilities: List[Tuple[int, int]]) -> str: Determines if there's a common time period when all participants are available. Parameters: n (int): Number of participants. availabilities (list of tuples): List of tuples where each tuple contains two integers, the start and end times of availability. Returns: str: 'yes' if a common time period exists, 'no' otherwise. >>> can_schedule_meeting(3, [(1, 5), (2, 6), (3, 8)]) 'yes' >>> can_schedule_meeting(3, [(1, 5), (6, 10), (11, 15)]) 'no' >>> can_schedule_meeting(1, [(0, 10)]) 'yes' >>> can_schedule_meeting(2, [(1, 5), (5, 10)]) 'no' >>> can_schedule_meeting(3, [(5, 10), (1, 6), (2, 7)]) 'yes'","solution":"def can_schedule_meeting(n, availabilities): Determines if there's a common time period when all participants are available. Parameters: n (int): Number of participants. availabilities (list of tuples): List of tuples where each tuple contains two integers, the start and end times of availability. Returns: str: 'yes' if a common time period exists, 'no' otherwise. if n == 0: return \\"no\\" # Initialize the common availability window with the maximum possible range common_start = 0 common_end = 10**9 for start, end in availabilities: common_start = max(common_start, start) common_end = min(common_end, end) # If at any point the common availability window becomes invalid if common_start >= common_end: return \\"no\\" return \\"yes\\""},{"question":"from typing import List def find_special_subset(nums: List[int]) -> List[int]: Find the maximum length subset in strictly increasing order with minimum sum. Args: nums: List of distinct integers. Returns: A list representing the special subset in ascending order. Example: >>> find_special_subset([5, -2, 3, 8, 4, 1, 10, 6]) [-2, 1, 3, 4, 5, 6, 8, 10] >>> find_special_subset([9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6, 7, 8, 9] pass from solution import find_special_subset def test_example_1(): nums = [5, -2, 3, 8, 4, 1, 10, 6] assert find_special_subset(nums) == [-2, 1, 3, 4, 5, 6, 8, 10] def test_example_2(): nums = [9, 8, 7, 6, 5, 4, 3, 2, 1] assert find_special_subset(nums) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_single_element(): nums = [1] assert find_special_subset(nums) == [1] def test_all_same_element(): nums = [4, 4, 4, 4] assert find_special_subset(nums) == [4] def test_negative_numbers(): nums = [-5, -10, -3, -1] assert find_special_subset(nums) == [-10, -5, -3, -1] def test_mixed_positive_and_negative(): nums = [4, -3, 2, -1, 5, 0] assert find_special_subset(nums) == [-3, -1, 0, 2, 4, 5] def test_increasing_sequence(): nums = [1, 2, 3, 4, 5] assert find_special_subset(nums) == [1, 2, 3, 4, 5] def test_decreasing_sequence(): nums = [5, 4, 3, 2, 1] assert find_special_subset(nums) == [1, 2, 3, 4, 5]","solution":"def find_special_subset(nums): Find the maximum length subset in strictly increasing order with minimum sum. nums = list(set(nums)) # Ensure uniqueness nums.sort() # Sort the numbers to form strictly increasing order return nums"},{"question":"def can_draw_path(n: int, m: int, grid: List[List[int]]) -> str: Determines if a path can be drawn from the top left to the bottom right of the grid using only cells with value 0. Parameters: n (int): Number of rows m (int): Number of columns grid (list of list of int): The grid itself Returns: str: \\"YES\\" if a path is possible, \\"NO\\" otherwise >>> can_draw_path(3, 3, [[0, 1, 0], [0, 0, 0], [0, 1, 0]]) 'YES' >>> can_draw_path(2, 2, [[0, 1], [1, 0]]) 'NO' >>> can_draw_path(1, 1, [[0]]) 'YES' >>> can_draw_path(3, 3, [[0, 1, 1], [1, 0, 1], [1, 1, 0]]) 'NO' >>> can_draw_path(5, 5, [[0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 1, 1, 0]]) 'YES' >>> can_draw_path(5, 5, [[0, 1, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 1, 1, 1]]) 'NO' pass","solution":"def can_draw_path(n, m, grid): Determines if a path can be drawn from the top left to the bottom right of the grid using only cells with value 0. Parameters: n (int): Number of rows m (int): Number of columns grid (list of list of int): The grid itself Returns: str: \\"YES\\" if a path is possible, \\"NO\\" otherwise def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 from collections import deque queue = deque([(0, 0)]) visited = [[False for _ in range(m)] for _ in range(n)] visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in [(0, 1), (1, 0)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"from typing import List, Dict, Tuple def can_complete_all_tasks(P: int, project_data: List[Dict[str, List[Tuple[int, int]]]]) -> List[str]: Check if all tasks can be completed without circular dependencies for each project. >>> project_data = [{'T': 3, 'dependencies': [(1, 2), (2, 3)]}] >>> can_complete_all_tasks(1, project_data) [\\"Yes\\"] >>> project_data = [{'T': 4, 'dependencies': [(1, 2), (2, 3), (3, 4), (4, 2)]}] >>> can_complete_all_tasks(1, project_data) [\\"No\\"]","solution":"def can_complete_all_tasks(P, project_data): from collections import defaultdict, deque def has_cycle(num_tasks, edges): graph = defaultdict(list) in_degree = [0] * (num_tasks + 1) for u, v in edges: graph[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(1, num_tasks + 1) if in_degree[i] == 0]) visited_count = 0 while queue: node = queue.popleft() visited_count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return visited_count != num_tasks results = [] for project in project_data: T, dependencies = project['T'], project['dependencies'] if has_cycle(T, dependencies): results.append(\\"No\\") else: results.append(\\"Yes\\") return results # Prepare data structure for input example project_data = [ {'T': 3, 'dependencies': [(1, 2), (2, 3)]}, {'T': 4, 'dependencies': [(1, 2), (2, 3), (3, 4), (4, 2)]} ] # Call the function with example data print(can_complete_all_tasks(2, project_data))"},{"question":"def rearrange_list(lst, d): Rearranges the list so that all elements less than d come before all elements greater than or equal to d. The order of elements within each partition is preserved. Parameters: lst (list of int): A list of integers. d (int): The pivot integer. Returns: list of int: The rearranged list. Examples: >>> rearrange_list([3, 7, 2, 4, 8, 1], 5) [3, 2, 4, 1, 7, 8] >>> rearrange_list([10, 5, 2, 15, 12, 3, 6], 8) [5, 2, 3, 6, 10, 15, 12]","solution":"def rearrange_list(lst, d): Rearranges the list so that all elements less than d come before all elements greater than or equal to d. The order of elements within each partition is preserved. Parameters: lst (list of int): A list of integers. d (int): The pivot integer. Returns: list of int: The rearranged list. less_than_d = [x for x in lst if x < d] greater_or_equal_d = [x for x in lst if x >= d] return less_than_d + greater_or_equal_d"},{"question":"def productExceptSelf(n: int, arr: List[int]) -> List[int]: Given an integer array \`arr\` of length \`n\`, return the product of all elements in the array except itself for every index without using division. >>> productExceptSelf(4, [1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf(3, [2, 3, 4]) [12, 8, 6] >>> productExceptSelf(1, [5]) [1] >>> productExceptSelf(2, [3, 4]) [4, 3] >>> productExceptSelf(4, [2, 2, 2, 2]) [8, 8, 8, 8] >>> productExceptSelf(5, [1, 0, 3, 0, 5]) [0, 0, 0, 0, 0] >>> productExceptSelf(5, [1, 2, 3, 0, 5]) [0, 0, 0, 30, 0] >>> productExceptSelf(4, [1000, 2000, 3000, 4000]) [24000000000, 12000000000, 8000000000, 6000000000] # Your code here","solution":"def productExceptSelf(n, arr): Returns an array where output[i] is the product of all the elements in the array except arr[i]. # Initialize the two auxiliary arrays left_products = [1] * n right_products = [1] * n output = [1] * n # Fill left_products such that left_products[i] contains the product of all elements to the left of arr[i] for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right_products such that right_products[i] contains the product of all elements to the right of arr[i] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Construct the output array using both left_products and right_products for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def unique_substrings(s: str) -> List[str]: Generate all possible unique substrings of string \`s\` and return them in lexicographic order. >>> unique_substrings(\\"abc\\") [\\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"] >>> unique_substrings(\\"aaa\\") [\\"a\\", \\"aa\\", \\"aaa\\"] from typing import List def test_unique_substrings_example1(): result = unique_substrings(\\"abc\\") expected = [\\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"] assert result == expected def test_unique_substrings_example2(): result = unique_substrings(\\"aaa\\") expected = [\\"a\\", \\"aa\\", \\"aaa\\"] assert result == expected def test_unique_substrings_single_char(): result = unique_substrings(\\"a\\") expected = [\\"a\\"] assert result == expected def test_unique_substrings_two_chars(): result = unique_substrings(\\"ab\\") expected = [\\"a\\", \\"ab\\", \\"b\\"] assert result == expected def test_unique_substrings_repeated_chars_mixed(): result = unique_substrings(\\"abba\\") expected = [\\"a\\", \\"ab\\", \\"abb\\", \\"abba\\", \\"b\\", \\"ba\\", \\"bb\\", \\"bba\\"] assert result == expected","solution":"def unique_substrings(s): Returns all unique substrings of s in lexicographic order. substr_set = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substr_set.add(s[i:j]) substr_list = sorted(substr_set) return substr_list"},{"question":"def canCatchWater(hill: List[int]) -> bool: Determines if there exists at least one local minimum in the hill array that can contain water. Args: hill (list): List of integers representing hill heights. Returns: bool: True if there exists at least one local minimum that can contain water, False otherwise. Examples: >>> canCatchWater([1, 2, 1, 3, 4, 3, 1, 2]) True >>> canCatchWater([1, 2, 3, 4, 5]) False from typing import List def test_canCatchWater_case1(): assert canCatchWater([1, 2, 1, 3, 4, 3, 1, 2]) == True def test_canCatchWater_case2(): assert canCatchWater([1, 2, 3, 4, 5]) == False def test_canCatchWater_case3(): assert canCatchWater([1, 1, 1]) == False def test_canCatchWater_case4(): assert canCatchWater([3, 1, 3]) == True def test_canCatchWater_case5(): assert canCatchWater([5, 4, 3, 2, 1]) == False def test_canCatchWater_empty_list(): assert canCatchWater([]) == False def test_canCatchWater_single_element(): assert canCatchWater([1]) == False def test_canCatchWater_two_elements(): assert canCatchWater([1, 2]) == False def test_canCatchWater_no_local_minima(): assert canCatchWater([1, 2, 3, 4, 5, 6, 7, 8]) == False","solution":"def canCatchWater(hill): Determines if there exists at least one local minimum in the hill array that can contain water. Args: hill (list): List of integers representing hill heights. Returns: bool: True if there exists at least one local minimum that can contain water, False otherwise. n = len(hill) # A hill with length less than 3 cannot form a local minimum that can contain water if n < 3: return False for i in range(1, n - 1): # Check if the current element is a local minimum if hill[i] < hill[i - 1] and hill[i] < hill[i + 1]: return True return False"},{"question":"def generate_balanced_array(n, m): Generate a balanced array of length n where each element is between 1 and m inclusive. >>> generate_balanced_array(4, 5) [2, 2, 3, 1] >>> generate_balanced_array(6, 8) [4, 2, 3, 3, 4, 2]","solution":"def generate_balanced_array(n, m): Generate a balanced array of length n where each element is between 1 and m inclusive. half_n = n // 2 # Generate first half of the array with random values from 1 to m/2 first_half = [1] * half_n # Generate second half with same sum as first half second_half = [1] * half_n return first_half + second_half"},{"question":"from typing import List def max_nested_boxes(heights: List[int]) -> int: Determine the maximum number of nested boxes possible given their heights. Args: heights (List[int]): A list of integers representing the heights of boxes. Returns: int: The maximum number of nested boxes. Examples: >>> max_nested_boxes([1, 3, 2, 4, 6, 5]) 4 >>> max_nested_boxes([5, 4, 3, 2, 1]) 1 >>> max_nested_boxes([1, 2, 3, 4, 5]) 5 >>> max_nested_boxes([10]) 1 >>> max_nested_boxes([10, 5, 2, 6, 4, 3, 1, 7]) 3 >>> max_nested_boxes([1, 2, 2, 3, 3, 4, 4]) 4 >>> max_nested_boxes(list(range(1, 20001))) 20000","solution":"from bisect import bisect_left def max_nested_boxes(heights): Function to find the maximum number of nested boxes possible. # To find the Longest Increasing Subsequence (LIS) lis = [] for height in heights: pos = bisect_left(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return len(lis)"},{"question":"def max_product_subarray(arr): Returns the maximum product of any contiguous subsequence within the array. >>> max_product_subarray([1, 2, 3, 4]) == 24 >>> max_product_subarray([-1, -3, -10, 0, 60]) == 60 >>> max_product_subarray([-2, 0, -1]) == 0 >>> max_product_subarray([2, 3, -2, 4]) == 6 >>> max_product_subarray([-2, -3, 7]) == 42 >>> max_product_subarray([6, -3, -10, 0, 2]) == 180 >>> max_product_subarray([-1, -3, -10, 0, 0, 0, 60, -2, 0]) == 60","solution":"def max_product_subarray(arr): Returns the maximum product of any contiguous subsequence within the array. max_product = float('-inf') current_max, current_min = 1, 1 for num in arr: if num == 0: current_max, current_min = 1, 1 max_product = max(max_product, 0) continue temp = current_max * num current_max = max(num, temp, current_min * num) current_min = min(num, temp, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"def isValidBraces(T: int, cases: List[str]) -> List[str]: Determines if each string in the input list has valid curly braces. Parameters: T : int Number of test cases cases : list of str List containing strings with curly braces for each test case Returns: list of str List containing \\"YES\\" or \\"NO\\" for each test case based on the validity of the curly braces in the corresponding string from solution import isValidBraces def test_valid_braces_simple(): assert isValidBraces(1, [\\"{}\\"]) == [\\"YES\\"] def test_valid_braces_nested(): assert isValidBraces(1, [\\"{{}}\\"]) == [\\"YES\\"] def test_invalid_braces_missing_closing(): assert isValidBraces(1, [\\"{{}{}\\"]) == [\\"NO\\"] def test_mixed_valid_and_invalid_braces(): assert isValidBraces(3, [\\"{}\\", \\"{{}}\\", \\"{{}{}\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_only_opening_braces(): assert isValidBraces(1, [\\"{{{{{{\\"]) == [\\"NO\\"] def test_only_closing_braces(): assert isValidBraces(1, [\\"}}}}}}\\"]) == [\\"NO\\"] def test_complex_valid_braces(): assert isValidBraces(1, [\\"{{{{}}}}\\"]) == [\\"YES\\"] def test_complex_invalid_braces(): assert isValidBraces(1, [\\"{{{{}}}\\"]) == [\\"NO\\"]","solution":"def isValidBraces(T, cases): Determines if each string in the input list has valid curly braces. Parameters: T : int Number of test cases cases : list of str List containing strings with curly braces for each test case Returns: list of str List containing \\"YES\\" or \\"NO\\" for each test case based on the validity of the curly braces in the corresponding string def is_valid(s): stack = [] for char in s: if char == '{': stack.append(char) elif char == '}': if not stack or stack[-1] != '{': return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" results = [] for case in cases: results.append(is_valid(case)) return results"},{"question":"def max_sum_of_magic_values(N: int, L: int, magic_values: List[int]) -> int: Determine the remainder of the maximum possible sum of selected magic values modulo 1000000009. Parameters: N (int): Total number of books. L (int): Number of contiguous subarrays to select. magic_values (List[int]): List of magic values of the books. Returns: int: Maximum possible sum of selected magic values modulo 1000000009. >>> max_sum_of_magic_values(6, 2, [1, 2, 3, 4, 5, 6]) 11 >>> max_sum_of_magic_values(5, 1, [1, 2, 3, 4, 5]) 5","solution":"def max_sum_of_magic_values(N, L, magic_values): MOD = 1000000009 # Initialize dp array where dp[i][j] is the maximum sum using j subarrays in the first i books dp = [[-float('inf')] * (L + 1) for _ in range(N + 1)] # Base case: zero books, zero subarrays dp[0][0] = 0 for i in range(1, N + 1): max_val = 0 for j in range(1, L + 1): for k in range(i): max_val = max(max_val, dp[k][j-1] + max(magic_values[k:i])) dp[i][j] = max_val return dp[N][L] % MOD"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: Returns the length of the longest univalue path in a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The length of the longest univalue path. Examples: >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) 2 def test_longest_univalue_path_sample1(): root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(1) root.right.right = TreeNode(5) assert longestUnivaluePath(root) == 2 def test_longest_univalue_path_sample2(): root = TreeNode(1) root.left = TreeNode(4) root.right = TreeNode(5) root.left.left = TreeNode(4) root.left.right = TreeNode(4) root.right.right = TreeNode(5) assert longestUnivaluePath(root) == 2 def test_longest_univalue_path_single_node(): root = TreeNode(1) assert longestUnivaluePath(root) == 0 def test_longest_univalue_path_all_same(): root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) root.left.left = TreeNode(1) root.left.right = TreeNode(1) root.right.right = TreeNode(1) assert longestUnivaluePath(root) == 4 def test_longest_univalue_path_none_univalue_paths(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert longestUnivaluePath(root) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: Returns the length of the longest univalue path in a binary tree. if not root: return 0 def dfs(node): nonlocal longest if not node: return 0 left_length = dfs(node.left) right_length = dfs(node.right) left_univalue = 0 right_univalue = 0 if node.left and node.left.val == node.val: left_univalue = left_length + 1 if node.right and node.right.val == node.val: right_univalue = right_length + 1 longest = max(longest, left_univalue + right_univalue) return max(left_univalue, right_univalue) longest = 0 dfs(root) return longest"},{"question":"def shortestPath(grid: List[List[int]]) -> int: Finds the shortest path in a grid from the top-left corner to the bottom-right corner, while avoiding obstacles. >>> shortestPath([ ... [0, 0, 0, 1], ... [1, 1, 0, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ]) == 6 >>> shortestPath([ ... [0, 1], ... [1, 0] ... ]) == -1 pass def test_shortest_path(): grid1 = [ [0, 0, 0, 1], [1, 1, 0, 0], [0, 0, 0, 0], [0, 1, 1, 0] ] grid2 = [ [0, 1], [1, 0] ] grid3 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] grid4 = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] grid5 = [ [0, 0, 0], [0, 1, 1], [0, 0, 0] ] assert shortestPath(grid1) == 6 assert shortestPath(grid2) == -1 assert shortestPath(grid3) == 4 assert shortestPath(grid4) == -1 assert shortestPath(grid5) == 4 if __name__ == \\"__main__\\": test_shortest_path()","solution":"from collections import deque def shortestPath(grid): Finds the shortest path in a grid from the top-left corner to the bottom-right corner, while avoiding obstacles. rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (rows-1, cols-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def max_distance_between_powered_lampposts(M, C, positions, lamp_demands, battery_capacities): Finds the maximum distance between any two powered lampposts or determines if it's not possible to power all lampposts with the available batteries. Parameters: M (int): Number of lampposts. C (int): Number of batteries. positions (List[int]): List of positions of the lampposts. lamp_demands (List[int]): List of required capacities of the lampposts. battery_capacities (List[int]): List of capacities of the batteries. Returns: int/str: The maximum distance between any two powered lampposts, or \\"Not Possible\\" if it is not possible to power all lampposts. >>> max_distance_between_powered_lampposts(4, 5, [-10, 0, 15, 20], [8, 5, 7, 6], [10, 12, 8, 5, 7]) 30 >>> max_distance_between_powered_lampposts(3, 2, [-5, 3, 9], [4, 10, 6], [5, 7]) \\"Not Possible\\" >>> max_distance_between_powered_lampposts(2, 2, [1, 2], [1, 1], [1, 1]) 1 >>> max_distance_between_powered_lampposts(5, 5, [-1000000000, -500000000, 0, 500000000, 1000000000], [100, 200, 300, 400, 500], [100, 200, 300, 400, 500]) 2000000000 >>> max_distance_between_powered_lampposts(1, 1, [10], [1], [1]) 0","solution":"def max_distance_between_powered_lampposts(M, C, positions, lamp_demands, battery_capacities): lamp_demands_batteries = sorted(zip(lamp_demands, positions)) battery_capacities.sort() if C < M: return \\"Not Possible\\" i, j = 0, 0 while i < C and j < M: if battery_capacities[i] >= lamp_demands_batteries[j][0]: j += 1 i += 1 if j < M: return \\"Not Possible\\" positions.sort() return abs(positions[-1] - positions[0])"},{"question":"def calculate_grade(scores): Returns the final grade based on the average of five scores >>> calculate_grade([95, 96, 97, 94, 98]) 'A' >>> calculate_grade([85, 90, 78, 92, 88]) 'B' >>> calculate_grade([75, 70, 65, 80, 75]) 'C' >>> calculate_grade([60, 58, 65, 67, 62]) 'D' >>> calculate_grade([50, 50, 50, 50, 50]) 'F' pass def determine_grades(student_scores): Takes a list of student scores and returns a list of their final grades >>> determine_grades([[85, 90, 78, 92, 88], [60, 58, 65, 67, 62], [95, 96, 92, 94, 98]]) ['B', 'D', 'A'] >>> determine_grades([[50, 50, 50, 50, 50], [75, 70, 65, 80, 75]]) ['F', 'C'] pass","solution":"def calculate_grade(scores): Returns the final grade based on the average of five scores average = sum(scores) / 5 if average >= 90: return 'A' elif average >= 80: return 'B' elif average >= 70: return 'C' elif average >= 60: return 'D' else: return 'F' def determine_grades(student_scores): Takes a list of student scores and returns a list of their final grades grades = [] for scores in student_scores: grades.append(calculate_grade(scores)) return grades"},{"question":"def longest_snake_path(grid: List[List[int]]) -> int: Find the length of the longest snake path in a grid. >>> longest_snake_path([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) 9 >>> longest_snake_path([ ... [4, 3, 2, 1], ... [5, 6, 7, 16], ... [8, 9, 10, 15], ... [11, 12, 13, 14] ... ]) 12 pass def process_test_cases(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Process multiple test cases for finding longest snake path. This function takes a list of test cases, where each test case is represented by: - n: the number of rows in the grid - m: the number of columns in the grid - grid: a 2D list representing the grid of integers >>> process_test_cases([ ... (3, 3, [ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]), ... (4, 4, [ ... [4, 3, 2, 1], ... [5, 6, 7, 16], ... [8, 9, 10, 15], ... [11, 12, 13, 14] ... ]) ... ]) [9, 12] pass","solution":"def longest_snake_path(grid): Find the length of the longest increasing snake path in a grid. def dfs(x, y, dp): if dp[x][y] != -1: return dp[x][y] max_length = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # four directions nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] > grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny, dp)) dp[x][y] = max_length return max_length if not grid: return 0 n, m = len(grid), len(grid[0]) dp = [[-1] * m for _ in range(n)] max_path_length = 1 for i in range(n): for j in range(m): max_path_length = max(max_path_length, dfs(i, j, dp)) return max_path_length def process_test_cases(test_cases): results = [] for case in test_cases: n, m, grid = case results.append(longest_snake_path(grid)) return results"},{"question":"def max_char(S: str) -> str: Given a string S consisting of only lowercase and uppercase letters, find the character that appears the most frequently in it. If there are two or more characters that occur the same number of times, return the lexicographically smallest character. >>> max_char(\\"testString\\") 't' >>> max_char(\\"racecarRACE\\") 'a'","solution":"def max_char(S): from collections import Counter lower_s = S.lower() count = Counter(lower_s) max_freq = max(count.values()) candidates = [char for char in count if count[char] == max_freq] return min(candidates)"},{"question":"def is_magic_square(n: int, matrix: List[List[int]]) -> bool: Determines if the given n x n matrix is a magic square. Args: n (int): Size of the matrix (n x n). matrix (list of list of int): The matrix to be checked. Returns: bool: True if the matrix is a magic square, False otherwise. >>> is_magic_square(3, [[2, 7, 6], [9, 5, 1], [4, 3, 8]]) True >>> is_magic_square(4, [[16, 2, 3, 13], [5, 11, 10, 8], [9, 7, 6, 12], [4, 14, 15, 1]]) True >>> is_magic_square(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) False","solution":"def is_magic_square(n, matrix): Determines if the given n x n matrix is a magic square. Args: n (int): Size of the matrix (n x n). matrix (list of list of int): The matrix to be checked. Returns: bool: True if the matrix is a magic square, False otherwise. # Calculate the sum of the first row to set the reference magic_constant = sum(matrix[0]) # Check sum of all rows for row in matrix: if sum(row) != magic_constant: return False # Check sum of all columns for col in range(n): col_sum = sum(matrix[row][col] for row in range(n)) if col_sum != magic_constant: return False # Check sum of the main diagonal if sum(matrix[i][i] for i in range(n)) != magic_constant: return False # Check sum of the secondary diagonal if sum(matrix[i][n-1-i] for i in range(n)) != magic_constant: return False return True"},{"question":"def max_non_overlapping_activities(n: int, activities: List[Tuple[int, int]]) -> int: Find the maximum number of non-overlapping activities. Each activity is specified by a start time and an end time. Parameters: - n: the number of activities - activities: a list of tuples, where each tuple contains two integers (start_time, end_time) >>> max_non_overlapping_activities(3, [(1, 2), (2, 3), (3, 4)]) == 3 >>> max_non_overlapping_activities(4, [(1, 3), (2, 5), (4, 6), (7, 8)]) == 3 >>> max_non_overlapping_activities(0, []) == 0 >>> max_non_overlapping_activities(1, [(1, 2)]) == 1 >>> max_non_overlapping_activities(3, [(1, 4), (2, 5), (3, 6)]) == 1 >>> max_non_overlapping_activities(3, [(1, 2), (2, 3), (3, 5)]) == 3 >>> max_non_overlapping_activities(5, [(1, 3), (2, 4), (3, 5), (7, 10), (9, 11)]) == 3 pass","solution":"def max_non_overlapping_activities(n, activities): Find the maximum number of non-overlapping activities # Sort activities by their end time activities.sort(key=lambda x: x[1]) count = 0 end_time = 0 for s, e in activities: if s >= end_time: count += 1 end_time = e return count"},{"question":"def game_night(n, m, difficulty_levels, events): Manage the game night flow and maintain the scoreboard updates according to the events. >>> game_night(4, 7, [3, 5, 2, 7], [[1, 4], [1, 6], [2, 1, 2], [2, 2, 1], [2, 1, 1], [3], [2, 2, 3]]) 1 1 >>> game_night(3, 5, [3, 5, 7], [[1, 2], [1, 4], [2, 1, 1], [2, 2, 3], [3]]) 0 0 >>> game_night(3, 4, [2, 3, 4], [[1, 5], [2, 1, 1], [2, 1, 2], [3]]) 2 >>> game_night(2, 7, [1, 2], [[1, 5], [1, 7], [2, 1, 1], [2, 2, 1], [3], [2, 1, 2], [3]]) 1 1 2 1","solution":"def game_night(n, m, difficulty_levels, events): players = [] scoreboard = [] for event in events: if event[0] == 1: # Add a new player with skill level event[1] players.append(event[1]) scoreboard.append(0) elif event[0] == 2: # Player p attempts to play game g p = event[1] - 1 g = event[2] - 1 if players[p] >= difficulty_levels[g]: scoreboard[p] += 1 elif event[0] == 3: # Print the scoreboard print(\\" \\".join(map(str, scoreboard)))"},{"question":"class NumMatrix: def __init__(self, matrix): Initialize the 2D matrix. pass def update(self, row, col, val): Updates the element at position (row, col) in the matrix to val. pass def sumRegion(self, r1, c1, r2, c2): Computes the sum of the elements within the rectangle defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2), inclusive. >>> matrix = NumMatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.sumRegion(0, 0, 1, 1) 12 >>> matrix.update(1, 1, 10) >>> matrix.sumRegion(0, 0, 1, 1) 17 pass","solution":"class NumMatrix: def __init__(self, matrix): Initialize the 2D matrix. if not matrix or not matrix[0]: self.matrix = [] else: self.matrix = [row[:] for row in matrix] # Deep copy of the matrix def update(self, row, col, val): Updates the element at position (row, col) in the matrix to val. if self.matrix: self.matrix[row][col] = val def sumRegion(self, r1, c1, r2, c2): Computes the sum of the elements within the rectangle defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2), inclusive. if not self.matrix: return 0 total = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): total += self.matrix[i][j] return total"},{"question":"def minimum_coins(K): Returns the minimum number of coins needed to sum up to exactly K using denominations which are powers of 2. Args: K (int): The value to form using coins. Returns: int: Minimum number of coins needed. Examples: >>> minimum_coins(6) 2 >>> minimum_coins(10) 2 >>> minimum_coins(15) 4 >>> minimum_coins(1023) 10 def process_queries(queries): Processes a list of queries and returns the results for each query. Args: queries (list of int): List of values for which we need to determine the minimum number of coins. Returns: list of int: List containing results for each query. Examples: >>> process_queries([6, 10, 15, 1023]) [2, 2, 4, 10] >>> process_queries([1, 2, 3, 4]) [1, 1, 2, 1]","solution":"def minimum_coins(K): Returns the minimum number of coins needed to sum up to exactly K using denominations which are powers of 2. num_coins = 0 while K > 0: highest_power_of_2 = 1 << (K.bit_length() - 1) K -= highest_power_of_2 num_coins += 1 return num_coins def process_queries(queries): Processes a list of queries and returns the results for each query. results = [] for K in queries: results.append(minimum_coins(K)) return results"},{"question":"def find_longest_word(n: int, S: str, words: List[str]) -> str: Given a string S and a dictionary of words D, find the longest word in D that can be formed by deleting some characters of the string S. If there are ties, return the word which appears first in the dictionary. >>> n = 5 >>> S = \\"abcde\\" >>> words = [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"cd\\"] >>> find_longest_word(n, S, words) \\"ab\\" >>> n = 4 >>> S = \\"aabbcc\\" >>> words = [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"] >>> find_longest_word(n, S, words) \\"abc\\"","solution":"def find_longest_word(n, S, words): def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) longest_word = \\"\\" for word in words: if is_subsequence(word, S): if len(word) > len(longest_word) or (len(word) == len(longest_word) and words.index(word) < words.index(longest_word)): longest_word = word return longest_word"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_smallest_sum(head: ListNode) -> int: Find the smallest sum of any non-empty, contiguous sublist of the linked list. >>> head = ListNode(3, ListNode(-4, ListNode(5, ListNode(6, ListNode(-8, ListNode(2, ListNode(1))))))) >>> find_smallest_sum(head) -8 >>> head = ListNode(2, ListNode(3, ListNode(-1, ListNode(1)))) >>> find_smallest_sum(head) -1 >>> head = ListNode(5, ListNode(6, ListNode(3))) >>> find_smallest_sum(head) 3","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_smallest_sum(head: ListNode) -> int: if not head: return 0 current_node = head current_sum = current_node.val min_sum = current_node.val while current_node.next is not None: current_node = current_node.next if current_sum > 0: current_sum = current_node.val else: current_sum += current_node.val if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"def smallestSubstring(s: str, n: int) -> int: Given a string s and an integer n, find the length of the smallest substring that contains at least \`n\` different characters. >>> smallestSubstring(\\"abcba\\", 3) 3 >>> smallestSubstring(\\"aaaaaa\\", 2) -1 >>> smallestSubstring(\\"a\\", 1) 1 >>> smallestSubstring(\\"abcdef\\", 4) 4 >>> smallestSubstring(\\"abcdef\\", 7) -1 >>> smallestSubstring(\\"ababababababa\\", 2) 2 >>> smallestSubstring(\\"aaabbc\\", 3) 4 >>> smallestSubstring(\\"abcdefghijklmnopqrstuvwxyz\\", 26) 26","solution":"def smallestSubstring(s, n): from collections import defaultdict if n > len(set(s)): return -1 char_count = defaultdict(int) left = 0 min_length = float('inf') unique_chars = 0 for right in range(len(s)): if char_count[s[right]] == 0: unique_chars += 1 char_count[s[right]] += 1 while unique_chars >= n: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: unique_chars -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def count_constant_temperature_subarrays(p: int, n: int, temperatures: List[int]) -> int: Count the number of subarrays of length n where all elements are the same. Parameters: - p: The number of temperature measurements. - n: The required length for the subarray of constant temperatures. - temperatures: List of temperature measurements. Returns: - The number of subarrays of length n with constant temperatures. Examples: >>> count_constant_temperature_subarrays(7, 3, [5, 5, 6, 6, 6, 5, 5]) 1 >>> count_constant_temperature_subarrays(5, 2, [3, 3, 3, 3, 3]) 4 >>> count_constant_temperature_subarrays(4, 1, [4, 4, 4, 4]) 4","solution":"def count_constant_temperature_subarrays(p, n, temperatures): Count the number of subarrays of length n where all elements are the same. Parameters: - p: The number of temperature measurements. - n: The required length for the subarray of constant temperatures. - temperatures: List of temperature measurements. Returns: - The number of subarrays of length n with constant temperatures. count = 0 for i in range(p - n + 1): if len(set(temperatures[i:i + n])) == 1: count += 1 return count"},{"question":"def max_sum_non_adjacent_buildings(n: int, heights: List[int]) -> int: Determines the maximum sum of heights of the selected buildings such that no two selected buildings are adjacent. >>> max_sum_non_adjacent_buildings(4, [1, 2, 3, 1]) 4 >>> max_sum_non_adjacent_buildings(6, [5, 5, 10, 100, 10, 5]) 110 >>> max_sum_non_adjacent_buildings(3, [10, 20, 30]) 40","solution":"def max_sum_non_adjacent_buildings(n, heights): if n == 0: return 0 if n == 1: return heights[0] dp = [0] * n dp[0] = heights[0] dp[1] = max(heights[0], heights[1]) for i in range(2, n): dp[i] = max(dp[i - 1], heights[i] + dp[i - 2]) return dp[-1]"},{"question":"def minimum_path_sum(grid): Calculate the minimum path sum from the top-left corner to the bottom-right corner of a square grid. Args: grid: List of List of int, representing the n x n grid with positive integer values in each cell. Returns: int: the minimum sum of the values of the cells visited from the top-left corner to the bottom-right corner. Example: >>> minimum_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minimum_path_sum([[1, 2], [1, 1]]) 3 pass def solve(test_cases): Solve the problem for multiple test cases. Args: test_cases: List of grids, each grid represented as a List of List of int. Returns: List of int: each element is the minimum path sum for the corresponding grid in test_cases. pass from solution import solve def test_single_case(): test_cases = [ [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ] assert solve(test_cases) == [7] def test_multiple_cases(): test_cases = [ [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ], [ [1, 2], [1, 1] ] ] assert solve(test_cases) == [7, 3] def test_larger_grid(): test_cases = [ [ [1, 3, 1, 8], [1, 5, 1, 2], [4, 2, 1, 1], [1, 1, 1, 1] ] ] assert solve(test_cases) == [9] def test_same_values_grid(): test_cases = [ [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] ] assert solve(test_cases) == [5] def test_large_numbers_grid(): test_cases = [ [ [1000, 1000], [1000, 1] ] ] assert solve(test_cases) == [2001]","solution":"def minimum_path_sum(grid): n = len(grid) dp = [[float('inf')] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(n): if i > 0: # check and update from cell above dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: # check and update from cell to the left dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[n-1][n-1] def solve(test_cases): results = [] for grid in test_cases: results.append(minimum_path_sum(grid)) return results"},{"question":"def calculate_calories(activities): Calculate the total calories burned based on the activities' duration and intensity. Parameters: activities (list of tuples): Each tuple contains (activity_type, duration, intensity) Returns: int: Total calories burned >>> calculate_calories([(\\"walking\\", 30, \\"medium\\"), (\\"running\\", 20, \\"high\\"), (\\"cycling\\", 60, \\"low\\")]) 715 >>> calculate_calories([(\\"walking\\", 10, \\"low\\"), (\\"running\\", 25, \\"medium\\"), (\\"cycling\\", 40, \\"high\\")]) 615 >>> calculate_calories([(\\"walking\\", 60, \\"high\\"), (\\"running\\", 15, \\"low\\"), (\\"cycling\\", 30, \\"medium\\")]) 660","solution":"def calculate_calories(activities): Calculate the total calories burned based on the activities' duration and intensity. Parameters: activities (list of tuples): Each tuple contains (activity_type, duration, intensity) Returns: int: Total calories burned calorie_burn_rates = { \\"walking\\": {\\"low\\": 3, \\"medium\\": 4.5, \\"high\\": 6}, \\"running\\": {\\"low\\": 8, \\"medium\\": 11, \\"high\\": 14}, \\"cycling\\": {\\"low\\": 5, \\"medium\\": 7.5, \\"high\\": 10} } total_calories = 0 for activity, duration, intensity in activities: if activity in calorie_burn_rates and intensity in calorie_burn_rates[activity]: total_calories += duration * calorie_burn_rates[activity][intensity] return total_calories"},{"question":"def traffic_signals_after_n_minutes(grid: List[str], N: int) -> List[str]: Returns the state of the signals after N minutes. Parameters: grid (List[str]): Initial state of the signals in a 4x4 grid. N (int): Number of minutes after which to determine the state. Returns: List[str]: State of the signals after N minutes. Example: >>> traffic_signals_after_n_minutes([\\"GGSG\\", \\"SSGS\\", \\"GSGS\\", \\"SGSG\\"], 1) [\\"SSGS\\", \\"GGSG\\", \\"SGSG\\", \\"GSGS\\"] >>> traffic_signals_after_n_minutes([\\"GSGS\\", \\"SGSG\\", \\"GSGS\\", \\"SGSG\\"], 2) [\\"GSGS\\", \\"SGSG\\", \\"GSGS\\", \\"SGSG\\"]","solution":"def traffic_signals_after_n_minutes(grid, N): Returns the state of the signals after N minutes. grid: List of strings representing the initial state in a 4x4 grid N: int, number of minutes after which to determine the state if N % 2 == 0: return grid else: return [\\"\\".join('S' if cell == 'G' else 'G' for cell in row) for row in grid] # Example input parsing and function call: # input_grid = [ # \\"GSSG\\", # \\"SSGS\\", # \\"GSGS\\", # \\"SGSG\\" # ] # N = 1 # print(\\"n\\".join(traffic_signals_after_n_minutes(input_grid, N)))"},{"question":"def largest_filled_rectangle(grid: List[List[int]]) -> int: Returns the size of the largest filled rectangle in a grid. Args: grid (List[List[int]]): A 2D grid where each cell is either 0 (white) or 1 (black). Returns: int: The size of the largest filled rectangle that can be formed by contiguous black cells (1s). Examples: >>> largest_filled_rectangle([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 6 >>> largest_filled_rectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> largest_filled_rectangle([[1, 1, 0, 1], [1, 1, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]) 9 pass def test_largest_filled_rectangle(): assert largest_filled_rectangle([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 6 assert largest_filled_rectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 assert largest_filled_rectangle([[1, 1, 0, 1], [1, 1, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]) == 9 assert largest_filled_rectangle([[1]]) == 1 assert largest_filled_rectangle([[0]]) == 0 def test_largest_filled_rectangle_single_row(): assert largest_filled_rectangle([[0, 1, 1, 1, 0, 1, 1]]) == 3 def test_largest_filled_rectangle_single_column(): assert largest_filled_rectangle([[1], [1], [0], [1], [1], [1], [0], [1]]) == 3 assert largest_filled_rectangle([[1], [1], [1]]) == 3 def test_largest_filled_rectangle_large_grid(): large_grid = [[1]*1000 for _ in range(1000)] assert largest_filled_rectangle(large_grid) == 1000000 if __name__ == \\"__main__\\": test_largest_filled_rectangle() test_largest_filled_rectangle_single_row() test_largest_filled_rectangle_single_column() test_largest_filled_rectangle_large_grid()","solution":"def largest_filled_rectangle(grid): Returns the size of the largest filled rectangle in a grid. if not grid or not grid[0]: return 0 M = len(grid) N = len(grid[0]) max_area = 0 # Create an array to store the heights of each column heights = [0] * N for row in range(M): for col in range(N): # If the cell is black, increment the height counter if grid[row][col] == 1: heights[col] += 1 # If the cell is white, reset the height counter else: heights[col] = 0 # Calculate the maximum area of rectangle in histogram for this row max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): Helper function to calculate the maximum rectangle area in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_operations_to_avoid_consecutive(s: str) -> int: Returns the minimum number of operations required so that no two consecutive characters in the string are the same. >>> min_operations_to_avoid_consecutive(\\"abc\\") == 0 >>> min_operations_to_avoid_consecutive(\\"aaab\\") == 2 >>> min_operations_to_avoid_consecutive(\\"ababa\\") == 0 >>> min_operations_to_avoid_consecutive(\\"cc\\") == 1 def solve(test_cases: List[Tuple[int, str]]) -> List[int]: For each test case, returns the minimum number of operations required so that no two consecutive characters in the string are the same. >>> solve([(3, \\"abc\\"), (4, \\"aaab\\"), (5, \\"ababa\\"), (2, \\"cc\\")]) == [0, 2, 0, 1] >>> solve([(2, \\"ab\\"), (2, \\"aa\\"), (3, \\"aab\\"), (1, \\"a\\")]) == [0, 1, 1, 0]","solution":"def min_operations_to_avoid_consecutive(s): Returns the minimum number of operations required so that no two consecutive characters in the string are the same. operations = 0 for i in range(1, len(s)): if s[i] == s[i-1]: operations += 1 # Skip the next character since we have changed the current one if i + 1 < len(s) and s[i] == s[i+1]: i += 1 return operations def solve(test_cases): results = [] for n, s in test_cases: results.append(min_operations_to_avoid_consecutive(s)) return results"},{"question":"def longest_substring_two_colors(n: int, beads: str) -> int: Given an integer n and a string of n beads (uppercase English letters), find the length of the longest contiguous sub-string that contains beads of exactly two different colors. >>> longest_substring_two_colors(10, \\"AABBBCBBBA\\") 7 >>> longest_substring_two_colors(6, \\"ABCABC\\") 2","solution":"def longest_substring_two_colors(n, beads): max_len = 0 left = 0 color_count = {} for right in range(n): if beads[right] in color_count: color_count[beads[right]] += 1 else: color_count[beads[right]] = 1 while len(color_count) > 2: color_count[beads[left]] -= 1 if color_count[beads[left]] == 0: del color_count[beads[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def optimal_tower_coverage(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[List[Tuple[int, int]]]: Given the number of factories and their positions on a line, determine the positions and ranges of the air purification towers to maximize the pollution reduction. Parameters: T (int): Number of test cases. test_cases (list[tuple]): List of tuples where each tuple contains: - N (int): Number of factories. - M (int): Number of towers. - positions (list[int]): List of integers indicating the positions of the factories. Returns: list[list[tuple]]: List containing results for each test case. Each result is a list of tuples, each tuple containing the starting point and the range for each tower. Example: >>> test_cases = [(5, 2, [10, 20, 30, 40, 50])] >>> optimal_tower_coverage(1, test_cases) [[(10, 20), (30, 20)]] results = [] for i in range(T): N, M, positions = test_cases[i] # sort positions of factories positions.sort() if M == 1: P = positions[0] R = positions[-1] - positions[0] # one tower covering from first to last factory results.append([(P, R)]) continue # Strategy: Initial naive implementation with evenly spaced positioning interval = (positions[-1] - positions[0]) / M # even spacing towers = [(positions[0] + i * interval, interval) for i in range(M)] results.append([(int(P), int(R)) for P, R in towers]) return results","solution":"def optimal_tower_coverage(T, test_cases): Given the number of factories and their positions, determine the positions and ranges of the air purification towers to maximize the pollution reduction. Parameters: T (int): Number of test cases. test_cases (list[tuple]): List of tuples where each tuple contains: - N (int): Number of factories. - M (int): Number of towers. - positions (list[int]): List of integers indicating the positions of the factories. Returns: list[list[tuple]]: List containing results for each test case. Each result is a list of tuples, each tuple containing the starting point and the range for each tower. results = [] for i in range(T): N, M, positions = test_cases[i] positions.sort() if M == 1: P = positions[0] R = positions[-1] - positions[0] results.append([(P, R)]) continue # Strategy: Initial naive implementation with evenly spaced positioning interval = (positions[-1] - positions[0]) / M towers = [(positions[0] + i * interval, interval) for i in range(M)] results.append([(int(P), int(R)) for P, R in towers]) return results"},{"question":"def count_divisible_subarrays(arr, k): You are given an array \`arr\` of integers and an integer \`k\`. For each possible subarray of \`arr\`, calculate its sum and determine if it is divisible by \`k\`. If it is, increment a counter. Return the count of such subarrays. Args: arr (List[int]): The input array of integers. k (int): The divisor. Returns: int: The count of subarrays whose sums are divisible by \`k\`. Examples: >>> count_divisible_subarrays([1, 2, 3, 4, 1], 3) 4 >>> count_divisible_subarrays([2, 2, 2, 2], 2) 10","solution":"def count_divisible_subarrays(arr, k): n = len(arr) # Initialize the prefix sums and counter prefix_sums = [0] * (n + 1) sum_count = {0: 1} result = 0 for i in range(n): prefix_sums[i + 1] = (prefix_sums[i] + arr[i]) % k if prefix_sums[i + 1] in sum_count: result += sum_count[prefix_sums[i + 1]] sum_count[prefix_sums[i + 1]] += 1 else: sum_count[prefix_sums[i + 1]] = 1 return result # Function to read input, process and print the result def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:2+n])) result = count_divisible_subarrays(arr, k) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def addPermission(perm: int, currentPerms: int) -> int: Adds the permission by setting the perm bit in currentPerms. >>> addPermission(1, 3) 3 >>> addPermission(2, 1) 5 >>> addPermission(0, 4) 5 >>> addPermission(3, 1) 9 def removePermission(perm: int, currentPerms: int) -> int: Removes the permission by clearing the perm bit in currentPerms. >>> removePermission(2, 5) 1 >>> removePermission(0, 7) 6 >>> removePermission(1, 3) 1 >>> removePermission(4, 16) 0 def checkPermission(perm: int, currentPerms: int) -> int: Checks if the permission is set in currentPerms. >>> checkPermission(0, 4) 0 >>> checkPermission(2, 5) 1 >>> checkPermission(1, 6) 1 >>> checkPermission(3, 8) 1 >>> checkPermission(9, 512) 1","solution":"def addPermission(perm, currentPerms): Adds the permission by setting the perm bit in currentPerms. return currentPerms | (1 << perm) def removePermission(perm, currentPerms): Removes the permission by clearing the perm bit in currentPerms. return currentPerms & ~(1 << perm) def checkPermission(perm, currentPerms): Checks if the permission is set in currentPerms. return 1 if currentPerms & (1 << perm) else 0"},{"question":"def smallest_largest_sum_or_product(arr: List[int]) -> Tuple[int, int, int]: Find the smallest and largest element in the array. If the array is sorted in strictly ascending order, return the sum of all elements. Otherwise, return the product of all elements. >>> smallest_largest_sum_or_product([1, 2, 3, 4, 5]) (1, 5, 15) >>> smallest_largest_sum_or_product([3, 1, 2, 4]) (1, 4, 24) >>> smallest_largest_sum_or_product([10]) (10, 10, 10) >>> smallest_largest_sum_or_product([1, 2]) (1, 2, 3) >>> smallest_largest_sum_or_product([2, 1]) (1, 2, 2) >>> smallest_largest_sum_or_product([1000000000, 999999999]) (999999999, 1000000000, 999999999000000000)","solution":"def smallest_largest_sum_or_product(arr): smallest = min(arr) largest = max(arr) is_sorted_ascending = all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) if is_sorted_ascending: result = sum(arr) else: result = 1 for num in arr: result *= num return smallest, largest, result"},{"question":"from typing import List def is_symmetric_tree(nodes: List[int]) -> bool: Given a binary tree represented as a list of integers, check if the tree is a mirror of itself (symmetric around its center). >>> is_symmetric_tree([1, 2, 2, 3, 4, 4, 3]) True >>> is_symmetric_tree([1, 2, 2, -1, 3, -1, 3]) False","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric_tree(nodes: List[int]) -> bool: if not nodes: return True # Helper function to convert the list of nodes into a binary tree def create_tree(index: int) -> Optional[TreeNode]: if index >= len(nodes) or nodes[index] == -1: return None root = TreeNode(nodes[index]) root.left = create_tree(2 * index + 1) root.right = create_tree(2 * index + 2) return root root = create_tree(0) # Helper function to check if two trees are mirror images def is_mirror(t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool: if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root, root)"},{"question":"def can_cross(stones: List[int]) -> bool: Determines if the frog can cross the river by reaching the last stone. >>> can_cross([0, 1, 3, 5, 6, 8, 12, 17]) True >>> can_cross([0, 1, 2, 3, 4, 8, 9, 11]) False","solution":"def can_cross(stones): Determines if the frog can cross the river by reaching the last stone. Parameters: stones (List[int]): A list of integers representing the positions of the stones. Returns: bool: True if the frog can reach the last stone, False otherwise. if not stones: return False stone_positions = {stone: set() for stone in stones} stone_positions[stones[0]].add(0) for stone in stones: for jump in stone_positions[stone]: for next_jump in (jump - 1, jump, jump + 1): if next_jump > 0 and (stone + next_jump) in stone_positions: stone_positions[stone + next_jump].add(next_jump) return bool(stone_positions[stones[-1]])"},{"question":"def max_gifts(gifts, capacity): Given an array of integers representing the weights of gifts and a single integer representing the capacity of a bag, determines the maximum number of gifts that can be carried in the bag without exceeding the given capacity. Args: gifts: List[int] - Array of integers representing the weights of the gifts. capacity: int - An integer representing the capacity of the bag. Returns: int - Maximum number of gifts that can be carried without exceeding the capacity. Examples: >>> max_gifts([2, 3, 5, 7], 10) 3 >>> max_gifts([], 10) 0 >>> max_gifts([2, 3, 5, 7], 0) 0 >>> max_gifts([1, 2, 3, 4, 5], 15) 5 >>> max_gifts([5, 5, 5], 4) 0 >>> max_gifts([1]*1000, 500) 500 >>> max_gifts([10000], 10000) 1 >>> max_gifts([2, 2, 3, 7], 10) 3","solution":"def max_gifts(gifts, capacity): Determines the maximum number of gifts that can be carried without exceeding the given capacity. gifts.sort() current_weight = 0 num_gifts = 0 for gift in gifts: if current_weight + gift <= capacity: current_weight += gift num_gifts += 1 else: break return num_gifts"},{"question":"def maxSubsequenceSum(arr, k): Given an array/list of integers and an integer k, find the maximum sum of any subsequence of k elements. >>> maxSubsequenceSum([3, 1, -2, 4, 6, -1], 2) 10 >>> maxSubsequenceSum([10, -3, 2, 8, 1, -5], 3) 20 >>> maxSubsequenceSum([1, 2, 3, 4, 5], 1) 5 >>> maxSubsequenceSum([-1, -2, -3, -4, -5], 2) -3","solution":"def maxSubsequenceSum(arr, k): Returns the maximum sum of any subsequence of k elements. # Sort the array in descending order arr_sorted = sorted(arr, reverse=True) # Take the first k elements since they will have the maximum sum max_sum = sum(arr_sorted[:k]) return max_sum"},{"question":"def min_operations(n: int, m: int) -> int: Determines the minimum number of operations to make all elements of the grid equal to m. Parameters: n (int): Size of the grid (n x n) m (int): Target positive integer to be achieved for all elements Returns: int: Minimum number of operations Examples: >>> min_operations(3, 2) 2 >>> min_operations(4, 3) 3","solution":"def min_operations(n, m): Determines the minimum number of operations to make all elements of the grid equal to m. Parameters: n (int): Size of the grid (n x n) m (int): Target positive integer to be achieved for all elements Returns: int: Minimum number of operations # Each operation effectively increments every element in a sub-grid by 1. # To determine the minimum number of operations, we realize that: # We need to increment every element of the n x n grid by m. # Hence, we need to perform m global operations return m"},{"question":"def find_greatest_distance_and_longest_leg(T, test_cases): Determines the participant who covered the greatest total distance and the participant who had the longest single leg for given test cases. Parameters: T (int): Number of test cases. test_cases (list): List of test cases where each test case is a tuple containing the number of participants, and a list of tuples representing each participant's name, number of legs, and the distances covered in each leg. Returns: list: A list of tuples containing the names of the participants with the greatest distance and the longest leg for each test case. >>> find_greatest_distance_and_longest_leg(2, [(3, [(\\"Alice\\", [5, 10, 7]), (\\"Bob\\", [9, 4]), (\\"Charlie\\", [6, 7, 8, 9])]), (2, [(\\"David\\", [8, 15]), (\\"Eve\\", [14, 5, 9])])]) [(\\"Charlie\\", \\"Alice\\"), (\\"Eve\\", \\"David\\")] >>> find_greatest_distance_and_longest_leg(1, [(2, [(\\"John\\", [15, 20]), (\\"Doe\\", [12, 25])])]) [(\\"Doe\\", \\"Doe\\")] >>> find_greatest_distance_and_longest_leg(1, [(1, [(\\"Single\\", [10, 10, 10])])]) [(\\"Single\\", \\"Single\\")] >>> find_greatest_distance_and_longest_leg(2, [(3, [(\\"Anna\\", [1, 2, 3]), (\\"Ben\\", [2, 3, 4]), (\\"Chris\\", [3, 2, 1])]), (2, [(\\"Greg\\", [5]), (\\"Helen\\", [10])])]) [(\\"Ben\\", \\"Ben\\"), (\\"Helen\\", \\"Helen\\")]","solution":"def find_greatest_distance_and_longest_leg(T, test_cases): Determines the participant who covered the greatest total distance and the participant who had the longest single leg for given test cases. Parameters: T (int): Number of test cases. test_cases (list): List of test cases where each test case is a tuple containing the number of participants, and a list of tuples representing each participant's name, number of legs, and the distances covered in each leg. Returns: list: A list of tuples containing the names of the participants with the greatest distance and the longest leg for each test case. results = [] for case in test_cases: N, participants = case max_total_distance = 0 max_individual_leg = 0 participant_greatest_distance = \\"\\" participant_longest_leg = \\"\\" for participant in participants: name, distances = participant total_distance = sum(distances) longest_leg = max(distances) if total_distance > max_total_distance: max_total_distance = total_distance participant_greatest_distance = name if longest_leg > max_individual_leg: max_individual_leg = longest_leg participant_longest_leg = name results.append((participant_greatest_distance, participant_longest_leg)) return results"},{"question":"def evaluateExpression(expression: str) -> int: Evaluates the given arithmetic expression and returns the result as an integer. The expression can contain single-digit integers and the operators +, -, *, and / and follows standard operator precedence. >>> evaluateExpression(\\"3+2*2\\") 7 >>> evaluateExpression(\\"3/2\\") 1 >>> evaluateExpression(\\"3+5/2\\") 5 >>> evaluateExpression(\\"10-2*3\\") 4 >>> evaluateExpression(\\"14/3*2\\") 8 >>> evaluateExpression(\\"1+2+3\\") 6 >>> evaluateExpression(\\"10+2-3\\") 9 >>> evaluateExpression(\\"2*3+4\\") 10 >>> evaluateExpression(\\"8/4+2\\") 4 >>> evaluateExpression(\\"2+3*4-5/5\\") 13 >>> evaluateExpression(\\"5*6/3+2-3\\") 9 >>> evaluateExpression(\\"1\\") 1 >>> evaluateExpression(\\"9+0\\") 9 >>> evaluateExpression(\\"0\\") 0 >>> evaluateExpression(\\"9-9+9*0/1\\") 0","solution":"def evaluateExpression(expression): Evaluates the given arithmetic expression and returns the result as an integer. The expression can contain single-digit integers and the operators +, -, *, and / and follows standard operator precedence. stack = [] current_number = 0 operation = '+' for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if operation == '+': stack.append(current_number) elif operation == '-': stack.append(-current_number) elif operation == '*': stack.append(stack.pop() * current_number) elif operation == '/': stack.append(int(stack.pop() / current_number)) # using int() for integer division truncation operation = char current_number = 0 return sum(stack)"},{"question":"def is_power_of_three(n: int) -> bool: Determine if a given positive integer is a power of three. >>> is_power_of_three(27) True >>> is_power_of_three(0) False >>> is_power_of_three(9) True >>> is_power_of_three(45) False","solution":"def is_power_of_three(n): Return True if n is a power of three, otherwise return False. if n <= 0: return False while n % 3 == 0: n //= 3 return n == 1"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string 's' a palindrome. >>> min_deletions_to_palindrome(\\"abca\\") == 1 >>> min_deletions_to_palindrome(\\"racecar\\") == 0 >>> min_deletions_to_palindrome(\\"google\\") == 2 >>> min_deletions_to_palindrome(\\"a\\") == 0 >>> min_deletions_to_palindrome(\\"madam\\") == 0 >>> min_deletions_to_palindrome(\\"aibohphobia\\") == 0","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the string 's' a palindrome. n = len(s) # Compute the length of the longest palindromic subsequence def longest_palindromic_subsequence(s): dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) return n - lps_length"},{"question":"from typing import List, Tuple def solve_min_transportation_costs(N: int, M: int, Q: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given the number of nodes N, number of edges M, number of queries Q, the list of edges (u_i, v_i, w_i), and the list of queries (q_i, r_i), returns a list of minimum transportation costs between each queried node pairs. Args: N (int): Number of nodes M (int): Number of edges Q (int): Number of queries edges (List[Tuple[int, int, int]]): List of edges where an edge is defined by a tuple (u, v, w) queries (List[Tuple[int, int]]): List of queries where each query is a tuple (q, r) Returns: List[int]: List of minimum transportation costs for each query. If no path exists, return -1. >>> solve_min_transportation_costs(5, 5, 3, [(1, 2, 2), (2, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3)], [(1, 5), (2, 3), (1, 3)]) [10, 4, 6] pass # Unit tests def test_example_case(): N = 5 M = 5 Q = 3 edges = [(1, 2, 2), (2, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3)] queries = [(1, 5), (2, 3), (1, 3)] result = solve_min_transportation_costs(N, M, Q, edges, queries) assert result == [10, 4, 6] def test_no_path(): N = 4 M = 2 Q = 2 edges = [(1, 2, 3), (3, 4, 5)] queries = [(1, 3), (2, 4)] result = solve_min_transportation_costs(N, M, Q, edges, queries) assert result == [-1, -1] def test_single_node_path(): N = 4 M = 2 Q = 2 edges = [(1, 2, 3), (2, 3, 4)] queries = [(1, 1), (3, 3)] result = solve_min_transportation_costs(N, M, Q, edges, queries) assert result == [0, 0] def test_large_graph(): N = 6 M = 7 Q = 2 edges = [(1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2)] queries = [(1, 5), (3, 6)] result = solve_min_transportation_costs(N, M, Q, edges, queries) assert result == [-1, 2] # Example usage if __name__ == \\"__main__\\": N = 5 M = 5 Q = 3 edges = [(1, 2, 2), (2, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3)] queries = [(1, 5), (2, 3), (1, 3)] print(solve_min_transportation_costs(N, M, Q, edges, queries)) # Expected output: [10, 4, 6]","solution":"import heapq def dijkstra(graph, start, n): Runs Dijkstra's algorithm to find the shortest paths from 'start' to all other nodes. distances = [float('inf')] * (n + 1) distances[start] = 0 pq = [(0, start)] # (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def solve_min_transportation_costs(N, M, Q, edges, queries): Solves the problem of finding minimum transportation costs between queried nodes. # Build the graph graph = [[] for _ in range(N + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Apply Dijkstra's algorithm from each queried node pair results = [] for q, r in queries: distances = dijkstra(graph, q, N) if distances[r] == float('inf'): results.append(-1) else: results.append(distances[r]) return results # Example usage: N = 5 M = 5 Q = 3 edges = [(1, 2, 2), (2, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3)] queries = [(1, 5), (2, 3), (1, 3)] print(solve_min_transportation_costs(N, M, Q, edges, queries)) # Expected output: [10, 4, 6]"},{"question":"def min_sections_to_collect_bacteria(n: int, m: int, bacteria_counts: List[int]) -> int: Returns the minimum number of sections needed to collect at least m bacteria. If it's not possible to collect m bacteria starting from any section, returns -1. >>> min_sections_to_collect_bacteria(5, 12, [1, 2, 3, 4, 5]) == 3 >>> min_sections_to_collect_bacteria(4, 10, [4, 4, 4, 4]) == 3 >>> min_sections_to_collect_bacteria(3, 15, [3, 1, 4]) == -1","solution":"def min_sections_to_collect_bacteria(n, m, bacteria_counts): Returns the minimum number of sections needed to collect at least m bacteria. If it's not possible to collect m bacteria starting from any section, returns -1. total_bacteria = sum(bacteria_counts) if total_bacteria < m: return -1 min_sections = n + 1 current_sum = 0 left = 0 for right in range(n): current_sum += bacteria_counts[right] while current_sum >= m: min_sections = min(min_sections, right - left + 1) current_sum -= bacteria_counts[left] left += 1 return min_sections if min_sections <= n else -1 # Example usage n, m = 5, 12 bacteria_counts = [1, 2, 3, 4, 5] print(min_sections_to_collect_bacteria(n, m, bacteria_counts)) # Should print 3"},{"question":"def find_winners(n: int, speeds: List[int]) -> List[int]: Returns a list of indices of participants with the maximum speed. >>> find_winners(5, [10, 12, 10, 15, 15]) [3, 4] >>> find_winners(4, [20, 15, 15, 20]) [0, 3]","solution":"def find_winners(n, speeds): Returns a list of indices of participants with the maximum speed. max_speed = max(speeds) winners = [index for index, speed in enumerate(speeds) if speed == max_speed] return winners"},{"question":"def max_non_overlapping_intervals(test_cases): Determines the maximum number of non-overlapping time windows from the given key cards. Arguments: test_cases -- a list of lists, where each inner list contains tuples representing the start and end times of time windows Returns: List of integers where each integer represents the maximum number of non-overlapping time windows for a corresponding test case Example: >>> input_data = [ ... \\"2\\", ... \\"3\\", ... \\"1 4\\", ... \\"2 5\\", ... \\"5 8\\", ... \\"4\\", ... \\"1 3\\", ... \\"2 4\\", ... \\"3 5\\", ... \\"5 7\\" ... ] >>> test_cases = process_input(input_data) >>> max_non_overlapping_intervals(test_cases) [2, 3] pass def process_input(input_lines): Converts input strings to data structures for processing. Arguments: input_lines -- list of strings representing the input for multiple test cases Returns: List of lists, where each inner list contains tuples representing the start and end times of time windows Example: >>> input_data = [ ... \\"2\\", ... \\"3\\", ... \\"1 4\\", ... \\"2 5\\", ... \\"5 8\\", ... \\"4\\", ... \\"1 3\\", ... \\"2 4\\", ... \\"3 5\\", ... \\"5 7\\" ... ] >>> process_input(input_data) [[(1, 4), (2, 5), (5, 8)], [(1, 3), (2, 4), (3, 5), (5, 7)]] pass # Test Cases def test_max_non_overlapping_intervals(): input_data = [ \\"2\\", \\"3\\", \\"1 4\\", \\"2 5\\", \\"5 8\\", \\"4\\", \\"1 3\\", \\"2 4\\", \\"3 5\\", \\"5 7\\" ] test_cases = process_input(input_data) expected_output = [2, 3] output = max_non_overlapping_intervals(test_cases) assert output == expected_output def test_non_overlapping_single_case(): input_data = [ \\"1\\", \\"5\\", \\"1 2\\", \\"3 4\\", \\"5 6\\", \\"7 8\\", \\"9 10\\" ] test_cases = process_input(input_data) expected_output = [5] output = max_non_overlapping_intervals(test_cases) assert output == expected_output def test_fully_overlapping_case(): input_data = [ \\"1\\", \\"3\\", \\"1 10\\", \\"2 9\\", \\"3 8\\" ] test_cases = process_input(input_data) expected_output = [1] output = max_non_overlapping_intervals(test_cases) assert output == expected_output def test_no_overlapping_intervals(): input_data = [ \\"1\\", \\"4\\", \\"1 3\\", \\"4 6\\", \\"7 9\\", \\"10 12\\" ] test_cases = process_input(input_data) expected_output = [4] output = max_non_overlapping_intervals(test_cases) assert output == expected_output","solution":"def max_non_overlapping_intervals(test_cases): results = [] for intervals in test_cases: # Sort intervals based on end time intervals.sort(key=lambda x: x[1]) count = 0 end_time = 0 for interval in intervals: if interval[0] >= end_time: count += 1 end_time = interval[1] results.append(count) return results def process_input(input_lines): t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) index += 1 intervals = [tuple(map(int, input_lines[index + i].split())) for i in range(n)] test_cases.append(intervals) index += n return test_cases"},{"question":"from typing import List def maxWaterTrap(height: List[int]) -> int: Computes the maximum amount of water that can be trapped after raining given the heights of the buildings. Args: height : List[int] : List of non-negative integers representing the heights of buildings. Returns: int : Maximum amount of water that can be trapped. Examples: >>> maxWaterTrap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> maxWaterTrap([4, 2, 0, 3, 2, 5]) 9 >>> maxWaterTrap([]) 0 >>> maxWaterTrap([1, 1, 1, 1]) 0 >>> maxWaterTrap([4, 2, 3]) 1","solution":"def maxWaterTrap(height): Computes the maximum amount of water that can be trapped. Args: height : List[int] : List of non-negative integers representing the heights of buildings. Returns: int : Maximum amount of water that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 max_left, max_right = height[left], height[right] water_trapped = 0 while left < right: if max_left < max_right: left += 1 max_left = max(max_left, height[left]) water_trapped += max_left - height[left] else: right -= 1 max_right = max(max_right, height[right]) water_trapped += max_right - height[right] return water_trapped"},{"question":"def count_hits(N, M, ship_positions, guesses): Count the number of hits on ships given the ship positions and guesses. Parameters: N (int): Number of rows of the grid. M (int): Number of columns of the grid. ship_positions (list of tuples): Starting and ending coordinates of ships. guesses (list of tuples): Coordinates of the guesses. Returns: int: Number of hits. pass # Test cases def test_count_hits_example(): N, M = 8, 8 ship_positions = [(1, 2, 1, 4), (2, 3, 2, 5), (4, 5, 6, 5)] guesses = [(1, 2), (2, 4), (4, 5), (4, 6), (1, 3)] assert count_hits(N, M, ship_positions, guesses) == 4 def test_count_hits_no_hits(): N, M = 5, 5 ship_positions = [(1, 1, 1, 3), (2, 2, 2, 3)] guesses = [(3, 3), (4, 4), (5, 5)] assert count_hits(N, M, ship_positions, guesses) == 0 def test_count_hits_all_hits(): N, M = 5, 5 ship_positions = [(1, 1, 1, 1), (2, 2, 2, 2), (3, 3, 3, 3)] guesses = [(1, 1), (2, 2), (3, 3)] assert count_hits(N, M, ship_positions, guesses) == 3 def test_count_hits_partial_hits(): N, M = 5, 5 ship_positions = [(1, 1, 1, 2), (2, 2, 2, 3), (3, 3, 3, 4)] guesses = [(1, 1), (2, 3), (4, 4)] assert count_hits(N, M, ship_positions, guesses) == 2","solution":"def count_hits(N, M, ship_positions, guesses): Count the number of hits on ships given the ship positions and guesses. Parameters: N (int): Number of rows of the grid. M (int): Number of columns of the grid. ship_positions (list of tuples): Starting and ending coordinates of ships. guesses (list of tuples): Coordinates of the guesses. Returns: int: Number of hits. # Create a set to store the coordinates of all ship cells ship_cells = set() # Convert ship positions to individual cells and add to ship_cells set for r1, c1, r2, c2 in ship_positions: if r1 == r2: # Horizontal ship for c in range(c1, c2 + 1): ship_cells.add((r1, c)) else: # Vertical ship for r in range(r1, r2 + 1): ship_cells.add((r, c1)) # Count hits from the guesses hits = 0 for r, c in guesses: if (r, c) in ship_cells: hits += 1 return hits"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Counts the number of distinct valid paths from the top-left to the bottom-right cell of the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid. Returns: int: Number of distinct valid paths >>> count_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> count_paths(3, 3, [\\".#.\\", \\".#.\\", \\"...\\"]) 1 >>> count_paths(3, 3, [\\".#.\\", \\".\\", \\"...\\"]) 0","solution":"def count_paths(n, m, grid): Counts the number of distinct valid paths from the top-left to the bottom-right cell of the grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: List of strings representing the grid. :return: Number of distinct valid paths. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def countInversions(N, A): Count the number of inversions in the array A of length N. An inversion is a pair (i, j) such that i < j and A[i] > A[j]. Example 1: >>> countInversions(5, [2, 4, 1, 3, 5]) 3 Example 2: >>> countInversions(5, [5, 4, 3, 2, 1]) 10 from solution import countInversions def test_example_1(): assert countInversions(5, [2, 4, 1, 3, 5]) == 3 def test_example_2(): assert countInversions(5, [5, 4, 3, 2, 1]) == 10 def test_no_inversion(): assert countInversions(5, [1, 2, 3, 4, 5]) == 0 def test_all_identical(): assert countInversions(5, [1, 1, 1, 1, 1]) == 0 def test_single_element(): assert countInversions(1, [1]) == 0 def test_large_input(): arr = list(range(1, 100001)) assert countInversions(len(arr), arr) == 0 def test_worst_case_large_input(): arr = list(range(100000, 0, -1)) expected_inversions = (len(arr)*(len(arr)-1))//2 assert countInversions(len(arr), arr) == expected_inversions","solution":"def countInversions(N, A): This function returns the number of inversions in the array A of length N. An inversion is a pair (i, j) such that i < j and A[i] > A[j]. def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge(arr, temp_arr, left, mid, right) return inv_count def merge(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count temp_arr = [0]*N return merge_sort(A, temp_arr, 0, N - 1)"},{"question":"def is_diagonally_dominant(matrix): Check if a given square matrix is Diagonally Dominant. >>> is_diagonally_dominant([ ... [3, -2, 1], ... [1, -4, 2], ... [1, 2, 5] ... ]) == True >>> is_diagonally_dominant([ ... [1, 2, 3], ... [2, 100, 2], ... [3, 2, 1] ... ]) == False pass def check_matrices(test_cases): Determine if each matrix in a list of test cases is Diagonally Dominant. >>> check_matrices([ ... [ ... [3, -2, 1], ... [1, -4, 2], ... [1, 2, 5] ... ], ... [ ... [1, 2, 3], ... [2, 100, 2], ... [3, 2, 1] ... ] ... ]) == [\\"YES\\", \\"NO\\"] pass def main(input_data): Process input data to determine if given matrices are Diagonally Dominant. >>> main(\\"2n3n3 -2 1n1 -4 2n1 2 5n3n1 2 3n2 100 2n3 2 1\\") == \\"YESnNO\\" >>> main(\\"1n2n1 2n4 1\\") == \\"NO\\" pass","solution":"def is_diagonally_dominant(matrix): n = len(matrix) for i in range(n): diag_element = abs(matrix[i][i]) row_sum = sum(abs(matrix[i][j]) for j in range(n) if i != j) if diag_element < row_sum: return False return True def check_matrices(test_cases): results = [] for matrix in test_cases: if is_diagonally_dominant(matrix): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def main(input_data): lines = input_data.split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 matrix = [] for _ in range(N): row = list(map(int, lines[index].split())) matrix.append(row) index += 1 test_cases.append(matrix) results = check_matrices(test_cases) return \\"n\\".join(results)"},{"question":"from typing import List def find_largest_palindromic_subgrid(n: int, m: int, grid: List[str]) -> int: Determine the size of the largest palindromic subgrid in the given grid. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): A list of strings representing the grid. Returns: int: The size of the largest palindromic subgrid. Examples: >>> find_largest_palindromic_subgrid(3, 3, [\\"ABA\\", \\"BAB\\", \\"ABA\\"]) 3 >>> find_largest_palindromic_subgrid(4, 4, [\\"AAAA\\", \\"ABBA\\", \\"ABBA\\", \\"AAAA\\"]) 4 >>> find_largest_palindromic_subgrid(2, 3, [\\"ABC\\", \\"DEF\\"]) 1 # Your code here # Unit Test import pytest def test_example_1(): n = 3 m = 3 grid = [\\"ABA\\", \\"BAB\\", \\"ABA\\"] assert find_largest_palindromic_subgrid(n, m, grid) == 3 def test_example_2(): n = 4 m = 4 grid = [\\"AAAA\\", \\"ABBA\\", \\"ABBA\\", \\"AAAA\\"] assert find_largest_palindromic_subgrid(n, m, grid) == 4 def test_example_3(): n = 2 m = 3 grid = [\\"ABC\\", \\"DEF\\"] assert find_largest_palindromic_subgrid(n, m, grid) == 1 def test_single_row(): n = 1 m = 5 grid = [\\"ABCDE\\"] assert find_largest_palindromic_subgrid(n, m, grid) == 1 def test_single_column(): n = 5 m = 1 grid = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] assert find_largest_palindromic_subgrid(n, m, grid) == 1","solution":"def is_palindromic_subgrid(grid, i1, j1, i2, j2): for i in range(i1, i2 + 1): if grid[i][j1:j2 + 1] != grid[i][j1:j2 + 1][::-1]: return False for j in range(j1, j2 + 1): col = ''.join(grid[i][j] for i in range(i1, i2 + 1)) if col != col[::-1]: return False return True def largest_palindromic_subgrid(n, m, grid): max_size = 1 for i1 in range(n): for j1 in range(m): for i2 in range(i1, n): for j2 in range(j1, m): if is_palindromic_subgrid(grid, i1, j1, i2, j2): max_size = max(max_size, (i2 - i1 + 1)) return max_size # Recognizing grid input and running the palindromic subgrid search def find_largest_palindromic_subgrid(n, m, grid): return largest_palindromic_subgrid(n, m, grid)"},{"question":"def sum_of_positives(numbers: List[int]) -> int: Returns the sum of all positive numbers in the given array. If there are no positive numbers, the function returns 0. >>> sum_of_positives([1, -2, 3, 4, -5]) 8 >>> sum_of_positives([-1, -2, -3, -4, -5]) 0 >>> sum_of_positives([]) 0","solution":"def sum_of_positives(numbers): Returns the sum of all positive numbers in the given array. If there are no positive numbers, the function returns 0. return sum(num for num in numbers if num > 0)"},{"question":"def can_complete_projects(n: int, projects: List[Tuple[int, int, List[int]]]) -> str: Determines if all projects can be completed by their deadlines. :param n: Number of projects :param projects: List of tuples, where each tuple contains three elements: - deadline day (int) - number of required resources (int) - availability days of the resources (List[int]) :return: \\"YES\\" if all projects can be completed by their deadlines, otherwise \\"NO\\" >>> can_complete_projects(3, [(10, 2, [3, 5]), (15, 3, [1, 1, 14]), (20, 1, [19])]) 'YES' >>> can_complete_projects(2, [(5, 3, [1, 2, 6]), (10, 2, [12, 15])]) 'NO' >>> can_complete_projects(1, [(10, 3, [1, 2, 3])]) 'YES' >>> can_complete_projects(1, [(5, 3, [2, 3, 6])]) 'NO' >>> can_complete_projects(2, [(10, 2, [10, 10]), (20, 3, [20, 20, 20])]) 'YES' >>> can_complete_projects(3, [(15, 2, [5, 10]), (20, 3, [5, 10, 15]), (25, 1, [20])]) 'YES'","solution":"def can_complete_projects(n, projects): Determines if all projects can be completed by their deadlines. :param n: Number of projects :param projects: List of tuples, where each tuple contains three elements: deadline day, number of required resources, and list of availability days of the resources :return: \\"YES\\" if all projects can be completed by their deadlines, otherwise \\"NO\\" for deadline, _, availability_days in projects: if any(day > deadline for day in availability_days): return \\"NO\\" return \\"YES\\" # Sample Input/Output Execution if __name__ == \\"__main__\\": # Example 1 n1 = 3 projects1 = [ (10, 2, [3, 5]), (15, 3, [1, 1, 14]), (20, 1, [19]), ] print(can_complete_projects(n1, projects1)) # Output: YES # Example 2 n2 = 2 projects2 = [ (5, 3, [1, 2, 6]), (10, 2, [12, 15]), ] print(can_complete_projects(n2, projects2)) # Output: NO"},{"question":"class ToDoList: A simple text-based to-do list application. This class supports the following operations: - add_task: Add a new task to the to-do list with a given description. - complete_task: Mark a specified task as completed. - list_tasks: Print all tasks, showing uncompleted tasks first, followed by completed tasks. Each task in the list should display its description and status (completed or uncompleted). - remove_task: Remove a specified task from the to-do list. >>> todo = ToDoList() >>> todo.add_task(\\"Buy groceries\\") >>> todo.add_task(\\"Go for a run\\") >>> todo.complete_task(\\"Buy groceries\\") >>> todo.list_tasks() [(\\"Go for a run\\", \\"uncompleted\\"), (\\"Buy groceries\\", \\"completed\\")] >>> todo.remove_task(\\"Go for a run\\") >>> todo.list_tasks() [(\\"Buy groceries\\", \\"completed\\")] def __init__(self): self.tasks = {} def add_task(self, description): Add a new task to the to-do list with the given description. pass def complete_task(self, description): Mark a specified task as completed. pass def list_tasks(self): Print all tasks, showing uncompleted tasks first, followed by completed tasks. pass def remove_task(self, description): Remove a specified task from the to-do list. pass","solution":"class ToDoList: def __init__(self): self.tasks = {} def add_task(self, description): if description not in self.tasks: self.tasks[description] = False def complete_task(self, description): if description in self.tasks: self.tasks[description] = True def list_tasks(self): uncompleted = [(desc, \\"uncompleted\\") for desc, completed in self.tasks.items() if not completed] completed = [(desc, \\"completed\\") for desc, completed in self.tasks.items() if completed] return uncompleted + completed def remove_task(self, description): if description in self.tasks: del self.tasks[description]"},{"question":"def main(input_str: str) -> List[int]: Execute commands on the given array of soldiers' strength and return results for type '2 L R' commands. Args: input_str: str: Multiline input string containing array size, number of commands, initial array values, and commands. Returns: List[int]: A list of integers representing results for type '2 L R' commands. >>> input_str = '6 5n6 10 3 5 7 15n2 1 6n1 4 11n2 3 5n2 1 3n2 2 4' >>> main(input_str) [3, 3, 1, 2] >>> input_str = '3 2n1 3 1n2 1 3n2 2 2' >>> main(input_str) [1, 1]","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def execute_commands(n, m, soldiers, commands): results = [] for command in commands: cmd = command.split() if cmd[0] == \\"1\\": X = int(cmd[1]) - 1 Y = int(cmd[2]) soldiers[X] = Y elif cmd[0] == \\"2\\": L = int(cmd[1]) - 1 R = int(cmd[2]) - 1 prime_count = sum(1 for i in range(L, R + 1) if is_prime(soldiers[i])) results.append(prime_count) return results def process_input(input_str): input_lines = input_str.strip().split('n') n, m = map(int, input_lines[0].split()) soldiers = list(map(int, input_lines[1].split())) commands = input_lines[2:] return n, m, soldiers, commands def main(input_str): n, m, soldiers, commands = process_input(input_str) results = execute_commands(n, m, soldiers, commands) return results"},{"question":"def is_prime(n: int) -> bool: Determine if a number is a prime. :param n: An integer number to check. :return: True if n is a prime number, False otherwise. # implementation here def classify_number(n: int) -> str: Classify a number as prime, composite or neither. :param n: An integer number to classify. :return: \\"prime number\\", \\"composite number\\" or \\"neither\\" # implementation here def process_numbers(numbers: List[int]) -> List[str]: Process a list of numbers and classify each as prime, composite or neither. :param numbers: A list of integer numbers. :return: A list of classification strings for each number. # implementation here from typing import List def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(1) == False assert is_prime(0) == False assert is_prime(-3) == False assert is_prime(17) == True assert is_prime(18) == False def test_classify_number(): assert classify_number(2) == \\"prime number\\" assert classify_number(3) == \\"prime number\\" assert classify_number(4) == \\"composite number\\" assert classify_number(1) == \\"neither\\" assert classify_number(0) == \\"neither\\" assert classify_number(-3) == \\"neither\\" assert classify_number(17) == \\"prime number\\" assert classify_number(18) == \\"composite number\\" def test_process_numbers(): assert process_numbers([5, 10, 1, 23, 0, 18, -1]) == [ \\"prime number\\", \\"composite number\\", \\"neither\\", \\"prime number\\", \\"neither\\", \\"composite number\\" ] assert process_numbers([2, 3, 4, 5, 6, -1]) == [ \\"prime number\\", \\"prime number\\", \\"composite number\\", \\"prime number\\", \\"composite number\\" ] assert process_numbers([-1]) == [] def test_process_numbers_with_extra_after_end(): assert process_numbers([7, 19, -1, 4, 9]) == [ \\"prime number\\", \\"prime number\\" ]","solution":"def is_prime(n): Determine if a number is a prime. :param n: An integer number to check. :return: True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def classify_number(n): Classify a number as prime, composite or neither. :param n: An integer number to classify. :return: \\"prime number\\", \\"composite number\\" or \\"neither\\" if n <= 1: return \\"neither\\" if is_prime(n): return \\"prime number\\" else: return \\"composite number\\" def process_numbers(numbers): Process a list of numbers and classify each as prime, composite or neither. :param numbers: A list of integer numbers. :return: A list of classification strings for each number. results = [] for number in numbers: if number == -1: break results.append(classify_number(number)) return results"},{"question":"def min_swaps_to_sort(nums): Returns the minimum number of swaps required to sort the array. >>> min_swaps_to_sort([4, 3, 1, 2]) 3 >>> min_swaps_to_sort([2, 3, 4, 1, 5]) 3 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort([5, 4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([1]) 0 >>> min_swaps_to_sort([2, 1]) 1","solution":"def min_swaps_to_sort(nums): Returns the minimum number of swaps required to sort the array. n = len(nums) arr_pos = [*enumerate(nums)] arr_pos.sort(key=lambda it: it[1]) vis = {k: False for k in range(n)} ans = 0 for i in range(n): if vis[i] or arr_pos[i][0] == i: continue cycle_size = 0 j = i while not vis[j]: vis[j] = True j = arr_pos[j][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"def can_assign_booths_unique(n: int, staff_requirements: List[int]) -> str: Checks if it's possible to assign booths such that the total number of staff members used in each combination is unique. Args: n : int : Number of different booth types. staff_requirements : list : List of integers representing the number of staff members required for each booth type. Returns: str : \\"Possible\\" or \\"Impossible\\" >>> can_assign_booths_unique(4, [1, 2, 3, 4]) 'Possible' >>> can_assign_booths_unique(3, [1, 2, 2]) 'Impossible' >>> can_assign_booths_unique(1, [5]) 'Possible' >>> can_assign_booths_unique(4, [3, 3, 3, 3]) 'Impossible' >>> can_assign_booths_unique(4, [1000, 2000, 3000, 4000]) 'Possible' >>> can_assign_booths_unique(4, [1000, 2000, 3000, 3000]) 'Impossible'","solution":"def can_assign_booths_unique(n, staff_requirements): Checks if it's possible to assign booths such that the total number of staff members used in each combination is unique. Args: n : int : Number of different booth types. staff_requirements : list : List of integers representing the number of staff members required for each booth type. Returns: str : \\"Possible\\" or \\"Impossible\\" staff_requirements_sorted = sorted(staff_requirements) for i in range(1, n): if staff_requirements_sorted[i] == staff_requirements_sorted[i - 1]: return \\"Impossible\\" return \\"Possible\\""},{"question":"def min_buses(routes): Returns the minimum number of buses required to cover all routes. Each route is represented as a list of integers indicating bus stops. >>> min_buses([[1, 2, 3], [3, 2, 1], [1, 3, 4]]) 2 >>> min_buses([[1, 2], [2, 3]]) 2 def process_input(input_data): Process the input data and return the results for each test case. The input_data parameter is a string containing input in the format specified. >>> input_data = \\"2n3n1 2 3n3 2 1n1 3 4n2n1 2n2 3n\\" >>> process_input(input_data) [2, 2] from solution import min_buses, process_input def test_min_buses(): # Test case 1 routes = [[1, 2, 3], [3, 2, 1], [1, 3, 4]] assert min_buses(routes) == 2 # Test case 2 routes = [[1, 2], [2, 3]] assert min_buses(routes) == 2 # Test case 3: same routes, different orders routes = [[1, 2, 3], [2, 3, 1], [3, 1, 2]] assert min_buses(routes) == 1 # Test case 4: all routes have unique stops routes = [[1, 4], [2, 5], [3, 6]] assert min_buses(routes) == 3 def test_process_input(): input_data = \\"2n3n1 2 3n3 2 1n1 3 4n2n1 2n2 3n\\" expected_output = [2, 2] assert process_input(input_data) == expected_output input_data = \\"1n2n1 4n2 5n\\" expected_output = [2] assert process_input(input_data) == expected_output","solution":"def min_buses(routes): Returns the minimum number of buses required to cover all routes. # Initialize a set to store unique routes unique_routes = set() # Iterate over the routes for route in routes: unique_routes.add(tuple(sorted(route))) # Return the number of unique routes as each requires a separate bus return len(unique_routes) def process_input(input_data): Process the input data and return the results for each test case. lines = input_data.strip().split('n') T = int(lines[0]) results = [] idx = 1 for _ in range(T): R = int(lines[idx]) routes = [list(map(int, lines[idx + i + 1].split())) for i in range(R)] results.append(min_buses(routes)) idx += R + 1 return results"},{"question":"def calculate_maximum_final_element(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases where each test case is a tuple containing an integer n and a list of n integers, determine the maximum possible value of the final element after performing any number of operations where in one operation, you can choose two adjacent elements and replace both with their sum. Return the results as a list of integers. Args: test_cases: List[Tuple[int, List[int]]] - List of test cases, where each test case is a tuple containing an integer n and a list of n integers. Returns: List[int] - A list of integers representing the maximum possible value of the final element for each test case. Examples: >>> test_cases = [(3, [1, 2, 3]), (4, [4, 5, 1, 3]), (2, [10, 20])] >>> calculate_maximum_final_element(test_cases) [6, 13, 30] >>> test_cases = [(5, [1, 1, 1, 1, 1]), (1, [100]), (6, [1, 2, 3, 4, 5, 6])] >>> calculate_maximum_final_element(test_cases) [5, 100, 21]","solution":"def calculate_maximum_final_element(test_cases): results = [] for case in test_cases: n, array = case results.append(sum(array)) return results"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequently occurring character in the string \`s\`. If there is a tie, returns the lexicographically smallest character with the highest frequency. >>> most_frequent_character(\\"a\\") \\"a\\" >>> most_frequent_character(\\"abcdef\\") \\"a\\" >>> most_frequent_character(\\"aabbcc\\") \\"a\\" >>> most_frequent_character(\\"abracadabra\\") \\"a\\" >>> most_frequent_character(\\"abcabcabc\\") \\"a\\" >>> most_frequent_character(\\"xyzxyz\\") \\"x\\" >>> most_frequent_character(\\" abbccc\\") \\"c\\"","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string \`s\`. If there is a tie, returns the lexicographically smallest character with the highest frequency. from collections import Counter # Count frequency of each character frequency = Counter(s) # Find the maximum frequency max_freq = max(frequency.values()) # Find all characters with the maximum frequency candidates = [char for char, freq in frequency.items() if freq == max_freq] # Return the lexicographically smallest character among the candidates return min(candidates)"},{"question":"from typing import List, Tuple, Dict def parse_logs(n: int, logs: List[str]) -> Dict[str, List[Tuple[str, str]]]: Parses log entries to extract valid login sessions for each user. Parameters: n (int): Number of log entries. logs (list): List of log entries, where each entry is a string in the format \\"timestamp user_id event\\". Returns: dict: Dictionary where keys are user_ids and values are lists of tuples representing valid sessions with start and end timestamps. from solution import parse_logs def test_parse_logs_example_1(): n = 6 logs = [ \\"2021-08-01 12:00:00 user1 login\\", \\"2021-08-01 12:30:00 user1 logout\\", \\"2021-08-01 12:15:00 user2 login\\", \\"2021-08-01 12:20:00 user2 login\\", \\"2021-08-01 12:35:00 user2 logout\\", \\"2021-08-01 13:00:00 user1 logout\\" ] expected_output = { \\"user1\\": [(\\"2021-08-01 12:00:00\\", \\"2021-08-01 12:30:00\\")], \\"user2\\": [(\\"2021-08-01 12:15:00\\", \\"2021-08-01 12:35:00\\")] } assert parse_logs(n, logs) == expected_output def test_parse_logs_example_2(): n = 5 logs = [ \\"2021-07-31 09:00:00 user1 login\\", \\"2021-07-31 09:05:00 user1 logout\\", \\"2021-07-31 09:15:00 user1 logout\\", \\"2021-07-31 09:10:00 user1 login\\", \\"2021-07-31 09:20:00 user1 login\\" ] expected_output = { \\"user1\\": [(\\"2021-07-31 09:00:00\\", \\"2021-07-31 09:05:00\\")] } assert parse_logs(n, logs) == expected_output def test_parse_logs_no_valid_sessions(): n = 3 logs = [ \\"2021-08-01 12:00:00 user1 logout\\", \\"2021-08-01 12:10:00 user1 logout\\", \\"2021-08-01 12:20:00 user1 logout\\" ] expected_output = {} assert parse_logs(n, logs) == expected_output def test_parse_logs_multiple_users(): n = 6 logs = [ \\"2021-08-01 12:00:00 user1 login\\", \\"2021-08-01 12:30:00 user1 logout\\", \\"2021-08-01 12:15:00 user2 login\\", \\"2021-08-01 12:40:00 user2 logout\\", \\"2021-08-01 13:00:00 user1 login\\", \\"2021-08-01 13:30:00 user1 logout\\" ] expected_output = { \\"user1\\": [(\\"2021-08-01 12:00:00\\", \\"2021-08-01 12:30:00\\"), (\\"2021-08-01 13:00:00\\", \\"2021-08-01 13:30:00\\")], \\"user2\\": [(\\"2021-08-01 12:15:00\\", \\"2021-08-01 12:40:00\\")] } assert parse_logs(n, logs) == expected_output def test_parse_logs_invalid_order(): n = 4 logs = [ \\"2021-08-01 12:00:00 user1 logout\\", \\"2021-08-01 12:10:00 user1 login\\", \\"2021-08-01 12:20:00 user1 login\\", \\"2021-08-01 12:30:00 user1 logout\\" ] expected_output = { \\"user1\\": [(\\"2021-08-01 12:10:00\\", \\"2021-08-01 12:30:00\\")] } assert parse_logs(n, logs) == expected_output","solution":"def parse_logs(n, logs): Parses log entries to extract valid login sessions for each user. Parameters: n (int): Number of log entries. logs (list): List of log entries, where each entry is a string in the format \\"timestamp user_id event\\". Returns: dict: Dictionary where keys are user_ids and values are lists of tuples representing valid sessions with start and end timestamps. from collections import defaultdict import operator sessions = defaultdict(list) current_sessions = {} # Process each log entry for log in logs: parts = log.split() timestamp = f\\"{parts[0]} {parts[1]}\\" user_id = parts[2] event = parts[3] if event == \\"login\\": if user_id not in current_sessions: current_sessions[user_id] = timestamp elif event == \\"logout\\": if user_id in current_sessions: sessions[user_id].append((current_sessions[user_id], timestamp)) del current_sessions[user_id] # Sort users lexicographically sorted_users = dict(sorted(sessions.items(), key=operator.itemgetter(0))) return sorted_users"},{"question":"def min_moves_to_balance(s: str) -> int: Determine the minimum number of moves required to make the brackets balanced. Parameters: s (str): A string composed of '(' and ')' characters. Returns: int: The minimum number of moves required to balance the brackets. Examples: >>> min_moves_to_balance('()))((') 4 >>> min_moves_to_balance('((()(()))') 1","solution":"def min_moves_to_balance(s): Returns the minimum number of moves required to make the brackets balanced. left_balance = 0 right_balance = 0 for char in s: if char == '(': left_balance += 1 elif char == ')': if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"def rotate_matrix(n: int, matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x n matrix 90 degrees clockwise. :param n: Integer representing the dimensions of the matrix :param matrix: 2D list of integers representing the matrix to rotate :return: 2D list of integers representing the rotated matrix >>> rotate_matrix(4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix(1, [[42]]) [[42]] >>> rotate_matrix(2, [ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix(3, [ ... [1000, -1000, 0], ... [0, 500, 600], ... [700, 800, 900] ... ]) [[700, 0, 1000], [800, 500, -1000], [900, 600, 0]]","solution":"def rotate_matrix(n, matrix): Rotates a given n x n matrix 90 degrees clockwise. :param n: Integer representing the dimensions of the matrix :param matrix: 2D list of integers representing the matrix to rotate :return: 2D list of integers representing the rotated matrix rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def smallest_missing_positive_integer(n: int, integers: List[int]) -> int: Given a list of integers, find the smallest positive integer that is not present in the list. >>> smallest_missing_positive_integer(5, [3, 4, -1, 1, 2]) 5 >>> smallest_missing_positive_integer(3, [7, 8, 9]) 1 >>> smallest_missing_positive_integer(3, [1, 2, 3]) 4 >>> smallest_missing_positive_integer(1, [-1]) 1 >>> smallest_missing_positive_integer(1, [0]) 1 >>> smallest_missing_positive_integer(1, [1]) 2 >>> smallest_missing_positive_integer(2, [1, 100000]) 2 >>> smallest_missing_positive_integer(7, [3, 5, -10, -1, 1, 2, 0]) 4 >>> smallest_missing_positive_integer(6, [6, 2, 3, 4, 5, 7]) 1 >>> smallest_missing_positive_integer(4, [6, 2, 3, 4]) 1 >>> smallest_missing_positive_integer(6, [-1, -2, -3, 0, 1, 2]) 3 >>> smallest_missing_positive_integer(5, [1, 2, 2, 1, 3]) 4 >>> smallest_missing_positive_integer(5, [5, 5, 5, 5, 5]) 1 >>> smallest_missing_positive_integer(4, [3, 3, 2, 2]) 1 >>> smallest_missing_positive_integer(1000, list(range(-500, 500))) 500","solution":"def smallest_missing_positive_integer(n, integers): Given a list of integers, find the smallest positive integer that is not present in the list. Parameters: n (int): Number of integers in the list. integers (list of int): The list of integers. Returns: int: The smallest positive integer that is not present in the list. integers = set(integers) # Convert list to set for O(1) average time complexity checks smallest_missing = 1 while smallest_missing in integers: smallest_missing += 1 return smallest_missing"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Determines if the linked list has a cycle in it. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise Example: >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = head # create a cycle >>> hasCycle(head) True import pytest from solution import hasCycle, ListNode def test_no_cycle_single_node(): head = ListNode(1) assert hasCycle(head) == False def test_no_cycle_multiple_nodes(): head = ListNode(1) second = ListNode(2) third = ListNode(3) head.next = second second.next = third assert hasCycle(head) == False def test_with_cycle_simple(): head = ListNode(1) second = ListNode(2) head.next = second second.next = head assert hasCycle(head) == True def test_with_cycle_complex(): head = ListNode(3) second = ListNode(2) third = ListNode(0) fourth = ListNode(-4) head.next = second second.next = third third.next = fourth fourth.next = second # create a cycle here assert hasCycle(head) == True def test_cycle_at_beginning(): head = ListNode(1) second = ListNode(2) head.next = second second.next = head # cycle back to the first node assert hasCycle(head) == True if __name__ == '__main__': pytest.main()","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Determines if the linked list has a cycle in it. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"from typing import List, Tuple def max_path_sum(n: int, weights: List[int], edges: List[Tuple[int, int]]) -> int: Find a path in the tree such that the sum of the weights of the nodes in the path is maximized. Parameters: n (int): The number of nodes in the tree. weights (List[int]): The weights of the nodes. edges (List[Tuple[int, int]]): The edges connecting the nodes. Returns: int: The maximum possible sum of the weights of the nodes in any path in the tree. >>> max_path_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 11 >>> max_path_sum(3, [2, 1, 5], [(1, 2), (2, 3)]) 8","solution":"import sys from collections import defaultdict, deque sys.setrecursionlimit(2000000) def max_path_sum(n, weights, edges): def dfs(node, parent): max1 = 0 # Maximum path sum starting from this node going down max2 = 0 # Second maximum path sum for comparison for neighbor in graph[node]: if neighbor == parent: continue subtree_weight = dfs(neighbor, node) if subtree_weight > max1: max1, max2 = subtree_weight, max1 elif subtree_weight > max2: max2 = subtree_weight # Update global max path sum nonlocal max_sum max_sum = max(max_sum, weights[node - 1] + max1 + max2) return weights[node - 1] + max1 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_sum = 0 dfs(1, -1) return max_sum # Example usage: n = 5 weights = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] print(max_path_sum(n, weights, edges)) # Output: 11"},{"question":"from typing import List, Tuple def max_devices_receive_alert(T: int, cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of devices that can receive an alert message if sent from any single device. >>> max_devices_receive_alert(2, [(4, 2, [(1, 2), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [2, 5] >>> max_devices_receive_alert(1, [(3, 0, [])]) == [1] >>> max_devices_receive_alert(1, [(1, 0, [])]) == [1] >>> max_devices_receive_alert(1, [(4, 3, [(1, 2), (2, 3), (3, 4)])]) == [4] ...","solution":"from collections import defaultdict, deque def find_largest_connected_component(n, edges): def bfs(start, visited): queue = deque([start]) visited[start] = True count = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) count += 1 return count graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) max_devices = 0 for i in range(1, n + 1): if not visited[i]: component_size = bfs(i, visited) max_devices = max(max_devices, component_size) return max_devices def max_devices_receive_alert(T, cases): results = [] for case in cases: n, m, edges = case results.append(find_largest_connected_component(n, edges)) return results"},{"question":"def balanced_binary_strings(n: int) -> int: Calculate the number of balanced binary strings of length 2n mod 10^9 + 7. >>> balanced_binary_strings(1) 1 >>> balanced_binary_strings(2) 2 >>> balanced_binary_strings(3) 5 def test_balanced_binary_strings(): assert balanced_binary_strings(1) == 1 assert balanced_binary_strings(2) == 2 assert balanced_binary_strings(3) == 5 assert balanced_binary_strings(4) == 14 assert balanced_binary_strings(5) == 42 def test_balanced_binary_strings_large(): assert balanced_binary_strings(10) == 16796 assert balanced_binary_strings(20) == 6564120420 % (10**9 + 7)","solution":"MOD = 10**9 + 7 def mod_inv(a, m): return pow(a, m-2, m) def catalan_number(n, mod): if n == 0: return 1 fact = [1] * (2 * n + 1) for i in range(2, 2 * n + 1): fact[i] = fact[i - 1] * i % mod return (fact[2 * n] * mod_inv(fact[n + 1], mod) % mod * mod_inv(fact[n], mod) % mod) % mod def balanced_binary_strings(n): return catalan_number(n, MOD)"},{"question":"def min_difficulty_sum(n: int, k: int, difficulties: List[int]) -> int: Returns the minimum possible sum of the difficulty factors for any contiguous subsequence of length k. Args: n : int : The number of segments. k : int : The number of consecutive segments to be selected. difficulties : List[int] : The difficulty factors of the segments. Returns: int : The minimum possible sum of the difficulty factors for any contiguous subsequence of length k. Example: >>> min_difficulty_sum(6, 3, [5, 3, 2, 6, 8, 4]) 10 >>> min_difficulty_sum(5, 2, [1, 2, 3, 4, 5]) 3 pass from solution import min_difficulty_sum def test_min_difficulty_sum_case1(): assert min_difficulty_sum(6, 3, [5, 3, 2, 6, 8, 4]) == 10 def test_min_difficulty_sum_case2(): assert min_difficulty_sum(5, 2, [1, 2, 3, 4, 5]) == 3 def test_min_difficulty_sum_edge_case(): assert min_difficulty_sum(1, 1, [100]) == 100 def test_min_difficulty_sum_large_case(): assert min_difficulty_sum(10, 4, [5, 1, 2, 3, 4, 8, 7, 6, 5, 4]) == 10 def test_min_difficulty_sum_another_case(): assert min_difficulty_sum(7, 3, [10, 20, 30, 40, 50, 60, 70]) == 60","solution":"def min_difficulty_sum(n, k, difficulties): Returns the minimum possible sum of the difficulty factors for any contiguous subsequence of length k. # Calculate the sum of first 'k' elements current_sum = sum(difficulties[:k]) min_sum = current_sum # Use sliding window to find the minimum sum of subsequence length k for i in range(k, n): current_sum += difficulties[i] - difficulties[i - k] if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"def trap_water(heights: List[int]) -> int: Calculate the total amount of trapped water between buildings represented by a list of heights. >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([1, 0, 2, 0, 1]) 2","solution":"def trap_water(heights): if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"def multiplyListElements(lst: List[int], factor: int) -> List[int]: Multiplies each element of the list by the given factor. Parameters: lst (list of int): List of non-negative integers. factor (int): Non-negative integer factor. Returns: list of int: New list with each element multiplied by the factor. Examples: >>> multiplyListElements([1, 2, 3, 4, 5], 3) [3, 6, 9, 12, 15] >>> multiplyListElements([0, 1, 2, 3], 5) [0, 5, 10, 15]","solution":"def multiplyListElements(lst, factor): Multiplies each element of the list by the given factor. Parameters: lst (list of int): List of non-negative integers. factor (int): Non-negative integer factor. Returns: list of int: New list with each element multiplied by the factor. return [element * factor for element in lst]"},{"question":"def isPalindrome(s: str) -> bool: Determines if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> isPalindrome(\\"A man, a plan, a canal: Panama\\") True >>> isPalindrome(\\"race a car\\") False","solution":"def isPalindrome(s: str) -> bool: Determines if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = ''.join(c.lower() for c in s if c.isalnum()) # Compare the string with its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def book_recommendations(book_data, queries): Finds the count of books that match the specified genre and meet or exceed the specified minimum rating. :param book_data: List of tuples, each containing a genre and a rating. :param queries: List of tuples, each containing a genre and a minimum rating. :return: List of integers, each representing the count of matching books for the corresponding query. pass def to_data_and_queries(input_str): Converts the input string into usable formats for book data and queries. :param input_str: Input string containing book data and queries. :return: Tuple of (book_data, queries) pass # Unit Tests def test_book_recommendations_sample_input(): input_str = \\"5nfiction 4nnonfiction 3nfiction 5nmystery 5nnonfiction 2n3nfiction 4nnonfiction 3nmystery 5\\" book_data, queries = to_data_and_queries(input_str) expected_output = [2, 1, 1] assert book_recommendations(book_data, queries) == expected_output def test_book_recommendations_no_match(): input_str = \\"3nromance 1nhorror 2ncomedy 3n2nfiction 5nnonfiction 4\\" book_data, queries = to_data_and_queries(input_str) expected_output = [0, 0] assert book_recommendations(book_data, queries) == expected_output def test_book_recommendations_all_match(): input_str = \\"4nfantasy 5nfantasy 5nfantasy 5nfantasy 5n1nfantasy 1\\" book_data, queries = to_data_and_queries(input_str) expected_output = [4] assert book_recommendations(book_data, queries) == expected_output def test_book_recommendations_partial_match(): input_str = \\"6nadventure 1nadventure 2nadventure 3nadventure 4nadventure 5nthriller 5n2nadventure 4nthriller 5\\" book_data, queries = to_data_and_queries(input_str) expected_output = [2, 1] assert book_recommendations(book_data, queries) == expected_output def test_book_recommendations_mixed_genres(): input_str = \\"8nscifi 3nscifi 4nscifi 2nscifi 1nhistory 5nhistory 3ncomedy 1ncomedy 2n3nscifi 3nhistory 4ncomedy 1\\" book_data, queries = to_data_and_queries(input_str) expected_output = [2, 1, 2] assert book_recommendations(book_data, queries) == expected_output","solution":"def book_recommendations(book_data, queries): Finds the count of books that match the specified genre and meet or exceed the specified minimum rating. :param book_data: List of tuples, each containing a genre and a rating. :param queries: List of tuples, each containing a genre and a minimum rating. :return: List of integers, each representing the count of matching books for the corresponding query. from collections import defaultdict # Creating a dictionary to store books as lists based on their genre genre_dict = defaultdict(list) for genre, rating in book_data: genre_dict[genre].append(rating) # Sorting the ratings for each genre for genre in genre_dict: genre_dict[genre].sort() result = [] for query_genre, min_rating in queries: if query_genre not in genre_dict: result.append(0) else: ratings = genre_dict[query_genre] # Binary search to find the first rating >= min_rating left, right = 0, len(ratings) while left < right: mid = (left + right) // 2 if ratings[mid] >= min_rating: right = mid else: left = mid + 1 result.append(len(ratings) - left) return result # Helper function to convert input into usable formats def to_data_and_queries(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) book_data = [tuple(line.split()) for line in input_lines[1:n+1]] book_data = [(genre, int(rating)) for genre, rating in book_data] q = int(input_lines[n+1]) queries = [tuple(line.split()) for line in input_lines[n+2:n+2+q]] queries = [(genre, int(min_rating)) for genre, min_rating in queries] return book_data, queries"},{"question":"def can_avoid_same_reboot_time(n: int) -> str: Determines if there exists a time t (1  t  1000) such that every server will not reboot at the same hour t. Parameters: n (int): The number of servers. Returns: str: \\"YES\\" if there exists such a time t, \\"NO\\" otherwise. >>> can_avoid_same_reboot_time(1) \\"YES\\" >>> can_avoid_same_reboot_time(2) \\"YES\\" >>> can_avoid_same_reboot_time(3) \\"NO\\" >>> can_avoid_same_reboot_time(1000) \\"NO\\" >>> can_avoid_same_reboot_time(999) \\"NO\\"","solution":"def can_avoid_same_reboot_time(n): Determines if there exists a time t (1  t  1000) such that every server will not reboot at the same hour t. Parameters: n (int): The number of servers. Returns: str: \\"YES\\" if there exists such a time t, \\"NO\\" otherwise. if n == 1: return \\"YES\\" elif n == 2: return \\"YES\\" elif n >= 3: return \\"NO\\" else: return \\"NO\\""},{"question":"from typing import List def max_total_magical_power(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum total magical power you can collect by picking one fruit from each tree without picking two fruits with the same magical power index. >>> max_total_magical_power(3, 3, [[2, 1, 7], [3, 5, 4], [6, 10, 1]]) 22 >>> max_total_magical_power(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> max_total_magical_power(3, 3, [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) 18 >>> max_total_magical_power(2, 2, [[100000, 99999], [99998, 100000]]) 200000 >>> max_total_magical_power(2, 2, [[1, 1], [1, 1]]) 2 ...","solution":"from heapq import nlargest def max_total_magical_power(n, m, grid): if not grid or not grid[0]: return 0 max_powers = [] for row in grid: max_powers.append(max(row)) sorted_max_powers = nlargest(n, max_powers) return sum(sorted_max_powers)"},{"question":"def most_frequent_value(test_cases): For each test case, determine the most frequently occurring value and its frequency. If multiple values have the same frequency, the smallest value is chosen. Args: test_cases: A list of tuples, where each tuple contains an integer N followed by N space-separated integers. Returns: A list of tuples where each tuple contains the most frequently occurring value and its frequency. >>> most_frequent_value([(5, 1, 2, 2, 3, 1), (6, 3, 3, 4, 4, 2, 2)]) [(1, 2), (2, 2)] # Example test cases def test_most_frequent_value(): test_cases = [ (5, 1, 2, 2, 3, 1), (6, 3, 3, 4, 4, 2, 2) ] expected_results = [(1, 2), (2, 2)] assert most_frequent_value(test_cases) == expected_results def test_single_value(): test_cases = [ (1, 1), (1, -1000000) ] expected_results = [(1, 1), (-1000000, 1)] assert most_frequent_value(test_cases) == expected_results def test_all_identical(): test_cases = [ (5, 3, 3, 3, 3, 3) ] expected_results = [(3, 5)] assert most_frequent_value(test_cases) == expected_results def test_different_frequencies(): test_cases = [ (7, 1, 1, 1, 2, 2, 3, 3) ] expected_results = [(1, 3)] assert most_frequent_value(test_cases) == expected_results def test_large_range(): test_cases = [ (5, 1000000, -1000000, -1000000, 500000, 500000) ] expected_results = [(-1000000, 2)] assert most_frequent_value(test_cases) == expected_results","solution":"def most_frequent_value(test_cases): For each test case, determine the most frequently occurring value and its frequency. If multiple values have the same frequency, the smallest value is chosen. results = [] for values in test_cases: N, *report_values = values frequency_map = {} for value in report_values: if value in frequency_map: frequency_map[value] += 1 else: frequency_map[value] = 1 max_frequency = max(frequency_map.values()) most_frequent_values = [val for val, freq in frequency_map.items() if freq == max_frequency] smallest_most_frequent_value = min(most_frequent_values) results.append((smallest_most_frequent_value, max_frequency)) return results"},{"question":"def num_distinct_islands(grid): Counts the number of distinct islands in the given grid. Parameters: grid: List of List of str : The grid representing '0' as empty cell and '1' as obstacle. Returns: int : The number of distinct islands. pass # Unit tests def test_case_1(): grid = [ \\"11000\\", \\"11010\\", \\"00000\\", \\"01110\\" ] assert num_distinct_islands([list(row) for row in grid]) == 3 def test_case_2(): grid = [ \\"111\\", \\"010\\", \\"111\\" ] assert num_distinct_islands([list(row) for row in grid]) == 1 def test_case_3(): grid = [ \\"000\\", \\"000\\", \\"000\\" ] assert num_distinct_islands([list(row) for row in grid]) == 0 def test_case_4(): grid = [ \\"100\\", \\"010\\", \\"001\\" ] assert num_distinct_islands([list(row) for row in grid]) == 3 def test_case_5(): grid = [ \\"0100\\", \\"1110\\", \\"0111\\" ] assert num_distinct_islands([list(row) for row in grid]) == 1","solution":"def num_distinct_islands(grid): Counts the number of distinct islands in the given grid. Parameters: grid: List of List of str : The grid representing '0' as empty cell and '1' as obstacle. Returns: int : The number of distinct islands. def dfs(grid, x, y, visited): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] stack = [(x, y)] visited.add((x, y)) while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] == '1': visited.add((nx, ny)) stack.append((nx, ny)) if not grid or not grid[0]: return 0 N, M = len(grid), len(grid[0]) visited = set() count = 0 for i in range(N): for j in range(M): if grid[i][j] == '1' and (i, j) not in visited: # Perform DFS to mark all cells in this island as visited dfs(grid, i, j, visited) count += 1 return count"},{"question":"def reverse_digits(n: int) -> int: Takes an integer n as input and returns the reverse of its digits. >>> reverse_digits(12345) 54321 >>> reverse_digits(0) 0 >>> reverse_digits(100) 1 >>> reverse_digits(987654321) 123456789 >>> reverse_digits(1) 1","solution":"def reverse_digits(n): Takes an integer n as input and returns the reverse of its digits. return int(str(n)[::-1])"},{"question":"def calculate_treasure(n, m, treasures, segments): Calculate the total amount of treasure each knight can protect. Args: n (int): Number of castles m (int): Number of knights treasures (list): List of treasure amounts in each castle segments (list): List of segments each knight can protect, given as tuples (l, r) Returns: list: List of total treasures each knight can protect >>> calculate_treasure(5, 3, [1, 3, 2, 5, 4], [(1, 3), (2, 4), (1, 5)]) [6, 10, 15] >>> calculate_treasure(1, 1, [5], [(1, 1)]) [5] >>> calculate_treasure(5, 2, [1, 2, 3, 4, 5], [(2, 2), (4, 4)]) [2, 4] >>> calculate_treasure(4, 2, [10, 20, 30, 40], [(1, 3), (2, 4)]) [60, 90] >>> calculate_treasure(4, 3, [1, 2, 3, 4], [(1, 4), (1, 4), (1, 4)]) [10, 10, 10] >>> calculate_treasure(6, 1, [5, 6, 7, 8, 9, 10], [(1, 6)]) [45]","solution":"def calculate_treasure(n, m, treasures, segments): Calculate the total amount of treasure each knight can protect. Args: n (int): Number of castles m (int): Number of knights treasures (list): List of treasure amounts in each castle segments (list): List of segments each knight can protect, given as tuples (l, r) Returns: list: List of total treasures each knight can protect result = [] for l, r in segments: result.append(sum(treasures[l-1:r])) return result"},{"question":"def can_place_art_pieces(n: int, m: int, art_pieces: List[Tuple[int, int]]) -> str: Determine if all art pieces can be placed on the canvas without overlapping and within the canvas boundaries. Parameters: n (int): The height of the canvas. m (int): The width of the canvas. art_pieces (List[Tuple[int, int]]): A list of tuples representing the dimensions (width, height) of the art pieces. Returns: str: \\"YES\\" if all pieces can be placed without overlapping and within boundaries, otherwise \\"NO\\". Examples: >>> can_place_art_pieces(5, 5, [(4, 2), (2, 3)]) 'YES' >>> can_place_art_pieces(4, 6, [(2, 2), (4, 3), (3, 2)]) 'NO' from typing import List, Tuple def test_can_place_art_pieces_example1(): assert can_place_art_pieces(5, 5, [(4, 2), (2, 3)]) == \\"YES\\" def test_can_place_art_pieces_example2(): assert can_place_art_pieces(4, 6, [(2, 2), (4, 3), (3, 2)]) == \\"NO\\" def test_can_place_art_pieces_single_piece_fit(): assert can_place_art_pieces(5, 5, [(2, 2)]) == \\"YES\\" def test_can_place_art_pieces_single_piece_does_not_fit(): assert can_place_art_pieces(2, 2, [(3, 3)]) == \\"NO\\" def test_can_place_art_pieces_multiple_identical_pieces_fit(): # Fit three 1x1 pieces in a 3x1 canvas assert can_place_art_pieces(3, 1, [(1, 1), (1, 1), (1, 1)]) == \\"YES\\" def test_can_place_art_pieces_multiple_identical_pieces_does_not_fit(): # Fit three 1x1 pieces in a 2x1 canvas assert can_place_art_pieces(2, 1, [(1, 1), (1, 1), (1, 1)]) == \\"NO\\" def test_can_place_art_pieces_exact_fit(): # Exact fit scenario assert can_place_art_pieces(6, 4, [(2, 4), (3, 4), (1, 4)]) == \\"YES\\" def test_can_place_art_pieces_complex_fit(): # Complex fit scenario assert can_place_art_pieces(10, 10, [(5, 5), (5, 2), (2, 3), (3, 1)]) == \\"YES\\"","solution":"def can_place_art_pieces(n, m, art_pieces): from itertools import permutations # Trying to fit pieces one after the other on the canvas def can_fit(pieces, canvas_width, canvas_height): used_width, used_height = 0, 0 max_height_in_row = 0 for w, h in pieces: if used_width + w <= canvas_width: used_width += w max_height_in_row = max(max_height_in_row, h) elif used_height + h <= canvas_height: used_height += max_height_in_row max_height_in_row = h if used_height + h > canvas_height: return False used_width = w else: return False return used_height + max_height_in_row <= canvas_height for perm in permutations(art_pieces): if can_fit(perm, n, m) or can_fit(perm, m, n): return \\"YES\\" return \\"NO\\" # Example usage: n, m = 5, 5 k = 2 art_pieces = [(4, 2), (2, 3)] print(can_place_art_pieces(n, m, art_pieces)) # Output should be: YES"},{"question":"def manage_reservations(tables_info, reservation_attempts): This function checks if a list of new table reservations can be accommodated. Each table has a unique ID, a capacity, and a list of existing reservations. Each reservation specifies the number of people and a time slot. Given the information about the tables and a list of new reservations, this function determines whether each new reservation can be accepted or not. :param tables_info: List of tuples containing table information and their reservations. Each tuple is (table_id, capacity, reservations) where reservations is a list of tuples (time_slot, num_guests). :param reservation_attempts: List of tuples containing reservation attempts. Each tuple is (table_id, time_slot, num_guests). :return: List of strings \\"Accepted\\" or \\"Rejected\\" for each reservation attempt. >>> tables_info = [(\\"Table1\\", 4, [(1200, 4), (1930, 2)]), (\\"Table2\\", 2, [(1800, 2)])] >>> reservation_attempts = [(\\"Table1\\", 1200, 2), (\\"Table2\\", 1700, 2), (\\"Table2\\", 1800, 1)] >>> manage_reservations(tables_info, reservation_attempts) ['Rejected', 'Accepted', 'Rejected'] >>> tables_info = [(\\"Table1\\", 4, []), (\\"Table2\\", 2, [])] >>> reservation_attempts = [(\\"Table1\\", 1200, 2), (\\"Table2\\", 1700, 1)] >>> manage_reservations(tables_info, reservation_attempts) ['Accepted', 'Accepted'] >>> tables_info = [(\\"Table1\\", 4, [(1200, 4), (1300, 4)]), (\\"Table2\\", 2, [(1400, 2)])] >>> reservation_attempts = [(\\"Table1\\", 1200, 1), (\\"Table1\\", 1300, 4), (\\"Table2\\", 1400, 1)] >>> manage_reservations(tables_info, reservation_attempts) ['Rejected', 'Rejected', 'Rejected'] >>> tables_info = [(\\"Table1\\", 4, [(1200, 2)])] >>> reservation_attempts = [(\\"Table1\\", 1200, 2)] >>> manage_reservations(tables_info, reservation_attempts) ['Accepted'] >>> tables_info = [(\\"Table1\\", 4, [(1200, 2)])] >>> reservation_attempts = [(\\"Table3\\", 1200, 2)] >>> manage_reservations(tables_info, reservation_attempts) ['Rejected']","solution":"def manage_reservations(tables_info, reservation_attempts): This function checks if a list of new table reservations can be accommodated. :param tables_info: List of tuples containing table information and their reservations. Each tuple is (table_id, capacity, reservations) where reservations is a list of tuples (time_slot, num_guests). :param reservation_attempts: List of tuples containing reservation attempts. Each tuple is (table_id, time_slot, num_guests). :return: List of strings \\"Accepted\\" or \\"Rejected\\" for each reservation attempt. # Convert tables_info to a dictionary for easy access tables = {} for table_id, capacity, reservations in tables_info: tables[table_id] = { \\"capacity\\": capacity, \\"reservations\\": {time_slot: num_guests for time_slot, num_guests in reservations} } # Process each reservation attempt results = [] for table_id, time_slot, num_guests in reservation_attempts: if table_id in tables: table = tables[table_id] if time_slot in table['reservations']: if table['reservations'][time_slot] + num_guests <= table['capacity']: results.append(\\"Accepted\\") else: results.append(\\"Rejected\\") else: if num_guests <= table['capacity']: results.append(\\"Accepted\\") else: results.append(\\"Rejected\\") else: results.append(\\"Rejected\\") return results # Sample usage with the provided example: tables_info = [ (\\"Table1\\", 4, [(1200, 4), (1930, 2)]), (\\"Table2\\", 2, [(1800, 2)]), ] reservation_attempts = [ (\\"Table1\\", 1200, 2), (\\"Table2\\", 1700, 2), (\\"Table2\\", 1800, 1), ] output = manage_reservations(tables_info, reservation_attempts) print(output) # Should print [\\"Rejected\\", \\"Accepted\\", \\"Rejected\\"]"},{"question":"def analyze_access_log(access_log: str) -> List[int]: Analyzes the access log to find the number of consecutive granted access attempts preceding each denied access attempt. >>> analyze_access_log(\\"GGDGGGDGGD\\") [2, 3, 2] >>> analyze_access_log(\\"DGGDG\\") [0, 2] >>> analyze_access_log(\\"GGGG\\") [] pass","solution":"def analyze_access_log(access_log): Analyzes the access log to find the number of consecutive granted access attempts preceding each denied access attempt. Parameters: access_log (str): A string with characters 'G' and 'D' representing granted and denied access attempts. Returns: list: A list of integers representing the count of consecutive 'G' preceding each 'D'. results = [] count = 0 for char in access_log: if char == 'G': count += 1 elif char == 'D': results.append(count) count = 0 return results"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an array of integers, find the first missing positive integer. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 from typing import List def test_example_1(): assert first_missing_positive([1, 2, 0]) == 3 def test_example_2(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_example_3(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_small_single_element(): assert first_missing_positive([1]) == 2 assert first_missing_positive([2]) == 1 def test_empty_array(): assert first_missing_positive([]) == 1 def test_larger_range_with_duplicates(): assert first_missing_positive([1, 1, 2, 2]) == 3 def test_all_positive_without_missing(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6","solution":"def first_missing_positive(nums): Finds the first missing positive integer in an array of integers. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with the number at its correct position nums[nums[i] - 1] nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def store_plates(n: int, plate_dimensions: List[Tuple[int, int]]) -> Tuple[int, int]: Compute the minimal maximum x-coordinate and the minimal maximum y-coordinate needed to store the plates. >>> store_plates(3, [(2, 3), (3, 2), (1, 4)]) (4, 2) >>> store_plates(2, [(5, 7), (3, 10)]) (10, 5) >>> store_plates(1, [(3, 5)]) (5, 3) >>> store_plates(3, [(5, 5), (5, 5), (5, 5)]) (5, 5) >>> store_plates(5, [(3, 4), (5, 2), (6, 1), (3, 7), (4, 6)]) (7, 4) >>> store_plates(100, [(1000, 1000) for _ in range(100)]) (1000, 1000)","solution":"def minimal_max_coordinates(n, plates): max_width = 0 max_height = 0 for height, width in plates: max_width = max(max_width, max(width, height)) max_height = max(max_height, min(width, height)) return max_width, max_height def store_plates(n, plate_dimensions): max_w = 0 max_h = 0 for h, w in plate_dimensions: if h > w: h, w = w, h max_w = max(max_w, w) max_h = max(max_h, h) return max_w, max_h"},{"question":"def max_non_consecutive_score(n: int, scores: List[int]) -> int: Determine the maximum possible score a participant can achieve without selecting any two consecutive games. >>> max_non_consecutive_score(5, [3, 2, 7, 10, 12]) 22 >>> max_non_consecutive_score(4, [5, 5, 10, 100]) 105 >>> max_non_consecutive_score(1, [10]) 10 >>> max_non_consecutive_score(0, []) 0 >>> max_non_consecutive_score(6, [3, 2, 5, 10, 7, 20]) 33","solution":"def max_non_consecutive_score(n, scores): if n == 0: return 0 if n == 1: return scores[0] dp = [0] * n dp[0] = scores[0] dp[1] = max(scores[0], scores[1]) for i in range(2, n): dp[i] = max(dp[i-1], scores[i] + dp[i-2]) return dp[-1]"},{"question":"def maxProfit(nums: List[int]) -> int: Determines the maximum profit you can achieve by buying one item and selling another item afterwards, given a list of prices. Parameters: nums (List[int]): A list of integers representing prices. Returns: int: Maximum profit achievable, 0 if no profit is possible. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>>","solution":"def maxProfit(nums): This function takes a list of prices and returns the maximum profit that can be achieved by buying one item and selling another item afterwards. if not nums or len(nums) < 2: return 0 min_price = nums[0] max_profit = 0 for price in nums[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def process_list_operations(n: int, operations: List[str]) -> Union[List[int], str]: Process a sequence of operations on a list according to given instructions. Args: n (int): The number of operations. operations (List[str]): The list of instructions. Returns: Union[List[int], str]: The final state of the list as a list of integers or \\"Empty\\" if the list is empty. Example: >>> process_list_operations(6, [\\"append 3\\", \\"append 4\\", \\"insert 1 5\\", \\"remove 3\\", \\"reverse\\", \\"extend [6, 7]\\"]) [7, 6, 4, 5] >>> process_list_operations(4, [\\"append 2\\", \\"append 3\\", \\"pop\\", \\"remove 2\\"]) 'Empty' from typing import List, Union # Add your implementation here","solution":"def process_list_operations(n, operations): lst = [] for operation in operations: if operation.startswith('append'): _, x = operation.split() lst.append(int(x)) elif operation.startswith('insert'): _, i, x = operation.split() lst.insert(int(i), int(x)) elif operation.startswith('remove'): _, x = operation.split() lst.remove(int(x)) elif operation == 'pop': if lst: lst.pop() elif operation == 'reverse': lst.reverse() elif operation.startswith('extend'): _, elems = operation.split(' ', 1) elems = eval(elems) lst.extend(elems) return lst if lst else 'Empty'"},{"question":"def can_form_team(N: int, K: int, preferences: List[List[int]]) -> str: Determine if it's possible to form exactly one team of exactly K students where each student in the team prefers all other members. >>> can_form_team(4, 3, [[1, 2], [0, 2], [0, 1], [0, 1]]) \\"YES\\" >>> can_form_team(4, 3, [[1, 2], [0, 2], [0, 3], [0, 1, 2]]) \\"NO\\"","solution":"def can_form_team(N, K, preferences): from itertools import combinations def is_valid_team(team, preferences): for member in team: for other_member in team: if member != other_member and other_member + 1 not in preferences[member]: return False return True if K > N: return \\"NO\\" for team in combinations(range(N), K): if is_valid_team(team, preferences): return \\"YES\\" return \\"NO\\" # Input reading function def main(): import sys input = sys.stdin.read data = input().strip().split('n') N, K = map(int, data[0].split()) preferences = [list(map(lambda x: int(x) - 1, line.split())) for line in data[1:]] result = can_form_team(N, K, preferences) print(result)"},{"question":"def compressString(s: str) -> str: Compresses the input string using a simple run-length encoding algorithm. - If a character appears consecutively more than once, replace the consecutive characters with the character followed by the count of the repetitions. - If a character appears only once, it remains unchanged in the compressed string. The goal is to minimize the length of the resultant string. If the compressed string is not shorter than the original string, the function should return the original string. >>> compressString(\\"aaabbccccc\\") \\"a3b2c5\\" >>> compressString(\\"abcd\\") \\"abcd\\" >>> compressString(\\"aabbcc\\") \\"aabbcc\\" >>> compressString(\\"aaaabbbbccccdddd\\") \\"a4b4c4d4\\"","solution":"def compressString(s): Compresses the input string using a simple run-length encoding algorithm. if not s: # If the string is empty, return it as is. return s compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(current_char) if count > 1: compressed.append(str(count)) current_char = char count = 1 compressed.append(current_char) if count > 1: compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_nodes(nodes, edges): if not nodes: return None node_dict = {val: TreeNode(val) for val in nodes} for parent_val, child_val in edges: parent = node_dict[parent_val] child = node_dict[child_val] if not parent.left: parent.left = child else: parent.right = child return node_dict[nodes[0]] def is_balanced(root): def check_height(node): if node is None: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1 def is_tree_balanced(n, node_values, edges): if n == 0: return \\"YES\\" root = insert_nodes(node_values, edges) return \\"YES\\" if is_balanced(root) else \\"NO\\" Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a tree in which the depth of the two subtrees of every node never differs by more than 1. >>> is_tree_balanced(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == \\"YES\\" >>> is_tree_balanced(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (4, 5)]) == \\"NO\\" from solution import is_tree_balanced def test_example_0(): assert is_tree_balanced(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == \\"YES\\" def test_example_1(): assert is_tree_balanced(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (4, 5)]) == \\"NO\\" def test_empty_tree(): assert is_tree_balanced(0, [], []) == \\"YES\\" def test_single_node_tree(): assert is_tree_balanced(1, [1], []) == \\"YES\\" def test_unbalanced_tree_left_heavy(): assert is_tree_balanced(3, [1, 2, 3], [(1, 2), (2, 3)]) == \\"NO\\" def test_unbalanced_tree_right_heavy(): assert is_tree_balanced(3, [1, 2, 3], [(1, 2), (1, 3)]) == \\"YES\\"","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_nodes(nodes, edges): if not nodes: return None node_dict = {val: TreeNode(val) for val in nodes} for parent_val, child_val in edges: parent = node_dict[parent_val] child = node_dict[child_val] if not parent.left: parent.left = child else: parent.right = child return node_dict[nodes[0]] def is_balanced(root): def check_height(node): if node is None: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1 def is_tree_balanced(n, node_values, edges): if n == 0: return \\"YES\\" root = insert_nodes(node_values, edges) return \\"YES\\" if is_balanced(root) else \\"NO\\""},{"question":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be scheduled. Parameters: events (list of tuples): A list of events, each defined by a tuple (start, end). Returns: int: Maximum number of non-overlapping events that can be scheduled. >>> max_non_overlapping_events([(0, 3), (1, 2), (3, 5), (4, 6), (5, 8)]) 3 >>> max_non_overlapping_events([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_events([(1, 2), (3, 4), (5, 6)]) 3 from solution import max_non_overlapping_events def test_sample_case(): events = [(0, 3), (1, 2), (3, 5), (4, 6), (5, 8)] assert max_non_overlapping_events(events) == 3 def test_no_events(): events = [] assert max_non_overlapping_events(events) == 0 def test_all_overlapping_events(): events = [(1, 4), (2, 5), (3, 6)] assert max_non_overlapping_events(events) == 1 def test_non_overlapping_events(): events = [(1, 2), (3, 4), (5, 6)] assert max_non_overlapping_events(events) == 3 def test_mixed_case(): events = [(1, 3), (2, 4), (3, 5), (0, 2)] assert max_non_overlapping_events(events) == 2 def test_single_event(): events = [(0, 1)] assert max_non_overlapping_events(events) == 1 def test_events_same_end_time(): events = [(1, 4), (2, 4), (3, 4)] assert max_non_overlapping_events(events) == 1 def test_events_ending_before_others_starting(): events = [(1, 2), (2, 3), (3, 4), (4, 5)] assert max_non_overlapping_events(events) == 4 def test_events_with_large_range(): events = [(0, 1000000), (1, 999999)] assert max_non_overlapping_events(events) == 1","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be scheduled. Parameters: events (list of tuples): A list of events, each defined by a tuple (start, end). Returns: int: Maximum number of non-overlapping events that can be scheduled. if not events: return 0 # Sort events based on their end times events.sort(key=lambda x: x[1]) count = 1 last_end_time = events[0][1] for start, end in events[1:]: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def max_candies(n: int, x: int, y: int) -> int: Returns the maximum total number of candies Polycarp can distribute in n bags with each bag containing a unique number of candies between x and y. >>> max_candies(3, 1, 5) == 12 >>> max_candies(4, 2, 8) == 26","solution":"def max_candies(n, x, y): Returns the maximum total number of candies Polycarp can distribute in n bags with each bag containing a unique number of candies between x and y. # Start from the highest candy count and go down to maximize the sum if n > (y - x + 1): return -1 # This should not happen based on the constraints total_candies = 0 for i in range(n): total_candies += (y - i) return total_candies"},{"question":"from typing import List def can_form_shape(n: int, stick_lengths: List[int]) -> str: Check if it is possible to form a rectangle or a square with the given set of sticks. - A rectangle can be formed if you can find two pairs of sticks with the same length. - A square can be formed if you can find four sticks of the same length. Args: n: int : number of sticks stick_lengths: List[int] : lengths of the sticks Returns: str : \\"YES\\" if you can form a rectangle or a square, otherwise \\"NO\\" Examples: >>> can_form_shape(4, [1, 1, 2, 2]) 'YES' >>> can_form_shape(6, [1, 2, 3, 4, 5, 6]) 'NO' >>> can_form_shape(8, [3, 4, 2, 4, 3, 3, 2, 3]) 'YES' pass def test_single_rectangle(): assert can_form_shape(4, [1, 1, 2, 2]) == \\"YES\\" def test_mixed(): assert can_form_shape(8, [3, 4, 2, 4, 3, 3, 2, 3]) == \\"YES\\" def test_no_rectangle_or_square(): assert can_form_shape(6, [1, 2, 3, 4, 5, 6]) == \\"NO\\" def test_four_of_same_length(): assert can_form_shape(5, [5, 5, 5, 5, 1]) == \\"YES\\" def test_two_pairs_with_extra(): assert can_form_shape(6, [2, 2, 3, 3, 4, 4]) == \\"YES\\" def test_insufficient_sticks(): assert can_form_shape(7, [1, 2, 3, 4, 5, 6, 6]) == \\"NO\\"","solution":"from collections import Counter def can_form_shape(n, stick_lengths): # Count the frequency of each stick length stick_count = Counter(stick_lengths) pairs = 0 quads = False # Check for pairs and quads for count in stick_count.values(): pairs += count // 2 if count >= 4: quads = True # Rectangle require at least 2 pairs, and square require at least one quad if pairs >= 2 or quads: return \\"YES\\" else: return \\"NO\\" # Example usage n = 8 stick_lengths = [3, 4, 2, 4, 3, 3, 2, 3] assert can_form_shape(n, stick_lengths) == \\"YES\\""},{"question":"from typing import List, Tuple def length_of_LNDS(arr: List[int]) -> int: Returns the length of the longest non-decreasing subsequence in the given array. def solve_LNDS_problems(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of N integers in the test cases, find the length of the longest subsequence such that all elements of the subsequence are in non-decreasing order in O(N log N) time. >>> solve_LNDS_problems([(5, [10, 9, 2, 5, 3]), (6, [1, 3, 2, 3, 4, 5])]) [2, 5] Test case format: - First integer is the number of elements N in the array. - Following integers are the elements of the array. Output format: - For each test case, a single integer is output, the length of the longest non-decreasing subsequence. def test_solve_LNDS_problems(): test_cases = [ (5, [10, 9, 2, 5, 3]), (6, [1, 3, 2, 3, 4, 5]) ] expected = [2, 5] assert solve_LNDS_problems(test_cases) == expected def test_single_element(): test_cases = [ (1, [7]), (1, [10]) ] expected = [1, 1] assert solve_LNDS_problems(test_cases) == expected def test_all_increasing(): test_cases = [ (5, [1, 2, 3, 4, 5]), (3, [1, 2, 3]) ] expected = [5, 3] assert solve_LNDS_problems(test_cases) == expected def test_all_decreasing(): test_cases = [ (5, [5, 4, 3, 2, 1]), (3, [3, 2, 1]) ] expected = [1, 1] assert solve_LNDS_problems(test_cases) == expected def test_mixed(): test_cases = [ (7, [10, 22, 9, 33, 21, 50, 41]), (8, [10, 22, 33, 21, 50, 41, 60, 80]) ] expected = [4, 6] assert solve_LNDS_problems(test_cases) == expected","solution":"import bisect def length_of_LNDS(arr): Returns the length of the longest non-decreasing subsequence in the given array. if not arr: return 0 subsequence = [] for num in arr: pos = bisect.bisect_right(subsequence, num) if pos == len(subsequence): subsequence.append(num) else: subsequence[pos] = num return len(subsequence) def solve_LNDS_problems(test_cases): results = [] for n, arr in test_cases: results.append(length_of_LNDS(arr)) return results"},{"question":"def min_operations_to_alternating_sequence(N, S): Returns the minimum number of operations required to make the sequence an alternating sequence. >>> min_operations_to_alternating_sequence(5, \\"11100\\") 2 >>> min_operations_to_alternating_sequence(1, \\"0\\") 0 >>> min_operations_to_alternating_sequence(1, \\"1\\") 0 >>> min_operations_to_alternating_sequence(3, \\"010\\") 0 >>> min_operations_to_alternating_sequence(4, \\"1010\\") 0 >>> min_operations_to_alternating_sequence(4, \\"1111\\") 2 >>> min_operations_to_alternating_sequence(4, \\"0000\\") 2 >>> min_operations_to_alternating_sequence(6, \\"010101\\") 0 >>> min_operations_to_alternating_sequence(6, \\"101010\\") 0 >>> min_operations_to_alternating_sequence(10, \\"1111111111\\") 5 >>> min_operations_to_alternating_sequence(10, \\"0000000000\\") 5","solution":"def min_operations_to_alternating_sequence(N, S): Returns the minimum number of operations required to make the sequence an alternating sequence. pattern1 = '01' * (N // 2) + '0' * (N % 2) pattern2 = '10' * (N // 2) + '1' * (N % 2) operations1 = sum(S[i] != pattern1[i] for i in range(N)) operations2 = sum(S[i] != pattern2[i] for i in range(N)) return min(operations1, operations2) # Example usage N = 5 S = \\"11100\\" print(min_operations_to_alternating_sequence(N, S)) # Output: 2"},{"question":"from collections import defaultdict, deque def can_complete_all_projects(projects, dependencies): Determine if all projects can be completed given the list of dependencies. Args: projects (list): List of project identifiers. dependencies (list): List of dependencies where each dependency is a pair of projects [a, b] meaning project a needs to be completed before project b. Returns: bool: True if all projects can be completed, False otherwise. Examples: >>> can_complete_all_projects([\\"p1\\"], []) True >>> can_complete_all_projects([\\"p1\\", \\"p2\\"], [[\\"p1\\", \\"p2\\"], [\\"p2\\", \\"p1\\"]]) False >>> can_complete_all_projects([\\"p1\\", \\"p2\\", \\"p3\\", \\"p4\\"], [[\\"p1\\", \\"p2\\"], [\\"p4\\", \\"p3\\"], [\\"p2\\", \\"p4\\"]]) True","solution":"from collections import defaultdict, deque def can_complete_all_projects(projects, dependencies): Determines if all projects can be completed given the list of dependencies. Args: projects (list): List of project identifiers. dependencies (list): List of dependencies where each dependency is a pair of projects [a, b] meaning project a needs to be completed before project b. Returns: bool: True if all projects can be completed, False otherwise. # Create a graph and in-degree count graph = defaultdict(list) in_degree = {project: 0 for project in projects} # Build the graph and in-degree count for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Use a queue to perform topological sort (Kahn's algorithm) queue = deque([project for project in projects if in_degree[project] == 0]) count = 0 while queue: current = queue.popleft() count += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count matches the number of projects, all projects can be completed return count == len(projects)"},{"question":"def min_moves_to_sort(n, arr): Given an array of n integers, returns the minimum number of moves required to sort the array in non-decreasing order by reversing any continuous subarray. >>> min_moves_to_sort(3, [3, 2, 1]) 1 >>> min_moves_to_sort(5, [5, 1, 2, 3, 4]) 2 >>> min_moves_to_sort(4, [4, 3, 2, 1]) 2","solution":"def min_moves_to_sort(n, arr): Given an array of n integers, returns the minimum number of moves required to sort the array in non-decreasing order by reversing any continuous subarray. # Find the first position where the array is not ordered start = 0 while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 # If the array is already sorted if start == n - 1: return 0 # Find the first position from the end where the array is not ordered end = n - 1 while end > 0 and arr[end] >= arr[end - 1]: end -= 1 # If reversing the entire sequence from start to end does not sort the array if arr[:start] + list(reversed(arr[start:end+1])) + arr[end+1:] != sorted(arr): return 2 return 1"},{"question":"from typing import List def largest_concatenated_number(numbers: List[int]) -> str: Given a list of non-negative integers, returns the largest possible number that can be formed by concatenating the elements of the list. >>> largest_concatenated_number([50, 2, 1, 9]) '95021' >>> largest_concatenated_number([1]) '1' >>> largest_concatenated_number([0, 0, 0]) '0' >>> largest_concatenated_number([10, 2]) '210' >>> largest_concatenated_number([3, 30, 34, 5, 9]) '9534330' >>> largest_concatenated_number([121, 12]) '12121' >>> largest_concatenated_number([82, 828]) '82882' >>> largest_concatenated_number([824, 8247]) '8248247'","solution":"from functools import cmp_to_key def largest_concatenated_number(numbers): Given a list of non-negative integers, returns the largest possible number that can be formed by concatenating the elements of the list. # Convert all integers to strings numbers = list(map(str, numbers)) # Custom comparator to decide order based on concatenated result def compare(x, y): return (y + x > x + y) - (y + x < x + y) # Sort by custom comparator numbers.sort(key=cmp_to_key(compare)) # Join and return the result largest_number = ''.join(numbers) # Convert to int and back to str to remove any leading zeros (e.g. \\"00\\" -> \\"0\\") return str(int(largest_number))"},{"question":"def min_adjacent_swaps_to_sort(n: int, heights: List[int]) -> int: Returns the minimum number of adjacent swaps needed to sort the array of book heights. >>> min_adjacent_swaps_to_sort(3, [3, 1, 2]) 2 >>> min_adjacent_swaps_to_sort(4, [4, 3, 2, 1]) 6 >>> min_adjacent_swaps_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort(5, [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort(4, [3, 2, 1, 4]) 3 >>> min_adjacent_swaps_to_sort(1, [1]) 0 >>> min_adjacent_swaps_to_sort(6, [1, 2, 3, 4, 5, 6]) 0","solution":"def min_adjacent_swaps_to_sort(n, heights): Returns the minimum number of adjacent swaps needed to sort the array of book heights. swaps = 0 # Implementing bubble sort to count the number of swaps. heights = list(heights) # Make sure heights can be modified if it's a tuple for i in range(n): for j in range(n - i - 1): if heights[j] > heights[j + 1]: heights[j], heights[j + 1] = heights[j + 1], heights[j] swaps += 1 return swaps"},{"question":"def min_remove_students_to_sort(n: int, heights: List[int]) -> int: Given a list of positive integers representing the heights of various students standing in a row, find the minimum number of students who need to be removed such that the remaining students are either strictly increasing or strictly decreasing in height. Args: n (int): The number of students. heights (List[int]): The heights of the students. Returns: int: The minimum number of students that need to be removed. Examples: >>> min_remove_students_to_sort(8, [1, 3, 2, 2, 4, 5, 3, 6]) 3 >>> min_remove_students_to_sort(5, [5, 4, 3, 2, 1]) 0 >>> min_remove_students_to_sort(5, [1, 2, 3, 4, 5]) 0 pass def test_min_remove_students_to_sort(): assert min_remove_students_to_sort(8, [1, 3, 2, 2, 4, 5, 3, 6]) == 3 assert min_remove_students_to_sort(5, [5, 4, 3, 2, 1]) == 0 assert min_remove_students_to_sort(5, [1, 2, 3, 4, 5]) == 0 assert min_remove_students_to_sort(1, [10]) == 0 assert min_remove_students_to_sort(6, [1, 3, 5, 4, 2, 6]) == 2 assert min_remove_students_to_sort(7, [7, 6, 5, 4, 3, 2, 1]) == 0 assert min_remove_students_to_sort(4, [4, 2, 3, 1]) == 1","solution":"def min_remove_students_to_sort(n, heights): def longest_increasing_subsequence(seq): dp = [1] * len(seq) for i in range(1, len(seq)): for j in range(i): if seq[i] > seq[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_decreasing_subsequence(seq): dp = [1] * len(seq) for i in range(1, len(seq)): for j in range(i): if seq[i] < seq[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) lis_length = longest_increasing_subsequence(heights) lds_length = longest_decreasing_subsequence(heights) return n - max(lis_length, lds_length)"},{"question":"def solve(n: int, grid_values: List[List[str]]) -> Union[List[str], str]: Determine whether it is possible to plant trees in an NxN grid such that no two trees share the same row or column, and no trees are planted on occupied plots. Args: n (int): Size of the grid (2  n  10) grid_values (List[List[str]]): NxN grid represented as a list of strings where '0' is an unoccupied plot and 'X' is an occupied plot. Returns: Union[List[str], str]: \\"Not possible\\" if it is not possible to place trees as per the rules, else a list of strings representing the grid configuration. Example: >>> solve(3, [\\"0 0 X\\".split(), \\"X 0 0\\".split(), \\"0 X 0\\".split()]) ['T 0 X', 'X T 0', '0 X T'] >>> solve(3, [\\"X X 0\\".split(), \\"0 X 0\\".split(), \\"0 X X\\".split()]) 'Not possible'","solution":"def plant_trees(grid): This function takes an NxN grid and determines if it is possible to plant one tree ('T') in each row and each column without placing a tree on an occupied plot ('X'). def find_place(row, col_occupied, grid, N): if row == N: return True for col in range(N): if col not in col_occupied and grid[row][col] != 'X': grid[row][col] = 'T' if find_place(row + 1, col_occupied | {col}, grid, N): return True grid[row][col] = '0' return False N = len(grid) if find_place(0, set(), grid, N): return grid else: return \\"Not possible\\" def solve(n, grid_values): grid = [list(row) for row in grid_values] result = plant_trees(grid) if result == \\"Not possible\\": return result else: return [' '.join(row) for row in result]"},{"question":"from typing import List, Tuple def find_min_partition_difference(arr: List[int]) -> Tuple[int, int, int]: Partition the list into two sublists such that the absolute difference between the sum of the elements of these sublists is the smallest possible. >>> find_min_partition_difference([7, 3, 2, 5, 8]) (1, 12, 13) >>> find_min_partition_difference([1, 2]) (1, 1, 2) pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to find the minimum partition difference for each. >>> process_test_cases([(5, [7, 3, 2, 5, 8]), (2, [1, 2])]) ['1 12 13', '1 1 2'] pass def main(input_data: str) -> str: Main function to handle input and output for the partition difference problem. >>> input_data = \\"1n5n7 3 2 5 8n\\" >>> main(input_data) '1 12 13' pass if __name__ == \\"__main__\\": input_data = input() print(main(input_data))","solution":"from itertools import combinations def find_min_partition_difference(arr): total_sum = sum(arr) half_sum = total_sum / 2 n = len(arr) min_diff = float('inf') best_partition = (0, 0) for i in range(1, n): for comb in combinations(arr, i): curr_sum = sum(comb) diff = abs(total_sum - 2 * curr_sum) if diff < min_diff: min_diff = diff best_partition = (curr_sum, total_sum - curr_sum) return min_diff, best_partition[0], best_partition[1] def process_test_cases(test_cases): results = [] for test in test_cases: n, arr = test min_diff, sum1, sum2 = find_min_partition_difference(arr) results.append(f\\"{min_diff} {sum1} {sum2}\\") return results def main(input_data): data = input_data.strip().split('n') T = int(data[0]) test_cases = [] index = 1 for _ in range(T): n = int(data[index]) arr = list(map(int, data[index + 1].split())) test_cases.append((n, arr)) index += 2 results = process_test_cases(test_cases) return \\"n\\".join(results)"},{"question":"from typing import List def canMakeAmount(coins: List[int], amount: int) -> bool: Determine whether it is possible to make a certain amount of money using the given coin denominations. Return True if it is possible, otherwise return False. Example 1: >>> canMakeAmount([1, 2, 5], 11) True Example 2: >>> canMakeAmount([2], 3) False Example 3: >>> canMakeAmount([1], 0) True","solution":"from typing import List def canMakeAmount(coins: List[int], amount: int) -> bool: Returns True if it's possible to make the \`amount\` with the given denominations, otherwise returns False. dp = [False] * (amount + 1) dp[0] = True for i in range(1, amount + 1): for coin in coins: if i - coin >= 0 and dp[i - coin]: dp[i] = True break return dp[amount]"},{"question":"from typing import List, Tuple def min_average_distance(x: int, y: int, n: int, garden: List[List[int]], potential_locations: List[Tuple[int, int]], k: int) -> int: Identify the optimal way to place the water tanks such that the average distance from any cell in the garden to the nearest tank is minimized. Args: x (int): Number of columns in the garden. y (int): Number of rows in the garden. n (int): Number of potential tank locations. garden (List[List[int]]): Heights of each cell in the garden. potential_locations (List[Tuple[int, int]]): List of tuples, where each tuple consists of row and column coordinates of potential tank locations. k (int): Number of tanks to be installed. Returns: int: Minimized average distance from any cell in the garden to the nearest tank. Examples: >>> min_average_distance(4, 3, 3, [[0, 0, 4, 3], [0, 2, 2, 3], [2, 1, 4, 3]], [(0, 0), (0, 3), (2, 1)], 1) 2 >>> min_average_distance(5, 4, 4, [[1, 1, 1, 1, 1], [3, 3, 3, 3, 3], [5, 5, 5, 5, 5], [0, 0, 0, 0, 0]], [(1, 0), (1, 4), (3, 0), (3, 4)], 2) 1 def test_case_1(): x = 4 y = 3 n = 3 garden = [ [0, 0, 4, 3], [0, 2, 2, 3], [2, 1, 4, 3] ] potential_locations = [(0, 0), (0, 3), (2, 1)] k = 1 assert min_average_distance(x, y, n, garden, potential_locations, k) == 2 def test_case_2(): x = 5 y = 4 n = 4 garden = [ [1, 1, 1, 1, 1], [3, 3, 3, 3, 3], [5, 5, 5, 5, 5], [0, 0, 0, 0, 0] ] potential_locations = [(1, 0), (1, 4), (3, 0), (3, 4)] k = 2 assert min_average_distance(x, y, n, garden, potential_locations, k) == 1 def test_case_3(): x = 6 y = 3 n = 2 garden = [ [2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3] ] potential_locations = [(0, 1), (1, 4)] k = 1 assert min_average_distance(x, y, n, garden, potential_locations, k) == 2 def test_case_4(): x = 3 y = 3 n = 2 garden = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] potential_locations = [(0, 0), (2, 2)] k = 1 assert min_average_distance(x, y, n, garden, potential_locations, k) == 2 def test_case_5(): x = 2 y = 2 n = 2 garden = [ [1, 2], [3, 4] ] potential_locations = [(0, 0), (1, 1)] k = 1 assert min_average_distance(x, y, n, garden, potential_locations, k) == 1","solution":"from itertools import combinations from collections import deque def min_average_distance(x, y, n, garden, potential_locations, k): def bfs(tank_locations): visited = [[False] * x for _ in range(y)] queue = deque() for loc in tank_locations: queue.append((loc[0], loc[1], 0)) visited[loc[0]][loc[1]] = True total_distance = 0 cells_count = 0 while queue: r, c, dist = queue.popleft() total_distance += dist cells_count += 1 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < y and 0 <= nc < x and not visited[nr][nc]: visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return total_distance / (y * x) min_avg_distance = float('inf') for tank_combination in combinations(potential_locations, k): avg_distance = bfs(tank_combination) if avg_distance < min_avg_distance: min_avg_distance = avg_distance return int(min_avg_distance) # Example usage: # Coordinates are 0-based for internal processing x = 5 y = 4 n = 4 garden = [ [1, 1, 1, 1, 1], [3, 3, 3, 3, 3], [5, 5, 5, 5, 5], [0, 0, 0, 0, 0] ] potential_locations = [(1 - 1, 2 - 1), (2 - 1, 5 - 1), (4 - 1, 1 - 1), (4 - 1, 5 - 1)] k = 2 print(min_average_distance(x, y, n, garden, potential_locations, k)) # Expected output: 1"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process update and range maximum queries on an array. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): Initial elements in the array. queries (List[Tuple[int, int, int]]): List of queries where each query is of the form (1, x, y) for update or (2, l, r) for range maximum. Returns: List[int]: Results of the range maximum queries. Example: >>> n = 5 >>> q = 5 >>> array = [1, 3, 5, 7, 9] >>> queries = [(2, 1, 3), (1, 3, 10), (2, 1, 3), (2, 3, 5), (1, 5, 4)] >>> process_queries(n, q, array, queries) [5, 10, 9] from typing import List, Tuple","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (4 * self.n) self._build(data, 0, 0, self.n - 1) def _build(self, data, node, start, end): if start == end: self.tree[node] = data[start] else: mid = (start + end) // 2 self._build(data, 2 * node + 1, start, mid) self._build(data, 2 * node + 2, mid + 1, end) self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2]) def update(self, idx, value, node, start, end): if start == end: self.tree[node] = value else: mid = (start + end) // 2 if start <= idx <= mid: self.update(idx, value, 2 * node + 1, start, mid) else: self.update(idx, value, 2 * node + 2, mid + 1, end) self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2]) def range_max(self, L, R, node, start, end): if R < start or end < L: return -float('inf') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_max = self.range_max(L, R, 2 * node + 1, start, mid) right_max = self.range_max(L, R, 2 * node + 2, mid + 1, end) return max(left_max, right_max) def process_queries(n, q, array, queries): segment_tree = SegmentTree(array) results = [] for query in queries: type_query = query[0] if type_query == 1: x, y = query[1]-1, query[2] segment_tree.update(x, y, 0, 0, n - 1) elif type_query == 2: l, r = query[1]-1, query[2]-1 result = segment_tree.range_max(l, r, 0, 0, n - 1) results.append(result) return results # Example usage: # n = 5 # q = 5 # array = [1, 3, 5, 7, 9] # queries = [ # (2, 1, 3), # (1, 3, 10), # (2, 1, 3), # (2, 3, 5), # (1, 5, 4) # ] # print(process_queries(n, q, array, queries))"},{"question":"def check_consistency(n: int, data_items: List[int], node_updates: List[List[Tuple[int, int]]]) -> str: Returns \\"Consistent\\" if all data items' timestamps on different nodes follow strictly increasing order, otherwise returns \\"Inconsistent\\". Parameters: n (int): Number of data items. data_items (list of int): List of data item identifiers. node_updates (list of list of tuples): List where each element is a list of tuples (node id, timestamp). Returns: str: \\"Consistent\\" or \\"Inconsistent\\" --- Examples --- >>> check_consistency(3, [1, 2, 3], [ ... [(1, 1000), (2, 2000)], ... [(1, 1001), (2, 999)], ... [(1, 1500), (3, 1600)] ... ]) \\"Inconsistent\\" >>> check_consistency(2, [4, 5], [ ... [(1, 2000), (2, 3000), (3, 4000)], ... [(2, 1000), (3, 2000)] ... ]) \\"Consistent\\"","solution":"def check_consistency(n, data_items, node_updates): Returns \\"Consistent\\" if all data items' timestamps on different nodes follow strictly increasing order, otherwise returns \\"Inconsistent\\". Parameters: n (int): Number of data items. data_items (list of int): List of data item identifiers. node_updates (list of list of tuples): List where each element is a list of tuples (node id, timestamp). Returns: str: \\"Consistent\\" or \\"Inconsistent\\" for updates in node_updates: # Extract timestamps and sort them timestamps = [timestamp for node, timestamp in updates] if timestamps != sorted(timestamps): return \\"Inconsistent\\" return \\"Consistent\\""},{"question":"def check_flower_layouts(n, layouts): This function checks for the uniqueness of each flower layout in the list. :param n: The number of layouts :param layouts: List of lists, where each inner list represents a flower layout :return: List of strings, each either \\"Unique\\" or \\"Duplicate\\" pass def parse_input(input_lines): This function parses the given input lines into the required format for processing. :param input_lines: List of strings, where each string represents a line of input :return: Tuple containing the number of layouts and a list of layouts pass # Example usage: # input_lines = [\\"4\\", \\"3 1 2 3\\", \\"4 1 4 5 6\\", \\"3 1 2 3\\", \\"2 7 8\\"] # n, layouts = parse_input(input_lines) # print(check_flower_layouts(n, layouts)) # Output: [\\"Unique\\", \\"Unique\\", \\"Duplicate\\", \\"Unique\\"] # Unit Tests def test_single_layout_unique(): input_lines = [\\"1\\", \\"3 1 2 3\\"] n, layouts = parse_input(input_lines) assert check_flower_layouts(n, layouts) == [\\"Unique\\"] def test_multiple_unique_layouts(): input_lines = [\\"3\\", \\"3 1 2 3\\", \\"2 4 5\\", \\"3 6 7 8\\"] n, layouts = parse_input(input_lines) assert check_flower_layouts(n, layouts) == [\\"Unique\\", \\"Unique\\", \\"Unique\\"] def test_duplicate_layout(): input_lines = [\\"3\\", \\"3 1 2 3\\", \\"3 1 2 3\\", \\"2 4 5\\"] n, layouts = parse_input(input_lines) assert check_flower_layouts(n, layouts) == [\\"Unique\\", \\"Duplicate\\", \\"Unique\\"] def test_multiple_duplicates(): input_lines = [\\"5\\", \\"2 1 5\\", \\"3 4 5 6\\", \\"2 1 5\\", \\"3 4 5 6\\", \\"2 7 8\\"] n, layouts = parse_input(input_lines) assert check_flower_layouts(n, layouts) == [\\"Unique\\", \\"Unique\\", \\"Duplicate\\", \\"Duplicate\\", \\"Unique\\"] def test_large_numbers(): input_lines = [\\"2\\", \\"3 1000000 999999 123456\\", \\"3 1000000 999999 123456\\"] n, layouts = parse_input(input_lines) assert check_flower_layouts(n, layouts) == [\\"Unique\\", \\"Duplicate\\"]","solution":"def check_flower_layouts(n, layouts): This function checks for the uniqueness of each flower layout in the list. :param n: The number of layouts :param layouts: List of lists, where each inner list represents a flower layout :return: List of strings, each either \\"Unique\\" or \\"Duplicate\\" seen_layouts = set() output = [] for layout in layouts: layout_tuple = tuple(layout) if layout_tuple in seen_layouts: output.append(\\"Duplicate\\") else: output.append(\\"Unique\\") seen_layouts.add(layout_tuple) return output # Helper function to parse input def parse_input(input_lines): n = int(input_lines[0]) layouts = [] for i in range(1, n+1): layout = list(map(int, input_lines[i].split()[1:])) layouts.append(layout) return n, layouts"},{"question":"from typing import List, Tuple def min_time_to_target(n: int, grid: List[List[int]], sx: int, sy: int, tx: int, ty: int) -> int: Determine the minimum time needed for RoboDeliver to get from the starting point to the target cell. If it is not possible, return -1. >>> min_time_to_target(3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]], 0, 0, 2, 2) 4 >>> min_time_to_target(3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) -1 def process_test_cases(t: int, test_cases: List[Tuple[int, List[List[int]], int, int, int, int]]) -> List[int]: Process multiple test cases to determine the minimum time needed for RoboDeliver for each test case. >>> t = 2 >>> test_cases = [ ... (3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]], 0, 0, 2, 2), ... (3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) ... ] >>> process_test_cases(t, test_cases) [4, -1] # Unit tests def test_single_case(): assert min_time_to_target(3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]], 0, 0, 2, 2) == 4 assert min_time_to_target(3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) == -1 def test_process_test_cases(): t = 2 test_cases = [ (3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]], 0, 0, 2, 2), (3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) ] assert process_test_cases(t, test_cases) == [4, -1] t = 1 test_cases = [ (4, [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 0, 1, 0]], 0, 0, 3, 3) ] assert process_test_cases(t, test_cases) == [6] def test_edge_cases(): assert min_time_to_target(2, [[0, 0], [1, 0]], 0, 0, 1, 1) == 2 assert min_time_to_target(2, [[0, 1], [1, 0]], 0, 0, 1, 1) == -1 assert min_time_to_target(5, [[0]*5, [0]*5, [0]*5, [0]*5, [0]*5], 0, 0, 4, 4) == 8 def test_no_path(): assert min_time_to_target(3, [[0, 0, 1], [1, 1, 1], [1, 0, 0]], 0, 0, 2, 2) == -1 assert min_time_to_target(3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]], 0, 0, 1, 1) == -1","solution":"from collections import deque def min_time_to_target(n, grid, sx, sy, tx, ty): if grid[sx][sy] == 1 or grid[tx][ty] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(n)] queue = deque([(sx, sy, 0)]) visited[sx][sy] = True while queue: x, y, dist = queue.popleft() if x == tx and y == ty: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited[nx][ny] = True return -1 def process_test_cases(t, test_cases): results = [] for i in range(t): n, grid, sx, sy, tx, ty = test_cases[i] results.append(min_time_to_target(n, grid, sx, sy, tx, ty)) return results"},{"question":"def min_herbs_to_discard(gathered_herbs, recipe): Determines the minimum number of gathered herbs that need to be discarded to create the required potion sequence. Parameters: gathered_herbs (list of int): List of gathered herbs. recipe (list of int): List of required herbs in the recipe. Returns: int: The minimum number of herbs that need to be discarded. pass # Unit tests def test_all_herbs_matched(): assert min_herbs_to_discard([1, 2, 3, 4, 5, 6, 7], [2, 4, 6, 7]) == 3 def test_no_herb_matched(): assert min_herbs_to_discard([1, 2, 3, 4], [5, 6, 7, 8]) == 4 def test_some_herbs_matched(): assert min_herbs_to_discard([1, 3, 5, 7, 9], [1, 7, 9]) == 2 def test_all_required_herbs_is_gathered(): assert min_herbs_to_discard([1, 2, 3, 4], [1, 2, 3, 4]) == 0 def test_some_required_herbs_is_gathered(): assert min_herbs_to_discard([1, 4, 3, 7, 6], [3, 7]) == 3 def test_gathered_herbs_is_empty(): assert min_herbs_to_discard([], [1, 2, 3]) == 0 def test_recipe_is_empty(): assert min_herbs_to_discard([1, 2, 3, 4], []) == 4 def test_both_empty(): assert min_herbs_to_discard([], []) == 0","solution":"def min_herbs_to_discard(gathered_herbs, recipe): Determines the minimum number of gathered herbs that need to be discarded to create the required potion sequence. Parameters: gathered_herbs (list of int): List of gathered herbs. recipe (list of int): List of required herbs in the recipe. Returns: int: The minimum number of herbs that need to be discarded. n = len(gathered_herbs) m = len(recipe) i = 0 j = 0 while i < n and j < m: if gathered_herbs[i] == recipe[j]: j += 1 i += 1 return n - j"},{"question":"def is_magic(square: List[List[int]]) -> bool: Check if a given square is a magic square. >>> is_magic([ [2, 7, 6], [9, 5, 1], [4, 3, 8] ]) True >>> is_magic([ [3, 7, 6], [9, 5, 1], [4, 3, 8] ]) False def complete_magic_square(n: int, grid: List[List[int]]) -> Tuple[str, List[List[int]]]: Complete the grid to form a magic square if possible. >>> n = 3 >>> grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] >>> complete_magic_square(n, grid) ('POSSIBLE', [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ]) >>> n = 3 >>> grid = [ [8, 0, 0], [0, 0, 6], [0, 0, 0] ] >>> complete_magic_square(n, grid) ('IMPOSSIBLE',) def solve(n: int, grid: List[List[int]]) -> None: Determine if it is possible to complete the grid to form a magic square and print the completed grid or 'IMPOSSIBLE'.","solution":"import itertools def is_magic(square): n = len(square) target_sum = sum(square[0]) # Check rows for row in square: if sum(row) != target_sum: return False # Check columns for col in range(n): if sum(square[row][col] for row in range(n)) != target_sum: return False # Check diagonals if sum(square[i][i] for i in range(n)) != target_sum or sum(square[i][n-i-1] for i in range(n)) != target_sum: return False return True def complete_magic_square(n, grid): def backtrack(i): if i == n * n: return is_magic(grid) x, y = divmod(i, n) if grid[x][y] != 0: return backtrack(i + 1) for num in range(1, n * n + 1): if num not in used: grid[x][y] = num used.add(num) if backtrack(i + 1): return True grid[x][y] = 0 used.remove(num) return False used = set(itertools.chain(*grid)) if backtrack(0): return \\"POSSIBLE\\", grid else: return \\"IMPOSSIBLE\\", def solve(n, grid): result = complete_magic_square(n, grid) if result[0] == \\"IMPOSSIBLE\\": print(\\"IMPOSSIBLE\\") else: print(\\"POSSIBLE\\") for row in result[1]: print(\\" \\".join(map(str, row))) # Example usage: # n = 3 # grid = [ # [0, 0, 0], # [0, 0, 0], # [0, 0, 0] # ] # solve(n, grid)"},{"question":"def isFibonacciArray(arr, N): Checks whether the array is a Fibonacci array. >>> isFibonacciArray([0, 1, 1, 2, 3, 5], 6) == True >>> isFibonacciArray([0, 1, 1, 3, 4], 5) == False","solution":"def isFibonacciArray(arr, N): Checks whether the array is a Fibonacci array. # Early exits for short lists if N == 0: return False if N == 1: return arr[0] == 0 if N == 2: return arr[0] == 0 and arr[1] == 1 # Verify that the array follows the Fibonacci rule if arr[0] != 0 or arr[1] != 1: return False for i in range(2, N): if arr[i] != arr[i-1] + arr[i-2]: return False return True"},{"question":"def can_drone_complete_round_trip(n, battery_capacities, x1, y1, x2, y2): Determines if there is a drone that can complete a round trip between two delivery points. Args: n (int): Number of drones. battery_capacities (list of int): Battery capacities of each drone. x1, y1 (int): Coordinates of the first delivery point. x2, y2 (int): Coordinates of the second delivery point. Returns: str: \\"YES\\" if at least one drone can make the round trip, otherwise \\"NO\\". # Implementation Here from solution import can_drone_complete_round_trip def test_can_drone_complete_round_trip_yes(): assert can_drone_complete_round_trip(3, [10, 20, 30], 0, 0, 3, 4) == \\"YES\\" def test_can_drone_complete_round_trip_no(): assert can_drone_complete_round_trip(2, [5, 8], 1, 2, 4, 6) == \\"NO\\" def test_can_drone_complete_round_trip_large(): assert can_drone_complete_round_trip(4, [7, 14, 21, 28], 0, 0, 6, 8) == \\"YES\\" def test_can_drone_complete_round_trip_edge_case(): assert can_drone_complete_round_trip(1, [10000], -10000, -10000, 10000, 10000) == \\"NO\\" def test_can_drone_complete_round_trip_exact_match(): assert can_drone_complete_round_trip(2, [10, 14], 0, 0, 3, 4) == \\"YES\\"","solution":"import math def can_drone_complete_round_trip(n, battery_capacities, x1, y1, x2, y2): Determines if there is a drone that can complete a round trip between two delivery points. Args: n (int): Number of drones. battery_capacities (list of int): Battery capacities of each drone. x1, y1 (int): Coordinates of the first delivery point. x2, y2 (int): Coordinates of the second delivery point. Returns: str: \\"YES\\" if at least one drone can make the round trip, otherwise \\"NO\\". # Calculate the Euclidean distance between the two points distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) round_trip_distance = 2 * distance # Check if any drone has the required battery capacity for battery_capacity in battery_capacities: if battery_capacity >= round_trip_distance: return \\"YES\\" return \\"NO\\""},{"question":"def restore_ip_addresses(s: str) -> List[str]: Write a function that takes a string containing digits and returns a list of strings representing all possible valid IP addresses that can be made by inserting periods (\\".\\") to separate the string into four octets. Each octet must be a valid integer between 0 and 255, inclusive, and should not have leading zeros except for the number '0' itself. Args: s (str): A string containing digits with a length from 1 to 12. Returns: List[str]: A list of strings representing all possible valid IP addresses. Examples: >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restore_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"]","solution":"def restore_ip_addresses(s): def is_valid(segment): # Check if a segment is valid: length is at most 3, and each number is between 0 and 255. # And no leading zeros unless the number is '0'. return len(segment) == 1 or (segment[0] != '0' and int(segment) <= 255) def restore(start=0, parts=[]): if start == len(s) and len(parts) == 4: ip_addresses.append('.'.join(parts)) return if len(parts) >= 4: return for length in range(1, 4): if start + length <= len(s): segment = s[start:start+length] if is_valid(segment): restore(start + length, parts + [segment]) ip_addresses = [] if 4 <= len(s) <= 12: restore() return ip_addresses"},{"question":"def count_anagram_groups(num_test_cases, test_cases): Count the number of groups of anagrams in each test case. >>> count_anagram_groups(1, [[3, \\"listen\\", \\"silent\\", \\"enlist\\"]]) [1] >>> count_anagram_groups(1, [[4, \\"cat\\", \\"dog\\", \\"tac\\", \\"god\\"]]) [2]","solution":"def count_anagram_groups(num_test_cases, test_cases): result = [] for i in range(num_test_cases): num_books = test_cases[i][0] book_titles = test_cases[i][1:] hash_map = {} for title in book_titles: sorted_title = ''.join(sorted(title)) if sorted_title in hash_map: hash_map[sorted_title].append(title) else: hash_map[sorted_title] = [title] result.append(len(hash_map)) return result"},{"question":"def removeDuplicates(S: str) -> str: Remove all the duplicate characters and digits from the input string S and return the modified string with the relative order preserved. >>> removeDuplicates(\\"programming12331\\") 'progamin123' >>> removeDuplicates(\\"hello1234567890\\") 'helo1234567890'","solution":"def removeDuplicates(S): Removes all the duplicate characters and digits from the input string S and returns the modified string with the relative order preserved. seen = set() result = [] for char in S: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def nthCullen(n: int) -> int: Returns the nth Cullen number. Cullen number is defined as: n * 2^n + 1. >>> nthCullen(1) == 3 >>> nthCullen(2) == 9 >>> nthCullen(3) == 25 >>> nthCullen(5) == 161 >>> nthCullen(20) == 20971521","solution":"def nthCullen(n): Returns the nth Cullen number. Cullen number is defined as: n * 2^n + 1 return n * (2 ** n) + 1"},{"question":"def smallest_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the input string. >>> smallest_permutation(\\"cba\\") -> \\"abc\\" >>> smallest_permutation(\\"dcba\\") -> \\"abcd\\" >>> smallest_permutation(\\"edcba\\")-> \\"abcde\\" >>> smallest_permutation(\\"banana\\")-> \\"aaabnn\\"","solution":"def smallest_permutation(s): Returns the lexicographically smallest permutation of the input string. return ''.join(sorted(s))"},{"question":"def is_palindrome(num: int) -> bool: Checks if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1221) True >>> is_palindrome(12321) True >>> is_palindrome(12331) False def next_palindrome(N: int) -> int: Finds the smallest palindrome greater than N. >>> next_palindrome(123) 131 >>> next_palindrome(808) 818 >>> next_palindrome(999) 1001 >>> next_palindrome(10) 11 >>> next_palindrome(1) 2 def find_next_palindromes(test_cases: List[int]) -> List[int]: For a list of test cases, return the next palindromes. >>> find_next_palindromes([123, 808, 999]) [131, 818, 1001] >>> find_next_palindromes([10, 1, 50]) [11, 2, 55] >>> find_next_palindromes([100, 101, 2002]) [101, 111, 2112]","solution":"def is_palindrome(num): Checks if a number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(N): Finds the smallest palindrome greater than N. N += 1 # Start checking from the next number while not is_palindrome(N): N += 1 return N def find_next_palindromes(test_cases): For a list of test cases, return the next palindromes. results = [] for N in test_cases: results.append(next_palindrome(N)) return results"},{"question":"def maximum_product_of_three(arr: List[int]) -> int: Given an array of integers, find the maximum possible product of three numbers in the array. The function should be efficient with a time complexity of O(n log n) or better. :param arr: List[int] - The input array of integers :return: int - The maximum possible product of three numbers from the array Examples: >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([-10, -10, 5, 2]) 500","solution":"def maximum_product_of_three(arr): Returns the maximum possible product of three numbers from the array. # Sorting the array arr.sort() # The maximum of the product of the largest three numbers # or the product of the two smallest numbers (which could be negative) # and the largest number. return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def max_discount_coupon_value(datasets: List[List[int]]) -> List[int]: Calculate the maximum discount coupon value for each dataset of daily meal expenses. >>> max_discount_coupon_value([[3, -2, 5, -1, 2]]) [7] >>> max_discount_coupon_value([[4, -1, 2, 1, -5, 4]]) [6]","solution":"def max_discount_coupon_value(datasets): Given a list of datasets, where each dataset is a list of daily meal expenses, this function returns a list of maximum possible discount coupon values for each dataset. results = [] for expenses in datasets: max_current = max_global = expenses[0] for i in range(1, len(expenses)): max_current = max(expenses[i], max_current + expenses[i]) if max_current > max_global: max_global = max_current results.append(max_global) return results"},{"question":"def combine_chunks(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[List[str]]: Combine multiple chunks of text into a single unified document while eliminating any duplicate lines. >>> combine_chunks(2, [(3, ['apple', 'banana', 'apple']), (2, ['hello', 'world'])]) [['apple', 'banana'], ['hello', 'world']] >>> combine_chunks(1, [(4, ['one', 'two', 'three', 'one'])]) [['one', 'two', 'three']] pass from solution import combine_chunks def test_case_1(): t = 2 test_cases = [ (3, ['apple', 'banana', 'apple']), (2, ['hello', 'world']) ] expected_output = [ ['apple', 'banana'], ['hello', 'world'] ] assert combine_chunks(t, test_cases) == expected_output def test_case_2(): t = 1 test_cases = [ (4, ['one', 'two', 'three', 'one']) ] expected_output = [ ['one', 'two', 'three'] ] assert combine_chunks(t, test_cases) == expected_output def test_case_3(): t = 2 test_cases = [ (5, ['a', 'b', 'a', 'c', 'b']), (3, ['x', 'y', 'z']) ] expected_output = [ ['a', 'b', 'c'], ['x', 'y', 'z'] ] assert combine_chunks(t, test_cases) == expected_output def test_case_4(): t = 1 test_cases = [ (3, ['same', 'same', 'same']) ] expected_output = [ ['same'] ] assert combine_chunks(t, test_cases) == expected_output def test_case_5(): t = 0 test_cases = [] expected_output = [] assert combine_chunks(t, test_cases) == expected_output","solution":"def combine_chunks(t, test_cases): result = [] for i in range(t): n, chunks = test_cases[i] seen = set() unified_document = [] for line in chunks: if line not in seen: seen.add(line) unified_document.append(line) result.append(unified_document) return result"},{"question":"from typing import List, Tuple def statement1(total_sum: int) -> bool: Determine if Wendy could say 'I cannot determine the three numbers' given the sum. >>> statement1(6) False >>> statement1(10) True def statement2(total_product: int) -> bool: Determine if Chris could say 'I still cannot determine the three numbers either' given the product. >>> statement2(6) False >>> statement2(30) True def statement3(total_sum: int) -> bool: Determine if Wendy could say 'Given Chris's response, now I know what the three numbers are' given the sum and Chris's statement. >>> statement3(6) False >>> statement3(10) True def statement4(total_product: int) -> bool: Determine if Chris could say 'Then I also know what the three numbers are now' given the product and Wendy's statement. >>> statement4(6) False >>> statement4(30) True def find_numbers(total_sum: int, total_product: int) -> Tuple[int, int, int]: Find the three numbers given their sum and product. >>> find_numbers(6, 6) (1, 2, 3) >>> find_numbers(10, 30) (2, 3, 5)","solution":"from itertools import combinations def find_sum_triplets(total_sum): triplets = [] for x in range(1, total_sum - 1): for y in range(x + 1, total_sum - x): z = total_sum - x - y if z > y: triplets.append((x, y, z)) return triplets def find_product_triplets(total_product): triplets = [] for x in range(1, int(total_product ** (1/3)) + 1): if total_product % x == 0: for y in range(x + 1, int((total_product // x) ** (1/2)) + 1): if (total_product // x) % y == 0: z = total_product // (x * y) if z >= y + 1 and x * y * z == total_product: triplets.append((x, y, z)) return triplets def statement1(total_sum): return len(find_sum_triplets(total_sum)) > 1 def statement2(total_product): return len(find_product_triplets(total_product)) != 1 def statement3(total_sum): possible_sums = find_sum_triplets(total_sum) for triplet in possible_sums: product = triplet[0] * triplet[1] * triplet[2] if statement2(product): return True return False def statement4(total_product): possible_products = find_product_triplets(total_product) for triplet in possible_products: total_sum = sum(triplet) if statement3(total_sum): return True return False def find_numbers(total_sum, total_product): possible_sums = find_sum_triplets(total_sum) for triplet in possible_sums: if triplet[0] * triplet[1] * triplet[2] == total_product: return tuple(sorted(triplet)) return None"},{"question":"def count_beautiful_palindromes(n: int) -> int: Returns the number of distinct beautiful palindromes of length n. >>> count_beautiful_palindromes(1) 26 >>> count_beautiful_palindromes(2) 26 >>> count_beautiful_palindromes(3) 26 >>> count_beautiful_palindromes(4) 26","solution":"def count_beautiful_palindromes(n): Returns the number of distinct beautiful palindromes of length n. if n == 1: return 26 return 26"},{"question":"from typing import List def has_pair_with_sum(numbers: List[int], target: int) -> bool: Determines if there is a pair of distinct elements in the list that sum up to the given target. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False","solution":"from typing import List def has_pair_with_sum(numbers: List[int], target: int) -> bool: Determines if there is a pair of distinct elements in the list that sum up to the given target. Parameters: numbers (List[int]): A list of integers. target (int): The target sum. Returns: bool: True if there is a pair of distinct elements that sum up to the target, False otherwise. seen = set() for number in numbers: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def isBalanced(s: str) -> bool: Determines whether a given string of parentheses is balanced or not. Supports three types of parentheses: '()', '{}' and '[]'. >>> isBalanced(\\"()\\") True >>> isBalanced(\\"{(})\\") False >>> isBalanced(\\"[()]{}{[()()]()}\\") True","solution":"def isBalanced(s: str) -> bool: Determines whether a given string of parentheses is balanced or not. Supports three types of parentheses: '()', '{}' and '[]'. stack = [] matching = {')': '(', '}': '{', ']': '['} for char in s: if char in matching.values(): stack.append(char) elif char in matching.keys(): if stack == [] or stack.pop() != matching[char]: return False else: # This part is redundant as per conditions, s should only contains '(){}[]' return False return stack == [] # Example usage # print(isBalanced(\\"()\\")) # True # print(isBalanced(\\"{(})\\")) # False # print(isBalanced(\\"[()]{}{[()()]()}\\")) # True"},{"question":"def does_subarray_sum_to_x(n, array, x): Determines if there exists a non-empty subarray that sums up to x. :param n: int, size of the array :param array: list of int, elements of the array :param x: int, target sum :return: 'YES' if such a subarray exists, otherwise 'NO' >>> does_subarray_sum_to_x(5, [1, 2, 3, 4, 5], 9) 'YES' >>> does_subarray_sum_to_x(6, [1, -1, 3, 2, -5, 4], 7) 'NO'","solution":"def does_subarray_sum_to_x(n, array, x): Determines if there exists a non-empty subarray that sums up to x. :param n: int, size of the array :param array: list of int, elements of the array :param x: int, target sum :return: 'YES' if such a subarray exists, otherwise 'NO' current_sum = 0 prefix_sums = {0} for num in array: current_sum += num if (current_sum - x) in prefix_sums: return 'YES' prefix_sums.add(current_sum) return 'NO'"},{"question":"def dice_game(T, rolls): Calculate final scores of Jane and John after T turns and determine the winner. Args: T : int : number of turns rolls : list of tuples : contains T tuples of 4 integers each (j1, j2, h1, h2) Returns: str : final scores of Jane and John, and the result (\\"Jane wins\\", \\"John wins\\", or \\"Draw\\") >>> dice_game(3, [(1, 2, 3, 3), (4, 4, 2, 5), (6, 6, 5, 5)]) == \\"Jane: 43 John: 39 Jane wins\\" >>> dice_game(2, [(6, 6, 1, 12), (6, 6, 1, 12)]) == \\"Jane: 48 John: 26 Jane wins\\" >>> dice_game(2, [(3, 3, 2, 2), (5, 5, 5, 5)]) == \\"Jane: 32 John: 28 Jane wins\\" >>> dice_game(2, [(1, 1, 1, 1), (6, 6, 6, 6)]) == \\"Jane: 28 John: 28 Draw\\" >>> dice_game(3, [(1, 2, 3, 3), (2, 2, 4, 4), (3, 4, 5, 5)]) == \\"Jane: 18 John: 48 John wins\\"","solution":"def dice_game(T, rolls): Calculate final scores of Jane and John after T turns and determine the winner. Args: T : int : number of turns rolls : list of tuples : contains T tuples of 4 integers each (j1, j2, h1, h2) Returns: str : final scores of Jane and John, and the result (\\"Jane wins\\", \\"John wins\\", or \\"Draw\\") jane_score = 0 john_score = 0 for roll in rolls: j1, j2, h1, h2 = roll # Calculate Jane's score for the turn if j1 == j2: jane_score += j1 + j2 + 2 * j1 else: jane_score += j1 + j2 # Calculate John's score for the turn if h1 == h2: john_score += h1 + h2 + 2 * h1 else: john_score += h1 + h2 if jane_score > john_score: result = f\\"Jane: {jane_score} John: {john_score} Jane wins\\" elif john_score > jane_score: result = f\\"Jane: {jane_score} John: {john_score} John wins\\" else: result = f\\"Jane: {jane_score} John: {john_score} Draw\\" return result"},{"question":"def calculate_performance_scores(n: int, k: int, submissions: List[Tuple[int, int]]) -> List[int]: Calculate the performance scores for each participant based on their top 3 highest distinct scores. If a participant has fewer than 3 distinct scores, sum all of their distinct scores. Args: n (int): Number of participants. k (int): Number of submissions. submissions (List[Tuple[int, int]]): List of tuples containing participant index and score. Returns: List[int]: List of performance scores for each participant in order of their index. >>> calculate_performance_scores(3, 8, [(1, 50), (1, 90), (1, 80), (1, 50), (2, 100), (2, 30), (2, 30), (3, 60)]) [220, 130, 60] >>> calculate_performance_scores(2, 4, [(1, 20), (1, 10), (1, 50), (2, 70)]) [80, 70] # Your code goes here from typing import List, Tuple def test_case_1(): n = 3 k = 8 submissions = [ (1, 50), (1, 90), (1, 80), (1, 50), (2, 100), (2, 30), (2, 30), (3, 60), ] assert calculate_performance_scores(n, k, submissions) == [220, 130, 60] def test_case_2(): n = 2 k = 4 submissions = [ (1, 20), (1, 10), (1, 50), (2, 70), ] assert calculate_performance_scores(n, k, submissions) == [80, 70] def test_case_3(): n = 4 k = 5 submissions = [ (1, 30), (2, 60), (2, 50), (3, 80), (4, 100), ] assert calculate_performance_scores(n, k, submissions) == [30, 110, 80, 100] def test_case_4(): n = 1 k = 6 submissions = [ (1, 10), (1, 20), (1, 30), (1, 40), (1, 40), (1, 50), ] assert calculate_performance_scores(n, k, submissions) == [120] def test_case_5(): n = 3 k = 3 submissions = [ (1, 100), (2, 40), (3, 70), ] assert calculate_performance_scores(n, k, submissions) == [100, 40, 70]","solution":"def calculate_performance_scores(n, k, submissions): from collections import defaultdict # Create a dictionary to store the scores for each participant participants_scores = defaultdict(set) # Iterate through the submissions to populate the scores for p, s in submissions: participants_scores[p].add(s) # Calculate the performance score for each participant performance_scores = [] for i in range(1, n + 1): scores = sorted(participants_scores[i], reverse=True) # Sort scores in descending order performance_scores.append(sum(scores[:3])) # Sum the top 3 highest distinct scores return performance_scores"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(node_list): Build a binary tree from a list of tuples. Each tuple contains a node's value, its left child's value, and its right child's value. # build the tree as described in the docstring pass def max_path_sum(node): Calculate the maximum path sum from root to leaf in a binary tree. # implement the max path sum logic pass def find_max_path_sum(node_list): Find the maximum path sum from root to leaf given a list of tuples representing a binary tree. >>> find_max_path_sum([(1, 2, 3), (2, 4, 5), (3, None, None), (4, None, None), (5, None, None)]) 8 >>> find_max_path_sum([(1, None, None)]) 1 >>> find_max_path_sum([(1, 2, None), (2, None, 3), (3, 4, None), (4, None, 5), (5, None, None)]) 15 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(node_list): if not node_list: return None nodes = {val: TreeNode(val) for val, left, right in node_list} for val, left, right in node_list: if left is not None: nodes[val].left = nodes[left] if right is not None: nodes[val].right = nodes[right] return nodes[node_list[0][0]] def max_path_sum(node): if not node: return 0 if not node.left and not node.right: return node.val if not node.left: return node.val + max_path_sum(node.right) if not node.right: return node.val + max_path_sum(node.left) left_sum = max_path_sum(node.left) right_sum = max_path_sum(node.right) return node.val + max(left_sum, right_sum) def find_max_path_sum(node_list): root = build_tree(node_list) return max_path_sum(root)"},{"question":"def single_occurrence_characters(s: str) -> int: Returns the number of distinct characters in the string that appear only once. >>> single_occurrence_characters(\\"hello\\") 3 >>> single_occurrence_characters(\\"aabbcc\\") 0 >>> single_occurrence_characters(\\"abcde\\") 5 >>> single_occurrence_characters(\\"\\") 0 >>> single_occurrence_characters(\\"ababcdcde\\") 1 >>> single_occurrence_characters(\\"a\\") 1 >>> single_occurrence_characters(\\"xyyzxw\\") 2","solution":"def single_occurrence_characters(s): Returns the number of distinct characters in the string that appear only once. from collections import Counter # Count all characters in the string char_count = Counter(s) # Get the number of characters that appear exactly once single_occurrence_count = sum(1 for count in char_count.values() if count == 1) return single_occurrence_count"},{"question":"from typing import List def shortest_paths(m: int, n: int, grid: List[str]) -> int or str: Find the number of distinct shortest paths in a grid from top-left to bottom-right. >>> shortest_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == 2 >>> shortest_paths(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) == \\"escape impossible\\"","solution":"from collections import deque def shortest_paths(m, n, grid): if grid[0][0] == '#' or grid[m-1][n-1] == '#': return \\"escape impossible\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = [[False] * n for _ in range(m)] visited[0][0] = True path_count = [[0] * n for _ in range(m)] path_count[0][0] = 1 distance = [[float('inf')] * n for _ in range(m)] distance[0][0] = 0 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '.' and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) distance[nx][ny] = distance[x][y] + 1 path_count[nx][ny] = path_count[x][y] elif 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '.' and distance[nx][ny] == distance[x][y] + 1: path_count[nx][ny] += path_count[x][y] if distance[m-1][n-1] == float('inf'): return \\"escape impossible\\" else: return path_count[m-1][n-1] # Example of usage # grid = [ # \\"...\\", # \\".#.\\", # \\"...\\" # ] # print(shortest_paths(3, 3, grid))"},{"question":"def kthHarmonicNumber(k): Calculate the k-th Harmonic Number rounded to 4 decimal places. Args: k: int - The position of the harmonic number to compute. Returns: float - The k-th harmonic number rounded to 4 decimal places. Examples: >>> kthHarmonicNumber(3) 1.8333 >>> kthHarmonicNumber(5) 2.2833 from solution import kthHarmonicNumber def test_harmonic_number_k_is_1(): assert kthHarmonicNumber(1) == 1.0000 def test_harmonic_number_k_is_2(): assert kthHarmonicNumber(2) == 1.5000 def test_harmonic_number_k_is_3(): assert kthHarmonicNumber(3) == 1.8333 def test_harmonic_number_k_is_4(): assert kthHarmonicNumber(4) == 2.0833 def test_harmonic_number_k_is_5(): assert kthHarmonicNumber(5) == 2.2833 def test_harmonic_number_high(): result = kthHarmonicNumber(1000000) assert abs(result - 14.3927) < 0.0001 # Ensuring precision to within 4 decimal places","solution":"def kthHarmonicNumber(k): Calculate the k-th Harmonic Number rounded to 4 decimal places. Args: k: int - The position of the harmonic number to compute. Returns: float - The k-th harmonic number rounded to 4 decimal places. harmonic_sum = 0.0 for i in range(1, k+1): harmonic_sum += 1 / i return round(harmonic_sum, 4)"},{"question":"def count_unique_words(text: str) -> int: Counts the number of unique words in the given text. A unique word is defined as a word that appears exactly once in the text. Parameters: text (str): The text to analyze. Returns: int: The number of unique words. >>> count_unique_words(\\"I love coding and I love learning.\\") 3 >>> count_unique_words(\\"hello hello world world\\") 0 >>> count_unique_words(\\"this is a test\\") 4 >>> count_unique_words(\\"Word word Unique word\\") 1 >>> count_unique_words(\\"\\") 0 >>> count_unique_words(\\"single\\") 1 >>> count_unique_words(\\"unique spaces here\\") 3","solution":"def count_unique_words(text): Counts the number of unique words in the given text. A unique word is defined as a word that appears exactly once in the text. Parameters: text (str): The text to analyze. Returns: int: The number of unique words. from collections import Counter # Convert text to lowercase and split into words words = text.lower().split() # Counting words using Counter word_count = Counter(words) # Filtering unique words unique_words = [word for word, count in word_count.items() if count == 1] return len(unique_words)"},{"question":"from typing import List def longest_increasing_subsequence(books: List[int]) -> int: Returns the length of the longest increasing subsequence of book thicknesses. >>> longest_increasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence([9, 8, 7, 6, 5]) 1 >>> longest_increasing_subsequence([1, 3, 2, 5, 4, 6, 1, 7]) 5","solution":"from bisect import bisect_left def longest_increasing_subsequence(books): Returns the length of the longest increasing subsequence of book thicknesses. if not books: return 0 # Initialize an empty list that will store the smallest ending value of # the increasing subsequence of each possible length. subseq_ends = [] for book in books: # Find the index where book would go in subseq_ends to maintain the sorted order pos = bisect_left(subseq_ends, book) # If pos is equal to length of subseq_ends, it means book can extend the longest subsequence if pos == len(subseq_ends): subseq_ends.append(book) else: # Otherwise, we replace the element at pos with book subseq_ends[pos] = book return len(subseq_ends)"},{"question":"from typing import List from collections import Counter def can_form_palindrome(s: str) -> str: Determines if the string s can be reordered to form a palindrome. Args: s (str): The input string consisting of lowercase letters and numbers. Returns: str: 'YES' if the string can be reordered to form a palindrome, otherwise 'NO'. >>> can_form_palindrome(\\"aabbcc\\") 'YES' >>> can_form_palindrome(\\"aabbc\\") 'YES' >>> can_form_palindrome(\\"aabcd\\") 'NO'","solution":"from collections import Counter def can_form_palindrome(s): Determines if the string s can be reordered to form a palindrome. Args: s (str): The input string consisting of lowercase letters and numbers. Returns: str: 'YES' if the string can be reordered to form a palindrome, otherwise 'NO'. count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) # A string can be rearranged to form a palindrome if at most one character occurs an odd number of times if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def minSwaps(A: str, B: str) -> int: Returns the minimum number of adjacent swaps required to transform string A into string B. If it's not possible, return -1. >>> minSwaps(\\"abac\\", \\"baca\\") 2 >>> minSwaps(\\"abc\\", \\"def\\") -1 >>> minSwaps(\\"abcd\\", \\"abcd\\") 0 >>> minSwaps(\\"ab\\", \\"ba\\") 1 >>> minSwaps(\\"a\\"*500 + \\"b\\"*500, \\"b\\"*500 + \\"a\\"*500) 250000 >>> minSwaps(\\"aaaabbbb\\", \\"aaaabbbb\\") 0 >>> minSwaps(\\"abcd\\", \\"dcba\\") 6 >>> minSwaps(\\"aabb\\", \\"bbaa\\") 4","solution":"def minSwaps(A, B): Returns the minimum number of adjacent swaps required to transform string A into string B. If it's not possible, return -1. if sorted(A) != sorted(B): return -1 n = len(A) swaps = 0 A = list(A) for i in range(n): if A[i] != B[i]: # Find index j where A[j] == B[i] j = i while j < n and A[j] != B[i]: j += 1 # Bring A[j] to A[i] by swapping adjacent elements while j > i: A[j], A[j-1] = A[j-1], A[j] j -= 1 swaps += 1 return swaps"},{"question":"from typing import List def min_replacements_to_make_symmetric(s: str) -> int: Given a string s consisting of lowercase English letters, this function returns the minimum number of characters that need to be replaced to make the string symmetric. >>> min_replacements_to_make_symmetric(\\"abca\\") 1 >>> min_replacements_to_make_symmetric(\\"racecar\\") 0 >>> min_replacements_to_make_symmetric(\\"abcd\\") 2 Unit Test: from solution import min_replacements_to_make_symmetric def test_example_1(): assert min_replacements_to_make_symmetric(\\"abca\\") == 1 def test_example_2(): assert min_replacements_to_make_symmetric(\\"racecar\\") == 0 def test_example_3(): assert min_replacements_to_make_symmetric(\\"abcd\\") == 2 def test_single_character(): assert min_replacements_to_make_symmetric(\\"a\\") == 0 def test_all_characters_different(): assert min_replacements_to_make_symmetric(\\"abcdef\\") == 3 def test_all_characters_same(): assert min_replacements_to_make_symmetric(\\"aaaaaa\\") == 0 def test_large_even_length(): assert min_replacements_to_make_symmetric(\\"abcdefghij\\" * 5000) == 25000 def test_large_odd_length(): assert min_replacements_to_make_symmetric(\\"abcdefghihgfedcba\\") == 0","solution":"def min_replacements_to_make_symmetric(s): Returns the minimum number of replacements required to make the string s symmetric. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"def keyword_analysis(keywords, documents): Determine the frequency of keywords across documents. Args: keywords : List[str] : list of keywords documents : List[str] : list of documents as strings Returns: List[int] : list of frequencies of each keyword in the same order as keywords list Examples: >>> keywords = [\\"keyword1\\", \\"keyword2\\", \\"keyword3\\"] >>> documents = [\\"this is a document containing keyword1 and another keyword1\\", \\"another document with keyword2\\"] >>> keyword_analysis(keywords, documents) [2, 1, 0] >>> keywords = [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> documents = [\\"apple banana\\", \\"banana cherry apple\\", \\"apple cherry banana\\"] >>> keyword_analysis(keywords, documents) [3, 3, 2] >>> keywords = [\\"dog\\", \\"cat\\", \\"mouse\\"] >>> documents = [\\"this document has no keywords\\", \\"neither does this one\\"] >>> keyword_analysis(keywords, documents) [0, 0, 0]","solution":"def keyword_analysis(keywords, documents): Returns a list of integers where each integer represents the frequency of the corresponding keyword in the keywords list across all documents. freq = [0] * len(keywords) for i, keyword in enumerate(keywords): for doc in documents: freq[i] += doc.split().count(keyword) return freq # Example usage: # keywords = [\\"keyword1\\", \\"keyword2\\", \\"keyword3\\"] # documents = [\\"this is a document containing keyword1 and another keyword1\\", # \\"another document with keyword2\\"] # print(keyword_analysis(keywords, documents)) # Output: [2, 1, 0]"},{"question":"def max_dishes(N, C, prices): Returns the maximum number of different dishes Chef can afford with his given budget. >>> max_dishes(5, 15, [1, 12, 5, 7, 3]) 3 >>> max_dishes(4, 10, [9, 8, 5, 2]) 2 def solve(T, test_cases): For each test case, determines the maximum number of different dishes Chef can afford with his given budget. >>> solve(2, [((5, 15), [1, 12, 5, 7, 3]), ((4, 10), [9, 8, 5, 2])]) [3, 2] >>> solve(2, [((5, 50), [1, 2, 3, 4, 5]), ((4, 20), [5, 4, 3, 2])]) [5, 4]","solution":"def max_dishes(N, C, prices): Returns the maximum number of different dishes Chef can afford with his given budget. Parameters: N (int): Number of dishes C (int): Number of coins Chef has prices (List[int]): List of prices of the dishes Returns: int: Maximum number of different dishes Chef can afford prices.sort() count = 0 for price in prices: if C >= price: count += 1 C -= price else: break return count def solve(T, test_cases): results = [] for case in test_cases: N, C = case[0] prices = case[1] results.append(max_dishes(N, C, prices)) return results"},{"question":"def determine_winner(n): Determines the winner of the game given the total sum n. Alice wins if n % 4 is not 0, otherwise Bob wins. Args: n (int): total sum to reach Returns: str: winner of the game >>> determine_winner(1) 'Alice' >>> determine_winner(4) 'Bob' pass def main(test_cases): Determines the winners for multiple test cases. Parameters: test_cases (list of int): List of integers representing multiple values of n. Returns: list of str: List of winners for each test case. >>> main([1, 2, 3]) ['Alice', 'Alice', 'Alice'] >>> main([4, 5, 6, 7, 8]) ['Bob', 'Alice', 'Alice', 'Alice', 'Bob'] pass","solution":"def determine_winner(n): Determines the winner of the game given the total sum n. Alice wins if n % 4 is not 0, otherwise Bob wins. if n % 4 == 0: return \\"Bob\\" else: return \\"Alice\\" def main(test_cases): Determines the winners for multiple test cases. Parameters: test_cases (list of int): List of integers representing multiple values of n. Returns: list of str: List of winners for each test case. results = [] for n in test_cases: results.append(determine_winner(n)) return results"},{"question":"def get_middle(s: str) -> str: Returns the middle character(s) of the string s. If the length of the string is odd, returns the middle character. If the length is even, returns the two middle characters. >>> get_middle(\\"testing\\") 't' >>> get_middle(\\"middle\\") 'dd' >>> get_middle(\\"A\\") 'A' >>> get_middle(\\"even\\") 've'","solution":"def get_middle(s): Returns the middle character(s) of the string s. If the length of the string is odd, returns the middle character. If the length is even, returns the two middle characters. length = len(s) if length % 2 == 0: # Length is even middle_index = length // 2 return s[middle_index - 1: middle_index + 1] else: # Length is odd middle_index = length // 2 return s[middle_index]"},{"question":"def minimum_adjustments(n: int, delivered: List[int], required: List[int]) -> int: Calculate the minimum number of adjustments needed to ensure each enclosure receives the correct meal portion. :param n: An integer representing the number of enclosures :param delivered: A list of integers representing the currently delivered portions :param required: A list of integers representing the required portions :return: An integer representing the minimum number of adjustments needed Examples: >>> minimum_adjustments(3, [5, 7, 6], [6, 8, 5]) 3 >>> minimum_adjustments(4, [3, 3, 3, 3], [3, 3, 3, 3]) 0 >>> minimum_adjustments(2, [1, 100000], [50000, 50000]) 99999 pass","solution":"def minimum_adjustments(n, delivered, required): This function calculates the minimum number of adjustments needed to ensure every enclosure receives the correct meal portion. :param n: An integer representing the number of enclosures :param delivered: A list of integers representing the currently delivered portions :param required: A list of integers representing the required portions :return: An integer representing the minimum number of adjustments needed total_adjustments = 0 for d, r in zip(delivered, required): total_adjustments += abs(d - r) return total_adjustments"},{"question":"def is_perfect_square(num: int) -> bool: Returns True if the given positive integer num is a perfect square, False otherwise. Uses a binary search algorithm for optimal time complexity. >>> is_perfect_square(16) # True >>> is_perfect_square(14) # False","solution":"def is_perfect_square(num): Returns True if the given positive integer num is a perfect square, False otherwise. Uses a binary search algorithm for optimal time complexity. if num < 1: return False left, right = 1, num while left <= right: mid = (left + right) // 2 square = mid * mid if square == num: return True elif square < num: left = mid + 1 else: right = mid - 1 return False"},{"question":"from typing import List def solve(arr: List[int], N: int) -> int: Given an array of integers of size N, find the length of the longest subarray which has an equal number of even and odd numbers. Args: arr : List[int] - input array of integers N : int - size of the array Returns: int - length of the longest subarray which has an equal number of even and odd numbers. Examples: >>> solve([1, 2, 3, 4, 5], 5) 4 >>> solve([1, 2, 1, 2, 1, 2], 6) 6 pass def test_solve_example1(): assert solve([1, 2, 3, 4, 5], 5) == 4 def test_solve_example2(): assert solve([1, 2, 1, 2, 1, 2], 6) == 6 def test_solve_all_even(): assert solve([2, 4, 6, 8], 4) == 0 def test_solve_all_odd(): assert solve([1, 3, 5, 7], 4) == 0 def test_solve_mixed_even_odd(): assert solve([1, 2, 3, 4], 4) == 4 assert solve([1, 2, 2, 1], 4) == 4 assert solve([1, 2, 3], 3) == 2 def test_solve_no_even_or_odd(): assert solve([1], 1) == 0 assert solve([2], 1) == 0","solution":"def solve(arr, N): Function to find the length of the longest subarray with equal number of even and odd numbers. # Replace elements with 1 for odd and -1 for even modified_arr = [1 if x % 2 != 0 else -1 for x in arr] # Dictionary to store the first occurrence of prefix sum prefix_sum_indices = {0: -1} # Initialize with prefix sum 0 at index -1 prefix_sum = 0 max_length = 0 for i in range(N): prefix_sum += modified_arr[i] if prefix_sum in prefix_sum_indices: max_length = max(max_length, i - prefix_sum_indices[prefix_sum]) else: prefix_sum_indices[prefix_sum] = i return max_length"},{"question":"def min_tools_required(n: int, m: int, k: int, grid: List[List[int]], tools: List[List[int]]) -> int: Determine the minimum number of tools required to clean every cell in the grid completely or if it's impossible to do so. >>> min_tools_required(4, 4, 3, [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ], [ ... [0, 0, 0, 0, 1, 0, 0, 0, 0], ... [1, 1, 1, 1, 1, 1, 1, 1, 1], ... [0, 1, 0, 1, 0, 1, 0, 1, 0] ... ]) == 4 >>> min_tools_required(2, 2, 1, [ ... [1, 1], ... [1, 1] ... ], [ ... [1, 1, 1, 1, 1, 1, 1, 1, 1] ... ]) == -1 >>> min_tools_required(3, 3, 1, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], [ ... [1, 1, 1, 1, 1, 1, 1, 1, 1] ... ]) == 1 >>> min_tools_required(3, 3, 2, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ], [ ... [1, 0, 1, 0, 1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0, 1, 0, 1, 0] ... ]) == 1","solution":"def min_tools_required(n, m, k, grid, tools): def apply_tool(grid, tool, x, y): for i in range(3): for j in range(3): if tool[i][j] == 1 and (0 <= x + i < n) and (0 <= y + j < m): grid[x + i][y + j] = 0 def is_clean(grid): return all(cell == 0 for row in grid for cell in row) def convert_tool(tool): return [tool[i:i + 3] for i in range(0, 9, 3)] tools = [convert_tool(tool) for tool in tools] import itertools min_tools_usage = float('inf') found_solution = False for tool_comb in itertools.product(tools, repeat=((n - 3 + 1) * (m - 3 + 1))): local_grid = [row[:] for row in grid] tool_count = 0 for t_index in range(len(tool_comb)): i, j = divmod(t_index, m - 2) if i + 2 < n and j + 2 < m: apply_tool(local_grid, tool_comb[t_index], i, j) tool_count += 1 if is_clean(local_grid): min_tools_usage = min(min_tools_usage, tool_count) found_solution = True break if not found_solution: return -1 return min_tools_usage # Reading input data def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) k = int(data[2]) grid = [] index = 3 for _ in range(n): grid.append(list(map(int, data[index:index + m]))) index += m tools = [] for _ in range(k): tools.append(list(map(int, data[index:index + 9]))) index += 9 print(min_tools_required(n, m, k, grid, tools)) if __name__ == \\"__main__\\": main()"},{"question":"import math from typing import List def lcm(x: int, y: int) -> int: Calculate the least common multiple (LCM) of two numbers. return (x * y) // math.gcd(x, y) def max_sum_after_operations(N: int) -> int: Function to compute the maximum possible sum of the sequence after performing the allowed operations. The allowed operations are: 1. Pick any two elements \`a\` and \`b\` from the sequence and replace them with their least common multiple (LCM). 2. Repeat this process any number of times. Parameters: N (int): An integer N (1  N  100). Returns: int: The maximum possible sum of the sequence after performing the operations. Examples: >>> max_sum_after_operations(4) 16 >>> max_sum_after_operations(6) 41","solution":"import math from functools import reduce from itertools import combinations def lcm(x, y): return (x * y) // math.gcd(x, y) def max_sum_after_operations(N): Function to compute the maximum possible sum of the sequence after performing the allowed operations. # Initial sequence sequence = list(range(1, N+1)) # As the provided example outputs are evaluated based on the highest possible values of the least common multiple, # we can consider doing pairwise least common multiple calculation in reverse manner. while len(sequence) > 1: max_lcm = 0 max_a, max_b = 0, 0 # Find the pair with the maximum lcm value for a, b in combinations(sequence, 2): current_lcm = lcm(a, b) if current_lcm > max_lcm: max_lcm = current_lcm max_a, max_b = a, b # Replace a and b with their lcm in the sequence sequence.remove(max_a) sequence.remove(max_b) sequence.append(max_lcm) # Sum of the final sequence return sum(sequence)"},{"question":"def factorial(n): Returns the factorial of a given number n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(10) == 3628800 # Your code here def compute_factorials(test_cases): Computes factorials for a list of test cases. :param test_cases: List of integers :return: List of factorials corresponding to the input numbers >>> compute_factorials([0, 5, 10]) == [1, 120, 3628800] >>> compute_factorials([1, 2, 3, 4]) == [1, 2, 6, 24] # Your code here","solution":"def factorial(n): Returns the factorial of a given number n. if n < 0 or n > 12: raise ValueError(\\"n should be in the range 0  n  12\\") result = 1 for i in range(2, n+1): result *= i return result def compute_factorials(test_cases): Computes factorials for a list of test cases. :param test_cases: List of integers :return: List of factorials corresponding to the input numbers return [factorial(n) for n in test_cases]"},{"question":"def parse_input(input_str: str): Parse the input string into test cases. >>> parse_input(\\"2n5 1 2 3 4 5 9n4 1 2 3 4 10\\") (2, [[5, 1, 2, 3, 4, 5, 9], [4, 1, 2, 3, 4, 10]]) input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] for line in input_lines[1:]: test_cases.append(list(map(int, line.split()))) return t, test_cases def three_sum_target(t: int, test_cases: list): Determine if there are three distinct numbers in the array that add up to the target value. >>> three_sum_target(2, [[5, 1, 2, 3, 4, 5, 9], [4, 1, 2, 3, 4, 10]]) [\\"YES\\", \\"NO\\"] results = [] for case in test_cases: n = case[0] array = case[1:-1] target = case[-1] found = False array.sort() for i in range(n - 2): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == target: found = True break elif current_sum < target: left += 1 else: right -= 1 if found: break results.append(\\"YES\\" if found else \\"NO\\") return results","solution":"def three_sum_target(t, test_cases): results = [] for case in test_cases: n = case[0] array = case[1:-1] target = case[-1] found = False array.sort() for i in range(n - 2): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == target: found = True break elif current_sum < target: left += 1 else: right -= 1 if found: break results.append(\\"YES\\" if found else \\"NO\\") return results def parse_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] for line in input_lines[1:]: test_cases.append(list(map(int, line.split()))) return t, test_cases"},{"question":"def longestContinuousIncreasingSubsequence(arr: List[int]) -> int: Given a sequence of integers, find the length of its longest strictly continuous increasing subsequence. >>> longestContinuousIncreasingSubsequence([1, 2, 3, 2, 3, 4, 5, 1]) 4 >>> longestContinuousIncreasingSubsequence([5, 6, 3, 5, 7, 8, 9]) 5 from typing import List def test_sample_input_0(): arr = [1, 2, 3, 2, 3, 4, 5, 1] assert longestContinuousIncreasingSubsequence(arr) == 4 def test_sample_input_1(): arr = [5, 6, 3, 5, 7, 8, 9] assert longestContinuousIncreasingSubsequence(arr) == 5 def test_single_element(): arr = [1] assert longestContinuousIncreasingSubsequence(arr) == 1 def test_all_equal_elements(): arr = [2, 2, 2, 2] assert longestContinuousIncreasingSubsequence(arr) == 1 def test_all_increasing_elements(): arr = [1, 2, 3, 4, 5] assert longestContinuousIncreasingSubsequence(arr) == 5 def test_all_decreasing_elements(): arr = [5, 4, 3, 2, 1] assert longestContinuousIncreasingSubsequence(arr) == 1 def test_empty_array(): arr = [] assert longestContinuousIncreasingSubsequence(arr) == 0 def test_alternating_elements(): arr = [1, 3, 2, 4, 3, 5] assert longestContinuousIncreasingSubsequence(arr) == 2","solution":"def longestContinuousIncreasingSubsequence(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def find_missing_number(n, sequence): Given n and a sequence of n-1 numbers, find the missing number in the range from 1 to n. >>> find_missing_number(5, [1, 2, 3, 5]) 4 >>> find_missing_number(3, [1, 3]) 2 def process_input(input_data): Process the input data and return the results for each test case. :param input_data: List of strings, the input data where the first element is the number of test cases and subsequent lines contain each test case as \\"N followed by N-1 integers\\" >>> process_input([\\"2\\", \\"5 1 2 3 5\\", \\"3 1 3\\"]) [4, 2] >>> process_input([\\"1\\", \\"4 1 3 4\\"]) [2]","solution":"def find_missing_number(n, sequence): Given n and a sequence of n-1 numbers, find the missing number in the range from 1 to n. total_sum = n * (n + 1) // 2 sequence_sum = sum(sequence) return total_sum - sequence_sum def process_input(input_data): Process the input data and return the results for each test case. :param input_data: List of strings, the input data where the first element is the number of test cases and subsequent lines contain each test case as \\"N followed by N-1 integers\\" results = [] T = int(input_data[0]) for i in range(1, T + 1): line = list(map(int, input_data[i].split())) N = line[0] sequence = line[1:] results.append(find_missing_number(N, sequence)) return results"},{"question":"from typing import List def find_missing_term(seq: List[int]) -> int: Finds the missing term in the given arithmetic progression sequence. >>> find_missing_term([2, 4, 8, 10]) 6 >>> find_missing_term([5, 15, 20, 25]) 10 pass def find_missing_term_in_test_cases(test_cases: List[List[int]]) -> List[int]: Finds the missing terms in the given arithmetic progression sequences. >>> find_missing_term_in_test_cases([[2, 4, 8, 10], [5, 15, 20, 25]]) [6, 10] pass","solution":"def find_missing_term(seq): Finds the missing term in the given arithmetic progression sequence. n = len(seq) total_sum = (n + 1) * (seq[0] + seq[-1]) // 2 actual_sum = sum(seq) return total_sum - actual_sum def find_missing_term_in_test_cases(test_cases): results = [] for case in test_cases: results.append(find_missing_term(case)) return results"},{"question":"def count_ways_to_install_pipes(d: int, k: int) -> int: Calculate the number of different ways to install exactly k water pipes between d houses. >>> count_ways_to_install_pipes(4, 2) 3 >>> count_ways_to_install_pipes(5, 2) 6 >>> count_ways_to_install_pipes(6, 3) 10 >>> count_ways_to_install_pipes(6, 4) 5 pass","solution":"def count_ways_to_install_pipes(d, k): from math import comb Calculate the number of different ways to install exactly k water pipes between d houses. :param d: int, the number of houses :param k: int, the maximum number of water pipes that can be installed :return: int, the number of different ways to install exactly k water pipes return comb(d-1, k)"},{"question":"from typing import List def alternating_sum(nums: List[int]) -> int: Returns the alternating sum of the elements in the list nums. >>> alternating_sum([1, 2, 3, 4, 5]) 3 >>> alternating_sum([10, 1, 1, 1, 10]) 19 >>> alternating_sum([0, 0, 0, 0, 0]) 0 >>> alternating_sum([5]) 5","solution":"def alternating_sum(nums): Returns the alternating sum of the elements in the list nums. result = 0 for i, num in enumerate(nums): if i % 2 == 0: result += num else: result -= num return result"},{"question":"from typing import List def is_palindrome(s: str) -> bool: Determine if a given string s is a valid palindrome considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A\\") == True >>> is_palindrome(\\"!!!\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"Able was I ere I saw Elba\\") == True","solution":"def is_palindrome(s): Determine if a given string s is a valid palindrome considering only alphanumeric characters and ignoring cases. # Convert to lower case and filter out non-alphanumeric characters filtered_chars = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def process_packet_logs(logs: List[str]) -> tuple: Processes the network packet logs and returns the total count of packets, the total bytes transferred, and a count of each protocol used. Args: logs (list of str): A list of packet log strings. Returns: tuple: A tuple containing the total packet count (int), the total bytes transferred (int), and a dictionary with counts of each protocol (dict). >>> process_packet_logs([\\"[2023-01-01 12:34:56] 192.168.0.1 -> 192.168.0.2 TCP 1500\\"]) == (1, 1500, {\\"ICMP\\": 0, \\"TCP\\": 1, \\"UDP\\": 0}) >>> process_packet_logs([\\"[2023-01-01 12:34:56] 192.168.0.1 -> 192.168.0.2 TCP 1500\\", \\"[2023-01-01 12:35:56] 192.168.0.1 -> 192.168.0.3 UDP 500\\", \\"[2023-01-01 12:36:56] 192.168.0.1 -> 192.168.0.2 ICMP 100\\", \\"[2023-01-01 12:37:56] 192.168.0.2 -> 192.168.0.3 ICMP 100\\"]) == (4, 2200, {\\"ICMP\\": 2, \\"TCP\\": 1, \\"UDP\\": 1}) >>> process_packet_logs([]) == (0, 0, {\\"ICMP\\": 0, \\"TCP\\": 0, \\"UDP\\": 0}) >>> process_packet_logs([\\"[2023-01-01 12:34:56] 192.168.0.1 -> 192.168.0.2 TCP 1500\\", \\"[2023-01-01 12:35:56] 192.168.0.1 -> 192.168.0.3 UDP 500\\"]) == (2, 2000, {\\"ICMP\\": 0, \\"TCP\\": 1, \\"UDP\\": 1}) >>> process_packet_logs([\\"[2023-01-01 12:34:56] 192.168.0.2 -> 192.168.0.3 ICMP 50\\", \\"[2023-01-01 12:35:56] 192.168.0.3 -> 192.168.0.4 ICMP 100\\"]) == (2, 150, {\\"ICMP\\": 2, \\"TCP\\": 0, \\"UDP\\": 0})","solution":"def process_packet_logs(logs): Processes the network packet logs and returns the total count of packets, the total bytes transferred, and a count of each protocol used. Args: logs (list of str): A list of packet log strings. Returns: tuple: A tuple containing the total packet count (int), the total bytes transferred (int), and a dictionary with counts of each protocol (dict). packet_count = 0 total_bytes = 0 protocol_count = {'ICMP': 0, 'TCP': 0, 'UDP': 0} for log in logs: parts = log.split() protocol = parts[-2] length = int(parts[-1]) packet_count += 1 total_bytes += length if protocol in protocol_count: protocol_count[protocol] += 1 return packet_count, total_bytes, protocol_count"},{"question":"def minimum_streetlights(L, d, M): Determine the minimum number of streetlights required or if it is impossible to place the required streetlights. Parameters: L (int): The length of the highway. d (int): The minimum distance between consecutive streetlights. M (int): The maximum number of streetlights allowed. Returns: int or str: The minimum number of streetlights required or 'Impossible'. Examples: >>> minimum_streetlights(10, 3, 5) 4 >>> minimum_streetlights(15, 5, 2) 'Impossible' >>> minimum_streetlights(20, 4, 6) 6 >>> minimum_streetlights(10, 2, 6) 6 >>> minimum_streetlights(8, 3, 6) 3 >>> minimum_streetlights(30, 10, 2) 'Impossible'","solution":"def minimum_streetlights(L, d, M): Returns the minimum number of streetlights required to meet the conditions or 'Impossible' if it is not possible. Parameters: L (int): The length of the highway. d (int): The minimum distance between consecutive streetlights. M (int): The maximum number of streetlights allowed. Returns: int or str: Minimum number of streetlights required or 'Impossible'. # The minimum number of streetlights needed streetlights_needed = (L // d) + 1 # Check if the number of streetlights needed is less than or equal to the allowed maximum if streetlights_needed <= M: return streetlights_needed else: return \\"Impossible\\""},{"question":"def can_form_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if it is possible to delete a subset of the edges such that the graph becomes a tree (connected and acyclic). Parameters: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): List of edges in the graph. Returns: str: \\"YES\\" if it is possible to delete some edges to form a tree, otherwise \\"NO\\". >>> can_form_tree(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\" >>> can_form_tree(4, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 1)]) \\"NO\\"","solution":"def can_form_tree(n, m, edges): Determines if it is possible to delete a subset of the edges such that the graph becomes a tree (connected and acyclic). Args: n (int): Number of nodes m (int): Number of edges edges (List[Tuple[int, int]]): List of edges Returns: str: \\"YES\\" if it is possible to delete some edges to form a tree, otherwise \\"NO\\" from collections import defaultdict if m < n - 1: return \\"NO\\" parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False for u, v in edges: if not union(u - 1, v - 1): return \\"NO\\" root_count = len(set(find(i) for i in range(n))) return \\"YES\\" if root_count == 1 else \\"NO\\""},{"question":"def max_locations_visited(weights: List[int], limits: List[int]) -> int: Determines the maximum number of locations the truck can visit given package weights and location limits. Args: weights (list): List of integers representing the weights of the packages. limits (list): List of integers representing the weight limits of the locations. Returns: int: Maximum number of locations the truck can visit. >>> max_locations_visited([4, 2, 5, 1, 3], [7, 3, 6]) 3 >>> max_locations_visited([1, 1, 1, 1], [2, 2, 2, 2]) 4 >>> max_locations_visited([10, 20, 30], [40, 5, 60]) 2 >>> max_locations_visited([2, 2, 2], [3, 3, 3]) 3 >>> max_locations_visited([1, 2, 3], [1, 2, 2]) 2 >>> max_locations_visited([9, 8, 7], [7, 8, 9]) 3 >>> max_locations_visited([5, 5, 5], [5, 5, 5]) 3 >>> max_locations_visited([1, 2, 2], [1, 1, 3, 3]) 3 >>> max_locations_visited([], [1, 2, 3]) 0 >>> max_locations_visited([1, 2, 3], []) 0","solution":"def max_locations_visited(weights, limits): Determines the maximum number of locations the truck can visit given package weights and location limits. Args: weights (list): List of integers representing the weights of the packages. limits (list): List of integers representing the weight limits of the locations. Returns: int: Maximum number of locations the truck can visit. # Sort the weights and limits in ascending order weights.sort() limits.sort() i, j = 0, 0 visited = 0 # Use two pointers to iterate through the weights and limits arrays while i < len(weights) and j < len(limits): if weights[i] <= limits[j]: # If current package weight can be added to current location's limit visited += 1 i += 1 j += 1 else: # Move to the next location, current package is too heavy j += 1 return visited"},{"question":"from itertools import permutations def is_palindrome(s: str) -> bool: Check if the given string s is a palindrome. >>> is_palindrome(\\"aba\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"abc\\") False pass def unique_palindrome_permutations(word: str) -> int: Generate all unique permutations of the given word and count how many of them are palindromes. >>> unique_palindrome_permutations(\\"aab\\") 1 >>> unique_palindrome_permutations(\\"racecar\\") 6 >>> unique_palindrome_permutations(\\"abc\\") 0 pass def count_palindrome_permutations(test_cases: list) -> list: Process a list of test cases and return the count of unique palindrome permutations for each word. >>> count_palindrome_permutations([\\"aab\\", \\"racecar\\", \\"abc\\"]) [1, 6, 0] >>> count_palindrome_permutations([\\"aaa\\", \\"aabb\\", \\"xyz\\"]) [1, 2, 0] pass","solution":"from itertools import permutations def is_palindrome(s): Check if the given string s is a palindrome. return s == s[::-1] def unique_palindrome_permutations(word): Generate all unique permutations of the given word and count how many of them are palindromes. permut_set = set(permutations(word)) palindrome_perms = [\\"\\".join(p) for p in permut_set if is_palindrome(\\"\\".join(p))] return len(palindrome_perms) def count_palindrome_permutations(test_cases): Process a list of test cases and return the count of unique palindrome permutations for each word. results = [] for word in test_cases: count = unique_palindrome_permutations(word) results.append(count) return results"},{"question":"def is_perfect_number(n: int) -> str: Determines if a given number n is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding itself). :param n: Integer to check (1 <= n <= 10^5) :return: \\"YES\\" if n is a perfect number, otherwise \\"NO\\" >>> is_perfect_number(6) \\"YES\\" >>> is_perfect_number(28) \\"YES\\" >>> is_perfect_number(12) \\"NO\\" >>> is_perfect_number(1) \\"NO\\"","solution":"def is_perfect_number(n): Determines if a given number n is a perfect number. A perfect number is a number that is equal to the sum of its proper divisors, excluding itself. :param n: Integer to check :return: \\"YES\\" if n is a perfect number, otherwise \\"NO\\" if n <= 1: return \\"NO\\" sum_of_divisors = sum(i for i in range(1, n) if n % i == 0) return \\"YES\\" if sum_of_divisors == n else \\"NO\\""},{"question":"def find_indices(nums, target): Write a function that accepts an array of integers and a target integer. The function should return the indices of the two numbers in the array that add up to the target. :param nums: List[int] - list of integers :param target: int - target sum :return: List[int] - indices of the two numbers >>> find_indices([2, 7, 11, 15], 9) #=> [0, 1] >>> find_indices([3, 2, 4], 6) #=> [1, 2] >>> find_indices([3, 3], 6) #=> [0, 1] >>> find_indices([-1, -2, -3, -4, -5], -8) #=> [2, 4] >>> find_indices([1, 0, -1], -1) #=> [1, 2]","solution":"def find_indices(nums, target): Returns the indices of the two numbers in the array that add up to the target. :param nums: List[int] - list of integers :param target: int - target sum :return: List[int] - indices of the two numbers num_indices = {} for index, num in enumerate(nums): complement = target - num if complement in num_indices: return [num_indices[complement], index] num_indices[num] = index"},{"question":"def min_operations_to_level_terrain(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Compute the minimum number of operations needed to make all the cells in the grid have the same height. Parameters: t (int): Number of test cases. test_cases (List[Dict[str, Any]]): List of dictionaries containing test case information, each with keys 'm' (number of rows), 'n' (number of columns) and 'grid' (2D list of heights). Returns: List[int]: List of integers representing the minimum number of operations needed for each test case. Example: >>> min_operations_to_level_terrain(2, [{'m': 3, 'n': 3, 'grid': [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {'m': 2, 'n': 2, 'grid': [[1, 2], [3, 4]]}]) [3, 2]","solution":"def min_operations_to_level_terrain(t, test_cases): results = [] for case in test_cases: m, n, grid = case['m'], case['n'], case['grid'] max_height = 0 unique_heights = set() for row in grid: for height in row: unique_heights.add(height) if height > max_height: max_height = height results.append(len(unique_heights) - 1) return results # Example usage: t = 2 test_cases = [ {'m': 3, 'n': 3, 'grid': [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {'m': 2, 'n': 2, 'grid': [[1, 2], [3, 4]]} ] print(min_operations_to_level_terrain(t, test_cases)) # Should output [3, 2]"},{"question":"from typing import List def shortest_path(grid: List[str]) -> int: Find the shortest path from the top-left cell to the bottom-right cell in the given grid. >>> shortest_path([ ... \\"....\\", ... \\".#a.\\", ... \\"a#\\", ... \\"....\\" ... ]) 6 >>> shortest_path([ ... \\".#.\\", ... \\"#\\", ... \\"...\\" ... ]) -1 >>> shortest_path([ ... \\".....\\", ... \\".#.\\", ... \\".#.#.\\", ... \\".#...\\", ... \\".....\\" ... ]) 8 >>> shortest_path([ ... \\".\\" ... ]) 0 >>> shortest_path([ ... \\"a....\\", ... \\".#.b.\\", ... \\"a.#\\", ... \\"b#.\\", ... \\".....\\" ... ]) 7 >>> shortest_path([ ... \\"a....\\", ... \\".#.#.\\", ... \\"a.#\\", ... \\"b#.\\", ... \\".b...\\" ... ]) -1","solution":"from collections import deque, defaultdict def shortest_path(grid): n = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (n-1, n-1) wormholes = defaultdict(list) for i in range(n): for j in range(n): if grid[i][j].isalpha(): wormholes[grid[i][j]].append((i, j)) queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) if grid[x][y].isalpha(): for wx, wy in wormholes[grid[x][y]]: if (wx, wy) != (x, y) and (wx, wy) not in visited: visited.add((wx, wy)) queue.append((wx, wy, dist)) # Clear the wormholes once used wormholes[grid[x][y]] = [] return -1"},{"question":"def dailyTemperatures(T): Calculate the number of days until a warmer temperature for each day. Parameters: T (List[int]): List of daily temperatures. Returns: List[int]: List of days to wait until a warmer temperature. pass from solution import dailyTemperatures def test_daily_temperatures_example1(): assert dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] def test_daily_temperatures_example2(): assert dailyTemperatures([30, 40, 50, 60, 70]) == [1, 1, 1, 1, 0] def test_daily_temperatures_example3(): assert dailyTemperatures([90, 80, 70]) == [0, 0, 0] def test_daily_temperatures_single_day(): assert dailyTemperatures([50]) == [0] def test_daily_temperatures_all_same(): assert dailyTemperatures([50, 50, 50, 50]) == [0, 0, 0, 0] def test_daily_temperatures_increasing(): assert dailyTemperatures([20, 30, 40, 50, 60]) == [1, 1, 1, 1, 0] def test_daily_temperatures_decreasing(): assert dailyTemperatures([100, 90, 80, 70, 60]) == [0, 0, 0, 0, 0] def test_daily_temperatures_alternating(): assert dailyTemperatures([30, 60, 30, 60, 30]) == [1, 0, 1, 0, 0] def test_daily_temperatures_large_input(): import random import time T = [random.randint(-100, 100) for _ in range(30000)] start_time = time.time() dailyTemperatures(T) duration = time.time() - start_time assert duration < 2 # Ensure the large input is handled in reasonable time","solution":"def dailyTemperatures(T): Calculate the number of days until a warmer temperature for each day. Parameters: T (List[int]): List of daily temperatures. Returns: List[int]: List of days to wait until a warmer temperature. # Initialize the result array with all zeros res = [0] * len(T) # Create a stack to store indices of the temperatures list stack = [] # Iterate over temperatures for i, temp in enumerate(T): # While stack is not empty and the current temperature is greater than the temperature at the index on the top of the stack while stack and temp > T[stack[-1]]: # Pop the index from the stack prev_index = stack.pop() # Calculate the difference in days between the current index and the index from stack res[prev_index] = i - prev_index # Push the current index onto the stack stack.append(i) return res"},{"question":"def longest_consecutive_subsequence_length(N: int, sequence: List[int]) -> int: Returns the length of the longest consecutive subsequence of identical numbers. >>> longest_consecutive_subsequence_length(7, [1, 2, 2, 2, 3, 3, 4]) 3 >>> longest_consecutive_subsequence_length(10, [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) 10 >>> longest_consecutive_subsequence_length(5, [1, 2, 3, 4, 5]) 1 >>> longest_consecutive_subsequence_length(1, [1]) 1 >>> longest_consecutive_subsequence_length(0, []) 0","solution":"def longest_consecutive_subsequence_length(N, sequence): Returns the length of the longest consecutive subsequence of identical numbers. if N == 0: return 0 max_length = 1 current_length = 1 for i in range(1, N): if sequence[i] == sequence[i-1]: current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def longest_consistent_subsequence(N, K, array): Returns the length of the longest consistent subsequence. Args: N : int : number of elements in the array K : int : maximum allowed difference between the maximum and minimum element in the subsequence array : list[int] : list of integers representing the elements of the array Returns: int : length of the longest consistent subsequence Example: >>> longest_consistent_subsequence(5, 3, [1, 3, 6, 10, 15]) 2 >>> longest_consistent_subsequence(5, 0, [1, 1, 1, 1, 1]) 5 >>> longest_consistent_subsequence(5, 15, [1, 3, 6, 10, 15]) 5 >>> longest_consistent_subsequence(5, 1, [10, 20, 30, 40, 50]) 1 >>> longest_consistent_subsequence(6, 1000000000, [1, 2, 3, 4, 5, 1000000000]) 6 >>> longest_consistent_subsequence(4, 3, [1000000000, 1000000001, 1000000002, 1000000003]) 4 pass # Implement the function here","solution":"def longest_consistent_subsequence(N, K, array): Returns the length of the longest consistent subsequence. Args: N : int : number of elements in the array K : int : maximum allowed difference between the maximum and minimum element in the subsequence array : list[int] : list of integers representing the elements of the array Returns: int : length of the longest consistent subsequence array.sort() left = 0 max_length = 0 for right in range(N): # Move the left pointer to maintain the condition max(array[left:right+1]) - min(array[left:right+1]) <= K while array[right] - array[left] > K: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def tickets_left(T: int, N: int, D: List[int]) -> int: Calculate the number of tickets left after N hours. :param int T: Initial number of tickets. :param int N: Number of hours. :param list D: Demand pattern represented as a list of integers. :return: The number of tickets left after N hours or 0 if tickets run out. :rtype: int >>> tickets_left(100, 5, [10, 20, 30, 10, 15]) == 15 >>> tickets_left(50, 3, [20, 20, 10]) == 0","solution":"def tickets_left(T, N, D): Calculate the number of tickets left after N hours. :param int T: Initial number of tickets. :param int N: Number of hours. :param list D: Demand pattern represented as a list of integers. :return: The number of tickets left after N hours or 0 if tickets run out. :rtype: int for demand in D: T -= demand if T <= 0: return 0 return T"},{"question":"def minPathSum(grid): Given a grid of size n x m filled with non-negative integers, find the minimal path sum from the top-left corner to the bottom-right corner. You can only move to the right or down at any point in time. The minimal path sum is defined as the sum of the values of the cells along the path from the top-left to the bottom-right corner. >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 2], ... [1, 1] ... ]) 3 >>> minPathSum([ ... [0] ... ]) 0 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21","solution":"def minPathSum(grid): n = len(grid) m = len(grid[0]) # Initialize DP table dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"def can_split_into_equal_parts(n: int, coins: List[int]) -> str: You are given an array of positive integers, which represents values of coins in a collection. Determine if you can split the collection into two non-empty parts such that the sum of the coin values in both parts is the same. Args: n (int): The number of coins in the collection. coins (List[int]): List of integers representing the coin values. Returns: str: \\"YES {x}\\" if possible to split into two parts with equal sum, otherwise \\"NO\\" Example: >>> can_split_into_equal_parts(6, [1, 2, 3, 3, 2, 1]) \\"YES 3\\" >>> can_split_into_equal_parts(3, [1, 2, 5]) \\"NO\\" from typing import List def test_example(): assert can_split_into_equal_parts(6, [1, 2, 3, 3, 2, 1]) == \\"YES 3\\" def test_no_possible_split(): assert can_split_into_equal_parts(3, [1, 2, 5]) == \\"NO\\" def test_all_equal_parts(): assert can_split_into_equal_parts(4, [2, 2, 2, 2]) == \\"YES 2\\" def test_single_element(): assert can_split_into_equal_parts(1, [1]) == \\"NO\\" def test_even_sum_partition_with_repeaties(): assert can_split_into_equal_parts(6, [1, 1, 1, 1, 1, 1]) == \\"YES 3\\" def test_large_array_with_valid_split(): array = [100, 200, 300, 400, 400, 300, 200, 100] assert can_split_into_equal_parts(8, array) == \\"YES 4\\" def test_odd_sum_no_partition(): assert can_split_into_equal_parts(5, [1, 1, 1, 1, 1]) == \\"NO\\"","solution":"def can_split_into_equal_parts(n, coins): total_sum = sum(coins) if total_sum % 2 != 0: return \\"NO\\" half_sum = total_sum // 2 current_sum = 0 for i in range(n): current_sum += coins[i] if current_sum == half_sum: return f\\"YES {i + 1}\\" return \\"NO\\""},{"question":"def is_palindrome(s): Check if a given string is a palindrome. >>> is_palindrome(\\"121\\") True >>> is_palindrome(\\"123\\") False pass # Replace with your solution def next_palindrome(N): Find the smallest palindrome greater than the given number. >>> next_palindrome(\\"123\\") \\"131\\" >>> next_palindrome(\\"898\\") \\"909\\" pass # Replace with your solution def smallest_palindromes(test_cases): Find the smallest palindrome greater than the given numbers. >>> smallest_palindromes([\\"123\\", \\"898\\", \\"2001\\"]) [\\"131\\", \\"909\\", \\"2002\\"] pass # Replace with your solution def process_input(t, test_cases): Process the input and compute the smallest palindromes for each test case. >>> process_input(3, [\\"123\\", \\"898\\", \\"2001\\"]) [\\"131\\", \\"909\\", \\"2002\\"] pass # Replace with your solution","solution":"def is_palindrome(s): return s == s[::-1] def next_palindrome(N): N = str(int(N) + 1) while not is_palindrome(N): N = str(int(N) + 1) return N def smallest_palindromes(test_cases): results = [] for N in test_cases: results.append(next_palindrome(N)) return results def process_input(t, test_cases): return smallest_palindromes(test_cases)"},{"question":"def count_central_intersections(n: int, m: int) -> int: Count the number of 'central intersections' in an n x m grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. Returns: int: number of central intersections. >>> count_central_intersections(4, 4) 4 >>> count_central_intersections(5, 5) 1 >>> count_central_intersections(6, 6) 4 >>> count_central_intersections(5, 4) 0 >>> count_central_intersections(4, 5) 0 # Unit tests def test_odd_x_odd_grid(): assert count_central_intersections(5, 5) == 1 assert count_central_intersections(3, 3) == 1 assert count_central_intersections(1, 1) == 1 def test_even_x_even_grid(): assert count_central_intersections(4, 4) == 4 assert count_central_intersections(6, 6) == 4 assert count_central_intersections(10, 10) == 4 def test_odd_x_even_grid(): assert count_central_intersections(5, 4) == 0 assert count_central_intersections(7, 2) == 0 def test_even_x_odd_grid(): assert count_central_intersections(4, 5) == 0 assert count_central_intersections(8, 3) == 0 def test_edge_cases(): assert count_central_intersections(1, 1000) == 0 assert count_central_intersections(1000, 1) == 0 assert count_central_intersections(1000, 1000) == 4 assert count_central_intersections(999, 999) == 1","solution":"def count_central_intersections(n, m): Counts the number of 'central intersections' in an n x m grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. Returns: int: number of central intersections. if n % 2 == 0 and m % 2 == 0: return 4 # For even x even grid, there are 4 central intersections. elif n % 2 == 1 and m % 2 == 1: return 1 # For odd x odd grid, there is 1 central intersection. else: return 0 # For odd x even or even x odd grid, there are no central intersections."},{"question":"from typing import List, Dict, Any def create_filesystem(paths: List[str]) -> Dict[str, Any]: Create a nested dictionary structure from a list of path strings. >>> create_filesystem([ ... \\"folder1/folder2/file1\\", ... \\"folder1/file2\\", ... \\"folder3/file3\\", ... \\"folder1/folder2/folder3/file4\\" ... ]) {\\"folder1\\": {\\"folder2\\": {\\"file1\\": None, \\"folder3\\": {\\"file4\\": None}}, \\"file2\\": None}, \\"folder3\\": {\\"file3\\": None}} >>> create_filesystem([\\"file1\\", \\"file2\\", \\"folder/file3\\"]) {\\"file1\\": None, \\"file2\\": None, \\"folder\\": {\\"file3\\": None}} >>> create_filesystem([]) {} >>> create_filesystem([\\"a/b/c/d/e/f/g/file\\"]) {\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": {\\"f\\": {\\"g\\": {\\"file\\": None}}}}}}}} pass","solution":"from typing import List, Dict, Any def create_filesystem(paths: List[str]) -> Dict[str, Any]: def insert_path(tree, path_parts): for part in path_parts[:-1]: if part not in tree: tree[part] = {} tree = tree[part] tree[path_parts[-1]] = None filesystem = {} for path in paths: path_parts = path.split('/') insert_path(filesystem, path_parts) return filesystem"},{"question":"def maxProductPair(N: int, A: List[int]) -> List[int]: You are given an array of integers A[] of size N. You need to find a pair of integers (A[i], A[j]) such that the product of A[i] and A[j] is maximum among all pairs. If there is more than one such pair with the same product, choose the pair with the smallest i. Return the indices i and j of this pair in the form of a list [i, j]. Example 1: >>> maxProductPair(5, [1, 20, 3, 4, 5]) == [1, 4] Example 2: >>> maxProductPair(4, [10, 2, 5, 2]) == [0, 2]","solution":"def maxProductPair(N, A): Returns the indices of the pair whose product is maximum. max_i = 0 max_j = 1 max_product = A[0] * A[1] for i in range(N): for j in range(i + 1, N): product = A[i] * A[j] if product > max_product or (product == max_product and i < max_i): max_product = product max_i = i max_j = j return [max_i, max_j]"},{"question":"def unique_bib_number(registration_number: int) -> int: Converts registration number into a unique bib number by summing its digits until a single digit is obtained. while registration_number >= 10: registration_number = sum(int(digit) for digit in str(registration_number)) return registration_number def get_bib_numbers(participants: List[int]) -> List[int]: Receives a list of registration numbers and returns their unique bib numbers. def test_unique_bib_number(): assert unique_bib_number(9875) == 2 assert unique_bib_number(123) == 6 assert unique_bib_number(45678) == 3 assert unique_bib_number(1) == 1 assert unique_bib_number(999999) == 9 # Further tests with larger numbers assert unique_bib_number(0) == 0 # Test edge case where number is zero def test_get_bib_numbers(): assert get_bib_numbers([9875, 123, 45678, 1]) == [2, 6, 3, 1] assert get_bib_numbers([11111, 222, 3333]) == [5, 6, 3]","solution":"def unique_bib_number(registration_number): Converts registration number into a unique bib number by summing its digits until a single digit is obtained. while registration_number >= 10: registration_number = sum(int(digit) for digit in str(registration_number)) return registration_number def get_bib_numbers(participants): Receives a list of registration numbers and returns their unique bib numbers. return [unique_bib_number(n) for n in participants]"},{"question":"def find_duplicate_isbn_counts(test_cases): Finds and counts how many duplicate ISBN numbers exist in the inventory for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of N ISBNs Returns: List[int]: A list containing the count of duplicate ISBN numbers for each test case. >>> find_duplicate_isbn_counts([(6, [9781234567897, 9781234567897, 9780544003415, 9780345816023, 9780544003415, 9780984782857])]) [2] >>> find_duplicate_isbn_counts([(4, [9783161484100, 9783161484100, 9783161484100, 9783161484100])]) [3]","solution":"def find_duplicate_isbn_counts(test_cases): results = [] for case in test_cases: N, isbns = case isbn_count = {} for isbn in isbns: if isbn in isbn_count: isbn_count[isbn] += 1 else: isbn_count[isbn] = 1 duplicates = sum(count - 1 for count in isbn_count.values() if count > 1) results.append(duplicates) return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 isbns = list(map(int, data[index:index + N])) test_cases.append((N, isbns)) index += N results = find_duplicate_isbn_counts(test_cases) for result in results: print(result)"},{"question":"from typing import List def process_stack_operations(datasets: List[List[str]]) -> List[int]: Processes a list of datasets containing stack operations and returns the results of \\"Max\\" operations. >>> process_stack_operations([[\\"Push 1\\", \\"Push 2\\", \\"Max\\", \\"Pop\\", \\"Max\\"], [\\"Push 10\\", \\"Max\\", \\"Push 5\\", \\"Max\\"]]) == [2, 1, 10, 10] >>> process_stack_operations([[\\"Push 5\\", \\"Push 3\\", \\"Max\\", \\"Pop\\", \\"Max\\", \\"Push 7\\", \\"Max\\"]]) == [5, 5, 7] pass def parse_input(input_data: str) -> List[List[str]]: Parses the input into datasets. >>> parse_input(\\"5nPush 1nPush 2nMaxnPopnMaxn4nPush 10nMaxnPush 5nMaxn-\\") == [[5, [\\"Push 1\\", \\"Push 2\\", \\"Max\\", \\"Pop\\", \\"Max\\"]], [4, [\\"Push 10\\", \\"Max\\", \\"Push 5\\", \\"Max\\"]]] >>> parse_input(\\"3nPush 10nMaxnPopn-\\") == [[3, [\\"Push 10\\", \\"Max\\", \\"Pop\\"]]] pass","solution":"def process_stack_operations(datasets): Processes a list of datasets containing stack operations and prints the results of \\"Max\\" operations. results = [] for dataset in datasets: stack = [] max_stack = [] for operation in dataset: if operation.startswith(\\"Push\\"): _, x = operation.split() x = int(x) stack.append(x) if not max_stack or x > max_stack[-1]: max_stack.append(x) else: max_stack.append(max_stack[-1]) elif operation == \\"Pop\\": if stack: stack.pop() max_stack.pop() elif operation == \\"Max\\": if stack: results.append(max_stack[-1]) return results def parse_input(input_data): Parses the input into datasets. datasets = [] dataset = [] lines = input_data.strip().split('n') for line in lines: if line == \\"-\\": if dataset: datasets.append(dataset) break elif line.isdigit(): if dataset: datasets.append(dataset) dataset = [] else: dataset.append(line) return datasets"},{"question":"def max_water_delivery(n: int, m: int, edges: List[Tuple[int, int, int]], t: int) -> int: Compute the maximum amount of water that can be delivered from the reservoir to a specified target farm. Parameters: n (int): Number of nodes (including the reservoir and all farms). m (int): Number of canal segments. edges (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, and c representing a canal segment from node u to node v with maximum flow capacity c. t (int): The target farm node. Returns: int: The maximum water flow that can be delivered from the reservoir to the target farm. Examples: >>> max_water_delivery(4, 5, [(1, 2, 40), (1, 3, 20), (2, 3, 10), (2, 4, 30), (3, 4, 20)], 4) 50 >>> max_water_delivery(3, 3, [(1, 2, 100), (1, 3, 50), (2, 3, 50)], 3) 100 >>> max_water_delivery(3, 2, [(1, 2, 10), (2, 3, 5)], 4) 0 >>> max_water_delivery(2, 1, [(1, 2, 50)], 2) 50 >>> max_water_delivery(6, 7, [(1, 2, 10), (1, 3, 10), (2, 4, 10), (2, 5, 5), (3, 5, 15), (4, 6, 10), (5, 6, 10)], 6) 20 pass","solution":"from collections import defaultdict, deque def bfs_capacity(graph, source, sink, parent): Breadth-First Search to find if there is a path from source to sink in residual graph. If there is a path, return True and fills parent to store the path. visited = [False] * len(graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(graph[u]): if visited[v] == False and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def edmonds_karp_max_flow(graph, source, sink): Implementation of Edmonds-Karp to find maximum flow in the given graph. parent = [-1] * len(graph) max_flow = 0 while bfs_capacity(graph, source, sink, parent): path_flow = float(\\"Inf\\") s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def max_water_delivery(n, m, edges, t): Finds the maximum amount of water that can be delivered from the reservoir (node 1) to the target farm (node t) using the given edges. # Create the graph graph = [[0] * (n + 1) for _ in range(n + 1)] for u, v, c in edges: graph[u][v] += c # Adding capacities for parallel edges # Run Edmonds-Karp to find max flow from source (1) to target (t) return edmonds_karp_max_flow(graph, 1, t) # --- Example Usage --- # Input # n = 4 # m = 5 # edges = [ # (1, 2, 40), # (1, 3, 20), # (2, 3, 10), # (2, 4, 30), # (3, 4, 20) # ] # t = 4 # Output # print(max_water_delivery(n, m, edges, t)) # Output: 50"},{"question":"def update_traffic_density(n: int, initial_states: List[int], m: int, events: List[str]) -> List[int]: Updates the effective traffic density at intersections based on the given events. Parameters: - n: int, number of intersections - initial_states: list of int, initial number of vehicles at each intersection - m: int, number of events - events: list of strings, describing the events Returns: - list of int, final number of vehicles at each intersection >>> update_traffic_density(4, [10, 20, 30, 40], 5, [\\"entry 1 10\\", \\"departure 2 5\\", \\"entry 3 15\\", \\"departure 4 20\\", \\"entry 1 5\\"]) [25, 15, 45, 20] >>> update_traffic_density(2, [0, 1000000], 2, [\\"entry 1 1000000\\", \\"departure 2 1000000\\"]) [1000000, 0] from solution import update_traffic_density def test_single_event_entry(): # Initial state: [10] # Event: entry 1 5 assert update_traffic_density(1, [10], 1, [\\"entry 1 5\\"]) == [15] def test_single_event_departure(): # Initial state: [20] # Event: departure 1 5 assert update_traffic_density(1, [20], 1, [\\"departure 1 5\\"]) == [15] def test_multiple_intersections(): # Initial state: [10, 20, 30, 40] # Events: # - entry 1 10 -> [20, 20, 30, 40] # - departure 2 5 -> [20, 15, 30, 40] # - entry 3 15 -> [20, 15, 45, 40] # - departure 4 20 -> [20, 15, 45, 20] # - entry 1 5 -> [25, 15, 45, 20] assert update_traffic_density(4, [10, 20, 30, 40], 5, [\\"entry 1 10\\", \\"departure 2 5\\", \\"entry 3 15\\", \\"departure 4 20\\", \\"entry 1 5\\"]) == [25, 15, 45, 20] def test_boundary_conditions(): # Testing edge boundaries # Initial state: [0, 1_000_000] # Events: # - entry 1 1_000_000 -> [1_000_000, 1_000_000] # - departure 2 1_000_000 -> [1_000_000, 0] assert update_traffic_density(2, [0, 1_000_000], 2, [\\"entry 1 1_000_000\\", \\"departure 2 1_000_000\\"]) == [1_000_000, 0]","solution":"def update_traffic_density(n, initial_states, m, events): Updates the effective traffic density at intersections based on the given events. Parameters: - n: int, number of intersections - initial_states: list of int, initial number of vehicles at each intersection - m: int, number of events - events: list of strings, describing the events Returns: - list of int, final number of vehicles at each intersection # Copy initial states to avoid mutating the original list traffic = initial_states[:] for event in events: parts = event.split() action = parts[0] index = int(parts[1]) - 1 # Convert 1-based index to 0-based index x = int(parts[2]) if action == \\"entry\\": traffic[index] += x elif action == \\"departure\\": traffic[index] -= x return traffic"},{"question":"def flatten_list(nested_list): Flattens a nested list of integers into a single list of integers. Args: nested_list (list): A nested list of integers Returns: list: A single flat list of integers Example: >>> flatten_list([[1, 2, [3, 4]], [5, 6], 7, [8, [9, 10, [11, 12]]]]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] >>> >>> flatten_list([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] def test_flatten_list_simple_case(): assert flatten_list([[1, 2, [3, 4]], [5, 6], 7, [8, [9, 10, [11, 12]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] def test_flatten_list_single_level(): assert flatten_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_flatten_list_empty(): assert flatten_list([]) == [] def test_flatten_list_no_nested_list(): assert flatten_list([1, 2, 3, 4]) == [1, 2, 3, 4] def test_flatten_list_deeply_nested(): assert flatten_list([[[[[1]], 2], 3], 4, [5]]) == [1, 2, 3, 4, 5] def test_flatten_list_only_integers(): assert flatten_list([[1, [2]], 3, [[4, 5, 6], [7, 8, [9, 10]]], 11, [12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] def test_flatten_list_large_nesting(): input_data = [[[[[[[[[[[1]]]]]]]]]]] expected_output = [1] assert flatten_list(input_data) == expected_output","solution":"def flatten_list(nested_list): Flattens a nested list of integers into a single list of integers. Args: nested_list (list): A nested list of integers Returns: list: A single flat list of integers flat_list = [] def flatten(nl): for elem in nl: if isinstance(elem, list): flatten(elem) else: flat_list.append(elem) flatten(nested_list) return flat_list"},{"question":"def longest_increasing_subsequence(timestamps: List[str]) -> int: Find the length of the longest consecutive subsequence of strictly increasing timestamps. >>> longest_increasing_subsequence([\\"12:05:30\\", \\"12:05:31\\", \\"12:05:32\\", \\"12:05:30\\", \\"12:05:33\\"]) 4 >>> longest_increasing_subsequence([\\"23:59:59\\", \\"00:00:00\\", \\"12:00:00\\", \\"12:01:00\\"]) 3 >>> longest_increasing_subsequence([\\"12:00:00\\"]) 1 >>> longest_increasing_subsequence([\\"12:00:00\\", \\"12:00:00\\", \\"12:00:00\\"]) 1 >>> longest_increasing_subsequence([\\"12:00:03\\", \\"12:00:02\\", \\"12:00:01\\", \\"12:00:00\\"]) 1 >>> longest_increasing_subsequence([\\"12:01:00\\", \\"12:00:00\\", \\"12:00:59\\", \\"12:02:00\\", \\"12:01:30\\"]) 3 >>> longest_increasing_subsequence([\\"00:00:01\\", \\"00:00:03\\", \\"00:00:02\\", \\"00:00:04\\"]) 3","solution":"def longest_increasing_subsequence(timestamps): import datetime # Convert timestamp strings to datetime objects for easy comparison timestamps = [datetime.datetime.strptime(t, \\"%H:%M:%S\\") for t in timestamps] # Initialize the list for dynamic programming dp = [1] * len(timestamps) # Compute the length of the longest increasing subsequence for i in range(1, len(timestamps)): for j in range(i): if timestamps[i] > timestamps[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp) # Example usage: # n = 5 # timestamps = [\\"12:05:30\\", \\"12:05:31\\", \\"12:05:32\\", \\"12:05:30\\", \\"12:05:33\\"] # print(longest_increasing_subsequence(timestamps)) # Output: 4"},{"question":"def find_valid_sequence(N: int, S: int): Generates a valid sequence of commands for the machine. Parameters: N (int): Number of commands S (int): Required sum of the commands Returns: list: A sequence of N non-negative integers if possible, otherwise \\"Impossible\\" >>> find_valid_sequence(5, 10) [1, 1, 1, 1, 6] >>> find_valid_sequence(3, 6) [1, 1, 4] >>> find_valid_sequence(4, 8) [1, 1, 1, 5] >>> find_valid_sequence(10, 5) 'Impossible' >>> find_valid_sequence(1, 1) [1] >>> find_valid_sequence(1000, 5000) [1, 1, 1, ..., 4997]","solution":"from math import gcd from functools import reduce def find_valid_sequence(N, S): Generates a valid sequence of commands for the machine. Parameters: N (int): Number of commands S (int): Required sum of the commands Returns: list: A sequence of N non-negative integers if possible, otherwise \\"Impossible\\" if S < N: return \\"Impossible\\" # Generate a sequence of ones and adjust the last element to match the required sum sequence = [1] * N sequence[-1] = S - (N - 1) # Check if the sequence has a GCD of 1 if reduce(gcd, sequence) == 1: return sequence else: return \\"Impossible\\""},{"question":"def lexicographical_min_strings(queries): Given a list of queries where each query is a string, return the smallest lexicographical string obtainable by Alice's operations. :param queries: List of string queries :return: List of lexicographically smallest strings from each query >>> lexicographical_min_strings([\\"dcba\\", \\"banana\\", \\"abcdefg\\"]) ['abcd', 'aaabnn', 'abcdefg'] >>> lexicographical_min_strings([]) [] >>> lexicographical_min_strings([\\"a\\", \\"z\\", \\"m\\"]) ['a', 'z', 'm'] >>> lexicographical_min_strings([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"]) ['aaaa', 'bbbb', 'cccc'] >>> lexicographical_min_strings([\\"bac\\", \\"cab\\", \\"dbca\\"]) ['abc', 'abc', 'abcd']","solution":"def lexicographical_min_strings(queries): Given a list of queries where each query is a string, return the smallest lexicographical string obtainable by Alice's operations. results = [] for s in queries: # The lexicographically smallest string can be obtained by sorting the characters sorted_string = ''.join(sorted(s)) results.append(sorted_string) return results"},{"question":"def max_subarray_sum(n: int, array: List[int]) -> int: Finds the maximum sum of any subarray within the array. Args: n (int): The number of elements in the array. array (list): A list of integers representing the array. Returns: int: The maximum sum of any subarray. Examples: >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum(7, [2, -1, 2, 3, -4, 2, -1]) == 6 >>> max_subarray_sum(1, [5]) == 5 >>> max_subarray_sum(1, [-5]) == -5","solution":"def max_subarray_sum(n, array): Finds the maximum sum of any subarray within the array. Args: n (int): The number of elements in the array. array (list): A list of integers representing the array. Returns: int: The maximum sum of any subarray. max_ending_here = max_so_far = array[0] for x in array[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Example usage: # n = 9 # array = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # print(max_subarray_sum(n, array))"},{"question":"from typing import List def is_word_present(grid: List[List[str]], N: int, M: int, word: str) -> bool: Determine whether the specified word can be found in the grid. >>> is_word_present([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 3, 4, \\"ABCCED\\") True >>> is_word_present([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 3, 4, \\"SEE\\") True >>> is_word_present([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 3, 4, \\"ABCB\\") False >>> is_word_present([ ['A'] ], 1, 1, \\"A\\") True >>> is_word_present([ ['A'] ], 1, 1, \\"B\\") False >>> is_word_present([ ['A', 'B'], ['C', 'D'] ], 2, 2, \\"ABCD\\") False >>> is_word_present([ ['A', 'B'], ['C', 'D'] ], 2, 2, \\"ABDC\\") True","solution":"def is_word_present(grid, N, M, word): def dfs(x, y, word, idx): if idx == len(word): return True if x < 0 or x >= N or y < 0 or y >= M or grid[x][y] != word[idx]: return False temp = grid[x][y] grid[x][y] = '#' # Mark as visited found = (dfs(x + 1, y, word, idx + 1) or dfs(x - 1, y, word, idx + 1) or dfs(x, y + 1, word, idx + 1) or dfs(x, y - 1, word, idx + 1)) grid[x][y] = temp # Unmark visited return found for i in range(N): for j in range(M): if dfs(i, j, word, 0): return True return False # Solution Code in Python"},{"question":"import math from typing import List def smallest_divisor(n: int) -> int: Returns the smallest divisor of n greater than 1. >>> smallest_divisor(10) 2 >>> smallest_divisor(17) 17 pass def process_test_cases(test_cases: List[int]) -> List[int]: Processes a list of test cases and returns a list of results. >>> process_test_cases([10, 17, 21, 49]) [2, 17, 3, 7] >>> process_test_cases([15, 19, 25]) [3, 19, 5] pass # Test cases def test_single_case(): assert smallest_divisor(10) == 2 assert smallest_divisor(17) == 17 assert smallest_divisor(21) == 3 assert smallest_divisor(49) == 7 def test_large_prime(): assert smallest_divisor(1000000007) == 1000000007 # Large prime number def test_even_number(): assert smallest_divisor(1000000000000) == 2 # Large even number def test_process_test_cases(): assert process_test_cases([10, 17, 21, 49]) == [2, 17, 3, 7] assert process_test_cases([15, 19, 25]) == [3, 19, 5] def test_mixed_cases(): test_cases = [2, 3, 4, 5, 6, 7, 8, 9, 10] expected_results = [2, 3, 2, 5, 2, 7, 2, 3, 2] assert process_test_cases(test_cases) == expected_results","solution":"import math def smallest_divisor(n): Returns the smallest divisor of n greater than 1. if n % 2 == 0: return 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return i return n def process_test_cases(test_cases): Processes a list of test cases and returns a list of results. results = [] for n in test_cases: results.append(smallest_divisor(n)) return results"},{"question":"from typing import List def average_temperature(n: int, m: int, readings: List[List[int]]) -> List[float]: Determine the average temperature for each time interval from multiple sensors. Args: n : int : Number of sensors m : int : Number of time intervals readings : List[List[int]] : Temperature readings with possible missing values (represented by -1000) Returns: List[float] : Average temperature for each time interval, rounded to two decimal places. >>> average_temperature(3, 4, [[23, 25, -1000, 28], [22, 24, 26, 27], [24, 23, 27, -1000]]) [23.00, 24.00, 26.50, 27.50] >>> average_temperature(2, 2, [[10, 20], [30, 40]]) [20.00, 30.00] >>> average_temperature(2, 2, [[0, 0], [0, 0]]) [0.00, 0.00] >>> average_temperature(3, 3, [[-1000, -1000, -1000], [-1000, -1000, -1000], [-1000, -1000, -1000]]) [0.00, 0.00, 0.00] >>> average_temperature(3, 3, [[1, -1000, 3], [-1000, 2, -1000], [1, 2, 3]]) [1.00, 2.00, 3.00]","solution":"def average_temperature(n, m, readings): result = [] for i in range(m): total_temp = 0 count = 0 for j in range(n): if readings[j][i] != -1000: total_temp += readings[j][i] count += 1 if count == 0: result.append(0.00) else: result.append(round(total_temp / count, 2)) return result"},{"question":"def count_face_up_tiles(N: int) -> int: Returns the number of tiles that will be face up after N persons have taken their turn. A tile will remain face up if its position is a perfect square. >>> count_face_up_tiles(3) == 1 >>> count_face_up_tiles(6) == 2 >>> count_face_up_tiles(1) == 1 >>> count_face_up_tiles(10) == 3 pass def fair_game(T: int, test_cases: List[int]) -> List[int]: Returns the number of tiles that will be face up for each test case. T denotes the number of test cases and test_cases contain the list of integers N. >>> fair_game(2, [3, 6]) == [1, 2] >>> fair_game(1, [1]) == [1] >>> fair_game(3, [1, 4, 10]) == [1, 2, 3] pass","solution":"def count_face_up_tiles(N): Returns the number of tiles that will be face up after N persons have taken their turn. # The tiles that remain face up are those whose positions are perfect squares. # This is because perfect squares have an odd number of divisors. return int(N ** 0.5) def fair_game(T, test_cases): Returns the number of tiles that will be face up for each test case. results = [] for N in test_cases: results.append(count_face_up_tiles(N)) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_nodes(root): Returns the sum of all the values of the nodes in the binary tree. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(7) >>> root.right = TreeNode(15) >>> sum_of_nodes(root) 39 >>> sum_of_nodes(None) 0 >>> single_node = TreeNode(10) >>> sum_of_nodes(single_node) 10 >>> root = TreeNode(-10) >>> root.left = TreeNode(-5) >>> root.left.left = TreeNode(-2) >>> root.left.right = TreeNode(-7) >>> root.right = TreeNode(-15) >>> sum_of_nodes(root) -39 >>> root = TreeNode(10) >>> root.left = TreeNode(-5) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(-7) >>> root.right = TreeNode(15) >>> sum_of_nodes(root) 15","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_nodes(root): Returns the sum of all the values of the nodes in the binary tree. if root is None: return 0 left_sum = sum_of_nodes(root.left) right_sum = sum_of_nodes(root.right) return root.value + left_sum + right_sum"},{"question":"from typing import List def min_moves(n: int, m: int, grid: List[str]) -> int: Determines whether it's possible to reach the bottom-right corner of the grid from the top-left corner avoiding boulders, and calculates the minimum number of moves required. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): Representation of the grid where '.' denotes an empty cell, and '#' denotes a cell with a boulder. Returns: int: Minimum number of moves to reach the bottom-right corner, or -1 if no path exists. Examples: >>> min_moves(5, 5, [ ... '.....', ... '.#.', ... '.....', ... '.#.', ... '.....' ... ]) 8 >>> min_moves(3, 3, [ ... '#.#', ... '.#.', ... '#.#' ... ]) -1 >>> min_moves(2, 2, [ ... '..', ... '..' ... ]) 2","solution":"from collections import deque def min_moves(n, m, grid): Returns the minimum number of moves required to reach the bottom-right corner of the grid from the top-left corner avoiding boulders, or -1 if no path exists. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def min_fatigue(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> int: Calculate the minimum possible value of the highest resistance level that John must endure to travel from island 1 to island n. >>> min_fatigue(4, 5, [(1, 2, 7), (1, 3, 3), (2, 3, 2), (2, 4, 9), (3, 4, 8)]) 8 >>> min_fatigue(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 5)]) 2 >>> min_fatigue(2, 1, [(1, 2, 1)]) 1 >>> min_fatigue(5, 7, [(1, 2, 10), (1, 3, 5), (2, 3, 100), (2, 4, 10), (3, 4, 15), (4, 5, 5), (3, 5, 20)]) 10","solution":"from collections import deque def can_reach_with_max_resistance(graph, n, max_resistance): visited = [False] * (n + 1) queue = deque([1]) visited[1] = True while queue: current = queue.popleft() if current == n: return True for neighbor, resistance in graph[current]: if not visited[neighbor] and resistance <= max_resistance: visited[neighbor] = True queue.append(neighbor) return False def min_fatigue(n, m, bridges): graph = [[] for _ in range(n + 1)] for a, b, r in bridges: graph[a].append((b, r)) graph[b].append((a, r)) low, high = 1, max(r for _, _, r in bridges) result = high while low <= high: mid = (low + high) // 2 if can_reach_with_max_resistance(graph, n, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def sum_of_tiles(n, m, grid): Computes the sum of all tiles in the grid. :param int n: Number of rows in the grid :param int m: Number of columns in the grid :param list[list[int]] grid: 2D list representing the grid of tiles :return: The sum of all tiles :rtype: int >>> sum_of_tiles(2, 3, [[1, 2, 3], [4, 5, 6]]) 21 >>> sum_of_tiles(1, 4, [[5, 5, 5, 5]]) 20 from solution import sum_of_tiles def test_sum_of_tiles(): assert sum_of_tiles(2, 3, [[1, 2, 3], [4, 5, 6]]) == 21 assert sum_of_tiles(1, 4, [[5, 5, 5, 5]]) == 20 assert sum_of_tiles(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9 assert sum_of_tiles(2, 2, [[10, 20], [30, 40]]) == 100 assert sum_of_tiles(1, 1, [[42]]) == 42","solution":"def sum_of_tiles(n, m, grid): Returns the sum of all tiles in the grid. :param int n: Number of rows in the grid :param int m: Number of columns in the grid :param list[list[int]] grid: 2D list representing the grid of tiles :return: The sum of all tiles :rtype: int total_sum = 0 for row in grid: total_sum += sum(row) return total_sum"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if str1 and str2 are anagrams of each other. >>> are_anagrams(\\"cinema\\", \\"iceman\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False >>> are_anagrams(\\"triangle\\", \\"integral\\") True","solution":"def are_anagrams(str1, str2): Determines if str1 and str2 are anagrams of each other. return sorted(str1) == sorted(str2)"},{"question":"def is_balanced(phrase: str) -> str: This function checks if a given phrase is balanced. Args: phrase (str): The input string consisting of '(' and ')' characters. Returns: str: \\"Yes\\" if the phrase is balanced, otherwise \\"No\\". Examples: >>> is_balanced('(())') 'Yes' >>> is_balanced('((())') 'No' >>> is_balanced('()()') 'Yes' >>> is_balanced(')(') 'No'","solution":"def is_balanced(phrase): This function checks if a given phrase is balanced. Args: phrase (str): The input string consisting of '(' and ')' characters. Returns: str: \\"Yes\\" if the phrase is balanced, otherwise \\"No\\". stack = [] for char in phrase: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"No\\" stack.pop() return \\"Yes\\" if not stack else \\"No\\""},{"question":"def modify_array(test_cases: List[Dict[str, Any]]) -> List[List[int]]: This function takes a list of test cases and returns the modified arrays for each test case. Each element in the array is replaced by the sum of all other elements in the array. Args: test_cases : list A list where each element is a dictionary containing the following keys: - 'N' : int : The number of elements in the array. - 'array' : list : A list of integers representing the elements of the array. Returns: list A list of modified arrays for each test case. Example: >>> test_cases = [ ... {'N': 3, 'array': [1, 2, 3]}, ... {'N': 4, 'array': [2, 3, 4, 5]} ... ] >>> modify_array(test_cases) [[5, 4, 3], [12, 11, 10, 9]]","solution":"def modify_array(test_cases): This function takes a list of test cases and returns the modified arrays for each test case. Each element in the array is replaced by the sum of all other elements in the array. Args: test_cases : list A list where each element is a dictionary containing the following keys: - 'N' : int : The number of elements in the array. - 'array' : list : A list of integers representing the elements of the array. Returns: list A list of modified arrays for each test case. results = [] for case in test_cases: N = case['N'] array = case['array'] total_sum = sum(array) modified_array = [total_sum - x for x in array] results.append(modified_array) return results"},{"question":"from typing import List def min_insertions_to_make_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string s a palindrome. >>> min_insertions_to_make_palindrome(\\"race\\") 3 >>> min_insertions_to_make_palindrome(\\"google\\") 2 def process_test_cases(test_cases: List[str]) -> List[int]: Given a list of strings, returns a list of minimum number of insertions required for each string to become a palindrome. >>> process_test_cases([\\"race\\", \\"google\\"]) [3, 2] >>> process_test_cases([\\"a\\", \\"ab\\", \\"abc\\"]) [0, 1, 2]","solution":"def min_insertions_to_make_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string s a palindrome. n = len(s) dp = [[0]*n for _ in range(n)] for gap in range(1, n): for i in range(n - gap): j = i + gap if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1 return dp[0][n - 1] def process_test_cases(test_cases): results = [] for s in test_cases: results.append(min_insertions_to_make_palindrome(s)) return results # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:] results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def optimal_palace_location(towns): Calculates the optimal coordinates for the palace such that the maximum distance to any town is minimized. Args: towns (list): A list of tuples containing the coordinates of the towns. Returns: tuple: The optimal (x, y) coordinates for the palace. >>> optimal_palace_location([(1, 1)]) (1.000000, 1.000000) >>> optimal_palace_location([(1, 1), (2, 2), (3, 3)]) (2.000000, 2.000000) >>> optimal_palace_location([(0, 0), (0, 4), (4, 0), (4, 4)]) (2.000000, 2.000000) >>> optimal_palace_location([(1, 2), (3, 4), (5, 6), (7, 8)]) (4.000000, 5.000000) >>> optimal_palace_location([(-1, -1), (-2, -2), (-3, -3)]) (-2.000000, -2.000000)","solution":"def optimal_palace_location(towns): Calculates the optimal coordinates for the palace such that the maximum distance to any town is minimized. Args: towns (list): A list of tuples containing the coordinates of the towns. Returns: tuple: The optimal (x, y) coordinates for the palace. n = len(towns) if n == 1: return towns[0] sum_x = sum(t[0] for t in towns) sum_y = sum(t[1] for t in towns) return (sum_x / n, sum_y / n)"},{"question":"from typing import List from collections import Counter def can_be_beautiful(s: str) -> str: Determines if a string can be rearranged such that there are no consecutive identical characters. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a beautiful string, otherwise \\"NO\\". >>> can_be_beautiful(\\"aabb\\") 'YES' >>> can_be_beautiful(\\"aaab\\") 'NO' Test Cases: def test_example_1(): assert can_be_beautiful(\\"aabb\\") == \\"YES\\" def test_example_2(): assert can_be_beautiful(\\"aaab\\") == \\"NO\\" def test_single_character(): assert can_be_beautiful(\\"a\\") == \\"YES\\" def test_all_unique_characters(): assert can_be_beautiful(\\"abcdef\\") == \\"YES\\" def test_large_input_no(): assert can_be_beautiful(\\"aaaaabb\\") == \\"NO\\" def test_large_input_yes(): assert can_be_beautiful(\\"aaaabbc\\") == \\"YES\\" def test_two_characters_yes(): assert can_be_beautiful(\\"ab\\") == \\"YES\\" def test_two_characters_no(): assert can_be_beautiful(\\"aa\\") == \\"NO\\"","solution":"from collections import Counter def can_be_beautiful(s): Determines if a string can be rearranged such that there are no consecutive identical characters. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a beautiful string, otherwise \\"NO\\". char_counts = Counter(s) max_count = max(char_counts.values()) if max_count <= (len(s) + 1) // 2: return \\"YES\\" else: return \\"NO\\""},{"question":"def highest_grade_student(n, students): Returns the name of the student with the highest grade. If there are multiple students with the same highest grade, returns the lexicographically smallest name. :param n: Number of students (int) :param students: List of tuples (name, grade) :return: Name of the student with the highest grade (str) pass # Example test cases def test_highest_grade_student_single(): assert highest_grade_student(1, [(\\"alice\\", 90)]) == \\"alice\\" def test_highest_grade_student_multiple(): assert highest_grade_student(5, [(\\"alice\\", 90), (\\"bob\\", 85), (\\"charlie\\", 90), (\\"david\\", 88), (\\"eve\\", 90)]) == \\"alice\\" def test_highest_grade_student_with_tie(): assert highest_grade_student(3, [(\\"amy\\", 75), (\\"becca\\", 75), (\\"don\\", 80)]) == \\"don\\" def test_highest_grade_student_brief(): assert highest_grade_student(2, [(\\"bob\\", 100), (\\"alice\\", 100)]) == \\"alice\\" def test_highest_grade_student_varied(): assert highest_grade_student(4, [(\\"amy\\", 50), (\\"bob\\", 80), (\\"charlie\\", 90), (\\"david\\", 90)]) == \\"charlie\\"","solution":"def highest_grade_student(n, students): Returns the name of the student with the highest grade. If there are multiple students with the same highest grade, returns the lexicographically smallest name. :param n: Number of students (int) :param students: List of tuples (name, grade) :return: Name of the student with the highest grade (str) max_grade = -1 best_student = \\"\\" for student in students: name, grade = student if grade > max_grade: max_grade = grade best_student = name elif grade == max_grade and name < best_student: best_student = name return best_student"},{"question":"def perform_sort_operations(n: int, m: int, array: List[int], operations: List[Tuple[int, int]]) -> List[int]: Perform m sorting operations on segments of the array according to the given operations. Parameters: n (int): The number of recruits (length of the array). m (int): The number of sorting operations. array (List[int]): The initial midichlorian counts of the recruits. operations (List[Tuple[int, int]]): List of operations where each operation is a tuple (l, r) representing the subarray to be sorted. Returns: List[int]: The midichlorian counts of the recruits after performing all the sorting operations. Example: >>> perform_sort_operations(5, 2, [10, 5, 3, 6, 2], [(1, 3), (2, 5)]) [3, 2, 5, 6, 10]","solution":"def perform_sort_operations(n, m, array, operations): for operation in operations: l, r = operation # Convert 1-based index to 0-based index array[l-1:r] = sorted(array[l-1:r]) return array"},{"question":"def max_non_overlapping_subsegments(T: int, energy_levels: List[int]) -> int: Find the maximum number of non-overlapping sub-segments whose total energy is exactly T. Parameters: T (int): Target energy value. energy_levels (List[int]): List of energy levels of the stones. Returns: int: Maximum number of non-overlapping sub-segments whose sum is T. >>> max_non_overlapping_subsegments(8, [1, 2, 3, 4, 5, 3, 5]) 1 >>> max_non_overlapping_subsegments(7, [1, 2, 3, 4, 5]) 1 >>> max_non_overlapping_subsegments(3, [1, 1, 1, 1, 1, 1, 1, 1]) 2 pass def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Processes multiple test cases and finds the maximum number of non-overlapping sub-segments whose sum is T for each case. Parameters: test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains (n, T, energy_levels). Returns: List[int]: A list of results for each test case. >>> process_test_cases([(6, 8, [1, 2, 3, 4, 5, 3, 5]), (5, 7, [1, 2, 3, 4, 5]), (8, 3, [1, 1, 1, 1, 1, 1, 1, 1])]) [1, 1, 2] pass","solution":"def max_non_overlapping_subsegments(T, energy_levels): Finds the maximum number of non-overlapping sub-segments whose sum is T. Parameters: T (int): Target energy value. energy_levels (list of int): List of energy levels of the stones. Returns: int: Maximum number of non-overlapping sub-segments whose sum is T. current_sum = 0 sum_count = {0: -1} max_count = 0 last_index = -1 for i, num in enumerate(energy_levels): current_sum += num if current_sum - T in sum_count: if sum_count[current_sum - T] >= last_index: max_count += 1 last_index = i sum_count[current_sum] = i return max_count def process_test_cases(test_cases): results = [] for n, T, energy_levels in test_cases: results.append(max_non_overlapping_subsegments(T, energy_levels)) return results"},{"question":"def minDistance(str1: str, str2: str) -> int: Returns the minimum number of operations required to convert str1 to str2. >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"kitten\\", \\"sitting\\") 3 >>> minDistance(\\"flaw\\", \\"lawn\\") 2 >>> minDistance(\\"abcdef\\", \\"azced\\") 3 >>> minDistance(\\"distance\\", \\"editing\\") 5 >>> minDistance(\\"a\\", \\"a\\") 0 >>> minDistance(\\"a\\", \\"b\\") 1","solution":"def minDistance(str1, str2): Returns the minimum number of operations required to convert str1 to str2. m, n = len(str1), len(str2) # Create a dp matrix dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp matrix for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the dp matrix for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) return dp[m][n]"},{"question":"def rearrange_array(arr): Rearrange the given array so that odd numbers appear in ascending order at the beginning followed by the even numbers in ascending order. Parameters: arr (list): List of integers Returns: list: Rearranged list with odd numbers first in ascending order and even numbers later in ascending order. Examples: >>> rearrange_array([12, 3, 5, 8, 7, 17, 6]) [3, 5, 7, 17, 6, 8, 12] >>> rearrange_array([9, 3, 1, 5, 7]) [1, 3, 5, 7, 9] >>> rearrange_array([12, 4, 8, 6, 2]) [2, 4, 6, 8, 12] >>> rearrange_array([]) [] >>> rearrange_array([5]) [5] >>> rearrange_array([6]) [6]","solution":"def rearrange_array(arr): Rearrange the given array so that odd numbers appear in ascending order at the beginning followed by the even numbers in ascending order. Parameters: arr (list): List of integers Returns: list: Rearranged list with odd numbers first in ascending order and even numbers later in ascending order. odd_numbers = sorted([x for x in arr if x % 2 != 0]) even_numbers = sorted([x for x in arr if x % 2 == 0]) return odd_numbers + even_numbers"},{"question":"def count_subarrays_with_product_less_than_k(arr, n, k): Returns the number of contiguous subarrays with product less than k. >>> count_subarrays_with_product_less_than_k([1, 2, 3, 4], 4, 10) 7 >>> count_subarrays_with_product_less_than_k([5], 1, 10) 1 >>> count_subarrays_with_product_less_than_k([11, 12, 13, 14], 4, 10) 0 >>> count_subarrays_with_product_less_than_k([4, 4, 4, 4], 4, 5) 4 >>> count_subarrays_with_product_less_than_k([1, 2, 3, 4], 4, 100000) 10 pass def solve_test_cases(T, test_cases): Solves multiple test cases based on the format provided. >>> solve_test_cases(1, [((4, 10), [1, 2, 3, 4])]) [7] >>> solve_test_cases(1, [((1, 10), [5])]) [1] >>> solve_test_cases(1, [((4, 10), [11, 12, 13, 14])]) [0] >>> solve_test_cases(1, [((4, 5), [4, 4, 4, 4])]) [4] >>> solve_test_cases(1, [((4, 100000), [1, 2, 3, 4])]) [10] >>> solve_test_cases(2, [((4, 10), [1, 2, 3, 4]), ((3, 5), [1, 2, 3])]) [7, 4] pass","solution":"def count_subarrays_with_product_less_than_k(arr, n, k): Returns the number of contiguous subarrays with product less than k. count = 0 product = 1 left = 0 for right in range(n): product *= arr[right] while product >= k and left <= right: product //= arr[left] left += 1 count += (right - left + 1) return count def solve_test_cases(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] arr = test_cases[i][1] result = count_subarrays_with_product_less_than_k(arr, N, K) results.append(result) return results"},{"question":"def most_frequent_lake(trip_data): Analyzes trip data to find the lake with the highest number of trips and the respective number of trips. If multiple lakes have the highest number of trips, returns the lexicographically first one. Parameters: trip_data (list of lists): Each element is a list containing the trip information for one query. Returns: list of tuples: Each tuple contains the name of the lake and the number of trips.","solution":"def most_frequent_lake(trip_data): Analyzes trip data to find the lake with the highest number of trips and the respective number of trips. If multiple lakes have the highest number of trips, returns the lexicographically first one. Parameters: trip_data (list of lists): Each element is a list containing the trip information for one query. Returns: list of tuples: Each tuple contains the name of the lake and the number of trips. results = [] for trips in trip_data: lake_count = {} for lake in trips: if lake in lake_count: lake_count[lake] += 1 else: lake_count[lake] = 1 max_trips = 0 frequent_lake = \\"\\" for lake, count in lake_count.items(): if count > max_trips or (count == max_trips and lake < frequent_lake): max_trips = count frequent_lake = lake results.append((frequent_lake, max_trips)) return results"},{"question":"def canSortProducts(productList): Determines if it is possible to place all products in the slots in ascending order. :param productList: List of product IDs. :return: \\"YES\\" if products can be sorted in ascending order, \\"NO\\" otherwise. def test_example1(): assert canSortProducts([4, 2, 1, 3]) == \\"YES\\" def test_example2(): assert canSortProducts([3, 1, 4, 1]) == \\"NO\\" def test_no_duplicate(): assert canSortProducts([2, 3, 4, 1]) == \\"YES\\" def test_with_duplicates(): assert canSortProducts([5, 5, 1, 2]) == \\"NO\\" def test_sorted_list(): assert canSortProducts([1, 2, 3, 4, 5]) == \\"YES\\" def test_reverse_sorted_list(): assert canSortProducts([5, 4, 3, 2, 1]) == \\"YES\\" def test_single_element(): assert canSortProducts([1]) == \\"YES\\" def test_missing_elements(): assert canSortProducts([1, 2, 4, 5]) == \\"NO\\"","solution":"def canSortProducts(productList): Determines if it is possible to place all products in the slots in ascending order. :param productList: List of product IDs. :return: \\"YES\\" if products can be sorted in ascending order, \\"NO\\" otherwise. if len(set(productList)) != len(productList): return \\"NO\\" return \\"YES\\" if sorted(productList) == list(range(1, len(productList) + 1)) else \\"NO\\""},{"question":"def single_number(nums): Find the element in the list that appears exactly once when all other elements appear exactly three times. Args: nums (list): List of integers where every integer appears exactly three times, except for one integer which appears exactly once. Returns: int: The integer that appears only once. pass # Unit Tests def test_example_1(): assert single_number([2, 2, 3, 2]) == 3 def test_example_2(): assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 def test_single_element(): assert single_number([4]) == 4 def test_large_numbers(): assert single_number([1001, 1001, 1001, 5000]) == 5000 def test_negative_numbers(): assert single_number([-3, -3, -3, -7]) == -7 def test_mixed_numbers(): assert single_number([-1, -1, 2, -1, 2, 2, 6]) == 6","solution":"def single_number(nums): Find the element in the list that appears exactly once when all other elements appear exactly three times. Args: nums (list): List of integers where every integer appears exactly three times, except for one integer which appears exactly once. Returns: int: The integer that appears only once. # Initialize variables to hold the bits ones, twos = 0, 0 for num in nums: # 'ones' holds the bitwise xor of all the elements which have appeared only once. ones = (ones ^ num) & ~twos # 'twos' holds the bitwise xor of all the elements which have appeared exactly twice. twos = (twos ^ num) & ~ones return ones"},{"question":"def find_gift_cards(n: int, P: int, gift_cards: List[int]) -> List[int]: Determine a combination of exactly three gift cards such that their total value equals P. If such a combination exists, it returns the values of the three gift cards in ascending order. If it is not possible, it returns [-1]. >>> find_gift_cards(5, 100, [10, 20, 30, 70, 50]) [10, 20, 70] >>> find_gift_cards(4, 85, [10, 25, 35, 45]) [-1]","solution":"def find_gift_cards(n, P, gift_cards): This function determines a combination of exactly three gift cards such that their total value equals P. If such a combination exists, it returns the values of the three gift cards in ascending order. If it is not possible, it returns [-1]. gift_cards.sort() for i in range(n - 2): l, r = i + 1, n - 1 while l < r: current_sum = gift_cards[i] + gift_cards[l] + gift_cards[r] if current_sum == P: return [gift_cards[i], gift_cards[l], gift_cards[r]] elif current_sum < P: l += 1 else: r -= 1 return [-1]"},{"question":"def has_cycle(n, m, edges): Determine whether a cycle exists in the road network. A cycle is a sequence of roads (v1, v2), (v2, v3), ..., (vk-1, vk), (vk, v1) where all vi are distinct and k >= 3. Parameters: n (int): Number of villages. m (int): Number of bidirectional roads. edges (List[Tuple[int, int]]): List of tuples where each tuple represents a bidirectional road between villages u and v. Returns: str: \\"YES\\" if there exists a cycle in the network, \\"NO\\" otherwise. >>> has_cycle(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) 'YES' >>> has_cycle(3, 2, [(1, 2), (2, 3)]) 'NO' >>> has_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> has_cycle(1, 0, []) 'NO' >>> has_cycle(6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (6, 4)]) 'YES'","solution":"def has_cycle(n, m, edges): from collections import defaultdict def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def shortest_path(grid: List[List[int]], start: List[int], target: List[int]) -> int: Finds the shortest path in a grid avoiding obstacles. Parameters: grid (list of list of int): The grid representation. start (list of int): Starting position [row, col]. target (list of int): Target position [row, col]. Returns: int: The length of the shortest path or -1 if no path exists. Examples: >>> grid = [ ... [0, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [0, 0, 0, 0, 1], ... [1, 1, 1, 0, 0], ... [0, 0, 1, 0, 0] ... ] >>> start = [0, 0] >>> target = [4, 4] >>> shortest_path(grid, start, target) 8 >>> start = [0, 0] >>> target = [2, 2] >>> shortest_path(grid, start, target) 4 # Your code here def test_shortest_path(): grid = [ [0, 0, 1, 0, 0], [1, 0, 1, 1, 1], [0, 0, 0, 0, 1], [1, 1, 1, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_path(grid, [0, 0], [4, 4]) == 8 assert shortest_path(grid, [0, 0], [2, 2]) == 4 assert shortest_path(grid, [0, 0], [3, 1]) == -1 def test_shortest_path_same_start_and_target(): grid = [ [0, 0], [0, 1] ] assert shortest_path(grid, [0, 0], [0, 0]) == 0 def test_shortest_path_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert shortest_path(grid, [0, 0], [2, 2]) == 4 assert shortest_path(grid, [0, 0], [1, 1]) == 2 def test_shortest_path_blocked(): grid = [ [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 1], [1, 1, 1, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_path(grid, [0, 0], [4, 4]) == -1","solution":"from collections import deque def shortest_path(grid, start, target): Finds the shortest path in a grid avoiding obstacles. Parameters: grid (list of list of int): The grid representation. start (list of int): Starting position [row, col]. target (list of int): Target position [row, col]. Returns: int: The length of the shortest path or -1 if no path exists. rows = len(grid) cols = len(grid[0]) if start == target: return 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, distance = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: if [nx, ny] == target: return distance + 1 queue.append((nx, ny, distance + 1)) visited.add((nx, ny)) return -1"},{"question":"def organize_books(n: int, genres: List[List[int]]) -> List: Sophie wants to ensure that the books in each genre are evenly distributed across their respective rows. This function calculates the shelf width for each genre, or indicates the number of full rows and the number of leftover books. Args: n : int : Number of genres genres : List[List[int]] : List of widths of books in each genre Returns: List : List of integers (or tuples) indicating the minimum total width of the shelf or the full rows and leftovers. Examples: >>> organize_books(3, [[2, 3, 1, 4, 5], [6, 1, 2], [8]]) [15, 9, 8] >>> organize_books(2, [[], [6, 1]]) [(0, 0), 7] pass from solution import organize_books def test_single_genre_single_book(): assert organize_books(1, [[4]]) == [4] def test_single_genre_multiple_books(): assert organize_books(1, [[2, 3, 1, 4, 5]]) == [15] def test_multiple_genres_varying_books(): assert organize_books(3, [[2, 3, 1, 4, 5], [6, 1, 2], [8]]) == [15, 9, 8] def test_empty_genres(): assert organize_books(2, [[], [6, 1]]) == [(0, 0), 7] def test_all_books_same_width(): assert organize_books(2, [[2, 2, 2, 2], [3, 3, 3]]) == [8, 9]","solution":"def organize_books(n, genres): results = [] for genre in genres: total_books = len(genre) rows = total_books sum_width = sum(genre) min_total_width = sum_width leftover = 0 if total_books == 0: results.append((0, 0)) else: results.append(min_total_width) return results # Example n = 3 genres = [[2, 3, 1, 4, 5], [6, 1, 2], [8]] print(organize_books(n, genres))"},{"question":"def num_large_islands(t: int, test_cases: List[Tuple[int, int, int, List[List[int]]]]) -> List[int]: Count the number of large islands in a grid. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, int, List[List[int]]]]): List of test cases, each with the dimensions of the grid, minimum number of land cells a large island should contain, and the grid itself. Returns: List[int]: The count of large islands for each test case. >>> num_large_islands(2, [ (4, 5, 3, [ [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 1], [0, 1, 0, 0, 0] ]), (3, 3, 2, [ [1, 1, 0], [0, 1, 1], [1, 0, 0] ]) ]) [2, 1] from typing import List, Tuple # Test Cases def test_example_case1(): t = 2 test_cases = [ (4, 5, 3, [ [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 1], [0, 1, 0, 0, 0] ]), (3, 3, 2, [ [1, 1, 0], [0, 1, 1], [1, 0, 0] ]) ] expected_output = [2, 1] assert num_large_islands(t, test_cases) == expected_output def test_all_land(): t = 1 test_cases = [ (3, 3, 4, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) ] expected_output = [1] assert num_large_islands(t, test_cases) == expected_output def test_no_land(): t = 1 test_cases = [ (3, 3, 2, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) ] expected_output = [0] assert num_large_islands(t, test_cases) == expected_output def test_mixed_small_large_islands(): t = 1 test_cases = [ (4, 5, 5, [ [1, 1, 1, 0, 0], [1, 1, 1, 0, 0], [0, 1, 0, 1, 1], [0, 0, 0, 1, 1] ]) ] expected_output = [1] assert num_large_islands(t, test_cases) == expected_output def test_islands_touching_borders(): t = 1 test_cases = [ (4, 4, 3, [ [1, 1, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 1, 1, 1] ]) ] expected_output = [2] assert num_large_islands(t, test_cases) == expected_output","solution":"def num_large_islands(t, test_cases): def dfs(grid, visited, i, j): stack = [(i, j)] cell_count = 0 while stack: x, y = stack.pop() if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and not visited[x][y] and grid[x][y] == 1: visited[x][y] = True cell_count += 1 stack.extend([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]) return cell_count results = [] for case in test_cases: n, m, k, grid = case visited = [[False] * m for _ in range(n)] large_island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: island_size = dfs(grid, visited, i, j) if island_size >= k: large_island_count += 1 results.append(large_island_count) return results # Example usage # t = 2 # test_cases = [ # (4, 5, 3, [ # [1, 1, 0, 1, 0], # [1, 1, 0, 0, 0], # [0, 0, 1, 1, 1], # [0, 1, 0, 0, 0] # ]), # (3, 3, 2, [ # [1, 1, 0], # [0, 1, 1], # [1, 0, 0] # ]) # ] # print(num_large_islands(t, test_cases)) # Output: [2, 1]"},{"question":"def divide_chocolate(m: int, n: int, k: int, chocolate: List[List[int]]) -> int: You are given a rectangular chocolate bar consisting of m  n square pieces. Some of the pieces have nuts in them while others do not. You are tasked with dividing the chocolate into exactly k smaller rectangular pieces by making k-1 straight cuts (either horizontal or vertical). Your goal is to maximize the minimum number of nut pieces in any of the resulting k pieces of chocolate after making the k-1 cuts. Parameters: m (int): The number of rows in the chocolate bar. n (int): The number of columns in the chocolate bar. k (int): The number of rectangular pieces the chocolate bar should be divided into. chocolate (List[List[int]]): A 2D list representing the chocolate bar where 1 represents a piece with a nut, and 0 represents a piece without a nut. Returns: int: The maximum possible value of the minimum number of nut pieces in any of the resulting k pieces after making the k-1 cuts. Examples: >>> divide_chocolate(3, 3, 4, [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 0 >>> divide_chocolate(4, 4, 2, [ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1] ... ]) == 4","solution":"def divide_chocolate(m, n, k, chocolate): def possible(min_nuts): # DP array with dimensions (m+1)x(n+1) for fewer boundary checks dp = [[0] * (n + 1) for _ in range(m + 1)] # Count total nuts from (0,0) to (i,j) for i in range(m): for j in range(n): dp[i+1][j+1] = chocolate[i][j] + dp[i+1][j] + dp[i][j+1] - dp[i][j] def get_nuts(x1, y1, x2, y2): # Calculate number of nuts in rectangle (x1,y1) to (x2,y2) return dp[x2+1][y2+1] - dp[x2+1][y1] - dp[x1][y2+1] + dp[x1][y1] # Try to make k pieces using horizontal and vertical cuts def dfs(x, y, pieces): if pieces == 1: return get_nuts(x, y, m-1, n-1) >= min_nuts for i in range(x, m): if get_nuts(x, y, i, n-1) >= min_nuts: if dfs(i + 1, y, pieces - 1): return True for j in range(y, n): if get_nuts(x, y, m-1, j) >= min_nuts: if dfs(x, j + 1, pieces - 1): return True return False return dfs(0, 0, k) nuts = sum(sum(row) for row in chocolate) lo, hi = 0, nuts // k while lo < hi: mid = (lo + hi + 1) // 2 if possible(mid): lo = mid else: hi = mid - 1 return lo # Example usage: # m = 3, n = 3, k = 4, chocolate = [ # [1, 0, 0], # [0, 1, 0], # [0, 0, 1] # ] # Output should be 0. # Example usage: # m = 4, n = 4, k = 2, chocolate = [ # [1, 0, 1, 0], # [0, 1, 0, 1], # [1, 0, 1, 0], # [0, 1, 0, 1] # ] # Output should be 4."},{"question":"def min_steps_to_reach_end(M: int, N: int, grid: List[str]) -> int: Determine the minimum steps required to reach from the top-left corner (0,0) to the bottom-right corner (M-1, N-1) in a grid. Parameters: M (int): Number of rows N (int): Number of columns grid (list of str): M lines each containing N characters ('.' for clear block, '#' for obstacle) Returns: int: Minimum steps to reach (M-1, N-1) or -1 if impossible. >>> grid = [ ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... \\".#.\\", ... \\".....\\" ... ] >>> min_steps_to_reach_end(5, 5, grid) 8 >>> grid = [ ... \\"..#\\", ... \\".#.\\", ... \\".#.\\" ... ] >>> min_steps_to_reach_end(3, 3, grid) -1 >>> grid = [ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ] >>> min_steps_to_reach_end(4, 4, grid) 6 >>> grid = [ ... \\"..\\", ... \\"\\" ... ] >>> min_steps_to_reach_end(2, 2, grid) -1 >>> grid = [ ... \\"#.\\", ... \\"..\\" ... ] >>> min_steps_to_reach_end(2, 2, grid) -1 >>> grid = [ ... \\"..\\", ... \\".#\\" ... ] >>> min_steps_to_reach_end(2, 2, grid) -1 # Your code here","solution":"from collections import deque def min_steps_to_reach_end(M, N, grid): Determine the minimum steps required to reach from the top-left corner (0,0) to the bottom-right corner (M-1,N-1) in a grid. Parameters: M (int): Number of rows N (int): Number of columns grid (list of str): M lines each containing N characters ('.' for clear block, '#' for obstacle) Returns: int: Minimum steps to reach (M-1,N-1) or -1 if impossible. if grid[0][0] == '#' or grid[M-1][N-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * N for _ in range(M)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny, nsteps = x + dx, y + dy, steps + 1 if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny] and grid[nx][ny] == '.': if nx == M-1 and ny == N-1: return nsteps queue.append((nx, ny, nsteps)) visited[nx][ny] = True return -1"},{"question":"def max_cakes_to_bake(datasets): Determine the maximum number of cakes that can be baked in a day for multiple datasets. Args: datasets (list): List of datasets where each dataset is a list with the format: [N, [CakeName1, StartTime1, EndTime1], [CakeName2, StartTime2, EndTime2], ..., [CakeNameN, StartTimeN, EndTimeN]] Returns: list: List of integers representing the maximum number of cakes that can be baked for each dataset. pass import pytest def test_example_case(): datasets = [ [3, [\\"Chocolate\\", \\"0900\\", \\"1100\\"], [\\"Vanilla\\", \\"1030\\", \\"1230\\"], [\\"Strawberry\\", \\"1200\\", \\"1400\\"]], [2, [\\"Lemon\\", \\"0800\\", \\"1000\\"], [\\"Blueberry\\", \\"0900\\", \\"1100\\"]], [0] ] assert max_cakes_to_bake(datasets) == [2, 1] def test_no_overlap(): datasets = [ [4, [\\"Cake1\\", \\"0600\\", \\"0700\\"], [\\"Cake2\\", \\"0700\\", \\"0800\\"], [\\"Cake3\\", \\"0800\\", \\"0900\\"], [\\"Cake4\\", \\"0900\\", \\"1000\\"]], [0] ] assert max_cakes_to_bake(datasets) == [4] def test_full_overlap(): datasets = [ [3, [\\"Cake1\\", \\"0600\\", \\"0900\\"], [\\"Cake2\\", \\"0600\\", \\"0900\\"], [\\"Cake3\\", \\"0600\\", \\"0900\\"]], [0] ] assert max_cakes_to_bake(datasets) == [1] def test_partial_overlap(): datasets = [ [4, [\\"Cake1\\", \\"0600\\", \\"1000\\"], [\\"Cake2\\", \\"0900\\", \\"1100\\"], [\\"Cake3\\", \\"1000\\", \\"1300\\"], [\\"Cake4\\", \\"1200\\", \\"1400\\"]], [0] ] assert max_cakes_to_bake(datasets) == [2] def test_single_cake(): datasets = [ [1, [\\"Cake1\\", \\"0600\\", \\"1000\\"]], [0] ] assert max_cakes_to_bake(datasets) == [1] def test_edge_times(): datasets = [ [3, [\\"Cake1\\", \\"0000\\", \\"0600\\"], [\\"Cake2\\", \\"0600\\", \\"1200\\"], [\\"Cake3\\", \\"1200\\", \\"1800\\"]], [0] ] assert max_cakes_to_bake(datasets) == [3]","solution":"def max_cakes_to_bake(datasets): Determine the maximum number of cakes that can be baked in a day for multiple datasets. Args: datasets (list): List of datasets where each dataset is a list with the format: [N, [CakeName1, StartTime1, EndTime1], [CakeName2, StartTime2, EndTime2], ..., [CakeNameN, StartTimeN, EndTimeN]] Returns: list: List of integers representing the maximum number of cakes that can be baked for each dataset. def max_activities(activities): activities.sort(key=lambda x: x[2]) # sort by EndTime count = 0 last_end_time = 0 for activity in activities: if activity[1] >= last_end_time: count += 1 last_end_time = activity[2] return count results = [] for dataset in datasets: N = dataset[0] if N == 0: continue activities = [] for i in range(1, N + 1): cake = dataset[i] start_time = int(cake[1]) end_time = int(cake[2]) activities.append((cake[0], start_time, end_time)) results.append(max_activities(activities)) return results"},{"question":"def print_diamond(n): Prints a diamond pattern of '*' symbols with the width determined by n. The value of n must be an odd positive integer greater than 2. Args: n (int): Width of the diamond at its widest point. Raises: ValueError: If n is not an odd positive integer greater than 2. Example: >>> print_diamond(3) * *** * >>> print_diamond(5) * *** ***** *** * >>> print_diamond(7) * *** ***** ******* ***** *** *","solution":"def print_diamond(n): Prints a diamond pattern of '*' symbols with the width determined by n. n must be an odd positive integer greater than 2. if n <= 2 or n % 2 == 0: raise ValueError(\\"The value of n must be an odd positive integer greater than 2.\\") # Generate the top half of the diamond including the center line for i in range(n // 2 + 1): print(' ' * (n // 2 - i) + '*' * (2 * i + 1)) # Generate the bottom half of the diamond for i in range(n // 2 - 1, -1, -1): print(' ' * (n // 2 - i) + '*' * (2 * i + 1))"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},P={class:"card-container"},C={key:0,class:"empty-state"},D=["disabled"],F={key:0},I={key:1};function z(i,e,u,m,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")},"  ")):l("",!0)]),t("div",P,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",C,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",I,"Loading...")):(s(),n("span",F,"See more"))],8,D)):l("",!0)])}const O=_(E,[["render",z],["__scopeId","data-v-ef959856"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/64.md","filePath":"guide/64.md"}'),Y={name:"guide/64.md"},G=Object.assign(Y,{setup(i){return(e,u)=>(s(),n("div",null,[w(O)]))}});export{B as __pageData,G as default};
